{"sha": "3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiOTYwYzcwM2VjMWZiYmQyYzBiOWY4MjFkYzk1N2E1NmFhNWQwMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-13T17:32:06Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-13T17:32:06Z"}, "message": "tree-scalar-evolution.c (resolve_mixers): Exported.\n\n\t* tree-scalar-evolution.c (resolve_mixers): Exported.\n\t* tree-scalar-evolution.h (resolve_mixers): Declare.\n\t* tree-data-ref.c (object_analysis, ptr_decl_may_alias_p,\n\tptr_ptr_may_alias_p, may_alias_p, record_ptr_differ_p,\n\trecord_record_differ_p, record_array_differ_p, array_ptr_differ_p,\n\tbase_object_differ_p, base_addr_differ_p, analyze_array_indexes,\n\tinit_array_ref, init_pointer_ref, analyze_indirect_ref,\n\tstrip_conversion, analyze_offset_expr, address_analysis,\n\tobject_analysis, analyze_offset): Removed.\n\t(dr_analyze_innermost, dr_analyze_indices, dr_analyze_alias,\n\tsplit_constant_offset, canonicalize_base_object_address,\n\tobject_address_invariant_in_loop_p, disjoint_objects_p,\n\tdr_may_alias_p, dr_address_invariant_p): New functions.\n\t(create_data_ref): Use dr_analyze_innermost, dr_analyze_indices\n\tand dr_analyze_alias.\n\t(initialize_data_dependence_relation): Use dr_may_alias_p\n\tand object_address_invariant_in_loop_p.\n\t(compute_self_dependence): Handle the case when DDR_ARE_DEPENDENT (ddr)\n\tis chrec_dont_know.\n\t(find_data_references_in_stmt): Restrict the analysis of data references\n\tto the given loop nest.\n\t(find_data_references_in_loop): Made static.  Pass loop nest to\n\tfind_data_references_in_stmt.\n\t(compute_data_dependences_for_loop): Use DR_VOPS.\n\t(free_data_ref): Free DR_VOPS.\n\t* tree-data-ref.h (struct first_location_in_loop): Replaced by ...\n\t(struct innermost_loop_behavior): ... new.\n\t(struct base_object_info): Replaced by ...\n\t(struct indices): ... new.\n\t(struct dr_alias): New.\n\t(enum data_ref_type): Removed.\n\t(struct data_reference): Consist of struct innermost_loop_behavior,\n\tstruct indices and struct dr_alias.\n\t(DR_SET_ACCESS_FNS, DR_FREE_ACCESS_FNS): Removed.\n\t(DR_MEMTAG): Renamed to ...\n\t(DR_SYMBOL_TAG): ... this.\n\t(find_data_references_in_loop): Declaration removed.\n\t* tree-vect-analyze.c (vect_compute_data_ref_alignment): Use DR_INIT\n\tinstead of DR_OFFSET_MISALIGNMENT.  DR_ALIGNED_TO is never NULL.\n\t(vect_analyze_data_refs): Use DR_SYMBOL_TAG instead of DR_MEMTAG.\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Ditto.\n\n\t* gcc.dg/vect/no-section-anchors-vect-69.c: Fix outcome.\n\t* gcc.dg/tree-ssa/loop-30.c: New test.\n\nFrom-SVN: r124655", "tree": {"sha": "d3a44fcfca4c6958e58886fcdc3c433a567cf1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3a44fcfca4c6958e58886fcdc3c433a567cf1a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/comments", "author": null, "committer": null, "parents": [{"sha": "de5e4138e587135467706f2c6d3d450aca8c2389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5e4138e587135467706f2c6d3d450aca8c2389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5e4138e587135467706f2c6d3d450aca8c2389"}], "stats": {"total": 2217, "additions": 575, "deletions": 1642}, "files": [{"sha": "e3380b50b8ce8250b8e3e4b662f7cc06b73b0000", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -1,3 +1,47 @@\n+2007-05-13  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-scalar-evolution.c (resolve_mixers): Exported.\n+\t* tree-scalar-evolution.h (resolve_mixers): Declare.\n+\t* tree-data-ref.c (object_analysis, ptr_decl_may_alias_p,\n+\tptr_ptr_may_alias_p, may_alias_p, record_ptr_differ_p,\n+\trecord_record_differ_p, record_array_differ_p, array_ptr_differ_p,\n+\tbase_object_differ_p, base_addr_differ_p, analyze_array_indexes,\n+\tinit_array_ref, init_pointer_ref, analyze_indirect_ref,\n+\tstrip_conversion, analyze_offset_expr, address_analysis,\n+\tobject_analysis, analyze_offset): Removed.\n+\t(dr_analyze_innermost, dr_analyze_indices, dr_analyze_alias,\n+\tsplit_constant_offset, canonicalize_base_object_address,\n+\tobject_address_invariant_in_loop_p, disjoint_objects_p,\n+\tdr_may_alias_p, dr_address_invariant_p): New functions.\n+\t(create_data_ref): Use dr_analyze_innermost, dr_analyze_indices\n+\tand dr_analyze_alias.\n+\t(initialize_data_dependence_relation): Use dr_may_alias_p\n+\tand object_address_invariant_in_loop_p.\n+\t(compute_self_dependence): Handle the case when DDR_ARE_DEPENDENT (ddr)\n+\tis chrec_dont_know.\n+\t(find_data_references_in_stmt): Restrict the analysis of data references\n+\tto the given loop nest.\n+\t(find_data_references_in_loop): Made static.  Pass loop nest to\n+\tfind_data_references_in_stmt.\n+\t(compute_data_dependences_for_loop): Use DR_VOPS.\n+\t(free_data_ref): Free DR_VOPS.\n+\t* tree-data-ref.h (struct first_location_in_loop): Replaced by ...\n+\t(struct innermost_loop_behavior): ... new.\n+\t(struct base_object_info): Replaced by ...\n+\t(struct indices): ... new.\n+\t(struct dr_alias): New.\n+\t(enum data_ref_type): Removed.\n+\t(struct data_reference): Consist of struct innermost_loop_behavior,\n+\tstruct indices and struct dr_alias.\n+\t(DR_SET_ACCESS_FNS, DR_FREE_ACCESS_FNS): Removed.\n+\t(DR_MEMTAG): Renamed to ...\n+\t(DR_SYMBOL_TAG): ... this.\n+\t(find_data_references_in_loop): Declaration removed.\n+\t* tree-vect-analyze.c (vect_compute_data_ref_alignment): Use DR_INIT\n+\tinstead of DR_OFFSET_MISALIGNMENT.  DR_ALIGNED_TO is never NULL.\n+\t(vect_analyze_data_refs): Use DR_SYMBOL_TAG instead of DR_MEMTAG.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Ditto.\n+\n 2007-05-13  Revital Eres  <eres@il.ibm.com>\n \n \t* tree-ssa-dse.c (get_use_of_stmt_lhs): New function"}, {"sha": "7cb625a784df6f66fc117f23930283ebb80cb2bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -1,3 +1,8 @@\n+2007-05-13  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/vect/no-section-anchors-vect-69.c: Fix outcome.\n+\t* gcc.dg/tree-ssa/loop-30.c: New test.\n+\n 2007-05-13  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/pr17141-1.c: Scan in forwprop2, xfail"}, {"sha": "14d58e59874b2b379b2c604b38fd68dadb2a9da5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-30.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-30.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -0,0 +1,14 @@\n+/* PR 25371 */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+void\n+slow_close(int n)\n+{\n+  int i;\n+  double *mm;\n+  for (i=0;i<2*n;i++)\n+    for (i=0;i<2*n;i++)\n+      *(mm+i*2*n+i) = 0;\n+}"}, {"sha": "08ea7de124f77c44909a37c7cdd7b0e8fef63521", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -50,7 +50,7 @@ int main1 ()\n         abort ();\n     }\n \n-  /* 2. aligned on 8-bytes */\n+  /* 2. aligned */\n   for (i = 3; i < N-1; i++)\n     {\n       tmp1[2].a.n[1][2][i] = 6;\n@@ -63,7 +63,7 @@ int main1 ()\n         abort ();\n     }\n \n-  /* 3. aligned on 16-bytes */\n+  /* 3. aligned */\n   for (i = 0; i < N; i++)\n     {\n       for (j = 0; j < N; j++)\n@@ -113,8 +113,5 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* Loops 1,2,4 are unaligned on targets that require 16-byte alignment.\n-   Loops 1,4 are unaligned on targets that require 8-byte alignment (ia64). */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail ia64-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1a814316ebe78f91881c192887b83a2c940080c0", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 438, "deletions": 1526, "changes": 1964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -122,463 +122,9 @@ static struct datadep_stats\n   int num_miv_unimplemented;\n } dependence_stats;\n \n-static tree object_analysis (tree, tree, bool, struct data_reference **, \n-\t\t\t     tree *, tree *, tree *, tree *, tree *,\n-\t\t\t     struct ptr_info_def **, subvar_t *);\n static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n \t\t\t\t\t   struct data_reference *,\n \t\t\t\t\t   struct data_reference *);\n-\n-/* Determine if PTR and DECL may alias, the result is put in ALIASED.\n-   Return FALSE if there is no symbol memory tag for PTR.  */\n-\n-static bool\n-ptr_decl_may_alias_p (tree ptr, tree decl, \n-\t\t      struct data_reference *ptr_dr, \n-\t\t      bool *aliased)\n-{\n-  tree tag = NULL_TREE;\n-  struct ptr_info_def *pi = DR_PTR_INFO (ptr_dr);  \n-\n-  gcc_assert (TREE_CODE (ptr) == SSA_NAME && DECL_P (decl));\n-\n-  if (pi)\n-    tag = pi->name_mem_tag;\n-  if (!tag)\n-    tag = symbol_mem_tag (SSA_NAME_VAR (ptr));\n-  if (!tag)\n-    tag = DR_MEMTAG (ptr_dr);\n-  if (!tag)\n-    return false;\n-   \n-  *aliased = is_aliased_with (tag, decl);      \n-  return true;\n-}\n-\n-\n-/* Determine if two pointers may alias, the result is put in ALIASED.\n-   Return FALSE if there is no symbol memory tag for one of the pointers.  */\n-\n-static bool\n-ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b, \n-\t\t     struct data_reference *dra, \n-\t\t     struct data_reference *drb, \n-\t\t     bool *aliased)\n-{  \n-  tree tag_a = NULL_TREE, tag_b = NULL_TREE;\n-  struct ptr_info_def *pi_a = DR_PTR_INFO (dra);  \n-  struct ptr_info_def *pi_b = DR_PTR_INFO (drb);  \n-  bitmap bal1, bal2;\n-\n-  if (pi_a && pi_a->name_mem_tag && pi_b && pi_b->name_mem_tag)\n-    {\n-      tag_a = pi_a->name_mem_tag;\n-      tag_b = pi_b->name_mem_tag;\n-    }\n-  else\n-    {\n-      tag_a = symbol_mem_tag (SSA_NAME_VAR (ptr_a));\n-      if (!tag_a)\n-\ttag_a = DR_MEMTAG (dra);\n-      if (!tag_a)\n-\treturn false;\n-      \n-      tag_b = symbol_mem_tag (SSA_NAME_VAR (ptr_b));\n-      if (!tag_b)\n-\ttag_b = DR_MEMTAG (drb);\n-      if (!tag_b)\n-\treturn false;\n-    }\n-  bal1 = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (bal1, DECL_UID (tag_a));\n-  if (MTAG_P (tag_a) && MTAG_ALIASES (tag_a))\n-    bitmap_ior_into (bal1, MTAG_ALIASES (tag_a));\n-\n-  bal2 = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (bal2, DECL_UID (tag_b));\n-  if (MTAG_P (tag_b) && MTAG_ALIASES (tag_b))\n-    bitmap_ior_into (bal2, MTAG_ALIASES (tag_b));\n-  *aliased = bitmap_intersect_p (bal1, bal2);\n-\n-  BITMAP_FREE (bal1);\n-  BITMAP_FREE (bal2);\n-  return true;\n-}\n-\n-\n-/* Determine if BASE_A and BASE_B may alias, the result is put in ALIASED.\n-   Return FALSE if there is no symbol memory tag for one of the symbols.  */\n-\n-static bool\n-may_alias_p (tree base_a, tree base_b,\n-\t     struct data_reference *dra,\n-\t     struct data_reference *drb,\n-\t     bool *aliased)\n-{\n-  if (TREE_CODE (base_a) == ADDR_EXPR || TREE_CODE (base_b) == ADDR_EXPR)\n-    {\n-      if (TREE_CODE (base_a) == ADDR_EXPR && TREE_CODE (base_b) == ADDR_EXPR)\n-\t{\n-\t *aliased = (TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0));\n-\t return true;\n-\t}\n-      if (TREE_CODE (base_a) == ADDR_EXPR)\n-\treturn ptr_decl_may_alias_p (base_b, TREE_OPERAND (base_a, 0), drb, \n-\t\t\t\t     aliased);\n-      else\n-\treturn ptr_decl_may_alias_p (base_a, TREE_OPERAND (base_b, 0), dra, \n-\t\t\t\t     aliased);\n-    }\n-\n-  return ptr_ptr_may_alias_p (base_a, base_b, dra, drb, aliased);\n-}\n-\n-\n-/* Determine if a pointer (BASE_A) and a record/union access (BASE_B)\n-   are not aliased. Return TRUE if they differ.  */\n-static bool\n-record_ptr_differ_p (struct data_reference *dra,\n-\t\t     struct data_reference *drb)\n-{\n-  bool aliased;\n-  tree base_a = DR_BASE_OBJECT (dra);\n-  tree base_b = DR_BASE_OBJECT (drb);\n-\n-  if (TREE_CODE (base_b) != COMPONENT_REF)\n-    return false;\n-\n-  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n-     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n-     Probably will be unnecessary with struct alias analysis.  */\n-  while (TREE_CODE (base_b) == COMPONENT_REF)\n-     base_b = TREE_OPERAND (base_b, 0);\n-  /* Compare a record/union access (b.c[i] or p->c[i]) and a pointer\n-     ((*q)[i]).  */\n-  if (TREE_CODE (base_a) == INDIRECT_REF\n-      && ((TREE_CODE (base_b) == VAR_DECL\n-\t   && (ptr_decl_may_alias_p (TREE_OPERAND (base_a, 0), base_b, dra, \n-\t\t\t\t     &aliased)\n-\t       && !aliased))\n-\t  || (TREE_CODE (base_b) == INDIRECT_REF\n-\t      && (ptr_ptr_may_alias_p (TREE_OPERAND (base_a, 0), \n-\t\t\t\t       TREE_OPERAND (base_b, 0), dra, drb, \n-\t\t\t\t       &aliased)\n-\t\t  && !aliased))))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* Determine if two record/union accesses are aliased. Return TRUE if they \n-   differ.  */\n-static bool\n-record_record_differ_p (struct data_reference *dra,\n-\t\t\tstruct data_reference *drb)\n-{\n-  bool aliased;\n-  tree base_a = DR_BASE_OBJECT (dra);\n-  tree base_b = DR_BASE_OBJECT (drb);\n-\n-  if (TREE_CODE (base_b) != COMPONENT_REF \n-      || TREE_CODE (base_a) != COMPONENT_REF)\n-    return false;\n-\n-  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n-     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n-     Probably will be unnecessary with struct alias analysis.  */\n-  while (TREE_CODE (base_b) == COMPONENT_REF)\n-    base_b = TREE_OPERAND (base_b, 0);\n-  while (TREE_CODE (base_a) == COMPONENT_REF)\n-    base_a = TREE_OPERAND (base_a, 0);\n-\n-  if (TREE_CODE (base_a) == INDIRECT_REF\n-      && TREE_CODE (base_b) == INDIRECT_REF\n-      && ptr_ptr_may_alias_p (TREE_OPERAND (base_a, 0), \n-\t\t\t      TREE_OPERAND (base_b, 0), \n-\t\t\t      dra, drb, &aliased)\n-      && !aliased)\n-    return true;\n-  else\n-    return false;\n-}\n-    \n-/* Determine if an array access (BASE_A) and a record/union access (BASE_B)\n-   are not aliased. Return TRUE if they differ.  */\n-static bool\n-record_array_differ_p (struct data_reference *dra,\n-\t\t       struct data_reference *drb)\n-{  \n-  bool aliased;\n-  tree base_a = DR_BASE_OBJECT (dra);\n-  tree base_b = DR_BASE_OBJECT (drb);\n-\n-  if (TREE_CODE (base_b) != COMPONENT_REF)\n-    return false;\n-\n-  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n-     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n-     Probably will be unnecessary with struct alias analysis.  */\n-  while (TREE_CODE (base_b) == COMPONENT_REF)\n-     base_b = TREE_OPERAND (base_b, 0);\n-\n-  /* Compare a record/union access (b.c[i] or p->c[i]) and an array access \n-     (a[i]). In case of p->c[i] use alias analysis to verify that p is not\n-     pointing to a.  */\n-  if (TREE_CODE (base_a) == VAR_DECL\n-      && (TREE_CODE (base_b) == VAR_DECL\n-\t  || (TREE_CODE (base_b) == INDIRECT_REF\n-\t      && (ptr_decl_may_alias_p (TREE_OPERAND (base_b, 0), base_a, drb, \n-\t\t\t\t\t&aliased)\n-\t\t  && !aliased))))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-\n-/* Determine if an array access (BASE_A) and a pointer (BASE_B)\n-   are not aliased. Return TRUE if they differ.  */\n-static bool\n-array_ptr_differ_p (tree base_a, tree base_b, \t     \n-\t\t    struct data_reference *drb)\n-{  \n-  bool aliased;\n-\n-  /* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the\n-     help of alias analysis that p is not pointing to a.  */\n-  if (TREE_CODE (base_a) == VAR_DECL && TREE_CODE (base_b) == INDIRECT_REF \n-      && (ptr_decl_may_alias_p (TREE_OPERAND (base_b, 0), base_a, drb, &aliased)\n-\t  && !aliased))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-\n-/* This is the simplest data dependence test: determines whether the\n-   data references A and B access the same array/region.  Returns\n-   false when the property is not computable at compile time.\n-   Otherwise return true, and DIFFER_P will record the result. This\n-   utility will not be necessary when alias_sets_conflict_p will be\n-   less conservative.  */\n-\n-static bool\n-base_object_differ_p (struct data_reference *a,\n-\t\t      struct data_reference *b,\n-\t\t      bool *differ_p)\n-{\n-  tree base_a = DR_BASE_OBJECT (a);\n-  tree base_b = DR_BASE_OBJECT (b);\n-  bool aliased;\n-\n-  if (!base_a || !base_b)\n-    return false;\n-\n-  /* Determine if same base.  Example: for the array accesses\n-     a[i], b[i] or pointer accesses *a, *b, bases are a, b.  */\n-  if (base_a == base_b)\n-    {\n-      *differ_p = false;\n-      return true;\n-    }\n-\n-  /* For pointer based accesses, (*p)[i], (*q)[j], the bases are (*p)\n-     and (*q)  */\n-  if (TREE_CODE (base_a) == INDIRECT_REF && TREE_CODE (base_b) == INDIRECT_REF\n-      && TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0))\n-    {\n-      *differ_p = false;\n-      return true;\n-    }\n-\n-  /* Record/union based accesses - s.a[i], t.b[j]. bases are s.a,t.b.  */ \n-  if (TREE_CODE (base_a) == COMPONENT_REF && TREE_CODE (base_b) == COMPONENT_REF\n-      && TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0)\n-      && TREE_OPERAND (base_a, 1) == TREE_OPERAND (base_b, 1))\n-    {\n-      *differ_p = false;\n-      return true;\n-    }\n-\n-\n-  /* Determine if different bases.  */\n-\n-  /* At this point we know that base_a != base_b.  However, pointer\n-     accesses of the form x=(*p) and y=(*q), whose bases are p and q,\n-     may still be pointing to the same base. In SSAed GIMPLE p and q will\n-     be SSA_NAMES in this case.  Therefore, here we check if they are\n-     really two different declarations.  */\n-  if (TREE_CODE (base_a) == VAR_DECL && TREE_CODE (base_b) == VAR_DECL)\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the\n-     help of alias analysis that p is not pointing to a.  */\n-  if (array_ptr_differ_p (base_a, base_b, b) \n-      || array_ptr_differ_p (base_b, base_a, a))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* If the bases are pointers ((*q)[i] and (*p)[i]), we check with the\n-     help of alias analysis they don't point to the same bases.  */\n-  if (TREE_CODE (base_a) == INDIRECT_REF && TREE_CODE (base_b) == INDIRECT_REF \n-      && (may_alias_p (TREE_OPERAND (base_a, 0), TREE_OPERAND (base_b, 0), a, b, \n-\t\t       &aliased)\n-\t  && !aliased))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* Compare two record/union bases s.a and t.b: s != t or (a != b and\n-     s and t are not unions).  */\n-  if (TREE_CODE (base_a) == COMPONENT_REF && TREE_CODE (base_b) == COMPONENT_REF\n-      && ((TREE_CODE (TREE_OPERAND (base_a, 0)) == VAR_DECL\n-           && TREE_CODE (TREE_OPERAND (base_b, 0)) == VAR_DECL\n-           && TREE_OPERAND (base_a, 0) != TREE_OPERAND (base_b, 0))\n-          || (TREE_CODE (TREE_TYPE (TREE_OPERAND (base_a, 0))) == RECORD_TYPE \n-              && TREE_CODE (TREE_TYPE (TREE_OPERAND (base_b, 0))) == RECORD_TYPE\n-              && TREE_OPERAND (base_a, 1) != TREE_OPERAND (base_b, 1))))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* Compare a record/union access (b.c[i] or p->c[i]) and a pointer\n-     ((*q)[i]).  */\n-  if (record_ptr_differ_p (a, b) || record_ptr_differ_p (b, a))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* Compare a record/union access (b.c[i] or p->c[i]) and an array access \n-     (a[i]). In case of p->c[i] use alias analysis to verify that p is not\n-     pointing to a.  */\n-  if (record_array_differ_p (a, b) || record_array_differ_p (b, a))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  /* Compare two record/union accesses (b.c[i] or p->c[i]).  */\n-  if (record_record_differ_p (a, b))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Function base_addr_differ_p.\n-\n-   This is the simplest data dependence test: determines whether the\n-   data references DRA and DRB access the same array/region.  Returns\n-   false when the property is not computable at compile time.\n-   Otherwise return true, and DIFFER_P will record the result.\n-\n-   The algorithm:   \n-   1. if (both DRA and DRB are represented as arrays)\n-          compare DRA.BASE_OBJECT and DRB.BASE_OBJECT\n-   2. else if (both DRA and DRB are represented as pointers)\n-          try to prove that DRA.FIRST_LOCATION == DRB.FIRST_LOCATION\n-   3. else if (DRA and DRB are represented differently or 2. fails)\n-          only try to prove that the bases are surely different\n-*/\n-\n-static bool\n-base_addr_differ_p (struct data_reference *dra,\n-\t\t    struct data_reference *drb,\n-\t\t    bool *differ_p)\n-{\n-  tree addr_a = DR_BASE_ADDRESS (dra);\n-  tree addr_b = DR_BASE_ADDRESS (drb);\n-  tree type_a, type_b;\n-  tree decl_a, decl_b;\n-  bool aliased;\n-\n-  if (!addr_a || !addr_b)\n-    return false;\n-\n-  type_a = TREE_TYPE (addr_a);\n-  type_b = TREE_TYPE (addr_b);\n-\n-  gcc_assert (POINTER_TYPE_P (type_a) &&  POINTER_TYPE_P (type_b));\n-\n-  /* 1. if (both DRA and DRB are represented as arrays)\n-            compare DRA.BASE_OBJECT and DRB.BASE_OBJECT.  */\n-  if (DR_TYPE (dra) == ARRAY_REF_TYPE && DR_TYPE (drb) == ARRAY_REF_TYPE)\n-    return base_object_differ_p (dra, drb, differ_p);\n-\n-  /* 2. else if (both DRA and DRB are represented as pointers)\n-\t    try to prove that DRA.FIRST_LOCATION == DRB.FIRST_LOCATION.  */\n-  /* If base addresses are the same, we check the offsets, since the access of \n-     the data-ref is described by {base addr + offset} and its access function,\n-     i.e., in order to decide whether the bases of data-refs are the same we \n-     compare both base addresses and offsets.  */\n-  if (DR_TYPE (dra) == POINTER_REF_TYPE && DR_TYPE (drb) == POINTER_REF_TYPE\n-      && (addr_a == addr_b \n-\t  || (TREE_CODE (addr_a) == ADDR_EXPR && TREE_CODE (addr_b) == ADDR_EXPR\n-\t      && TREE_OPERAND (addr_a, 0) == TREE_OPERAND (addr_b, 0))))\n-    {\n-      /* Compare offsets.  */\n-      tree offset_a = DR_OFFSET (dra); \n-      tree offset_b = DR_OFFSET (drb);\n-      \n-      STRIP_NOPS (offset_a);\n-      STRIP_NOPS (offset_b);\n-\n-      /* FORNOW: we only compare offsets that are MULT_EXPR, i.e., we don't handle\n-\t PLUS_EXPR.  */\n-      if (offset_a == offset_b\n-\t  || (TREE_CODE (offset_a) == MULT_EXPR \n-\t      && TREE_CODE (offset_b) == MULT_EXPR\n-\t      && TREE_OPERAND (offset_a, 0) == TREE_OPERAND (offset_b, 0)\n-\t      && TREE_OPERAND (offset_a, 1) == TREE_OPERAND (offset_b, 1)))\n-\t{\n-\t  *differ_p = false;\n-\t  return true;\n-\t}\n-    }\n-\n-  /*  3. else if (DRA and DRB are represented differently or 2. fails) \n-              only try to prove that the bases are surely different.  */\n-\n-  /* Apply alias analysis.  */\n-  if (may_alias_p (addr_a, addr_b, dra, drb, &aliased) && !aliased)\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-  \n-  /* An instruction writing through a restricted pointer is \"independent\" of any \n-     instruction reading or writing through a different restricted pointer, \n-     in the same block/scope.  */\n-  else if (TYPE_RESTRICT (type_a)\n-\t   &&  TYPE_RESTRICT (type_b) \n-\t   && (!DR_IS_READ (drb) || !DR_IS_READ (dra))\n-\t   && TREE_CODE (DR_BASE_ADDRESS (dra)) == SSA_NAME\n-\t   && (decl_a = SSA_NAME_VAR (DR_BASE_ADDRESS (dra)))\n-\t   && TREE_CODE (decl_a) == PARM_DECL\n-\t   && TREE_CODE (DECL_CONTEXT (decl_a)) == FUNCTION_DECL\n-\t   && TREE_CODE (DR_BASE_ADDRESS (drb)) == SSA_NAME\n-\t   && (decl_b = SSA_NAME_VAR (DR_BASE_ADDRESS (drb)))\n-\t   && TREE_CODE (decl_b) == PARM_DECL\n-\t   && TREE_CODE (DECL_CONTEXT (decl_b)) == FUNCTION_DECL\n-\t   && DECL_CONTEXT (decl_a) == DECL_CONTEXT (decl_b)) \n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Returns true iff A divides B.  */\n \n static inline bool \n@@ -940,1125 +486,334 @@ dump_ddrs (FILE *file, VEC (ddr_p, heap) *ddrs)\n   fprintf (file, \"\\n\\n\");\n }\n \n-\f\n-\n-/* Given an ARRAY_REF node REF, records its access functions.\n-   Example: given A[i][3], record in ACCESS_FNS the opnd1 function,\n-   i.e. the constant \"3\", then recursively call the function on opnd0,\n-   i.e. the ARRAY_REF \"A[i]\".  \n-   The function returns the base name: \"A\".  */\n-\n-static tree\n-analyze_array_indexes (struct loop *loop,\n-\t\t       VEC(tree,heap) **access_fns, \n-\t\t       tree ref, tree stmt)\n-{\n-  tree opnd0, opnd1;\n-  tree access_fn;\n-\n-  opnd0 = TREE_OPERAND (ref, 0);\n-  opnd1 = TREE_OPERAND (ref, 1);\n+/* Expresses EXP as VAR + OFF, where off is a constant.  The type of OFF\n+   will be ssizetype.  */\n \n-  /* The detection of the evolution function for this data access is\n-     postponed until the dependence test.  This lazy strategy avoids\n-     the computation of access functions that are of no interest for\n-     the optimizers.  */\n-  access_fn = instantiate_parameters\n-    (loop, analyze_scalar_evolution (loop, opnd1));\n-\n-  VEC_safe_push (tree, heap, *access_fns, access_fn);\n-  \n-  /* Recursively record other array access functions.  */\n-  if (TREE_CODE (opnd0) == ARRAY_REF)\n-    return analyze_array_indexes (loop, access_fns, opnd0, stmt);\n-\n-  /* Return the base name of the data access.  */\n-  else\n-    return opnd0;\n-}\n-\n-/* For a data reference REF contained in the statement STMT, initialize\n-   a DATA_REFERENCE structure, and return it.  IS_READ flag has to be\n-   set to true when REF is in the right hand side of an\n-   assignment.  */\n-\n-static struct data_reference *\n-init_array_ref (tree stmt, tree ref, bool is_read)\n-{\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  VEC(tree,heap) *acc_fns = VEC_alloc (tree, heap, 3);\n-  struct data_reference *res = XNEW (struct data_reference);;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"(init_array_ref \\n\");\n-      fprintf (dump_file, \"  (ref = \");\n-      print_generic_stmt (dump_file, ref, 0);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  DR_STMT (res) = stmt;\n-  DR_REF (res) = ref;\n-  DR_BASE_OBJECT (res) = analyze_array_indexes (loop, &acc_fns, ref, stmt);\n-  DR_TYPE (res) = ARRAY_REF_TYPE;\n-  DR_SET_ACCESS_FNS (res, acc_fns);\n-  DR_IS_READ (res) = is_read;\n-  DR_BASE_ADDRESS (res) = NULL_TREE;\n-  DR_OFFSET (res) = NULL_TREE;\n-  DR_INIT (res) = NULL_TREE;\n-  DR_STEP (res) = NULL_TREE;\n-  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n-  DR_MEMTAG (res) = NULL_TREE;\n-  DR_PTR_INFO (res) = NULL;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n-\n-  return res;\n-}\n-\n-/* For a data reference REF contained in the statement STMT, initialize\n-   a DATA_REFERENCE structure, and return it.  */\n-\n-static struct data_reference *\n-init_pointer_ref (tree stmt, tree ref, tree access_fn, bool is_read,\n-\t\t  tree base_address, tree step, struct ptr_info_def *ptr_info)\n-{\n-  struct data_reference *res = XNEW (struct data_reference);\n-  VEC(tree,heap) *acc_fns = VEC_alloc (tree, heap, 3);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"(init_pointer_ref \\n\");\n-      fprintf (dump_file, \"  (ref = \");\n-      print_generic_stmt (dump_file, ref, 0);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  DR_STMT (res) = stmt;\n-  DR_REF (res) = ref;\n-  DR_BASE_OBJECT (res) = NULL_TREE;\n-  DR_TYPE (res) = POINTER_REF_TYPE;\n-  DR_SET_ACCESS_FNS (res, acc_fns);\n-  VEC_quick_push (tree, DR_ACCESS_FNS (res), access_fn);\n-  DR_IS_READ (res) = is_read;\n-  DR_BASE_ADDRESS (res) = base_address;\n-  DR_OFFSET (res) = NULL_TREE;\n-  DR_INIT (res) = NULL_TREE;\n-  DR_STEP (res) = step;\n-  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n-  DR_MEMTAG (res) = NULL_TREE;\n-  DR_PTR_INFO (res) = ptr_info;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \")\\n\");\n-\n-  return res;\n-}\n-\n-/* Analyze an indirect memory reference, REF, that comes from STMT.\n-   IS_READ is true if this is an indirect load, and false if it is\n-   an indirect store.\n-   Return a new data reference structure representing the indirect_ref, or\n-   NULL if we cannot describe the access function.  */\n-\n-static struct data_reference *\n-analyze_indirect_ref (tree stmt, tree ref, bool is_read)\n-{\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  tree ptr_ref = TREE_OPERAND (ref, 0);\n-  tree access_fn = analyze_scalar_evolution (loop, ptr_ref);\n-  tree init = initial_condition_in_loop_num (access_fn, loop->num);\n-  tree base_address = NULL_TREE, evolution, step = NULL_TREE;\n-  struct ptr_info_def *ptr_info = NULL;\n-\n-  if (TREE_CODE (ptr_ref) == SSA_NAME)\n-    ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n-\n-  STRIP_NOPS (init);\n-  if (access_fn == chrec_dont_know || !init || init == chrec_dont_know)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"\\nBad access function of ptr: \");\n-\t  print_generic_expr (dump_file, ref, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      return NULL;\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nAccess function of ptr: \");\n-      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  if (!expr_invariant_in_loop_p (loop, init))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"\\ninitial condition is not loop invariant.\\n\");\t\n-    }\n-  else\n-    {\n-      base_address = init;\n-      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n-      if (evolution != chrec_dont_know)\n-\t{       \n-\t  if (!evolution)\n-\t    step = ssize_int (0);\n-\t  else  \n-\t    {\n-\t      if (TREE_CODE (evolution) == INTEGER_CST)\n-\t\tstep = fold_convert (ssizetype, evolution);\n-\t      else\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  fprintf (dump_file, \"\\nnon constant step for ptr access.\\n\");\t\n-\t    }\n-\t}\n-      else\n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  fprintf (dump_file, \"\\nunknown evolution of ptr.\\n\");\t\n-    }\n-  return init_pointer_ref (stmt, ref, access_fn, is_read, base_address, \n-\t\t\t   step, ptr_info);\n-}\n-\n-/* Function strip_conversions\n-\n-   Strip conversions that don't narrow the mode.  */\n-\n-static tree \n-strip_conversion (tree expr)\n-{\n-  tree to, ti, oprnd0;\n-  \n-  while (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n-    {\n-      to = TREE_TYPE (expr);\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      ti = TREE_TYPE (oprnd0);\n- \n-      if (!INTEGRAL_TYPE_P (to) || !INTEGRAL_TYPE_P (ti))\n-\treturn NULL_TREE;\n-      if (GET_MODE_SIZE (TYPE_MODE (to)) < GET_MODE_SIZE (TYPE_MODE (ti)))\n-\treturn NULL_TREE;\n-      \n-      expr = oprnd0;\n-    }\n-  return expr; \n-}\n-\f\n-\n-/* Function analyze_offset_expr\n-\n-   Given an offset expression EXPR received from get_inner_reference, analyze\n-   it and create an expression for INITIAL_OFFSET by substituting the variables \n-   of EXPR with initial_condition of the corresponding access_fn in the loop. \n-   E.g., \n-      for i\n-         for (j = 3; j < N; j++)\n-            a[j].b[i][j] = 0;\n-\t \n-   For a[j].b[i][j], EXPR will be 'i * C_i + j * C_j + C'. 'i' cannot be \n-   substituted, since its access_fn in the inner loop is i. 'j' will be \n-   substituted with 3. An INITIAL_OFFSET will be 'i * C_i + C`', where\n-   C` =  3 * C_j + C.\n-\n-   Compute MISALIGN (the misalignment of the data reference initial access from\n-   its base). Misalignment can be calculated only if all the variables can be \n-   substituted with constants, otherwise, we record maximum possible alignment\n-   in ALIGNED_TO. In the above example, since 'i' cannot be substituted, MISALIGN \n-   will be NULL_TREE, and the biggest divider of C_i (a power of 2) will be \n-   recorded in ALIGNED_TO.\n-\n-   STEP is an evolution of the data reference in this loop in bytes.\n-   In the above example, STEP is C_j.\n-\n-   Return FALSE, if the analysis fails, e.g., there is no access_fn for a \n-   variable. In this case, all the outputs (INITIAL_OFFSET, MISALIGN, ALIGNED_TO\n-   and STEP) are NULL_TREEs. Otherwise, return TRUE.\n-\n-*/\n-\n-static bool\n-analyze_offset_expr (tree expr, \n-\t\t     struct loop *loop, \n-\t\t     tree *initial_offset,\n-\t\t     tree *misalign,\n-\t\t     tree *aligned_to,\n-\t\t     tree *step)\n+static void\n+split_constant_offset (tree exp, tree *var, tree *off)\n {\n-  tree oprnd0;\n-  tree oprnd1;\n-  tree left_offset = ssize_int (0);\n-  tree right_offset = ssize_int (0);\n-  tree left_misalign = ssize_int (0);\n-  tree right_misalign = ssize_int (0);\n-  tree left_step = ssize_int (0);\n-  tree right_step = ssize_int (0);\n-  enum tree_code code;\n-  tree init, evolution;\n-  tree left_aligned_to = NULL_TREE, right_aligned_to = NULL_TREE;\n-\n-  *step = NULL_TREE;\n-  *misalign = NULL_TREE;\n-  *aligned_to = NULL_TREE;  \n-  *initial_offset = NULL_TREE;\n-\n-  /* Strip conversions that don't narrow the mode.  */\n-  expr = strip_conversion (expr);\n-  if (!expr)\n-    return false;\n-\n-  /* Stop conditions:\n-     1. Constant.  */\n-  if (TREE_CODE (expr) == INTEGER_CST)\n-    {\n-      *initial_offset = fold_convert (ssizetype, expr);\n-      *misalign = fold_convert (ssizetype, expr);      \n-      *step = ssize_int (0);\n-      return true;\n-    }\n-\n-  /* 2. Variable. Try to substitute with initial_condition of the corresponding\n-     access_fn in the current loop.  */\n-  if (SSA_VAR_P (expr))\n-    {\n-      tree access_fn = analyze_scalar_evolution (loop, expr);\n-\n-      if (access_fn == chrec_dont_know)\n-\t/* No access_fn.  */\n-\treturn false;\n+  tree type = TREE_TYPE (exp), otype;\n+  tree var0, var1;\n+  tree off0, off1;\n \n-      init = initial_condition_in_loop_num (access_fn, loop->num);\n-      if (!expr_invariant_in_loop_p (loop, init))\n-\t/* Not enough information: may be not loop invariant.  \n-\t   E.g., for a[b[i]], we get a[D], where D=b[i]. EXPR is D, its \n-\t   initial_condition is D, but it depends on i - loop's induction\n-\t   variable.  */\t  \n-\treturn false;\n-\n-      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n-      if (evolution && TREE_CODE (evolution) != INTEGER_CST)\n-\t/* Evolution is not constant.  */\n-\treturn false;\n-\n-      if (TREE_CODE (init) == INTEGER_CST)\n-\t*misalign = fold_convert (ssizetype, init);\n-      else\n-\t/* Not constant, misalignment cannot be calculated.  */\n-\t*misalign = NULL_TREE;\n-\n-      *initial_offset = fold_convert (ssizetype, init); \n-\n-      *step = evolution ? fold_convert (ssizetype, evolution) : ssize_int (0);\n-      return true;      \n-    }\n+  *var = exp;\n+  STRIP_NOPS (exp);\n+  otype = TREE_TYPE (exp);\n \n-  /* Recursive computation.  */\n-  if (!BINARY_CLASS_P (expr))\n+  switch (TREE_CODE (exp))\n     {\n-      /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-\t  fprintf (dump_file, \"\\nNot binary expression \");\n-          print_generic_expr (dump_file, expr, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      return false;\n-    }\n-  oprnd0 = TREE_OPERAND (expr, 0);\n-  oprnd1 = TREE_OPERAND (expr, 1);\n+    case INTEGER_CST:\n+      *var = build_int_cst (type, 0);\n+      *off = fold_convert (ssizetype, exp);\n+      return;\n \n-  if (!analyze_offset_expr (oprnd0, loop, &left_offset, &left_misalign, \n-\t\t\t    &left_aligned_to, &left_step)\n-      || !analyze_offset_expr (oprnd1, loop, &right_offset, &right_misalign, \n-\t\t\t       &right_aligned_to, &right_step))\n-    return false;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      split_constant_offset (TREE_OPERAND (exp, 0), &var0, &off0);\n+      split_constant_offset (TREE_OPERAND (exp, 1), &var1, &off1);\n+      *var = fold_convert (type, fold_build2 (TREE_CODE (exp), otype, \n+\t\t\t\t\t      var0, var1));\n+      *off = size_binop (TREE_CODE (exp), off0, off1);\n+      return;\n \n-  /* The type of the operation: plus, minus or mult.  */\n-  code = TREE_CODE (expr);\n-  switch (code)\n-    {\n     case MULT_EXPR:\n-      if (TREE_CODE (right_offset) != INTEGER_CST)\n-\t/* RIGHT_OFFSET can be not constant. For example, for arrays of variable \n-\t   sized types. \n-\t   FORNOW: We don't support such cases.  */\n-\treturn false;\n-\n-      /* Strip conversions that don't narrow the mode.  */\n-      left_offset = strip_conversion (left_offset);      \n-      if (!left_offset)\n-\treturn false;      \n-      /* Misalignment computation.  */\n-      if (SSA_VAR_P (left_offset))\n-\t{\n-\t  /* If the left side contains variables that can't be substituted with \n-\t     constants, the misalignment is unknown. However, if the right side \n-\t     is a multiple of some alignment, we know that the expression is\n-\t     aligned to it. Therefore, we record such maximum possible value.\n-\t   */\n-\t  *misalign = NULL_TREE;\n-\t  *aligned_to = ssize_int (highest_pow2_factor (right_offset));\n-\t}\n-      else \n-\t{\n-\t  /* The left operand was successfully substituted with constant.  */\t  \n-\t  if (left_misalign)\n-\t    {\n-\t      /* In case of EXPR '(i * C1 + j) * C2', LEFT_MISALIGN is \n-\t\t NULL_TREE.  */\n-\t      *misalign  = size_binop (code, left_misalign, right_misalign);\n-\t      if (left_aligned_to && right_aligned_to)\n-\t\t*aligned_to = size_binop (MIN_EXPR, left_aligned_to, \n-\t\t\t\t\t  right_aligned_to);\n-\t      else \n-\t\t*aligned_to = left_aligned_to ? \n-\t\t  left_aligned_to : right_aligned_to;\n-\t    }\n-\t  else\n-\t    *misalign = NULL_TREE; \n-\t}\n+      off1 = TREE_OPERAND (exp, 1);\n+      if (TREE_CODE (off1) != INTEGER_CST)\n+\tbreak;\n+\n+      split_constant_offset (TREE_OPERAND (exp, 0), &var0, &off0);\n+      *var = fold_convert (type, fold_build2 (MULT_EXPR, otype,\n+\t\t\t\t\t      var0, off1));\n+      *off = size_binop (MULT_EXPR, off0, fold_convert (ssizetype, off1));\n+      return;\n \n-      /* Step calculation.  */\n-      /* Multiply the step by the right operand.  */\n-      *step  = size_binop (MULT_EXPR, left_step, right_offset);\n-      break;\n-   \n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* Combine the recursive calculations for step and misalignment.  */\n-      *step = size_binop (code, left_step, right_step);\n+    case ADDR_EXPR:\n+      {\n+\ttree op, base, poffset;\n+\tHOST_WIDE_INT pbitsize, pbitpos;\n+\tenum machine_mode pmode;\n+\tint punsignedp, pvolatilep;\n \n-      /* Unknown alignment.  */\n-      if ((!left_misalign && !left_aligned_to)\n-\t  || (!right_misalign && !right_aligned_to))\n-\t{\n-\t  *misalign = NULL_TREE;\n-\t  *aligned_to = NULL_TREE;\n+\top = TREE_OPERAND (exp, 0);\n+\tif (!handled_component_p (op))\n \t  break;\n-\t}\n \n-      if (left_misalign && right_misalign)\n-\t*misalign = size_binop (code, left_misalign, right_misalign);\n-      else\n-\t*misalign = left_misalign ? left_misalign : right_misalign;\n+\tbase = get_inner_reference (op, &pbitsize, &pbitpos, &poffset,\n+\t\t\t\t    &pmode, &punsignedp, &pvolatilep, false);\n \n-      if (left_aligned_to && right_aligned_to)\n-\t*aligned_to = size_binop (MIN_EXPR, left_aligned_to, right_aligned_to);\n-      else \n-\t*aligned_to = left_aligned_to ? left_aligned_to : right_aligned_to;\n+\tif (pbitpos % BITS_PER_UNIT != 0)\n+\t  break;\n+\tbase = build_fold_addr_expr (base);\n+\toff0 = ssize_int (pbitpos / BITS_PER_UNIT);\n \n-      break;\n+\tif (poffset)\n+\t  {\n+\t    split_constant_offset (poffset, &poffset, &off1);\n+\t    off0 = size_binop (PLUS_EXPR, off0, off1);\n+\t    base = fold_build2 (PLUS_EXPR, TREE_TYPE (base),\n+\t\t\t\tbase,\n+\t\t\t\tfold_convert (TREE_TYPE (base), poffset));\n+\t  }\n+\n+\t*var = fold_convert (type, base);\n+\t*off = off0;\n+\treturn;\n+      }\n \n     default:\n-      gcc_unreachable ();\n+      break;\n     }\n \n-  /* Compute offset.  */\n-  *initial_offset = fold_convert (ssizetype, \n-\t\t\t\t  fold_build2 (code, TREE_TYPE (left_offset), \n-\t\t\t\t\t       left_offset, \n-\t\t\t\t\t       right_offset));\n-  return true;\n+  *off = ssize_int (0);\n }\n \n-/* Function address_analysis\n-\n-   Return the BASE of the address expression EXPR.\n-   Also compute the OFFSET from BASE, MISALIGN and STEP.\n-\n-   Input:\n-   EXPR - the address expression that is being analyzed\n-   STMT - the statement that contains EXPR or its original memory reference\n-   IS_READ - TRUE if STMT reads from EXPR, FALSE if writes to EXPR\n-   DR - data_reference struct for the original memory reference\n-\n-   Output:\n-   BASE (returned value) - the base of the data reference EXPR.\n-   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n-   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n-              computation is impossible \n-   ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be \n-                calculated (doesn't depend on variables)\n-   STEP - evolution of EXPR in the loop\n- \n-   If something unexpected is encountered (an unsupported form of data-ref),\n-   then NULL_TREE is returned.  \n- */\n+/* Returns the address ADDR of an object in a canonical shape (without nop\n+   casts, and with type of pointer to the object).  */\n \n static tree\n-address_analysis (tree expr, tree stmt, bool is_read, struct data_reference *dr, \n-\t\t  tree *offset, tree *misalign, tree *aligned_to, tree *step)\n+canonicalize_base_object_address (tree addr)\n {\n-  tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n-  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n-  tree dummy, address_aligned_to = NULL_TREE;\n-  struct ptr_info_def *dummy1;\n-  subvar_t dummy2;\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* EXPR is of form {base +/- offset} (or {offset +/- base}).  */\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n+  STRIP_NOPS (addr);\n \n-      STRIP_NOPS (oprnd0);\n-      STRIP_NOPS (oprnd1);\n-      \n-      /* Recursively try to find the base of the address contained in EXPR.\n-\t For offset, the returned base will be NULL.  */\n-      base_addr0 = address_analysis (oprnd0, stmt, is_read, dr, &address_offset, \n-\t\t\t\t     &address_misalign, &address_aligned_to, \n-\t\t\t\t     step);\n-\n-      base_addr1 = address_analysis (oprnd1, stmt, is_read,  dr, &address_offset, \n-\t\t\t\t     &address_misalign, &address_aligned_to, \n-\t\t\t\t     step);\n-\n-      /* We support cases where only one of the operands contains an \n-\t address.  */\n-      if ((base_addr0 && base_addr1) || (!base_addr0 && !base_addr1))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \n-\t\t    \"\\neither more than one address or no addresses in expr \");\n-\t      print_generic_expr (dump_file, expr, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\t\n-\t  return NULL_TREE;\n-\t}\n+  if (TREE_CODE (addr) != ADDR_EXPR)\n+    return addr;\n \n-      /* To revert STRIP_NOPS.  */\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n-      \n-      offset_expr = base_addr0 ? \n-\tfold_convert (ssizetype, oprnd1) : fold_convert (ssizetype, oprnd0);\n-\n-      /* EXPR is of form {base +/- offset} (or {offset +/- base}). If offset is \n-\t a number, we can add it to the misalignment value calculated for base,\n-\t otherwise, misalignment is NULL.  */\n-      if (TREE_CODE (offset_expr) == INTEGER_CST && address_misalign)\n-\t{\n-\t  *misalign = size_binop (TREE_CODE (expr), address_misalign, \n-\t\t\t\t  offset_expr);\n-\t  *aligned_to = address_aligned_to;\n-\t}\n-      else\n-\t{\n-\t  *misalign = NULL_TREE;\n-\t  *aligned_to = NULL_TREE;\n-\t}\n-\n-      /* Combine offset (from EXPR {base + offset}) with the offset calculated\n-\t for base.  */\n-      *offset = size_binop (TREE_CODE (expr), address_offset, offset_expr);\n-      return base_addr0 ? base_addr0 : base_addr1;\n-\n-    case ADDR_EXPR:\n-      base_address = object_analysis (TREE_OPERAND (expr, 0), stmt, is_read, \n-\t\t\t\t      &dr, offset, misalign, aligned_to, step, \n-\t\t\t\t      &dummy, &dummy1, &dummy2);\n-      return base_address;\n-\n-    case SSA_NAME:\n-      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nnot pointer SSA_NAME \");\n-\t      print_generic_expr (dump_file, expr, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\t\n-\t  return NULL_TREE;\n-\t}\n-      *aligned_to = ssize_int (TYPE_ALIGN_UNIT (TREE_TYPE (TREE_TYPE (expr))));\n-      *misalign = ssize_int (0);\n-      *offset = ssize_int (0);\n-      *step = ssize_int (0);\n-      return expr;\n-      \n-    default:\n-      return NULL_TREE;\n-    }\n+  return build_fold_addr_expr (TREE_OPERAND (addr, 0));\n }\n \n+/* Analyzes the behavior of the memory reference DR in the innermost loop that\n+   contains it.  */\n \n-/* Function object_analysis\n-\n-   Create a data-reference structure DR for MEMREF.\n-   Return the BASE of the data reference MEMREF if the analysis is possible.\n-   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n-   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n-   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n-   instantiated with initial_conditions of access_functions of variables, \n-   and STEP is the evolution of the DR_REF in this loop.\n-   \n-   Function get_inner_reference is used for the above in case of ARRAY_REF and\n-   COMPONENT_REF.\n-\n-   The structure of the function is as follows:\n-   Part 1:\n-   Case 1. For handled_component_p refs \n-          1.1 build data-reference structure for MEMREF\n-          1.2 call get_inner_reference\n-            1.2.1 analyze offset expr received from get_inner_reference\n-          (fall through with BASE)\n-   Case 2. For declarations \n-          2.1 set MEMTAG\n-   Case 3. For INDIRECT_REFs \n-          3.1 build data-reference structure for MEMREF\n-\t  3.2 analyze evolution and initial condition of MEMREF\n-\t  3.3 set data-reference structure for MEMREF\n-          3.4 call address_analysis to analyze INIT of the access function\n-\t  3.5 extract memory tag\n-\n-   Part 2:\n-   Combine the results of object and address analysis to calculate \n-   INITIAL_OFFSET, STEP and misalignment info.   \n-\n-   Input:\n-   MEMREF - the memory reference that is being analyzed\n-   STMT - the statement that contains MEMREF\n-   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n-   \n-   Output:\n-   BASE_ADDRESS (returned value) - the base address of the data reference MEMREF\n-                                   E.g, if MEMREF is a.b[k].c[i][j] the returned\n-\t\t\t           base is &a.\n-   DR - data_reference struct for MEMREF\n-   INITIAL_OFFSET - initial offset of MEMREF from BASE (an expression)\n-   MISALIGN - offset of MEMREF from BASE in bytes (a constant) modulo alignment of \n-              ALIGNMENT or NULL_TREE if the computation is impossible\n-   ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be \n-                calculated (doesn't depend on variables)\n-   STEP - evolution of the DR_REF in the loop\n-   MEMTAG - memory tag for aliasing purposes\n-   PTR_INFO - NULL or points-to aliasing info from a pointer SSA_NAME\n-   SUBVARS - Sub-variables of the variable\n-\n-   If the analysis of MEMREF evolution in the loop fails, NULL_TREE is returned, \n-   but DR can be created anyway.\n-   \n-*/\n- \n-static tree\n-object_analysis (tree memref, tree stmt, bool is_read, \n-\t\t struct data_reference **dr, tree *offset, tree *misalign, \n-\t\t tree *aligned_to, tree *step, tree *memtag,\n-\t\t struct ptr_info_def **ptr_info, subvar_t *subvars)\n+static void\n+dr_analyze_innermost (struct data_reference *dr)\n {\n-  tree base = NULL_TREE, base_address = NULL_TREE;\n-  tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n-  tree object_step = ssize_int (0), address_step = ssize_int (0);\n-  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+  tree stmt = DR_STMT (dr);\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  tree ref = DR_REF (dr);\n   HOST_WIDE_INT pbitsize, pbitpos;\n-  tree poffset, bit_pos_in_bytes;\n+  tree base, poffset;\n   enum machine_mode pmode;\n   int punsignedp, pvolatilep;\n-  tree ptr_step = ssize_int (0), ptr_init = NULL_TREE;\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  struct data_reference *ptr_dr = NULL;\n-  tree object_aligned_to = NULL_TREE, address_aligned_to = NULL_TREE;\n-  tree comp_ref = NULL_TREE;\n+  affine_iv base_iv, offset_iv;\n+  tree init, dinit, step;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"analyze_innermost: \");\n \n- *ptr_info = NULL;\n+  base = get_inner_reference (ref, &pbitsize, &pbitpos, &poffset,\n+\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n+  gcc_assert (base != NULL_TREE);\n \n-  /* Part 1:  */\n-  /* Case 1. handled_component_p refs.  */\n-  if (handled_component_p (memref))\n+  if (pbitpos % BITS_PER_UNIT != 0)\n     {\n-      /* 1.1 build data-reference structure for MEMREF.  */\n-      if (!(*dr))\n-\t{ \n-\t  if (TREE_CODE (memref) == ARRAY_REF)\n-\t    *dr = init_array_ref (stmt, memref, is_read);\t  \n-\t  else if (TREE_CODE (memref) == COMPONENT_REF)\n-\t    comp_ref = memref;\n-\t  else  \n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"\\ndata-ref of unsupported type \");\n-\t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"failed: bit offset alignment.\\n\");\n+      return;\n+    }\n \n-      /* 1.2 call get_inner_reference.  */\n-      /* Find the base and the offset from it.  */\n-      base = get_inner_reference (memref, &pbitsize, &pbitpos, &poffset,\n-\t\t\t\t  &pmode, &punsignedp, &pvolatilep, false);\n-      if (!base)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nfailed to get inner ref for \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\t  \n-\t  return NULL_TREE;\n-\t}\n+  base = build_fold_addr_expr (base);\n+  if (!simple_iv (loop, stmt, base, &base_iv, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n+      return;\n+    }\n+  if (!poffset)\n+    {\n+      offset_iv.base = ssize_int (0);\n+      offset_iv.step = ssize_int (0);\n+    }\n+  else if (!simple_iv (loop, stmt, poffset, &offset_iv, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"failed: evolution of offset is not affine.\\n\");\n+      return;\n+    }\n \n-      /* 1.2.1 analyze offset expr received from get_inner_reference.  */\n-      if (poffset \n-\t  && !analyze_offset_expr (poffset, loop, &object_offset, \n-\t\t\t\t   &object_misalign, &object_aligned_to,\n-\t\t\t\t   &object_step))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nfailed to compute offset or step for \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n+  init = ssize_int (pbitpos / BITS_PER_UNIT);\n+  split_constant_offset (base_iv.base, &base_iv.base, &dinit);\n+  init =  size_binop (PLUS_EXPR, init, dinit);\n+  split_constant_offset (offset_iv.base, &offset_iv.base, &dinit);\n+  init =  size_binop (PLUS_EXPR, init, dinit);\n \n-      /* Add bit position to OFFSET and MISALIGN.  */\n+  step = size_binop (PLUS_EXPR,\n+\t\t     fold_convert (ssizetype, base_iv.step),\n+\t\t     fold_convert (ssizetype, offset_iv.step));\n \n-      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n-      /* Check that there is no remainder in bits.  */\n-      if (pbitpos%BITS_PER_UNIT)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"\\nbit offset alignment.\\n\");\n-\t  return NULL_TREE;\n-\t}\n-      object_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, object_offset);     \n-      if (object_misalign) \n-\tobject_misalign = size_binop (PLUS_EXPR, object_misalign, \n-\t\t\t\t      bit_pos_in_bytes); \n-      \n-      memref = base; /* To continue analysis of BASE.  */\n-      /* fall through  */\n-    }\n-  \n-  /*  Part 1: Case 2. Declarations.  */ \n-  if (DECL_P (memref))\n-    {\n-      /* We expect to get a decl only if we already have a DR, or with \n-\t COMPONENT_REFs of type 'a[i].b'.  */\n-      if (!(*dr))\n-\t{\n-\t  if (comp_ref && TREE_CODE (TREE_OPERAND (comp_ref, 0)) == ARRAY_REF)\n-\t    {\n-\t      *dr = init_array_ref (stmt, TREE_OPERAND (comp_ref, 0), is_read);\t      \t      \n-\t      if (DR_NUM_DIMENSIONS (*dr) != 1)\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"\\n multidimensional component ref \");\n-\t\t      print_generic_expr (dump_file, comp_ref, TDF_SLIM);\n-\t\t      fprintf (dump_file, \"\\n\");\n-\t\t    }\n-\t\t  return NULL_TREE;\n-\t\t}\n-\t    }\n-\t  else \n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"\\nunhandled decl \");\n-\t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n+  DR_BASE_ADDRESS (dr) = canonicalize_base_object_address (base_iv.base);\n \n-      /* TODO: if during the analysis of INDIRECT_REF we get to an object, put \n-\t the object in BASE_OBJECT field if we can prove that this is O.K., \n-\t i.e., the data-ref access is bounded by the bounds of the BASE_OBJECT.\n-\t (e.g., if the object is an array base 'a', where 'a[N]', we must prove\n-\t that every access with 'p' (the original INDIRECT_REF based on '&a')\n-\t in the loop is within the array boundaries - from a[0] to a[N-1]).\n-\t Otherwise, our alias analysis can be incorrect.\n-\t Even if an access function based on BASE_OBJECT can't be build, update\n-\t BASE_OBJECT field to enable us to prove that two data-refs are \n-\t different (without access function, distance analysis is impossible).\n-      */\n-     if (SSA_VAR_P (memref) && var_can_have_subvars (memref))\t\n-\t*subvars = get_subvars_for_var (memref);\n-      base_address = build_fold_addr_expr (memref);\n-      /* 2.1 set MEMTAG.  */\n-      *memtag = memref;\n-    }\n+  DR_OFFSET (dr) = fold_convert (ssizetype, offset_iv.base);\n+  DR_INIT (dr) = init;\n+  DR_STEP (dr) = step;\n \n-  /* Part 1:  Case 3. INDIRECT_REFs.  */\n-  else if (TREE_CODE (memref) == INDIRECT_REF)\n-    {\n-      tree ptr_ref = TREE_OPERAND (memref, 0);\n-      if (TREE_CODE (ptr_ref) == SSA_NAME)\n-        *ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n+  DR_ALIGNED_TO (dr) = size_int (highest_pow2_factor (offset_iv.base));\n \n-      /* 3.1 build data-reference structure for MEMREF.  */\n-      ptr_dr = analyze_indirect_ref (stmt, memref, is_read);\n-      if (!ptr_dr)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nfailed to create dr for \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\t\n-\t  return NULL_TREE;      \n-\t}\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"success.\\n\");\n+}\n \n-      /* 3.2 analyze evolution and initial condition of MEMREF.  */\n-      ptr_step = DR_STEP (ptr_dr);\n-      ptr_init = DR_BASE_ADDRESS (ptr_dr);\n-      if (!ptr_init || !ptr_step || !POINTER_TYPE_P (TREE_TYPE (ptr_init)))\n-\t{\n-\t  *dr = (*dr) ? *dr : ptr_dr;\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nbad pointer access \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n+/* Determines the base object and the list of indices of memory reference\n+   DR, analysed in loop nest NEST.  */\n \n-      if (integer_zerop (ptr_step) && !(*dr))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS)) \n-\t    fprintf (dump_file, \"\\nptr is loop invariant.\\n\");\t\n-\t  *dr = ptr_dr;\n-\t  return NULL_TREE;\n-\t\n-\t  /* If there exists DR for MEMREF, we are analyzing the base of\n-\t     handled component (PTR_INIT), which not necessary has evolution in \n-\t     the loop.  */\n-\t}\n-      object_step = size_binop (PLUS_EXPR, object_step, ptr_step);\n-\n-      /* 3.3 set data-reference structure for MEMREF.  */\n-      if (!*dr)\n-        *dr = ptr_dr;\n-\n-      /* 3.4 call address_analysis to analyze INIT of the access \n-\t function.  */\n-      base_address = address_analysis (ptr_init, stmt, is_read, *dr, \n-\t\t\t\t       &address_offset, &address_misalign, \n-\t\t\t\t       &address_aligned_to, &address_step);\n-      if (!base_address)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nfailed to analyze address \");\n-\t      print_generic_expr (dump_file, ptr_init, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n+static void\n+dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n+{\n+  tree stmt = DR_STMT (dr);\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  VEC (tree, heap) *access_fns = NULL;\n+  tree ref = unshare_expr (DR_REF (dr)), aref = ref, op;\n+  tree base, off, access_fn;\n \n-      /* 3.5 extract memory tag.  */\n-      switch (TREE_CODE (base_address))\n-\t{\n-\tcase SSA_NAME:\n-\t  *memtag = symbol_mem_tag (SSA_NAME_VAR (base_address));\n-\t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n-\t    *memtag = symbol_mem_tag (SSA_NAME_VAR (TREE_OPERAND (memref, 0)));\n-\t  break;\n-\tcase ADDR_EXPR:\n-\t  *memtag = TREE_OPERAND (base_address, 0);\n-\t  break;\n-\tdefault:\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nno memtag for \"); \n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  *memtag = NULL_TREE;\n-\t  break;\n-\t}\n-    }      \n-    \n-  if (!base_address)\n+  while (handled_component_p (aref))\n     {\n-      /* MEMREF cannot be analyzed.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (TREE_CODE (aref) == ARRAY_REF)\n \t{\n-\t  fprintf (dump_file, \"\\ndata-ref of unsupported type \");\n-\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n+\t  op = TREE_OPERAND (aref, 1);\n+\t  access_fn = analyze_scalar_evolution (loop, op);\n+\t  access_fn = resolve_mixers (nest, access_fn);\n+\t  VEC_safe_push (tree, heap, access_fns, access_fn);\n+\n+\t  TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n \t}\n-      return NULL_TREE;\n+      \n+      aref = TREE_OPERAND (aref, 0);\n     }\n \n-  if (comp_ref)\n-    DR_REF (*dr) = comp_ref;\n-\n-  if (SSA_VAR_P (*memtag) && var_can_have_subvars (*memtag))\n-    *subvars = get_subvars_for_var (*memtag);\n-\t\n-  /* Part 2: Combine the results of object and address analysis to calculate \n-     INITIAL_OFFSET, STEP and misalignment info.  */\n-  *offset = size_binop (PLUS_EXPR, object_offset, address_offset);\n-\n-  if ((!object_misalign && !object_aligned_to)\n-      || (!address_misalign && !address_aligned_to))\n-    {\n-      *misalign = NULL_TREE;\n-      *aligned_to = NULL_TREE;\n-    }  \n-  else \n+  if (INDIRECT_REF_P (aref))\n     {\n-      if (object_misalign && address_misalign)\n-\t*misalign = size_binop (PLUS_EXPR, object_misalign, address_misalign);\n-      else\n-\t*misalign = object_misalign ? object_misalign : address_misalign;\n-      if (object_aligned_to && address_aligned_to)\n-\t*aligned_to = size_binop (MIN_EXPR, object_aligned_to, \n-\t\t\t\t  address_aligned_to);\n-      else\n-\t*aligned_to = object_aligned_to ? \n-\t  object_aligned_to : address_aligned_to; \n+      op = TREE_OPERAND (aref, 0);\n+      access_fn = analyze_scalar_evolution (loop, op);\n+      access_fn = resolve_mixers (nest, access_fn);\n+      base = initial_condition (access_fn);\n+      split_constant_offset (base, &base, &off);\n+      access_fn = chrec_replace_initial_condition (access_fn,\n+\t\t\tfold_convert (TREE_TYPE (base), off));\n+\n+      TREE_OPERAND (aref, 0) = base;\n+      VEC_safe_push (tree, heap, access_fns, access_fn);\n     }\n-  *step = size_binop (PLUS_EXPR, object_step, address_step); \n \n-  return base_address;\n+  DR_BASE_OBJECT (dr) = ref;\n+  DR_ACCESS_FNS (dr) = access_fns;\n }\n \n-/* Function analyze_offset.\n-   \n-   Extract INVARIANT and CONSTANT parts from OFFSET. \n+/* Extracts the alias analysis information from the memory reference DR.  */\n \n-*/\n-static bool \n-analyze_offset (tree offset, tree *invariant, tree *constant)\n+static void\n+dr_analyze_alias (struct data_reference *dr)\n {\n-  tree op0, op1, constant_0, constant_1, invariant_0, invariant_1;\n-  enum tree_code code = TREE_CODE (offset);\n+  tree stmt = DR_STMT (dr);\n+  tree ref = DR_REF (dr);\n+  tree base = get_base_address (ref), addr, smt = NULL_TREE;\n+  ssa_op_iter it;\n+  tree op;\n+  bitmap vops;\n+\n+  if (DECL_P (base))\n+    smt = base;\n+  else if (INDIRECT_REF_P (base))\n+    {\n+      addr = TREE_OPERAND (base, 0);\n+      if (TREE_CODE (addr) == SSA_NAME)\n+\t{\n+\t  smt = symbol_mem_tag (SSA_NAME_VAR (addr));\n+\t  DR_PTR_INFO (dr) = SSA_NAME_PTR_INFO (addr);\n+\t}\n+    }\n \n-  *invariant = NULL_TREE;\n-  *constant = NULL_TREE;\n+  DR_SYMBOL_TAG (dr) = smt;\n+  if (var_can_have_subvars (smt))\n+    DR_SUBVARS (dr) = get_subvars_for_var (smt);\n \n-  /* Not PLUS/MINUS expression - recursion stop condition.  */\n-  if (code != PLUS_EXPR && code != MINUS_EXPR)\n+  vops = BITMAP_ALLOC (NULL);\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, it, SSA_OP_VIRTUAL_USES)\n     {\n-      if (TREE_CODE (offset) == INTEGER_CST)\n-\t*constant = offset;\n-      else\n-\t*invariant = offset;\n-      return true;\n+      bitmap_set_bit (vops, DECL_UID (SSA_NAME_VAR (op)));\n     }\n \n-  op0 = TREE_OPERAND (offset, 0);\n-  op1 = TREE_OPERAND (offset, 1);\n+  DR_VOPS (dr) = vops;\n+}\n \n-  /* Recursive call with the operands.  */\n-  if (!analyze_offset (op0, &invariant_0, &constant_0)\n-      || !analyze_offset (op1, &invariant_1, &constant_1))\n-    return false;\n+/* Returns true if the address of DR is invariant.  */\n \n-  /* Combine the results. Add negation to the subtrahend in case of \n-     subtraction.  */\n-  if (constant_0 && constant_1)\n-    return false;\n-  *constant = constant_0 ? constant_0 : constant_1;\n-  if (code == MINUS_EXPR && constant_1)\n-    *constant = fold_build1 (NEGATE_EXPR, TREE_TYPE (*constant), *constant);\n+static bool\n+dr_address_invariant_p (struct data_reference *dr)\n+{\n+  unsigned i;\n+  tree idx;\n+\n+  for (i = 0; VEC_iterate (tree, DR_ACCESS_FNS (dr), i, idx); i++)\n+    if (tree_contains_chrecs (idx, NULL))\n+      return false;\n \n-  if (invariant_0 && invariant_1)\n-    *invariant = \n-      fold_build2 (code, TREE_TYPE (invariant_0), invariant_0, invariant_1);\n-  else\n-    {\n-      *invariant = invariant_0 ? invariant_0 : invariant_1;\n-      if (code == MINUS_EXPR && invariant_1)\n-        *invariant = \n-           fold_build1 (NEGATE_EXPR, TREE_TYPE (*invariant), *invariant);\n-    }\n   return true;\n }\n \n-/* Free the memory used by the data reference DR.  */\n+/* Frees data reference DR.  */\n \n static void\n free_data_ref (data_reference_p dr)\n {\n-  DR_FREE_ACCESS_FNS (dr);\n+  BITMAP_FREE (DR_VOPS (dr));\n+  VEC_free (tree, heap, DR_ACCESS_FNS (dr));\n   free (dr);\n }\n \n-/* Function create_data_ref.\n-   \n-   Create a data-reference structure for MEMREF. Set its DR_BASE_ADDRESS,\n-   DR_OFFSET, DR_INIT, DR_STEP, DR_OFFSET_MISALIGNMENT, DR_ALIGNED_TO,\n-   DR_MEMTAG, and DR_POINTSTO_INFO fields. \n-\n-   Input:\n-   MEMREF - the memory reference that is being analyzed\n-   STMT - the statement that contains MEMREF\n-   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n-\n-   Output:\n-   DR (returned value) - data_reference struct for MEMREF\n-*/\n+/* Analyzes memory reference MEMREF accessed in STMT.  The reference\n+   is read if IS_READ is true, write otherwise.  Returns the\n+   data_reference description of MEMREF.  NEST is the outermost loop of the\n+   loop nest in that the reference should be analysed.  */\n \n static struct data_reference *\n-create_data_ref (tree memref, tree stmt, bool is_read)\n+create_data_ref (struct loop *nest, tree memref, tree stmt, bool is_read)\n {\n-  struct data_reference *dr = NULL;\n-  tree base_address, offset, step, misalign, memtag;\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  tree invariant = NULL_TREE, constant = NULL_TREE;\n-  tree type_size, init_cond;\n-  struct ptr_info_def *ptr_info;\n-  subvar_t subvars = NULL;\n-  tree aligned_to, type = NULL_TREE, orig_offset;\n-\n-  if (!memref)\n-    return NULL;\n-\n-  base_address = object_analysis (memref, stmt, is_read, &dr, &offset, \n-\t\t\t\t  &misalign, &aligned_to, &step, &memtag, \n-\t\t\t\t  &ptr_info, &subvars);\n-  if (!dr || !base_address)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"\\ncreate_data_ref: failed to create a dr for \");\n-\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      return NULL;\n-    }\n-\n-  DR_BASE_ADDRESS (dr) = base_address;\n-  DR_OFFSET (dr) = offset;\n-  DR_INIT (dr) = ssize_int (0);\n-  DR_STEP (dr) = step;\n-  DR_OFFSET_MISALIGNMENT (dr) = misalign;\n-  DR_ALIGNED_TO (dr) = aligned_to;\n-  DR_MEMTAG (dr) = memtag;\n-  DR_PTR_INFO (dr) = ptr_info;\n-  DR_SUBVARS (dr) = subvars;\n-  \n-  type_size = fold_convert (ssizetype, TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n-\n-  /* Extract CONSTANT and INVARIANT from OFFSET.  */\n-  /* Remove cast from OFFSET and restore it for INVARIANT part.  */\n-  orig_offset = offset;\n-  STRIP_NOPS (offset);\n-  if (offset != orig_offset)\n-    type = TREE_TYPE (orig_offset);\n-  if (!analyze_offset (offset, &invariant, &constant))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"\\ncreate_data_ref: failed to analyze dr's\");\n-          fprintf (dump_file, \" offset for \");\n-          print_generic_expr (dump_file, memref, TDF_SLIM);\n-          fprintf (dump_file, \"\\n\");\n-        }\n-      return NULL;\n-    }\n-  if (type && invariant)\n-    invariant = fold_convert (type, invariant);\n+  struct data_reference *dr;\n \n-  /* Put CONSTANT part of OFFSET in DR_INIT and INVARIANT in DR_OFFSET field\n-     of DR.  */\n-  if (constant)\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      DR_INIT (dr) = fold_convert (ssizetype, constant);\n-      init_cond = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n-\t\t\t       constant, type_size);\n+      fprintf (dump_file, \"Creating dr for \");\n+      print_generic_expr (dump_file, memref, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n     }\n-  else\n-    DR_INIT (dr) = init_cond = ssize_int (0);\n-\n-  if (invariant)\n-    DR_OFFSET (dr) = invariant;\n-  else\n-    DR_OFFSET (dr) = ssize_int (0);\n-\n-  /* Change the access function for INIDIRECT_REFs, according to \n-     DR_BASE_ADDRESS.  Analyze OFFSET calculated in object_analysis. OFFSET is \n-     an expression that can contain loop invariant expressions and constants.\n-     We put the constant part in the initial condition of the access function\n-     (for data dependence tests), and in DR_INIT of the data-ref. The loop\n-     invariant part is put in DR_OFFSET. \n-     The evolution part of the access function is STEP calculated in\n-     object_analysis divided by the size of data type.\n-  */\n-  if (!DR_BASE_OBJECT (dr)\n-      || (TREE_CODE (memref) == COMPONENT_REF && DR_NUM_DIMENSIONS (dr) == 1))\n-    {\n-      tree access_fn;\n-      tree new_step;\n-\n-      /* Update access function.  */\n-      access_fn = DR_ACCESS_FN (dr, 0);\n-      if (automatically_generated_chrec_p (access_fn))\n-\t{\n-\t  free_data_ref (dr);\n-\t  return NULL;\n-\t}\n \n-      new_step = size_binop (TRUNC_DIV_EXPR,  \n-\t\t\t     fold_convert (ssizetype, step), type_size);\n-\n-      init_cond = chrec_convert (chrec_type (access_fn), init_cond, stmt);\n-      new_step = chrec_convert (chrec_type (access_fn), new_step, stmt);\n-      if (automatically_generated_chrec_p (init_cond)\n-\t  || automatically_generated_chrec_p (new_step))\n-\t{\n-\t  free_data_ref (dr);\n-\t  return NULL;\n-\t}\n-      access_fn = chrec_replace_initial_condition (access_fn, init_cond);\n-      access_fn = reset_evolution_in_loop (loop->num, access_fn, new_step);\n+  dr = XCNEW (struct data_reference);\n+  DR_STMT (dr) = stmt;\n+  DR_REF (dr) = memref;\n+  DR_IS_READ (dr) = is_read;\n \n-      VEC_replace (tree, DR_ACCESS_FNS (dr), 0, access_fn);\n-    }\n+  dr_analyze_innermost (dr);\n+  dr_analyze_indices (dr, nest);\n+  dr_analyze_alias (dr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      struct ptr_info_def *pi = DR_PTR_INFO (dr);\n-\n-      fprintf (dump_file, \"\\nCreated dr for \");\n-      print_generic_expr (dump_file, memref, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\\tbase_address: \");\n+      fprintf (dump_file, \"\\tbase_address: \");\n       print_generic_expr (dump_file, DR_BASE_ADDRESS (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\\toffset from base address: \");\n       print_generic_expr (dump_file, DR_OFFSET (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\\tconstant offset from base address: \");\n       print_generic_expr (dump_file, DR_INIT (dr), TDF_SLIM);\n-      fprintf (dump_file, \"\\n\\tbase_object: \");\n-      print_generic_expr (dump_file, DR_BASE_OBJECT (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\\tstep: \");\n       print_generic_expr (dump_file, DR_STEP (dr), TDF_SLIM);\n-      fprintf (dump_file, \"B\\n\\tmisalignment from base: \");\n-      print_generic_expr (dump_file, DR_OFFSET_MISALIGNMENT (dr), TDF_SLIM);\n-      if (DR_OFFSET_MISALIGNMENT (dr))\n-\tfprintf (dump_file, \"B\");\n-      if (DR_ALIGNED_TO (dr))\n-\t{\n-\t  fprintf (dump_file, \"\\n\\taligned to: \");\n-\t  print_generic_expr (dump_file, DR_ALIGNED_TO (dr), TDF_SLIM);\n-\t}\n-      fprintf (dump_file, \"\\n\\tmemtag: \");\n-      print_generic_expr (dump_file, DR_MEMTAG (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\taligned to: \");\n+      print_generic_expr (dump_file, DR_ALIGNED_TO (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tbase_object: \");\n+      print_generic_expr (dump_file, DR_BASE_OBJECT (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tsymbol tag: \");\n+      print_generic_expr (dump_file, DR_SYMBOL_TAG (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\");\n-      if (pi && pi->name_mem_tag)\n-        {\n-          fprintf (dump_file, \"\\n\\tnametag: \");\n-          print_generic_expr (dump_file, pi->name_mem_tag, TDF_SLIM);\n-          fprintf (dump_file, \"\\n\");\n-        }\n-    }  \n+    }\n+\n+  /* FIXME -- data dependence analysis does not work correctly for objects with\n+     invariant addresses.  Let us fail here until the problem is fixed.  */\n+  if (dr_address_invariant_p (dr))\n+    {\n+      free_data_ref (dr);\n+      dr = NULL;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"\\tFAILED as dr address is invariant\\n\");\n+    }\n+\n   return dr;  \n }\n \n@@ -2259,6 +1014,180 @@ conflict_fn_no_dependence (void)\n   return fn;\n }\n \n+/* Returns true if the address of OBJ is invariant in LOOP.  */\n+\n+static bool\n+object_address_invariant_in_loop_p (struct loop *loop, tree obj)\n+{\n+  while (handled_component_p (obj))\n+    {\n+      if (TREE_CODE (obj) == ARRAY_REF)\n+\t{\n+\t  /* Index of the ARRAY_REF was zeroed in analyze_indices, thus we only\n+\t     need to check the stride and the lower bound of the reference.  */\n+\t  if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (obj, 2),\n+\t\t\t\t\t\t      loop->num)\n+\t      || chrec_contains_symbols_defined_in_loop (TREE_OPERAND (obj, 3),\n+\t\t\t\t\t\t\t loop->num))\n+\t    return false;\n+\t}\n+      else if (TREE_CODE (obj) == COMPONENT_REF)\n+\t{\n+\t  if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (obj, 2),\n+\t\t\t\t\t\t      loop->num))\n+\t    return false;\n+\t}\n+      obj = TREE_OPERAND (obj, 0);\n+    }\n+\n+  if (!INDIRECT_REF_P (obj))\n+    return true;\n+\n+  return !chrec_contains_symbols_defined_in_loop (TREE_OPERAND (obj, 0),\n+\t\t\t\t\t\t  loop->num);\n+}\n+\n+/* Returns true if A and B are accesses to different objects, or to different\n+   fields of the same object.  */\n+\n+static bool\n+disjoint_objects_p (tree a, tree b)\n+{\n+  tree base_a, base_b;\n+  VEC (tree, heap) *comp_a = NULL, *comp_b = NULL;\n+  bool ret;\n+\n+  base_a = get_base_address (a);\n+  base_b = get_base_address (b);\n+\n+  if (DECL_P (base_a)\n+      && DECL_P (base_b)\n+      && base_a != base_b)\n+    return true;\n+\n+  if (!operand_equal_p (base_a, base_b, 0))\n+    return false;\n+\n+  /* Compare the component references of A and B.  We must start from the inner\n+     ones, so record them to the vector first.  */\n+  while (handled_component_p (a))\n+    {\n+      VEC_safe_push (tree, heap, comp_a, a);\n+      a = TREE_OPERAND (a, 0);\n+    }\n+  while (handled_component_p (b))\n+    {\n+      VEC_safe_push (tree, heap, comp_b, b);\n+      b = TREE_OPERAND (b, 0);\n+    }\n+\n+  ret = false;\n+  while (1)\n+    {\n+      if (VEC_length (tree, comp_a) == 0\n+\t  || VEC_length (tree, comp_b) == 0)\n+\tbreak;\n+\n+      a = VEC_pop (tree, comp_a);\n+      b = VEC_pop (tree, comp_b);\n+\n+      /* Real and imaginary part of a variable do not alias.  */\n+      if ((TREE_CODE (a) == REALPART_EXPR\n+\t   && TREE_CODE (b) == IMAGPART_EXPR)\n+\t  || (TREE_CODE (a) == IMAGPART_EXPR\n+\t      && TREE_CODE (b) == REALPART_EXPR))\n+\t{\n+\t  ret = true;\n+\t  break;\n+\t}\n+\n+      if (TREE_CODE (a) != TREE_CODE (b))\n+\tbreak;\n+\n+      /* Nothing to do for ARRAY_REFs, as the indices of array_refs in\n+\t DR_BASE_OBJECT are always zero.  */\n+      if (TREE_CODE (a) == ARRAY_REF)\n+\tcontinue;\n+      else if (TREE_CODE (a) == COMPONENT_REF)\n+\t{\n+\t  if (operand_equal_p (TREE_OPERAND (a, 1), TREE_OPERAND (b, 1), 0))\n+\t    continue;\n+\n+\t  /* Different fields of unions may overlap.  */\n+\t  base_a = TREE_OPERAND (a, 0);\n+\t  if (TREE_CODE (TREE_TYPE (base_a)) == UNION_TYPE)\n+\t    break;\n+\n+\t  /* Different fields of structures cannot.  */\n+\t  ret = true;\n+\t  break;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  VEC_free (tree, heap, comp_a);\n+  VEC_free (tree, heap, comp_b);\n+\n+  return ret;\n+}\n+\n+/* Returns false if we can prove that data references A and B do not alias,\n+   true otherwise.  */\n+\n+static bool\n+dr_may_alias_p (struct data_reference *a, struct data_reference *b)\n+{\n+  tree addr_a = DR_BASE_ADDRESS (a);\n+  tree addr_b = DR_BASE_ADDRESS (b);\n+  tree type_a, type_b;\n+  tree decl_a = NULL_TREE, decl_b = NULL_TREE;\n+\n+  /* If the sets of virtual operands are disjoint, the memory references do not\n+     alias.  */\n+  if (!bitmap_intersect_p (DR_VOPS (a), DR_VOPS (b)))\n+    return false;\n+\n+  /* If the accessed objects are disjoint, the memory references do not\n+     alias.  */\n+  if (disjoint_objects_p (DR_BASE_OBJECT (a), DR_BASE_OBJECT (b)))\n+    return false;\n+\n+  if (!addr_a || !addr_b)\n+    return true;\n+\n+  /* If the references are based on different static objects, they cannot alias\n+     (PTA should be able to disambiguate such accesses, but often it fails to,\n+     since currently we cannot distinguish between pointer and offset in pointer\n+     arithmetics).  */\n+  if (TREE_CODE (addr_a) == ADDR_EXPR\n+      && TREE_CODE (addr_b) == ADDR_EXPR)\n+    return TREE_OPERAND (addr_a, 0) == TREE_OPERAND (addr_b, 0);\n+\n+  /* An instruction writing through a restricted pointer is \"independent\" of any \n+     instruction reading or writing through a different restricted pointer, \n+     in the same block/scope.  */\n+\n+  type_a = TREE_TYPE (addr_a);\n+  type_b = TREE_TYPE (addr_b);\n+  gcc_assert (POINTER_TYPE_P (type_a) && POINTER_TYPE_P (type_b));\n+\n+  if (TREE_CODE (addr_a) == SSA_NAME)\n+    decl_a = SSA_NAME_VAR (addr_a);\n+  if (TREE_CODE (addr_b) == SSA_NAME)\n+    decl_b = SSA_NAME_VAR (addr_b);\n+\n+  if (TYPE_RESTRICT (type_a) && TYPE_RESTRICT (type_b) \n+      && (!DR_IS_READ (a) || !DR_IS_READ (b))\n+      && decl_a && TREE_CODE (decl_a) == PARM_DECL\n+      && decl_b && TREE_CODE (decl_b) == PARM_DECL\n+      && TREE_CODE (DECL_CONTEXT (decl_a)) == FUNCTION_DECL\n+      && DECL_CONTEXT (decl_a) == DECL_CONTEXT (decl_b))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Initialize a data dependence relation between data accesses A and\n    B.  NB_LOOPS is the number of loops surrounding the references: the\n    size of the classic distance/direction vectors.  */\n@@ -2269,7 +1198,6 @@ initialize_data_dependence_relation (struct data_reference *a,\n  \t\t\t\t     VEC (loop_p, heap) *loop_nest)\n {\n   struct data_dependence_relation *res;\n-  bool differ_p, known_dependence;\n   unsigned int i;\n   \n   res = XNEW (struct data_dependence_relation);\n@@ -2283,34 +1211,33 @@ initialize_data_dependence_relation (struct data_reference *a,\n       return res;\n     }   \n \n-  /* When A and B are arrays and their dimensions differ, we directly\n-     initialize the relation to \"there is no dependence\": chrec_known.  */\n-  if (DR_BASE_OBJECT (a) && DR_BASE_OBJECT (b)\n-      && DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b))\n+  /* If the data references do not alias, then they are independent.  */\n+  if (!dr_may_alias_p (a, b))\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_known;\n+      DDR_ARE_DEPENDENT (res) = chrec_known;    \n       return res;\n     }\n \n-  if (DR_BASE_ADDRESS (a) && DR_BASE_ADDRESS (b))\n-    known_dependence = base_addr_differ_p (a, b, &differ_p);\n-  else \n-    known_dependence = base_object_differ_p (a, b, &differ_p);\n-\n-  if (!known_dependence)\n+  /* If the references do not access the same object, we do not know\n+     whether they alias or not.  */\n+  if (!operand_equal_p (DR_BASE_OBJECT (a), DR_BASE_OBJECT (b), 0))\n     {\n-      /* Can't determine whether the data-refs access the same memory \n-\t region.  */\n       DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n       return res;\n     }\n \n-  if (differ_p)\n+  /* If the base of the object is not invariant in the loop nest, we cannot\n+     analyse it.  TODO -- in fact, it would suffice to record that there may\n+     be arbitrary depencences in the loops where the base object varies.  */\n+  if (!object_address_invariant_in_loop_p (VEC_index (loop_p, loop_nest, 0),\n+\t\t\t\t\t   DR_BASE_OBJECT (a)))\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_known;    \n+      DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n       return res;\n     }\n-    \n+\n+  gcc_assert (DR_NUM_DIMENSIONS (a) == DR_NUM_DIMENSIONS (b));\n+\n   DDR_AFFINE_P (res) = true;\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n   DDR_SUBSCRIPTS (res) = VEC_alloc (subscript_p, heap, DR_NUM_DIMENSIONS (a));\n@@ -4895,6 +3822,9 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n   unsigned int i;\n   struct subscript *subscript;\n \n+  if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n+    return;\n+\n   for (i = 0; VEC_iterate (subscript_p, DDR_SUBSCRIPTS (ddr), i, subscript);\n        i++)\n     {\n@@ -5013,10 +3943,11 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n }\n \n /* Stores the data references in STMT to DATAREFS.  If there is an unanalyzable\n-   reference, returns false, otherwise returns true.  */\n+   reference, returns false, otherwise returns true.  NEST is the outermost\n+   loop of the loop nest in that the references should be analysed.  */\n \n static bool\n-find_data_references_in_stmt (tree stmt,\n+find_data_references_in_stmt (struct loop *nest, tree stmt,\n \t\t\t      VEC (data_reference_p, heap) **datarefs)\n {\n   unsigned i;\n@@ -5033,7 +3964,7 @@ find_data_references_in_stmt (tree stmt,\n \n   for (i = 0; VEC_iterate (data_ref_loc, references, i, ref); i++)\n     {\n-      dr = create_data_ref (*ref->pos, stmt, ref->is_read);\n+      dr = create_data_ref (nest, *ref->pos, stmt, ref->is_read);\n       if (dr)\n \tVEC_safe_push (data_reference_p, heap, *datarefs, dr);\n       else\n@@ -5049,11 +3980,11 @@ find_data_references_in_stmt (tree stmt,\n /* Search the data references in LOOP, and record the information into\n    DATAREFS.  Returns chrec_dont_know when failing to analyze a\n    difficult case, returns NULL_TREE otherwise.\n-   \n+\n    TODO: This function should be made smarter so that it can handle address\n    arithmetic as if they were array accesses, etc.  */\n \n-tree \n+static tree \n find_data_references_in_loop (struct loop *loop,\n \t\t\t      VEC (data_reference_p, heap) **datarefs)\n {\n@@ -5071,24 +4002,10 @@ find_data_references_in_loop (struct loop *loop,\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  if (!find_data_references_in_stmt (stmt, datarefs))\n+\t  if (!find_data_references_in_stmt (loop, stmt, datarefs))\n \t    {\n \t      struct data_reference *res;\n-\t      res = XNEW (struct data_reference);\n-\t      DR_STMT (res) = NULL_TREE;\n-\t      DR_REF (res) = NULL_TREE;\n-\t      DR_BASE_OBJECT (res) = NULL;\n-\t      DR_TYPE (res) = ARRAY_REF_TYPE;\n-\t      DR_SET_ACCESS_FNS (res, NULL);\n-\t      DR_BASE_OBJECT (res) = NULL;\n-\t      DR_IS_READ (res) = false;\n-\t      DR_BASE_ADDRESS (res) = NULL_TREE;\n-\t      DR_OFFSET (res) = NULL_TREE;\n-\t      DR_INIT (res) = NULL_TREE;\n-\t      DR_STEP (res) = NULL_TREE;\n-\t      DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n-\t      DR_MEMTAG (res) = NULL_TREE;\n-\t      DR_PTR_INFO (res) = NULL;\n+\t      res = XCNEW (struct data_reference);\n \t      VEC_safe_push (data_reference_p, heap, *datarefs, res);\n \n \t      free (bbs);\n@@ -5155,16 +4072,15 @@ compute_data_dependences_for_loop (struct loop *loop,\n \t\t\t\t   VEC (data_reference_p, heap) **datarefs,\n \t\t\t\t   VEC (ddr_p, heap) **dependence_relations)\n {\n-  struct loop *loop_nest = loop;\n   VEC (loop_p, heap) *vloops = VEC_alloc (loop_p, heap, 3);\n \n   memset (&dependence_stats, 0, sizeof (dependence_stats));\n \n   /* If the loop nest is not well formed, or one of the data references \n      is not computable, give up without spending time to compute other\n      dependences.  */\n-  if (!loop_nest\n-      || !find_loop_nest (loop_nest, &vloops)\n+  if (!loop\n+      || !find_loop_nest (loop, &vloops)\n       || find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n     {\n       struct data_dependence_relation *ddr;\n@@ -5287,12 +4203,8 @@ analyze_all_data_dependences (struct loop *loop)\n \t\t{\n \t\t  struct data_reference *a = DDR_A (ddr);\n \t\t  struct data_reference *b = DDR_B (ddr);\n-\t\t  bool differ_p;\t\n-\t      \n-\t\t  if ((DR_BASE_OBJECT (a) && DR_BASE_OBJECT (b)\n-\t\t       && DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b))\n-\t\t      || (base_object_differ_p (a, b, &differ_p) \n-\t\t\t  && differ_p))\n+\n+\t\t  if (!bitmap_intersect_p (DR_VOPS (a), DR_VOPS (b)))\n \t\t    nb_basename_differ++;\n \t\t  else\n \t\t    nb_bot_relations++;"}, {"sha": "2edee2c771691504d86b72ba4559de703e752ffa", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 65, "deletions": 103, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -26,56 +26,81 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"omega.h\"\n \n /*\n-  The first location accessed by data-ref in the loop is the address of data-ref's \n-  base (BASE_ADDRESS) plus the initial offset from the base. We divide the initial offset \n-  into two parts: loop invariant offset (OFFSET) and constant offset (INIT). \n-  STEP is the stride of data-ref in the loop in bytes.\n+  innermost_loop_behavior describes the evolution of the address of the memory\n+  reference in the innermost enclosing loop.  The address is expressed as\n+  BASE + STEP * # of iteration, and base is further decomposed as the base\n+  pointer (BASE_ADDRESS),  loop invariant offset (OFFSET) and\n+  constant offset (INIT).  Examples, in loop nest \n+  \n+  for (i = 0; i < 100; i++)\n+    for (j = 3; j < 100; j++)\n \n                        Example 1                      Example 2\n-      data-ref         a[j].b[i][j]                   a + x + 16B (a is int*)\n+      data-ref         a[j].b[i][j]                   *(p + x + 16B + 4B * j)\n       \n-  First location info:\n-      base_address     &a                             a\n-      offset           j_0*D_j + i_0*D_i              x\n-      init             C_b + C_a                      16\n+  innermost_loop_behavior\n+      base_address     &a                             p\n+      offset           i * D_i\t\t\t      x\n+      init             3 * D_j + offsetof (b)         28\n       step             D_j                            4\n-      access_fn        NULL                           {16, +, 1}\n-\n-  Base object info:\n-      base_object      a                              NULL\n-      access_fn        <access_fns of indexes of b>   NULL\n \n   */\n-struct first_location_in_loop\n+struct innermost_loop_behavior\n {\n   tree base_address;\n   tree offset;\n   tree init;\n   tree step;\n-  /* Access function related to first location in the loop.  */\n-  VEC(tree,heap) *access_fns;\n+\n+  /* Alignment information.  ALIGNED_TO is set to the largest power of two\n+     that divides OFFSET.  */\n+  tree aligned_to;\n };\n \n-struct base_object_info\n+/* Describes the evolutions of indices of the memory reference.  The indices\n+   are indices of the ARRAY_REFs and the operands of INDIRECT_REFs.\n+   For ARRAY_REFs, BASE_OBJECT is the reference with zeroed indices\n+   (note that this reference does not have to be valid, if zero does not\n+   belong to the range of the array; hence it is not recommended to use\n+   BASE_OBJECT in any code generation).  For INDIRECT_REFs, the address is\n+   set to the loop-invariant part of the address of the object, except for\n+   the constant offset.  For the examples above,\n+\n+   base_object:        a[0].b[0][0]                   *(p + x + 4B * j_0)\n+   indices:            {j_0, +, 1}_2                  {16, +, 4}_2\n+\t\t       {i_0, +, 1}_1\n+\t\t       {j_0, +, 1}_2\n+*/\n+\n+struct indices\n {\n   /* The object.  */\n   tree base_object;\n   \n-  /* A list of chrecs.  Access functions related to BASE_OBJECT.  */\n+  /* A list of chrecs.  Access functions of the indices.  */\n   VEC(tree,heap) *access_fns;\n };\n \n-enum data_ref_type {\n-  ARRAY_REF_TYPE,\n-  POINTER_REF_TYPE\n+struct dr_alias\n+{\n+  /* The alias information that should be used for new pointers to this\n+     location.  SYMBOL_TAG is either a DECL or a SYMBOL_MEMORY_TAG.  */\n+  tree symbol_tag;\n+  subvar_t subvars;\n+  struct ptr_info_def *ptr_info;\n+\n+  /* The set of virtual operands corresponding to this memory reference,\n+     serving as a description of the alias information for the memory\n+     reference.  This could be eliminated if we had alias oracle.  */\n+  bitmap vops;\n };\n \n struct data_reference\n {\n   /* A pointer to the statement that contains this DR.  */\n   tree stmt;\n   \n-  /* A pointer to the ARRAY_REF node.  */\n+  /* A pointer to the memory reference.  */\n   tree ref;\n \n   /* Auxiliary info specific to a pass.  */\n@@ -84,58 +109,14 @@ struct data_reference\n   /* True when the data reference is in RHS of a stmt.  */\n   bool is_read;\n \n-  /* First location accessed by the data-ref in the loop.  */\n-  struct first_location_in_loop first_location;\n+  /* Behavior of the memory reference in the innermost loop.  */\n+  struct innermost_loop_behavior innermost;\n \n-  /* Base object related info.  */\n-  struct base_object_info object_info;\n+  /* Decomposition to indices for alias analysis.  */\n+  struct indices indices;\n \n-  /* Aliasing information.  This field represents the symbol that\n-     should be aliased by a pointer holding the address of this data\n-     reference.  If the original data reference was a pointer\n-     dereference, then this field contains the memory tag that should\n-     be used by the new vector-pointer.  */\n-  tree memtag;\n-  struct ptr_info_def *ptr_info;\n-  subvar_t subvars;\n-\n-  /* Alignment information.  \n-     MISALIGNMENT is the offset of the data-reference from its base in bytes.\n-     ALIGNED_TO is the maximum data-ref's alignment.  \n-\n-     Example 1, \n-       for i\n-          for (j = 3; j < N; j++)\n-            a[j].b[i][j] = 0;\n-\t \n-     For a[j].b[i][j], the offset from base (calculated in get_inner_reference() \n-     will be 'i * C_i + j * C_j + C'. \n-     We try to substitute the variables of the offset expression\n-     with initial_condition of the corresponding access_fn in the loop.\n-     'i' cannot be substituted, since its access_fn in the inner loop is i. 'j' \n-     will be substituted with 3. \n-\n-     Example 2\n-        for (j = 3; j < N; j++)\n-          a[j].b[5][j] = 0; \n-\n-     Here the offset expression (j * C_j + C) will not contain variables after\n-     substitution of j=3 (3*C_j + C).\n-\n-     Misalignment can be calculated only if all the variables can be \n-     substituted with constants, otherwise, we record maximum possible alignment\n-     in ALIGNED_TO. In Example 1, since 'i' cannot be substituted, \n-     MISALIGNMENT will be NULL_TREE, and the biggest divider of C_i (a power of \n-     2) will be recorded in ALIGNED_TO.\n-\n-     In Example 2, MISALIGNMENT will be the value of 3*C_j + C in bytes, and \n-     ALIGNED_TO will be NULL_TREE.\n-  */\n-  tree misalignment;\n-  tree aligned_to;\n-\n-  /* The type of the data-ref.  */\n-  enum data_ref_type type;\n+  /* Alias information for the data reference.  */\n+  struct dr_alias alias;\n };\n \n typedef struct data_reference *data_reference_p;\n@@ -144,37 +125,20 @@ DEF_VEC_ALLOC_P (data_reference_p, heap);\n \n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n-#define DR_BASE_OBJECT(DR)         (DR)->object_info.base_object\n-#define DR_TYPE(DR)                (DR)->type\n-#define DR_ACCESS_FNS(DR)\\\n-  (DR_TYPE(DR) == ARRAY_REF_TYPE ?  \\\n-   (DR)->object_info.access_fns : (DR)->first_location.access_fns)\n+#define DR_BASE_OBJECT(DR)         (DR)->indices.base_object\n+#define DR_ACCESS_FNS(DR)\t   (DR)->indices.access_fns\n #define DR_ACCESS_FN(DR, I)        VEC_index (tree, DR_ACCESS_FNS (DR), I)\n #define DR_NUM_DIMENSIONS(DR)      VEC_length (tree, DR_ACCESS_FNS (DR))  \n #define DR_IS_READ(DR)             (DR)->is_read\n-#define DR_BASE_ADDRESS(DR)        (DR)->first_location.base_address\n-#define DR_OFFSET(DR)              (DR)->first_location.offset\n-#define DR_INIT(DR)                (DR)->first_location.init\n-#define DR_STEP(DR)                (DR)->first_location.step\n-#define DR_MEMTAG(DR)              (DR)->memtag\n-#define DR_ALIGNED_TO(DR)          (DR)->aligned_to\n-#define DR_OFFSET_MISALIGNMENT(DR) (DR)->misalignment\n-#define DR_PTR_INFO(DR)            (DR)->ptr_info\n-#define DR_SUBVARS(DR)             (DR)->subvars\n-#define DR_SET_ACCESS_FNS(DR, ACC_FNS)         \\\n-{                                              \\\n-  if (DR_TYPE(DR) == ARRAY_REF_TYPE)           \\\n-    (DR)->object_info.access_fns = ACC_FNS;    \\\n-  else                                         \\\n-    (DR)->first_location.access_fns = ACC_FNS; \\\n-}\n-#define DR_FREE_ACCESS_FNS(DR)                              \\\n-{                                                           \\\n-  if (DR_TYPE(DR) == ARRAY_REF_TYPE)                        \\\n-    VEC_free (tree, heap, (DR)->object_info.access_fns);    \\\n-  else                                                      \\\n-    VEC_free (tree, heap, (DR)->first_location.access_fns); \\\n-}\n+#define DR_BASE_ADDRESS(DR)        (DR)->innermost.base_address\n+#define DR_OFFSET(DR)              (DR)->innermost.offset\n+#define DR_INIT(DR)                (DR)->innermost.init\n+#define DR_STEP(DR)                (DR)->innermost.step\n+#define DR_SYMBOL_TAG(DR)          (DR)->alias.symbol_tag\n+#define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n+#define DR_SUBVARS(DR)             (DR)->alias.subvars\n+#define DR_VOPS(DR)\t\t   (DR)->alias.vops\n+#define DR_ALIGNED_TO(DR)          (DR)->innermost.aligned_to\n \n enum data_dependence_direction {\n   dir_positive, \n@@ -335,8 +299,6 @@ DEF_VEC_O (data_ref_loc);\n DEF_VEC_ALLOC_O (data_ref_loc, heap);\n \n bool get_references_in_stmt (tree, VEC (data_ref_loc, heap) **);\n-extern tree find_data_references_in_loop (struct loop *,\n-\t\t\t\t\t  VEC (data_reference_p, heap) **);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);"}, {"sha": "9fd5c786ebf45a256f84de92f27ca5d5c6b44d72", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -254,7 +254,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"params.h\"\n \n static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);\n-static tree resolve_mixers (struct loop *, tree);\n \n /* The cached information about a ssa name VAR, claiming that inside LOOP,\n    the value of VAR can be expressed as CHREC.  */\n@@ -2408,7 +2407,7 @@ instantiate_parameters (struct loop *loop,\n    care about causing overflows, as long as they do not affect value\n    of an expression.  */\n \n-static tree\n+tree\n resolve_mixers (struct loop *loop, tree chrec)\n {\n   htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);"}, {"sha": "e0218cc9e067464c67d0b1163d786c37c7c35501", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -31,6 +31,7 @@ extern void scev_reset (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_parameters (struct loop *, tree);\n+extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n unsigned int scev_const_prop (void);"}, {"sha": "f928973a408331b41d95f8d21be2865f342d7c09", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -1130,15 +1130,14 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   /* Initialize misalignment to unknown.  */\n   DR_MISALIGNMENT (dr) = -1;\n \n-  misalign = DR_OFFSET_MISALIGNMENT (dr);\n+  misalign = DR_INIT (dr);\n   aligned_to = DR_ALIGNED_TO (dr);\n   base_addr = DR_BASE_ADDRESS (dr);\n   base = build_fold_indirect_ref (base_addr);\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n \n-  if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)\n-      || !misalign)\n+  if (tree_int_cst_compare (aligned_to, alignment) < 0)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n@@ -2044,7 +2043,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n             }\n           return false;\n         }\n-      if (!DR_MEMTAG (dr))\n+      if (!DR_SYMBOL_TAG (dr))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n             {"}, {"sha": "875731da3606fe0f8db2e4625aa915e18946dbf0", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=3cb960c703ec1fbbd2c0b9f821dc957a56aa5d00", "patch": "@@ -298,7 +298,7 @@ vect_create_data_ref_ptr (tree stmt,\n   /** (2) Add aliasing information to the new vector-pointer:\n           (The points-to info (DR_PTR_INFO) may be defined later.)  **/\n   \n-  tag = DR_MEMTAG (dr);\n+  tag = DR_SYMBOL_TAG (dr);\n   gcc_assert (tag);\n \n   /* If tag is a variable (and NOT_A_TAG) than a new symbol memory"}]}