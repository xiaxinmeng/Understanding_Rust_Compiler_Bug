{"sha": "61ee09668e64881e1e42a35d13d2bdbb073d75e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFlZTA5NjY4ZTY0ODgxZTFlNDJhMzVkMTNkMmJkYmIwNzNkNzVlNA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2019-01-22T02:29:47Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2019-01-22T02:29:47Z"}, "message": "[RS6000] PR88614, output_operand: invalid %z value\n\nThe direct cause of this PR is the fact that tls_gdld_nomark didn't\nhandle indirect calls.  Also, most indirect calls were being optimised\nback to direct calls anyway, due to tls_gdld_nomark not checking any\nof the parallel elements except the first (plus the extra element that\ndistinguishes this call from normal calls).  There were other unwanted\nsubstitutions too.\n\nSo this patch attacks the problem of handling special calls in a\ndifferent way.  Rather than adding another element to the call insn\nparallel to distinguish -mno-tls-markers __tls_get_addr calls from any\nother calls, we now inspect the second CALL arg.  Each\ncall_value_nonlocal and call_value_indirect insn now checks for the\ntlsgd/ld unspecs when !TARGET_TLS_MARKERS and emits the arg setup\ninsns.  I disallow the local call patterns since we'll only see local\ncalls to __tls_get_addr in testcases, and it doesn't seem a good idea\nto complicate the patterns just for a minor optimisation.  Sibling\ncall insns aren't used for libcalls, so none of these insns need to\nchange.\n\nThe patch also fixes a minor problem with -mno-tls-markers\n__tls_get_addr calls causing a \"li 3,0\" instruction to be emitted\nprior to the arg setup instructions, due to using a libcall with one\narg.  That isn't correct when the call insn itself sets up its arg.\nAlso, I've tidied the V4 secure-plt calls, generating them in\nrs6000_call_sysv rather than by splitting in rs6000.md.  The\nCALL_INSN_FUNCTION_USAGE added in edit_tls_call_insn is no longer\nneeded (since git commit 0a4b5c66df9).\n\nOn the subject of unwanted substitutions, I also saw a\n_GLOBAL_OFFSET_TABLE_ symbol_ref being substituted for the GOT reg,\nresulting in code like \"addi 3,_GLOBAL_OFFSET_TABLE_,tls_ld@got@tlsld\".\nFixed by the unspec_tls change.\n\n\tPR target/88614\n\t* config/rs6000/predicates.md (unspec_tls): Ensure GOT reg\n\tstays a reg.  Allow a const_int.\n\t* config/rs6000/rs6000-protos.h (rs6000_output_tlsargs): Declare.\n\t* config/rs6000/rs6000.h (IS_V4_FP_ARGS): Define.\n\t(IS_NOMARK_TLSGETADDR): Define.\n\t* config/rs6000/rs6000.c (edit_tls_call_insn): Delete.\n\t(rs6000_output_tlsargs): New function.\n\t(rs6000_legitimize_tls_address): Don't say a !TARGET_TLS_MARKERS\n\t__tls_get_addr call takes an arg.\n\t(rs6000_call_sysv): Generate sysv4 secure plt call pattern here..\n\t* config/rs6000/rs6000.md (call_nonlocal_sysv): ..rather than here,\n\tdelete split..\n\t(call_value_nonlocal_sysv): ..or here, delete split.\n\t(tls_gdld_nomark): Delete.\n\t(call_value_indirect_nonlocal_sysv): Use unspec_tls as operand2\n\tpredicate.  Call rs6000_output_tlsargs.  Adjust length to suit.\n\t(call_value_nonlocal_sysv): Likewise.\n\t(call_value_nonlocal_sysv_secure): Likewise.\n\t(call_value_nonlocal_aix): Likewise.\n\t(call_value_indirect_aix): Likewise.\n\t(call_value_indirect_elfv2): Likewise.\n\t(call_value_local32, call_value_local64): Disable for no-mark tls.\n\t(call_value_local_aix): Likewise.\n\nFrom-SVN: r268135", "tree": {"sha": "6d407662a737be2c080b13ce21e57e82ca668e63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d407662a737be2c080b13ce21e57e82ca668e63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ee09668e64881e1e42a35d13d2bdbb073d75e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ee09668e64881e1e42a35d13d2bdbb073d75e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ee09668e64881e1e42a35d13d2bdbb073d75e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ee09668e64881e1e42a35d13d2bdbb073d75e4/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "106fc1fca96ce122683ab38f0225bd812e354ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106fc1fca96ce122683ab38f0225bd812e354ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106fc1fca96ce122683ab38f0225bd812e354ccf"}], "stats": {"total": 362, "additions": 201, "deletions": 161}, "files": [{"sha": "8f89d653fd77f2d086ac02a0ce3d3db631324244", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -1,3 +1,30 @@\n+2019-01-22  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/88614\n+\t* config/rs6000/predicates.md (unspec_tls): Ensure GOT reg\n+\tstays a reg.  Allow a const_int.\n+\t* config/rs6000/rs6000-protos.h (rs6000_output_tlsargs): Declare.\n+\t* config/rs6000/rs6000.h (IS_V4_FP_ARGS): Define.\n+\t(IS_NOMARK_TLSGETADDR): Define.\n+\t* config/rs6000/rs6000.c (edit_tls_call_insn): Delete.\n+\t(rs6000_output_tlsargs): New function.\n+\t(rs6000_legitimize_tls_address): Don't say a !TARGET_TLS_MARKERS\n+\t__tls_get_addr call takes an arg.\n+\t(rs6000_call_sysv): Generate sysv4 secure plt call pattern here..\n+\t* config/rs6000/rs6000.md (call_nonlocal_sysv): ..rather than here,\n+\tdelete split..\n+\t(call_value_nonlocal_sysv): ..or here, delete split.\n+\t(tls_gdld_nomark): Delete.\n+\t(call_value_indirect_nonlocal_sysv): Use unspec_tls as operand2\n+\tpredicate.  Call rs6000_output_tlsargs.  Adjust length to suit.\n+\t(call_value_nonlocal_sysv): Likewise.\n+\t(call_value_nonlocal_sysv_secure): Likewise.\n+\t(call_value_nonlocal_aix): Likewise.\n+\t(call_value_indirect_aix): Likewise.\n+\t(call_value_indirect_elfv2): Likewise.\n+\t(call_value_local32, call_value_local64): Disable for no-mark tls.\n+\t(call_value_local_aix): Likewise.\n+\n 2019-01-21  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/88938"}, {"sha": "540f45887e64c9cfb909c97a74d2017ff514a5df", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -984,11 +984,18 @@\n   (and (match_code \"symbol_ref\")\n        (match_test \"RS6000_SYMBOL_REF_TLS_P (op)\")))\n \n-;; Return 1 for the UNSPEC used in TLS call operands\n+;; Return 1 for the CONST_INT or UNSPEC second CALL operand.\n+;; Prevents unwanted substitution of the unspec got_reg arg.\n (define_predicate \"unspec_tls\"\n-  (match_code \"unspec\")\n+  (match_code \"const_int,unspec\")\n {\n-  return XINT (op, 1) == UNSPEC_TLSGD || XINT (op, 1) == UNSPEC_TLSLD;\n+  if (CONST_INT_P (op))\n+    return 1;\n+  if (XINT (op, 1) == UNSPEC_TLSGD)\n+    return REG_P (XVECEXP (op, 0, 1));\n+  if (XINT (op, 1) == UNSPEC_TLSLD)\n+    return REG_P (XVECEXP (op, 0, 0));\n+  return 0;\n })\n \n ;; Return 1 if the operand, used inside a MEM, is a valid first argument"}, {"sha": "9af619808acd044d70a16bfc82fae54daf5d833d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -141,6 +141,7 @@ extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,\n \t\t\t\t\t\tbool, bool);\n+extern void rs6000_output_tlsargs (rtx *);\n extern rtx rs6000_find_base_term (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n extern void rs6000_output_symbol_ref (FILE*, rtx);"}, {"sha": "3b31ba9828b5ec55df30ed4485f728379ab6238f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 57, "deletions": 50, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -8626,35 +8626,39 @@ rs6000_legitimize_tls_address_aix (rtx addr, enum tls_model model)\n   return dest;\n }\n \n-/* Mess with a call, to make it look like the tls_gdld insns when\n-   !TARGET_TLS_MARKERS.  These insns have an extra unspec to\n-   differentiate them from standard calls, because they need to emit\n-   the arg setup insns as well as the actual call.  That keeps the\n-   arg setup insns immediately adjacent to the branch and link.  */\n+/* Output arg setup instructions for a !TARGET_TLS_MARKERS\n+   __tls_get_addr call.  */\n \n-static void\n-edit_tls_call_insn (rtx arg)\n-{\n-  rtx call_insn = last_call_insn ();\n-  if (!TARGET_TLS_MARKERS)\n-    {\n-      rtx patt = PATTERN (call_insn);\n-      gcc_assert (GET_CODE (patt) == PARALLEL);\n-      rtvec orig = XVEC (patt, 0);\n-      rtvec v = rtvec_alloc (GET_NUM_ELEM (orig) + 1);\n-      gcc_assert (GET_NUM_ELEM (orig) > 0);\n-      /* The (set (..) (call (mem ..))).  */\n-      RTVEC_ELT (v, 0) = RTVEC_ELT (orig, 0);\n-      /* The extra unspec.  */\n-      RTVEC_ELT (v, 1) = arg;\n-      /* All other assorted call pattern pieces.  */\n-      for (int i = 1; i < GET_NUM_ELEM (orig); i++)\n-\tRTVEC_ELT (v, i + 1) = RTVEC_ELT (orig, i);\n-      XVEC (patt, 0) = v;\n-    }\n-  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n-\t     pic_offset_table_rtx);\n+void\n+rs6000_output_tlsargs (rtx *operands)\n+{\n+  /* Set up operands for output_asm_insn, without modifying OPERANDS.  */\n+  rtx op[3];\n+\n+  /* The set dest of the call, ie. r3, which is also the first arg reg.  */\n+  op[0] = operands[0];\n+  /* The TLS symbol from global_tlsarg stashed as CALL operand 2.  */\n+  op[1] = XVECEXP (operands[2], 0, 0);\n+  if (XINT (operands[2], 1) == UNSPEC_TLSGD)\n+    {\n+      /* The GOT register.  */\n+      op[2] = XVECEXP (operands[2], 0, 1);\n+      if (TARGET_CMODEL != CMODEL_SMALL)\n+\toutput_asm_insn (\"addis %0,%2,%1@got@tlsgd@ha\\n\\t\"\n+\t\t\t \"addi %0,%0,%1@got@tlsgd@l\", op);\n+      else\n+\toutput_asm_insn (\"addi %0,%2,%1@got@tlsgd\", op);\n+    }\n+  else if (XINT (operands[2], 1) == UNSPEC_TLSLD)\n+    {\n+      if (TARGET_CMODEL != CMODEL_SMALL)\n+\toutput_asm_insn (\"addis %0,%1,%&@got@tlsld@ha\\n\\t\"\n+\t\t\t \"addi %0,%0,%&@got@tlsld@l\", op);\n+      else\n+\toutput_asm_insn (\"addi %0,%1,%&@got@tlsld\", op);\n+    }\n+  else\n+    gcc_unreachable ();\n }\n \n /* Passes the tls arg value for global dynamic and local dynamic\n@@ -8757,41 +8761,36 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t{\n \t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, addr, got),\n \t\t\t\t    UNSPEC_TLSGD);\n+\t  tga = rs6000_tls_get_addr ();\n \t  global_tlsarg = arg;\n-\t  rtx argreg = const0_rtx;\n \t  if (TARGET_TLS_MARKERS)\n \t    {\n-\t      argreg = gen_rtx_REG (Pmode, 3);\n+\t      rtx argreg = gen_rtx_REG (Pmode, 3);\n \t      emit_insn (gen_rtx_SET (argreg, arg));\n+\t      emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n+\t\t\t\t       argreg, Pmode);\n \t    }\n-\n-\t  tga = rs6000_tls_get_addr ();\n-\t  emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n-\t\t\t\t   argreg, Pmode);\n+\t  else\n+\t    emit_library_call_value (tga, dest, LCT_CONST, Pmode);\n \t  global_tlsarg = NULL_RTX;\n-\n-\t  edit_tls_call_insn (arg);\n \t}\n       else if (model == TLS_MODEL_LOCAL_DYNAMIC)\n \t{\n-\t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got),\n-\t\t\t\t    UNSPEC_TLSLD);\n+\t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got), UNSPEC_TLSLD);\n+\t  tga = rs6000_tls_get_addr ();\n+\t  tmp1 = gen_reg_rtx (Pmode);\n \t  global_tlsarg = arg;\n-\t  rtx argreg = const0_rtx;\n \t  if (TARGET_TLS_MARKERS)\n \t    {\n-\t      argreg = gen_rtx_REG (Pmode, 3);\n+\t      rtx argreg = gen_rtx_REG (Pmode, 3);\n \t      emit_insn (gen_rtx_SET (argreg, arg));\n+\t      emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n+\t\t\t\t       argreg, Pmode);\n \t    }\n-\n-\t  tga = rs6000_tls_get_addr ();\n-\t  tmp1 = gen_reg_rtx (Pmode);\n-\t  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n-\t\t\t\t   argreg, Pmode);\n+\t  else\n+\t    emit_library_call_value (tga, tmp1, LCT_CONST, Pmode);\n \t  global_tlsarg = NULL_RTX;\n \n-\t  edit_tls_call_insn (arg);\n-\n \t  if (rs6000_tls_size == 16)\n \t    {\n \t      if (TARGET_64BIT)\n@@ -37920,9 +37919,10 @@ rs6000_call_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n   rtx func = func_desc;\n   rtx func_addr;\n-  rtx call[3];\n+  rtx call[4];\n   rtx insn;\n   rtx abi_reg = NULL_RTX;\n+  int n;\n \n   if (global_tlsarg)\n     tlsarg = global_tlsarg;\n@@ -37970,9 +37970,16 @@ rs6000_call_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n     call[0] = gen_rtx_SET (value, call[0]);\n \n   call[1] = gen_rtx_USE (VOIDmode, cookie);\n-  call[2] = gen_hard_reg_clobber (Pmode, LR_REGNO);\n+  n = 2;\n+  if (TARGET_SECURE_PLT\n+      && flag_pic\n+      && GET_CODE (func_addr) == SYMBOL_REF\n+      && !SYMBOL_REF_LOCAL_P (func_addr))\n+    call[n++] = gen_rtx_USE (VOIDmode, pic_offset_table_rtx);\n \n-  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (3, call));\n+  call[n++] = gen_hard_reg_clobber (Pmode, LR_REGNO);\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (n, call));\n   insn = emit_call_insn (insn);\n   if (abi_reg)\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), abi_reg);"}, {"sha": "0281000e5e26371ceab9b575abbfa699893d98ed", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -1489,6 +1489,16 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define CALL_LONG\t\t0x00000008\t/* always call indirect */\n #define CALL_LIBCALL\t\t0x00000010\t/* libcall */\n \n+#define IS_V4_FP_ARGS(OP) \\\n+  ((INTVAL (OP) & (CALL_V4_CLEAR_FP_ARGS | CALL_V4_SET_FP_ARGS)) != 0)\n+\n+/* Whether OP is an UNSPEC used in !TARGET_TLS_MARKER calls.  */\n+#define IS_NOMARK_TLSGETADDR(OP)\t\t\\\n+  (!TARGET_TLS_MARKERS\t\t\t\t\\\n+   && GET_CODE (OP) == UNSPEC\t\t\t\\\n+   && (XINT (OP, 1) == UNSPEC_TLSGD\t\t\\\n+       || XINT (OP, 1) == UNSPEC_TLSLD))\n+\n /* We don't have prologue and epilogue functions to save/restore\n    everything for most ABIs.  */\n #define WORLD_SAVE_P(INFO) 0"}, {"sha": "cbb6bf3a57d520a470a1965d51eb3c20bf487c90", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 96, "deletions": 108, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ee09668e64881e1e42a35d13d2bdbb073d75e4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=61ee09668e64881e1e42a35d13d2bdbb073d75e4", "patch": "@@ -9437,44 +9437,6 @@\n \f\n ;; TLS support.\n \n-(define_insn \"*tls_gdld_nomark<bits>\"\n-  [(match_parallel 3 \"\"\n-    [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-\t  (call (mem:SI (match_operand:P 1))\n-\t\t(match_operand:P 2 \"unspec_tls\")))\n-     (match_dup 2)])]\n-  \"HAVE_AS_TLS && !TARGET_TLS_MARKERS && DEFAULT_ABI != ABI_DARWIN\"\n-{\n-  rtx op[3];\n-  op[0] = operands[0];\n-  op[1] = XVECEXP (operands[2], 0, 0);\n-  if (XINT (operands[2], 1) == UNSPEC_TLSGD)\n-    {\n-      op[2] = XVECEXP (operands[2], 0, 1);\n-      if (TARGET_CMODEL != CMODEL_SMALL)\n-\toutput_asm_insn (\"addis %0,%2,%1@got@tlsgd@ha\\;\"\n-\t\t\t \"addi %0,%0,%1@got@tlsgd@l\", op);\n-      else\n-\toutput_asm_insn (\"addi %0,%2,%1@got@tlsgd\", op);\n-    }\n-  else\n-    {\n-      if (TARGET_CMODEL != CMODEL_SMALL)\n-\toutput_asm_insn (\"addis %0,%1,%&@got@tlsld@ha\\;\"\n-\t\t\t \"addi %0,%0,%&@got@tlsld@l\", op);\n-      else\n-\toutput_asm_insn (\"addi %0,%1,%&@got@tlsld\", op);\n-    }\n-  return rs6000_call_template (operands, 1);\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set (attr \"length\")\n-     (cond [(match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t\t(const_int 16)\n-\t    (match_test \"DEFAULT_ABI != ABI_V4\")\n-\t\t(const_int 12)]\n-\t(const_int 8)))])\n-\n (define_insn_and_split \"*tls_gd<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:P [(match_operand:P 1 \"rs6000_tls_symbol_ref\" \"\")\n@@ -10367,7 +10329,8 @@\n \t      (match_operand 2)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n-  \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"(INTVAL (operands[3]) & CALL_LONG) == 0\n+   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n@@ -10387,7 +10350,8 @@\n \t      (match_operand 2)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:DI LR_REGNO))]\n-  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\n+   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n@@ -10435,7 +10399,7 @@\n \t\t  (const_string \"8\")]\n \t      (const_string \"4\")))])\n \n-(define_insn_and_split \"*call_nonlocal_sysv<mode>\"\n+(define_insn \"*call_nonlocal_sysv<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s,s\"))\n \t (match_operand 1))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n@@ -10451,17 +10415,6 @@\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n   return rs6000_call_template (operands, 0);\n-}\n-  \"DEFAULT_ABI == ABI_V4\n-   && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[0])\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  [(parallel [(call (mem:SI (match_dup 0))\n-\t\t    (match_dup 1))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-{\n-  operands[3] = pic_offset_table_rtx;\n }\n   [(set_attr \"type\" \"branch,branch\")\n    (set_attr \"length\" \"4,8\")])\n@@ -10490,13 +10443,16 @@\n (define_insn \"*call_value_indirect_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n-\t      (match_operand 2)))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n    (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n {\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n@@ -10506,71 +10462,72 @@\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(cond [(and (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t (match_test \"which_alternative != 1\"))\n-\t\t    (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n-\t\t  (const_string \"12\")\n-\t       (ior (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t (match_test \"which_alternative != 1\"))\n-\t\t   (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n-\t\t  (const_string \"8\")]\n-\t      (const_string \"4\")))])\n-\n-(define_insn_and_split \"*call_value_nonlocal_sysv<mode>\"\n+\t(plus\n+\t  (if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t\t\t     (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t    (const_int 4)\n+\t    (const_int 0))\n+\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t     (match_test \"which_alternative != 1\"))\n+\t    (const_int 8)\n+\t    (const_int 4))))])\n+\n+(define_insn \"*call_value_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s,s\"))\n-\t      (match_operand 2)))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n\"))\n    (clobber (reg:P LR_REGNO))]\n   \"(DEFAULT_ABI == ABI_DARWIN\n-   || (DEFAULT_ABI == ABI_V4\n-       && (INTVAL (operands[3]) & CALL_LONG) == 0))\"\n+    || (DEFAULT_ABI == ABI_V4\n+\t&& (INTVAL (operands[3]) & CALL_LONG) == 0))\"\n {\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n   return rs6000_call_template (operands, 1);\n }\n-  \"DEFAULT_ABI == ABI_V4\n-   && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[1])\n-   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (call (mem:SI (match_dup 1))\n-\t\t\t (match_dup 2)))\n-\t      (use (match_dup 3))\n-\t      (use (match_dup 4))\n-\t      (clobber (reg:SI LR_REGNO))])]\n-{\n-  operands[4] = pic_offset_table_rtx;\n-}\n-  [(set_attr \"type\" \"branch,branch\")\n-   (set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t\t\t   (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t  (const_int 8)\n+\t  (const_int 4)))])\n \n (define_insn \"*call_value_nonlocal_sysv_secure<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s,s\"))\n-\t      (match_operand 2)))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (use (match_operand:SI 4 \"register_operand\" \"r,r\"))\n+\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n\"))\n+   (use (match_operand:SI 4 \"register_operand\" \"r\"))\n    (clobber (reg:P LR_REGNO))]\n   \"(DEFAULT_ABI == ABI_V4\n     && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[1])\n     && (INTVAL (operands[3]) & CALL_LONG) == 0)\"\n {\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n   return rs6000_call_template (operands, 1);\n }\n-  [(set_attr \"type\" \"branch,branch\")\n-   (set_attr \"length\" \"4,8\")])\n-\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t\t\t   (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t  (const_int 8)\n+\t  (const_int 4)))])\n \n ;; Call to AIX abi function in the same module.\n \n@@ -10587,7 +10544,8 @@\n \t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s\"))\n \t      (match_operand 2)))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n   \"bl %z1\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -10608,14 +10566,22 @@\n (define_insn \"*call_value_nonlocal_aix<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2)))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n   return rs6000_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n+   (set (attr \"length\")\n+\t(if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t  (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t    (const_int 16)\n+\t    (const_int 12))\n+\t  (const_int 8)))])\n \n ;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n ;; Operand0 is the addresss of the function to call\n@@ -10642,20 +10608,31 @@\n (define_insn \"*call_value_indirect_aix<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n-\t      (match_operand 2)))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n    (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n+   (set (reg:P TOC_REGNUM)\n+\t(unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")]\n+\t\t  UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n {\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n   return rs6000_indirect_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t   (match_test \"which_alternative != 1\"))\n-\t\t      (const_string \"16\")\n-\t\t      (const_string \"12\")))])\n+\t(plus\n+\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t      (const_int 8)\n+\t      (const_int 4))\n+\t    (const_int 0))\n+\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t     (match_test \"which_alternative != 1\"))\n+\t    (const_string \"16\")\n+\t    (const_string \"12\"))))])\n \n ;; Call to indirect functions with the ELFv2 ABI.\n ;; Operand0 is the addresss of the function to call\n@@ -10680,19 +10657,30 @@\n (define_insn \"*call_value_indirect_elfv2<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n-\t      (match_operand 2)))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (set (reg:P TOC_REGNUM)\n+\t(unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")]\n+\t\t  UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n {\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n   return rs6000_indirect_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t   (match_test \"which_alternative != 1\"))\n-\t\t      (const_string \"12\")\n-\t\t      (const_string \"8\")))])\n+\t(plus\n+\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t      (const_int 8)\n+\t      (const_int 4))\n+\t    (const_int 0))\n+\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t     (match_test \"which_alternative != 1\"))\n+\t    (const_string \"12\")\n+\t    (const_string \"8\"))))])\n \n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\""}]}