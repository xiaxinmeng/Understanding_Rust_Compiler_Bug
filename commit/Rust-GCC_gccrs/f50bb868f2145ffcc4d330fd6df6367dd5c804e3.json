{"sha": "f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwYmI4NjhmMjE0NWZmY2M0ZDMzMGZkNmRmNjM2N2RkNWM4MDRlMw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2015-11-11T12:28:37Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2015-11-11T12:28:37Z"}, "message": "arc-common.c (arc_handle_option): Handle ARCv2 options.\n\n2015-11-11  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* common/config/arc/arc-common.c (arc_handle_option): Handle ARCv2\n\toptions.\n\t* config/arc/arc-opts.h: Add ARCv2 CPUs.\n\t* config/arc/arc-protos.h (arc_secondary_reload_conv): Prototype.\n\t* config/arc/arc.c (arc_secondary_reload): Handle subreg (reg)\n\tsituation, and store instructions with large offsets.\n\t(arc_secondary_reload_conv): New function.\n\t(arc_init): Add ARCv2 options.\n\t(arc_conditional_register_usage): Select the proper register usage\n\tfor ARCv2 processors.\n\t(arc_handle_interrupt_attribute): ILINK2 is only valid for ARCv1\n\tarchitecture.\n\t(arc_compute_function_type): Likewise.\n\t(arc_print_operand): Handle new ARCv2 punctuation characters.\n\t(arc_return_in_memory): ARCv2 ABI returns in registers up to 16\n\tbytes.\n\t(workaround_arc_anomaly, arc_asm_insn_p, arc_loop_hazard): New\n\tfunction.\n\t(arc_reorg, arc_hazard): Use it.\n\t* config/arc/arc.h (TARGET_CPU_CPP_BUILTINS): Define __HS__ and\n\t__EM__.\n\t(ASM_SPEC): Add ARCv2 options.\n\t(TARGET_NORM): ARC HS has norm instructions by default.\n\t(TARGET_OPTFPE): Use optimized floating point emulation for ARC\n\tHS.\n\t(TARGET_AT_DBR_CONDEXEC): Only for ARC600 family.\n\t(TARGET_EM, TARGET_HS, TARGET_V2, TARGET_MPYW, TARGET_MULTI):\n\tDefine.\n\t(SIGNED_INT16, TARGET_MPY, TARGET_ARC700_MPY, TARGET_ANY_MPY):\n\tLikewise.\n\t(TARGET_ARC600_FAMILY, TARGET_ARCOMPACT_FAMILY): Likewise.\n\t(TARGET_LP_WR_INTERLOCK): Likewise.\n\t* config/arc/arc.md\n\t(commutative_binary_mult_comparison_result_used, movsicc_insn)\n\t(mulsi3, mulsi3_600_lib, mulsidi3, mulsidi3_700, mulsi3_highpart)\n\t(umulsi3_highpart_i, umulsi3_highpart_int, umulsi3_highpart)\n\t(umulsidi3, umulsidi3_700, cstoresi4, simple_return, p_return_i):\n\tUse it for ARCv2.\n\t(mulhisi3, mulhisi3_imm, mulhisi3_reg, umulhisi3, umulhisi3_imm)\n\t(umulhisi3_reg, umulhisi3_reg, mulsi3_v2, nopv, bswapsi2)\n\t(prefetch, divsi3, udivsi3 modsi3, umodsi3, arcset, arcsetltu)\n\t(arcsetgeu, arcsethi, arcsetls, reload_*_load, reload_*_store)\n\t(extzvsi): New pattern.\n\t* config/arc/arc.opt: New ARCv2 options.\n\t* config/arc/arcEM.md: New file.\n\t* config/arc/arcHS.md: Likewise.\n\t* config/arc/constraints.md (C3p): New constraint, accepts 1 and 2\n\tvalues.\n\t(Cm2): A signed 9-bit integer constant constraint.\n\t(C62): An unsigned 6-bit integer constant constraint.\n\t(C16): A signed 16-bit integer constant constraint.\n\t* config/arc/predicates.md (mult_operator): Add ARCv2 processort.\n\t(short_const_int_operand): New predicate.\n\t* config/arc/t-arc-newlib: Add ARCv2 multilib options.\n\t* doc/invoke.texi: Add documentation for -mcpu=<archs/arcem>\n\t-mcode-density and -mdiv-rem.\n\nFrom-SVN: r230156", "tree": {"sha": "466ff01e94e8f34086de16d5ae3ca4fe2b1b879e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/466ff01e94e8f34086de16d5ae3ca4fe2b1b879e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e0c852bf27917d9e425b3d795b6ac8c45404bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0c852bf27917d9e425b3d795b6ac8c45404bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0c852bf27917d9e425b3d795b6ac8c45404bcd"}], "stats": {"total": 1368, "additions": 1224, "deletions": 144}, "files": [{"sha": "8946e68c95e3fea488285e1c795539563a805064", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -1,3 +1,62 @@\n+2015-11-11  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* common/config/arc/arc-common.c (arc_handle_option): Handle ARCv2\n+\toptions.\n+\t* config/arc/arc-opts.h: Add ARCv2 CPUs.\n+\t* config/arc/arc-protos.h (arc_secondary_reload_conv): Prototype.\n+\t* config/arc/arc.c (arc_secondary_reload): Handle subreg (reg)\n+\tsituation, and store instructions with large offsets.\n+\t(arc_secondary_reload_conv): New function.\n+\t(arc_init): Add ARCv2 options.\n+\t(arc_conditional_register_usage): Select the proper register usage\n+\tfor ARCv2 processors.\n+\t(arc_handle_interrupt_attribute): ILINK2 is only valid for ARCv1\n+\tarchitecture.\n+\t(arc_compute_function_type): Likewise.\n+\t(arc_print_operand): Handle new ARCv2 punctuation characters.\n+\t(arc_return_in_memory): ARCv2 ABI returns in registers up to 16\n+\tbytes.\n+\t(workaround_arc_anomaly, arc_asm_insn_p, arc_loop_hazard): New\n+\tfunction.\n+\t(arc_reorg, arc_hazard): Use it.\n+\t* config/arc/arc.h (TARGET_CPU_CPP_BUILTINS): Define __HS__ and\n+\t__EM__.\n+\t(ASM_SPEC): Add ARCv2 options.\n+\t(TARGET_NORM): ARC HS has norm instructions by default.\n+\t(TARGET_OPTFPE): Use optimized floating point emulation for ARC\n+\tHS.\n+\t(TARGET_AT_DBR_CONDEXEC): Only for ARC600 family.\n+\t(TARGET_EM, TARGET_HS, TARGET_V2, TARGET_MPYW, TARGET_MULTI):\n+\tDefine.\n+\t(SIGNED_INT16, TARGET_MPY, TARGET_ARC700_MPY, TARGET_ANY_MPY):\n+\tLikewise.\n+\t(TARGET_ARC600_FAMILY, TARGET_ARCOMPACT_FAMILY): Likewise.\n+\t(TARGET_LP_WR_INTERLOCK): Likewise.\n+\t* config/arc/arc.md\n+\t(commutative_binary_mult_comparison_result_used, movsicc_insn)\n+\t(mulsi3, mulsi3_600_lib, mulsidi3, mulsidi3_700, mulsi3_highpart)\n+\t(umulsi3_highpart_i, umulsi3_highpart_int, umulsi3_highpart)\n+\t(umulsidi3, umulsidi3_700, cstoresi4, simple_return, p_return_i):\n+\tUse it for ARCv2.\n+\t(mulhisi3, mulhisi3_imm, mulhisi3_reg, umulhisi3, umulhisi3_imm)\n+\t(umulhisi3_reg, umulhisi3_reg, mulsi3_v2, nopv, bswapsi2)\n+\t(prefetch, divsi3, udivsi3 modsi3, umodsi3, arcset, arcsetltu)\n+\t(arcsetgeu, arcsethi, arcsetls, reload_*_load, reload_*_store)\n+\t(extzvsi): New pattern.\n+\t* config/arc/arc.opt: New ARCv2 options.\n+\t* config/arc/arcEM.md: New file.\n+\t* config/arc/arcHS.md: Likewise.\n+\t* config/arc/constraints.md (C3p): New constraint, accepts 1 and 2\n+\tvalues.\n+\t(Cm2): A signed 9-bit integer constant constraint.\n+\t(C62): An unsigned 6-bit integer constant constraint.\n+\t(C16): A signed 16-bit integer constant constraint.\n+\t* config/arc/predicates.md (mult_operator): Add ARCv2 processort.\n+\t(short_const_int_operand): New predicate.\n+\t* config/arc/t-arc-newlib: Add ARCv2 multilib options.\n+\t* doc/invoke.texi: Add documentation for -mcpu=<archs/arcem>\n+\t-mcode-density and -mdiv-rem.\n+\n 2015-11-11  Julia Koval  <julia.koval@intel.com>\n \n \t* config/i386/i386.c (m_SKYLAKE_AVX512): Fix typo."}, {"sha": "c06f488d285ff1b0565f8c66baced57a5cef168e", "filename": "gcc/common/config/arc/arc-common.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -33,7 +33,7 @@ arc_option_init_struct (struct gcc_options *opts)\n {\n   opts->x_flag_no_common = 255; /* Mark as not user-initialized.  */\n \n-  /* Which cpu we're compiling for (ARC600, ARC601, ARC700).  */\n+  /* Which cpu we're compiling for (ARC600, ARC601, ARC700, ARCv2).  */\n   arc_cpu = PROCESSOR_NONE;\n }\n \n@@ -68,6 +68,7 @@ arc_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n {\n   size_t code = decoded->opt_index;\n   int value = decoded->value;\n+  const char *arg = decoded->arg;\n \n   switch (code)\n     {\n@@ -91,9 +92,40 @@ arc_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t  if (! (opts_set->x_target_flags & MASK_BARREL_SHIFTER) )\n \t    opts->x_target_flags &= ~MASK_BARREL_SHIFTER;\n \t  break;\n+\tcase PROCESSOR_ARCHS:\n+\t  if ( !(opts_set->x_target_flags & MASK_BARREL_SHIFTER))\n+\t    opts->x_target_flags |= MASK_BARREL_SHIFTER;  /* Default: on.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_CODE_DENSITY))\n+\t    opts->x_target_flags |= MASK_CODE_DENSITY;\t  /* Default: on.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_NORM_SET))\n+\t    opts->x_target_flags |= MASK_NORM_SET;\t  /* Default: on.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_SWAP_SET))\n+\t    opts->x_target_flags |= MASK_SWAP_SET;\t  /* Default: on.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_DIVREM))\n+\t    opts->x_target_flags |= MASK_DIVREM;\t  /* Default: on.  */\n+\t  break;\n+\n+\tcase PROCESSOR_ARCEM:\n+\t  if ( !(opts_set->x_target_flags & MASK_BARREL_SHIFTER))\n+\t    opts->x_target_flags |= MASK_BARREL_SHIFTER;  /* Default: on.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_CODE_DENSITY))\n+\t    opts->x_target_flags &= ~MASK_CODE_DENSITY;\t  /* Default: off.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_NORM_SET))\n+\t    opts->x_target_flags &= ~MASK_NORM_SET;\t  /* Default: off.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_SWAP_SET))\n+\t    opts->x_target_flags &= ~MASK_SWAP_SET;\t  /* Default: off.  */\n+\t  if ( !(opts_set->x_target_flags & MASK_DIVREM))\n+\t    opts->x_target_flags &= ~MASK_DIVREM;\t  /* Default: off.  */\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      break;\n+\n+    case OPT_mmpy_option_:\n+      if (value < 0 || value > 9)\n+\terror_at (loc, \"bad value %qs for -mmpy-option switch\", arg);\n+      break;\n     }\n \n   return true;"}, {"sha": "a33f4b775216d6af9be8757e3ab31a0c3eeb6b7e", "filename": "gcc/config/arc/arc-opts.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-opts.h?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -23,5 +23,7 @@ enum processor_type\n   PROCESSOR_NONE,\n   PROCESSOR_ARC600,\n   PROCESSOR_ARC601,\n-  PROCESSOR_ARC700\n+  PROCESSOR_ARC700,\n+  PROCESSOR_ARCEM,\n+  PROCESSOR_ARCHS\n };"}, {"sha": "6e04351159b2c703d7aff3fcda4f955457193bda", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -118,3 +118,4 @@ extern bool arc_epilogue_uses (int regno);\n extern int regno_clobbered_p (unsigned int, rtx_insn *, machine_mode, int);\n extern int arc_return_slot_offset (void);\n extern bool arc_legitimize_reload_address (rtx *, machine_mode, int, int);\n+extern void arc_secondary_reload_conv (rtx, rtx, rtx, bool);"}, {"sha": "85d53e4d2e34bea2de200a4fb0294ee42a9b54ff", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 310, "deletions": 40, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -590,20 +590,113 @@ arc_sched_adjust_priority (rtx_insn *insn, int priority)\n   return priority;\n }\n \n+/* For ARC base register + offset addressing, the validity of the\n+   address is mode-dependent for most of the offset range, as the\n+   offset can be scaled by the access size.\n+   We don't expose these as mode-dependent addresses in the\n+   mode_dependent_address_p target hook, because that would disable\n+   lots of optimizations, and most uses of these addresses are for 32\n+   or 64 bit accesses anyways, which are fine.\n+   However, that leaves some addresses for 8 / 16 bit values not\n+   properly reloaded by the generic code, which is why we have to\n+   schedule secondary reloads for these.  */\n+\n static reg_class_t\n-arc_secondary_reload (bool in_p, rtx x, reg_class_t cl, machine_mode,\n-\t\t      secondary_reload_info *)\n+arc_secondary_reload (bool in_p,\n+\t\t      rtx x,\n+\t\t      reg_class_t cl,\n+\t\t      machine_mode mode,\n+\t\t      secondary_reload_info *sri)\n {\n+  enum rtx_code code = GET_CODE (x);\n+\n   if (cl == DOUBLE_REGS)\n     return GENERAL_REGS;\n \n   /* The loop counter register can be stored, but not loaded directly.  */\n   if ((cl == LPCOUNT_REG || cl == WRITABLE_CORE_REGS)\n       && in_p && MEM_P (x))\n     return GENERAL_REGS;\n+\n+ /* If we have a subreg (reg), where reg is a pseudo (that will end in\n+    a memory location), then we may need a scratch register to handle\n+    the fp/sp+largeoffset address.  */\n+  if (code == SUBREG)\n+    {\n+      rtx addr = NULL_RTX;\n+      x = SUBREG_REG (x);\n+\n+      if (REG_P (x))\n+\t{\n+\t  int regno = REGNO (x);\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t    regno = reg_renumber[regno];\n+\n+\t  if (regno != -1)\n+\t    return NO_REGS;\n+\n+\t  /* It is a pseudo that ends in a stack location.  */\n+\t  if (reg_equiv_mem (REGNO (x)))\n+\t    {\n+\t      /* Get the equivalent address and check the range of the\n+\t\t offset.  */\n+\t      rtx mem = reg_equiv_mem (REGNO (x));\n+\t      addr = find_replacement (&XEXP (mem, 0));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (MEM_P (x));\n+\t  addr = XEXP (x, 0);\n+\t  addr = simplify_rtx (addr);\n+\t}\n+      if (addr && GET_CODE (addr) == PLUS\n+\t  && CONST_INT_P (XEXP (addr, 1))\n+\t  && (!RTX_OK_FOR_OFFSET_P (mode, XEXP (addr, 1))))\n+\t{\n+\t  switch (mode)\n+\t    {\n+\t    case QImode:\n+\t      sri->icode =\n+\t\tin_p ? CODE_FOR_reload_qi_load : CODE_FOR_reload_qi_store;\n+\t      break;\n+\t    case HImode:\n+\t      sri->icode =\n+\t\tin_p ? CODE_FOR_reload_hi_load : CODE_FOR_reload_hi_store;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n   return NO_REGS;\n }\n \n+/* Convert reloads using offsets that are too large to use indirect\n+   addressing.  */\n+\n+void\n+arc_secondary_reload_conv (rtx reg, rtx mem, rtx scratch, bool store_p)\n+{\n+  rtx addr;\n+\n+  gcc_assert (GET_CODE (mem) == MEM);\n+  addr = XEXP (mem, 0);\n+\n+  /* Large offset: use a move.  FIXME: ld ops accepts limms as\n+     offsets.  Hence, the following move insn is not required.  */\n+  emit_move_insn (scratch, addr);\n+  mem = replace_equiv_address_nv (mem, scratch);\n+\n+  /* Now create the move.  */\n+  if (store_p)\n+    emit_insn (gen_rtx_SET (mem, reg));\n+  else\n+    emit_insn (gen_rtx_SET (reg, mem));\n+\n+  return;\n+}\n+\n static unsigned arc_ifcvt (void);\n \n namespace {\n@@ -687,23 +780,35 @@ arc_init (void)\n {\n   enum attr_tune tune_dflt = TUNE_NONE;\n \n-  if (TARGET_ARC600)\n+  switch (arc_cpu)\n     {\n+    case PROCESSOR_ARC600:\n       arc_cpu_string = \"ARC600\";\n       tune_dflt = TUNE_ARC600;\n-    }\n-  else if (TARGET_ARC601)\n-    {\n+      break;\n+\n+    case PROCESSOR_ARC601:\n       arc_cpu_string = \"ARC601\";\n       tune_dflt = TUNE_ARC600;\n-    }\n-  else if (TARGET_ARC700)\n-    {\n+      break;\n+\n+    case PROCESSOR_ARC700:\n       arc_cpu_string = \"ARC700\";\n       tune_dflt = TUNE_ARC700_4_2_STD;\n+      break;\n+\n+    case PROCESSOR_ARCEM:\n+      arc_cpu_string = \"EM\";\n+      break;\n+\n+    case PROCESSOR_ARCHS:\n+      arc_cpu_string = \"HS\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    gcc_unreachable ();\n+\n   if (arc_tune == TUNE_NONE)\n     arc_tune = tune_dflt;\n   /* Note: arc_multcost is only used in rtx_cost if speed is true.  */\n@@ -737,15 +842,15 @@ arc_init (void)\n       }\n \n   /* Support mul64 generation only for ARC600.  */\n-  if (TARGET_MUL64_SET && TARGET_ARC700)\n-      error (\"-mmul64 not supported for ARC700\");\n+  if (TARGET_MUL64_SET && (!TARGET_ARC600_FAMILY))\n+      error (\"-mmul64 not supported for ARC700 or ARCv2\");\n \n-  /* MPY instructions valid only for ARC700.  */\n-  if (TARGET_NOMPY_SET && !TARGET_ARC700)\n-      error (\"-mno-mpy supported only for ARC700\");\n+  /* MPY instructions valid only for ARC700 or ARCv2.  */\n+  if (TARGET_NOMPY_SET && TARGET_ARC600_FAMILY)\n+      error (\"-mno-mpy supported only for ARC700 or ARCv2\");\n \n   /* mul/mac instructions only for ARC600.  */\n-  if (TARGET_MULMAC_32BY16_SET && !(TARGET_ARC600 || TARGET_ARC601))\n+  if (TARGET_MULMAC_32BY16_SET && (!TARGET_ARC600_FAMILY))\n       error (\"-mmul32x16 supported only for ARC600 or ARC601\");\n \n   if (!TARGET_DPFP && TARGET_DPFP_DISABLE_LRSR)\n@@ -757,18 +862,25 @@ arc_init (void)\n     error (\"FPX fast and compact options cannot be specified together\");\n \n   /* FPX-2. No fast-spfp for arc600 or arc601.  */\n-  if (TARGET_SPFP_FAST_SET && (TARGET_ARC600 || TARGET_ARC601))\n+  if (TARGET_SPFP_FAST_SET && TARGET_ARC600_FAMILY)\n     error (\"-mspfp_fast not available on ARC600 or ARC601\");\n \n   /* FPX-3. No FPX extensions on pre-ARC600 cores.  */\n   if ((TARGET_DPFP || TARGET_SPFP)\n-      && !(TARGET_ARC600 || TARGET_ARC601 || TARGET_ARC700))\n+      && !TARGET_ARCOMPACT_FAMILY)\n     error (\"FPX extensions not available on pre-ARC600 cores\");\n \n+  /* Only selected multiplier configurations are available for HS.  */\n+  if (TARGET_HS && ((arc_mpy_option > 2 && arc_mpy_option < 7)\n+\t\t    || (arc_mpy_option == 1)))\n+    error (\"This multiplier configuration is not available for HS cores\");\n+\n   /* Warn for unimplemented PIC in pre-ARC700 cores, and disable flag_pic.  */\n-  if (flag_pic && !TARGET_ARC700)\n+  if (flag_pic && TARGET_ARC600_FAMILY)\n     {\n-      warning (DK_WARNING, \"PIC is not supported for %s. Generating non-PIC code only..\", arc_cpu_string);\n+      warning (DK_WARNING,\n+\t       \"PIC is not supported for %s. Generating non-PIC code only..\",\n+\t       arc_cpu_string);\n       flag_pic = 0;\n     }\n \n@@ -782,6 +894,8 @@ arc_init (void)\n   arc_punct_chars['!'] = 1;\n   arc_punct_chars['^'] = 1;\n   arc_punct_chars['&'] = 1;\n+  arc_punct_chars['+'] = 1;\n+  arc_punct_chars['_'] = 1;\n \n   if (optimize > 1 && !TARGET_NO_COND_EXEC)\n     {\n@@ -825,7 +939,7 @@ arc_override_options (void)\n   if (flag_no_common == 255)\n     flag_no_common = !TARGET_NO_SDATA_SET;\n \n-  /* TARGET_COMPACT_CASESI needs the \"q\" register class.  */ \\\n+  /* TARGET_COMPACT_CASESI needs the \"q\" register class.  */\n   if (TARGET_MIXED_CODE)\n     TARGET_Q_CLASS = 1;\n   if (!TARGET_Q_CLASS)\n@@ -1198,6 +1312,8 @@ arc_init_reg_tables (void)\n   char rname57[5] = \"r57\";\n   char rname58[5] = \"r58\";\n   char rname59[5] = \"r59\";\n+  char rname29[7] = \"ilink1\";\n+  char rname30[7] = \"ilink2\";\n \n static void\n arc_conditional_register_usage (void)\n@@ -1206,6 +1322,14 @@ arc_conditional_register_usage (void)\n   int i;\n   int fix_start = 60, fix_end = 55;\n \n+  if (TARGET_V2)\n+    {\n+      /* For ARCv2 the core register set is changed.  */\n+      strcpy (rname29, \"ilink\");\n+      strcpy (rname30, \"r30\");\n+      fixed_regs[30] = call_used_regs[30] = 1;\n+   }\n+\n   if (TARGET_MUL64_SET)\n     {\n       fix_start = 57;\n@@ -1271,15 +1395,15 @@ arc_conditional_register_usage (void)\n      machine_dependent_reorg.  */\n   if (TARGET_ARC600)\n     CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], LP_COUNT);\n-  else if (!TARGET_ARC700)\n+  else if (!TARGET_LP_WR_INTERLOCK)\n     fixed_regs[LP_COUNT] = 1;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!call_used_regs[regno])\n       CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\n   for (regno = 32; regno < 60; regno++)\n     if (!fixed_regs[regno])\n       SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], regno);\n-  if (TARGET_ARC700)\n+  if (!TARGET_ARC600_FAMILY)\n     {\n       for (regno = 32; regno <= 60; regno++)\n \tCLEAR_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], regno);\n@@ -1313,7 +1437,7 @@ arc_conditional_register_usage (void)\n \t  = (fixed_regs[i]\n \t     ? (TEST_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], i)\n \t\t? CHEAP_CORE_REGS : ALL_CORE_REGS)\n-\t     : ((TARGET_ARC700\n+\t     : (((!TARGET_ARC600_FAMILY)\n \t\t && TEST_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], i))\n \t\t? CHEAP_CORE_REGS : WRITABLE_CORE_REGS));\n       else\n@@ -1331,7 +1455,8 @@ arc_conditional_register_usage (void)\n \n   /* Handle Special Registers.  */\n   arc_regno_reg_class[29] = LINK_REGS; /* ilink1 register.  */\n-  arc_regno_reg_class[30] = LINK_REGS; /* ilink2 register.  */\n+  if (!TARGET_V2)\n+    arc_regno_reg_class[30] = LINK_REGS; /* ilink2 register.  */\n   arc_regno_reg_class[31] = LINK_REGS; /* blink register.  */\n   arc_regno_reg_class[60] = LPCOUNT_REG;\n   arc_regno_reg_class[61] = NO_REGS;      /* CC_REG: must be NO_REGS.  */\n@@ -1413,13 +1538,23 @@ arc_handle_interrupt_attribute (tree *, tree name, tree args, int,\n       *no_add_attrs = true;\n     }\n   else if (strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n-\t   && strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n+\t   && strcmp (TREE_STRING_POINTER (value), \"ilink2\")\n+\t   && !TARGET_V2)\n     {\n       warning (OPT_Wattributes,\n \t       \"argument of %qE attribute is not \\\"ilink1\\\" or \\\"ilink2\\\"\",\n \t       name);\n       *no_add_attrs = true;\n     }\n+  else if (TARGET_V2\n+\t   && strcmp (TREE_STRING_POINTER (value), \"ilink\"))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"argument of %qE attribute is not \\\"ilink\\\"\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -1931,7 +2066,8 @@ arc_compute_function_type (struct function *fun)\n \t{\n \t  tree value = TREE_VALUE (args);\n \n-\t  if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\"))\n+\t  if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n+\t      || !strcmp (TREE_STRING_POINTER (value), \"ilink\"))\n \t    fn_type = ARC_FUNCTION_ILINK1;\n \t  else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n \t    fn_type = ARC_FUNCTION_ILINK2;\n@@ -3115,6 +3251,18 @@ arc_print_operand (FILE *file, rtx x, int code)\n       if (TARGET_ANNOTATE_ALIGN && cfun->machine->size_reason)\n \tfprintf (file, \"; unalign: %d\", cfun->machine->unalign);\n       return;\n+    case '+':\n+      if (TARGET_V2)\n+\tfputs (\"m\", file);\n+      else\n+\tfputs (\"h\", file);\n+      return;\n+    case '_':\n+      if (TARGET_V2)\n+\tfputs (\"h\", file);\n+      else\n+\tfputs (\"w\", file);\n+      return;\n     default :\n       /* Unknown flag.  */\n       output_operand_lossage (\"invalid operand output code\");\n@@ -4224,7 +4372,7 @@ arc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t*total= arc_multcost;\n       /* We do not want synth_mult sequences when optimizing\n \t for size.  */\n-      else if (TARGET_MUL64_SET || (TARGET_ARC700 && !TARGET_NOMPY_SET))\n+      else if (TARGET_MUL64_SET || TARGET_ARC700_MPY)\n \t*total = COSTS_N_INSNS (1);\n       else\n \t*total = COSTS_N_INSNS (2);\n@@ -5639,7 +5787,7 @@ arc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   else\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n-      return (size == -1 || size > 8);\n+      return (size == -1 || size > (TARGET_V2 ? 16 : 8));\n     }\n }\n \n@@ -5737,6 +5885,26 @@ arc_invalid_within_doloop (const rtx_insn *insn)\n   return NULL;\n }\n \n+/* The same functionality as arc_hazard.  It is called in machine\n+   reorg before any other optimization.  Hence, the NOP size is taken\n+   into account when doing branch shortening.  */\n+\n+static void\n+workaround_arc_anomaly (void)\n+{\n+  rtx_insn *insn, *succ0;\n+\n+  /* For any architecture: call arc_hazard here.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      succ0 = next_real_insn (insn);\n+      if (arc_hazard (insn, succ0))\n+\t{\n+\t  emit_insn_before (gen_nopv (), succ0);\n+\t}\n+    }\n+}\n+\n static int arc_reorg_in_progress = 0;\n \n /* ARC's machince specific reorg function.  */\n@@ -5750,6 +5918,8 @@ arc_reorg (void)\n   long offset;\n   int changed;\n \n+  workaround_arc_anomaly ();\n+\n   cfun->machine->arc_reorg_started = 1;\n   arc_reorg_in_progress = 1;\n \n@@ -7758,6 +7928,109 @@ arc600_corereg_hazard (rtx_insn *pred, rtx_insn *succ)\n   return 0;\n }\n \n+/* Given a rtx, check if it is an assembly instruction or not.  */\n+\n+static int\n+arc_asm_insn_p (rtx x)\n+{\n+  int i, j;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case ASM_OPERANDS:\n+    case ASM_INPUT:\n+      return 1;\n+\n+    case SET:\n+      return arc_asm_insn_p (SET_SRC (x));\n+\n+    case PARALLEL:\n+      j = 0;\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\tj += arc_asm_insn_p (XVECEXP (x, 0, i));\n+      if ( j > 0)\n+\treturn 1;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* We might have a CALL to a non-returning function before a loop end.\n+   ??? Although the manual says that's OK (the target is outside the\n+   loop, and the loop counter unused there), the assembler barfs on\n+   this for ARC600, so we must insert a nop before such a call too.\n+   For ARC700, and ARCv2 is not allowed to have the last ZOL\n+   instruction a jump to a location where lp_count is modified.  */\n+\n+static bool\n+arc_loop_hazard (rtx_insn *pred, rtx_insn *succ)\n+{\n+  rtx_insn *jump  = NULL;\n+  rtx_insn *label = NULL;\n+  basic_block succ_bb;\n+\n+  if (recog_memoized (succ) != CODE_FOR_doloop_end_i)\n+    return false;\n+\n+  /* Phase 1: ARC600 and ARCv2HS doesn't allow any control instruction\n+     (i.e., jump/call) as the last instruction of a ZOL.  */\n+  if (TARGET_ARC600 || TARGET_HS)\n+    if (JUMP_P (pred) || CALL_P (pred)\n+\t|| arc_asm_insn_p (PATTERN (pred))\n+\t|| GET_CODE (PATTERN (pred)) == SEQUENCE)\n+      return true;\n+\n+  /* Phase 2: Any architecture, it is not allowed to have the last ZOL\n+     instruction a jump to a location where lp_count is modified.  */\n+\n+  /* Phase 2a: Dig for the jump instruction.  */\n+  if (JUMP_P (pred))\n+    jump = pred;\n+  else if (GET_CODE (PATTERN (pred)) == SEQUENCE\n+\t   && JUMP_P (XVECEXP (PATTERN (pred), 0, 0)))\n+    jump = as_a <rtx_insn *> XVECEXP (PATTERN (pred), 0, 0);\n+  else\n+    return false;\n+\n+  label = JUMP_LABEL_AS_INSN (jump);\n+  if (!label)\n+    return false;\n+\n+  /* Phase 2b: Make sure is not a millicode jump.  */\n+  if ((GET_CODE (PATTERN (jump)) == PARALLEL)\n+      && (XVECEXP (PATTERN (jump), 0, 0) == ret_rtx))\n+    return false;\n+\n+  /* Phase 2c: Make sure is not a simple_return.  */\n+  if ((GET_CODE (PATTERN (jump)) == SIMPLE_RETURN)\n+      || (GET_CODE (label) == SIMPLE_RETURN))\n+    return false;\n+\n+  /* Pahse 2d: Go to the target of the jump and check for aliveness of\n+     LP_COUNT register.  */\n+  succ_bb = BLOCK_FOR_INSN (label);\n+  if (!succ_bb)\n+    {\n+      gcc_assert (NEXT_INSN (label));\n+      if (NOTE_INSN_BASIC_BLOCK_P (NEXT_INSN (label)))\n+\tsucc_bb = NOTE_BASIC_BLOCK (NEXT_INSN (label));\n+      else\n+\tsucc_bb = BLOCK_FOR_INSN (NEXT_INSN (label));\n+    }\n+\n+  if (succ_bb && REGNO_REG_SET_P (df_get_live_out (succ_bb), LP_COUNT))\n+    return true;\n+\n+  return false;\n+}\n+\n /* For ARC600:\n    A write to a core reg greater or equal to 32 must not be immediately\n    followed by a use.  Anticipate the length requirement to insert a nop\n@@ -7766,19 +8039,16 @@ arc600_corereg_hazard (rtx_insn *pred, rtx_insn *succ)\n int\n arc_hazard (rtx_insn *pred, rtx_insn *succ)\n {\n-  if (!TARGET_ARC600)\n-    return 0;\n   if (!pred || !INSN_P (pred) || !succ || !INSN_P (succ))\n     return 0;\n-  /* We might have a CALL to a non-returning function before a loop end.\n-     ??? Although the manual says that's OK (the target is outside the loop,\n-     and the loop counter unused there), the assembler barfs on this, so we\n-     must instert a nop before such a call too.  */\n-  if (recog_memoized (succ) == CODE_FOR_doloop_end_i\n-      && (JUMP_P (pred) || CALL_P (pred)\n-\t  || GET_CODE (PATTERN (pred)) == SEQUENCE))\n+\n+  if (arc_loop_hazard (pred, succ))\n     return 4;\n-  return arc600_corereg_hazard (pred, succ);\n+\n+  if (TARGET_ARC600)\n+    return arc600_corereg_hazard (pred, succ);\n+\n+  return 0;\n }\n \n /* Return length adjustment for INSN.  */"}, {"sha": "d312f9f14a7e40d7537012d0b1411b272198259e", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -80,6 +80,14 @@ along with GCC; see the file COPYING3.  If not see\n \tbuiltin_define (\"__A7__\");\t\\\n \tbuiltin_define (\"__ARC700__\");\t\\\n       }\t\t\t\t\t\\\n+    else if (TARGET_EM)\t\t\t\\\n+      {\t\t\t\t\t\\\n+\tbuiltin_define (\"__EM__\");\t\\\n+      }\t\t\t\t\t\\\n+    else if (TARGET_HS)\t\t\t\\\n+      {\t\t\t\t\t\\\n+\tbuiltin_define (\"__HS__\");\t\\\n+      }\t\t\t\t\t\\\n     if (TARGET_NORM)\t\t\t\\\n       {\t\t\t\t\t\\\n \tbuiltin_define (\"__ARC_NORM__\");\\\n@@ -143,6 +151,8 @@ along with GCC; see the file COPYING3.  If not see\n %{mcpu=ARC700|!mcpu=*:%{mlock}} \\\n %{mcpu=ARC700|!mcpu=*:%{mswape}} \\\n %{mcpu=ARC700|!mcpu=*:%{mrtsc}} \\\n+%{mcpu=ARCHS:-mHS} \\\n+%{mcpu=ARCEM:-mEM} \\\n \"\n \n #if DEFAULT_LIBC == LIBC_UCLIBC\n@@ -246,12 +256,13 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Non-zero means the cpu supports norm instruction.  This flag is set by\n    default for A7, and only for pre A7 cores when -mnorm is given.  */\n-#define TARGET_NORM (TARGET_ARC700 || TARGET_NORM_SET)\n+#define TARGET_NORM (TARGET_ARC700 || TARGET_NORM_SET || TARGET_HS)\n /* Indicate if an optimized floating point emulation library is available.  */\n #define TARGET_OPTFPE \\\n  (TARGET_ARC700 \\\n   /* We need a barrel shifter and NORM.  */ \\\n-  || (TARGET_ARC600 && TARGET_NORM_SET))\n+  || (TARGET_ARC600 && TARGET_NORM_SET) \\\n+  || TARGET_HS)\n \n /* Non-zero means the cpu supports swap instruction.  This flag is set by\n    default for A7, and only for pre A7 cores when -mswap is given.  */\n@@ -271,11 +282,15 @@ along with GCC; see the file COPYING3.  If not see\n \n /* For an anulled-true delay slot insn for a delayed branch, should we only\n    use conditional execution?  */\n-#define TARGET_AT_DBR_CONDEXEC  (!TARGET_ARC700)\n+#define TARGET_AT_DBR_CONDEXEC  (!TARGET_ARC700 && !TARGET_V2)\n \n #define TARGET_ARC600 (arc_cpu == PROCESSOR_ARC600)\n #define TARGET_ARC601 (arc_cpu == PROCESSOR_ARC601)\n #define TARGET_ARC700 (arc_cpu == PROCESSOR_ARC700)\n+#define TARGET_EM     (arc_cpu == PROCESSOR_ARCEM)\n+#define TARGET_HS     (arc_cpu == PROCESSOR_ARCHS)\n+#define TARGET_V2\t\t\t\t\t\t\t\\\n+  ((arc_cpu == PROCESSOR_ARCHS) || (arc_cpu == PROCESSOR_ARCEM))\n \n /* Recast the cpu class to be the cpu attribute.  */\n #define arc_cpu_attr ((enum attr_cpu)arc_cpu)\n@@ -744,6 +759,7 @@ extern enum reg_class arc_regno_reg_class[];\n   ((unsigned) (((X) >> (SHIFT)) + 0x100) \\\n    < 0x200 - ((unsigned) (OFFSET) >> (SHIFT)))\n #define SIGNED_INT12(X) ((unsigned) ((X) + 0x800) < 0x1000)\n+#define SIGNED_INT16(X) ((unsigned) ((X) + 0x8000) < 0x10000)\n #define LARGE_INT(X) \\\n (((X) < 0) \\\n  ? (X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n@@ -1305,14 +1321,15 @@ do {\t\t\t\t\t\t\t\\\n #endif\n #define SET_ASM_OP \"\\t.set\\t\"\n \n+extern char rname29[], rname30[];\n extern char rname56[], rname57[], rname58[], rname59[];\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n #define REGISTER_NAMES\t\t\t\t\t\t\t\t\\\n {  \"r0\",   \"r1\",   \"r2\",   \"r3\",       \"r4\",     \"r5\",     \"r6\",    \"r7\",\t\\\n    \"r8\",   \"r9\",  \"r10\",  \"r11\",      \"r12\",    \"r13\",    \"r14\",   \"r15\",\t\\\n   \"r16\",  \"r17\",  \"r18\",  \"r19\",      \"r20\",    \"r21\",    \"r22\",   \"r23\",\t\\\n-  \"r24\",  \"r25\",   \"gp\",   \"fp\",       \"sp\", \"ilink1\", \"ilink2\", \"blink\",\t\\\n+  \"r24\",  \"r25\",   \"gp\",   \"fp\",       \"sp\",  rname29,  rname30, \"blink\",\t\\\n   \"r32\",  \"r33\",  \"r34\",  \"r35\",      \"r36\",    \"r37\",    \"r38\",   \"r39\",\t\\\n    \"d1\",   \"d1\",   \"d2\",   \"d2\",      \"r44\",    \"r45\",    \"r46\",   \"r47\",\t\\\n   \"r48\",  \"r49\",  \"r50\",  \"r51\",      \"r52\",    \"r53\",    \"r54\",   \"r55\",\t\\\n@@ -1678,4 +1695,25 @@ enum\n #define SFUNC_CHECK_PREDICABLE \\\n   (GET_CODE (PATTERN (insn)) != COND_EXEC || !flag_pic || !TARGET_MEDIUM_CALLS)\n \n+/* MPYW feature macro.  Only valid for ARCHS and ARCEM cores.  */\n+#define TARGET_MPYW     ((arc_mpy_option > 0) && TARGET_V2)\n+/* Full ARCv2 multiplication feature macro.  */\n+#define TARGET_MULTI    ((arc_mpy_option > 1) && TARGET_V2)\n+/* General MPY feature macro.  */\n+#define TARGET_MPY      ((TARGET_ARC700 && (!TARGET_NOMPY_SET)) || TARGET_MULTI)\n+/* ARC700 MPY feature macro.  */\n+#define TARGET_ARC700_MPY (TARGET_ARC700 && (!TARGET_NOMPY_SET))\n+/* Any multiplication feature macro.  */\n+#define TARGET_ANY_MPY\t\t\t\t\t\t\\\n+  (TARGET_MPY || TARGET_MUL64_SET || TARGET_MULMAC_32BY16_SET)\n+\n+/* ARC600 and ARC601 feature macro.  */\n+#define TARGET_ARC600_FAMILY (TARGET_ARC600 || TARGET_ARC601)\n+/* ARC600, ARC601 and ARC700 feature macro.  */\n+#define TARGET_ARCOMPACT_FAMILY\t\t\t\t\\\n+  (TARGET_ARC600 || TARGET_ARC601 || TARGET_ARC700)\n+/* Loop count register can be read in very next instruction after has\n+   been written to by an ordinary instruction.  */\n+#define TARGET_LP_WR_INTERLOCK (!TARGET_ARC600_FAMILY)\n+\n #endif /* GCC_ARC_H */"}, {"sha": "1d070a30d82a85d00fe62539f85aa380a783f73e", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 460, "deletions": 92, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -84,6 +84,8 @@\n ;; Include DFA scheduluers\n (include (\"arc600.md\"))\n (include (\"arc700.md\"))\n+(include (\"arcEM.md\"))\n+(include (\"arcHS.md\"))\n \n ;; Predicates\n \n@@ -124,6 +126,7 @@\n    (VUNSPEC_SR 26) ; blockage insn for writing to an auxiliary register\n    (VUNSPEC_TRAP_S 27) ; blockage insn for trap_s generation\n    (VUNSPEC_UNIMP_S 28) ; blockage insn for unimp_s generation\n+   (VUNSPEC_NOP 29) ; volatile NOP\n \n    (R0_REG 0)\n    (R1_REG 1)\n@@ -165,7 +168,7 @@\n    simd_varith_with_acc, simd_vlogic, simd_vlogic_with_acc,\n    simd_vcompare, simd_vpermute, simd_vpack, simd_vpack_with_acc,\n    simd_valign, simd_valign_with_acc, simd_vcontrol,\n-   simd_vspecial_3cycle, simd_vspecial_4cycle, simd_dma\"\n+   simd_vspecial_3cycle, simd_vspecial_4cycle, simd_dma, mul16_em, div_rem\"\n   (cond [(eq_attr \"is_sfunc\" \"yes\")\n \t (cond [(match_test \"!TARGET_LONG_CALLS_SET && (!TARGET_MEDIUM_CALLS || GET_CODE (PATTERN (insn)) != COND_EXEC)\") (const_string \"call\")\n \t\t(match_test \"flag_pic\") (const_string \"sfunc\")]\n@@ -188,7 +191,7 @@\n \n \n ;; Attribute describing the processor\n-(define_attr \"cpu\" \"none,ARC600,ARC700\"\n+(define_attr \"cpu\" \"none,ARC600,ARC700,ARCEM,ARCHS\"\n   (const (symbol_ref \"arc_cpu_attr\")))\n \n ;; true for compact instructions (those with _s suffix)\n@@ -226,8 +229,21 @@\n \t(symbol_ref \"get_attr_length (NEXT_INSN (PREV_INSN (insn)))\n \t\t     - get_attr_length (insn)\")))\n \n+; for ARCv2 we need to disable/enable different instruction alternatives\n+(define_attr \"cpu_facility\" \"std,av1,av2\"\n+  (const_string \"std\"))\n \n-(define_attr \"enabled\" \"no,yes\" (const_string \"yes\"))\n+; We should consider all the instructions enabled until otherwise\n+(define_attr \"enabled\" \"no,yes\"\n+  (cond [(and (eq_attr \"cpu_facility\" \"av1\")\n+\t      (match_test \"TARGET_V2\"))\n+\t (const_string \"no\")\n+\n+\t (and (eq_attr \"cpu_facility\" \"av2\")\n+\t      (not (match_test \"TARGET_V2\")))\n+\t (const_string \"no\")\n+\t ]\n+\t(const_string \"yes\")))\n \n (define_attr \"predicable\" \"no,yes\" (const_string \"no\"))\n ;; if 'predicable' were not so brain-dead, we would specify:\n@@ -580,7 +596,8 @@\n    stb%U0%V0 %1,%0\"\n   [(set_attr \"type\" \"move,move,move,move,move,move,move,load,store,load,load,store,store\")\n    (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,true,true,true,false,false,false\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,no,no,no,no,no,no\")])\n+   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"move_dest_operand\" \"\")\n@@ -607,15 +624,16 @@\n    mov%? %0,%1\n    mov%? %0,%S1%&\n    mov%? %0,%S1\n-   ldw%? %0,%1%&\n-   stw%? %1,%0%&\n-   ldw%U1%V1 %0,%1\n-   stw%U0%V0 %1,%0\n-   stw%U0%V0 %1,%0\n-   stw%U0%V0 %S1,%0\"\n+   ld%_%? %0,%1%&\n+   st%_%? %1,%0%&\n+   ld%_%U1%V1 %0,%1\n+   st%_%U0%V0 %1,%0\n+   st%_%U0%V0 %1,%0\n+   st%_%U0%V0 %S1,%0\"\n   [(set_attr \"type\" \"move,move,move,move,move,move,move,move,load,store,load,store,store,store\")\n    (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,maybe_limm,false,true,true,false,false,false,false\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,yes,no,no,no,no,no,no\")])\n+   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,yes,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n@@ -669,7 +687,8 @@\n    ; Use default length for iscompact to allow for COND_EXEC.  But set length\n    ; of Crr to 4.\n    (set_attr \"length\" \"*,*,*,4,4,4,4,8,8,*,8,*,*,*,*,*,*,*,*,8\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no\")])\n+   (set_attr \"predicable\" \"yes,no,yes,yes,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; Sometimes generated by the epilogue code.  We don't want to\n ;; recognize these addresses in general, because the limm is costly,\n@@ -698,7 +717,7 @@\n \n (define_insn_and_split \"*movsi_set_cc_insn\"\n   [(set (match_operand:CC_ZN 2 \"cc_set_register\" \"\")\n-\t(match_operator 3 \"zn_compare_operator\"\n+\t(match_operator:CC_ZN 3 \"zn_compare_operator\"\n \t  [(match_operand:SI 1 \"nonmemory_operand\" \"cI,cL,Cal\") (const_int 0)]))\n    (set (match_operand:SI 0 \"register_operand\" \"=w,w,w\")\n \t(match_dup 1))]\n@@ -715,7 +734,7 @@\n \n (define_insn \"unary_comparison\"\n   [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n-\t(match_operator 3 \"zn_compare_operator\"\n+\t(match_operator:CC_ZN 3 \"zn_compare_operator\"\n \t  [(match_operator:SI 2 \"unary_operator\"\n \t     [(match_operand:SI 1 \"register_operand\" \"c\")])\n \t   (const_int 0)]))]\n@@ -779,7 +798,7 @@\n \n (define_insn \"*commutative_binary_comparison\"\n   [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n-\t(match_operator 5 \"zn_compare_operator\"\n+\t(match_operator:CC_ZN 5 \"zn_compare_operator\"\n \t  [(match_operator:SI 4 \"commutative_operator\"\n \t     [(match_operand:SI 1 \"register_operand\" \"%c,c,c\")\n \t      (match_operand:SI 2 \"nonmemory_operand\" \"cL,I,?Cal\")])\n@@ -857,7 +876,7 @@\n \t; Make sure to use the W class to not touch LP_COUNT.\n    (set (match_operand:SI 0 \"register_operand\" \"=W,W,W\")\n \t(match_dup 4))]\n-  \"TARGET_ARC700\"\n+  \"!TARGET_ARC600_FAMILY\"\n   \"%O4.f %0,%1,%2 ; mult commutative\"\n   [(set_attr \"type\" \"compare,compare,compare\")\n    (set_attr \"cond\" \"set_zn,set_zn,set_zn\")\n@@ -881,7 +900,7 @@\n \n (define_insn \"*noncommutative_binary_comparison\"\n   [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n-\t(match_operator 5 \"zn_compare_operator\"\n+\t(match_operator:CC_ZN 5 \"zn_compare_operator\"\n \t  [(match_operator:SI 4 \"noncommutative_operator\"\n \t     [(match_operand:SI 1 \"register_operand\" \"c,c,c\")\n \t      (match_operand:SI 2 \"nonmemory_operand\" \"cL,I,?Cal\")])\n@@ -1145,7 +1164,7 @@\n    (set (match_operand:SI 0 \"dest_reg_operand\" \"=w,w\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldw.a%V4 %3,[%0,%S2]\"\n+  \"ld%_.a%V4 %3,[%0,%S2]\"\n   [(set_attr \"type\" \"load,load\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -1157,7 +1176,7 @@\n    (set (match_operand:SI 0 \"dest_reg_operand\" \"=r,r\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldw.a%V4 %3,[%0,%S2]\"\n+  \"ld%_.a%V4 %3,[%0,%S2]\"\n   [(set_attr \"type\" \"load,load\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -1170,7 +1189,7 @@\n    (set (match_operand:SI 0 \"dest_reg_operand\" \"=w,w\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldw.x.a%V4 %3,[%0,%S2]\"\n+  \"ld%_.x.a%V4 %3,[%0,%S2]\"\n   [(set_attr \"type\" \"load,load\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -1182,7 +1201,7 @@\n    (set (match_operand:SI 0 \"dest_reg_operand\" \"=w\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"stw.a%V4 %3,[%0,%2]\"\n+  \"st%_.a%V4 %3,[%0,%2]\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n@@ -1283,7 +1302,7 @@\n       && satisfies_constraint_Rcq (operands[0]))\n     return \"sub%?.ne %0,%0,%0\";\n   /* ??? might be good for speed on ARC600 too, *if* properly scheduled.  */\n-  if ((TARGET_ARC700 || optimize_size)\n+  if ((optimize_size && (!TARGET_ARC600_FAMILY))\n       && rtx_equal_p (operands[1], constm1_rtx)\n       && GET_CODE (operands[3]) == LTU)\n     return \"sbc.cs %0,%0,%0\";\n@@ -1435,13 +1454,13 @@\n \t(zero_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"0,q,0,c,Usd,Usd,m\")))]\n   \"\"\n   \"@\n-   extw%? %0,%1%&\n-   extw%? %0,%1%&\n+   ext%_%? %0,%1%&\n+   ext%_%? %0,%1%&\n    bmsk%? %0,%1,15\n-   extw %0,%1\n-   ldw%? %0,%1%&\n-   ldw%U1 %0,%1\n-   ldw%U1%V1 %0,%1\"\n+   ext%_ %0,%1\n+   ld%_%? %0,%1%&\n+   ld%_%U1 %0,%1\n+   ld%_%U1%V1 %0,%1\"\n   [(set_attr \"type\" \"unary,unary,unary,unary,load,load,load\")\n    (set_attr \"iscompact\" \"maybe,true,false,false,true,false,false\")\n    (set_attr \"predicable\" \"no,no,yes,no,no,no,no\")])\n@@ -1498,9 +1517,9 @@\n \t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"Rcqq,c,m\")))]\n   \"\"\n   \"@\n-   sexw%? %0,%1%&\n-   sexw %0,%1\n-   ldw.x%U1%V1 %0,%1\"\n+   sex%_%? %0,%1%&\n+   sex%_ %0,%1\n+   ld%_.x%U1%V1 %0,%1\"\n   [(set_attr \"type\" \"unary,unary,load\")\n    (set_attr \"iscompact\" \"true,false,false\")])\n \n@@ -1604,7 +1623,88 @@\n    (set_attr \"cond\" \"canuse,canuse,canuse,canuse,canuse,canuse,nocond,canuse,nocond,nocond,nocond,nocond,canuse_limm,canuse_limm,canuse,canuse,nocond\")\n ])\n \n-;; ARC700/ARC600 multiply\n+;; ARCv2 MPYW and MPYUW\n+(define_expand \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                           \"\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\"  \"\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"\"))))]\n+  \"TARGET_MPYW\"\n+  \"{\n+    if (CONSTANT_P (operands[2]))\n+    {\n+      emit_insn (gen_mulhisi3_imm (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+   }\"\n+)\n+\n+(define_insn \"mulhisi3_imm\"\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=r,r,r,  r,  r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0,r,0,  0,  r\"))\n+\t\t (match_operand:HI 2 \"short_const_int_operand\"          \"L,L,I,C16,C16\")))]\n+  \"TARGET_MPYW\"\n+  \"mpyw%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"mul16_em\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse_limm,nocond\")\n+   ])\n+\n+(define_insn \"mulhisi3_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=Rcqq,r,r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\"  \"   0,0,r\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"Rcqq,r,r\"))))]\n+  \"TARGET_MPYW\"\n+  \"mpyw%? %0,%1,%2\"\n+  [(set_attr \"length\" \"*,4,4\")\n+   (set_attr \"iscompact\" \"maybe,false,false\")\n+   (set_attr \"type\" \"mul16_em\")\n+   (set_attr \"predicable\" \"yes,yes,no\")\n+   (set_attr \"cond\" \"canuse,canuse,nocond\")\n+   ])\n+\n+(define_expand \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"                           \"\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\"  \"\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"nonmemory_operand\" \"\"))))]\n+  \"TARGET_MPYW\"\n+  \"{\n+    if (CONSTANT_P (operands[2]))\n+    {\n+      emit_insn (gen_umulhisi3_imm (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  }\"\n+)\n+\n+(define_insn \"umulhisi3_imm\"\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=r, r,r,  r,  r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \" 0, r,0,  0,  r\"))\n+\t\t (match_operand:HI 2 \"short_const_int_operand\"          \" L, L,I,C16,C16\")))]\n+  \"TARGET_MPYW\"\n+  \"mpyuw%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"mul16_em\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse_limm,nocond\")\n+   ])\n+\n+(define_insn \"umulhisi3_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=Rcqq, r, r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"    0, 0, r\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \" Rcqq, r, r\"))))]\n+  \"TARGET_MPYW\"\n+  \"mpyuw%? %0,%1,%2\"\n+  [(set_attr \"length\" \"*,4,4\")\n+   (set_attr \"iscompact\" \"maybe,false,false\")\n+   (set_attr \"type\" \"mul16_em\")\n+   (set_attr \"predicable\" \"yes,yes,no\")\n+   (set_attr \"cond\" \"canuse,canuse,nocond\")\n+   ])\n+\n+;; ARC700/ARC600/V2 multiply\n ;; SI <- SI * SI\n \n (define_expand \"mulsi3\"\n@@ -1613,7 +1713,7 @@\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n {\n-  if (TARGET_ARC700 && !TARGET_NOMPY_SET)\n+  if (TARGET_MPY)\n     {\n       if (!register_operand (operands[0], SImode))\n \t{\n@@ -1743,8 +1843,7 @@\n    (clobber (reg:SI LP_START))\n    (clobber (reg:SI LP_END))\n    (clobber (reg:CC CC_REG))]\n-  \"!TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\n-   && (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+  \"!TARGET_ANY_MPY\n    && SFUNC_CHECK_PREDICABLE\"\n   \"*return arc_output_libcall (\\\"__mulsi3\\\");\"\n   [(set_attr \"is_sfunc\" \"yes\")\n@@ -1794,23 +1893,35 @@\n  [(set (match_operand:SI 0 \"mpy_dest_reg_operand\"        \"=Rcr,r,r,Rcr,r\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\"  \" 0,c,0,0,c\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"cL,cL,I,Cal,Cal\")))]\n-\"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n+ \"TARGET_ARC700_MPY\"\n   \"mpyu%? %0,%1,%2\"\n   [(set_attr \"length\" \"4,4,4,8,8\")\n    (set_attr \"type\" \"umulti\")\n    (set_attr \"predicable\" \"yes,no,no,yes,no\")\n    (set_attr \"cond\" \"canuse,nocond,canuse_limm,canuse,nocond\")])\n \n+; ARCv2 has no penalties between mpy and mpyu. So, we use mpy because of its\n+; short variant. LP_COUNT constraints are still valid.\n+(define_insn \"mulsi3_v2\"\n+ [(set (match_operand:SI 0 \"mpy_dest_reg_operand\"        \"=Rcqq,Rcr, r,r,Rcr,  r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\"     \"%0,  0, c,0,  0,  c\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \" Rcqq, cL,cL,I,Cal,Cal\")))]\n+ \"TARGET_MULTI\"\n+ \"mpy%? %0,%1,%2\"\n+ [(set_attr \"length\" \"*,4,4,4,8,8\")\n+  (set_attr \"iscompact\" \"maybe,false,false,false,false,false\")\n+  (set_attr \"type\" \"umulti\")\n+  (set_attr \"predicable\" \"no,yes,no,no,yes,no\")\n+  (set_attr \"cond\" \"nocond,canuse,nocond,canuse_limm,canuse,nocond\")])\n+\n (define_expand \"mulsidi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(mult:DI (sign_extend:DI(match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (sign_extend:DI(match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n-  \"(TARGET_ARC700 && !TARGET_NOMPY_SET)\n-   || TARGET_MUL64_SET\n-   || TARGET_MULMAC_32BY16_SET\"\n+  \"TARGET_ANY_MPY\"\n \"\n {\n-  if (TARGET_ARC700 && !TARGET_NOMPY_SET)\n+  if (TARGET_MPY)\n     {\n       operands[2] = force_reg (SImode, operands[2]);\n       if (!register_operand (operands[0], DImode))\n@@ -1892,7 +2003,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%c\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"extend_operand\" \"cL\"))))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n+  \"TARGET_MPY\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -1902,7 +2013,7 @@\n   rtx l0 = simplify_gen_subreg (word_mode, operands[0], DImode, lo);\n   rtx h0 = simplify_gen_subreg (word_mode, operands[0], DImode, hi);\n   emit_insn (gen_mulsi3_highpart (h0, operands[1], operands[2]));\n-  emit_insn (gen_mulsi3_700 (l0, operands[1], operands[2]));\n+  emit_insn (gen_mulsi3 (l0, operands[1], operands[2]));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")\n@@ -1916,8 +2027,8 @@\n \t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,c,  0,c\"))\n \t   (sign_extend:DI (match_operand:SI 2 \"extend_operand\"    \"c,c,  i,i\")))\n \t  (const_int 32))))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n-  \"mpyh%? %0,%1,%2\"\n+  \"TARGET_MPY\"\n+  \"mpy%+%? %0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,yes,no\")\n@@ -1933,8 +2044,8 @@\n \t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,c,  0,c\"))\n \t   (zero_extend:DI (match_operand:SI 2 \"extend_operand\"    \"c,c,  i,i\")))\n \t  (const_int 32))))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n-  \"mpyhu%? %0,%1,%2\"\n+  \"TARGET_MPY\"\n+  \"mpy%+u%? %0,%1,%2\"\n   [(set_attr \"length\" \"4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,yes,no\")\n@@ -1956,8 +2067,7 @@\n    (clobber (reg:DI MUL64_OUT_REG))\n    (clobber (reg:CC CC_REG))]\n   \"!TARGET_BIG_ENDIAN\n-   && !TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\n-   && (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+   && !TARGET_ANY_MPY\n    && SFUNC_CHECK_PREDICABLE\"\n   \"*return arc_output_libcall (\\\"__umulsi3_highpart\\\");\"\n   [(set_attr \"is_sfunc\" \"yes\")\n@@ -1977,8 +2087,7 @@\n    (clobber (reg:DI MUL64_OUT_REG))\n    (clobber (reg:CC CC_REG))]\n   \"TARGET_BIG_ENDIAN\n-   && !TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\n-   && (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+   && !TARGET_ANY_MPY\n    && SFUNC_CHECK_PREDICABLE\"\n   \"*return arc_output_libcall (\\\"__umulsi3_highpart\\\");\"\n   [(set_attr \"is_sfunc\" \"yes\")\n@@ -1995,8 +2104,8 @@\n \t   (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \" 0, c, 0,  0,  c\"))\n \t   (match_operand:DI 2 \"immediate_usidi_operand\" \"L, L, I, Cal, Cal\"))\n \t  (const_int 32))))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n-  \"mpyhu%? %0,%1,%2\"\n+  \"TARGET_MPY\"\n+  \"mpy%+u%? %0,%1,%2\"\n   [(set_attr \"length\" \"4,4,4,8,8\")\n    (set_attr \"type\" \"multi\")\n    (set_attr \"predicable\" \"yes,no,no,yes,no\")\n@@ -2010,12 +2119,12 @@\n \t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t   (zero_extend:DI (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n \t  (const_int 32))))]\n-  \"TARGET_ARC700 || (!TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET)\"\n+  \"!TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\"\n   \"\n {\n   rtx target = operands[0];\n \n-  if (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+  if (!TARGET_MPY)\n     {\n       emit_move_insn (gen_rtx_REG (SImode, 0), operands[1]);\n       emit_move_insn (gen_rtx_REG (SImode, 1), operands[2]);\n@@ -2047,7 +2156,7 @@\n \t\t (zero_extend:DI(match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n   \"\"\n {\n-  if (TARGET_ARC700 && !TARGET_NOMPY_SET)\n+  if (TARGET_MPY)\n     {\n       operands[2] = force_reg (SImode, operands[2]);\n       if (!register_operand (operands[0], DImode))\n@@ -2141,7 +2250,7 @@\n   [(set (match_operand:DI 0 \"dest_reg_operand\" \"=&r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%c\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"extend_operand\" \"cL\"))))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\"\n+  \"TARGET_MPY\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n@@ -2151,7 +2260,7 @@\n   rtx l0 = operand_subword (operands[0], lo, 0, DImode);\n   rtx h0 = operand_subword (operands[0], hi, 0, DImode);\n   emit_insn (gen_umulsi3_highpart (h0, operands[1], operands[2]));\n-  emit_insn (gen_mulsi3_700 (l0, operands[1], operands[2]));\n+  emit_insn (gen_mulsi3 (l0, operands[1], operands[2]));\n   DONE;\n }\n   [(set_attr \"type\" \"umulti\")\n@@ -2166,8 +2275,7 @@\n    (clobber (reg:SI R12_REG))\n    (clobber (reg:DI MUL64_OUT_REG))\n    (clobber (reg:CC CC_REG))]\n-   \"!TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\n-   && (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+   \"!TARGET_ANY_MPY\n    && SFUNC_CHECK_PREDICABLE\"\n   \"*return arc_output_libcall (\\\"__umulsidi3\\\");\"\n   [(set_attr \"is_sfunc\" \"yes\")\n@@ -2183,8 +2291,7 @@\n       (clobber (reg:SI R12_REG))\n       (clobber (reg:DI MUL64_OUT_REG))\n       (clobber (reg:CC CC_REG))])]\n-  \"!TARGET_MUL64_SET && !TARGET_MULMAC_32BY16_SET\n-   && (!TARGET_ARC700 || TARGET_NOMPY_SET)\n+  \"!TARGET_ANY_MPY\n    && peep2_regno_dead_p (1, TARGET_BIG_ENDIAN ? R1_REG : R0_REG)\"\n   [(pc)]\n {\n@@ -2350,7 +2457,7 @@\n \tadc %0,%1,%2\"\n   ; if we have a bad schedule after sched2, split.\n   \"reload_completed\n-   && !optimize_size && TARGET_ARC700\n+   && !optimize_size && (!TARGET_ARC600_FAMILY)\n    && arc_scheduling_not_expected ()\n    && arc_sets_cc_p (prev_nonnote_insn (insn))\n    /* If next comes a return or other insn that needs a delay slot,\n@@ -2564,7 +2671,7 @@\n \tsbc %0,%1,%2\"\n   ; if we have a bad schedule after sched2, split.\n   \"reload_completed\n-   && !optimize_size && TARGET_ARC700\n+   && !optimize_size && (!TARGET_ARC600_FAMILY)\n    && arc_scheduling_not_expected ()\n    && arc_sets_cc_p (prev_nonnote_insn (insn))\n    /* If next comes a return or other insn that needs a delay slot,\n@@ -2802,7 +2909,7 @@\n       return \\\"bclr%? %0,%1,%M2%&\\\";\n     case 4:\n       return (INTVAL (operands[2]) == 0xff\n-\t      ? \\\"extb%? %0,%1%&\\\" : \\\"extw%? %0,%1%&\\\");\n+\t      ? \\\"extb%? %0,%1%&\\\" : \\\"ext%_%? %0,%1%&\\\");\n     case 9: case 14: return \\\"bic%? %0,%1,%n2-1\\\";\n     case 18:\n       if (TARGET_BIG_ENDIAN)\n@@ -2813,11 +2920,11 @@\n \t  xop[1] = adjust_address (operands[1], QImode,\n \t\t\t\t   INTVAL (operands[2]) == 0xff ? 3 : 2);\n \t  output_asm_insn (INTVAL (operands[2]) == 0xff\n-\t\t\t   ? \\\"ldb %0,%1\\\" : \\\"ldw %0,%1\\\",\n+\t\t\t   ? \\\"ldb %0,%1\\\" : \\\"ld%_ %0,%1\\\",\n \t\t\t   xop);\n \t  return \\\"\\\";\n \t}\n-      return INTVAL (operands[2]) == 0xff ? \\\"ldb %0,%1\\\" : \\\"ldw %0,%1\\\";\n+      return INTVAL (operands[2]) == 0xff ? \\\"ldb %0,%1\\\" : \\\"ld%_ %0,%1\\\";\n     default:\n       gcc_unreachable ();\n     }\n@@ -3196,19 +3303,19 @@\n ;; Next come the scc insns.\n \n (define_expand \"cstoresi4\"\n-  [(set (reg:CC CC_REG)\n-\t(compare:CC (match_operand:SI 2 \"nonmemory_operand\" \"\")\n-\t\t    (match_operand:SI 3 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n-\t(match_operator:SI 1 \"ordered_comparison_operator\" [(reg CC_REG)\n-\t\t\t\t\t\t\t    (const_int 0)]))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\" [(match_operand:SI 2 \"nonmemory_operand\" \"\")\n+\t\t\t\t\t\t\t    (match_operand:SI 3 \"nonmemory_operand\" \"\")]))]\n   \"\"\n {\n-  gcc_assert (XEXP (operands[1], 0) == operands[2]);\n-  gcc_assert (XEXP (operands[1], 1) == operands[3]);\n-  operands[1] = gen_compare_reg (operands[1], SImode);\n-  emit_insn (gen_scc_insn (operands[0], operands[1]));\n-  DONE;\n+  if (!TARGET_CODE_DENSITY)\n+  {\n+   gcc_assert (XEXP (operands[1], 0) == operands[2]);\n+   gcc_assert (XEXP (operands[1], 1) == operands[3]);\n+   operands[1] = gen_compare_reg (operands[1], SImode);\n+   emit_insn (gen_scc_insn (operands[0], operands[1]));\n+   DONE;\n+  }\n })\n \n (define_mode_iterator SDF [SF DF])\n@@ -3590,8 +3697,8 @@\n       return \\\"ld.as %0,[%1,%2]%&\\\";\n     case HImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n-\treturn \\\"ldw.as %0,[%1,%2]\\\";\n-      return \\\"ldw.x.as %0,[%1,%2]\\\";\n+\treturn \\\"ld%_.as %0,[%1,%2]\\\";\n+      return \\\"ld%_.x.as %0,[%1,%2]\\\";\n     case QImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn \\\"ldb%? %0,[%1,%2]%&\\\";\n@@ -3658,7 +3765,7 @@\n \t 2 of these are for alignment, and are anticipated in the length\n \t of the ADDR_DIFF_VEC.  */\n       if (unalign && !satisfies_constraint_Rcq (xop[0]))\n-\ts = \\\"add2 %2,pcl,%0\\n\\tld_s%2,[%2,12]\\\";\n+\ts = \\\"add2 %2,pcl,%0\\n\\tld_s %2,[%2,12]\\\";\n       else if (unalign)\n \ts = \\\"add_s %2,%0,2\\n\\tld.as %2,[pcl,%2]\\\";\n       else\n@@ -3670,25 +3777,25 @@\n \t{\n \t  if (satisfies_constraint_Rcq (xop[0]))\n \t    {\n-\t      s = \\\"add_s %2,%0,%1\\n\\tldw.as %2,[pcl,%2]\\\";\n+\t      s = \\\"add_s %2,%0,%1\\n\\tld%_.as %2,[pcl,%2]\\\";\n \t      xop[1] = GEN_INT ((10 - unalign) / 2U);\n \t    }\n \t  else\n \t    {\n-\t      s = \\\"add1 %2,pcl,%0\\n\\tldw_s %2,[%2,%1]\\\";\n+\t      s = \\\"add1 %2,pcl,%0\\n\\tld%__s %2,[%2,%1]\\\";\n \t      xop[1] = GEN_INT (10 + unalign);\n \t    }\n \t}\n       else\n \t{\n \t  if (satisfies_constraint_Rcq (xop[0]))\n \t    {\n-\t      s = \\\"add_s %2,%0,%1\\n\\tldw.x.as %2,[pcl,%2]\\\";\n+\t      s = \\\"add_s %2,%0,%1\\n\\tld%_.x.as %2,[pcl,%2]\\\";\n \t      xop[1] = GEN_INT ((10 - unalign) / 2U);\n \t    }\n \t  else\n \t    {\n-\t      s = \\\"add1 %2,pcl,%0\\n\\tldw_s.x %2,[%2,%1]\\\";\n+\t      s = \\\"add1 %2,pcl,%0\\n\\tld%__s.x %2,[%2,%1]\\\";\n \t      xop[1] = GEN_INT (10 + unalign);\n \t    }\n \t}\n@@ -3886,6 +3993,14 @@\n    (set_attr \"cond\" \"canuse\")\n    (set_attr \"length\" \"2\")])\n \n+(define_insn \"nopv\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_NOP)]\n+  \"\"\n+  \"nop%?\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"iscompact\" \"true\")\n+   (set_attr \"length\" \"2\")])\n+\n ;; Special pattern to flush the icache.\n ;; ??? Not sure what to do here.  Some ARC's are known to support this.\n \n@@ -3985,7 +4100,7 @@\n    (set (match_operand:SI 4 \"register_operand\" \"\")\n   \t(mult:SI (match_operand:SI 2 \"register_operand\")\n \t\t (match_operand:SI 3 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\n+  \"TARGET_ARC700_MPY\n    && (rtx_equal_p (operands[0], operands[2])\n        || rtx_equal_p (operands[0], operands[3]))\n    && peep2_regno_dead_p (0, CC_REG)\n@@ -4015,7 +4130,7 @@\n    (set (match_operand:SI 4 \"register_operand\" \"\")\n   \t(mult:SI (match_operand:SI 2 \"register_operand\")\n \t\t (match_operand:SI 3 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_ARC700 && !TARGET_NOMPY_SET\n+  \"TARGET_ARC700_MPY\n    && (rtx_equal_p (operands[0], operands[2])\n        || rtx_equal_p (operands[0], operands[3]))\n    && peep2_regno_dead_p (2, CC_REG)\"\n@@ -4068,8 +4183,8 @@\n \t  (clrsb:HI (match_operand:HI 1 \"general_operand\" \"cL,Cal\"))))]\n   \"TARGET_NORM\"\n   \"@\n-   normw \\t%0, %1\n-   normw \\t%0, %S1\"\n+   norm%_ \\t%0, %1\n+   norm%_ \\t%0, %S1\"\n   [(set_attr \"length\" \"4,8\")\n    (set_attr \"type\" \"two_cycle_core,two_cycle_core\")])\n \n@@ -4479,6 +4594,11 @@\n     = gen_rtx_REG (Pmode,\n \t\t   arc_return_address_regs[arc_compute_function_type (cfun)]);\n \n+  if (arc_compute_function_type (cfun) == ARC_FUNCTION_ILINK1\n+      && TARGET_V2)\n+  {\n+    return \\\"rtie\\\";\n+  }\n   if (TARGET_PAD_RETURN)\n     arc_pad_return ();\n   output_asm_insn (\\\"j%!%* [%0]%&\\\", &reg);\n@@ -4487,8 +4607,13 @@\n   [(set_attr \"type\" \"return\")\n    ; predicable won't help here since the canonical rtl looks different\n    ; for branches.\n-   (set_attr \"cond\" \"canuse\")\n-   (set (attr \"iscompact\")\n+   (set (attr \"cond\")\n+\t(cond [(and (eq (symbol_ref \"arc_compute_function_type (cfun)\")\n+\t\t\t(symbol_ref \"ARC_FUNCTION_ILINK1\"))\n+\t\t    (match_test \"TARGET_V2\"))\n+\t       (const_string \"nocond\")]\n+\t      (const_string \"canuse\")))\n+  (set (attr \"iscompact\")\n \t(cond [(eq (symbol_ref \"arc_compute_function_type (cfun)\")\n \t\t   (symbol_ref \"ARC_FUNCTION_NORMAL\"))\n \t       (const_string \"maybe\")]\n@@ -4504,7 +4629,9 @@\n \t(if_then_else (match_operator 0 \"proper_comparison_operator\"\n \t\t\t\t      [(reg CC_REG) (const_int 0)])\n \t\t      (simple_return) (pc)))]\n-  \"reload_completed\"\n+  \"reload_completed\n+   && !(TARGET_V2\n+     && arc_compute_function_type (cfun) == ARC_FUNCTION_ILINK1)\"\n {\n   rtx xop[2];\n   xop[0] = operands[0];\n@@ -4909,7 +5036,7 @@\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"register_operand\" \"\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_ARC600 || TARGET_ARC700\"\n+  \"!TARGET_ARC601\"\n {\n   /* We could do smaller bivs with biv widening, and wider bivs by having\n      a high-word counter in an outer loop - but punt on this for now.  */\n@@ -5158,6 +5285,247 @@\n ;; this would not work right for -0.  OTOH optabs.c has already code\n ;; to synthesyze negate by flipping the sign bit.\n \n+;;V2 instructions\n+(define_insn \"bswapsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"= r,r\")\n+\t(bswap:SI (match_operand:SI 1 \"nonmemory_operand\" \"rL,Cal\")))]\n+  \"TARGET_V2 && TARGET_SWAP\"\n+  \"swape %0, %1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"two_cycle_core\")])\n+\n+(define_expand \"prefetch\"\n+  [(prefetch (match_operand:SI 0 \"address_operand\" \"\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"TARGET_HS\"\n+  \"\")\n+\n+(define_insn \"prefetch_1\"\n+  [(prefetch (match_operand:SI 0 \"register_operand\" \"r\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_HS\"\n+  {\n+   if (INTVAL (operands[1]))\n+      return \"prefetchw [%0]\";\n+   else\n+      return \"prefetch [%0]\";\n+  }\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"prefetch_2\"\n+  [(prefetch (plus:SI (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t      (match_operand:SI 1 \"nonmemory_operand\" \"r,Cm2,Cal\"))\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n,n,n\")\n+\t     (match_operand:SI 3 \"const_int_operand\" \"n,n,n\"))]\n+  \"TARGET_HS\"\n+  {\n+   if (INTVAL (operands[2]))\n+      return \"prefetchw [%0, %1]\";\n+   else\n+      return \"prefetch [%0, %1]\";\n+  }\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4,4,8\")])\n+\n+(define_insn \"prefetch_3\"\n+  [(prefetch (match_operand:SI 0 \"address_operand\" \"p\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_HS\"\n+  {\n+   operands[0] = gen_rtx_MEM (SImode, operands[0]);\n+   if (INTVAL (operands[1]))\n+      return \"prefetchw%U0 %0\";\n+   else\n+      return \"prefetch%U0 %0\";\n+   }\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,  r,r,r,r,  r,  r\")\n+\t(div:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal,0,r,0,  0,  r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,r,  r,L,L,I,Cal,Cal\")))]\n+  \"TARGET_DIVREM\"\n+  \"div%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,8,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"div_rem\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r,  r,r,r,r,  r,  r\")\n+\t(udiv:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal,0,r,0,  0,  r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r,r,  r,L,L,I,Cal,Cal\")))]\n+  \"TARGET_DIVREM\"\n+  \"divu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,8,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"div_rem\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,  r,r,r,r,  r,  r\")\n+\t(mod:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal,0,r,0,  0,  r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,r,  r,L,L,I,Cal,Cal\")))]\n+  \"TARGET_DIVREM\"\n+  \"rem%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,8,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"div_rem\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r,  r,r,r,r,  r,  r\")\n+\t(umod:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,Cal,0,r,0,  0,  r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r,r,  r,L,L,I,Cal,Cal\")))]\n+  \"TARGET_DIVREM\"\n+  \"remu%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,8,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"div_rem\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+;; SETcc instructions\n+(define_code_iterator arcCC_cond [eq ne gt lt ge le])\n+\n+(define_insn \"arcset<code>\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r,r,r,r,r,r,r\")\n+\t(arcCC_cond:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,0,r,0,0,r\")\n+\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"r,r,L,L,I,n,n\")))]\n+  \"TARGET_V2 && TARGET_CODE_DENSITY\"\n+  \"set<code>%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+(define_insn \"arcsetltu\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,r,r,r,  r,  r\")\n+\t(ltu:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,0,r,0,  0,  r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,r,L,L,I,  n,  n\")))]\n+  \"TARGET_V2 && TARGET_CODE_DENSITY\"\n+  \"setlo%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+(define_insn \"arcsetgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,r,r,r,  r,  r\")\n+\t(geu:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,r,0,r,0,  0,  r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,r,L,L,I,  n,  n\")))]\n+  \"TARGET_V2 && TARGET_CODE_DENSITY\"\n+  \"seths%? %0, %1, %2\"\n+  [(set_attr \"length\" \"4,4,4,4,4,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no,yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse,nocond,nocond,canuse,nocond\")\n+   ])\n+\n+;; Special cases of SETCC\n+(define_insn_and_split \"arcsethi\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,  r,r\")\n+\t(gtu:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,  r,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,r,C62,n\")))]\n+  \"TARGET_V2 && TARGET_CODE_DENSITY\"\n+  \"setlo%? %0, %2, %1\"\n+  \"reload_completed\n+   && CONST_INT_P (operands[2])\n+   && satisfies_constraint_C62 (operands[2])\"\n+  [(const_int 0)]\n+  \"{\n+    /* sethi a,b,u6 => seths a,b,u6 + 1.  */\n+    operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n+    emit_insn (gen_arcsetgeu (operands[0], operands[1], operands[2]));\n+    DONE;\n+ }\"\n+ [(set_attr \"length\" \"4,4,4,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"predicable\" \"yes,no,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,nocond\")]\n+)\n+\n+(define_insn_and_split \"arcsetls\"\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r,  r,r\")\n+\t(leu:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,  r,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"0,r,C62,n\")))]\n+  \"TARGET_V2 && TARGET_CODE_DENSITY\"\n+  \"seths%? %0, %2, %1\"\n+  \"reload_completed\n+   && CONST_INT_P (operands[2])\n+   && satisfies_constraint_C62 (operands[2])\"\n+  [(const_int 0)]\n+  \"{\n+    /* setls a,b,u6 => setlo a,b,u6 + 1.  */\n+    operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n+    emit_insn (gen_arcsetltu (operands[0], operands[1], operands[2]));\n+    DONE;\n+ }\"\n+ [(set_attr \"length\" \"4,4,4,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"predicable\" \"yes,no,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,nocond,nocond\")]\n+)\n+\n+; Any mode that needs to be solved by secondary reload\n+(define_mode_iterator SRI [QI HI])\n+\n+(define_expand \"reload_<mode>_load\"\n+  [(parallel [(match_operand:SRI 0 \"register_operand\" \"=r\")\n+\t      (match_operand:SRI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:SI 2 \"register_operand\" \"=&r\")])]\n+  \"\"\n+{\n+ arc_secondary_reload_conv (operands[0], operands[1], operands[2], false);\n+ DONE;\n+})\n+\n+(define_expand \"reload_<mode>_store\"\n+  [(parallel [(match_operand:SRI 0 \"memory_operand\" \"=m\")\n+\t      (match_operand:SRI 1 \"register_operand\" \"r\")\n+\t      (match_operand:SI 2 \"register_operand\" \"=&r\")])]\n+  \"\"\n+{\n+ arc_secondary_reload_conv (operands[1], operands[0], operands[2], true);\n+ DONE;\n+})\n+\n+\n+(define_insn \"extzvsi\"\n+  [(set (match_operand:SI 0 \"register_operand\"                  \"=r  , r  , r, r, r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\"  \"0  , r  , 0, 0, r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"C3p, C3p, i, i, i\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i  , i  , i, i, i\")))]\n+  \"TARGET_HS && TARGET_BARREL_SHIFTER\"\n+  {\n+   int assemble_op2 = (((INTVAL (operands[2]) - 1) & 0x1f) << 5) | (INTVAL (operands[3]) & 0x1f);\n+   operands[2] = GEN_INT (assemble_op2);\n+   return \"xbfu%? %0,%1,%2\";\n+  }\n+  [(set_attr \"type\"       \"shift\")\n+   (set_attr \"iscompact\"  \"false\")\n+   (set_attr \"length\"     \"4,4,4,8,8\")\n+   (set_attr \"predicable\" \"yes,no,no,yes,no\")\n+   (set_attr \"cond\"       \"canuse,nocond,nocond,canuse,nocond\")])\n \n ;; include the arc-FPX instructions\n (include \"fpx.md\")"}, {"sha": "0c10c67c4e7137afdd82db4a5ed54f0593ec9a20", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -53,6 +53,18 @@ mARC700\n Target Report\n Same as -mA7.\n \n+mmpy-option=\n+Target RejectNegative Joined UInteger Var(arc_mpy_option) Init(2)\n+-mmpy-option={0,1,2,3,4,5,6,7,8,9} Compile ARCv2 code with a multiplier design option.  Option 2 is default on.\n+\n+mdiv-rem\n+Target Report Mask(DIVREM)\n+Enable DIV-REM instructions for ARCv2\n+\n+mcode-density\n+Target Report Mask(CODE_DENSITY)\n+Enable code density instructions for ARCv2\n+\n mmixed-code\n Target Report Mask(MIXED_CODE_SET)\n Tweak register allocation to help 16-bit instruction generation.\n@@ -161,12 +173,33 @@ Name(processor_type) Type(enum processor_type)\n EnumValue\n Enum(processor_type) String(ARC600) Value(PROCESSOR_ARC600)\n \n+EnumValue\n+Enum(processor_type) String(arc600) Value(PROCESSOR_ARC600)\n+\n EnumValue\n Enum(processor_type) String(ARC601) Value(PROCESSOR_ARC601)\n \n+EnumValue\n+Enum(processor_type) String(arc601) Value(PROCESSOR_ARC601)\n+\n EnumValue\n Enum(processor_type) String(ARC700) Value(PROCESSOR_ARC700)\n \n+EnumValue\n+Enum(processor_type) String(arc700) Value(PROCESSOR_ARC700)\n+\n+EnumValue\n+Enum(processor_type) String(ARCEM) Value(PROCESSOR_ARCEM)\n+\n+EnumValue\n+Enum(processor_type) String(arcem) Value(PROCESSOR_ARCEM)\n+\n+EnumValue\n+Enum(processor_type) String(ARCHS) Value(PROCESSOR_ARCHS)\n+\n+EnumValue\n+Enum(processor_type) String(archs) Value(PROCESSOR_ARCHS)\n+\n msize-level=\n Target RejectNegative Joined UInteger Var(arc_size_opt_level) Init(-1)\n size optimization level: 0:none 1:opportunistic 2: regalloc 3:drop align, -Os."}, {"sha": "a72d2504e526e4819c566f6cc793051fd9c70c47", "filename": "gcc/config/arc/arcEM.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2FarcEM.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2FarcEM.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2FarcEM.md?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -0,0 +1,93 @@\n+;; DFA scheduling description of the Synopsys DesignWare ARC EM cpu\n+;; for GNU C compiler\n+;; Copyright (C) 2007-2015 Free Software Foundation, Inc.\n+;; Contributor: Claudiu Zissulescu <claudiu.zissulescu@synopsys.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"ARCEM\")\n+\n+(define_cpu_unit \"em_issue, ld_st, mul_em, divrem_em\" \"ARCEM\")\n+\n+(define_insn_reservation \"em_data_load\" 2\n+  (and (match_test \"TARGET_EM\")\n+       (eq_attr \"type\" \"load\"))\n+  \"em_issue+ld_st,nothing\")\n+\n+(define_insn_reservation \"em_data_store\" 1\n+  (and (match_test \"TARGET_EM\")\n+       (eq_attr \"type\" \"store\"))\n+  \"em_issue+ld_st\")\n+\n+;; Multipliers options\n+(define_insn_reservation \"mul_em_mpyw_1\" 1\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option > 0\")\n+       (match_test \"arc_mpy_option <= 2\")\n+       (eq_attr \"type\" \"mul16_em\"))\n+  \"em_issue+mul_em\")\n+\n+(define_insn_reservation \"mul_em_mpyw_2\" 2\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option > 2\")\n+       (match_test \"arc_mpy_option <= 5\")\n+       (eq_attr \"type\" \"mul16_em\"))\n+  \"em_issue+mul_em, nothing\")\n+\n+(define_insn_reservation \"mul_em_mpyw_4\" 4\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 6\")\n+       (eq_attr \"type\" \"mul16_em\"))\n+  \"em_issue+mul_em, mul_em*3\")\n+\n+(define_insn_reservation \"mul_em_multi_wlh1\" 1\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 2\")\n+       (eq_attr \"type\" \"multi,umulti\"))\n+  \"em_issue+mul_em\")\n+\n+(define_insn_reservation \"mul_em_multi_wlh2\" 2\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 3\")\n+       (eq_attr \"type\" \"multi,umulti\"))\n+  \"em_issue+mul_em, nothing\")\n+\n+(define_insn_reservation \"mul_em_multi_wlh3\" 3\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 4\")\n+       (eq_attr \"type\" \"multi,umulti\"))\n+  \"em_issue+mul_em, mul_em*2\")\n+\n+;; FIXME! Make the difference between MPY and MPYM for WLH4\n+(define_insn_reservation \"mul_em_multi_wlh4\" 4\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 5\")\n+       (eq_attr \"type\" \"multi,umulti\"))\n+  \"em_issue+mul_em, mul_em*4\")\n+\n+(define_insn_reservation \"mul_em_multi_wlh5\" 9\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"arc_mpy_option == 6\")\n+       (eq_attr \"type\" \"multi,umulti\"))\n+  \"em_issue+mul_em, mul_em*8\")\n+\n+;; Radix-4 divider timing\n+(define_insn_reservation \"em_divrem\" 3\n+  (and (match_test \"TARGET_EM\")\n+       (match_test \"TARGET_DIVREM\")\n+       (eq_attr \"type\" \"div_rem\"))\n+  \"em_issue+mul_em+divrem_em, (mul_em+divrem_em)*2\")"}, {"sha": "06937445a477718654cf986f083437b92a9f6039", "filename": "gcc/config/arc/arcHS.md", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2FarcHS.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2FarcHS.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2FarcHS.md?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -0,0 +1,76 @@\n+;; DFA scheduling description of the Synopsys DesignWare ARC HS cpu\n+;; for GNU C compiler\n+;; Copyright (C) 2007-2015 Free Software Foundation, Inc.\n+;; Contributor: Claudiu Zissulescu <claudiu.zissulescu@synopsys.com>\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"ARCHS\")\n+\n+(define_cpu_unit \"hs_issue, hs_ld_st, divrem_hs, mul_hs, x1, x2\" \"ARCHS\")\n+\n+(define_insn_reservation \"hs_data_load\" 4\n+  (and (match_test \"TARGET_HS\")\n+       (eq_attr \"type\" \"load\"))\n+  \"hs_issue+hs_ld_st,hs_ld_st,nothing*2\")\n+\n+(define_insn_reservation \"hs_data_store\" 1\n+  (and (match_test \"TARGET_HS\")\n+       (eq_attr \"type\" \"store\"))\n+  \"hs_issue+hs_ld_st\")\n+\n+(define_insn_reservation \"hs_alu0\" 2\n+  (and (match_test \"TARGET_HS\")\n+       (eq_attr \"type\" \"cc_arith, two_cycle_core, shift, lr, sr\"))\n+  \"hs_issue+x1,x2\")\n+\n+(define_insn_reservation \"hs_alu1\" 4\n+  (and (match_test \"TARGET_HS\")\n+       (eq_attr \"type\" \"move, cmove, unary, binary, compare, misc\"))\n+  \"hs_issue+x1, nothing*3\")\n+\n+(define_insn_reservation \"hs_divrem\" 13\n+  (and (match_test \"TARGET_HS\")\n+       (match_test \"TARGET_DIVREM\")\n+       (eq_attr \"type\" \"div_rem\"))\n+  \"hs_issue+divrem_hs, (divrem_hs)*12\")\n+\n+(define_insn_reservation \"hs_mul\" 3\n+  (and (match_test \"TARGET_HS\")\n+       (eq_attr \"type\" \"mul16_em, multi, umulti\"))\n+  \"hs_issue+mul_hs, nothing*3\")\n+\n+;; BYPASS EALU ->\n+(define_bypass 1 \"hs_alu0\" \"hs_divrem\")\n+(define_bypass 1 \"hs_alu0\" \"hs_mul\")\n+\n+;; BYPASS BALU ->\n+(define_bypass 1 \"hs_alu1\" \"hs_alu1\")\n+(define_bypass 1 \"hs_alu1\" \"hs_data_store\" \"store_data_bypass_p\")\n+\n+;; BYPASS LD ->\n+(define_bypass 1 \"hs_data_load\" \"hs_alu1\")\n+(define_bypass 3 \"hs_data_load\" \"hs_divrem\")\n+(define_bypass 3 \"hs_data_load\" \"hs_data_load\")\n+(define_bypass 3 \"hs_data_load\" \"hs_mul\")\n+(define_bypass 1 \"hs_data_load\" \"hs_data_store\" \"store_data_bypass_p\")\n+\n+;; BYPASS MPY ->\n+;;(define_bypass 3 \"hs_mul\" \"hs_mul\")\n+(define_bypass 1 \"hs_mul\" \"hs_alu1\")\n+(define_bypass 3 \"hs_mul\" \"hs_divrem\")\n+(define_bypass 1 \"hs_mul\" \"hs_data_store\" \"store_data_bypass_p\")"}, {"sha": "65ea44a9f136a940a6476a214499798adee17006", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -127,6 +127,12 @@\n   (and (match_code \"const_int\")\n        (match_test \"UNSIGNED_INT6 (-ival)\")))\n \n+(define_constraint \"C16\"\n+  \"@internal\n+   A 16-bit signed integer constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIGNED_INT16 (ival)\")))\n+\n (define_constraint \"M\"\n   \"@internal\n    A 5-bit unsigned integer constant\"\n@@ -212,6 +218,12 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival && IS_POWEROF2_P (ival + 1)\")))\n \n+(define_constraint \"C3p\"\n+ \"@internal\n+  constant int used to select xbfu a,b,u6 instruction.  The values accepted are 1 and 2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"((ival == 1) || (ival == 2))\")))\n+\n (define_constraint \"Ccp\"\n  \"@internal\n   constant such that ~x (one's Complement) is a power of two\"\n@@ -397,3 +409,15 @@\n    Integer constant zero\"\n   (and (match_code \"const_int\")\n        (match_test \"IS_ZERO (ival)\")))\n+\n+(define_constraint \"Cm2\"\n+  \"@internal\n+   A signed 9-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival >= -256) && (ival <=255)\")))\n+\n+(define_constraint \"C62\"\n+  \"@internal\n+   An unsigned 6-bit integer constant, up to 62.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UNSIGNED_INT6 (ival - 1)\")))"}, {"sha": "43f9474c6910a5b626632e2b44848c05a33eca14", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -664,7 +664,7 @@\n        (match_operand 0 \"shiftr4_operator\")))\n \n (define_predicate \"mult_operator\"\n-    (and (match_code \"mult\") (match_test \"TARGET_ARC700 && !TARGET_NOMPY_SET\"))\n+    (and (match_code \"mult\") (match_test \"TARGET_MPY\"))\n )\n \n (define_predicate \"commutative_operator\"\n@@ -809,3 +809,7 @@\n     (match_test \"INTVAL (op) >= 0\")\n     (and (match_test \"const_double_operand (op, mode)\")\n \t (match_test \"CONST_DOUBLE_HIGH (op) == 0\"))))\n+\n+(define_predicate \"short_const_int_operand\"\n+  (and (match_operand 0 \"const_int_operand\")\n+       (match_test \"satisfies_constraint_C16 (op)\")))"}, {"sha": "ea43a52cdc0094155c514fc463d82e9404487653", "filename": "gcc/config/arc/t-arc-newlib", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Ft-arc-newlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fconfig%2Farc%2Ft-arc-newlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ft-arc-newlib?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -17,19 +17,30 @@\n # with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS=mcpu=ARC600/mcpu=ARC601 mmul64/mmul32x16 mnorm\n-MULTILIB_DIRNAMES=arc600 arc601 mul64 mul32x16 norm\n+MULTILIB_OPTIONS=mcpu=ARC600/mcpu=ARC601/mcpu=ARC700/mcpu=ARCEM/mcpu=ARCHS mmul64/mmul32x16 mnorm\n+MULTILIB_DIRNAMES=arc600 arc601 arc700 em hs mul64 mul32x16 norm\n #\n # Aliases:\n MULTILIB_MATCHES  = mcpu?ARC600=mcpu?arc600\n MULTILIB_MATCHES += mcpu?ARC600=mARC600\n MULTILIB_MATCHES += mcpu?ARC600=mA6\n MULTILIB_MATCHES += mcpu?ARC600=mno-mpy\n MULTILIB_MATCHES += mcpu?ARC601=mcpu?arc601\n+MULTILIB_MATCHES += mcpu?ARC700=mA7\n+MULTILIB_MATCHES += mcpu?ARC700=mARC700\n+MULTILIB_MATCHES += mcpu?ARC700=mcpu?arc700\n+MULTILIB_MATCHES += mcpu?ARCEM=mcpu?arcem\n+MULTILIB_MATCHES += mcpu?ARCHS=mcpu?archs\n MULTILIB_MATCHES += EL=mlittle-endian\n MULTILIB_MATCHES += EB=mbig-endian\n #\n # These don't make sense for the ARC700 default target:\n-MULTILIB_EXCEPTIONS=mmul64* mmul32x16* mnorm*\n+MULTILIB_EXCEPTIONS=mmul64* mmul32x16* norm*\n # And neither of the -mmul* options make sense without -mnorm:\n MULTILIB_EXCLUSIONS=mARC600/mmul64/!mnorm mcpu=ARC601/mmul64/!mnorm mARC600/mmul32x16/!mnorm\n+# Exclusions for ARC700\n+MULTILIB_EXCEPTIONS += mcpu=ARC700/mnorm* mcpu=ARC700/mmul64* mcpu=ARC700/mmul32x16*\n+# Exclusions for ARCv2EM\n+MULTILIB_EXCEPTIONS += mcpu=ARCEM/mmul64* mcpu=ARCEM/mmul32x16*\n+# Exclusions for ARCv2HS\n+MULTILIB_EXCEPTIONS += mcpu=ARCHS/mmul64* mcpu=ARCHS/mmul32x16* mcpu=ARCHS/mnorm*"}, {"sha": "fb908b3a2bc335befd5e6ef4eb9e43b50a62b233", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50bb868f2145ffcc4d330fd6df6367dd5c804e3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f50bb868f2145ffcc4d330fd6df6367dd5c804e3", "patch": "@@ -549,7 +549,9 @@ Objective-C and Objective-C++ Dialects}.\n -mexpand-adddi -mindexed-loads -mlra -mlra-priority-none @gol\n -mlra-priority-compact mlra-priority-noncompact -mno-millicode @gol\n -mmixed-code -mq-class -mRcq -mRcw -msize-level=@var{level} @gol\n--mtune=@var{cpu} -mmultcost=@var{num} -munalign-prob-threshold=@var{probability}}\n+-mtune=@var{cpu} -mmultcost=@var{num} @gol\n+-munalign-prob-threshold=@var{probability} -mmpy-option=@var{multo} @gol\n+-mdiv-rem -mcode-density}\n \n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n@@ -12841,7 +12843,7 @@ is being compiled:\n @item -mbarrel-shifter\n @opindex mbarrel-shifter\n Generate instructions supported by barrel shifter.  This is the default\n-unless @option{-mcpu=ARC601} is in effect.\n+unless @option{-mcpu=ARC601} or @samp{-mcpu=ARCEM} is in effect.\n \n @item -mcpu=@var{cpu}\n @opindex mcpu\n@@ -12854,17 +12856,28 @@ values for @var{cpu} are\n @opindex mA6\n @opindex mARC600\n @item ARC600\n+@item arc600\n Compile for ARC600.  Aliases: @option{-mA6}, @option{-mARC600}.\n \n @item ARC601\n+@item arc601\n @opindex mARC601\n Compile for ARC601.  Alias: @option{-mARC601}.\n \n @item ARC700\n+@item arc700\n @opindex mA7\n @opindex mARC700\n Compile for ARC700.  Aliases: @option{-mA7}, @option{-mARC700}.\n This is the default when configured with @option{--with-cpu=arc700}@.\n+\n+@item ARCEM\n+@item arcem\n+Compile for ARC EM.\n+\n+@item ARCHS\n+@item archs\n+Compile for ARC HS.\n @end table\n \n @item -mdpfp\n@@ -12935,6 +12948,62 @@ can overridden by FPX options; @samp{mspfp}, @samp{mspfp-compact}, or\n @opindex mswap\n Generate swap instructions.\n \n+@item -mdiv-rem\n+@opindex mdiv-rem\n+Enable DIV/REM instructions for ARCv2 cores.\n+\n+@item -mcode-density\n+@opindex mcode-density\n+Enable code density instructions for ARC EM, default on for ARC HS.\n+\n+@item -mmpy-option=@var{multo}\n+@opindex mmpy-option\n+Compile ARCv2 code with a multiplier design option.  @samp{wlh1} is\n+the default value.  The recognized values for @var{multo} are:\n+\n+@table @samp\n+@item 0\n+No multiplier available.\n+\n+@item 1\n+@opindex w\n+The multiply option is set to w: 16x16 multiplier, fully pipelined.\n+The following instructions are enabled: MPYW, and MPYUW.\n+\n+@item 2\n+@opindex wlh1\n+The multiply option is set to wlh1: 32x32 multiplier, fully\n+pipelined (1 stage).  The following instructions are additionaly\n+enabled: MPY, MPYU, MPYM, MPYMU, and MPY_S.\n+\n+@item 3\n+@opindex wlh2\n+The multiply option is set to wlh2: 32x32 multiplier, fully pipelined\n+(2 stages).  The following instructions are additionaly enabled: MPY,\n+MPYU, MPYM, MPYMU, and MPY_S.\n+\n+@item 4\n+@opindex wlh3\n+The multiply option is set to wlh3: Two 16x16 multiplier, blocking,\n+sequential.  The following instructions are additionaly enabled: MPY,\n+MPYU, MPYM, MPYMU, and MPY_S.\n+\n+@item 5\n+@opindex wlh4\n+The multiply option is set to wlh4: One 16x16 multiplier, blocking,\n+sequential.  The following instructions are additionaly enabled: MPY,\n+MPYU, MPYM, MPYMU, and MPY_S.\n+\n+@item 6\n+@opindex wlh5\n+The multiply option is set to wlh5: One 32x4 multiplier, blocking,\n+sequential.  The following instructions are additionaly enabled: MPY,\n+MPYU, MPYM, MPYMU, and MPY_S.\n+\n+@end table\n+\n+This option is only available for ARCv2 cores@.\n+\n @end table\n \n The following options are passed through to the assembler, and also"}]}