{"sha": "f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjNzc3ZjQwYWEwYjY5NDFlZmM3NDQwNDk1YThkN2UwY2MyYTFiYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-21T08:39:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-21T08:39:50Z"}, "message": "tree-optimization: Improve spaceship_replacement [PR94589]\n\nOn Wed, May 19, 2021 at 01:30:31PM -0400, Jason Merrill via Gcc-patches wrote:\n> Here, when genericizing lexicographical_compare_three_way, we haven't yet\n> walked the operands, so (a == a) still sees ADDR_EXPR <a>, but this is after\n> we've changed the type of a to REFERENCE_TYPE.  When we try to fold (a == a)\n> by constexpr evaluation, the constexpr code doesn't understand trying to\n> take the address of a reference, and we end up crashing.\n>\n> Fixed by avoiding constexpr evaluation in genericize_spaceship, by using\n> fold_build2 instead of build_new_op on scalar operands.  Class operands\n> should have been expanded during parsing.\n\nUnfortunately this slightly changed the IL and spaceship_replacement no\nlonger pattern matches it.\n\nHere are 3 improvements that make it match:\n\n1) as mentioned in the comment above spaceship_replacement, for\n   strong_ordering, we are pattern matching something like:\n   x == y ? 0 : x < y ? -1 : 1;\n   and for partial_ordering\n   x == y ? 0 : x < y ? -1 : x > y ? 1 : 2;\n   but given the == comparison done first and the other comparisons only\n   if == was false, we actually don't care if the other comparisons\n   are < vs. <= (or > vs. >=), provided the operands of the comparison\n   are the same; we know == is false when doing those and < vs. <= or\n   > vs. >= have the same behavior for NaNs too\n2) when y is an integral constant, we should treat x < 5 equivalently\n   to x <= 4 etc.\n3) the code punted if cond2_phi_edge wasn't a EDGE_TRUE_VALUE edge, but\n   as the new IL shows, that isn't really needed; given 1) that\n   > and >= are equivalent in the code, any of swapping the comparison\n   operands, changing L[TE]_EXPR to G[TE]_EXPR or vice versa or\n   swapping the EDGE_TRUE_VALUE / EDGE_FALSE_VALUE bits on the edges\n   reverses one of the two comparisons\n\n2021-05-21  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/94589\n\t* tree-ssa-phiopt.c (spaceship_replacement): For integral rhs1 and\n\trhs2, treat x <= 4 equivalently to x < 5 etc.  In cmp1 and cmp2 (if\n\tnot the same as cmp3) treat <= the same as < and >= the same as >.\n\tDon't require that cond2_phi_edge is true edge, instead take\n\tfalse/true edges into account based on cmp1/cmp2 comparison kinds.", "tree": {"sha": "53fbb4793efdf8a510bcf20a937509018caa33b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53fbb4793efdf8a510bcf20a937509018caa33b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f53aff92acef9d5291ffed72995adc33e91fa209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53aff92acef9d5291ffed72995adc33e91fa209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f53aff92acef9d5291ffed72995adc33e91fa209"}], "stats": {"total": 75, "additions": 64, "deletions": 11}, "files": [{"sha": "f133659a781900b5cf6e1f4fed0e5b0de7c712ef", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f1c777f40aa0b6941efc7440495a8d7e0cc2a1bb", "patch": "@@ -1988,8 +1988,16 @@ spaceship_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   gcond *cond1 = as_a <gcond *> (last_stmt (cond_bb));\n   enum tree_code cmp1 = gimple_cond_code (cond1);\n-  if (cmp1 != LT_EXPR && cmp1 != GT_EXPR)\n-    return false;\n+  switch (cmp1)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      break;\n+    default:\n+      return false;\n+    }\n   tree lhs1 = gimple_cond_lhs (cond1);\n   tree rhs1 = gimple_cond_rhs (cond1);\n   /* The optimization may be unsafe due to NaNs.  */\n@@ -2029,7 +2037,42 @@ spaceship_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (lhs2 == lhs1)\n     {\n       if (!operand_equal_p (rhs2, rhs1, 0))\n-\treturn false;\n+\t{\n+\t  if ((cmp2 == EQ_EXPR || cmp2 == NE_EXPR)\n+\t      && TREE_CODE (rhs1) == INTEGER_CST\n+\t      && TREE_CODE (rhs2) == INTEGER_CST)\n+\t    {\n+\t      /* For integers, we can have cond2 x == 5\n+\t\t and cond1 x < 5, x <= 4, x <= 5, x < 6,\n+\t\t x > 5, x >= 6, x >= 5 or x > 4.  */\n+\t      if (tree_int_cst_lt (rhs1, rhs2))\n+\t\t{\n+\t\t  if (wi::ne_p (wi::to_wide (rhs1) + 1, wi::to_wide (rhs2)))\n+\t\t    return false;\n+\t\t  if (cmp1 == LE_EXPR)\n+\t\t    cmp1 = LT_EXPR;\n+\t\t  else if (cmp1 == GT_EXPR)\n+\t\t    cmp1 = GE_EXPR;\n+\t\t  else\n+\t\t    return false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_checking_assert (tree_int_cst_lt (rhs2, rhs1));\n+\t\t  if (wi::ne_p (wi::to_wide (rhs2) + 1, wi::to_wide (rhs1)))\n+\t\t    return false;\n+\t\t  if (cmp1 == LT_EXPR)\n+\t\t    cmp1 = LE_EXPR;\n+\t\t  else if (cmp1 == GE_EXPR)\n+\t\t    cmp1 = GT_EXPR;\n+\t\t  else\n+\t\t    return false;\n+\t\t}\n+\t      rhs1 = rhs2;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n     }\n   else if (lhs2 == rhs1)\n     {\n@@ -2061,20 +2104,30 @@ spaceship_replacement (basic_block cond_bb, basic_block middle_bb,\n \t       || absu_hwi (tree_to_shwi (arg0)) != 1\n \t       || wi::to_widest (arg0) == wi::to_widest (arg1))\n \treturn false;\n-      if (cmp2 != LT_EXPR && cmp2 != GT_EXPR)\n-\treturn false;\n+      switch (cmp2)\n+\t{\n+\tcase LT_EXPR:\n+\tcase LE_EXPR:\n+\tcase GT_EXPR:\n+\tcase GE_EXPR:\n+\t  break;\n+\tdefault:\n+\t  return false;\n+\t}\n       /* if (x < y) goto phi_bb; else fallthru;\n \t if (x > y) goto phi_bb; else fallthru;\n \t bbx:;\n \t phi_bb:;\n \t is ok, but if x and y are swapped in one of the comparisons,\n \t or the comparisons are the same and operands not swapped,\n-\t or second goto phi_bb is not the true edge, it is not.  */\n+\t or the true and false edges are swapped, it is not.  */\n       if ((lhs2 == lhs1)\n-\t  ^ (cmp2 == cmp1)\n-\t  ^ ((e1->flags & EDGE_TRUE_VALUE) != 0))\n-\treturn false;\n-      if ((cond2_phi_edge->flags & EDGE_TRUE_VALUE) == 0)\n+\t  ^ (((cond2_phi_edge->flags\n+\t       & ((cmp2 == LT_EXPR || cmp2 == LE_EXPR)\n+\t\t  ? EDGE_TRUE_VALUE : EDGE_FALSE_VALUE)) != 0)\n+\t     != ((e1->flags\n+\t\t  & ((cmp1 == LT_EXPR || cmp1 == LE_EXPR)\n+\t\t     ? EDGE_TRUE_VALUE : EDGE_FALSE_VALUE)) != 0)))\n \treturn false;\n       if (!single_pred_p (cond2_bb) || !cond_only_block_p (cond2_bb))\n \treturn false;\n@@ -2124,7 +2177,7 @@ spaceship_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* lhs1 one_cmp rhs1 results in phires of 1.  */\n   enum tree_code one_cmp;\n-  if ((cmp1 == LT_EXPR)\n+  if ((cmp1 == LT_EXPR || cmp1 == LE_EXPR)\n       ^ (!integer_onep ((e1->flags & EDGE_TRUE_VALUE) ? arg1 : arg0)))\n     one_cmp = LT_EXPR;\n   else"}]}