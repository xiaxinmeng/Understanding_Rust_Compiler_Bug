{"sha": "a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxNmIzZmNkMDU2MjRjZTBhYWRjYTM0NzhmNmEzYzdiNDk0YzJkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:38:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:38:38Z"}, "message": "[multiple changes]\n\n2017-09-06  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch5.adb, s-diinio.ads, sem_ch4.adb, s-diflio.ads: Minor spelling\n\tadjustments and a typo fix.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb (Resolve_Call): Do not issue info\n\tmessage about inlining of calls to functions in assertions,\n\tfor functions whose body has not been seen yet.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* a-comlin.ads, a-comlin.adb (Argument): Simplify the code, now that\n\twe can use modern Ada in this package.\n\t* s-resfil.ads, s-resfil.adb, a-clrefi.ads, a-clrefi.adb:\n\tMove Ada.Command_Line.Response_File to System.Response_File,\n\tand make Ada.Command_Line.Response_File into a rename of\n\tSystem.Response_File. This is to avoid having gnatbind depend\n\tAda.Command_Line, which would damage the bootstrap process now\n\tthat Ada.Command_Line contains modern Ada (the raise expression).\n\t* gnatbind.adb: Avoid dependence on\n\tAda.Command_Line. Depend on System.Response_File instead\n\tof Ada.Command_Line.Response_File. Change one call to\n\tAda.Command_Line.Command_Name to use Fill_Arg.\tChange one call\n\tto Ada.Command_Line.Argument_Count to use Arg_Count.\n\t* gcc-interface/Make-lang.in, Makefile.rtl: Take note of the new files.\n\nFrom-SVN: r251775", "tree": {"sha": "198c275d0367c716081e97ddbab90621ade51af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/198c275d0367c716081e97ddbab90621ade51af8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/comments", "author": null, "committer": null, "parents": [{"sha": "9caf55e370f2346d393e141b8fb4c4e59afc32c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caf55e370f2346d393e141b8fb4c4e59afc32c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caf55e370f2346d393e141b8fb4c4e59afc32c9"}], "stats": {"total": 1321, "additions": 704, "deletions": 617}, "files": [{"sha": "0d3f844d32104fde00ac4121ea6148da4c98a566", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -1,3 +1,31 @@\n+2017-09-06  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch5.adb, s-diinio.ads, sem_ch4.adb, s-diflio.ads: Minor spelling\n+\tadjustments and a typo fix.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Call): Do not issue info\n+\tmessage about inlining of calls to functions in assertions,\n+\tfor functions whose body has not been seen yet.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* a-comlin.ads, a-comlin.adb (Argument): Simplify the code, now that\n+\twe can use modern Ada in this package.\n+\t* s-resfil.ads, s-resfil.adb, a-clrefi.ads, a-clrefi.adb:\n+\tMove Ada.Command_Line.Response_File to System.Response_File,\n+\tand make Ada.Command_Line.Response_File into a rename of\n+\tSystem.Response_File. This is to avoid having gnatbind depend\n+\tAda.Command_Line, which would damage the bootstrap process now\n+\tthat Ada.Command_Line contains modern Ada (the raise expression).\n+\t* gnatbind.adb: Avoid dependence on\n+\tAda.Command_Line. Depend on System.Response_File instead\n+\tof Ada.Command_Line.Response_File. Change one call to\n+\tAda.Command_Line.Command_Name to use Fill_Arg.\tChange one call\n+\tto Ada.Command_Line.Argument_Count to use Arg_Count.\n+\t* gcc-interface/Make-lang.in, Makefile.rtl: Take note of the new files.\n+\n 2017-09-06  Bob Duff  <duff@adacore.com>\n \n \t* frontend.adb (Frontend): Skip -gnatec=gnat.adc"}, {"sha": "4eb60b536dccf04aca6782ebb958aa6667afcb67", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003-2012, Free Software Foundation, Inc.\n+#   Copyright (C) 2003-2017, Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -651,6 +651,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-ransee$(objext) \\\n   s-regexp$(objext) \\\n   s-regpat$(objext) \\\n+  s-resfil$(objext) \\\n   s-restri$(objext) \\\n   s-rident$(objext) \\\n   s-rpc$(objext)    \\"}, {"sha": "71d05ff7735227a4a744d79d1d21424342e379e8", "filename": "gcc/ada/a-clrefi.adb", "status": "modified", "additions": 4, "deletions": 493, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-clrefi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-clrefi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-clrefi.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -29,497 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-with Ada.Unchecked_Deallocation;\n-\n-with System.OS_Lib; use System.OS_Lib;\n-\n-package body Ada.Command_Line.Response_File is\n-\n-   type File_Rec;\n-   type File_Ptr is access File_Rec;\n-   type File_Rec is record\n-      Name : String_Access;\n-      Next : File_Ptr;\n-      Prev : File_Ptr;\n-   end record;\n-   --  To build a stack of response file names\n-\n-   procedure Free is new Ada.Unchecked_Deallocation (File_Rec, File_Ptr);\n-\n-   type Argument_List_Access is access Argument_List;\n-   procedure Free is new Ada.Unchecked_Deallocation\n-     (Argument_List, Argument_List_Access);\n-   --  Free only the allocated Argument_List, not allocated String components\n-\n-   --------------------\n-   -- Arguments_From --\n-   --------------------\n-\n-   function Arguments_From\n-     (Response_File_Name        : String;\n-      Recursive                 : Boolean := False;\n-      Ignore_Non_Existing_Files : Boolean := False)\n-      return Argument_List\n-   is\n-      First_File : File_Ptr := null;\n-      Last_File  : File_Ptr := null;\n-      --  The stack of response files\n-\n-      Arguments  : Argument_List_Access := new Argument_List (1 .. 4);\n-      Last_Arg   : Natural := 0;\n-\n-      procedure Add_Argument (Arg : String);\n-      --  Add argument Arg to argument list Arguments, increasing Arguments\n-      --  if necessary.\n-\n-      procedure Recurse (File_Name : String);\n-      --  Get the arguments from the file and call itself recursively if one of\n-      --  the argument starts with character '@'.\n-\n-      ------------------\n-      -- Add_Argument --\n-      ------------------\n-\n-      procedure Add_Argument (Arg : String) is\n-      begin\n-         if Last_Arg = Arguments'Last then\n-            declare\n-               New_Arguments : constant Argument_List_Access :=\n-                 new Argument_List (1 .. Arguments'Last * 2);\n-            begin\n-               New_Arguments (Arguments'Range) := Arguments.all;\n-               Arguments.all := (others => null);\n-               Free (Arguments);\n-               Arguments := New_Arguments;\n-            end;\n-         end if;\n-\n-         Last_Arg := Last_Arg + 1;\n-         Arguments (Last_Arg) := new String'(Arg);\n-      end Add_Argument;\n-\n-      -------------\n-      -- Recurse --\n-      -------------\n-\n-      procedure Recurse (File_Name : String) is\n-         --  Open the response file. If not found, fail or report a warning,\n-         --  depending on the value of Ignore_Non_Existing_Files.\n-\n-         FD : constant File_Descriptor := Open_Read (File_Name, Text);\n-\n-         Buffer_Size : constant := 1500;\n-         Buffer : String (1 .. Buffer_Size);\n-\n-         Buffer_Length : Natural;\n-\n-         Buffer_Cursor : Natural;\n-\n-         End_Of_File_Reached : Boolean;\n-\n-         Line : String (1 .. Max_Line_Length + 1);\n-         Last : Natural;\n-\n-         First_Char : Positive;\n-         --  Index of the first character of an argument in Line\n-\n-         Last_Char : Natural;\n-         --  Index of the last character of an argument in Line\n-\n-         In_String : Boolean;\n-         --  True when inside a quoted string\n-\n-         Arg : Positive;\n-\n-         function End_Of_File return Boolean;\n-         --  True when the end of the response file has been reached\n-\n-         procedure Get_Buffer;\n-         --  Read one buffer from the response file\n-\n-         procedure Get_Line;\n-         --  Get one line from the response file\n-\n-         -----------------\n-         -- End_Of_File --\n-         -----------------\n-\n-         function End_Of_File return Boolean is\n-         begin\n-            return End_Of_File_Reached and then Buffer_Cursor > Buffer_Length;\n-         end End_Of_File;\n-\n-         ----------------\n-         -- Get_Buffer --\n-         ----------------\n-\n-         procedure Get_Buffer is\n-         begin\n-            Buffer_Length := Read (FD, Buffer (1)'Address, Buffer'Length);\n-            End_Of_File_Reached := Buffer_Length < Buffer'Length;\n-            Buffer_Cursor := 1;\n-         end Get_Buffer;\n-\n-         --------------\n-         -- Get_Line --\n-         --------------\n-\n-         procedure Get_Line is\n-            Ch : Character;\n-\n-         begin\n-            Last := 0;\n-\n-            if End_Of_File then\n-               return;\n-            end if;\n-\n-            loop\n-               Ch := Buffer (Buffer_Cursor);\n-\n-               exit when Ch = ASCII.CR or else\n-                         Ch = ASCII.LF or else\n-                         Ch = ASCII.FF;\n-\n-               Last := Last + 1;\n-               Line (Last) := Ch;\n-\n-               if Last = Line'Last then\n-                  return;\n-               end if;\n-\n-               Buffer_Cursor := Buffer_Cursor + 1;\n-\n-               if Buffer_Cursor > Buffer_Length then\n-                  Get_Buffer;\n-\n-                  if End_Of_File then\n-                     return;\n-                  end if;\n-               end if;\n-            end loop;\n-\n-            loop\n-               Ch := Buffer (Buffer_Cursor);\n-\n-               exit when Ch /= ASCII.HT and then\n-                         Ch /= ASCII.LF and then\n-                         Ch /= ASCII.FF;\n-\n-               Buffer_Cursor := Buffer_Cursor + 1;\n-\n-               if Buffer_Cursor > Buffer_Length then\n-                  Get_Buffer;\n-\n-                  if End_Of_File then\n-                     return;\n-                  end if;\n-               end if;\n-            end loop;\n-         end Get_Line;\n-\n-      --  Start of processing for Recurse\n-\n-      begin\n-         Last_Arg := 0;\n-\n-         if FD = Invalid_FD then\n-            if Ignore_Non_Existing_Files then\n-               return;\n-            else\n-               raise File_Does_Not_Exist;\n-            end if;\n-         end if;\n-\n-         --  Put the response file name on the stack\n-\n-         if First_File = null then\n-            First_File :=\n-              new File_Rec'\n-                (Name => new String'(File_Name),\n-                 Next => null,\n-                 Prev => null);\n-            Last_File  := First_File;\n-\n-         else\n-            declare\n-               Current : File_Ptr := First_File;\n-\n-            begin\n-               loop\n-                  if Current.Name.all = File_Name then\n-                     raise Circularity_Detected;\n-                  end if;\n-\n-                  Current := Current.Next;\n-                  exit when Current = null;\n-               end loop;\n-\n-               Last_File.Next :=\n-                 new File_Rec'\n-                   (Name => new String'(File_Name),\n-                    Next => null,\n-                    Prev => Last_File);\n-               Last_File := Last_File.Next;\n-            end;\n-         end if;\n-\n-         End_Of_File_Reached := False;\n-         Get_Buffer;\n-\n-         --  Read the response file line by line\n-\n-         Line_Loop :\n-         while not End_Of_File loop\n-            Get_Line;\n-\n-            if Last = Line'Last then\n-               raise Line_Too_Long;\n-            end if;\n-\n-            First_Char := 1;\n-\n-            --  Get each argument on the line\n-\n-            Arg_Loop :\n-            loop\n-               --  First, skip any white space\n-\n-               while First_Char <= Last loop\n-                  exit when Line (First_Char) /= ' ' and then\n-                            Line (First_Char) /= ASCII.HT;\n-                  First_Char := First_Char + 1;\n-               end loop;\n-\n-               exit Arg_Loop when First_Char > Last;\n-\n-               Last_Char := First_Char;\n-               In_String := False;\n-\n-               --  Get the character one by one\n-\n-               Character_Loop :\n-               while Last_Char <= Last loop\n-\n-                  --  Inside a string, check only for '\"'\n-\n-                  if In_String then\n-                     if Line (Last_Char) = '\"' then\n-\n-                        --  Remove the '\"'\n-\n-                        Line (Last_Char .. Last - 1) :=\n-                          Line (Last_Char + 1 .. Last);\n-                        Last := Last - 1;\n-\n-                        --  End of string is end of argument\n-\n-                        if Last_Char > Last or else\n-                          Line (Last_Char) = ' ' or else\n-                          Line (Last_Char) = ASCII.HT\n-                        then\n-                           In_String := False;\n-\n-                           Last_Char := Last_Char - 1;\n-                           exit Character_Loop;\n-\n-                        else\n-                           --  If there are two consecutive '\"', the quoted\n-                           --  string is not closed\n-\n-                           In_String := Line (Last_Char) = '\"';\n-\n-                           if In_String then\n-                              Last_Char := Last_Char + 1;\n-                           end if;\n-                        end if;\n-\n-                     else\n-                        Last_Char := Last_Char + 1;\n-                     end if;\n-\n-                  elsif Last_Char = Last then\n-\n-                     --  An opening '\"' at the end of the line is an error\n-\n-                     if Line (Last) = '\"' then\n-                        raise No_Closing_Quote;\n-\n-                     else\n-                        --  The argument ends with the line\n-\n-                        exit Character_Loop;\n-                     end if;\n-\n-                  elsif Line (Last_Char) = '\"' then\n-\n-                     --  Entering a quoted string: remove the '\"'\n-\n-                     In_String := True;\n-                     Line (Last_Char .. Last - 1) :=\n-                       Line (Last_Char + 1 .. Last);\n-                     Last := Last - 1;\n-\n-                  else\n-                     --  Outside quoted strings, white space ends the argument\n-\n-                     exit Character_Loop\n-                          when Line (Last_Char + 1) = ' ' or else\n-                               Line (Last_Char + 1) = ASCII.HT;\n-\n-                     Last_Char := Last_Char + 1;\n-                  end if;\n-               end loop Character_Loop;\n-\n-               --  It is an error to not close a quoted string before the end\n-               --  of the line.\n-\n-               if In_String then\n-                  raise No_Closing_Quote;\n-               end if;\n-\n-               --  Add the argument to the list\n-\n-               declare\n-                  Arg : String (1 .. Last_Char - First_Char + 1);\n-               begin\n-                  Arg := Line (First_Char .. Last_Char);\n-                  Add_Argument (Arg);\n-               end;\n-\n-               --  Next argument, if line is not finished\n-\n-               First_Char := Last_Char + 1;\n-            end loop Arg_Loop;\n-         end loop Line_Loop;\n-\n-         Close (FD);\n-\n-         --  If Recursive is True, check for any argument starting with '@'\n-\n-         if Recursive then\n-            Arg := 1;\n-            while Arg <= Last_Arg loop\n-\n-               if Arguments (Arg)'Length > 0 and then\n-                  Arguments (Arg) (1) = '@'\n-               then\n-                  --  Ignore argument \"@\" with no file name\n-\n-                  if Arguments (Arg)'Length = 1 then\n-                     Arguments (Arg .. Last_Arg - 1) :=\n-                       Arguments (Arg + 1 .. Last_Arg);\n-                     Last_Arg := Last_Arg - 1;\n-\n-                  else\n-                     --  Save the current arguments and get those in the new\n-                     --  response file.\n-\n-                     declare\n-                        Inc_File_Name     : constant String :=\n-                          Arguments (Arg) (2 .. Arguments (Arg)'Last);\n-                        Current_Arguments : constant Argument_List :=\n-                          Arguments (1 .. Last_Arg);\n-                     begin\n-                        Recurse (Inc_File_Name);\n-\n-                        --  Insert the new arguments where the new response\n-                        --  file was imported.\n-\n-                        declare\n-                           New_Arguments : constant Argument_List :=\n-                             Arguments (1 .. Last_Arg);\n-                           New_Last_Arg  : constant Positive :=\n-                             Current_Arguments'Length +\n-                             New_Arguments'Length - 1;\n-\n-                        begin\n-                           --  Grow Arguments if it is not large enough\n-\n-                           if Arguments'Last < New_Last_Arg then\n-                              Last_Arg := Arguments'Last;\n-                              Free (Arguments);\n-\n-                              while Last_Arg < New_Last_Arg loop\n-                                 Last_Arg := Last_Arg * 2;\n-                              end loop;\n-\n-                              Arguments := new Argument_List (1 .. Last_Arg);\n-                           end if;\n-\n-                           Last_Arg := New_Last_Arg;\n-\n-                           Arguments (1 .. Last_Arg) :=\n-                             Current_Arguments (1 .. Arg - 1) &\n-                           New_Arguments &\n-                           Current_Arguments\n-                             (Arg + 1 .. Current_Arguments'Last);\n-\n-                           Arg := Arg + New_Arguments'Length;\n-                        end;\n-                     end;\n-                  end if;\n-\n-               else\n-                  Arg := Arg + 1;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         --  Remove the response file name from the stack\n-\n-         if First_File = Last_File then\n-            System.Strings.Free (First_File.Name);\n-            Free (First_File);\n-            First_File := null;\n-            Last_File := null;\n-\n-         else\n-            System.Strings.Free (Last_File.Name);\n-            Last_File := Last_File.Prev;\n-            Free (Last_File.Next);\n-         end if;\n-\n-      exception\n-         when others =>\n-            Close (FD);\n-\n-            raise;\n-      end Recurse;\n-\n-   --  Start of processing for Arguments_From\n-\n-   begin\n-      --  The job is done by procedure Recurse\n-\n-      Recurse (Response_File_Name);\n-\n-      --  Free Arguments before returning the result\n-\n-      declare\n-         Result : constant Argument_List := Arguments (1 .. Last_Arg);\n-      begin\n-         Free (Arguments);\n-         return Result;\n-      end;\n-\n-   exception\n-      when others =>\n-\n-         --  When an exception occurs, deallocate everything\n-\n-         Free (Arguments);\n-\n-         while First_File /= null loop\n-            Last_File := First_File.Next;\n-            System.Strings.Free (First_File.Name);\n-            Free (First_File);\n-            First_File := Last_File;\n-         end loop;\n-\n-         raise;\n-   end Arguments_From;\n-\n-end Ada.Command_Line.Response_File;\n+pragma No_Body;"}, {"sha": "14971f320e3f9c7e3feb063976963f0bf4985abc", "filename": "gcc/ada/a-clrefi.ads", "status": "modified", "additions": 4, "deletions": 69, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-clrefi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-clrefi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-clrefi.ads?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2007-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2007-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,72 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package is intended to be used in conjunction with its parent unit,\n---  Ada.Command_Line. It provides facilities for getting command line arguments\n---  from a text file, called a \"response file\".\n---\n---  Using a response file allow passing a set of arguments to an executable\n---  longer than the maximum allowed by the system on the command line.\n+--  See s-resfil.ads for documentation\n \n-pragma Compiler_Unit_Warning;\n-\n-with System.Strings;\n-\n-package Ada.Command_Line.Response_File is\n-\n-   subtype String_Access is System.Strings.String_Access;\n-   --  type String_Access is access all String;\n-\n-   procedure Free (S : in out String_Access) renames System.Strings.Free;\n-   --  To deallocate a String\n-\n-   subtype Argument_List is System.Strings.String_List;\n-   --  type String_List is array (Positive range <>) of String_Access;\n-\n-   Max_Line_Length : constant := 4096;\n-   --  The maximum length of lines in a response file\n-\n-   File_Does_Not_Exist : exception;\n-   --  Raise by Arguments_From when a response file cannot be found\n-\n-   Line_Too_Long : exception;\n-   --  Raise by Arguments_From when a line in the response file is longer than\n-   --  Max_Line_Length.\n-\n-   No_Closing_Quote : exception;\n-   --  Raise by Arguments_From when a quoted string does not end before the\n-   --  end of the line.\n-\n-   Circularity_Detected : exception;\n-   --  Raise by Arguments_From when Recursive is True and the same response\n-   --  file is reading itself, either directly or indirectly.\n-\n-   function Arguments_From\n-     (Response_File_Name        : String;\n-      Recursive                 : Boolean := False;\n-      Ignore_Non_Existing_Files : Boolean := False)\n-      return Argument_List;\n-   --  Read response file with name Response_File_Name and return the argument\n-   --  it contains as an Argument_List. It is the responsibility of the caller\n-   --  to deallocate the strings in the Argument_List if desired. When\n-   --  Recursive is True, any argument of the form @file_name indicates the\n-   --  name of another response file and is replaced by the arguments in this\n-   --  response file.\n-   --\n-   --  Each non empty line of the response file contains one or several\n-   --  arguments separated by white space. Empty lines or lines containing only\n-   --  white space are ignored. Arguments containing white space or a double\n-   --  quote ('\"')must be quoted. A double quote inside a quote string is\n-   --  indicated by two consecutive double quotes. Example: \"-Idir with quote\n-   --  \"\" and spaces\" Non white space characters immediately before or after a\n-   --  quoted string are part of the same argument. Example -Idir\" with \"spaces\n-   --\n-   --  When a response file cannot be found, exception File_Does_Not_Exist is\n-   --  raised if Ignore_Non_Existing_Files is False, otherwise the response\n-   --  file is ignored. Exception Line_Too_Long is raised when a line of a\n-   --  response file is longer than Max_Line_Length. Exception No_Closing_Quote\n-   --  is raised when a quoted argument is not closed before the end of the\n-   --  line. Exception Circularity_Detected is raised when a Recursive is True\n-   --  and a response file is reading itself, either directly or indirectly.\n-\n-end Ada.Command_Line.Response_File;\n+with System.Response_File;\n+package Ada.Command_Line.Response_File renames System.Response_File;"}, {"sha": "2af8bd9e7acaa9f7eeafd8da23431dd07e8db836", "filename": "gcc/ada/a-comlin.adb", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n-\n with System; use System;\n \n package body Ada.Command_Line is\n@@ -58,25 +56,12 @@ package body Ada.Command_Line is\n    --------------\n \n    function Argument (Number : Positive) return String is\n-      Num : Positive;\n-\n+      Num : constant Positive :=\n+        (if Remove_Args = null then Number else Remove_Args (Number));\n+      Arg : aliased String (1 .. Len_Arg (Num));\n    begin\n-      if Number > Argument_Count then\n-         raise Constraint_Error;\n-      end if;\n-\n-      if Remove_Args = null then\n-         Num := Number;\n-      else\n-         Num := Remove_Args (Number);\n-      end if;\n-\n-      declare\n-         Arg : aliased String (1 .. Len_Arg (Num));\n-      begin\n-         Fill_Arg (Arg'Address, Num);\n-         return Arg;\n-      end;\n+      Fill_Arg (Arg'Address, Num);\n+      return Arg;\n    end Argument;\n \n    --------------------"}, {"sha": "b8e556270c215035d8e6c9515b7446e9455bfc8d", "filename": "gcc/ada/a-comlin.ads", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fa-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.ads?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -33,8 +33,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n-\n package Ada.Command_Line is\n    pragma Preelaborate;\n \n@@ -45,14 +43,8 @@ package Ada.Command_Line is\n    --\n    --  In GNAT: Corresponds to (argc - 1) in C.\n \n-   pragma Assertion_Policy (Pre => Ignore);\n-   --  We need to ignore the precondition of Argument, below, so that we don't\n-   --  raise Assertion_Error. The body raises Constraint_Error. It would be\n-   --  cleaner to add \"or else raise Constraint_Error\" to the precondition, but\n-   --  SPARK does not yet support raise expressions.\n-\n-   function Argument (Number : Positive) return String;\n-   pragma Precondition (Number <= Argument_Count);\n+   function Argument (Number : Positive) return String with\n+      Pre => Number <= Argument_Count or else raise Constraint_Error;\n    --  If the external execution environment supports passing arguments to\n    --  a program, then Argument returns an implementation-defined value\n    --  corresponding to the argument at relative position Number. If Number"}, {"sha": "981137d43096c2251648bb6c1da08af5c464f3bc", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -3957,7 +3957,7 @@ package body Exp_Ch5 is\n                --  redefined on derived container types, while the default\n                --  iterator was inherited from the parent type. This\n                --  nonstandard extension is preserved for use by the\n-               --  modelling project under debug flag -gnatd.X.\n+               --  modeling project under debug flag -gnatd.X.\n \n                if Debug_Flag_Dot_XX then\n                   if Base_Type (Etype (Container)) /="}, {"sha": "e38a1f9e06f446f4543941383d93b88759df71e8", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -468,8 +468,6 @@ GNAT1_ADA_OBJS = $(GNAT_ADA_OBJS) ada/back_end.o ada/gnat1drv.o\n GNAT1_OBJS = $(GNAT1_C_OBJS) $(GNAT1_ADA_OBJS) ada/b_gnat1.o\n \n GNATBIND_OBJS = \\\n- ada/a-clrefi.o   \\\n- ada/a-comlin.o   \\\n  ada/a-elchha.o   \\\n  ada/a-except.o   \\\n  ada/ada.o        \\\n@@ -553,6 +551,7 @@ GNATBIND_OBJS = \\\n  ada/s-memory.o   \\\n  ada/s-os_lib.o   \\\n  ada/s-parame.o   \\\n+ ada/s-resfil.o   \\\n  ada/s-restri.o   \\\n  ada/s-secsta.o   \\\n  ada/s-soflin.o   \\"}, {"sha": "63e796521436af8e1b8a403ec4ecf07a04e4534b", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -36,7 +36,12 @@ with Debug;    use Debug;\n with Fmap;\n with Namet;    use Namet;\n with Opt;      use Opt;\n+\n with Osint;    use Osint;\n+--  Note that we use low-level routines in Osint to read command-line\n+--  arguments. We cannot depend on Ada.Command_Line, because it contains modern\n+--  Ada features that would break bootstrapping with old base compilers.\n+\n with Osint.B;  use Osint.B;\n with Output;   use Output;\n with Rident;   use Rident;\n@@ -47,10 +52,9 @@ with Targparm; use Targparm;\n with Types;    use Types;\n \n with System.Case_Util; use System.Case_Util;\n+with System.Response_File;\n with System.OS_Lib;    use System.OS_Lib;\n \n-with Ada.Command_Line.Response_File; use Ada.Command_Line;\n-\n procedure Gnatbind is\n \n    Total_Errors : Nat := 0;\n@@ -505,8 +509,6 @@ procedure Gnatbind is\n       Next_Arg : Positive := 1;\n \n    begin\n-      --  Use low level argument routines to avoid dragging in secondary stack\n-\n       while Next_Arg < Arg_Count loop\n          declare\n             Next_Argv : String (1 .. Len_Arg (Next_Arg));\n@@ -519,7 +521,7 @@ procedure Gnatbind is\n                   if Next_Argv'Length > 1 then\n                      declare\n                         Arguments : constant Argument_List :=\n-                                      Response_File.Arguments_From\n+                          System.Response_File.Arguments_From\n                                         (Response_File_Name        =>\n                                            Next_Argv (2 .. Next_Argv'Last),\n                                          Recursive                 => True,\n@@ -598,7 +600,13 @@ begin\n    Scan_Bind_Args;\n \n    if Verbose_Mode then\n-      Write_Str (Command_Name);\n+      declare\n+         Command_Name : String (1 .. Len_Arg (0));\n+      begin\n+         Fill_Arg (Command_Name'Address, 0);\n+         Write_Str (Command_Name);\n+      end;\n+\n       Put_Bind_Args;\n       Write_Eol;\n    end if;\n@@ -669,7 +677,7 @@ begin\n    --  Output usage information if no arguments\n \n    if not More_Lib_Files then\n-      if Argument_Count = 0 then\n+      if Arg_Count = 0 then\n          Bindusg.Display;\n       else\n          Write_Line (\"try \"\"gnatbind --help\"\" for more information.\");"}, {"sha": "223f5a23712fb42b268d96df54944e462f0ee8c1", "filename": "gcc/ada/s-diflio.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-diflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-diflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diflio.ads?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@\n ------------------------------------------------------------------------------\n \n --  This package provides output routines for float dimensioned types. All Put\n---  routines are modelled after those in package Ada.Text_IO.Float_IO with the\n+--  routines are modeled after those in package Ada.Text_IO.Float_IO with the\n --  addition of an extra default parameter. All Put_Dim_Of routines\n --  output the dimension of Item in a symbolic manner.\n "}, {"sha": "babcc166b114eac075e06f62158a9fe6d657154b", "filename": "gcc/ada/s-diinio.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-diinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-diinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diinio.ads?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,7 @@\n ------------------------------------------------------------------------------\n \n --  This package provides output routines for integer dimensioned types. All\n---  Put routines are modelled after those in package Ada.Text_IO.Integer_IO\n+--  Put routines are modeled after those in package Ada.Text_IO.Integer_IO\n --  with the addition of an extra default parameter. All Put_Dim_Of routines\n --  output the dimension of Item in a symbolic manner.\n "}, {"sha": "b36ff944592bea3a6da70910242967e0d47c862e", "filename": "gcc/ada/s-resfil.adb", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-resfil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-resfil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-resfil.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -0,0 +1,525 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . R E S P O N S E _ F I L E                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2007-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Compiler_Unit_Warning;\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with System.OS_Lib; use System.OS_Lib;\n+\n+package body System.Response_File is\n+\n+   type File_Rec;\n+   type File_Ptr is access File_Rec;\n+   type File_Rec is record\n+      Name : String_Access;\n+      Next : File_Ptr;\n+      Prev : File_Ptr;\n+   end record;\n+   --  To build a stack of response file names\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (File_Rec, File_Ptr);\n+\n+   type Argument_List_Access is access Argument_List;\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Argument_List, Argument_List_Access);\n+   --  Free only the allocated Argument_List, not allocated String components\n+\n+   --------------------\n+   -- Arguments_From --\n+   --------------------\n+\n+   function Arguments_From\n+     (Response_File_Name        : String;\n+      Recursive                 : Boolean := False;\n+      Ignore_Non_Existing_Files : Boolean := False)\n+      return Argument_List\n+   is\n+      First_File : File_Ptr := null;\n+      Last_File  : File_Ptr := null;\n+      --  The stack of response files\n+\n+      Arguments  : Argument_List_Access := new Argument_List (1 .. 4);\n+      Last_Arg   : Natural := 0;\n+\n+      procedure Add_Argument (Arg : String);\n+      --  Add argument Arg to argument list Arguments, increasing Arguments\n+      --  if necessary.\n+\n+      procedure Recurse (File_Name : String);\n+      --  Get the arguments from the file and call itself recursively if one of\n+      --  the arguments starts with character '@'.\n+\n+      ------------------\n+      -- Add_Argument --\n+      ------------------\n+\n+      procedure Add_Argument (Arg : String) is\n+      begin\n+         if Last_Arg = Arguments'Last then\n+            declare\n+               New_Arguments : constant Argument_List_Access :=\n+                 new Argument_List (1 .. Arguments'Last * 2);\n+            begin\n+               New_Arguments (Arguments'Range) := Arguments.all;\n+               Arguments.all := (others => null);\n+               Free (Arguments);\n+               Arguments := New_Arguments;\n+            end;\n+         end if;\n+\n+         Last_Arg := Last_Arg + 1;\n+         Arguments (Last_Arg) := new String'(Arg);\n+      end Add_Argument;\n+\n+      -------------\n+      -- Recurse --\n+      -------------\n+\n+      procedure Recurse (File_Name : String) is\n+         --  Open the response file. If not found, fail or report a warning,\n+         --  depending on the value of Ignore_Non_Existing_Files.\n+\n+         FD : constant File_Descriptor := Open_Read (File_Name, Text);\n+\n+         Buffer_Size : constant := 1500;\n+         Buffer : String (1 .. Buffer_Size);\n+\n+         Buffer_Length : Natural;\n+\n+         Buffer_Cursor : Natural;\n+\n+         End_Of_File_Reached : Boolean;\n+\n+         Line : String (1 .. Max_Line_Length + 1);\n+         Last : Natural;\n+\n+         First_Char : Positive;\n+         --  Index of the first character of an argument in Line\n+\n+         Last_Char : Natural;\n+         --  Index of the last character of an argument in Line\n+\n+         In_String : Boolean;\n+         --  True when inside a quoted string\n+\n+         Arg : Positive;\n+\n+         function End_Of_File return Boolean;\n+         --  True when the end of the response file has been reached\n+\n+         procedure Get_Buffer;\n+         --  Read one buffer from the response file\n+\n+         procedure Get_Line;\n+         --  Get one line from the response file\n+\n+         -----------------\n+         -- End_Of_File --\n+         -----------------\n+\n+         function End_Of_File return Boolean is\n+         begin\n+            return End_Of_File_Reached and then Buffer_Cursor > Buffer_Length;\n+         end End_Of_File;\n+\n+         ----------------\n+         -- Get_Buffer --\n+         ----------------\n+\n+         procedure Get_Buffer is\n+         begin\n+            Buffer_Length := Read (FD, Buffer (1)'Address, Buffer'Length);\n+            End_Of_File_Reached := Buffer_Length < Buffer'Length;\n+            Buffer_Cursor := 1;\n+         end Get_Buffer;\n+\n+         --------------\n+         -- Get_Line --\n+         --------------\n+\n+         procedure Get_Line is\n+            Ch : Character;\n+\n+         begin\n+            Last := 0;\n+\n+            if End_Of_File then\n+               return;\n+            end if;\n+\n+            loop\n+               Ch := Buffer (Buffer_Cursor);\n+\n+               exit when Ch = ASCII.CR or else\n+                         Ch = ASCII.LF or else\n+                         Ch = ASCII.FF;\n+\n+               Last := Last + 1;\n+               Line (Last) := Ch;\n+\n+               if Last = Line'Last then\n+                  return;\n+               end if;\n+\n+               Buffer_Cursor := Buffer_Cursor + 1;\n+\n+               if Buffer_Cursor > Buffer_Length then\n+                  Get_Buffer;\n+\n+                  if End_Of_File then\n+                     return;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            loop\n+               Ch := Buffer (Buffer_Cursor);\n+\n+               exit when Ch /= ASCII.HT and then\n+                         Ch /= ASCII.LF and then\n+                         Ch /= ASCII.FF;\n+\n+               Buffer_Cursor := Buffer_Cursor + 1;\n+\n+               if Buffer_Cursor > Buffer_Length then\n+                  Get_Buffer;\n+\n+                  if End_Of_File then\n+                     return;\n+                  end if;\n+               end if;\n+            end loop;\n+         end Get_Line;\n+\n+      --  Start of processing for Recurse\n+\n+      begin\n+         Last_Arg := 0;\n+\n+         if FD = Invalid_FD then\n+            if Ignore_Non_Existing_Files then\n+               return;\n+            else\n+               raise File_Does_Not_Exist;\n+            end if;\n+         end if;\n+\n+         --  Put the response file name on the stack\n+\n+         if First_File = null then\n+            First_File :=\n+              new File_Rec'\n+                (Name => new String'(File_Name),\n+                 Next => null,\n+                 Prev => null);\n+            Last_File  := First_File;\n+\n+         else\n+            declare\n+               Current : File_Ptr := First_File;\n+\n+            begin\n+               loop\n+                  if Current.Name.all = File_Name then\n+                     raise Circularity_Detected;\n+                  end if;\n+\n+                  Current := Current.Next;\n+                  exit when Current = null;\n+               end loop;\n+\n+               Last_File.Next :=\n+                 new File_Rec'\n+                   (Name => new String'(File_Name),\n+                    Next => null,\n+                    Prev => Last_File);\n+               Last_File := Last_File.Next;\n+            end;\n+         end if;\n+\n+         End_Of_File_Reached := False;\n+         Get_Buffer;\n+\n+         --  Read the response file line by line\n+\n+         Line_Loop :\n+         while not End_Of_File loop\n+            Get_Line;\n+\n+            if Last = Line'Last then\n+               raise Line_Too_Long;\n+            end if;\n+\n+            First_Char := 1;\n+\n+            --  Get each argument on the line\n+\n+            Arg_Loop :\n+            loop\n+               --  First, skip any white space\n+\n+               while First_Char <= Last loop\n+                  exit when Line (First_Char) /= ' ' and then\n+                            Line (First_Char) /= ASCII.HT;\n+                  First_Char := First_Char + 1;\n+               end loop;\n+\n+               exit Arg_Loop when First_Char > Last;\n+\n+               Last_Char := First_Char;\n+               In_String := False;\n+\n+               --  Get the character one by one\n+\n+               Character_Loop :\n+               while Last_Char <= Last loop\n+\n+                  --  Inside a string, check only for '\"'\n+\n+                  if In_String then\n+                     if Line (Last_Char) = '\"' then\n+\n+                        --  Remove the '\"'\n+\n+                        Line (Last_Char .. Last - 1) :=\n+                          Line (Last_Char + 1 .. Last);\n+                        Last := Last - 1;\n+\n+                        --  End of string is end of argument\n+\n+                        if Last_Char > Last or else\n+                          Line (Last_Char) = ' ' or else\n+                          Line (Last_Char) = ASCII.HT\n+                        then\n+                           In_String := False;\n+\n+                           Last_Char := Last_Char - 1;\n+                           exit Character_Loop;\n+\n+                        else\n+                           --  If there are two consecutive '\"', the quoted\n+                           --  string is not closed\n+\n+                           In_String := Line (Last_Char) = '\"';\n+\n+                           if In_String then\n+                              Last_Char := Last_Char + 1;\n+                           end if;\n+                        end if;\n+\n+                     else\n+                        Last_Char := Last_Char + 1;\n+                     end if;\n+\n+                  elsif Last_Char = Last then\n+\n+                     --  An opening '\"' at the end of the line is an error\n+\n+                     if Line (Last) = '\"' then\n+                        raise No_Closing_Quote;\n+\n+                     else\n+                        --  The argument ends with the line\n+\n+                        exit Character_Loop;\n+                     end if;\n+\n+                  elsif Line (Last_Char) = '\"' then\n+\n+                     --  Entering a quoted string: remove the '\"'\n+\n+                     In_String := True;\n+                     Line (Last_Char .. Last - 1) :=\n+                       Line (Last_Char + 1 .. Last);\n+                     Last := Last - 1;\n+\n+                  else\n+                     --  Outside quoted strings, white space ends the argument\n+\n+                     exit Character_Loop\n+                          when Line (Last_Char + 1) = ' ' or else\n+                               Line (Last_Char + 1) = ASCII.HT;\n+\n+                     Last_Char := Last_Char + 1;\n+                  end if;\n+               end loop Character_Loop;\n+\n+               --  It is an error to not close a quoted string before the end\n+               --  of the line.\n+\n+               if In_String then\n+                  raise No_Closing_Quote;\n+               end if;\n+\n+               --  Add the argument to the list\n+\n+               declare\n+                  Arg : String (1 .. Last_Char - First_Char + 1);\n+               begin\n+                  Arg := Line (First_Char .. Last_Char);\n+                  Add_Argument (Arg);\n+               end;\n+\n+               --  Next argument, if line is not finished\n+\n+               First_Char := Last_Char + 1;\n+            end loop Arg_Loop;\n+         end loop Line_Loop;\n+\n+         Close (FD);\n+\n+         --  If Recursive is True, check for any argument starting with '@'\n+\n+         if Recursive then\n+            Arg := 1;\n+            while Arg <= Last_Arg loop\n+\n+               if Arguments (Arg)'Length > 0 and then\n+                  Arguments (Arg) (1) = '@'\n+               then\n+                  --  Ignore argument '@' with no file name\n+\n+                  if Arguments (Arg)'Length = 1 then\n+                     Arguments (Arg .. Last_Arg - 1) :=\n+                       Arguments (Arg + 1 .. Last_Arg);\n+                     Last_Arg := Last_Arg - 1;\n+\n+                  else\n+                     --  Save the current arguments and get those in the new\n+                     --  response file.\n+\n+                     declare\n+                        Inc_File_Name     : constant String :=\n+                          Arguments (Arg) (2 .. Arguments (Arg)'Last);\n+                        Current_Arguments : constant Argument_List :=\n+                          Arguments (1 .. Last_Arg);\n+                     begin\n+                        Recurse (Inc_File_Name);\n+\n+                        --  Insert the new arguments where the new response\n+                        --  file was imported.\n+\n+                        declare\n+                           New_Arguments : constant Argument_List :=\n+                             Arguments (1 .. Last_Arg);\n+                           New_Last_Arg  : constant Positive :=\n+                             Current_Arguments'Length +\n+                             New_Arguments'Length - 1;\n+\n+                        begin\n+                           --  Grow Arguments if it is not large enough\n+\n+                           if Arguments'Last < New_Last_Arg then\n+                              Last_Arg := Arguments'Last;\n+                              Free (Arguments);\n+\n+                              while Last_Arg < New_Last_Arg loop\n+                                 Last_Arg := Last_Arg * 2;\n+                              end loop;\n+\n+                              Arguments := new Argument_List (1 .. Last_Arg);\n+                           end if;\n+\n+                           Last_Arg := New_Last_Arg;\n+\n+                           Arguments (1 .. Last_Arg) :=\n+                             Current_Arguments (1 .. Arg - 1) &\n+                           New_Arguments &\n+                           Current_Arguments\n+                             (Arg + 1 .. Current_Arguments'Last);\n+\n+                           Arg := Arg + New_Arguments'Length;\n+                        end;\n+                     end;\n+                  end if;\n+\n+               else\n+                  Arg := Arg + 1;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Remove the response file name from the stack\n+\n+         if First_File = Last_File then\n+            System.Strings.Free (First_File.Name);\n+            Free (First_File);\n+            First_File := null;\n+            Last_File := null;\n+\n+         else\n+            System.Strings.Free (Last_File.Name);\n+            Last_File := Last_File.Prev;\n+            Free (Last_File.Next);\n+         end if;\n+\n+      exception\n+         when others =>\n+            Close (FD);\n+\n+            raise;\n+      end Recurse;\n+\n+   --  Start of processing for Arguments_From\n+\n+   begin\n+      --  The job is done by procedure Recurse\n+\n+      Recurse (Response_File_Name);\n+\n+      --  Free Arguments before returning the result\n+\n+      declare\n+         Result : constant Argument_List := Arguments (1 .. Last_Arg);\n+      begin\n+         Free (Arguments);\n+         return Result;\n+      end;\n+\n+   exception\n+      when others =>\n+\n+         --  When an exception occurs, deallocate everything\n+\n+         Free (Arguments);\n+\n+         while First_File /= null loop\n+            Last_File := First_File.Next;\n+            System.Strings.Free (First_File.Name);\n+            Free (First_File);\n+            First_File := Last_File;\n+         end loop;\n+\n+         raise;\n+   end Arguments_From;\n+\n+end System.Response_File;"}, {"sha": "fbb7f7af09f898aeeca5470ecbbd1f05af54c63d", "filename": "gcc/ada/s-resfil.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-resfil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fs-resfil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-resfil.ads?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . R E S P O N S E _ F I L E                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2007-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides facilities for getting command line arguments\n+--  from a text file, called a \"response file\".\n+--\n+--  Using a response file allow passing a set of arguments to an executable\n+--  longer than the maximum allowed by the system on the command line.\n+\n+pragma Compiler_Unit_Warning;\n+\n+with System.Strings;\n+\n+package System.Response_File is\n+\n+   subtype String_Access is System.Strings.String_Access;\n+   --  type String_Access is access all String;\n+\n+   procedure Free (S : in out String_Access) renames System.Strings.Free;\n+   --  To deallocate a String\n+\n+   subtype Argument_List is System.Strings.String_List;\n+   --  type String_List is array (Positive range <>) of String_Access;\n+\n+   Max_Line_Length : constant := 4096;\n+   --  The maximum length of lines in a response file\n+\n+   File_Does_Not_Exist : exception;\n+   --  Raise by Arguments_From when a response file cannot be found\n+\n+   Line_Too_Long : exception;\n+   --  Raise by Arguments_From when a line in the response file is longer than\n+   --  Max_Line_Length.\n+\n+   No_Closing_Quote : exception;\n+   --  Raise by Arguments_From when a quoted string does not end before the\n+   --  end of the line.\n+\n+   Circularity_Detected : exception;\n+   --  Raise by Arguments_From when Recursive is True and the same response\n+   --  file is reading itself, either directly or indirectly.\n+\n+   function Arguments_From\n+     (Response_File_Name        : String;\n+      Recursive                 : Boolean := False;\n+      Ignore_Non_Existing_Files : Boolean := False)\n+      return Argument_List;\n+   --  Read response file with name Response_File_Name and return the argument\n+   --  it contains as an Argument_List. It is the responsibility of the caller\n+   --  to deallocate the strings in the Argument_List if desired. When\n+   --  Recursive is True, any argument of the form @file_name indicates the\n+   --  name of another response file and is replaced by the arguments in this\n+   --  response file.\n+   --\n+   --  Each nonempty line of the response file contains one or several\n+   --  arguments separated by white space. Empty lines or lines containing only\n+   --  white space are ignored. Arguments containing white space or a double\n+   --  quote ('\"')must be quoted. A double quote inside a quote string is\n+   --  indicated by two consecutive double quotes. Example: \"-Idir with quote\n+   --  \"\" and spaces\". Non-white-space characters immediately before or after a\n+   --  quoted string are part of the same argument. Ex: -Idir\" with \"spaces\n+   --\n+   --  When a response file cannot be found, exception File_Does_Not_Exist is\n+   --  raised if Ignore_Non_Existing_Files is False, otherwise the response\n+   --  file is ignored. Exception Line_Too_Long is raised when a line of a\n+   --  response file is longer than Max_Line_Length. Exception No_Closing_Quote\n+   --  is raised when a quoted argument is not closed before the end of the\n+   --  line. Exception Circularity_Detected is raised when a Recursive is True\n+   --  and a response file is reading itself, either directly or indirectly.\n+\n+end System.Response_File;"}, {"sha": "b02d72bc509cbe3e52338e52ee5bd4c99b9b0912", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -283,7 +283,7 @@ package body Sem_Ch4 is\n    --  Called when P is the prefix of an implicit dereference, denoting an\n    --  object E. The function returns the designated type of the prefix, taking\n    --  into account that the designated type of an anonymous access type may be\n-   --  a limited view, when the non-limited view is visible.\n+   --  a limited view, when the nonlimited view is visible.\n    --\n    --  If in semantics only mode (-gnatc or generic), the function also records\n    --  that the prefix is a reference to E, if any. Normally, such a reference\n@@ -755,7 +755,7 @@ package body Sem_Ch4 is\n                           (\"\\constraint with discriminant values required\", N);\n                      end if;\n \n-                  --  Limited Ada 2005 and general non-limited case\n+                  --  Limited Ada 2005 and general nonlimited case\n \n                   else\n                      Error_Msg_N\n@@ -1469,10 +1469,10 @@ package body Sem_Ch4 is\n          --  can also happen when the function declaration appears before the\n          --  full view of the type (which is legal in Ada 2012) and the call\n          --  appears in a different unit, in which case the incomplete view\n-         --  must be replaced with the full view (or the non-limited view)\n+         --  must be replaced with the full view (or the nonlimited view)\n          --  to prevent subsequent type errors. Note that the usual install/\n          --  removal of limited_with clauses is not sufficient to handle this\n-         --  case, because the limited view may have been captured is another\n+         --  case, because the limited view may have been captured in another\n          --  compilation unit that defines the current function.\n \n          if Is_Incomplete_Type (Etype (N)) then\n@@ -4582,7 +4582,7 @@ package body Sem_Ch4 is\n       --  in what follows, either to retrieve a component of to find\n       --  a primitive operation. If the prefix is an explicit dereference,\n       --  set the type of the prefix to reflect this transformation.\n-      --  If the non-limited view is itself an incomplete type, get the\n+      --  If the nonlimited view is itself an incomplete type, get the\n       --  full view if available.\n \n       if From_Limited_With (Prefix_Type)\n@@ -9012,7 +9012,7 @@ package body Sem_Ch4 is\n \n          --  The type may have be obtained through a limited_with clause,\n          --  in which case the primitive operations are available on its\n-         --  non-limited view. If still incomplete, retrieve full view.\n+         --  nonlimited view. If still incomplete, retrieve full view.\n \n          if Ekind (Obj_Type) = E_Incomplete_Type\n            and then From_Limited_With (Obj_Type)"}, {"sha": "ea5618f383df2c4729064d30af85d0f681c9bae7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "patch": "@@ -6630,11 +6630,15 @@ package body Sem_Res is\n                null;\n \n             --  Calls cannot be inlined inside assertions, as GNATprove treats\n-            --  assertions as logic expressions.\n+            --  assertions as logic expressions. Only issue a message when the\n+            --  body has been seen, otherwise this leads to spurious messages\n+            --  on expression functions.\n \n             elsif In_Assertion_Expr /= 0 then\n-               Cannot_Inline\n-                 (\"cannot inline & (in assertion expression)?\", N, Nam_UA);\n+               if Present (Body_Id) then\n+                  Cannot_Inline\n+                    (\"cannot inline & (in assertion expression)?\", N, Nam_UA);\n+               end if;\n \n             --  Calls cannot be inlined inside default expressions\n "}]}