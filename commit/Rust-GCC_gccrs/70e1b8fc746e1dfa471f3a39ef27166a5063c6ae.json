{"sha": "70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlMWI4ZmM3NDZlMWRmYTQ3MWYzYTM5ZWYyNzE2NmE1MDYzYzZhZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-03-22T08:01:02Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-03-22T08:01:02Z"}, "message": "* combine.c (simplify_comparison <AND>): Use gen_int_mode.  Tidy.\n\nFrom-SVN: r64703", "tree": {"sha": "6ddf51362c6dfb20b81531fc99bf7007b3a8b9bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ddf51362c6dfb20b81531fc99bf7007b3a8b9bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae/comments", "author": null, "committer": null, "parents": [{"sha": "6932a1994e035982ca387d7d66b32e53b8e3bce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6932a1994e035982ca387d7d66b32e53b8e3bce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6932a1994e035982ca387d7d66b32e53b8e3bce0"}], "stats": {"total": 82, "additions": 41, "deletions": 41}, "files": [{"sha": "34c7d46999d90b2374b19184e329e275aa798d7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "patch": "@@ -1,3 +1,7 @@\n+2003-03-22  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* combine.c (simplify_comparison <AND>): Use gen_int_mode.  Tidy.\n+\n 2003-03-21  Zack Weinberg  <zack@codesourcery.com>\n \n \t* c-common.c: Include intl.h.\n@@ -414,8 +418,8 @@ Tue Mar 18 13:15:08 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t(PROFILE_KERNEL): Remove hacks.\n \t* config/rs6000/rs6000.c (TARGET_PROFILE_KERNEL): Define default.\n \t(rs6000_stack_info): No need to save lr if just for profiling when\n-\tTARGET_KERNEL_PROFILE.\n-\t(output_profile_hook): Output nothing when TARGET_KERNEL_PROFILE.\n+\tTARGET_PROFILE_KERNEL.\n+\t(output_profile_hook): Output nothing when TARGET_PROFILE_KERNEL.\n \t(output_function_profiler): Localize label generation.  Emit code\n \tfor kernel profiling.\n "}, {"sha": "cd7261bf1eb41f55d41ae68ce1d73ad35ce181dd", "filename": "gcc/combine.c", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e1b8fc746e1dfa471f3a39ef27166a5063c6ae/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=70e1b8fc746e1dfa471f3a39ef27166a5063c6ae", "patch": "@@ -11138,49 +11138,45 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1 fits\n-\t     in both M1 and M2 and the SUBREG is either paradoxical or\n-\t     represents the low part, permute the SUBREG and the AND and\n-\t     try again.  */\n-\t  if (GET_CODE (XEXP (op0, 0)) == SUBREG\n+\t  /* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1\n+\t     fits in both M1 and M2 and the SUBREG is either paradoxical\n+\t     or represents the low part, permute the SUBREG and the AND\n+\t     and try again.  */\n+\t  if (GET_CODE (XEXP (op0, 0)) == SUBREG)\n+\t    {\n+\t      unsigned HOST_WIDE_INT c1;\n+\t      tmode = GET_MODE (SUBREG_REG (XEXP (op0, 0)));\n \t      /* Require an integral mode, to avoid creating something like\n \t\t (AND:SF ...).  */\n-\t      && SCALAR_INT_MODE_P (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n-\t      /* It is unsafe to commute the AND into the SUBREG if the SUBREG\n-\t\t is paradoxical and WORD_REGISTER_OPERATIONS is not defined.\n-\t\t As originally written the upper bits have a defined value\n-\t\t due to the AND operation.  However, if we commute the AND\n-\t\t inside the SUBREG then they no longer have defined values\n-\t\t and the meaning of the code has been changed.  */\n-\t      && (0\n+\t      if (SCALAR_INT_MODE_P (tmode)\n+\t\t  /* It is unsafe to commute the AND into the SUBREG if the\n+\t\t     SUBREG is paradoxical and WORD_REGISTER_OPERATIONS is\n+\t\t     not defined.  As originally written the upper bits\n+\t\t     have a defined value due to the AND operation.\n+\t\t     However, if we commute the AND inside the SUBREG then\n+\t\t     they no longer have defined values and the meaning of\n+\t\t     the code has been changed.  */\n+\t\t  && (0\n #ifdef WORD_REGISTER_OPERATIONS\n-\t\t  || ((mode_width\n-\t\t       > (GET_MODE_BITSIZE\n-\t\t\t   (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n-\t\t      && mode_width <= BITS_PER_WORD)\n+\t\t      || (mode_width > GET_MODE_BITSIZE (tmode)\n+\t\t\t  && mode_width <= BITS_PER_WORD)\n #endif\n-\t\t  || ((mode_width\n-\t\t       <= (GET_MODE_BITSIZE\n-\t\t\t   (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n-\t\t      && subreg_lowpart_p (XEXP (op0, 0))))\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t      && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n-\t\t  <= HOST_BITS_PER_WIDE_INT)\n-\t      && (INTVAL (XEXP (op0, 1)) & ~mask) == 0\n-\t      && 0 == (~GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n-\t\t       & INTVAL (XEXP (op0, 1)))\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1)) != mask\n-\t      && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n-\t\t  != GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n-\n-\t    {\n-\t      op0\n-\t\t= gen_lowpart_for_combine\n-\t\t  (mode,\n-\t\t   gen_binary (AND, GET_MODE (SUBREG_REG (XEXP (op0, 0))),\n-\t\t\t       SUBREG_REG (XEXP (op0, 0)), XEXP (op0, 1)));\n-\t      continue;\n+\t\t      || (mode_width <= GET_MODE_BITSIZE (tmode)\n+\t\t\t  && subreg_lowpart_p (XEXP (op0, 0))))\n+\t\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t\t  && mode_width <= HOST_BITS_PER_WIDE_INT\n+\t\t  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT\n+\t\t  && ((c1 = INTVAL (XEXP (op0, 1))) & ~mask) == 0\n+\t\t  && (c1 & ~GET_MODE_MASK (tmode)) == 0\n+\t\t  && c1 != mask\n+\t\t  && c1 != GET_MODE_MASK (tmode))\n+\t\t{\n+\t\t  op0 = gen_binary (AND, tmode,\n+\t\t\t\t    SUBREG_REG (XEXP (op0, 0)),\n+\t\t\t\t    gen_int_mode (c1, tmode));\n+\t\t  op0 = gen_lowpart_for_combine (mode, op0);\n+\t\t  continue;\n+\t\t}\n \t    }\n \n \t  /* Convert (ne (and (lshiftrt (not X)) 1) 0) to"}]}