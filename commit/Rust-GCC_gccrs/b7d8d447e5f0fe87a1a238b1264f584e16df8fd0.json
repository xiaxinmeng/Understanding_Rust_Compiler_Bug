{"sha": "b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkOGQ0NDdlNWYwZmU4N2ExYTIzOGIxMjY0ZjU4NGUxNmRmOGZkMA==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-04-18T21:23:10Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-04-18T21:23:10Z"}, "message": "tree-vrp.c (find_case_label_index): Fix the binary search.\n\n2008-04-18  Rafael Espindola  <espindola@google.com>\n\t* tree-vrp.c (find_case_label_index): Fix the binary search.\n\t(find_case_label_range): New.\n\t(vrp_visit_switch_stmt): Use find_case_label_range.\n\t(simplify_switch_using_ranges): Use find_case_label_range.\n\nFrom-SVN: r134452", "tree": {"sha": "968b2b693d69697134a147506a0ec8b114504701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/968b2b693d69697134a147506a0ec8b114504701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0/comments", "author": null, "committer": null, "parents": [{"sha": "0ce7db600da86142b1ed27feb6f252c324426bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce7db600da86142b1ed27feb6f252c324426bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce7db600da86142b1ed27feb6f252c324426bd1"}], "stats": {"total": 175, "additions": 106, "deletions": 69}, "files": [{"sha": "a86b7494707e3ecc80fa107841b6a5b6639374e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "patch": "@@ -1,3 +1,9 @@\n+2008-04-18  Rafael Espindola  <espindola@google.com>\n+\t* tree-vrp.c (find_case_label_index): Fix the binary search.\n+\t(find_case_label_range): New.\n+\t(vrp_visit_switch_stmt): Use find_case_label_range.\n+\t(simplify_switch_using_ranges): Use find_case_label_range.\n+\n 2008-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c (gimplify_modify_expr_rhs) <COND_EXPR>: Gimplify the LHS"}, {"sha": "e9106c47f1984c6b86d494230354f6cb3463194f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 100, "deletions": 69, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d8d447e5f0fe87a1a238b1264f584e16df8fd0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b7d8d447e5f0fe87a1a238b1264f584e16df8fd0", "patch": "@@ -5528,59 +5528,119 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n   return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n+/* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n+   that includes the value VAL.  The search is restricted to the range\n+   [START_IDX, n - 2] where n is the size of VEC (n - 1 is the default label).\n \n-/* Searches the case label vector VEC for the index *IDX the CASE_LABEL\n-   includes the value VAL.  The search starts at index START_IDX and\n-   true is returned if *IDX corresponds to such an index.  False is\n-   returned in case VAL hits the default case label and *IDX in this\n-   case is the next higher or the next lower case label index.  */\n+   If there is a CASE_LABEL for VAL, its index is placed in IDX and true is\n+   returned.\n+\n+   If there is no CASE_LABEL for VAL and the is one that is larger than VAL,\n+   it is placed in IDX and false is returned.\n+\n+   If VAL is larger than any CASE_LABEL, n - 1 is placed on IDX and false is\n+   returned. */\n \n static bool\n find_case_label_index (tree vec, size_t start_idx, tree val, size_t *idx)\n {\n   size_t n = TREE_VEC_LENGTH (vec);\n-  size_t low, high, i = start_idx;\n+  size_t low, high;\n+\n+  /* Find case label for minimum of the value range or the next one.\n+     At each iteration we are searching in [low, high - 1]. */\n \n-  /* Find case label for minimum of the value range or the next one.  */\n-  for (low = start_idx - 1, high = n - 1; high - low > 1; )\n+  for (low = start_idx, high = n - 1; high != low; )\n     {\n       tree t;\n       int cmp;\n-      i = (high + low) / 2;\n+      /* Note that i != high, so we never ask for n - 1. */\n+      size_t i = (high + low) / 2;\n       t = TREE_VEC_ELT (vec, i);\n \n       /* Cache the result of comparing CASE_LOW and val.  */\n       cmp = tree_int_cst_compare (CASE_LOW (t), val);\n \n-      if (cmp > 0)\n+      if (cmp == 0)\n+\t{\n+\t  /* Ranges cannot be empty. */\n+\t  *idx = i;\n+\t  return true;\n+\t}\n+      else if (cmp > 0)\n         high = i;\n       else\n-        low = i;\n-\n-      if (CASE_HIGH (t) == NULL)\n-        {\n-          /* A singe-valued case label.  */\n-          if (cmp == 0)\n-\t    {\n-\t      *idx = i;\n-\t      return true;\n-\t    }\n-        }\n-      else\n-        {\n-          /* A case range.  We can only handle integer ranges.  */\n-          if (cmp <= 0 && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n+\t{\n+\t  low = i + 1;\n+\t  if (CASE_HIGH (t) != NULL\n+\t      && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n \t    {\n \t      *idx = i;\n \t      return true;\n \t    }\n         }\n     }\n \n-  *idx = i;\n+  *idx = high;\n   return false;\n }\n \n+/* Searches the case label vector VEC for the range of CASE_LABELs that is used\n+   for values between MIN and MAX. The first index is placed in MIN_IDX. The\n+   last index is placed in MAX_IDX. If the range of CASE_LABELs is empty\n+   then MAX_IDX < MIN_IDX.\n+   Returns true if the default label is not needed. */\n+\n+static bool\n+find_case_label_range (tree vec, tree min, tree max, size_t *min_idx, size_t *max_idx)\n+{\n+  size_t i, j;\n+  bool min_take_default = !find_case_label_index (vec, 0, min, &i);\n+  bool max_take_default = !find_case_label_index (vec, i, max, &j);\n+\n+  if (i == j\n+      && min_take_default\n+      && max_take_default)\n+    {\n+      /* Only the default case label reached. \n+         Return an empty range. */\n+      *min_idx = 1;\n+      *max_idx = 0;\n+      return false;\n+    }\n+  else\n+    {\n+      bool take_default = min_take_default || max_take_default;\n+      tree low, high;\n+      size_t k;\n+\n+      if (max_take_default)\n+\tj--;\n+\n+      /* If the case label range is continuous, we do not need\n+\t the default case label.  Verify that.  */\n+      high = CASE_LOW (TREE_VEC_ELT (vec, i));\n+      if (CASE_HIGH (TREE_VEC_ELT (vec, i)))\n+\thigh = CASE_HIGH (TREE_VEC_ELT (vec, i));\n+      for (k = i + 1; k <= j; ++k)\n+\t{\n+\t  low = CASE_LOW (TREE_VEC_ELT (vec, k));\n+\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high, 0)))\n+\t    {\n+\t      take_default = true;\n+\t      break;\n+\t    }\n+\t  high = low;\n+\t  if (CASE_HIGH (TREE_VEC_ELT (vec, k)))\n+\t    high = CASE_HIGH (TREE_VEC_ELT (vec, k));\n+\t}\n+\n+      *min_idx = i;\n+      *max_idx = j;\n+      return !take_default;\n+    }\n+}\n+\n /* Visit switch statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n    *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n@@ -5593,7 +5653,7 @@ vrp_visit_switch_stmt (tree stmt, edge *taken_edge_p)\n   value_range_t *vr;\n   size_t i = 0, j = 0, n;\n   tree vec;\n-  bool min_take_default, max_take_default;\n+  bool take_default;\n \n   *taken_edge_p = NULL;\n   op = TREE_OPERAND (stmt, 0);\n@@ -5618,27 +5678,23 @@ vrp_visit_switch_stmt (tree stmt, edge *taken_edge_p)\n   vec = SWITCH_LABELS (stmt);\n   n = TREE_VEC_LENGTH (vec);\n \n-  /* Find case label for minimum of the value range or the next one.  */\n-  min_take_default = !find_case_label_index (vec, 0, vr->min, &i);\n-\n-  /* Find case label for maximum of the value range or the previous one.  */\n-  max_take_default = !find_case_label_index (vec, i, vr->max, &j);\n+  take_default = !find_case_label_range (vec, vr->min, vr->max, &i, &j);\n \n-  /* Check if we reach the default label only.  */\n+  /* Check if the range spans no CASE_LABEL. If so, we only reach the default\n+     label */\n   if (j < i)\n-    val = TREE_VEC_ELT (vec, n - 1);\n-  /* Check if we reach exactly one label and not the default label.  */\n-  else if (i == j\n-\t   && !min_take_default\n-\t   && !max_take_default)\n-    val = TREE_VEC_ELT (vec, i);\n+    {\n+      gcc_assert (take_default);\n+      val = TREE_VEC_ELT (vec, n - 1);\n+    }\n   else\n     {\n-      /* Check if labels with index i to j are all reaching the same label.\n-         If we don't hit a single case label only, the default case also has\n-         to branch to the same label.  */\n+      /* Check if labels with index i to j and maybe the default label\n+\t are all reaching the same label.  */\n+\n       val = TREE_VEC_ELT (vec, i);\n-      if (CASE_LABEL (TREE_VEC_ELT (vec, n - 1)) != CASE_LABEL (val))\n+      if (take_default\n+\t  && CASE_LABEL (TREE_VEC_ELT (vec, n - 1)) != CASE_LABEL (val))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  not a single destination for this \"\n@@ -6323,32 +6379,7 @@ simplify_switch_using_ranges (tree stmt)\n   /* Find case label for min/max of the value range.  */\n   vec = SWITCH_LABELS (stmt);\n   n = TREE_VEC_LENGTH (vec);\n-  take_default = !find_case_label_index (vec, 0, vr->min, &i);\n-  take_default |= !find_case_label_index (vec, i, vr->max, &j);\n-\n-  /* If the case label range is continuous, we do not need to\n-     preserve the default case label.  Verify that.  */\n-  if (!take_default && j > i)\n-    {\n-      tree low, high;\n-      size_t k;\n-\n-      high = CASE_LOW (TREE_VEC_ELT (vec, i));\n-      if (CASE_HIGH (TREE_VEC_ELT (vec, i)))\n-\thigh = CASE_HIGH (TREE_VEC_ELT (vec, i));\n-      for (k = i + 1; k <= j; ++k)\n-\t{\n-\t  low = CASE_LOW (TREE_VEC_ELT (vec, k));\n-\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high, 0)))\n-\t    {\n-\t      take_default = true;\n-\t      break;\n-\t    }\n-\t  high = low;\n-\t  if (CASE_HIGH (TREE_VEC_ELT (vec, k)))\n-\t    high = CASE_HIGH (TREE_VEC_ELT (vec, k));\n-\t}\n-    }\n+  take_default = !find_case_label_range (vec, vr->min, vr->max, &i, &j);\n \n   /* Bail out if this is just all edges taken.  */\n   if (i == 0"}]}