{"sha": "d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "node_id": "C_kwDOANBUbNoAKGQ5NGQ1YjFlYTIzMjIwZDQyM2ZkNDBiZDAwY2FkYjBlNmVkZTc1MWY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-27T12:32:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-27T12:32:38Z"}, "message": "Merge #1410\n\n1410: unsafe: Add UnsafeCheck visitor r=CohenArthur a=CohenArthur\n\nThis visitor takes care of checking for unsafe expressions in safe\r\ncontexts. This first iteration reports the dereferencing of raw\r\npointers.\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "9a6292e682c843b6ee7c3f65f23e6f74fd6c0dca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a6292e682c843b6ee7c3f65f23e6f74fd6c0dca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4TBmCRBK7hj4Ov3rIwAA7zYIAIyHMiGs2o9/YqrJcayQd1Rt\nowJagdBfdp7yZI4Iqy45HkxyviTZpY19vggvG6jsBc5nrLtMfbOQ7pb3lJUpNQ+w\nDlLr3Eqnya8bzP7Fj/yB/raBwsarntq9nGfw6a732be9QgQkt0WB2lv46UQjWgWS\nZ7mOIwZSZb4Zbn4jKsEs9RKEPIE+4xKjGextG1lTInUYcLF+SLvgXAQhGlTeOfMt\nx09hcfxw80fX/OEDIrF6hhYjZbeBqnsZ6Nb68tbN9EJbZRlYVbwX96tdAERG2/1x\nimfTpVG3a5LDsAo30zY1umpJJQw8PPTidwLP5imvGxXrnQ8wTFo8GaqRGgbKwME=\n=HFj+\n-----END PGP SIGNATURE-----\n", "payload": "tree 9a6292e682c843b6ee7c3f65f23e6f74fd6c0dca\nparent dec7ee4c5e703422ecb9bc94417645d66af7eaae\nparent 961468ed824a7b49f10ed597ba9dcc98177125ca\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1658925158 +0000\ncommitter GitHub <noreply@github.com> 1658925158 +0000\n\nMerge #1410\n\n1410: unsafe: Add UnsafeCheck visitor r=CohenArthur a=CohenArthur\n\nThis visitor takes care of checking for unsafe expressions in safe\r\ncontexts. This first iteration reports the dereferencing of raw\r\npointers.\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec7ee4c5e703422ecb9bc94417645d66af7eaae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec7ee4c5e703422ecb9bc94417645d66af7eaae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec7ee4c5e703422ecb9bc94417645d66af7eaae"}, {"sha": "961468ed824a7b49f10ed597ba9dcc98177125ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961468ed824a7b49f10ed597ba9dcc98177125ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961468ed824a7b49f10ed597ba9dcc98177125ca"}], "stats": {"total": 1018, "additions": 1017, "deletions": 1}, "files": [{"sha": "1ae9bd758ced169b3c2c9f210e2403df5f6b44e2", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -123,6 +123,7 @@ GRS_OBJS = \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-lint-unused-var.o \\\n     rust/rust-hir-type-check-path.o \\\n+    rust/rust-unsafe-checker.o \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-compile-pattern.o \\\n     rust/rust-compile-fnparam.o \\"}, {"sha": "def3cc11b7a5906f769a97debad8c510c4943948", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.cc", "status": "added", "additions": 779, "deletions": 0, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -0,0 +1,779 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-unsafe-checker.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+UnsafeChecker::UnsafeChecker () : context (*Resolver::TypeCheckContext::get ())\n+{}\n+\n+void\n+UnsafeChecker::go (HIR::Crate &crate)\n+{\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::push_unsafe (HirId id)\n+{\n+  unsafe_contexts.emplace_back (id);\n+}\n+\n+HirId\n+UnsafeChecker::pop_unsafe ()\n+{\n+  rust_assert (!unsafe_contexts.empty ());\n+\n+  auto last = unsafe_contexts.back ();\n+  unsafe_contexts.pop_back ();\n+\n+  return last;\n+}\n+\n+bool\n+UnsafeChecker::is_unsafe_context ()\n+{\n+  return !unsafe_contexts.empty ();\n+}\n+\n+void\n+UnsafeChecker::visit (IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (Lifetime &lifetime)\n+{}\n+\n+void\n+UnsafeChecker::visit (LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+UnsafeChecker::visit (PathInExpression &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePathSegment &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePath &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (QualifiedPathInExpression &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (QualifiedPathInType &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (LiteralExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BorrowExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *to_deref_type;\n+  auto to_deref = expr.get_expr ()->get_mappings ().get_hirid ();\n+\n+  rust_assert (context.lookup_type (to_deref, &to_deref_type));\n+\n+  if (to_deref_type->get_kind () == TyTy::TypeKind::POINTER\n+      && !is_unsafe_context ())\n+    rust_error_at (expr.get_locus (), \"dereference of raw pointer requires \"\n+\t\t\t\t      \"unsafe function or block\");\n+}\n+\n+void\n+UnsafeChecker::visit (ErrorPropagationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (NegationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArithmeticOrLogicalExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ComparisonExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (LazyBooleanExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TypeCastExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (AssignmentExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (CompoundAssignmentExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (GroupedExpr &expr)\n+{\n+  expr.get_expr_in_parens ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    elem->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayElemsCopied &elems)\n+{\n+  elems.get_elem_to_copy ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayExpr &expr)\n+{\n+  expr.get_internal_elements ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayIndexExpr &expr)\n+{\n+  expr.get_array_expr ()->accept_vis (*this);\n+  expr.get_index_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TupleExpr &expr)\n+{\n+  for (auto &elem : expr.get_tuple_elems ())\n+    elem->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TupleIndexExpr &expr)\n+{\n+  expr.get_tuple_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStruct &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIdentifierValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIndexValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStructFields &expr)\n+{\n+  for (auto &field : expr.get_fields ())\n+    field->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStructBase &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (CallExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (MethodCallExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (FieldAccessExpr &expr)\n+{\n+  // FIXME: If the receiver is an union, we need to be in an unsafe context to\n+  // access it. Make sure to check.\n+\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ClosureExprInner &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BlockExpr &expr)\n+{\n+  for (auto &stmt : expr.get_statements ())\n+    stmt->accept_vis (*this);\n+\n+  if (expr.has_expr ())\n+    expr.get_final_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (ContinueExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFromToExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFromExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeToExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFullExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangeFromToInclExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeToInclExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ReturnExpr &expr)\n+{\n+  if (expr.has_return_expr ())\n+    expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (UnsafeBlockExpr &expr)\n+{\n+  push_unsafe (expr.get_mappings ().get_hirid ());\n+\n+  expr.get_block_expr ()->accept_vis (*this);\n+\n+  pop_unsafe ();\n+}\n+\n+void\n+UnsafeChecker::visit (LoopExpr &expr)\n+{\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (WhileLoopExpr &expr)\n+{\n+  expr.get_predicate_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (WhileLetLoopExpr &expr)\n+{\n+  expr.get_cond ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ForLoopExpr &expr)\n+{\n+  expr.get_iterator_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExpr &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqElse &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_else_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqIf &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqIfLet &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit conseq if let expression\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqElse &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit else expression\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqIf &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqIfLet &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit conseq if let expression\n+}\n+\n+void\n+UnsafeChecker::visit (MatchExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+\n+  for (auto &match_arm : expr.get_match_cases ())\n+    match_arm.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (AwaitExpr &expr)\n+{\n+  // TODO: Visit expression\n+}\n+\n+void\n+UnsafeChecker::visit (AsyncBlockExpr &expr)\n+{\n+  // TODO: Visit block expression\n+}\n+\n+void\n+UnsafeChecker::visit (TypeParam &param)\n+{}\n+\n+void\n+UnsafeChecker::visit (ConstGenericParam &param)\n+{}\n+\n+void\n+UnsafeChecker::visit (LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExternCrate &crate)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeGlob &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeList &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeRebind &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseDeclaration &use_decl)\n+{}\n+\n+void\n+UnsafeChecker::visit (Function &function)\n+{\n+  auto is_unsafe_fn = function.get_qualifiers ().is_unsafe ();\n+\n+  if (is_unsafe_fn)\n+    push_unsafe (function.get_mappings ().get_hirid ());\n+\n+  function.get_definition ()->accept_vis (*this);\n+\n+  if (is_unsafe_fn)\n+    pop_unsafe ();\n+}\n+\n+void\n+UnsafeChecker::visit (TypeAlias &type_alias)\n+{\n+  // FIXME: What do we need to do to handle type aliasing? Is it possible to\n+  // have unsafe types? Type aliases on unsafe functions?\n+}\n+\n+void\n+UnsafeChecker::visit (StructStruct &struct_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStruct &tuple_struct)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemTuple &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemStruct &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemDiscriminant &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Enum &enum_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Union &union_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ConstantItem &const_item)\n+{\n+  const_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StaticItem &static_item)\n+{\n+  static_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemFunc &item)\n+{\n+  if (item.has_block_defined ())\n+    item.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemConst &item)\n+{\n+  if (item.has_expr ())\n+    item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemType &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Trait &trait)\n+{\n+  // FIXME: Handle unsafe traits\n+  for (auto &item : trait.get_trait_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ImplBlock &impl)\n+{\n+  // FIXME: Handle unsafe impls\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExternalStaticItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ExternalFunctionItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ExternBlock &block)\n+{\n+  // FIXME: Do we need to do this?\n+  for (auto &item : block.get_extern_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (LiteralPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (IdentifierPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (WildcardPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundPath &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (ReferencePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldIdent &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (GroupedPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (SlicePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (EmptyStmt &stmt)\n+{}\n+\n+void\n+UnsafeChecker::visit (LetStmt &stmt)\n+{\n+  if (stmt.has_init_expr ())\n+    stmt.get_init_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExprStmtWithoutBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExprStmtWithBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitBound &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (ImplTraitType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (TraitObjectType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ParenthesisedType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (NeverType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (RawPointerType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ReferenceType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ArrayType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (SliceType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (InferredType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (BareFunctionType &type)\n+{}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "3c8170739932367e7d84b4efc09104904d3ec6a6", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -0,0 +1,193 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_UNSAFE_CHECKER_H\n+#define RUST_UNSAFE_CHECKER_H\n+\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+class UnsafeChecker : public HIRFullVisitor\n+{\n+public:\n+  UnsafeChecker ();\n+\n+  void go (HIR::Crate &crate);\n+\n+private:\n+  /* Stack of unsafe contexts */\n+  std::vector<HirId> unsafe_contexts;\n+\n+  /**\n+   * Add an unsafe context to the stack. To call when entering unsafe blocks\n+   */\n+  void push_unsafe (HirId id);\n+\n+  /**\n+   * Remove an unsafe context from the stack. Call this when exiting unsafe\n+   * blocks\n+   */\n+  HirId pop_unsafe ();\n+\n+  /**\n+   * Are we currently in an unsafe context or not\n+   */\n+  bool is_unsafe_context ();\n+\n+  Resolver::TypeCheckContext &context;\n+\n+  virtual void visit (IdentifierExpr &ident_expr) override;\n+  virtual void visit (Lifetime &lifetime) override;\n+  virtual void visit (LifetimeParam &lifetime_param) override;\n+  virtual void visit (PathInExpression &path) override;\n+  virtual void visit (TypePathSegment &segment) override;\n+  virtual void visit (TypePathSegmentGeneric &segment) override;\n+  virtual void visit (TypePathSegmentFunction &segment) override;\n+  virtual void visit (TypePath &path) override;\n+  virtual void visit (QualifiedPathInExpression &path) override;\n+  virtual void visit (QualifiedPathInType &path) override;\n+  virtual void visit (LiteralExpr &expr) override;\n+  virtual void visit (BorrowExpr &expr) override;\n+  virtual void visit (DereferenceExpr &expr) override;\n+  virtual void visit (ErrorPropagationExpr &expr) override;\n+  virtual void visit (NegationExpr &expr) override;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) override;\n+  virtual void visit (ComparisonExpr &expr) override;\n+  virtual void visit (LazyBooleanExpr &expr) override;\n+  virtual void visit (TypeCastExpr &expr) override;\n+  virtual void visit (AssignmentExpr &expr) override;\n+  virtual void visit (CompoundAssignmentExpr &expr) override;\n+  virtual void visit (GroupedExpr &expr) override;\n+  virtual void visit (ArrayElemsValues &elems) override;\n+  virtual void visit (ArrayElemsCopied &elems) override;\n+  virtual void visit (ArrayExpr &expr) override;\n+  virtual void visit (ArrayIndexExpr &expr) override;\n+  virtual void visit (TupleExpr &expr) override;\n+  virtual void visit (TupleIndexExpr &expr) override;\n+  virtual void visit (StructExprStruct &expr) override;\n+  virtual void visit (StructExprFieldIdentifier &field) override;\n+  virtual void visit (StructExprFieldIdentifierValue &field) override;\n+  virtual void visit (StructExprFieldIndexValue &field) override;\n+  virtual void visit (StructExprStructFields &expr) override;\n+  virtual void visit (StructExprStructBase &expr) override;\n+  virtual void visit (CallExpr &expr) override;\n+  virtual void visit (MethodCallExpr &expr) override;\n+  virtual void visit (FieldAccessExpr &expr) override;\n+  virtual void visit (ClosureExprInner &expr) override;\n+  virtual void visit (BlockExpr &expr) override;\n+  virtual void visit (ClosureExprInnerTyped &expr) override;\n+  virtual void visit (ContinueExpr &expr) override;\n+  virtual void visit (BreakExpr &expr) override;\n+  virtual void visit (RangeFromToExpr &expr) override;\n+  virtual void visit (RangeFromExpr &expr) override;\n+  virtual void visit (RangeToExpr &expr) override;\n+  virtual void visit (RangeFullExpr &expr) override;\n+  virtual void visit (RangeFromToInclExpr &expr) override;\n+  virtual void visit (RangeToInclExpr &expr) override;\n+  virtual void visit (ReturnExpr &expr) override;\n+  virtual void visit (UnsafeBlockExpr &expr) override;\n+  virtual void visit (LoopExpr &expr) override;\n+  virtual void visit (WhileLoopExpr &expr) override;\n+  virtual void visit (WhileLetLoopExpr &expr) override;\n+  virtual void visit (ForLoopExpr &expr) override;\n+  virtual void visit (IfExpr &expr) override;\n+  virtual void visit (IfExprConseqElse &expr) override;\n+  virtual void visit (IfExprConseqIf &expr) override;\n+  virtual void visit (IfExprConseqIfLet &expr) override;\n+  virtual void visit (IfLetExpr &expr) override;\n+  virtual void visit (IfLetExprConseqElse &expr) override;\n+  virtual void visit (IfLetExprConseqIf &expr) override;\n+  virtual void visit (IfLetExprConseqIfLet &expr) override;\n+  virtual void visit (MatchExpr &expr) override;\n+  virtual void visit (AwaitExpr &expr) override;\n+  virtual void visit (AsyncBlockExpr &expr) override;\n+  virtual void visit (TypeParam &param) override;\n+  virtual void visit (ConstGenericParam &param) override;\n+  virtual void visit (LifetimeWhereClauseItem &item) override;\n+  virtual void visit (TypeBoundWhereClauseItem &item) override;\n+  virtual void visit (Module &module) override;\n+  virtual void visit (ExternCrate &crate) override;\n+  virtual void visit (UseTreeGlob &use_tree) override;\n+  virtual void visit (UseTreeList &use_tree) override;\n+  virtual void visit (UseTreeRebind &use_tree) override;\n+  virtual void visit (UseDeclaration &use_decl) override;\n+  virtual void visit (Function &function) override;\n+  virtual void visit (TypeAlias &type_alias) override;\n+  virtual void visit (StructStruct &struct_item) override;\n+  virtual void visit (TupleStruct &tuple_struct) override;\n+  virtual void visit (EnumItem &item) override;\n+  virtual void visit (EnumItemTuple &item) override;\n+  virtual void visit (EnumItemStruct &item) override;\n+  virtual void visit (EnumItemDiscriminant &item) override;\n+  virtual void visit (Enum &enum_item) override;\n+  virtual void visit (Union &union_item) override;\n+  virtual void visit (ConstantItem &const_item) override;\n+  virtual void visit (StaticItem &static_item) override;\n+  virtual void visit (TraitItemFunc &item) override;\n+  virtual void visit (TraitItemConst &item) override;\n+  virtual void visit (TraitItemType &item) override;\n+  virtual void visit (Trait &trait) override;\n+  virtual void visit (ImplBlock &impl) override;\n+  virtual void visit (ExternalStaticItem &item) override;\n+  virtual void visit (ExternalFunctionItem &item) override;\n+  virtual void visit (ExternBlock &block) override;\n+  virtual void visit (LiteralPattern &pattern) override;\n+  virtual void visit (IdentifierPattern &pattern) override;\n+  virtual void visit (WildcardPattern &pattern) override;\n+  virtual void visit (RangePatternBoundLiteral &bound) override;\n+  virtual void visit (RangePatternBoundPath &bound) override;\n+  virtual void visit (RangePatternBoundQualPath &bound) override;\n+  virtual void visit (RangePattern &pattern) override;\n+  virtual void visit (ReferencePattern &pattern) override;\n+  virtual void visit (StructPatternFieldTuplePat &field) override;\n+  virtual void visit (StructPatternFieldIdentPat &field) override;\n+  virtual void visit (StructPatternFieldIdent &field) override;\n+  virtual void visit (StructPattern &pattern) override;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) override;\n+  virtual void visit (TupleStructItemsRange &tuple_items) override;\n+  virtual void visit (TupleStructPattern &pattern) override;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) override;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) override;\n+  virtual void visit (TuplePattern &pattern) override;\n+  virtual void visit (GroupedPattern &pattern) override;\n+  virtual void visit (SlicePattern &pattern) override;\n+  virtual void visit (EmptyStmt &stmt) override;\n+  virtual void visit (LetStmt &stmt) override;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) override;\n+  virtual void visit (ExprStmtWithBlock &stmt) override;\n+  virtual void visit (TraitBound &bound) override;\n+  virtual void visit (ImplTraitType &type) override;\n+  virtual void visit (TraitObjectType &type) override;\n+  virtual void visit (ParenthesisedType &type) override;\n+  virtual void visit (ImplTraitTypeOneBound &type) override;\n+  virtual void visit (TupleType &type) override;\n+  virtual void visit (NeverType &type) override;\n+  virtual void visit (RawPointerType &type) override;\n+  virtual void visit (ReferenceType &type) override;\n+  virtual void visit (ArrayType &type) override;\n+  virtual void visit (SliceType &type) override;\n+  virtual void visit (InferredType &type) override;\n+  virtual void visit (BareFunctionType &type) override;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif /* !RUST_UNSAFE_CHECKER_H */"}, {"sha": "327a9accfe17b1cbfd6ac23c3c70206b29807496", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -2716,6 +2716,8 @@ class RangeToInclExpr : public RangeExpr\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRExpressionVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_to_expr () { return to; };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "0d41bd0bbb0dc0c3206f362aece5d08ddee80655", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -502,6 +502,7 @@ struct FunctionQualifiers\n   AsyncConstStatus get_status () const { return const_status; }\n \n   bool is_const () const { return const_status == AsyncConstStatus::CONST_FN; }\n+  bool is_unsafe () const { return unsafety == Unsafety::Unsafe; }\n \n   ABI get_abi () const { return abi; }\n };"}, {"sha": "6a2c1b6dd6275a51a2e30a57f9c3fa3afdd08a18", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-session-manager.h\"\n+#include \"rust-unsafe-checker.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n@@ -789,8 +790,14 @@ Session::parse_file (const char *filename)\n   if (saw_errors ())\n     return;\n \n-  // privacy pass\n+  // Various HIR error passes. The privacy pass happens before the unsafe checks\n   Privacy::Resolver::resolve (hir);\n+  if (saw_errors ())\n+    return;\n+\n+  HIR::UnsafeChecker ().go (hir);\n+  if (saw_errors ())\n+    return;\n \n   // do compile to gcc generic\n   Compile::Context ctx (backend);"}, {"sha": "7d1356bc3e588058ebb0a8ca44fcd32a85281ee1", "filename": "gcc/testsuite/rust/compile/unsafe4.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe4.rs?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -0,0 +1,29 @@\n+fn foo() -> i32 {\n+    let a = 15;\n+    let p_a = &a as *const i32;\n+\n+    unsafe { *p_a }\n+}\n+\n+unsafe fn bar() -> i32 {\n+    let a = 15;\n+    let p_a = &a as *const i32;\n+\n+    *p_a\n+}\n+\n+fn baz() -> i32 {\n+    let a = 15;\n+    let p_a = &a as *const i32;\n+\n+    *p_a // { dg-error \"dereference of raw pointer\" }\n+}\n+\n+unsafe fn qux() -> i32 {\n+    let a = 15;\n+    let p_a = &a as *const i32;\n+\n+    unsafe {}\n+\n+    *p_a\n+}"}, {"sha": "35990f6ee9f2324e18de9eda0c1499fa4c1b3450", "filename": "gcc/testsuite/rust/compile/unsafe5.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d94d5b1ea23220d423fd40bd00cadb0e6ede751f/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funsafe5.rs?ref=d94d5b1ea23220d423fd40bd00cadb0e6ede751f", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let b = 15;\n+    let c = *(&b as *const i32); // { dg-error \"dereference of raw pointer\" }\n+}"}]}