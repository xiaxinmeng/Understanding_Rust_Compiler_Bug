{"sha": "b7e757713c17d27acbce6bb2d2dd19f226e2e552", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdlNzU3NzEzYzE3ZDI3YWNiY2U2YmIyZDJkZDE5ZjIyNmUyZTU1Mg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-04-13T01:59:35Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-04-13T01:59:35Z"}, "message": "[multiple changes]\n\n2010-04-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\t* array.c (extract_element): Restore function from trunk.\n\t(gfc_get_array_element): Restore function from trunk.\n\t(gfc_expand_constructor): Restore check against\n\tflag_max_array_constructor.\n\t* constructor.c (node_copy_and_append): Delete unused.\n\t* gfortran.h: Delete comment and extra include.\n\t* constructor.h: Bump copyright and clean up TODO comments.\n\t* resolve.c: Whitespace.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* simplify.c (compute_dot_product): Replaced usage of ADVANCE macro\n\twith direct access access to elements. Adjusted prototype, fixed all\n\tcallers.\n\t(gfc_simplify_dot_product): Removed duplicate check for zero-sized\n\tarray.\n\t(gfc_simplify_matmul): Removed usage of ADVANCE macro.\n\t(gfc_simplify_spread): Removed workaround, directly insert elements\n\tat a given array position.\n\t(gfc_simplify_transpose): Likewise.\n\t(gfc_simplify_pack): Replaced usage of ADVANCE macro with corresponding\n\tfunction calls.\n\t(gfc_simplify_unpack): Likewise.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* simplify.c (only_convert_cmplx_boz): Renamed to ...\n\t(convert_boz): ... this and moved to start of file.\n\t(gfc_simplify_abs): Whitespace fix.\n\t(gfc_simplify_acos): Whitespace fix.\n\t(gfc_simplify_acosh): Whitespace fix.\n\t(gfc_simplify_aint): Whitespace fix.\n\t(gfc_simplify_dint): Whitespace fix.\n\t(gfc_simplify_anint): Whitespace fix.\n\t(gfc_simplify_and): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_dnint): Whitespace fix.\n\t(gfc_simplify_asin): Whitespace fix.\n\t(gfc_simplify_asinh): Moved creation of result-expr out of switch.\n\t(gfc_simplify_atan): Likewise.\n\t(gfc_simplify_atanh): Whitespace fix.\n\t(gfc_simplify_atan2): Whitespace fix.\n\t(gfc_simplify_bessel_j0): Removed ATTRIBUTE_UNUSED.\n\t(gfc_simplify_bessel_j1): Likewise.\n\t(gfc_simplify_bessel_jn): Likewise.\n\t(gfc_simplify_bessel_y0): Likewise.\n\t(gfc_simplify_bessel_y1): Likewise.\n\t(gfc_simplify_bessel_yn): Likewise.\n\t(gfc_simplify_ceiling): Reorderd statements.\n\t(simplify_cmplx): Use convert_boz(), check for constant arguments.\n\tWhitespace fix.\n\t(gfc_simplify_cmplx): Use correct default kind. Removed check for\n\tconstant arguments.\n\t(gfc_simplify_complex): Replaced if-gate. Removed check for\n\tconstant arguments.\n\t(gfc_simplify_conjg): Whitespace fix.\n\t(gfc_simplify_cos): Whitespace fix.\n\t(gfc_simplify_cosh): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_dcmplx): Removed check for constant arguments.\n\t(gfc_simplify_dble): Use convert_boz() and gfc_convert_constant().\n\t(gfc_simplify_digits): Whitespace fix.\n\t(gfc_simplify_dim): Whitespace fix.\n\t(gfc_simplify_dprod): Reordered statements.\n\t(gfc_simplify_erf): Whitespace fix.\n\t(gfc_simplify_erfc): Whitespace fix.\n\t(gfc_simplify_epsilon): Whitespace fix.\n\t(gfc_simplify_exp): Whitespace fix.\n\t(gfc_simplify_exponent): Use convert_boz().\n\t(gfc_simplify_floor): Reorderd statements.\n\t(gfc_simplify_gamma): Whitespace fix.\n\t(gfc_simplify_huge): Whitespace fix.\n\t(gfc_simplify_iand): Whitespace fix.\n\t(gfc_simplify_ieor): Whitespace fix.\n\t(simplify_intconv): Use gfc_convert_constant().\n\t(gfc_simplify_int): Use simplify_intconv().\n\t(gfc_simplify_int2): Reorderd statements.\n\t(gfc_simplify_idint): Reorderd statements.\n\t(gfc_simplify_ior): Whitespace fix.\n\t(gfc_simplify_ishftc): Removed duplicate type check.\n\t(gfc_simplify_len): Use range_check() instead of manual range check.\n\t(gfc_simplify_lgamma): Removed ATTRIBUTE_UNUSED. Whitespace fix.\n\t(gfc_simplify_log): Whitespace fix.\n\t(gfc_simplify_log10): Whitespace fix.\n\t(gfc_simplify_minval): Whitespace fix.\n\t(gfc_simplify_maxval): Whitespace fix.\n\t(gfc_simplify_mod): Whitespace fix.\n\t(gfc_simplify_modulo): Whitespace fix.\n\t(simplify_nint): Reorderd statements.\n\t(gfc_simplify_not): Whitespace fix.\n\t(gfc_simplify_or): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_radix): Removed unused result-variable. Whitespace fix.\n\t(gfc_simplify_range): Removed unused result-variable. Whitespace fix.\n\t(gfc_simplify_real): Use convert_boz() and gfc_convert_constant().\n\t(gfc_simplify_realpart): Whitespace fix.\n\t(gfc_simplify_selected_char_kind): Removed unused result-variable.\n\t(gfc_simplify_selected_int_kind): Removed unused result-variable.\n\t(gfc_simplify_selected_real_kind): Removed unused result-variable.\n\t(gfc_simplify_sign): Whitespace fix.\n\t(gfc_simplify_sin): Whitespace fix.\n\t(gfc_simplify_sinh): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_sqrt): Avoided goto by inlining check. Whitespace fix.\n\t(gfc_simplify_tan): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_tanh): Replaced if-gate by more common switch-over-type.\n\t(gfc_simplify_xor): Replaced if-gate by more common switch-over-type.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* gfortran.h (gfc_start_constructor): Removed.\n\t(gfc_get_array_element): Removed.\n\t* array.c (gfc_start_constructor): Removed, use gfc_get_array_expr \n\tinstead. Fixed all callers.\n\t(extract_element): Removed.\n\t(gfc_expand_constructor): Temporarily removed check for\n\tmax-array-constructor. Will be re-introduced later if still required.\n\t(gfc_get_array_element): Removed, use gfc_constructor_lookup_expr\n\tinstead. Fixed all callers.\n\t* expr.c (find_array_section): Replaced manual lookup of elements\n\tby gfc_constructor_lookup.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n        * gfortran.h (gfc_get_null_expr): New prototype.\n        (gfc_get_operator_expr): New prototype.\n        (gfc_get_character_expr): New prototype.\n        (gfc_get_iokind_expr): New prototype.\n        * expr.c (gfc_get_null_expr): New.\n        (gfc_get_character_expr): New.\n        (gfc_get_iokind_expr): New.\n        (gfc_get_operator_expr): Moved here from matchexp.c (build_node).\n        * matchexp.c (build_node): Renamed and moved to\n        expr.c (gfc_get_operator_expr). Reordered arguments to match \n        other functions. Fixed all callers.\n        (gfc_get_parentheses): Use specific function to build expr.\n        * array.c (gfc_match_array_constructor): Likewise.\n        * arith.c (eval_intrinsic): Likewise.\n        (gfc_hollerith2int): Likewise.\n        (gfc_hollerith2real): Likewise.\n        (gfc_hollerith2complex): Likewise.\n        (gfc_hollerith2logical): Likewise.\n        * data.c (create_character_intializer): Likewise.\n        * decl.c (gfc_match_null): Likewise.\n        (enum_initializer): Likewise.\n        * io.c (gfc_match_format): Likewise.\n        (match_io): Likewise.\n        * match.c (gfc_match_nullify): Likewise.\n        * primary.c (match_string_constant): Likewise.\n        (match_logical_constant): Likewise.\n        (build_actual_constructor): Likewise.\n        * resolve.c (build_default_init_expr): Likewise.\n        * symbol.c (generate_isocbinding_symbol): Likewise.\n        (gfc_build_class_symbol): Likewise.\n        (gfc_find_derived_vtab): Likewise.\n        * simplify.c (simplify_achar_char): Likewise.\n        (gfc_simplify_adjustl): Likewise.\n        (gfc_simplify_adjustr): Likewise.\n        (gfc_simplify_and): Likewise.\n        (gfc_simplify_bit_size): Likewise.\n        (gfc_simplify_is_iostat_end): Likewise.\n        (gfc_simplify_is_iostat_eor): Likewise.\n        (gfc_simplify_isnan): Likewise.\n        (simplify_bound): Likewise.\n        (gfc_simplify_leadz): Likewise.\n        (gfc_simplify_len_trim): Likewise.\n        (gfc_simplify_logical): Likewise.\n        (gfc_simplify_maxexponent): Likewise.\n        (gfc_simplify_minexponent): Likewise.\n        (gfc_simplify_new_line): Likewise.\n        (gfc_simplify_null): Likewise.\n        (gfc_simplify_or): Likewise.\n        (gfc_simplify_precision): Likewise.\n        (gfc_simplify_repeat): Likewise.\n        (gfc_simplify_scan): Likewise.\n        (gfc_simplify_size): Likewise.\n        (gfc_simplify_trailz): Likewise.\n        (gfc_simplify_trim): Likewise.\n        (gfc_simplify_verify): Likewise.\n        (gfc_simplify_xor): Likewise.\n        * trans-io.c (build_dt): Likewise.\n        (gfc_new_nml_name_expr): Removed.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* arith.h (gfc_constant_result): Removed prototype.\n\t* constructor.h (gfc_build_array_expr): Removed prototype.\n\t(gfc_build_structure_constructor_expr): Removed prototype.\n\t* gfortran.h (gfc_int_expr): Removed prototype.\n\t(gfc_logical_expr): Removed prototype.\n\t(gfc_get_array_expr): New prototype.\n\t(gfc_get_structure_constructor_expr): New prototype.\n\t(gfc_get_constant_expr): New prototype.\n\t(gfc_get_int_expr): New prototype.\n\t(gfc_get_logical_expr): New prototype.\n\t* arith.c (gfc_constant_result): Moved and renamed to\n\texpr.c (gfc_get_constant_expr). Fixed all callers.\n\t* constructor.c (gfc_build_array_expr): Moved and renamed to\n\texpr.c (gfc_get_array_expr). Split gfc_typespec argument to type\n\tand kind. Fixed all callers.\n\t(gfc_build_structure_constructor_expr): Moved and renamed to\n\texpr.c (gfc_get_structure_constructor_expr). Split gfc_typespec argument\n\tto type and kind. Fixed all callers.\n\t* expr.c (gfc_logical_expr): Renamed to ...\n\t(gfc_get_logical_expr): ... this. Added kind argument. Fixed all callers.\n\t(gfc_int_expr): Renamed to ...\n\t(gfc_get_int_expr): ... this. Added kind and where arguments. Fixed all\n\tcallers.\n\t(gfc_get_constant_expr): New.\n\t(gfc_get_array_expr): New.\n\t(gfc_get_structure_constructor_expr): New.\n\t* simplify.c (int_expr_with_kind): Removed, callers use gfc_get_int_expr\n\tinstead.\n\n2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* constructor.h: New.\n\t* constructor.c: New.\n\t* Make-lang.in: Add new files to F95_PARSER_OBJS.\n\t* arith.c (reducy_unary): Use constructor API.\n\t(reduce_binary_ac): Likewise.\n\t(reduce_binary_ca): Likewise.\n\t(reduce_binary_aa): Likewise.\n\t* check.c (gfc_check_pack): Likewise.\n\t(gfc_check_reshape): Likewise.\n\t(gfc_check_unpack): Likewise.\n\t* decl.c (add_init_expr_to_sym): Likewise.\n\t(build_struct): Likewise.\n\t* dependency.c (gfc_check_dependency): Likewise.\n\t(contains_forall_index_p): Likewise.\n\t* dump-parse-tree.c (show_constructor): Likewise.\n\t* expr.c (free_expr0): Likewise.\n\t(gfc_copy_expr): Likewise.\n\t(gfc_is_constant_expr): Likewise.\n\t(simplify_constructor): Likewise.\n\t(find_array_element): Likewise.\n\t(find_component_ref): Likewise.\n\t(find_array_section): Likewise.\n\t(find_substring_ref): Likewise.\n\t(simplify_const_ref): Likewise.\n\t(scalarize_intrinsic_call): Likewise.\n\t(check_alloc_comp_init): Likewise.\n\t(gfc_default_initializer): Likewise.\n\t(gfc_traverse_expr): Likewise.\n\t* iresolve.c (check_charlen_present): Likewise.\n\t(gfc_resolve_reshape): Likewise.\n\t(gfc_resolve_transfer): Likewise.\n\t* module.c (mio_constructor): Likewise.\n\t* primary.c (build_actual_constructor): Likewise.\n\t(gfc_match_structure_constructor): Likewise.\n\t* resolve.c (resolve_structure_cons): Likewise.\n\t* simplify.c (is_constant_array_expr): Likewise.\n\t(init_result_expr): Likewise.\n\t(transformational_result): Likewise.\n\t(simplify_transformation_to_scalar): Likewise.\n\t(simplify_transformation_to_array): Likewise.\n\t(gfc_simplify_dot_product): Likewise.\n\t(simplify_bound): Likewise.\n\t(simplify_matmul): Likewise.\n\t(simplify_minval_maxval): Likewise.\n\t(gfc_simplify_pack): Likewise.\n\t(gfc_simplify_reshape): Likewise.\n\t(gfc_simplify_shape): Likewise.\n\t(gfc_simplify_spread): Likewise.\n\t(gfc_simplify_transpose): Likewise.\n\t(gfc_simplify_unpack): Likewise.q\n\t(gfc_convert_constant): Likewise.\n\t(gfc_convert_char_constant): Likewise.\n\t* target-memory.c (size_array): Likewise.\n\t(encode_array): Likewise.\n\t(encode_derived): Likewise.\n\t(interpret_array): Likewise.\n\t(gfc_interpret_derived): Likewise.\n\t(expr_to_char): Likewise.\n\t(gfc_merge_initializers): Likewise.\n\t* trans-array.c (gfc_get_array_constructor_size): Likewise.\n\t(gfc_trans_array_constructor_value): Likewise.\n\t(get_array_ctor_strlen): Likewise.\n\t(gfc_constant_array_constructor_p): Likewise.\n\t(gfc_build_constant_array_constructor): Likewise.\n\t(gfc_trans_array_constructor): Likewise.\n\t(gfc_conv_array_initializer): Likewise.\n\t* trans-decl.c (check_constant_initializer): Likewise.\n\t* trans-expr.c (flatten_array_ctors_without_strlen): Likewise.\n\t(gfc_apply_interface_mapping_to_cons): Likewise.\n\t(gfc_trans_structure_assign): Likewise.\n\t(gfc_conv_structure): Likewise.\n\t* array.c (check_duplicate_iterator): Likewise.\n\t(match_array_list): Likewise.\n\t(match_array_cons_element): Likewise.\n\t(gfc_match_array_constructor): Likewise.\n\t(check_constructor_type): Likewise.\n\t(check_constructor): Likewise.\n\t(expand): Likewise.\n\t(expand_constructor): Likewise.\n\t(extract_element): Likewise.\n\t(gfc_expanded_ac): Likewise.\n\t(resolve_array_list): Likewise.\n\t(gfc_resolve_character_array_constructor): Likewise.\n\t(copy_iterator): Renamed to ...\n\t(gfc_copy_iterator): ... this.\n\t(gfc_append_constructor): Removed.\n\t(gfc_insert_constructor): Removed unused function.\n\t(gfc_get_constructor): Removed.\n\t(gfc_free_constructor): Removed.\n\t(qgfc_copy_constructor): Removed.\n\t* gfortran.h (struct gfc_expr): Removed member 'con_by_offset'.\n\tRemoved all references. Replaced constructor list by splay-tree.\n\t(struct gfc_constructor): Removed member 'next', moved 'offset' from\n\tthe inner struct, added member 'base'.\n\t(gfc_append_constructor): Removed prototype.\n\t(gfc_insert_constructor): Removed prototype.\n\t(gfc_get_constructor): Removed prototype.\n\t(gfc_free_constructor): Removed prototype.\n\t(qgfc_copy_constructor): Removed prototype.\n\t(gfc_copy_iterator): New prototype.\n\t* trans-array.h (gfc_constant_array_constructor_p): Adjusted prototype.\n\nFrom-SVN: r158253", "tree": {"sha": "918735c4a29176e24e41c0c81fa94027f00f96f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/918735c4a29176e24e41c0c81fa94027f00f96f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7e757713c17d27acbce6bb2d2dd19f226e2e552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e757713c17d27acbce6bb2d2dd19f226e2e552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e757713c17d27acbce6bb2d2dd19f226e2e552", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e757713c17d27acbce6bb2d2dd19f226e2e552/comments", "author": null, "committer": null, "parents": [{"sha": "57408aaf2ba396a43394465e549f157d8fbfb173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57408aaf2ba396a43394465e549f157d8fbfb173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57408aaf2ba396a43394465e549f157d8fbfb173"}], "stats": {"total": 5193, "additions": 2562, "deletions": 2631}, "files": [{"sha": "4ef8eb97c3979b49f8774ff73c6d5af350c94672", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,3 +1,319 @@\n+2010-04-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\t* array.c (extract_element): Restore function from trunk.\n+\t(gfc_get_array_element): Restore function from trunk.\n+\t(gfc_expand_constructor): Restore check against\n+\tflag_max_array_constructor.\n+\t* constructor.c (node_copy_and_append): Delete unused.\n+\t* gfortran.h: Delete comment and extra include.\n+\t* constructor.h: Bump copyright and clean up TODO comments.\n+\t* resolve.c: Whitespace.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* simplify.c (compute_dot_product): Replaced usage of ADVANCE macro\n+\twith direct access access to elements. Adjusted prototype, fixed all\n+\tcallers.\n+\t(gfc_simplify_dot_product): Removed duplicate check for zero-sized\n+\tarray.\n+\t(gfc_simplify_matmul): Removed usage of ADVANCE macro.\n+\t(gfc_simplify_spread): Removed workaround, directly insert elements\n+\tat a given array position.\n+\t(gfc_simplify_transpose): Likewise.\n+\t(gfc_simplify_pack): Replaced usage of ADVANCE macro with corresponding\n+\tfunction calls.\n+\t(gfc_simplify_unpack): Likewise.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* simplify.c (only_convert_cmplx_boz): Renamed to ...\n+\t(convert_boz): ... this and moved to start of file.\n+\t(gfc_simplify_abs): Whitespace fix.\n+\t(gfc_simplify_acos): Whitespace fix.\n+\t(gfc_simplify_acosh): Whitespace fix.\n+\t(gfc_simplify_aint): Whitespace fix.\n+\t(gfc_simplify_dint): Whitespace fix.\n+\t(gfc_simplify_anint): Whitespace fix.\n+\t(gfc_simplify_and): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_dnint): Whitespace fix.\n+\t(gfc_simplify_asin): Whitespace fix.\n+\t(gfc_simplify_asinh): Moved creation of result-expr out of switch.\n+\t(gfc_simplify_atan): Likewise.\n+\t(gfc_simplify_atanh): Whitespace fix.\n+\t(gfc_simplify_atan2): Whitespace fix.\n+\t(gfc_simplify_bessel_j0): Removed ATTRIBUTE_UNUSED.\n+\t(gfc_simplify_bessel_j1): Likewise.\n+\t(gfc_simplify_bessel_jn): Likewise.\n+\t(gfc_simplify_bessel_y0): Likewise.\n+\t(gfc_simplify_bessel_y1): Likewise.\n+\t(gfc_simplify_bessel_yn): Likewise.\n+\t(gfc_simplify_ceiling): Reorderd statements.\n+\t(simplify_cmplx): Use convert_boz(), check for constant arguments.\n+\tWhitespace fix.\n+\t(gfc_simplify_cmplx): Use correct default kind. Removed check for\n+\tconstant arguments.\n+\t(gfc_simplify_complex): Replaced if-gate. Removed check for\n+\tconstant arguments.\n+\t(gfc_simplify_conjg): Whitespace fix.\n+\t(gfc_simplify_cos): Whitespace fix.\n+\t(gfc_simplify_cosh): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_dcmplx): Removed check for constant arguments.\n+\t(gfc_simplify_dble): Use convert_boz() and gfc_convert_constant().\n+\t(gfc_simplify_digits): Whitespace fix.\n+\t(gfc_simplify_dim): Whitespace fix.\n+\t(gfc_simplify_dprod): Reordered statements.\n+\t(gfc_simplify_erf): Whitespace fix.\n+\t(gfc_simplify_erfc): Whitespace fix.\n+\t(gfc_simplify_epsilon): Whitespace fix.\n+\t(gfc_simplify_exp): Whitespace fix.\n+\t(gfc_simplify_exponent): Use convert_boz().\n+\t(gfc_simplify_floor): Reorderd statements.\n+\t(gfc_simplify_gamma): Whitespace fix.\n+\t(gfc_simplify_huge): Whitespace fix.\n+\t(gfc_simplify_iand): Whitespace fix.\n+\t(gfc_simplify_ieor): Whitespace fix.\n+\t(simplify_intconv): Use gfc_convert_constant().\n+\t(gfc_simplify_int): Use simplify_intconv().\n+\t(gfc_simplify_int2): Reorderd statements.\n+\t(gfc_simplify_idint): Reorderd statements.\n+\t(gfc_simplify_ior): Whitespace fix.\n+\t(gfc_simplify_ishftc): Removed duplicate type check.\n+\t(gfc_simplify_len): Use range_check() instead of manual range check.\n+\t(gfc_simplify_lgamma): Removed ATTRIBUTE_UNUSED. Whitespace fix.\n+\t(gfc_simplify_log): Whitespace fix.\n+\t(gfc_simplify_log10): Whitespace fix.\n+\t(gfc_simplify_minval): Whitespace fix.\n+\t(gfc_simplify_maxval): Whitespace fix.\n+\t(gfc_simplify_mod): Whitespace fix.\n+\t(gfc_simplify_modulo): Whitespace fix.\n+\t(simplify_nint): Reorderd statements.\n+\t(gfc_simplify_not): Whitespace fix.\n+\t(gfc_simplify_or): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_radix): Removed unused result-variable. Whitespace fix.\n+\t(gfc_simplify_range): Removed unused result-variable. Whitespace fix.\n+\t(gfc_simplify_real): Use convert_boz() and gfc_convert_constant().\n+\t(gfc_simplify_realpart): Whitespace fix.\n+\t(gfc_simplify_selected_char_kind): Removed unused result-variable.\n+\t(gfc_simplify_selected_int_kind): Removed unused result-variable.\n+\t(gfc_simplify_selected_real_kind): Removed unused result-variable.\n+\t(gfc_simplify_sign): Whitespace fix.\n+\t(gfc_simplify_sin): Whitespace fix.\n+\t(gfc_simplify_sinh): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_sqrt): Avoided goto by inlining check. Whitespace fix.\n+\t(gfc_simplify_tan): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_tanh): Replaced if-gate by more common switch-over-type.\n+\t(gfc_simplify_xor): Replaced if-gate by more common switch-over-type.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* gfortran.h (gfc_start_constructor): Removed.\n+\t(gfc_get_array_element): Removed.\n+\t* array.c (gfc_start_constructor): Removed, use gfc_get_array_expr \n+\tinstead. Fixed all callers.\n+\t(extract_element): Removed.\n+\t(gfc_expand_constructor): Temporarily removed check for\n+\tmax-array-constructor. Will be re-introduced later if still required.\n+\t(gfc_get_array_element): Removed, use gfc_constructor_lookup_expr\n+\tinstead. Fixed all callers.\n+\t* expr.c (find_array_section): Replaced manual lookup of elements\n+\tby gfc_constructor_lookup.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+        * gfortran.h (gfc_get_null_expr): New prototype.\n+        (gfc_get_operator_expr): New prototype.\n+        (gfc_get_character_expr): New prototype.\n+        (gfc_get_iokind_expr): New prototype.\n+        * expr.c (gfc_get_null_expr): New.\n+        (gfc_get_character_expr): New.\n+        (gfc_get_iokind_expr): New.\n+        (gfc_get_operator_expr): Moved here from matchexp.c (build_node).\n+        * matchexp.c (build_node): Renamed and moved to\n+        expr.c (gfc_get_operator_expr). Reordered arguments to match \n+        other functions. Fixed all callers.\n+        (gfc_get_parentheses): Use specific function to build expr.\n+        * array.c (gfc_match_array_constructor): Likewise.\n+        * arith.c (eval_intrinsic): Likewise.\n+        (gfc_hollerith2int): Likewise.\n+        (gfc_hollerith2real): Likewise.\n+        (gfc_hollerith2complex): Likewise.\n+        (gfc_hollerith2logical): Likewise.\n+        * data.c (create_character_intializer): Likewise.\n+        * decl.c (gfc_match_null): Likewise.\n+        (enum_initializer): Likewise.\n+        * io.c (gfc_match_format): Likewise.\n+        (match_io): Likewise.\n+        * match.c (gfc_match_nullify): Likewise.\n+        * primary.c (match_string_constant): Likewise.\n+        (match_logical_constant): Likewise.\n+        (build_actual_constructor): Likewise.\n+        * resolve.c (build_default_init_expr): Likewise.\n+        * symbol.c (generate_isocbinding_symbol): Likewise.\n+        (gfc_build_class_symbol): Likewise.\n+        (gfc_find_derived_vtab): Likewise.\n+        * simplify.c (simplify_achar_char): Likewise.\n+        (gfc_simplify_adjustl): Likewise.\n+        (gfc_simplify_adjustr): Likewise.\n+        (gfc_simplify_and): Likewise.\n+        (gfc_simplify_bit_size): Likewise.\n+        (gfc_simplify_is_iostat_end): Likewise.\n+        (gfc_simplify_is_iostat_eor): Likewise.\n+        (gfc_simplify_isnan): Likewise.\n+        (simplify_bound): Likewise.\n+        (gfc_simplify_leadz): Likewise.\n+        (gfc_simplify_len_trim): Likewise.\n+        (gfc_simplify_logical): Likewise.\n+        (gfc_simplify_maxexponent): Likewise.\n+        (gfc_simplify_minexponent): Likewise.\n+        (gfc_simplify_new_line): Likewise.\n+        (gfc_simplify_null): Likewise.\n+        (gfc_simplify_or): Likewise.\n+        (gfc_simplify_precision): Likewise.\n+        (gfc_simplify_repeat): Likewise.\n+        (gfc_simplify_scan): Likewise.\n+        (gfc_simplify_size): Likewise.\n+        (gfc_simplify_trailz): Likewise.\n+        (gfc_simplify_trim): Likewise.\n+        (gfc_simplify_verify): Likewise.\n+        (gfc_simplify_xor): Likewise.\n+        * trans-io.c (build_dt): Likewise.\n+        (gfc_new_nml_name_expr): Removed.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* arith.h (gfc_constant_result): Removed prototype.\n+\t* constructor.h (gfc_build_array_expr): Removed prototype.\n+\t(gfc_build_structure_constructor_expr): Removed prototype.\n+\t* gfortran.h (gfc_int_expr): Removed prototype.\n+\t(gfc_logical_expr): Removed prototype.\n+\t(gfc_get_array_expr): New prototype.\n+\t(gfc_get_structure_constructor_expr): New prototype.\n+\t(gfc_get_constant_expr): New prototype.\n+\t(gfc_get_int_expr): New prototype.\n+\t(gfc_get_logical_expr): New prototype.\n+\t* arith.c (gfc_constant_result): Moved and renamed to\n+\texpr.c (gfc_get_constant_expr). Fixed all callers.\n+\t* constructor.c (gfc_build_array_expr): Moved and renamed to\n+\texpr.c (gfc_get_array_expr). Split gfc_typespec argument to type\n+\tand kind. Fixed all callers.\n+\t(gfc_build_structure_constructor_expr): Moved and renamed to\n+\texpr.c (gfc_get_structure_constructor_expr). Split gfc_typespec argument\n+\tto type and kind. Fixed all callers.\n+\t* expr.c (gfc_logical_expr): Renamed to ...\n+\t(gfc_get_logical_expr): ... this. Added kind argument. Fixed all callers.\n+\t(gfc_int_expr): Renamed to ...\n+\t(gfc_get_int_expr): ... this. Added kind and where arguments. Fixed all\n+\tcallers.\n+\t(gfc_get_constant_expr): New.\n+\t(gfc_get_array_expr): New.\n+\t(gfc_get_structure_constructor_expr): New.\n+\t* simplify.c (int_expr_with_kind): Removed, callers use gfc_get_int_expr\n+\tinstead.\n+\n+2010-04-12  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* constructor.h: New.\n+\t* constructor.c: New.\n+\t* Make-lang.in: Add new files to F95_PARSER_OBJS.\n+\t* arith.c (reducy_unary): Use constructor API.\n+\t(reduce_binary_ac): Likewise.\n+\t(reduce_binary_ca): Likewise.\n+\t(reduce_binary_aa): Likewise.\n+\t* check.c (gfc_check_pack): Likewise.\n+\t(gfc_check_reshape): Likewise.\n+\t(gfc_check_unpack): Likewise.\n+\t* decl.c (add_init_expr_to_sym): Likewise.\n+\t(build_struct): Likewise.\n+\t* dependency.c (gfc_check_dependency): Likewise.\n+\t(contains_forall_index_p): Likewise.\n+\t* dump-parse-tree.c (show_constructor): Likewise.\n+\t* expr.c (free_expr0): Likewise.\n+\t(gfc_copy_expr): Likewise.\n+\t(gfc_is_constant_expr): Likewise.\n+\t(simplify_constructor): Likewise.\n+\t(find_array_element): Likewise.\n+\t(find_component_ref): Likewise.\n+\t(find_array_section): Likewise.\n+\t(find_substring_ref): Likewise.\n+\t(simplify_const_ref): Likewise.\n+\t(scalarize_intrinsic_call): Likewise.\n+\t(check_alloc_comp_init): Likewise.\n+\t(gfc_default_initializer): Likewise.\n+\t(gfc_traverse_expr): Likewise.\n+\t* iresolve.c (check_charlen_present): Likewise.\n+\t(gfc_resolve_reshape): Likewise.\n+\t(gfc_resolve_transfer): Likewise.\n+\t* module.c (mio_constructor): Likewise.\n+\t* primary.c (build_actual_constructor): Likewise.\n+\t(gfc_match_structure_constructor): Likewise.\n+\t* resolve.c (resolve_structure_cons): Likewise.\n+\t* simplify.c (is_constant_array_expr): Likewise.\n+\t(init_result_expr): Likewise.\n+\t(transformational_result): Likewise.\n+\t(simplify_transformation_to_scalar): Likewise.\n+\t(simplify_transformation_to_array): Likewise.\n+\t(gfc_simplify_dot_product): Likewise.\n+\t(simplify_bound): Likewise.\n+\t(simplify_matmul): Likewise.\n+\t(simplify_minval_maxval): Likewise.\n+\t(gfc_simplify_pack): Likewise.\n+\t(gfc_simplify_reshape): Likewise.\n+\t(gfc_simplify_shape): Likewise.\n+\t(gfc_simplify_spread): Likewise.\n+\t(gfc_simplify_transpose): Likewise.\n+\t(gfc_simplify_unpack): Likewise.q\n+\t(gfc_convert_constant): Likewise.\n+\t(gfc_convert_char_constant): Likewise.\n+\t* target-memory.c (size_array): Likewise.\n+\t(encode_array): Likewise.\n+\t(encode_derived): Likewise.\n+\t(interpret_array): Likewise.\n+\t(gfc_interpret_derived): Likewise.\n+\t(expr_to_char): Likewise.\n+\t(gfc_merge_initializers): Likewise.\n+\t* trans-array.c (gfc_get_array_constructor_size): Likewise.\n+\t(gfc_trans_array_constructor_value): Likewise.\n+\t(get_array_ctor_strlen): Likewise.\n+\t(gfc_constant_array_constructor_p): Likewise.\n+\t(gfc_build_constant_array_constructor): Likewise.\n+\t(gfc_trans_array_constructor): Likewise.\n+\t(gfc_conv_array_initializer): Likewise.\n+\t* trans-decl.c (check_constant_initializer): Likewise.\n+\t* trans-expr.c (flatten_array_ctors_without_strlen): Likewise.\n+\t(gfc_apply_interface_mapping_to_cons): Likewise.\n+\t(gfc_trans_structure_assign): Likewise.\n+\t(gfc_conv_structure): Likewise.\n+\t* array.c (check_duplicate_iterator): Likewise.\n+\t(match_array_list): Likewise.\n+\t(match_array_cons_element): Likewise.\n+\t(gfc_match_array_constructor): Likewise.\n+\t(check_constructor_type): Likewise.\n+\t(check_constructor): Likewise.\n+\t(expand): Likewise.\n+\t(expand_constructor): Likewise.\n+\t(extract_element): Likewise.\n+\t(gfc_expanded_ac): Likewise.\n+\t(resolve_array_list): Likewise.\n+\t(gfc_resolve_character_array_constructor): Likewise.\n+\t(copy_iterator): Renamed to ...\n+\t(gfc_copy_iterator): ... this.\n+\t(gfc_append_constructor): Removed.\n+\t(gfc_insert_constructor): Removed unused function.\n+\t(gfc_get_constructor): Removed.\n+\t(gfc_free_constructor): Removed.\n+\t(qgfc_copy_constructor): Removed.\n+\t* gfortran.h (struct gfc_expr): Removed member 'con_by_offset'.\n+\tRemoved all references. Replaced constructor list by splay-tree.\n+\t(struct gfc_constructor): Removed member 'next', moved 'offset' from\n+\tthe inner struct, added member 'base'.\n+\t(gfc_append_constructor): Removed prototype.\n+\t(gfc_insert_constructor): Removed prototype.\n+\t(gfc_get_constructor): Removed prototype.\n+\t(gfc_free_constructor): Removed prototype.\n+\t(qgfc_copy_constructor): Removed prototype.\n+\t(gfc_copy_iterator): New prototype.\n+\t* trans-array.h (gfc_constant_array_constructor_p): Adjusted prototype.\n+\n 2010-04-10  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/43591"}, {"sha": "d9544a4e06e973df0d4543f23fbe80218765a1b8", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -53,8 +53,8 @@ fortran-warn = $(STRICT_WARN)\n # from the parse tree to GENERIC\n \n F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \\\n-    fortran/check.o fortran/cpp.o fortran/data.o fortran/decl.o \\\n-    fortran/dump-parse-tree.o fortran/error.o fortran/expr.o \\\n+    fortran/check.o fortran/constructor.o fortran/cpp.o fortran/data.o \\\n+    fortran/decl.o fortran/dump-parse-tree.o fortran/error.o fortran/expr.o \\\n     fortran/interface.o fortran/intrinsic.o fortran/io.o fortran/iresolve.o \\\n     fortran/match.o fortran/matchexp.o fortran/misc.o fortran/module.o \\\n     fortran/openmp.o fortran/options.o fortran/parse.o fortran/primary.o \\\n@@ -320,7 +320,7 @@ fortran.stagefeedback: stageprofile-start\n # TODO: Add dependencies on the backend/tree header files\n \n $(F95_PARSER_OBJS): fortran/gfortran.h fortran/libgfortran.h \\\n-\t\tfortran/intrinsic.h fortran/match.h \\\n+\t\tfortran/intrinsic.h fortran/match.h fortran/constructor.h \\\n \t\tfortran/parse.h fortran/arith.h fortran/target-memory.h \\\n \t\t$(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TM_P_H) coretypes.h \\\n \t\t$(RTL_H) $(TREE_H) $(TREE_DUMP_H) $(GGC_H) $(EXPR_H) \\"}, {"sha": "7a9741b0cdd081973105e8c90cc91d38b902d521", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 104, "deletions": 193, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,6 @@\n /* Compiler arithmetic\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -30,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"arith.h\"\n #include \"target-memory.h\"\n+#include \"constructor.h\"\n \n /* MPFR does not have a direct replacement for mpz_set_f() from GMP.\n    It's easily implemented with a few calls though.  */\n@@ -399,47 +401,6 @@ gfc_check_real_range (mpfr_t p, int kind)\n }\n \n \n-/* Function to return a constant expression node of a given type and kind.  */\n-\n-gfc_expr *\n-gfc_constant_result (bt type, int kind, locus *where)\n-{\n-  gfc_expr *result;\n-\n-  if (!where)\n-    gfc_internal_error (\"gfc_constant_result(): locus 'where' cannot be NULL\");\n-\n-  result = gfc_get_expr ();\n-\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = type;\n-  result->ts.kind = kind;\n-  result->where = *where;\n-\n-  switch (type)\n-    {\n-    case BT_INTEGER:\n-      mpz_init (result->value.integer);\n-      break;\n-\n-    case BT_REAL:\n-      gfc_set_model_kind (kind);\n-      mpfr_init (result->value.real);\n-      break;\n-\n-    case BT_COMPLEX:\n-      gfc_set_model_kind (kind);\n-      mpc_init2 (result->value.complex, mpfr_get_default_prec());\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return result;\n-}\n-\n-\n /* Low-level arithmetic functions.  All of these subroutines assume\n    that all operands are of the same type and return an operand of the\n    same type.  The other thing about these subroutines is that they\n@@ -451,7 +412,7 @@ gfc_arith_not (gfc_expr *op1, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, op1->ts.kind, &op1->where);\n   result->value.logical = !op1->value.logical;\n   *resultp = result;\n \n@@ -464,8 +425,8 @@ gfc_arith_and (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_kind_max (op1, op2),\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_kind_max (op1, op2),\n+\t\t\t\t  &op1->where);\n   result->value.logical = op1->value.logical && op2->value.logical;\n   *resultp = result;\n \n@@ -478,8 +439,8 @@ gfc_arith_or (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_kind_max (op1, op2),\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_kind_max (op1, op2),\n+\t\t\t\t  &op1->where);\n   result->value.logical = op1->value.logical || op2->value.logical;\n   *resultp = result;\n \n@@ -492,8 +453,8 @@ gfc_arith_eqv (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_kind_max (op1, op2),\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_kind_max (op1, op2),\n+\t\t\t\t  &op1->where);\n   result->value.logical = op1->value.logical == op2->value.logical;\n   *resultp = result;\n \n@@ -506,8 +467,8 @@ gfc_arith_neqv (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_kind_max (op1, op2),\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_kind_max (op1, op2),\n+\t\t\t\t  &op1->where);\n   result->value.logical = op1->value.logical != op2->value.logical;\n   *resultp = result;\n \n@@ -621,7 +582,7 @@ gfc_arith_uminus (gfc_expr *op1, gfc_expr **resultp)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op1->ts.type)\n     {\n@@ -653,7 +614,7 @@ gfc_arith_plus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op1->ts.type)\n     {\n@@ -687,7 +648,7 @@ gfc_arith_minus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op1->ts.type)\n     {\n@@ -721,7 +682,7 @@ gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op1->ts.type)\n     {\n@@ -758,7 +719,7 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   rc = ARITH_OK;\n \n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op1->ts.type)\n     {\n@@ -826,7 +787,7 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   extern bool init_flag;\n \n   rc = ARITH_OK;\n-  result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n+  result = gfc_get_constant_expr (op1->ts.type, op1->ts.kind, &op1->where);\n \n   switch (op2->ts.type)\n     {\n@@ -992,8 +953,8 @@ gfc_arith_concat (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   int len;\n \n   gcc_assert (op1->ts.kind == op2->ts.kind);\n-  result = gfc_constant_result (BT_CHARACTER, op1->ts.kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_CHARACTER, op1->ts.kind,\n+\t\t\t\t  &op1->where);\n \n   len = op1->value.character.length + op2->value.character.length;\n \n@@ -1162,8 +1123,8 @@ gfc_arith_eq (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (op1->ts.type == BT_COMPLEX)\n \t\t\t? compare_complex (op1, op2)\n \t\t\t: (gfc_compare_expr (op1, op2, INTRINSIC_EQ) == 0);\n@@ -1178,8 +1139,8 @@ gfc_arith_ne (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (op1->ts.type == BT_COMPLEX)\n \t\t\t? !compare_complex (op1, op2)\n \t\t\t: (gfc_compare_expr (op1, op2, INTRINSIC_EQ) != 0);\n@@ -1194,8 +1155,8 @@ gfc_arith_gt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_GT) > 0);\n   *resultp = result;\n \n@@ -1208,8 +1169,8 @@ gfc_arith_ge (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_GE) >= 0);\n   *resultp = result;\n \n@@ -1222,8 +1183,8 @@ gfc_arith_lt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_LT) < 0);\n   *resultp = result;\n \n@@ -1236,8 +1197,8 @@ gfc_arith_le (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n-\t\t\t\t&op1->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, gfc_default_logical_kind,\n+\t\t\t\t  &op1->where);\n   result->value.logical = (gfc_compare_expr (op1, op2, INTRINSIC_LE) <= 0);\n   *resultp = result;\n \n@@ -1249,17 +1210,17 @@ static arith\n reduce_unary (arith (*eval) (gfc_expr *, gfc_expr **), gfc_expr *op,\n \t      gfc_expr **result)\n {\n-  gfc_constructor *c, *head;\n+  gfc_constructor_base head;\n+  gfc_constructor *c;\n   gfc_expr *r;\n   arith rc;\n \n   if (op->expr_type == EXPR_CONSTANT)\n     return eval (op, result);\n \n   rc = ARITH_OK;\n-  head = gfc_copy_constructor (op->value.constructor);\n-\n-  for (c = head; c; c = c->next)\n+  head = gfc_constructor_copy (op->value.constructor);\n+  for (c = gfc_constructor_first (head); c; c = gfc_constructor_next (c))\n     {\n       rc = reduce_unary (eval, c->expr, &r);\n \n@@ -1270,18 +1231,15 @@ reduce_unary (arith (*eval) (gfc_expr *, gfc_expr **), gfc_expr *op,\n     }\n \n   if (rc != ARITH_OK)\n-    gfc_free_constructor (head);\n+    gfc_constructor_free (head);\n   else\n     {\n-      r = gfc_get_expr ();\n-      r->expr_type = EXPR_ARRAY;\n-      r->value.constructor = head;\n+      gfc_constructor *c = gfc_constructor_first (head);\n+      r = gfc_get_array_expr (c->expr->ts.type, c->expr->ts.kind,\n+\t\t\t      &op->where);\n       r->shape = gfc_copy_shape (op->shape, op->rank);\n-\n-      r->ts = head->expr->ts;\n-      r->where = op->where;\n       r->rank = op->rank;\n-\n+      r->value.constructor = head;\n       *result = r;\n     }\n \n@@ -1293,14 +1251,13 @@ static arith\n reduce_binary_ac (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n-  gfc_constructor *c, *head;\n+  gfc_constructor_base head;\n+  gfc_constructor *c;\n   gfc_expr *r;\n-  arith rc;\n+  arith rc = ARITH_OK;\n \n-  head = gfc_copy_constructor (op1->value.constructor);\n-  rc = ARITH_OK;\n-\n-  for (c = head; c; c = c->next)\n+  head = gfc_constructor_copy (op1->value.constructor);\n+  for (c = gfc_constructor_first (head); c; c = gfc_constructor_next (c))\n     {\n       if (c->expr->expr_type == EXPR_CONSTANT)\n         rc = eval (c->expr, op2, &r);\n@@ -1314,18 +1271,15 @@ reduce_binary_ac (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n     }\n \n   if (rc != ARITH_OK)\n-    gfc_free_constructor (head);\n+    gfc_constructor_free (head);\n   else\n     {\n-      r = gfc_get_expr ();\n-      r->expr_type = EXPR_ARRAY;\n-      r->value.constructor = head;\n+      gfc_constructor *c = gfc_constructor_first (head);\n+      r = gfc_get_array_expr (c->expr->ts.type, c->expr->ts.kind,\n+\t\t\t      &op1->where);\n       r->shape = gfc_copy_shape (op1->shape, op1->rank);\n-\n-      r->ts = head->expr->ts;\n-      r->where = op1->where;\n       r->rank = op1->rank;\n-\n+      r->value.constructor = head;\n       *result = r;\n     }\n \n@@ -1337,14 +1291,13 @@ static arith\n reduce_binary_ca (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n-  gfc_constructor *c, *head;\n+  gfc_constructor_base head;\n+  gfc_constructor *c;\n   gfc_expr *r;\n-  arith rc;\n+  arith rc = ARITH_OK;\n \n-  head = gfc_copy_constructor (op2->value.constructor);\n-  rc = ARITH_OK;\n-\n-  for (c = head; c; c = c->next)\n+  head = gfc_constructor_copy (op2->value.constructor);\n+  for (c = gfc_constructor_first (head); c; c = gfc_constructor_next (c))\n     {\n       if (c->expr->expr_type == EXPR_CONSTANT)\n \trc = eval (op1, c->expr, &r);\n@@ -1358,18 +1311,15 @@ reduce_binary_ca (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n     }\n \n   if (rc != ARITH_OK)\n-    gfc_free_constructor (head);\n+    gfc_constructor_free (head);\n   else\n     {\n-      r = gfc_get_expr ();\n-      r->expr_type = EXPR_ARRAY;\n-      r->value.constructor = head;\n+      gfc_constructor *c = gfc_constructor_first (head);\n+      r = gfc_get_array_expr (c->expr->ts.type, c->expr->ts.kind,\n+\t\t\t      &op2->where);\n       r->shape = gfc_copy_shape (op2->shape, op2->rank);\n-\n-      r->ts = head->expr->ts;\n-      r->where = op2->where;\n       r->rank = op2->rank;\n-\n+      r->value.constructor = head;\n       *result = r;\n     }\n \n@@ -1386,52 +1336,41 @@ static arith\n reduce_binary_aa (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n-  gfc_constructor *c, *d, *head;\n+  gfc_constructor_base head;\n+  gfc_constructor *c, *d;\n   gfc_expr *r;\n-  arith rc;\n+  arith rc = ARITH_OK;\n \n-  head = gfc_copy_constructor (op1->value.constructor);\n+  if (gfc_check_conformance (op1, op2,\n+\t\t\t     \"elemental binary operation\") != SUCCESS)\n+    return ARITH_INCOMMENSURATE;\n \n-  rc = ARITH_OK;\n-  d = op2->value.constructor;\n-\n-  if (gfc_check_conformance (op1, op2, \"elemental binary operation\")\n-      != SUCCESS)\n-    rc = ARITH_INCOMMENSURATE;\n-  else\n+  head = gfc_constructor_copy (op1->value.constructor);\n+  for (c = gfc_constructor_first (head),\n+       d = gfc_constructor_first (op2->value.constructor);\n+       c && d;\n+       c = gfc_constructor_next (c), d = gfc_constructor_next (d))\n     {\n-      for (c = head; c; c = c->next, d = d->next)\n-\t{\n-\t  if (d == NULL)\n-\t    {\n-\t      rc = ARITH_INCOMMENSURATE;\n-\t      break;\n-\t    }\n-\n-\t  rc = reduce_binary (eval, c->expr, d->expr, &r);\n-\t  if (rc != ARITH_OK)\n-\t    break;\n-\n-\t  gfc_replace_expr (c->expr, r);\n-\t}\n+\trc = reduce_binary (eval, c->expr, d->expr, &r);\n+\tif (rc != ARITH_OK)\n+\t  break;\n \n-      if (d != NULL)\n-\trc = ARITH_INCOMMENSURATE;\n+\tgfc_replace_expr (c->expr, r);\n     }\n \n+  if (c || d)\n+    rc = ARITH_INCOMMENSURATE;\n+\n   if (rc != ARITH_OK)\n-    gfc_free_constructor (head);\n+    gfc_constructor_free (head);\n   else\n     {\n-      r = gfc_get_expr ();\n-      r->expr_type = EXPR_ARRAY;\n-      r->value.constructor = head;\n+      gfc_constructor *c = gfc_constructor_first (head);\n+      r = gfc_get_array_expr (c->expr->ts.type, c->expr->ts.kind,\n+\t\t\t      &op1->where);\n       r->shape = gfc_copy_shape (op1->shape, op1->rank);\n-\n-      r->ts = head->expr->ts;\n-      r->where = op1->where;\n       r->rank = op1->rank;\n-\n+      r->value.constructor = head;\n       *result = r;\n     }\n \n@@ -1644,17 +1583,9 @@ eval_intrinsic (gfc_intrinsic_op op,\n \n runtime:\n   /* Create a run-time expression.  */\n-  result = gfc_get_expr ();\n+  result = gfc_get_operator_expr (&op1->where, op, op1, op2);\n   result->ts = temp.ts;\n \n-  result->expr_type = EXPR_OP;\n-  result->value.op.op = op;\n-\n-  result->value.op.op1 = op1;\n-  result->value.op.op2 = op2;\n-\n-  result->where = op1->where;\n-\n   return result;\n }\n \n@@ -1921,7 +1852,7 @@ gfc_convert_integer (const char *buffer, int kind, int radix, locus *where)\n   gfc_expr *e;\n   const char *t;\n \n-  e = gfc_constant_result (BT_INTEGER, kind, where);\n+  e = gfc_get_constant_expr (BT_INTEGER, kind, where);\n   /* A leading plus is allowed, but not by mpz_set_str.  */\n   if (buffer[0] == '+')\n     t = buffer + 1;\n@@ -1940,7 +1871,7 @@ gfc_convert_real (const char *buffer, int kind, locus *where)\n {\n   gfc_expr *e;\n \n-  e = gfc_constant_result (BT_REAL, kind, where);\n+  e = gfc_get_constant_expr (BT_REAL, kind, where);\n   mpfr_set_str (e->value.real, buffer, 10, GFC_RND_MODE);\n \n   return e;\n@@ -1955,7 +1886,7 @@ gfc_convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n {\n   gfc_expr *e;\n \n-  e = gfc_constant_result (BT_COMPLEX, kind, &real->where);\n+  e = gfc_get_constant_expr (BT_COMPLEX, kind, &real->where);\n   mpc_set_fr_fr (e->value.complex, real->value.real, imag->value.real,\n \t\t GFC_MPC_RND_MODE);\n \n@@ -2022,7 +1953,7 @@ gfc_int2int (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n   mpz_set (result->value.integer, src->value.integer);\n \n@@ -2052,7 +1983,7 @@ gfc_int2real (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_REAL, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n   mpfr_set_z (result->value.real, src->value.integer, GFC_RND_MODE);\n \n@@ -2075,7 +2006,7 @@ gfc_int2complex (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n   mpc_set_z (result->value.complex, src->value.integer, GFC_MPC_RND_MODE);\n \n@@ -2099,7 +2030,7 @@ gfc_real2int (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n   gfc_mpfr_to_mpz (result->value.integer, src->value.real, &src->where);\n \n@@ -2122,7 +2053,7 @@ gfc_real2real (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_REAL, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n   mpfr_set (result->value.real, src->value.real, GFC_RND_MODE);\n \n@@ -2153,7 +2084,7 @@ gfc_real2complex (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n   mpc_set_fr (result->value.complex, src->value.real, GFC_MPC_RND_MODE);\n \n@@ -2184,7 +2115,7 @@ gfc_complex2int (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n   gfc_mpfr_to_mpz (result->value.integer, mpc_realref (src->value.complex),\n \t\t   &src->where);\n@@ -2208,7 +2139,7 @@ gfc_complex2real (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_REAL, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n   mpc_real (result->value.real, src->value.complex, GFC_RND_MODE);\n \n@@ -2239,7 +2170,7 @@ gfc_complex2complex (gfc_expr *src, int kind)\n   gfc_expr *result;\n   arith rc;\n \n-  result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n   mpc_set (result->value.complex, src->value.complex, GFC_MPC_RND_MODE);\n \n@@ -2284,7 +2215,7 @@ gfc_log2log (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, kind, &src->where);\n   result->value.logical = src->value.logical;\n \n   return result;\n@@ -2298,7 +2229,7 @@ gfc_log2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n   mpz_set_si (result->value.integer, src->value.logical);\n \n   return result;\n@@ -2312,7 +2243,7 @@ gfc_int2log (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n \n-  result = gfc_constant_result (BT_LOGICAL, kind, &src->where);\n+  result = gfc_get_constant_expr (BT_LOGICAL, kind, &src->where);\n   result->value.logical = (mpz_cmp_si (src->value.integer, 0) != 0);\n \n   return result;\n@@ -2355,12 +2286,7 @@ gfc_expr *\n gfc_hollerith2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = BT_INTEGER;\n-  result->ts.kind = kind;\n-  result->where = src->where;\n+  result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n   hollerith2representation (result, src);\n   gfc_interpret_integer (kind, (unsigned char *) result->representation.string,\n@@ -2376,12 +2302,7 @@ gfc_expr *\n gfc_hollerith2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = BT_REAL;\n-  result->ts.kind = kind;\n-  result->where = src->where;\n+  result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n   hollerith2representation (result, src);\n   gfc_interpret_float (kind, (unsigned char *) result->representation.string,\n@@ -2397,12 +2318,7 @@ gfc_expr *\n gfc_hollerith2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = BT_COMPLEX;\n-  result->ts.kind = kind;\n-  result->where = src->where;\n+  result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n   hollerith2representation (result, src);\n   gfc_interpret_complex (kind, (unsigned char *) result->representation.string,\n@@ -2437,12 +2353,7 @@ gfc_expr *\n gfc_hollerith2logical (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = BT_LOGICAL;\n-  result->ts.kind = kind;\n-  result->where = src->where;\n+  result = gfc_get_constant_expr (BT_LOGICAL, kind, &src->where);\n \n   hollerith2representation (result, src);\n   gfc_interpret_logical (kind, (unsigned char *) result->representation.string,"}, {"sha": "7066bb079494e8001707d88297c05d061d8ce4d2", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -31,9 +31,6 @@ void gfc_mpfr_to_mpz (mpz_t, mpfr_t, locus *);\n void gfc_set_model_kind (int);\n void gfc_set_model (mpfr_t);\n \n-/* Return a constant result of a given type and kind, with locus.  */\n-gfc_expr *gfc_constant_result (bt, int, locus *);\n-\n /* Make sure a gfc_expr expression is within its allowed range.  Checks\n    for overflow and underflow.  */\n arith gfc_range_check (gfc_expr *);"}, {"sha": "c3e366d677b8852c977d3c4ff699d0454e4e13e5", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 111, "deletions": 337, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"gfortran.h\"\n #include \"match.h\"\n+#include \"constructor.h\"\n \n /**************** Array reference matching subroutines *****************/\n \n@@ -365,7 +366,7 @@ match_array_element_spec (gfc_array_spec *as)\n \n   if (gfc_match_char ('*') == MATCH_YES)\n     {\n-      *lower = gfc_int_expr (1);\n+      *lower = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n       return AS_ASSUMED_SIZE;\n     }\n \n@@ -382,7 +383,7 @@ match_array_element_spec (gfc_array_spec *as)\n \n   if (gfc_match_char (':') == MATCH_NO)\n     {\n-      *lower = gfc_int_expr (1);\n+      *lower = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n       return AS_EXPLICIT;\n     }\n \n@@ -635,7 +636,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n       for (i = 0; i < as->rank + as->corank; i++)\n \t{\n \t  if (as->lower[i] == NULL)\n-\t    as->lower[i] = gfc_int_expr (1);\n+\t    as->lower[i] = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n \t}\n     }\n \n@@ -806,163 +807,19 @@ gfc_compare_array_spec (gfc_array_spec *as1, gfc_array_spec *as2)\n \n /****************** Array constructor functions ******************/\n \n-/* Start an array constructor.  The constructor starts with zero\n-   elements and should be appended to by gfc_append_constructor().  */\n-\n-gfc_expr *\n-gfc_start_constructor (bt type, int kind, locus *where)\n-{\n-  gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-\n-  result->expr_type = EXPR_ARRAY;\n-  result->rank = 1;\n-\n-  result->ts.type = type;\n-  result->ts.kind = kind;\n-  result->where = *where;\n-  return result;\n-}\n-\n-\n-/* Given an array constructor expression, append the new expression\n-   node onto the constructor.  */\n-\n-void\n-gfc_append_constructor (gfc_expr *base, gfc_expr *new_expr)\n-{\n-  gfc_constructor *c;\n-\n-  if (base->value.constructor == NULL)\n-    base->value.constructor = c = gfc_get_constructor ();\n-  else\n-    {\n-      c = base->value.constructor;\n-      while (c->next)\n-\tc = c->next;\n-\n-      c->next = gfc_get_constructor ();\n-      c = c->next;\n-    }\n-\n-  c->expr = new_expr;\n-\n-  if (new_expr\n-      && (new_expr->ts.type != base->ts.type || new_expr->ts.kind != base->ts.kind))\n-    gfc_internal_error (\"gfc_append_constructor(): New node has wrong kind\");\n-}\n-\n-\n-/* Given an array constructor expression, insert the new expression's\n-   constructor onto the base's one according to the offset.  */\n-\n-void\n-gfc_insert_constructor (gfc_expr *base, gfc_constructor *c1)\n-{\n-  gfc_constructor *c, *pre;\n-  expr_t type;\n-  int t;\n-\n-  type = base->expr_type;\n-\n-  if (base->value.constructor == NULL)\n-    base->value.constructor = c1;\n-  else\n-    {\n-      c = pre = base->value.constructor;\n-      while (c)\n-\t{\n-\t  if (type == EXPR_ARRAY)\n-\t    {\n-\t      t = mpz_cmp (c->n.offset, c1->n.offset);\n-\t      if (t < 0)\n-\t\t{\n-\t\t  pre = c;\n-\t\t  c = c->next;\n-\t\t}\n-\t      else if (t == 0)\n-\t\t{\n-\t\t  gfc_error (\"duplicated initializer\");\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\tbreak;\n-\t    }\n-\t  else\n-\t    {\n-\t      pre = c;\n-\t      c = c->next;\n-\t    }\n-\t}\n-\n-      if (pre != c)\n-\t{\n-\t  pre->next = c1;\n-\t  c1->next = c;\n-\t}\n-      else\n-\t{\n-\t  c1->next = c;\n-\t  base->value.constructor = c1;\n-\t}\n-    }\n-}\n-\n-\n-/* Get a new constructor.  */\n-\n-gfc_constructor *\n-gfc_get_constructor (void)\n-{\n-  gfc_constructor *c;\n-\n-  c = XCNEW (gfc_constructor);\n-  c->expr = NULL;\n-  c->iterator = NULL;\n-  c->next = NULL;\n-  mpz_init_set_si (c->n.offset, 0);\n-  mpz_init_set_si (c->repeat, 0);\n-  return c;\n-}\n-\n-\n-/* Free chains of gfc_constructor structures.  */\n-\n-void\n-gfc_free_constructor (gfc_constructor *p)\n-{\n-  gfc_constructor *next;\n-\n-  if (p == NULL)\n-    return;\n-\n-  for (; p; p = next)\n-    {\n-      next = p->next;\n-\n-      if (p->expr)\n-\tgfc_free_expr (p->expr);\n-      if (p->iterator != NULL)\n-\tgfc_free_iterator (p->iterator, 1);\n-      mpz_clear (p->n.offset);\n-      mpz_clear (p->repeat);\n-      gfc_free (p);\n-    }\n-}\n-\n \n /* Given an expression node that might be an array constructor and a\n    symbol, make sure that no iterators in this or child constructors\n    use the symbol as an implied-DO iterator.  Returns nonzero if a\n    duplicate was found.  */\n \n static int\n-check_duplicate_iterator (gfc_constructor *c, gfc_symbol *master)\n+check_duplicate_iterator (gfc_constructor_base base, gfc_symbol *master)\n {\n+  gfc_constructor *c;\n   gfc_expr *e;\n \n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       e = c->expr;\n \n@@ -987,14 +844,15 @@ check_duplicate_iterator (gfc_constructor *c, gfc_symbol *master)\n \n \n /* Forward declaration because these functions are mutually recursive.  */\n-static match match_array_cons_element (gfc_constructor **);\n+static match match_array_cons_element (gfc_constructor_base *);\n \n /* Match a list of array elements.  */\n \n static match\n-match_array_list (gfc_constructor **result)\n+match_array_list (gfc_constructor_base *result)\n {\n-  gfc_constructor *p, *head, *tail, *new_cons;\n+  gfc_constructor_base head;\n+  gfc_constructor *p;\n   gfc_iterator iter;\n   locus old_loc;\n   gfc_expr *e;\n@@ -1013,8 +871,6 @@ match_array_list (gfc_constructor **result)\n   if (m != MATCH_YES)\n     goto cleanup;\n \n-  tail = head;\n-\n   if (gfc_match_char (',') != MATCH_YES)\n     {\n       m = MATCH_NO;\n@@ -1029,7 +885,7 @@ match_array_list (gfc_constructor **result)\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n \n-      m = match_array_cons_element (&new_cons);\n+      m = match_array_cons_element (&head);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_NO)\n@@ -1040,9 +896,6 @@ match_array_list (gfc_constructor **result)\n \t  goto cleanup;\t\t/* Could be a complex constant */\n \t}\n \n-      tail->next = new_cons;\n-      tail = new_cons;\n-\n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n \t  if (n > 2)\n@@ -1061,27 +914,21 @@ match_array_list (gfc_constructor **result)\n       goto cleanup;\n     }\n \n-  e = gfc_get_expr ();\n-  e->expr_type = EXPR_ARRAY;\n-  e->where = old_loc;\n+  e = gfc_get_array_expr (BT_UNKNOWN, 0, &old_loc);\n   e->value.constructor = head;\n \n-  p = gfc_get_constructor ();\n-  p->where = gfc_current_locus;\n+  p = gfc_constructor_append_expr (result, e, &gfc_current_locus);\n   p->iterator = gfc_get_iterator ();\n   *p->iterator = iter;\n \n-  p->expr = e;\n-  *result = p;\n-\n   return MATCH_YES;\n \n syntax:\n   gfc_error (\"Syntax error in array constructor at %C\");\n   m = MATCH_ERROR;\n \n cleanup:\n-  gfc_free_constructor (head);\n+  gfc_constructor_free (head);\n   gfc_free_iterator (&iter, 0);\n   gfc_current_locus = old_loc;\n   return m;\n@@ -1092,9 +939,8 @@ match_array_list (gfc_constructor **result)\n    single expression or a list of elements.  */\n \n static match\n-match_array_cons_element (gfc_constructor **result)\n+match_array_cons_element (gfc_constructor_base *result)\n {\n-  gfc_constructor *p;\n   gfc_expr *expr;\n   match m;\n \n@@ -1106,11 +952,7 @@ match_array_cons_element (gfc_constructor **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  p = gfc_get_constructor ();\n-  p->where = gfc_current_locus;\n-  p->expr = expr;\n-\n-  *result = p;\n+  gfc_constructor_append_expr (result, expr, &gfc_current_locus);\n   return MATCH_YES;\n }\n \n@@ -1120,7 +962,7 @@ match_array_cons_element (gfc_constructor **result)\n match\n gfc_match_array_constructor (gfc_expr **result)\n {\n-  gfc_constructor *head, *tail, *new_cons;\n+  gfc_constructor_base head, new_cons;\n   gfc_expr *expr;\n   gfc_typespec ts;\n   locus where;\n@@ -1144,7 +986,7 @@ gfc_match_array_constructor (gfc_expr **result)\n     end_delim = \" /)\";\n \n   where = gfc_current_locus;\n-  head = tail = NULL;\n+  head = new_cons = NULL;\n   seen_ts = false;\n \n   /* Try to match an optional \"type-spec ::\"  */\n@@ -1176,19 +1018,12 @@ gfc_match_array_constructor (gfc_expr **result)\n \n   for (;;)\n     {\n-      m = match_array_cons_element (&new_cons);\n+      m = match_array_cons_element (&head);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n-      if (head == NULL)\n-\thead = new_cons;\n-      else\n-\ttail->next = new_cons;\n-\n-      tail = new_cons;\n-\n       if (gfc_match_char (',') == MATCH_NO)\n \tbreak;\n     }\n@@ -1197,32 +1032,27 @@ gfc_match_array_constructor (gfc_expr **result)\n     goto syntax;\n \n done:\n-  expr = gfc_get_expr ();\n-\n-  expr->expr_type = EXPR_ARRAY;\n-\n-  expr->value.constructor = head;\n   /* Size must be calculated at resolution time.  */\n-\n   if (seen_ts)\n-    expr->ts = ts;\n+    {\n+      expr = gfc_get_array_expr (ts.type, ts.kind, &where);\n+      expr->ts = ts;\n+    }\n   else\n-    expr->ts.type = BT_UNKNOWN;\n-  \n+    expr = gfc_get_array_expr (BT_UNKNOWN, 0, &where);\n+\n+  expr->value.constructor = head;\n   if (expr->ts.u.cl)\n     expr->ts.u.cl->length_from_typespec = seen_ts;\n \n-  expr->where = where;\n-  expr->rank = 1;\n-\n   *result = expr;\n   return MATCH_YES;\n \n syntax:\n   gfc_error (\"Syntax error in array constructor at %C\");\n \n cleanup:\n-  gfc_free_constructor (head);\n+  gfc_constructor_free (head);\n   return MATCH_ERROR;\n }\n \n@@ -1278,11 +1108,12 @@ check_element_type (gfc_expr *expr, bool convert)\n /* Recursive work function for gfc_check_constructor_type().  */\n \n static gfc_try\n-check_constructor_type (gfc_constructor *c, bool convert)\n+check_constructor_type (gfc_constructor_base base, bool convert)\n {\n+  gfc_constructor *c;\n   gfc_expr *e;\n \n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       e = c->expr;\n \n@@ -1341,7 +1172,7 @@ cons_stack;\n \n static cons_stack *base;\n \n-static gfc_try check_constructor (gfc_constructor *, gfc_try (*) (gfc_expr *));\n+static gfc_try check_constructor (gfc_constructor_base, gfc_try (*) (gfc_expr *));\n \n /* Check an EXPR_VARIABLE expression in a constructor to make sure\n    that that variable is an iteration variables.  */\n@@ -1367,13 +1198,14 @@ gfc_check_iter_variable (gfc_expr *expr)\n    constructor, giving variables with the names of iterators a pass.  */\n \n static gfc_try\n-check_constructor (gfc_constructor *c, gfc_try (*check_function) (gfc_expr *))\n+check_constructor (gfc_constructor_base ctor, gfc_try (*check_function) (gfc_expr *))\n {\n   cons_stack element;\n   gfc_expr *e;\n   gfc_try t;\n+  gfc_constructor *c;\n \n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (ctor); c; c = gfc_constructor_next (c))\n     {\n       e = c->expr;\n \n@@ -1427,7 +1259,7 @@ iterator_stack *iter_stack;\n \n typedef struct\n {\n-  gfc_constructor *new_head, *new_tail;\n+  gfc_constructor_base base;\n   int extract_count, extract_n;\n   gfc_expr *extracted;\n   mpz_t *count;\n@@ -1442,7 +1274,7 @@ expand_info;\n \n static expand_info current_expand;\n \n-static gfc_try expand_constructor (gfc_constructor *);\n+static gfc_try expand_constructor (gfc_constructor_base);\n \n \n /* Work function that counts the number of elements present in a\n@@ -1501,21 +1333,10 @@ extract_element (gfc_expr *e)\n static gfc_try\n expand (gfc_expr *e)\n {\n-  if (current_expand.new_head == NULL)\n-    current_expand.new_head = current_expand.new_tail =\n-      gfc_get_constructor ();\n-  else\n-    {\n-      current_expand.new_tail->next = gfc_get_constructor ();\n-      current_expand.new_tail = current_expand.new_tail->next;\n-    }\n+  gfc_constructor *c = gfc_constructor_append_expr (&current_expand.base,\n+\t\t\t\t\t\t    e, &e->where);\n \n-  current_expand.new_tail->where = e->where;\n-  current_expand.new_tail->expr = e;\n-\n-  mpz_set (current_expand.new_tail->n.offset, *current_expand.offset);\n-  current_expand.new_tail->n.component = current_expand.component;\n-  mpz_set (current_expand.new_tail->repeat, *current_expand.repeat);\n+  c->n.component = current_expand.component;\n   return SUCCESS;\n }\n \n@@ -1535,7 +1356,7 @@ gfc_simplify_iterator_var (gfc_expr *e)\n   if (p == NULL)\n     return;\t\t/* Variable not found */\n \n-  gfc_replace_expr (e, gfc_int_expr (0));\n+  gfc_replace_expr (e, gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));\n \n   mpz_set (e->value.integer, p->value);\n \n@@ -1649,11 +1470,12 @@ expand_iterator (gfc_constructor *c)\n    passed expression.  */\n \n static gfc_try\n-expand_constructor (gfc_constructor *c)\n+expand_constructor (gfc_constructor_base base)\n {\n+  gfc_constructor *c;\n   gfc_expr *e;\n \n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next(c))\n     {\n       if (c->iterator != NULL)\n \t{\n@@ -1678,16 +1500,49 @@ expand_constructor (gfc_constructor *c)\n \t  gfc_free_expr (e);\n \t  return FAILURE;\n \t}\n-      current_expand.offset = &c->n.offset;\n-      current_expand.component = c->n.component;\n+      current_expand.offset = &c->offset;\n       current_expand.repeat = &c->repeat;\n+      current_expand.component = c->n.component;\n       if (current_expand.expand_work_function (e) == FAILURE)\n \treturn FAILURE;\n     }\n   return SUCCESS;\n }\n \n \n+/* Given an array expression and an element number (starting at zero),\n+   return a pointer to the array element.  NULL is returned if the\n+   size of the array has been exceeded.  The expression node returned\n+   remains a part of the array and should not be freed.  Access is not\n+   efficient at all, but this is another place where things do not\n+   have to be particularly fast.  */\n+\n+static gfc_expr *\n+gfc_get_array_element (gfc_expr *array, int element)\n+{\n+  expand_info expand_save;\n+  gfc_expr *e;\n+  gfc_try rc;\n+\n+  expand_save = current_expand;\n+  current_expand.extract_n = element;\n+  current_expand.expand_work_function = extract_element;\n+  current_expand.extracted = NULL;\n+  current_expand.extract_count = 0;\n+\n+  iter_stack = NULL;\n+\n+  rc = expand_constructor (array->value.constructor);\n+  e = current_expand.extracted;\n+  current_expand = expand_save;\n+\n+  if (rc == FAILURE)\n+    return NULL;\n+\n+  return e;\n+}\n+\n+\n /* Top level subroutine for expanding constructors.  We only expand\n    constructor if they are small enough.  */\n \n@@ -1698,29 +1553,32 @@ gfc_expand_constructor (gfc_expr *e)\n   gfc_expr *f;\n   gfc_try rc;\n \n+  /* If we can successfully get an array element at the max array size then\n+     the array is too big to expand, so we just return.  */\n   f = gfc_get_array_element (e, gfc_option.flag_max_array_constructor);\n   if (f != NULL)\n     {\n       gfc_free_expr (f);\n       return SUCCESS;\n     }\n \n+  /* We now know the array is not too big so go ahead and try to expand it.  */\n   expand_save = current_expand;\n-  current_expand.new_head = current_expand.new_tail = NULL;\n+  current_expand.base = NULL;\n \n   iter_stack = NULL;\n \n   current_expand.expand_work_function = expand;\n \n   if (expand_constructor (e->value.constructor) == FAILURE)\n     {\n-      gfc_free_constructor (current_expand.new_head);\n+      gfc_constructor_free (current_expand.base);\n       rc = FAILURE;\n       goto done;\n     }\n \n-  gfc_free_constructor (e->value.constructor);\n-  e->value.constructor = current_expand.new_head;\n+  gfc_constructor_free (e->value.constructor);\n+  e->value.constructor = current_expand.base;\n \n   rc = SUCCESS;\n \n@@ -1758,37 +1616,14 @@ gfc_constant_ac (gfc_expr *e)\n {\n   expand_info expand_save;\n   gfc_try rc;\n-  gfc_constructor * con;\n-  \n-  rc = SUCCESS;\n \n-  if (e->value.constructor\n-      && e->value.constructor->expr->expr_type == EXPR_ARRAY)\n-    {\n-      /* Expand the constructor.  */\n-      iter_stack = NULL;\n-      expand_save = current_expand;\n-      current_expand.expand_work_function = is_constant_element;\n+  iter_stack = NULL;\n+  expand_save = current_expand;\n+  current_expand.expand_work_function = is_constant_element;\n \n-      rc = expand_constructor (e->value.constructor);\n-\n-      current_expand = expand_save;\n-    }\n-  else\n-    {\n-      /* No need to expand this further.  */\n-      for (con = e->value.constructor; con; con = con->next)\n-\t{\n-\t  if (con->expr->expr_type == EXPR_CONSTANT)\n-\t    continue;\n-\t  else\n-\t    {\n-\t      if (!gfc_is_constant_expr (con->expr))\n-\t\trc = FAILURE;\n-\t    }\n-\t}\n-    }\n+  rc = expand_constructor (e->value.constructor);\n \n+  current_expand = expand_save;\n   if (rc == FAILURE)\n     return 0;\n \n@@ -1802,11 +1637,12 @@ gfc_constant_ac (gfc_expr *e)\n int\n gfc_expanded_ac (gfc_expr *e)\n {\n-  gfc_constructor *p;\n+  gfc_constructor *c;\n \n   if (e->expr_type == EXPR_ARRAY)\n-    for (p = e->value.constructor; p; p = p->next)\n-      if (p->iterator != NULL || !gfc_expanded_ac (p->expr))\n+    for (c = gfc_constructor_first (e->value.constructor);\n+\t c; c = gfc_constructor_next (c))\n+      if (c->iterator != NULL || !gfc_expanded_ac (c->expr))\n \treturn 0;\n \n   return 1;\n@@ -1819,19 +1655,20 @@ gfc_expanded_ac (gfc_expr *e)\n    be of the same type.  */\n \n static gfc_try\n-resolve_array_list (gfc_constructor *p)\n+resolve_array_list (gfc_constructor_base base)\n {\n   gfc_try t;\n+  gfc_constructor *c;\n \n   t = SUCCESS;\n \n-  for (; p; p = p->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n-      if (p->iterator != NULL\n-\t  && gfc_resolve_iterator (p->iterator, false) == FAILURE)\n+      if (c->iterator != NULL\n+\t  && gfc_resolve_iterator (c->iterator, false) == FAILURE)\n \tt = FAILURE;\n \n-      if (gfc_resolve_expr (p->expr) == FAILURE)\n+      if (gfc_resolve_expr (c->expr) == FAILURE)\n \tt = FAILURE;\n     }\n \n@@ -1854,7 +1691,8 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \n   if (expr->ts.u.cl == NULL)\n     {\n-      for (p = expr->value.constructor; p; p = p->next)\n+      for (p = gfc_constructor_first (expr->value.constructor);\n+\t   p; p = gfc_constructor_next (p))\n \tif (p->expr->ts.u.cl != NULL)\n \t  {\n \t    /* Ensure that if there is a char_len around that it is\n@@ -1875,7 +1713,8 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       /* Check that all constant string elements have the same length until\n \t we reach the end or find a variable-length one.  */\n \n-      for (p = expr->value.constructor; p; p = p->next)\n+      for (p = gfc_constructor_first (expr->value.constructor);\n+\t   p; p = gfc_constructor_next (p))\n \t{\n \t  int current_length = -1;\n \t  gfc_ref *ref;\n@@ -1922,7 +1761,8 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       gcc_assert (found_length != -1);\n \n       /* Update the character length of the array constructor.  */\n-      expr->ts.u.cl->length = gfc_int_expr (found_length);\n+      expr->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\tNULL, found_length);\n     }\n   else \n     {\n@@ -1940,7 +1780,8 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t (without typespec) all elements are verified to have the same length\n \t anyway.  */\n       if (found_length != -1)\n-\tfor (p = expr->value.constructor; p; p = p->next)\n+\tfor (p = gfc_constructor_first (expr->value.constructor);\n+\t     p; p = gfc_constructor_next (p))\n \t  if (p->expr->expr_type == EXPR_CONSTANT)\n \t    {\n \t      gfc_expr *cl = NULL;\n@@ -1990,8 +1831,8 @@ gfc_resolve_array_constructor (gfc_expr *expr)\n \n /* Copy an iterator structure.  */\n \n-static gfc_iterator *\n-copy_iterator (gfc_iterator *src)\n+gfc_iterator *\n+gfc_copy_iterator (gfc_iterator *src)\n {\n   gfc_iterator *dest;\n \n@@ -2009,73 +1850,6 @@ copy_iterator (gfc_iterator *src)\n }\n \n \n-/* Copy a constructor structure.  */\n-\n-gfc_constructor *\n-gfc_copy_constructor (gfc_constructor *src)\n-{\n-  gfc_constructor *dest;\n-  gfc_constructor *tail;\n-\n-  if (src == NULL)\n-    return NULL;\n-\n-  dest = tail = NULL;\n-  while (src)\n-    {\n-      if (dest == NULL)\n-\tdest = tail = gfc_get_constructor ();\n-      else\n-\t{\n-\t  tail->next = gfc_get_constructor ();\n-\t  tail = tail->next;\n-\t}\n-      tail->where = src->where;\n-      tail->expr = gfc_copy_expr (src->expr);\n-      tail->iterator = copy_iterator (src->iterator);\n-      mpz_set (tail->n.offset, src->n.offset);\n-      tail->n.component = src->n.component;\n-      mpz_set (tail->repeat, src->repeat);\n-      src = src->next;\n-    }\n-\n-  return dest;\n-}\n-\n-\n-/* Given an array expression and an element number (starting at zero),\n-   return a pointer to the array element.  NULL is returned if the\n-   size of the array has been exceeded.  The expression node returned\n-   remains a part of the array and should not be freed.  Access is not\n-   efficient at all, but this is another place where things do not\n-   have to be particularly fast.  */\n-\n-gfc_expr *\n-gfc_get_array_element (gfc_expr *array, int element)\n-{\n-  expand_info expand_save;\n-  gfc_expr *e;\n-  gfc_try rc;\n-\n-  expand_save = current_expand;\n-  current_expand.extract_n = element;\n-  current_expand.expand_work_function = extract_element;\n-  current_expand.extracted = NULL;\n-  current_expand.extract_count = 0;\n-\n-  iter_stack = NULL;\n-\n-  rc = expand_constructor (array->value.constructor);\n-  e = current_expand.extracted;\n-  current_expand = expand_save;\n-\n-  if (rc == FAILURE)\n-    return NULL;\n-\n-  return e;\n-}\n-\n-\n /********* Subroutines for determining the size of an array *********/\n \n /* These are needed just to accommodate RESHAPE().  There are no"}, {"sha": "bd2791a100bec46b0b49d1ff43bef31f4a032580", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n+#include \"constructor.h\"\n \n \n /* Make sure an expression is a scalar.  */\n@@ -2266,7 +2267,8 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n \n \t  if (mask->expr_type == EXPR_ARRAY)\n \t    {\n-\t      gfc_constructor *mask_ctor = mask->value.constructor;\n+\t      gfc_constructor *mask_ctor;\n+\t      mask_ctor = gfc_constructor_first (mask->value.constructor);\n \t      while (mask_ctor)\n \t\t{\n \t\t  if (mask_ctor->expr->expr_type != EXPR_CONSTANT)\n@@ -2278,7 +2280,7 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n \t\t  if (mask_ctor->expr->value.logical)\n \t\t    mask_true_values++;\n \n-\t\t  mask_ctor = mask_ctor->next;\n+\t\t  mask_ctor = gfc_constructor_next (mask_ctor);\n \t\t}\n \t    }\n \t  else if (mask->expr_type == EXPR_CONSTANT && mask->value.logical)\n@@ -2508,12 +2510,9 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n       int i, extent;\n       for (i = 0; i < shape_size; ++i)\n \t{\n-\t  e = gfc_get_array_element (shape, i);\n+\t  e = gfc_constructor_lookup_expr (shape->value.constructor, i);\n \t  if (e->expr_type != EXPR_CONSTANT)\n-\t    {\n-\t      gfc_free_expr (e);\n-\t      continue;\n-\t    }\n+\t    continue;\n \n \t  gfc_extract_int (e, &extent);\n \t  if (extent < 0)\n@@ -2523,8 +2522,6 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t\t gfc_current_intrinsic, &e->where, extent);\n \t      return FAILURE;\n \t    }\n-\n-\t  gfc_free_expr (e);\n \t}\n     }\n \n@@ -2569,12 +2566,9 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n \t  for (i = 1; i <= order_size; ++i)\n \t    {\n-\t      e = gfc_get_array_element (order, i-1);\n+\t      e = gfc_constructor_lookup_expr (order->value.constructor, i-1);\n \t      if (e->expr_type != EXPR_CONSTANT)\n-\t\t{\n-\t\t  gfc_free_expr (e);\n-\t\t  continue;\n-\t\t}\n+\t\tcontinue;\n \n \t      gfc_extract_int (e, &dim);\n \n@@ -2597,7 +2591,6 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t}\n \n \t      perm[dim-1] = 1;\n-\t      gfc_free_expr (e);\n \t    }\n \t}\n     }\n@@ -2613,9 +2606,10 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t  gfc_constructor *c;\n \t  bool test;\n \n-\t  c = shape->value.constructor;\n+\t  \n \t  mpz_init_set_ui (size, 1);\n-\t  for (; c; c = c->next)\n+\t  for (c = gfc_constructor_first (shape->value.constructor);\n+\t       c; c = gfc_constructor_next (c))\n \t    mpz_mul (size, size, c->expr->value.integer);\n \n \t  test = mpz_cmp (nelems, size) < 0 && mpz_cmp_ui (size, 0) > 0;\n@@ -3224,7 +3218,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n       && gfc_array_size (vector, &vector_size) == SUCCESS)\n     {\n       int mask_true_count = 0;\n-      gfc_constructor *mask_ctor = mask->value.constructor;\n+      gfc_constructor *mask_ctor;\n+      mask_ctor = gfc_constructor_first (mask->value.constructor);\n       while (mask_ctor)\n \t{\n \t  if (mask_ctor->expr->expr_type != EXPR_CONSTANT)\n@@ -3236,7 +3231,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \t  if (mask_ctor->expr->value.logical)\n \t    mask_true_count++;\n \n-\t  mask_ctor = mask_ctor->next;\n+\t  mask_ctor = gfc_constructor_next (mask_ctor);\n \t}\n \n       if (mpz_get_si (vector_size) < mask_true_count)"}, {"sha": "d2789b127f7ae8d7a9c3614c6e7517ea5fec545e", "filename": "gcc/fortran/constructor.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fconstructor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fconstructor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -0,0 +1,253 @@\n+/* Array and structure constructors\n+   Copyright (C) 2009, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gfortran.h\"\n+#include \"constructor.h\"\n+\n+\n+static void\n+node_free (splay_tree_value value)\n+{\n+  gfc_constructor *c = (gfc_constructor*)value;\n+\n+  if (c->expr)\n+    gfc_free_expr (c->expr);\n+\n+  if (c->iterator)\n+    gfc_free_iterator (c->iterator, 1);\n+\n+  mpz_clear (c->offset);\n+  mpz_clear (c->repeat);\n+\n+  gfc_free (c);\n+}\n+\n+\n+static gfc_constructor *\n+node_copy (splay_tree_node node, void *base)\n+{\n+  gfc_constructor *c, *src = (gfc_constructor*)node->value;\n+\n+  c = XCNEW (gfc_constructor);\n+  c->base = (gfc_constructor_base)base;\n+  c->expr = gfc_copy_expr (src->expr);\n+  c->iterator = gfc_copy_iterator (src->iterator);\n+  c->where = src->where;\n+  c->n.component = src->n.component;\n+\n+  mpz_init_set (c->offset, src->offset);\n+  mpz_init_set (c->repeat, src->repeat);\n+\n+  return c;\n+}\n+\n+\n+static int\n+node_copy_and_insert (splay_tree_node node, void *base)\n+{\n+  int n = mpz_get_si (((gfc_constructor*)node->value)->offset);\n+  gfc_constructor_insert ((gfc_constructor_base*)base,\n+\t\t\t  node_copy (node, base), n);\n+  return 0;\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_get (void)\n+{\n+  gfc_constructor *c = XCNEW (gfc_constructor);\n+  c->base = NULL;\n+  c->expr = NULL;\n+  c->iterator = NULL;\n+\n+  mpz_init_set_si (c->offset, 0);\n+  mpz_init_set_si (c->repeat, 0);\n+\n+  return c;\n+}\n+\n+gfc_constructor_base gfc_constructor_get_base (void)\n+{\n+  return splay_tree_new (splay_tree_compare_ints, NULL, node_free);\n+}\n+\n+\n+gfc_constructor_base\n+gfc_constructor_copy (gfc_constructor_base base)\n+{\n+  gfc_constructor_base new_base;\n+\n+  if (!base)\n+    return NULL;\n+\n+  new_base = gfc_constructor_get_base ();\n+  splay_tree_foreach (base, node_copy_and_insert, &new_base);\n+\n+  return new_base;\n+}\n+\n+\n+void\n+gfc_constructor_free (gfc_constructor_base base)\n+{\n+  if (base)\n+    splay_tree_delete (base);\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_append (gfc_constructor_base *base, gfc_constructor *c)\n+{\n+  int offset = 0;\n+  if (*base)\n+    offset = (int)(splay_tree_max (*base)->key) + 1;\n+\n+  return gfc_constructor_insert (base, c, offset);\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_append_expr (gfc_constructor_base *base,\n+\t\t\t     gfc_expr *e, locus *where)\n+{\n+  gfc_constructor *c = gfc_constructor_get ();\n+  c->expr = e;\n+  if (where)\n+    c->where = *where;\n+\n+  return gfc_constructor_append (base, c);\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_insert (gfc_constructor_base *base, gfc_constructor *c, int n)\n+{\n+  splay_tree_node node;\n+\n+  if (*base == NULL)\n+    *base = splay_tree_new (splay_tree_compare_ints, NULL, node_free);\n+\n+  c->base = *base;\n+  mpz_set_si (c->offset, n);\n+\n+  node = splay_tree_insert (*base, (splay_tree_key) n, (splay_tree_value) c);\n+  gcc_assert (node);\n+\n+  return (gfc_constructor*)node->value;\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_insert_expr (gfc_constructor_base *base,\n+\t\t\t     gfc_expr *e, locus *where, int n)\n+{\n+  gfc_constructor *c = gfc_constructor_get ();\n+  c->expr = e;\n+  if (where)\n+    c->where = *where;\n+\n+  return gfc_constructor_insert (base, c, n);\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_lookup (gfc_constructor_base base, int offset)\n+{\n+  gfc_constructor *c;\n+  splay_tree_node node;\n+\n+  if (!base)\n+    return NULL;\n+\n+  node = splay_tree_lookup (base, (splay_tree_key) offset);\n+  if (node)\n+    return (gfc_constructor*) node->value;\n+\n+  /* Check if the previous node as a repeat count big enough to\n+     cover the offset looked for.  */\n+  node = splay_tree_predecessor (base, offset);\n+  if (!node)\n+    return NULL;\n+\n+  c = (gfc_constructor*) node->value;\n+  if (mpz_cmp_si (c->repeat, 1) > 0)\n+    {\n+      if (mpz_get_si (c->offset) + mpz_get_si (c->repeat) <= offset)\n+\tc = NULL;\n+    }\n+  else\n+    c = NULL;\n+\n+  return c;\n+}\n+\n+\n+gfc_expr *\n+gfc_constructor_lookup_expr (gfc_constructor_base base, int offset)\n+{\n+  gfc_constructor *c = gfc_constructor_lookup (base, offset);\n+  return c ? c->expr : NULL;\n+}\n+\n+\n+int\n+gfc_constructor_expr_foreach (gfc_constructor *ctor ATTRIBUTE_UNUSED,\n+\t\t\t      int(*f)(gfc_expr *) ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (0);\n+  return 0;\n+}\n+\n+void\n+gfc_constructor_swap (gfc_constructor *ctor ATTRIBUTE_UNUSED,\n+                      int n ATTRIBUTE_UNUSED, int m ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (0);\n+}\n+\n+\n+\n+gfc_constructor *\n+gfc_constructor_first (gfc_constructor_base base)\n+{\n+  if (base)\n+    {\n+      splay_tree_node node = splay_tree_min (base);\n+      return node ? (gfc_constructor*) node->value : NULL;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+\n+gfc_constructor *\n+gfc_constructor_next (gfc_constructor *ctor)\n+{\n+  if (ctor)\n+    {\n+      splay_tree_node node = splay_tree_successor (ctor->base,\n+\t\t\t\t\t\t   mpz_get_si (ctor->offset));\n+      return node ? (gfc_constructor*) node->value : NULL;\n+    }\n+  else\n+    return NULL;\n+}"}, {"sha": "1f7d78388f8bea011d05466f7c80bed470e8e5d3", "filename": "gcc/fortran/constructor.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fconstructor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fconstructor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.h?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -0,0 +1,90 @@\n+/* Array and structure constructors\n+   Copyright (C) 2009, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GFC_CONSTRUCTOR_H\n+#define GFC_CONSTRUCTOR_H\n+\n+#include \"gfortran.h\"\n+#include \"splay-tree.h\"\n+\n+\n+/* Get a new constructor structure.  */\n+gfc_constructor *gfc_constructor_get (void);\n+\n+gfc_constructor_base gfc_constructor_get_base (void);\n+\n+/* Copy a constructor structure.  */\n+gfc_constructor_base gfc_constructor_copy (gfc_constructor_base base);\n+\n+\n+/* Free a gfc_constructor structure.  */\n+void gfc_constructor_free (gfc_constructor_base base);\n+\n+\n+/* Given an constructor structure, append the expression node onto\n+   the constructor. Returns the constructor node appended.  */\n+gfc_constructor *gfc_constructor_append (gfc_constructor_base *base,\n+\t\t\t\t\t gfc_constructor *c);\n+\n+gfc_constructor *gfc_constructor_append_expr (gfc_constructor_base *base,\n+\t\t\t\t\t      gfc_expr *e, locus *where);\n+\n+\n+/* Given an constructor structure, place the expression node at position.\n+   Returns the constructor node inserted.  */\n+gfc_constructor *gfc_constructor_insert (gfc_constructor_base *base,\n+\t\t\t\t\t gfc_constructor *c, int n);\n+\n+gfc_constructor *gfc_constructor_insert_expr (gfc_constructor_base *base,\n+\t\t\t\t\t      gfc_expr *e, locus *where,\n+\t\t\t\t\t      int n);\n+\n+/* Given an array constructor expression and an element number (starting\n+   at zero), return a pointer to the array element.  NULL is returned if\n+   the size of the array has been exceeded. The expression node returned\n+   remains a part of the array and should not be freed.  */\n+\n+gfc_constructor *gfc_constructor_lookup (gfc_constructor_base base, int n);\n+\n+/* Convenience function. Same as ...\n+     gfc_constructor *c = gfc_constructor_lookup (base, n);\n+     gfc_expr *e = c ? c->expr : NULL;\n+*/\n+gfc_expr *gfc_constructor_lookup_expr (gfc_constructor_base base, int n);\n+\n+\n+int gfc_constructor_expr_foreach (gfc_constructor *ctor, int(*)(gfc_expr *));\n+\n+\n+void gfc_constructor_swap (gfc_constructor *ctor, int n, int m);\n+\n+\n+\n+/* Get the first constructor node in the constructure structure.\n+   Returns NULL if there is no such expression.  */\n+gfc_constructor *gfc_constructor_first (gfc_constructor_base base);\n+\n+/* Get the next constructor node in the constructure structure.\n+   Returns NULL if there is no next expression.  */\n+gfc_constructor *gfc_constructor_next (gfc_constructor *ctor);\n+\n+gfc_constructor *gfc_constructor_advance (gfc_constructor *ctor, int n);\n+\n+#endif /* GFC_CONSTRUCTOR_H */"}, {"sha": "fca251cb660181740527f27aa3758bcf86d8661c", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 50, "deletions": 202, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,5 @@\n /* Supporting functions for resolving DATA statement.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Lifang Zeng <zlf605@hotmail.com>\n \n@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"gfortran.h\"\n #include \"data.h\"\n+#include \"constructor.h\"\n \n static void formalize_init_expr (gfc_expr *);\n \n@@ -76,67 +77,18 @@ get_array_index (gfc_array_ref *ar, mpz_t *offset)\n   mpz_clear (tmp);\n }\n \n-\n-/* Find if there is a constructor which offset is equal to OFFSET.  */\n+/* Find if there is a constructor which component is equal to COM.\n+   TODO: remove this, use symbol.c(gfc_find_component) instead.  */\n \n static gfc_constructor *\n-find_con_by_offset (splay_tree spt, mpz_t offset)\n+find_con_by_component (gfc_component *com, gfc_constructor_base base)\n {\n-  mpz_t tmp;\n-  gfc_constructor *ret = NULL;\n-  gfc_constructor *con;\n-  splay_tree_node sptn;\n-\n-  /* The complexity is due to needing quick access to the linked list of\n-     constructors.  Both a linked list and a splay tree are used, and both\n-     are kept up to date if they are array elements (which is the only time\n-     that a specific constructor has to be found).  */  \n-\n-  gcc_assert (spt != NULL);\n-  mpz_init (tmp);\n-\n-  sptn = splay_tree_lookup (spt, (splay_tree_key) mpz_get_si (offset));\n-\n-  if (sptn)\n-    ret = (gfc_constructor*) sptn->value;  \n-  else\n-    {\n-       /* Need to check and see if we match a range, so we will pull\n-\t  the next lowest index and see if the range matches.  */\n-       sptn = splay_tree_predecessor (spt,\n-\t\t\t\t      (splay_tree_key) mpz_get_si (offset));\n-       if (sptn)\n-\t {\n-\t    con = (gfc_constructor*) sptn->value;\n-\t    if (mpz_cmp_ui (con->repeat, 1) > 0)\n-\t      {\n-\t\t mpz_init (tmp);\n-\t\t mpz_add (tmp, con->n.offset, con->repeat);\n-\t\t if (mpz_cmp (offset, tmp) < 0)\n-\t\t   ret = con;\n-\t\t mpz_clear (tmp);\n-\t      }\n-\t    else \n-\t      ret = NULL; /* The range did not match.  */\n-\t }\n-      else\n-\tret = NULL; /* No pred, so no match.  */\n-    }\n-\n-  return ret;\n-}\n-\n+  gfc_constructor *c;\n \n-/* Find if there is a constructor which component is equal to COM.  */\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n+    if (com == c->n.component)\n+      return c;\n \n-static gfc_constructor *\n-find_con_by_component (gfc_component *com, gfc_constructor *con)\n-{\n-  for (; con; con = con->next)\n-    {\n-      if (com == con->n.component)\n-\treturn con;\n-    }\n   return NULL;\n }\n \n@@ -158,20 +110,11 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n   if (init == NULL)\n     {\n       /* Create a new initializer.  */\n-      init = gfc_get_expr ();\n-      init->expr_type = EXPR_CONSTANT;\n+      init = gfc_get_character_expr (ts->kind, NULL, NULL, len);\n       init->ts = *ts;\n-      \n-      dest = gfc_get_wide_string (len + 1);\n-      dest[len] = '\\0';\n-      init->value.character.length = len;\n-      init->value.character.string = dest;\n-      /* Blank the string if we're only setting a substring.  */\n-      if (ref != NULL)\n-\tgfc_wide_memset (dest, ' ', len);\n     }\n-  else\n-    dest = init->value.character.string;\n+\n+  dest = init->value.character.string;\n \n   if (ref)\n     {\n@@ -254,12 +197,9 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n   gfc_expr *expr;\n   gfc_constructor *con;\n   gfc_constructor *last_con;\n-  gfc_constructor *pred;\n   gfc_symbol *symbol;\n   gfc_typespec *last_ts;\n   mpz_t offset;\n-  splay_tree spt;\n-  splay_tree_node sptn;\n \n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n@@ -343,40 +283,13 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t\t}\n \t    }\n \n-\t  /* Splay tree containing offset and gfc_constructor.  */\n-\t  spt = expr->con_by_offset;\n-\n-\t  if (spt == NULL)\n+\t  con = gfc_constructor_lookup (expr->value.constructor,\n+\t\t\t\t\tmpz_get_si (offset));\n+\t  if (!con)\n \t    {\n-\t       spt = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n-\t       expr->con_by_offset = spt; \n-\t       con = NULL;\n-\t    }\n-\t else\n-\t  con = find_con_by_offset (spt, offset);\n-\n-\t  if (con == NULL)\n-\t    {\n-\t      splay_tree_key j;\n-\n-\t      /* Create a new constructor.  */\n-\t      con = gfc_get_constructor ();\n-\t      mpz_set (con->n.offset, offset);\n-\t      j = (splay_tree_key) mpz_get_si (offset);\n-\t      sptn = splay_tree_insert (spt, j, (splay_tree_value) con);\n-\t      /* Fix up the linked list.  */\n-\t      sptn = splay_tree_predecessor (spt, j);\n-\t      if (sptn == NULL)\n-\t\t{  /* Insert at the head.  */\n-\t\t   con->next = expr->value.constructor;\n-\t\t   expr->value.constructor = con;\n-\t\t}\n-\t      else\n-\t\t{  /* Insert in the chain.  */\n-\t\t   pred = (gfc_constructor*) sptn->value;\n-\t\t   con->next = pred->next;\n-\t\t   pred->next = con;\n-\t\t}\n+\t      con = gfc_constructor_insert_expr (&expr->value.constructor,\n+\t\t\t\t\t\t NULL, NULL,\n+\t\t\t\t\t\t mpz_get_si (offset));\n \t    }\n \t  break;\n \n@@ -393,16 +306,15 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t  last_ts = &ref->u.c.component->ts;\n \n \t  /* Find the same element in the existing constructor.  */\n-\t  con = expr->value.constructor;\n-\t  con = find_con_by_component (ref->u.c.component, con);\n+\t  con = find_con_by_component (ref->u.c.component,\n+\t\t\t\t       expr->value.constructor);\n \n \t  if (con == NULL)\n \t    {\n \t      /* Create a new constructor.  */\n-\t      con = gfc_get_constructor ();\n+\t      con = gfc_constructor_append_expr (&expr->value.constructor,\n+\t\t\t\t\t\t NULL, NULL);\n \t      con->n.component = ref->u.c.component;\n-\t      con->next = expr->value.constructor;\n-\t      expr->value.constructor = con;\n \t    }\n \t  break;\n \n@@ -469,12 +381,9 @@ gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n   gfc_ref *ref;\n   gfc_expr *init, *expr;\n   gfc_constructor *con, *last_con;\n-  gfc_constructor *pred;\n   gfc_symbol *symbol;\n   gfc_typespec *last_ts;\n   mpz_t offset;\n-  splay_tree spt;\n-  splay_tree_node sptn;\n \n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n@@ -527,44 +436,15 @@ gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n \t      gcc_assert (ref->next == NULL);\n \t    }\n \n-\t  /* Find the same element in the existing constructor.  */\n-\n-\t  /* Splay tree containing offset and gfc_constructor.  */\n-\t  spt = expr->con_by_offset;\n-\n-\t  if (spt == NULL)\n-\t    {\n-\t       spt = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n-\t       expr->con_by_offset = spt;\n-\t       con = NULL;\n-\t    }\n-\t  else \n-\t    con = find_con_by_offset (spt, offset);\n-\n+\t  con = gfc_constructor_lookup (expr->value.constructor,\n+\t\t\t\t\tmpz_get_si (offset));\n \t  if (con == NULL)\n \t    {\n-\t      splay_tree_key j;\n-\t      /* Create a new constructor.  */\n-\t      con = gfc_get_constructor ();\n-\t      mpz_set (con->n.offset, offset);\n-\t      j = (splay_tree_key) mpz_get_si (offset);\n-\t  \n+\t      con = gfc_constructor_insert_expr (&expr->value.constructor,\n+\t\t\t\t\t\t NULL, NULL,\n+\t\t\t\t\t\t mpz_get_si (offset));\n \t      if (ref->next == NULL)\n \t\tmpz_set (con->repeat, repeat);\n-\t      sptn = splay_tree_insert (spt, j, (splay_tree_value) con);\n-\t      /* Fix up the linked list.  */\n-\t      sptn = splay_tree_predecessor (spt, j);\n-\t      if (sptn == NULL)\n-\t\t{  /* Insert at the head.  */\n-\t\t   con->next = expr->value.constructor;\n-\t\t   expr->value.constructor = con;\n-\t\t}\n-\t      else\n-\t\t{  /* Insert in the chain.  */\n-\t\t   pred = (gfc_constructor*) sptn->value;\n-\t\t   con->next = pred->next;\n-\t\t   pred->next = con;\n-\t\t}\n \t    }\n \t  else\n \t    gcc_assert (ref->next != NULL);\n@@ -582,17 +462,16 @@ gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n \t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n \t  last_ts = &ref->u.c.component->ts;\n \n-\t  /* Find the same element in the existing constructor.  */\n-\t  con = expr->value.constructor;\n-\t  con = find_con_by_component (ref->u.c.component, con);\n+  \t  /* Find the same element in the existing constructor.  */\n+\t  con = find_con_by_component (ref->u.c.component,\n+\t\t\t\t       expr->value.constructor);\n \n \t  if (con == NULL)\n \t    {\n \t      /* Create a new constructor.  */\n-\t      con = gfc_get_constructor ();\n+\t      con = gfc_constructor_append_expr (&expr->value.constructor,\n+\t\t\t\t\t\t NULL, NULL);\n \t      con->n.component = ref->u.c.component;\n-\t      con->next = expr->value.constructor;\n-\t      expr->value.constructor = con;\n \t    }\n \n \t  /* Since we're only intending to initialize arrays here,\n@@ -709,59 +588,30 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n static void\n formalize_structure_cons (gfc_expr *expr)\n {\n-  gfc_constructor *head;\n-  gfc_constructor *tail;\n+  gfc_constructor_base base = NULL;\n   gfc_constructor *cur;\n-  gfc_constructor *last;\n-  gfc_constructor *c;\n   gfc_component *order;\n \n-  c = expr->value.constructor;\n-\n   /* Constructor is already formalized.  */\n-  if (!c || c->n.component == NULL)\n+  cur = gfc_constructor_first (expr->value.constructor);\n+  if (!cur || cur->n.component == NULL)\n     return;\n \n-  head = tail = NULL;\n   for (order = expr->ts.u.derived->components; order; order = order->next)\n     {\n-      /* Find the next component.  */\n-      last = NULL;\n-      cur = c;\n-      while (cur != NULL && cur->n.component != order)\n-\t{\n-\t  last = cur;\n-\t  cur = cur->next;\n-\t}\n-\n-      if (cur == NULL)\n-\t{\n-\t  /* Create a new one.  */\n-\t  cur = gfc_get_constructor ();\n-\t}\n+      cur = find_con_by_component (order, expr->value.constructor);\n+      if (cur)\n+\tgfc_constructor_append_expr (&base, cur->expr, &cur->expr->where);\n       else\n-\t{\n-\t  /* Remove it from the chain.  */\n-\t  if (last == NULL)\n-\t    c = cur->next;\n-\t  else\n-\t    last->next = cur->next;\n-\t  cur->next = NULL;\n+\tgfc_constructor_append_expr (&base, NULL, NULL);\n+    }\n \n-\t  formalize_init_expr (cur->expr);\n-\t}\n+  /* For all what it's worth, one would expect\n+       gfc_constructor_free (expr->value.constructor);\n+     here. However, if the constructor is actually free'd,\n+     hell breaks loose in the testsuite?!  */\n \n-      /* Add it to the new constructor.  */\n-      if (head == NULL)\n-\thead = tail = cur;\n-      else\n-\t{\n-\t  tail->next = cur;\n-\t  tail = tail->next;\n-\t}\n-    }\n-  gcc_assert (c == NULL);\n-  expr->value.constructor = head;\n+  expr->value.constructor = base;\n }\n \n \n@@ -781,13 +631,11 @@ formalize_init_expr (gfc_expr *expr)\n   switch (type)\n     {\n     case EXPR_ARRAY:\n-      c = expr->value.constructor;\n-      while (c)\n-\t{\n-\t  formalize_init_expr (c->expr);\n-\t  c = c->next;\n-\t}\n-      break;\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n+\tformalize_init_expr (c->expr);\n+\n+    break;\n \n     case EXPR_STRUCTURE:\n       formalize_structure_cons (expr);"}, {"sha": "88513983261143d6236db8e0b64a66b68c9b7b57", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"parse.h\"\n #include \"flags.h\"\n-\n+#include \"constructor.h\"\n \n /* Macros to access allocate memory for gfc_data_variable,\n    gfc_data_value and gfc_data.  */\n@@ -714,7 +714,7 @@ match_char_length (gfc_expr **expr)\n       if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: \"\n \t\t\t  \"Old-style character length at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n-      *expr = gfc_int_expr (length);\n+      *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, length);\n       return m;\n     }\n \n@@ -1339,13 +1339,18 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t  if (init->expr_type == EXPR_CONSTANT)\n \t\t    {\n \t\t      clen = init->value.character.length;\n-\t\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n+\t\t      sym->ts.u.cl->length\n+\t\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t    NULL, clen);\n \t\t    }\n \t\t  else if (init->expr_type == EXPR_ARRAY)\n \t\t    {\n-\t\t      gfc_expr *p = init->value.constructor->expr;\n-\t\t      clen = p->value.character.length;\n-\t\t      sym->ts.u.cl->length = gfc_int_expr (clen);\n+\t\t      gfc_constructor *c;\n+\t\t      c = gfc_constructor_first (init->value.constructor);\n+\t\t      clen = c->expr->value.character.length;\n+\t\t      sym->ts.u.cl->length\n+\t\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t    NULL, clen);\n \t\t    }\n \t\t  else if (init->ts.u.cl && init->ts.u.cl->length)\n \t\t    sym->ts.u.cl->length =\n@@ -1356,19 +1361,21 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t  else if (sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \t    {\n \t      int len = mpz_get_si (sym->ts.u.cl->length->value.integer);\n-\t      gfc_constructor * p;\n \n \t      if (init->expr_type == EXPR_CONSTANT)\n \t\tgfc_set_constant_character_len (len, init, -1);\n \t      else if (init->expr_type == EXPR_ARRAY)\n \t\t{\n+\t\t  gfc_constructor *c;\n+\n \t\t  /* Build a new charlen to prevent simplification from\n \t\t     deleting the length before it is resolved.  */\n \t\t  init->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n \t\t  init->ts.u.cl->length = gfc_copy_expr (sym->ts.u.cl->length);\n \n-\t\t  for (p = init->value.constructor; p; p = p->next)\n-\t\t    gfc_set_constant_character_len (len, p->expr, -1);\n+\t\t  for (c = gfc_constructor_first (init->value.constructor);\n+\t\t       c; c = gfc_constructor_next (c))\n+\t\t    gfc_set_constant_character_len (len, c->expr, -1);\n \t\t}\n \t    }\n \t}\n@@ -1392,38 +1399,27 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t  if (init->ts.is_iso_c)\n \t    sym->ts.f90_type = init->ts.f90_type;\n \t}\n-      \n+\n       /* Add initializer.  Make sure we keep the ranks sane.  */\n       if (sym->attr.dimension && init->rank == 0)\n \t{\n \t  mpz_t size;\n \t  gfc_expr *array;\n-\t  gfc_constructor *c;\n \t  int n;\n \t  if (sym->attr.flavor == FL_PARAMETER\n \t\t&& init->expr_type == EXPR_CONSTANT\n \t\t&& spec_size (sym->as, &size) == SUCCESS\n \t\t&& mpz_cmp_si (size, 0) > 0)\n \t    {\n-\t      array = gfc_start_constructor (init->ts.type, init->ts.kind,\n-\t\t\t\t\t     &init->where);\n-\n-\t      array->value.constructor = c = NULL;\n+\t      array = gfc_get_array_expr (init->ts.type, init->ts.kind,\n+\t\t\t\t\t  &init->where);\n \t      for (n = 0; n < (int)mpz_get_si (size); n++)\n-\t\t{\n-\t\t  if (array->value.constructor == NULL)\n-\t\t    {\n-\t\t      array->value.constructor = c = gfc_get_constructor ();\n-\t\t      c->expr = init;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      c->next = gfc_get_constructor ();\n-\t\t      c = c->next;\n-\t\t      c->expr = gfc_copy_expr (init);\n-\t\t    }\n-\t\t}\n-\n+\t\tgfc_constructor_append_expr (&array->value.constructor,\n+\t\t\t\t\t     n == 0\n+\t\t\t\t\t\t? init\n+\t\t\t\t\t\t: gfc_copy_expr (init),\n+\t\t\t\t\t     &init->where);\n+\t\t\n \t      array->shape = gfc_get_shape (sym->as->rank);\n \t      for (n = 0; n < sym->as->rank; n++)\n \t\tspec_dimen_size (sym->as, n, &array->shape[n]);\n@@ -1513,15 +1509,14 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n       else if (mpz_cmp (c->ts.u.cl->length->value.integer,\n \t\t\tc->initializer->ts.u.cl->length->value.integer))\n \t{\n-\t  bool has_ts;\n-\t  gfc_constructor *ctor = c->initializer->value.constructor;\n-\n-\t  has_ts = (c->initializer->ts.u.cl\n-\t\t    && c->initializer->ts.u.cl->length_from_typespec);\n+\t  gfc_constructor *ctor;\n+\t  ctor = gfc_constructor_first (c->initializer->value.constructor);\n \n \t  if (ctor)\n \t    {\n \t      int first_len;\n+\t      bool has_ts = (c->initializer->ts.u.cl\n+\t\t\t     && c->initializer->ts.u.cl->length_from_typespec);\n \n \t      /* Remember the length of the first element for checking\n \t\t that all elements *in the constructor* have the same\n@@ -1530,11 +1525,12 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);\n \t      first_len = ctor->expr->value.character.length;\n \n-\t      for (; ctor; ctor = ctor->next)\n+\t      for ( ; ctor; ctor = gfc_constructor_next (ctor))\n+\t\tif (ctor->expr->expr_type == EXPR_CONSTANT)\n \t\t{\n-\t\t  if (ctor->expr->expr_type == EXPR_CONSTANT)\n-\t\t    gfc_set_constant_character_len (len, ctor->expr,\n-\t\t\t\t\t\t    has_ts ? -1 : first_len);\n+\t\t  gfc_set_constant_character_len (len, ctor->expr,\n+\t\t\t\t\t\t  has_ts ? -1 : first_len);\n+\t\t  ctor->expr->ts.u.cl->length = gfc_copy_expr (c->ts.u.cl->length);\n \t\t}\n \t    }\n \t}\n@@ -1586,7 +1582,6 @@ match\n gfc_match_null (gfc_expr **result)\n {\n   gfc_symbol *sym;\n-  gfc_expr *e;\n   match m;\n \n   m = gfc_match (\" null ( )\");\n@@ -1608,12 +1603,7 @@ gfc_match_null (gfc_expr **result)\n \t  || gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE))\n     return MATCH_ERROR;\n \n-  e = gfc_get_expr ();\n-  e->where = gfc_current_locus;\n-  e->expr_type = EXPR_NULL;\n-  e->ts.type = BT_UNKNOWN;\n-\n-  *result = e;\n+  *result = gfc_get_null_expr (&gfc_current_locus);\n \n   return MATCH_YES;\n }\n@@ -2309,7 +2299,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n   cl = gfc_new_charlen (gfc_current_ns, NULL);\n \n   if (seen_length == 0)\n-    cl->length = gfc_int_expr (1);\n+    cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n   else\n     cl->length = len;\n \n@@ -2690,7 +2680,8 @@ gfc_match_implicit (void)\n \t\t{\n \t\t  ts.kind = gfc_default_character_kind;\n \t\t  ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\t\t  ts.u.cl->length = gfc_int_expr (1);\n+\t\t  ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t      NULL, 1);\n \t\t}\n \n \t      /* Record the Successful match.  */\n@@ -7147,12 +7138,7 @@ static gfc_expr *\n enum_initializer (gfc_expr *last_initializer, locus where)\n {\n   gfc_expr *result;\n-\n-  result = gfc_get_expr ();\n-  result->expr_type = EXPR_CONSTANT;\n-  result->ts.type = BT_INTEGER;\n-  result->ts.kind = gfc_c_int_kind;\n-  result->where = where;\n+  result = gfc_get_constant_expr (BT_INTEGER, gfc_c_int_kind, &where);\n \n   mpz_init (result->value.integer);\n "}, {"sha": "adeea6ab25da5d23e90797531e3385eb40e21c32", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"gfortran.h\"\n #include \"dependency.h\"\n+#include \"constructor.h\"\n \n /* static declarations */\n /* Enums  */\n@@ -843,7 +844,8 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n \n     case EXPR_ARRAY:\n       /* Loop through the array constructor's elements.  */\n-      for (c = expr2->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (expr2->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \t{\n \t  /* If this is an iterator, assume the worst.  */\n \t  if (c->iterator)\n@@ -1190,7 +1192,8 @@ contains_forall_index_p (gfc_expr *expr)\n \n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n-      for (c = expr->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; gfc_constructor_next (c))\n \tif (contains_forall_index_p (c->expr))\n \t  return true;\n       break;"}, {"sha": "967a0a543ff20388fc341c5657e4ed49673a082d", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"gfortran.h\"\n+#include \"constructor.h\"\n \n /* Keep track of indentation for symbol tree dumps.  */\n static int show_level = 0;\n@@ -271,9 +272,10 @@ show_ref (gfc_ref *p)\n /* Display a constructor.  Works recursively for array constructors.  */\n \n static void\n-show_constructor (gfc_constructor *c)\n+show_constructor (gfc_constructor_base base)\n {\n-  for (; c; c = c->next)\n+  gfc_constructor *c;\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       if (c->iterator == NULL)\n \tshow_expr (c->expr);\n@@ -294,7 +296,7 @@ show_constructor (gfc_constructor *c)\n \t  fputc (')', dumpfile);\n \t}\n \n-      if (c->next != NULL)\n+      if (gfc_constructor_next (c) != NULL)\n \tfputs (\" , \", dumpfile);\n     }\n }"}, {"sha": "700fd10f6fe872c285241f2a65385b2fd300289c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 545, "deletions": 411, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -26,8 +26,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"arith.h\"\n #include \"match.h\"\n #include \"target-memory.h\" /* for gfc_convert_boz */\n+#include \"constructor.h\"\n \n-/* Get a new expr node.  */\n+\n+/* The following set of functions provide access to gfc_expr* of\n+   various types - actual all but EXPR_FUNCTION and EXPR_VARIABLE.\n+\n+   There are two functions available elsewhere that provide\n+   slightly different flavours of variables.  Namely:\n+     expr.c (gfc_get_variable_expr)\n+     symbol.c (gfc_lval_expr_from_sym)\n+   TODO: Merge these functions, if possible.  */\n+\n+/* Get a new expression node.  */\n \n gfc_expr *\n gfc_get_expr (void)\n@@ -39,92 +50,349 @@ gfc_get_expr (void)\n   e->shape = NULL;\n   e->ref = NULL;\n   e->symtree = NULL;\n-  e->con_by_offset = NULL;\n   return e;\n }\n \n \n-/* Free an argument list and everything below it.  */\n+/* Get a new expression node that is an array constructor\n+   of given type and kind.  */\n \n-void\n-gfc_free_actual_arglist (gfc_actual_arglist *a1)\n+gfc_expr *\n+gfc_get_array_expr (bt type, int kind, locus *where)\n {\n-  gfc_actual_arglist *a2;\n+  gfc_expr *e;\n \n-  while (a1)\n-    {\n-      a2 = a1->next;\n-      gfc_free_expr (a1->expr);\n-      gfc_free (a1);\n-      a1 = a2;\n-    }\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_ARRAY;\n+  e->value.constructor = NULL;\n+  e->rank = 1;\n+  e->shape = NULL;\n+\n+  e->ts.type = type;\n+  e->ts.kind = kind;\n+  if (where)\n+    e->where = *where;\n+\n+  return e;\n }\n \n \n-/* Copy an arglist structure and all of the arguments.  */\n+/* Get a new expression node that is the NULL expression.  */\n \n-gfc_actual_arglist *\n-gfc_copy_actual_arglist (gfc_actual_arglist *p)\n+gfc_expr *\n+gfc_get_null_expr (locus *where)\n {\n-  gfc_actual_arglist *head, *tail, *new_arg;\n+  gfc_expr *e;\n \n-  head = tail = NULL;\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_NULL;\n+  e->ts.type = BT_UNKNOWN;\n \n-  for (; p; p = p->next)\n+  if (where)\n+    e->where = *where;\n+\n+  return e;\n+}\n+\n+\n+/* Get a new expression node that is an operator expression node.  */\n+\n+gfc_expr *\n+gfc_get_operator_expr (locus *where, gfc_intrinsic_op op,\n+                      gfc_expr *op1, gfc_expr *op2)\n+{\n+  gfc_expr *e;\n+\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_OP;\n+  e->value.op.op = op;\n+  e->value.op.op1 = op1;\n+  e->value.op.op2 = op2;\n+\n+  if (where)\n+    e->where = *where;\n+\n+  return e;\n+}\n+\n+\n+/* Get a new expression node that is an structure constructor\n+   of given type and kind.  */\n+\n+gfc_expr *\n+gfc_get_structure_constructor_expr (bt type, int kind, locus *where)\n+{\n+  gfc_expr *e;\n+\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_STRUCTURE;\n+  e->value.constructor = NULL;\n+\n+  e->ts.type = type;\n+  e->ts.kind = kind;\n+  if (where)\n+    e->where = *where;\n+\n+  return e;\n+}\n+\n+\n+/* Get a new expression node that is an constant of given type and kind.  */\n+\n+gfc_expr *\n+gfc_get_constant_expr (bt type, int kind, locus *where)\n+{\n+  gfc_expr *e;\n+\n+  if (!where)\n+    gfc_internal_error (\"gfc_get_constant_expr(): locus 'where' cannot be NULL\");\n+\n+  e = gfc_get_expr ();\n+\n+  e->expr_type = EXPR_CONSTANT;\n+  e->ts.type = type;\n+  e->ts.kind = kind;\n+  e->where = *where;\n+\n+  switch (type)\n     {\n-      new_arg = gfc_get_actual_arglist ();\n-      *new_arg = *p;\n+    case BT_INTEGER:\n+      mpz_init (e->value.integer);\n+      break;\n \n-      new_arg->expr = gfc_copy_expr (p->expr);\n-      new_arg->next = NULL;\n+    case BT_REAL:\n+      gfc_set_model_kind (kind);\n+      mpfr_init (e->value.real);\n+      break;\n \n-      if (head == NULL)\n-\thead = new_arg;\n-      else\n-\ttail->next = new_arg;\n+    case BT_COMPLEX:\n+      gfc_set_model_kind (kind);\n+      mpc_init2 (e->value.complex, mpfr_get_default_prec());\n+      break;\n \n-      tail = new_arg;\n+    default:\n+      break;\n     }\n \n-  return head;\n+  return e;\n }\n \n \n-/* Free a list of reference structures.  */\n+/* Get a new expression node that is an string constant.\n+   If no string is passed, a string of len is allocated,\n+   blanked and null-terminated.  */\n \n-void\n-gfc_free_ref_list (gfc_ref *p)\n+gfc_expr *\n+gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n {\n-  gfc_ref *q;\n-  int i;\n+  gfc_expr *e;\n+  gfc_char_t *dest;\n \n-  for (; p; p = q)\n+  if (!src)\n     {\n-      q = p->next;\n+      dest = gfc_get_wide_string (len + 1);\n+      gfc_wide_memset (dest, ' ', len);\n+      dest[len] = '\\0';\n+    }\n+  else\n+    dest = gfc_char_to_widechar (src);\n \n-      switch (p->type)\n+  e = gfc_get_constant_expr (BT_CHARACTER, kind,\n+                            where ? where : &gfc_current_locus);\n+  e->value.character.string = dest;\n+  e->value.character.length = len;\n+\n+  return e;\n+}\n+\n+\n+/* Get a new expression node that is an integer constant.  */\n+\n+gfc_expr *\n+gfc_get_int_expr (int kind, locus *where, int value)\n+{\n+  gfc_expr *p;\n+  p = gfc_get_constant_expr (BT_INTEGER, kind,\n+\t\t\t     where ? where : &gfc_current_locus);\n+\n+  mpz_init_set_si (p->value.integer, value);\n+\n+  return p;\n+}\n+\n+\n+/* Get a new expression node that is a logical constant.  */\n+\n+gfc_expr *\n+gfc_get_logical_expr (int kind, locus *where, bool value)\n+{\n+  gfc_expr *p;\n+  p = gfc_get_constant_expr (BT_LOGICAL, kind,\n+\t\t\t     where ? where : &gfc_current_locus);\n+\n+  p->value.logical = value;\n+\n+  return p;\n+}\n+\n+\n+gfc_expr *\n+gfc_get_iokind_expr (locus *where, io_kind k)\n+{\n+  gfc_expr *e;\n+\n+  /* Set the types to something compatible with iokind. This is needed to\n+     get through gfc_free_expr later since iokind really has no Basic Type,\n+     BT, of its own.  */\n+\n+  e = gfc_get_expr ();\n+  e->expr_type = EXPR_CONSTANT;\n+  e->ts.type = BT_LOGICAL;\n+  e->value.iokind = k;\n+  e->where = *where;\n+\n+  return e;\n+}\n+\n+\n+/* Given an expression pointer, return a copy of the expression.  This\n+   subroutine is recursive.  */\n+\n+gfc_expr *\n+gfc_copy_expr (gfc_expr *p)\n+{\n+  gfc_expr *q;\n+  gfc_char_t *s;\n+  char *c;\n+\n+  if (p == NULL)\n+    return NULL;\n+\n+  q = gfc_get_expr ();\n+  *q = *p;\n+\n+  switch (q->expr_type)\n+    {\n+    case EXPR_SUBSTRING:\n+      s = gfc_get_wide_string (p->value.character.length + 1);\n+      q->value.character.string = s;\n+      memcpy (s, p->value.character.string,\n+\t      (p->value.character.length + 1) * sizeof (gfc_char_t));\n+      break;\n+\n+    case EXPR_CONSTANT:\n+      /* Copy target representation, if it exists.  */\n+      if (p->representation.string)\n \t{\n-\tcase REF_ARRAY:\n-\t  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n+\t  c = XCNEWVEC (char, p->representation.length + 1);\n+\t  q->representation.string = c;\n+\t  memcpy (c, p->representation.string, (p->representation.length + 1));\n+\t}\n+\n+      /* Copy the values of any pointer components of p->value.  */\n+      switch (q->ts.type)\n+\t{\n+\tcase BT_INTEGER:\n+\t  mpz_init_set (q->value.integer, p->value.integer);\n+\t  break;\n+\n+\tcase BT_REAL:\n+\t  gfc_set_model_kind (q->ts.kind);\n+\t  mpfr_init (q->value.real);\n+\t  mpfr_set (q->value.real, p->value.real, GFC_RND_MODE);\n+\t  break;\n+\n+\tcase BT_COMPLEX:\n+\t  gfc_set_model_kind (q->ts.kind);\n+\t  mpc_init2 (q->value.complex, mpfr_get_default_prec());\n+\t  mpc_set (q->value.complex, p->value.complex, GFC_MPC_RND_MODE);\n+\t  break;\n+\n+\tcase BT_CHARACTER:\n+\t  if (p->representation.string)\n+\t    q->value.character.string\n+\t      = gfc_char_to_widechar (q->representation.string);\n+\t  else\n \t    {\n-\t      gfc_free_expr (p->u.ar.start[i]);\n-\t      gfc_free_expr (p->u.ar.end[i]);\n-\t      gfc_free_expr (p->u.ar.stride[i]);\n-\t    }\n+\t      s = gfc_get_wide_string (p->value.character.length + 1);\n+\t      q->value.character.string = s;\n \n+\t      /* This is the case for the C_NULL_CHAR named constant.  */\n+\t      if (p->value.character.length == 0\n+\t\t  && (p->ts.is_c_interop || p->ts.is_iso_c))\n+\t\t{\n+\t\t  *s = '\\0';\n+\t\t  /* Need to set the length to 1 to make sure the NUL\n+\t\t     terminator is copied.  */\n+\t\t  q->value.character.length = 1;\n+\t\t}\n+\t      else\n+\t\tmemcpy (s, p->value.character.string,\n+\t\t\t(p->value.character.length + 1) * sizeof (gfc_char_t));\n+\t    }\n \t  break;\n \n-\tcase REF_SUBSTRING:\n-\t  gfc_free_expr (p->u.ss.start);\n-\t  gfc_free_expr (p->u.ss.end);\n+\tcase BT_HOLLERITH:\n+\tcase BT_LOGICAL:\n+\tcase BT_DERIVED:\n+\tcase BT_CLASS:\n+\t  break;\t\t/* Already done.  */\n+\n+\tcase BT_PROCEDURE:\n+        case BT_VOID:\n+           /* Should never be reached.  */\n+\tcase BT_UNKNOWN:\n+\t  gfc_internal_error (\"gfc_copy_expr(): Bad expr node\");\n+\t  /* Not reached.  */\n+\t}\n+\n+      break;\n+\n+    case EXPR_OP:\n+      switch (q->value.op.op)\n+\t{\n+\tcase INTRINSIC_NOT:\n+\tcase INTRINSIC_PARENTHESES:\n+\tcase INTRINSIC_UPLUS:\n+\tcase INTRINSIC_UMINUS:\n+\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n \t  break;\n \n-\tcase REF_COMPONENT:\n+\tdefault:\t\t/* Binary operators.  */\n+\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n+\t  q->value.op.op2 = gfc_copy_expr (p->value.op.op2);\n \t  break;\n \t}\n \n-      gfc_free (p);\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      q->value.function.actual =\n+\tgfc_copy_actual_arglist (p->value.function.actual);\n+      break;\n+\n+    case EXPR_COMPCALL:\n+    case EXPR_PPC:\n+      q->value.compcall.actual =\n+\tgfc_copy_actual_arglist (p->value.compcall.actual);\n+      q->value.compcall.tbp = p->value.compcall.tbp;\n+      break;\n+\n+    case EXPR_STRUCTURE:\n+    case EXPR_ARRAY:\n+      q->value.constructor = gfc_constructor_copy (p->value.constructor);\n+      break;\n+\n+    case EXPR_VARIABLE:\n+    case EXPR_NULL:\n+      break;\n     }\n+\n+  q->shape = gfc_copy_shape (p->shape, p->rank);\n+\n+  q->ref = gfc_copy_ref (p->ref);\n+\n+  return q;\n }\n \n \n@@ -191,7 +459,7 @@ free_expr0 (gfc_expr *e)\n \n     case EXPR_ARRAY:\n     case EXPR_STRUCTURE:\n-      gfc_free_constructor (e->value.constructor);\n+      gfc_constructor_free (e->value.constructor);\n       break;\n \n     case EXPR_SUBSTRING:\n@@ -211,26 +479,108 @@ free_expr0 (gfc_expr *e)\n       for (n = 0; n < e->rank; n++)\n \tmpz_clear (e->shape[n]);\n \n-      gfc_free (e->shape);\n-    }\n+      gfc_free (e->shape);\n+    }\n+\n+  gfc_free_ref_list (e->ref);\n+\n+  memset (e, '\\0', sizeof (gfc_expr));\n+}\n+\n+\n+/* Free an expression node and everything beneath it.  */\n+\n+void\n+gfc_free_expr (gfc_expr *e)\n+{\n+  if (e == NULL)\n+    return;\n+  free_expr0 (e);\n+  gfc_free (e);\n+}\n+\n+\n+/* Free an argument list and everything below it.  */\n+\n+void\n+gfc_free_actual_arglist (gfc_actual_arglist *a1)\n+{\n+  gfc_actual_arglist *a2;\n+\n+  while (a1)\n+    {\n+      a2 = a1->next;\n+      gfc_free_expr (a1->expr);\n+      gfc_free (a1);\n+      a1 = a2;\n+    }\n+}\n+\n+\n+/* Copy an arglist structure and all of the arguments.  */\n+\n+gfc_actual_arglist *\n+gfc_copy_actual_arglist (gfc_actual_arglist *p)\n+{\n+  gfc_actual_arglist *head, *tail, *new_arg;\n+\n+  head = tail = NULL;\n+\n+  for (; p; p = p->next)\n+    {\n+      new_arg = gfc_get_actual_arglist ();\n+      *new_arg = *p;\n+\n+      new_arg->expr = gfc_copy_expr (p->expr);\n+      new_arg->next = NULL;\n+\n+      if (head == NULL)\n+\thead = new_arg;\n+      else\n+\ttail->next = new_arg;\n+\n+      tail = new_arg;\n+    }\n+\n+  return head;\n+}\n+\n+\n+/* Free a list of reference structures.  */\n+\n+void\n+gfc_free_ref_list (gfc_ref *p)\n+{\n+  gfc_ref *q;\n+  int i;\n+\n+  for (; p; p = q)\n+    {\n+      q = p->next;\n \n-  gfc_free_ref_list (e->ref);\n+      switch (p->type)\n+\t{\n+\tcase REF_ARRAY:\n+\t  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n+\t    {\n+\t      gfc_free_expr (p->u.ar.start[i]);\n+\t      gfc_free_expr (p->u.ar.end[i]);\n+\t      gfc_free_expr (p->u.ar.stride[i]);\n+\t    }\n \n-  memset (e, '\\0', sizeof (gfc_expr));\n-}\n+\t  break;\n \n+\tcase REF_SUBSTRING:\n+\t  gfc_free_expr (p->u.ss.start);\n+\t  gfc_free_expr (p->u.ss.end);\n+\t  break;\n \n-/* Free an expression node and everything beneath it.  */\n+\tcase REF_COMPONENT:\n+\t  break;\n+\t}\n \n-void\n-gfc_free_expr (gfc_expr *e)\n-{\n-  if (e == NULL)\n-    return;\n-  if (e->con_by_offset)\n-    splay_tree_delete (e->con_by_offset); \n-  free_expr0 (e);\n-  gfc_free (e);\n+      gfc_free (p);\n+    }\n }\n \n \n@@ -420,147 +770,6 @@ gfc_copy_shape_excluding (mpz_t *shape, int rank, gfc_expr *dim)\n }\n \n \n-/* Given an expression pointer, return a copy of the expression.  This\n-   subroutine is recursive.  */\n-\n-gfc_expr *\n-gfc_copy_expr (gfc_expr *p)\n-{\n-  gfc_expr *q;\n-  gfc_char_t *s;\n-  char *c;\n-\n-  if (p == NULL)\n-    return NULL;\n-\n-  q = gfc_get_expr ();\n-  *q = *p;\n-\n-  switch (q->expr_type)\n-    {\n-    case EXPR_SUBSTRING:\n-      s = gfc_get_wide_string (p->value.character.length + 1);\n-      q->value.character.string = s;\n-      memcpy (s, p->value.character.string,\n-\t      (p->value.character.length + 1) * sizeof (gfc_char_t));\n-      break;\n-\n-    case EXPR_CONSTANT:\n-      /* Copy target representation, if it exists.  */\n-      if (p->representation.string)\n-\t{\n-\t  c = XCNEWVEC (char, p->representation.length + 1);\n-\t  q->representation.string = c;\n-\t  memcpy (c, p->representation.string, (p->representation.length + 1));\n-\t}\n-\n-      /* Copy the values of any pointer components of p->value.  */\n-      switch (q->ts.type)\n-\t{\n-\tcase BT_INTEGER:\n-\t  mpz_init_set (q->value.integer, p->value.integer);\n-\t  break;\n-\n-\tcase BT_REAL:\n-\t  gfc_set_model_kind (q->ts.kind);\n-\t  mpfr_init (q->value.real);\n-\t  mpfr_set (q->value.real, p->value.real, GFC_RND_MODE);\n-\t  break;\n-\n-\tcase BT_COMPLEX:\n-\t  gfc_set_model_kind (q->ts.kind);\n-\t  mpc_init2 (q->value.complex, mpfr_get_default_prec());\n-\t  mpc_set (q->value.complex, p->value.complex, GFC_MPC_RND_MODE);\n-\t  break;\n-\n-\tcase BT_CHARACTER:\n-\t  if (p->representation.string)\n-\t    q->value.character.string\n-\t      = gfc_char_to_widechar (q->representation.string);\n-\t  else\n-\t    {\n-\t      s = gfc_get_wide_string (p->value.character.length + 1);\n-\t      q->value.character.string = s;\n-\n-\t      /* This is the case for the C_NULL_CHAR named constant.  */\n-\t      if (p->value.character.length == 0\n-\t\t  && (p->ts.is_c_interop || p->ts.is_iso_c))\n-\t\t{\n-\t\t  *s = '\\0';\n-\t\t  /* Need to set the length to 1 to make sure the NUL\n-\t\t     terminator is copied.  */\n-\t\t  q->value.character.length = 1;\n-\t\t}\n-\t      else\n-\t\tmemcpy (s, p->value.character.string,\n-\t\t\t(p->value.character.length + 1) * sizeof (gfc_char_t));\n-\t    }\n-\t  break;\n-\n-\tcase BT_HOLLERITH:\n-\tcase BT_LOGICAL:\n-\tcase BT_DERIVED:\n-\tcase BT_CLASS:\n-\t  break;\t\t/* Already done.  */\n-\n-\tcase BT_PROCEDURE:\n-        case BT_VOID:\n-           /* Should never be reached.  */\n-\tcase BT_UNKNOWN:\n-\t  gfc_internal_error (\"gfc_copy_expr(): Bad expr node\");\n-\t  /* Not reached.  */\n-\t}\n-\n-      break;\n-\n-    case EXPR_OP:\n-      switch (q->value.op.op)\n-\t{\n-\tcase INTRINSIC_NOT:\n-\tcase INTRINSIC_PARENTHESES:\n-\tcase INTRINSIC_UPLUS:\n-\tcase INTRINSIC_UMINUS:\n-\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n-\t  break;\n-\n-\tdefault:\t\t/* Binary operators.  */\n-\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n-\t  q->value.op.op2 = gfc_copy_expr (p->value.op.op2);\n-\t  break;\n-\t}\n-\n-      break;\n-\n-    case EXPR_FUNCTION:\n-      q->value.function.actual =\n-\tgfc_copy_actual_arglist (p->value.function.actual);\n-      break;\n-\n-    case EXPR_COMPCALL:\n-    case EXPR_PPC:\n-      q->value.compcall.actual =\n-\tgfc_copy_actual_arglist (p->value.compcall.actual);\n-      q->value.compcall.tbp = p->value.compcall.tbp;\n-      break;\n-\n-    case EXPR_STRUCTURE:\n-    case EXPR_ARRAY:\n-      q->value.constructor = gfc_copy_constructor (p->value.constructor);\n-      break;\n-\n-    case EXPR_VARIABLE:\n-    case EXPR_NULL:\n-      break;\n-    }\n-\n-  q->shape = gfc_copy_shape (p->shape, p->rank);\n-\n-  q->ref = gfc_copy_ref (p->ref);\n-\n-  return q;\n-}\n-\n-\n /* Return the maximum kind of two expressions.  In general, higher\n    kind numbers mean more precision for numeric types.  */\n \n@@ -589,48 +798,6 @@ gfc_numeric_ts (gfc_typespec *ts)\n }\n \n \n-/* Returns an expression node that is an integer constant.  */\n-\n-gfc_expr *\n-gfc_int_expr (int i)\n-{\n-  gfc_expr *p;\n-\n-  p = gfc_get_expr ();\n-\n-  p->expr_type = EXPR_CONSTANT;\n-  p->ts.type = BT_INTEGER;\n-  p->ts.kind = gfc_default_integer_kind;\n-\n-  p->where = gfc_current_locus;\n-  mpz_init_set_si (p->value.integer, i);\n-\n-  return p;\n-}\n-\n-\n-/* Returns an expression node that is a logical constant.  */\n-\n-gfc_expr *\n-gfc_logical_expr (int i, locus *where)\n-{\n-  gfc_expr *p;\n-\n-  p = gfc_get_expr ();\n-\n-  p->expr_type = EXPR_CONSTANT;\n-  p->ts.type = BT_LOGICAL;\n-  p->ts.kind = gfc_default_logical_kind;\n-\n-  if (where == NULL)\n-    where = &gfc_current_locus;\n-  p->where = *where;\n-  p->value.logical = i;\n-\n-  return p;\n-}\n-\n-\n /* Return an expression node with an optional argument list attached.\n    A variable number of gfc_expr pointers are strung together in an\n    argument list with a NULL pointer terminating the list.  */\n@@ -764,76 +931,62 @@ gfc_is_constant_expr (gfc_expr *e)\n {\n   gfc_constructor *c;\n   gfc_actual_arglist *arg;\n-  int rv;\n \n   if (e == NULL)\n     return 1;\n \n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n-      rv = (gfc_is_constant_expr (e->value.op.op1)\n-\t    && (e->value.op.op2 == NULL\n-\t\t|| gfc_is_constant_expr (e->value.op.op2)));\n-      break;\n+      return (gfc_is_constant_expr (e->value.op.op1)\n+\t      && (e->value.op.op2 == NULL\n+\t\t  || gfc_is_constant_expr (e->value.op.op2)));\n \n     case EXPR_VARIABLE:\n-      rv = 0;\n-      break;\n+      return 0;\n \n     case EXPR_FUNCTION:\n     case EXPR_PPC:\n     case EXPR_COMPCALL:\n       /* Specification functions are constant.  */\n       if (check_specification_function (e) == MATCH_YES)\n-\t{\n-\t  rv = 1;\n-\t  break;\n-\t}\n+\treturn 1;\n \n       /* Call to intrinsic with at least one argument.  */\n-      rv = 0;\n       if (e->value.function.isym && e->value.function.actual)\n \t{\n \t  for (arg = e->value.function.actual; arg; arg = arg->next)\n-\t    {\n-\t      if (!gfc_is_constant_expr (arg->expr))\n-\t\tbreak;\n-\t    }\n-\t  if (arg == NULL)\n-\t    rv = 1;\n+\t    if (!gfc_is_constant_expr (arg->expr))\n+\t      return 0;\n+\n+\t  return 1;\n \t}\n-      break;\n+      else\n+\treturn 0;\n \n     case EXPR_CONSTANT:\n     case EXPR_NULL:\n-      rv = 1;\n-      break;\n+      return 1;\n \n     case EXPR_SUBSTRING:\n-      rv = e->ref == NULL || (gfc_is_constant_expr (e->ref->u.ss.start)\n-\t\t\t      && gfc_is_constant_expr (e->ref->u.ss.end));\n-      break;\n+      return e->ref == NULL || (gfc_is_constant_expr (e->ref->u.ss.start)\n+\t\t\t\t&& gfc_is_constant_expr (e->ref->u.ss.end));\n \n     case EXPR_STRUCTURE:\n-      rv = 0;\n-      for (c = e->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (e->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \tif (!gfc_is_constant_expr (c->expr))\n-\t  break;\n+\t  return 0;\n \n-      if (c == NULL)\n-\trv = 1;\n-      break;\n+      return 1;\n \n     case EXPR_ARRAY:\n-      rv = gfc_constant_ac (e);\n-      break;\n+      return gfc_constant_ac (e);\n \n     default:\n       gfc_internal_error (\"gfc_is_constant_expr(): Unknown expression type\");\n+      return 0;\n     }\n-\n-  return rv;\n }\n \n \n@@ -1005,11 +1158,12 @@ simplify_intrinsic_op (gfc_expr *p, int type)\n    with gfc_simplify_expr().  */\n \n static gfc_try\n-simplify_constructor (gfc_constructor *c, int type)\n+simplify_constructor (gfc_constructor_base base, int type)\n {\n+  gfc_constructor *c;\n   gfc_expr *p;\n \n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       if (c->iterator\n \t  && (gfc_simplify_expr (c->iterator->start, type) == FAILURE\n@@ -1041,7 +1195,7 @@ simplify_constructor (gfc_constructor *c, int type)\n /* Pull a single array element out of an array constructor.  */\n \n static gfc_try\n-find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n+find_array_element (gfc_constructor_base base, gfc_array_ref *ar,\n \t\t    gfc_constructor **rval)\n {\n   unsigned long nelemen;\n@@ -1050,6 +1204,7 @@ find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n   mpz_t offset;\n   mpz_t span;\n   mpz_t tmp;\n+  gfc_constructor *cons;\n   gfc_expr *e;\n   gfc_try t;\n \n@@ -1104,16 +1259,13 @@ find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n       mpz_mul (span, span, tmp);\n     }\n \n-  for (nelemen = mpz_get_ui (offset); nelemen > 0; nelemen--)\n+  for (cons = gfc_constructor_first (base), nelemen = mpz_get_ui (offset);\n+       cons && nelemen > 0; cons = gfc_constructor_next (cons), nelemen--)\n     {\n-      if (cons)\n+      if (cons->iterator)\n \t{\n-\t  if (cons->iterator)\n-\t    {\n-\t      cons = NULL;\n-\t      goto depart;\n-\t    }\n-\t  cons = cons->next;\n+\t  cons = NULL;\n+\t  goto depart;\n \t}\n     }\n \n@@ -1132,20 +1284,21 @@ find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n /* Find a component of a structure constructor.  */\n \n static gfc_constructor *\n-find_component_ref (gfc_constructor *cons, gfc_ref *ref)\n+find_component_ref (gfc_constructor_base base, gfc_ref *ref)\n {\n   gfc_component *comp;\n   gfc_component *pick;\n+  gfc_constructor *c = gfc_constructor_first (base);\n \n   comp = ref->u.c.sym->components;\n   pick = ref->u.c.component;\n   while (comp != pick)\n     {\n       comp = comp->next;\n-      cons = cons->next;\n+      c = gfc_constructor_next (c);\n     }\n \n-  return cons;\n+  return c;\n }\n \n \n@@ -1190,15 +1343,13 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   mpz_t tmp_mpz;\n   mpz_t nelts;\n   mpz_t ptr;\n-  mpz_t index;\n-  gfc_constructor *cons;\n-  gfc_constructor *base;\n+  gfc_constructor_base base;\n+  gfc_constructor *cons, *vecsub[GFC_MAX_DIMENSIONS];\n   gfc_expr *begin;\n   gfc_expr *finish;\n   gfc_expr *step;\n   gfc_expr *upper;\n   gfc_expr *lower;\n-  gfc_constructor *vecsub[GFC_MAX_DIMENSIONS], *c;\n   gfc_try t;\n \n   t = SUCCESS;\n@@ -1240,6 +1391,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n       if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */\n \t{\n+\t  gfc_constructor *ci;\n \t  gcc_assert (begin);\n \n \t  if (begin->expr_type != EXPR_ARRAY || !gfc_is_constant_expr (begin))\n@@ -1256,16 +1408,16 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t      break;\n \t    }\n \n-\t  vecsub[d] = begin->value.constructor;\n+\t  vecsub[d] = gfc_constructor_first (begin->value.constructor);\n \t  mpz_set (ctr[d], vecsub[d]->expr->value.integer);\n \t  mpz_mul (nelts, nelts, begin->shape[0]);\n \t  mpz_set (expr->shape[shape_i++], begin->shape[0]);\n \n \t  /* Check bounds.  */\n-\t  for (c = vecsub[d]; c; c = c->next)\n+\t  for (ci = vecsub[d]; ci; ci = gfc_constructor_next (ci))\n \t    {\n-\t      if (mpz_cmp (c->expr->value.integer, upper->value.integer) > 0\n-\t\t  || mpz_cmp (c->expr->value.integer,\n+\t      if (mpz_cmp (ci->expr->value.integer, upper->value.integer) > 0\n+\t\t  || mpz_cmp (ci->expr->value.integer,\n \t\t\t      lower->value.integer) < 0)\n \t\t{\n \t\t  gfc_error (\"index in dimension %d is out of bounds \"\n@@ -1346,9 +1498,8 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       mpz_mul (delta_mpz, delta_mpz, tmp_mpz);\n     }\n \n-  mpz_init (index);\n   mpz_init (ptr);\n-  cons = base;\n+  cons = gfc_constructor_first (base);\n \n   /* Now clock through the array reference, calculating the index in\n      the source constructor and transferring the elements to the new\n@@ -1374,11 +1525,11 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    {\n \t      gcc_assert(vecsub[d]);\n \n-\t      if (!vecsub[d]->next)\n-\t\tvecsub[d] = ref->u.ar.start[d]->value.constructor;\n+\t      if (!gfc_constructor_next (vecsub[d]))\n+\t\tvecsub[d] = gfc_constructor_first (ref->u.ar.start[d]->value.constructor);\n \t      else\n \t\t{\n-\t\t  vecsub[d] = vecsub[d]->next;\n+\t\t  vecsub[d] = gfc_constructor_next (vecsub[d]);\n \t\t  incr_ctr = false;\n \t\t}\n \t      mpz_set (ctr[d], vecsub[d]->expr->value.integer);\n@@ -1396,25 +1547,13 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    }\n \t}\n \n-      /* There must be a better way of dealing with negative strides\n-\t than resetting the index and the constructor pointer!  */ \n-      if (mpz_cmp (ptr, index) < 0)\n-\t{\n-\t  mpz_set_ui (index, 0);\n-\t  cons = base;\n-\t}\n-\n-      while (cons && cons->next && mpz_cmp (ptr, index) > 0)\n-\t{\n-\t  mpz_add_ui (index, index, one);\n-\t  cons = cons->next;\n-\t}\n-\n-      gfc_append_constructor (expr, gfc_copy_expr (cons->expr));\n+      cons = gfc_constructor_lookup (base, mpz_get_ui (ptr));\n+      gcc_assert (cons);\n+      gfc_constructor_append_expr (&expr->value.constructor,\n+\t\t\t\t   gfc_copy_expr (cons->expr), NULL);\n     }\n \n   mpz_clear (ptr);\n-  mpz_clear (index);\n \n cleanup:\n \n@@ -1429,7 +1568,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       mpz_clear (ctr[d]);\n       mpz_clear (stride[d]);\n     }\n-  gfc_free_constructor (base);\n+  gfc_constructor_free (base);\n   return t;\n }\n \n@@ -1470,7 +1609,7 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n static gfc_try\n simplify_const_ref (gfc_expr *p)\n {\n-  gfc_constructor *cons;\n+  gfc_constructor *cons, *c;\n   gfc_expr *newp;\n   gfc_ref *last_ref;\n \n@@ -1510,20 +1649,20 @@ simplify_const_ref (gfc_expr *p)\n \t      if (p->ref->next != NULL\n \t\t  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))\n \t\t{\n-\t\t  cons = p->value.constructor;\n-\t\t  for (; cons; cons = cons->next)\n+\t\t  for (c = gfc_constructor_first (p->value.constructor);\n+\t\t       c; c = gfc_constructor_next (c))\n \t\t    {\n-\t\t      cons->expr->ref = gfc_copy_ref (p->ref->next);\n-\t\t      if (simplify_const_ref (cons->expr) == FAILURE)\n+\t\t      c->expr->ref = gfc_copy_ref (p->ref->next);\n+\t\t      if (simplify_const_ref (c->expr) == FAILURE)\n \t\t\treturn FAILURE;\n \t\t    }\n \n \t\t  if (p->ts.type == BT_DERIVED\n \t\t\t&& p->ref->next\n-\t\t\t&& p->value.constructor)\n+\t\t\t&& (c = gfc_constructor_first (p->value.constructor)))\n \t\t    {\n \t\t      /* There may have been component references.  */\n-\t\t      p->ts = p->value.constructor->expr->ts;\n+\t\t      p->ts = c->expr->ts;\n \t\t    }\n \n \t\t  last_ref = p->ref;\n@@ -1537,9 +1676,9 @@ simplify_const_ref (gfc_expr *p)\n \t\t\t character length according to the first element\n \t\t\t (as all should have the same length).  */\n \t\t      int string_len;\n-\t\t      if (p->value.constructor)\n+\t\t      if ((c = gfc_constructor_first (p->value.constructor)))\n \t\t\t{\n-\t\t\t  const gfc_expr* first = p->value.constructor->expr;\n+\t\t\t  const gfc_expr* first = c->expr;\n \t\t\t  gcc_assert (first->expr_type == EXPR_CONSTANT);\n \t\t\t  gcc_assert (first->ts.type == BT_CHARACTER);\n \t\t\t  string_len = first->value.character.length;\n@@ -1553,7 +1692,9 @@ simplify_const_ref (gfc_expr *p)\n \t\t      else\n \t\t\tgfc_free_expr (p->ts.u.cl->length);\n \n-\t\t      p->ts.u.cl->length = gfc_int_expr (string_len);\n+\t\t      p->ts.u.cl->length\n+\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t    NULL, string_len);\n \t\t    }\n \t\t}\n \t      gfc_free_ref_list (p->ref);\n@@ -1724,7 +1865,9 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  p->value.character.string = s;\n \t  p->value.character.length = end - start;\n \t  p->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\t  p->ts.u.cl->length = gfc_int_expr (p->value.character.length);\n+\t  p->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL,\n+\t\t\t\t\t\t p->value.character.length);\n \t  gfc_free_ref_list (p->ref);\n \t  p->ref = NULL;\n \t  p->expr_type = EXPR_CONSTANT;\n@@ -1812,10 +1955,12 @@ static gfc_try\n scalarize_intrinsic_call (gfc_expr *e)\n {\n   gfc_actual_arglist *a, *b;\n-  gfc_constructor *args[5], *ctor, *new_ctor;\n+  gfc_constructor_base ctor;\n+  gfc_constructor *args[5];\n+  gfc_constructor *ci, *new_ctor;\n   gfc_expr *expr, *old;\n   int n, i, rank[5], array_arg;\n-\n+  \n   /* Find which, if any, arguments are arrays.  Assume that the old\n      expression carries the type information and that the first arg\n      that is an array expression carries all the shape information.*/\n@@ -1836,9 +1981,8 @@ scalarize_intrinsic_call (gfc_expr *e)\n \n   old = gfc_copy_expr (e);\n \n-  gfc_free_constructor (expr->value.constructor);\n+  gfc_constructor_free (expr->value.constructor);\n   expr->value.constructor = NULL;\n-\n   expr->ts = old->ts;\n   expr->where = old->where;\n   expr->expr_type = EXPR_ARRAY;\n@@ -1858,72 +2002,67 @@ scalarize_intrinsic_call (gfc_expr *e)\n \t{\n \t  rank[n] = a->expr->rank;\n \t  ctor = a->expr->symtree->n.sym->value->value.constructor;\n-\t  args[n] = gfc_copy_constructor (ctor);\n+\t  args[n] = gfc_constructor_first (ctor);\n \t}\n       else if (a->expr && a->expr->expr_type == EXPR_ARRAY)\n \t{\n \t  if (a->expr->rank)\n \t    rank[n] = a->expr->rank;\n \t  else\n \t    rank[n] = 1;\n-\t  args[n] = gfc_copy_constructor (a->expr->value.constructor);\n+\t  ctor = gfc_constructor_copy (a->expr->value.constructor);\n+\t  args[n] = gfc_constructor_first (ctor);\n \t}\n       else\n \targs[n] = NULL;\n+\n       n++;\n     }\n \n \n   /* Using the array argument as the master, step through the array\n      calling the function for each element and advancing the array\n      constructors together.  */\n-  ctor = args[array_arg - 1];\n-  new_ctor = NULL;\n-  for (; ctor; ctor = ctor->next)\n+  for (ci = args[array_arg - 1]; ci; ci = gfc_constructor_next (ci))\n     {\n-\t  if (expr->value.constructor == NULL)\n-\t    expr->value.constructor\n-\t\t= new_ctor = gfc_get_constructor ();\n+      new_ctor = gfc_constructor_append_expr (&expr->value.constructor,\n+\t\t\t\t\t      gfc_copy_expr (old), NULL);\n+\n+      gfc_free_actual_arglist (new_ctor->expr->value.function.actual);\n+      a = NULL;\n+      b = old->value.function.actual;\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  if (a == NULL)\n+\t    new_ctor->expr->value.function.actual\n+\t\t\t= a = gfc_get_actual_arglist ();\n \t  else\n \t    {\n-\t      new_ctor->next = gfc_get_constructor ();\n-\t      new_ctor = new_ctor->next;\n+\t      a->next = gfc_get_actual_arglist ();\n+\t      a = a->next;\n \t    }\n-\t  new_ctor->expr = gfc_copy_expr (old);\n-\t  gfc_free_actual_arglist (new_ctor->expr->value.function.actual);\n-\t  a = NULL;\n-\t  b = old->value.function.actual;\n-\t  for (i = 0; i < n; i++)\n-\t    {\n-\t      if (a == NULL)\n-\t\tnew_ctor->expr->value.function.actual\n-\t\t\t= a = gfc_get_actual_arglist ();\n-\t      else\n-\t\t{\n-\t\t  a->next = gfc_get_actual_arglist ();\n-\t\t  a = a->next;\n-\t\t}\n-\t      if (args[i])\n-\t\ta->expr = gfc_copy_expr (args[i]->expr);\n-\t      else\n-\t\ta->expr = gfc_copy_expr (b->expr);\n \n-\t      b = b->next;\n-\t    }\n+\t  if (args[i])\n+\t    a->expr = gfc_copy_expr (args[i]->expr);\n+\t  else\n+\t    a->expr = gfc_copy_expr (b->expr);\n+\n+\t  b = b->next;\n+\t}\n \n-\t  /* Simplify the function calls.  If the simplification fails, the\n-\t     error will be flagged up down-stream or the library will deal\n-\t     with it.  */\n-\t  gfc_simplify_expr (new_ctor->expr, 0);\n+      /* Simplify the function calls.  If the simplification fails, the\n+\t error will be flagged up down-stream or the library will deal\n+\t with it.  */\n+      gfc_simplify_expr (new_ctor->expr, 0);\n \n-\t  for (i = 0; i < n; i++)\n-\t    if (args[i])\n-\t      args[i] = args[i]->next;\n+      for (i = 0; i < n; i++)\n+\tif (args[i])\n+\t  args[i] = gfc_constructor_next (args[i]);\n \n-\t  for (i = 1; i < n; i++)\n-\t    if (rank[i] && ((args[i] != NULL && args[array_arg - 1] == NULL)\n-\t\t\t || (args[i] == NULL && args[array_arg - 1] != NULL)))\n-\t      goto compliance;\n+      for (i = 1; i < n; i++)\n+\tif (rank[i] && ((args[i] != NULL && args[array_arg - 1] == NULL)\n+\t\t\t|| (args[i] == NULL && args[array_arg - 1] != NULL)))\n+\t  goto compliance;\n     }\n \n   free_expr0 (e);\n@@ -2063,21 +2202,22 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n static gfc_try\n check_alloc_comp_init (gfc_expr *e)\n {\n-  gfc_component *c;\n+  gfc_component *comp;\n   gfc_constructor *ctor;\n \n   gcc_assert (e->expr_type == EXPR_STRUCTURE);\n   gcc_assert (e->ts.type == BT_DERIVED);\n \n-  for (c = e->ts.u.derived->components, ctor = e->value.constructor;\n-       c; c = c->next, ctor = ctor->next)\n+  for (comp = e->ts.u.derived->components,\n+       ctor = gfc_constructor_first (e->value.constructor);\n+       comp; comp = comp->next, ctor = gfc_constructor_next (ctor))\n     {\n-      if (c->attr.allocatable\n+      if (comp->attr.allocatable\n           && ctor->expr->expr_type != EXPR_NULL)\n         {\n \t  gfc_error(\"Invalid initialization expression for ALLOCATABLE \"\n \t            \"component '%s' in structure constructor at %L\",\n-\t            c->name, &ctor->expr->where);\n+\t            comp->name, &ctor->expr->where);\n \t  return FAILURE;\n \t}\n     }\n@@ -3444,45 +3584,38 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n gfc_expr *\n gfc_default_initializer (gfc_typespec *ts)\n {\n-  gfc_constructor *tail;\n   gfc_expr *init;\n-  gfc_component *c;\n+  gfc_component *comp;\n \n   /* See if we have a default initializer.  */\n-  for (c = ts->u.derived->components; c; c = c->next)\n-    if (c->initializer || c->attr.allocatable)\n+  for (comp = ts->u.derived->components; comp; comp = comp->next)\n+    if (comp->initializer || comp->attr.allocatable)\n       break;\n \n-  if (!c)\n+  if (!comp)\n     return NULL;\n \n-  /* Build the constructor.  */\n-  init = gfc_get_expr ();\n-  init->expr_type = EXPR_STRUCTURE;\n+  init = gfc_get_structure_constructor_expr (ts->type, ts->kind,\n+\t\t\t\t\t     &ts->u.derived->declared_at);\n   init->ts = *ts;\n-  init->where = ts->u.derived->declared_at;\n \n-  tail = NULL;\n-  for (c = ts->u.derived->components; c; c = c->next)\n+  for (comp = ts->u.derived->components; comp; comp = comp->next)\n     {\n-      if (tail == NULL)\n-\tinit->value.constructor = tail = gfc_get_constructor ();\n-      else\n-\t{\n-\t  tail->next = gfc_get_constructor ();\n-\t  tail = tail->next;\n-\t}\n+      gfc_constructor *ctor = gfc_constructor_get();\n \n-      if (c->initializer)\n-\ttail->expr = gfc_copy_expr (c->initializer);\n+      if (comp->initializer)\n+\tctor->expr = gfc_copy_expr (comp->initializer);\n \n-      if (c->attr.allocatable)\n+      if (comp->attr.allocatable)\n \t{\n-\t  tail->expr = gfc_get_expr ();\n-\t  tail->expr->expr_type = EXPR_NULL;\n-\t  tail->expr->ts = c->ts;\n+\t  ctor->expr = gfc_get_expr ();\n+\t  ctor->expr->expr_type = EXPR_NULL;\n+\t  ctor->expr->ts = comp->ts;\n \t}\n+\n+      gfc_constructor_append (&init->value.constructor, ctor);\n     }\n+\n   return init;\n }\n \n@@ -3611,7 +3744,8 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n-      for (c = expr->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \t{\n \t  if (gfc_traverse_expr (c->expr, sym, func, f))\n \t    return true;"}, {"sha": "a95134cb59d28d5f9e3b48a655500cd14905ce10", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1643,6 +1643,8 @@ gfc_class_esym_list;\n #define GFC_RND_MODE GMP_RNDN\n #define GFC_MPC_RND_MODE MPC_RNDNN\n \n+typedef splay_tree gfc_constructor_base;\n+\n typedef struct gfc_expr\n {\n   expr_t expr_type;\n@@ -1674,9 +1676,6 @@ typedef struct gfc_expr\n      a function call in interface.c(gfc_extend_expr).  */\n   unsigned int user_operator : 1;\n \n-  /* Used to quickly find a given constructor by its offset.  */\n-  splay_tree con_by_offset;\n-\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from\n@@ -1745,7 +1744,7 @@ typedef struct gfc_expr\n     }\n     character;\n \n-    struct gfc_constructor *constructor;\n+    gfc_constructor_base constructor;\n   }\n   value;\n \n@@ -2182,19 +2181,21 @@ extern gfc_option_t gfc_option;\n /* Constructor nodes for array and structure constructors.  */\n typedef struct gfc_constructor\n {\n+  gfc_constructor_base base;\n+  mpz_t offset;               /* Offset within a constructor, used as\n+\t\t\t\t key within base. */\n+\n   gfc_expr *expr;\n   gfc_iterator *iterator;\n   locus where;\n-  struct gfc_constructor *next;\n-  struct\n+\n+  union\n   {\n-    mpz_t offset; /* Record the offset of array element which appears in\n-                     data statement like \"data a(5)/4/\".  */\n-    gfc_component *component; /* Record the component being initialized.  */\n+     gfc_component *component; /* Record the component being initialized.  */\n   }\n   n;\n   mpz_t repeat; /* Record the repeat number of initial values in data\n-                 statement like \"data a/5*10/\".  */\n+                  statement like \"data a/5*10/\".  */\n }\n gfc_constructor;\n \n@@ -2610,10 +2611,18 @@ gfc_try gfc_simplify_expr (gfc_expr *, int);\n int gfc_has_vector_index (gfc_expr *);\n \n gfc_expr *gfc_get_expr (void);\n+gfc_expr *gfc_get_array_expr (bt type, int kind, locus *);\n+gfc_expr *gfc_get_null_expr (locus *);\n+gfc_expr *gfc_get_operator_expr (locus *, gfc_intrinsic_op,gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_get_structure_constructor_expr (bt, int, locus *);\n+gfc_expr *gfc_get_constant_expr (bt, int, locus *);\n+gfc_expr *gfc_get_character_expr (int, locus *, const char *, int len);\n+gfc_expr *gfc_get_int_expr (int, locus *, int);\n+gfc_expr *gfc_get_logical_expr (int, locus *, bool);\n+gfc_expr *gfc_get_iokind_expr (locus *, io_kind);\n+\n void gfc_free_expr (gfc_expr *);\n void gfc_replace_expr (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_int_expr (int);\n-gfc_expr *gfc_logical_expr (int, locus *);\n mpz_t *gfc_copy_shape (mpz_t *, int);\n mpz_t *gfc_copy_shape_excluding (mpz_t *, int, gfc_expr *);\n gfc_expr *gfc_copy_expr (gfc_expr *);\n@@ -2677,6 +2686,8 @@ bool gfc_type_is_extensible (gfc_symbol *sym);\n \n \n /* array.c */\n+gfc_iterator *gfc_copy_iterator (gfc_iterator *);\n+\n void gfc_free_array_spec (gfc_array_spec *);\n gfc_array_ref *gfc_copy_array_ref (gfc_array_ref *);\n \n@@ -2686,9 +2697,6 @@ gfc_try gfc_resolve_array_spec (gfc_array_spec *, int);\n \n int gfc_compare_array_spec (gfc_array_spec *, gfc_array_spec *);\n \n-gfc_expr *gfc_start_constructor (bt, int, locus *);\n-void gfc_append_constructor (gfc_expr *, gfc_expr *);\n-void gfc_free_constructor (gfc_constructor *);\n void gfc_simplify_iterator_var (gfc_expr *);\n gfc_try gfc_expand_constructor (gfc_expr *);\n int gfc_constant_ac (gfc_expr *);\n@@ -2698,14 +2706,10 @@ gfc_try gfc_resolve_array_constructor (gfc_expr *);\n gfc_try gfc_check_constructor_type (gfc_expr *);\n gfc_try gfc_check_iter_variable (gfc_expr *);\n gfc_try gfc_check_constructor (gfc_expr *, gfc_try (*)(gfc_expr *));\n-gfc_constructor *gfc_copy_constructor (gfc_constructor *);\n-gfc_expr *gfc_get_array_element (gfc_expr *, int);\n gfc_try gfc_array_size (gfc_expr *, mpz_t *);\n gfc_try gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n gfc_try gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n gfc_array_ref *gfc_find_array_ref (gfc_expr *);\n-void gfc_insert_constructor (gfc_expr *, gfc_constructor *);\n-gfc_constructor *gfc_get_constructor (void);\n tree gfc_conv_array_initializer (tree type, gfc_expr *);\n gfc_try spec_size (gfc_array_spec *, mpz_t *);\n gfc_try spec_dimen_size (gfc_array_spec *, int, mpz_t *);"}, {"sha": "6766f3d8a23b615e278d7c7b4f4e6faaf0d91de3", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,6 @@\n /* Deal with I/O statements & related stuff.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1229,14 +1230,9 @@ gfc_match_format (void)\n   new_st.loc = start;\n   new_st.op = EXEC_NOP;\n \n-  e = gfc_get_expr();\n-  e->expr_type = EXPR_CONSTANT;\n-  e->ts.type = BT_CHARACTER;\n-  e->ts.kind = gfc_default_character_kind;\n-  e->where = start;\n-  e->value.character.string = format_string\n-\t\t\t    = gfc_get_wide_string (format_length + 1);\n-  e->value.character.length = format_length;\n+  e = gfc_get_character_expr (gfc_default_character_kind, &start,\n+\t\t\t      NULL, format_length);\n+  format_string = e->value.character.string;\n   gfc_statement_label->format = e;\n \n   mode = MODE_COPY;\n@@ -2439,7 +2435,7 @@ default_unit (io_kind k)\n   else\n     unit = 6;\n \n-  return gfc_int_expr (unit);\n+  return gfc_get_int_expr (gfc_default_integer_kind, NULL, unit);\n }\n \n \n@@ -3655,17 +3651,8 @@ match_io (io_kind k)\n      that might have a format expression without unit number.  */\n   if (!comma_flag && gfc_match_char (',') == MATCH_YES)\n     {\n-      dt->extra_comma = gfc_get_expr ();\n-\n-      /* Set the types to something compatible with iokind. This is needed to\n-\t get through gfc_free_expr later since iokind really has no Basic Type,\n-\t BT, of its own.  */\n-      dt->extra_comma->expr_type = EXPR_CONSTANT;\n-      dt->extra_comma->ts.type = BT_LOGICAL;\n-\n       /* Save the iokind and locus for later use in resolution.  */\n-      dt->extra_comma->value.iokind = k;\n-      dt->extra_comma->where = gfc_current_locus;\n+      dt->extra_comma = gfc_get_iokind_expr (&gfc_current_locus, k);\n     }\n \n   io_code = NULL;"}, {"sha": "0b75604cf2cdd57eaaf206240a64e9c208e9c3e1", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n+#include \"constructor.h\"\n \n /* Given printf-like arguments, return a stable version of the result string. \n \n@@ -68,12 +69,18 @@ check_charlen_present (gfc_expr *source)\n \n   if (source->expr_type == EXPR_CONSTANT)\n     {\n-      source->ts.u.cl->length = gfc_int_expr (source->value.character.length);\n+      source->ts.u.cl->length\n+\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t    source->value.character.length);\n       source->rank = 0;\n     }\n   else if (source->expr_type == EXPR_ARRAY)\n-    source->ts.u.cl->length =\n-\tgfc_int_expr (source->value.constructor->expr->value.character.length);\n+    {\n+      gfc_constructor *c = gfc_constructor_first (source->value.constructor);\n+      source->ts.u.cl->length\n+\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t    c->expr->value.character.length);\n+    }\n }\n \n /* Helper function for resolving the \"mask\" argument.  */\n@@ -163,7 +170,7 @@ gfc_resolve_char_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind,\n   f->ts.kind = (kind == NULL)\n \t     ? gfc_default_character_kind : mpz_get_si (kind->value.integer);\n   f->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-  f->ts.u.cl->length = gfc_int_expr (1);\n+  f->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n \n   f->value.function.name = gfc_get_string (name, f->ts.kind,\n \t\t\t\t\t   gfc_type_letter (x->ts.type),\n@@ -488,7 +495,8 @@ gfc_resolve_cmplx (gfc_expr *f, gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n void\n gfc_resolve_dcmplx (gfc_expr *f, gfc_expr *x, gfc_expr *y)\n {\n-  gfc_resolve_cmplx (f, x, y, gfc_int_expr (gfc_default_double_kind));\n+  gfc_resolve_cmplx (f, x, y, gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t\t\tgfc_default_double_kind));\n }\n \n \n@@ -1968,11 +1976,11 @@ gfc_resolve_reshape (gfc_expr *f, gfc_expr *source, gfc_expr *shape,\n     {\n       gfc_constructor *c;\n       f->shape = gfc_get_shape (f->rank);\n-      c = shape->value.constructor;\n+      c = gfc_constructor_first (shape->value.constructor);\n       for (i = 0; i < f->rank; i++)\n \t{\n \t  mpz_init_set (f->shape[i], c->expr->value.integer);\n-\t  c = c->next;\n+\t  c = gfc_constructor_next (c);\n \t}\n     }\n \n@@ -2398,11 +2406,17 @@ gfc_resolve_transfer (gfc_expr *f, gfc_expr *source ATTRIBUTE_UNUSED,\n     {\n       int len;\n       if (mold->expr_type == EXPR_CONSTANT)\n-\tmold->ts.u.cl->length = gfc_int_expr (mold->value.character.length);\n+        {\n+\t  len = mold->value.character.length;\n+\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t    NULL, len);\n+\t}\n       else\n \t{\n-\t  len = mold->value.constructor->expr->value.character.length;\n-\t  mold->ts.u.cl->length = gfc_int_expr (len);\n+\t  gfc_constructor *c = gfc_constructor_first (mold->value.constructor);\n+\t  len = c->expr->value.character.length;\n+\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t    NULL, len);\n \t}\n     }\n "}, {"sha": "ea1134a45fdcb612cd2c277a289ce2735a1f5f8a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,6 @@\n /* Matching subroutines in all sizes, shapes and colors.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010\n    2010 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1005,7 +1006,7 @@ gfc_match_iterator (gfc_iterator *iter, int init_flag)\n \n   if (gfc_match_char (',') != MATCH_YES)\n     {\n-      e3 = gfc_int_expr (1);\n+      e3 = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n       goto done;\n     }\n \n@@ -1826,7 +1827,7 @@ gfc_match_do (void)\n \n   if (gfc_match_eos () == MATCH_YES)\n     {\n-      iter.end = gfc_logical_expr (1, NULL);\n+      iter.end = gfc_get_logical_expr (gfc_default_logical_kind, NULL, true);\n       new_st.op = EXEC_DO_WHILE;\n       goto done;\n     }\n@@ -2464,7 +2465,8 @@ gfc_match_goto (void)\n \t}\n \n       cp = gfc_get_case ();\n-      cp->low = cp->high = gfc_int_expr (i++);\n+      cp->low = cp->high = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t     NULL, i++);\n \n       tail->op = EXEC_SELECT;\n       tail->ext.case_list = cp;\n@@ -2944,10 +2946,7 @@ gfc_match_nullify (void)\n \t}\n \n       /* build ' => NULL() '.  */\n-      e = gfc_get_expr ();\n-      e->where = gfc_current_locus;\n-      e->expr_type = EXPR_NULL;\n-      e->ts.type = BT_UNKNOWN;\n+      e = gfc_get_null_expr (&gfc_current_locus);\n \n       /* Chain to list.  */\n       if (tail == NULL)\n@@ -3355,7 +3354,8 @@ gfc_match_call (void)\n \t  c->op = EXEC_SELECT;\n \n \t  new_case = gfc_get_case ();\n-\t  new_case->high = new_case->low = gfc_int_expr (i);\n+\t  new_case->high = gfc_get_int_expr (gfc_default_integer_kind, NULL, i);\n+\t  new_case->low = new_case->high;\n \t  c->ext.case_list = new_case;\n \n \t  c->next = gfc_get_code ();\n@@ -4786,7 +4786,7 @@ match_forall_iterator (gfc_forall_iterator **result)\n     goto cleanup;\n \n   if (gfc_match_char (':') == MATCH_NO)\n-    iter->stride = gfc_int_expr (1);\n+    iter->stride = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n   else\n     {\n       m = gfc_match_expr (&iter->stride);"}, {"sha": "8b99ce986920a53de13ca5531400fbfb4309bb7d", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,5 @@\n /* Expression parser.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -130,14 +130,10 @@ gfc_get_parentheses (gfc_expr *e)\n {\n   gfc_expr *e2;\n \n-  e2 = gfc_get_expr();\n-  e2->expr_type = EXPR_OP;\n+  e2 = gfc_get_operator_expr (&e->where, INTRINSIC_PARENTHESES, e, NULL);\n   e2->ts = e->ts;\n   e2->rank = e->rank;\n-  e2->where = e->where;\n-  e2->value.op.op = INTRINSIC_PARENTHESES;\n-  e2->value.op.op1 = e;\n-  e2->value.op.op2 = NULL;\n+\n   return e2;\n }\n \n@@ -195,26 +191,6 @@ match_primary (gfc_expr **result)\n }\n \n \n-/* Build an operator expression node.  */\n-\n-static gfc_expr *\n-build_node (gfc_intrinsic_op op, locus *where,\n-\t    gfc_expr *op1, gfc_expr *op2)\n-{\n-  gfc_expr *new_expr;\n-\n-  new_expr = gfc_get_expr ();\n-  new_expr->expr_type = EXPR_OP;\n-  new_expr->value.op.op = op;\n-  new_expr->where = *where;\n-\n-  new_expr->value.op.op1 = op1;\n-  new_expr->value.op.op2 = op2;\n-\n-  return new_expr;\n-}\n-\n-\n /* Match a level 1 expression.  */\n \n static match\n@@ -239,7 +215,7 @@ match_level_1 (gfc_expr **result)\n     *result = e;\n   else\n     {\n-      f = build_node (INTRINSIC_USER, &where, e, NULL);\n+      f = gfc_get_operator_expr (&where, INTRINSIC_USER, e, NULL);\n       f->value.op.uop = uop;\n       *result = f;\n     }\n@@ -915,7 +891,7 @@ gfc_match_expr (gfc_expr **result)\n \t  return MATCH_ERROR;\n \t}\n \n-      all = build_node (INTRINSIC_USER, &where, all, e);\n+      all = gfc_get_operator_expr (&where, INTRINSIC_USER, all, e);\n       all->value.op.uop = uop;\n     }\n "}, {"sha": "c58a67c3d580c3eb9cdf3384458511b77cecef8a", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"parse.h\" /* FIXME */\n #include \"md5.h\"\n+#include \"constructor.h\"\n \n #define MODULE_EXTENSION \".mod\"\n \n@@ -2628,15 +2629,15 @@ mio_iterator (gfc_iterator **ip)\n \n \n static void\n-mio_constructor (gfc_constructor **cp)\n+mio_constructor (gfc_constructor_base *cp)\n {\n-  gfc_constructor *c, *tail;\n+  gfc_constructor *c;\n \n   mio_lparen ();\n \n   if (iomode == IO_OUTPUT)\n     {\n-      for (c = *cp; c; c = c->next)\n+      for (c = gfc_constructor_first (*cp); c; c = gfc_constructor_next (c))\n \t{\n \t  mio_lparen ();\n \t  mio_expr (&c->expr);\n@@ -2646,19 +2647,9 @@ mio_constructor (gfc_constructor **cp)\n     }\n   else\n     {\n-      *cp = NULL;\n-      tail = NULL;\n-\n       while (peek_atom () != ATOM_RPAREN)\n \t{\n-\t  c = gfc_get_constructor ();\n-\n-\t  if (tail == NULL)\n-\t    *cp = c;\n-\t  else\n-\t    tail->next = c;\n-\n-\t  tail = c;\n+\t  c = gfc_constructor_append_expr (cp, NULL, NULL);\n \n \t  mio_lparen ();\n \t  mio_expr (&c->expr);\n@@ -5343,7 +5334,7 @@ create_int_parameter (const char *name, int value, const char *modname,\n   sym->attr.flavor = FL_PARAMETER;\n   sym->ts.type = BT_INTEGER;\n   sym->ts.kind = gfc_default_integer_kind;\n-  sym->value = gfc_int_expr (value);\n+  sym->value = gfc_get_int_expr (gfc_default_integer_kind, NULL, value);\n   sym->attr.use_assoc = 1;\n   sym->from_intmod = module;\n   sym->intmod_sym_id = id;"}, {"sha": "c8ca3d4cf8a083c2d94f215593ccfc6aac8ae41a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,5 @@\n /* Primary expression subroutines\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"parse.h\"\n #include \"toplev.h\"\n+#include \"constructor.h\"\n \n /* Matches a kind-parameter expression, which is either a named\n    symbolic constant or a nonnegative integer constant.  If\n@@ -276,8 +277,8 @@ match_hollerith_constant (gfc_expr **result)\n       else\n \t{\n \t  gfc_free_expr (e);\n-\t  e = gfc_constant_result (BT_HOLLERITH, gfc_default_character_kind,\n-\t\t\t\t   &gfc_current_locus);\n+\t  e = gfc_get_constant_expr (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t\t\t     &gfc_current_locus);\n \n \t  e->representation.string = XCNEWVEC (char, num + 1);\n \n@@ -711,7 +712,7 @@ match_substring (gfc_charlen *cl, int init, gfc_ref **result)\n \n       ref->type = REF_SUBSTRING;\n       if (start == NULL)\n-\tstart = gfc_int_expr (1);\n+\tstart = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n       ref->u.ss.start = start;\n       if (end == NULL && cl)\n \tend = gfc_copy_expr (cl->length);\n@@ -969,19 +970,10 @@ match_string_constant (gfc_expr **result)\n   if (peek == 'b' || peek == 'o' || peek =='z' || peek == 'x')\n     goto no_match;\n \n-\n-  e = gfc_get_expr ();\n-\n-  e->expr_type = EXPR_CONSTANT;\n+  e = gfc_get_character_expr (kind, &start_locus, NULL, length);\n   e->ref = NULL;\n-  e->ts.type = BT_CHARACTER;\n-  e->ts.kind = kind;\n   e->ts.is_c_interop = 0;\n   e->ts.is_iso_c = 0;\n-  e->where = start_locus;\n-\n-  e->value.character.string = p = gfc_get_wide_string (length + 1);\n-  e->value.character.length = length;\n \n   gfc_current_locus = start_locus;\n   gfc_next_char ();\t\t/* Skip delimiter */\n@@ -991,6 +983,7 @@ match_string_constant (gfc_expr **result)\n   warn_ampersand = gfc_option.warn_ampersand;\n   gfc_option.warn_ampersand = 0;\n \n+  p = e->value.character.string;\n   for (i = 0; i < length; i++)\n     {\n       c = next_string_char (delimiter, &ret);\n@@ -1084,15 +1077,9 @@ match_logical_constant (gfc_expr **result)\n       return MATCH_ERROR;\n     }\n \n-  e = gfc_get_expr ();\n-\n-  e->expr_type = EXPR_CONSTANT;\n-  e->value.logical = i;\n-  e->ts.type = BT_LOGICAL;\n-  e->ts.kind = kind;\n+  e = gfc_get_logical_expr (kind, &gfc_current_locus, i);\n   e->ts.is_c_interop = 0;\n   e->ts.is_iso_c = 0;\n-  e->where = gfc_current_locus;\n \n   *result = e;\n   return MATCH_YES;\n@@ -2175,10 +2162,9 @@ gfc_free_structure_ctor_component (gfc_structure_ctor_component *comp)\n    for components without explicit value given.  */\n static gfc_try\n build_actual_constructor (gfc_structure_ctor_component **comp_head,\n-\t\t\t  gfc_constructor **ctor_head, gfc_symbol *sym)\n+\t\t\t  gfc_constructor_base *ctor_head, gfc_symbol *sym)\n {\n   gfc_structure_ctor_component *comp_iter;\n-  gfc_constructor *ctor_tail = NULL;\n   gfc_component *comp;\n \n   for (comp = sym->components; comp; comp = comp->next)\n@@ -2199,20 +2185,19 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t a value expression for the parent derived type and calling self.  */\n       if (!comp_iter && comp == sym->components && sym->attr.extension)\n \t{\n-\t  value = gfc_get_expr ();\n-\t  value->expr_type = EXPR_STRUCTURE;\n-\t  value->value.constructor = NULL;\n+\t  value = gfc_get_structure_constructor_expr (comp->ts.type,\n+\t\t\t\t\t\t      comp->ts.kind,\n+\t\t\t\t\t\t      &gfc_current_locus);\n \t  value->ts = comp->ts;\n-\t  value->where = gfc_current_locus;\n \n \t  if (build_actual_constructor (comp_head, &value->value.constructor,\n \t\t\t\t\tcomp->ts.u.derived) == FAILURE)\n \t    {\n \t      gfc_free_expr (value);\n \t      return FAILURE;\n \t    }\n-\t  *ctor_head = ctor_tail = gfc_get_constructor ();\n-\t  ctor_tail->expr = value;\n+\n+\t  gfc_constructor_append_expr (ctor_head, value, NULL);\n \t  continue;\n \t}\n \n@@ -2239,15 +2224,7 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \tvalue = comp_iter->val;\n \n       /* Add the value to the constructor chain built.  */\n-      if (ctor_tail)\n-\t{\n-\t  ctor_tail->next = gfc_get_constructor ();\n-\t  ctor_tail = ctor_tail->next;\n-\t}\n-      else\n-\t*ctor_head = ctor_tail = gfc_get_constructor ();\n-      gcc_assert (value);\n-      ctor_tail->expr = value;\n+      gfc_constructor_append_expr (ctor_head, value, NULL);\n \n       /* Remove the entry from the component list.  We don't want the expression\n \t value to be free'd, so set it to NULL.  */\n@@ -2266,15 +2243,14 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n \t\t\t\t bool parent)\n {\n   gfc_structure_ctor_component *comp_tail, *comp_head, *comp_iter;\n-  gfc_constructor *ctor_head, *ctor_tail;\n+  gfc_constructor_base ctor_head = NULL;\n   gfc_component *comp; /* Is set NULL when named component is first seen */\n   gfc_expr *e;\n   locus where;\n   match m;\n   const char* last_name = NULL;\n \n   comp_tail = comp_head = NULL;\n-  ctor_head = ctor_tail = NULL;\n \n   if (!parent && gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n@@ -2439,14 +2415,8 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n   else\n     gcc_assert (!comp_head);\n \n-  e = gfc_get_expr ();\n-\n-  e->expr_type = EXPR_STRUCTURE;\n-\n-  e->ts.type = BT_DERIVED;\n+  e = gfc_get_structure_constructor_expr (BT_DERIVED, 0, &where);\n   e->ts.u.derived = sym;\n-  e->where = where;\n-\n   e->value.constructor = ctor_head;\n \n   *result = e;\n@@ -2462,7 +2432,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n       gfc_free_structure_ctor_component (comp_iter);\n       comp_iter = next;\n     }\n-  gfc_free_constructor (ctor_head);\n+  gfc_constructor_free (ctor_head);\n   return MATCH_ERROR;\n }\n "}, {"sha": "2831149c757a410c08e945d7bc5d1365d56ecfbd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n #include \"data.h\"\n #include \"target-memory.h\" /* for gfc_simplify_transfer */\n+#include \"constructor.h\"\n \n /* Types used in equivalence statements.  */\n \n@@ -227,7 +228,8 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t{\n \t  sym->as->type = AS_ASSUMED_SHAPE;\n \t  for (i = 0; i < sym->as->rank; i++)\n-\t    sym->as->lower[i] = gfc_int_expr (1);\n+\t    sym->as->lower[i] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t  NULL, 1);\n \t}\n \n       if ((sym->as && sym->as->rank > 0 && sym->as->type == AS_ASSUMED_SHAPE)\n@@ -841,7 +843,7 @@ resolve_structure_cons (gfc_expr *expr)\n   symbol_attribute a;\n \n   t = SUCCESS;\n-  cons = expr->value.constructor;\n+  cons = gfc_constructor_first (expr->value.constructor);\n   /* A constructor may have references if it is the result of substituting a\n      parameter variable.  In this case we just pull out the component we\n      want.  */\n@@ -867,7 +869,7 @@ resolve_structure_cons (gfc_expr *expr)\n       && cons->expr && cons->expr->expr_type == EXPR_NULL)\n     return SUCCESS;\n \n-  for (; comp; comp = comp->next, cons = cons->next)\n+  for (; comp && cons; comp = comp->next, cons = gfc_constructor_next (cons))\n     {\n       int rank;\n \n@@ -4309,7 +4311,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   if (char_ref->u.ss.start)\n     start = gfc_copy_expr (char_ref->u.ss.start);\n   else\n-    start = gfc_int_expr (1);\n+    start = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n \n   if (char_ref->u.ss.end)\n     end = gfc_copy_expr (char_ref->u.ss.end);\n@@ -4323,7 +4325,9 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n \n   /* Length = (end - start +1).  */\n   e->ts.u.cl->length = gfc_subtract (end, start);\n-  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length, gfc_int_expr (1));\n+  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,\n+\t\t\t\tgfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t  NULL, 1));\n \n   e->ts.u.cl->length->ts.type = BT_INTEGER;\n   e->ts.u.cl->length->ts.kind = gfc_charlen_int_kind;\n@@ -4820,12 +4824,14 @@ gfc_resolve_character_operator (gfc_expr *e)\n   if (op1->ts.u.cl && op1->ts.u.cl->length)\n     e1 = gfc_copy_expr (op1->ts.u.cl->length);\n   else if (op1->expr_type == EXPR_CONSTANT)\n-    e1 = gfc_int_expr (op1->value.character.length);\n+    e1 = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t   op1->value.character.length);\n \n   if (op2->ts.u.cl && op2->ts.u.cl->length)\n     e2 = gfc_copy_expr (op2->ts.u.cl->length);\n   else if (op2->expr_type == EXPR_CONSTANT)\n-    e2 = gfc_int_expr (op2->value.character.length);\n+    e2 = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t   op2->value.character.length);\n \n   e->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n \n@@ -5690,15 +5696,16 @@ gfc_is_expandable_expr (gfc_expr *e)\n       /* Traverse the constructor looking for variables that are flavor\n \t parameter.  Parameters must be expanded since they are fully used at\n \t compile time.  */\n-      for (con = e->value.constructor; con; con = con->next)\n+      con = gfc_constructor_first (e->value.constructor);\n+      for (; con; con = gfc_constructor_next (con))\n \t{\n \t  if (con->expr->expr_type == EXPR_VARIABLE\n-\t  && con->expr->symtree\n-\t  && (con->expr->symtree->n.sym->attr.flavor == FL_PARAMETER\n+\t      && con->expr->symtree\n+\t      && (con->expr->symtree->n.sym->attr.flavor == FL_PARAMETER\n \t      || con->expr->symtree->n.sym->attr.flavor == FL_VARIABLE))\n \t    return true;\n \t  if (con->expr->expr_type == EXPR_ARRAY\n-\t    && gfc_is_expandable_expr (con->expr))\n+\t      && gfc_is_expandable_expr (con->expr))\n \t    return true;\n \t}\n     }\n@@ -7282,12 +7289,14 @@ resolve_select_type (gfc_code *code)\n   for (body = code->block; body; body = body->block)\n     {\n       c = body->ext.case_list;\n-      \n+\n       if (c->ts.type == BT_DERIVED)\n-\tc->low = c->high = gfc_int_expr (c->ts.u.derived->hash_value);\n+\tc->low = c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t\t     c->ts.u.derived->hash_value);\n+\n       else if (c->ts.type == BT_UNKNOWN)\n \tcontinue;\n-      \n+\n       /* Assign temporary to selector.  */\n       if (c->ts.type == BT_CLASS)\n \tsprintf (name, \"tmp$class$%s\", c->ts.u.derived->name);\n@@ -7543,7 +7552,8 @@ resolve_sync (gfc_code *code)\n \t       && gfc_simplify_expr (code->expr1, 0) == SUCCESS)\n \t{\n \t   gfc_constructor *cons;\n-\t   for (cons = code->expr1->value.constructor; cons; cons = cons->next)\n+\t   cons = gfc_constructor_first (code->expr1->value.constructor);\n+\t   for (; cons; cons = gfc_constructor_next (cons))\n \t     if (cons->expr->expr_type == EXPR_CONSTANT\n \t\t &&  mpz_cmp_si (cons->expr->value.integer, 1) < 0)\n \t       gfc_error (\"Imageset argument at %L must between 1 and \"\n@@ -8895,7 +8905,8 @@ resolve_charlen (gfc_charlen *cl)\n \tgfc_warning_now (\"CHARACTER variable at %L has negative length %d,\"\n \t\t\t \" the length has been set to zero\",\n \t\t\t &cl->length->where, i);\n-      gfc_replace_expr (cl->length, gfc_int_expr (0));\n+      gfc_replace_expr (cl->length,\n+\t\t\tgfc_get_int_expr (gfc_default_integer_kind, NULL, 0));\n     }\n \n   /* Check that the character length is not too large.  */\n@@ -9027,12 +9038,9 @@ build_default_init_expr (gfc_symbol *sym)\n     return NULL;\n \n   /* Now we'll try to build an initializer expression.  */\n-  init_expr = gfc_get_expr ();\n-  init_expr->expr_type = EXPR_CONSTANT;\n-  init_expr->ts.type = sym->ts.type;\n-  init_expr->ts.kind = sym->ts.kind;\n-  init_expr->where = sym->declared_at;\n-  \n+  init_expr = gfc_get_constant_expr (sym->ts.type, sym->ts.kind,\n+\t\t\t\t     &sym->declared_at);\n+\n   /* We will only initialize integers, reals, complex, logicals, and\n      characters, and only if the corresponding command-line flags\n      were set.  Otherwise, we free init_expr and return null.  */\n@@ -12398,7 +12406,8 @@ resolve_equivalence (gfc_equiv *eq)\n \t\t{\n \t\t  ref->type = REF_SUBSTRING;\n \t\t  if (start == NULL)\n-\t\t    start = gfc_int_expr (1);\n+\t\t    start = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t      NULL, 1);\n \t\t  ref->u.ss.start = start;\n \t\t  if (end == NULL && e->ts.u.cl)\n \t\t    end = gfc_copy_expr (e->ts.u.cl->length);"}, {"sha": "b909b1c2adda1e6c79efa77af4496047db62764a", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 749, "deletions": 1078, "changes": 1827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552"}, {"sha": "4356845e206f5daa997bfc50272a65c284bd22a3", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"parse.h\"\n #include \"match.h\"\n+#include \"constructor.h\"\n \n \n /* Strings for all symbol attributes.  We use these for dumping the\n@@ -3664,6 +3665,7 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n {\n   gfc_symtree *tmp_symtree;\n   gfc_symbol *tmp_sym;\n+  gfc_constructor *c;\n \n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, ptr_name);\n \t \n@@ -3725,10 +3727,11 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n   tmp_sym->value->expr_type = EXPR_STRUCTURE;\n   tmp_sym->value->ts.type = BT_DERIVED;\n   tmp_sym->value->ts.u.derived = tmp_sym->ts.u.derived;\n-  tmp_sym->value->value.constructor = gfc_get_constructor ();\n-  tmp_sym->value->value.constructor->expr = gfc_get_expr ();\n-  tmp_sym->value->value.constructor->expr->expr_type = EXPR_NULL;\n-  tmp_sym->value->value.constructor->expr->ts.is_iso_c = 1;\n+  gfc_constructor_append_expr (&tmp_sym->value->value.constructor, NULL, NULL);\n+  c = gfc_constructor_first (tmp_sym->value->value.constructor);\n+  c->expr = gfc_get_expr ();\n+  c->expr->expr_type = EXPR_NULL;\n+  c->expr->ts.is_iso_c = 1;\n   /* Must declare c_null_ptr and c_null_funptr as having the\n      PARAMETER attribute so they can be used in init expressions.  */\n   tmp_sym->attr.flavor = FL_PARAMETER;\n@@ -3934,7 +3937,8 @@ gen_shape_param (gfc_formal_arglist **head,\n       param_sym->as->upper[i] = NULL;\n     }\n   param_sym->as->rank = 1;\n-  param_sym->as->lower[0] = gfc_int_expr (1);\n+  param_sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t      NULL, 1);\n \n   /* The extent is unknown until we get it.  The length give us\n      the rank the incoming pointer.  */\n@@ -4277,7 +4281,8 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n #define NAMED_CHARKNDCST(a,b,c) case a :\n #include \"iso-c-binding.def\"\n \n-\ttmp_sym->value = gfc_int_expr (c_interop_kinds_table[s].value);\n+\ttmp_sym->value = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t \t   c_interop_kinds_table[s].value);\n \n \t/* Initialize an integer constant expression node.  */\n \ttmp_sym->attr.flavor = FL_PARAMETER;\n@@ -4307,20 +4312,16 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \n \t/* Initialize an integer constant expression node for the\n \t   length of the character.  */\n-\ttmp_sym->value = gfc_get_expr (); \n-\ttmp_sym->value->expr_type = EXPR_CONSTANT;\n-\ttmp_sym->value->ts.type = BT_CHARACTER;\n-\ttmp_sym->value->ts.kind = gfc_default_character_kind;\n-\ttmp_sym->value->where = gfc_current_locus;\n+\ttmp_sym->value = gfc_get_character_expr (gfc_default_character_kind,\n+\t\t\t\t\t\t &gfc_current_locus, NULL, 1);\n \ttmp_sym->value->ts.is_c_interop = 1;\n \ttmp_sym->value->ts.is_iso_c = 1;\n \ttmp_sym->value->value.character.length = 1;\n-\ttmp_sym->value->value.character.string = gfc_get_wide_string (2);\n \ttmp_sym->value->value.character.string[0]\n \t  = (gfc_char_t) c_interop_kinds_table[s].value;\n-\ttmp_sym->value->value.character.string[1] = '\\0';\n \ttmp_sym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\ttmp_sym->ts.u.cl->length = gfc_int_expr (1);\n+\ttmp_sym->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t     NULL, 1);\n \n \t/* May not need this in both attr and ts, but do need in\n \t   attr for writing module file.  */\n@@ -4756,8 +4757,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->attr.codimension = attr->codimension;\n       c->attr.abstract = ts->u.derived->attr.abstract;\n       c->as = (*as);\n-      c->initializer = gfc_get_expr ();\n-      c->initializer->expr_type = EXPR_NULL;\n+      c->initializer = gfc_get_null_expr (NULL);\n \n       /* Add component '$vptr'.  */\n       if (gfc_add_component (fclass, \"$vptr\", &c) == FAILURE)\n@@ -4767,8 +4767,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       gcc_assert (vtab);\n       c->ts.u.derived = vtab->ts.u.derived;\n       c->attr.pointer = 1;\n-      c->initializer = gfc_get_expr ();\n-      c->initializer->expr_type = EXPR_NULL;\n     }\n \n   /* Since the extension field is 8 bit wide, we can only have\n@@ -4842,7 +4840,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      c->ts.type = BT_INTEGER;\n \t      c->ts.kind = 4;\n \t      c->attr.access = ACCESS_PRIVATE;\n-\t      c->initializer = gfc_int_expr (derived->hash_value);\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL, derived->hash_value);\n \n \t      /* Add component '$size'.  */\n \t      if (gfc_add_component (vtype, \"$size\", &c) == FAILURE)\n@@ -4854,20 +4853,21 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t so that the correct initializer can be set later on\n \t\t (in gfc_conv_structure).  */\n \t      c->ts.u.derived = derived;\n-\t      c->initializer = gfc_int_expr (0);\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL, 0);\n \n \t      /* Add component $extends.  */\n \t      if (gfc_add_component (vtype, \"$extends\", &c) == FAILURE)\n \t\treturn NULL;\n \t      c->attr.pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n-\t      c->initializer = gfc_get_expr ();\n \t      parent = gfc_get_derived_super_type (derived);\n \t      if (parent)\n \t\t{\n \t\t  parent_vtab = gfc_find_derived_vtab (parent);\n \t\t  c->ts.type = BT_DERIVED;\n \t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n+\t\t  c->initializer = gfc_get_expr ();\n \t\t  c->initializer->expr_type = EXPR_VARIABLE;\n \t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns, 0,\n \t\t\t\t     &c->initializer->symtree);\n@@ -4876,7 +4876,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t{\n \t\t  c->ts.type = BT_DERIVED;\n \t\t  c->ts.u.derived = vtype;\n-\t\t  c->initializer->expr_type = EXPR_NULL;\n+\t\t  c->initializer = gfc_get_null_expr (NULL);\n \t\t}\n \t    }\n \t  vtab->ts.u.derived = vtype;"}, {"sha": "93e1c8c89bb70a829af41d0a4328d703a9db4076", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 51, "deletions": 62, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,5 +1,5 @@\n /* Simulate storage of variables into target memory.\n-   Copyright (C) 2007, 2008, 2009\n+   Copyright (C) 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Paul Thomas and Brooks Moses\n \n@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n+#include \"constructor.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n #include \"trans-types.h\"\n@@ -38,7 +39,8 @@ static size_t\n size_array (gfc_expr *e)\n {\n   mpz_t array_size;\n-  size_t elt_size = gfc_target_expr_size (e->value.constructor->expr);\n+  gfc_constructor *c = gfc_constructor_first (e->value.constructor);\n+  size_t elt_size = gfc_target_expr_size (c->expr);\n \n   gfc_array_size (e, &array_size);\n   return (size_t)mpz_get_ui (array_size) * elt_size;\n@@ -134,10 +136,12 @@ encode_array (gfc_expr *expr, unsigned char *buffer, size_t buffer_size)\n   int i;\n   int ptr = 0;\n \n+  gfc_constructor_base ctor = expr->value.constructor;\n+\n   gfc_array_size (expr, &array_size);\n   for (i = 0; i < (int)mpz_get_ui (array_size); i++)\n     {\n-      ptr += gfc_target_encode_expr (gfc_get_array_element (expr, i),\n+      ptr += gfc_target_encode_expr (gfc_constructor_lookup_expr (ctor, i),\n \t\t\t\t     &buffer[ptr], buffer_size - ptr);\n     }\n \n@@ -205,28 +209,29 @@ gfc_encode_character (int kind, int length, const gfc_char_t *string,\n static int\n encode_derived (gfc_expr *source, unsigned char *buffer, size_t buffer_size)\n {\n-  gfc_constructor *ctr;\n+  gfc_constructor *c;\n   gfc_component *cmp;\n   int ptr;\n   tree type;\n \n   type = gfc_typenode_for_spec (&source->ts);\n \n-  ctr = source->value.constructor;\n-  cmp = source->ts.u.derived->components;\n-  for (;ctr; ctr = ctr->next, cmp = cmp->next)\n+  for (c = gfc_constructor_first (source->value.constructor),\n+       cmp = source->ts.u.derived->components;\n+       c;\n+       c = gfc_constructor_next (c), cmp = cmp->next)\n     {\n       gcc_assert (cmp);\n-      if (!ctr->expr)\n+      if (!c->expr)\n \tcontinue;\n       ptr = TREE_INT_CST_LOW(DECL_FIELD_OFFSET(cmp->backend_decl))\n \t    + TREE_INT_CST_LOW(DECL_FIELD_BIT_OFFSET(cmp->backend_decl))/8;\n \n-      if (ctr->expr->expr_type == EXPR_NULL)\n+      if (c->expr->expr_type == EXPR_NULL)\n  \tmemset (&buffer[ptr], 0,\n \t\tint_size_in_bytes (TREE_TYPE (cmp->backend_decl)));\n       else\n-\tgfc_target_encode_expr (ctr->expr, &buffer[ptr],\n+\tgfc_target_encode_expr (c->expr, &buffer[ptr],\n \t\t\t\tbuffer_size - ptr);\n     }\n \n@@ -302,10 +307,10 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n static int\n interpret_array (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n {\n+  gfc_constructor_base base = NULL;\n   int array_size = 1;\n   int i;\n   int ptr = 0;\n-  gfc_constructor *head = NULL, *tail = NULL;\n \n   /* Calculate array size from its shape and rank.  */\n   gcc_assert (result->rank > 0 && result->shape);\n@@ -316,27 +321,19 @@ interpret_array (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n   /* Iterate over array elements, producing constructors.  */\n   for (i = 0; i < array_size; i++)\n     {\n-      if (head == NULL)\n-\thead = tail = gfc_get_constructor ();\n-      else\n-\t{\n-\t  tail->next = gfc_get_constructor ();\n-\t  tail = tail->next;\n-\t}\n+      gfc_expr *e = gfc_get_constant_expr (result->ts.type, result->ts.kind,\n+\t\t\t\t\t   &result->where);\n+      e->ts = result->ts;\n \n-      tail->where = result->where;\n-      tail->expr = gfc_constant_result (result->ts.type,\n-\t\t\t\t\t  result->ts.kind, &result->where);\n-      tail->expr->ts = result->ts;\n+      if (e->ts.type == BT_CHARACTER)\n+\te->value.character.length = result->value.character.length;\n \n-      if (tail->expr->ts.type == BT_CHARACTER)\n-\ttail->expr->value.character.length = result->value.character.length;\n+      gfc_constructor_append_expr (&base, e, &result->where);\n \n-      ptr += gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr,\n-\t\t\t\t\ttail->expr);\n+      ptr += gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e);\n     }\n-  result->value.constructor = head;\n \n+  result->value.constructor = base;\n   return ptr;\n }\n \n@@ -439,7 +436,6 @@ int\n gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n {\n   gfc_component *cmp;\n-  gfc_constructor *head = NULL, *tail = NULL;\n   int ptr;\n   tree type;\n \n@@ -452,45 +448,37 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n   /* Run through the derived type components.  */\n   for (;cmp; cmp = cmp->next)\n     {\n-      if (head == NULL)\n-\thead = tail = gfc_get_constructor ();\n-      else\n-\t{\n-\t  tail->next = gfc_get_constructor ();\n-\t  tail = tail->next;\n-\t}\n-\n-      /* The constructor points to the component.  */\n-      tail->n.component = cmp;\n-\n-      tail->expr = gfc_constant_result (cmp->ts.type, cmp->ts.kind,\n-\t\t\t\t\t&result->where);\n-      tail->expr->ts = cmp->ts;\n+      gfc_constructor *c;\n+      gfc_expr *e = gfc_get_constant_expr (cmp->ts.type, cmp->ts.kind,\n+\t\t\t\t\t   &result->where); \n+      e->ts = cmp->ts;\n \n       /* Copy shape, if needed.  */\n       if (cmp->as && cmp->as->rank)\n \t{\n \t  int n;\n \n-\t  tail->expr->expr_type = EXPR_ARRAY;\n-\t  tail->expr->rank = cmp->as->rank;\n+\t  e->expr_type = EXPR_ARRAY;\n+\t  e->rank = cmp->as->rank;\n \n-\t  tail->expr->shape = gfc_get_shape (tail->expr->rank);\n-\t  for (n = 0; n < tail->expr->rank; n++)\n+\t  e->shape = gfc_get_shape (e->rank);\n+\t  for (n = 0; n < e->rank; n++)\n \t     {\n-\t       mpz_init_set_ui (tail->expr->shape[n], 1);\n-\t       mpz_add (tail->expr->shape[n], tail->expr->shape[n],\n+\t       mpz_init_set_ui (e->shape[n], 1);\n+\t       mpz_add (e->shape[n], e->shape[n],\n \t\t\tcmp->as->upper[n]->value.integer);\n-\t       mpz_sub (tail->expr->shape[n], tail->expr->shape[n],\n+\t       mpz_sub (e->shape[n], e->shape[n],\n \t\t\tcmp->as->lower[n]->value.integer);\n \t     }\n \t}\n \n-      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n-      gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr,\n-\t\t\t\t tail->expr);\n+      c = gfc_constructor_append_expr (&result->value.constructor, e, NULL);\n \n-      result->value.constructor = head;\n+      /* The constructor points to the component.  */\n+      c->n.component = cmp;\n+\n+      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n+      gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr, e);\n     }\n     \n   return int_size_in_bytes (type);\n@@ -578,7 +566,7 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n {\n   int i;\n   int ptr;\n-  gfc_constructor *ctr;\n+  gfc_constructor *c;\n   gfc_component *cmp;\n   unsigned char *buffer;\n \n@@ -589,16 +577,16 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n      declaration.  */\n   if (e->ts.type == BT_DERIVED)\n     {\n-      ctr = e->value.constructor;\n-      cmp = e->ts.u.derived->components;\n-      for (;ctr; ctr = ctr->next, cmp = cmp->next)\n+      for (c = gfc_constructor_first (e->value.constructor),\n+\t   cmp = e->ts.u.derived->components;\n+\t   c; c = gfc_constructor_next (c), cmp = cmp->next)\n \t{\n \t  gcc_assert (cmp && cmp->backend_decl);\n-\t  if (!ctr->expr)\n+\t  if (!c->expr)\n \t    continue;\n \t    ptr = TREE_INT_CST_LOW(DECL_FIELD_OFFSET(cmp->backend_decl))\n \t\t\t+ TREE_INT_CST_LOW(DECL_FIELD_BIT_OFFSET(cmp->backend_decl))/8;\n-\t  expr_to_char (ctr->expr, &data[ptr], &chk[ptr], len);\n+\t  expr_to_char (c->expr, &data[ptr], &chk[ptr], len);\n \t}\n       return len;\n     }\n@@ -645,12 +633,13 @@ gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n       break;\n \n     case EXPR_ARRAY:\n-      for (c = e->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (e->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \t{\n \t  size_t elt_size = gfc_target_expr_size (c->expr);\n \n-\t  if (c->n.offset)\n-\t    len = elt_size * (size_t)mpz_get_si (c->n.offset);\n+\t  if (c->offset)\n+\t    len = elt_size * (size_t)mpz_get_si (c->offset);\n \n \t  len = len + gfc_merge_initializers (ts, c->expr, &data[len],\n \t\t\t\t\t      &chk[len], length - len);"}, {"sha": "0380049862e8124254c171125617e7cc3487a3bc", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"real.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n+#include \"constructor.h\"\n #include \"trans.h\"\n #include \"trans-stmt.h\"\n #include \"trans-types.h\"\n@@ -94,7 +95,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n \n static gfc_ss *gfc_walk_subexpr (gfc_ss *, gfc_expr *);\n-static bool gfc_get_array_constructor_size (mpz_t *, gfc_constructor *);\n+static bool gfc_get_array_constructor_size (mpz_t *, gfc_constructor_base);\n \n /* The contents of this structure aren't actually used, just the address.  */\n static gfc_ss gfc_ss_terminator_var;\n@@ -1014,8 +1015,9 @@ gfc_get_array_constructor_element_size (mpz_t * size, gfc_expr * expr)\n    of array constructor C.  */\n \n static bool\n-gfc_get_array_constructor_size (mpz_t * size, gfc_constructor * c)\n+gfc_get_array_constructor_size (mpz_t * size, gfc_constructor_base base)\n {\n+  gfc_constructor *c;\n   gfc_iterator *i;\n   mpz_t val;\n   mpz_t len;\n@@ -1026,7 +1028,7 @@ gfc_get_array_constructor_size (mpz_t * size, gfc_constructor * c)\n   mpz_init (val);\n \n   dynamic = false;\n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       i = c->iterator;\n       if (i && gfc_iterator_has_dynamic_bounds (i))\n@@ -1231,20 +1233,21 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n \n static void\n gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n-\t\t\t\t   tree desc, gfc_constructor * c,\n+\t\t\t\t   tree desc, gfc_constructor_base base,\n \t\t\t\t   tree * poffset, tree * offsetvar,\n \t\t\t\t   bool dynamic)\n {\n   tree tmp;\n   stmtblock_t body;\n   gfc_se se;\n   mpz_t size;\n+  gfc_constructor *c;\n \n   tree shadow_loopvar = NULL_TREE;\n   gfc_saved_var saved_loopvar;\n \n   mpz_init (size);\n-  for (; c; c = c->next)\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       /* If this is an iterator or an array, the offset must be a variable.  */\n       if ((c->iterator || c->expr->rank > 0) && INTEGER_CST_P (*poffset))\n@@ -1289,7 +1292,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  n = 0;\n \t  while (p && !(p->iterator || p->expr->expr_type != EXPR_CONSTANT))\n \t    {\n-\t      p = p->next;\n+\t      p = gfc_constructor_next (p);\n \t      n++;\n \t    }\n \t  if (n < 4)\n@@ -1332,7 +1335,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t  list = tree_cons (build_int_cst (gfc_array_index_type,\n \t\t\t\t\t\t   idx++), se.expr, list);\n \t\t  c = p;\n-\t\t  p = p->next;\n+\t\t  p = gfc_constructor_next (p);\n \t\t}\n \n \t      bound = build_int_cst (NULL_TREE, n - 1);\n@@ -1585,13 +1588,14 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n    Returns TRUE if all elements are character constants.  */\n \n bool\n-get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n+get_array_ctor_strlen (stmtblock_t *block, gfc_constructor_base base, tree * len)\n {\n+  gfc_constructor *c;\n   bool is_const;\n-  \n+\n   is_const = TRUE;\n \n-  if (c == NULL)\n+  if (gfc_constructor_first (base) == NULL)\n     {\n       if (len)\n \t*len = build_int_cstu (gfc_charlen_type_node, 0);\n@@ -1601,7 +1605,8 @@ get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n   /* Loop over all constructor elements to find out is_const, but in len we\n      want to store the length of the first, not the last, element.  We can\n      of course exit the loop as soon as is_const is found to be false.  */\n-  for (; c && is_const; c = c->next)\n+  for (c = gfc_constructor_first (base);\n+       c && is_const; c = gfc_constructor_next (c))\n     {\n       switch (c->expr->expr_type)\n \t{\n@@ -1641,17 +1646,18 @@ get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n    return zero.  Note, an empty or NULL array constructor returns zero.  */\n \n unsigned HOST_WIDE_INT\n-gfc_constant_array_constructor_p (gfc_constructor * c)\n+gfc_constant_array_constructor_p (gfc_constructor_base base)\n {\n   unsigned HOST_WIDE_INT nelem = 0;\n \n+  gfc_constructor *c = gfc_constructor_first (base);\n   while (c)\n     {\n       if (c->iterator\n \t  || c->expr->rank > 0\n \t  || c->expr->expr_type != EXPR_CONSTANT)\n \treturn 0;\n-      c = c->next;\n+      c = gfc_constructor_next (c);\n       nelem++;\n     }\n   return nelem;\n@@ -1676,7 +1682,7 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n      to tree to build an initializer.  */\n   nelem = 0;\n   list = NULL_TREE;\n-  c = expr->value.constructor;\n+  c = gfc_constructor_first (expr->value.constructor);\n   while (c)\n     {\n       gfc_init_se (&se, NULL);\n@@ -1688,7 +1694,7 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n \t\t\t\t       se.expr);\n       list = tree_cons (build_int_cst (gfc_array_index_type, nelem),\n \t\t\tse.expr, list);\n-      c = c->next;\n+      c = gfc_constructor_next (c);\n       nelem++;\n     }\n \n@@ -1702,15 +1708,17 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n   as.type = AS_EXPLICIT;\n   if (!expr->shape)\n     {\n-      as.lower[0] = gfc_int_expr (0);\n-      as.upper[0] = gfc_int_expr (nelem - 1);\n+      as.lower[0] = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+      as.upper[0] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t      NULL, nelem - 1);\n     }\n   else\n     for (i = 0; i < expr->rank; i++)\n       {\n \tint tmp = (int) mpz_get_si (expr->shape[i]);\n-\tas.lower[i] = gfc_int_expr (0);\n-\tas.upper[i] = gfc_int_expr (tmp - 1);\n+        as.lower[i] = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+        as.upper[i] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\tNULL, tmp - 1);\n       }\n \n   tmptype = gfc_get_nodesc_array_type (type, &as, PACKED_STATIC, true);\n@@ -1807,7 +1815,7 @@ constant_array_constructor_loop_size (gfc_loopinfo * loop)\n static void\n gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n {\n-  gfc_constructor *c;\n+  gfc_constructor_base c;\n   tree offset;\n   tree offsetvar;\n   tree desc;\n@@ -3557,7 +3565,6 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   tree tmp;\n   gfc_ss *loopspec[GFC_MAX_DIMENSIONS];\n   bool dynamic[GFC_MAX_DIMENSIONS];\n-  gfc_constructor *c;\n   mpz_t *cshape;\n   mpz_t i;\n \n@@ -3582,6 +3589,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n \t  if (ss->type == GFC_SS_CONSTRUCTOR)\n \t    {\n+\t      gfc_constructor_base base;\n \t      /* An unknown size constructor will always be rank one.\n \t\t Higher rank constructors will either have known shape,\n \t\t or still be wrapped in a call to reshape.  */\n@@ -3591,8 +3599,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t\t can be determined at compile time.  Prefer not to otherwise,\n \t\t since the general case involves realloc, and it's better to\n \t\t avoid that overhead if possible.  */\n-\t      c = ss->expr->value.constructor;\n-\t      dynamic[n] = gfc_get_array_constructor_size (&i, c);\n+\t      base = ss->expr->value.constructor;\n+\t      dynamic[n] = gfc_get_array_constructor_size (&i, base);\n \t      if (!dynamic[n] || !loopspec[n])\n \t\tloopspec[n] = ss;\n \t      continue;\n@@ -4117,7 +4125,8 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \n     case EXPR_ARRAY:\n       /* Create a vector of all the elements.  */\n-      for (c = expr->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n         {\n           if (c->iterator)\n             {\n@@ -4130,8 +4139,8 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \t\t\t       gfc_option.flag_max_array_constructor);\n \t      return NULL_TREE;\n \t    }\n-          if (mpz_cmp_si (c->n.offset, 0) != 0)\n-            index = gfc_conv_mpz_to_tree (c->n.offset, gfc_index_integer_kind);\n+          if (mpz_cmp_si (c->offset, 0) != 0)\n+            index = gfc_conv_mpz_to_tree (c->offset, gfc_index_integer_kind);\n           else\n             index = NULL_TREE;\n \t  mpz_init (maxval);\n@@ -4140,16 +4149,16 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n               tree tmp1, tmp2;\n \n               mpz_set (maxval, c->repeat);\n-              mpz_add (maxval, c->n.offset, maxval);\n+              mpz_add (maxval, c->offset, maxval);\n               mpz_sub_ui (maxval, maxval, 1);\n               tmp2 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n-              if (mpz_cmp_si (c->n.offset, 0) != 0)\n+              if (mpz_cmp_si (c->offset, 0) != 0)\n                 {\n-                  mpz_add_ui (maxval, c->n.offset, 1);\n+                  mpz_add_ui (maxval, c->offset, 1);\n                   tmp1 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n                 }\n               else\n-                tmp1 = gfc_conv_mpz_to_tree (c->n.offset, gfc_index_integer_kind);\n+                tmp1 = gfc_conv_mpz_to_tree (c->offset, gfc_index_integer_kind);\n \n               range = fold_build2 (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n             }"}, {"sha": "44256fb86f477b536834d31ecd5ad4b311427f32", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -144,7 +144,7 @@ void gfc_conv_descriptor_ubound_set (stmtblock_t *, tree, tree, tree);\n void gfc_add_intrinsic_ss_code (gfc_loopinfo *, gfc_ss *);\n \n /* Functions for constant array constructor processing.  */\n-unsigned HOST_WIDE_INT gfc_constant_array_constructor_p (gfc_constructor *);\n+unsigned HOST_WIDE_INT gfc_constant_array_constructor_p (gfc_constructor_base);\n tree gfc_build_constant_array_constructor (gfc_expr *, tree);\n \n /* Copy a string from src to dest.  */"}, {"sha": "9afb9351d59949505728bfb6a22bb72812ff745d", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1,6 +1,6 @@\n /* Translation of constants\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of GCC.\n@@ -349,14 +349,15 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n           || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR)\n         {\n           /* Create a new EXPR_CONSTANT expression for our local uses.  */\n-          expr = gfc_int_expr (0);\n+          expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n         }\n     }\n \n   if (expr->expr_type != EXPR_CONSTANT)\n     {\n+      gfc_expr *e = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n       gfc_error (\"non-constant initialization expression at %L\", &expr->where);\n-      se->expr = gfc_conv_constant_to_tree (gfc_int_expr (0));\n+      se->expr = gfc_conv_constant_to_tree (e);\n       return;\n     }\n "}, {"sha": "658aadb408796837e52a854e44733bc79ed06f14", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"gfortran.h\"\n #include \"pointer-set.h\"\n+#include \"constructor.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-array.h\"\n@@ -3578,7 +3579,8 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,\n \treturn check_constant_initializer (expr, ts, false, false);\n       else if (expr->expr_type != EXPR_ARRAY)\n \treturn false;\n-      for (c = expr->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \t{\n \t  if (c->iterator)\n \t    return false;\n@@ -3598,7 +3600,8 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,\n       if (expr->expr_type != EXPR_STRUCTURE)\n \treturn false;\n       cm = expr->ts.u.derived->components;\n-      for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n+      for (c = gfc_constructor_first (expr->value.constructor);\n+\t   c; c = gfc_constructor_next (c), cm = cm->next)\n \t{\n \t  if (!c->expr || cm->attr.allocatable)\n \t    continue;"}, {"sha": "42e1d34d38ccf6345979d820a5664c182f94520e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n+#include \"constructor.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n #include \"trans-types.h\"\n@@ -278,11 +279,14 @@ flatten_array_ctors_without_strlen (gfc_expr* e)\n       /* We've found what we're looking for.  */\n       if (e->ts.type == BT_CHARACTER && !e->ts.u.cl->length)\n \t{\n+\t  gfc_constructor *c;\n \t  gfc_expr* new_expr;\n+\n \t  gcc_assert (e->value.constructor);\n \n-\t  new_expr = e->value.constructor->expr;\n-\t  e->value.constructor->expr = NULL;\n+\t  c = gfc_constructor_first (e->value.constructor);\n+\t  new_expr = c->expr;\n+\t  c->expr = NULL;\n \n \t  flatten_array_ctors_without_strlen (new_expr);\n \t  gfc_replace_expr (e, new_expr);\n@@ -291,7 +295,8 @@ flatten_array_ctors_without_strlen (gfc_expr* e)\n \n       /* Otherwise, fall through to handle constructor elements.  */\n     case EXPR_STRUCTURE:\n-      for (c = e->value.constructor; c; c = c->next)\n+      for (c = gfc_constructor_first (e->value.constructor);\n+\t   c; c = gfc_constructor_next (c))\n \tflatten_array_ctors_without_strlen (c->expr);\n       break;\n \n@@ -1432,7 +1437,8 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n \t  gfc_typespec ts;\n           gfc_clear_ts (&ts);\n \n-\t  *expr = gfc_int_expr ((int)(*expr)->value.character.string[0]);\n+\t  *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t    (int)(*expr)->value.character.string[0]);\n \t  if ((*expr)->ts.kind != gfc_c_int_kind)\n \t    {\n   \t      /* The expr needs to be compatible with a C int.  If the \n@@ -1991,9 +1997,10 @@ gfc_finish_interface_mapping (gfc_interface_mapping * mapping,\n \n static void\n gfc_apply_interface_mapping_to_cons (gfc_interface_mapping * mapping,\n-\t\t\t\t     gfc_constructor * c)\n+\t\t\t\t     gfc_constructor_base base)\n {\n-  for (; c; c = c->next)\n+  gfc_constructor *c;\n+  for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n       gfc_apply_interface_mapping_to_expr (mapping, c->expr);\n       if (c->iterator)\n@@ -2101,7 +2108,9 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n \t      return false;\n \t    }\n \n-\t  tmp = gfc_add (gfc_copy_expr (sym->as->upper[d]), gfc_int_expr (1));\n+\t  tmp = gfc_add (gfc_copy_expr (sym->as->upper[d]),\n+\t\t\t\t\tgfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t\t  NULL, 1));\n \t  tmp = gfc_subtract (tmp, gfc_copy_expr (sym->as->lower[d]));\n \t  if (new_expr)\n \t    new_expr = gfc_multiply (new_expr, tmp);\n@@ -3984,12 +3993,10 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n     {\n       gfc_symbol *derived = expr->ts.u.derived;\n \n-      expr = gfc_int_expr (0);\n-\n       /* The derived symbol has already been converted to a (void *).  Use\n \t its kind.  */\n+      expr = gfc_get_int_expr (derived->ts.kind, NULL, 0);\n       expr->ts.f90_type = derived->ts.f90_type;\n-      expr->ts.kind = derived->ts.kind;\n \n       gfc_init_se (&se, NULL);\n       gfc_conv_constant (&se, expr);\n@@ -4389,7 +4396,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n \n   gfc_start_block (&block);\n   cm = expr->ts.u.derived->components;\n-  for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n+  for (c = gfc_constructor_first (expr->value.constructor);\n+       c; c = gfc_constructor_next (c), cm = cm->next)\n     {\n       /* Skip absent members in default initializers.  */\n       if (!c->expr)\n@@ -4445,7 +4453,8 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \n   cm = expr->ts.u.derived->components;\n \n-  for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n+  for (c = gfc_constructor_first (expr->value.constructor);\n+       c; c = gfc_constructor_next (c), cm = cm->next)\n     {\n       /* Skip absent members in default initializers and allocatable\n \t components.  Although the latter have a default initializer\n@@ -5619,7 +5628,7 @@ gfc_trans_class_assign (gfc_code *code)\n \t  rhs->ts = vtab->ts;\n \t}\n       else if (code->expr2->expr_type == EXPR_NULL)\n-\trhs = gfc_int_expr (0);\n+\trhs = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n       else\n \tgcc_unreachable ();\n "}, {"sha": "1ffe2842ce3b6bf3ea041e2ae5e19e2fa29d684d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -4684,15 +4684,17 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n       gfc_add_component_ref (a, \"$hash\");\n     }\n   else if (a->ts.type == BT_DERIVED)\n-    a = gfc_int_expr (a->ts.u.derived->hash_value);\n+    a = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t  a->ts.u.derived->hash_value);\n \n   if (b->ts.type == BT_CLASS)\n     {\n       gfc_add_component_ref (b, \"$vptr\");\n       gfc_add_component_ref (b, \"$hash\");\n     }\n   else if (b->ts.type == BT_DERIVED)\n-    b = gfc_int_expr (b->ts.u.derived->hash_value);\n+    b = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t  b->ts.u.derived->hash_value);\n \n   gfc_conv_expr (&se1, a);\n   gfc_conv_expr (&se2, b);"}, {"sha": "b7464d0519c380430936cd14bf9eda31c6fcb199", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -1391,21 +1391,6 @@ gfc_trans_wait (gfc_code * code)\n \n }\n \n-static gfc_expr *\n-gfc_new_nml_name_expr (const char * name)\n-{\n-   gfc_expr * nml_name;\n-\n-   nml_name = gfc_get_expr();\n-   nml_name->ref = NULL;\n-   nml_name->expr_type = EXPR_CONSTANT;\n-   nml_name->ts.kind = gfc_default_character_kind;\n-   nml_name->ts.type = BT_CHARACTER;\n-   nml_name->value.character.length = strlen(name);\n-   nml_name->value.character.string = gfc_char_to_widechar (name);\n-\n-   return nml_name;\n-}\n \n /* nml_full_name builds up the fully qualified name of a\n    derived type component.  */\n@@ -1776,7 +1761,9 @@ build_dt (tree function, gfc_code * code)\n \t  if (dt->format_expr || dt->format_label)\n \t    gfc_internal_error (\"build_dt: format with namelist\");\n \n-\t  nmlname = gfc_new_nml_name_expr (dt->namelist->name);\n+          nmlname = gfc_get_character_expr (gfc_default_character_kind, NULL,\n+\t\t\t\t\t    dt->namelist->name,\n+\t\t\t\t\t    strlen (dt->namelist->name));\n \n \t  mask |= set_string (&block, &post_block, var, IOPARM_dt_namelist_name,\n \t\t\t      nmlname);"}, {"sha": "782ff1d9e78816232589eafc44d97a2f38eb8451", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e757713c17d27acbce6bb2d2dd19f226e2e552/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b7e757713c17d27acbce6bb2d2dd19f226e2e552", "patch": "@@ -450,7 +450,7 @@ extern GTY(()) tree gfc_static_ctors;\n void gfc_generate_constructors (void);\n \n /* Get the string length of an array constructor.  */\n-bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor *, tree *);\n+bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor_base, tree *);\n \n /* Generate a runtime error call.  */\n tree gfc_trans_runtime_error (bool, locus*, const char*, ...);"}]}