{"sha": "fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJiMTg2MTM1ZGI0Yzk5MThlNWY2Y2IwZDhiNWM1Mjc5ZWQzNTZkOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-08-04T19:55:31Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-08-04T19:55:31Z"}, "message": "c-lex.c: Sync with C++ frontend.\n\n\t* c-lex.c: Sync with C++ frontend.\n\t(linemode): New variable.\n\t(parse_float): imag, conversion_errno, and type are output only.\n\t(yylex): Adjust.  Move initial '.' case into main switch.\n\tUse linemode.\n\t(handle_generic_pragma): Just deal with tokens.\n\t(readescape): Use ISXDIGIT and ISGRAPH.\n\t* c-parse.in: Add END_OF_LINE token.\n\n\t* c-lex.c (lang_init): Generalize.\n\t(nextchar): Remove.  Replace uses with UNGETC.\n\t(skip_white_space): Handle linemode here.  Optimize for cpplib.\n\t(skip_white_space_on_line): Remove.\n\t(extend_token_buffer_to): New fn.\n\t(extend_token_buffer): Use it.\n\t(read_line_number, check_newline): Just deal with tokens.\n\t(token_getch, token_put_back): New fns.\n\t(yylex): Use them.  More cpplib optimizations.  Simplify.\n\n\t* c-lex.c (init_parse): Set cpp_token to CPP_DIRECTIVE.\n\t(consume_string): Make this smart about USE_CPPLIB.\n\t(check_newline): Rewrite to be intelligent about USE_CPPLIB.\n\t(yylex): Rewrite to be intelligent about USE_CPPLIB.\n\tAlso, clean up cases where we redundantly set token_buffer[0].\n\t(read_line_number): New fn.\n\t(ignore_escape_flag): New variable.\n\nFrom-SVN: r28507", "tree": {"sha": "0b909457c993dd96ebfd9fdf0ee4b221030ae739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b909457c993dd96ebfd9fdf0ee4b221030ae739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/comments", "author": null, "committer": null, "parents": [{"sha": "825b4dde6b73d6405ab663d6a05de723b0678151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825b4dde6b73d6405ab663d6a05de723b0678151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825b4dde6b73d6405ab663d6a05de723b0678151"}], "stats": {"total": 3598, "additions": 1793, "deletions": 1805}, "files": [{"sha": "c538dc24b9db83877963b958293f74cb68fc99a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "patch": "@@ -1,3 +1,35 @@\n+Wed Aug  4 12:53:44 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* c-lex.c: Sync with C++ frontend.\n+\t(linemode): New variable.\n+\t(parse_float): imag, conversion_errno, and type are output only.\n+\t(yylex): Adjust.  Move initial '.' case into main switch.\n+\tUse linemode.\n+\t(handle_generic_pragma): Just deal with tokens.\n+\t(readescape): Use ISXDIGIT and ISGRAPH.\n+\t* c-parse.in: Add END_OF_LINE token.\n+\n+\t* c-lex.c (lang_init): Generalize.\n+\t(nextchar): Remove.  Replace uses with UNGETC.\n+\t(skip_white_space): Handle linemode here.  Optimize for cpplib.\n+\t(skip_white_space_on_line): Remove.\n+\t(extend_token_buffer_to): New fn.\n+\t(extend_token_buffer): Use it.\n+\t(read_line_number, check_newline): Just deal with tokens.\n+\t(token_getch, token_put_back): New fns.\n+\t(yylex): Use them.  More cpplib optimizations.  Simplify.\n+\n+Wed Aug  4 12:53:44 1999  Michael Tiemann  <tiemann@holodeck.cygnus.com>\n+\t\t\t  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* c-lex.c (init_parse): Set cpp_token to CPP_DIRECTIVE.\n+\t(consume_string): Make this smart about USE_CPPLIB.\n+\t(check_newline): Rewrite to be intelligent about USE_CPPLIB.\n+\t(yylex): Rewrite to be intelligent about USE_CPPLIB.\n+\tAlso, clean up cases where we redundantly set token_buffer[0].\n+\t(read_line_number): New fn.\n+\t(ignore_escape_flag): New variable.\n+\n Wed Aug  4 13:12:17 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa.md (divsi3, udivsi3, modsi3, umodsi3 expanders): Clobber a new"}, {"sha": "0201504a59271ce122bf89365c1134aed5173335", "filename": "gcc/c-lex.c", "status": "modified", "additions": 456, "deletions": 433, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "patch": "@@ -1,5 +1,5 @@\n /* Lexical analyzer for C and Objective C.\n-   Copyright (C) 1987, 88, 89, 92, 94-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -66,6 +66,7 @@ tree ridpointers[(int) RID_MAX];\n \n #if USE_CPPLIB\n extern unsigned char *yy_cur, *yy_lim;\n+extern enum cpp_token cpp_token;\n \n extern int yy_get_token ();\n \n@@ -113,6 +114,8 @@ put_back (ch)\n }\n #endif /* ! USE_CPPLIB */\n \n+int linemode;\n+\n /* the declaration found for the last IDENTIFIER token read in.\n    yylex must look this up to detect typedefs, which get token type TYPENAME,\n    so it is left around in case the identifier is not a typedef but is\n@@ -144,22 +147,19 @@ char *token_buffer;\t/* Pointer to token buffer.\n \t\t\t   Actual allocated length is maxtoken + 2.\n \t\t\t   This is not static because objc-parse.y uses it.  */\n \n-static int indent_level = 0;        /* Number of { minus number of }. */\n+static int indent_level;        /* Number of { minus number of }. */\n+\n+/* Nonzero tells yylex to ignore \\ in string constants.  */\n+static int ignore_escape_flag;\n \n /* Nonzero if end-of-file has been seen on input.  */\n static int end_of_file;\n \n-#if !USE_CPPLIB\n-/* Buffered-back input character; faster than using ungetc.  */\n-static int nextchar = -1;\n-#endif\n-\n #ifdef HANDLE_GENERIC_PRAGMAS\n static int handle_generic_pragma\tPROTO((int));\n #endif /* HANDLE_GENERIC_PRAGMAS */\n static int whitespace_cr\t\tPROTO((int));\n static int skip_white_space\t\tPROTO((int));\n-static int skip_white_space_on_line\tPROTO((void));\n static char *extend_token_buffer\tPROTO((const char *));\n static int readescape\t\t\tPROTO((int *));\n static void parse_float\t\t\tPROTO((PTR));\n@@ -246,6 +246,7 @@ init_parse (filename)\n      token buffer.  We must arrange to read it out here. */\n   yy_cur = parse_in.token_buffer;\n   yy_lim = CPP_PWRITTEN (&parse_in);\n+  cpp_token = CPP_DIRECTIVE;\n #endif\n \n   init_lex ();\n@@ -434,6 +435,11 @@ skip_white_space (c)\n \t     Also, there's no need, since cpp removes all comments.  */\n \n \tcase '\\n':\n+\t  if (linemode)\n+\t    {\n+\t      UNGETC (c);\n+\t      return EOF;\n+\t    }\n \t  c = check_newline ();\n \t  break;\n \n@@ -442,7 +448,14 @@ skip_white_space (c)\n \tcase '\\f':\n \tcase '\\v':\n \tcase '\\b':\n-\t  c = GETC();\n+#if USE_CPPLIB\n+\t  /* While processing a # directive we don't get CPP_HSPACE\n+\t     tokens, so we also need to handle whitespace the normal way.  */\n+\t  if (cpp_token == CPP_HSPACE)\n+\t    c = yy_get_token ();\n+\t  else\n+#endif\n+\t    c = GETC();\n \t  break;\n \n \tcase '\\r':\n@@ -465,70 +478,39 @@ skip_white_space (c)\n     }\n }\n \n-/* Skips all of the white space at the current location in the input file.\n-   Must use and reset nextchar if it has the next character.  */\n+/* Skips all of the white space at the current location in the input file.  */\n \n void\n position_after_white_space ()\n {\n   register int c;\n \n-#if !USE_CPPLIB\n-  if (nextchar != -1)\n-    c = nextchar, nextchar = -1;\n-  else\n-#endif\n-    c = GETC();\n+  c = GETC();\n \n   UNGETC (skip_white_space (c));\n }\n \n-/* Like skip_white_space, but don't advance beyond the end of line.\n-   Moreover, we don't get passed a character to start with.  */\n-static int\n-skip_white_space_on_line ()\n-{\n-  register int c;\n-\n-  while (1)\n-    {\n-      c = GETC();\n-      switch (c)\n-\t{\n-\tcase '\\n':\n-\tdefault:\n-\t  break;\n-\n-\tcase ' ':\n-\tcase '\\t':\n-\tcase '\\f':\n-\tcase '\\v':\n-\tcase '\\b':\n-\t  continue;\n-\n-\tcase '\\r':\n-\t  whitespace_cr (c);\n-\t  continue;\n-\t}\n-      break;\n-    }\n-  return c;\n-}\n-\n /* Make the token buffer longer, preserving the data in it.\n    P should point to just beyond the last valid character in the old buffer.\n    The value we return is a pointer to the new buffer\n    at a place corresponding to P.  */\n \n+static void\n+extend_token_buffer_to (size)\n+     int size;\n+{\n+  do\n+    maxtoken = maxtoken * 2 + 10;\n+  while (maxtoken < size);\n+  token_buffer = (char *) xrealloc (token_buffer, maxtoken + 2);\n+}\n+\n static char *\n extend_token_buffer (p)\n      const char *p;\n {\n   int offset = p - token_buffer;\n-\n-  maxtoken = maxtoken * 2 + 10;\n-  token_buffer = (char *) xrealloc (token_buffer, maxtoken + 2);\n-\n+  extend_token_buffer_to (offset);\n   return token_buffer + offset;\n }\n \f\n@@ -548,352 +530,327 @@ pragma_ungetc (arg)\n }\n #endif\n \n+static int\n+read_line_number (num)\n+     int *num;\n+{\n+  register int token = yylex ();\n+\n+  if (token == CONSTANT\n+      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n+    {\n+      *num = TREE_INT_CST_LOW (yylval.ttype);\n+      return 1;\n+    }\n+  else\n+    {\n+      if (token != END_OF_LINE)\n+\terror (\"invalid #-line\");\n+      return 0;\n+    }\n+}\n+  \n /* At the beginning of a line, increment the line number\n    and process any #-directive on this line.\n    If the line is a #-directive, read the entire line and return a newline.\n-   Otherwise, return the line's first non-whitespace character.  */\n+   Otherwise, return the line's first non-whitespace character.\n+\n+   Note that in the case of USE_CPPLIB, we get the whole line as one\n+   CPP_DIRECTIVE token.  */\n \n int\n check_newline ()\n {\n   register int c;\n   register int token;\n+  int saw_line;\n+  enum { act_none, act_push, act_pop } action;\n+  int old_lineno, action_number, l;\n \n-  lineno++;\n-\n+ restart:\n   /* Read first nonwhite char on the line.  */\n \n-  c = GETC();\n-  while (c == ' ' || c == '\\t')\n-    c = GETC();\n+#ifdef USE_CPPLIB\n+  c = GETC ();\n+  /* In some cases where we're leaving an include file, we can get multiple\n+     CPP_HSPACE tokens in a row, so we need to loop.  */\n+  while (cpp_token == CPP_HSPACE)\n+    c = yy_get_token ();\n+#else\n+  do\n+    c = GETC ();\n+  while (c == ' ' || c == '\\t');\n+#endif\n+\n+  lineno++;\n \n   if (c != '#')\n     {\n+      /* Sequences of multiple newlines are very common; optimize them.  */\n+      if (c == '\\n')\n+\tgoto restart;\n+\n       /* If not #, return it so caller will use it.  */\n       return c;\n     }\n \n-  /* Read first nonwhite char after the `#'.  */\n-\n-  c = GETC();\n-  while (c == ' ' || c == '\\t')\n-    c = GETC();\n+  /* Don't read beyond this line.  */\n+  saw_line = 0;\n+  linemode = 1;\n+  \n+#if USE_CPPLIB\n+  if (cpp_token == CPP_VSPACE)\n+    {\n+      /* Format is \"<space> <line number> <filename> <newline>\".\n+\t Only the line number is interesting, and even that\n+\t we can get more efficiently than scanning the line.  */\n+      yy_cur = yy_lim - 1;\n+      lineno = parse_in.lineno - 1;\n+      goto skipline;\n+    }\n+#endif\n \n-  /* If a letter follows, then if the word here is `line', skip\n-     it and ignore it; otherwise, ignore the line, with an error\n-     if the word isn't `pragma', `ident', `define', or `undef'.  */\n+  token = yylex ();\n \n-  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n+  if (token == IDENTIFIER)\n     {\n-      if (c == 'p')\n-\t{\n-\t  if (GETC() == 'r'\n-\t      && GETC() == 'a'\n-\t      && GETC() == 'g'\n-\t      && GETC() == 'm'\n-\t      && GETC() == 'a'\n-\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'\n-\t\t   || whitespace_cr (c) ))\n-\t    {\n-\t      while (c == ' ' || c == '\\t' || whitespace_cr (c))\n-\t\tc = GETC ();\n-\t      if (c == '\\n')\n-\t\treturn c;\n-\n-#if defined HANDLE_PRAGMA || defined HANDLE_GENERIC_PRAGMAS\n-\t      UNGETC (c);\n-\t      token = yylex ();\n-\t      if (token != IDENTIFIER)\n-\t\tgoto skipline;\n-#endif /* HANDLE_PRAGMA || HANDLE_GENERIC_PRAGMAS */\n+      /* If a letter follows, then if the word here is `line', skip\n+\t it and ignore it; otherwise, ignore the line, with an error\n+\t if the word isn't `pragma'.  */\n \n-#ifdef HANDLE_PRAGMA\n-\t      /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS (if\n-\t\t both are defined), in order to give the back end a chance to\n-\t\t override the interpretation of generic style pragmas.  */\n-#if !USE_CPPLIB\n-\t      if (nextchar >= 0)\n-\t\t{\n-\t\t  c = nextchar, nextchar = -1;\n-\t\t  UNGETC (c);\n-\t\t}\n-#endif /* !USE_CPPLIB */\n+      const char *name = IDENTIFIER_POINTER (yylval.ttype);\n \n-\t      if (TREE_CODE (yylval.ttype) != IDENTIFIER_NODE)\n-\t\tgoto skipline;\n+      if (!strcmp (name, \"pragma\"))\n+\t{\n+\t  token = yylex ();\n+\t  if (token != IDENTIFIER\n+\t      || TREE_CODE (yylval.ttype) != IDENTIFIER_NODE)\n+\t    goto skipline;\n \n-\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n-\t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n-\t\treturn GETC ();\n+#ifdef HANDLE_PRAGMA\n+\t  /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS\n+\t     (if both are defined), in order to give the back\n+\t     end a chance to override the interpretation of\n+\t     SYSV style pragmas.  */\n+\t  if (HANDLE_PRAGMA (getch, put_back,\n+\t\t\t     IDENTIFIER_POINTER (yylval.ttype)))\n+\t    goto skipline;\n #endif /* HANDLE_PRAGMA */\n-\n+\t      \n #ifdef HANDLE_GENERIC_PRAGMAS\n-\t      if (handle_generic_pragma (token))\n-\t\treturn GETC ();\n+\t  if (handle_generic_pragma (token))\n+\t    goto skipline;\n #endif /* HANDLE_GENERIC_PRAGMAS */\n \n-\t      /* Issue a warning message if we have been asked to do so.\n-\t\t Ignoring unknown pragmas in system header file unless\n-\t\t an explcit -Wunknown-pragmas has been given. */\n-\t      if (warn_unknown_pragmas > 1\n-\t\t  || (warn_unknown_pragmas && ! in_system_header))\n-\t\twarning (\"ignoring pragma: %s\", token_buffer);\n+\t  /* Issue a warning message if we have been asked to do so.\n+\t     Ignoring unknown pragmas in system header file unless\n+\t     an explcit -Wunknown-pragmas has been given. */\n+\t  if (warn_unknown_pragmas > 1\n+\t      || (warn_unknown_pragmas && ! in_system_header))\n+\t    warning (\"ignoring pragma: %s\", token_buffer);\n \n-\t      goto skipline;\n-\t    }\n+\t  goto skipline;\n \t}\n-\n-      else if (c == 'd')\n+      else if (!strcmp (name, \"define\"))\n \t{\n-\t  if (GETC() == 'e'\n-\t      && GETC() == 'f'\n-\t      && GETC() == 'i'\n-\t      && GETC() == 'n'\n-\t      && GETC() == 'e'\n-\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'))\n-\t    {\n-\t      if (c != '\\n')\n-\t\tdebug_define (lineno, GET_DIRECTIVE_LINE ());\n-\t      goto skipline;\n-\t    }\n+\t  debug_define (lineno, GET_DIRECTIVE_LINE ());\n+\t  goto skipline;\n \t}\n-      else if (c == 'u')\n+      else if (!strcmp (name, \"undef\"))\n \t{\n-\t  if (GETC() == 'n'\n-\t      && GETC() == 'd'\n-\t      && GETC() == 'e'\n-\t      && GETC() == 'f'\n-\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'))\n-\t    {\n-\t      if (c != '\\n')\n-\t\tdebug_undef (lineno, GET_DIRECTIVE_LINE ());\n-\t      goto skipline;\n-\t    }\n+\t  debug_undef (lineno, GET_DIRECTIVE_LINE ());\n+\t  goto skipline;\n \t}\n-      else if (c == 'l')\n+      else if (!strcmp (name, \"line\"))\n \t{\n-\t  if (GETC() == 'i'\n-\t      && GETC() == 'n'\n-\t      && GETC() == 'e'\n-\t      && ((c = GETC()) == ' ' || c == '\\t'))\n-\t    goto linenum;\n+\t  saw_line = 1;\n+\t  token = yylex ();\n+\t  goto linenum;\n \t}\n-      else if (c == 'i')\n+      else if (!strcmp (name, \"ident\"))\n \t{\n-\t  if (GETC() == 'd'\n-\t      && GETC() == 'e'\n-\t      && GETC() == 'n'\n-\t      && GETC() == 't'\n-\t      && ((c = GETC()) == ' ' || c == '\\t'))\n-\t    {\n-\t      /* #ident.  The pedantic warning is now in cccp.c.  */\n-\n-\t      /* Here we have just seen `#ident '.\n-\t\t A string constant should follow.  */\n+\t  /* #ident.  The pedantic warning is now in cccp.c.  */\n \n-\t      c = skip_white_space_on_line ();\n+\t  /* Here we have just seen `#ident '.\n+\t     A string constant should follow.  */\n \n-\t      /* If no argument, ignore the line.  */\n-\t      if (c == '\\n')\n-\t\treturn c;\n-\n-\t      UNGETC (c);\n-\t      token = yylex ();\n-\t      if (token != STRING\n-\t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t{\n-\t\t  error (\"invalid #ident\");\n-\t\t  goto skipline;\n-\t\t}\n+\t  token = yylex ();\n+\t  if (token == END_OF_LINE)\n+\t    goto skipline;\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid #ident\");\n+\t      goto skipline;\n+\t    }\n \n-\t      if (!flag_no_ident)\n-\t\t{\n+\t  if (! flag_no_ident)\n+\t    {\n #ifdef ASM_OUTPUT_IDENT\n-\t\t  ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (yylval.ttype));\n+\t      ASM_OUTPUT_IDENT (asm_out_file,\n+\t\t\t\tTREE_STRING_POINTER (yylval.ttype));\n #endif\n-\t\t}\n-\n-\t      /* Skip the rest of this line.  */\n-\t      goto skipline;\n \t    }\n+\n+\t  /* Skip the rest of this line.  */\n+\t  goto skipline;\n \t}\n \n-      error (\"undefined or invalid # directive\");\n+      error (\"undefined or invalid # directive `%s'\", name);\n       goto skipline;\n     }\n \n+  /* If the # is the only nonwhite char on the line,\n+     just ignore it.  Check the new newline.  */\n+  if (token == END_OF_LINE)\n+    goto skipline;\n+\n linenum:\n   /* Here we have either `#line' or `# <nonletter>'.\n      In either case, it should be a line number; a digit should follow.  */\n \n-  /* Can't use skip_white_space here, but must handle all whitespace\n-     that is not '\\n', lest we get a recursion for '\\r' '\\n' when\n-     calling yylex.  */\n-  UNGETC (c);\n-  c = skip_white_space_on_line ();\n+  if (token != CONSTANT\n+      || TREE_CODE (yylval.ttype) != INTEGER_CST)\n+    {\n+      error (\"invalid #-line\");\n+      goto skipline;\n+    }\n \n-  /* If the # is the only nonwhite char on the line,\n-     just ignore it.  Check the new newline.  */\n-  if (c == '\\n')\n-    return c;\n+  /* subtract one, because it is the following line that\n+     gets the specified number */\n \n-  /* Something follows the #; read a token.  */\n+  l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n \n-  UNGETC (c);\n-  token = yylex ();\n+  /* More follows: it must be a string constant (filename).\n+     It would be neat to use cpplib to quickly process the string, but\n+     (1) we don't have a handy tokenization of the string, and\n+     (2) I don't know how well that would work in the presense\n+     of filenames that contain wide characters.  */\n \n-  if (token == CONSTANT\n-      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n+  if (saw_line)\n     {\n-      int old_lineno = lineno;\n-      int used_up = 0;\n-      /* subtract one, because it is the following line that\n-\t gets the specified number */\n-\n-      int l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n+      /* Don't treat \\ as special if we are processing #line 1 \"...\".\n+\t If you want it to be treated specially, use # 1 \"...\".  */\n+      ignore_escape_flag = 1;\n+    }\n \n-      /* Is this the last nonwhite stuff on the line?  */\n-      c = skip_white_space_on_line ();\n-      if (c == '\\n')\n-\t{\n-\t  /* No more: store the line number and check following line.  */\n-\t  lineno = l;\n-\t  return c;\n-\t}\n-      UNGETC (c);\n+  /* Read the string constant.  */\n+  token = yylex ();\n \n-      /* More follows: it must be a string constant (filename).  */\n+  ignore_escape_flag = 0;\n \n-      /* Read the string constant.  */\n-      token = yylex ();\n+  if (token == END_OF_LINE)\n+    {\n+      /* No more: store the line number and check following line.  */\n+      lineno = l;\n+      goto skipline;\n+    }\n \n-      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t{\n-\t  error (\"invalid #line\");\n-\t  goto skipline;\n-\t}\n+  if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+    {\n+      error (\"invalid #line\");\n+      goto skipline;\n+    }\n \n+  if (!TREE_PERMANENT (yylval.ttype))\n+    {\n       input_filename\n \t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n       strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));\n-      lineno = l;\n-\n-      /* Each change of file name\n-\t reinitializes whether we are now in a system header.  */\n-      in_system_header = 0;\n-\n-      if (main_input_filename == 0)\n-\tmain_input_filename = input_filename;\n-\n-      /* Is this the last nonwhite stuff on the line?  */\n-      c = skip_white_space_on_line ();\n-      if (c == '\\n')\n-\t{\n-\t  /* Update the name in the top element of input_file_stack.  */\n-\t  if (input_file_stack)\n-\t    input_file_stack->name = input_filename;\n-\n-\t  return c;\n-\t}\n-      UNGETC (c);\n-\n-      token = yylex ();\n-      used_up = 0;\n+    }\n+  else\n+    input_filename = TREE_STRING_POINTER (yylval.ttype);\n \n-      /* `1' after file name means entering new file.\n-\t `2' after file name means just left a file.  */\n+  if (main_input_filename == 0)\n+    main_input_filename = input_filename;\n \n-      if (token == CONSTANT\n-\t  && TREE_CODE (yylval.ttype) == INTEGER_CST)\n-\t{\n-\t  if (TREE_INT_CST_LOW (yylval.ttype) == 1)\n-\t    {\n-\t      /* Pushing to a new file.  */\n-\t      struct file_stack *p\n-\t\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n-\t      input_file_stack->line = old_lineno;\n-\t      p->next = input_file_stack;\n-\t      p->name = input_filename;\n-\t      p->indent_level = indent_level;\n-\t      input_file_stack = p;\n-\t      input_file_stack_tick++;\n-\t      debug_start_source_file (input_filename);\n-\t      used_up = 1;\n-\t    }\n-\t  else if (TREE_INT_CST_LOW (yylval.ttype) == 2)\n-\t    {\n-\t      /* Popping out of a file.  */\n-\t      if (input_file_stack->next)\n-\t\t{\n-\t\t  struct file_stack *p = input_file_stack;\n-\t\t  if (indent_level != p->indent_level)\n-\t\t    {\n-\t\t      warning_with_file_and_line\n-\t\t\t(p->name, old_lineno,\n-\t\t\t \"This file contains more `%c's than `%c's.\",\n-\t\t\t indent_level > p->indent_level ? '{' : '}',\n-\t\t\t indent_level > p->indent_level ? '}' : '{');\n-\t\t    }\n-\t\t  input_file_stack = p->next;\n-\t\t  free (p);\n-\t\t  input_file_stack_tick++;\n-\t\t  debug_end_source_file (input_file_stack->line);\n-\t\t}\n-\t      else\n-\t\terror (\"#-lines for entering and leaving files don't match\");\n+  old_lineno = lineno;\n+  action = act_none;\n+  action_number = 0;\n+  lineno = l;\n \n-\t      used_up = 1;\n-\t    }\n-\t}\n+  /* Each change of file name\n+     reinitializes whether we are now in a system header.  */\n+  in_system_header = 0;\n \n-      /* Now that we've pushed or popped the input stack,\n-\t update the name in the top element.  */\n+  if (!read_line_number (&action_number))\n+    {\n+      /* Update the name in the top element of input_file_stack.  */\n       if (input_file_stack)\n \tinput_file_stack->name = input_filename;\n+    }\n \n-      /* If we have handled a `1' or a `2',\n-\t see if there is another number to read.  */\n-      if (used_up)\n-\t{\n-\t  /* Is this the last nonwhite stuff on the line?  */\n-\t  c = skip_white_space_on_line ();\n-\t  if (c == '\\n')\n-\t    return c;\n-\t  UNGETC (c);\n-\n-\t  token = yylex ();\n-\t  used_up = 0;\n-\t}\n+  /* `1' after file name means entering new file.\n+     `2' after file name means just left a file.  */\n \n+  if (action_number == 1)\n+    {\n+      action = act_push;\n+      read_line_number (&action_number);\n+    }\n+  else if (action_number == 2)\n+    {\n+      action = act_pop;\n+      read_line_number (&action_number);\n+    }\n+  if (action_number == 3)\n+    {\n       /* `3' after file name means this is a system header file.  */\n+      in_system_header = 1;\n+      read_line_number (&action_number);\n+    }\n \n-      if (token == CONSTANT\n-\t  && TREE_CODE (yylval.ttype) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (yylval.ttype) == 3)\n-\tin_system_header = 1, used_up = 1;\n+  /* Do the actions implied by the preceding numbers.  */\n \n-      if (used_up)\n+  if (action == act_push)\n+    {\n+      /* Pushing to a new file.  */\n+      struct file_stack *p\n+\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+      input_file_stack->line = old_lineno;\n+      p->next = input_file_stack;\n+      p->name = input_filename;\n+      p->indent_level = indent_level;\n+      input_file_stack = p;\n+      input_file_stack_tick++;\n+      debug_start_source_file (input_filename);\n+    }\n+  else if (action == act_pop)\n+    {\n+      /* Popping out of a file.  */\n+      if (input_file_stack->next)\n \t{\n-\t  /* Is this the last nonwhite stuff on the line?  */\n-\t  c = skip_white_space_on_line ();\n-\t  if (c == '\\n')\n-\t    return c;\n-\t  UNGETC (c);\n+\t  struct file_stack *p = input_file_stack;\n+\t  if (indent_level != p->indent_level)\n+\t    {\n+\t      warning_with_file_and_line\n+\t\t(p->name, old_lineno,\n+\t\t \"This file contains more `%c's than `%c's.\",\n+\t\t indent_level > p->indent_level ? '{' : '}',\n+\t\t indent_level > p->indent_level ? '}' : '{');\n+\t    }\n+\t  input_file_stack = p->next;\n+\t  free (p);\n+\t  input_file_stack_tick++;\n+\t  debug_end_source_file (input_file_stack->line);\n \t}\n-\n-      warning (\"unrecognized text at end of #line\");\n+      else\n+\terror (\"#-lines for entering and leaving files don't match\");\n     }\n-  else\n-    error (\"invalid #-line\");\n+\n+  /* Now that we've pushed or popped the input stack,\n+     update the name in the top element.  */\n+  if (input_file_stack)\n+    input_file_stack->name = input_filename;\n \n   /* skip the rest of this line.  */\n  skipline:\n-#if !USE_CPPLIB\n-  if (c != '\\n' && c != EOF && nextchar >= 0)\n-    c = nextchar, nextchar = -1;\n-#endif\n-  while (c != '\\n' && c != EOF)\n+  linemode = 0;\n+  end_of_file = 0;\n+\n+  do\n     c = GETC();\n+  while (c != '\\n' && c != EOF);\n   return c;\n }\n \f\n@@ -922,22 +879,13 @@ handle_generic_pragma (token)\n \tcase CONSTANT:\n \t  handle_pragma_token (token_buffer, yylval.ttype);\n \t  break;\n+\n+\tcase END_OF_LINE:\n+\t  return handle_pragma_token (NULL_PTR, NULL_TREE);\n+\n \tdefault:\n \t  handle_pragma_token (token_buffer, NULL);\n \t}\n-#if !USE_CPPLIB\n-      if (nextchar >= 0)\n-\tc = nextchar, nextchar = -1;\n-      else\n-#endif\n-\tc = GETC ();\n-\n-      while (c == ' ' || c == '\\t')\n-\tc = GETC ();\n-      UNGETC (c);\n-\n-      if (c == '\\n' || c == EOF)\n-\treturn handle_pragma_token (NULL, NULL);\n \n       token = yylex ();\n     }\n@@ -975,9 +923,7 @@ readescape (ignore_ptr)\n       while (1)\n \t{\n \t  c = GETC();\n-\t  if (!(c >= 'a' && c <= 'f')\n-\t      && !(c >= 'A' && c <= 'F')\n-\t      && !(c >= '0' && c <= '9'))\n+\t  if (! ISXDIGIT (c))\n \t    {\n \t      UNGETC (c);\n \t      break;\n@@ -1004,7 +950,9 @@ readescape (ignore_ptr)\n \t;\n       else if ((count - 1) * 4 >= TYPE_PRECISION (integer_type_node)\n \t       || (count > 1\n-\t\t   && (((unsigned)1 << (TYPE_PRECISION (integer_type_node) - (count - 1) * 4))\n+\t\t   && (((unsigned)1\n+\t\t\t<< (TYPE_PRECISION (integer_type_node)\n+\t\t\t    - (count - 1) * 4))\n \t\t       <= firstdig)))\n \tpedwarn (\"hex escape out of range\");\n       return code;\n@@ -1075,10 +1023,10 @@ readescape (ignore_ptr)\n       /* `\\%' is used to prevent SCCS from getting confused.  */\n     case '%':\n       if (pedantic)\n-\tpedwarn (\"non-ANSI escape sequence `\\\\%c'\", c);\n+\tpedwarn (\"unknown escape sequence `\\\\%c'\", c);\n       return c;\n     }\n-  if (c >= 040 && c < 0177)\n+  if (ISGRAPH (c))\n     pedwarn (\"unknown escape sequence `\\\\%c'\", c);\n   else\n     pedwarn (\"unknown escape sequence: `\\\\' followed by char code 0x%x\", c);\n@@ -1135,10 +1083,10 @@ struct pf_args\n   char * p;\n   /* I/O */\n   int c;\n+  /* Output */\n   int imag;\n   tree type;\n   int conversion_errno;\n-  /* Output */\n   REAL_VALUE_TYPE value;\n };\n  \n@@ -1153,6 +1101,9 @@ parse_float (data)\n      REAL_VALUE_ATOF may not work any more.  */\n   char *copy = (char *) alloca (args->p - token_buffer + 1);\n   bcopy (token_buffer, copy, args->p - token_buffer + 1);\n+  args->imag = 0;\n+  args->conversion_errno = 0;\n+  args->type = double_type_node;\n \n   while (1)\n     {\n@@ -1242,6 +1193,36 @@ parse_float (data)\n     }\n }\n  \n+/* Get the next character, staying within the current token if possible.\n+   If we're lexing a token, we don't want to look beyond the end of the\n+   token cpplib has prepared for us; otherwise, we end up reading in the\n+   next token, which screws up feed_input.  So just return a null\n+   character.  */\n+\n+inline int\n+token_getch ()\n+{\n+#if USE_CPPLIB\n+  if (yy_cur == yy_lim)\n+    return '\\0';\n+#endif\n+  return GETC ();\n+}\n+\n+inline void\n+token_put_back (ch)\n+     int ch;\n+{\n+#if USE_CPPLIB\n+  if (ch == '\\0')\n+    return;\n+#endif\n+  UNGETC (ch);\n+}\n+\n+/* Read a single token from the input stream, and assign it lexical\n+   semantics.  */\n+\n int\n yylex ()\n {\n@@ -1251,12 +1232,7 @@ yylex ()\n   int wide_flag = 0;\n   int objc_flag = 0;\n \n-#if !USE_CPPLIB\n-  if (nextchar >= 0)\n-    c = nextchar, nextchar = -1;\n-  else\n-#endif\n-    c = GETC();\n+  c = GETC();\n \n   /* Effectively do c = skip_white_space (c)\n      but do it faster in the usual cases.  */\n@@ -1268,7 +1244,12 @@ yylex ()\n       case '\\f':\n       case '\\v':\n       case '\\b':\n-\tc = GETC();\n+#if USE_CPPLIB\n+\tif (cpp_token == CPP_HSPACE)\n+\t  c = yy_get_token ();\n+\telse\n+#endif\n+\t  c = GETC();\n \tbreak;\n \n       case '\\r':\n@@ -1293,13 +1274,20 @@ yylex ()\n     case EOF:\n       end_of_file = 1;\n       token_buffer[0] = 0;\n-      value = ENDFILE;\n+      if (linemode)\n+\tvalue = END_OF_LINE;\n+      else\n+\tvalue = ENDFILE;\n       break;\n \n     case 'L':\n+#if USE_CPPLIB\n+      if (cpp_token == CPP_NAME)\n+\tgoto letter;\n+#endif\n       /* Capital L may start a wide-string or wide-character constant.  */\n       {\n-\tregister int c = GETC();\n+\tregister int c = token_getch();\n \tif (c == '\\'')\n \t  {\n \t    wide_flag = 1;\n@@ -1310,7 +1298,7 @@ yylex ()\n \t    wide_flag = 1;\n \t    goto string_constant;\n \t  }\n-\tUNGETC (c);\n+\ttoken_put_back (c);\n       }\n       goto letter;\n \n@@ -1323,13 +1311,13 @@ yylex ()\n       else\n \t{\n \t  /* '@' may start a constant string object.  */\n-\t  register int c = GETC ();\n+\t  register int c = token_getch ();\n \t  if (c == '\"')\n \t    {\n \t      objc_flag = 1;\n \t      goto string_constant;\n \t    }\n-\t  UNGETC (c);\n+\t  token_put_back (c);\n \t  /* Fall through to treat '@' as the start of an identifier.  */\n \t}\n \n@@ -1348,31 +1336,45 @@ yylex ()\n     case '_':\n     case '$':\n     letter:\n-      p = token_buffer;\n-      while (ISALNUM (c) || c == '_' || c == '$' || c == '@')\n+#if USE_CPPLIB\n+      if (cpp_token == CPP_NAME)\n+\t{\n+\t  /* Note that one character has already been read from\n+\t     yy_cur into token_buffer.  Also, cpplib complains about\n+\t     $ in identifiers, so we don't have to.  */\n+\n+\t  int len = yy_lim - yy_cur + 1;\n+\t  if (len >= maxtoken)\n+\t    extend_token_buffer_to (len + 1);\n+\t  memcpy (token_buffer + 1, yy_cur, len);\n+\t  p = token_buffer + len;\n+\t  yy_cur = yy_lim;\n+\t}\n+      else\n+#endif\n \t{\n-\t  /* Make sure this char really belongs in an identifier.  */\n-\t  if (c == '$')\n+\t  p = token_buffer;\n+\t  while (ISALNUM (c) || c == '_' || c == '$' || c == '@')\n \t    {\n-\t      if (! dollars_in_ident)\n-\t\terror (\"`$' in identifier\");\n-\t      else if (pedantic)\n-\t\tpedwarn (\"`$' in identifier\");\n-\t    }\n+\t      /* Make sure this char really belongs in an identifier.  */\n+\t      if (c == '$')\n+\t\t{\n+\t\t  if (! dollars_in_ident)\n+\t\t    error (\"`$' in identifier\");\n+\t\t  else if (pedantic)\n+\t\t    pedwarn (\"`$' in identifier\");\n+\t\t}\n \n-\t  if (p >= token_buffer + maxtoken)\n-\t    p = extend_token_buffer (p);\n+\t      if (p >= token_buffer + maxtoken)\n+\t\tp = extend_token_buffer (p);\n \n-\t  *p++ = c;\n-\t  c = GETC();\n-\t}\n+\t      *p++ = c;\n+\t      c = token_getch();\n+\t    }\n \n-      *p = 0;\n-#if USE_CPPLIB\n-      UNGETC (c);\n-#else\n-      nextchar = c;\n-#endif\n+\t  *p = 0;\n+\t  token_put_back (c);\n+\t}\n \n       value = IDENTIFIER;\n       yylval.itype = 0;\n@@ -1452,16 +1454,53 @@ yylex ()\n \n       break;\n \n+    case '.':\n+#if USE_CPPLIB\n+      if (yy_cur < yy_lim)\n+#endif\n+\t{\n+\t  /* It's hard to preserve tokenization on '.' because\n+\t     it could be a symbol by itself, or it could be the\n+\t     start of a floating point number and cpp won't tell us.  */\n+\t  register int c1 = token_getch ();\n+\t  token_buffer[1] = c1;\n+\t  if (c1 == '.')\n+\t    {\n+\t      c1 = token_getch ();\n+\t      if (c1 == '.')\n+\t\t{\n+\t\t  token_buffer[2] = c1;\n+\t\t  token_buffer[3] = 0;\n+\t\t  value = ELLIPSIS;\n+\t\t  goto done;\n+\t\t}\n+\t      error (\"parse error at `..'\");\n+\t    }\n+\t  if (ISDIGIT (c1))\n+\t    {\n+\t      token_put_back (c1);\n+\t      goto number;\n+\t    }\n+\t  token_put_back (c1);\n+\t}\n+      value = '.';\n+      token_buffer[1] = 0;\n+      break;\n+\n     case '0':  case '1':\n+      /* Optimize for most frequent case.  */\n       {\n-\tint next_c;\n-\t/* Check first for common special case:  single-digit 0 or 1.  */\n+\tregister int cond;\n \n-\tnext_c = GETC ();\n-\tUNGETC (next_c);\t/* Always undo this lookahead.  */\n-\tif (!ISALNUM (next_c) && next_c != '.')\n+#if USE_CPPLIB\n+\tcond = (yy_cur == yy_lim);\n+#else\n+\tregister int c1 = token_getch ();\n+\ttoken_put_back (c1);\n+\tcond = (! ISALNUM (c1) && c1 != '.');\n+#endif\n+\tif (cond)\n \t  {\n-\t    token_buffer[0] = (char)c,  token_buffer[1] = '\\0';\n \t    yylval.ttype = (c == '0') ? integer_zero_node : integer_one_node;\n \t    value = CONSTANT;\n \t    break;\n@@ -1470,7 +1509,7 @@ yylex ()\n       }\n     case '2':  case '3':  case '4':\n     case '5':  case '6':  case '7':  case '8':  case '9':\n-    case '.':\n+    number:\n       {\n \tint base = 10;\n \tint count = 0;\n@@ -1489,7 +1528,7 @@ yylex ()\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n \tunsigned int parts[TOTAL_PARTS];\n \n-\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON}\n+\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON }\n \t  floatflag = NOT_FLOAT;\n \n \tfor (count = 0; count < TOTAL_PARTS; count++)\n@@ -1500,11 +1539,11 @@ yylex ()\n \n \tif (c == '0')\n \t  {\n-\t    *p++ = (c = GETC());\n+\t    *p++ = (c = token_getch());\n \t    if ((c == 'x') || (c == 'X'))\n \t      {\n \t\tbase = 16;\n-\t\t*p++ = (c = GETC());\n+\t\t*p++ = (c = token_getch());\n \t      }\n \t    /* Leading 0 forces octal unless the 0 is the only digit.  */\n \t    else if (c >= '0' && c <= '9')\n@@ -1527,7 +1566,7 @@ yylex ()\n \t    if (c == '.')\n \t      {\n \t\tif (base == 16 && pedantic)\n-\t\t  error (\"floating constant may not be in radix 16\");\n+\t\t  pedwarn (\"floating constant may not be in radix 16\");\n \t\tif (floatflag == TOO_MANY_POINTS)\n \t\t  /* We have already emitted an error.  Don't need another.  */\n \t\t  ;\n@@ -1544,29 +1583,11 @@ yylex ()\n \n \t\tif (base == 8)\n \t\t  base = 10;\n-\t\t*p++ = c = GETC();\n+\t\t*p++ = c = token_getch();\n \t\t/* Accept '.' as the start of a floating-point number\n-\t\t   only when it is followed by a digit.\n-\t\t   Otherwise, unread the following non-digit\n-\t\t   and use the '.' as a structural token.  */\n+\t\t   only when it is followed by a digit.  */\n \t\tif (p == token_buffer + 2 && !ISDIGIT (c))\n-\t\t  {\n-\t\t    if (c == '.')\n-\t\t      {\n-\t\t\tc = GETC();\n-\t\t\tif (c == '.')\n-\t\t\t  {\n-\t\t\t    *p++ = c;\n-\t\t\t    *p = 0;\n-\t\t\t    return ELLIPSIS;\n-\t\t\t  }\n-\t\t\terror (\"parse error at `..'\");\n-\t\t      }\n-\t\t    UNGETC (c);\n-\t\t    token_buffer[1] = 0;\n-\t\t    value = '.';\n-\t\t    goto done;\n-\t\t  }\n+\t\t  abort ();\n \t      }\n \t    else\n \t      {\n@@ -1618,7 +1639,7 @@ yylex ()\n \t\t    else\n \t\t      parts[0] += c;\n \t\t  }\n-\t\t\n+\n \t\t/* If the highest-order part overflows (gets larger than\n \t\t   a host char will hold) then the whole number has \n \t\t   overflowed.  Record this and truncate the highest-order\n@@ -1631,24 +1652,24 @@ yylex ()\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n-\t\t*p++ = (c = GETC());\n+\t\t*p++ = (c = token_getch());\n \t      }\n \t  }\n \n \tif (numdigits == 0)\n-\t  error (\"numeric constant with no digits\");\n+\t  abort ();\n \n \tif (largest_digit >= base)\n \t  error (\"numeric constant contains digits beyond the radix\");\n \n-\t/* Remove terminating char from the token buffer and delimit the string */\n+\t/* Remove terminating char from the token buffer and delimit the\n+           string.  */\n \t*--p = 0;\n \n \tif (floatflag != NOT_FLOAT)\n \t  {\n-\t    tree type = double_type_node;\n-\t    int imag = 0;\n-\t    int conversion_errno = 0;\n+\t    tree type;\n+\t    int imag, conversion_errno;\n \t    REAL_VALUE_TYPE value;\n \t    struct pf_args args;\n \n@@ -1660,11 +1681,11 @@ yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = GETC();\n+\t\tc = token_getch();\n \t\tif ((c == '+') || (c == '-'))\n \t\t  {\n \t\t    *p++ = c;\n-\t\t    c = GETC();\n+\t\t    c = token_getch();\n \t\t  }\n \t\t/* Exponent is decimal, even if string is a hex float.  */\n \t\tif (! ISDIGIT (c))\n@@ -1674,7 +1695,7 @@ yylex ()\n \t\t    if (p >= token_buffer + maxtoken - 3)\n \t\t      p = extend_token_buffer (p);\n \t\t    *p++ = c;\n-\t\t    c = GETC();\n+\t\t    c = token_getch ();\n \t\t  }\n \t      }\n \t    if (base == 16 && floatflag != AFTER_EXPON)\n@@ -1686,9 +1707,6 @@ yylex ()\n \t    args.base = base;\n \t    args.p = p;\n \t    args.c = c;\n-\t    args.imag = imag;\n-\t    args.type = type;\n-\t    args.conversion_errno = conversion_errno;\n \n \t    /* Convert string to a double, checking for overflow.  */\n \t    if (do_float_handler (parse_float, (PTR) &args))\n@@ -1776,7 +1794,7 @@ yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = GETC();\n+\t\tc = token_getch();\n \t      }\n \n \t    /* If the literal overflowed, pedwarn about it now. */\n@@ -1929,7 +1947,7 @@ yylex ()\n \t      pedwarn (\"integer constant is larger than the maximum value for its type\");\n \t  }\n \n-\tUNGETC (c);\n+\ttoken_put_back (c);\n \t*p = 0;\n \n \tif (ISALNUM (c) || c == '.' || c == '_' || c == '$'\n@@ -1950,7 +1968,7 @@ yylex ()\n \tint max_chars;\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n \n \tmax_chars = TYPE_PRECISION (integer_type_node) / width;\n@@ -1960,7 +1978,7 @@ yylex ()\n \twhile (1)\n \t  {\n \t  tryagain:\n-\t    c = GETC();\n+\t    c = token_getch();\n \n \t    if (c == '\\'' || c == EOF)\n \t      break;\n@@ -2003,13 +2021,13 @@ yylex ()\n \t\t\t\t\t     i);\n \t\t    if (char_len != -1)\n \t\t      break;\n-\t\t    c = GETC ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t\tif (char_len > 1)\n \t\t  {\n \t\t    /* mbtowc sometimes needs an extra char before accepting */\n \t\t    if (char_len < i)\n-\t\t      UNGETC (c);\n+\t\t      token_put_back (c);\n \t\t    if (! wide_flag)\n \t\t      {\n \t\t\t/* Merge character into result; ignore excess chars.  */\n@@ -2036,7 +2054,7 @@ yylex ()\n \t\t\twarning (\"Ignoring invalid multibyte character\");\n \t\t\t/* Replace all but the first byte.  */\n \t\t\tfor (--i; i > 1; --i)\n-\t\t\t  UNGETC (token_buffer[i]);\n+\t\t\t  token_put_back (token_buffer[i]);\n \t\t\twc = token_buffer[1];\n \t\t      }\n #ifdef MAP_CHARACTER\n@@ -2119,14 +2137,16 @@ yylex ()\n \t                           : TYPE_PRECISION (char_type_node);\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\tc = GETC ();\n+\n+\tc = token_getch ();\n \tp = token_buffer + 1;\n \n-\twhile (c != '\"' && c >= 0)\n+\twhile (c != '\"' && c != EOF)\n \t  {\n-\t    if (c == '\\\\')\n+\t    /* ignore_escape_flag is set for reading the filename in #line.  */\n+\t    if (!ignore_escape_flag && c == '\\\\')\n \t      {\n \t\tint ignore = 0;\n \t\tc = readescape (&ignore);\n@@ -2157,24 +2177,24 @@ yylex ()\n \t\t    char_len = local_mbtowc (& wc, p, i + 1);\n \t\t    if (char_len != -1)\n \t\t      break;\n-\t\t    c = GETC ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t\tif (char_len == -1)\n \t\t  {\n \t\t    warning (\"Ignoring invalid multibyte character\");\n \t\t    /* Replace all except the first byte.  */\n-\t\t    UNGETC (c);\n+\t\t    token_put_back (c);\n \t\t    for (--i; i > 0; --i)\n-\t\t      UNGETC (p[i]);\n+\t\t      token_put_back (p[i]);\n \t\t    char_len = 1;\n \t\t  }\n \t\t/* mbtowc sometimes needs an extra char before accepting */\n \t\tif (char_len <= i)\n-\t\t  UNGETC (c);\n+\t\t  token_put_back (c);\n \t\tif (! wide_flag)\n \t\t  {\n \t\t    p += (i + 1);\n-\t\t    c = GETC ();\n+\t\t    c = token_getch ();\n \t\t    continue;\n \t\t  }\n \t\tc = wc;\n@@ -2214,7 +2234,7 @@ yylex ()\n \t      }\n \n \t  skipnewline:\n-\t    c = GETC ();\n+\t    c = token_getch ();\n \t  }\n \n \t/* Terminate the string value, either with a single byte zero\n@@ -2233,7 +2253,7 @@ yylex ()\n \t    *p++ = 0;\n \t  }\n \n-\tif (c < 0)\n+\tif (c == EOF)\n \t  error (\"Unterminated string constant\");\n \n \t/* We have read the entire constant.\n@@ -2311,7 +2331,7 @@ yylex ()\n \t    yylval.code = GT_EXPR; break;\n \t  }\n \n-\ttoken_buffer[1] = c1 = GETC();\n+\ttoken_buffer[1] = c1 = token_getch();\n \ttoken_buffer[2] = 0;\n \n \tif (c1 == '=')\n@@ -2354,6 +2374,8 @@ yylex ()\n \t      if (c1 == '>')\n \t\t{ value = POINTSAT; goto done; }\n \t      break;\n+\n+\t      /* digraphs */\n \t    case ':':\n \t      if (c1 == '>')\n \t\t{ value = ']'; goto done; }\n@@ -2369,13 +2391,14 @@ yylex ()\n \t\t{ value = '}'; indent_level--; goto done; }\n \t      break;\n \t    }\n-\tUNGETC (c1);\n+\n+\ttoken_put_back (c1);\n \ttoken_buffer[1] = 0;\n \n \tif ((c == '<') || (c == '>'))\n \t  value = ARITHCOMPARE;\n \telse value = c;\n-\tgoto done;\n+\tbreak;\n       }\n \n     case 0:"}, {"sha": "ff2b2294b246c9e643d108750238122e24ada42e", "filename": "gcc/c-parse.c", "status": "modified", "additions": 1238, "deletions": 1312, "changes": 2550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8"}, {"sha": "5c9abe09ac1d8bccd4652b7f061bc89da62c2143", "filename": "gcc/c-parse.h", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.h?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "patch": "@@ -1,65 +1,66 @@\n typedef union {long itype; tree ttype; enum tree_code code;\n \tchar *filename; int lineno; int ends_in_label; } YYSTYPE;\n-#define\tIDENTIFIER\t257\n-#define\tTYPENAME\t258\n-#define\tSCSPEC\t259\n-#define\tTYPESPEC\t260\n-#define\tTYPE_QUAL\t261\n-#define\tCONSTANT\t262\n-#define\tSTRING\t263\n-#define\tELLIPSIS\t264\n-#define\tSIZEOF\t265\n-#define\tENUM\t266\n-#define\tSTRUCT\t267\n-#define\tUNION\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tTYPEOF\t282\n-#define\tALIGNOF\t283\n-#define\tATTRIBUTE\t284\n-#define\tEXTENSION\t285\n-#define\tLABEL\t286\n-#define\tREALPART\t287\n-#define\tIMAGPART\t288\n-#define\tVA_ARG\t289\n-#define\tASSIGN\t290\n-#define\tOROR\t291\n-#define\tANDAND\t292\n-#define\tEQCOMPARE\t293\n-#define\tARITHCOMPARE\t294\n-#define\tLSHIFT\t295\n-#define\tRSHIFT\t296\n-#define\tUNARY\t297\n-#define\tPLUSPLUS\t298\n-#define\tMINUSMINUS\t299\n-#define\tHYPERUNARY\t300\n-#define\tPOINTSAT\t301\n-#define\tINTERFACE\t302\n-#define\tIMPLEMENTATION\t303\n-#define\tEND\t304\n-#define\tSELECTOR\t305\n-#define\tDEFS\t306\n-#define\tENCODE\t307\n-#define\tCLASSNAME\t308\n-#define\tPUBLIC\t309\n-#define\tPRIVATE\t310\n-#define\tPROTECTED\t311\n-#define\tPROTOCOL\t312\n-#define\tOBJECTNAME\t313\n-#define\tCLASS\t314\n-#define\tALIAS\t315\n-#define\tOBJC_STRING\t316\n+#define\tIDENTIFIER\t258\n+#define\tTYPENAME\t259\n+#define\tSCSPEC\t260\n+#define\tTYPESPEC\t261\n+#define\tTYPE_QUAL\t262\n+#define\tCONSTANT\t263\n+#define\tSTRING\t264\n+#define\tELLIPSIS\t265\n+#define\tSIZEOF\t266\n+#define\tENUM\t267\n+#define\tSTRUCT\t268\n+#define\tUNION\t269\n+#define\tIF\t270\n+#define\tELSE\t271\n+#define\tWHILE\t272\n+#define\tDO\t273\n+#define\tFOR\t274\n+#define\tSWITCH\t275\n+#define\tCASE\t276\n+#define\tDEFAULT\t277\n+#define\tBREAK\t278\n+#define\tCONTINUE\t279\n+#define\tRETURN\t280\n+#define\tGOTO\t281\n+#define\tASM_KEYWORD\t282\n+#define\tTYPEOF\t283\n+#define\tALIGNOF\t284\n+#define\tATTRIBUTE\t285\n+#define\tEXTENSION\t286\n+#define\tLABEL\t287\n+#define\tREALPART\t288\n+#define\tIMAGPART\t289\n+#define\tVA_ARG\t290\n+#define\tEND_OF_LINE\t291\n+#define\tASSIGN\t292\n+#define\tOROR\t293\n+#define\tANDAND\t294\n+#define\tEQCOMPARE\t295\n+#define\tARITHCOMPARE\t296\n+#define\tLSHIFT\t297\n+#define\tRSHIFT\t298\n+#define\tUNARY\t299\n+#define\tPLUSPLUS\t300\n+#define\tMINUSMINUS\t301\n+#define\tHYPERUNARY\t302\n+#define\tPOINTSAT\t303\n+#define\tINTERFACE\t304\n+#define\tIMPLEMENTATION\t305\n+#define\tEND\t306\n+#define\tSELECTOR\t307\n+#define\tDEFS\t308\n+#define\tENCODE\t309\n+#define\tCLASSNAME\t310\n+#define\tPUBLIC\t311\n+#define\tPRIVATE\t312\n+#define\tPROTECTED\t313\n+#define\tPROTOCOL\t314\n+#define\tOBJECTNAME\t315\n+#define\tCLASS\t316\n+#define\tALIAS\t317\n+#define\tOBJC_STRING\t318\n \n \n extern YYSTYPE yylval;"}, {"sha": "dc8df7827d8b62868840e42c06777d19104c76ee", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "patch": "@@ -138,6 +138,9 @@ end ifc\n %token ATTRIBUTE EXTENSION LABEL\n %token REALPART IMAGPART VA_ARG\n \n+/* Used in c-lex.c for parsing pragmas.  */\n+%token END_OF_LINE\n+\n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n %nonassoc ELSE"}, {"sha": "73730fb5cce2e9e5ebca7b3099a6ac600f3e4c81", "filename": "gcc/c-parse.y", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb186135db4c9918e5f6cb0d8b5c5279ed356d8/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=fbb186135db4c9918e5f6cb0d8b5c5279ed356d8", "patch": "@@ -126,6 +126,9 @@ char *language_string = \"GNU C\";\n %token ATTRIBUTE EXTENSION LABEL\n %token REALPART IMAGPART VA_ARG\n \n+/* Used in c-lex.c for parsing pragmas.  */\n+%token END_OF_LINE\n+\n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n %nonassoc ELSE"}]}