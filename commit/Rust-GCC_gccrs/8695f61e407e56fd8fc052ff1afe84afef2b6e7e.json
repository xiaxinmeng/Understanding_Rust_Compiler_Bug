{"sha": "8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5NWY2MWU0MDdlNTZmZDhmYzA1MmZmMWFmZTg0YWZlZjJiNmU3ZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-06-09T21:58:54Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-06-09T21:58:54Z"}, "message": "k6.md: Rewrite using the DFA model.\n\n\t* config/i386/k6.md: Rewrite using the DFA model.\n\t* config/i386/i386.c (ix86_adjust_cost): Don't increase the\n\tcost of load-operation insns for the K6.\n\t(ia32_use_dfa_pipeline_interface): Add TARGET_K6.\n\t(ia32_multipass_dfa_lookahead): Likewise.\n\nFrom-SVN: r82859", "tree": {"sha": "a45c2ed92678d83cdcbffa821af9d0d155073720", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a45c2ed92678d83cdcbffa821af9d0d155073720"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/comments", "author": null, "committer": null, "parents": [{"sha": "282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282450180d4350e1b94d527c3d7a1c5b4a63c7ac"}], "stats": {"total": 398, "additions": 267, "deletions": 131}, "files": [{"sha": "d9e3267f5264ee34180535cc4a03d045d76f0192", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "patch": "@@ -1,3 +1,11 @@\n+2004-06-09  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* config/i386/k6.md: Rewrite using the DFA model.\n+\t* config/i386/i386.c (ix86_adjust_cost): Don't increase the\n+\tcost of load-operation insns for the K6.\n+\t(ia32_use_dfa_pipeline_interface): Add TARGET_K6.\n+\t(ia32_multipass_dfa_lookahead): Likewise.\n+\n 2004-06-09  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (alpha_gimplify_va_arg_1,\n@@ -131,8 +139,8 @@\n \n 2004-06-08  Jeff Law  <law@redhat.com>\n \n-        * doc/contrib.texi: Add entries for Stefan Olsson and\n-        Ola Ronnerup.\n+\t* doc/contrib.texi: Add entries for Stefan Olsson and\n+\tOla Ronnerup.\n \n 2004-06-08  DJ Delorie  <dj@redhat.com>\n \n@@ -155,13 +163,13 @@\n \n 2004-06-08  Richard Henderson  <rth@redhat.com>\n \n-        * gimple-low.c (struct lower_data): Replace the_return_label and\n-        one_return_stmt with return_statements.\n-        (lower_function_body): Process the entire list of return_statements.\n-        (lower_return_expr): Check source value before unifying return_exprs.   \n-        * gimplify.c (gimplify_return_expr): Force the use of a temporary\n-        for !aggregate_value_p.\n-        * tree-gimple.c: Update RETURN_EXPR grammer.\n+\t* gimple-low.c (struct lower_data): Replace the_return_label and\n+\tone_return_stmt with return_statements.\n+\t(lower_function_body): Process the entire list of return_statements.\n+\t(lower_return_expr): Check source value before unifying return_exprs.   \n+\t* gimplify.c (gimplify_return_expr): Force the use of a temporary\n+\tfor !aggregate_value_p.\n+\t* tree-gimple.c: Update RETURN_EXPR grammer.\n \n 2004-06-08  Vladimir Makarov  <vmakarov@redhat.com>\n "}, {"sha": "75e80a651b23732f23b9e59265cc0ba22099266b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "patch": "@@ -12482,7 +12482,7 @@ static int\n ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_type insn_type, dep_insn_type;\n-  enum attr_memory memory, dep_memory;\n+  enum attr_memory memory;\n   rtx set, set2;\n   int dep_insn_code_number;\n \n@@ -12550,18 +12550,13 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n     case PROCESSOR_K6:\n       memory = get_attr_memory (insn);\n-      dep_memory = get_attr_memory (dep_insn);\n+\n       /* The esp dependency is resolved before the instruction is really\n          finished.  */\n       if ((insn_type == TYPE_PUSH || insn_type == TYPE_POP)\n \t  && (dep_insn_type == TYPE_PUSH || dep_insn_type == TYPE_POP))\n \treturn 1;\n \n-      /* Since we can't represent delayed latencies of load+operation,\n-\t increase the cost here for non-imov insns.  */\n-      if (dep_memory == MEMORY_LOAD || dep_memory == MEMORY_BOTH)\n-\tcost += (dep_insn_type != TYPE_IMOV) ? 2 : 1;\n-\n       /* INT->FP conversion is expensive.  */\n       if (get_attr_fp_int_src (dep_insn))\n \tcost += 5;\n@@ -12587,7 +12582,6 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n     case PROCESSOR_ATHLON:\n     case PROCESSOR_K8:\n       memory = get_attr_memory (insn);\n-      dep_memory = get_attr_memory (dep_insn);\n \n       /* Show ability of reorder buffer to hide latency of load by executing\n \t in parallel with previous instruction in case\n@@ -12626,6 +12620,7 @@ ia32_use_dfa_pipeline_interface (void)\n {\n   if (TARGET_PENTIUM\n       || TARGET_PENTIUMPRO\n+      || TARGET_K6\n       || TARGET_ATHLON_K8)\n     return 1;\n   return 0;\n@@ -12641,7 +12636,8 @@ ia32_multipass_dfa_lookahead (void)\n   if (ix86_tune == PROCESSOR_PENTIUM)\n     return 2;\n \n-  if (ix86_tune == PROCESSOR_PENTIUMPRO)\n+  if (ix86_tune == PROCESSOR_PENTIUMPRO\n+      || ix86_tune == PROCESSOR_K6)\n     return 1;\n \n   else"}, {"sha": "33d4f1ee9b32abeb9350bd6e229b964ba2245182", "filename": "gcc/config/i386/k6.md", "status": "modified", "additions": 245, "deletions": 113, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2Fconfig%2Fi386%2Fk6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8695f61e407e56fd8fc052ff1afe84afef2b6e7e/gcc%2Fconfig%2Fi386%2Fk6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fk6.md?ref=8695f61e407e56fd8fc052ff1afe84afef2b6e7e", "patch": "@@ -1,5 +1,6 @@\n ;; AMD K6/K6-2 Scheduling\n-;; Copyright (C) 2002 ;; Free Software Foundation, Inc.\n+;; Copyright (C) 2002, 2004\n+;; Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -16,121 +17,252 @@\n ;; You should have received a copy of the GNU General Public License\n ;; along with GCC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.  */\n+;; Boston, MA 02111-1307, USA.\n ;;\n-;; The K6 has similar architecture to PPro.  Important difference is, that\n-;; there are only two decoders and they seems to be much slower than execution\n-;; units.  So we have to pay much more attention to proper decoding for\n-;; schedulers.  We share most of scheduler code for PPro in i386.c\n+;; The K6 architecture is quite similar to PPro.  Important difference is\n+;; that there are only two decoders and they seems to be much slower than\n+;; any of the execution units.  So we have to pay much more attention to\n+;; proper scheduling for the decoders.\n+;; FIXME: We don't do that right now.  A good start would be to sort the\n+;;        instructions based on length.\n ;;\n-;; The fp unit is not pipelined and do one operation per two cycles including\n-;; the FXCH.\n+;; This description is based on data from the following documents:\n ;;\n-;; alu\t  describes both ALU units (ALU-X and ALU-Y).\n-;; alux   describes X alu unit\n-;; fpu    describes FPU unit\n-;; load   describes load unit.\n-;; branch describes branch unit.\n-;; store  describes store unit.  This unit is not modelled completely and only\n-;;        used to model lea operation.  Otherwise it lie outside of the critical\n-;;        path.\n+;;    \"AMD-K6 Processor Data Sheet (Preliminary information)\"\n+;;    Advanced Micro Devices, Inc., 1998.\n+;;\n+;;    \"AMD-K6 Processor Code Optimization Application Note\"\n+;;    Advanced Micro Devices, Inc., 2000.\n+;;\n+;; CPU execution units of the K6:\n+;;\n+;; store\tdescribes the Store unit.  This unit is not modelled\n+;;\t\tcompletely and it is only used to model lea operation.\n+;;\t\tOtherwise it lies outside of any critical path.\n+;; load\t\tdescribes the Load unit\n+;; alux\t\tdescribes the Integer X unit\n+;; mm\t\tdescribes the Multimedia unit, which shares a pipe\n+;;\t\twith the Integer X unit.  This unit is used for MMX,\n+;;\t\twhich is not implemented for K6.\n+;; aluy\t\tdescribes the Integer Y unit\n+;; fpu\t\tdescribes the FPU unit\n+;; branch\tdescribes the Branch unit\n+;;\n+;; The fp unit is not pipelined, and it can only do one operation per two\n+;; cycles, including fxcg.\n+;;\n+;; Generally this is a very poor description, but at least no worse than\n+;; the old description, and a lot easier to extend to something more\n+;; reasonable if anyone still cares enough about this architecture in 2004.\n ;;\n ;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n \n-;; The decoder specification is in the PPro section above!\n-\n-;; Shift instructions and certain arithmetic are issued only to X pipe.\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1,alu1,negnot,cld\"))\n-  1 1)\n-\n-;; The QI mode arithmetic is issued to X pipe only.\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec\")\n-\t    (eq_attr \"mode\" \"QI\")))\n-  1 1)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1,alu1,negnot,alu,icmp,test,imovx,incdec,setcc,lea\"))\n-  1 1)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"imov\")\n-       \t    (eq_attr \"memory\" \"none\")))\n-  1 1)\n-\n-(define_function_unit \"k6_branch\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"call,callv,ibr\"))\n-  1 1)\n-\n-;; Load unit have two cycle latency, but we take care for it in adjust_cost\n-(define_function_unit \"k6_load\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (ior (eq_attr \"type\" \"pop,leave\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  1 1)\n-\n-(define_function_unit \"k6_load\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (and (eq_attr \"type\" \"str\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  10 10)\n-\n-;; Lea have two instructions, so latency is probably 2\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"lea\"))\n-  2 1)\n-\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"str\"))\n-  10 10)\n-\n-(define_function_unit \"k6_store\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (ior (eq_attr \"type\" \"push\")\n-\t    (eq_attr \"memory\" \"store,both\")))\n-  1 1)\n-\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fop,fmov,fcmp,fistp\"))\n-  2 2)\n-\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fmul\"))\n-  2 2)\n-\n-;; ??? Guess\n-(define_function_unit \"k6_fpu\" 1 1\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 56)\n-\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"imul\"))\n-  2 2)\n-\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"imul\"))\n-  2 2)\n-\n-;; ??? Guess\n-(define_function_unit \"k6_alu\" 2 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n-\n-(define_function_unit \"k6_alux\" 1 0\n-  (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n+(define_automaton \"k6_decoder,k6_load_unit,k6_store_unit,k6_integer_units,k6_fpu_unit,k6_branch_unit\")\n+\n+;; The K6 instruction decoding begins before the on-chip instruction cache is\n+;; filled.  Depending on the length of the instruction, two simple instructions\n+;; can be decoded in two parallel short decoders, or one complex instruction can\n+;; be decoded in either the long or the vector decoder.  For all practical\n+;; purposes, the long and vector decoder can be modelled as one decoder.\n+(define_cpu_unit \"k6_decode_short0\" \"k6_decoder\")\n+(define_cpu_unit \"k6_decode_short1\" \"k6_decoder\")\n+(define_cpu_unit \"k6_decode_long\" \"k6_decoder\")\n+(exclusion_set \"k6_decode_long\" \"k6_decode_short0,k6_decode_short1\")\n+(define_reservation \"k6_decode_short\" \"k6_decode_short0|k6_decode_short1\")\n+(define_reservation \"k6_decode_vector\" \"k6_decode_long\")\n+\n+(define_cpu_unit \"k6_store\" \"k6_store_unit\")\n+(define_cpu_unit \"k6_load\" \"k6_load_unit\")\n+(define_cpu_unit \"k6_alux,k6_aluy\" \"k6_integer_units\")\n+(define_cpu_unit \"k6_fpu\" \"k6_fpu_unit\")\n+(define_cpu_unit \"k6_branch\" \"k6_branch_unit\")\n+\n+;; Shift instructions and certain arithmetic are issued only on Integer X.\n+(define_insn_reservation \"k6_alux_only\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1,alu1,negnot,cld\")\n+\t\t\t\t   (eq_attr \"memory\" \"none\")))\n+\t\t\t \"k6_decode_short,k6_alux\")\n+\n+(define_insn_reservation \"k6_alux_only_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t       (and (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1,alu1,negnot,cld\")\n+\t\t\t\t    (eq_attr \"memory\" \"load\")))\n+\t\t\t \"k6_decode_short,k6_load,k6_alux\")\n+\n+(define_insn_reservation \"k6_alux_only_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t       (and (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1,alu1,negnot,cld\")\n+\t\t\t\t    (eq_attr \"memory\" \"store,both,unknown\")))\n+\t\t\t \"k6_decode_long,k6_load,k6_alux,k6_store\")\n+\n+;; Integer divide and multiply can only be issued on Integer X, too.\n+(define_insn_reservation \"k6_alu_imul\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"imul\"))\n+\t\t\t \"k6_decode_vector,k6_alux*3\")\n+\n+(define_insn_reservation \"k6_alu_imul_load\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imul\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"k6_decode_vector,k6_load,k6_alux*3\")\n+\n+(define_insn_reservation \"k6_alu_imul_store\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imul\")\n+\t\t\t\t   (eq_attr \"memory\" \"store,both,unknown\")))\n+\t\t\t \"k6_decode_vector,k6_load,k6_alux*3,k6_store\")\n+\n+;; ??? Guessed latencies based on the old pipeline description.\n+(define_insn_reservation \"k6_alu_idiv\" 17\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"idiv\")\n+\t\t\t\t   (eq_attr \"memory\" \"none\")))\n+\t\t\t \"k6_decode_vector,k6_alux*17\")\n+\n+(define_insn_reservation \"k6_alu_idiv_mem\" 19\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"idiv\")\n+\t\t\t\t   (eq_attr \"memory\" \"!none\")))\n+\t\t\t \"k6_decode_vector,k6_load,k6_alux*17\")\n+\n+;; Basic word and doubleword ALU ops can be issued on both Integer units.\n+(define_insn_reservation \"k6_alu\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec,setcc\")\n+\t\t\t\t   (eq_attr \"memory\" \"none\")))\n+\t\t\t \"k6_decode_short,k6_alux|k6_aluy\")\n+\n+(define_insn_reservation \"k6_alu_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec,setcc\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"k6_decode_short,k6_load,k6_alux|k6_aluy\")\n+\n+(define_insn_reservation \"k6_alu_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"alu,alu1,negnot,icmp,test,imovx,incdec,setcc\")\n+\t\t\t\t   (eq_attr \"memory\" \"store,both,unknown\")))\n+\t\t\t \"k6_decode_long,k6_load,k6_alux|k6_aluy,k6_store\")\n+\n+;; A \"load immediate\" operation does not require execution at all,\n+;; it is available immediately after decoding.  Special-case this.\n+(define_insn_reservation \"k6_alu_imov\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imov\")\n+\t\t\t\t   (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t\t(match_operand 1 \"nonimmediate_operand\"))))\n+\t\t\t \"k6_decode_short,k6_alux|k6_aluy\")\n+\n+(define_insn_reservation \"k6_alu_imov_imm\" 0\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imov\")\n+\t\t\t\t   (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t\t(match_operand 1 \"immediate_operand\"))))\n+\t\t\t \"k6_decode_short\")\n+\n+(define_insn_reservation \"k6_alu_imov_load\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imov\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"k6_decode_short,k6_load\")\n+\n+(define_insn_reservation \"k6_alu_imov_store\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imov\")\n+\t\t\t\t   (eq_attr \"memory\" \"store\")))\n+\t\t\t \"k6_decode_short,k6_store\")\n+\n+(define_insn_reservation \"k6_alu_imov_both\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"imov\")\n+\t\t\t\t   (eq_attr \"memory\" \"both,unknown\")))\n+\t\t\t \"k6_decode_long,k6_load,k6_alux|k6_aluy\")\n+\n+;; The branch unit.\n+(define_insn_reservation \"k6_branch_call\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"call,callv\"))\n+\t\t\t \"k6_decode_vector,k6_branch\")\n+\n+(define_insn_reservation \"k6_branch_branch\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"ibr\"))\n+\t\t\t \"k6_decode_short,k6_branch\")\n+\n+;; The load and units have two pipeline stages.  The load latency is\n+;; two cycles.\n+(define_insn_reservation \"k6_load_pop\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (ior (eq_attr \"type\" \"pop\")\n+\t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n+\t\t\t \"k6_decode_short,k6_load\")\n+\n+(define_insn_reservation \"k6_load_leave\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"leave\"))\n+\t\t\t \"k6_decode_long,k6_load,(k6_alux|k6_aluy)*2\")\n+\n+;; ??? From the old pipeline description.  Egad!\n+;; ??? Apparently we take care of this reservation in adjust_cost.\n+(define_insn_reservation \"k6_load_str\" 10\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"str\")\n+\t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n+\t\t\t \"k6_decode_vector,k6_load*10\")\n+\n+;; The store unit handles lea and push.  It is otherwise unmodelled.\n+(define_insn_reservation \"k6_store_lea\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"lea\"))\n+\t\t\t \"k6_decode_short,k6_store,k6_alux|k6_aluy\")\n+\n+(define_insn_reservation \"k6_store_push\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (ior (eq_attr \"type\" \"push\")\n+\t\t\t\t   (eq_attr \"memory\" \"store,both\")))\n+\t\t\t \"k6_decode_short,k6_store\")\n+\n+(define_insn_reservation \"k6_store_str\" 10\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"str\"))\n+\t\t\t \"k6_store*10\")\n+\n+;; Most FPU instructions have latency 2 and throughput 2.\n+(define_insn_reservation \"k6_fpu\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"fop,fmov,fcmp,fistp\")\n+\t\t\t\t   (eq_attr \"memory\" \"none\")))\n+\t\t\t \"k6_decode_vector,k6_fpu*2\")\n+\n+(define_insn_reservation \"k6_fpu_load\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"fop,fmov,fcmp,fistp\")\n+\t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n+\t\t\t \"k6_decode_short,k6_load,k6_fpu*2\")\n+\n+(define_insn_reservation \"k6_fpu_store\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"fop,fmov,fcmp,fistp\")\n+\t\t\t\t   (eq_attr \"memory\" \"store\")))\n+\t\t\t \"k6_decode_short,k6_store,k6_fpu*2\")\n+\n+(define_insn_reservation \"k6_fpu_fmul\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"fmul\")\n+\t\t\t\t   (eq_attr \"memory\" \"none\")))\n+\t\t\t \"k6_decode_short,k6_fpu*2\")\n+\n+(define_insn_reservation \"k6_fpu_fmul_load\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (and (eq_attr \"type\" \"fmul\")\n+\t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n+\t\t\t \"k6_decode_short,k6_load,k6_fpu*2\")\n+\n+;; ??? Guessed latencies from the old pipeline description.\n+(define_insn_reservation \"k6_fpu_expensive\" 56\n+\t\t\t (and (eq_attr \"cpu\" \"k6\")\n+\t\t\t      (eq_attr \"type\" \"fdiv,fpspc\"))\n+\t\t\t \"k6_decode_short,k6_fpu*56\")\n+"}]}