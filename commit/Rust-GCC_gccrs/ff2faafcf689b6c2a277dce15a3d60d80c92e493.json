{"sha": "ff2faafcf689b6c2a277dce15a3d60d80c92e493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyZmFhZmNmNjg5YjZjMmEyNzdkY2UxNWEzZDYwZDgwYzkyZTQ5Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-02-10T15:34:52Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-02-10T15:34:52Z"}, "message": "re PR c++/10200 (Weird clash with same names in different scopes)\n\n\tPR c++/10200\n\n\t* parser.c (cp_parser_lookup_name): When looking for a template\n\tafter . or ->, only consider class templates.\n\t(cp_parser_postfix_dot_deref_expression): Handle the current\n\tinstantiation.  Remember a dependent object expression.\n\t* typeck2.c (build_x_arrow): Handle the current instantiation.\n\nFrom-SVN: r233277", "tree": {"sha": "c89456c79620b96874951134be2fdb0acd5caa62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c89456c79620b96874951134be2fdb0acd5caa62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2faafcf689b6c2a277dce15a3d60d80c92e493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2faafcf689b6c2a277dce15a3d60d80c92e493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2faafcf689b6c2a277dce15a3d60d80c92e493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2faafcf689b6c2a277dce15a3d60d80c92e493/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a4219caad501437c37f8adeded65299fbbdd310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4219caad501437c37f8adeded65299fbbdd310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a4219caad501437c37f8adeded65299fbbdd310"}], "stats": {"total": 59, "additions": 43, "deletions": 16}, "files": [{"sha": "92e65fcbba46704c5a77a82e010f2b76fdc5aab9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff2faafcf689b6c2a277dce15a3d60d80c92e493", "patch": "@@ -1,5 +1,12 @@\n 2016-02-10  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/10200\n+\t* parser.c (cp_parser_lookup_name): When looking for a template\n+\tafter . or ->, only consider class templates.\n+\t(cp_parser_postfix_dot_deref_expression): Handle the current\n+\tinstantiation.  Remember a dependent object expression.\n+\t* typeck2.c (build_x_arrow): Handle the current instantiation.\n+\n \t* ptree.c (debug_tree): Implement for cp_expr.\n \n 2016-02-08  Patrick Palka  <ppalka@gcc.gnu.org>"}, {"sha": "07d182156d6375230fbeca6f5a6023fbd68f87de", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ff2faafcf689b6c2a277dce15a3d60d80c92e493", "patch": "@@ -7184,8 +7184,16 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   if (token_type == CPP_DEREF)\n     postfix_expression = build_x_arrow (location, postfix_expression,\n \t\t\t\t\ttf_warning_or_error);\n-  /* Check to see whether or not the expression is type-dependent.  */\n-  dependent_p = type_dependent_expression_p (postfix_expression);\n+  /* According to the standard, no expression should ever have\n+     reference type.  Unfortunately, we do not currently match\n+     the standard in this respect in that our internal representation\n+     of an expression may have reference type even when the standard\n+     says it does not.  Therefore, we have to manually obtain the\n+     underlying type here.  */\n+  scope = non_reference (TREE_TYPE (postfix_expression));\n+  /* Check to see whether or not the expression is type-dependent and\n+     not the current instantiation.  */\n+  dependent_p = !scope || dependent_scope_p (scope);\n   /* The identifier following the `->' or `.' is not qualified.  */\n   parser->scope = NULL_TREE;\n   parser->qualifying_scope = NULL_TREE;\n@@ -7194,16 +7202,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \n   /* Enter the scope corresponding to the type of the object\n      given by the POSTFIX_EXPRESSION.  */\n-  if (!dependent_p && TREE_TYPE (postfix_expression) != NULL_TREE)\n-    {\n-      scope = TREE_TYPE (postfix_expression);\n-      /* According to the standard, no expression should ever have\n-\t reference type.  Unfortunately, we do not currently match\n-\t the standard in this respect in that our internal representation\n-\t of an expression may have reference type even when the standard\n-\t says it does not.  Therefore, we have to manually obtain the\n-\t underlying type here.  */\n-      scope = non_reference (scope);\n+  if (!dependent_p)\n+    {\n       /* The type of the POSTFIX_EXPRESSION must be complete.  */\n       if (scope == unknown_type_node)\n \t{\n@@ -7215,7 +7215,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t required to be of complete type for purposes of class member\n \t access (5.2.5) outside the member function body.  */\n       else if (postfix_expression != current_class_ref\n-\t       && !(processing_template_decl && scope == current_class_type))\n+\t       && !(processing_template_decl\n+\t\t    && current_class_type\n+\t\t    && (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t(scope, current_class_type))))\n \tscope = complete_type_or_else (scope, NULL_TREE);\n       /* Let the name lookup machinery know that we are processing a\n \t class member access expression.  */\n@@ -7231,6 +7234,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       if (scope == error_mark_node)\n \tpostfix_expression = error_mark_node;\n     }\n+  else\n+    /* Tell cp_parser_lookup_name that there was an object, even though it's\n+       type-dependent.  */\n+    parser->context->object_type = unknown_type_node;\n \n   /* Assume this expression is not a pseudo-destructor access.  */\n   pseudo_destructor_p = false;\n@@ -24720,10 +24727,15 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \tdecl = NULL_TREE;\n \n       if (!decl)\n-\t/* Look it up in the enclosing context.  */\n-\tdecl = lookup_name_real (name, tag_type != none_type,\n+\t/* Look it up in the enclosing context.  DR 141: When looking for a\n+\t   template-name after -> or ., only consider class templates.  */\n+\tdecl = lookup_name_real (name, tag_type != none_type || is_template,\n \t\t\t\t /*nonclass=*/0,\n \t\t\t\t /*block_p=*/true, is_namespace, 0);\n+      if (object_type == unknown_type_node)\n+\t/* The object is type-dependent, so we can't look anything up; we used\n+\t   this to get the DR 141 behavior.  */\n+\tobject_type = NULL_TREE;\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }"}, {"sha": "54a432f256f3801b63a1b7dcc60ee0273d46e836", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=ff2faafcf689b6c2a277dce15a3d60d80c92e493", "patch": "@@ -1694,7 +1694,10 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \n   if (processing_template_decl)\n     {\n-      if (type_dependent_expression_p (expr))\n+      if (type && TREE_CODE (type) == POINTER_TYPE\n+\t  && !dependent_scope_p (TREE_TYPE (type)))\n+\t/* Pointer to current instantiation, don't treat as dependent.  */;\n+      else if (type_dependent_expression_p (expr))\n \treturn build_min_nt_loc (loc, ARROW_EXPR, expr);\n       expr = build_non_dependent_expr (expr);\n     }"}, {"sha": "54784488af88a8a0bb49be82c22805aa90825c5e", "filename": "gcc/testsuite/g++.dg/lookup/member2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2faafcf689b6c2a277dce15a3d60d80c92e493/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember2.C?ref=ff2faafcf689b6c2a277dce15a3d60d80c92e493", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/10200\n+\n+template<class Tp> inline void end(Tp) { }\n+\n+template <typename T> bool tnegative(const T& t) { return t.end < 0; }"}]}