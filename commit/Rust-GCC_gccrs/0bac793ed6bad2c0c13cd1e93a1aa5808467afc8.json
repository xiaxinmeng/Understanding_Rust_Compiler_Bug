{"sha": "0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhYzc5M2VkNmJhZDJjMGMxM2NkMWU5M2ExYWE1ODA4NDY3YWZjOA==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-08-05T15:29:03Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-08-05T15:29:03Z"}, "message": "openmp: Implement omp_get_device_num routine\n\nThis patch implements the omp_get_device_num library routine, specified in\nOpenMP 5.0.\n\nGOMP_DEVICE_NUM_VAR is a macro symbol which defines name of a \"device number\"\nvariable, is defined on the device-side libgomp, has it's address returned to\nhost-side libgomp during device initialization, and the host libgomp then\nsets its value to the designated device number.\n\nlibgomp/ChangeLog:\n\n\t* icv-device.c (omp_get_device_num): New API function, host side.\n\t* fortran.c (omp_get_device_num_): New interface function.\n\t* libgomp-plugin.h (GOMP_DEVICE_NUM_VAR): Define macro symbol.\n\t* libgomp.map (OMP_5.0.2): New version space with omp_get_device_num,\n\tomp_get_device_num_.\n\t* libgomp.texi (omp_get_device_num): Add documentation for new API\n\tfunction.\n\t* omp.h.in (omp_get_device_num): Add declaration.\n\t* omp_lib.f90.in (omp_get_device_num): Likewise.\n\t* omp_lib.h.in (omp_get_device_num): Likewise.\n\t* target.c (gomp_load_image_to_device): If additional entry for device\n\tnumber exists at end of returned entries from 'load_image_func' hook,\n\tcopy the assigned device number over to the device variable.\n\n\t* config/gcn/icv-device.c (GOMP_DEVICE_NUM_VAR): Define static global.\n\t(omp_get_device_num): New API function, device side.\n\t* plugin/plugin-gcn.c (\"symcat.h\"): Add include.\n\t(GOMP_OFFLOAD_load_image): Add addresses of device GOMP_DEVICE_NUM_VAR\n\tat end of returned 'target_table' entries.\n\n\t* config/nvptx/icv-device.c (GOMP_DEVICE_NUM_VAR): Define static global.\n\t(omp_get_device_num): New API function, device side.\n\t* plugin/plugin-nvptx.c (\"symcat.h\"): Add include.\n\t(GOMP_OFFLOAD_load_image): Add addresses of device GOMP_DEVICE_NUM_VAR\n\tat end of returned 'target_table' entries.\n\n\t* testsuite/lib/libgomp.exp\n\t(check_effective_target_offload_target_intelmic): New function for\n\ttesting for intelmic offloading.\n\t* testsuite/libgomp.c-c++-common/target-45.c: New test.\n\t* testsuite/libgomp.fortran/target10.f90: New test.", "tree": {"sha": "4f956146f4b129e344b00fa47e0326b831ef9928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f956146f4b129e344b00fa47e0326b831ef9928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dec72aeb54e98643c0fb3d53768cdb96cf1342a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dec72aeb54e98643c0fb3d53768cdb96cf1342a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dec72aeb54e98643c0fb3d53768cdb96cf1342a"}], "stats": {"total": 245, "additions": 238, "deletions": 7}, "files": [{"sha": "34e0f8346f2348f77feadd16332a14787f77aadb", "filename": "libgomp/config/gcn/icv-device.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ficv-device.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -70,10 +70,21 @@ omp_is_initial_device (void)\n   return 0;\n }\n \n+/* This is set to the device number of current GPU during device initialization,\n+   when the offload image containing this libgomp portion is loaded.  */\n+static volatile int GOMP_DEVICE_NUM_VAR;\n+\n+int\n+omp_get_device_num (void)\n+{\n+  return GOMP_DEVICE_NUM_VAR;\n+}\n+\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_initial_device)\n ialias (omp_get_num_devices)\n ialias (omp_get_num_teams)\n ialias (omp_get_team_num)\n ialias (omp_is_initial_device)\n+ialias (omp_get_device_num)"}, {"sha": "b63149d0c34cd2fd44e09821cc231e12d6b571e4", "filename": "libgomp/config/nvptx/icv-device.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -58,8 +58,19 @@ omp_is_initial_device (void)\n   return 0;\n }\n \n+/* This is set to the device number of current GPU during device initialization,\n+   when the offload image containing this libgomp portion is loaded.  */\n+static volatile int GOMP_DEVICE_NUM_VAR;\n+\n+int\n+omp_get_device_num (void)\n+{\n+  return GOMP_DEVICE_NUM_VAR;\n+}\n+\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_initial_device)\n ialias (omp_get_num_devices)\n ialias (omp_is_initial_device)\n+ialias (omp_get_device_num)"}, {"sha": "07f97656e51c0ca051728ee4d4f91a500d184d1e", "filename": "libgomp/fortran.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -83,6 +83,7 @@ ialias_redirect (omp_get_partition_place_nums)\n ialias_redirect (omp_set_default_device)\n ialias_redirect (omp_get_default_device)\n ialias_redirect (omp_get_num_devices)\n+ialias_redirect (omp_get_device_num)\n ialias_redirect (omp_get_num_teams)\n ialias_redirect (omp_get_team_num)\n ialias_redirect (omp_is_initial_device)\n@@ -599,6 +600,12 @@ omp_get_initial_device_ (void)\n   return omp_get_initial_device ();\n }\n \n+int32_t\n+omp_get_device_num_ (void)\n+{\n+  return omp_get_device_num ();\n+}\n+\n int32_t\n omp_get_max_task_priority_ (void)\n {"}, {"sha": "f11bdfa85c48c67c7e6ec7091d8d4542449713dc", "filename": "libgomp/icv-device.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -61,8 +61,17 @@ omp_is_initial_device (void)\n   return 1;\n }\n \n+int\n+omp_get_device_num (void)\n+{\n+  /* By specification, this is equivalent to omp_get_initial_device\n+     on the host.  */\n+  return omp_get_initial_device ();\n+}\n+\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_initial_device)\n ialias (omp_get_num_devices)\n ialias (omp_is_initial_device)\n+ialias (omp_get_device_num)"}, {"sha": "cf24a2bee4166caa3c5762a7894407268fd00b10", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -102,6 +102,12 @@ struct addr_pair\n   uintptr_t end;\n };\n \n+/* This symbol is to name a target side variable that holds the designated\n+   'device number' of the target device. The symbol needs to be available to\n+   libgomp code and the offload plugin (which in the latter case must be\n+   stringified).  */\n+#define GOMP_DEVICE_NUM_VAR __gomp_device_num\n+\n /* Miscellaneous functions.  */\n extern void *GOMP_PLUGIN_malloc (size_t) __attribute__ ((malloc));\n extern void *GOMP_PLUGIN_malloc_cleared (size_t) __attribute__ ((malloc));"}, {"sha": "cc44885cba913c0bc0e8979086104c3096f01300", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -199,12 +199,18 @@ OMP_5.0.1 {\n \tomp_fulfill_event_;\n } OMP_5.0;\n \n+OMP_5.0.2 {\n+  global:\n+\tomp_get_device_num;\n+\tomp_get_device_num_;\n+} OMP_5.0.1;\n+\n OMP_5.1 {\n   global:\n \tomp_display_env;\n \tomp_display_env_;\n \tomp_display_env_8_;\n-} OMP_5.0.1;\n+} OMP_5.0.2;\n \n GOMP_1.0 {\n   global:"}, {"sha": "fc9e708a8d254d1943a31f35f43377c707acddcc", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -165,6 +165,7 @@ linkage, and do not throw exceptions.\n * omp_get_ancestor_thread_num:: Ancestor thread ID\n * omp_get_cancellation::        Whether cancellation support is enabled\n * omp_get_default_device::      Get the default device for target regions\n+* omp_get_device_num::          Get device that current thread is running on\n * omp_get_dynamic::             Dynamic teams setting\n * omp_get_initial_device::      Device number of host device\n * omp_get_level::               Number of parallel regions\n@@ -385,6 +386,34 @@ For OpenMP 5.1, this must be equal to the value returned by the\n \n \n \n+@node omp_get_device_num\n+@section @code{omp_get_device_num} -- Return device number of current device\n+@table @asis\n+@item @emph{Description}:\n+This function returns a device number that represents the device that the\n+current thread is executing on. For OpenMP 5.0, this must be equal to the\n+value returned by the @code{omp_get_initial_device} function when called\n+from the host.\n+\n+@item @emph{C/C++}\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_device_num(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_device_num()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_get_initial_device}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openmp.org, OpenMP specification v5.0}, Section 3.2.37.\n+@end table\n+\n+\n+\n @node omp_get_level\n @section @code{omp_get_level} -- Obtain the current nesting level\n @table @asis"}, {"sha": "da34a9d98a6b1a19699a864b96dff303098c588b", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -243,6 +243,7 @@ extern void omp_get_partition_place_nums (int *) __GOMP_NOTHROW;\n extern void omp_set_default_device (int) __GOMP_NOTHROW;\n extern int omp_get_default_device (void) __GOMP_NOTHROW;\n extern int omp_get_num_devices (void) __GOMP_NOTHROW;\n+extern int omp_get_device_num (void) __GOMP_NOTHROW;\n extern int omp_get_num_teams (void) __GOMP_NOTHROW;\n extern int omp_get_team_num (void) __GOMP_NOTHROW;\n "}, {"sha": "d7e804f4fd50eb68b51b18c34ef39630c38e87f5", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -550,6 +550,12 @@\n           end function omp_get_initial_device\n         end interface\n \n+        interface\n+          function omp_get_device_num ()\n+            integer (4) :: omp_get_device_num\n+          end function omp_get_device_num\n+        end interface\n+\n         interface\n           function omp_get_max_task_priority ()\n             integer (4) :: omp_get_max_task_priority"}, {"sha": "20c32645e3c4491e7f8b053d5001b2cde266a0c7", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -244,6 +244,9 @@\n       external omp_get_initial_device\n       integer(4) omp_get_initial_device\n \n+      external omp_get_device_num\n+      integer(4) omp_get_device_num\n+\n       external omp_get_max_task_priority\n       integer(4) omp_get_max_task_priority\n "}, {"sha": "f26d73611067115062969fba9175efacaf1c2bcc", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -29,6 +29,7 @@\n /* {{{ Includes and defines  */\n \n #include \"config.h\"\n+#include \"symcat.h\"\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -3305,6 +3306,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   struct kernel_info *kernel;\n   int kernel_count = image_desc->kernel_count;\n   unsigned var_count = image_desc->global_variable_count;\n+  int other_count = 1;\n \n   agent = get_agent_info (ord);\n   if (!agent)\n@@ -3321,7 +3323,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n \n   GCN_DEBUG (\"Encountered %d kernels in an image\\n\", kernel_count);\n   GCN_DEBUG (\"Encountered %u global variables in an image\\n\", var_count);\n-  pair = GOMP_PLUGIN_malloc ((kernel_count + var_count - 2)\n+  GCN_DEBUG (\"Expect %d other variables in an image\\n\", other_count);\n+  pair = GOMP_PLUGIN_malloc ((kernel_count + var_count + other_count - 2)\n \t\t\t     * sizeof (struct addr_pair));\n   *target_table = pair;\n   module = (struct module_info *)\n@@ -3396,6 +3399,37 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       pair++;\n     }\n \n+  GCN_DEBUG (\"Looking for variable %s\\n\", STRINGX (GOMP_DEVICE_NUM_VAR));\n+\n+  hsa_status_t status;\n+  hsa_executable_symbol_t var_symbol;\n+  status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n+\t\t\t\t\t\t STRINGX (GOMP_DEVICE_NUM_VAR),\n+\t\t\t\t\t\t agent->id, 0, &var_symbol);\n+  if (status == HSA_STATUS_SUCCESS)\n+    {\n+      uint64_t device_num_varptr;\n+      uint32_t device_num_varsize;\n+\n+      status = hsa_fns.hsa_executable_symbol_get_info_fn\n+\t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS,\n+\t &device_num_varptr);\n+      if (status != HSA_STATUS_SUCCESS)\n+\thsa_fatal (\"Could not extract a variable from its symbol\", status);\n+      status = hsa_fns.hsa_executable_symbol_get_info_fn\n+\t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE,\n+\t &device_num_varsize);\n+      if (status != HSA_STATUS_SUCCESS)\n+\thsa_fatal (\"Could not extract a variable size from its symbol\", status);\n+\n+      pair->start = device_num_varptr;\n+      pair->end = device_num_varptr + device_num_varsize;\n+    }\n+  else\n+    /* The 'GOMP_DEVICE_NUM_VAR' variable was not in this image.  */\n+    pair->start = pair->end = 0;\n+  pair++;\n+\n   /* Ensure that constructors are run first.  */\n   struct GOMP_kernel_launch_attributes kla =\n     { 3,\n@@ -3418,7 +3452,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   if (module->fini_array_func)\n     kernel_count--;\n \n-  return kernel_count + var_count;\n+  return kernel_count + var_count + other_count;\n }\n \n /* Unload GCN object-code module described by struct gcn_image_desc in"}, {"sha": "0f16e1cf00dba800d03ab5ef7bbc8a72de6c6003", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -34,6 +34,7 @@\n #define _GNU_SOURCE\n #include \"openacc.h\"\n #include \"config.h\"\n+#include \"symcat.h\"\n #include \"libgomp-plugin.h\"\n #include \"oacc-plugin.h\"\n #include \"gomp-constants.h\"\n@@ -1265,7 +1266,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   CUmodule module;\n   const char *const *var_names;\n   const struct targ_fn_launch *fn_descs;\n-  unsigned int fn_entries, var_entries, i, j;\n+  unsigned int fn_entries, var_entries, other_entries, i, j;\n   struct targ_fn_descriptor *targ_fns;\n   struct addr_pair *targ_tbl;\n   const nvptx_tdata_t *img_header = (const nvptx_tdata_t *) target_data;\n@@ -1295,8 +1296,11 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   fn_entries = img_header->fn_num;\n   fn_descs = img_header->fn_descs;\n \n+  /* Currently, the only other entry kind is 'device number'.  */\n+  other_entries = 1;\n+\n   targ_tbl = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n-\t\t\t\t * (fn_entries + var_entries));\n+\t\t\t\t * (fn_entries + var_entries + other_entries));\n   targ_fns = GOMP_PLUGIN_malloc (sizeof (struct targ_fn_descriptor)\n \t\t\t\t * fn_entries);\n \n@@ -1345,9 +1349,24 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       targ_tbl->end = targ_tbl->start + bytes;\n     }\n \n+  CUdeviceptr device_num_varptr;\n+  size_t device_num_varsize;\n+  CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &device_num_varptr,\n+\t\t\t\t  &device_num_varsize, module,\n+\t\t\t\t  STRINGX (GOMP_DEVICE_NUM_VAR));\n+  if (r == CUDA_SUCCESS)\n+    {\n+      targ_tbl->start = (uintptr_t) device_num_varptr;\n+      targ_tbl->end = (uintptr_t) (device_num_varptr + device_num_varsize);\n+    }\n+  else\n+    /* The 'GOMP_DEVICE_NUM_VAR' variable was not in this image.  */\n+    targ_tbl->start = targ_tbl->end = 0;\n+  targ_tbl++;\n+\n   nvptx_set_clocktick (module, dev);\n \n-  return fn_entries + var_entries;\n+  return fn_entries + var_entries + other_entries;\n }\n \n /* Unload the program described by TARGET_DATA.  DEV_DATA is the"}, {"sha": "67fcf41cc2e6e68116f8db0093d9c0df7de63e8d", "filename": "libgomp/target.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -1974,6 +1974,9 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n   int num_funcs = host_funcs_end - host_func_table;\n   int num_vars  = (host_vars_end - host_var_table) / 2;\n \n+  /* Others currently is only 'device_num' */\n+  int num_others = 1;\n+\n   /* Load image to device and get target addresses for the image.  */\n   struct addr_pair *target_table = NULL;\n   int i, num_target_entries;\n@@ -1982,7 +1985,9 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n     = devicep->load_image_func (devicep->target_id, version,\n \t\t\t\ttarget_data, &target_table);\n \n-  if (num_target_entries != num_funcs + num_vars)\n+  if (num_target_entries != num_funcs + num_vars\n+      /* Others (device_num) are included as trailing entries in pair list.  */\n+      && num_target_entries != num_funcs + num_vars + num_others)\n     {\n       gomp_mutex_unlock (&devicep->lock);\n       if (is_register_lock)\n@@ -2054,6 +2059,35 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       array++;\n     }\n \n+  /* Last entry is for the on-device 'device_num' variable. Tolerate case\n+     where plugin does not return this entry.  */\n+  if (num_funcs + num_vars < num_target_entries)\n+    {\n+      struct addr_pair *device_num_var = &target_table[num_funcs + num_vars];\n+      /* Start address will be non-zero for last entry if GOMP_DEVICE_NUM_VAR\n+\t was found in this image.  */\n+      if (device_num_var->start != 0)\n+\t{\n+\t  /* The index of the devicep within devices[] is regarded as its\n+\t     'device number', which is different from the per-device type\n+\t     devicep->target_id.  */\n+\t  int device_num_val = (int) (devicep - &devices[0]);\n+\t  if (device_num_var->end - device_num_var->start != sizeof (int))\n+\t    {\n+\t      gomp_mutex_unlock (&devicep->lock);\n+\t      if (is_register_lock)\n+\t\tgomp_mutex_unlock (&register_lock);\n+\t      gomp_fatal (\"offload plugin managed 'device_num' not of expected \"\n+\t\t\t  \"format\");\n+\t    }\n+\n+\t  /* Copy device_num value to place on device memory, hereby actually\n+\t     designating its device number into effect.  */\n+\t  gomp_copy_host2dev (devicep, NULL, (void *) device_num_var->start,\n+\t\t\t      &device_num_val, sizeof (int), false, NULL);\n+\t}\n+    }\n+\n   free (target_table);\n }\n "}, {"sha": "ba8a73275c507d0d42148351ce0d2d2191e6dfb1", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -374,6 +374,11 @@ proc check_effective_target_offload_target_amdgcn { } {\n     return [libgomp_check_effective_target_offload_target \"amdgcn\"]\n }\n \n+# Return 1 if compiling for offload target intelmic\n+proc check_effective_target_offload_target_intelmic { } {\n+    return [libgomp_check_effective_target_offload_target \"*-intelmic\"]\n+}\n+\n # Return 1 if offload device is available.\n proc check_effective_target_offload_device { } {\n     return [check_runtime_nocache offload_device_available_ {"}, {"sha": "ec0d202e51cfdab164c8e84405539599c805e231", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-45.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { ! offload_target_intelmic } } } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int main (void)\n+{\n+\n+  int host_device_num = omp_get_device_num ();\n+\n+  if (host_device_num != omp_get_initial_device ())\n+    abort ();\n+\n+  int device_num;\n+  int initial_device;\n+\n+  #pragma omp target map(from: device_num, initial_device)\n+  {\n+    initial_device = omp_is_initial_device ();\n+    device_num = omp_get_device_num ();\n+  }\n+\n+  if (initial_device && host_device_num != device_num)\n+    abort ();\n+\n+  if (!initial_device && host_device_num == device_num)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "0b939ad7a0dcbbb3942dffb835171e6144f32efa", "filename": "libgomp/testsuite/libgomp.fortran/target10.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bac793ed6bad2c0c13cd1e93a1aa5808467afc8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90?ref=0bac793ed6bad2c0c13cd1e93a1aa5808467afc8", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run { target { ! offload_target_intelmic } } }\n+\n+program main\n+  use omp_lib\n+  implicit none\n+  integer :: device_num, host_device_num\n+  logical :: initial_device\n+\n+  host_device_num = omp_get_device_num ()\n+  if (host_device_num .ne. omp_get_initial_device ()) stop 1\n+\n+  !$omp target map(from: device_num, initial_device)\n+  initial_device = omp_is_initial_device ()\n+  device_num = omp_get_device_num ()\n+  !$omp end target\n+\n+  if (initial_device .and. (host_device_num .ne. device_num)) stop 2\n+  if ((.not. initial_device) .and. (host_device_num .eq. device_num)) stop 3\n+\n+end program main"}]}