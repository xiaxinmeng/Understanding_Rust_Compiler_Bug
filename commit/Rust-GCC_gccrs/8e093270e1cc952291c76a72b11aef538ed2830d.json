{"sha": "8e093270e1cc952291c76a72b11aef538ed2830d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwOTMyNzBlMWNjOTUyMjkxYzc2YTcyYjExYWVmNTM4ZWQyODMwZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-08-16T19:42:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-08-16T19:42:28Z"}, "message": "tree-core.h (tree_type_non_common): Rename binfo to lang_1.\n\n\t* tree-core.h (tree_type_non_common): Rename binfo to lang_1.\n\t* tree.h (TYPE_BINFO): Use type_non_common.maxval.\n\t(TYPE_LANG_SLOT_1): Use type_non_common.lang_1, for any type.\n\t* tree.c (free_lang_data_in_type): Use else-if chain.  Always\n\tclear TYPE_LANG_1.  Remove obsolete member-function stripping.\n\t(find_decls_types_r): Comment about TYPE_MAX_VALUES_RAW.\n\t(verify_type): Adjust for TYPE_BINFO move.\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body): No need to\n\tprocess TYPE_BINFO directly.\n\t(hash_tree): Likewise.\n\t* tree-streamer-in.c (lto_input_ts_type_non_common_tree_pointers):\n\tLikewise.\n\t* tree-streamer-out.c (write_ts_type_non_common_tree_pointers):\n\tLikewise.\n\n\tlto/\n\t* lto.c (mentions_vars_p_type): Use TYPE_LANG_SLOT_1.\n\t(compare_tree_sccs_1): No need to compare TYPE_BINFO directly.\n\t(lto_fixup_prevailing_decls): Use TYPE_LANG_SLOT_1.\n\nFrom-SVN: r251129", "tree": {"sha": "d94401e00911f189ce0200934a358febe2d2cbd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d94401e00911f189ce0200934a358febe2d2cbd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e093270e1cc952291c76a72b11aef538ed2830d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e093270e1cc952291c76a72b11aef538ed2830d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e093270e1cc952291c76a72b11aef538ed2830d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e093270e1cc952291c76a72b11aef538ed2830d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d001563319c4f599f04018acc6c497fbd67450d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d001563319c4f599f04018acc6c497fbd67450d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d001563319c4f599f04018acc6c497fbd67450d4"}], "stats": {"total": 179, "additions": 77, "deletions": 102}, "files": [{"sha": "f4ef9ad8791c63043044445df3c080b54f12a69b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -1,3 +1,25 @@\n+2017-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* tree-core.h (tree_type_non_common): Rename binfo to lang_1.\n+\t* tree.h (TYPE_BINFO): Use type_non_common.maxval.\n+\t(TYPE_LANG_SLOT_1): Use type_non_common.lang_1, for any type.\n+\t* tree.c (free_lang_data_in_type): Use else-if chain.  Always\n+\tclear TYPE_LANG_1.  Remove obsolete member-function stripping.\n+\t(find_decls_types_r): Comment about TYPE_MAX_VALUES_RAW.\n+\t(verify_type): Adjust for TYPE_BINFO move.\n+\t* lto-streamer-out.c (DFS::DFS_write_tree_body): No need to\n+\tprocess TYPE_BINFO directly.\n+\t(hash_tree): Likewise.\n+\t* tree-streamer-in.c (lto_input_ts_type_non_common_tree_pointers):\n+\tLikewise.\n+\t* tree-streamer-out.c (write_ts_type_non_common_tree_pointers):\n+\tLikewise.\n+\t\n+\tlto/\n+\t* lto.c (mentions_vars_p_type): Use TYPE_LANG_SLOT_1.\n+\t(compare_tree_sccs_1): No need to compare TYPE_BINFO directly.\n+\t(lto_fixup_prevailing_decls): Use TYPE_LANG_SLOT_1.\n+\n 2017-08-16  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic-show-locus.c (colorizer::m_caret): Remove unused"}, {"sha": "5988af52b2adb52d25ad2b26eb743cb49cb20ca7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -837,8 +837,6 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n       if (!POINTER_TYPE_P (expr))\n \tDFS_follow_tree_edge (TYPE_MIN_VALUE_RAW (expr));\n       DFS_follow_tree_edge (TYPE_MAX_VALUE_RAW (expr));\n-      if (RECORD_OR_UNION_TYPE_P (expr))\n-\tDFS_follow_tree_edge (TYPE_BINFO (expr));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n@@ -1273,8 +1271,6 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n       if (!POINTER_TYPE_P (t))\n \tvisit (TYPE_MIN_VALUE_RAW (t));\n       visit (TYPE_MAX_VALUE_RAW (t));\n-      if (RECORD_OR_UNION_TYPE_P (t))\n-\tvisit (TYPE_BINFO (t));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))"}, {"sha": "eb2a5daad999e719bf1047f0fbde5cde22e2a66e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -1,3 +1,9 @@\n+2017-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* lto.c (mentions_vars_p_type): Use TYPE_LANG_SLOT_1.\n+\t(compare_tree_sccs_1): No need to compare TYPE_BINFO directly.\n+\t(lto_fixup_prevailing_decls): Use TYPE_LANG_SLOT_1.\n+\n 2017-08-08  Tom de Vries  <tom@codesourcery.com>\n \n \t* lto.c: Include attribs.h."}, {"sha": "2064423418df13d84fbc0d4c5e31c5726e5de541", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -651,7 +651,7 @@ mentions_vars_p_type (tree t)\n   CHECK_VAR (TYPE_MAX_VALUE_RAW (t));\n \n   /* Accessor is for derived node types only. */\n-  CHECK_NO_VAR (t->type_non_common.binfo);\n+  CHECK_NO_VAR (TYPE_LANG_SLOT_1 (t));\n \n   CHECK_VAR (TYPE_CONTEXT (t));\n   CHECK_NO_VAR (TYPE_CANONICAL (t));\n@@ -1410,7 +1410,6 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \t       f1 || f2;\n \t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n \t    compare_tree_edges (f1, f2);\n-\t  compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n \t}\n       else if (code == FUNCTION_TYPE\n \t       || code == METHOD_TYPE)\n@@ -2584,7 +2583,7 @@ lto_fixup_prevailing_decls (tree t)\n \n       LTO_SET_PREVAIL (TYPE_MIN_VALUE_RAW (t));\n       LTO_SET_PREVAIL (TYPE_MAX_VALUE_RAW (t));\n-      LTO_NO_PREVAIL (t->type_non_common.binfo);\n+      LTO_NO_PREVAIL (TYPE_LANG_SLOT_1 (t));\n \n       LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n "}, {"sha": "5b9ca387565c363dceb996ce2c207632d56d141d", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -1552,7 +1552,7 @@ struct GTY(()) tree_type_non_common {\n   tree values;\n   tree minval;\n   tree maxval;\n-  tree binfo;\n+  tree lang_1;\n };\n \n struct GTY (()) tree_binfo {"}, {"sha": "4a49d924e7b7c6e5953a8a459a20f2619dc6d71b", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -841,8 +841,6 @@ lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n   if (!POINTER_TYPE_P (expr))\n     TYPE_MIN_VALUE_RAW (expr) = stream_read_tree (ib, data_in);\n   TYPE_MAX_VALUE_RAW (expr) = stream_read_tree (ib, data_in);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "32b23461dfdfe607c45d52625f6195191e647472", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -706,8 +706,6 @@ write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n   if (!POINTER_TYPE_P (expr))\n     stream_write_tree (ob, TYPE_MIN_VALUE_RAW (expr), ref_p);\n   stream_write_tree (ob, TYPE_MAX_VALUE_RAW (expr), ref_p);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    stream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n }\n \n "}, {"sha": "31fe31fb537527d041cdef5f96472777bc9903dc", "filename": "gcc/tree.c", "status": "modified", "additions": 43, "deletions": 86, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -4890,9 +4890,7 @@ free_lang_data_in_type (tree type)\n \t leading to false ODR violation errors when merging two\n \t instances of the same function signature compiled by\n \t different front ends.  */\n-      tree p;\n-\n-      for (p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+      for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n \t{\n \t  tree arg_type = TREE_VALUE (p);\n \n@@ -4908,69 +4906,30 @@ free_lang_data_in_type (tree type)\n \t  TREE_PURPOSE (p) = NULL;\n \t}\n     }\n-  if (TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      tree p;\n-\n-      for (p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n-\t{\n-\t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n-\t  TREE_PURPOSE (p) = NULL;\n-\t}\n-    }\n-\n-  /* Remove members that are not actually FIELD_DECLs from the field\n-     list of an aggregate.  These occur in C++.  */\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      tree prev, member;\n-\n-      /* Note that TYPE_FIELDS can be shared across distinct\n-\t TREE_TYPEs.  Therefore, if the first field of TYPE_FIELDS is\n-\t to be removed, we cannot set its TREE_CHAIN to NULL.\n-\t Otherwise, we would not be able to find all the other fields\n-\t in the other instances of this TREE_TYPE.\n-\n-\t This was causing an ICE in testsuite/g++.dg/lto/20080915.C.  */\n-      prev = NULL_TREE;\n-      member = TYPE_FIELDS (type);\n-      while (member)\n-\t{\n-\t  if (TREE_CODE (member) == FIELD_DECL\n-\t      || (TREE_CODE (member) == TYPE_DECL\n-\t\t  && !DECL_IGNORED_P (member)\n-\t\t  && debug_info_level > DINFO_LEVEL_TERSE\n-\t\t  && !is_redundant_typedef (member)))\n-\t    {\n-\t      if (prev)\n-\t\tTREE_CHAIN (prev) = member;\n-\t      else\n-\t\tTYPE_FIELDS (type) = member;\n-\t      prev = member;\n-\t    }\n-\n-\t  member = TREE_CHAIN (member);\n-\t}\n-\n-      if (prev)\n-\tTREE_CHAIN (prev) = NULL_TREE;\n-      else\n-\tTYPE_FIELDS (type) = NULL_TREE;\n+  else if (TREE_CODE (type) == METHOD_TYPE)\n+    for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+      /* C++ FE uses TREE_PURPOSE to store initial values.  */\n+      TREE_PURPOSE (p) = NULL;\n+  else if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      /* Remove members that are not FIELD_DECLs (and maybe\n+\t TYPE_DECLs) from the field list of an aggregate.  These occur\n+\t in C++.  */\n+      for (tree *prev = &TYPE_FIELDS (type), member; (member = *prev);)\n+\tif (TREE_CODE (member) == FIELD_DECL\n+\t    || (TREE_CODE (member) == TYPE_DECL\n+\t\t&& !DECL_IGNORED_P (member)\n+\t\t&& debug_info_level > DINFO_LEVEL_TERSE\n+\t\t&& !is_redundant_typedef (member)))\n+\t  prev = &DECL_CHAIN (member);\n+\telse\n+\t  *prev = DECL_CHAIN (member);\n \n       /* FIXME: C FE uses TYPE_VFIELD to record C_TYPE_INCOMPLETE_VARS\n  \t and danagle the pointer from time to time.  */\n       if (TYPE_VFIELD (type) && TREE_CODE (TYPE_VFIELD (type)) != FIELD_DECL)\n         TYPE_VFIELD (type) = NULL_TREE;\n \n-      /* Splice out FUNCTION_DECLS and TEMPLATE_DECLS from\n-\t TYPE_FIELDS.  So LTO doesn't grow.  */\n-      for (tree probe, *prev= &TYPE_FIELDS (type); (probe = *prev); )\n-\tif (TREE_CODE (probe) == FUNCTION_DECL\n-\t    || TREE_CODE (probe) == TEMPLATE_DECL)\n-\t  *prev = probe;\n-\telse\n-\t  prev = &DECL_CHAIN (probe);\n-\n       if (TYPE_BINFO (type))\n \t{\n \t  free_lang_data_in_binfo (TYPE_BINFO (type));\n@@ -4987,21 +4946,16 @@ free_lang_data_in_type (tree type)\n \t    TYPE_BINFO (type) = NULL;\n \t}\n     }\n-  else\n+  else if (INTEGRAL_TYPE_P (type)\n+\t   || SCALAR_FLOAT_TYPE_P (type)\n+\t   || FIXED_POINT_TYPE_P (type))\n     {\n-      /* For non-aggregate types, clear out the language slot (which\n-\t overloads TYPE_BINFO).  */\n-      TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n-\n-      if (INTEGRAL_TYPE_P (type)\n-\t  || SCALAR_FLOAT_TYPE_P (type)\n-\t  || FIXED_POINT_TYPE_P (type))\n-\t{\n-\t  free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n-\t  free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n-\t}\n+      free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n+      free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n     }\n \n+  TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n+\n   free_lang_data_in_one_sizepos (&TYPE_SIZE (type));\n   free_lang_data_in_one_sizepos (&TYPE_SIZE_UNIT (type));\n \n@@ -5382,6 +5336,7 @@ find_decls_types_r (tree *tp, int *ws, void *data)\n \t this way.  */\n       if (!POINTER_TYPE_P (t))\n \tfld_worklist_push (TYPE_MIN_VALUE_RAW (t), fld);\n+      /* TYPE_MAX_VALUE_RAW is TYPE_BINFO for record types.  */\n       if (!RECORD_OR_UNION_TYPE_P (t))\n \tfld_worklist_push (TYPE_MAX_VALUE_RAW (t), fld);\n       fld_worklist_push (TYPE_MAIN_VARIANT (t), fld);\n@@ -13267,9 +13222,23 @@ verify_type (const_tree t)\n \t but does not for C sizetypes in LTO.  */\n     }\n \n-  /* Check various uses of TYPE_MAXVAL.  */\n+  /* Check various uses of TYPE_MAXVAL_RAW.  */\n   if (RECORD_OR_UNION_TYPE_P (t))\n     {\n+      if (!TYPE_BINFO (t))\n+\t;\n+      else if (TREE_CODE (TYPE_BINFO (t)) != TREE_BINFO)\n+\t{\n+\t  error (\"TYPE_BINFO is not TREE_BINFO\");\n+\t  debug_tree (TYPE_BINFO (t));\n+\t  error_found = true;\n+\t}\n+      else if (TREE_TYPE (TYPE_BINFO (t)) != TYPE_MAIN_VARIANT (t))\n+\t{\n+\t  error (\"TYPE_BINFO type is not TYPE_MAIN_VARIANT\");\n+\t  debug_tree (TREE_TYPE (TYPE_BINFO (t)));\n+\t  error_found = true;\n+\t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n     {\n@@ -13318,19 +13287,7 @@ verify_type (const_tree t)\n       error_found = true;\n     }\n \n-  /* Check various uses of TYPE_BINFO.  */\n-  if (RECORD_OR_UNION_TYPE_P (t))\n-    {\n-      if (!TYPE_BINFO (t))\n-\t;\n-      else if (TREE_CODE (TYPE_BINFO (t)) != TREE_BINFO)\n-\t{\n-\t  error (\"TYPE_BINFO is not TREE_BINFO\");\n-\t  debug_tree (TYPE_BINFO (t));\n-\t  error_found = true;\n-\t}\n-    }\n-  else if (TYPE_LANG_SLOT_1 (t) && in_lto_p)\n+  if (TYPE_LANG_SLOT_1 (t) && in_lto_p)\n     {\n       error (\"TYPE_LANG_SLOT_1 (binfo) field is non-NULL\");\n       debug_tree (TYPE_LANG_SLOT_1 (t));"}, {"sha": "1f3cf1a115989a08835d07f061597598f67c1c49", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e093270e1cc952291c76a72b11aef538ed2830d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8e093270e1cc952291c76a72b11aef538ed2830d", "patch": "@@ -2129,14 +2129,13 @@ extern machine_mode element_mode (const_tree t);\n #define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n   (ARRAY_TYPE_CHECK (ARRAY_TYPE)->type_non_common.maxval)\n #define TYPE_MAX_VALUE_RAW(NODE) (TYPE_CHECK (NODE)->type_non_common.maxval)\n-\n /* For record and union types, information about this type, as a base type\n    for itself.  */\n-#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK (NODE)->type_non_common.binfo)\n+#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK (NODE)->type_non_common.maxval)\n \n-/* For non record and union types, used in a language-dependent way.  */\n+/* For types, used in a language-dependent way.  */\n #define TYPE_LANG_SLOT_1(NODE) \\\n-  (NOT_RECORD_OR_UNION_CHECK (NODE)->type_non_common.binfo)\n+  (TYPE_CHECK (NODE)->type_non_common.lang_1)\n \n /* Define accessor macros for information about type inheritance\n    and basetypes."}]}