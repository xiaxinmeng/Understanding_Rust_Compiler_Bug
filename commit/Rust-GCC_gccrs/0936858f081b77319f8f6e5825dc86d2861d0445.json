{"sha": "0936858f081b77319f8f6e5825dc86d2861d0445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzNjg1OGYwODFiNzczMTlmOGY2ZTU4MjVkYzg2ZDI4NjFkMDQ0NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-07-12T13:01:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-12T13:01:48Z"}, "message": "Support fused multiply-adds in fully-masked reductions\n\nThis patch adds support for fusing a conditional add or subtract\nwith a multiplication, so that we can use fused multiply-add and\nmultiply-subtract operations for fully-masked reductions.  E.g.\nfor SVE we vectorise:\n\n  double res = 0.0;\n  for (int i = 0; i < n; ++i)\n    res += x[i] * y[i];\n\nusing a fully-masked loop in which the loop body has the form:\n\n  res_1 = PHI<0(preheader), res_2(latch)>;\n  avec = .MASK_LOAD (loop_mask, a)\n  bvec = .MASK_LOAD (loop_mask, b)\n  prod = avec * bvec;\n  res_2 = .COND_ADD (loop_mask, res_1, prod, res_1);\n\nwhere the last statement does the equivalent of:\n\n  res_2 = loop_mask ? res_1 + prod : res_1;\n\n(operating elementwise).  The point of the patch is to convert the last\ntwo statements into:\n\n  res_s = .COND_FMA (loop_mask, avec, bvec, res_1, res_1);\n\nwhich is equivalent to:\n\n  res_2 = loop_mask ? fma (avec, bvec, res_1) : res_1;\n\n(again operating elementwise).\n\n2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* internal-fn.h (can_interpret_as_conditional_op_p): Declare.\n\t* internal-fn.c (can_interpret_as_conditional_op_p): New function.\n\t* tree-ssa-math-opts.c (convert_mult_to_fma_1): Handle conditional\n\tplus and minus and convert them into IFN_COND_FMA-based sequences.\n\t(convert_mult_to_fma): Handle conditional plus and minus.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-fma-2.c: New test.\n\t* gcc.target/aarch64/sve/reduc_4.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_6.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_7.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r262588", "tree": {"sha": "87c7aa8363d38fe0e4022d33f8a25f14b6dc8ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87c7aa8363d38fe0e4022d33f8a25f14b6dc8ff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0936858f081b77319f8f6e5825dc86d2861d0445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0936858f081b77319f8f6e5825dc86d2861d0445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0936858f081b77319f8f6e5825dc86d2861d0445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0936858f081b77319f8f6e5825dc86d2861d0445/comments", "author": null, "committer": null, "parents": [{"sha": "b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41d1f6ed753bf7ae7e68f745e50c26ee65b5711"}], "stats": {"total": 265, "additions": 209, "deletions": 56}, "files": [{"sha": "20ed355ca124bdc675332ceace84a8e312cbb62f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -1,3 +1,13 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* internal-fn.h (can_interpret_as_conditional_op_p): Declare.\n+\t* internal-fn.c (can_interpret_as_conditional_op_p): New function.\n+\t* tree-ssa-math-opts.c (convert_mult_to_fma_1): Handle conditional\n+\tplus and minus and convert them into IFN_COND_FMA-based sequences.\n+\t(convert_mult_to_fma): Handle conditional plus and minus.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/md.texi (cond_fma, cond_fms, cond_fnma, cond_fnms): Document."}, {"sha": "15755ea06fdaca14ebbfcbfb80e7ab18418f3a0d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -3333,6 +3333,62 @@ get_unconditional_internal_fn (internal_fn ifn)\n     }\n }\n \n+/* Return true if STMT can be interpreted as a conditional tree code\n+   operation of the form:\n+\n+     LHS = COND ? OP (RHS1, ...) : ELSE;\n+\n+   operating elementwise if the operands are vectors.  This includes\n+   the case of an all-true COND, so that the operation always happens.\n+\n+   When returning true, set:\n+\n+   - *COND_OUT to the condition COND, or to NULL_TREE if the condition\n+     is known to be all-true\n+   - *CODE_OUT to the tree code\n+   - OPS[I] to operand I of *CODE_OUT\n+   - *ELSE_OUT to the fallback value ELSE, or to NULL_TREE if the\n+     condition is known to be all true.  */\n+\n+bool\n+can_interpret_as_conditional_op_p (gimple *stmt, tree *cond_out,\n+\t\t\t\t   tree_code *code_out,\n+\t\t\t\t   tree (&ops)[3], tree *else_out)\n+{\n+  if (gassign *assign = dyn_cast <gassign *> (stmt))\n+    {\n+      *cond_out = NULL_TREE;\n+      *code_out = gimple_assign_rhs_code (assign);\n+      ops[0] = gimple_assign_rhs1 (assign);\n+      ops[1] = gimple_assign_rhs2 (assign);\n+      ops[2] = gimple_assign_rhs3 (assign);\n+      *else_out = NULL_TREE;\n+      return true;\n+    }\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    if (gimple_call_internal_p (call))\n+      {\n+\tinternal_fn ifn = gimple_call_internal_fn (call);\n+\ttree_code code = conditional_internal_fn_code (ifn);\n+\tif (code != ERROR_MARK)\n+\t  {\n+\t    *cond_out = gimple_call_arg (call, 0);\n+\t    *code_out = code;\n+\t    unsigned int nops = gimple_call_num_args (call) - 2;\n+\t    for (unsigned int i = 0; i < 3; ++i)\n+\t      ops[i] = i < nops ? gimple_call_arg (call, i + 1) : NULL_TREE;\n+\t    *else_out = gimple_call_arg (call, nops + 1);\n+\t    if (integer_truep (*cond_out))\n+\t      {\n+\t\t*cond_out = NULL_TREE;\n+\t\t*else_out = NULL_TREE;\n+\t      }\n+\t    return true;\n+\t  }\n+      }\n+  return false;\n+}\n+\n /* Return true if IFN is some form of load from memory.  */\n \n bool"}, {"sha": "2296ca0c53903fed2d177d3d03a2046e4c2c6253", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -196,6 +196,9 @@ extern internal_fn get_conditional_internal_fn (tree_code);\n extern internal_fn get_conditional_internal_fn (internal_fn);\n extern tree_code conditional_internal_fn_code (internal_fn);\n extern internal_fn get_unconditional_internal_fn (internal_fn);\n+extern bool can_interpret_as_conditional_op_p (gimple *, tree *,\n+\t\t\t\t\t       tree_code *, tree (&)[3],\n+\t\t\t\t\t       tree *);\n \n extern bool internal_load_fn_p (internal_fn);\n extern bool internal_store_fn_p (internal_fn);"}, {"sha": "8291e3d72f0e060a420e8b4d036e581c2cf209b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -1,3 +1,12 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/vect-fma-2.c: New test.\n+\t* gcc.target/aarch64/sve/reduc_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_7.c: Likewise.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/vect-cond-arith-3.c: New test."}, {"sha": "20d1baff28fbcca37454b2bb5893a7bab955621e", "filename": "gcc/testsuite/gcc.dg/vect/vect-fma-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fma-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fma-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fma-2.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-optimized -fassociative-math -fno-trapping-math -fno-signed-zeros\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 3)\n+\n+double\n+dot_prod (double *x, double *y)\n+{\n+  double sum = 0;\n+  for (int i = 0; i < N; ++i)\n+    sum += x[i] * y[i];\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump { = \\.COND_FMA } \"optimized\" { target { vect_double && { vect_fully_masked && scalar_all_fma } } } } } */"}, {"sha": "eb4b231dcc62c4b8695413e57a171ab677248600", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_4.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+double\n+f (double *restrict a, double *restrict b, int *lookup)\n+{\n+  double res = 0.0;\n+  for (int i = 0; i < 512; ++i)\n+    res += a[lookup[i]] * b[i];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+.d, p[0-7]/m, } 2 } } */\n+/* Check that the vector instructions are the only instructions.  */\n+/* { dg-final { scan-assembler-times {\\tfmla\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tfadd\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\td0,} 1 } } */\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "65647c4e97abad96ac3091e9a8d4f2c847548eab", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_6.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define REDUC(TYPE)\t\t\t\t\t\t\\\n+  TYPE reduc_##TYPE (TYPE *x, TYPE *y, int count)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE sum = 0;\t\t\t\t\t\t\\\n+    for (int i = 0; i < count; ++i)\t\t\t\t\\\n+      sum += x[i] * y[i];\t\t\t\t\t\\\n+    return sum;\t\t\t\t\t\t\t\\\n+  }\n+\n+REDUC (float)\n+REDUC (double)\n+\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.s, p[0-7]/m} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmla\\tz[0-9]+\\.d, p[0-7]/m} 1 } } */"}, {"sha": "b4b408a0c57df68dcd2bf90c6940bad7043fd0be", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_7.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#define REDUC(TYPE)\t\t\t\t\t\t\\\n+  TYPE reduc_##TYPE (TYPE *x, TYPE *y, int count)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE sum = 0;\t\t\t\t\t\t\\\n+    for (int i = 0; i < count; ++i)\t\t\t\t\\\n+      sum -= x[i] * y[i];\t\t\t\t\t\\\n+    return sum;\t\t\t\t\t\t\t\\\n+  }\n+\n+REDUC (float)\n+REDUC (double)\n+\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.s, p[0-7]/m} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmls\\tz[0-9]+\\.d, p[0-7]/m} 1 } } */"}, {"sha": "e32669dc944b66d749fc5bc2b0952ca630f3a878", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0936858f081b77319f8f6e5825dc86d2861d0445/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=0936858f081b77319f8f6e5825dc86d2861d0445", "patch": "@@ -2655,16 +2655,15 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-      enum tree_code use_code;\n       tree addop, mulop1 = op1, result = mul_result;\n       bool negate_p = false;\n       gimple_seq seq = NULL;\n \n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      use_code = gimple_assign_rhs_code (use_stmt);\n-      if (use_code == NEGATE_EXPR)\n+      if (is_gimple_assign (use_stmt)\n+\t  && gimple_assign_rhs_code (use_stmt) == NEGATE_EXPR)\n \t{\n \t  result = gimple_assign_lhs (use_stmt);\n \t  use_operand_p use_p;\n@@ -2675,22 +2674,23 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n \n \t  use_stmt = neguse_stmt;\n \t  gsi = gsi_for_stmt (use_stmt);\n-\t  use_code = gimple_assign_rhs_code (use_stmt);\n \t  negate_p = true;\n \t}\n \n-      if (gimple_assign_rhs1 (use_stmt) == result)\n+      tree cond, else_value, ops[3];\n+      tree_code code;\n+      if (!can_interpret_as_conditional_op_p (use_stmt, &cond, &code,\n+\t\t\t\t\t      ops, &else_value))\n+\tgcc_unreachable ();\n+      addop = ops[0] == result ? ops[1] : ops[0];\n+\n+      if (code == MINUS_EXPR)\n \t{\n-\t  addop = gimple_assign_rhs2 (use_stmt);\n-\t  /* a * b - c -> a * b + (-c)  */\n-\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t  if (ops[0] == result)\n+\t    /* a * b - c -> a * b + (-c)  */\n \t    addop = gimple_build (&seq, NEGATE_EXPR, type, addop);\n-\t}\n-      else\n-\t{\n-\t  addop = gimple_assign_rhs1 (use_stmt);\n-\t  /* a - b * c -> (-b) * c + a */\n-\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t  else\n+\t    /* a - b * c -> (-b) * c + a */\n \t    negate_p = !negate_p;\n \t}\n \n@@ -2699,8 +2699,13 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n \n       if (seq)\n \tgsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n-      fma_stmt = gimple_build_call_internal (IFN_FMA, 3, mulop1, op2, addop);\n-      gimple_call_set_lhs (fma_stmt, gimple_assign_lhs (use_stmt));\n+\n+      if (cond)\n+\tfma_stmt = gimple_build_call_internal (IFN_COND_FMA, 5, cond, mulop1,\n+\t\t\t\t\t       op2, addop, else_value);\n+      else\n+\tfma_stmt = gimple_build_call_internal (IFN_FMA, 3, mulop1, op2, addop);\n+      gimple_set_lhs (fma_stmt, gimple_get_lhs (use_stmt));\n       gimple_call_set_nothrow (fma_stmt, !stmt_can_throw_internal (use_stmt));\n       gsi_replace (&gsi, fma_stmt, true);\n       /* Follow all SSA edges so that we generate FMS, FNMA and FNMS\n@@ -2883,7 +2888,6 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n      as an addition.  */\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, mul_result)\n     {\n-      enum tree_code use_code;\n       tree result = mul_result;\n       bool negate_p = false;\n \n@@ -2904,13 +2908,9 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n       if (gimple_bb (use_stmt) != gimple_bb (mul_stmt))\n \treturn false;\n \n-      if (!is_gimple_assign (use_stmt))\n-\treturn false;\n-\n-      use_code = gimple_assign_rhs_code (use_stmt);\n-\n       /* A negate on the multiplication leads to FNMA.  */\n-      if (use_code == NEGATE_EXPR)\n+      if (is_gimple_assign (use_stmt)\n+\t  && gimple_assign_rhs_code (use_stmt) == NEGATE_EXPR)\n \t{\n \t  ssa_op_iter iter;\n \t  use_operand_p usep;\n@@ -2932,17 +2932,20 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n \t  use_stmt = neguse_stmt;\n \t  if (gimple_bb (use_stmt) != gimple_bb (mul_stmt))\n \t    return false;\n-\t  if (!is_gimple_assign (use_stmt))\n-\t    return false;\n \n-\t  use_code = gimple_assign_rhs_code (use_stmt);\n \t  negate_p = true;\n \t}\n \n-      switch (use_code)\n+      tree cond, else_value, ops[3];\n+      tree_code code;\n+      if (!can_interpret_as_conditional_op_p (use_stmt, &cond, &code, ops,\n+\t\t\t\t\t      &else_value))\n+\treturn false;\n+\n+      switch (code)\n \t{\n \tcase MINUS_EXPR:\n-\t  if (gimple_assign_rhs2 (use_stmt) == result)\n+\t  if (ops[1] == result)\n \t    negate_p = !negate_p;\n \t  break;\n \tcase PLUS_EXPR:\n@@ -2952,47 +2955,50 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n \t  return false;\n \t}\n \n-      /* If the subtrahend (gimple_assign_rhs2 (use_stmt)) is computed\n-\t by a MULT_EXPR that we'll visit later, we might be able to\n-\t get a more profitable match with fnma.\n+      if (cond)\n+\t{\n+\t  if (cond == result || else_value == result)\n+\t    return false;\n+\t  if (!direct_internal_fn_supported_p (IFN_COND_FMA, type, opt_type))\n+\t    return false;\n+\t}\n+\n+      /* If the subtrahend (OPS[1]) is computed by a MULT_EXPR that\n+\t we'll visit later, we might be able to get a more profitable\n+\t match with fnma.\n \t OTOH, if we don't, a negate / fma pair has likely lower latency\n \t that a mult / subtract pair.  */\n-      if (use_code == MINUS_EXPR && !negate_p\n-\t  && gimple_assign_rhs1 (use_stmt) == result\n+      if (code == MINUS_EXPR\n+\t  && !negate_p\n+\t  && ops[0] == result\n \t  && !direct_internal_fn_supported_p (IFN_FMS, type, opt_type)\n-\t  && direct_internal_fn_supported_p (IFN_FNMA, type, opt_type))\n+\t  && direct_internal_fn_supported_p (IFN_FNMA, type, opt_type)\n+\t  && TREE_CODE (ops[1]) == SSA_NAME\n+\t  && has_single_use (ops[1]))\n \t{\n-\t  tree rhs2 = gimple_assign_rhs2 (use_stmt);\n-\n-\t  if (TREE_CODE (rhs2) == SSA_NAME)\n-\t    {\n-\t      gimple *stmt2 = SSA_NAME_DEF_STMT (rhs2);\n-\t      if (has_single_use (rhs2)\n-\t\t  && is_gimple_assign (stmt2)\n-\t\t  && gimple_assign_rhs_code (stmt2) == MULT_EXPR)\n-\t      return false;\n-\t    }\n+\t  gimple *stmt2 = SSA_NAME_DEF_STMT (ops[1]);\n+\t  if (is_gimple_assign (stmt2)\n+\t      && gimple_assign_rhs_code (stmt2) == MULT_EXPR)\n+\t    return false;\n \t}\n \n-      tree use_rhs1 = gimple_assign_rhs1 (use_stmt);\n-      tree use_rhs2 = gimple_assign_rhs2 (use_stmt);\n       /* We can't handle a * b + a * b.  */\n-      if (use_rhs1 == use_rhs2)\n+      if (ops[0] == ops[1])\n \treturn false;\n       /* If deferring, make sure we are not looking at an instruction that\n \t wouldn't have existed if we were not.  */\n       if (state->m_deferring_p\n-\t  && (state->m_mul_result_set.contains (use_rhs1)\n-\t      || state->m_mul_result_set.contains (use_rhs2)))\n+\t  && (state->m_mul_result_set.contains (ops[0])\n+\t      || state->m_mul_result_set.contains (ops[1])))\n \treturn false;\n \n       if (check_defer)\n \t{\n-\t  tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t  tree use_lhs = gimple_get_lhs (use_stmt);\n \t  if (state->m_last_result)\n \t    {\n-\t      if (use_rhs2 == state->m_last_result\n-\t\t  || use_rhs1 == state->m_last_result)\n+\t      if (ops[1] == state->m_last_result\n+\t\t  || ops[0] == state->m_last_result)\n \t\tdefer = true;\n \t      else\n \t\tdefer = false;\n@@ -3001,12 +3007,12 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n \t    {\n \t      gcc_checking_assert (!state->m_initial_phi);\n \t      gphi *phi;\n-\t      if (use_rhs1 == result)\n-\t\tphi = result_of_phi (use_rhs2);\n+\t      if (ops[0] == result)\n+\t\tphi = result_of_phi (ops[1]);\n \t      else\n \t\t{\n-\t\t  gcc_assert (use_rhs2 == result);\n-\t\t  phi = result_of_phi (use_rhs1);\n+\t\t  gcc_assert (ops[1] == result);\n+\t\t  phi = result_of_phi (ops[0]);\n \t\t}\n \n \t      if (phi)"}]}