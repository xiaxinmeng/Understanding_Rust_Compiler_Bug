{"sha": "5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNjOTM1M2Q1NzZlZDRjNzkyMDNmNWM0N2NmNzRiZjAzNDE4YjFhNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-02T09:52:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T09:52:49Z"}, "message": "sem_res.adb: Minor reformatting.\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb: Minor reformatting.\n\nFrom-SVN: r177115", "tree": {"sha": "c09dc8c5428e66cb9022392a364140ed5aed8b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09dc8c5428e66cb9022392a364140ed5aed8b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc9353d576ed4c79203f5c47cf74bf03418b1a4/comments", "author": null, "committer": null, "parents": [{"sha": "e51537ff6cdf7a85ed58883511d00ee309c21bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51537ff6cdf7a85ed58883511d00ee309c21bd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51537ff6cdf7a85ed58883511d00ee309c21bd9"}], "stats": {"total": 356, "additions": 178, "deletions": 178}, "files": [{"sha": "24556944b3186d528610bea3a9535a7a5470349e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc9353d576ed4c79203f5c47cf74bf03418b1a4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc9353d576ed4c79203f5c47cf74bf03418b1a4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "patch": "@@ -1,3 +1,7 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb: Minor reformatting.\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads,"}, {"sha": "eb736a03662c81c9a9dfe63a2f593f9dd93b424a", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 174, "deletions": 178, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc9353d576ed4c79203f5c47cf74bf03418b1a4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc9353d576ed4c79203f5c47cf74bf03418b1a4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5cc9353d576ed4c79203f5c47cf74bf03418b1a4", "patch": "@@ -84,11 +84,11 @@ package body Sem_Res is\n    -----------------------\n \n    --  Second pass (top-down) type checking and overload resolution procedures\n-   --  Typ is the type required by context. These procedures propagate the\n-   --  type information recursively to the descendants of N. If the node\n-   --  is not overloaded, its Etype is established in the first pass. If\n-   --  overloaded,  the Resolve routines set the correct type. For arith.\n-   --  operators, the Etype is the base type of the context.\n+   --  Typ is the type required by context. These procedures propagate the type\n+   --  information recursively to the descendants of N. If the node is not\n+   --  overloaded, its Etype is established in the first pass. If overloaded,\n+   --  the Resolve routines set the correct type. For arith. operators, the\n+   --  Etype is the base type of the context.\n \n    --  Note that Resolve_Attribute is separated off in Sem_Attr\n \n@@ -136,8 +136,8 @@ package body Sem_Res is\n    --  the style check for Style_Check_Boolean_And_Or.\n \n    function Is_Definite_Access_Type (E : Entity_Id) return Boolean;\n-   --  Determine whether E is an access type declared by an access\n-   --  declaration, and not an (anonymous) allocator type.\n+   --  Determine whether E is an access type declared by an access declaration,\n+   --  and not an (anonymous) allocator type.\n \n    function Is_Predefined_Op (Nam : Entity_Id) return Boolean;\n    --  Utility to check whether the entity for an operator is a predefined\n@@ -226,11 +226,10 @@ package body Sem_Res is\n    --  function with no arguments, and the return value is indexed.\n \n    procedure Resolve_Intrinsic_Operator (N : Node_Id; Typ : Entity_Id);\n-   --  A call to a user-defined intrinsic operator is rewritten as a call\n-   --  to the corresponding predefined operator, with suitable conversions.\n-   --  Note that this applies only for intrinsic operators that denote\n-   --  predefined operators, not operators that are intrinsic imports of\n-   --  back-end builtins.\n+   --  A call to a user-defined intrinsic operator is rewritten as a call to\n+   --  the corresponding predefined operator, with suitable conversions. Note\n+   --  that this applies only for intrinsic operators that denote predefined\n+   --  operators, not ones that are intrinsic imports of back-end builtins.\n \n    procedure Resolve_Intrinsic_Unary_Operator (N : Node_Id; Typ : Entity_Id);\n    --  Ditto, for unary operators (arithmetic ones and \"not\" on signed\n@@ -270,19 +269,19 @@ package body Sem_Res is\n    --  to integer conversion and Truncation attribute.\n \n    function Unique_Fixed_Point_Type (N : Node_Id) return Entity_Id;\n-   --  A universal_fixed expression in an universal context is unambiguous\n-   --  if there is only one applicable fixed point type. Determining whether\n-   --  there is only one requires a search over all visible entities, and\n-   --  happens only in very pathological cases (see 6115-006).\n+   --  A universal_fixed expression in an universal context is unambiguous if\n+   --  there is only one applicable fixed point type. Determining whether there\n+   --  is only one requires a search over all visible entities, and happens\n+   --  only in very pathological cases (see 6115-006).\n \n    function Valid_Conversion\n      (N       : Node_Id;\n       Target  : Entity_Id;\n       Operand : Node_Id) return Boolean;\n-   --  Verify legality rules given in 4.6 (8-23). Target is the target\n-   --  type of the conversion, which may be an implicit conversion of\n-   --  an actual parameter to an anonymous access type (in which case\n-   --  N denotes the actual parameter and N = Operand).\n+   --  Verify legality rules given in 4.6 (8-23). Target is the target type\n+   --  of the conversion, which may be an implicit conversion of an actual\n+   --  parameter to an anonymous access type (in which case N denotes the\n+   --  actual parameter and N = Operand).\n \n    -------------------------\n    -- Ambiguous_Character --\n@@ -365,11 +364,11 @@ package body Sem_Res is\n       if Current_Scope /= Scop\n         and then Scope_Is_Transient\n       then\n-         --  This can only happen if a transient scope was created\n-         --  for an inner expression, which will be removed upon\n-         --  completion of the analysis of an enclosing construct.\n-         --  The transient scope must have the suppress status of\n-         --  the enclosing environment, not of this Analyze call.\n+         --  This can only happen if a transient scope was created for an inner\n+         --  expression, which will be removed upon completion of the analysis\n+         --  of an enclosing construct. The transient scope must have the\n+         --  suppress status of the enclosing environment, not of this Analyze\n+         --  call.\n \n          Scope_Stack.Table (Scope_Stack.Last).Save_Scope_Suppress :=\n            Scope_Suppress;\n@@ -457,13 +456,12 @@ package body Sem_Res is\n \n          elsif Nkind (P) = N_Index_Or_Discriminant_Constraint then\n \n-            --  The following check catches the unusual case where\n-            --  a discriminant appears within an index constraint\n-            --  that is part of a larger expression within a constraint\n-            --  on a component, e.g. \"C : Int range 1 .. F (new A(1 .. D))\".\n-            --  For now we only check case of record components, and\n-            --  note that a similar check should also apply in the\n-            --  case of discriminant constraints below. ???\n+            --  The following check catches the unusual case where a\n+            --  discriminant appears within an index constraint that is part of\n+            --  a larger expression within a constraint on a component, e.g. \"C\n+            --  : Int range 1 .. F (new A(1 .. D))\". For now we only check case\n+            --  of record components, and note that a similar check should also\n+            --  apply in the case of discriminant constraints below. ???\n \n             --  Note that the check for N_Subtype_Declaration below is to\n             --  detect the valid use of discriminants in the constraints of a\n@@ -505,9 +503,9 @@ package body Sem_Res is\n                CB : Entity_Id;\n \n                function Large_Storage_Type (T : Entity_Id) return Boolean;\n-               --  Return True if type T has a large enough range that\n-               --  any array whose index type covered the whole range of\n-               --  the type would likely raise Storage_Error.\n+               --  Return True if type T has a large enough range that any\n+               --  array whose index type covered the whole range of the type\n+               --  would likely raise Storage_Error.\n \n                ------------------------\n                -- Large_Storage_Type --\n@@ -551,8 +549,8 @@ package body Sem_Res is\n                   goto No_Danger;\n                end if;\n \n-               --  Check the array allows a large range at this bound.\n-               --  First find the array\n+               --  Check the array allows a large range at this bound. First\n+               --  find the array\n \n                SI := Parent (P);\n \n@@ -619,8 +617,8 @@ package body Sem_Res is\n \n          return;\n \n-      --  Otherwise, context is an expression. It should not be within\n-      --  (i.e. a subexpression of) a constraint for a component.\n+      --  Otherwise, context is an expression. It should not be within (i.e. a\n+      --  subexpression of) a constraint for a component.\n \n       else\n          D := PN;\n@@ -634,10 +632,10 @@ package body Sem_Res is\n             exit when No (P);\n          end loop;\n \n-         --  If the discriminant is used in an expression that is a bound\n-         --  of a scalar type, an Itype is created and the bounds are attached\n-         --  to its range,  not to the original subtype indication. Such use\n-         --  is of course a double fault.\n+         --  If the discriminant is used in an expression that is a bound of a\n+         --  scalar type, an Itype is created and the bounds are attached to\n+         --  its range, not to the original subtype indication. Such use is of\n+         --  course a double fault.\n \n          if (Nkind (P) = N_Subtype_Indication\n               and then Nkind_In (Parent (P), N_Component_Definition,\n@@ -731,8 +729,8 @@ package body Sem_Res is\n       C : Node_Id;\n \n       function Same_Argument_List return Boolean;\n-      --  Check whether list of actuals is identical to list of formals\n-      --  of called function (which is also the enclosing scope).\n+      --  Check whether list of actuals is identical to list of formals of\n+      --  called function (which is also the enclosing scope).\n \n       ------------------------\n       -- Same_Argument_List --\n@@ -1111,8 +1109,8 @@ package body Sem_Res is\n                                                               E_Procedure)\n                          and then Is_Overloaded (Selector_Name (N)))))\n \n-      --  If one of the above three conditions is met, rewrite as call.\n-      --  Apply the rewriting only once.\n+      --  If one of the above three conditions is met, rewrite as call. Apply\n+      --  the rewriting only once.\n \n       then\n          if Nkind (Parent (N)) /= N_Function_Call\n@@ -1556,11 +1554,11 @@ package body Sem_Res is\n \n       if Is_Private_Type (Typ) then\n          case Nkind (N) is\n-            when N_Op_Add  | N_Op_Subtract | N_Op_Multiply | N_Op_Divide |\n-            N_Op_Expon     | N_Op_Mod      | N_Op_Rem      =>\n+            when N_Op_Add   | N_Op_Subtract | N_Op_Multiply | N_Op_Divide |\n+                 N_Op_Expon | N_Op_Mod      | N_Op_Rem      =>\n                Resolve_Intrinsic_Operator (N, Typ);\n \n-            when N_Op_Plus | N_Op_Minus    | N_Op_Abs      =>\n+            when N_Op_Plus  | N_Op_Minus    | N_Op_Abs      =>\n                Resolve_Intrinsic_Unary_Operator (N, Typ);\n \n             when others =>\n@@ -1779,8 +1777,8 @@ package body Sem_Res is\n       begin\n          return\n            Sloc (Nod) = Standard_Location\n-             or else Is_Predefined_File_Name (Unit_File_Name (\n-                       Get_Source_Unit (Sloc (Nod))));\n+             or else Is_Predefined_File_Name\n+                       (Unit_File_Name (Get_Source_Unit (Sloc (Nod))));\n       end Comes_From_Predefined_Lib_Unit;\n \n       --------------------\n@@ -2215,9 +2213,9 @@ package body Sem_Res is\n                         end if;\n \n                      --  If this is an indirect call, use the subprogram_type\n-                     --  in the message, to have a meaningful location.\n-                     --  Also indicate if this is an inherited operation,\n-                     --  created by a type declaration.\n+                     --  in the message, to have a meaningful location. Also\n+                     --  indicate if this is an inherited operation, created\n+                     --  by a type declaration.\n \n                      elsif Nkind (N) = N_Function_Call\n                        and then Nkind (Name (N)) = N_Explicit_Dereference\n@@ -2464,10 +2462,10 @@ package body Sem_Res is\n                   procedure Check_Elmt (Aelmt : Node_Id) is\n                   begin\n                      --  If we have a nested aggregate, go inside it (to\n-                     --  attempt a naked analyze-resolve of the aggregate\n-                     --  can cause undesirable cascaded errors). Do not\n-                     --  resolve expression if it needs a type from context,\n-                     --  as for integer * fixed expression.\n+                     --  attempt a naked analyze-resolve of the aggregate can\n+                     --  cause undesirable cascaded errors). Do not resolve\n+                     --  expression if it needs a type from context, as for\n+                     --  integer * fixed expression.\n \n                      if Nkind (Aelmt) = N_Aggregate then\n                         Check_Aggr (Aelmt);\n@@ -2492,9 +2490,8 @@ package body Sem_Res is\n                end;\n             end if;\n \n-            --  If an error message was issued already, Found got reset\n-            --  to True, so if it is still False, issue the standard\n-            --  Wrong_Type message.\n+            --  If an error message was issued already, Found got reset to\n+            --  True, so if it is still False, issue standard Wrong_Type msg.\n \n             if not Found then\n                if Is_Overloaded (N)\n@@ -2574,9 +2571,9 @@ package body Sem_Res is\n          then\n             Ctx_Type := Expr_Type;\n \n-            --  Any_Fixed is legal in a real context only if a specific\n-            --  fixed point type is imposed. If Norman Cohen can be\n-            --  confused by this, it deserves a separate message.\n+            --  Any_Fixed is legal in a real context only if a specific fixed-\n+            --  point type is imposed. If Norman Cohen can be confused by this,\n+            --  it deserves a separate message.\n \n             if Typ = Any_Real\n               and then Expr_Type = Any_Fixed\n@@ -2770,16 +2767,16 @@ package body Sem_Res is\n          --  Freeze expression type, entity if it is a name, and designated\n          --  type if it is an allocator (RM 13.14(10,11,13)).\n \n-         --  Now that the resolution of the type of the node is complete,\n-         --  and we did not detect an error, we can expand this node. We\n-         --  skip the expand call if we are in a default expression, see\n-         --  section \"Handling of Default Expressions\" in Sem spec.\n+         --  Now that the resolution of the type of the node is complete, and\n+         --  we did not detect an error, we can expand this node. We skip the\n+         --  expand call if we are in a default expression, see section\n+         --  \"Handling of Default Expressions\" in Sem spec.\n \n          Debug_A_Exit (\"resolving  \", N, \"  (done)\");\n \n          --  We unconditionally freeze the expression, even if we are in\n-         --  default expression mode (the Freeze_Expression routine tests\n-         --  this flag and only freezes static types if it is set).\n+         --  default expression mode (the Freeze_Expression routine tests this\n+         --  flag and only freezes static types if it is set).\n \n          Freeze_Expression (N);\n \n@@ -3111,10 +3108,10 @@ package body Sem_Res is\n                then\n                   Analyze_And_Resolve (Actval, Base_Type (Etype (Actval)));\n \n-               --  Resolve entities with their own type, which may differ\n-               --  from the type of a reference in a generic context (the\n-               --  view swapping mechanism did not anticipate the re-analysis\n-               --  of default values in calls).\n+               --  Resolve entities with their own type, which may differ from\n+               --  the type of a reference in a generic context (the view\n+               --  swapping mechanism did not anticipate the re-analysis of\n+               --  default values in calls).\n \n                elsif Is_Entity_Name (Actval) then\n                   Analyze_And_Resolve (Actval, Etype (Entity (Actval)));\n@@ -3124,8 +3121,8 @@ package body Sem_Res is\n                end if;\n             end if;\n \n-            --  If default is a tag indeterminate function call, propagate\n-            --  tag to obtain proper dispatching.\n+            --  If default is a tag indeterminate function call, propagate tag\n+            --  to obtain proper dispatching.\n \n             if Is_Controlling_Formal (F)\n               and then Nkind (Default_Value (F)) = N_Function_Call\n@@ -3136,10 +3133,10 @@ package body Sem_Res is\n          end if;\n \n          --  If the default expression raises constraint error, then just\n-         --  silently replace it with an N_Raise_Constraint_Error node,\n-         --  since we already gave the warning on the subprogram spec.\n-         --  If node is already a Raise_Constraint_Error leave as is, to\n-         --  prevent loops in the warnings removal machinery.\n+         --  silently replace it with an N_Raise_Constraint_Error node, since\n+         --  we already gave the warning on the subprogram spec. If node is\n+         --  already a Raise_Constraint_Error leave as is, to prevent loops in\n+         --  the warnings removal machinery.\n \n          if Raises_Constraint_Error (Actval)\n            and then Nkind (Actval) /= N_Raise_Constraint_Error\n@@ -3226,8 +3223,8 @@ package body Sem_Res is\n \n             when N_Op_Concat =>\n \n-               --  Concatenation is static when both operands are static\n-               --  and the concatenation operator is a predefined one.\n+               --  Concatenation is static when both operands are static and\n+               --  the concatenation operator is a predefined one.\n \n                return Scope (Entity (N)) = Standard_Standard\n                         and then\n@@ -3283,8 +3280,7 @@ package body Sem_Res is\n          --  If the actual is an entity, generate a reference to it now. We\n          --  do this before the actual is resolved, because a formal of some\n          --  protected subprogram, or a task discriminant, will be rewritten\n-         --  during expansion, and the reference to the source entity may\n-         --  be lost.\n+         --  during expansion, and the source entity reference may be lost.\n \n          if Present (A)\n            and then Is_Entity_Name (A)\n@@ -3521,7 +3517,7 @@ package body Sem_Res is\n                   end if;\n \n                   --  Tagged synchronized type (case 1): the actual is a\n-                  --  concurrent type\n+                  --  concurrent type.\n \n                   if Is_Concurrent_Type (A_Typ)\n                     and then Corresponding_Record_Type (A_Typ) = F_Typ\n@@ -3532,7 +3528,7 @@ package body Sem_Res is\n                      Resolve (A, Etype (F));\n \n                   --  Tagged synchronized type (case 2): the formal is a\n-                  --  concurrent type\n+                  --  concurrent type.\n \n                   elsif Ekind (Full_A_Typ) = E_Record_Type\n                     and then Present\n@@ -4375,9 +4371,9 @@ package body Sem_Res is\n       if No_Pool_Assigned (Typ) then\n          Error_Msg_N (\"allocation from empty storage pool!\", N);\n \n-      --  If the context is an unchecked conversion, as may happen within\n-      --  an inlined subprogram, the allocator is being resolved with its\n-      --  own anonymous type. In that case, if the target type has a specific\n+      --  If the context is an unchecked conversion, as may happen within an\n+      --  inlined subprogram, the allocator is being resolved with its own\n+      --  anonymous type. In that case, if the target type has a specific\n       --  storage pool, it must be inherited explicitly by the allocator type.\n \n       elsif Nkind (Parent (N)) = N_Unchecked_Type_Conversion\n@@ -4663,12 +4659,11 @@ package body Sem_Res is\n          Resolve_Intrinsic_Operator (N, Typ);\n          return;\n \n-      --  Special-case for mixed-mode universal expressions or fixed point\n-      --  type operation: each argument is resolved separately. The same\n-      --  treatment is required if one of the operands of a fixed point\n-      --  operation is universal real, since in this case we don't do a\n-      --  conversion to a specific fixed-point type (instead the expander\n-      --  takes care of the case).\n+      --  Special-case for mixed-mode universal expressions or fixed point type\n+      --  operation: each argument is resolved separately. The same treatment\n+      --  is required if one of the operands of a fixed point operation is\n+      --  universal real, since in this case we don't do a conversion to a\n+      --  specific fixed-point type (instead the expander handles the case).\n \n       elsif (B_Typ = Universal_Integer or else B_Typ = Universal_Real)\n         and then Present (Universal_Interpretation (L))\n@@ -4692,8 +4687,8 @@ package body Sem_Res is\n             Check_For_Visible_Operator (N, B_Typ);\n          end if;\n \n-         --  If context is a fixed type and one operand is integer, the\n-         --  other is resolved with the type of the context.\n+         --  If context is a fixed type and one operand is integer, the other\n+         --  is resolved with the type of the context.\n \n          if Is_Fixed_Point_Type (B_Typ)\n            and then (Base_Type (TL) = Base_Type (Standard_Integer)\n@@ -4747,7 +4742,9 @@ package body Sem_Res is\n                end if;\n \n                --  The expected type is \"any real type\" in contexts like\n+\n                --    type T is delta <universal_fixed-expression> ...\n+\n                --  in which case we need to set the type to Universal_Real\n                --  so that static expression evaluation will work properly.\n \n@@ -4768,8 +4765,8 @@ package body Sem_Res is\n \n          elsif Etype (N) = Any_Fixed then\n \n-            --  If no previous errors, this is only possible if one operand\n-            --  is overloaded and the context is universal. Resolve as such.\n+            --  If no previous errors, this is only possible if one operand is\n+            --  overloaded and the context is universal. Resolve as such.\n \n             Set_Etype (N, B_Typ);\n          end if;\n@@ -5617,7 +5614,7 @@ package body Sem_Res is\n       then\n          Generate_Reference (Nam, Subp, 'R');\n \n-      --  Normal case, not a dispatching call. Generate a call reference.\n+      --  Normal case, not a dispatching call: generate a call reference\n \n       else\n          Generate_Reference (Nam, Subp, 's');\n@@ -5714,16 +5711,16 @@ package body Sem_Res is\n       elsif B_Typ = Any_Character then\n          return;\n \n-      --  For Standard.Character or a type derived from it, check that\n-      --  the literal is in range\n+      --  For Standard.Character or a type derived from it, check that the\n+      --  literal is in range.\n \n       elsif Root_Type (B_Typ) = Standard_Character then\n          if In_Character_Range (UI_To_CC (Char_Literal_Value (N))) then\n             return;\n          end if;\n \n-      --  For Standard.Wide_Character or a type derived from it, check\n-      --  that the literal is in range\n+      --  For Standard.Wide_Character or a type derived from it, check that the\n+      --  literal is in range.\n \n       elsif Root_Type (B_Typ) = Standard_Wide_Character then\n          if In_Wide_Character_Range (UI_To_CC (Char_Literal_Value (N))) then\n@@ -5759,8 +5756,8 @@ package body Sem_Res is\n       end if;\n \n       --  If we fall through, then the literal does not match any of the\n-      --  entries of the enumeration type. This isn't just a constraint\n-      --  error situation, it is an illegality (see RM 4.2).\n+      --  entries of the enumeration type. This isn't just a constraint error\n+      --  situation, it is an illegality (see RM 4.2).\n \n       Error_Msg_NE\n         (\"character not defined for }\", N, First_Subtype (B_Typ));\n@@ -5771,9 +5768,9 @@ package body Sem_Res is\n    ---------------------------\n \n    --  Context requires a boolean type, and plays no role in resolution.\n-   --  Processing identical to that for equality operators. The result\n-   --  type is the base type, which matters when pathological subtypes of\n-   --  booleans with limited ranges are used.\n+   --  Processing identical to that for equality operators. The result type is\n+   --  the base type, which matters when pathological subtypes of booleans with\n+   --  limited ranges are used.\n \n    procedure Resolve_Comparison_Op (N : Node_Id; Typ : Entity_Id) is\n       L : constant Node_Id := Left_Opnd (N);\n@@ -5854,8 +5851,8 @@ package body Sem_Res is\n          Error_Msg_N (\"comparison on unordered enumeration type?\", N);\n       end if;\n \n-      --  Evaluate the relation (note we do this after the above check\n-      --  since this Eval call may change N to True/False.\n+      --  Evaluate the relation (note we do this after the above check since\n+      --  this Eval call may change N to True/False.\n \n       Eval_Relational_Op (N);\n    end Resolve_Comparison_Op;\n@@ -5935,11 +5932,11 @@ package body Sem_Res is\n             Set_Etype (N, Typ);\n             Rewrite (Low_Bound (R),\n               Make_Attribute_Reference (Sloc (Low_Bound (R)),\n-                Prefix =>         New_Occurrence_Of (Typ, Sloc (R)),\n+                Prefix         => New_Occurrence_Of (Typ, Sloc (R)),\n                 Attribute_Name => Name_First));\n             Rewrite (High_Bound (R),\n               Make_Attribute_Reference (Sloc (High_Bound (R)),\n-                Prefix =>         New_Occurrence_Of (Typ, Sloc (R)),\n+                Prefix         => New_Occurrence_Of (Typ, Sloc (R)),\n                 Attribute_Name => Name_First));\n \n          else\n@@ -6203,9 +6200,9 @@ package body Sem_Res is\n    --  Start of processing of Resolve_Entry\n \n    begin\n-      --  Find name of entry being called, and resolve prefix of name\n-      --  with its own type. The prefix can be overloaded, and the name\n-      --  and signature of the entry must be taken into account.\n+      --  Find name of entry being called, and resolve prefix of name with its\n+      --  own type. The prefix can be overloaded, and the name and signature of\n+      --  the entry must be taken into account.\n \n       if Nkind (Entry_Name) = N_Indexed_Component then\n \n@@ -6272,8 +6269,7 @@ package body Sem_Res is\n         and then Is_Overloaded (Prefix (Entry_Name))\n       then\n          --  Use the entry name (which must be unique at this point) to find\n-         --  the prefix that returns the corresponding task type or protected\n-         --  type.\n+         --  the prefix that returns the corresponding task/protected type.\n \n          declare\n             Pref : constant Node_Id := Prefix (Entry_Name);\n@@ -6384,17 +6380,17 @@ package body Sem_Res is\n          Was_Over := Is_Overloaded (Selector_Name (Prefix (Entry_Name)));\n       end if;\n \n-      --  We cannot in general check the maximum depth of protected entry\n-      --  calls at compile time. But we can tell that any protected entry\n-      --  call at all violates a specified nesting depth of zero.\n+      --  We cannot in general check the maximum depth of protected entry calls\n+      --  at compile time. But we can tell that any protected entry call at all\n+      --  violates a specified nesting depth of zero.\n \n       if Is_Protected_Type (Scope (Nam)) then\n          Check_Restriction (Max_Entry_Queue_Length, N);\n       end if;\n \n       --  Use context type to disambiguate a protected function that can be\n-      --  called without actuals and that returns an array type, and where\n-      --  the argument list may be an indexing of the returned value.\n+      --  called without actuals and that returns an array type, and where the\n+      --  argument list may be an indexing of the returned value.\n \n       if Ekind (Nam) = E_Function\n         and then Needs_No_Actuals (Nam)\n@@ -6420,8 +6416,8 @@ package body Sem_Res is\n                   Make_Function_Call (Loc, Name => Relocate_Node (Entry_Name)),\n                 Expressions => Parameter_Associations (N));\n \n-            --  Since we are correcting a node classification error made by\n-            --  the parser, we call Replace rather than Rewrite.\n+            --  Since we are correcting a node classification error made by the\n+            --  parser, we call Replace rather than Rewrite.\n \n             Replace (N, Index_Node);\n             Set_Etype (Prefix (N), Etype (Nam));\n@@ -6436,8 +6432,8 @@ package body Sem_Res is\n         and then Current_Scope /= PPC_Wrapper (Nam)\n       then\n          --  Rewrite as call to the precondition wrapper, adding the task\n-         --  object to the list of actuals. If the call is to a member of\n-         --  an entry family, include the index as well.\n+         --  object to the list of actuals. If the call is to a member of an\n+         --  entry family, include the index as well.\n \n          declare\n             New_Call    : Node_Id;\n@@ -6464,8 +6460,8 @@ package body Sem_Res is\n       end if;\n \n       --  The operation name may have been overloaded. Order the actuals\n-      --  according to the formals of the resolved entity, and set the\n-      --  return type to that of the operation.\n+      --  according to the formals of the resolved entity, and set the return\n+      --  type to that of the operation.\n \n       if Was_Over then\n          Normalize_Actuals (N, Nam, False, Norm_OK);\n@@ -7250,9 +7246,9 @@ package body Sem_Res is\n    -- Resolve_Membership_Op --\n    ---------------------------\n \n-   --  The context can only be a boolean type, and does not determine\n-   --  the arguments. Arguments should be unambiguous, but the preference\n-   --  rule for universal types applies.\n+   --  The context can only be a boolean type, and does not determine the\n+   --  arguments. Arguments should be unambiguous, but the preference rule for\n+   --  universal types applies.\n \n    procedure Resolve_Membership_Op (N : Node_Id; Typ : Entity_Id) is\n       pragma Warnings (Off, Typ);\n@@ -7262,8 +7258,8 @@ package body Sem_Res is\n       T : Entity_Id;\n \n       procedure Resolve_Set_Membership;\n-      --  Analysis has determined a unique type for the left operand.\n-      --  Use it to resolve the disjuncts.\n+      --  Analysis has determined a unique type for the left operand. Use it to\n+      --  resolve the disjuncts.\n \n       ----------------------------\n       -- Resolve_Set_Membership --\n@@ -7754,10 +7750,10 @@ package body Sem_Res is\n       B_Typ : Entity_Id;\n \n       function Parent_Is_Boolean return Boolean;\n-      --  This function determines if the parent node is a boolean operator\n-      --  or operation (comparison op, membership test, or short circuit form)\n-      --  and the not in question is the left operand of this operation.\n-      --  Note that if the not is in parens, then false is returned.\n+      --  This function determines if the parent node is a boolean operator or\n+      --  operation (comparison op, membership test, or short circuit form) and\n+      --  the not in question is the left operand of this operation. Note that\n+      --  if the not is in parens, then false is returned.\n \n       -----------------------\n       -- Parent_Is_Boolean --\n@@ -7830,7 +7826,7 @@ package body Sem_Res is\n          Set_Etype (N, Any_Type);\n          return;\n \n-      --  OK resolution of not\n+      --  OK resolution of NOT\n \n       else\n          --  Warn if non-boolean types involved. This is a case like not a < b\n@@ -7900,12 +7896,12 @@ package body Sem_Res is\n            (\"array types should have matching static bounds\", N);\n       end if;\n \n-      --  A qualified expression requires an exact match of the type,\n-      --  class-wide matching is not allowed. However, if the qualifying\n-      --  type is specific and the expression has a class-wide type, it\n-      --  may still be okay, since it can be the result of the expansion\n-      --  of a call to a dispatching function, so we also have to check\n-      --  class-wideness of the type of the expression's original node.\n+      --  A qualified expression requires an exact match of the type, class-\n+      --  wide matching is not allowed. However, if the qualifying type is\n+      --  specific and the expression has a class-wide type, it may still be\n+      --  okay, since it can be the result of the expansion of a call to a\n+      --  dispatching function, so we also have to check class-wideness of the\n+      --  type of the expression's original node.\n \n       if (Is_Class_Wide_Type (Target_Typ)\n            or else\n@@ -8028,11 +8024,10 @@ package body Sem_Res is\n          return;\n       end if;\n \n-      --  If bounds are static, constant-fold them, so size computations\n-      --  are identical between front-end and back-end. Do not perform this\n+      --  If bounds are static, constant-fold them, so size computations are\n+      --  identical between front-end and back-end. Do not perform this\n       --  transformation while analyzing generic units, as type information\n-      --  would then be lost when reanalyzing the constant node in the\n-      --  instance.\n+      --  would be lost when reanalyzing the constant node in the instance.\n \n       if Is_Discrete_Type (Typ) and then Expander_Active then\n          if Is_OK_Static_Expression (L) then\n@@ -8054,8 +8049,8 @@ package body Sem_Res is\n \n    begin\n       --  Special processing for fixed-point literals to make sure that the\n-      --  value is an exact multiple of small where this is required. We\n-      --  skip this for the universal real case, and also for generic types.\n+      --  value is an exact multiple of small where this is required. We skip\n+      --  this for the universal real case, and also for generic types.\n \n       if Is_Fixed_Point_Type (Typ)\n         and then Typ /= Universal_Fixed\n@@ -8074,8 +8069,8 @@ package body Sem_Res is\n \n             if Den /= 1 then\n \n-               --  For a source program literal for a decimal fixed-point\n-               --  type, this is statically illegal (RM 4.9(36)).\n+               --  For a source program literal for a decimal fixed-point type,\n+               --  this is statically illegal (RM 4.9(36)).\n \n                if Is_Decimal_Fixed_Point_Type (Typ)\n                  and then Actual_Typ = Universal_Real\n@@ -8135,11 +8130,11 @@ package body Sem_Res is\n \n       Resolve (P, Designated_Type (Etype (N)));\n \n-      --  If we are taking the reference of a volatile entity, then treat\n-      --  it as a potential modification of this entity. This is much too\n-      --  conservative, but is necessary because remove side effects can\n-      --  result in transformations of normal assignments into reference\n-      --  sequences that otherwise fail to notice the modification.\n+      --  If we are taking the reference of a volatile entity, then treat it as\n+      --  a potential modification of this entity. This is too conservative,\n+      --  but necessary because remove side effects can cause transformations\n+      --  of normal assignments into reference sequences that otherwise fail to\n+      --  notice the modification.\n \n       if Is_Entity_Name (P) and then Treat_As_Volatile (Entity (P)) then\n          Note_Possible_Modification (P, Sure => False);\n@@ -8326,8 +8321,8 @@ package body Sem_Res is\n \n       --  If the array type is atomic, and is packed, and we are in a left side\n       --  context, then this is worth a warning, since we have a situation\n-      --  where the access to the component may cause extra read/writes of\n-      --  the atomic array object, which could be considered unexpected.\n+      --  where the access to the component may cause extra read/writes of the\n+      --  atomic array object, which could be considered unexpected.\n \n       if Nkind (N) = N_Selected_Component\n         and then (Is_Atomic (T)\n@@ -8576,11 +8571,11 @@ package body Sem_Res is\n          end;\n \n       --  Maybe this should just be \"else\", instead of checking for the\n-      --  specific case of slice??? This is needed for the case where\n-      --  the prefix is an Image attribute, which gets expanded to a\n-      --  slice, and so has a constrained subtype which we want to use\n-      --  for the slice range check applied below (the range check won't\n-      --  get done if the unconstrained subtype of the 'Image is used).\n+      --  specific case of slice??? This is needed for the case where the\n+      --  prefix is an Image attribute, which gets expanded to a slice, and so\n+      --  has a constrained subtype which we want to use for the slice range\n+      --  check applied below (the range check won't get done if the\n+      --  unconstrained subtype of the 'Image is used).\n \n       elsif Nkind (Name) = N_Slice then\n          Array_Type := Etype (Name);\n@@ -8816,8 +8811,8 @@ package body Sem_Res is\n          --  has compile time known bounds. If yes we can directly check\n          --  whether the evaluation of the string will raise constraint error.\n          --  Otherwise we need to transform the string literal into the\n-         --  corresponding character aggregate and let the aggregate\n-         --  code do the checking.\n+         --  corresponding character aggregate and let the aggregate code do\n+         --  the checking.\n \n          if Is_Standard_Character_Type (R_Typ) then\n \n@@ -8886,6 +8881,7 @@ package body Sem_Res is\n                P := P + 1;\n \n             --  Should we have a call to Skip_Wide here ???\n+\n             --  ???     else\n             --             Skip_Wide (P);\n \n@@ -9114,13 +9110,13 @@ package body Sem_Res is\n             then\n                null;\n \n-            --  Finally, if this type conversion occurs in a context that\n-            --  requires a prefix, and the expression is a qualified expression\n-            --  then the type conversion is not redundant, because a qualified\n-            --  expression is not a prefix, whereas a type conversion is. For\n-            --  example, \"X := T'(Funx(...)).Y;\" is illegal because a selected\n-            --  component requires a prefix, but a type conversion makes it\n-            --  legal: \"X := T(T'(Funx(...))).Y;\"\n+            --  Finally, if this type conversion occurs in a context requiring\n+            --  a prefix, and the expression is a qualified expression then the\n+            --  type conversion is not redundant, since a qualified expression\n+            --  is not a prefix, whereas a type conversion is. For example, \"X\n+            --  := T'(Funx(...)).Y;\" is illegal because a selected component\n+            --  requires a prefix, but a type conversion makes it legal: \"X :=\n+            --  T(T'(Funx(...))).Y;\"\n \n             --  In Ada 2012, a qualified expression is a name, so this idiom is\n             --  no longer needed, but we still suppress the warning because it\n@@ -9639,9 +9635,9 @@ package body Sem_Res is\n \n       Set_Etype (N, Slice_Subtype);\n \n-      --  For packed slice subtypes, freeze immediately (except in the\n-      --  case of being in a \"spec expression\" where we never freeze\n-      --  when we first see the expression).\n+      --  For packed slice subtypes, freeze immediately (except in the case of\n+      --  being in a \"spec expression\" where we never freeze when we first see\n+      --  the expression).\n \n       if Is_Packed (Slice_Subtype) and not In_Spec_Expression then\n          Freeze_Itype (Slice_Subtype, N);"}]}