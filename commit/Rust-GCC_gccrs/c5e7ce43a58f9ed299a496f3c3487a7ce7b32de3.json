{"sha": "c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlN2NlNDNhNThmOWVkMjk5YTQ5NmYzYzM0ODdhN2NlN2IzMmRlMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-08T14:02:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-08T14:02:51Z"}, "message": "h8300.c (output_logical_op): Replace byte/word extraction of det with b0, b1, w0, w2, etc.\n\n\t* config/h8300/h8300.c (output_logical_op): Replace byte/word\n\textraction of det with b0, b1, w0, w2, etc.\n\t(compute_logical_op_length): Likewise.\n\t(compute_logical_op_cc): Likewise.\n\nFrom-SVN: r61045", "tree": {"sha": "0d26e2248212ade000e71488c938f6d668cf7f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d26e2248212ade000e71488c938f6d668cf7f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3/comments", "author": null, "committer": null, "parents": [{"sha": "eb8a8ec47058366af6d49a8e8bb66c10174d999a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8a8ec47058366af6d49a8e8bb66c10174d999a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8a8ec47058366af6d49a8e8bb66c10174d999a"}], "stats": {"total": 71, "additions": 41, "deletions": 30}, "files": [{"sha": "e887641afd7b8ef9fe3254e7bc9eb457ea564351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "patch": "@@ -1,3 +1,10 @@\n+2003-01-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c (output_logical_op): Replace byte/word\n+\textraction of det with b0, b1, w0, w2, etc.\n+\t(compute_logical_op_length): Likewise.\n+\t(compute_logical_op_cc): Likewise.\n+\n 2003-01-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.h (CONSTANT_ADDRESS_P): Allow CONST and"}, {"sha": "c98f6e11d6b25c1427e0a0a96a4dbfad8d6fdede", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "patch": "@@ -2064,6 +2064,8 @@ output_logical_op (mode, operands)\n   /* Break up DET into pieces.  */\n   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n+  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;\n+  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;\n   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n   int lower_half_easy_p = 0;\n@@ -2092,22 +2094,22 @@ output_logical_op (mode, operands)\n     case HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x00ff) != 0)\n-\t  && ((det & 0xff00) != 0))\n+\t  && b0 != 0\n+\t  && b1 != 0)\n \t{\n \t  sprintf (insn_buf, \"%s.w\\t%%T2,%%T0\", opname);\n \t  output_asm_insn (insn_buf, operands);\n \t}\n       else\n \t{\n \t  /* Take care of the lower byte.  */\n-\t  if ((det & 0x00ff) != 0)\n+\t  if (b0 != 0)\n \t    {\n \t      sprintf (insn_buf, \"%s\\t%%s2,%%s0\", opname);\n \t      output_asm_insn (insn_buf, operands);\n \t    }\n \t  /* Take care of the upper byte.  */\n-\t  if ((det & 0xff00) != 0)\n+\t  if (b1 != 0)\n \t    {\n \t      sprintf (insn_buf, \"%s\\t%%t2,%%t0\", opname);\n \t      output_asm_insn (insn_buf, operands);\n@@ -2146,59 +2148,59 @@ output_logical_op (mode, operands)\n \t     1) the special insn (in case of AND or XOR),\n \t     2) the word-wise insn, and\n \t     3) The byte-wise insn.  */\n-\t  if ((det & 0x0000ffff) == 0x0000ffff\n+\t  if (w0 == 0xffff\n \t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n \t    output_asm_insn ((code == AND)\n \t\t\t     ? \"sub.w\\t%f0,%f0\" : \"not.w\\t%f0\",\n \t\t\t     operands);\n \t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && ((det & 0x000000ff) != 0)\n-\t\t   && ((det & 0x0000ff00) != 0))\n+\t\t   && (b0 != 0)\n+\t\t   && (b1 != 0))\n \t    {\n \t      sprintf (insn_buf, \"%s.w\\t%%f2,%%f0\", opname);\n \t      output_asm_insn (insn_buf, operands);\n \t    }\n \t  else\n \t    {\n-\t      if ((det & 0x000000ff) != 0)\n+\t      if (b0 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s\\t%%w2,%%w0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n \t\t}\n-\t      if ((det & 0x0000ff00) != 0)\n+\t      if (b1 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s\\t%%x2,%%x0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n \t\t}\n \t    }\n \n-\t  if ((det & 0xffff0000) == 0xffff0000\n+\t  if ((w1 == 0xffff)\n \t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n \t    output_asm_insn ((code == AND)\n \t\t\t     ? \"sub.w\\t%e0,%e0\" : \"not.w\\t%e0\",\n \t\t\t     operands);\n \t  else if ((TARGET_H8300H || TARGET_H8300S)\n \t\t   && code == AND\n-\t\t   && (det & 0xffff0000) == 0xff000000)\n+\t\t   && w1 == 0xff00)\n \t    {\n \t      output_asm_insn (\"extu.w\\t%e0\", operands);\n \t    }\n \t  else if (TARGET_H8300H || TARGET_H8300S)\n \t    {\n-\t      if ((det & 0xffff0000) != 0)\n+\t      if (w1 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s.w\\t%%e2,%%e0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      if ((det & 0x00ff0000) != 0)\n+\t      if (b2 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s\\t%%y2,%%y0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n \t\t}\n-\t      if ((det & 0xff000000) != 0)\n+\t      if (b3 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s\\t%%z2,%%z0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n@@ -2229,6 +2231,8 @@ compute_logical_op_length (mode, operands)\n   /* Break up DET into pieces.  */\n   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n+  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;\n+  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;\n   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n   int lower_half_easy_p = 0;\n@@ -2241,8 +2245,8 @@ compute_logical_op_length (mode, operands)\n     case HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x00ff) != 0)\n-\t  && ((det & 0xff00) != 0))\n+\t  && b0 != 0\n+\t  && b1 != 0)\n \t{\n \t  if (REG_P (operands[2]))\n \t    length += 2;\n@@ -2252,11 +2256,11 @@ compute_logical_op_length (mode, operands)\n       else\n \t{\n \t  /* Take care of the lower byte.  */\n-\t  if ((det & 0x00ff) != 0)\n+\t  if (b0 != 0)\n \t    length += 2;\n \n \t  /* Take care of the upper byte.  */\n-\t  if ((det & 0xff00) != 0)\n+\t  if (b1 != 0)\n \t    length += 2;\n \t}\n       break;\n@@ -2294,48 +2298,48 @@ compute_logical_op_length (mode, operands)\n \t     1) the special insn (in case of AND or XOR),\n \t     2) the word-wise insn, and\n \t     3) The byte-wise insn.  */\n-\t  if ((det & 0x0000ffff) == 0x0000ffff\n+\t  if (w0 == 0xffff\n \t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n \t    {\n \t      length += 2;\n \t    }\n \t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && ((det & 0x000000ff) != 0)\n-\t\t   && ((det & 0x0000ff00) != 0))\n+\t\t   && (b0 != 0)\n+\t\t   && (b1 != 0))\n \t    {\n \t      length += 4;\n \t    }\n \t  else\n \t    {\n-\t      if ((det & 0x000000ff) != 0)\n+\t      if (b0 != 0)\n \t\tlength += 2;\n \n-\t      if ((det & 0x0000ff00) != 0)\n+\t      if (b1 != 0)\n \t\tlength += 2;\n \t    }\n \n-\t  if ((det & 0xffff0000) == 0xffff0000\n+\t  if (w1 == 0xffff\n \t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n \t    {\n \t      length += 2;\n \t    }\n \t  else if ((TARGET_H8300H || TARGET_H8300S)\n \t\t   && code == AND\n-\t\t   && (det & 0xffff0000) == 0xff000000)\n+\t\t   && w1 == 0xff00)\n \t    {\n \t      length += 2;\n \t    }\n \t  else if (TARGET_H8300H || TARGET_H8300S)\n \t    {\n-\t      if ((det & 0xffff0000) != 0)\n+\t      if (w1 != 0)\n \t\tlength += 4;\n \t    }\n \t  else\n \t    {\n-\t      if ((det & 0x00ff0000) != 0)\n+\t      if (b2 != 0)\n \t\tlength += 2;\n \n-\t      if ((det & 0xff000000) != 0)\n+\t      if (b3 != 0)\n \t\tlength += 2;\n \t    }\n \t}\n@@ -2375,8 +2379,8 @@ compute_logical_op_cc (mode, operands)\n     case HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((det & 0x00ff) != 0)\n-\t  && ((det & 0xff00) != 0))\n+\t  && b0 != 0\n+\t  && b1 != 0)\n \t{\n \t  cc = CC_SET_ZNV;\n \t}"}]}