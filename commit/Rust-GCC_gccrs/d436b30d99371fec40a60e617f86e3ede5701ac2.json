{"sha": "d436b30d99371fec40a60e617f86e3ede5701ac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzNmIzMGQ5OTM3MWZlYzQwYTYwZTYxN2Y4NmUzZWRlNTcwMWFjMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:18:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:18:30Z"}, "message": "[multiple changes]\n\n2013-04-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.adb (Host_Entry): Introduce intermediate copy of\n\tmemory location pointed to by Hostent_H_Addr, as it might not\n\thave sufficient alignment.\n\n2013-04-24  Yannick Moy  <moy@adacore.com>\n\n\t* repinfo.adb (List_Rep_Info): Set the value of Unit_Casing before\n\tcalling subprograms which may read it.\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Remove Loop_Entry_Attributes from the usage of\n\tnodes. Flag 260 is now used.\n\t(Has_Loop_Entry_Attributes): New routine.\n\t(Loop_Entry_Attributes): Removed.\n\t(Set_Has_Loop_Entry_Attributes): New routine.\n\t(Set_Loop_Entry_Attributes): Removed.\n\t(Write_Entity_Flags): Write out Flag 260.\n\t(Write_Field10_Name): Remove the output for Loop_Entry_Attributes.\n\t* einfo.ads: Remove attribute Loop_Entry_Attributes,\n\tits related comment and uses in nodes.\tAdd new attribute\n\tHas_Loop_Entry_Attributes, related comment and uses in loop nodes.\n\t(Has_Loop_Entry_Attributes): New routine and pragma Inline.\n\t(Loop_Entry_Attributes): Removed along with pragma Inline.\n\t(Set_Has_Loop_Entry_Attributes): New routine and pragma Inline.\n\t(Set_Loop_Entry_Attributes): Removed along with pragma Inline.\n\t* exp_attr.adb (Expand_Loop_Entry_Attribute): New routine.\n\t(Expand_N_Attribute_Reference): Expand attribute 'Loop_Entry.\n\t* exp_ch5.adb: Remove with and use clause for Elists.\n\t(Expand_Loop_Entry_Attributes): Removed.\n\t(Expand_N_Loop_Statement): Add local variable Stmt. Rename local\n\tconstant Isc to Scheme. When a loop is subject to attribute\n\t'Loop_Entry, retrieve the nested loop from the conditional\n\tblock. Move the processing of controlled object at the end of\n\tloop expansion.\n\t* sem_attr.adb (Analyze_Attribute): Do not chain attribute\n\t'Loop_Entry to its related loop.\n\t* sem_ch5.adb (Analyze_Loop_Statement): Add local variable\n\tStmt. When the iteration scheme mentions attribute 'Loop_Entry,\n\tthe entire loop is rewritten into a block.  Retrieve the nested\n\tloop in such cases to complete the analysis.\n\t* sem_util.ads, sem_util.adb (Find_Loop_In_Conditional_Block): New\n\troutine.\n\t(Subject_To_Loop_Entry_Attributes): New routine.\n\n2013-04-24  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_prag.adb (Expand_Loop_Variant): Generate pragma Check\n\t(Loop_Variant, xxx) rather than Assert (xxx).\n\t* gnat_rm.texi: Document pragma Loop_Variant.\n\t* sem_prag.adb (Analyze_Pragma, case Loop_Variant): Remove call\n\tto S14_Pragma.\n\nFrom-SVN: r198235", "tree": {"sha": "5288e0f51c7951d5e5361fedd68284f13d64cc55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5288e0f51c7951d5e5361fedd68284f13d64cc55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d436b30d99371fec40a60e617f86e3ede5701ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d436b30d99371fec40a60e617f86e3ede5701ac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d436b30d99371fec40a60e617f86e3ede5701ac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d436b30d99371fec40a60e617f86e3ede5701ac2/comments", "author": null, "committer": null, "parents": [{"sha": "06b599fd62cccd693a395130dda53004f577714d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b599fd62cccd693a395130dda53004f577714d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b599fd62cccd693a395130dda53004f577714d"}], "stats": {"total": 1070, "additions": 641, "deletions": 429}, "files": [{"sha": "4b39d70ec3b215d39a75c2de2bdb5bcc823fac08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -1,3 +1,58 @@\n+2013-04-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.adb (Host_Entry): Introduce intermediate copy of\n+\tmemory location pointed to by Hostent_H_Addr, as it might not\n+\thave sufficient alignment.\n+\n+2013-04-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* repinfo.adb (List_Rep_Info): Set the value of Unit_Casing before\n+\tcalling subprograms which may read it.\n+\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Remove Loop_Entry_Attributes from the usage of\n+\tnodes. Flag 260 is now used.\n+\t(Has_Loop_Entry_Attributes): New routine.\n+\t(Loop_Entry_Attributes): Removed.\n+\t(Set_Has_Loop_Entry_Attributes): New routine.\n+\t(Set_Loop_Entry_Attributes): Removed.\n+\t(Write_Entity_Flags): Write out Flag 260.\n+\t(Write_Field10_Name): Remove the output for Loop_Entry_Attributes.\n+\t* einfo.ads: Remove attribute Loop_Entry_Attributes,\n+\tits related comment and uses in nodes.\tAdd new attribute\n+\tHas_Loop_Entry_Attributes, related comment and uses in loop nodes.\n+\t(Has_Loop_Entry_Attributes): New routine and pragma Inline.\n+\t(Loop_Entry_Attributes): Removed along with pragma Inline.\n+\t(Set_Has_Loop_Entry_Attributes): New routine and pragma Inline.\n+\t(Set_Loop_Entry_Attributes): Removed along with pragma Inline.\n+\t* exp_attr.adb (Expand_Loop_Entry_Attribute): New routine.\n+\t(Expand_N_Attribute_Reference): Expand attribute 'Loop_Entry.\n+\t* exp_ch5.adb: Remove with and use clause for Elists.\n+\t(Expand_Loop_Entry_Attributes): Removed.\n+\t(Expand_N_Loop_Statement): Add local variable Stmt. Rename local\n+\tconstant Isc to Scheme. When a loop is subject to attribute\n+\t'Loop_Entry, retrieve the nested loop from the conditional\n+\tblock. Move the processing of controlled object at the end of\n+\tloop expansion.\n+\t* sem_attr.adb (Analyze_Attribute): Do not chain attribute\n+\t'Loop_Entry to its related loop.\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Add local variable\n+\tStmt. When the iteration scheme mentions attribute 'Loop_Entry,\n+\tthe entire loop is rewritten into a block.  Retrieve the nested\n+\tloop in such cases to complete the analysis.\n+\t* sem_util.ads, sem_util.adb (Find_Loop_In_Conditional_Block): New\n+\troutine.\n+\t(Subject_To_Loop_Entry_Attributes): New routine.\n+\n+2013-04-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_prag.adb (Expand_Loop_Variant): Generate pragma Check\n+\t(Loop_Variant, xxx) rather than Assert (xxx).\n+\t* gnat_rm.texi: Document pragma Loop_Variant.\n+\t* sem_prag.adb (Analyze_Pragma, case Loop_Variant): Remove call\n+\tto S14_Pragma.\n+\n 2013-04-24  Yannick Moy  <moy@adacore.com>\n \n \t* adabkend.adb, ali-util.adb, ali.adb, debug.adb,"}, {"sha": "96e875e0f09ea02579f296bee69b3d94d84fe35b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -93,7 +93,6 @@ package body Einfo is\n    --    Discriminal_Link                Node10\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n    --    Handler_Records                 List10\n-   --    Loop_Entry_Attributes           Elist10\n    --    Normalized_Position_Max         Uint10\n \n    --    Component_Bit_Offset            Uint11\n@@ -548,8 +547,7 @@ package body Einfo is\n    --    Is_Invariant_Procedure          Flag257\n    --    Has_Dynamic_Predicate_Aspect    Flag258\n    --    Has_Static_Predicate_Aspect     Flag259\n-\n-   --    (unused)                        Flag260\n+   --    Has_Loop_Entry_Attributes       Flag260\n \n    --    (unused)                        Flag261\n    --    (unused)                        Flag262\n@@ -1467,6 +1465,12 @@ package body Einfo is\n       return Flag232 (Id);\n    end Has_Invariants;\n \n+   function Has_Loop_Entry_Attributes (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      return Flag260 (Id);\n+   end Has_Loop_Entry_Attributes;\n+\n    function Has_Machine_Radix_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -2396,12 +2400,6 @@ package body Einfo is\n       return Node16 (Id);\n    end Lit_Strings;\n \n-   function Loop_Entry_Attributes (Id : E) return L is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Loop);\n-      return Elist10 (Id);\n-   end Loop_Entry_Attributes;\n-\n    function Low_Bound_Tested (Id : E) return B is\n    begin\n       return Flag205 (Id);\n@@ -4051,6 +4049,12 @@ package body Einfo is\n       Set_Flag232 (Id, V);\n    end Set_Has_Invariants;\n \n+   procedure Set_Has_Loop_Entry_Attributes (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      Set_Flag260 (Id, V);\n+   end Set_Has_Loop_Entry_Attributes;\n+\n    procedure Set_Has_Machine_Radix_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -5022,12 +5026,6 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_Lit_Strings;\n \n-   procedure Set_Loop_Entry_Attributes (Id : E; V : L) is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Loop);\n-      Set_Elist10 (Id, V);\n-   end Set_Loop_Entry_Attributes;\n-\n    procedure Set_Low_Bound_Tested (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Formal (Id));\n@@ -7816,6 +7814,7 @@ package body Einfo is\n       W (\"Has_Inheritable_Invariants\",      Flag248 (Id));\n       W (\"Has_Initial_Value\",               Flag219 (Id));\n       W (\"Has_Invariants\",                  Flag232 (Id));\n+      W (\"Has_Loop_Entry_Attributes\",       Flag260 (Id));\n       W (\"Has_Machine_Radix_Clause\",        Flag83  (Id));\n       W (\"Has_Master_Entity\",               Flag21  (Id));\n       W (\"Has_Missing_Return\",              Flag142 (Id));\n@@ -8268,9 +8267,6 @@ package body Einfo is\n               E_Procedure                                  =>\n             Write_Str (\"Handler_Records\");\n \n-         when E_Loop                                       =>\n-            Write_Str (\"Loop_Entry_Attributes\");\n-\n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position_Max\");"}, {"sha": "62cdb8e3f0f08f3c2324da6ac047ede60a0b1e00", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -1598,6 +1598,11 @@ package Einfo is\n --       Note that it might be the full type which has inheritable invariants,\n --       and then the flag will also be set in the private type.\n \n+--    Has_Loop_Entry_Attributes (Flag260)\n+--       Defined in E_Loop entities. Set when the loop is subject to at least\n+--       one attribute 'Loop_Entry. The flag also implies that the loop has\n+--       already been transformed. See Expand_Loop_Entry_Attribute for details.\n+\n --    Has_Machine_Radix_Clause (Flag83)\n --       Defined in decimal types and subtypes, set if a Machine_Radix\n --       representation clause is present. This flag is used to detect\n@@ -3033,10 +3038,6 @@ package Einfo is\n --       the nature and use of this entity for implementing the Image and\n --       Value attributes for the enumeration type in question.\n \n---    Loop_Entry_Attributes (Elist10)\n---       Defined for loop statement scopes. The list contains all Loop_Entry\n---       attribute references related to the target loop.\n-\n --    Low_Bound_Tested (Flag205)\n --       Defined in all entities. Currently this can only be set True for\n --       formal parameter entries of a standard unconstrained one-dimensional\n@@ -5507,8 +5508,8 @@ package Einfo is\n \n    --  E_Loop\n    --    First_Exit_Statement                (Node8)\n-   --    Loop_Entry_Attributes               (Elist10)\n    --    Has_Exit                            (Flag47)\n+   --    Has_Loop_Entry_Attributes           (Flag260)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n \n@@ -6280,6 +6281,7 @@ package Einfo is\n    function Has_Initial_Value                   (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n    function Has_Invariants                      (Id : E) return B;\n+   function Has_Loop_Entry_Attributes           (Id : E) return B;\n    function Has_Machine_Radix_Clause            (Id : E) return B;\n    function Has_Master_Entity                   (Id : E) return B;\n    function Has_Missing_Return                  (Id : E) return B;\n@@ -6444,7 +6446,6 @@ package Einfo is\n    function Limited_View                        (Id : E) return E;\n    function Lit_Indexes                         (Id : E) return E;\n    function Lit_Strings                         (Id : E) return E;\n-   function Loop_Entry_Attributes               (Id : E) return L;\n    function Low_Bound_Tested                    (Id : E) return B;\n    function Machine_Radix_10                    (Id : E) return B;\n    function Master_Id                           (Id : E) return E;\n@@ -6887,6 +6888,7 @@ package Einfo is\n    procedure Set_Has_Inheritable_Invariants      (Id : E; V : B := True);\n    procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n    procedure Set_Has_Invariants                  (Id : E; V : B := True);\n+   procedure Set_Has_Loop_Entry_Attributes       (Id : E; V : B := True);\n    procedure Set_Has_Machine_Radix_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n@@ -7057,7 +7059,6 @@ package Einfo is\n    procedure Set_Limited_View                    (Id : E; V : E);\n    procedure Set_Lit_Indexes                     (Id : E; V : E);\n    procedure Set_Lit_Strings                     (Id : E; V : E);\n-   procedure Set_Loop_Entry_Attributes           (Id : E; V : L);\n    procedure Set_Low_Bound_Tested                (Id : E; V : B := True);\n    procedure Set_Machine_Radix_10                (Id : E; V : B := True);\n    procedure Set_Master_Id                       (Id : E; V : E);\n@@ -7586,6 +7587,7 @@ package Einfo is\n    pragma Inline (Has_Inheritable_Invariants);\n    pragma Inline (Has_Initial_Value);\n    pragma Inline (Has_Invariants);\n+   pragma Inline (Has_Loop_Entry_Attributes);\n    pragma Inline (Has_Machine_Radix_Clause);\n    pragma Inline (Has_Master_Entity);\n    pragma Inline (Has_Missing_Return);\n@@ -7795,7 +7797,6 @@ package Einfo is\n    pragma Inline (Limited_View);\n    pragma Inline (Lit_Indexes);\n    pragma Inline (Lit_Strings);\n-   pragma Inline (Loop_Entry_Attributes);\n    pragma Inline (Low_Bound_Tested);\n    pragma Inline (Machine_Radix_10);\n    pragma Inline (Master_Id);\n@@ -8043,6 +8044,7 @@ package Einfo is\n    pragma Inline (Set_Has_Inheritable_Invariants);\n    pragma Inline (Set_Has_Initial_Value);\n    pragma Inline (Set_Has_Invariants);\n+   pragma Inline (Set_Has_Loop_Entry_Attributes);\n    pragma Inline (Set_Has_Machine_Radix_Clause);\n    pragma Inline (Set_Has_Master_Entity);\n    pragma Inline (Set_Has_Missing_Return);\n@@ -8212,7 +8214,6 @@ package Einfo is\n    pragma Inline (Set_Limited_View);\n    pragma Inline (Set_Lit_Indexes);\n    pragma Inline (Set_Lit_Strings);\n-   pragma Inline (Set_Loop_Entry_Attributes);\n    pragma Inline (Set_Low_Bound_Tested);\n    pragma Inline (Set_Machine_Radix_10);\n    pragma Inline (Set_Master_Id);"}, {"sha": "fc44324d160380bed5ceaea1a7ea1839a115d28f", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 379, "deletions": 5, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -136,6 +136,10 @@ package body Exp_Attr is\n    --  that takes two floating-point arguments. The function to be called\n    --  is always the same as the attribute name.\n \n+   procedure Expand_Loop_Entry_Attribute (Attr : Node_Id);\n+   --  Handle the expansion of attribute 'Loop_Entry. As a result, the related\n+   --  loop may be converted into a conditional block. See body for details.\n+\n    procedure Expand_Pred_Succ (N : Node_Id);\n    --  Handles expansion of Pred or Succ attributes for case of non-real\n    --  operand with overflow checking required.\n@@ -635,10 +639,11 @@ package body Exp_Attr is\n    --  by Expand_Fpt_Attribute\n \n    procedure Expand_Fpt_Attribute_RR (N : Node_Id) is\n-      E1  : constant Node_Id   := First (Expressions (N));\n+      E1  : constant Node_Id := First (Expressions (N));\n+      E2  : constant Node_Id := Next (E1);\n       Ftp : Entity_Id;\n       Pkg : RE_Id;\n-      E2  : constant Node_Id   := Next (E1);\n+\n    begin\n       Find_Fat_Info (Etype (E1), Ftp, Pkg);\n       Expand_Fpt_Attribute\n@@ -648,6 +653,374 @@ package body Exp_Attr is\n            Unchecked_Convert_To (Ftp, Relocate_Node (E2))));\n    end Expand_Fpt_Attribute_RR;\n \n+   ---------------------------------\n+   -- Expand_Loop_Entry_Attribute --\n+   ---------------------------------\n+\n+   procedure Expand_Loop_Entry_Attribute (Attr : Node_Id) is\n+      procedure Build_Conditional_Block\n+        (Loc       : Source_Ptr;\n+         Cond      : Node_Id;\n+         Loop_Stmt : Node_Id;\n+         If_Stmt   : out Node_Id;\n+         Blk_Stmt  : out Node_Id);\n+      --  Create a block Blk_Stmt with an empty declarative list and a single\n+      --  loop Loop_Stmt. The block is encased in an if statement If_Stmt with\n+      --  condition Cond. If_Stmt is Empty when there is no condition provided.\n+\n+      function Is_Array_Iteration (N : Node_Id) return Boolean;\n+      --  Determine whether loop statement N denotes an Ada 2012 iteration over\n+      --  an array object.\n+\n+      -----------------------------\n+      -- Build_Conditional_Block --\n+      -----------------------------\n+\n+      procedure Build_Conditional_Block\n+        (Loc       : Source_Ptr;\n+         Cond      : Node_Id;\n+         Loop_Stmt : Node_Id;\n+         If_Stmt   : out Node_Id;\n+         Blk_Stmt  : out Node_Id)\n+      is\n+      begin\n+         --  Do not reanalyze the original loop statement because it is simply\n+         --  being relocated.\n+\n+         Set_Analyzed (Loop_Stmt);\n+\n+         Blk_Stmt :=\n+           Make_Block_Statement (Loc,\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Loop_Stmt)));\n+\n+         if Present (Cond) then\n+            If_Stmt :=\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Blk_Stmt));\n+         else\n+            If_Stmt := Empty;\n+         end if;\n+      end Build_Conditional_Block;\n+\n+      ------------------------\n+      -- Is_Array_Iteration --\n+      ------------------------\n+\n+      function Is_Array_Iteration (N : Node_Id) return Boolean is\n+         Stmt : constant Node_Id := Original_Node (N);\n+         Iter : Node_Id;\n+\n+      begin\n+         if Nkind (Stmt) = N_Loop_Statement\n+           and then Present (Iteration_Scheme (Stmt))\n+           and then Present (Iterator_Specification (Iteration_Scheme (Stmt)))\n+         then\n+            Iter := Iterator_Specification (Iteration_Scheme (Stmt));\n+\n+            return\n+              Of_Present (Iter) and then Is_Array_Type (Etype (Name (Iter)));\n+         end if;\n+\n+         return False;\n+      end Is_Array_Iteration;\n+\n+      --  Local variables\n+\n+      Exprs     : constant List_Id   := Expressions (Attr);\n+      Pref      : constant Node_Id   := Prefix (Attr);\n+      Typ       : constant Entity_Id := Etype (Pref);\n+      Blk       : Node_Id;\n+      Decls     : List_Id;\n+      Installed : Boolean;\n+      Loc       : Source_Ptr;\n+      Loop_Id   : Entity_Id;\n+      Loop_Stmt : Node_Id;\n+      Result    : Node_Id;\n+      Scheme    : Node_Id;\n+      Temp_Decl : Node_Id;\n+      Temp_Id   : Entity_Id;\n+\n+   --  Start of processing for Expand_Loop_Entry_Attribute\n+\n+   begin\n+      --  Step 1: Find the related loop\n+\n+      --  The loop label variant of attribute 'Loop_Entry already has all the\n+      --  information in its expression.\n+\n+      if Present (Exprs) then\n+         Loop_Id   := Entity (First (Exprs));\n+         Loop_Stmt := Label_Construct (Parent (Loop_Id));\n+\n+      --  Climb the parent chain to find the nearest enclosing loop. Skip all\n+      --  internally generated loops for quantified expressions.\n+\n+      else\n+         Loop_Stmt := Attr;\n+         while Present (Loop_Stmt) loop\n+            if Nkind (Loop_Stmt) = N_Loop_Statement\n+              and then Present (Identifier (Loop_Stmt))\n+            then\n+               exit;\n+            end if;\n+\n+            Loop_Stmt := Parent (Loop_Stmt);\n+         end loop;\n+\n+         Loop_Id := Entity (Identifier (Loop_Stmt));\n+      end if;\n+\n+      Loc := Sloc (Loop_Stmt);\n+\n+      --  Step 2: Transform the loop\n+\n+      --  The loop has already been transformed during the expansion of a prior\n+      --  'Loop_Entry attribute. Retrieve the declarative list of the block.\n+\n+      if Has_Loop_Entry_Attributes (Loop_Id) then\n+         Decls  := Declarations (Parent (Parent (Loop_Stmt)));\n+         Result := Empty;\n+\n+      --  Transform the loop into a conditional block\n+\n+      else\n+         Set_Has_Loop_Entry_Attributes (Loop_Id);\n+         Scheme := Iteration_Scheme (Loop_Stmt);\n+\n+         --  While loops are transformed into:\n+\n+         --    if <Condition> then\n+         --       declare\n+         --          Temp1 : constant <type of Pref1> := <Pref1>;\n+         --          . . .\n+         --          TempN : constant <type of PrefN> := <PrefN>;\n+         --       begin\n+         --          loop\n+         --             <original source statements with attribute rewrites>\n+         --             exit when not <Condition>;\n+         --          end loop;\n+         --       end;\n+         --    end if;\n+\n+         --  Note that loops over iterators and containers are already\n+         --  converted into while loops.\n+\n+         if Present (Condition (Scheme)) then\n+            declare\n+               Cond : constant Node_Id := Condition (Scheme);\n+\n+            begin\n+               --  Transform the original while loop into an infinite loop\n+               --  where the last statement checks the negated condition. This\n+               --  placement ensures that the condition will not be evaluated\n+               --  twice on the first iteration.\n+\n+               --  Generate:\n+               --    exit when not <Cond>:\n+\n+               Append_To (Statements (Loop_Stmt),\n+                 Make_Exit_Statement (Loc,\n+                   Condition => Make_Op_Not (Loc, New_Copy_Tree (Cond))));\n+\n+               Build_Conditional_Block (Loc,\n+                 Cond      => Relocate_Node (Cond),\n+                 Loop_Stmt => Relocate_Node (Loop_Stmt),\n+                 If_Stmt   => Result,\n+                 Blk_Stmt  => Blk);\n+            end;\n+\n+         --  Ada 2012 iteration over an array is transformed into:\n+\n+         --    if <Array_Nam>'Length (1) > 0\n+         --      and then <Array_Nam>'Length (N) > 0\n+         --    then\n+         --       declare\n+         --          Temp1 : constant <type of Pref1> := <Pref1>;\n+         --          . . .\n+         --          TempN : constant <type of PrefN> := <PrefN>;\n+         --       begin\n+         --          for X in ... loop  --  multiple loops depending on dims\n+         --             <original source statements with attribute rewrites>\n+         --          end loop;\n+         --       end;\n+         --    end if;\n+\n+         elsif Is_Array_Iteration (Loop_Stmt) then\n+            declare\n+               Array_Nam : constant Entity_Id :=\n+                             Entity (Name (Iterator_Specification\n+                              (Iteration_Scheme (Original_Node (Loop_Stmt)))));\n+               Num_Dims  : constant Pos :=\n+                             Number_Dimensions (Etype (Array_Nam));\n+               Cond      : Node_Id := Empty;\n+               Check     : Node_Id;\n+\n+            begin\n+               --  Generate a check which determines whether all dimensions of\n+               --  the array are non-null.\n+\n+               for Dim in 1 .. Num_Dims loop\n+                  Check :=\n+                    Make_Op_Gt (Loc,\n+                      Left_Opnd  =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix         => New_Reference_To (Array_Nam, Loc),\n+                          Attribute_Name => Name_Length,\n+                          Expressions    => New_List (\n+                            Make_Integer_Literal (Loc, Dim))),\n+                      Right_Opnd =>\n+                        Make_Integer_Literal (Loc, 0));\n+\n+                  if No (Cond) then\n+                     Cond := Check;\n+                  else\n+                     Cond :=\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  => Cond,\n+                         Right_Opnd => Check);\n+                  end if;\n+               end loop;\n+\n+               Build_Conditional_Block (Loc,\n+                 Cond      => Cond,\n+                 Loop_Stmt => Relocate_Node (Loop_Stmt),\n+                 If_Stmt   => Result,\n+                 Blk_Stmt  => Blk);\n+            end;\n+\n+         --  For loops are transformed into:\n+\n+         --    if <Low> <= <High> then\n+         --       declare\n+         --          Temp1 : constant <type of Pref1> := <Pref1>;\n+         --          . . .\n+         --          TempN : constant <type of PrefN> := <PrefN>;\n+         --       begin\n+         --          for <Def_Id> in <Low> .. <High> loop\n+         --             <original source statements with attribute rewrites>\n+         --          end loop;\n+         --       end;\n+         --    end if;\n+\n+         elsif Present (Loop_Parameter_Specification (Scheme)) then\n+            declare\n+               Loop_Spec : constant Node_Id :=\n+                             Loop_Parameter_Specification (Scheme);\n+               Cond      : Node_Id;\n+               Subt_Def  : Node_Id;\n+\n+            begin\n+               Subt_Def := Discrete_Subtype_Definition (Loop_Spec);\n+\n+               --  When the loop iterates over a subtype indication with a\n+               --  range, use the low and high bounds of the subtype itself.\n+\n+               if Nkind (Subt_Def) = N_Subtype_Indication then\n+                  Subt_Def := Scalar_Range (Etype (Subt_Def));\n+               end if;\n+\n+               pragma Assert (Nkind (Subt_Def) = N_Range);\n+\n+               --  Generate\n+               --    Low <= High\n+\n+               Cond :=\n+                 Make_Op_Le (Loc,\n+                   Left_Opnd  => New_Copy_Tree (Low_Bound (Subt_Def)),\n+                   Right_Opnd => New_Copy_Tree (High_Bound (Subt_Def)));\n+\n+               Build_Conditional_Block (Loc,\n+                 Cond      => Cond,\n+                 Loop_Stmt => Relocate_Node (Loop_Stmt),\n+                 If_Stmt   => Result,\n+                 Blk_Stmt  => Blk);\n+            end;\n+\n+         --  Infinite loops are transformed into:\n+\n+         --    declare\n+         --       Temp1 : constant <type of Pref1> := <Pref1>;\n+         --       . . .\n+         --       TempN : constant <type of PrefN> := <PrefN>;\n+         --    begin\n+         --       loop\n+         --          <original source statements with attribute rewrites>\n+         --       end loop;\n+         --    end;\n+\n+         else\n+            Build_Conditional_Block (Loc,\n+              Cond      => Empty,\n+              Loop_Stmt => Relocate_Node (Loop_Stmt),\n+              If_Stmt   => Result,\n+              Blk_Stmt  => Blk);\n+\n+            Result := Blk;\n+         end if;\n+\n+         Decls := Declarations (Blk);\n+      end if;\n+\n+      --  Step 3: Create a constant to capture the value of the prefix at the\n+      --  entry point into the loop.\n+\n+      --  Generate:\n+      --    Temp : constant <type of Pref> := <Pref>;\n+\n+      Temp_Id := Make_Temporary (Loc, 'P');\n+\n+      Temp_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Temp_Id,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (Typ, Loc),\n+          Expression          => Relocate_Node (Pref));\n+      Append_To (Decls, Temp_Decl);\n+\n+      --  Step 4: Analyze all bits\n+\n+      Rewrite (Attr, New_Reference_To (Temp_Id, Loc));\n+\n+      --  The analysis of the conditional block takes care of the constant\n+      --  declaration.\n+\n+      Installed := Current_Scope = Loop_Id;\n+\n+      if not Installed then\n+         Push_Scope (Scope (Loop_Id));\n+      end if;\n+\n+      if Present (Result) then\n+         Rewrite (Loop_Stmt, Result);\n+         Analyze (Loop_Stmt);\n+      else\n+         Analyze (Temp_Decl);\n+      end if;\n+\n+      Analyze (Attr);\n+\n+      --  Patch up a renaming of a 'Loop_Entry attribute. This case may arise\n+      --  when the attribute is used as the name in an Ada 2012 iterator loop.\n+\n+      if Nkind (Parent (Attr)) = N_Object_Renaming_Declaration then\n+         declare\n+            Mark : constant Node_Id := Subtype_Mark (Parent (Attr));\n+\n+         begin\n+            Rewrite (Mark, New_Reference_To (Etype (Temp_Id), Sloc (Mark)));\n+            Analyze (Mark);\n+         end;\n+      end if;\n+\n+      if not Installed then\n+         Pop_Scope;\n+      end if;\n+   end Expand_Loop_Entry_Attribute;\n+\n    ----------------------------------\n    -- Expand_N_Attribute_Reference --\n    ----------------------------------\n@@ -3138,11 +3511,12 @@ package body Exp_Attr is\n          end if;\n       end Length;\n \n-      --  The expansion of this attribute is carried out when the target loop\n-      --  is processed. See Expand_Loop_Entry_Attributes for details.\n+      --  Attribute Loop_Entry is replaced with a reference to a constant value\n+      --  which captures the prefix at the entry point of the related loop. The\n+      --  loop itself may be transformed into a conditional block.\n \n       when Attribute_Loop_Entry =>\n-         null;\n+         Expand_Loop_Entry_Attribute (N);\n \n       -------------\n       -- Machine --"}, {"sha": "95e649a13e9214fba8ff613eec4b678a331bae48", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 28, "deletions": 368, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -28,7 +28,6 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n-with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -111,10 +110,6 @@ package body Exp_Ch5 is\n    procedure Expand_Iterator_Loop_Over_Array (N : Node_Id);\n    --  Expand loop over arrays that uses the form \"for X of C\"\n \n-   procedure Expand_Loop_Entry_Attributes (N : Node_Id);\n-   --  Given a loop statement subject to at least one Loop_Entry attribute,\n-   --  expand both the loop and all related Loop_Entry references.\n-\n    procedure Expand_Predicated_Loop (N : Node_Id);\n    --  Expand for loop over predicated subtype\n \n@@ -1527,347 +1522,6 @@ package body Exp_Ch5 is\n       end;\n    end Expand_Assign_Record;\n \n-   ----------------------------------\n-   -- Expand_Loop_Entry_Attributes --\n-   ----------------------------------\n-\n-   procedure Expand_Loop_Entry_Attributes (N : Node_Id) is\n-      procedure Build_Conditional_Block\n-        (Loc      : Source_Ptr;\n-         Cond     : Node_Id;\n-         Stmt     : Node_Id;\n-         If_Stmt  : out Node_Id;\n-         Blk_Stmt : out Node_Id);\n-      --  Create a block Blk_Stmt with an empty declarative list and a single\n-      --  statement Stmt. The block is encased in an if statement If_Stmt with\n-      --  condition Cond. If_Stmt is Empty when there is no condition provided.\n-\n-      function Is_Array_Iteration (N : Node_Id) return Boolean;\n-      --  Determine whether loop statement N denotes an Ada 2012 iteration over\n-      --  an array object.\n-\n-      -----------------------------\n-      -- Build_Conditional_Block --\n-      -----------------------------\n-\n-      procedure Build_Conditional_Block\n-        (Loc      : Source_Ptr;\n-         Cond     : Node_Id;\n-         Stmt     : Node_Id;\n-         If_Stmt  : out Node_Id;\n-         Blk_Stmt : out Node_Id)\n-      is\n-      begin\n-         Blk_Stmt :=\n-           Make_Block_Statement (Loc,\n-             Declarations               => New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (Stmt)));\n-\n-         if Present (Cond) then\n-            If_Stmt :=\n-              Make_If_Statement (Loc,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Blk_Stmt));\n-         else\n-            If_Stmt := Empty;\n-         end if;\n-      end Build_Conditional_Block;\n-\n-      ------------------------\n-      -- Is_Array_Iteration --\n-      ------------------------\n-\n-      function Is_Array_Iteration (N : Node_Id) return Boolean is\n-         Stmt : constant Node_Id := Original_Node (N);\n-         Iter : Node_Id;\n-\n-      begin\n-         if Nkind (Stmt) = N_Loop_Statement\n-           and then Present (Iteration_Scheme (Stmt))\n-           and then Present (Iterator_Specification (Iteration_Scheme (Stmt)))\n-         then\n-            Iter := Iterator_Specification (Iteration_Scheme (Stmt));\n-\n-            return\n-              Of_Present (Iter)\n-                and then Is_Array_Type (Etype (Name (Iter)));\n-         end if;\n-\n-         return False;\n-      end Is_Array_Iteration;\n-\n-      --  Local variables\n-\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Loop_Id : constant Entity_Id  := Identifier (N);\n-      Scheme  : constant Node_Id    := Iteration_Scheme (N);\n-      Blk     : Node_Id;\n-      LE      : Node_Id;\n-      LE_Elmt : Elmt_Id;\n-      Result  : Node_Id;\n-      Temp    : Entity_Id;\n-      Typ     : Entity_Id;\n-\n-   --  Start of processing for Expand_Loop_Entry_Attributes\n-\n-   begin\n-      --  The loop will never execute after it has been expanded, no point in\n-      --  processing it.\n-\n-      if Is_Null_Loop (N) then\n-         return;\n-\n-      --  A loop without an identifier cannot be referenced in 'Loop_Entry\n-\n-      elsif No (Loop_Id) then\n-         return;\n-\n-      --  The loop is not subject to 'Loop_Entry\n-\n-      elsif No (Loop_Entry_Attributes (Entity (Loop_Id))) then\n-         return;\n-\n-      --  Step 1: Loop transformations\n-\n-      --  While loops are transformed into:\n-\n-      --    if <Condition> then\n-      --       declare\n-      --          Temp1 : constant <type of Pref1> := <Pref1>;\n-      --          . . .\n-      --          TempN : constant <type of PrefN> := <PrefN>;\n-      --       begin\n-      --          loop\n-      --             <original source statements with attribute rewrites>\n-      --             exit when not <Condition>;\n-      --          end loop;\n-      --       end;\n-      --    end if;\n-\n-      --  Note that loops over iterators and containers are already converted\n-      --  into while loops.\n-\n-      elsif Present (Condition (Scheme)) then\n-         declare\n-            Cond : constant Node_Id := Condition (Scheme);\n-\n-         begin\n-            --  Transform the original while loop into an infinite loop where\n-            --  the last statement checks the negated condition. This placement\n-            --  ensures that the condition will not be evaluated twice on the\n-            --  first iteration.\n-\n-            --  Generate:\n-            --    exit when not <Cond>:\n-\n-            Append_To (Statements (N),\n-              Make_Exit_Statement (Loc,\n-                Condition => Make_Op_Not (Loc, New_Copy_Tree (Cond))));\n-\n-            Build_Conditional_Block (Loc,\n-              Cond     => Relocate_Node (Cond),\n-              Stmt     => Relocate_Node (N),\n-              If_Stmt  => Result,\n-              Blk_Stmt => Blk);\n-         end;\n-\n-      --  Ada 2012 iteration over an array is transformed into:\n-\n-      --    if <Array_Nam>'Length (1) > 0\n-      --      and then <Array_Nam>'Length (N) > 0\n-      --    then\n-      --       declare\n-      --          Temp1 : constant <type of Pref1> := <Pref1>;\n-      --          . . .\n-      --          TempN : constant <type of PrefN> := <PrefN>;\n-      --       begin\n-      --          for X in ... loop  --  multiple loops depending on dims\n-      --             <original source statements with attribute rewrites>\n-      --          end loop;\n-      --       end;\n-      --    end if;\n-\n-      elsif Is_Array_Iteration (N) then\n-         declare\n-            Array_Nam : constant Entity_Id :=\n-                          Entity (Name (Iterator_Specification\n-                            (Iteration_Scheme (Original_Node (N)))));\n-            Num_Dims  : constant Pos :=\n-                          Number_Dimensions (Etype (Array_Nam));\n-            Cond      : Node_Id := Empty;\n-            Check     : Node_Id;\n-            Top_Loop  : Node_Id;\n-\n-         begin\n-            --  Generate a check which determines whether all dimensions of\n-            --  the array are non-null.\n-\n-            for Dim in 1 .. Num_Dims loop\n-               Check :=\n-                 Make_Op_Gt (Loc,\n-                   Left_Opnd  =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => New_Reference_To (Array_Nam, Loc),\n-                       Attribute_Name => Name_Length,\n-                       Expressions    => New_List (\n-                         Make_Integer_Literal (Loc, Dim))),\n-                   Right_Opnd =>\n-                     Make_Integer_Literal (Loc, 0));\n-\n-               if No (Cond) then\n-                  Cond := Check;\n-               else\n-                  Cond :=\n-                    Make_And_Then (Loc,\n-                      Left_Opnd  => Cond,\n-                      Right_Opnd => Check);\n-               end if;\n-            end loop;\n-\n-            Top_Loop := Relocate_Node (N);\n-            Set_Analyzed (Top_Loop);\n-\n-            Build_Conditional_Block (Loc,\n-              Cond     => Cond,\n-              Stmt     => Top_Loop,\n-              If_Stmt  => Result,\n-              Blk_Stmt => Blk);\n-         end;\n-\n-      --  For loops are transformed into:\n-\n-      --    if <Low> <= <High> then\n-      --       declare\n-      --          Temp1 : constant <type of Pref1> := <Pref1>;\n-      --          . . .\n-      --          TempN : constant <type of PrefN> := <PrefN>;\n-      --       begin\n-      --          for <Def_Id> in <Low> .. <High> loop\n-      --             <original source statements with attribute rewrites>\n-      --          end loop;\n-      --       end;\n-      --    end if;\n-\n-      elsif Present (Loop_Parameter_Specification (Scheme)) then\n-         declare\n-            Loop_Spec : constant Node_Id :=\n-                          Loop_Parameter_Specification (Scheme);\n-            Cond      : Node_Id;\n-            Subt_Def  : Node_Id;\n-\n-         begin\n-            Subt_Def := Discrete_Subtype_Definition (Loop_Spec);\n-\n-            --  When the loop iterates over a subtype indication with a range,\n-            --  use the low and high bounds of the subtype itself.\n-\n-            if Nkind (Subt_Def) = N_Subtype_Indication then\n-               Subt_Def := Scalar_Range (Etype (Subt_Def));\n-            end if;\n-\n-            pragma Assert (Nkind (Subt_Def) = N_Range);\n-\n-            --  Generate\n-            --    Low <= High\n-\n-            Cond :=\n-              Make_Op_Le (Loc,\n-                Left_Opnd  => New_Copy_Tree (Low_Bound (Subt_Def)),\n-                Right_Opnd => New_Copy_Tree (High_Bound (Subt_Def)));\n-\n-            Build_Conditional_Block (Loc,\n-              Cond     => Cond,\n-              Stmt     => Relocate_Node (N),\n-              If_Stmt  => Result,\n-              Blk_Stmt => Blk);\n-         end;\n-\n-      --  Infinite loops are transformed into:\n-\n-      --    declare\n-      --       Temp1 : constant <type of Pref1> := <Pref1>;\n-      --       . . .\n-      --       TempN : constant <type of PrefN> := <PrefN>;\n-      --    begin\n-      --       loop\n-      --          <original source statements with attribute rewrites>\n-      --       end loop;\n-      --    end;\n-\n-      else\n-         Build_Conditional_Block (Loc,\n-           Cond     => Empty,\n-           Stmt     => Relocate_Node (N),\n-           If_Stmt  => Result,\n-           Blk_Stmt => Blk);\n-\n-         Result := Blk;\n-      end if;\n-\n-      --  Step 2: Loop_Entry attribute transformations\n-\n-      --  At this point the various loops have been augmented to contain a\n-      --  block. Populate the declarative list of the block with constants\n-      --  which store the value of their relative prefixes at the point of\n-      --  entry in the loop.\n-\n-      LE_Elmt := First_Elmt (Loop_Entry_Attributes (Entity (Loop_Id)));\n-      while Present (LE_Elmt) loop\n-         LE  := Node (LE_Elmt);\n-         Typ := Etype (Prefix (LE));\n-\n-         --  Declare a constant to capture the value of the prefix of each\n-         --  Loop_Entry attribute.\n-\n-         --  Generate:\n-         --    Temp : constant <type of Pref> := <Pref>;\n-\n-         Temp := Make_Temporary (Loc, 'P');\n-\n-         Append_To (Declarations (Blk),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Reference_To (Typ, Loc),\n-             Expression          => Relocate_Node (Prefix (LE))));\n-\n-         --  Perform minor decoration as this information will be needed for\n-         --  the creation of index checks (if applicable).\n-\n-         Set_Ekind (Temp, E_Constant);\n-         Set_Etype (Temp, Typ);\n-\n-         --  Replace the original attribute with a reference to the constant\n-\n-         Rewrite (LE, New_Reference_To (Temp, Loc));\n-         Set_Etype (LE, Typ);\n-\n-         --  Analysis converts attribute references of the following form\n-\n-         --     Prefix'Loop_Entry (Expr)\n-         --     Prefix'Loop_Entry (Expr1, Expr2, ... ExprN)\n-\n-         --  into indexed components for error detection purposes. Generate\n-         --  index checks now that 'Loop_Entry has been properly expanded.\n-\n-         if Nkind (Parent (LE)) = N_Indexed_Component then\n-            Generate_Index_Checks (Parent (LE));\n-         end if;\n-\n-         Next_Elmt (LE_Elmt);\n-      end loop;\n-\n-      --  Destroy the list of Loop_Entry attributes to prevent the infinite\n-      --  expansion when analyzing and expanding the newly generated loops.\n-\n-      Set_Loop_Entry_Attributes (Entity (Loop_Id), No_Elist);\n-\n-      Rewrite (N, Result);\n-      Analyze (N);\n-   end Expand_Loop_Entry_Attributes;\n-\n    -----------------------------------\n    -- Expand_N_Assignment_Statement --\n    -----------------------------------\n@@ -3777,8 +3431,9 @@ package body Exp_Ch5 is\n    --  7. Insert polling call if required\n \n    procedure Expand_N_Loop_Statement (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Isc  : constant Node_Id    := Iteration_Scheme (N);\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Scheme : constant Node_Id    := Iteration_Scheme (N);\n+      Stmt   : Node_Id;\n \n    begin\n       --  Delete null loop\n@@ -3788,12 +3443,10 @@ package body Exp_Ch5 is\n          return;\n       end if;\n \n-      Process_Statements_For_Controlled_Objects (N);\n-\n       --  Deal with condition for C/Fortran Boolean\n \n-      if Present (Isc) then\n-         Adjust_Condition (Condition (Isc));\n+      if Present (Scheme) then\n+         Adjust_Condition (Condition (Scheme));\n       end if;\n \n       --  Generate polling call\n@@ -3804,7 +3457,7 @@ package body Exp_Ch5 is\n \n       --  Nothing more to do for plain loop with no iteration scheme\n \n-      if No (Isc) then\n+      if No (Scheme) then\n          null;\n \n       --  Case of for loop (Loop_Parameter_Specification present)\n@@ -3813,9 +3466,10 @@ package body Exp_Ch5 is\n       --  range bounds here, since they were frozen with constant declarations\n       --  and it is during that process that the validity checking is done.\n \n-      elsif Present (Loop_Parameter_Specification (Isc)) then\n+      elsif Present (Loop_Parameter_Specification (Scheme)) then\n          declare\n-            LPS     : constant Node_Id   := Loop_Parameter_Specification (Isc);\n+            LPS     : constant Node_Id   :=\n+                        Loop_Parameter_Specification (Scheme);\n             Loop_Id : constant Entity_Id := Defining_Identifier (LPS);\n             Ltype   : constant Entity_Id := Etype (Loop_Id);\n             Btype   : constant Entity_Id := Base_Type (Ltype);\n@@ -3990,22 +3644,22 @@ package body Exp_Ch5 is\n       --       ...\n       --    end loop\n \n-      elsif Present (Isc)\n-        and then Present (Condition_Actions (Isc))\n-        and then Present (Condition (Isc))\n+      elsif Present (Scheme)\n+        and then Present (Condition_Actions (Scheme))\n+        and then Present (Condition (Scheme))\n       then\n          declare\n             ES : Node_Id;\n \n          begin\n             ES :=\n-              Make_Exit_Statement (Sloc (Condition (Isc)),\n+              Make_Exit_Statement (Sloc (Condition (Scheme)),\n                 Condition =>\n-                  Make_Op_Not (Sloc (Condition (Isc)),\n-                    Right_Opnd => Condition (Isc)));\n+                  Make_Op_Not (Sloc (Condition (Scheme)),\n+                    Right_Opnd => Condition (Scheme)));\n \n             Prepend (ES, Statements (N));\n-            Insert_List_Before (ES, Condition_Actions (Isc));\n+            Insert_List_Before (ES, Condition_Actions (Scheme));\n \n             --  This is not an implicit loop, since it is generated in response\n             --  to the loop statement being processed. If this is itself\n@@ -4023,18 +3677,24 @@ package body Exp_Ch5 is\n \n       --  Here to deal with iterator case\n \n-      elsif Present (Isc)\n-        and then Present (Iterator_Specification (Isc))\n+      elsif Present (Scheme)\n+        and then Present (Iterator_Specification (Scheme))\n       then\n          Expand_Iterator_Loop (N);\n       end if;\n \n-      --  If the loop is subject to at least one Loop_Entry attribute, it\n-      --  requires additional processing.\n+      --  When the iteration scheme mentiones attribute 'Loop_Entry, the loop\n+      --  is transformed into a conditional block where the original loop is\n+      --  the sole statement. Inspect the statements of the nested loop for\n+      --  controlled objects.\n+\n+      Stmt := N;\n \n-      if Nkind (N) = N_Loop_Statement then\n-         Expand_Loop_Entry_Attributes (N);\n+      if Subject_To_Loop_Entry_Attributes (Stmt) then\n+         Stmt := Find_Loop_In_Conditional_Block (Stmt);\n       end if;\n+\n+      Process_Statements_For_Controlled_Objects (Stmt);\n    end Expand_N_Loop_Statement;\n \n    ----------------------------"}, {"sha": "fba371e2b95c8df4ab43c0a0ff6efe80dbbff4ba", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -830,9 +830,9 @@ package body Exp_Prag is\n \n    --        if Flag then\n    --           if Curr_1 /= Old_1 then\n-   --              pragma Assert (Curr_1 > Old_1);\n+   --              pragma Check (Loop_Variant, Curr_1 > Old_1);\n    --           else\n-   --              pragma Assert (Curr_2 < Old_2);\n+   --              pragma Check (Loop_Variant, Curr_2 < Old_2);\n    --           end if;\n    --        else\n    --           Flag := True;\n@@ -999,12 +999,14 @@ package body Exp_Prag is\n          --  Step 5: Create corresponding assertion to verify change of value\n \n          --  Generate:\n-         --    pragma Assert (Curr <|> Old);\n+         --    pragma Check (Loop_Variant, Curr <|> Old);\n \n          Prag :=\n            Make_Pragma (Loc,\n-             Chars                        => Name_Assert,\n+             Chars                        => Name_Check,\n              Pragma_Argument_Associations => New_List (\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression => Make_Identifier (Loc, Name_Loop_Variant)),\n                Make_Pragma_Argument_Association (Loc,\n                  Expression =>\n                    Make_Op (Loc,"}, {"sha": "bafd224f5b973df7f1dea1fadfddcf7de50fa449", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -2485,8 +2485,8 @@ package body GNAT.Sockets is\n \n       Aliases_Count, Addresses_Count : Natural;\n \n-      --  H_Length is not used because it is currently only set to 4\n-      --  H_Addrtype is always AF_INET\n+      --  H_Length is not used because it is currently only ever set to 4, as\n+      --  H_Addrtype is always AF_INET.\n \n    begin\n       Aliases_Count := 0;\n@@ -2514,10 +2514,24 @@ package body GNAT.Sockets is\n          for J in Result.Addresses'Range loop\n             declare\n                Addr : In_Addr;\n-               for Addr'Address use\n-                 Hostent_H_Addr (E, C.int (J - Result.Addresses'First));\n-               pragma Import (Ada, Addr);\n+\n+               --  Hostent_H_Addr (E, <index>) may return an address that is\n+               --  not correctly aligned for In_Addr, so we need to use\n+               --  an intermediate copy operation on a type with an alignemnt\n+               --  of 1 to recover the value.\n+\n+               subtype Addr_Buf_T is C.char_array (1 .. Addr'Size / 8);\n+               Unaligned_Addr : Addr_Buf_T;\n+               for Unaligned_Addr'Address\n+                 use Hostent_H_Addr (E, C.int (J - Result.Addresses'First));\n+               pragma Import (Ada, Unaligned_Addr);\n+\n+               Aligned_Addr : Addr_Buf_T;\n+               for Aligned_Addr'Address use Addr'Address;\n+               pragma Import (Ada, Aligned_Addr);\n+\n             begin\n+               Aligned_Addr := Unaligned_Addr;\n                To_Inet_Addr (Addr, Result.Addresses (J));\n             end;\n          end loop;"}, {"sha": "edad79318e23670d82bd3b2aef29a9193a13c30f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -180,6 +180,7 @@ Implementation Defined Pragmas\n * Pragma Linker_Section::\n * Pragma Long_Float::\n * Pragma Loop_Optimize::\n+* Pragma Loop_Variant::\n * Pragma Machine_Attribute::\n * Pragma Main::\n * Pragma Main_Storage::\n@@ -937,6 +938,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Linker_Section::\n * Pragma Long_Float::\n * Pragma Loop_Optimize::\n+* Pragma Loop_Variant::\n * Pragma Machine_Attribute::\n * Pragma Main::\n * Pragma Main_Storage::\n@@ -4040,6 +4042,45 @@ compiler in order to enable the relevant optimizations, that is to say\n @option{-funroll-loops} for unrolling and @option{-ftree-vectorize} for\n vectorization.\n \n+@node Pragma Loop_Variant\n+@unnumberedsec Pragma Loop_Variant\n+@findex Loop_Variant\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Loop_Variant ( LOOP_VARIANT_ITEM @{, LOOP_VARIANT_ITEM @} );\n+LOOP_VARIANT_ITEM ::= CHANGE_DIRECTION => discrete_EXPRESSION\n+CHANGE_DIRECTION ::= Increases | Decreases\n+@end smallexample\n+\n+@noindent\n+This pragma must appear immediately within the sequence of statements of a\n+loop statement. It allows the specification of quantities which must always\n+decrease or increase in successive iterations of the loop. In its simplest\n+form, just one expression is specified, whose value must increase or decrease\n+on each iteration of the loop.\n+\n+In a more complex form, multiple arguments can be given which are intepreted\n+in a nesting lexicographic manner. For example:\n+\n+@smallexample @c ada\n+pragma Loop_Variant (Increases => X, Decreases => Y);\n+@end smallexample\n+\n+@noindent\n+specifies that each time through the loop either X increases, or X stays\n+the same and Y decreases. A @code{Loop_Variant} pragma ensures that the\n+loop is making progress. It can be useful in helping to show informally\n+or prove formally that the loop always terminates.\n+\n+@code{Loop_Variant} is an assertion whose effect can be controlled using\n+an @code{Assertion_Policy} with a check name of @code{Loop_Variant}. The\n+policy can be @code{Check} to enable the loop variant check, @code{Ignore}\n+to ignore the check (in which case the pragma has no effect on the program),\n+or @code{Disable} in which case the pragma is not even checked for correct\n+syntax.\n+\n @node Pragma Machine_Attribute\n @unnumberedsec Pragma Machine_Attribute\n @findex Machine_Attribute"}, {"sha": "9f13f32aa364d04cd54a2837b633255514367967", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -114,7 +114,8 @@ package body Repinfo is\n       Table_Name           => \"FE_Rep_Table\");\n \n    Unit_Casing : Casing_Type;\n-   --  Identifier casing for current unit\n+   --  Identifier casing for current unit. This is set by List_Rep_Info for\n+   --  each unit, before calling subprograms which may read it.\n \n    Need_Blank_Line : Boolean;\n    --  Set True if a blank line is needed before outputting any information for\n@@ -988,11 +989,11 @@ package body Repinfo is\n       then\n          for U in Main_Unit .. Last_Unit loop\n             if In_Extended_Main_Source_Unit (Cunit_Entity (U)) then\n+               Unit_Casing := Identifier_Casing (Source_Index (U));\n \n                --  Normal case, list to standard output\n \n                if not List_Representation_Info_To_File then\n-                  Unit_Casing := Identifier_Casing (Source_Index (U));\n                   Write_Eol;\n                   Write_Str (\"Representation information for unit \");\n                   Write_Unit_Name (Unit_Name (U));"}, {"sha": "fc1ace241dfe1cbecf90a62ccacd97c080f2cf80", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -3891,19 +3891,7 @@ package body Sem_Attr is\n             Error_Attr_P (\"prefix of attribute % must denote an entity\");\n          end if;\n \n-         Set_Etype (N, Etype (P));\n-\n-         --  Associate the attribute with its related loop\n-\n-         if No (Loop_Entry_Attributes (Loop_Id)) then\n-            Set_Loop_Entry_Attributes (Loop_Id, New_Elmt_List);\n-         end if;\n-\n-         --  A Loop_Entry may be [pre]analyzed several times, depending on the\n-         --  context. Ensure that it appears only once in the attributes list\n-         --  of the related loop.\n-\n-         Append_Unique_Elmt (N, Loop_Entry_Attributes (Loop_Id));\n+         Set_Etype (N, P_Type);\n       end Loop_Entry;\n \n       -------------"}, {"sha": "c2023cdc216b101881d0c33e085c170cbf42297e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -2545,6 +2545,7 @@ package body Sem_Ch5 is\n       Iter : constant Node_Id := Iteration_Scheme (N);\n       Loc  : constant Source_Ptr := Sloc (N);\n       Ent  : Entity_Id;\n+      Stmt : Node_Id;\n \n    --  Start of processing for Analyze_Loop_Statement\n \n@@ -2707,13 +2708,22 @@ package body Sem_Ch5 is\n          Analyze_Statements (Statements (N));\n       end if;\n \n+      --  When the iteration scheme of a loop contains attribute 'Loop_Entry,\n+      --  the loop is transformed into a conditional block. Retrieve the loop.\n+\n+      Stmt := N;\n+\n+      if Subject_To_Loop_Entry_Attributes (Stmt) then\n+         Stmt := Find_Loop_In_Conditional_Block (Stmt);\n+      end if;\n+\n       --  Finish up processing for the loop. We kill all current values, since\n       --  in general we don't know if the statements in the loop have been\n       --  executed. We could do a bit better than this with a loop that we\n       --  know will execute at least once, but it's not worth the trouble and\n       --  the front end is not in the business of flow tracing.\n \n-      Process_End_Label (N, 'e', Ent);\n+      Process_End_Label (Stmt, 'e', Ent);\n       End_Scope;\n       Kill_Current_Values;\n \n@@ -2724,15 +2734,15 @@ package body Sem_Ch5 is\n       --  before making this call, since Check_Infinite_Loop_Warning relies on\n       --  being able to use semantic visibility information to find references.\n \n-      if Comes_From_Source (N) then\n-         Check_Infinite_Loop_Warning (N);\n+      if Comes_From_Source (Stmt) then\n+         Check_Infinite_Loop_Warning (Stmt);\n       end if;\n \n       --  Code after loop is unreachable if the loop has no WHILE or FOR and\n       --  contains no EXIT statements within the body of the loop.\n \n       if No (Iter) and then not Has_Exit (Ent) then\n-         Check_Unreachable_Code (N);\n+         Check_Unreachable_Code (Stmt);\n       end if;\n    end Analyze_Loop_Statement;\n "}, {"sha": "c421b5a358e82297e2fe54e7c2e7a4e98b0d19dd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -13962,7 +13962,6 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n-            S14_Pragma;\n             Check_At_Least_N_Arguments (1);\n             Check_Loop_Pragma_Placement;\n "}, {"sha": "5cf86f97d24585c3e9252d0f62c017e86c50284f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -4740,6 +4740,41 @@ package body Sem_Util is\n       raise Program_Error;\n    end Find_Corresponding_Discriminant;\n \n+   ------------------------------------\n+   -- Find_Loop_In_Conditional_Block --\n+   ------------------------------------\n+\n+   function Find_Loop_In_Conditional_Block (N : Node_Id) return Node_Id is\n+      Stmt : Node_Id;\n+\n+   begin\n+      Stmt := N;\n+\n+      if Nkind (Stmt) = N_If_Statement then\n+         Stmt := First (Then_Statements (Stmt));\n+      end if;\n+\n+      pragma Assert (Nkind (Stmt) = N_Block_Statement);\n+\n+      --  Inspect the statements of the conditional block. In general the loop\n+      --  should be the first statement in the statement sequence of the block,\n+      --  but the finalization machinery may have introduced extra object\n+      --  declarations.\n+\n+      Stmt := First (Statements (Handled_Statement_Sequence (Stmt)));\n+      while Present (Stmt) loop\n+         if Nkind (Stmt) = N_Loop_Statement then\n+            return Stmt;\n+         end if;\n+\n+         Next (Stmt);\n+      end loop;\n+\n+      --  The expansion of attribute 'Loop_Entry produced a malformed block\n+\n+      raise Program_Error;\n+   end Find_Loop_In_Conditional_Block;\n+\n    --------------------------\n    -- Find_Overlaid_Entity --\n    --------------------------\n@@ -13870,6 +13905,33 @@ package body Sem_Util is\n         and then not Is_Formal (Entity (R2));\n    end Statically_Different;\n \n+   --------------------------------------\n+   -- Subject_To_Loop_Entry_Attributes --\n+   --------------------------------------\n+\n+   function Subject_To_Loop_Entry_Attributes (N : Node_Id) return Boolean is\n+      Stmt : Node_Id;\n+\n+   begin\n+      Stmt := N;\n+\n+      --  The expansion mechanism transform a loop subject to at least one\n+      --  'Loop_Entry attribute into a conditional block. Infinite loops lack\n+      --  the conditional part.\n+\n+      if Nkind_In (Stmt, N_Block_Statement, N_If_Statement)\n+        and then Nkind (Original_Node (N)) = N_Loop_Statement\n+      then\n+         Stmt := Original_Node (N);\n+      end if;\n+\n+      return\n+        Nkind (Stmt) = N_Loop_Statement\n+          and then Present (Identifier (Stmt))\n+          and then Present (Entity (Identifier (Stmt)))\n+          and then Has_Loop_Entry_Attributes (Entity (Identifier (Stmt)));\n+   end Subject_To_Loop_Entry_Attributes;\n+\n    -----------------------------\n    -- Subprogram_Access_Level --\n    -----------------------------"}, {"sha": "6fe1abe88b5d7273b336194a8c1ad1b477214555", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436b30d99371fec40a60e617f86e3ede5701ac2/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d436b30d99371fec40a60e617f86e3ede5701ac2", "patch": "@@ -474,6 +474,11 @@ package Sem_Util is\n    --  analyzed. Subsequent uses of this id on a different type denotes the\n    --  discriminant at the same position in this new type.\n \n+   function Find_Loop_In_Conditional_Block (N : Node_Id) return Node_Id;\n+   --  Find the nested loop statement in a conditional block. Loops subject to\n+   --  attribute 'Loop_Entry are transformed into blocks. Parts of the original\n+   --  loop are nested within the block.\n+\n    procedure Find_Overlaid_Entity\n      (N   : Node_Id;\n       Ent : out Entity_Id;\n@@ -1524,6 +1529,10 @@ package Sem_Util is\n    --  Return True if it can be statically determined that the Expressions\n    --  E1 and E2 refer to different objects\n \n+   function Subject_To_Loop_Entry_Attributes (N : Node_Id) return Boolean;\n+   --  Determine whether node N is a loop statement subject to at least one\n+   --  'Loop_Entry attribute.\n+\n    function Subprogram_Access_Level (Subp : Entity_Id) return Uint;\n    --  Return the accessibility level of the view denoted by Subp\n "}]}