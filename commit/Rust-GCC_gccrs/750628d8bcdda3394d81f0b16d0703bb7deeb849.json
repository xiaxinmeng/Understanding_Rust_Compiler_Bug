{"sha": "750628d8bcdda3394d81f0b16d0703bb7deeb849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwNjI4ZDhiY2RkYTMzOTRkODFmMGIxNmQwNzAzYmI3ZGVlYjg0OQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-08-29T06:16:02Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-08-29T06:16:02Z"}, "message": "Makefile.in (OBJS-common): Add tree-ssa-propagate.o\n\n\n\t* Makefile.in (OBJS-common): Add tree-ssa-propagate.o\n\t(tree-ssa-propagate.o): New rule.\n\t(GTFILES): Add tree-ssa-propagate.c.\n\t* tree-flow.h (struct stmt_ann_d): Remove field\n\tin_ccp_worklist.\n\t* tree-ssa-propagate.c: New file.\n\t* tree-ssa-propagate.h: New file.\n\t* tree-ssa-ccp.c: Re-write to use the routines from\n\ttree-ssa-propagate.c.\n\nFrom-SVN: r86711", "tree": {"sha": "7614a76a2ddfc4ba7fe4532833225adde4aeb47d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7614a76a2ddfc4ba7fe4532833225adde4aeb47d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/750628d8bcdda3394d81f0b16d0703bb7deeb849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750628d8bcdda3394d81f0b16d0703bb7deeb849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/750628d8bcdda3394d81f0b16d0703bb7deeb849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750628d8bcdda3394d81f0b16d0703bb7deeb849/comments", "author": null, "committer": null, "parents": [{"sha": "f108270b88db1ada07dbc81727577b97b312bcb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f108270b88db1ada07dbc81727577b97b312bcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f108270b88db1ada07dbc81727577b97b312bcb3"}], "stats": {"total": 3135, "additions": 1686, "deletions": 1449}, "files": [{"sha": "10cd7d05ac7c16863e2842f989ae1018feed5562", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -1,3 +1,15 @@\n+2004-08-29  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Makefile.in (OBJS-common): Add tree-ssa-propagate.o\n+\t(tree-ssa-propagate.o): New rule.\n+\t(GTFILES): Add tree-ssa-propagate.c.\n+\t* tree-flow.h (struct stmt_ann_d): Remove field\n+\tin_ccp_worklist.\n+\t* tree-ssa-propagate.c: New file.\n+\t* tree-ssa-propagate.h: New file.\n+\t* tree-ssa-ccp.c: Re-write to use the routines from\n+\ttree-ssa-propagate.c.\n+\n 2004-08-28  Andrew Pinski  <apinski@apple.com>\n \n \t* tree-ssa-loop.c: Remove extra include of basic-block.h."}, {"sha": "093b597cc0f540e503c90212dbc25e9e31e4429f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -890,7 +890,7 @@ OBJS-common = \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n- tree-vectorizer.o tree-ssa-loop-ivcanon.o\t\t\t \t   \\\n+ tree-vectorizer.o tree-ssa-loop-ivcanon.o tree-ssa-propagate.o\t \t   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1628,6 +1628,11 @@ tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(BASIC_BLOCK_H) tree-pass.h langhooks.h\n+tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n+   diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n+   tree-ssa-propagate.h\n tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -1923,10 +1928,11 @@ lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) system.h errors.h $(TREE_H) \\\n     $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) diagnostic.h $(TIMEVAR_H) $(TM_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H)\n-tree-ssa-ccp.o : tree-ssa-ccp.c $(CONFIG_H) system.h errors.h $(TREE_H) \\\n-    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) diagnostic.h tree-inline.h \\\n-    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n-    $(EXPR_H) tree-pass.h $(FLAGS_H) langhooks.h\n+tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n+   diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n+   tree-ssa-propagate.h\n tree-sra.o : tree-sra.c $(CONFIG_H) system.h errors.h $(TREE_H) $(RTL_H) \\\n     $(TM_P_H) $(TREE_FLOW_H) diagnostic.h tree-inline.h \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n@@ -2393,7 +2399,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parse.in \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c \\\n   $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n-  $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-ccp.c \\\n+  $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n   $(srcdir)/tree-alias-type.h $(srcdir)/tree-alias-common.h \\\n   $(srcdir)/tree-alias-type.c $(srcdir)/tree-alias-common.c \\"}, {"sha": "a82c90b609e4290e855e59447d54f6afc452d0cd", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -248,11 +248,6 @@ struct stmt_ann_d GTY(())\n      need to be scanned again).  */\n   unsigned modified : 1;\n \n-  /* Nonzero if the statement is in the CCP worklist and has not been\n-     \"cancelled\".  If we ever need to use this bit outside CCP, then\n-     it should be renamed.  */\n-  unsigned in_ccp_worklist: 1;\n-\n   /* Nonzero if the statement makes aliased loads.  */\n   unsigned makes_aliased_loads : 1;\n "}, {"sha": "70a2dadd02371f9481a4971ed33cd2a5b300dafa", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 926, "deletions": 1438, "changes": 2364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -37,26 +37,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"errors.h\"\n-#include \"ggc.h\"\n #include \"tree.h\"\n-#include \"langhooks.h\"\n-\n-/* These RTL headers are needed for basic-block.h.  */\n+#include \"flags.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n+#include \"ggc.h\"\n #include \"basic-block.h\"\n-\n+#include \"output.h\"\n+#include \"errors.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n #include \"diagnostic.h\"\n-#include \"tree-inline.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-gimple.h\"\n+#include \"timevar.h\"\n #include \"tree-dump.h\"\n+#include \"tree-flow.h\"\n #include \"tree-pass.h\"\n-#include \"timevar.h\"\n-#include \"expr.h\"\n-#include \"flags.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"langhooks.h\"\n \n \n /* Possible lattice values.  */\n@@ -69,10 +66,6 @@ typedef enum\n   VARYING\n } latticevalue;\n \n-/* Use the TREE_VISITED bitflag to mark statements and PHI nodes that have\n-   been deemed VARYING and shouldn't be simulated again.  */\n-#define DONT_SIMULATE_AGAIN(T)\tTREE_VISITED (T)\n-\n /* Main structure for CCP.  Contains the lattice value and, if it's a\n     constant, the constant value.  */\n typedef struct\n@@ -81,178 +74,112 @@ typedef struct\n   tree const_val;\n } value;\n \n-/* A bitmap to keep track of executable blocks in the CFG.  */\n-static sbitmap executable_blocks;\n-\n-/* Array of control flow edges on the worklist.  */\n-static GTY(()) varray_type cfg_blocks = NULL;\n-\n-static unsigned int cfg_blocks_num = 0;\n-static int cfg_blocks_tail;\n-static int cfg_blocks_head;\n-\n-static sbitmap bb_in_list;\n-\n /* This is used to track the current value of each variable.  */\n static value *value_vector;\n \n-/* Worklist of SSA edges which will need reexamination as their definition\n-   has changed.  SSA edges are def-use edges in the SSA web.  For each\n-   edge, we store the definition statement or PHI node D.  The destination\n-   nodes that need to be visited are accessed using immediate_uses\n-   (D).  */\n-static GTY(()) varray_type ssa_edges;\n-\n-/* Identical to SSA_EDGES.  For performance reasons, the list of SSA\n-   edges is split into two.  One contains all SSA edges who need to be\n-   reexamined because their lattice value changed to varying (this\n-   worklist), and the other contains all other SSA edges to be\n-   reexamined (ssa_edges).\n-   \n-   Since most values in the program are varying, the ideal situation\n-   is to move them to that lattice value as quickly as possible.\n-   Thus, it doesn't make sense to process any other type of lattice\n-   value until all varying values are propagated fully, which is one\n-   thing using the varying worklist achieves.  In addition, if you\n-   don't use a separate worklist for varying edges, you end up with\n-   situations where lattice values move from\n-   undefined->constant->varying instead of undefined->varying.\n-*/\n-static GTY(()) varray_type varying_ssa_edges;\n-\n-\n-static void initialize (void);\n-static void finalize (void);\n-static void visit_phi_node (tree);\n-static tree ccp_fold (tree);\n-static value cp_lattice_meet (value, value);\n-static void visit_stmt (tree);\n-static void visit_cond_stmt (tree);\n-static void visit_assignment (tree);\n-static void add_var_to_ssa_edges_worklist (tree, value);\n-static void add_outgoing_control_edges (basic_block);\n-static void add_control_edge (edge);\n-static void def_to_varying (tree);\n-static void set_lattice_value (tree, value);\n-static void simulate_block (basic_block);\n-static void simulate_stmt (tree);\n-static void substitute_and_fold (void);\n-static value evaluate_stmt (tree);\n-static void dump_lattice_value (FILE *, const char *, value);\n-static bool replace_uses_in (tree, bool *);\n-static bool replace_vuse_in (tree, bool *);\n-static latticevalue likely_value (tree);\n-static tree get_rhs (tree);\n-static bool set_rhs (tree *, tree);\n-static value *get_value (tree);\n-static value get_default_value (tree);\n-static tree ccp_fold_builtin (tree, tree);\n-static bool get_strlen (tree, tree *, bitmap);\n-static inline bool cfg_blocks_empty_p (void);\n-static void cfg_blocks_add (basic_block);\n-static basic_block cfg_blocks_get (void);\n-static bool need_imm_uses_for (tree var);\n-\n-/* Process an SSA edge worklist.  WORKLIST is the SSA edge worklist to\n-   drain. This pops statements off the given WORKLIST and processes\n-   them until there are no more statements on WORKLIST.  */\n+\n+/* Dump lattice value VAL to file OUTF prefixed by PREFIX.  */\n \n static void\n-process_ssa_edge_worklist (varray_type *worklist)\n+dump_lattice_value (FILE *outf, const char *prefix, value val)\n {\n-  /* Drain the entire worklist.  */\n-  while (VARRAY_ACTIVE_SIZE (*worklist) > 0)\n+  switch (val.lattice_val)\n     {\n-      /* Pull the statement to simulate off the worklist.  */\n-      tree stmt = VARRAY_TOP_TREE (*worklist);\n-      stmt_ann_t ann = stmt_ann (stmt);\n-      VARRAY_POP (*worklist);\n-      \n-      /* visit_stmt can \"cancel\" reevaluation of some statements.\n-\t If it does, then in_ccp_worklist will be zero.  */\n-      if (ann->in_ccp_worklist)\n-\t{\n-\t  ann->in_ccp_worklist = 0;\n-\t  simulate_stmt (stmt);\n-\t}\n-    } \n+    case UNDEFINED:\n+      fprintf (outf, \"%sUNDEFINED\", prefix);\n+      break;\n+    case VARYING:\n+      fprintf (outf, \"%sVARYING\", prefix);\n+      break;\n+    case UNKNOWN_VAL:\n+      fprintf (outf, \"%sUNKNOWN_VAL\", prefix);\n+      break;\n+    case CONSTANT:\n+      fprintf (outf, \"%sCONSTANT \", prefix);\n+      print_generic_expr (outf, val.const_val, dump_flags);\n+      break;\n+    default:\n+      abort ();\n+    }\n }\n- \n-/* Main entry point for SSA Conditional Constant Propagation.  FNDECL is\n-   the declaration for the function to optimize.\n-   \n-   On exit, VARS_TO_RENAME will contain the symbols that have been exposed by\n-   the propagation of ADDR_EXPR expressions into pointer dereferences and need\n-   to be renamed into SSA.\n \n-   PHASE indicates which dump file from the DUMP_FILES array to use when\n-   dumping debugging information.  */\n \n-static void\n-tree_ssa_ccp (void)\n-{\n-  initialize ();\n+/* Return a default value for variable VAR using the following rules:\n \n-  /* Iterate until the worklists are empty.  */\n-  while (!cfg_blocks_empty_p () \n-\t || VARRAY_ACTIVE_SIZE (ssa_edges) > 0\n-\t || VARRAY_ACTIVE_SIZE (varying_ssa_edges) > 0)\n-    {\n-      if (!cfg_blocks_empty_p ())\n-\t{\n-\t  /* Pull the next block to simulate off the worklist.  */\n-\t  basic_block dest_block = cfg_blocks_get ();\n-\t  simulate_block (dest_block);\n-\t}\n+   1- Function arguments are considered VARYING.\n+   \n+   2- Global and static variables that are declared constant are\n+      considered CONSTANT.\n \n-      /* In order to move things to varying as quickly as\n-         possible,process the VARYING_SSA_EDGES worklist first.  */\n-      process_ssa_edge_worklist (&varying_ssa_edges);\n+   3- Any other virtually defined variable is considered UNKNOWN_VAL.\n \n-      /* Now process the SSA_EDGES worklist.  */\n-      process_ssa_edge_worklist (&ssa_edges);\n-    }\n+   4- Any other value is considered UNDEFINED.  This is useful when\n+      considering PHI nodes.  PHI arguments that are undefined do not\n+      change the constant value of the PHI node, which allows for more\n+      constants to be propagated.  */\n \n-  /* Now perform substitutions based on the known constant values.  */\n-  substitute_and_fold ();\n+static value\n+get_default_value (tree var)\n+{\n+  value val;\n+  tree sym;\n \n-  /* Now cleanup any unreachable code.  */\n-  cleanup_tree_cfg ();\n+  if (TREE_CODE (var) == SSA_NAME)\n+    sym = SSA_NAME_VAR (var);\n+  else\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (!DECL_P (var))\n+\tabort ();\n+#endif\n+      sym = var;\n+    }\n \n-  /* Free allocated memory.  */\n-  finalize ();\n+  val.lattice_val = UNDEFINED;\n+  val.const_val = NULL_TREE;\n \n-  /* Debugging dumps.  */\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n     {\n-      dump_referenced_vars (dump_file);\n-      fprintf (dump_file, \"\\n\\n\");\n+      /* Function arguments and volatile variables are considered VARYING.  */\n+      val.lattice_val = VARYING;\n     }\n-}\n+  else if (TREE_STATIC (sym))\n+    {\n+      /* Globals and static variables are considered UNKNOWN_VAL,\n+         unless they are declared 'const'.  */\n+      if (TREE_READONLY (sym)\n+\t  && DECL_INITIAL (sym)\n+\t  && is_gimple_min_invariant (DECL_INITIAL (sym)))\n+\t{\n+\t  val.lattice_val = CONSTANT;\n+\t  val.const_val = DECL_INITIAL (sym);\n+\t}\n+      else\n+        {\n+          val.const_val = NULL_TREE;\n+\t  val.lattice_val = UNKNOWN_VAL;\n+\t}\n+    }\n+  else if (!is_gimple_reg (sym))\n+    {\n+      val.const_val = NULL_TREE;\n+      val.lattice_val = UNKNOWN_VAL;\n+    }\n+  else\n+    {\n+      enum tree_code code;\n+      tree stmt = SSA_NAME_DEF_STMT (var);\n \n-static bool\n-gate_ccp (void)\n-{\n-  return flag_tree_ccp != 0;\n-}\n+      if (!IS_EMPTY_STMT (stmt))\n+        {\n+\t  code = TREE_CODE (stmt);\n+\t  if (code != MODIFY_EXPR && code != PHI_NODE)\n+\t    val.lattice_val = VARYING;\n+\t}\n+    }\n \n-struct tree_opt_pass pass_ccp = \n-{\n-  \"ccp\",\t\t\t\t/* name */\n-  gate_ccp,\t\t\t\t/* gate */\n-  tree_ssa_ccp,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CCP,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\n-    | TODO_ggc_collect | TODO_verify_ssa\n-    | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n-};\n+  return val;\n+}\n \n \n /* Get the constant value associated with variable VAR.  */\n@@ -275,602 +202,597 @@ get_value (tree var)\n }\n \n \n-/* Simulate the execution of BLOCK.  Evaluate the statement associated\n-   with each variable reference inside the block.  */\n+/* Set the lattice value for variable VAR to VAL.  Return true if VAL\n+   is different from VAR's previous value.  */\n \n-static void\n-simulate_block (basic_block block)\n+static bool\n+set_lattice_value (tree var, value val)\n {\n-  tree phi;\n-\n-  /* There is nothing to do for the exit block.  */\n-  if (block == EXIT_BLOCK_PTR)\n-    return;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nSimulating block %d\\n\", block->index);\n-\n-  /* Always simulate PHI nodes, even if we have simulated this block\n-     before.  */\n-  for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n-    visit_phi_node (phi);\n+  value *old = get_value (var);\n \n-  /* If this is the first time we've simulated this block, then we\n-     must simulate each of its statements.  */\n-  if (!TEST_BIT (executable_blocks, block->index))\n+#ifdef ENABLE_CHECKING\n+  if (val.lattice_val == UNDEFINED)\n     {\n-      block_stmt_iterator j;\n-      unsigned int normal_edge_count;\n-      edge e, normal_edge;\n-\n-      /* Note that we have simulated this block.  */\n-      SET_BIT (executable_blocks, block->index);\n-\n-      for (j = bsi_start (block); !bsi_end_p (j); bsi_next (&j))\n-\tvisit_stmt (bsi_stmt (j));\n-\n-      /* We can not predict when abnormal edges will be executed, so\n-\t once a block is considered executable, we consider any\n-\t outgoing abnormal edges as executable.\n-\n-\t At the same time, if this block has only one successor that is\n-\t reached by non-abnormal edges, then add that successor to the\n-\t worklist.  */\n-      normal_edge_count = 0;\n-      normal_edge = NULL;\n-      for (e = block->succ; e; e = e->succ_next)\n-        {\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    {\n-\t      add_control_edge (e);\n-\t    }\n-\t  else\n-\t    {\n-\t      normal_edge_count++;\n-\t      normal_edge = e;\n-\t    }\n-        }\n+      /* CONSTANT->UNDEFINED is never a valid state transition.  */\n+      if (old->lattice_val == CONSTANT)\n+\tabort ();\n+\t\n+      /* UNKNOWN_VAL->UNDEFINED is never a valid state transition.  */\n+      if (old->lattice_val == UNKNOWN_VAL)\n+\tabort ();\n \n-        if (normal_edge_count == 1)\n-\t  add_control_edge (normal_edge);\n+      /* VARYING->UNDEFINED is generally not a valid state transition,\n+\t except for values which are initialized to VARYING.  */\n+      if (old->lattice_val == VARYING\n+\t  && get_default_value (var).lattice_val != VARYING)\n+\tabort ();\n     }\n-}\n-\n-\n-/* Follow the def-use edges for statement DEF_STMT and simulate all the\n-   statements reached by it.  */\n-\n-static void\n-simulate_stmt (tree use_stmt)\n-{\n-  basic_block use_bb = bb_for_stmt (use_stmt);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  else if (val.lattice_val == CONSTANT)\n     {\n-      fprintf (dump_file, \"\\nSimulating statement (from ssa_edges): \");\n-      print_generic_stmt (dump_file, use_stmt, dump_flags);\n+      /* VARYING -> CONSTANT is an invalid state transition, except\n+\t for objects which start off in a VARYING state.  */\n+      if (old->lattice_val == VARYING\n+\t  && get_default_value (var).lattice_val != VARYING)\n+\tabort ();\n     }\n+#endif\n \n-  if (TREE_CODE (use_stmt) == PHI_NODE)\n+  /* If the constant for VAR has changed, then this VAR is really varying.  */\n+  if (old->lattice_val == CONSTANT\n+      && val.lattice_val == CONSTANT\n+      && !simple_cst_equal (old->const_val, val.const_val))\n     {\n-      /* PHI nodes are always visited, regardless of whether or not the\n-         destination block is executable.  */\n-      visit_phi_node (use_stmt);\n+      val.lattice_val = VARYING;\n+      val.const_val = NULL_TREE;\n     }\n-  else if (TEST_BIT (executable_blocks, use_bb->index))\n+\n+  if (old->lattice_val != val.lattice_val)\n     {\n-      /* Otherwise, visit the statement containing the use reached by\n-         DEF, only if the destination block is marked executable.  */\n-      visit_stmt (use_stmt);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  dump_lattice_value (dump_file, \"Lattice value changed to \", val);\n+\t  fprintf (dump_file, \".  Adding definition to SSA edges.\\n\");\n+\t}\n+\n+      *old = val;\n+      return true;\n     }\n+\n+  return false;\n }\n \n \n-/* Perform final substitution and folding.  After this pass the program\n-   should still be in SSA form.  */\n+/* Set the lattice value for the variable VAR to VARYING.  */\n \n static void\n-substitute_and_fold (void)\n+def_to_varying (tree var)\n {\n-  basic_block bb;\n+  value val;\n+  val.lattice_val = VARYING;\n+  val.const_val = NULL_TREE;\n+  set_lattice_value (var, val);\n+}\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file,\n-\t     \"\\nSubstituing constants and folding statements\\n\\n\");\n \n-  /* Substitute constants in every statement of every basic block.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator i;\n-      tree phi;\n+/* Return the likely latticevalue for STMT.\n \n-      /* Propagate our known constants into PHI nodes.  */\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  int i;\n+   If STMT has no operands, then return CONSTANT.\n \n-\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      value *new_val;\n-\t      use_operand_p orig_p = PHI_ARG_DEF_PTR (phi, i);\n-\t      tree orig = USE_FROM_PTR (orig_p);\n+   Else if any operands of STMT are undefined, then return UNDEFINED.\n \n-\t      if (! SSA_VAR_P (orig))\n-\t\tbreak;\n+   Else if any operands of STMT are constants, then return CONSTANT.\n \n-\t      new_val = get_value (orig);\n-\t      if (new_val->lattice_val == CONSTANT\n-\t\t  && may_propagate_copy (orig, new_val->const_val))\n-\t\tSET_USE (orig_p, new_val->const_val);\n-\t    }\n-\t}\n+   Else return VARYING.  */\n \n-      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n-\t{\n-          bool replaced_address;\n-\t  tree stmt = bsi_stmt (i);\n+static latticevalue\n+likely_value (tree stmt)\n+{\n+  vuse_optype vuses;\n+  int found_constant = 0;\n+  stmt_ann_t ann;\n+  tree use;\n+  ssa_op_iter iter;\n \n-\t  /* Skip statements that have been folded already.  */\n-\t  if (stmt_modified_p (stmt) || !is_exec_stmt (stmt))\n-\t    continue;\n+  /* If the statement makes aliased loads or has volatile operands, it\n+     won't fold to a constant value.  */\n+  ann = stmt_ann (stmt);\n+  if (ann->makes_aliased_loads || ann->has_volatile_ops)\n+    return VARYING;\n \n-\t  /* Replace the statement with its folded version and mark it\n-\t     folded.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Line %d: replaced \", get_lineno (stmt));\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-\t    }\n+  /* A CALL_EXPR is assumed to be varying.  This may be overly conservative,\n+     in the presence of const and pure calls.  */\n+  if (get_call_expr_in (stmt) != NULL_TREE)\n+    return VARYING;\n \n-\t  if (replace_uses_in (stmt, &replaced_address)\n-\t      || replace_vuse_in (stmt, &replaced_address))\n-\t    {\n-\t      bool changed = fold_stmt (bsi_stmt_ptr (i));\n-\t      stmt = bsi_stmt(i);\n-\t      /* If we folded a builtin function, we'll likely\n-\t\t need to rename VDEFs.  */\n-\t      if (replaced_address || changed)\n-\t\t{\n-\t\t  mark_new_vars_to_rename (stmt, vars_to_rename);\n-\t\t  if (maybe_clean_eh_stmt (stmt))\n-\t\t    tree_purge_dead_eh_edges (bb);\n-\t\t}\n-\t      else\n-\t\tmodify_stmt (stmt);\n-\t    }\n+  get_stmt_operands (stmt);\n \n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+    {\n+      value *val = get_value (use);\n+\n+      if (val->lattice_val == UNDEFINED)\n+\treturn UNDEFINED;\n+\n+      if (val->lattice_val == CONSTANT)\n+\tfound_constant = 1;\n+    }\n+    \n+  vuses = VUSE_OPS (ann);\n+  \n+  if (NUM_VUSES (vuses))\n+    {\n+      tree vuse = VUSE_OP (vuses, 0);\n+      value *val = get_value (vuse);\n+      \n+      if (val->lattice_val == UNKNOWN_VAL)\n+        return UNKNOWN_VAL;\n+\t\n+#ifdef ENABLE_CHECKING\n+  /* There should be no VUSE operands that are UNDEFINED. */\n+  if (val->lattice_val == UNDEFINED)\n+    abort ();\n+#endif\n+\t\n+      if (val->lattice_val == CONSTANT)\n+\tfound_constant = 1;\n     }\n+\n+  return ((found_constant || (!USE_OPS (ann) && !vuses)) ? CONSTANT : VARYING);\n }\n \n \n-/* Loop through the PHI_NODE's parameters for BLOCK and compare their\n-   lattice values to determine PHI_NODE's lattice value.  The value of a\n-   PHI node is determined calling cp_lattice_meet() with all the arguments\n-   of the PHI node that are incoming via executable edges.  */\n+/* Function indicating whether we ought to include information for VAR\n+   when calculating immediate uses.  */\n+\n+static bool\n+need_imm_uses_for (tree var)\n+{\n+  return get_value (var)->lattice_val != VARYING;\n+}\n+\n+\n+/* Initialize local data structures for CCP.  */\n \n static void\n-visit_phi_node (tree phi)\n+ccp_initialize (void)\n {\n-  bool short_circuit = 0;\n-  value phi_val, *curr_val;\n-  int i;\n+  basic_block bb;\n+  sbitmap is_may_def;\n \n-  /* If the PHI node has already been deemed to be VARYING, don't simulate\n-     it again.  */\n-  if (DONT_SIMULATE_AGAIN (phi))\n-    return;\n+  value_vector = (value *) xmalloc (num_ssa_names * sizeof (value));\n+  memset (value_vector, 0, num_ssa_names * sizeof (value));\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nVisiting PHI node: \");\n-      print_generic_expr (dump_file, phi, dump_flags);\n-    }\n+  /* Set of SSA_NAMEs that are defined by a V_MAY_DEF.  */\n+  is_may_def = sbitmap_alloc (num_ssa_names);\n+  sbitmap_zero (is_may_def);\n \n-  curr_val = get_value (PHI_RESULT (phi));\n-  switch (curr_val->lattice_val)\n+  /* Initialize simulation flags for PHI nodes and statements.  */\n+  FOR_EACH_BB (bb)\n     {\n-    case VARYING:\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"\\n   Shortcircuit. Default of VARYING.\");\n-      short_circuit = 1;\n-      break;\n+      block_stmt_iterator i;\n \n-    case CONSTANT:\n-      phi_val = *curr_val;\n-      break;\n+      /* Mark all V_MAY_DEF operands VARYING.  */\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+        {\n+\t  bool is_varying = false;\n+\t  tree stmt = bsi_stmt (i);\n+\t  ssa_op_iter iter;\n+\t  tree def;\n \n-    case UNKNOWN_VAL:\n-      /* To avoid the default value of UNKNOWN_VAL overriding\n-         that of its possible constant arguments, temporarily\n-\t set the phi node's default lattice value to be \n-\t UNDEFINED. At the same time, place something other\n-\t than NULL_TREE in phi_val.const_val as a flag to\n-\t check when setting a new state for this phi node to\n-\t ensure that we avoid incorrect state transitions from\n-\t UNKNOWN_VAL to UNDEFINED. */\n-      phi_val.lattice_val = UNDEFINED;\n-      phi_val.const_val = phi;\n-      break;\n+\t  get_stmt_operands (stmt);\n \n-    case UNDEFINED:\n-    case UNINITIALIZED:\n-      phi_val.lattice_val = UNDEFINED;\n-      phi_val.const_val = NULL_TREE;\n-      break;\n+\t  /* Get the default value for each DEF and V_MUST_DEF.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, \n+\t\t\t\t     (SSA_OP_DEF | SSA_OP_VMUSTDEF))\n+\t    {\n+\t      if (get_value (def)->lattice_val == VARYING)\n+\t\tis_varying = true;\n+\t    }\n \n-    default:\n-      abort ();\n+\t  /* Mark all V_MAY_DEF operands VARYING.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n+\t    {\n+\t      get_value (def)->lattice_val = VARYING;\n+\t      SET_BIT (is_may_def, SSA_NAME_VERSION (def));\n+\t    }\n+\n+\t  /* Statements other than MODIFY_EXPR, COND_EXPR and\n+\t     SWITCH_EXPR are not interesting for constant propagation.\n+\t     Mark them VARYING.  */\n+\t  if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t      && TREE_CODE (stmt) != COND_EXPR\n+\t      && TREE_CODE (stmt) != SWITCH_EXPR)\n+\t    is_varying = true;\n+\n+\t  DONT_SIMULATE_AGAIN (stmt) = is_varying;\n+\t}\n     }\n \n-  /* If the variable is volatile or the variable is never referenced in a\n-     real operand, then consider the PHI node VARYING.  */\n-  if (short_circuit || TREE_THIS_VOLATILE (SSA_NAME_VAR (PHI_RESULT (phi))))\n+  /* Now process PHI nodes.  */\n+  FOR_EACH_BB (bb)\n     {\n-      phi_val.lattice_val = VARYING;\n-      phi_val.const_val = NULL;\n+      tree phi, var;\n+      int x;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  value *val = get_value (PHI_RESULT (phi));\n+\n+\t  for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n+\t    {\n+\t      var = PHI_ARG_DEF (phi, x);\n+\n+\t      /* If one argument has a V_MAY_DEF, the result is\n+\t\t VARYING.  */\n+\t      if (TREE_CODE (var) == SSA_NAME)\n+\t\t{\n+\t\t  if (TEST_BIT (is_may_def, SSA_NAME_VERSION (var)))\n+\t\t    {\n+\t\t      val->lattice_val = VARYING;\n+\t\t      SET_BIT (is_may_def, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  DONT_SIMULATE_AGAIN (phi) = (val->lattice_val == VARYING);\n+\t}\n     }\n-  else\n-    for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-      {\n-\t/* Compute the meet operator over all the PHI arguments.  */\n-\tedge e = PHI_ARG_EDGE (phi, i);\n \n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  {\n-\t    fprintf (dump_file,\n-\t\t     \"\\n    Argument #%d (%d -> %d %sexecutable)\\n\",\n-\t\t     i, e->src->index, e->dest->index,\n-\t\t     (e->flags & EDGE_EXECUTABLE) ? \"\" : \"not \");\n-\t  }\n+  sbitmap_free (is_may_def);\n \n-\t/* If the incoming edge is executable, Compute the meet operator for\n-\t   the existing value of the PHI node and the current PHI argument.  */\n-\tif (e->flags & EDGE_EXECUTABLE)\n-\t  {\n-\t    tree rdef = PHI_ARG_DEF (phi, i);\n-\t    value *rdef_val, val;\n+  /* Compute immediate uses for variables we care about.  */\n+  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, need_imm_uses_for);\n+}\n \n-\t    if (is_gimple_min_invariant (rdef))\n-\t      {\n-\t\tval.lattice_val = CONSTANT;\n-\t\tval.const_val = rdef;\n-\t\trdef_val = &val;\n-\t      }\n-\t    else\n-\t      rdef_val = get_value (rdef);\n \n-\t    phi_val = cp_lattice_meet (phi_val, *rdef_val);\n+/* Replace USE references in statement STMT with their immediate reaching\n+   definition.  Return true if at least one reference was replaced.  If\n+   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n+   constant was replaced.  */\n \n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      {\n-\t\tfprintf (dump_file, \"\\t\");\n-\t\tprint_generic_expr (dump_file, rdef, dump_flags);\n-\t\tdump_lattice_value (dump_file, \"\\tValue: \", *rdef_val);\n-\t\tfprintf (dump_file, \"\\n\");\n-\t      }\n+static bool\n+replace_uses_in (tree stmt, bool *replaced_addresses_p)\n+{\n+  bool replaced = false;\n+  use_operand_p use;\n+  ssa_op_iter iter;\n \n-\t    if (phi_val.lattice_val == VARYING)\n-\t      break;\n-\t  }\n-      }\n+  if (replaced_addresses_p)\n+    *replaced_addresses_p = false;\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      dump_lattice_value (dump_file, \"\\n    PHI node value: \", phi_val);\n-      fprintf (dump_file, \"\\n\\n\");\n-    }\n+  get_stmt_operands (stmt);\n \n-  /* Check for an invalid change from UNKNOWN_VAL to UNDEFINED. */\n-  if (phi_val.lattice_val != UNDEFINED || phi_val.const_val == NULL_TREE)\n+  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      set_lattice_value (PHI_RESULT (phi), phi_val);\n-      if (phi_val.lattice_val == VARYING)\n-        DONT_SIMULATE_AGAIN (phi) = 1;\n+      value *val = get_value (USE_FROM_PTR (use));\n+\n+      if (val->lattice_val == CONSTANT)\n+\t{\n+\t  SET_USE (use, val->const_val);\n+\t  replaced = true;\n+\t  if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (use))) \n+\t      && replaced_addresses_p)\n+\t    *replaced_addresses_p = true;\n+\t}\n     }\n+\n+  return replaced;\n }\n \n \n-/* Compute the meet operator between VAL1 and VAL2:\n+/* Replace the VUSE references in statement STMT with its immediate reaching\n+   definition.  Return true if the reference was replaced.  If\n+   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n+   constant was replaced.  */\n \n-   \t\tany  M UNDEFINED     = any\n-\t\tany  M VARYING       = VARYING\n-\t\tany  M UNKNOWN_VAL   = UNKNOWN_VAL\n-\t\tCi   M Cj\t     = Ci\tif (i == j)\n-\t\tCi   M Cj\t     = VARYING\tif (i != j)  */\n-static value\n-cp_lattice_meet (value val1, value val2)\n+static bool\n+replace_vuse_in (tree stmt, bool *replaced_addresses_p)\n {\n-  value result;\n+  bool replaced = false;\n+  vuse_optype vuses;\n+  use_operand_p vuse;\n+  value *val;\n \n-  /* any M UNDEFINED = any.  */\n-  if (val1.lattice_val == UNDEFINED)\n-    return val2;\n-  else if (val2.lattice_val == UNDEFINED)\n-    return val1;\n+  if (replaced_addresses_p)\n+    *replaced_addresses_p = false;\n \n-  /* any M VARYING = VARYING.  */\n-  if (val1.lattice_val == VARYING || val2.lattice_val == VARYING)\n-    {\n-      result.lattice_val = VARYING;\n-      result.const_val = NULL_TREE;\n-      return result;\n-    }\n+  get_stmt_operands (stmt);\n \n-  /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n-  if (val1.lattice_val == UNKNOWN_VAL \n-      || val2.lattice_val == UNKNOWN_VAL)\n-    {\n-      result.lattice_val = UNKNOWN_VAL;\n-      result.const_val = NULL_TREE;\n-      return result;\n-    }\n+  vuses = STMT_VUSE_OPS (stmt);\n \n-  /* Ci M Cj = Ci\tif (i == j)\n-     Ci M Cj = VARYING\tif (i != j)  */\n-  if (simple_cst_equal (val1.const_val, val2.const_val) == 1)\n-    {\n-      result.lattice_val = CONSTANT;\n-      result.const_val = val1.const_val;\n-    }\n-  else\n+  if (NUM_VUSES (vuses) != 1)\n+    return false;\n+\n+  vuse = VUSE_OP_PTR (vuses, 0);\n+  val = get_value (USE_FROM_PTR (vuse));\n+\n+  if (val->lattice_val == CONSTANT\n+      && TREE_CODE (stmt) == MODIFY_EXPR\n+      && DECL_P (TREE_OPERAND (stmt, 1))\n+      && TREE_OPERAND (stmt, 1) == SSA_NAME_VAR (USE_FROM_PTR (vuse)))\n     {\n-      result.lattice_val = VARYING;\n-      result.const_val = NULL_TREE;\n+      TREE_OPERAND (stmt, 1) = val->const_val;\n+      replaced = true;\n+      if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (vuse))) \n+          && replaced_addresses_p)\n+        *replaced_addresses_p = true;\n     }\n \n-  return result;\n+  return replaced;\n }\n \n \n-/* Evaluate statement STMT.  If the statement produces an output value and\n-   its evaluation changes the lattice value of its output, do the following:\n-\n-   - If the statement is an assignment, add all the SSA edges starting at\n-     this definition.\n-\n-   - If the statement is a conditional branch:\n-   \t. If the statement evaluates to non-constant, add all edges to\n-\t  worklist.\n-\t. If the statement is constant, add the edge executed as the\n-\t  result of the branch.  */\n+/* Perform final substitution and folding.  After this pass the program\n+   should still be in SSA form.  */\n \n static void\n-visit_stmt (tree stmt)\n+substitute_and_fold (void)\n {\n-  stmt_ann_t ann;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  tree def;\n-  ssa_op_iter iter;\n-\n-  /* If the statement has already been deemed to be VARYING, don't simulate\n-     it again.  */\n-  if (DONT_SIMULATE_AGAIN (stmt))\n-    return;\n+  basic_block bb;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"\\nSubstituing constants and folding statements\\n\\n\");\n+\n+  /* Substitute constants in every statement of every basic block.  */\n+  FOR_EACH_BB (bb)\n     {\n-      fprintf (dump_file, \"\\nVisiting statement: \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+      block_stmt_iterator i;\n+      tree phi;\n \n-  ann = stmt_ann (stmt);\n+      /* Propagate our known constants into PHI nodes.  */\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  int i;\n \n-  /* If this statement is already in the worklist then \"cancel\" it.  The\n-     reevaluation implied by the worklist entry will produce the same\n-     value we generate here and thus reevaluating it again from the\n-     worklist is pointless.  */\n-  if (ann->in_ccp_worklist)\n-    ann->in_ccp_worklist = 0;\n+\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+\t    {\n+\t      value *new_val;\n+\t      use_operand_p orig_p = PHI_ARG_DEF_PTR (phi, i);\n+\t      tree orig = USE_FROM_PTR (orig_p);\n \n-  /* Now examine the statement.  If the statement is an assignment that\n-     produces a single output value, evaluate its RHS to see if the lattice\n-     value of its output has changed.  */\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && NUM_V_MAY_DEFS (v_may_defs) == 0\n-      && (NUM_V_MUST_DEFS (v_must_defs) == 1\n-          || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n-    visit_assignment (stmt);\n+\t      if (! SSA_VAR_P (orig))\n+\t\tbreak;\n \n-  /* Definitions made by statements other than assignments to SSA_NAMEs\n-     represent unknown modifications to their outputs.  Mark them VARYING.  */\n-  else if (NUM_DEFS (DEF_OPS (ann)) != 0)\n-    {\n-      DONT_SIMULATE_AGAIN (stmt) = 1;\n-      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-\t{\n-\t  def_to_varying (def);\n+\t      new_val = get_value (orig);\n+\t      if (new_val->lattice_val == CONSTANT\n+\t\t  && may_propagate_copy (orig, new_val->const_val))\n+\t\tSET_USE (orig_p, new_val->const_val);\n+\t    }\n \t}\n-    }\n \n-  /* If STMT is a conditional branch, see if we can determine which branch\n-     will be taken.  */\n-  else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n-    visit_cond_stmt (stmt);\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+          bool replaced_address;\n+\t  tree stmt = bsi_stmt (i);\n \n-  /* Any other kind of statement is not interesting for constant\n-     propagation and, therefore, not worth simulating.  */\n-  else\n-    {\n-      DONT_SIMULATE_AGAIN (stmt) = 1;\n+\t  /* Skip statements that have been folded already.  */\n+\t  if (stmt_modified_p (stmt) || !is_exec_stmt (stmt))\n+\t    continue;\n \n-      /* If STMT is a computed goto, then mark all the output edges\n-\t executable.  */\n-      if (computed_goto_p (stmt))\n-\tadd_outgoing_control_edges (bb_for_stmt (stmt));\n-    }\n+\t  /* Replace the statement with its folded version and mark it\n+\t     folded.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Line %d: replaced \", get_lineno (stmt));\n+\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t    }\n \n-  /* Mark all V_MAY_DEF operands VARYING.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n-    def_to_varying (def);\n-    \n+\t  if (replace_uses_in (stmt, &replaced_address)\n+\t      || replace_vuse_in (stmt, &replaced_address))\n+\t    {\n+\t      bool changed = fold_stmt (bsi_stmt_ptr (i));\n+\t      stmt = bsi_stmt(i);\n+\t      /* If we folded a builtin function, we'll likely\n+\t\t need to rename VDEFs.  */\n+\t      if (replaced_address || changed)\n+\t\t{\n+\t\t  mark_new_vars_to_rename (stmt, vars_to_rename);\n+\t\t  if (maybe_clean_eh_stmt (stmt))\n+\t\t    tree_purge_dead_eh_edges (bb);\n+\t\t}\n+\t      else\n+\t\tmodify_stmt (stmt);\n+\t    }\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \" with \");\n+\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n }\n \n \n-/* Visit the assignment statement STMT.  Set the value of its LHS to the\n-   value computed by the RHS.  */\n+/* Free allocated storage.  */\n \n static void\n-visit_assignment (tree stmt)\n+ccp_finalize (void)\n {\n-  value val;\n-  tree lhs, rhs;\n-  vuse_optype vuses;\n-  v_must_def_optype v_must_defs;\n+  /* Perform substitutions based on the known constant values.  */\n+  substitute_and_fold ();\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n-  vuses = STMT_VUSE_OPS (stmt);\n-  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+  /* Now cleanup any unreachable code.  */\n+  cleanup_tree_cfg ();\n \n-#if defined ENABLE_CHECKING\n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n-      || (NUM_V_MUST_DEFS (v_must_defs) != 1\n-          && TREE_CODE (lhs) != SSA_NAME))\n-    abort ();\n-#endif\n+  free (value_vector);\n+}\n \n-  /* We require the SSA version number of the lhs for the value_vector.\n-     Make sure we have it.  */\n-  if (TREE_CODE (lhs) != SSA_NAME)\n-    {\n-      /* If we make it here, then stmt only has one definition:\n-         a V_MUST_DEF.  */\n-      lhs = V_MUST_DEF_OP (v_must_defs, 0);\n-    }\n \n-  if (TREE_CODE (rhs) == SSA_NAME)\n-    {\n-      /* For a simple copy operation, we copy the lattice values.  */\n-      value *nval = get_value (rhs);\n-      val = *nval;\n-    }\n-  else if (DECL_P (rhs) \n-           && NUM_VUSES (vuses) == 1\n-           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n-    {\n-      /* Same as above, but the rhs is not a gimple register and yet\n-        has a known VUSE.  */\n-      value *nval = get_value (VUSE_OP (vuses, 0));\n-      val = *nval;\n-    }\n-  else\n+\n+/* Compute the meet operator between VAL1 and VAL2:\n+\n+   \t\tany  M UNDEFINED     = any\n+\t\tany  M VARYING       = VARYING\n+\t\tany  M UNKNOWN_VAL   = UNKNOWN_VAL\n+\t\tCi   M Cj\t     = Ci\tif (i == j)\n+\t\tCi   M Cj\t     = VARYING\tif (i != j)  */\n+static value\n+ccp_lattice_meet (value val1, value val2)\n+{\n+  value result;\n+\n+  /* any M UNDEFINED = any.  */\n+  if (val1.lattice_val == UNDEFINED)\n+    return val2;\n+  else if (val2.lattice_val == UNDEFINED)\n+    return val1;\n+\n+  /* any M VARYING = VARYING.  */\n+  if (val1.lattice_val == VARYING || val2.lattice_val == VARYING)\n     {\n-      /* Evaluate the statement.  */\n-      val = evaluate_stmt (stmt);\n+      result.lattice_val = VARYING;\n+      result.const_val = NULL_TREE;\n+      return result;\n     }\n \n-  /* FIXME: Hack.  If this was a definition of a bitfield, we need to widen\n-     the constant value into the type of the destination variable.  This\n-     should not be necessary if GCC represented bitfields properly.  */\n-  {\n-    tree lhs = TREE_OPERAND (stmt, 0);\n-    if (val.lattice_val == CONSTANT\n-\t&& TREE_CODE (lhs) == COMPONENT_REF\n-\t&& DECL_BIT_FIELD (TREE_OPERAND (lhs, 1)))\n-      {\n-\ttree w = widen_bitfield (val.const_val, TREE_OPERAND (lhs, 1), lhs);\n-\n-\tif (w && is_gimple_min_invariant (w))\n-\t  val.const_val = w;\n-\telse\n-\t  {\n-\t    val.lattice_val = VARYING;\n-\t    val.const_val = NULL;\n-\t  }\n-      }\n-  }\n+  /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n+  if (val1.lattice_val == UNKNOWN_VAL \n+      || val2.lattice_val == UNKNOWN_VAL)\n+    {\n+      result.lattice_val = UNKNOWN_VAL;\n+      result.const_val = NULL_TREE;\n+      return result;\n+    }\n \n-  /* If LHS is not a gimple register, then it cannot take on an\n-     UNDEFINED value. */\n-  if (!is_gimple_reg (SSA_NAME_VAR (lhs)) \n-      && val.lattice_val == UNDEFINED)\n-    val.lattice_val = UNKNOWN_VAL;      \n+  /* Ci M Cj = Ci\tif (i == j)\n+     Ci M Cj = VARYING\tif (i != j)  */\n+  if (simple_cst_equal (val1.const_val, val2.const_val) == 1)\n+    {\n+      result.lattice_val = CONSTANT;\n+      result.const_val = val1.const_val;\n+    }\n+  else\n+    {\n+      result.lattice_val = VARYING;\n+      result.const_val = NULL_TREE;\n+    }\n \n-  /* Set the lattice value of the statement's output.  */\n-  set_lattice_value (lhs, val);\n-  if (val.lattice_val == VARYING)\n-    DONT_SIMULATE_AGAIN (stmt) = 1;\n+  return result;\n }\n \n \n-/* Visit the conditional statement STMT.  If it evaluates to a constant value,\n-   mark outgoing edges appropriately.  */\n+/* Loop through the PHI_NODE's parameters for BLOCK and compare their\n+   lattice values to determine PHI_NODE's lattice value.  The value of a\n+   PHI node is determined calling ccp_lattice_meet() with all the arguments\n+   of the PHI node that are incoming via executable edges.  */\n \n-static void\n-visit_cond_stmt (tree stmt)\n+static enum ssa_prop_result\n+ccp_visit_phi_node (tree phi)\n {\n-  edge e;\n-  value val;\n-  basic_block block;\n-\n-  block = bb_for_stmt (stmt);\n-  val = evaluate_stmt (stmt);\n+  value new_val, *old_val;\n+  int i;\n \n-  /* Find which edge out of the conditional block will be taken and add it\n-     to the worklist.  If no single edge can be determined statically, add\n-     all outgoing edges from BLOCK.  */\n-  e = find_taken_edge (block, val.const_val);\n-  if (e)\n-    add_control_edge (e);\n-  else\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      DONT_SIMULATE_AGAIN (stmt) = 1;\n-      add_outgoing_control_edges (block);\n+      fprintf (dump_file, \"\\nVisiting PHI node: \");\n+      print_generic_expr (dump_file, phi, dump_flags);\n     }\n-}\n \n+  old_val = get_value (PHI_RESULT (phi));\n+  switch (old_val->lattice_val)\n+    {\n+    case VARYING:\n+      return SSA_PROP_NOT_INTERESTING;\n \n-/* Add all the edges coming out of BB to the control flow worklist.  */\n+    case CONSTANT:\n+      new_val = *old_val;\n+      break;\n \n-static void\n-add_outgoing_control_edges (basic_block bb)\n-{\n-  edge e;\n+    case UNKNOWN_VAL:\n+      /* To avoid the default value of UNKNOWN_VAL overriding\n+         that of its possible constant arguments, temporarily\n+\t set the PHI node's default lattice value to be \n+\t UNDEFINED.  If the PHI node's old value was UNKNOWN_VAL and\n+\t the new value is UNDEFINED, then we prevent the invalid\n+\t transition by not calling set_lattice_value.  */\n+      new_val.lattice_val = UNDEFINED;\n+      new_val.const_val = NULL_TREE;\n+      break;\n \n-  for (e = bb->succ; e; e = e->succ_next)\n-    add_control_edge (e);\n-}\n+    case UNDEFINED:\n+    case UNINITIALIZED:\n+      new_val.lattice_val = UNDEFINED;\n+      new_val.const_val = NULL_TREE;\n+      break;\n \n+    default:\n+      abort ();\n+    }\n \n-/* Add edge E to the control flow worklist.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      /* Compute the meet operator over all the PHI arguments.  */\n+      edge e = PHI_ARG_EDGE (phi, i);\n \n-static void\n-add_control_edge (edge e)\n-{\n-  basic_block bb = e->dest;\n-  if (bb == EXIT_BLOCK_PTR)\n-    return;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file,\n+\t      \"\\n    Argument #%d (%d -> %d %sexecutable)\\n\",\n+\t      i, e->src->index, e->dest->index,\n+\t      (e->flags & EDGE_EXECUTABLE) ? \"\" : \"not \");\n+\t}\n+\n+      /* If the incoming edge is executable, Compute the meet operator for\n+\t the existing value of the PHI node and the current PHI argument.  */\n+      if (e->flags & EDGE_EXECUTABLE)\n+\t{\n+\t  tree rdef = PHI_ARG_DEF (phi, i);\n+\t  value *rdef_val, val;\n \n-  /* If the edge had already been executed, skip it.  */\n-  if (e->flags & EDGE_EXECUTABLE)\n-      return;\n+\t  if (is_gimple_min_invariant (rdef))\n+\t    {\n+\t      val.lattice_val = CONSTANT;\n+\t      val.const_val = rdef;\n+\t      rdef_val = &val;\n+\t    }\n+\t  else\n+\t    rdef_val = get_value (rdef);\n \n-  e->flags |= EDGE_EXECUTABLE;\n+\t  new_val = ccp_lattice_meet (new_val, *rdef_val);\n \n-  /* If the block is already in the list, we're done.  */\n-  if (TEST_BIT (bb_in_list, bb->index))\n-    return;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\t\");\n+\t      print_generic_expr (dump_file, rdef, dump_flags);\n+\t      dump_lattice_value (dump_file, \"\\tValue: \", *rdef_val);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \n-  cfg_blocks_add (bb);\n+\t  if (new_val.lattice_val == VARYING)\n+\t    break;\n+\t}\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Adding Destination of edge (%d -> %d) to worklist\\n\\n\",\n-\t     e->src->index, e->dest->index);\n+    {\n+      dump_lattice_value (dump_file, \"\\n    PHI node value: \", new_val);\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  /* Check for an invalid change from UNKNOWN_VAL to UNDEFINED. */\n+  if (old_val->lattice_val == UNKNOWN_VAL\n+      && new_val.lattice_val == UNDEFINED)\n+    return SSA_PROP_NOT_INTERESTING;\n+\n+  /* Otherwise, make the transition to the new value.  */\n+  if (set_lattice_value (PHI_RESULT (phi), new_val))\n+    {\n+      if (new_val.lattice_val == VARYING)\n+\treturn SSA_PROP_VARYING;\n+      else\n+\treturn SSA_PROP_INTERESTING;\n+    }\n+  else\n+    return SSA_PROP_NOT_INTERESTING;\n }\n \n \n-/* CCP specific front-end to the non-destructive constant folding routines.\n+/* CCP specific front-end to the non-destructive constant folding\n+   routines.\n \n    Attempt to simplify the RHS of STMT knowing that one or more\n    operands are constants.\n@@ -1069,547 +991,304 @@ evaluate_stmt (tree stmt)\n          had undefined or virtual operands, then the result of the \n \t statement should be undefined or virtual respectively.  \n \t Else the result of the statement is VARYING.  */\n-      val.lattice_val = (likelyvalue == UNDEFINED ? UNDEFINED : VARYING);\n-      val.lattice_val = (likelyvalue == UNKNOWN_VAL \n-                           ? UNKNOWN_VAL : val.lattice_val);\n-      val.const_val = NULL_TREE;\n-    }\n-\n-  return val;\n-}\n-\n-\n-/* Debugging dumps.  */\n-\n-static void\n-dump_lattice_value (FILE *outf, const char *prefix, value val)\n-{\n-  switch (val.lattice_val)\n-    {\n-    case UNDEFINED:\n-      fprintf (outf, \"%sUNDEFINED\", prefix);\n-      break;\n-    case VARYING:\n-      fprintf (outf, \"%sVARYING\", prefix);\n-      break;\n-    case UNKNOWN_VAL:\n-      fprintf (outf, \"%sUNKNOWN_VAL\", prefix);\n-      break;\n-    case CONSTANT:\n-      fprintf (outf, \"%sCONSTANT \", prefix);\n-      print_generic_expr (outf, val.const_val, dump_flags);\n-      break;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Given a constant value VAL for bitfield FIELD, and a destination\n-   variable VAR, return VAL appropriately widened to fit into VAR.  If\n-   FIELD is wider than HOST_WIDE_INT, NULL is returned.  */\n-\n-tree\n-widen_bitfield (tree val, tree field, tree var)\n-{\n-  unsigned HOST_WIDE_INT var_size, field_size;\n-  tree wide_val;\n-  unsigned HOST_WIDE_INT mask;\n-  unsigned int i;\n-\n-  /* We can only do this if the size of the type and field and VAL are\n-     all constants representable in HOST_WIDE_INT.  */\n-  if (!host_integerp (TYPE_SIZE (TREE_TYPE (var)), 1)\n-      || !host_integerp (DECL_SIZE (field), 1)\n-      || !host_integerp (val, 0))\n-    return NULL_TREE;\n-\n-  var_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (var)), 1);\n-  field_size = tree_low_cst (DECL_SIZE (field), 1);\n-\n-  /* Give up if either the bitfield or the variable are too wide.  */\n-  if (field_size > HOST_BITS_PER_WIDE_INT || var_size > HOST_BITS_PER_WIDE_INT)\n-    return NULL_TREE;\n-\n-#if defined ENABLE_CHECKING\n-  if (var_size < field_size)\n-    abort ();\n-#endif\n-\n-  /* If the sign bit of the value is not set or the field's type is unsigned,\n-     just mask off the high order bits of the value.  */\n-  if (DECL_UNSIGNED (field)\n-      || !(tree_low_cst (val, 0) & (((HOST_WIDE_INT)1) << (field_size - 1))))\n-    {\n-      /* Zero extension.  Build a mask with the lower 'field_size' bits\n-\t set and a BIT_AND_EXPR node to clear the high order bits of\n-\t the value.  */\n-      for (i = 0, mask = 0; i < field_size; i++)\n-\tmask |= ((HOST_WIDE_INT) 1) << i;\n-\n-      wide_val = build (BIT_AND_EXPR, TREE_TYPE (var), val, \n-\t\t\tfold_convert (TREE_TYPE (var),\n-\t\t\t\t      build_int_cst (NULL_TREE, mask)));\n-    }\n-  else\n-    {\n-      /* Sign extension.  Create a mask with the upper 'field_size'\n-\t bits set and a BIT_IOR_EXPR to set the high order bits of the\n-\t value.  */\n-      for (i = 0, mask = 0; i < (var_size - field_size); i++)\n-\tmask |= ((HOST_WIDE_INT) 1) << (var_size - i - 1);\n-\n-      wide_val = build (BIT_IOR_EXPR, TREE_TYPE (var), val,\n-\t\t\tfold_convert (TREE_TYPE (var),\n-\t\t\t\t      build_int_cst (NULL_TREE, mask)));\n-    }\n-\n-  return fold (wide_val);\n-}\n-\n-\n-/* Function indicating whether we ought to include information for 'var'\n-   when calculating immediate uses.  */\n-\n-static bool\n-need_imm_uses_for (tree var)\n-{\n-  return get_value (var)->lattice_val != VARYING;\n-}\n-\n-\n-/* Initialize local data structures and worklists for CCP.  */\n-\n-static void\n-initialize (void)\n-{\n-  edge e;\n-  basic_block bb;\n-  sbitmap virtual_var;\n-  tree def;\n-  ssa_op_iter iter;\n-\n-  /* Worklists of SSA edges.  */\n-  VARRAY_TREE_INIT (ssa_edges, 20, \"ssa_edges\");\n-  VARRAY_TREE_INIT (varying_ssa_edges, 20, \"varying_ssa_edges\");\n-\n-  executable_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (executable_blocks);\n-\n-  bb_in_list = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (bb_in_list);\n-\n-  value_vector = (value *) xmalloc (num_ssa_names * sizeof (value));\n-  memset (value_vector, 0, num_ssa_names * sizeof (value));\n-\n-  /* 1 if ssa variable is used in a virtual variable context.  */\n-  virtual_var = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (virtual_var);\n-\n-  /* Initialize default values and simulation flags for PHI nodes, statements \n-     and edges.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator i;\n-      tree stmt;\n-      int vary;\n-\n-      /* Get the default value for each definition.  */\n-      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n-        {\n-\t  vary = 0;\n-\t  stmt = bsi_stmt (i);\n-\t  get_stmt_operands (stmt);\n-\n-\t  /* Get the default value for each DEF and V_MUST_DEF.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, \n-\t\t\t\t     (SSA_OP_DEF | SSA_OP_VMUSTDEF))\n-\t    {\n-\t      if (get_value (def)->lattice_val == VARYING)\n-\t\tvary = 1;\n-\t    }\n-\t  \n-\t  DONT_SIMULATE_AGAIN (stmt) = vary;\n-\n-\t  /* Mark all V_MAY_DEF operands VARYING.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n-\t    {\n-\t      get_value (def)->lattice_val = VARYING;\n-\t      SET_BIT (virtual_var, SSA_NAME_VERSION (def));\n-\t    }\n-\t}\n-\n-      for (e = bb->succ; e; e = e->succ_next)\n-\te->flags &= ~EDGE_EXECUTABLE;\n-    }\n-\n-  /* Now process PHI nodes.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi, var;\n-      int x;\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-        {\n-\t  value *val;\n-\t  val = get_value (PHI_RESULT (phi));\n-\t  if (val->lattice_val != VARYING)\n-\t    {\n-\t      for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n-\t        {\n-\t\t  var = PHI_ARG_DEF (phi, x);\n-\t\t  /* If one argument has a V_MAY_DEF, \n-\t\t     the result is varying.  */\n-\t\t  if (TREE_CODE (var) == SSA_NAME)\n-\t\t    {\n-\t\t      if (TEST_BIT (virtual_var, SSA_NAME_VERSION (var)))\n-\t\t        {\n-\t\t\t  val->lattice_val = VARYING;\n-\t\t\t  SET_BIT (virtual_var, \n-\t\t\t\t   SSA_NAME_VERSION (PHI_RESULT (phi)));\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t}\n-\t    }\n-\t  DONT_SIMULATE_AGAIN (phi) = ((val->lattice_val == VARYING) ? 1 : 0);\n-\t}\n-    }\n-\n-  sbitmap_free (virtual_var);\n-  /* Compute immediate uses for variables we care about.  */\n-  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, need_imm_uses_for);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_immediate_uses (dump_file);\n-\n-  VARRAY_BB_INIT (cfg_blocks, 20, \"cfg_blocks\");\n-\n-  /* Seed the algorithm by adding the successors of the entry block to the\n-     edge worklist.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    {\n-      if (e->dest != EXIT_BLOCK_PTR)\n-        {\n-\t  e->flags |= EDGE_EXECUTABLE;\n-\t  cfg_blocks_add (e->dest);\n-\t}\n+      val.lattice_val = (likelyvalue == UNDEFINED ? UNDEFINED : VARYING);\n+      val.lattice_val = (likelyvalue == UNKNOWN_VAL \n+                           ? UNKNOWN_VAL : val.lattice_val);\n+      val.const_val = NULL_TREE;\n     }\n+\n+  return val;\n }\n \n \n-/* Free allocated storage.  */\n+/* Visit the assignment statement STMT.  Set the value of its LHS to the\n+   value computed by the RHS and store LHS in *OUTPUT_P.  */\n \n-static void\n-finalize (void)\n+static enum ssa_prop_result\n+visit_assignment (tree stmt, tree *output_p)\n {\n-  ssa_edges = NULL;\n-  varying_ssa_edges = NULL;\n-  cfg_blocks = NULL;\n-  free (value_vector);\n-  sbitmap_free (bb_in_list);\n-  sbitmap_free (executable_blocks);\n-  free_df ();\n-}\n-\n-/* Is the block worklist empty.  */\n+  value val;\n+  tree lhs, rhs;\n+  vuse_optype vuses;\n+  v_must_def_optype v_must_defs;\n \n-static inline bool\n-cfg_blocks_empty_p (void)\n-{\n-  return (cfg_blocks_num == 0);\n-}\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+  vuses = STMT_VUSE_OPS (stmt);\n+  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n \n-/* Add a basic block to the worklist.  */\n+#if defined ENABLE_CHECKING\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n+      || (NUM_V_MUST_DEFS (v_must_defs) != 1\n+          && TREE_CODE (lhs) != SSA_NAME))\n+    abort ();\n+#endif\n \n-static void \n-cfg_blocks_add (basic_block bb)\n-{\n-   if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n-     return;\n+  /* We require the SSA version number of the lhs for the value_vector.\n+     Make sure we have it.  */\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    {\n+      /* If we make it here, then stmt only has one definition:\n+         a V_MUST_DEF.  */\n+      lhs = V_MUST_DEF_OP (v_must_defs, 0);\n+    }\n \n-   if (TEST_BIT (bb_in_list, bb->index))\n-     return;\n+  if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      /* For a simple copy operation, we copy the lattice values.  */\n+      value *nval = get_value (rhs);\n+      val = *nval;\n+    }\n+  else if (DECL_P (rhs) \n+           && NUM_VUSES (vuses) == 1\n+           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n+    {\n+      /* Same as above, but the rhs is not a gimple register and yet\n+        has a known VUSE.  */\n+      value *nval = get_value (VUSE_OP (vuses, 0));\n+      val = *nval;\n+    }\n+  else\n+    {\n+      /* Evaluate the statement.  */\n+      val = evaluate_stmt (stmt);\n+    }\n \n-    if (cfg_blocks_empty_p ())\n-      {\n-\tcfg_blocks_tail = cfg_blocks_head = 0;\n-\tcfg_blocks_num = 1;\n-      }\n-    else\n+  /* FIXME: Hack.  If this was a definition of a bitfield, we need to widen\n+     the constant value into the type of the destination variable.  This\n+     should not be necessary if GCC represented bitfields properly.  */\n+  {\n+    tree lhs = TREE_OPERAND (stmt, 0);\n+    if (val.lattice_val == CONSTANT\n+\t&& TREE_CODE (lhs) == COMPONENT_REF\n+\t&& DECL_BIT_FIELD (TREE_OPERAND (lhs, 1)))\n       {\n-\tcfg_blocks_num++;\n-\tif (cfg_blocks_num > VARRAY_SIZE (cfg_blocks))\n+\ttree w = widen_bitfield (val.const_val, TREE_OPERAND (lhs, 1), lhs);\n+\n+\tif (w && is_gimple_min_invariant (w))\n+\t  val.const_val = w;\n+\telse\n \t  {\n-\t    /* We have to grow the array now.  Adjust to queue to occupy the\n-\t       full space of the original array.  */\n-\t    cfg_blocks_tail = VARRAY_SIZE (cfg_blocks);\n-\t    cfg_blocks_head = 0;\n-\t    VARRAY_GROW (cfg_blocks, 2 * VARRAY_SIZE (cfg_blocks));\n+\t    val.lattice_val = VARYING;\n+\t    val.const_val = NULL;\n \t  }\n-\telse\n-\t  cfg_blocks_tail = (cfg_blocks_tail + 1) % VARRAY_SIZE (cfg_blocks);\n       }\n-    VARRAY_BB (cfg_blocks, cfg_blocks_tail) = bb;\n-    SET_BIT (bb_in_list, bb->index);\n-}\n-\n-/* Remove a block from the worklist.  */\n-\n-static basic_block\n-cfg_blocks_get (void)\n-{\n-  basic_block bb;\n-\n-  bb = VARRAY_BB (cfg_blocks, cfg_blocks_head);\n-\n-#ifdef ENABLE_CHECKING\n-  if (cfg_blocks_empty_p () || !bb)\n-    abort ();\n-#endif\n-\n-  cfg_blocks_head = (cfg_blocks_head + 1) % VARRAY_SIZE (cfg_blocks);\n-  --cfg_blocks_num;\n-  RESET_BIT (bb_in_list, bb->index);\n-\n-  return bb;\n-}\n+  }\n \n-/* We have just defined a new value for VAR.  Add all immediate uses\n-   of VAR to the ssa_edges or varying_ssa_edges worklist.  */\n-static void\n-add_var_to_ssa_edges_worklist (tree var, value val)\n-{\n-  tree stmt = SSA_NAME_DEF_STMT (var);\n-  dataflow_t df = get_immediate_uses (stmt);\n-  int num_uses = num_immediate_uses (df);\n-  int i;\n+  /* If LHS is not a gimple register, then it cannot take on an\n+     UNDEFINED value. */\n+  if (!is_gimple_reg (SSA_NAME_VAR (lhs)) \n+      && val.lattice_val == UNDEFINED)\n+    val.lattice_val = UNKNOWN_VAL;      \n \n-  for (i = 0; i < num_uses; i++)\n+  /* Set the lattice value of the statement's output.  */\n+  if (set_lattice_value (lhs, val))\n     {\n-      tree use = immediate_use (df, i);\n-\n-      if (!DONT_SIMULATE_AGAIN (use))\n-\t{\n-\t  stmt_ann_t ann = stmt_ann (use);\n-\t  if (ann->in_ccp_worklist == 0)\n-\t    {\n-\t      ann->in_ccp_worklist = 1;\n-\t      if (val.lattice_val == VARYING)\n-\t\tVARRAY_PUSH_TREE (varying_ssa_edges, use);\n-\t      else\n-\t\tVARRAY_PUSH_TREE (ssa_edges, use);\n-\t    }\n-\t}\n+      *output_p = lhs;\n+      if (val.lattice_val == VARYING)\n+\treturn SSA_PROP_VARYING;\n+      else\n+\treturn SSA_PROP_INTERESTING;\n     }\n+  else\n+    return SSA_PROP_NOT_INTERESTING;\n }\n \n-/* Set the lattice value for the variable VAR to VARYING.  */\n \n-static void\n-def_to_varying (tree var)\n+/* Visit the conditional statement STMT.  Return SSA_PROP_INTERESTING\n+   if it can determine which edge will be taken.  Otherwise, return\n+   SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+visit_cond_stmt (tree stmt, edge *taken_edge_p)\n {\n   value val;\n-  val.lattice_val = VARYING;\n-  val.const_val = NULL_TREE;\n-  set_lattice_value (var, val);\n+  basic_block block;\n+\n+  block = bb_for_stmt (stmt);\n+  val = evaluate_stmt (stmt);\n+\n+  /* Find which edge out of the conditional block will be taken and add it\n+     to the worklist.  If no single edge can be determined statically,\n+     return SSA_PROP_VARYING to feed all the outgoing edges to the\n+     propagation engine.  */\n+  *taken_edge_p = find_taken_edge (block, val.const_val);\n+  if (*taken_edge_p)\n+    return SSA_PROP_INTERESTING;\n+  else\n+    return SSA_PROP_VARYING;\n }\n \n-/* Set the lattice value for variable VAR to VAL.  */\n \n-static void\n-set_lattice_value (tree var, value val)\n-{\n-  value *old = get_value (var);\n+/* Evaluate statement STMT.  If the statement produces an output value and\n+   its evaluation changes the lattice value of its output, return\n+   SSA_PROP_INTERESTING and set *OUTPUT_P to the SSA_NAME holding the\n+   output value.\n+   \n+   If STMT is a conditional branch and we can determine its truth\n+   value, set *TAKEN_EDGE_P accordingly.  If STMT produces a varying\n+   value, return SSA_PROP_VARYING.  */\n \n-#ifdef ENABLE_CHECKING\n-  if (val.lattice_val == UNDEFINED)\n-    {\n-      /* CONSTANT->UNDEFINED is never a valid state transition.  */\n-      if (old->lattice_val == CONSTANT)\n-\tabort ();\n-\t\n-      /* UNKNOWN_VAL->UNDEFINED is never a valid state transition.  */\n-      if (old->lattice_val == UNKNOWN_VAL)\n-\tabort ();\n+static enum ssa_prop_result\n+ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n+{\n+  stmt_ann_t ann;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  tree def;\n+  ssa_op_iter iter;\n \n-      /* VARYING->UNDEFINED is generally not a valid state transition,\n-\t except for values which are initialized to VARYING.  */\n-      if (old->lattice_val == VARYING\n-\t  && get_default_value (var).lattice_val != VARYING)\n-\tabort ();\n-    }\n-  else if (val.lattice_val == CONSTANT)\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      /* VARYING -> CONSTANT is an invalid state transition, except\n-\t for objects which start off in a VARYING state.  */\n-      if (old->lattice_val == VARYING\n-\t  && get_default_value (var).lattice_val != VARYING)\n-\tabort ();\n+      fprintf (dump_file, \"\\nVisiting statement: \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n     }\n-#endif\n \n-  /* If the constant for VAR has changed, then this VAR is really varying.  */\n-  if (old->lattice_val == CONSTANT && val.lattice_val == CONSTANT\n-      && !simple_cst_equal (old->const_val, val.const_val))\n+  ann = stmt_ann (stmt);\n+\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  if (TREE_CODE (stmt) == MODIFY_EXPR\n+      && NUM_V_MAY_DEFS (v_may_defs) == 0\n+      && (NUM_V_MUST_DEFS (v_must_defs) == 1\n+          || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n     {\n-      val.lattice_val = VARYING;\n-      val.const_val = NULL_TREE;\n+      /* If the statement is an assignment that produces a single\n+\t output value, evaluate its RHS to see if the lattice value of\n+\t its output has changed.  */\n+      return visit_assignment (stmt, output_p);\n     }\n-\n-  if (old->lattice_val != val.lattice_val)\n+  else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  dump_lattice_value (dump_file,\n-\t\t\t      \"Lattice value changed to \", val);\n-\t  fprintf (dump_file, \".  Adding definition to SSA edges.\\n\");\n-\t}\n-\n-      add_var_to_ssa_edges_worklist (var, val);\n-      *old = val;\n+      /* If STMT is a conditional branch, see if we can determine\n+\t which branch will be taken.  */\n+      return visit_cond_stmt (stmt, taken_edge_p);\n     }\n-}\n \n-/* Replace USE references in statement STMT with their immediate reaching\n-   definition.  Return true if at least one reference was replaced.  If\n-   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n-   constant was replaced.  */\n+  /* Any other kind of statement is not interesting for constant\n+     propagation and, therefore, not worth simulating.  */\n+#if 0\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"No interesting values produced.  Marked VARYING.\\n\");\n+#endif\n \n-static bool\n-replace_uses_in (tree stmt, bool *replaced_addresses_p)\n-{\n-  bool replaced = false;\n-  use_operand_p use;\n-  ssa_op_iter iter;\n+  /* Definitions made by statements other than assignments to\n+     SSA_NAMEs represent unknown modifications to their outputs.\n+     Mark them VARYING.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+    def_to_varying (def);\n \n-  if (replaced_addresses_p)\n-    *replaced_addresses_p = false;\n+  /* Mark all V_MAY_DEF operands VARYING.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n+    def_to_varying (def);\n \n-  get_stmt_operands (stmt);\n+  return SSA_PROP_VARYING;\n+}\n \n-  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-    {\n-      value *val = get_value (USE_FROM_PTR (use));\n \n-      if (val->lattice_val == CONSTANT)\n-\t{\n-\t  SET_USE (use, val->const_val);\n-\t  replaced = true;\n-\t  if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (use))) \n-\t      && replaced_addresses_p)\n-\t    *replaced_addresses_p = true;\n-\t}\n-    }\n+/* Main entry point for SSA Conditional Constant Propagation.\n \n-  return replaced;\n+   [ DESCRIBE MAIN ALGORITHM HERE ]  */\n+\n+static void\n+execute_ssa_ccp (void)\n+{\n+  ccp_initialize ();\n+  ssa_propagate (ccp_visit_stmt, ccp_visit_phi_node);\n+  ccp_finalize ();\n }\n \n-/* Replace the VUSE references in statement STMT with its immediate reaching\n-   definition.  Return true if the reference was replaced.  If\n-   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n-   constant was replaced.  */\n \n static bool\n-replace_vuse_in (tree stmt, bool *replaced_addresses_p)\n+gate_ccp (void)\n {\n-  bool replaced = false;\n-  vuse_optype vuses;\n-  use_operand_p vuse;\n-  value *val;\n-\n-  if (replaced_addresses_p)\n-    *replaced_addresses_p = false;\n-\n-  get_stmt_operands (stmt);\n-\n-  vuses = STMT_VUSE_OPS (stmt);\n-\n-  if (NUM_VUSES (vuses) != 1)\n-    return false;\n-\n-  vuse = VUSE_OP_PTR (vuses, 0);\n-  val = get_value (USE_FROM_PTR (vuse));\n-\n-  if (val->lattice_val == CONSTANT\n-      && TREE_CODE (stmt) == MODIFY_EXPR\n-      && DECL_P (TREE_OPERAND (stmt, 1))\n-      && TREE_OPERAND (stmt, 1) == SSA_NAME_VAR (USE_FROM_PTR (vuse)))\n-    {\n-      TREE_OPERAND (stmt, 1) = val->const_val;\n-      replaced = true;\n-      if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (vuse))) \n-          && replaced_addresses_p)\n-        *replaced_addresses_p = true;\n-    }\n-\n-  return replaced;\n+  return flag_tree_ccp != 0;\n }\n \n-/* Return the likely latticevalue for STMT.\n-\n-   If STMT has no operands, then return CONSTANT.\n \n-   Else if any operands of STMT are undefined, then return UNDEFINED.\n+struct tree_opt_pass pass_ccp = \n+{\n+  \"ccp\",\t\t\t\t/* name */\n+  gate_ccp,\t\t\t\t/* gate */\n+  execute_ssa_ccp,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_CCP,\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_rename_vars\n+    | TODO_ggc_collect | TODO_verify_ssa\n+    | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n+};\n \n-   Else if any operands of STMT are constants, then return CONSTANT.\n \n-   Else return VARYING.  */\n+/* Given a constant value VAL for bitfield FIELD, and a destination\n+   variable VAR, return VAL appropriately widened to fit into VAR.  If\n+   FIELD is wider than HOST_WIDE_INT, NULL is returned.  */\n \n-static latticevalue\n-likely_value (tree stmt)\n+tree\n+widen_bitfield (tree val, tree field, tree var)\n {\n-  vuse_optype vuses;\n-  int found_constant = 0;\n-  stmt_ann_t ann;\n-  tree use;\n-  ssa_op_iter iter;\n+  unsigned HOST_WIDE_INT var_size, field_size;\n+  tree wide_val;\n+  unsigned HOST_WIDE_INT mask;\n+  unsigned int i;\n \n-  /* If the statement makes aliased loads or has volatile operands, it\n-     won't fold to a constant value.  */\n-  ann = stmt_ann (stmt);\n-  if (ann->makes_aliased_loads || ann->has_volatile_ops)\n-    return VARYING;\n+  /* We can only do this if the size of the type and field and VAL are\n+     all constants representable in HOST_WIDE_INT.  */\n+  if (!host_integerp (TYPE_SIZE (TREE_TYPE (var)), 1)\n+      || !host_integerp (DECL_SIZE (field), 1)\n+      || !host_integerp (val, 0))\n+    return NULL_TREE;\n \n-  /* A CALL_EXPR is assumed to be varying.  This may be overly conservative,\n-     in the presence of const and pure calls.  */\n-  if (get_call_expr_in (stmt) != NULL_TREE)\n-    return VARYING;\n+  var_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (var)), 1);\n+  field_size = tree_low_cst (DECL_SIZE (field), 1);\n \n-  get_stmt_operands (stmt);\n+  /* Give up if either the bitfield or the variable are too wide.  */\n+  if (field_size > HOST_BITS_PER_WIDE_INT || var_size > HOST_BITS_PER_WIDE_INT)\n+    return NULL_TREE;\n \n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-    {\n-      value *val = get_value (use);\n+#if defined ENABLE_CHECKING\n+  if (var_size < field_size)\n+    abort ();\n+#endif\n \n-      if (val->lattice_val == UNDEFINED)\n-\treturn UNDEFINED;\n+  /* If the sign bit of the value is not set or the field's type is unsigned,\n+     just mask off the high order bits of the value.  */\n+  if (DECL_UNSIGNED (field)\n+      || !(tree_low_cst (val, 0) & (((HOST_WIDE_INT)1) << (field_size - 1))))\n+    {\n+      /* Zero extension.  Build a mask with the lower 'field_size' bits\n+\t set and a BIT_AND_EXPR node to clear the high order bits of\n+\t the value.  */\n+      for (i = 0, mask = 0; i < field_size; i++)\n+\tmask |= ((HOST_WIDE_INT) 1) << i;\n \n-      if (val->lattice_val == CONSTANT)\n-\tfound_constant = 1;\n+      wide_val = build (BIT_AND_EXPR, TREE_TYPE (var), val, \n+\t\t\tfold_convert (TREE_TYPE (var),\n+\t\t\t\t      build_int_cst (NULL_TREE, mask)));\n     }\n-    \n-  vuses = VUSE_OPS (ann);\n-  \n-  if (NUM_VUSES (vuses))\n+  else\n     {\n-      tree vuse = VUSE_OP (vuses, 0);\n-      value *val = get_value (vuse);\n-      \n-      if (val->lattice_val == UNKNOWN_VAL)\n-        return UNKNOWN_VAL;\n-\t\n-#ifdef ENABLE_CHECKING\n-  /* There should be no VUSE operands that are UNDEFINED. */\n-  if (val->lattice_val == UNDEFINED)\n-    abort ();\n-#endif\n-\t\n-      if (val->lattice_val == CONSTANT)\n-\tfound_constant = 1;\n+      /* Sign extension.  Create a mask with the upper 'field_size'\n+\t bits set and a BIT_IOR_EXPR to set the high order bits of the\n+\t value.  */\n+      for (i = 0, mask = 0; i < (var_size - field_size); i++)\n+\tmask |= ((HOST_WIDE_INT) 1) << (var_size - i - 1);\n+\n+      wide_val = build (BIT_IOR_EXPR, TREE_TYPE (var), val,\n+\t\t\tfold_convert (TREE_TYPE (var),\n+\t\t\t\t      build_int_cst (NULL_TREE, mask)));\n     }\n \n-  return ((found_constant || (!USE_OPS (ann) && !vuses)) ? CONSTANT : VARYING);\n+  return fold (wide_val);\n }\n \n+\n /* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n    is the desired result type.  */\n@@ -1704,6 +1383,7 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n \t\t\t  / (TYPE_ALIGN (elt_type) / BITS_PER_UNIT)));\n }\n \n+\n /* A subroutine of fold_stmt_r.  Attempts to fold *(S+O) to S.X.\n    BASE is a record type.  OFFSET is a byte displacement.  ORIG_TYPE\n    is the desired result type.  */\n@@ -1813,6 +1493,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \t\t\t\t\t     orig_type, false);\n }\n \n+\n /* A subroutine of fold_stmt_r.  Attempt to simplify *(BASE+OFFSET).\n    Return the simplified expression, or NULL if nothing could be done.  */\n \n@@ -1914,6 +1595,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n   return NULL_TREE;\n }\n \n+\n /* A subroutine of fold_stmt_r.  EXPR is a PLUS_EXPR.\n \n    A quaint feature extant in our address arithmetic is that there\n@@ -2031,6 +1713,7 @@ maybe_fold_stmt_addition (tree expr)\n   return t;\n }\n \n+\n /* Subroutine of fold_stmt called via walk_tree.  We perform several\n    simplifications of EXPR_P, mostly having to do with pointer arithmetic.  */\n \n@@ -2117,282 +1800,98 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Fold the statement pointed by STMT_P.  In some cases, this function may\n-   replace the whole statement with a new one.  Returns true iff folding\n-   makes any changes.  */\n-\n-bool\n-fold_stmt (tree *stmt_p)\n-{\n-  tree rhs, result, stmt;\n-  bool changed = false;\n-\n-  stmt = *stmt_p;\n-\n-  /* If we replaced constants and the statement makes pointer dereferences,\n-     then we may need to fold instances of *&VAR into VAR, etc.  */\n-  if (walk_tree (stmt_p, fold_stmt_r, &changed, NULL))\n-    {\n-      *stmt_p\n-\t= build_function_call_expr (implicit_built_in_decls[BUILT_IN_TRAP],\n-\t\t\t\t    NULL);\n-      return true;\n-    }\n-\n-  rhs = get_rhs (stmt);\n-  if (!rhs)\n-    return changed;\n-  result = NULL_TREE;\n-\n-  if (TREE_CODE (rhs) == CALL_EXPR)\n-    {\n-      tree callee;\n-\n-      /* Check for builtins that CCP can handle using information not\n-\t available in the generic fold routines.  */\n-      callee = get_callee_fndecl (rhs);\n-      if (callee && DECL_BUILT_IN (callee))\n-\tresult = ccp_fold_builtin (stmt, rhs);\n-      else\n-\t{\n-\t  /* Check for resolvable OBJ_TYPE_REF.  The only sorts we can resolve\n-\t     here are when we've propagated the address of a decl into the\n-\t     object slot.  */\n-\t  /* ??? Should perhaps do this in fold proper.  However, doing it\n-\t     there requires that we create a new CALL_EXPR, and that requires\n-\t     copying EH region info to the new node.  Easier to just do it\n-\t     here where we can just smash the call operand.  */\n-\t  callee = TREE_OPERAND (rhs, 0);\n-\t  if (TREE_CODE (callee) == OBJ_TYPE_REF\n-\t      && lang_hooks.fold_obj_type_ref\n-\t      && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (OBJ_TYPE_REF_OBJECT (callee), 0)))\n-\t    {\n-\t      tree t;\n-\n-\t      /* ??? Caution: Broken ADDR_EXPR semantics means that\n-\t\t looking at the type of the operand of the addr_expr\n-\t\t can yield an array type.  See silly exception in\n-\t\t check_pointer_types_r.  */\n-\n-\t      t = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (callee)));\n-\t      t = lang_hooks.fold_obj_type_ref (callee, t);\n-\t      if (t)\n-\t\t{\n-\t\t  TREE_OPERAND (rhs, 0) = t;\n-\t\t  changed = true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* If we couldn't fold the RHS, hand over to the generic fold routines.  */\n-  if (result == NULL_TREE)\n-    result = fold (rhs);\n-\n-  /* Strip away useless type conversions.  Both the NON_LVALUE_EXPR that\n-     may have been added by fold, and \"useless\" type conversions that might\n-     now be apparent due to propagation.  */\n-  STRIP_USELESS_TYPE_CONVERSION (result);\n-\n-  if (result != rhs)\n-    changed |= set_rhs (stmt_p, result);\n-\n-  return changed;\n-}\n-\n-/* Get the main expression from statement STMT.  */\n-\n-static tree\n-get_rhs (tree stmt)\n-{\n-  enum tree_code code = TREE_CODE (stmt);\n-\n-  switch (code)\n-    {\n-    case RETURN_EXPR:\n-      stmt = TREE_OPERAND (stmt, 0);\n-      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n-\treturn stmt;\n-      /* FALLTHRU */\n-\n-    case MODIFY_EXPR:\n-      stmt = TREE_OPERAND (stmt, 1);\n-      if (TREE_CODE (stmt) == WITH_SIZE_EXPR)\n-\treturn TREE_OPERAND (stmt, 0);\n-      else\n-\treturn stmt;\n-\n-    case COND_EXPR:\n-      return COND_EXPR_COND (stmt);\n-    case SWITCH_EXPR:\n-      return SWITCH_COND (stmt);\n-    case GOTO_EXPR:\n-      return GOTO_DESTINATION (stmt);\n-    case LABEL_EXPR:\n-      return LABEL_EXPR_LABEL (stmt);\n-\n-    default:\n-      return stmt;\n-    }\n-}\n-\n \n-/* Set the main expression of *STMT_P to EXPR.  */\n+/* Return the string length of ARG in LENGTH.  If ARG is an SSA name variable,\n+   follow its use-def chains.  If LENGTH is not NULL and its value is not\n+   equal to the length we determine, or if we are unable to determine the\n+   length, return false.  VISITED is a bitmap of visited variables.  */\n \n static bool\n-set_rhs (tree *stmt_p, tree expr)\n+get_strlen (tree arg, tree *length, bitmap visited)\n {\n-  tree stmt = *stmt_p, op;\n-  enum tree_code code = TREE_CODE (expr);\n-  stmt_ann_t ann;\n-  tree var;\n-  ssa_op_iter iter;\n-\n-  /* Verify the constant folded result is valid gimple.  */\n-  if (TREE_CODE_CLASS (code) == '2')\n-    {\n-      if (!is_gimple_val (TREE_OPERAND (expr, 0))\n-\t  || !is_gimple_val (TREE_OPERAND (expr, 1)))\n-\treturn false;\n-    }\n-  else if (TREE_CODE_CLASS (code) == '1')\n+  tree var, def_stmt, val;\n+  \n+  if (TREE_CODE (arg) != SSA_NAME)\n     {\n-      if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n+      val = c_strlen (arg, 1);\n+      if (!val)\n \treturn false;\n-    }\n-\n-  switch (TREE_CODE (stmt))\n-    {\n-    case RETURN_EXPR:\n-      op = TREE_OPERAND (stmt, 0);\n-      if (TREE_CODE (op) != MODIFY_EXPR)\n-\t{\n-\t  TREE_OPERAND (stmt, 0) = expr;\n-\t  break;\n-\t}\n-      stmt = op;\n-      /* FALLTHRU */\n-\n-    case MODIFY_EXPR:\n-      op = TREE_OPERAND (stmt, 1);\n-      if (TREE_CODE (op) == WITH_SIZE_EXPR)\n-\tstmt = op;\n-      TREE_OPERAND (stmt, 1) = expr;\n-      break;\n-\n-    case COND_EXPR:\n-      COND_EXPR_COND (stmt) = expr;\n-      break;\n-    case SWITCH_EXPR:\n-      SWITCH_COND (stmt) = expr;\n-      break;\n-    case GOTO_EXPR:\n-      GOTO_DESTINATION (stmt) = expr;\n-      break;\n-    case LABEL_EXPR:\n-      LABEL_EXPR_LABEL (stmt) = expr;\n-      break;\n \n-    default:\n-      /* Replace the whole statement with EXPR.  If EXPR has no side\n-\t effects, then replace *STMT_P with an empty statement.  */\n-      ann = stmt_ann (stmt);\n-      *stmt_p = TREE_SIDE_EFFECTS (expr) ? expr : build_empty_stmt ();\n-      (*stmt_p)->common.ann = (tree_ann_t) ann;\n+      if (*length && simple_cst_equal (val, *length) != 1)\n+\treturn false;\n \n-      if (TREE_SIDE_EFFECTS (expr))\n-\t{\n-\t  /* Fix all the SSA_NAMEs created by *STMT_P to point to its new\n-\t     replacement.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_DEFS)\n-\t    {\n-\t      if (TREE_CODE (var) == SSA_NAME)\n-\t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n-\t    }\n-\t}\n-      break;\n+      *length = val;\n+      return true;\n     }\n \n-  return true;\n-}\n+  /* If we were already here, break the infinite cycle.  */\n+  if (bitmap_bit_p (visited, SSA_NAME_VERSION (arg)))\n+    return true;\n+  bitmap_set_bit (visited, SSA_NAME_VERSION (arg));\n+\n+  var = arg;\n+  def_stmt = SSA_NAME_DEF_STMT (var);\n \n+  switch (TREE_CODE (def_stmt))\n+    {\n+      case MODIFY_EXPR:\n+\t{\n+\t  tree len, rhs;\n+\t  \n+\t  /* The RHS of the statement defining VAR must either have a\n+\t     constant length or come from another SSA_NAME with a constant\n+\t     length.  */\n+\t  rhs = TREE_OPERAND (def_stmt, 1);\n+\t  STRIP_NOPS (rhs);\n+\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t    return get_strlen (rhs, length, visited);\n \n-/* Return a default value for variable VAR using the following rules:\n+\t  /* See if the RHS is a constant length.  */\n+\t  len = c_strlen (rhs, 1);\n+\t  if (len)\n+\t    {\n+\t      if (*length && simple_cst_equal (len, *length) != 1)\n+\t\treturn false;\n \n-   1- Function arguments are considered VARYING.\n-   \n-   2- Global and static variables that are declared constant are\n-      considered CONSTANT.\n+\t      *length = len;\n+\t      return true;\n+\t    }\n \n-   3- Any other virtually defined variable is considered UNKNOWN_VAL.\n+\t  break;\n+\t}\n \n-   4- Any other value is considered UNDEFINED.  This is useful when\n-      considering PHI nodes.  PHI arguments that are undefined do not\n-      change the constant value of the PHI node, which allows for more\n-      constants to be propagated.  */\n+      case PHI_NODE:\n+\t{\n+\t  /* All the arguments of the PHI node must have the same constant\n+\t     length.  */\n+\t  int i;\n \n-static value\n-get_default_value (tree var)\n-{\n-  value val;\n-  tree sym;\n+\t  for (i = 0; i < PHI_NUM_ARGS (def_stmt); i++)\n+\t    {\n+\t      tree arg = PHI_ARG_DEF (def_stmt, i);\n \n-  if (TREE_CODE (var) == SSA_NAME)\n-    sym = SSA_NAME_VAR (var);\n-  else\n-    {\n-#ifdef ENABLE_CHECKING\n-      if (!DECL_P (var))\n-\tabort ();\n-#endif\n-      sym = var;\n-    }\n+\t      /* If this PHI has itself as an argument, we cannot\n+\t\t determine the string length of this argument.  However,\n+\t\t if we can find a constant string length for the other\n+\t\t PHI args then we can still be sure that this is a\n+\t\t constant string length.  So be optimistic and just\n+\t\t continue with the next argument.  */\n+\t      if (arg == PHI_RESULT (def_stmt))\n+\t\tcontinue;\n \n-  val.lattice_val = UNDEFINED;\n-  val.const_val = NULL_TREE;\n+\t      if (!get_strlen (arg, length, visited))\n+\t\treturn false;\n+\t    }\n \n-  if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n-    {\n-      /* Function arguments and volatile variables are considered VARYING.  */\n-      val.lattice_val = VARYING;\n-    }\n-  else if (TREE_STATIC (sym))\n-    {\n-      /* Globals and static variables are considered UNKNOWN_VAL,\n-         unless they are declared 'const'.  */\n-      if (TREE_READONLY (sym)\n-\t  && DECL_INITIAL (sym)\n-\t  && is_gimple_min_invariant (DECL_INITIAL (sym)))\n-\t{\n-\t  val.lattice_val = CONSTANT;\n-\t  val.const_val = DECL_INITIAL (sym);\n-\t}\n-      else\n-        {\n-          val.const_val = NULL_TREE;\n-\t  val.lattice_val = UNKNOWN_VAL;\n+\t  return true;\n \t}\n-    }\n-  else if (!is_gimple_reg (sym))\n-    {\n-      val.const_val = NULL_TREE;\n-      val.lattice_val = UNKNOWN_VAL;\n-    }\n-  else\n-    {\n-      enum tree_code code;\n-      tree stmt = SSA_NAME_DEF_STMT (var);\n \n-      if (!IS_EMPTY_STMT (stmt))\n-        {\n-\t  code = TREE_CODE (stmt);\n-\t  if (code != MODIFY_EXPR && code != PHI_NODE)\n-\t    val.lattice_val = VARYING;\n-\t}\n+      default:\n+\tbreak;\n     }\n \n-  return val;\n+\n+  return false;\n }\n \n \n@@ -2512,97 +2011,88 @@ ccp_fold_builtin (tree stmt, tree fn)\n }\n \n \n-/* Return the string length of ARG in LENGTH.  If ARG is an SSA name variable,\n-   follow its use-def chains.  If LENGTH is not NULL and its value is not\n-   equal to the length we determine, or if we are unable to determine the\n-   length, return false.  VISITED is a bitmap of visited variables.  */\n+/* Fold the statement pointed by STMT_P.  In some cases, this function may\n+   replace the whole statement with a new one.  Returns true iff folding\n+   makes any changes.  */\n \n-static bool\n-get_strlen (tree arg, tree *length, bitmap visited)\n+bool\n+fold_stmt (tree *stmt_p)\n {\n-  tree var, def_stmt, val;\n-  \n-  if (TREE_CODE (arg) != SSA_NAME)\n-    {\n-      val = c_strlen (arg, 1);\n-      if (!val)\n-\treturn false;\n+  tree rhs, result, stmt;\n+  bool changed = false;\n \n-      if (*length && simple_cst_equal (val, *length) != 1)\n-\treturn false;\n+  stmt = *stmt_p;\n \n-      *length = val;\n+  /* If we replaced constants and the statement makes pointer dereferences,\n+     then we may need to fold instances of *&VAR into VAR, etc.  */\n+  if (walk_tree (stmt_p, fold_stmt_r, &changed, NULL))\n+    {\n+      *stmt_p\n+\t= build_function_call_expr (implicit_built_in_decls[BUILT_IN_TRAP],\n+\t\t\t\t    NULL);\n       return true;\n     }\n \n-  /* If we were already here, break the infinite cycle.  */\n-  if (bitmap_bit_p (visited, SSA_NAME_VERSION (arg)))\n-    return true;\n-  bitmap_set_bit (visited, SSA_NAME_VERSION (arg));\n-\n-  var = arg;\n-  def_stmt = SSA_NAME_DEF_STMT (var);\n+  rhs = get_rhs (stmt);\n+  if (!rhs)\n+    return changed;\n+  result = NULL_TREE;\n \n-  switch (TREE_CODE (def_stmt))\n+  if (TREE_CODE (rhs) == CALL_EXPR)\n     {\n-      case MODIFY_EXPR:\n-\t{\n-\t  tree len, rhs;\n-\t  \n-\t  /* The RHS of the statement defining VAR must either have a\n-\t     constant length or come from another SSA_NAME with a constant\n-\t     length.  */\n-\t  rhs = TREE_OPERAND (def_stmt, 1);\n-\t  STRIP_NOPS (rhs);\n-\t  if (TREE_CODE (rhs) == SSA_NAME)\n-\t    return get_strlen (rhs, length, visited);\n-\n-\t  /* See if the RHS is a constant length.  */\n-\t  len = c_strlen (rhs, 1);\n-\t  if (len)\n-\t    {\n-\t      if (*length && simple_cst_equal (len, *length) != 1)\n-\t\treturn false;\n-\n-\t      *length = len;\n-\t      return true;\n-\t    }\n-\n-\t  break;\n-\t}\n+      tree callee;\n \n-      case PHI_NODE:\n+      /* Check for builtins that CCP can handle using information not\n+\t available in the generic fold routines.  */\n+      callee = get_callee_fndecl (rhs);\n+      if (callee && DECL_BUILT_IN (callee))\n+\tresult = ccp_fold_builtin (stmt, rhs);\n+      else\n \t{\n-\t  /* All the arguments of the PHI node must have the same constant\n-\t     length.  */\n-\t  int i;\n-\n-\t  for (i = 0; i < PHI_NUM_ARGS (def_stmt); i++)\n+\t  /* Check for resolvable OBJ_TYPE_REF.  The only sorts we can resolve\n+\t     here are when we've propagated the address of a decl into the\n+\t     object slot.  */\n+\t  /* ??? Should perhaps do this in fold proper.  However, doing it\n+\t     there requires that we create a new CALL_EXPR, and that requires\n+\t     copying EH region info to the new node.  Easier to just do it\n+\t     here where we can just smash the call operand.  */\n+\t  callee = TREE_OPERAND (rhs, 0);\n+\t  if (TREE_CODE (callee) == OBJ_TYPE_REF\n+\t      && lang_hooks.fold_obj_type_ref\n+\t      && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n+\t      && DECL_P (TREE_OPERAND (OBJ_TYPE_REF_OBJECT (callee), 0)))\n \t    {\n-\t      tree arg = PHI_ARG_DEF (def_stmt, i);\n+\t      tree t;\n \n-\t      /* If this PHI has itself as an argument, we cannot\n-\t\t determine the string length of this argument.  However,\n-\t\t if we can find a constant string length for the other\n-\t\t PHI args then we can still be sure that this is a\n-\t\t constant string length.  So be optimistic and just\n-\t\t continue with the next argument.  */\n-\t      if (arg == PHI_RESULT (def_stmt))\n-\t\tcontinue;\n+\t      /* ??? Caution: Broken ADDR_EXPR semantics means that\n+\t\t looking at the type of the operand of the addr_expr\n+\t\t can yield an array type.  See silly exception in\n+\t\t check_pointer_types_r.  */\n \n-\t      if (!get_strlen (arg, length, visited))\n-\t\treturn false;\n+\t      t = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (callee)));\n+\t      t = lang_hooks.fold_obj_type_ref (callee, t);\n+\t      if (t)\n+\t\t{\n+\t\t  TREE_OPERAND (rhs, 0) = t;\n+\t\t  changed = true;\n+\t\t}\n \t    }\n-\n-\t  return true;\n \t}\n-\n-      default:\n-\tbreak;\n     }\n \n+  /* If we couldn't fold the RHS, hand over to the generic fold routines.  */\n+  if (result == NULL_TREE)\n+    result = fold (rhs);\n \n-  return false;\n+  /* Strip away useless type conversions.  Both the NON_LVALUE_EXPR that\n+     may have been added by fold, and \"useless\" type conversions that might\n+     now be apparent due to propagation.  */\n+  STRIP_USELESS_TYPE_CONVERSION (result);\n+\n+  if (result != rhs)\n+    changed |= set_rhs (stmt_p, result);\n+\n+  return changed;\n }\n \n \f\n@@ -2662,6 +2152,7 @@ execute_fold_all_builtins (void)\n     }\n }\n \n+\n struct tree_opt_pass pass_fold_builtins = \n {\n   \"fab\",\t\t\t\t/* name */\n@@ -2677,6 +2168,3 @@ struct tree_opt_pass pass_fold_builtins =\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_verify_ssa\t/* todo_flags_finish */\n };\n-\n-\n-#include \"gt-tree-ssa-ccp.h\""}, {"sha": "1577a9c0b5ab4a25215f048e52f7662d5f4a08bf", "filename": "gcc/tree-ssa-propagate.c", "status": "added", "additions": 674, "deletions": 0, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -0,0 +1,674 @@\n+/* Generic SSA value propagation engine.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@redhat.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"errors.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"langhooks.h\"\n+\n+\n+/* This file implements a generic value propagation engine based on\n+   the same propagation used by the SSA-CCP algorithm [1].\n+\n+   Propagation is performed by simulating the execution of every\n+   statement that produces the value being propagated.  Simulation\n+   proceeds as follows:\n+\n+   1- Initially, all edges of the CFG are marked not executable and\n+      the CFG worklist seeded with all the statements in the entry\n+      basic block (block 0).\n+\n+   2- Every statement S is simulated with a call to the call-back\n+      function SSA_PROP_VISIT_STMT.  This evaluation may produce 3\n+      results:\n+\n+      \tSSA_PROP_NOT_INTERESTING: Statement S produces nothing of\n+\t    interest and does not affect any of the work lists.\n+\n+\tSSA_PROP_VARYING: The value produced by S cannot be determined\n+\t    at compile time.  Further simulation of S is not required.\n+\t    If S is a conditional jump, all the outgoing edges for the\n+\t    block are considered executable and added to the work\n+\t    list.\n+\n+\tSSA_PROP_INTERESTING: S produces a value that can be computed\n+\t    at compile time.  Its result can be propagated into the\n+\t    statements that feed from S.  Furhtermore, if S is a\n+\t    conditional jump, only the edge known to be taken is added\n+\t    to the work list.  Edges that are known not to execute are\n+\t    never simulated.\n+\n+   3- PHI nodes are simulated with a call to SSA_PROP_VISIT_PHI.  The\n+      return value from SSA_PROP_VISIT_PHI has the same semantics as\n+      described in #3.\n+\n+   4- Three work lists are kept.  Statements are only added to these\n+      lists if they produce one of SSA_PROP_INTERESTING or\n+      SSA_PROP_VARYING.\n+\n+   \tCFG_BLOCKS contains the list of blocks to be simulated.\n+\t    Blocks are added to this list if their incoming edges are\n+\t    found executable.\n+\n+\tVARYING_SSA_EDGES contains the list of statements that feed\n+\t    from statements that produce an SSA_PROP_VARYING result.\n+\t    These are simulated first to speed up processing.\n+\n+\tINTERESTING_SSA_EDGES contains the list of statements that\n+\t    feed from statements that produce an SSA_PROP_INTERESTING\n+\t    result.\n+\n+   5- Simulation terminates when all three work lists are drained.\n+\n+   Before calling ssa_propagate, it is important to clear\n+   DONT_SIMULATE_AGAIN for all the statements in the program that\n+   should be simulated.  This initialization allows an implementation\n+   to specify which statements should never be simulated.\n+\n+   It is also important to compute def-use information before calling\n+   ssa_propagate.\n+\n+   References:\n+\n+     [1] Constant propagation with conditional branches,\n+         Wegman and Zadeck, ACM TOPLAS 13(2):181-210.\n+\n+     [2] Building an Optimizing Compiler,\n+\t Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.\n+\n+     [3] Advanced Compiler Design and Implementation,\n+\t Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6  */\n+\n+/* Function pointers used to parameterize the propagation engine.  */\n+static ssa_prop_visit_stmt_fn ssa_prop_visit_stmt;\n+static ssa_prop_visit_phi_fn ssa_prop_visit_phi;\n+\n+/* Use the TREE_DEPRECATED bitflag to mark statements that have been\n+   added to one of the SSA edges worklists.  This flag is used to\n+   avoid visiting statements unnecessarily when draining an SSA edge\n+   worklist.  If while simulating a basic block, we find a statement with\n+   STMT_IN_SSA_EDGE_WORKLIST set, we clear it to prevent SSA edge\n+   processing from visiting it again.  */\n+#define STMT_IN_SSA_EDGE_WORKLIST(T)\tTREE_DEPRECATED (T)\n+\n+/* A bitmap to keep track of executable blocks in the CFG.  */\n+static sbitmap executable_blocks;\n+\n+/* Array of control flow edges on the worklist.  */\n+static GTY(()) varray_type cfg_blocks = NULL;\n+\n+static unsigned int cfg_blocks_num = 0;\n+static int cfg_blocks_tail;\n+static int cfg_blocks_head;\n+\n+static sbitmap bb_in_list;\n+\n+/* Worklist of SSA edges which will need reexamination as their\n+   definition has changed.  SSA edges are def-use edges in the SSA\n+   web.  For each D-U edge, we store the target statement or PHI node\n+   U.  */\n+static GTY(()) varray_type interesting_ssa_edges;\n+\n+/* Identical to INTERESTING_SSA_EDGES.  For performance reasons, the\n+   list of SSA edges is split into two.  One contains all SSA edges\n+   who need to be reexamined because their lattice value changed to\n+   varying (this worklist), and the other contains all other SSA edges\n+   to be reexamined (INTERESTING_SSA_EDGES).\n+\n+   Since most values in the program are VARYING, the ideal situation\n+   is to move them to that lattice value as quickly as possible.\n+   Thus, it doesn't make sense to process any other type of lattice\n+   value until all VARYING values are propagated fully, which is one\n+   thing using the VARYING worklist achieves.  In addition, if we\n+   don't use a separate worklist for VARYING edges, we end up with\n+   situations where lattice values move from\n+   UNDEFINED->INTERESTING->VARYING instead of UNDEFINED->VARYING.  */\n+static GTY(()) varray_type varying_ssa_edges;\n+\n+\n+/* Return true if the block worklist empty.  */\n+\n+static inline bool\n+cfg_blocks_empty_p (void)\n+{\n+  return (cfg_blocks_num == 0);\n+}\n+\n+\n+/* Add a basic block to the worklist.  */\n+\n+static void \n+cfg_blocks_add (basic_block bb)\n+{\n+  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n+    return;\n+\n+  if (TEST_BIT (bb_in_list, bb->index))\n+    return;\n+\n+  if (cfg_blocks_empty_p ())\n+    {\n+      cfg_blocks_tail = cfg_blocks_head = 0;\n+      cfg_blocks_num = 1;\n+    }\n+  else\n+    {\n+      cfg_blocks_num++;\n+      if (cfg_blocks_num > VARRAY_SIZE (cfg_blocks))\n+\t{\n+\t  /* We have to grow the array now.  Adjust to queue to occupy the\n+\t     full space of the original array.  */\n+\t  cfg_blocks_tail = VARRAY_SIZE (cfg_blocks);\n+\t  cfg_blocks_head = 0;\n+\t  VARRAY_GROW (cfg_blocks, 2 * VARRAY_SIZE (cfg_blocks));\n+\t}\n+      else\n+\tcfg_blocks_tail = (cfg_blocks_tail + 1) % VARRAY_SIZE (cfg_blocks);\n+    }\n+\n+  VARRAY_BB (cfg_blocks, cfg_blocks_tail) = bb;\n+  SET_BIT (bb_in_list, bb->index);\n+}\n+\n+\n+/* Remove a block from the worklist.  */\n+\n+static basic_block\n+cfg_blocks_get (void)\n+{\n+  basic_block bb;\n+\n+  bb = VARRAY_BB (cfg_blocks, cfg_blocks_head);\n+\n+#ifdef ENABLE_CHECKING\n+  if (cfg_blocks_empty_p () || !bb)\n+    abort ();\n+#endif\n+\n+  cfg_blocks_head = (cfg_blocks_head + 1) % VARRAY_SIZE (cfg_blocks);\n+  --cfg_blocks_num;\n+  RESET_BIT (bb_in_list, bb->index);\n+\n+  return bb;\n+}\n+\n+\n+/* We have just defined a new value for VAR.  If IS_VARYING is true,\n+   add all immediate uses of VAR to VARYING_SSA_EDGES, otherwise add\n+   them to INTERESTING_SSA_EDGES.  */\n+\n+static void\n+add_ssa_edge (tree var, bool is_varying)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (var);\n+  dataflow_t df = get_immediate_uses (stmt);\n+  int num_uses = num_immediate_uses (df);\n+  int i;\n+\n+  for (i = 0; i < num_uses; i++)\n+    {\n+      tree use_stmt = immediate_use (df, i);\n+\n+      if (!DONT_SIMULATE_AGAIN (use_stmt)\n+\t  && !STMT_IN_SSA_EDGE_WORKLIST (use_stmt))\n+\t{\n+\t  STMT_IN_SSA_EDGE_WORKLIST (use_stmt) = 1;\n+\t  if (is_varying)\n+\t    VARRAY_PUSH_TREE (varying_ssa_edges, use_stmt);\n+\t  else\n+\t    VARRAY_PUSH_TREE (interesting_ssa_edges, use_stmt);\n+\t}\n+    }\n+}\n+\n+\n+/* Add edge E to the control flow worklist.  */\n+\n+static void\n+add_control_edge (edge e)\n+{\n+  basic_block bb = e->dest;\n+  if (bb == EXIT_BLOCK_PTR)\n+    return;\n+\n+  /* If the edge had already been executed, skip it.  */\n+  if (e->flags & EDGE_EXECUTABLE)\n+    return;\n+\n+  e->flags |= EDGE_EXECUTABLE;\n+\n+  /* If the block is already in the list, we're done.  */\n+  if (TEST_BIT (bb_in_list, bb->index))\n+    return;\n+\n+  cfg_blocks_add (bb);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Adding Destination of edge (%d -> %d) to worklist\\n\\n\",\n+\te->src->index, e->dest->index);\n+}\n+\n+\n+/* Simulate the execution of STMT and update the work lists accordingly.  */\n+\n+static void\n+simulate_stmt (tree stmt)\n+{\n+  enum ssa_prop_result val = SSA_PROP_NOT_INTERESTING;\n+  edge taken_edge = NULL;\n+  tree output_name = NULL_TREE;\n+\n+  /* Don't bother visiting statements that are already\n+     considered varying by the propagator.  */\n+  if (DONT_SIMULATE_AGAIN (stmt))\n+    return;\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      val = ssa_prop_visit_phi (stmt);\n+      output_name = PHI_RESULT (stmt);\n+    }\n+  else\n+    val = ssa_prop_visit_stmt (stmt, &taken_edge, &output_name);\n+\n+  if (val == SSA_PROP_VARYING)\n+    {\n+      DONT_SIMULATE_AGAIN (stmt) = 1;\n+\n+      /* If the statement produced a new varying value, add the SSA\n+\t edges coming out of OUTPUT_NAME.  */\n+      if (output_name)\n+\tadd_ssa_edge (output_name, true);\n+\n+      /* If STMT transfers control out of its basic block, add\n+\t all outgoing edges to the work list.  */\n+      if (stmt_ends_bb_p (stmt))\n+\t{\n+\t  edge e;\n+\t  basic_block bb = bb_for_stmt (stmt);\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    add_control_edge (e);\n+\t}\n+    }\n+  else if (val == SSA_PROP_INTERESTING)\n+    {\n+      /* If the statement produced new value, add the SSA edges coming\n+\t out of OUTPUT_NAME.  */\n+      if (output_name)\n+\tadd_ssa_edge (output_name, false);\n+\n+      /* If we know which edge is going to be taken out of this block,\n+\t add it to the CFG work list.  */\n+      if (taken_edge)\n+\tadd_control_edge (taken_edge);\n+    }\n+}\n+\n+/* Process an SSA edge worklist.  WORKLIST is the SSA edge worklist to\n+   drain.  This pops statements off the given WORKLIST and processes\n+   them until there are no more statements on WORKLIST.  */\n+\n+static void\n+process_ssa_edge_worklist (varray_type *worklist)\n+{\n+  /* Drain the entire worklist.  */\n+  while (VARRAY_ACTIVE_SIZE (*worklist) > 0)\n+    {\n+      basic_block bb;\n+\n+      /* Pull the statement to simulate off the worklist.  */\n+      tree stmt = VARRAY_TOP_TREE (*worklist);\n+      VARRAY_POP (*worklist);\n+\n+      /* If this statement was already visited by simulate_block, then\n+\t we don't need to visit it again here.  */\n+      if (!STMT_IN_SSA_EDGE_WORKLIST (stmt))\n+\tcontinue;\n+\n+      /* STMT is no longer in a worklist.  */\n+      STMT_IN_SSA_EDGE_WORKLIST (stmt) = 0;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\nSimulating statement (from ssa_edges): \");\n+\t  print_generic_stmt (dump_file, stmt, dump_flags);\n+\t}\n+\n+      bb = bb_for_stmt (stmt);\n+\n+      /* PHI nodes are always visited, regardless of whether or not\n+\t the destination block is executable.  Otherwise, visit the\n+\t statement only if its block is marked executable.  */\n+      if (TREE_CODE (stmt) == PHI_NODE\n+\t  || TEST_BIT (executable_blocks, bb->index))\n+\tsimulate_stmt (stmt);\n+    }\n+}\n+\n+\n+/* Simulate the execution of BLOCK.  Evaluate the statement associated\n+   with each variable reference inside the block.  */\n+\n+static void\n+simulate_block (basic_block block)\n+{\n+  tree phi;\n+\n+  /* There is nothing to do for the exit block.  */\n+  if (block == EXIT_BLOCK_PTR)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nSimulating block %d\\n\", block->index);\n+\n+  /* Always simulate PHI nodes, even if we have simulated this block\n+     before.  */\n+  for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n+    simulate_stmt (phi);\n+\n+  /* If this is the first time we've simulated this block, then we\n+     must simulate each of its statements.  */\n+  if (!TEST_BIT (executable_blocks, block->index))\n+    {\n+      block_stmt_iterator j;\n+      unsigned int normal_edge_count;\n+      edge e, normal_edge;\n+\n+      /* Note that we have simulated this block.  */\n+      SET_BIT (executable_blocks, block->index);\n+\n+      for (j = bsi_start (block); !bsi_end_p (j); bsi_next (&j))\n+\t{\n+\t  tree stmt = bsi_stmt (j);\n+\n+\t  /* If this statement is already in the worklist then\n+\t     \"cancel\" it.  The reevaluation implied by the worklist\n+\t     entry will produce the same value we generate here and\n+\t     thus reevaluating it again from the worklist is\n+\t     pointless.  */\n+\t  if (STMT_IN_SSA_EDGE_WORKLIST (stmt))\n+\t    STMT_IN_SSA_EDGE_WORKLIST (stmt) = 0;\n+\n+\t  simulate_stmt (stmt);\n+\t}\n+\n+      /* We can not predict when abnormal edges will be executed, so\n+\t once a block is considered executable, we consider any\n+\t outgoing abnormal edges as executable.\n+\n+\t At the same time, if this block has only one successor that is\n+\t reached by non-abnormal edges, then add that successor to the\n+\t worklist.  */\n+      normal_edge_count = 0;\n+      normal_edge = NULL;\n+      for (e = block->succ; e; e = e->succ_next)\n+\t{\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    add_control_edge (e);\n+\t  else\n+\t    {\n+\t      normal_edge_count++;\n+\t      normal_edge = e;\n+\t    }\n+\t}\n+\n+      if (normal_edge_count == 1)\n+\tadd_control_edge (normal_edge);\n+    }\n+}\n+\n+\n+/* Initialize local data structures and work lists.  */\n+\n+static void\n+ssa_prop_init (void)\n+{\n+  edge e;\n+  basic_block bb;\n+\n+  /* Worklists of SSA edges.  */\n+  VARRAY_TREE_INIT (interesting_ssa_edges, 20, \"interesting_ssa_edges\");\n+  VARRAY_TREE_INIT (varying_ssa_edges, 20, \"varying_ssa_edges\");\n+\n+  executable_blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (executable_blocks);\n+\n+  bb_in_list = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (bb_in_list);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_immediate_uses (dump_file);\n+\n+  VARRAY_BB_INIT (cfg_blocks, 20, \"cfg_blocks\");\n+\n+  /* Initially assume that every edge in the CFG is not executable.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator si;\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\tSTMT_IN_SSA_EDGE_WORKLIST (bsi_stmt (si)) = 0;\n+\n+      for (e = bb->succ; e; e = e->succ_next)\n+\te->flags &= ~EDGE_EXECUTABLE;\n+    }\n+\n+  /* Seed the algorithm by adding the successors of the entry block to the\n+     edge worklist.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest != EXIT_BLOCK_PTR)\n+\t{\n+\t  e->flags |= EDGE_EXECUTABLE;\n+\t  cfg_blocks_add (e->dest);\n+\t}\n+    }\n+}\n+\n+\n+/* Free allocated storage.  */\n+\n+static void\n+ssa_prop_fini (void)\n+{\n+  interesting_ssa_edges = NULL;\n+  varying_ssa_edges = NULL;\n+  cfg_blocks = NULL;\n+  sbitmap_free (bb_in_list);\n+  sbitmap_free (executable_blocks);\n+  free_df ();\n+}\n+\n+\n+/* Get the main expression from statement STMT.  */\n+\n+tree\n+get_rhs (tree stmt)\n+{\n+  enum tree_code code = TREE_CODE (stmt);\n+\n+  switch (code)\n+    {\n+    case RETURN_EXPR:\n+      stmt = TREE_OPERAND (stmt, 0);\n+      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+\treturn stmt;\n+      /* FALLTHRU */\n+\n+    case MODIFY_EXPR:\n+      stmt = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (stmt) == WITH_SIZE_EXPR)\n+\treturn TREE_OPERAND (stmt, 0);\n+      else\n+\treturn stmt;\n+\n+    case COND_EXPR:\n+      return COND_EXPR_COND (stmt);\n+    case SWITCH_EXPR:\n+      return SWITCH_COND (stmt);\n+    case GOTO_EXPR:\n+      return GOTO_DESTINATION (stmt);\n+    case LABEL_EXPR:\n+      return LABEL_EXPR_LABEL (stmt);\n+\n+    default:\n+      return stmt;\n+    }\n+}\n+\n+\n+/* Set the main expression of *STMT_P to EXPR.  If EXPR is not a valid\n+   GIMPLE expression no changes are done and the function returns\n+   false.  */\n+\n+bool\n+set_rhs (tree *stmt_p, tree expr)\n+{\n+  tree stmt = *stmt_p, op;\n+  enum tree_code code = TREE_CODE (expr);\n+  stmt_ann_t ann;\n+  tree var;\n+  ssa_op_iter iter;\n+\n+  /* Verify the constant folded result is valid gimple.  */\n+  if (TREE_CODE_CLASS (code) == '2')\n+    {\n+      if (!is_gimple_val (TREE_OPERAND (expr, 0))\n+\t  || !is_gimple_val (TREE_OPERAND (expr, 1)))\n+\treturn false;\n+    }\n+  else if (TREE_CODE_CLASS (code) == '1')\n+    {\n+      if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n+\treturn false;\n+    }\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      op = TREE_OPERAND (stmt, 0);\n+      if (TREE_CODE (op) != MODIFY_EXPR)\n+\t{\n+\t  TREE_OPERAND (stmt, 0) = expr;\n+\t  break;\n+\t}\n+      stmt = op;\n+      /* FALLTHRU */\n+\n+    case MODIFY_EXPR:\n+      op = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (op) == WITH_SIZE_EXPR)\n+\tstmt = op;\n+      TREE_OPERAND (stmt, 1) = expr;\n+      break;\n+\n+    case COND_EXPR:\n+      COND_EXPR_COND (stmt) = expr;\n+      break;\n+    case SWITCH_EXPR:\n+      SWITCH_COND (stmt) = expr;\n+      break;\n+    case GOTO_EXPR:\n+      GOTO_DESTINATION (stmt) = expr;\n+      break;\n+    case LABEL_EXPR:\n+      LABEL_EXPR_LABEL (stmt) = expr;\n+      break;\n+\n+    default:\n+      /* Replace the whole statement with EXPR.  If EXPR has no side\n+\t effects, then replace *STMT_P with an empty statement.  */\n+      ann = stmt_ann (stmt);\n+      *stmt_p = TREE_SIDE_EFFECTS (expr) ? expr : build_empty_stmt ();\n+      (*stmt_p)->common.ann = (tree_ann_t) ann;\n+\n+      if (TREE_SIDE_EFFECTS (expr))\n+\t{\n+\t  /* Fix all the SSA_NAMEs created by *STMT_P to point to its new\n+\t     replacement.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_DEFS)\n+\t    {\n+\t      if (TREE_CODE (var) == SSA_NAME)\n+\t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n+\t    }\n+\t}\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Entry point to the propagation engine.\n+\n+   VISIT_STMT is called for every statement visited.\n+   VISIT_PHI is called for every PHI node visited.  */\n+\n+void\n+ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n+\t       ssa_prop_visit_phi_fn visit_phi)\n+{\n+  ssa_prop_visit_stmt = visit_stmt;\n+  ssa_prop_visit_phi = visit_phi;\n+\n+  ssa_prop_init ();\n+\n+  /* Iterate until the worklists are empty.  */\n+  while (!cfg_blocks_empty_p () \n+\t || VARRAY_ACTIVE_SIZE (interesting_ssa_edges) > 0\n+\t || VARRAY_ACTIVE_SIZE (varying_ssa_edges) > 0)\n+    {\n+      if (!cfg_blocks_empty_p ())\n+\t{\n+\t  /* Pull the next block to simulate off the worklist.  */\n+\t  basic_block dest_block = cfg_blocks_get ();\n+\t  simulate_block (dest_block);\n+\t}\n+\n+      /* In order to move things to varying as quickly as\n+\t possible,process the VARYING_SSA_EDGES worklist first.  */\n+      process_ssa_edge_worklist (&varying_ssa_edges);\n+\n+      /* Now process the INTERESTING_SSA_EDGES worklist.  */\n+      process_ssa_edge_worklist (&interesting_ssa_edges);\n+    }\n+\n+  ssa_prop_fini ();\n+}\n+\n+#include \"gt-tree-ssa-propagate.h\""}, {"sha": "d390176937a71dc8ddfe81504ebcdf9e694ec3bd", "filename": "gcc/tree-ssa-propagate.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750628d8bcdda3394d81f0b16d0703bb7deeb849/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=750628d8bcdda3394d81f0b16d0703bb7deeb849", "patch": "@@ -0,0 +1,62 @@\n+/* Data structures and function declarations for the SSA value propagation\n+   engine.\n+   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _TREE_SSA_PROPAGATE_H\n+#define _TREE_SSA_PROPAGATE_H 1\n+\n+/* Use the TREE_VISITED bitflag to mark statements and PHI nodes that\n+   have been deemed varying and should not be simulated again.  */\n+#define DONT_SIMULATE_AGAIN(T)\tTREE_VISITED (T)\n+\n+/* Lattice values used for propagation purposes.  Specific instances\n+   of a propagation engine must return these values from the statement\n+   and PHI visit functions to direct the engine.  */\n+\n+enum ssa_prop_result {\n+    /* The statement produces nothing of interest.  No edges will be\n+       added to the work lists.  */\n+    SSA_PROP_NOT_INTERESTING,\n+\n+    /* The statement produces an interesting value.  The set SSA_NAMEs\n+       returned by SSA_PROP_VISIT_STMT should be added to\n+       INTERESTING_SSA_EDGES.  If the statement being visited is a\n+       conditional jump, SSA_PROP_VISIT_STMT should indicate which edge\n+       out of the basic block should be marked exectuable.  */\n+    SSA_PROP_INTERESTING,\n+\n+    /* The statement produces a varying (i.e., useless) value and\n+       should not be simulated again.  If the statement being visited\n+       is a conditional jump, all the edges coming out of the block\n+       will be considered executable.  */\n+    SSA_PROP_VARYING\n+};\n+\n+\n+/* Call-back functions used by the value propagation engine.  */\n+typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (tree, edge *, tree *);\n+typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (tree);\n+\n+void ssa_propagate (ssa_prop_visit_stmt_fn, ssa_prop_visit_phi_fn);\n+tree get_rhs (tree);\n+bool set_rhs (tree *, tree);\n+\n+#endif /* _TREE_SSA_PROPAGATE_H  */"}]}