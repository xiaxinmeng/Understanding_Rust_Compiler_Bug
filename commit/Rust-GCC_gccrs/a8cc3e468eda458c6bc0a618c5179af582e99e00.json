{"sha": "a8cc3e468eda458c6bc0a618c5179af582e99e00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjYzNlNDY4ZWRhNDU4YzZiYzBhNjE4YzUxNzlhZjU4MmU5OWUwMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-09-09T13:48:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T13:48:11Z"}, "message": "impunit.adb: Add entry for a-izteio.\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* impunit.adb: Add entry for a-izteio.\n\t* checks.adb: Add comment.\n\t* debug.adb, exp_disp.adb: Minor reformatting.\n\t* exp_dbug.ads: Minor reformatting throughout (pack block comments).\n\nFrom-SVN: r164098", "tree": {"sha": "af4141f52236cf0ede8847a4d046735217e9b0d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af4141f52236cf0ede8847a4d046735217e9b0d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8cc3e468eda458c6bc0a618c5179af582e99e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8cc3e468eda458c6bc0a618c5179af582e99e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8cc3e468eda458c6bc0a618c5179af582e99e00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8cc3e468eda458c6bc0a618c5179af582e99e00/comments", "author": null, "committer": null, "parents": [{"sha": "4fb0b3f0ddf99a0a6eae445efc44fbd16600d504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb0b3f0ddf99a0a6eae445efc44fbd16600d504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb0b3f0ddf99a0a6eae445efc44fbd16600d504"}], "stats": {"total": 387, "additions": 197, "deletions": 190}, "files": [{"sha": "a8a32f982f83081f50092ef80be80fe6609c6ccd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -1,3 +1,10 @@\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* impunit.adb: Add entry for a-izteio.\n+\t* checks.adb: Add comment.\n+\t* debug.adb, exp_disp.adb: Minor reformatting.\n+\t* exp_dbug.ads: Minor reformatting throughout (pack block comments).\n+\n 2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_eval.adb (Is_Same_Value): Two occurrences of the same"}, {"sha": "29212608372cfb749397a89edb306c243d09b789", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -819,6 +819,15 @@ package body Checks is\n                      --  node is retained, in order to avoid the warning for\n                      --  redundant conversions in Resolve_Type_Conversion.\n \n+                     --  The above comment is uncomfortable. This seems like\n+                     --  an awkward covert channel, since there isno general\n+                     --  requirement in sinfo.ads or einfo.ads that requires\n+                     --  this rewrite. Instead, the issue seems to be that in\n+                     --  the old code, some node was incorrectly marked as\n+                     --  coming from source when it should not have been and/or\n+                     --  the warning code did not properly test the appropriate\n+                     --  Comes_From_Soure flag. ???\n+\n                      Rewrite (N, Relocate_Node (N));\n \n                      Set_Etype (N, Target_Type);"}, {"sha": "bbf86466eaed19a9ed8461558ed3c92d86ea2023", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -581,7 +581,8 @@ package body Debug is\n    --  d.T  Force Optimize_Alignment (Time) mode as the default\n \n    --  d.W  Print out debugging information for Walk_Library_Items, including\n-   --       the order in which units are walked. This is primarily for CodePeer\n+   --       the order in which units are walked. This is primarily for use in\n+   --       debugging CodePeer mode.\n \n    --  d.X  By default, the compiler uses an elaborate rewriting framework for\n    --       short-circuited forms where the right hand condition generates"}, {"sha": "71c9bba651bc7faf93dbed47bdc02a83e36c8892", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 173, "deletions": 181, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -37,11 +37,11 @@ package Exp_Dbug is\n    -- Encoding and Qualification of Names of Entities --\n    -----------------------------------------------------\n \n-   --  This section describes how the names of entities are encoded in\n-   --  the generated debugging information.\n+   --  This section describes how the names of entities are encoded in the\n+   --  generated debugging information.\n \n-   --  An entity in Ada has a name of the form X.Y.Z ... E where X,Y,Z\n-   --  are the enclosing scopes (not including Standard at the start).\n+   --  An entity in Ada has a name of the form X.Y.Z ... E where X,Y,Z are the\n+   --  enclosing scopes (not including Standard at the start).\n \n    --  The encoding of the name follows this basic qualified naming scheme,\n    --  where the encoding of individual entity names is as described in Namet\n@@ -306,13 +306,13 @@ package Exp_Dbug is\n       -- Interface Names --\n       ---------------------\n \n-      --  Note: if an interface name is present, then the external name\n-      --  is taken from the specified interface name. Given the current\n-      --  limitations of the gcc backend, this means that the debugging\n-      --  name is also set to the interface name, but conceptually, it\n-      --  would be possible (and indeed desirable) to have the debugging\n-      --  information still use the Ada name as qualified above, so we\n-      --  still fully qualify the name in the front end.\n+      --  Note: if an interface name is present, then the external name is\n+      --  taken from the specified interface name. Given current limitations of\n+      --  the gcc backend, this means that the debugging name is also set to\n+      --  the interface name, but conceptually, it would be possible (and\n+      --  indeed desirable) to have the debugging information still use the Ada\n+      --  name as qualified above, so we still fully qualify the name in the\n+      --  front end.\n \n       -------------------------------------\n       -- Encodings Related to Task Types --\n@@ -330,7 +330,7 @@ package Exp_Dbug is\n       --      end TaskObj;\n       --    end P;\n       --\n-      --  The name of subprogram TaskObj.F1 is encoded as p__taskobjTK__f1,\n+      --  The name of subprogram TaskObj.F1 is encoded as p__taskobjTK__f1.\n       --  The body, B, is contained in a subprogram whose name is\n       --  p__taskobjTKB.\n \n@@ -413,22 +413,21 @@ package Exp_Dbug is\n \n    No_Dollar_In_Label : constant Boolean := True;\n    --  True iff the target does not allow dollar signs (\"$\") in external names\n-   --  ??? We want to migrate all platforms to use the same convention.\n-   --  As a first step, we force this constant to always be True. This\n-   --  constant will eventually be deleted after we have verified that\n-   --  the migration does not cause any unforseen adverse impact.\n-   --  We chose \"__\" because it is supported on all platforms, which is\n-   --  not the case of \"$\".\n+   --  ??? We want to migrate all platforms to use the same convention. As a\n+   --  first step, we force this constant to always be True. This constant will\n+   --  eventually be deleted after we have verified that the migration does not\n+   --  cause any unforseen adverse impact. We chose \"__\" because it is\n+   --  supported on all platforms, which is not the case of \"$\".\n \n    procedure Get_External_Name\n      (Entity     : Entity_Id;\n       Has_Suffix : Boolean);\n-   --  Set Name_Buffer and Name_Len to the external name of entity E.\n-   --  The external name is the Interface_Name, if specified, unless\n-   --  the entity has an address clause or a suffix.\n+   --  Set Name_Buffer and Name_Len to the external name of entity E. The\n+   --  external name is the Interface_Name, if specified, unless the entity\n+   --  has an address clause or a suffix.\n    --\n-   --  If the Interface is not present, or not used, the external name\n-   --  is the concatenation of:\n+   --  If the Interface is not present, or not used, the external name is the\n+   --  concatenation of:\n    --\n    --    - the string \"_ada_\", if the entity is a library subprogram,\n    --    - the names of any enclosing scopes, each followed by \"__\",\n@@ -441,9 +440,9 @@ package Exp_Dbug is\n    procedure Get_External_Name_With_Suffix\n      (Entity : Entity_Id;\n       Suffix : String);\n-   --  Set Name_Buffer and Name_Len to the external name of entity E.\n-   --  If Suffix is the empty string the external name is as above,\n-   --  otherwise the external name is the concatenation of:\n+   --  Set Name_Buffer and Name_Len to the external name of entity E. If\n+   --  Suffix is the empty string the external name is as above, otherwise\n+   --  the external name is the concatenation of:\n    --\n    --    - the string \"_ada_\", if the entity is a library subprogram,\n    --    - the names of any enclosing scopes, each followed by \"__\",\n@@ -483,33 +482,33 @@ package Exp_Dbug is\n    --  output of names for debugging purposes (which is why we are doing\n    --  the name changes in the first place.\n \n-   --  Note: the routines Get_Unqualified_[Decoded]_Name_String in Namet\n-   --  are useful to remove qualification from a name qualified by the\n-   --  call to Qualify_All_Entity_Names.\n+   --  Note: the routines Get_Unqualified_[Decoded]_Name_String in Namet are\n+   --  useful to remove qualification from a name qualified by the call to\n+   --  Qualify_All_Entity_Names.\n \n    --------------------------------\n    -- Handling of Numeric Values --\n    --------------------------------\n \n-   --  All numeric values here are encoded as strings of decimal digits.\n-   --  Only integer values need to be encoded. A negative value is encoded\n-   --  as the corresponding positive value followed by a lower case m for\n-   --  minus to indicate that the value is negative (e.g. 2m for -2).\n+   --  All numeric values here are encoded as strings of decimal digits. Only\n+   --  integer values need to be encoded. A negative value is encoded as the\n+   --  corresponding positive value followed by a lower case m for minus to\n+   --  indicate that the value is negative (e.g. 2m for -2).\n \n    -------------------------\n    -- Type Name Encodings --\n    -------------------------\n \n-   --  In the following typ is the name of the type as normally encoded by\n-   --  the debugger rules, i.e. a non-qualified name, all in lower case,\n-   --  with standard encoding of upper half and wide characters\n+   --  In the following typ is the name of the type as normally encoded by the\n+   --  debugger rules, i.e. a non-qualified name, all in lower case, with\n+   --  standard encoding of upper half and wide characters\n \n       ------------------------\n       -- Encapsulated Types --\n       ------------------------\n \n-      --  In some cases, the compiler encapsulates a type by wrapping it in\n-      --  a structure. For example, this is used when a size or alignment\n+      --  In some cases, the compiler encapsulates a type by wrapping it in a\n+      --  structure. For example, this is used when a size or alignment\n       --  specification requires a larger type. Consider:\n \n       --    type y is mod 2 ** 64;\n@@ -523,34 +522,34 @@ package Exp_Dbug is\n       --  a size of 256 for a signed integer value, then a typical choice is\n       --  to wrap a 64-bit integer in a 256 bit PAD structure.\n \n-      --  A similar encapsulation is done for some packed array types,\n-      --  in which case the structure type is y___JM and the field name\n-      --  is OBJECT. This is used in the case of a packed array stored\n-      --  in modular representation (see section on representation of\n-      --  packed array objects). In this case the JM wrapping is used to\n-      --  achieve correct positioning of the packed array value (left or\n-      --  right justified in its field depending on endianness.\n-\n-      --  When the debugger sees an object of a type whose name has a\n-      --  suffix of ___PAD or ___JM, the type will be a record containing\n-      --  a single field, and the name of that field will be all upper case.\n-      --  In this case, it should look inside to get the value of the inner\n-      --  field, and neither the outer structure name, nor the field name\n-      --  should appear when the value is printed.\n+      --  A similar encapsulation is done for some packed array types, in which\n+      --  case the structure type is y___JM and the field name is OBJECT.\n+      --  This is used in the case of a packed array stored using modular\n+      --  representation (see section on representation of packed array\n+      --  objects). In this case the JM wrapping is used to achieve correct\n+      --  positioning of the packed array value (left or right justified in its\n+      --  field depending on endianness.\n+\n+      --  When the debugger sees an object of a type whose name has a suffix of\n+      --  ___PAD or ___JM, the type will be a record containing a single field,\n+      --  and the name of that field will be all upper case. In this case, it\n+      --  should look inside to get the value of the inner field, and neither\n+      --  the outer structure name, nor the field name should appear when the\n+      --  value is printed.\n \n       --  When the debugger sees a record named REP being a field inside\n-      --  another record, it should treat the fields inside REP as being\n-      --  part of the outer record (this REP field is only present for\n-      --  code generation purposes). The REP record should not appear in\n-      --  the values printed by the debugger.\n+      --  another record, it should treat the fields inside REP as being part\n+      --  of the outer record (this REP field is only present for code\n+      --  generation purposes). The REP record should not appear in the values\n+      --  printed by the debugger.\n \n       -----------------------\n       -- Fixed-Point Types --\n       -----------------------\n \n       --   Fixed-point types are encoded using a suffix that indicates the\n-      --   delta and small values. The actual type itself is a normal\n-      --   integer type.\n+      --   delta and small values. The actual type itself is a normal integer\n+      --   type.\n \n       --     typ___XF_nn_dd\n       --     typ___XF_nn_dd_nn_dd\n@@ -576,9 +575,9 @@ package Exp_Dbug is\n       --     typ___XFG\n \n       --   representing the Vax F Float, D Float, and G Float types. The\n-      --   debugger must treat these specially. In particular, printing\n-      --   these values can be achieved using the debug procedures that\n-      --   are provided in package System.Vax_Float_Operations:\n+      --   debugger must treat these specially. In particular, printing these\n+      --   values can be achieved using the debug procedures that are provided\n+      --   in package System.Vax_Float_Operations:\n \n       --     procedure Debug_Output_D (Arg : D);\n       --     procedure Debug_Output_F (Arg : F);\n@@ -592,17 +591,15 @@ package Exp_Dbug is\n       -- Discrete Types --\n       --------------------\n \n-      --   Discrete types are coded with a suffix indicating the range in\n-      --   the case where one or both of the bounds are discriminants or\n-      --   variable.\n+      --   Discrete types are coded with a suffix indicating the range in the\n+      --   case where one or both of the bounds are discriminants or variable.\n \n-      --   Note: at the current time, we also encode compile time known\n-      --   bounds if they do not match the natural machine type bounds,\n-      --   but this may be removed in the future, since it is redundant\n-      --   for most debugging formats. However, we do not ever need XD\n-      --   encoding for enumeration base types, since here it is always\n-      --   clear what the bounds are from the total number of enumeration\n-      --   literals.\n+      --   Note: at the current time, we also encode compile time known bounds\n+      --   if they do not match the natural machine type bounds, but this may\n+      --   be removed in the future, since it is redundant for most debugging\n+      --   formats. However, we do not ever need XD encoding for enumeration\n+      --   base types, since here it is always clear what the bounds are from\n+      --   the total number of enumeration literals.\n \n       --     typ___XD\n       --     typ___XDL_lowerbound\n@@ -615,27 +612,26 @@ package Exp_Dbug is\n       --   constrained range that does not correspond to the size or that\n       --   has discriminant references or other compile time known bounds.\n \n-      --   The first form is used if both bounds are dynamic, in which case\n-      --   two constant objects are present whose names are typ___L and\n-      --   typ___U in the same scope as typ, and the values of these constants\n-      --   indicate the bounds. As far as the debugger is concerned, these\n-      --   are simply variables that can be accessed like any other variables.\n-      --   In the enumeration case, these values correspond to the Enum_Rep\n-      --   values for the lower and upper bounds.\n-\n-      --   The second form is used if the upper bound is dynamic, but the\n-      --   lower bound is either constant or depends on a discriminant of\n-      --   the record with which the type is associated. The upper bound\n-      --   is stored in a constant object of name typ___U as previously\n-      --   described, but the lower bound is encoded directly into the\n-      --   name as either a decimal integer, or as the discriminant name.\n-\n-      --   The third form is similarly used if the lower bound is dynamic,\n-      --   but the upper bound is compile time known or a discriminant\n-      --   reference, in which case the lower bound is stored in a constant\n-      --   object of name typ___L, and the upper bound is encoded directly\n-      --   into the name as either a decimal integer, or as the discriminant\n-      --   name.\n+      --   The first form is used if both bounds are dynamic, in which case two\n+      --   constant objects are present whose names are typ___L and typ___U in\n+      --   the same scope as typ, and the values of these constants indicate\n+      --   the bounds. As far as the debugger is concerned, these are simply\n+      --   variables that can be accessed like any other variables. In the\n+      --   enumeration case, these values correspond to the Enum_Rep values for\n+      --   the lower and upper bounds.\n+\n+      --   The second form is used if the upper bound is dynamic, but the lower\n+      --   bound is either constant or depends on a discriminant of the record\n+      --   with which the type is associated. The upper bound is stored in a\n+      --   constant object of name typ___U as previously described, but the\n+      --   lower bound is encoded directly into the name as either a decimal\n+      --   integer, or as the discriminant name.\n+\n+      --   The third form is similarly used if the lower bound is dynamic, but\n+      --   the upper bound is compile time known or a discriminant reference,\n+      --   in which case the lower bound is stored in a constant object of name\n+      --   typ___L, and the upper bound is encoded directly into the name as\n+      --   either a decimal integer, or as the discriminant name.\n \n       --   The fourth form is used if both bounds are discriminant references\n       --   or compile time known values, with the encoding first for the lower\n@@ -650,9 +646,9 @@ package Exp_Dbug is\n       --    type x is mod N;\n \n       --  Is encoded as a subrange of an unsigned base type with lower bound\n-      --  0 and upper bound N. That is, there is no name encoding. We use\n-      --  the standard encodings provided by the debugging format. Thus\n-      --  we give these types a non-standard interpretation: the standard\n+      --  zero and upper bound N. That is, there is no name encoding. We use\n+      --  the standard encodings provided by the debugging format. Thus we\n+      --  give these types a non-standard interpretation: the standard\n       --  interpretation of our encoding would not, in general, imply that\n       --  arithmetic on type x was to be performed modulo N (especially not\n       --  when N is not a power of 2).\n@@ -661,23 +657,22 @@ package Exp_Dbug is\n       -- Biased Types --\n       ------------------\n \n-      --   Only discrete types can be biased, and the fact that they are\n-      --   biased is indicated by a suffix of the form:\n+      --   Only discrete types can be biased, and the fact that they are biased\n+      --   is indicated by a suffix of the form:\n \n       --     typ___XB_lowerbound__upperbound\n \n-      --   Here lowerbound and upperbound are decimal integers, with the\n-      --   usual (postfix \"m\") encoding for negative numbers. Biased\n-      --   types are only possible where the bounds are compile time\n-      --   known, and the values are represented as unsigned offsets\n-      --   from the lower bound given. For example:\n+      --   Here lowerbound and upperbound are decimal integers, with the usual\n+      --   (postfix \"m\") encoding for negative numbers. Biased types are only\n+      --   possible where the bounds are compile time known, and the values are\n+      --   represented as unsigned offsets from the lower bound given. For\n+      --   example:\n \n       --     type Q is range 10 .. 15;\n       --     for Q'size use 3;\n \n-      --   The size clause will force values of type Q in memory to be\n-      --   stored in biased form (e.g. 11 will be represented by the\n-      --   bit pattern 001).\n+      --   The size clause will force values of type Q in memory to be stored\n+      --   in biased form (e.g. 11 will be represented by the bit pattern 001).\n \n       ----------------------------------------------\n       -- Record Types with Variable-Length Fields --\n@@ -692,10 +687,10 @@ package Exp_Dbug is\n       --    type___XVU\n \n       --  The former name is used for a record and the latter for the union\n-      --  that is made for a variant record (see below) if that record or\n-      --  union has a field of variable size or if the record or union itself\n-      --  has a variable size. These encodings suffix any other encodings that\n-      --  that might be suffixed to the type name.\n+      --  that is made for a variant record (see below) if that record or union\n+      --  has a field of variable size or if the record or union itself has a\n+      --  variable size. These encodings suffix any other encodings that that\n+      --  might be suffixed to the type name.\n \n       --  The idea here is to provide all the needed information to interpret\n       --  objects of the original type in the form of a \"fixed up\" type, which\n@@ -706,23 +701,22 @@ package Exp_Dbug is\n       --  To deal with this, we encode *all* the field bit positions of the\n       --  special ___XV type in a non-standard manner.\n \n-      --  The idea is to encode not the position, but rather information\n-      --  that allows computing the position of a field from the position\n-      --  of the previous field. The algorithm for computing the actual\n-      --  positions of all fields and the length of the record is as\n-      --  follows. In this description, let P represent the current\n-      --  bit position in the record.\n+      --  The idea is to encode not the position, but rather information that\n+      --  allows computing the position of a field from the position of the\n+      --  previous field. The algorithm for computing the actual positions of\n+      --  all fields and the length of the record is as follows. In this\n+      --  description, let P represent the current bit position in the record.\n \n       --    1. Initialize P to 0\n \n       --    2. For each field in the record:\n \n-      --       2a. If an alignment is given (see below), then round P\n-      --       up, if needed, to the next multiple of that alignment.\n+      --       2a. If an alignment is given (see below), then round P up, if\n+      --       needed, to the next multiple of that alignment.\n \n-      --       2b. If a bit position is given, then increment P by that\n-      --       amount (that is, treat it as an offset from the end of the\n-      --       preceding record).\n+      --       2b. If a bit position is given, then increment P by that amount\n+      --       (that is, treat it as an offset from the end of the preceding\n+      --       record).\n \n       --       2c. Assign P as the actual position of the field\n \n@@ -738,15 +732,15 @@ package Exp_Dbug is\n       --  where the nn after the XVA indicates the alignment value in storage\n       --  units. This encoding is present only if an alignment is present.\n \n-      --  The size of the record described by an XVE-encoded type (in bits)\n-      --  is generally the maximum value attained by P' in step 2d above,\n-      --  rounded up according to the record's alignment.\n+      --  The size of the record described by an XVE-encoded type (in bits) is\n+      --  generally the maximum value attained by P' in step 2d above, rounded\n+      --  up according to the record's alignment.\n \n       --  Second, the variable-length fields themselves are represented by\n-      --  replacing the type by a special access type. The designated type\n-      --  of this access type is the original variable-length type, and the\n-      --  fact that this field has been transformed in this way is signalled\n-      --  by encoding the field name as:\n+      --  replacing the type by a special access type. The designated type of\n+      --  this access type is the original variable-length type, and the fact\n+      --  that this field has been transformed in this way is signalled by\n+      --  encoding the field name as:\n \n       --    field___XVL\n \n@@ -757,24 +751,24 @@ package Exp_Dbug is\n       --    field___XVLnn\n \n       --  Note: the reason that we change the type is so that the resulting\n-      --  type has no variable-length fields. At least some of the formats\n-      --  used for debugging information simply cannot tolerate variable-\n-      --  length fields, so the encoded information would get lost.\n-\n-      --  Third, in the case of a variant record, the special union\n-      --  that contains the variants is replaced by a normal C union.\n-      --  In this case, the positions are all zero.\n-\n-      --  Discriminants appear before any variable-length fields that depend\n-      --  on them, with one exception. In some cases, a discriminant\n-      --  governing the choice of a variant clause may appear in the list\n-      --  of fields of an XVE type after the entry for the variant clause\n-      --  itself (this can happen in the presence of a representation clause\n-      --  for the record type in the source program). However, when this\n-      --  happens, the discriminant's position may be determined by first\n-      --  applying the rules described in this section, ignoring the variant\n-      --  clause. As a result, discriminants can always be located\n-      --  independently of the variable-length fields that depend on them.\n+      --  type has no variable-length fields. At least some of the formats used\n+      --  for debugging information simply cannot tolerate variable- length\n+      --  fields, so the encoded information would get lost.\n+\n+      --  Third, in the case of a variant record, the special union that\n+      --  contains the variants is replaced by a normal C union. In this case,\n+      --  the positions are all zero.\n+\n+      --  Discriminants appear before any variable-length fields that depend on\n+      --  them, with one exception. In some cases, a discriminant governing the\n+      --  choice of a variant clause may appear in the list of fields of an XVE\n+      --  type after the entry for the variant clause itself (this can happen\n+      --  in the presence of a representation clause for the record type in the\n+      --  source program). However, when this happens, the discriminant's\n+      --  position may be determined by first applying the rules described in\n+      --  this section, ignoring the variant clause. As a result, discriminants\n+      --  can always be located independently of the variable-length fields\n+      --  that depend on them.\n \n       --  The size of the ___XVE or ___XVU record or union is set to the\n       --  alignment (in bytes) of the original object so that the debugger\n@@ -815,20 +809,18 @@ package Exp_Dbug is\n \n       --  Notes:\n \n-      --  1) The B field could also have been encoded by using a position\n-      --  of zero, and an alignment of 4, but in such a case, the coding by\n-      --  position is preferred (since it takes up less space). We have used\n-      --  the (illegal) notation access xxx as field types in the example\n-      --  above.\n+      --  1) The B field could also have been encoded by using a position of\n+      --  zero and an alignment of 4, but in such a case the coding by position\n+      --  is preferred (since it takes up less space). We have used the\n+      --  (illegal) notation access xxx as field types in the example above.\n \n-      --  2) The E field does not actually need the alignment indication\n-      --  but this may not be detected in this case by the conversion\n-      --  routines.\n+      --  2) The E field does not actually need the alignment indication but\n+      --  this may not be detected in this case by the conversion routines.\n \n       --  3) Our conventions do not cover all XVE-encoded records in which\n-      --  some, but not all, fields have representation clauses. Such\n-      --  records may, therefore, be displayed incorrectly by debuggers.\n-      --  This situation is not common.\n+      --  some, but not all, fields have representation clauses. Such records\n+      --  may, therefore, be displayed incorrectly by debuggers. This situation\n+      --  is not common.\n \n       -----------------------\n       -- Base Record Types --\n@@ -853,7 +845,7 @@ package Exp_Dbug is\n       --  The size of the objects typed as x should be obtained from the\n       --  structure of x (and x___XVE, if applicable) as for ordinary types\n       --  unless there is a variable named x___XVZ, which, if present, will\n-      --  hold the size (in bytes) of x; in this latter case, the size of the\n+      --  hold the size (in bytes) of x. In this latter case, the size of the\n       --  x___XVS type will not be a constant but a reference to x___XVZ.\n \n       --  The type x will either be a subtype of y (see also Subtypes of\n@@ -965,8 +957,8 @@ package Exp_Dbug is\n    -- Renaming --\n    --------------\n \n-   --  Debugging information is generated for exception, object, package,\n-   --  and subprogram renaming (generic renamings are not significant, since\n+   --  Debugging information is generated for exception, object, package, and\n+   --  subprogram renaming (generic renamings are not significant, since\n    --  generic templates are not relevant at debugging time).\n \n    --  Consider a renaming declaration of the form\n@@ -997,8 +989,8 @@ package Exp_Dbug is\n \n    --  Note: subprogram renamings are not encoded at the present time\n \n-   --  The suffix of the variable name describing the renamed object is\n-   --  defined to use the following encoding:\n+   --  The suffix of the variable name describing the renamed object is defined\n+   --  to use the following encoding:\n \n    --    For the simple entity case, where y is just an entity name, the suffix\n    --    is of the form:\n@@ -1099,13 +1091,13 @@ package Exp_Dbug is\n    --  For every constrained packed array, two types are created, and both\n    --  appear in the debugging output:\n \n-   --    The original declared array type is a perfectly normal array type,\n-   --    and its index bounds indicate the original bounds of the array.\n+   --    The original declared array type is a perfectly normal array type, and\n+   --    its index bounds indicate the original bounds of the array.\n \n    --    The corresponding packed array type, which may be a modular type, or\n-   --    may be an array of bytes type (see Exp_Pakd for full details). This\n-   --    is the type that is actually used in the generated code and for\n-   --    debugging information for all objects of the packed type.\n+   --    may be an array of bytes type (see Exp_Pakd for full details). This is\n+   --    the type that is actually used in the generated code and for debugging\n+   --    information for all objects of the packed type.\n \n    --  The name of the corresponding packed array type is:\n \n@@ -1138,16 +1130,16 @@ package Exp_Dbug is\n    -- Packed Array Representation in Memory --\n    -------------------------------------------\n \n-   --  Packed arrays are represented in tightly packed form, with no extra\n-   --  bits between components. This is true even when the component size\n-   --  is not a factor of the storage unit size, so that as a result it is\n-   --  possible for components to cross storage unit boundaries.\n+   --  Packed arrays are represented in tightly packed form, with no extra bits\n+   --  between components. This is true even when the component size is not a\n+   --  factor of the storage unit size, so that as a result it is possible for\n+   --  components to cross storage unit boundaries.\n \n    --  The layout in storage is identical, regardless of whether the\n-   --  implementation type is a modular type or an array-of-bytes type.\n-   --  See Exp_Pakd for details of how these implementation types are used,\n-   --  but for the purpose of the debugger, only the starting address of\n-   --  the object in memory is significant.\n+   --  implementation type is a modular type or an array-of-bytes type. See\n+   --  Exp_Pakd for details of how these implementation types are used, but for\n+   --  the purpose of the debugger, only the starting address of the object in\n+   --  memory is significant.\n \n    --  The following example should show clearly how the packing works in\n    --  the little-endian and big-endian cases:\n@@ -1187,8 +1179,8 @@ package Exp_Dbug is\n    --  For example, in the normal modular case, if we have a 6-bit modular\n    --  type, declared as mod 2**6, and we allocate an 8-bit object for this\n    --  type, then we extend the value with two bits on the most significant\n-   --  end, and in either the little-endian or big-endian case, the value 63 is\n-   --  represented as 00111111 in binary in memory.\n+   --  end, and in either the little-endian or big-endian case, the value 63\n+   --  is represented as 00111111 in binary in memory.\n \n    --  For a modular type used to represent a packed array, the rule is\n    --  different. In this case, if we have to extend the value, then we do it\n@@ -1225,11 +1217,11 @@ package Exp_Dbug is\n    --  However, in the equality case, it is important to ensure that the\n    --  undefined bits do not participate in an equality test.\n \n-   --  If a modular packed array value is assigned to a register, then\n-   --  logically it could always be held right justified, to avoid any need to\n-   --  shift, e.g. when doing comparisons. But probably this is a bad choice,\n-   --  as it would mean that an assignment such as a := above would require\n-   --  shifts when one value is in a register and the other value is in memory.\n+   --  If a modular packed array value is assigned to a register then logically\n+   --  it could always be held right justified, to avoid any need to shift,\n+   --  e.g. when doing comparisons. But probably this is a bad choice, as it\n+   --  would mean that an assignment such as a := above would require shifts\n+   --  when one value is in a register and the other value is in memory.\n \n    ------------------------------------------------------\n    -- Subprograms for Handling Packed Array Type Names --"}, {"sha": "9ecca31dde14492deb3a6033ed56717c60ef0547", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -6311,16 +6311,13 @@ package body Exp_Disp is\n       Set_Related_Type (DT_Ptr, Typ);\n \n       --  For CPP types there is no need to build the dispatch tables since\n-      --  they are imported from the C++ side. If the CPP type has an IP\n-      --  then we declare now the variable that will store the copy of the\n-      --  C++ tag. If the CPP type is an interface, we need the variable as\n-      --  well, because it becomes the pointer to the corresponding secondary\n-      --  table.\n+      --  they are imported from the C++ side. If the CPP type has an IP then\n+      --  we declare now the variable that will store the copy of the C++ tag.\n+      --  If the CPP type is an interface, we need the variable as well,\n+      --  because it becomes the pointer to the corresponding secondary table.\n \n       if Is_CPP_Class (Typ) then\n-         if Has_CPP_Constructors (Typ)\n-           or else Is_Interface (Typ)\n-         then\n+         if Has_CPP_Constructors (Typ) or else Is_Interface (Typ) then\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT_Ptr,"}, {"sha": "24b94af224983142edbbef9b36e4e2c790eb1cb8", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8cc3e468eda458c6bc0a618c5179af582e99e00/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=a8cc3e468eda458c6bc0a618c5179af582e99e00", "patch": "@@ -395,6 +395,7 @@ package body Impunit is\n      \"a-envvar\",    -- Ada.Environment_Variables\n      \"a-exetim\",    -- Ada.Execution_Time\n      \"a-extiti\",    -- Ada.Execution_Time.Timers\n+     \"a-izteio\",    -- Ada.Integer_Wide_Wide_TextIO;\n      \"a-rttiev\",    -- Ada.Real_Time.Timing_Events\n      \"a-ngcoar\",    -- Ada.Numerics.Generic_Complex_Arrays\n      \"a-ngrear\",    -- Ada.Numerics.Generic_Real_Arrays"}]}