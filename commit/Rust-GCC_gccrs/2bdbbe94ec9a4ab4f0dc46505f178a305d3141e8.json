{"sha": "2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJkYmJlOTRlYzlhNGFiNGYwZGM0NjUwNWYxNzhhMzA1ZDMxNDFlOA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-12-03T13:36:32Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-12-03T13:36:32Z"}, "message": "re PR middle-end/38474 (compile time explosion in dataflow_set_preserve_mem_locs at -O3)\n\n\tPR middle-end/38474\n\t* cfgexpand.c (struct stack_var): Add conflicts member.\n\t(stack_vars_conflict, stack_vars_conflict_alloc,\n\tn_stack_vars_conflict): Remove.\n\t(add_stack_var): Initialize conflicts member.\n\t(triangular_index, resize_stack_vars_conflict): Remove.\n\t(add_stack_var_conflict, stack_var_conflict_p): Rewrite in\n\tterms of new member.\n\t(union_stack_vars): Only run over the conflicts.\n\t(partition_stack_vars): Remove special case.\n\t(expand_used_vars_for_block): Don't call resize_stack_vars_conflict,\n\tdon't create self-conflicts.\n\t(account_used_vars_for_block): Don't create any conflicts.\n\t(fini_vars_expansion): Free bitmaps, don't free or clear removed\n\tglobals.\n\nFrom-SVN: r154945", "tree": {"sha": "d288db8143cfdd1b8a0c63884deaa6c39b1863ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d288db8143cfdd1b8a0c63884deaa6c39b1863ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8/comments", "author": null, "committer": null, "parents": [{"sha": "1f92467594e21b64452a0718defc523f7fa3f2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f92467594e21b64452a0718defc523f7fa3f2b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f92467594e21b64452a0718defc523f7fa3f2b7"}], "stats": {"total": 155, "additions": 59, "deletions": 96}, "files": [{"sha": "0c99c6e24078a2c8cc92f88f9ed130282f108c1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "patch": "@@ -1,3 +1,21 @@\n+2009-12-03  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/38474\n+\t* cfgexpand.c (struct stack_var): Add conflicts member.\n+\t(stack_vars_conflict, stack_vars_conflict_alloc,\n+\tn_stack_vars_conflict): Remove.\n+\t(add_stack_var): Initialize conflicts member.\n+\t(triangular_index, resize_stack_vars_conflict): Remove.\n+\t(add_stack_var_conflict, stack_var_conflict_p): Rewrite in\n+\tterms of new member.\n+\t(union_stack_vars): Only run over the conflicts.\n+\t(partition_stack_vars): Remove special case.\n+\t(expand_used_vars_for_block): Don't call resize_stack_vars_conflict,\n+\tdon't create self-conflicts.\n+\t(account_used_vars_for_block): Don't create any conflicts.\n+\t(fini_vars_expansion): Free bitmaps, don't free or clear removed\n+\tglobals.\n+\n 2009-12-03  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tPR middle-end/42202\n@@ -10,14 +28,14 @@\n \n 2009-12-03  Ken Werner  <ken.werner@de.ibm.com>\n \n-        * config/spu/spu-elf.h (STARTFILE_SPEC): Add support for gprof\n-        startup files.\n-        * config/spu/spu-protos.h (spu_function_profiler): Add prototype.\n-        * config/spu/spu.c (spu_function_profiler): New function.\n-        * config/spu/spu.h (FUNCTION_PROFILER): Invoke\n-        spu_function_profiler.\n-        (NO_PROFILE_COUNTERS): Define.\n-        (PROFILE_BEFORE_PROLOGUE): Likewise.\n+\t* config/spu/spu-elf.h (STARTFILE_SPEC): Add support for gprof\n+\tstartup files.\n+\t* config/spu/spu-protos.h (spu_function_profiler): Add prototype.\n+\t* config/spu/spu.c (spu_function_profiler): New function.\n+\t* config/spu/spu.h (FUNCTION_PROFILER): Invoke\n+\tspu_function_profiler.\n+\t(NO_PROFILE_COUNTERS): Define.\n+\t(PROFILE_BEFORE_PROLOGUE): Likewise.\n \n 2009-12-03  Dave Korn  <dave.korn.cygwin@gmail.com>\n "}, {"sha": "4245d0f7a7f40d249b999397fcdff30e892f3e99", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 33, "deletions": 88, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2bdbbe94ec9a4ab4f0dc46505f178a305d3141e8", "patch": "@@ -200,6 +200,9 @@ struct stack_var\n \n   /* The next stack variable in the partition, or EOC.  */\n   size_t next;\n+\n+  /* The numbers of conflicting stack variables.  */\n+  bitmap conflicts;\n };\n \n #define EOC  ((size_t)-1)\n@@ -213,12 +216,6 @@ static size_t stack_vars_num;\n    is non-decreasing.  */\n static size_t *stack_vars_sorted;\n \n-/* We have an interference graph between such objects.  This graph\n-   is lower triangular.  */\n-static bool *stack_vars_conflict;\n-static size_t stack_vars_conflict_alloc;\n-static size_t n_stack_vars_conflict;\n-\n /* The phase of the stack frame.  This is the known misalignment of\n    virtual_stack_vars_rtx from PREFERRED_STACK_BOUNDARY.  That is,\n    (frame_offset+frame_phase) % PREFERRED_STACK_BOUNDARY == 0.  */\n@@ -320,68 +317,40 @@ add_stack_var (tree decl)\n   stack_vars[stack_vars_num].representative = stack_vars_num;\n   stack_vars[stack_vars_num].next = EOC;\n \n+  /* All variables initially conflict with no other.  */\n+  stack_vars[stack_vars_num].conflicts = NULL;\n+\n   /* Ensure that this decl doesn't get put onto the list twice.  */\n   set_rtl (decl, pc_rtx);\n \n   stack_vars_num++;\n }\n \n-/* Compute the linear index of a lower-triangular coordinate (I, J).  */\n-\n-static size_t\n-triangular_index (size_t i, size_t j)\n-{\n-  if (i < j)\n-    {\n-      size_t t;\n-      t = i, i = j, j = t;\n-    }\n-\n-  if (i & 1)\n-    return ((i + 1) / 2) * i + j;\n-  else\n-    return (i / 2) * (i + 1) + j;\n-}\n-\n-/* Ensure that STACK_VARS_CONFLICT is large enough for N objects.  */\n-\n-static void\n-resize_stack_vars_conflict (size_t n)\n-{\n-  size_t size = triangular_index (n-1, n-1) + 1;\n-\n-  if (size <= stack_vars_conflict_alloc)\n-    {\n-      if (n > n_stack_vars_conflict)\n-\tfatal_error (\"program is too large to be compiled on this machine\");\n-      return;\n-    }\n-\n-  stack_vars_conflict = XRESIZEVEC (bool, stack_vars_conflict, size);\n-  memset (stack_vars_conflict + stack_vars_conflict_alloc, 0,\n-\t  (size - stack_vars_conflict_alloc) * sizeof (bool));\n-  stack_vars_conflict_alloc = size;\n-  n_stack_vars_conflict = n;\n-}\n-\n /* Make the decls associated with luid's X and Y conflict.  */\n \n static void\n add_stack_var_conflict (size_t x, size_t y)\n {\n-  size_t index = triangular_index (x, y);\n-  gcc_assert (index < stack_vars_conflict_alloc);\n-  stack_vars_conflict[index] = true;\n+  struct stack_var *a = &stack_vars[x];\n+  struct stack_var *b = &stack_vars[y];\n+  if (!a->conflicts)\n+    a->conflicts = BITMAP_ALLOC (NULL);\n+  if (!b->conflicts)\n+    b->conflicts = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (a->conflicts, y);\n+  bitmap_set_bit (b->conflicts, x);\n }\n \n /* Check whether the decls associated with luid's X and Y conflict.  */\n \n static bool\n stack_var_conflict_p (size_t x, size_t y)\n {\n-  size_t index = triangular_index (x, y);\n-  gcc_assert (index < stack_vars_conflict_alloc);\n-  return stack_vars_conflict[index];\n+  struct stack_var *a = &stack_vars[x];\n+  struct stack_var *b = &stack_vars[y];\n+  if (!a->conflicts || !b->conflicts)\n+    return false;\n+  return bitmap_bit_p (a->conflicts, y);\n }\n \n /* Returns true if TYPE is or contains a union type.  */\n@@ -626,6 +595,9 @@ static void\n union_stack_vars (size_t a, size_t b, HOST_WIDE_INT offset)\n {\n   size_t i, last;\n+  struct stack_var *vb = &stack_vars[b];\n+  bitmap_iterator bi;\n+  unsigned u;\n \n   /* Update each element of partition B with the given offset,\n      and merge them into partition A.  */\n@@ -642,9 +614,12 @@ union_stack_vars (size_t a, size_t b, HOST_WIDE_INT offset)\n     stack_vars[a].alignb = stack_vars[b].alignb;\n \n   /* Update the interference graph and merge the conflicts.  */\n-  for (last = stack_vars_num, i = 0; i < last; ++i)\n-    if (stack_var_conflict_p (b, i))\n-      add_stack_var_conflict (a, i);\n+  if (vb->conflicts)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (vb->conflicts, 0, u, bi)\n+\tadd_stack_var_conflict (a, stack_vars[u].representative);\n+      BITMAP_FREE (vb->conflicts);\n+    }\n }\n \n /* A subroutine of expand_used_vars.  Binpack the variables into\n@@ -679,15 +654,6 @@ partition_stack_vars (void)\n \n   qsort (stack_vars_sorted, n, sizeof (size_t), stack_var_size_cmp);\n \n-  /* Special case: detect when all variables conflict, and thus we can't\n-     do anything during the partitioning loop.  It isn't uncommon (with\n-     C code at least) to declare all variables at the top of the function,\n-     and if we're not inlining, then all variables will be in the same scope.\n-     Take advantage of very fast libc routines for this scan.  */\n-  gcc_assert (sizeof(bool) == sizeof(char));\n-  if (memchr (stack_vars_conflict, false, stack_vars_conflict_alloc) == NULL)\n-    return;\n-\n   for (si = 0; si < n; ++si)\n     {\n       size_t i = stack_vars_sorted[si];\n@@ -1084,15 +1050,13 @@ expand_used_vars_for_block (tree block, bool toplevel)\n   /* Since we do not track exact variable lifetimes (which is not even\n      possible for variables whose address escapes), we mirror the block\n      tree in the interference graph.  Here we cause all variables at this\n-     level, and all sublevels, to conflict.  Do make certain that a\n-     variable conflicts with itself.  */\n+     level, and all sublevels, to conflict.  */\n   if (old_sv_num < this_sv_num)\n     {\n       new_sv_num = stack_vars_num;\n-      resize_stack_vars_conflict (new_sv_num);\n \n       for (i = old_sv_num; i < new_sv_num; ++i)\n-\tfor (j = i < this_sv_num ? i+1 : this_sv_num; j-- > old_sv_num ;)\n+\tfor (j = i < this_sv_num ? i : this_sv_num; j-- > old_sv_num ;)\n \t  add_stack_var_conflict (i, j);\n     }\n }\n@@ -1260,37 +1224,18 @@ create_stack_guard (void)\n static HOST_WIDE_INT\n account_used_vars_for_block (tree block, bool toplevel)\n {\n-  size_t i, j, old_sv_num, this_sv_num, new_sv_num;\n   tree t;\n   HOST_WIDE_INT size = 0;\n \n-  old_sv_num = toplevel ? 0 : stack_vars_num;\n-\n   /* Expand all variables at this level.  */\n   for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n     if (TREE_USED (t))\n       size += expand_one_var (t, toplevel, false);\n \n-  this_sv_num = stack_vars_num;\n-\n   /* Expand all variables at containing levels.  */\n   for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n     size += account_used_vars_for_block (t, false);\n \n-  /* Since we do not track exact variable lifetimes (which is not even\n-     possible for variables whose address escapes), we mirror the block\n-     tree in the interference graph.  Here we cause all variables at this\n-     level, and all sublevels, to conflict.  Do make certain that a\n-     variable conflicts with itself.  */\n-  if (old_sv_num < this_sv_num)\n-    {\n-      new_sv_num = stack_vars_num;\n-      resize_stack_vars_conflict (new_sv_num);\n-\n-      for (i = old_sv_num; i < new_sv_num; ++i)\n-\tfor (j = i < this_sv_num ? i+1 : this_sv_num; j-- > old_sv_num ;)\n-\t  add_stack_var_conflict (i, j);\n-    }\n   return size;\n }\n \n@@ -1315,13 +1260,13 @@ init_vars_expansion (void)\n static void\n fini_vars_expansion (void)\n {\n+  size_t i, n = stack_vars_num;\n+  for (i = 0; i < n; i++)\n+    BITMAP_FREE (stack_vars[i].conflicts);\n   XDELETEVEC (stack_vars);\n   XDELETEVEC (stack_vars_sorted);\n-  XDELETEVEC (stack_vars_conflict);\n   stack_vars = NULL;\n   stack_vars_alloc = stack_vars_num = 0;\n-  stack_vars_conflict = NULL;\n-  stack_vars_conflict_alloc = 0;\n }\n \n /* Make a fair guess for the size of the stack frame of the current"}]}