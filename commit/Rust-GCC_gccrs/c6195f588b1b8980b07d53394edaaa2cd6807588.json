{"sha": "c6195f588b1b8980b07d53394edaaa2cd6807588", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYxOTVmNTg4YjFiODk4MGIwN2Q1MzM5NGVkYWFhMmNkNjgwNzU4OA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-09-24T19:55:35Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-09-24T19:55:35Z"}, "message": "re PR libstdc++/29988 (More stl_tree.h enhancements: improving operator=)\n\n2014-09-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/29988\n\t* include/bits/stl_tree.h (_Rb_tree_reuse_or_alloc_node<>): New.\n\t(_Rb_tree_alloc_node<>): New.\n\t(_Rb_tree<>::operator=(_Rb_tree<>&&)): New.\n\t(_Rb_tree<>::_M_assign_unique): New.\n\t(_Rb_tree<>::_M_assign_equal): New.\n\t(_Rb_tree<>): Adapt to reuse allocated nodes as much as possible.\n\t* include/bits/stl_map.h\n\t(std::map<>::operator=(std::map<>&&)): Default implementation.\n\t(std::map<>::operator=(initializer_list<>)): Adapt to use\n\t_Rb_tree::_M_assign_unique.\n\t* include/bits/stl_multimap.h\n\t(std::multimap<>::operator=(std::multimap<>&&)): Default implementation.\n\t(std::multimap<>::operator=(initializer_list<>)): Adapt to use\n\t_Rb_tree::_M_assign_equal.\n\t* include/bits/stl_set.h\n\t(std::set<>::operator=(std::set<>&&)): Default implementation.\n\t(std::set<>::operator=(initializer_list<>)): Adapt to use\n\t_Rb_tree::_M_assign_unique.\n\t* include/bits/stl_multiset.h\n\t(std::multiset<>::operator=(std::multiset<>&&)): Default implementation.\n\t(std::multiset<>::operator=(initializer_list<>)): Adapt to use\n\t_Rb_tree::_M_assign_equal.\n\t* testsuite/23_containers/map/allocator/copy_assign.cc (test03): New.\n\t* testsuite/23_containers/map/allocator/init-list.cc: New.\n\t* testsuite/23_containers/map/allocator/move_assign.cc (test03): New.\n\t* testsuite/23_containers/multimap/allocator/copy_assign.cc\n\t(test03): New.\n\t* testsuite/23_containers/multimap/allocator/init-list.cc: New.\n\t* testsuite/23_containers/multimap/allocator/move_assign.cc\n\t(test03): New.\n\t* testsuite/23_containers/multiset/allocator/copy_assign.cc\n\t(test03): New.\n\t* testsuite/23_containers/multiset/allocator/init-list.cc: New.\n\t* testsuite/23_containers/multiset/allocator/move_assign.cc\n\t(test03): New.\n\t* testsuite/23_containers/set/allocator/copy_assign.cc (test03): New.\n\t* testsuite/23_containers/set/allocator/init-list.cc: New.\n\t* testsuite/23_containers/set/allocator/move_assign.cc (test03): New.\n\nFrom-SVN: r215568", "tree": {"sha": "6ac18352bbabea764bd719c371cf8c3175164ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ac18352bbabea764bd719c371cf8c3175164ef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6195f588b1b8980b07d53394edaaa2cd6807588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6195f588b1b8980b07d53394edaaa2cd6807588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6195f588b1b8980b07d53394edaaa2cd6807588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6195f588b1b8980b07d53394edaaa2cd6807588/comments", "author": null, "committer": null, "parents": [{"sha": "00de328a7ac2c812c0ea4f12c44fbd8d71028b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00de328a7ac2c812c0ea4f12c44fbd8d71028b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00de328a7ac2c812c0ea4f12c44fbd8d71028b91"}], "stats": {"total": 1136, "additions": 897, "deletions": 239}, "files": [{"sha": "630b116f33fbebdf5d6fe38e773a7a482b071b16", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -1,3 +1,45 @@\n+2014-09-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/29988\n+\t* include/bits/stl_tree.h (_Rb_tree_reuse_or_alloc_node<>): New.\n+\t(_Rb_tree_alloc_node<>): New.\n+\t(_Rb_tree<>::operator=(_Rb_tree<>&&)): New.\n+\t(_Rb_tree<>::_M_assign_unique): New.\n+\t(_Rb_tree<>::_M_assign_equal): New.\n+\t(_Rb_tree<>): Adapt to reuse allocated nodes as much as possible.\n+\t* include/bits/stl_map.h\n+\t(std::map<>::operator=(std::map<>&&)): Default implementation.\n+\t(std::map<>::operator=(initializer_list<>)): Adapt to use\n+\t_Rb_tree::_M_assign_unique.\n+\t* include/bits/stl_multimap.h\n+\t(std::multimap<>::operator=(std::multimap<>&&)): Default implementation.\n+\t(std::multimap<>::operator=(initializer_list<>)): Adapt to use\n+\t_Rb_tree::_M_assign_equal.\n+\t* include/bits/stl_set.h\n+\t(std::set<>::operator=(std::set<>&&)): Default implementation.\n+\t(std::set<>::operator=(initializer_list<>)): Adapt to use\n+\t_Rb_tree::_M_assign_unique.\n+\t* include/bits/stl_multiset.h\n+\t(std::multiset<>::operator=(std::multiset<>&&)): Default implementation.\n+\t(std::multiset<>::operator=(initializer_list<>)): Adapt to use\n+\t_Rb_tree::_M_assign_equal.\n+\t* testsuite/23_containers/map/allocator/copy_assign.cc (test03): New.\n+\t* testsuite/23_containers/map/allocator/init-list.cc: New.\n+\t* testsuite/23_containers/map/allocator/move_assign.cc (test03): New.\n+\t* testsuite/23_containers/multimap/allocator/copy_assign.cc\n+\t(test03): New.\n+\t* testsuite/23_containers/multimap/allocator/init-list.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/move_assign.cc\n+\t(test03): New.\n+\t* testsuite/23_containers/multiset/allocator/copy_assign.cc\n+\t(test03): New.\n+\t* testsuite/23_containers/multiset/allocator/init-list.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/move_assign.cc\n+\t(test03): New.\n+\t* testsuite/23_containers/set/allocator/copy_assign.cc (test03): New.\n+\t* testsuite/23_containers/set/allocator/init-list.cc: New.\n+\t* testsuite/23_containers/set/allocator/move_assign.cc (test03): New.\n+\n 2014-09-24  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/63353"}, {"sha": "899f063d4a42d33baded4aaeec976470973690bd", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -297,28 +297,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n-      /**\n-       *  @brief  %Map move assignment operator.\n-       *  @param  __x  A %map of identical element and allocator types.\n-       *\n-       *  The contents of @a __x are moved into this map (without copying\n-       *  if the allocators compare equal or get moved on assignment).\n-       *  Afterwards @a __x is in a valid, but unspecified state.\n-       */\n+      /// Move assignment operator.\n       map&\n-      operator=(map&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\tif (!_M_t._M_move_assign(__x._M_t))\n-\t  {\n-\t    // The rvalue's allocator cannot be moved and is not equal,\n-\t    // so we need to individually move each element.\n-\t    clear();\n-\t    insert(std::__make_move_if_noexcept_iterator(__x.begin()),\n-\t\t   std::__make_move_if_noexcept_iterator(__x.end()));\n-\t    __x.clear();\n-\t  }\n-\treturn *this;\n-      }\n+      operator=(map&&) = default;\n \n       /**\n        *  @brief  %Map list assignment operator.\n@@ -334,8 +315,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       map&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n+\t_M_t._M_assign_unique(__l.begin(), __l.end());\n \treturn *this;\n       }\n #endif"}, {"sha": "ab0c59bf6c35d256475f06160c3cca5d7fea17a3", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -292,28 +292,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n-      /**\n-       *  @brief  %Multimap move assignment operator.\n-       *  @param  __x  A %multimap of identical element and allocator types.\n-       *\n-       *  The contents of @a __x are moved into this multimap (without copying\n-       *  if the allocators compare equal or get moved on assignment).\n-       *  Afterwards @a __x is in a valid, but unspecified state.\n-       */\n+      /// Move assignment operator.\n       multimap&\n-      operator=(multimap&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\tif (!_M_t._M_move_assign(__x._M_t))\n-\t  {\n-\t    // The rvalue's allocator cannot be moved and is not equal,\n-\t    // so we need to individually move each element.\n-\t    clear();\n-\t    insert(std::__make_move_if_noexcept_iterator(__x.begin()),\n-\t\t   std::__make_move_if_noexcept_iterator(__x.end()));\n-\t    __x.clear();\n-\t  }\n-\treturn *this;\n-      }\n+      operator=(multimap&&) = default;\n \n       /**\n        *  @brief  %Multimap list assignment operator.\n@@ -329,8 +310,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       multimap&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n+\t_M_t._M_assign_equal(__l.begin(), __l.end());\n \treturn *this;\n       }\n #endif"}, {"sha": "8b0dba1b00c76d334b833de635d8a29b7edd4cc8", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -263,28 +263,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n-      /**\n-       *  @brief  %Multiset move assignment operator.\n-       *  @param  __x  A %multiset of identical element and allocator types.\n-       *\n-       *  The contents of @a __x are moved into this %multiset (without\n-       *  copying if the allocators compare equal or get moved on assignment).\n-       *  Afterwards @a __x is in a valid, but unspecified state.\n-       */\n+      /// Move assignment operator.\n       multiset&\n-      operator=(multiset&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\tif (!_M_t._M_move_assign(__x._M_t))\n-\t  {\n-\t    // The rvalue's allocator cannot be moved and is not equal,\n-\t    // so we need to individually move each element.\n-\t    clear();\n-\t    insert(std::__make_move_if_noexcept_iterator(__x._M_t.begin()),\n-\t\t   std::__make_move_if_noexcept_iterator(__x._M_t.end()));\n-\t    __x.clear();\n-\t  }\n-\treturn *this;\n-      }\n+      operator=(multiset&&) = default;\n \n       /**\n        *  @brief  %Multiset list assignment operator.\n@@ -300,8 +281,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       multiset&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n+\t_M_t._M_assign_equal(__l.begin(), __l.end());\n \treturn *this;\n       }\n #endif"}, {"sha": "53938eae33a759af0038ba5df3cd2d6d8076d41b", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -267,28 +267,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n-      /**\n-       *  @brief %Set move assignment operator.\n-       *  @param __x  A %set of identical element and allocator types.\n-       *\n-       *  The contents of @a __x are moved into this %set (without copying\n-       *  if the allocators compare equal or get moved on assignment).\n-       *  Afterwards @a __x is in a valid, but unspecified state.\n-       */\n+      /// Move assignment operator.\n       set&\n-      operator=(set&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\tif (!_M_t._M_move_assign(__x._M_t))\n-\t  {\n-\t    // The rvalue's allocator cannot be moved and is not equal,\n-\t    // so we need to individually move each element.\n-\t    clear();\n-\t    insert(std::__make_move_if_noexcept_iterator(__x._M_t.begin()),\n-\t\t   std::__make_move_if_noexcept_iterator(__x._M_t.end()));\n-\t    __x.clear();\n-\t  }\n-      \treturn *this;\n-      }\n+      operator=(set&&) = default;\n \n       /**\n        *  @brief  %Set list assignment operator.\n@@ -304,8 +285,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       set&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n+\t_M_t._M_assign_unique(__l.begin(), __l.end());\n \treturn *this;\n       }\n #endif"}, {"sha": "258579d31dbf5e8b8d91c85f0ba0ddc15ad875e5", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 395, "deletions": 143, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -355,6 +355,106 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     protected:\n       typedef _Rb_tree_node_base* \t\t_Base_ptr;\n       typedef const _Rb_tree_node_base* \t_Const_Base_ptr;\n+      typedef _Rb_tree_node<_Val>* \t\t_Link_type;\n+      typedef const _Rb_tree_node<_Val>*\t_Const_Link_type;\n+\n+    private:\n+      // Functor recycling a pool of nodes and using allocation once the pool is\n+      // empty.\n+      struct _Reuse_or_alloc_node\n+      {\n+\t_Reuse_or_alloc_node(const _Rb_tree_node_base& __header,\n+\t\t\t     _Rb_tree& __t)\n+\t  : _M_root(__header._M_parent), _M_nodes(__header._M_right), _M_t(__t)\n+\t{\n+\t  if (_M_root)\n+\t    _M_root->_M_parent = 0;\n+\t  else\n+\t    _M_nodes = 0;\n+\t}\n+\n+#if __cplusplus >= 201103L\n+\t_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;\n+#endif\n+\n+\t~_Reuse_or_alloc_node()\n+\t{ _M_t._M_erase(static_cast<_Link_type>(_M_root)); }\n+\n+\ttemplate<typename _Arg>\n+\t  _Link_type\n+#if __cplusplus < 201103L\n+\t  operator()(const _Arg& __arg)\n+#else\n+\t  operator()(_Arg&& __arg)\n+#endif\n+\t  {\n+\t    _Link_type __node = static_cast<_Link_type>(_M_extract());\n+\t    if (__node)\n+\t      {\n+\t\t_M_t._M_destroy_node(__node);\n+\t\t_M_t._M_construct_node(__node, _GLIBCXX_FORWARD(_Arg, __arg));\n+\t\treturn __node;\n+\t      }\n+\n+\t    return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg));\n+\t  }\n+\n+      private:\n+\t_Base_ptr\n+\t_M_extract()\n+\t{\n+\t  if (!_M_nodes)\n+\t    return _M_nodes;\n+\n+\t  _Base_ptr __node = _M_nodes;\n+\t  _M_nodes = _M_nodes->_M_parent;\n+\t  if (_M_nodes)\n+\t    {\n+\t      if (_M_nodes->_M_right == __node)\n+\t\t{\n+\t\t  _M_nodes->_M_right = 0;\n+\n+\t\t  if (_M_nodes->_M_left)\n+\t\t    {\n+\t\t      _M_nodes = _M_nodes->_M_left;\n+\n+\t\t      while (_M_nodes->_M_right)\n+\t\t\t_M_nodes = _M_nodes->_M_right;\n+\t\t    }\n+\t\t}\n+\t      else // __node is on the left.\n+\t\t_M_nodes->_M_left = 0;\n+\t    }\n+\t  else\n+\t    _M_root = 0;\n+\n+\t  return __node;\n+\t}\n+\n+\t_Base_ptr _M_root;\n+\t_Base_ptr _M_nodes;\n+\t_Rb_tree& _M_t;\n+      };\n+\n+      // Functor similar to the previous one but without any pool of node to\n+      // recycle.\n+      struct _Alloc_node\n+      {\n+\t_Alloc_node(_Rb_tree& __t)\n+\t  : _M_t(__t) { }\n+\n+\ttemplate<typename _Arg>\n+\t  _Link_type\n+#if __cplusplus < 201103L\n+\t  operator()(const _Arg& __arg) const\n+#else\n+\t  operator()(_Arg&& __arg) const\n+#endif\n+\t  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }\n+\n+      private:\n+\t_Rb_tree& _M_t;\n+      };\n \n     public:\n       typedef _Key \t\t\t\tkey_type;\n@@ -363,8 +463,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const value_type* \t\tconst_pointer;\n       typedef value_type& \t\t\treference;\n       typedef const value_type& \t\tconst_reference;\n-      typedef _Rb_tree_node<_Val>* \t\t_Link_type;\n-      typedef const _Rb_tree_node<_Val>*\t_Const_Link_type;\n       typedef size_t \t\t\t\tsize_type;\n       typedef ptrdiff_t \t\t\tdifference_type;\n       typedef _Alloc \t\t\t\tallocator_type;\n@@ -391,44 +489,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }\n \n #if __cplusplus < 201103L\n-      _Link_type\n-      _M_create_node(const value_type& __x)\n+      void\n+      _M_construct_node(_Link_type __node, const value_type& __x)\n       {\n-\t_Link_type __tmp = _M_get_node();\n \t__try\n-\t  { get_allocator().construct(__tmp->_M_valptr(), __x); }\n+\t  { get_allocator().construct(__node->_M_valptr(), __x); }\n \t__catch(...)\n \t  {\n-\t    _M_put_node(__tmp);\n+\t    _M_put_node(__node);\n \t    __throw_exception_again;\n \t  }\n+      }\n+\n+      _Link_type\n+      _M_create_node(const value_type& __x)\n+      {\n+\t_Link_type __tmp = _M_get_node();\n+\t_M_construct_node(__tmp, __x);\n \treturn __tmp;\n       }\n \n       void\n       _M_destroy_node(_Link_type __p)\n-      {\n-\tget_allocator().destroy(__p->_M_valptr());\n-\t_M_put_node(__p);\n-      }\n+      { get_allocator().destroy(__p->_M_valptr()); }\n #else\n       template<typename... _Args>\n-        _Link_type\n-        _M_create_node(_Args&&... __args)\n+\tvoid\n+\t_M_construct_node(_Link_type __node, _Args&&... __args)\n \t{\n-\t  _Link_type __tmp = _M_get_node();\n \t  __try\n \t    {\n-\t      ::new(__tmp) _Rb_tree_node<_Val>;\n+\t      ::new(__node) _Rb_tree_node<_Val>;\n \t      _Alloc_traits::construct(_M_get_Node_allocator(),\n-\t\t\t\t       __tmp->_M_valptr(),\n+\t\t\t\t       __node->_M_valptr(),\n \t\t\t\t       std::forward<_Args>(__args)...);\n \t    }\n \t  __catch(...)\n \t    {\n-\t      _M_put_node(__tmp);\n+\t      __node->~_Rb_tree_node<_Val>();\n+\t      _M_put_node(__node);\n \t      __throw_exception_again;\n \t    }\n+\t}\n+\n+      template<typename... _Args>\n+        _Link_type\n+        _M_create_node(_Args&&... __args)\n+\t{\n+\t  _Link_type __tmp = _M_get_node();\n+\t  _M_construct_node(__tmp, std::forward<_Args>(__args)...);\n \t  return __tmp;\n \t}\n \n@@ -437,23 +546,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());\n \t__p->~_Rb_tree_node<_Val>();\n-\t_M_put_node(__p);\n       }\n #endif\n \n-      _Link_type\n-      _M_clone_node(_Const_Link_type __x)\n+      void\n+      _M_drop_node(_Link_type __p) _GLIBCXX_NOEXCEPT\n       {\n-\t_Link_type __tmp = _M_create_node(*__x->_M_valptr());\n-\t__tmp->_M_color = __x->_M_color;\n-\t__tmp->_M_left = 0;\n-\t__tmp->_M_right = 0;\n-\treturn __tmp;\n+\t_M_destroy_node(__p);\n+\t_M_put_node(__p);\n       }\n \n+      template<typename _NodeGen>\n+\t_Link_type\n+\t_M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)\n+\t{\n+\t  _Link_type __tmp = __node_gen(*__x->_M_valptr());\n+\t  __tmp->_M_color = __x->_M_color;\n+\t  __tmp->_M_left = 0;\n+\t  __tmp->_M_right = 0;\n+\t  return __tmp;\n+\t}\n+\n     protected:\n-      template<typename _Key_compare, \n-\t       bool _Is_pod_comparator = __is_pod(_Key_compare)>\n+      // Unused _Is_pod_comparator is kept as it is part of mangled name.\n+      template<typename _Key_compare,\n+\t       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>\n         struct _Rb_tree_impl : public _Node_allocator\n         {\n \t  _Key_compare\t\t_M_key_compare;\n@@ -477,6 +594,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  { _M_initialize(); }\n #endif\n \n+\t  void\n+\t  _M_reset()\n+\t  {\n+\t    this->_M_header._M_parent = 0;\n+\t    this->_M_header._M_left = &this->_M_header;\n+\t    this->_M_header._M_right = &this->_M_header;\n+\t    this->_M_node_count = 0;\n+\t  }\n+\n \tprivate:\n \t  void\n \t  _M_initialize()\n@@ -605,9 +731,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t   const key_type& __k);\n \n #if __cplusplus >= 201103L\n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGen>\n         iterator\n-        _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);\n+\t_M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);\n \n       iterator\n       _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);\n@@ -626,9 +752,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       iterator\n       _M_insert_equal_lower_node(_Link_type __z);\n #else\n-      iterator\n-      _M_insert_(_Base_ptr __x, _Base_ptr __y,\n-\t\t const value_type& __v);\n+      template<typename _NodeGen>\n+\titerator\n+\t_M_insert_(_Base_ptr __x, _Base_ptr __y,\n+\t\t   const value_type& __v, _NodeGen&);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 233. Insertion hints in associative containers.\n@@ -639,8 +766,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_insert_equal_lower(const value_type& __x);\n #endif\n \n+      template<typename _NodeGen>\n+\t_Link_type\n+\t_M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen&);\n+\n       _Link_type\n-      _M_copy(_Const_Link_type __x, _Link_type __p);\n+      _M_copy(_Const_Link_type __x, _Link_type __p)\n+      {\n+\t_Alloc_node __an(*this);\n+\treturn _M_copy(__x, __p, __an);\n+      }\n \n       void\n       _M_erase(_Link_type __x);\n@@ -690,7 +825,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)\n       : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))\n       {\n-\tif (__x._M_root() != 0)\n+\tif (__x._M_root() != nullptr)\n \t  {\n \t    _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t    _M_leftmost() = _S_minimum(_M_root());\n@@ -794,13 +929,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         iterator\n         _M_insert_equal(_Arg&& __x);\n \n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGen>\n         iterator\n-        _M_insert_unique_(const_iterator __position, _Arg&& __x);\n+\t_M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);\n \n       template<typename _Arg>\n-        iterator\n-        _M_insert_equal_(const_iterator __position, _Arg&& __x);\n+\titerator\n+\t_M_insert_unique_(const_iterator __pos, _Arg&& __x)\n+\t{\n+\t  _Alloc_node __an(*this);\n+\t  return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);\n+\t}\n+\n+      template<typename _Arg, typename _NodeGen>\n+\titerator\n+\t_M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);\n+\n+      template<typename _Arg>\n+\titerator\n+\t_M_insert_equal_(const_iterator __pos, _Arg&& __x)\n+\t{\n+\t  _Alloc_node __an(*this);\n+\t  return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);\n+\t}\n \n       template<typename... _Args>\n \tpair<iterator, bool>\n@@ -824,11 +975,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       iterator\n       _M_insert_equal(const value_type& __x);\n \n+      template<typename _NodeGen>\n+\titerator\n+\t_M_insert_unique_(const_iterator __pos, const value_type& __x,\n+\t\t\t  _NodeGen&);\n+\n       iterator\n-      _M_insert_unique_(const_iterator __position, const value_type& __x);\n+      _M_insert_unique_(const_iterator __pos, const value_type& __x)\n+      {\n+\t_Alloc_node __an(*this);\n+\treturn _M_insert_unique_(__pos, __x, __an);\n+      }\n \n+      template<typename _NodeGen>\n+\titerator\n+\t_M_insert_equal_(const_iterator __pos, const value_type& __x,\n+\t\t\t _NodeGen&);\n       iterator\n-      _M_insert_equal_(const_iterator __position, const value_type& __x);\n+      _M_insert_equal_(const_iterator __pos, const value_type& __x)\n+      {\n+\t_Alloc_node __an(*this);\n+\treturn _M_insert_equal_(__pos, __x, __an);\n+      }\n #endif\n \n       template<typename _InputIterator>\n@@ -908,10 +1076,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       clear() _GLIBCXX_NOEXCEPT\n       {\n         _M_erase(_M_begin());\n-        _M_leftmost() = _M_end();\n-        _M_root() = 0;\n-        _M_rightmost() = _M_end();\n-        _M_impl._M_node_count = 0;\n+\t_M_impl._M_reset();\n       }\n \n       // Set operations.\n@@ -951,8 +1116,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __rb_verify() const;\n \n #if __cplusplus >= 201103L\n-      bool\n-      _M_move_assign(_Rb_tree&);\n+      _Rb_tree&\n+      operator=(_Rb_tree&&) noexcept(_Alloc_traits::_S_nothrow_move());\n+\n+      template<typename _Iterator>\n+\tvoid\n+\t_M_assign_unique(_Iterator, _Iterator);\n+\n+      template<typename _Iterator>\n+\tvoid\n+\t_M_assign_equal(_Iterator, _Iterator);\n \n     private:\n       // Move elements from container with equal allocator.\n@@ -1029,7 +1202,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : _M_impl(__x._M_impl._M_key_compare, std::move(__a))\n     {\n       using __eq = integral_constant<bool, _Alloc_traits::_S_always_equal()>;\n-      if (__x._M_root() != 0)\n+      if (__x._M_root() != nullptr)\n \t_M_move_data(__x, __eq());\n     }\n \n@@ -1062,7 +1235,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_move_data(__x, std::true_type());\n       else\n \t{\n-\t  _M_root() = _M_copy(__x._M_begin(), _M_end());\n+\t  _Alloc_node __an(*this);\n+\t  auto __lbd =\n+\t    [&__an](const value_type& __cval)\n+\t    {\n+\t      auto& __val = const_cast<value_type&>(__cval);\n+\t      return __an(std::move_if_noexcept(__val));\n+\t    };\n+\t  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);\n \t  _M_leftmost() = _S_minimum(_M_root());\n \t  _M_rightmost() = _S_maximum(_M_root());\n \t  _M_impl._M_node_count = __x._M_impl._M_node_count;\n@@ -1071,24 +1251,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    bool\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_move_assign(_Rb_tree& __x)\n+    operator=(_Rb_tree&& __x)\n+    noexcept(_Alloc_traits::_S_nothrow_move())\n     {\n       _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n       if (_Alloc_traits::_S_propagate_on_move_assign()\n \t  || _Alloc_traits::_S_always_equal()\n \t  || _M_get_Node_allocator() == __x._M_get_Node_allocator())\n \t{\n \t  clear();\n-\t  if (__x._M_root() != 0)\n+\t  if (__x._M_root() != nullptr)\n \t    _M_move_data(__x, std::true_type());\n \t  std::__alloc_on_move(_M_get_Node_allocator(),\n \t\t\t       __x._M_get_Node_allocator());\n-\t  return true;\n+\t  return *this;\n+\t}\n+\n+      // Try to move each node reusing existing nodes and copying __x nodes\n+      // structure.\n+      _Reuse_or_alloc_node __roan(_M_impl._M_header, *this);\n+      _M_impl._M_reset();\n+      if (__x._M_root() != nullptr)\n+\t{\n+\t  auto __lbd =\n+\t    [&__roan](const value_type& __cval)\n+\t    {\n+\t      auto& __val = const_cast<value_type&>(__cval);\n+\t      return __roan(std::move_if_noexcept(__val));\n+\t    };\n+\t  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);\n+\t  _M_leftmost() = _S_minimum(_M_root());\n+\t  _M_rightmost() = _S_maximum(_M_root());\n+\t  _M_impl._M_node_count = __x._M_impl._M_node_count;\n+\t  __x.clear();\n \t}\n-      return false;\n+      return *this;\n     }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename _Iterator>\n+      void\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_assign_unique(_Iterator __first, _Iterator __last)\n+      {\n+\t_Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t_M_impl._M_reset();\n+\tfor (; __first != __last; ++__first)\n+\t  _M_insert_unique_(end(), *__first, __roan);\n+      }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename _Iterator>\n+      void\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_assign_equal(_Iterator __first, _Iterator __last)\n+      {\n+\t_Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t_M_impl._M_reset();\n+\tfor (; __first != __last; ++__first)\n+\t  _M_insert_equal_(end(), *__first, __roan);\n+      }\n #endif\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1100,7 +1326,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (this != &__x)\n \t{\n \t  // Note that _Key may be a constant type.\n-\t  clear();\n #if __cplusplus >= 201103L\n \t  if (_Alloc_traits::_S_propagate_on_copy_assign())\n \t    {\n@@ -1109,46 +1334,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      if (!_Alloc_traits::_S_always_equal()\n \t\t  && __this_alloc != __that_alloc)\n \t\t{\n+\t\t  // Replacement allocator cannot free existing storage, we need\n+\t\t  // to erase nodes first.\n+\t\t  clear();\n \t\t  std::__alloc_on_copy(__this_alloc, __that_alloc);\n \t\t}\n \t    }\n #endif\n+\n+\t  _Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t  _M_impl._M_reset();\n \t  _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n \t  if (__x._M_root() != 0)\n \t    {\n-\t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n+\t      _M_root() = _M_copy(__x._M_begin(), _M_end(), __roan);\n \t      _M_leftmost() = _S_minimum(_M_root());\n \t      _M_rightmost() = _S_maximum(_M_root());\n \t      _M_impl._M_node_count = __x._M_impl._M_node_count;\n \t    }\n \t}\n+\n       return *this;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n #if __cplusplus >= 201103L\n-    template<typename _Arg>\n+    template<typename _Arg, typename _NodeGen>\n+#else\n+    template<typename _NodeGen>\n #endif\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_insert_(_Base_ptr __x, _Base_ptr __p,\n #if __cplusplus >= 201103L\n-    _M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)\n+\t\t _Arg&& __v,\n #else\n-    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n+\t\t const _Val& __v,\n #endif\n-    {\n-      bool __insert_left = (__x != 0 || __p == _M_end()\n-\t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t\t      _S_key(__p)));\n+\t\t _NodeGen& __node_gen)\n+      {\n+\tbool __insert_left = (__x != 0 || __p == _M_end()\n+\t\t\t      || _M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t\t\t_S_key(__p)));\n \n-      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));\n+\t_Link_type __z = __node_gen(_GLIBCXX_FORWARD(_Arg, __v));\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n-\t\t\t\t    this->_M_impl._M_header);\n-      ++_M_impl._M_node_count;\n-      return iterator(__z);\n-    }\n+\t_Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n+\t\t\t\t      this->_M_impl._M_header);\n+\t++_M_impl._M_node_count;\n+\treturn iterator(__z);\n+      }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n@@ -1200,40 +1436,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Val, typename _KoV,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n-    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n-    _M_copy(_Const_Link_type __x, _Link_type __p)\n-    {\n-      // Structural copy.  __x and __p must be non-null.\n-      _Link_type __top = _M_clone_node(__x);\n-      __top->_M_parent = __p;\n-\n-      __try\n-\t{\n-\t  if (__x->_M_right)\n-\t    __top->_M_right = _M_copy(_S_right(__x), __top);\n-\t  __p = __top;\n-\t  __x = _S_left(__x);\n+\t   typename _Compare, typename _Alloc>\n+    template<typename _NodeGen>\n+      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n+      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n+      _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen& __node_gen)\n+      {\n+\t// Structural copy. __x and __p must be non-null.\n+\t_Link_type __top = _M_clone_node(__x, __node_gen);\n+\t__top->_M_parent = __p;\n \n-\t  while (__x != 0)\n-\t    {\n-\t      _Link_type __y = _M_clone_node(__x);\n-\t      __p->_M_left = __y;\n-\t      __y->_M_parent = __p;\n-\t      if (__x->_M_right)\n-\t\t__y->_M_right = _M_copy(_S_right(__x), __y);\n-\t      __p = __y;\n-\t      __x = _S_left(__x);\n-\t    }\n-\t}\n-      __catch(...)\n-\t{\n-\t  _M_erase(__top);\n-\t  __throw_exception_again;\n-\t}\n-      return __top;\n-    }\n+\t__try\n+\t  {\n+\t    if (__x->_M_right)\n+\t      __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);\n+\t    __p = __top;\n+\t    __x = _S_left(__x);\n+\n+\t    while (__x != 0)\n+\t      {\n+\t\t_Link_type __y = _M_clone_node(__x, __node_gen);\n+\t\t__p->_M_left = __y;\n+\t\t__y->_M_parent = __p;\n+\t\tif (__x->_M_right)\n+\t\t  __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);\n+\t\t__p = __y;\n+\t\t__x = _S_left(__x);\n+\t      }\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_erase(__top);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn __top;\n+      }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n@@ -1246,7 +1483,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _M_erase(_S_right(__x));\n \t  _Link_type __y = _S_left(__x);\n-\t  _M_destroy_node(__x);\n+\t  _M_drop_node(__x);\n \t  __x = __y;\n \t}\n     }\n@@ -1394,10 +1631,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      _M_leftmost() = __t._M_leftmost();\n \t      _M_rightmost() = __t._M_rightmost();\n \t      _M_root()->_M_parent = _M_end();\n+\t      _M_impl._M_node_count = __t._M_impl._M_node_count;\n \t      \n-\t      __t._M_root() = 0;\n-\t      __t._M_leftmost() = __t._M_end();\n-\t      __t._M_rightmost() = __t._M_end();\n+\t      __t._M_impl._M_reset();\n \t    }\n \t}\n       else if (__t._M_root() == 0)\n@@ -1406,10 +1642,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __t._M_leftmost() = _M_leftmost();\n \t  __t._M_rightmost() = _M_rightmost();\n \t  __t._M_root()->_M_parent = __t._M_end();\n+\t  __t._M_impl._M_node_count = _M_impl._M_node_count;\n \t  \n-\t  _M_root() = 0;\n-\t  _M_leftmost() = _M_end();\n-\t  _M_rightmost() = _M_end();\n+\t  _M_impl._M_reset();\n \t}\n       else\n \t{\n@@ -1419,9 +1654,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  \n \t  _M_root()->_M_parent = _M_end();\n \t  __t._M_root()->_M_parent = __t._M_end();\n+\t  std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);\n \t}\n       // No need to swap header's color as it does not change.\n-      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);\n       std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);\n \n       _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),\n@@ -1500,9 +1735,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t= _M_get_insert_unique_pos(_KeyOfValue()(__v));\n \n       if (__res.second)\n-\treturn _Res(_M_insert_(__res.first, __res.second,\n-\t\t\t       _GLIBCXX_FORWARD(_Arg, __v)),\n-\t\t    true);\n+\t{\n+\t  _Alloc_node __an(*this);\n+\t  return _Res(_M_insert_(__res.first, __res.second,\n+\t\t\t\t _GLIBCXX_FORWARD(_Arg, __v), __an),\n+\t\t      true);\n+\t}\n \n       return _Res(iterator(static_cast<_Link_type>(__res.first)), false);\n     }\n@@ -1522,7 +1760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       pair<_Base_ptr, _Base_ptr> __res\n \t= _M_get_insert_equal_pos(_KeyOfValue()(__v));\n-      return _M_insert_(__res.first, __res.second, _GLIBCXX_FORWARD(_Arg, __v));\n+      _Alloc_node __an(*this);\n+      return _M_insert_(__res.first, __res.second,\n+\t\t\t_GLIBCXX_FORWARD(_Arg, __v), __an);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1587,22 +1827,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n #if __cplusplus >= 201103L\n-    template<typename _Arg>\n+    template<typename _Arg, typename _NodeGen>\n+#else\n+    template<typename _NodeGen>\n #endif\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_insert_unique_(const_iterator __position,\n #if __cplusplus >= 201103L\n-    _M_insert_unique_(const_iterator __position, _Arg&& __v)\n+\t\t\t_Arg&& __v,\n #else\n-    _M_insert_unique_(const_iterator __position, const _Val& __v)\n+\t\t\tconst _Val& __v,\n #endif\n+\t\t\t_NodeGen& __node_gen)\n     {\n       pair<_Base_ptr, _Base_ptr> __res\n \t= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));\n \n       if (__res.second)\n \treturn _M_insert_(__res.first, __res.second,\n-\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\t\t  _GLIBCXX_FORWARD(_Arg, __v),\n+\t\t\t  __node_gen);\n       return iterator(static_cast<_Link_type>(__res.first));\n     }\n \n@@ -1664,25 +1909,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n #if __cplusplus >= 201103L\n-    template<typename _Arg>\n+    template<typename _Arg, typename _NodeGen>\n+#else\n+    template<typename _NodeGen>\n #endif\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_insert_equal_(const_iterator __position,\n #if __cplusplus >= 201103L\n-    _M_insert_equal_(const_iterator __position, _Arg&& __v)\n+\t\t       _Arg&& __v,\n #else\n-    _M_insert_equal_(const_iterator __position, const _Val& __v)\n+\t\t       const _Val& __v,\n #endif\n-    {\n-      pair<_Base_ptr, _Base_ptr> __res\n-\t= _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));\n+\t\t       _NodeGen& __node_gen)\n+      {\n+\tpair<_Base_ptr, _Base_ptr> __res\n+\t  = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));\n \n-      if (__res.second)\n-\treturn _M_insert_(__res.first, __res.second,\n-\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\tif (__res.second)\n+\t  return _M_insert_(__res.first, __res.second,\n+\t\t\t    _GLIBCXX_FORWARD(_Arg, __v),\n+\t\t\t    __node_gen);\n \n-      return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));\n-    }\n+\treturn _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));\n+      }\n \n #if __cplusplus >= 201103L\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1751,12 +2001,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__res.second)\n \t      return _Res(_M_insert_node(__res.first, __res.second, __z), true);\n \t\n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -1777,7 +2027,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -1798,12 +2048,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__res.second)\n \t      return _M_insert_node(__res.first, __res.second, __z);\n \n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    return iterator(static_cast<_Link_type>(__res.first));\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -1828,7 +2078,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_destroy_node(__z);\n+\t    _M_drop_node(__z);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -1841,8 +2091,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n       _M_insert_unique(_II __first, _II __last)\n       {\n+\t_Alloc_node __an(*this);\n \tfor (; __first != __last; ++__first)\n-\t  _M_insert_unique_(end(), *__first);\n+\t  _M_insert_unique_(end(), *__first, __an);\n       }\n \n   template<typename _Key, typename _Val, typename _KoV,\n@@ -1852,8 +2103,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n       _M_insert_equal(_II __first, _II __last)\n       {\n+\t_Alloc_node __an(*this);\n \tfor (; __first != __last; ++__first)\n-\t  _M_insert_equal_(end(), *__first);\n+\t  _M_insert_equal_(end(), *__first, __an);\n       }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1866,7 +2118,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n \t\t\t\t(const_cast<_Base_ptr>(__position._M_node),\n \t\t\t\t this->_M_impl._M_header));\n-      _M_destroy_node(__y);\n+      _M_drop_node(__y);\n       --_M_impl._M_node_count;\n     }\n "}, {"sha": "ea914cb89d6c3896c7ad03f224d41ff9690a9bc3", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/copy_assign.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -59,9 +59,33 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<std::pair<const int, int>> alloc_type;\n+  typedef std::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1 = { { 0, 0 }, { 1, 1 } };\n+  test_type v2 = { { 2, 2 }, { 3, 3 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  v1 = v2;\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "d33d10deab8eeaf4ed88a49eb4abceb4ca538073", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/init-list.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Finit-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Finit-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Finit-list.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<std::pair<const int, int>> alloc_type;\n+  typedef std::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1;\n+  v1 = { { 0, 0 }, { 1, 1 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  VERIFY( allocs != 0 );\n+  VERIFY( constructs != 0 );\n+\n+  // Check no allocation on list initialization.\n+  v1 = { { 4, 4 }, { 5, 5 } };\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "167e87dd36a7c736e4b8a7faaafb4a3196fe2e65", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move_assign.cc", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -43,8 +43,8 @@ void test01()\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n \n-  VERIFY(1 == v1.get_allocator().get_personality());\n-  VERIFY(2 == v2.get_allocator().get_personality());\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n }\n \n void test02()\n@@ -60,14 +60,47 @@ void test02()\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n \n-  VERIFY(0 == v1.get_allocator().get_personality());\n-  VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( 0 == v1.get_allocator().get_personality() );\n+  VERIFY( 1 == v2.get_allocator().get_personality() );\n   VERIFY( it == v2.begin() );\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef propagating_allocator<std::pair<const int, int>, false,\n+\t\t\t\ttracker_allocator<std::pair<const int, int>>>\n+    alloc_type;\n+  typedef std::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 0, 0 }, { 1, 1 } };\n+\n+  test_type v2(alloc_type(2));\n+  v2 = { { 2, 2 }, { 3, 3 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  // Check no allocation on move assignment with non propagating allocators.\n+  v1 = std::move(v2);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "ee841a3320f33ae5a6f0f506abbce1deabedcaa9", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/copy_assign.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -59,9 +59,33 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<std::pair<const int, int>> alloc_type;\n+  typedef std::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1 = { { 1, 1 }, { 1, 1 } };\n+  test_type v2 = { { 2, 2 }, { 2, 2 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  v1 = v2;\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "c2241b41089ed0f685b47e77271add14e3211ec4", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/init-list.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Finit-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Finit-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Finit-list.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<std::pair<const int, int>> alloc_type;\n+  typedef std::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1;\n+  v1 = { { 0, 0 }, { 0, 0 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  VERIFY( allocs != 0 );\n+  VERIFY( constructs != 0 );\n+\n+  // Check no allocation on list initialization.\n+  v1 = { { 1, 1 }, { 1, 1 } };\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "11b5e357531dcb9bb7885b09278754a105af7375", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move_assign.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -61,9 +61,42 @@ void test02()\n   VERIFY( it == v2.begin()  );\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef propagating_allocator<std::pair<const int, int>, false,\n+\t\t\t\ttracker_allocator<std::pair<const int, int>>>\n+    alloc_type;\n+  typedef std::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 1, 1 }, { 1, 1 } };\n+\n+  test_type v2(alloc_type(2));\n+  v2 = { { 2, 2 }, { 2, 2 } };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  // Check no allocation on move assignment with non propagating allocators.\n+  v1 = std::move(v2);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "f5921ab59b091906f614fe61c36b0ecd659de2a2", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/copy_assign.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -57,9 +57,33 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<int> alloc_type;\n+  typedef std::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1 = { 0, 0 };\n+  test_type v2 = { 1, 1 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  v1 = v2;\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "a657ae0f6cf053f6d1adecdfdc175fdf90a3eb52", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/init-list.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Finit-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Finit-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Finit-list.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<int> alloc_type;\n+  typedef std::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1;\n+  v1 = { 0, 0 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  VERIFY( allocs != 0 );\n+  VERIFY( constructs != 0 );\n+\n+  // Check no allocation on list initialization.\n+  v1 = { 1, 1 };\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "405aff1d3d613f5b96662334503e4d4fd8e2b951", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move_assign.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -59,9 +59,40 @@ void test02()\n   VERIFY( it == v2.begin() );\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef propagating_allocator<int, false, tracker_allocator<int>> alloc_type;\n+  typedef std::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0, 0 };\n+\n+  test_type v2(alloc_type(2));\n+  v2 = { 2, 2 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  // Check no allocation on move assignment with non propagating allocators.\n+  v1 = std::move(v2);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "1176a700e7e3c7f46627ddb05e59ef8564576b04", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/copy_assign.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -57,9 +57,33 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<int> alloc_type;\n+  typedef std::set<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1 = { 0, 1 };\n+  test_type v2 = { 2, 3 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  v1 = v2;\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "1c39da204af06589027bf9435f10f50389bc7e6b", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/init-list.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Finit-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Finit-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Finit-list.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<int> alloc_type;\n+  typedef std::set<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1;\n+  v1 = { 0, 1 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  VERIFY( allocs != 0 );\n+  VERIFY( constructs != 0 );\n+\n+  // Check no allocation on list initialization.\n+  v1 = { 4, 5 };\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "f4d02e898acf8daa3dc2c4053b6b3bc87cdec514", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move_assign.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6195f588b1b8980b07d53394edaaa2cd6807588/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc?ref=c6195f588b1b8980b07d53394edaaa2cd6807588", "patch": "@@ -59,9 +59,40 @@ void test02()\n   VERIFY( it == v2.begin() );\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef propagating_allocator<int, false, tracker_allocator<int>> alloc_type;\n+  typedef std::set<int, std::less<int>, alloc_type> test_type;\n+\n+  tracker_allocator_counter::reset();\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0, 1 };\n+\n+  test_type v2(alloc_type(2));\n+  v2 = { 2, 3 };\n+\n+  auto allocs = tracker_allocator_counter::get_allocation_count();\n+  auto constructs = tracker_allocator_counter::get_construct_count();\n+\n+  // Check no allocation on move assignment with non propagating allocators.\n+  v1 = std::move(v2);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocs );\n+  VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}]}