{"sha": "07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiM2JiZjIwMDdiYjlmYWI4YjZjMDgzMjFhYmY5YzJjYzdhMjQ0Mw==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-12-01T21:04:38Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-12-01T21:04:38Z"}, "message": "re PR libfortran/29568 (implement unformatted files with subrecords (Intel style))\n\n2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/29568\n\t* gfortran.dg/convert_implied_open.f90:  Change to\n\tnew default record length.\n\t* gfortran.dg/unf_short_record_1.f90:  Adapt to\n\tnew error message.\n\t* gfortran.dg/unformatted_subrecords_1.f90:  New test.\n\n2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/29568\n\t* gfortran.h (gfc_option_t):  Add max_subrecord_length.\n\t(top level): Define MAX_SUBRECORD_LENGTH.\n\t* lang.opt:  Add option -fmax-subrecord-length=.\n\t* trans-decl.c:  Add new function set_max_subrecord_length.\n\t(gfc_generate_function_code): If we are within the main\n\tprogram and max_subrecord_length has been set, call\n\tset_max_subrecord_length.\n\t* options.c (gfc_init_options):  Add defaults for\n\tmax_subrecord_lenght, convert and record_marker.\n\t(gfc_handle_option):  Add handling for\n\t-fmax_subrecord_length.\n\t* invoke.texi:  Document the new default for\n\t-frecord-marker=<n>.\n\n2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/29568\n\t* libgfortran/libgfortran.h (compile_options_t):  Add\n\trecord_marker. (top level):  Define GFC_MAX_SUBRECORD_LENGTH.\n\t* runtime/compile_options.c (set_record_marker):  Change\n\tdefault to four-byte record marker.\n\t(set_max_subrecord_length):  New function.\n\t* runtime/error.c (translate_error):  Change error message\n\tfor short record on unformatted read.\n\t* io/io.h (gfc_unit):  Add recl_subrecord, bytes_left_subrecord\n\tand continued.\n\t* io/file_pos.c (unformatted_backspace):  Change default of record\n\tmarker size to four bytes.  Loop over subrecords.\n\t* io/open.c:  Default recl is max_offset.  If\n\tcompile_options.max_subrecord_length has been set, set set\n\tu->recl_subrecord to its value, to the maximum value otherwise.\n\t* io/transfer.c (top level):  Add prototypes for us_read, us_write,\n\tnext_record_r_unf and next_record_w_unf.\n\t(read_block_direct):  Separate codepaths for unformatted direct\n\tand unformatted sequential.  If a recl has been set by the\n\tuser, use the number of bytes left for the record if it is smaller\n\tthan the read request.  Loop over subrecords.  Set an error if the\n\tuser has set a recl and the read was short.\n\t(write_buf):  Separate codepaths for unformatted direct and\n\tunformatted sequential. If a recl has been set by the\n\tuser, use the number of bytes left for the record if it is smaller\n\tthan the read request.  Loop over subrecords.  Set an error if the\n\tuser has set a recl and the read was short.\n\t(us_read):  Add parameter continued (to indicate that bytes_left\n\tshould not be intialized).  Change default of record marker size\n\tto four bytes. Use subrecord.  If the subrecord length is smaller than\n\tzero, this indicates a continuation.\n\t(us_write):  Add parameter continued (to indicate that the continued\n\tflag should be set).  Use subrecord.\n\t(pre_position):  Use 0 for continued on us_write and us_read calls.\n\t(skip_record):  New function.\n\t(next_record_r_unf):  New function.\n\t(next_record_r):  Use next_record_r_unf.\n\t(write_us_marker):  Default size for record markers is four bytes.\n\t(next_record_w_unf):  New function.\n\t(next_record_w):  Use next_record_w_unf.\n\nFrom-SVN: r119412", "tree": {"sha": "fa9d74bece4649b8f0f42522f03ff4b74899826b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9d74bece4649b8f0f42522f03ff4b74899826b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/comments", "author": null, "committer": null, "parents": [{"sha": "7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6a62dd399b670aac5a1d8c96ba591b75df74b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c6a62dd399b670aac5a1d8c96ba591b75df74b7"}], "stats": {"total": 918, "additions": 665, "deletions": 253}, "files": [{"sha": "be3e91e5dacb6d77e4ad3de9304ba031e863a1cc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -1,3 +1,20 @@\n+2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/29568\n+\t* gfortran.h (gfc_option_t):  Add max_subrecord_length.\n+\t(top level): Define MAX_SUBRECORD_LENGTH.\n+\t* lang.opt:  Add option -fmax-subrecord-length=.\n+\t* trans-decl.c:  Add new function set_max_subrecord_length.\n+\t(gfc_generate_function_code): If we are within the main\n+\tprogram and max_subrecord_length has been set, call\n+\tset_max_subrecord_length.\n+\t* options.c (gfc_init_options):  Add defaults for\n+\tmax_subrecord_lenght, convert and record_marker.\n+\t(gfc_handle_option):  Add handling for\n+\t-fmax_subrecord_length.\n+\t* invoke.texi:  Document the new default for\n+\t-frecord-marker=<n>.\n+\n 2006-11-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29976"}, {"sha": "9a18e7851d725ff071bcff9581b7e1db1a158bd9", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -59,6 +59,9 @@ char *alloca ();\n #define GFC_MAX_DIMENSIONS 7\t/* Maximum dimensions in an array.  */\n #define GFC_LETTERS 26\t\t/* Number of letters in the alphabet.  */\n \n+#define MAX_SUBRECORD_LENGTH 2147483639   /* 2**31-9 */\n+\n+\n #define free(x) Use_gfc_free_instead_of_free()\n #define gfc_is_whitespace(c) ((c==' ') || (c=='\\t'))\n \n@@ -1661,12 +1664,12 @@ typedef struct\n   int fshort_enums;\n   int convert;\n   int record_marker;\n+  int max_subrecord_length;\n }\n gfc_option_t;\n \n extern gfc_option_t gfc_option;\n \n-\n /* Constructor nodes for array and structure constructors.  */\n typedef struct gfc_constructor\n {"}, {"sha": "c4ee5d351baa9275c16ac3d0d16a79c5e5e47bf2", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -650,13 +650,17 @@ variable override the default specified by -fconvert.}\n @cindex -frecord-marker=@var{length}\n @item -frecord-marker=@var{length}\n Specify the length of record markers for unformatted files.\n-Valid values for @var{length} are 4 and 8.  Default is whatever\n-@code{off_t} is specified to be on that particular system.\n-Note that specifying @var{length} as 4 limits the record\n-length of unformatted files to 2 GB.  This option does not\n-extend the maximum possible record length on systems where\n-@code{off_t} is a four_byte quantity.\n-\n+Valid values for @var{length} are 4 and 8.  Default is 4.\n+@emph{This is different from previous versions of gfortran},\n+which specified a default record marker length of 8 on most\n+systems.  If you want to read or write files compatible\n+with earlier versions of gfortran, use @samp{-frecord-marker=8}.\n+\n+@cindex -fmax-subrecord-length=@var{length}\n+@item -fmax-subrecord-length=@var{length}\n+Specify the maximum length for a subrecord.  The maximum permitted\n+value for length is 2147483639, which is also the default.  Only\n+really useful for use by the gfortran testsuite.\n @end table\n \n @node Code Gen Options"}, {"sha": "ebd6b8dd8ec05a379218c3f7862a69d502db14b2", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -189,6 +189,10 @@ fmax-identifier-length=\n Fortran RejectNegative Joined UInteger\n -fmax-identifier-length=<n>\tMaximum identifier length\n \n+fmax-subrecord-length=\n+Fortran RejectNegative Joined UInteger\n+-fmax-subrecord-length=<n>\tMaximum length for subrecords\n+\n fmax-stack-var-size=\n Fortran RejectNegative Joined UInteger\n -fmax-stack-var-size=<n>\tSize in bytes of the largest array that will be put on the stack"}, {"sha": "6ec846761850eb32f0c4b95a5d1f4fda874a4df8", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -51,6 +51,9 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.max_continue_fixed = 19;\n   gfc_option.max_continue_free = 39;\n   gfc_option.max_identifier_length = GFC_MAX_SYMBOL_LEN;\n+  gfc_option.max_subrecord_length = 0;\n+  gfc_option.convert = CONVERT_NATIVE;\n+  gfc_option.record_marker = 0;\n   gfc_option.verbose = 0;\n \n   gfc_option.warn_aliasing = 0;\n@@ -636,6 +639,12 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n     case OPT_frecord_marker_8:\n       gfc_option.record_marker = 8;\n       break;\n+\n+    case OPT_fmax_subrecord_length_:\n+      if (value > MAX_SUBRECORD_LENGTH)\n+\tgfc_fatal_error (\"Maximum subrecord length cannot exceed %d\", MAX_SUBRECORD_LENGTH);\n+\n+      gfc_option.max_subrecord_length = value;\n     }\n \n   return result;"}, {"sha": "270083f022e13efe9f834ba58a0821096074ef78", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -94,6 +94,7 @@ tree gfor_fndecl_set_fpe;\n tree gfor_fndecl_set_std;\n tree gfor_fndecl_set_convert;\n tree gfor_fndecl_set_record_marker;\n+tree gfor_fndecl_set_max_subrecord_length;\n tree gfor_fndecl_ctime;\n tree gfor_fndecl_fdate;\n tree gfor_fndecl_ttynam;\n@@ -2379,6 +2380,10 @@ gfc_build_builtin_function_decls (void)\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"set_record_marker\")),\n \t\t\t\t     void_type_node, 1, gfc_c_int_type_node);\n \n+  gfor_fndecl_set_max_subrecord_length =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"set_max_subrecord_length\")),\n+\t\t\t\t     void_type_node, 1, gfc_c_int_type_node);\n+\n   gfor_fndecl_in_pack = gfc_build_library_function_decl (\n         get_identifier (PREFIX(\"internal_pack\")),\n         pvoid_type_node, 1, pvoid_type_node);\n@@ -3187,6 +3192,18 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n     }\n \n+  if (sym->attr.is_main_program && gfc_option.max_subrecord_length != 0)\n+    {\n+      tree arglist, gfc_c_int_type_node;\n+\n+      gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n+      arglist = gfc_chainon_list (NULL_TREE,\n+\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t\t gfc_option.max_subrecord_length));\n+      tmp = build_function_call_expr (gfor_fndecl_set_max_subrecord_length, arglist);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n       && sym->attr.subroutine)\n     {"}, {"sha": "fe29e8615eb677cdeaaf7c15fa12d8d03193e7d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -1,3 +1,12 @@\n+2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/29568\n+\t* gfortran.dg/convert_implied_open.f90:  Change to\n+\tnew default record length.\n+\t* gfortran.dg/unf_short_record_1.f90:  Adapt to\n+\tnew error message.\n+\t* gfortran.dg/unformatted_subrecords_1.f90:  New test.\n+\n 2006-12-01  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gcc.dg/max-1.c: Remove reference to -fno-tree-lrs option."}, {"sha": "9c25b5d961c2ce306e059bd15643fca2f41f2adc", "filename": "gcc/testsuite/gfortran.dg/convert_implied_open.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Fconvert_implied_open.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Fconvert_implied_open.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconvert_implied_open.f90?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -3,13 +3,13 @@\n ! PR 26735 - implied open didn't use to honor -fconvert\n program main\n   implicit none\n-  integer (kind=8) :: i1, i2, i3\n-  write (10) 1_8\n+  integer (kind=4) :: i1, i2, i3\n+  write (10) 1_4\n   close (10)\n-  open (10, form=\"unformatted\", access=\"direct\", recl=8)\n+  open (10, form=\"unformatted\", access=\"direct\", recl=4)\n   read (10,rec=1) i1\n   read (10,rec=2) i2\n   read (10,rec=3) i3\n-  if (i1 /= 8 .or. i2 /= 1 .or. i3 /= 8) call abort\n+  if (i1 /= 4 .or. i2 /= 1 .or. i3 /= 4) call abort\n   close (10,status=\"delete\")\n end program main"}, {"sha": "45c94c29405dbe935990078bb6e9552af3fbf798", "filename": "gcc/testsuite/gfortran.dg/unf_short_record_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -11,7 +11,7 @@ program main\n   read (10, err=20, iomsg=msg) a\n   call abort\n 20 continue\n-  if (msg .ne. \"Short record on unformatted read\") call abort\n+  if (msg .ne. \"I/O past end of record on unformatted file\") call abort\n   if (a(1) .ne. 'a' .or. a(2) .ne. 'b' .or. a(3) .ne. 'b') call abort\n   close (10, status=\"delete\")\n end program main"}, {"sha": "5812a8eaaf569a4f5bd9846e57db7be0278f06cc", "filename": "gcc/testsuite/gfortran.dg/unformatted_subrecord_1.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Funformatted_subrecord_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/gcc%2Ftestsuite%2Fgfortran.dg%2Funformatted_subrecord_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funformatted_subrecord_1.f90?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-options \"-fmax-subrecord-length=16\" }\n+! Test Intel record markers with 16-byte subrecord sizes.\n+program main\n+  implicit none\n+  integer, dimension(20) :: n\n+  integer, dimension(30) :: m\n+  integer :: i\n+  real :: r\n+  integer :: k\n+  ! Maximum subrecord length is 16 here, or the test will fail.\n+  open (10, file=\"f10.dat\", &\n+       form=\"unformatted\", access=\"sequential\")\n+  n = (/ (i**2, i=1, 20) /)\n+  write (10) n\n+  close (10)\n+  ! Read back the file, including record markers.\n+  open (10, file=\"f10.dat\", form=\"unformatted\", access=\"stream\")\n+  read (10) m\n+  if (any(m .ne. (/ -16, 1, 4, 9, 16, 16, -16, 25, 36, 49, 64, &\n+       -16, -16, 81, 100, 121, 144, -16, -16, 169, 196, 225, & \n+       256, -16, 16, 289, 324, 361, 400, -16 /))) call abort\n+  close (10)\n+  open (10, file=\"f10.dat\", form=\"unformatted\", &\n+       access=\"sequential\")\n+  m = 42\n+  read (10) m(1:5)\n+  if (any(m(1:5) .ne. (/ 1, 4, 9, 16, 25 /))) call abort\n+  if (any(m(6:30) .ne. 42)) call abort\n+  backspace 10\n+  n = 0\n+  read (10) n(1:5)\n+  if (any(n(1:5) .ne. (/ 1, 4, 9, 16, 25 /))) call abort\n+  if (any(n(6:20) .ne. 0)) call abort\n+  ! Append to the end of the file\n+  write (10) 3.14\n+  ! Test multiple backspace statements\n+  backspace 10\n+  backspace 10\n+  read (10) k\n+  if (k .ne. 1) call abort\n+  read (10) r\n+  if (abs(r-3.14) .gt. 1e-7) call abort\n+  close (10, status=\"delete\")\n+end program main"}, {"sha": "ca823924d0b0fb4abb654f34c08ebe88966c81ec", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -1,3 +1,46 @@\n+2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/29568\n+\t* libgfortran/libgfortran.h (compile_options_t):  Add\n+\trecord_marker. (top level):  Define GFC_MAX_SUBRECORD_LENGTH.\n+\t* runtime/compile_options.c (set_record_marker):  Change\n+\tdefault to four-byte record marker.\n+\t(set_max_subrecord_length):  New function.\n+\t* runtime/error.c (translate_error):  Change error message\n+\tfor short record on unformatted read.\n+\t* io/io.h (gfc_unit):  Add recl_subrecord, bytes_left_subrecord\n+\tand continued.\n+\t* io/file_pos.c (unformatted_backspace):  Change default of record\n+\tmarker size to four bytes.  Loop over subrecords.\n+\t* io/open.c:  Default recl is max_offset.  If\n+\tcompile_options.max_subrecord_length has been set, set set\n+\tu->recl_subrecord to its value, to the maximum value otherwise.\n+\t* io/transfer.c (top level):  Add prototypes for us_read, us_write,\n+\tnext_record_r_unf and next_record_w_unf.\n+\t(read_block_direct):  Separate codepaths for unformatted direct\n+\tand unformatted sequential.  If a recl has been set by the\n+\tuser, use the number of bytes left for the record if it is smaller\n+\tthan the read request.  Loop over subrecords.  Set an error if the\n+\tuser has set a recl and the read was short.\n+\t(write_buf):  Separate codepaths for unformatted direct and\n+\tunformatted sequential. If a recl has been set by the\n+\tuser, use the number of bytes left for the record if it is smaller\n+\tthan the read request.  Loop over subrecords.  Set an error if the\n+\tuser has set a recl and the read was short.\n+\t(us_read):  Add parameter continued (to indicate that bytes_left\n+\tshould not be intialized).  Change default of record marker size\n+\tto four bytes. Use subrecord.  If the subrecord length is smaller than\n+\tzero, this indicates a continuation.\n+\t(us_write):  Add parameter continued (to indicate that the continued\n+\tflag should be set).  Use subrecord.\n+\t(pre_position):  Use 0 for continued on us_write and us_read calls.\n+\t(skip_record):  New function.\n+\t(next_record_r_unf):  New function.\n+\t(next_record_r):  Use next_record_r_unf.\n+\t(write_us_marker):  Default size for record markers is four bytes.\n+\t(next_record_w_unf):  New function.\n+\t(next_record_w):  Use next_record_w_unf.\n+\n 2006-11-25  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* Makefile.am: Remove intrinsics/erf.c and intrinsics/bessel.c."}, {"sha": "df722e4cbc795f5bd91e90ca89e12c1482c26486", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -98,7 +98,7 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n \n /* unformatted_backspace(fpp) -- Move the file backwards for an unformatted\n    sequential file.  We are guaranteed to be between records on entry and \n-   we have to shift to the previous record.  */\n+   we have to shift to the previous record.  Loop over subrecords.  */\n \n static void\n unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n@@ -107,74 +107,74 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n   GFC_INTEGER_4 m4;\n   GFC_INTEGER_8 m8;\n   int length, length_read;\n+  int continued;\n   char *p;\n \n   if (compile_options.record_marker == 0)\n-    length = sizeof (gfc_offset);\n+    length = sizeof (GFC_INTEGER_4);\n   else\n     length = compile_options.record_marker;\n \n-  length_read = length;\n+  do\n+    {\n+      length_read = length;\n \n-  p = salloc_r_at (u->s, &length_read,\n-\t\t   file_position (u->s) - length);\n-  if (p == NULL || length_read != length)\n-    goto io_error;\n+      p = salloc_r_at (u->s, &length_read,\n+\t\t       file_position (u->s) - length);\n+      if (p == NULL || length_read != length)\n+\tgoto io_error;\n \n-  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-  if (u->flags.convert == CONVERT_NATIVE)\n-    {\n-      switch (compile_options.record_marker)\n+      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+      if (u->flags.convert == CONVERT_NATIVE)\n \t{\n-\tcase 0:\n-\t  memcpy (&m, p, sizeof(gfc_offset));\n-\t  break;\n-\n-\tcase sizeof(GFC_INTEGER_4):\n-\t  memcpy (&m4, p, sizeof (m4));\n-\t  m = m4;\n-\t  break;\n-\n-\tcase sizeof(GFC_INTEGER_8):\n-\t  memcpy (&m8, p, sizeof (m8));\n-\t  m = m8;\n-\t  break;\n-\n-\tdefault:\n-\t  runtime_error (\"Illegal value for record marker\");\n-\t  break;\n+\t  switch (length)\n+\t    {\n+\t    case sizeof(GFC_INTEGER_4):\n+\t      memcpy (&m4, p, sizeof (m4));\n+\t      m = m4;\n+\t      break;\n+\n+\t    case sizeof(GFC_INTEGER_8):\n+\t      memcpy (&m8, p, sizeof (m8));\n+\t      m = m8;\n+\t      break;\n+\n+\t    default:\n+\t      runtime_error (\"Illegal value for record marker\");\n+\t      break;\n+\t    }\n \t}\n-    }\n-  else\n-    {\n-      switch (compile_options.record_marker)\n+      else\n \t{\n-\tcase 0:\n-\t  reverse_memcpy (&m, p, sizeof(gfc_offset));\n-\t  break;\n-\n-\tcase sizeof(GFC_INTEGER_4):\n-\t  reverse_memcpy (&m4, p, sizeof (m4));\n-\t  m = m4;\n-\t  break;\n-\n-\tcase sizeof(GFC_INTEGER_8):\n-\t  reverse_memcpy (&m8, p, sizeof (m8));\n-\t  m = m8;\n-\t  break;\n-\n-\tdefault:\n-\t  runtime_error (\"Illegal value for record marker\");\n-\t  break;\n+\t  switch (length)\n+\t    {\n+\t    case sizeof(GFC_INTEGER_4):\n+\t      reverse_memcpy (&m4, p, sizeof (m4));\n+\t      m = m4;\n+\t      break;\n+\n+\t    case sizeof(GFC_INTEGER_8):\n+\t      reverse_memcpy (&m8, p, sizeof (m8));\n+\t      m = m8;\n+\t      break;\n+\n+\t    default:\n+\t      runtime_error (\"Illegal value for record marker\");\n+\t      break;\n+\t    }\n+\n \t}\n \n-    }\n+      continued = m < 0;\n+      if (continued)\n+\tm = -m;\n \n-  if ((new = file_position (u->s) - m - 2*length) < 0)\n-    new = 0;\n+      if ((new = file_position (u->s) - m - 2*length) < 0)\n+\tnew = 0;\n \n-  if (sseek (u->s, new) == FAILURE)\n-    goto io_error;\n+      if (sseek (u->s, new) == FAILURE)\n+\tgoto io_error;\n+    } while (continued);\n \n   u->last_record--;\n   return;"}, {"sha": "4d227dd3b8c80fd10f6464ed6a366daa13001c8e", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -499,12 +499,19 @@ typedef struct gfc_unit\n   unit_mode mode;\n   unit_flags flags;\n \n-  /* recl           -- Record length of the file.\n-     last_record    -- Last record number read or written\n-     maxrec         -- Maximum record number in a direct access file\n-     bytes_left     -- Bytes left in current record.\n-     strm_pos       -- Current position in file for STREAM I/O.  */\n-  gfc_offset recl, last_record, maxrec, bytes_left, strm_pos;\n+  /* recl                 -- Record length of the file.\n+     last_record          -- Last record number read or written\n+     maxrec               -- Maximum record number in a direct access file\n+     bytes_left           -- Bytes left in current record.\n+     strm_pos             -- Current position in file for STREAM I/O.\n+     recl_subrecord       -- Maximum length for subrecord.\n+     bytes_left_subrecord -- Bytes left in current subrecord.  */\n+  gfc_offset recl, last_record, maxrec, bytes_left, strm_pos,\n+    recl_subrecord, bytes_left_subrecord;\n+\n+  /* Set to 1 if we have read a subrecord.  */\n+\n+  int continued;\n \n   __gthread_mutex_t lock;\n   /* Number of threads waiting to acquire this unit's lock."}, {"sha": "06fba75e1df0af11eeba2e4c05ecde57aa2226bc", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -413,23 +413,29 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   else\n     {\n       u->flags.has_recl = 0;\n-      switch (compile_options.record_marker)\n+      u->recl = max_offset;\n+      if (compile_options.max_subrecord_length)\n \t{\n-\tcase 0:\n-\t  u->recl = max_offset;\n-\t  break;\n-\n-\tcase sizeof (GFC_INTEGER_4):\n-\t  u->recl = GFC_INTEGER_4_HUGE;\n-\t  break;\n-\n-\tcase sizeof (GFC_INTEGER_8):\n-\t  u->recl = max_offset;\n-\t  break;\n-\n-\tdefault:\n-\t  runtime_error (\"Illegal value for record marker\");\n-\t  break;\n+\t  u->recl_subrecord = compile_options.max_subrecord_length;\n+\t}\n+      else\n+\t{\n+\t  switch (compile_options.record_marker)\n+\t    {\n+\t    case 0:\n+\t      /* Fall through */\n+\t    case sizeof (GFC_INTEGER_4):\n+\t      u->recl_subrecord = GFC_MAX_SUBRECORD_LENGTH;\n+\t      break;\n+\n+\t    case sizeof (GFC_INTEGER_8):\n+\t      u->recl_subrecord = max_offset - 16;\n+\t      break;\n+\n+\t    default:\n+\t      runtime_error (\"Illegal value for record marker\");\n+\t      break;\n+\t    }\n \t}\n     }\n "}, {"sha": "4270d61e693cb01410bafd6645330317e3a79f45", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 393, "deletions": 159, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -82,6 +82,11 @@ extern void transfer_array (st_parameter_dt *, gfc_array_char *, int,\n \t\t\t    gfc_charlen_type);\n export_proto(transfer_array);\n \n+static void us_read (st_parameter_dt *, int);\n+static void us_write (st_parameter_dt *, int);\n+static void next_record_r_unf (st_parameter_dt *, int);\n+static void next_record_w_unf (st_parameter_dt *, int);\n+\n static const st_option advance_opt[] = {\n   {\"yes\", ADVANCE_YES},\n   {\"no\", ADVANCE_NO},\n@@ -336,12 +341,16 @@ read_block (st_parameter_dt *dtp, int *length)\n }\n \n \n-/* Reads a block directly into application data space.  */\n+/* Reads a block directly into application data space.  This is for\n+   unformatted files.  */\n \n static void\n read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  size_t nread;\n+  size_t to_read_record;\n+  size_t have_read_record;\n+  size_t to_read_subrecord;\n+  size_t have_read_subrecord;\n   int short_record;\n \n   if (is_stream_io (dtp))\n@@ -353,62 +362,169 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t  return;\n \t}\n \n-      nread = *nbytes;\n-      if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n+      to_read_record = *nbytes;\n+      have_read_record = to_read_record;\n+      if (sread (dtp->u.p.current_unit->s, buf, &have_read_record) != 0)\n \t{\n \t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nread; \n-\n-      if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n-\tgenerate_error (&dtp->common, ERROR_END, NULL);\t  \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_read_record; \n \n+      if (to_read_record != have_read_record)\n+\t{\n+\t  /* Short read,  e.g. if we hit EOF.  */\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return;\n+\t}\n       return;\n     }\n \n-  /* Unformatted file with records */\n-  if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n     {\n-      short_record = 1;\n-      nread = (size_t) dtp->u.p.current_unit->bytes_left;\n-      *nbytes = nread;\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n+\t{\n+\t  short_record = 1;\n+\t  to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n+\t  *nbytes = to_read_record;\n \n-      if (dtp->u.p.current_unit->bytes_left == 0)\n+\t  if (dtp->u.p.current_unit->bytes_left == 0)\n+\t    {\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t      generate_error (&dtp->common, ERROR_END, NULL);\n+\t      return;\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  short_record = 0;\n+\t  to_read_record = *nbytes;\n+\t}\n+\n+      dtp->u.p.current_unit->bytes_left -= to_read_record;\n+\n+      if (sread (dtp->u.p.current_unit->s, buf, &to_read_record) != 0)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return;\n+\t}\n+\n+      if (to_read_record != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n \t{\n-\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t  *nbytes = to_read_record;\n \t  generate_error (&dtp->common, ERROR_END, NULL);\n \t  return;\n \t}\n+\n+      if (short_record)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+\t  return;\n+\t}\n+      return;\n     }\n \n+  /* Unformatted sequential.  We loop over the subrecords, reading\n+     until the request has been fulfilled or the record has run out\n+     of continuation subrecords.  */\n+\n+  /* Check whether we exceed the total record length.  */\n+\n+  if (dtp->u.p.current_unit->flags.has_recl)\n+    {\n+      to_read_record =\n+\t*nbytes > (size_t) dtp->u.p.current_unit->bytes_left ?\n+\t*nbytes : (size_t) dtp->u.p.current_unit->bytes_left;\n+      short_record = 1;\n+    }\n   else\n     {\n+      to_read_record = *nbytes;\n       short_record = 0;\n-      nread = *nbytes;\n     }\n+  have_read_record = 0;\n \n-  dtp->u.p.current_unit->bytes_left -= nread;\n-\n-  if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n+  while(1)\n     {\n-      generate_error (&dtp->common, ERROR_OS, NULL);\n-      return;\n-    }\n+      if (dtp->u.p.current_unit->bytes_left_subrecord\n+\t  < (gfc_offset) to_read_record)\n+\t{\n+\t  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t  to_read_record -= to_read_subrecord;\n \n-  if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n-    {\n-      *nbytes = nread;\n-      generate_error (&dtp->common, ERROR_END, NULL);\n-      return;\n+\t  if (dtp->u.p.current_unit->bytes_left_subrecord == 0)\n+\t    {\n+\t      if (dtp->u.p.current_unit->continued)\n+\t\t{\n+\t\t  /* Skip to the next subrecord */\n+\t\t  next_record_r_unf (dtp, 0);\n+\t\t  us_read (dtp, 1);\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  to_read_subrecord = to_read_record;\n+\t  to_read_record = 0;\n+\t}\n+\n+      dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;\n+\n+      have_read_subrecord = to_read_subrecord;\n+      if (sread (dtp->u.p.current_unit->s, buf + have_read_record,\n+\t\t &have_read_subrecord) != 0)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return;\n+\t}\n+\n+      have_read_record += have_read_subrecord;\n+\n+      if (to_read_subrecord != have_read_subrecord)  /* Short read,\n+\t\t\t\t\t\t\te.g. if we hit EOF.  */\n+\t{\n+\t  *nbytes = have_read_record;\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return;\n+\t}\n+\n+      if (to_read_record > 0)\n+\t{\n+\t  if (dtp->u.p.current_unit->continued)\n+\t    {\n+\t      next_record_r_unf (dtp, 0);\n+\t      us_read (dtp, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Normal exit, the read request has been fulfilled.  */\n+\t  break;\n+\t}\n     }\n \n+  dtp->u.p.current_unit->bytes_left -= have_read_record;\n   if (short_record)\n     {\n       generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n       return;\n     }\n+  return;\n }\n \n \n@@ -471,11 +587,20 @@ write_block (st_parameter_dt *dtp, int length)\n }\n \n \n-/* High level interface to swrite(), taking care of errors.  */\n+/* High level interface to swrite(), taking care of errors.  This is only\n+   called for unformatted files.  There are three cases to consider:\n+   Stream I/O, unformatted direct, unformatted sequential.  */\n \n static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n+\n+  size_t have_written, to_write_subrecord;\n+  int short_record;\n+\n+\n+  /* Stream I/O.  */\n+\n   if (is_stream_io (dtp))\n     {\n       if (sseek (dtp->u.p.current_unit->s,\n@@ -484,42 +609,88 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n+\n+      if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return FAILURE;\n+\t}\n+\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+\n+      return SUCCESS;\n     }\n-  else\n+\n+  /* Unformatted direct access.  */\n+\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)\n \t{\n-\t  /* For preconnected units with default record length, set\n-\t     bytes left to unit record length and proceed, otherwise\n-\t     error.  */\n-\t  if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n-\t       || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n-\t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-\t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-\t  else\n-\t    {\n-\t      if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n-\t\tgenerate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n-\t      else\n-\t\tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n-\t      return FAILURE;\n-\t    }\n+\t  generate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+\t  return FAILURE;\n+\t}\n+\n+      if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+\n+      return SUCCESS;\n+\n     }\n \n-  if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n+  /* Unformatted sequential.  */\n+\n+  have_written = 0;\n+\n+  if (dtp->u.p.current_unit->flags.has_recl\n+      && (gfc_offset) nbytes > dtp->u.p.current_unit->bytes_left)\n     {\n-      generate_error (&dtp->common, ERROR_OS, NULL);\n-      return FAILURE;\n+      nbytes = dtp->u.p.current_unit->bytes_left;\n+      short_record = 1;\n+    }\n+  else\n+    {\n+      short_record = 0;\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-\tdtp->u.p.size_used += (gfc_offset) nbytes;\n+  while (1)\n+    {\n+\n+      to_write_subrecord =\n+\t(size_t) dtp->u.p.current_unit->bytes_left_subrecord < nbytes ?\n+\t(size_t) dtp->u.p.current_unit->bytes_left_subrecord : nbytes;\n+\n+      dtp->u.p.current_unit->bytes_left_subrecord -=\n+\t(gfc_offset) to_write_subrecord;\n \n-  dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+      if (swrite (dtp->u.p.current_unit->s, buf + have_written,\n+\t\t  &to_write_subrecord) != 0)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return FAILURE;\n+\t}\n+\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) to_write_subrecord; \n+      nbytes -= to_write_subrecord;\n+      have_written += to_write_subrecord;\n \n+      if (nbytes == 0)\n+\tbreak;\n+\n+      next_record_w_unf (dtp, 1);\n+      us_write (dtp, 1);\n+    }\n+  dtp->u.p.current_unit->bytes_left -= have_written;\n+  if (short_record)\n+    {\n+      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+      return FAILURE;\n+    }\n   return SUCCESS;\n }\n \n@@ -1357,7 +1528,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n /* Preposition a sequential unformatted file while reading.  */\n \n static void\n-us_read (st_parameter_dt *dtp)\n+us_read (st_parameter_dt *dtp, int continued)\n {\n   char *p;\n   int n;\n@@ -1370,7 +1541,7 @@ us_read (st_parameter_dt *dtp)\n     return;\n \n   if (compile_options.record_marker == 0)\n-    n = sizeof (gfc_offset);\n+    n = sizeof (GFC_INTEGER_4);\n   else\n     n = compile_options.record_marker;\n \n@@ -1393,12 +1564,8 @@ us_read (st_parameter_dt *dtp)\n   /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n   if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n     {\n-      switch (compile_options.record_marker)\n+      switch (nr)\n \t{\n-\tcase 0:\n-\t  memcpy (&i, p, sizeof(gfc_offset));\n-\t  break;\n-\n \tcase sizeof(GFC_INTEGER_4):\n \t  memcpy (&i4, p, sizeof (i4));\n \t  i = i4;\n@@ -1415,12 +1582,8 @@ us_read (st_parameter_dt *dtp)\n \t}\n     }\n   else\n-      switch (compile_options.record_marker)\n+      switch (nr)\n \t{\n-\tcase 0:\n-\t  reverse_memcpy (&i, p, sizeof(gfc_offset));\n-\t  break;\n-\n \tcase sizeof(GFC_INTEGER_4):\n \t  reverse_memcpy (&i4, p, sizeof (i4));\n \t  i = i4;\n@@ -1436,36 +1599,48 @@ us_read (st_parameter_dt *dtp)\n \t  break;\n \t}\n \n-  dtp->u.p.current_unit->bytes_left = i;\n+  if (i >= 0)\n+    {\n+      dtp->u.p.current_unit->bytes_left_subrecord = i;\n+      dtp->u.p.current_unit->continued = 0;\n+    }\n+  else\n+    {\n+      dtp->u.p.current_unit->bytes_left_subrecord = -i;\n+      dtp->u.p.current_unit->continued = 1;\n+    }\n+\n+  if (! continued)\n+    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n }\n \n \n /* Preposition a sequential unformatted file while writing.  This\n    amount to writing a bogus length that will be filled in later.  */\n \n static void\n-us_write (st_parameter_dt *dtp)\n+us_write (st_parameter_dt *dtp, int continued)\n {\n   size_t nbytes;\n   gfc_offset dummy;\n \n   dummy = 0;\n \n   if (compile_options.record_marker == 0)\n-    nbytes = sizeof (gfc_offset);\n+    nbytes = sizeof (GFC_INTEGER_4);\n   else\n     nbytes = compile_options.record_marker ;\n \n   if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n     generate_error (&dtp->common, ERROR_OS, NULL);\n \n   /* For sequential unformatted, if RECL= was not specified in the OPEN\n-     we write until we have more bytes than can fit in the record markers.\n-     If disk space runs out first, it will error on the write.  */\n-  if (dtp->u.p.current_unit->flags.has_recl == 0)\n-    dtp->u.p.current_unit->recl = max_offset;\n+     we write until we have more bytes than can fit in the subrecord\n+     markers, then we write a new subrecord.  */\n \n-  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+  dtp->u.p.current_unit->bytes_left_subrecord =\n+    dtp->u.p.current_unit->recl_subrecord;\n+  dtp->u.p.current_unit->continued = continued;\n }\n \n \n@@ -1491,9 +1666,9 @@ pre_position (st_parameter_dt *dtp)\n     \n     case UNFORMATTED_SEQUENTIAL:\n       if (dtp->u.p.mode == READING)\n-\tus_read (dtp);\n+\tus_read (dtp, 0);\n       else\n-\tus_write (dtp);\n+\tus_write (dtp, 0);\n \n       break;\n \n@@ -1886,17 +2061,92 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls)\n   return index;\n }\n \n-/* Space to the next record for read mode.  If the file is not\n-   seekable, we read MAX_READ chunks until we get to the right\n+\n+\n+/* Skip to the end of the current record, taking care of an optional\n+   record marker of size bytes.  If the file is not seekable, we\n+   read chunks of size MAX_READ until we get to the right\n    position.  */\n \n #define MAX_READ 4096\n \n+static void\n+skip_record (st_parameter_dt *dtp, size_t bytes)\n+{\n+  gfc_offset new;\n+  int rlength, length;\n+  char *p;\n+\n+  dtp->u.p.current_unit->bytes_left_subrecord += bytes;\n+  if (dtp->u.p.current_unit->bytes_left_subrecord == 0)\n+    return;\n+\n+  if (is_seekable (dtp->u.p.current_unit->s))\n+    {\n+      new = file_position (dtp->u.p.current_unit->s)\n+\t+ dtp->u.p.current_unit->bytes_left_subrecord;\n+\n+      /* Direct access files do not generate END conditions,\n+\t only I/O errors.  */\n+      if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n+\tgenerate_error (&dtp->common, ERROR_OS, NULL);\n+    }\n+  else\n+    {\t\t\t/* Seek by reading data.  */\n+      while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n+\t{\n+\t  rlength = length =\n+\t    (MAX_READ > dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t    MAX_READ : dtp->u.p.current_unit->bytes_left_subrecord;\n+\n+\t  p = salloc_r (dtp->u.p.current_unit->s, &rlength);\n+\t  if (p == NULL)\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      return;\n+\t    }\n+\n+\t  dtp->u.p.current_unit->bytes_left_subrecord -= length;\n+\t}\n+    }\n+\n+}\n+\n+#undef MAX_READ\n+\n+/* Advance to the next record reading unformatted files, taking\n+   care of subrecords.  If complete_record is nonzero, we loop\n+   until all subrecords are cleared.  */\n+\n+static void\n+next_record_r_unf (st_parameter_dt *dtp, int complete_record)\n+{\n+  size_t bytes;\n+\n+  bytes =  compile_options.record_marker == 0 ?\n+    sizeof (GFC_INTEGER_4) : compile_options.record_marker;\n+\n+  while(1)\n+    {\n+\n+      /* Skip over tail */\n+\n+      skip_record (dtp, bytes);\n+\n+      if ( ! (complete_record && dtp->u.p.current_unit->continued))\n+\treturn;\n+\n+      us_read (dtp, 1);\n+    }\n+}\n+\n+/* Space to the next record for read mode.  */\n+\n static void\n next_record_r (st_parameter_dt *dtp)\n {\n-  gfc_offset new, record;\n-  int bytes_left, rlength, length;\n+  gfc_offset record;\n+  int length, bytes_left;\n   char *p;\n \n   switch (current_mode (dtp))\n@@ -1906,47 +2156,12 @@ next_record_r (st_parameter_dt *dtp)\n       return;\n     \n     case UNFORMATTED_SEQUENTIAL:\n-\n-      /* Skip over tail */\n-      dtp->u.p.current_unit->bytes_left +=\n-\tcompile_options.record_marker == 0 ?\n-\tsizeof (gfc_offset) : compile_options.record_marker;\n-      \n-      /* Fall through...  */\n+      next_record_r_unf (dtp, 1);\n+      break;\n \n     case FORMATTED_DIRECT:\n     case UNFORMATTED_DIRECT:\n-      if (dtp->u.p.current_unit->bytes_left == 0)\n-\tbreak;\n-\n-      if (is_seekable (dtp->u.p.current_unit->s))\n-\t{\n-\t  new = file_position (dtp->u.p.current_unit->s)\n-\t\t+ dtp->u.p.current_unit->bytes_left;\n-\n-\t  /* Direct access files do not generate END conditions,\n-\t     only I/O errors.  */\n-\t  if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n-\t    generate_error (&dtp->common, ERROR_OS, NULL);\n-\n-\t}\n-      else\n-\t{\t\t\t/* Seek by reading data.  */\n-\t  while (dtp->u.p.current_unit->bytes_left > 0)\n-\t    {\n-\t      rlength = length = (MAX_READ > dtp->u.p.current_unit->bytes_left) ?\n-\t\tMAX_READ : dtp->u.p.current_unit->bytes_left;\n-\n-\t      p = salloc_r (dtp->u.p.current_unit->s, &rlength);\n-\t      if (p == NULL)\n-\t\t{\n-\t\t  generate_error (&dtp->common, ERROR_OS, NULL);\n-\t\t  break;\n-\t\t}\n-\n-\t      dtp->u.p.current_unit->bytes_left -= length;\n-\t    }\n-\t}\n+      skip_record (dtp, 0);\n       break;\n \n     case FORMATTED_STREAM:\n@@ -2025,19 +2240,15 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n   char p[sizeof (GFC_INTEGER_8)];\n \n   if (compile_options.record_marker == 0)\n-    len = sizeof (gfc_offset);\n+    len = sizeof (GFC_INTEGER_4);\n   else\n     len = compile_options.record_marker;\n \n   /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n   if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n     {\n-      switch (compile_options.record_marker)\n+      switch (len)\n \t{\n-\tcase 0:\n-\t  return swrite (dtp->u.p.current_unit->s, &buf, &len);\n-\t  break;\n-\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n \t  return swrite (dtp->u.p.current_unit->s, &buf4, &len);\n@@ -2055,13 +2266,8 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n     }\n   else\n     {\n-      switch (compile_options.record_marker)\n+      switch (len)\n \t{\n-\tcase 0:\n-\t  reverse_memcpy (p, &buf, sizeof (gfc_offset));\n-\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n-\t  break;\n-\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n \t  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));\n@@ -2070,7 +2276,7 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n-\t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_4));\n+\t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));\n \t  return swrite (dtp->u.p.current_unit->s, p, &len);\n \t  break;\n \n@@ -2082,16 +2288,72 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \n }\n \n+/* Position to the next (sub)record in write mode for\n+   unformatted sequential files.  */\n+\n+static void\n+next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n+{\n+  gfc_offset c, m, m_write;\n+  size_t record_marker;\n+\n+  /* Bytes written.  */\n+  m = dtp->u.p.current_unit->recl_subrecord\n+    - dtp->u.p.current_unit->bytes_left_subrecord;\n+  c = file_position (dtp->u.p.current_unit->s);\n+\n+  /* Write the length tail.  If we finish a record containing\n+     subrecords, we write out the negative length.  */\n+\n+  if (dtp->u.p.current_unit->continued)\n+    m_write = -m;\n+  else\n+    m_write = m;\n+\n+  if (write_us_marker (dtp, m_write) != 0)\n+    goto io_error;\n+\n+  if (compile_options.record_marker == 0)\n+    record_marker = sizeof (GFC_INTEGER_4);\n+  else\n+    record_marker = compile_options.record_marker;\n+\n+  /* Seek to the head and overwrite the bogus length with the real\n+     length.  */\n+\n+  if (sseek (dtp->u.p.current_unit->s, c - m - record_marker)\n+      == FAILURE)\n+    goto io_error;\n+\n+  if (next_subrecord)\n+    m_write = -m;\n+  else\n+    m_write = m;\n+\n+  if (write_us_marker (dtp, m_write) != 0)\n+    goto io_error;\n+\n+  /* Seek past the end of the current record.  */\n+\n+  if (sseek (dtp->u.p.current_unit->s, c + record_marker) == FAILURE)\n+    goto io_error;\n+\n+  return;\n+\n+ io_error:\n+  generate_error (&dtp->common, ERROR_OS, NULL);\n+  return;\n+\n+}\n \n /* Position to the next record in write mode.  */\n \n static void\n next_record_w (st_parameter_dt *dtp, int done)\n {\n-  gfc_offset c, m, record, max_pos;\n+  gfc_offset m, record, max_pos;\n   int length;\n   char *p;\n-  size_t record_marker;\n \n   /* Zero counters for X- and T-editing.  */\n   max_pos = dtp->u.p.max_pos;\n@@ -2119,35 +2381,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n       break;\n \n     case UNFORMATTED_SEQUENTIAL:\n-      /* Bytes written.  */\n-      m = dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left;\n-      c = file_position (dtp->u.p.current_unit->s);\n-\n-      /* Write the length tail.  */\n-\n-      if (write_us_marker (dtp, m) != 0)\n-\tgoto io_error;\n-\n-      if (compile_options.record_marker == 4)\n-\trecord_marker = sizeof(GFC_INTEGER_4);\n-      else\n-\trecord_marker = sizeof (gfc_offset);\n-\n-      /* Seek to the head and overwrite the bogus length with the real\n-\t length.  */\n-\n-      if (sseek (dtp->u.p.current_unit->s, c - m - record_marker)\n-\t  == FAILURE)\n-\tgoto io_error;\n-\n-      if (write_us_marker (dtp, m) != 0)\n-\tgoto io_error;\n-\n-      /* Seek past the end of the current record.  */\n-\n-      if (sseek (dtp->u.p.current_unit->s, c + record_marker) == FAILURE)\n-\tgoto io_error;\n-\n+      next_record_w_unf (dtp, 0);\n       break;\n \n     case FORMATTED_STREAM:"}, {"sha": "644a0adc7844557bfaaf50d283d58948c9ef38c3", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -370,6 +370,7 @@ typedef struct\n   int pedantic;\n   int convert;\n   size_t record_marker;\n+  int max_subrecord_length;\n }\n compile_options_t;\n \n@@ -379,6 +380,7 @@ internal_proto(compile_options);\n extern void init_compile_options (void);\n internal_proto(init_compile_options);\n \n+#define GFC_MAX_SUBRECORD_LENGTH 2147483639   /* 2**31 - 9 */\n \n /* Structure for statement options.  */\n "}, {"sha": "b2aef05a832ee40dcd8eff6d9fea5fda437b578d", "filename": "libgfortran/runtime/compile_options.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fruntime%2Fcompile_options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fruntime%2Fcompile_options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fcompile_options.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -86,17 +86,29 @@ set_record_marker (int val)\n   switch(val)\n     {\n     case 4:\n-      if (sizeof (GFC_INTEGER_4) != sizeof (gfc_offset))\n-\tcompile_options.record_marker = sizeof (GFC_INTEGER_4);\n+      compile_options.record_marker = sizeof (GFC_INTEGER_4);\n       break;\n \n     case 8:\n-      if (sizeof (GFC_INTEGER_8) != sizeof (gfc_offset))\n-\tcompile_options.record_marker = sizeof (GFC_INTEGER_8);\n+      compile_options.record_marker = sizeof (GFC_INTEGER_8);\n       break;\n \n     default:\n       runtime_error (\"Invalid value for record marker\");\n       break;\n     }\n }\n+\n+extern void set_max_subrecord_length (int);\n+export_proto (set_max_subrecord_length);\n+\n+void set_max_subrecord_length(int val)\n+{\n+  if (val > GFC_MAX_SUBRECORD_LENGTH || val < 1)\n+    {\n+      runtime_error (\"Invalid value for maximum subrecord length\");\n+      return;\n+    }\n+\n+  compile_options.max_subrecord_length = val;\n+}"}, {"sha": "122f6d14bab426f596b4a45b5ae37441fbd52e0d", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=07b3bbf2007bb9fab8b6c08321abf9c2cc7a2443", "patch": "@@ -437,7 +437,7 @@ translate_error (int code)\n       break;\n \n     case ERROR_SHORT_RECORD:\n-      p = \"Short record on unformatted read\";\n+      p = \"I/O past end of record on unformatted file\";\n       break;\n \n     default:"}]}