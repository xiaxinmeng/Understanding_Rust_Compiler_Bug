{"sha": "e008606e0208a1dde5f1699fbe78b937025fdc56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAwODYwNmUwMjA4YTFkZGU1ZjE2OTlmYmU3OGI5MzcwMjVmZGM1Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-19T21:59:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-19T21:59:41Z"}, "message": "(SECONDARY_{IN,OUT}PUT_RELOAD_CLASS): Don't need for QImode or HImode if TARGET_BYTE_OPS.\n\n(SECONDARY_{IN,OUT}PUT_RELOAD_CLASS): Don't need for QImode or HImode\nif TARGET_BYTE_OPS.\n(ASM_FILE_START): Write a .arch directive.\n(STACK_CHECK_BUILTIN): New macro.\n\nFrom-SVN: r14495", "tree": {"sha": "67b69379bc5ac3d55e0e2235237545a1fd4abf0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67b69379bc5ac3d55e0e2235237545a1fd4abf0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e008606e0208a1dde5f1699fbe78b937025fdc56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e008606e0208a1dde5f1699fbe78b937025fdc56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e008606e0208a1dde5f1699fbe78b937025fdc56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e008606e0208a1dde5f1699fbe78b937025fdc56/comments", "author": null, "committer": null, "parents": [{"sha": "9b009d452a9006b65eec19d766791ee6ac970f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b009d452a9006b65eec19d766791ee6ac970f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b009d452a9006b65eec19d766791ee6ac970f0e"}], "stats": {"total": 15, "additions": 11, "deletions": 4}, "files": [{"sha": "2b6976a01d2c64cd02d1608a8e0d4e4ba7bde898", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e008606e0208a1dde5f1699fbe78b937025fdc56/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e008606e0208a1dde5f1699fbe78b937025fdc56/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e008606e0208a1dde5f1699fbe78b937025fdc56", "patch": "@@ -674,7 +674,8 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n-   QImode and HImode from an aligned address to a general register. \n+   QImode and HImode from an aligned address to a general register\n+   unless byte instructions are permitted.\n    We also cannot load an unaligned address or a paradoxical SUBREG into an\n    FP register.   */\n \n@@ -688,7 +689,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n   && (((CLASS) == FLOAT_REGS\t\t\t\t\t\t\\\n        && ((MODE) == SImode || (MODE) == HImode || (MODE) == QImode))\t\\\n       || (((MODE) == QImode || (MODE) == HImode)\t\t\t\\\n-\t  && unaligned_memory_operand (IN, MODE))))\t\t\t\\\n+\t  && ! TARGET_BYTE_OPS && unaligned_memory_operand (IN, MODE)))) \\\n  ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n  : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == MEM\t\t\t\\\n     && GET_CODE (XEXP (IN, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n@@ -704,7 +705,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n        && (GET_CODE (SUBREG_REG (OUT)) == MEM\t\t\t\t\\\n \t   || (GET_CODE (SUBREG_REG (OUT)) == REG\t\t\t\\\n \t       && REGNO (SUBREG_REG (OUT)) >= FIRST_PSEUDO_REGISTER)))) \\\n-  && (((MODE) == HImode || (MODE) == QImode\t\t\t\t\\\n+  && ((((MODE) == HImode || (MODE) == QImode) && ! TARGET_BYTE_OPS\t\\\n        || ((MODE) == SImode && (CLASS) == FLOAT_REGS))))\t\t\\\n  ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n  : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == MEM\t\t\t\\\n@@ -789,6 +790,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    On Alpha, don't define this because there are no push insns.  */\n /*  #define PUSH_ROUNDING(BYTES) */\n \n+/* Define this to be nonzero if stack checking is built into the ABI.  */\n+#define STACK_CHECK_BUILTIN 1\n+\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n@@ -1696,8 +1700,11 @@ extern void final_prescan_insn ();\n {\t\t\t\t\t\t\t\t\\\n   alpha_write_verstamp (FILE);\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.set volatile\\n\");                                \\\n+  fprintf (FILE, \"\\t.set volatile\\n\");                          \\\n   fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.arch %s\\n\",\t\t\t\t\\\n+\t   (TARGET_BYTE_OPS ? \"ev56\"\t\t\t\t\\\n+\t    : alpha_cpu == PROCESSOR_EV4 ? \"ev4\" : \"ev5\"));\t\\\n   ASM_OUTPUT_SOURCE_FILENAME (FILE, main_input_filename);\t\\\n }\n "}]}