{"sha": "e28072cdc85406f97fb06389639f5b9933101201", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4MDcyY2RjODU0MDZmOTdmYjA2Mzg5NjM5ZjViOTkzMzEwMTIwMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:10:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:10:58Z"}, "message": "[multiple changes]\n\n2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch13.adb (Aspect_Specifications_Present)): In earlier than\n\tAda2012 mode, assume that a legal aspect name following \"with\"\n\tkeyword is an older gnat switch and not a misplaced with_clause.\n\n2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry for Aspect_Refined_Pre in\n\ttable Canonical_Aspect.\n\t(Aspects_On_Body_OK): Renamed to\n\tAspects_On_Body_Or_Stub_OK.\n\t(Aspects_On_Body_Or_Stub_OK):\n\tUpdate the query in table Aspect_On_Body_OK.\n\t* aspects.ads: Add an entry for Aspect_Refined_Pre in tables\n\tAspect_Id, Aspect_Argument, Aspect_Names, Aspect_Delay,\n\tAspect_On_Body_Or_Stub_OK. Table Aspect_On_Body_OK is now known as\n\tAspect_On_Body_Or_Stub_OK.  Add a section of aspect specifications\n\tthat apply to body stubs.\n\t(Aspects_On_Body_OK): Renamed to Aspects_On_Body_Or_Stub_OK.\n\t(Aspects_On_Body_Or_Stub_OK): Update the comment on usage.\n\t* par-prag.adb: Add pragma Refined_Pre to the list of pragmas\n\tthat do not require special processing by the parser.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Delay the\n\tanalysis of aspect specifications that apply to a body stub\n\tuntil the proper body is analyzed.\n\t* sem_ch10.adb: Add with and use clause for Sem_Ch13.\n\t(Analyze_Package_Body_Stub): Set the corresponding spec of the stub.\n\t(Analyze_Proper_Body): Relocate all pragmas that apply\n\tto a subprogram body stub to the declarations of the proper\n\tbody. Analyze the aspect specifications of the stub when the\n\tproper body is not present.\n\t(Analyze_Protected_Body_Stub): Set the corresponding spec of the stub.\n\t(Analyze_Task_Body_Stub): Set the corresponding spec of the stub.\n\t(Move_Stub_Pragmas_To_Body): New routine.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Refined_Pre.\n\t(Check_Aspect_At_Freeze_Point): Aspect\n\tRefined_Pre does not need delayed processing at the freeze point.\n\t* sem_prag.adb: Remove with and use clause for Snames. Add\n\tan entry for Pragma_Refined_Pre in table Sig_Flags.\n\t(Analyze_Pragma): Add processing for pragma Refined_Pre.\n\t* sem_prag.ads: Add with and use clause for Snames. Add table\n\tPragma_On_Stub_OK.\n\t* sinfo.adb (Corresponding_Spec_Of_Stub): New routine.\n\t(Set_Corresponding_Spec_Of_Stub): New routine.\n\t* sinfo.ads: Add new attribute Corresponding_Spec_Of_Stub\n\talong with comment on usage and occurrences in nodes.\n\t(Corresponding_Spec_Of_Stub): New routine along with pragma\n\tInline.\n\t(Set_Corresponding_Spec_Of_Stub): New routine along\n\twith pragma Inline.\n\t* snames.ads-tmpl: Add new predefined name for Refined_Pre. Add\n\tnew Pragma_Id for Refined_Pre.\n\n2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Package_Instantiation,\n\tAnalyze_Subprogram_Instantiation): Improve error message when\n\tname in instantiation does not designate a generic unit of the\n\tright kind.\n\nFrom-SVN: r203355", "tree": {"sha": "33b0b66fb30d3aa482ca82a0cb0342e91e27b07b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33b0b66fb30d3aa482ca82a0cb0342e91e27b07b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28072cdc85406f97fb06389639f5b9933101201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28072cdc85406f97fb06389639f5b9933101201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28072cdc85406f97fb06389639f5b9933101201", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28072cdc85406f97fb06389639f5b9933101201/comments", "author": null, "committer": null, "parents": [{"sha": "13b72c22f731e9be33af0331f244f3407dca12f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b72c22f731e9be33af0331f244f3407dca12f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b72c22f731e9be33af0331f244f3407dca12f8"}], "stats": {"total": 524, "additions": 460, "deletions": 64}, "files": [{"sha": "be5c54763d66e784f77d48022d86f0835dcbce75", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -1,3 +1,65 @@\n+2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch13.adb (Aspect_Specifications_Present)): In earlier than\n+\tAda2012 mode, assume that a legal aspect name following \"with\"\n+\tkeyword is an older gnat switch and not a misplaced with_clause.\n+\n+2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry for Aspect_Refined_Pre in\n+\ttable Canonical_Aspect.\n+\t(Aspects_On_Body_OK): Renamed to\n+\tAspects_On_Body_Or_Stub_OK.\n+\t(Aspects_On_Body_Or_Stub_OK):\n+\tUpdate the query in table Aspect_On_Body_OK.\n+\t* aspects.ads: Add an entry for Aspect_Refined_Pre in tables\n+\tAspect_Id, Aspect_Argument, Aspect_Names, Aspect_Delay,\n+\tAspect_On_Body_Or_Stub_OK. Table Aspect_On_Body_OK is now known as\n+\tAspect_On_Body_Or_Stub_OK.  Add a section of aspect specifications\n+\tthat apply to body stubs.\n+\t(Aspects_On_Body_OK): Renamed to Aspects_On_Body_Or_Stub_OK.\n+\t(Aspects_On_Body_Or_Stub_OK): Update the comment on usage.\n+\t* par-prag.adb: Add pragma Refined_Pre to the list of pragmas\n+\tthat do not require special processing by the parser.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Delay the\n+\tanalysis of aspect specifications that apply to a body stub\n+\tuntil the proper body is analyzed.\n+\t* sem_ch10.adb: Add with and use clause for Sem_Ch13.\n+\t(Analyze_Package_Body_Stub): Set the corresponding spec of the stub.\n+\t(Analyze_Proper_Body): Relocate all pragmas that apply\n+\tto a subprogram body stub to the declarations of the proper\n+\tbody. Analyze the aspect specifications of the stub when the\n+\tproper body is not present.\n+\t(Analyze_Protected_Body_Stub): Set the corresponding spec of the stub.\n+\t(Analyze_Task_Body_Stub): Set the corresponding spec of the stub.\n+\t(Move_Stub_Pragmas_To_Body): New routine.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Refined_Pre.\n+\t(Check_Aspect_At_Freeze_Point): Aspect\n+\tRefined_Pre does not need delayed processing at the freeze point.\n+\t* sem_prag.adb: Remove with and use clause for Snames. Add\n+\tan entry for Pragma_Refined_Pre in table Sig_Flags.\n+\t(Analyze_Pragma): Add processing for pragma Refined_Pre.\n+\t* sem_prag.ads: Add with and use clause for Snames. Add table\n+\tPragma_On_Stub_OK.\n+\t* sinfo.adb (Corresponding_Spec_Of_Stub): New routine.\n+\t(Set_Corresponding_Spec_Of_Stub): New routine.\n+\t* sinfo.ads: Add new attribute Corresponding_Spec_Of_Stub\n+\talong with comment on usage and occurrences in nodes.\n+\t(Corresponding_Spec_Of_Stub): New routine along with pragma\n+\tInline.\n+\t(Set_Corresponding_Spec_Of_Stub): New routine along\n+\twith pragma Inline.\n+\t* snames.ads-tmpl: Add new predefined name for Refined_Pre. Add\n+\tnew Pragma_Id for Refined_Pre.\n+\n+2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Package_Instantiation,\n+\tAnalyze_Subprogram_Instantiation): Improve error message when\n+\tname in instantiation does not designate a generic unit of the\n+\tright kind.\n+\n 2013-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch3.adb (Expand_N_Variant_Part): Expand statically"}, {"sha": "e20cae4782fc97ab44331fe9bcba902073cdabac", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -140,11 +140,11 @@ package body Aspects is\n       end if;\n    end Aspect_Specifications;\n \n-   ------------------------\n-   -- Aspects_On_Body_OK --\n-   ------------------------\n+   --------------------------------\n+   -- Aspects_On_Body_Or_Stub_OK --\n+   --------------------------------\n \n-   function Aspects_On_Body_OK (N : Node_Id) return Boolean is\n+   function Aspects_On_Body_Or_Stub_OK (N : Node_Id) return Boolean is\n       Aspect  : Node_Id;\n       Aspects : List_Id;\n \n@@ -159,20 +159,20 @@ package body Aspects is\n                                             N_Task_Body));\n \n       --  Look through all aspects and see whether they can be applied to a\n-      --  body.\n+      --  body [stub].\n \n       Aspects := Aspect_Specifications (N);\n       Aspect  := First (Aspects);\n       while Present (Aspect) loop\n-         if not Aspect_On_Body_OK (Get_Aspect_Id (Aspect)) then\n+         if not Aspect_On_Body_Or_Stub_OK (Get_Aspect_Id (Aspect)) then\n             return False;\n          end if;\n \n          Next (Aspect);\n       end loop;\n \n       return True;\n-   end Aspects_On_Body_OK;\n+   end Aspects_On_Body_Or_Stub_OK;\n \n    -----------------\n    -- Find_Aspect --\n@@ -368,9 +368,9 @@ package body Aspects is\n       N_Single_Protected_Declaration           => True,\n       N_Single_Task_Declaration                => True,\n       N_Subprogram_Body                        => True,\n+      N_Subprogram_Body_Stub                   => True,\n       N_Subprogram_Declaration                 => True,\n       N_Subprogram_Renaming_Declaration        => True,\n-      N_Subprogram_Body_Stub                   => True,\n       N_Subtype_Declaration                    => True,\n       N_Task_Body                              => True,\n       N_Task_Body_Stub                         => True,\n@@ -466,6 +466,7 @@ package body Aspects is\n     Aspect_Pure_05                      => Aspect_Pure_05,\n     Aspect_Pure_12                      => Aspect_Pure_12,\n     Aspect_Pure_Function                => Aspect_Pure_Function,\n+    Aspect_Refined_Pre                  => Aspect_Refined_Pre,\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n     Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,\n     Aspect_Remote_Types                 => Aspect_Remote_Types,"}, {"sha": "66c4b857da054c77bc3bcac7426ffb303841308b", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -111,6 +111,7 @@ package Aspects is\n       Aspect_Predicate,                     -- GNAT\n       Aspect_Priority,\n       Aspect_Read,\n+      Aspect_Refined_Pre,                   -- GNAT\n       Aspect_Relative_Deadline,\n       Aspect_Scalar_Storage_Order,          -- GNAT\n       Aspect_Simple_Storage_Pool,           -- GNAT\n@@ -319,6 +320,7 @@ package Aspects is\n       Aspect_Predicate               => Expression,\n       Aspect_Priority                => Expression,\n       Aspect_Read                    => Name,\n+      Aspect_Refined_Pre             => Expression,\n       Aspect_Relative_Deadline       => Expression,\n       Aspect_Scalar_Storage_Order    => Expression,\n       Aspect_Simple_Storage_Pool     => Name,\n@@ -415,6 +417,7 @@ package Aspects is\n       Aspect_Pure_12                      => Name_Pure_12,\n       Aspect_Pure_Function                => Name_Pure_Function,\n       Aspect_Read                         => Name_Read,\n+      Aspect_Refined_Pre                  => Name_Refined_Pre,\n       Aspect_Relative_Deadline            => Name_Relative_Deadline,\n       Aspect_Remote_Access_Type           => Name_Remote_Access_Type,\n       Aspect_Remote_Call_Interface        => Name_Remote_Call_Interface,\n@@ -636,6 +639,7 @@ package Aspects is\n       Aspect_Convention                   => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,\n+      Aspect_Refined_Pre                  => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n       Aspect_Test_Case                    => Never_Delay,\n@@ -657,15 +661,44 @@ package Aspects is\n       Aspect_Volatile                     => Rep_Aspect,\n       Aspect_Volatile_Components          => Rep_Aspect);\n \n-   --  The following table indicates which aspects can apply simultaneously to\n-   --  both subprogram/package specs and bodies. For instance, the following is\n-   --  legal:\n+   ------------------------------------------------\n+   -- Handling of Aspect Specifications on Stubs --\n+   ------------------------------------------------\n+\n+   --  Aspects that appear on the following stub nodes\n+\n+   --    N_Package_Body_Stub\n+   --    N_Protected_Body_Stub\n+   --    N_Subprogram_Body_Stub\n+   --    N_Task_Body_Stub\n+\n+   --  are treated as if they apply to the corresponding proper body. Their\n+   --  analysis is postponed until the analysis of the proper body takes place\n+   --  (see Analyze_Proper_Body). The delay is required because the analysis\n+   --  may generate extra code which would be harder to relocate to the body.\n+   --  If the proper body is present, the aspect specifications are relocated\n+   --  to the corresponding body node:\n+\n+   --    N_Package_Body\n+   --    N_Protected_Body\n+   --    N_Subprogram_Body\n+   --    N_Task_Body\n+\n+   --  The subsequent analysis takes care of the aspect-to-pragma conversions\n+   --  and verification of pragma legality. In the case where the proper body\n+   --  is not available, the aspect specifications are analyzed on the spot\n+   --  (see Analyze_Proper_Body) to catch potential errors.\n+\n+   --  The following table lists all aspects that can apply to a subprogram\n+   --  body [stub]. For instance, the following example is legal:\n \n    --    package P with SPARK_Mode ...;\n    --    package body P with SPARK_Mode is ...;\n \n-   Aspect_On_Body_OK : constant array (Aspect_Id) of Boolean :=\n-     (Aspect_SPARK_Mode                   => True,\n+   Aspect_On_Body_Or_Stub_OK : constant array (Aspect_Id) of Boolean :=\n+     (Aspect_Refined_Pre                  => True,\n+      Aspect_SPARK_Mode                   => True,\n+      Aspect_Warnings                     => True,\n       others                              => False);\n \n    ---------------------------------------------------\n@@ -696,9 +729,9 @@ package Aspects is\n    --  Replace calls, and this function may be used to retrieve the aspect\n    --  specifications for the original rewritten node in such cases.\n \n-   function Aspects_On_Body_OK (N : Node_Id) return Boolean;\n+   function Aspects_On_Body_Or_Stub_OK (N : Node_Id) return Boolean;\n    --  N denotes a body [stub] with aspects. Determine whether all aspects of N\n-   --  can appear simultaneously in bodies and specs.\n+   --  are allowed to appear on a body [stub].\n \n    function Find_Aspect (Id : Entity_Id; A : Aspect_Id) return Node_Id;\n    --  Find the aspect specification of aspect A associated with entity I."}, {"sha": "0fadd302daa794487b6a39dc90318a252a78cb08", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -111,9 +111,11 @@ package body Ch13 is\n \n             --  The identifier may be the name of a boolean aspect with a\n             --  defaulted True value. Further checks when analyzing aspect\n-            --  specification.\n+            --  specification, which may include further aspects.\n \n-            elsif Token = Tok_Comma then\n+            elsif Token = Tok_Comma\n+              or else Token = Tok_Semicolon\n+            then\n                Result := True;\n \n             elsif Token = Tok_Apostrophe then"}, {"sha": "91e9b96b138d222188db7470df15f6a32714fac0", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -1250,6 +1250,7 @@ begin\n            Pragma_Pure_12                        |\n            Pragma_Pure_Function                  |\n            Pragma_Queuing_Policy                 |\n+           Pragma_Refined_Pre                    |\n            Pragma_Relative_Deadline              |\n            Pragma_Remote_Access_Type             |\n            Pragma_Remote_Call_Interface          |"}, {"sha": "c68c5caa46adf378e140ee6560ee3774a8f59dd6", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 112, "deletions": 4, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -53,6 +53,7 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Dist; use Sem_Dist;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n@@ -1581,6 +1582,7 @@ package body Sem_Ch10 is\n \n          Set_Has_Completion (Nam);\n          Set_Scope (Defining_Entity (N), Current_Scope);\n+         Set_Corresponding_Spec_Of_Stub (N, Nam);\n          Generate_Reference (Nam, Id, 'b');\n          Analyze_Proper_Body (N, Nam);\n       end if;\n@@ -1594,12 +1596,85 @@ package body Sem_Ch10 is\n       Subunit_Name : constant Unit_Name_Type := Get_Unit_Name (N);\n       Unum         : Unit_Number_Type;\n \n+      procedure Move_Stub_Pragmas_To_Body (Bod : Node_Id);\n+      --  Relocate all pragmas that apply to a subprogram body stub to the\n+      --  declarations of proper body Bod.\n+      --  Should we do this for the reamining body stub kinds???\n+\n       procedure Optional_Subunit;\n       --  This procedure is called when the main unit is a stub, or when we\n       --  are not generating code. In such a case, we analyze the subunit if\n       --  present, which is user-friendly and in fact required for ASIS, but\n       --  we don't complain if the subunit is missing.\n \n+      -------------------------------\n+      -- Move_Stub_Pragmas_To_Body --\n+      -------------------------------\n+\n+      procedure Move_Stub_Pragmas_To_Body (Bod : Node_Id) is\n+         procedure Move_Pragma (Prag : Node_Id);\n+         --  Relocate one pragma to the declarations of Bod\n+\n+         -----------------\n+         -- Move_Pragma --\n+         -----------------\n+\n+         procedure Move_Pragma (Prag : Node_Id) is\n+            Decls : List_Id := Declarations (Bod);\n+\n+         begin\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (Bod, Decls);\n+            end if;\n+\n+            --  Unhook the pragma from its current list\n+\n+            Remove (Prag);\n+            Prepend (Prag, Decls);\n+         end Move_Pragma;\n+\n+         --  Local variables\n+\n+         Next_Stmt : Node_Id;\n+         Stmt      : Node_Id;\n+\n+      --  Start of processing for Move_Stub_Pragmas_To_Body\n+\n+      begin\n+         pragma Assert (Nkind (N) = N_Subprogram_Body_Stub);\n+\n+         --  Perform a bit of a lookahead - peek at any subsequent source\n+         --  pragmas while skipping internally generated code.\n+\n+         Stmt := Next (N);\n+         while Present (Stmt) loop\n+            Next_Stmt := Next (Stmt);\n+\n+            --  Move a source pragma that applies to a subprogram stub to the\n+            --  declarations of the proper body.\n+\n+            if Comes_From_Source (Stmt)\n+              and then Nkind (Stmt) = N_Pragma\n+              and then Pragma_On_Stub_OK (Get_Pragma_Id (Stmt))\n+            then\n+               Move_Pragma (Stmt);\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Stmt) then\n+               null;\n+\n+            --  No valid pragmas are available for relocation\n+\n+            else\n+               exit;\n+            end if;\n+\n+            Stmt := Next_Stmt;\n+         end loop;\n+      end Move_Stub_Pragmas_To_Body;\n+\n       ----------------------\n       -- Optional_Subunit --\n       ----------------------\n@@ -1664,6 +1739,10 @@ package body Sem_Ch10 is\n          end if;\n       end Optional_Subunit;\n \n+      --  Local variables\n+\n+      Stub_Id : Entity_Id;\n+\n    --  Start of processing for Analyze_Proper_Body\n \n    begin\n@@ -1818,6 +1897,7 @@ package body Sem_Ch10 is\n \n                declare\n                   Comp_Unit : constant Node_Id := Cunit (Unum);\n+                  Prop_Body : Node_Id;\n \n                begin\n                   --  Check for child unit instead of subunit\n@@ -1830,6 +1910,8 @@ package body Sem_Ch10 is\n                   --  OK, we have a subunit\n \n                   else\n+                     Prop_Body := Proper_Body (Unit (Comp_Unit));\n+\n                      --  Set corresponding stub (even if errors)\n \n                      Set_Corresponding_Stub (Unit (Comp_Unit), N);\n@@ -1845,11 +1927,17 @@ package body Sem_Ch10 is\n                         SCO_Record (Unum);\n                      end if;\n \n-                     --  Propagate any aspect specifications associated with\n-                     --  with the stub to the proper body.\n+                     --  Propagate all aspect specifications associated with\n+                     --  the stub to the proper body.\n \n-                     Move_Or_Merge_Aspects\n-                       (From => N, To => Proper_Body (Unit (Comp_Unit)));\n+                     Move_Or_Merge_Aspects (From => N, To => Prop_Body);\n+\n+                     --  Propagate all source pragmas associated with a\n+                     --  subprogram body stub to the proper body.\n+\n+                     if Nkind (N) = N_Subprogram_Body_Stub then\n+                        Move_Stub_Pragmas_To_Body (Prop_Body);\n+                     end if;\n \n                      --  Analyze the unit if semantics active\n \n@@ -1869,6 +1957,24 @@ package body Sem_Ch10 is\n                      Version_Update (Cunit (Main_Unit), Comp_Unit);\n                   end if;\n                end;\n+\n+            --  The unit which should contain the proper subprogram body does\n+            --  not exist. Analyze the aspect specifications of the stub (if\n+            --  any).\n+\n+            elsif Nkind (N) = N_Subprogram_Body_Stub\n+              and then Has_Aspects (N)\n+            then\n+               Stub_Id := Defining_Unit_Name (Specification (N));\n+\n+               --  Restore the proper visibility of the stub and its formals\n+\n+               Push_Scope (Stub_Id);\n+               Install_Formals (Stub_Id);\n+\n+               Analyze_Aspect_Specifications (N, Stub_Id);\n+\n+               Pop_Scope;\n             end if;\n          end if;\n \n@@ -1906,6 +2012,7 @@ package body Sem_Ch10 is\n       else\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Set_Has_Completion (Etype (Nam));\n+         Set_Corresponding_Spec_Of_Stub (N, Nam);\n          Generate_Reference (Nam, Defining_Identifier (N), 'b');\n          Analyze_Proper_Body (N, Etype (Nam));\n       end if;\n@@ -2351,6 +2458,7 @@ package body Sem_Ch10 is\n       else\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Generate_Reference (Nam, Defining_Identifier (N), 'b');\n+         Set_Corresponding_Spec_Of_Stub (N, Nam);\n \n          --  Check for duplicate stub, if so give message and terminate\n "}, {"sha": "f9e525652d4ff8f826029c91eedc8746c0c33313", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -3479,8 +3479,8 @@ package body Sem_Ch12 is\n             Error_Msg_N\n               (\"cannot instantiate a limited withed package\", Gen_Id);\n          else\n-            Error_Msg_N\n-              (\"expect name of generic package in instantiation\", Gen_Id);\n+            Error_Msg_NE\n+              (\"& is not the name of a generic package\", Gen_Id, Gen_Unit);\n          end if;\n \n          Restore_Env;\n@@ -4669,34 +4669,17 @@ package body Sem_Ch12 is\n       --  Verify that it is a generic subprogram of the right kind, and that\n       --  it does not lead to a circular instantiation.\n \n-      if not Ekind_In (Gen_Unit, E_Generic_Procedure, E_Generic_Function) then\n-         Error_Msg_N (\"expect generic subprogram in instantiation\", Gen_Id);\n+      if K = E_Procedure and then Ekind (Gen_Unit) /= E_Generic_Procedure then\n+         Error_Msg_NE\n+           (\"& is not the name of a generic procedure\", Gen_Id, Gen_Unit);\n+\n+      elsif K = E_Function and then Ekind (Gen_Unit) /= E_Generic_Function then\n+         Error_Msg_NE\n+           (\"& is not the name of a generic function\", Gen_Id, Gen_Unit);\n \n       elsif In_Open_Scopes (Gen_Unit) then\n          Error_Msg_NE (\"instantiation of & within itself\", N, Gen_Unit);\n \n-      elsif K = E_Procedure\n-        and then Ekind (Gen_Unit) /= E_Generic_Procedure\n-      then\n-         if Ekind (Gen_Unit) = E_Generic_Function then\n-            Error_Msg_N\n-              (\"cannot instantiate generic function as procedure\", Gen_Id);\n-         else\n-            Error_Msg_N\n-              (\"expect name of generic procedure in instantiation\", Gen_Id);\n-         end if;\n-\n-      elsif K = E_Function\n-        and then Ekind (Gen_Unit) /= E_Generic_Function\n-      then\n-         if Ekind (Gen_Unit) = E_Generic_Procedure then\n-            Error_Msg_N\n-              (\"cannot instantiate generic procedure as function\", Gen_Id);\n-         else\n-            Error_Msg_N\n-              (\"expect name of generic function in instantiation\", Gen_Id);\n-         end if;\n-\n       else\n          Set_Entity (Gen_Id, Gen_Unit);\n          Set_Is_Instantiated (Gen_Unit);"}, {"sha": "864d42d3b1b83fde096976d1777075d2281be96f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -1928,6 +1928,15 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n \n+               --  Refined_Pre\n+\n+               when Aspect_Refined_Pre =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Refined_Pre);\n+\n                --  Relative_Deadline\n \n                when Aspect_Relative_Deadline =>\n@@ -7779,6 +7788,7 @@ package body Sem_Ch13 is\n               Aspect_Postcondition        |\n               Aspect_Pre                  |\n               Aspect_Precondition         |\n+              Aspect_Refined_Pre          |\n               Aspect_SPARK_Mode           |\n               Aspect_Test_Case     =>\n             raise Program_Error;"}, {"sha": "4fffb88374d703d27114dd84511ce9c770e8dec7", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -2672,20 +2672,30 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  Language-defined aspects cannot appear in a subprogram body if the\n-      --  corresponding spec already has aspects. Exception to this rule are\n-      --  certain user-defined aspects. Aspects that apply to a body stub are\n-      --  moved to the proper body. Do not emit an error in this case.\n+      --  Language-defined aspects cannot appear in a subprogram body [stub] if\n+      --  the corresponding spec already has aspects. An exception to this rule\n+      --  are certain user-defined aspects.\n \n       if Has_Aspects (N) then\n          if Present (Spec_Id)\n-           and then Nkind (N) not in N_Body_Stub\n-           and then Nkind (Parent (N)) /= N_Subunit\n-           and then not Aspects_On_Body_OK (N)\n+           and then not Aspects_On_Body_Or_Stub_OK (N)\n+\n+            --  Do not emit an error on a subprogram body stub that act as\n+            --  its own spec.\n+\n+           and then Nkind (Parent (Parent (Spec_Id))) /= N_Subprogram_Body_Stub\n          then\n             Error_Msg_N\n               (\"aspect specifications must appear in subprogram declaration\",\n                 N);\n+\n+         --  Delay the analysis of aspect specifications that apply to a body\n+         --  stub until the proper body is analyzed. If the corresponding body\n+         --  is missing, the aspects are still analyzed in Analyze_Proper_Body.\n+\n+         elsif Nkind (N) in N_Body_Stub then\n+            null;\n+\n          else\n             Analyze_Aspect_Specifications (N, Body_Id);\n          end if;\n@@ -2835,7 +2845,12 @@ package body Sem_Ch6 is\n             Reference_Body_Formals (Spec_Id, Body_Id);\n          end if;\n \n-         if Nkind (N) /= N_Subprogram_Body_Stub then\n+         if Nkind (N) = N_Subprogram_Body_Stub then\n+            Set_Corresponding_Spec_Of_Stub (N, Spec_Id);\n+\n+         --  Regular body\n+\n+         else\n             Set_Corresponding_Spec (N, Spec_Id);\n \n             --  Ada 2005 (AI-345): If the operation is a primitive operation"}, {"sha": "9d8f590ab9ec527594eca28f0b6336b8ccb9b1cf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -75,7 +75,6 @@ with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinfo.CN; use Sinfo.CN;\n with Sinput;   use Sinput;\n-with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Stylesw;  use Stylesw;\n with Table;\n@@ -15932,6 +15931,137 @@ package body Sem_Prag is\n          when Pragma_Rational =>\n             Set_Rational_Profile;\n \n+         -----------------\n+         -- Refined_Pre --\n+         -----------------\n+\n+         --  pragma Refined_Pre (boolean_EXPRESSION);\n+\n+         when Pragma_Refined_Pre => Refined_Pre : declare\n+            Body_Decl : Node_Id := Parent (N);\n+            Pack_Spec : Node_Id;\n+            Restore   : Boolean := False;\n+            Spec_Decl : Node_Id;\n+            Spec_Id   : Entity_Id;\n+            Stmt      : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_No_Identifiers;\n+\n+            --  Verify the placement of the pragma and check for duplicates\n+\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+               --  The pragma applies to a subprogram body stub\n+\n+               elsif Nkind (Stmt) = N_Subprogram_Body_Stub then\n+                  Body_Decl := Stmt;\n+                  exit;\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n+\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            --  Pragma Refined_Pre must apply to a subprogram body [stub]\n+\n+            if not Nkind_In (Body_Decl, N_Subprogram_Body,\n+                                        N_Subprogram_Body_Stub)\n+            then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            --  The body [stub] must not act as a spec\n+\n+            if Nkind (Body_Decl) = N_Subprogram_Body then\n+               Spec_Id := Corresponding_Spec (Body_Decl);\n+            else\n+               Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n+            end if;\n+\n+            if No (Spec_Id) then\n+               Error_Pragma (\"pragma % cannot apply to a stand alone body\");\n+               return;\n+            end if;\n+\n+            --  Refined_Pre may only apply to the body [stub] of a subprogram\n+            --  declared in the visible part of a package. Retrieve the context\n+            --  of the subprogram declaration.\n+\n+            Spec_Decl := Parent (Parent (Spec_Id));\n+\n+            pragma Assert\n+              (Nkind_In (Spec_Decl, N_Abstract_Subprogram_Declaration,\n+                                    N_Generic_Subprogram_Declaration,\n+                                    N_Subprogram_Declaration));\n+\n+            Pack_Spec := Parent (Spec_Decl);\n+\n+            if Nkind (Pack_Spec) /= N_Package_Specification\n+              or else List_Containing (Spec_Decl) /=\n+                        Visible_Declarations (Pack_Spec)\n+            then\n+               Error_Pragma\n+                 (\"pragma % must apply to the body of a visible subprogram\");\n+            end if;\n+\n+            --  When the pragma applies to a subprogram stub without a proper\n+            --  body, we have to restore the visibility of the stub and its\n+            --  formals to perform analysis.\n+\n+            if Nkind (Body_Decl) = N_Subprogram_Body_Stub\n+              and then No (Library_Unit (Body_Decl))\n+              and then Current_Scope /= Spec_Id\n+            then\n+               Restore := True;\n+               Push_Scope (Spec_Id);\n+               Install_Formals (Spec_Id);\n+            end if;\n+\n+            --  Convert pragma Refined_Pre into pragma Check. The analysis of\n+            --  the generated pragma will take care of the expression.\n+\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Check,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Pname)),\n+\n+                  Make_Pragma_Argument_Association (Sloc (Arg1),\n+                    Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n+\n+            Analyze (N);\n+\n+            if Restore then\n+               Pop_Scope;\n+            end if;\n+         end Refined_Pre;\n+\n          -----------------------\n          -- Relative_Deadline --\n          -----------------------\n@@ -18994,12 +19124,12 @@ package body Sem_Prag is\n       Pragma_Page                           => -1,\n       Pragma_Partition_Elaboration_Policy   => -1,\n       Pragma_Passive                        => -1,\n-      Pragma_Preelaborable_Initialization   => -1,\n-      Pragma_Polling                        => -1,\n       Pragma_Persistent_BSS                 =>  0,\n+      Pragma_Polling                        => -1,\n       Pragma_Postcondition                  => -1,\n       Pragma_Precondition                   => -1,\n       Pragma_Predicate                      => -1,\n+      Pragma_Preelaborable_Initialization   => -1,\n       Pragma_Preelaborate                   => -1,\n       Pragma_Preelaborate_05                => -1,\n       Pragma_Priority                       => -1,\n@@ -19015,6 +19145,7 @@ package body Sem_Prag is\n       Pragma_Queuing_Policy                 => -1,\n       Pragma_Rational                       => -1,\n       Pragma_Ravenscar                      => -1,\n+      Pragma_Refined_Pre                    => -1,\n       Pragma_Relative_Deadline              => -1,\n       Pragma_Remote_Access_Type             => -1,\n       Pragma_Remote_Call_Interface          => -1,"}, {"sha": "c01c5f21c108c3b0e878c686173240bbf0b4c344", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -26,11 +26,20 @@\n --  Pragma handling is isolated in a separate package\n --  (logically this processing belongs in chapter 4)\n \n-with Namet; use Namet;\n-with Types; use Types;\n+with Namet;  use Namet;\n+with Snames; use Snames;\n+with Types;  use Types;\n \n package Sem_Prag is\n \n+   --  The following table lists all the user-defined pragmas that may apply to\n+   --  a body stub.\n+\n+   Pragma_On_Stub_OK : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Refined_Pre  => True,\n+      Pragma_SPARK_Mode   => True,\n+      others              => False);\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "4aae39daf88eee2c5d10e5c0a9c12bc31a779eec", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -691,6 +691,17 @@ package body Sinfo is\n       return Node5 (N);\n    end Corresponding_Spec;\n \n+   function Corresponding_Spec_Of_Stub\n+      (N : Node_Id) return Entity_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Package_Body_Stub\n+        or else NT (N).Nkind = N_Protected_Body_Stub\n+        or else NT (N).Nkind = N_Subprogram_Body_Stub\n+        or else NT (N).Nkind = N_Task_Body_Stub);\n+      return Node2 (N);\n+   end Corresponding_Spec_Of_Stub;\n+\n    function Corresponding_Stub\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3817,6 +3828,17 @@ package body Sinfo is\n       Set_Node5 (N, Val); -- semantic field, no parent set\n    end Set_Corresponding_Spec;\n \n+   procedure Set_Corresponding_Spec_Of_Stub\n+      (N : Node_Id; Val : Entity_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Package_Body_Stub\n+        or else NT (N).Nkind = N_Protected_Body_Stub\n+        or else NT (N).Nkind = N_Subprogram_Body_Stub\n+        or else NT (N).Nkind = N_Task_Body_Stub);\n+      Set_Node2 (N, Val); -- semantic field, no parent set\n+   end Set_Corresponding_Spec_Of_Stub;\n+\n    procedure Set_Corresponding_Stub\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "6028b92540c0f2b64001432775724c740a332e35", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -822,6 +822,11 @@ package Sinfo is\n    --    In Ada 2012, Corresponding_Spec is set on expression functions that\n    --    complete a subprogram declaration.\n \n+   --  Corresponding_Spec_Of_Stub (Node2-Sem)\n+   --    This field is present in subprogram, package, task and protected body\n+   --    stubs where it points to the corresponding spec of the stub. Due to\n+   --    clashes in the structure of nodes, we cannot use Corresponding_Spec.\n+\n    --  Corresponding_Stub (Node3-Sem)\n    --    This field is present in an N_Subunit node. It holds the node in\n    --    the parent unit that is the stub declaration for the subunit. It is\n@@ -6067,6 +6072,7 @@ package Sinfo is\n       --  N_Subprogram_Body_Stub\n       --  Sloc points to FUNCTION or PROCEDURE\n       --  Specification (Node1)\n+      --  Corresponding_Spec_Of_Stub (Node2-Sem)\n       --  Library_Unit (Node4-Sem) points to the subunit\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -6081,6 +6087,7 @@ package Sinfo is\n       --  N_Package_Body_Stub\n       --  Sloc points to PACKAGE\n       --  Defining_Identifier (Node1)\n+      --  Corresponding_Spec_Of_Stub (Node2-Sem)\n       --  Library_Unit (Node4-Sem) points to the subunit\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -6095,6 +6102,7 @@ package Sinfo is\n       --  N_Task_Body_Stub\n       --  Sloc points to TASK\n       --  Defining_Identifier (Node1)\n+      --  Corresponding_Spec_Of_Stub (Node2-Sem)\n       --  Library_Unit (Node4-Sem) points to the subunit\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -6111,6 +6119,7 @@ package Sinfo is\n       --  N_Protected_Body_Stub\n       --  Sloc points to PROTECTED\n       --  Defining_Identifier (Node1)\n+      --  Corresponding_Spec_Of_Stub (Node2-Sem)\n       --  Library_Unit (Node4-Sem) points to the subunit\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -8503,6 +8512,9 @@ package Sinfo is\n    function Corresponding_Spec\n      (N : Node_Id) return Node_Id;    -- Node5\n \n+   function Corresponding_Spec_Of_Stub\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Corresponding_Stub\n      (N : Node_Id) return Node_Id;    -- Node3\n \n@@ -9499,6 +9511,9 @@ package Sinfo is\n    procedure Set_Corresponding_Spec\n      (N : Node_Id; Val : Node_Id);            -- Node5\n \n+   procedure Set_Corresponding_Spec_Of_Stub\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Corresponding_Stub\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n@@ -11509,28 +11524,28 @@ package Sinfo is\n \n      N_Subprogram_Body_Stub =>\n        (1 => True,    --  Specification (Node1)\n-        2 => False,   --  unused\n+        2 => False,   --  Corresponding_Spec_Of_Stub (Node2-Sem)\n         3 => False,   --  unused\n         4 => False,   --  Library_Unit (Node4-Sem)\n         5 => False),  --  Corresponding_Body (Node5-Sem)\n \n      N_Package_Body_Stub =>\n        (1 => True,    --  Defining_Identifier (Node1)\n-        2 => False,   --  unused\n+        2 => False,   --  Corresponding_Spec_Of_Stub (Node2-Sem)\n         3 => False,   --  unused\n         4 => False,   --  Library_Unit (Node4-Sem)\n         5 => False),  --  Corresponding_Body (Node5-Sem)\n \n      N_Task_Body_Stub =>\n        (1 => True,    --  Defining_Identifier (Node1)\n-        2 => False,   --  unused\n+        2 => False,   --  Corresponding_Spec_Of_Stub (Node2-Sem)\n         3 => False,   --  unused\n         4 => False,   --  Library_Unit (Node4-Sem)\n         5 => False),  --  Corresponding_Body (Node5-Sem)\n \n      N_Protected_Body_Stub =>\n        (1 => True,    --  Defining_Identifier (Node1)\n-        2 => False,   --  unused\n+        2 => False,   --  Corresponding_Spec_Of_Stub (Node2-Sem)\n         3 => False,   --  unused\n         4 => False,   --  Library_Unit (Node4-Sem)\n         5 => False),  --  Corresponding_Body (Node5-Sem)\n@@ -12097,6 +12112,7 @@ package Sinfo is\n    pragma Inline (Corresponding_Generic_Association);\n    pragma Inline (Corresponding_Integer_Value);\n    pragma Inline (Corresponding_Spec);\n+   pragma Inline (Corresponding_Spec_Of_Stub);\n    pragma Inline (Corresponding_Stub);\n    pragma Inline (Dcheck_Function);\n    pragma Inline (Declarations);\n@@ -12426,6 +12442,7 @@ package Sinfo is\n    pragma Inline (Set_Corresponding_Generic_Association);\n    pragma Inline (Set_Corresponding_Integer_Value);\n    pragma Inline (Set_Corresponding_Spec);\n+   pragma Inline (Set_Corresponding_Spec_Of_Stub);\n    pragma Inline (Set_Corresponding_Stub);\n    pragma Inline (Set_Dcheck_Function);\n    pragma Inline (Set_Declarations);"}, {"sha": "ed483f4c3334c346e4f9017b2ff99da1ead09eb3", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28072cdc85406f97fb06389639f5b9933101201/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e28072cdc85406f97fb06389639f5b9933101201", "patch": "@@ -580,6 +580,7 @@ package Snames is\n    Name_Pure_05                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_12                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_Function                  : constant Name_Id := N + $; -- GNAT\n+   Name_Refined_Pre                    : constant Name_Id := N + $; -- GNAT\n    Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05\n    Name_Remote_Access_Type             : constant Name_Id := N + $; -- GNAT\n    Name_Remote_Call_Interface          : constant Name_Id := N + $;\n@@ -1860,6 +1861,7 @@ package Snames is\n       Pragma_Pure_05,\n       Pragma_Pure_12,\n       Pragma_Pure_Function,\n+      Pragma_Refined_Pre,\n       Pragma_Relative_Deadline,\n       Pragma_Remote_Access_Type,\n       Pragma_Remote_Call_Interface,"}]}