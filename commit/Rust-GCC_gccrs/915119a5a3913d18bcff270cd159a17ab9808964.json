{"sha": "915119a5a3913d18bcff270cd159a17ab9808964", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1MTE5YTVhMzkxM2QxOGJjZmYyNzBjZDE1OWExN2FiOTgwODk2NA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-08T17:36:33Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-08T17:36:33Z"}, "message": "MMX/SSE patterns for i386\n\nFrom-SVN: r36270", "tree": {"sha": "6b19fda7cb60fd41eab3f79841fd48637a93bbae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b19fda7cb60fd41eab3f79841fd48637a93bbae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/915119a5a3913d18bcff270cd159a17ab9808964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915119a5a3913d18bcff270cd159a17ab9808964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915119a5a3913d18bcff270cd159a17ab9808964", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915119a5a3913d18bcff270cd159a17ab9808964/comments", "author": null, "committer": null, "parents": [{"sha": "8e49e00a2cced241a0b785f4d6037dd2e5dfd7a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e49e00a2cced241a0b785f4d6037dd2e5dfd7a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e49e00a2cced241a0b785f4d6037dd2e5dfd7a9"}], "stats": {"total": 1691, "additions": 1678, "deletions": 13}, "files": [{"sha": "c92af028ae090a594f3b31dca6f4ac3f86ed507c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=915119a5a3913d18bcff270cd159a17ab9808964", "patch": "@@ -1,3 +1,39 @@\n+2000-09-08  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* i386-protos.h (sse_comparison_operator, mmx_reg_operand): Declare\n+\tnew functions.\n+\t* i386.c (sse_comparison_operator, mmx_reg_operand): New functions.\n+\t* i386.md (attr \"type\"): Add sse and mmx types.\n+\t(attr \"memory\"): Handle them without a crash.\n+\t(movsi_1, movdi_2): Allow MMX regs.\n+\t(movdi splits): Don't split moves involving MMX regs.\n+\t(setcc_4): Remove '*' from pattern name so we get a gen_setcc4.\n+\t(movv4sf_internal, movv4si_internal, movv8qi_internal,\n+\tmovv4hi_internal, movv2si_internal, movv8qi, movv4hi, movv2si,\n+\tmovv4sf, movv4si, pushv4sf, pushv4si, pushv8qi, pushv4hi, pushv2si,\n+\tsse_movaps, sse_movups, sse_movmskps, mmx_pmovmskb, mmx_maskmovq,\n+\tsse_movntv4sf, sse_movntdi, sse_movhlps, sse_movlhps, sse_movhps,\n+\tsse_movlps, sse_loadss, sse_movss, sse_storess, sse_shufps,\n+\taddv4sf3, vmaddv4sf3, subv4sf3, vmsubv4sf3, mulv4sf3, vmmulv4sf3,\n+\tdivv4sf3, vmdivv4sf3, rcpv4sf2, vmrcpv4sf2, rsqrtv4sf2, vmrsqrtv4sf2,\n+\tsqrtv4sf2, vmsqrtv4sf2, sse_andti3, sse_nandti3, sse_iorti3,\n+ \tsse_xorti3, maskcmpv4sf3, maskncmpv4sf3, vmmaskcmpv4sf3,\n+ \tvmmaskncmpv4sf3, sse_comi, sse_ucomi, sse_unpckhps, sse_unpcklps,\n+\tsmaxv4sf3, vmsmaxv4sf3, sminv4sf3, vmsminv4sf3, cvtpi2ps, cvtps2pi,\n+\tcvttps2pi, cvtsi2ss, cvtss2si, cvttss2si, addv8qi3, addv4hi3,\n+\taddv2si3, ssaddv8qi3, ssaddv4hi3, usaddv8qi3, usaddv4hi3, subv8qi3,\n+\tsubv4hi3, subv2si3, sssubv8qi3, sssubv4hi3, ussubv8qi3, ussubv4hi3,\n+\tmulv4hi3, smulv4hi3_highpart, umulv4hi3_highpart, mmx_pmaddwd,\n+\tmmx_iordi3, mmx_xordi3, mmx_anddi3, mmx_nanddi3, mmx_uavgv8qi3,\n+\tmmx_uavgv4hi3, mmx_psadbw, mmx_pinsrw, mmx_pextrw, mmx_pshufw,\n+\teqv8qi3, eqv4hi3, eqv2si3, gtv8qi3, gtv4hi3, gtv2si3, umaxv8qi3,\n+\tsmaxv4hi3, uminv8qi3, sminv4hi3, ashrv4hi3, ashrv2si3, lshrv4hi3,\n+\tlshrv2si3, mmx_lshrdi3, ashlv4hi3, ashlv2si3, mmx_ashldi3,\n+\tmmx_packsswb, mmx_packssdw, mmx_packuswb, mmx_punpckhbw,\n+\tmmx_punpckhwd, mmx_punpckhdq, mmx_punpcklbw, mmx_punpcklwd,\n+\tmmx_punpckldq, emms, sfence, ldmxcsr, prefetch, stmxcsr, sse_clrti,\n+\tmmx_clrdi): New patterns.\n+\n 2000-09-08  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c: Don't include tm.h directly."}, {"sha": "7ffb299ee88f34da824a4442ddc068b4b794b3ba", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=915119a5a3913d18bcff270cd159a17ab9808964", "patch": "@@ -51,11 +51,13 @@ extern int const1_operand PARAMS ((rtx, enum machine_mode));\n extern int const248_operand PARAMS ((rtx, enum machine_mode));\n extern int incdec_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_no_sp_operand PARAMS ((rtx, enum machine_mode));\n+extern int mmx_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int general_no_elim_operand PARAMS ((rtx, enum machine_mode));\n extern int nonmemory_no_elim_operand PARAMS ((rtx, enum machine_mode));\n extern int q_regs_operand PARAMS ((rtx, enum machine_mode));\n extern int non_q_regs_operand PARAMS ((rtx, enum machine_mode));\n extern int no_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int sse_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int fcmov_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int uno_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int cmp_fp_expander_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "7485d1904bd718086ec7b5c93d3a13c72bc76218", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=915119a5a3913d18bcff270cd159a17ab9808964", "patch": "@@ -1174,6 +1174,14 @@ reg_no_sp_operand (op, mode)\n   return register_operand (op, mode);\n }\n \n+int\n+mmx_reg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return MMX_REG_P (op);\n+}\n+\n /* Return false if this is any eliminable register.  Otherwise\n    general_operand.  */\n \n@@ -1264,6 +1272,17 @@ no_comparison_operator (op, mode)\n     }\n }\n \n+/* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS\n+   insns.  */\n+int\n+sse_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return code == EQ || code == LT || code == LE || code == UNORDERED;\n+}\n+\n /* Return 1 if OP is a comparison operator that can be issued by fcmov.  */\n \n int"}, {"sha": "ab0b5369012f0bfd8a63d7513eb49a8a6ce53631", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=915119a5a3913d18bcff270cd159a17ab9808964", "patch": "@@ -2584,6 +2584,7 @@ do { long l;\t\t\t\t\t\t\\\n   {\"const1_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"const248_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"incdec_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"mmx_reg_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"reg_no_sp_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"general_no_elim_operand\", {CONST_INT, CONST_DOUBLE, CONST,\t\t\\\n \t\t\tSYMBOL_REF, LABEL_REF, SUBREG, REG, MEM}},\t\\\n@@ -2592,6 +2593,7 @@ do { long l;\t\t\t\t\t\t\\\n   {\"non_q_regs_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"no_comparison_operator\", {EQ, NE, LT, GE, LTU, GTU, LEU, GEU}},\t\\\n   {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU}},\t\t\\\n+  {\"sse_comparison_operator\", {EQ, LT, LE, UNORDERED }},\t\t\\\n   {\"uno_comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU,\t\\\n \t\t\t       GTU, UNORDERED, ORDERED}},\t\t\\\n   {\"cmp_fp_expander_operand\", {CONST_DOUBLE, SUBREG, REG, MEM}},\t\\"}, {"sha": "51386bc011489f1d59ef9014dc0e898567e8f3eb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1619, "deletions": 13, "changes": 1632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915119a5a3913d18bcff270cd159a17ab9808964/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=915119a5a3913d18bcff270cd159a17ab9808964", "patch": "@@ -71,7 +71,25 @@\n ;; 9  This is an `fnstsw' operation.\n ;; 10 This is a `sahf' operation.\n ;; 11 This is a `fstcw' operation\n-;;\n+\n+;; For SSE/MMX support:\n+;; 30 This is `fix', guaranteed to be truncating.\n+;; 31 This is a `emms' operation.\n+;; 32 This is a `maskmov' operation.\n+;; 33 This is a `movmsk' operation.\n+;; 34 This is a `non-temporal' move.\n+;; 35 This is a `prefetch' operation.\n+;; 36 This is used to distinguish COMISS from UCOMISS.\n+;; 37 This is a `ldmxcsr' operation.\n+;; 38 This is a forced `movaps' instruction (rather than whatever movti does)\n+;; 39 This is a forced `movups' instruction (rather than whatever movti does)\n+;; 40 This is a `stmxcsr' operation.\n+;; 41 This is a `shuffle' operation.\n+;; 42 This is a `rcp' operation.\n+;; 43 This is a `rsqsrt' operation.\n+;; 44 This is a `sfence' operation.\n+;; 45 This is a noop to prevent excessive combiner cleverness.\n+\n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n ;; from i386.c.\n \n@@ -84,7 +102,7 @@\n ;; A basic instruction type.  Refinements due to arguments to be\n ;; provided in other attributes.\n (define_attr \"type\"\n-  \"other,multi,alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,str,cld\"\n+  \"other,multi,alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,str,cld,sse,mmx\"\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n@@ -234,7 +252,7 @@\n \t   (const_string \"store\")\n \t (match_operand 1 \"memory_operand\" \"\")\n \t   (const_string \"load\")\n-\t (and (eq_attr \"type\" \"!icmp,test,alu1,negnot,fop1,fsgn,imov,imovx,fmov,fcmp\")\n+\t (and (eq_attr \"type\" \"!icmp,test,alu1,negnot,fop1,fsgn,imov,imovx,fmov,fcmp,sse,mmx\")\n \t      (match_operand 2 \"memory_operand\" \"\"))\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\" \"icmov\")\n@@ -1530,28 +1548,35 @@\n    (set_attr \"length_immediate\" \"1\")])\n \n (define_insn \"*movsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*a,r,*a,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*a,r,*a,m,!*y,!r\")\n+\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,r,*y\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n+    case TYPE_MMX:\n+      return \\\"movd\\\\t{%1, %0|%0, %1}\\\";\n+\n     case TYPE_LEA:\n       return \\\"lea{l}\\\\t{%1, %0|%0, %1}\\\";\n+\n     default:\n       if (flag_pic && SYMBOLIC_CONST (operands[1]))\n \tabort();\n       return \\\"mov{l}\\\\t{%1, %0|%0, %1}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (cond [(and (ne (symbol_ref \"flag_pic\") (const_int 0))\n+     (cond [(ior (match_operand:SI 0 \"mmx_reg_operand\" \"\")\n+\t\t (match_operand:SI 1 \"mmx_reg_operand\" \"\"))\n+\t      (const_string \"mmx\")\n+\t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n \t\t (match_operand:SI 1 \"symbolic_operand\" \"\"))\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"0,*,0,*\")\n+   (set_attr \"modrm\" \"0,*,0,*,*,*\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*swapsi\"\n@@ -1983,23 +2008,28 @@\n   \"#\")\n \n (define_insn \"*movdi_2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"riFo,riF\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!m*y,!*y\")\n+\t(match_operand:DI 1 \"general_operand\" \"riFo,riF,*y,m\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"#\")\n+  \"@\n+   #\n+   #\n+   movq\\\\t{%1, %0|%0, %1}\n+   movq\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"*,*,mmx,mmx\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"reload_completed\"\n+  \"reload_completed && ! MMX_REG_P (operands[1])\"\n   [(const_int 0)]\n   \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n ;; %%% This multiword shite has got to go.\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"reload_completed\"\n+  \"reload_completed && ! MMX_REG_P (operands[0]) && ! MMX_REG_P (operands[1])\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 3) (match_dup 6))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n@@ -7864,7 +7894,7 @@\n   [(set_attr \"type\" \"setcc\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*setcc_4\"\n+(define_insn \"setcc_4\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n \t(match_operator:QI 1 \"uno_comparison_operator\"\n \t  [(reg:CC 17) (const_int 0)]))]\n@@ -11170,3 +11200,1579 @@\n \t\t\t     CODE_LABEL_NUMBER (operands[2]));\n   RET;\n }\")\n+\n+\t;; Pentium III SIMD instructions.\n+\n+;; Moves for SSE/MMX regs.\n+\n+(define_insn \"movv4sf_internal\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(match_operand:V4SF 1 \"general_operand\" \"xm,x\"))]\n+  \"TARGET_SSE\"\n+  ;; @@@ let's try to use movaps here.\n+  \"movaps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"movv4si_internal\"\n+  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(match_operand:V4SI 1 \"general_operand\" \"xm,x\"))]\n+  \"TARGET_SSE\"\n+  ;; @@@ let's try to use movaps here.\n+  \"movaps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"movv8qi_internal\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,m\")\n+\t(match_operand:V8QI 1 \"general_operand\" \"ym,y\"))]\n+  \"TARGET_MMX\"\n+  \"movq\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"movv4hi_internal\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,m\")\n+\t(match_operand:V4HI 1 \"general_operand\" \"ym,y\"))]\n+  \"TARGET_MMX\"\n+  \"movq\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"movv2si_internal\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,m\")\n+\t(match_operand:V2SI 1 \"general_operand\" \"ym,y\"))]\n+  \"TARGET_MMX\"\n+  \"movq\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_expand \"movti\"\n+  [(set (match_operand:TI 0 \"general_operand\" \"\")\n+\t(match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"TARGET_SSE\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], TImode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (TImode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (TImode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], TImode)\n+      && !register_operand (operands[1], TImode)\n+      && operands[1] != CONST0_RTX (TImode))\n+    {\n+      rtx temp = force_reg (TImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movv4sf\"\n+  [(set (match_operand:V4SF 0 \"general_operand\" \"\")\n+\t(match_operand:V4SF 1 \"general_operand\" \"\"))]\n+  \"TARGET_SSE\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], V4SFmode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (V4SFmode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (V4SFmode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], V4SFmode)\n+      && !register_operand (operands[1], V4SFmode)\n+      && operands[1] != CONST0_RTX (V4SFmode))\n+    {\n+      rtx temp = force_reg (V4SFmode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movv4si\"\n+  [(set (match_operand:V4SI 0 \"general_operand\" \"\")\n+\t(match_operand:V4SI 1 \"general_operand\" \"\"))]\n+  \"TARGET_MMX\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], V4SImode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (V4SImode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (V4SImode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], V4SImode)\n+      && !register_operand (operands[1], V4SImode)\n+      && operands[1] != CONST0_RTX (V4SImode))\n+    {\n+      rtx temp = force_reg (V4SImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movv2si\"\n+  [(set (match_operand:V2SI 0 \"general_operand\" \"\")\n+\t(match_operand:V2SI 1 \"general_operand\" \"\"))]\n+  \"TARGET_MMX\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], V2SImode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (V2SImode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (V2SImode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], V2SImode)\n+      && !register_operand (operands[1], V2SImode)\n+      && operands[1] != CONST0_RTX (V2SImode))\n+    {\n+      rtx temp = force_reg (V2SImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movv4hi\"\n+  [(set (match_operand:V4HI 0 \"general_operand\" \"\")\n+\t(match_operand:V4HI 1 \"general_operand\" \"\"))]\n+  \"TARGET_MMX\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], V4HImode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (V4HImode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (V4HImode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], V4HImode)\n+      && !register_operand (operands[1], V4HImode)\n+      && operands[1] != CONST0_RTX (V4HImode))\n+    {\n+      rtx temp = force_reg (V4HImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movv8qi\"\n+  [(set (match_operand:V8QI 0 \"general_operand\" \"\")\n+\t(match_operand:V8QI 1 \"general_operand\" \"\"))]\n+  \"TARGET_MMX\"\n+  \"\n+{\n+  /* For constants other than zero into memory.  We do not know how the\n+     instructions used to build constants modify the upper 64 bits\n+     of the register, once we have that information we may be able\n+     to handle some of them more efficiently.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && register_operand (operands[0], V8QImode)\n+      && CONSTANT_P (operands[1]))\n+    {\n+      rtx addr = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (addr, XEXP (force_const_mem (V8QImode, operands[1]), 0));\n+      operands[1] = gen_rtx_MEM (V8QImode, addr);\n+    }\n+\n+  /* Make operand1 a register if it isn't already.  */\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], V8QImode)\n+      && !register_operand (operands[1], V8QImode)\n+      && operands[1] != CONST0_RTX (V8QImode))\n+    {\n+      rtx temp = force_reg (V8QImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn_and_split \"*pushti\"\n+  [(set (match_operand:TI 0 \"push_operand\" \"=<\")\n+\t(match_operand:TI 1 \"nonmemory_operand\" \"x\"))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:TI (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn_and_split \"*pushv4sf\"\n+  [(set (match_operand:V4SF 0 \"push_operand\" \"=<\")\n+\t(match_operand:V4SF 1 \"nonmemory_operand\" \"x\"))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:V4SF (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn_and_split \"*pushv4si\"\n+  [(set (match_operand:V4SI 0 \"push_operand\" \"=<\")\n+\t(match_operand:V4SI 1 \"nonmemory_operand\" \"x\"))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:V4SI (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn_and_split \"*pushv2si\"\n+  [(set (match_operand:V2SI 0 \"push_operand\" \"=<\")\n+\t(match_operand:V2SI 1 \"nonmemory_operand\" \"y\"))]\n+  \"TARGET_MMX\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n+   (set (mem:V2SI (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn_and_split \"*pushv4hi\"\n+  [(set (match_operand:V4HI 0 \"push_operand\" \"=<\")\n+\t(match_operand:V4HI 1 \"nonmemory_operand\" \"y\"))]\n+  \"TARGET_MMX\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n+   (set (mem:V4HI (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn_and_split \"*pushv8qi\"\n+  [(set (match_operand:V8QI 0 \"push_operand\" \"=<\")\n+\t(match_operand:V8QI 1 \"nonmemory_operand\" \"y\"))]\n+  \"TARGET_MMX\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n+   (set (mem:V8QI (reg:SI 7)) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"movti_internal\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(match_operand:TI 1 \"general_operand\" \"xm,x\"))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movaps\\\\t{%1, %0|%0, %1}\n+   movaps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+;; These two patterns are useful for specifying exactly whether to use\n+;; movaps or movups\n+(define_insn \"sse_movaps\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(unspec:V4SF [(match_operand:V4SF 1 \"general_operand\" \"xm,x\")] 38))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movaps\\\\t{%1, %0|%0, %1}\n+   movaps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movups\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(unspec:V4SF [(match_operand:V4SF 1 \"general_operand\" \"xm,x\")] 39))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movups\\\\t{%1, %0|%0, %1}\n+   movups\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE Strange Moves.\n+\n+(define_insn \"sse_movmskps\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:V4SF 1 \"register_operand\" \"x\")] 33))]\n+  \"TARGET_SSE\"\n+  \"movmskps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_pmovmskb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:V8QI 1 \"register_operand\" \"y\")] 33))]\n+  \"TARGET_SSE\"\n+  \"pmovmskb\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_maskmovq\"\n+  [(set (mem:V8QI (match_operand:SI 0 \"register_operand\" \"D\"))\n+\t(unspec:V8QI [(match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V8QI 2 \"register_operand\" \"y\")] 32))]\n+  \"TARGET_SSE\"\n+  ;; @@@ check ordering of operands in intel/nonintel syntax\n+  \"maskmovq\\\\t{%2, %1|%1, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movntv4sf\"\n+  [(set (match_operand:V4SF 0 \"memory_operand\" \"=m\")\n+\t(unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"x\")] 34))]\n+  \"TARGET_SSE\"\n+  \"movntps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movntdi\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"x\")] 34))]\n+  \"TARGET_SSE\"\n+  \"movntq\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movhlps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t (vec_select:V4SF (match_operand:V4SF 2 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 3)))]\n+  \"TARGET_SSE\"\n+  \"movhlps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movlhps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t (vec_select:V4SF (match_operand:V4SF 2 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 12)))]\n+  \"TARGET_SSE\"\n+  \"movlhps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movhps\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,0\")\n+\t (match_operand:V4SF 2 \"nonimmediate_operand\" \"m,x\")\n+\t (const_int 12)))]\n+  \"TARGET_SSE && (GET_CODE (operands[1]) == MEM || GET_CODE (operands[2]) == MEM)\"\n+  \"movhps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movlps\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,0\")\n+\t (match_operand:V4SF 2 \"nonimmediate_operand\" \"m,x\")\n+\t (const_int 3)))]\n+  \"TARGET_SSE && (GET_CODE (operands[1]) == MEM || GET_CODE (operands[2]) == MEM)\"\n+  \"movlps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_loadss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"memory_operand\" \"m\")\n+\t (vec_duplicate:V4SF (float:SF (const_int 0)))\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"movss\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_movss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t (match_operand:V4SF 2 \"register_operand\" \"x\")\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"movss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_storess\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(vec_select:SF\n+\t (match_operand:V4SF 1 \"register_operand\" \"x\")\n+\t (parallel [(const_int 0)])))]\n+  \"TARGET_SSE\"\n+  \"movss\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_shufps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")\n+\t\t      (match_operand:SI 3 \"immediate_operand\" \"i\")] 41))]\n+  \"TARGET_SSE\"\n+  ;; @@@ check operand order for intel/nonintel syntax\n+  \"shufps\\\\t{%3, %2, %0|%0, %2, %3}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE arithmetic\n+\n+(define_insn \"addv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (plus:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"addps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmaddv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (plus:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t                           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"addss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"subv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (minus:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"subps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmsubv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (minus:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t                           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"subss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mulv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (mult:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"mulps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmmulv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (mult:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t                           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"mulss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"divv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (div:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t          (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"divps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmdivv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (div:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"divss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE square root/reciprocal\n+\n+(define_insn \"rcpv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 42))]\n+  \"TARGET_SSE\"\n+  \"rcpps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmrcpv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 42)\n+                        (match_operand:V4SF 2 \"register_operand\" \"0\")\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"rcpss\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"rsqrtv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 43))]\n+  \"TARGET_SSE\"\n+  \"rsqrtps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmrsqrtv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 43)\n+                        (match_operand:V4SF 2 \"register_operand\" \"0\")\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"rsqrtss\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sqrtv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (sqrt:V4SF (match_operand:V4SF 1 \"register_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"sqrtps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmsqrtv4sf2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (sqrt:V4SF (match_operand:V4SF 1 \"register_operand\" \"xm\"))\n+                        (match_operand:V4SF 2 \"register_operand\" \"0\")\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"sqrtss\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE logical operations.\n+\n+;; These are not called andti3 etc. because we really really don't want\n+;; the compiler to widen DImode ands to TImode ands and then try to move\n+;; into DImode subregs of SSE registers, and them together, and move out\n+;; of DImode subregs again!\n+\n+(define_insn \"sse_andti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (and:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"andps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_nandti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"andnps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_iorti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (ior:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"iorps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_xorti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (xor:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"xorps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+;; Use xor, but don't show input operands so they aren't live before\n+;; this insn.\n+(define_insn \"sse_clrti\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (unspec:TI [(const_int 0)] 45))]\n+  \"TARGET_SSE\"\n+  \"xorps\\\\t{%0, %0|%0, %0}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE mask-generating compares\n+\n+(define_insn \"maskcmpv4sf3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+        (match_operator:V4SI 3 \"sse_comparison_operator\"\n+\t\t\t     [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x\")]))]\n+  \"TARGET_SSE\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\n+      return \\\"cmpeqps\\\\t{%2, %0|%0, %2}\\\";\n+    case LT:\n+      return \\\"cmpltps\\\\t{%2, %0|%0, %2}\\\";\n+    case LE:\n+      return \\\"cmpleps\\\\t{%2, %0|%0, %2}\\\";\n+    case UNORDERED:\n+      return \\\"cmpunordps\\\\t{%2, %0|%0, %2}\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"maskncmpv4sf3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+        (not:V4SI\n+\t (match_operator:V4SI 3 \"sse_comparison_operator\"\n+\t\t\t      [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t       (match_operand:V4SF 2 \"nonimmediate_operand\" \"x\")])))]\n+  \"TARGET_SSE\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\n+      return \\\"cmpneqps\\\\t{%2, %0|%0, %2}\\\";\n+    case LT:\n+      return \\\"cmpnltps\\\\t{%2, %0|%0, %2}\\\";\n+    case LE:\n+      return \\\"cmpnleps\\\\t{%2, %0|%0, %2}\\\";\n+    case UNORDERED:\n+      return \\\"cmpordps\\\\t{%2, %0|%0, %2}\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmmaskcmpv4sf3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SI\n+\t (match_operator:V4SI 3 \"sse_comparison_operator\"\n+\t\t\t      [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t       (match_operand:V4SF 2 \"nonimmediate_operand\" \"x\")])\n+\t (match_dup 1)\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\n+      return \\\"cmpeqss\\\\t{%2, %0|%0, %2}\\\";\n+    case LT:\n+      return \\\"cmpltss\\\\t{%2, %0|%0, %2}\\\";\n+    case LE:\n+      return \\\"cmpless\\\\t{%2, %0|%0, %2}\\\";\n+    case UNORDERED:\n+      return \\\"cmpunordss\\\\t{%2, %0|%0, %2}\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmmaskncmpv4sf3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SI\n+\t (not:V4SI\n+\t  (match_operator:V4SI 3 \"sse_comparison_operator\"\n+\t\t\t       [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"x\")]))\n+\t (subreg:V4SI (match_dup 1) 0)\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\n+      return \\\"cmpneqss\\\\t{%2, %0|%0, %2}\\\";\n+    case LT:\n+      return \\\"cmpnltss\\\\t{%2, %0|%0, %2}\\\";\n+    case LE:\n+      return \\\"cmpnless\\\\t{%2, %0|%0, %2}\\\";\n+    case UNORDERED:\n+      return \\\"cmpordss\\\\t{%2, %0|%0, %2}\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_comi\"\n+  [(set (reg:CCFP 17)\n+        (match_operator:CCFP 2 \"sse_comparison_operator\"\n+\t\t\t[(vec_select:SF\n+\t\t\t  (match_operand:V4SF 0 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 0)]))\n+\t\t\t (vec_select:SF\n+\t\t\t  (match_operand:V4SF 1 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 0)]))]))]\n+  \"TARGET_SSE\"\n+  \"comiss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_ucomi\"\n+  [(set (reg:CCFPU 17)\n+\t(match_operator:CCFPU 2 \"sse_comparison_operator\"\n+\t\t\t[(vec_select:SF\n+\t\t\t  (match_operand:V4SF 0 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 0)]))\n+\t\t\t (vec_select:SF\n+\t\t\t  (match_operand:V4SF 1 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 0)]))]))]\n+  \"TARGET_SSE\"\n+  \"ucomiss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE unpack\n+\n+(define_insn \"sse_unpckhps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (vec_select:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (const_int 5)))]\n+  \"TARGET_SSE\"\n+  \"unpckhps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sse_unpcklps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF\n+\t (vec_select:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"x\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 5)))]\n+  \"TARGET_SSE\"\n+  \"unpcklps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE min/max\n+\n+(define_insn \"smaxv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (smax:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"maxps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmsmaxv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (smax:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t                           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"maxss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sminv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+        (smin:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"minps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"vmsminv4sf3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (smin:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t                           (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+                        (match_dup 1)\n+\t\t\t(const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"minss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; SSE <-> integer/MMX conversions\n+\n+(define_insn \"cvtpi2ps\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t\t(vec_duplicate:V4SF\n+\t\t\t (float:V2SF (match_operand:V2SI 2 \"register_operand\" \"ym\")))\n+\t\t\t(const_int 12)))]\n+  \"TARGET_SSE\"\n+  \"cvtpi2ps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"cvtps2pi\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t(vec_select:V2SI (fix:V4SI (match_operand:V4SF 1 \"register_operand\" \"xm\"))\n+\t\t\t (parallel\n+\t\t\t  [(const_int 0)\n+\t\t\t   (const_int 1)])))]\n+  \"TARGET_SSE\"\n+  \"cvtps2pi\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"cvttps2pi\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t(vec_select:V2SI (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 30)\n+\t\t\t (parallel\n+\t\t\t  [(const_int 0)\n+\t\t\t   (const_int 1)])))]\n+  \"TARGET_SSE\"\n+  \"cvttps2pi\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"cvtsi2ss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V4SF (match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t \t\t(vec_duplicate:V4SF\n+\t\t\t (float:SF (match_operand:SI 2 \"register_operand\" \"rm\")))\n+\t\t\t(const_int 15)))]\n+  \"TARGET_SSE\"\n+  \"cvtsi2ss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"cvtss2si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(vec_select:SI (fix:V4SI (match_operand:V4SF 1 \"register_operand\" \"xm\"))\n+\t\t       (parallel [(const_int 0)])))]\n+  \"TARGET_SSE\"\n+  \"cvtss2si\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"cvttss2si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(vec_select:SI (unspec:V4SI [(match_operand:V4SF 1 \"register_operand\" \"xm\")] 30)\n+\t\t       (parallel [(const_int 0)])))]\n+  \"TARGET_SSE\"\n+  \"cvttss2si\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; MMX insns\n+\n+;; MMX arithmetic\n+\n+(define_insn \"addv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (plus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t           (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"addv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (plus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t           (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"addv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (plus:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t           (match_operand:V2SI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ssaddv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (ss_plus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddsb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ssaddv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (ss_plus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddsw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"usaddv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (us_plus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddusb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"usaddv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (us_plus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"paddusw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"subv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (minus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"subv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (minus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"subv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (minus:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V2SI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"sssubv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (ss_minus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubsb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"sssubv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (ss_minus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubsw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ussubv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (us_minus:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubusb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ussubv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (us_minus:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"psubusw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mulv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (mult:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pmullw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"smulv4hi3_highpart\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(truncate:V4HI\n+\t (lshiftrt:V4SI\n+\t  (mult:V4SI (sign_extend:V4SI (match_operand:V4HI 1 \"register_operand\" \"0\"))\n+\t\t     (sign_extend:V4SI (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))\n+\t  (const_int 16))))]\n+  \"TARGET_MMX\"\n+  \"pmulhw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"umulv4hi3_highpart\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(truncate:V4HI\n+\t (lshiftrt:V4SI\n+\t  (mult:V4SI (zero_extend:V4SI (match_operand:V4HI 1 \"register_operand\" \"0\"))\n+\t\t     (zero_extend:V4SI (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))\n+\t  (const_int 16))))]\n+  \"TARGET_MMX\"\n+  \"pmulhuw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_pmaddwd\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (plus:V2SI\n+\t (mult:V2SI\n+\t  (sign_extend:V2SI (vec_select:V2HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t\t\t\t     (parallel [(const_int 0)\n+\t\t\t\t\t\t\t(const_int 2)])))\n+\t  (sign_extend:V2SI (vec_select:V2HI (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")\n+\t\t\t\t\t     (parallel [(const_int 0)\n+\t\t\t\t\t\t\t(const_int 2)]))))\n+\t (mult:V2SI\n+\t  (sign_extend:V2SI (vec_select:V2HI (match_dup 1)\n+\t\t\t\t\t     (parallel [(const_int 1)\n+\t\t\t\t\t\t\t(const_int 3)])))\n+\t  (sign_extend:V2SI (vec_select:V2HI (match_dup 2)\n+\t\t\t\t\t     (parallel [(const_int 1)\n+\t\t\t\t\t\t\t(const_int 3)]))))))]\n+  \"TARGET_MMX\"\n+  \"pmaddwd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+\n+;; MMX logical operations\n+;; Note we don't want to declare these as regular iordi3 insns to prevent\n+;; normal code that also wants to use the FPU from getting broken.\n+;; The UNSPECs are there to prevent the combiner from getting overly clever.\n+(define_insn \"mmx_iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI\n+\t [(ior:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"nonimmediate_operand\" \"ym\"))] 45))]\n+  \"TARGET_MMX\"\n+  \"por\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI\n+\t [(xor:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"nonimmediate_operand\" \"ym\"))] 45))]\n+  \"TARGET_MMX\"\n+  \"pxor\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+;; Same as pxor, but don't show input operands so that we don't think\n+;; they are live.\n+(define_insn \"mmx_clrdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI [(const_int 0)] 45))]\n+  \"TARGET_MMX\"\n+  \"pxor\\\\t{%0, %0|%0, %0}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI\n+\t [(and:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"nonimmediate_operand\" \"ym\"))] 45))]\n+  \"TARGET_MMX\"\n+  \"pand\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_nanddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI\n+\t [(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"0\"))\n+\t\t\t  (match_operand:DI 2 \"nonimmediate_operand\" \"ym\"))] 45))]\n+  \"TARGET_MMX\"\n+  \"pandn\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+\n+;; MMX unsigned averages/sum of absolute differences\n+\n+(define_insn \"mmx_uavgv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V8QI\n+\t (plus:V8QI (plus:V8QI\n+\t\t     (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\"))\n+\t\t    (vec_const:V8QI (parallel [(const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)])))\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"pavgbn\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_uavgv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI\n+\t (plus:V4HI (plus:V4HI\n+\t\t     (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\"))\n+\t\t    (vec_const:V4HI (parallel [(const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)\n+\t\t\t\t\t       (const_int 1)])))\n+\t (const_int 1)))]\n+  \"TARGET_SSE\"\n+  \"pavgwn\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_psadbw\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (abs:V8QI (minus:V8QI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t\t      (match_operand:DI 2 \"nonimmediate_operand\" \"ym\"))))]\n+  \"TARGET_SSE\"\n+  \"padbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; MMX insert/extract/shuffle\n+\n+(define_insn \"mmx_pinsrw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (vec_merge:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t\t(vec_duplicate:V4HI\n+\t\t\t (truncate:HI (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n+\t\t\t(match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"TARGET_SSE\"\n+  ;; @@@ check operand order for intel/nonintel syntax.\n+  \"pinsrw\\\\t%3, {%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_pextrw\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extend:SI (vec_select:HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t\t       (parallel\n+\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_SSE\"\n+  ;; @@@ check operand order for intel/nonintel syntax.\n+  \"pextrw\\\\t%2, {%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"mmx_pshufw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")\n+\t\t      (match_operand:SI 3 \"immediate_operand\" \"i\")] 41))]\n+  \"TARGET_SSE\"\n+  ;; @@@ check operand order for intel/nonintel syntax\n+  \"pshufw\\\\t %3,{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; MMX mask-generating comparisons\n+\n+(define_insn \"eqv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (eq:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpeqb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"eqv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (eq:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpeqw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"eqv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (eq:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V2SI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpeqd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"gtv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (gt:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpgtb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"gtv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (gt:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpgtw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"gtv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (gt:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:V2SI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_MMX\"\n+  \"pcmpgtd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+\n+;; MMX max/min insns\n+\n+(define_insn \"umaxv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (umax:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_SSE\"\n+  \"pmaxub\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"smaxv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (smax:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_SSE\"\n+  \"pmaxsw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"uminv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (umin:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_SSE\"\n+  \"pminub\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"sminv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (smin:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))]\n+  \"TARGET_SSE\"\n+  \"pminsw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+\n+;; MMX shifts\n+\n+(define_insn \"ashrv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psraw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ashrv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psrad\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"lshrv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (lshiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psrlw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"lshrv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (lshiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psrld\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+;; See logical MMX insns.\n+(define_insn \"mmx_lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psrlq\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ashlv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (ashift:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psllw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ashlv2si3\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (ashift:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"pslld\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+;; See logical MMX insns.\n+(define_insn \"mmx_ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:DI 2 \"nonmemory_operand\" \"yi\")))]\n+  \"TARGET_MMX\"\n+  \"psllq\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+\n+;; MMX pack/unpack insns.\n+\n+(define_insn \"mmx_packsswb\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t(vec_concat:V8QI\n+\t (ss_truncate:V4QI (match_operand:V4HI 1 \"register_operand\" \"0\"))\n+\t (ss_truncate:V4QI (match_operand:V4HI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_MMX\"\n+  \"packsswb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_packssdw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(vec_concat:V4HI\n+\t (ss_truncate:V2HI (match_operand:V2SI 1 \"register_operand\" \"0\"))\n+\t (ss_truncate:V2HI (match_operand:V2SI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_MMX\"\n+  \"packssdw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_packuswb\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t(vec_concat:V8QI\n+\t (us_truncate:V4QI (match_operand:V4HI 1 \"register_operand\" \"0\"))\n+\t (us_truncate:V4QI (match_operand:V4HI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_MMX\"\n+  \"packuswb\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpckhbw\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V8QI\n+\t (vec_select:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 4)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 7)\n+\t\t\t\t     (const_int 3)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 4)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 7)]))\n+\t (const_int 85)))]\n+  \"TARGET_MMX\"\n+  \"punpckhbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpckhwd\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V4HI\n+\t (vec_select:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (vec_select:V4HI (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 5)))]\n+  \"TARGET_MMX\"\n+  \"punpckhbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpckhdq\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V2SI\n+\t (vec_select:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (vec_select:V2SI (match_operand:V2SI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 1)\n+\t\t\t\t     (const_int 0)]))\n+\t (const_int 1)))]\n+  \"TARGET_MMX\"\n+  \"punpckhbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpcklbw\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V8QI\n+\t (vec_select:V8QI (match_operand:V8QI 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 4)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 7)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 4)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 7)\n+\t\t\t\t     (const_int 3)]))\n+\t (const_int 85)))]\n+  \"TARGET_MMX\"\n+  \"punpcklbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpcklwd\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V4HI\n+\t (vec_select:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (vec_select:V4HI (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (const_int 5)))]\n+  \"TARGET_MMX\"\n+  \"punpcklbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"mmx_punpckldq\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t(vec_merge:V2SI\n+\t (vec_select:V2SI (match_operand:V2SI 1 \"register_operand\" \"0\")\n+\t\t\t   (parallel [(const_int 1)\n+\t\t\t\t      (const_int 0)]))\n+\t (vec_select:V2SI (match_operand:V2SI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 1)))]\n+  \"TARGET_MMX\"\n+  \"punpcklbw\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+\n+;; Miscellaneous stuff\n+\n+(define_insn \"emms\"\n+  [(unspec_volatile [(const_int 0)] 31)\n+   (clobber (reg:XF 8))\n+   (clobber (reg:XF 9))\n+   (clobber (reg:XF 10))\n+   (clobber (reg:XF 11))\n+   (clobber (reg:XF 12))\n+   (clobber (reg:XF 13))\n+   (clobber (reg:XF 14))\n+   (clobber (reg:XF 15))\n+   (clobber (reg:DI 27))\n+   (clobber (reg:DI 28))\n+   (clobber (reg:DI 29))\n+   (clobber (reg:DI 30))\n+   (clobber (reg:DI 31))\n+   (clobber (reg:DI 32))\n+   (clobber (reg:DI 33))\n+   (clobber (reg:DI 34))]\n+  \"TARGET_MMX\"\n+  \"emms\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"ldmxcsr\"\n+  [(unspec_volatile [(match_operand:SI 0 \"memory_operand\" \"m\")] 37)]\n+  \"TARGET_MMX\"\n+  \"ldmxcsr\\\\t%0\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_insn \"stmxcsr\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:SI [(const_int 0)] 40))]\n+  \"TARGET_MMX\"\n+  \"stmxcsr\\\\t%0\"\n+  [(set_attr \"type\" \"mmx\")])\n+\n+(define_expand \"sfence\"\n+  [(set (match_dup 0)\n+\t(unspec:BLK [(match_dup 0)] 44))]\n+  \"TARGET_SSE\"\n+  \"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+}\")\n+\n+(define_insn \"*sfence_insn\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] 44))]\n+  \"TARGET_SSE\"\n+  \"sfence\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"prefetch\"\n+  [(unspec [(match_operand:SI 0 \"address_operand\" \"p\")\n+\t    (match_operand:SI 1 \"address_operand\" \"p\")] 35)]\n+  \"TARGET_SSE\"\n+  \"*\n+{\n+  switch (INTVAL (operands[1]))\n+    {\n+    case 0:\n+      return \\\"prefetcht0\\\\t%0\\\";\n+    case 1:\n+      return \\\"prefetcht1\\\\t%0\\\";\n+    case 2:\n+      return \\\"prefetcht2\\\\t%0\\\";\n+    case 3:\n+      return \\\"prefetchnta\\\\t%0\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"sse\")])\n+"}]}