{"sha": "26570b21745ef73ffb6df68712cd3fb6932fe602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY1NzBiMjE3NDVlZjczZmZiNmRmNjg3MTJjZDNmYjY5MzJmZTYwMg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-03-26T07:42:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:42:37Z"}, "message": "sem_res.adb (Check_Infinite_Recursion): Diagnose definite infinite recursion and raise SE directly.\n\n2008-03-26  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb (Check_Infinite_Recursion): Diagnose definite infinite\n\trecursion and raise SE directly.\n\t(Resolve_Actuals): Reset Never_Set_In_Source if warnings off is\n\tset for formal type for IN mode parameter.\n\nFrom-SVN: r133579", "tree": {"sha": "975257c84c75b35b22c3dda0a9c2cd03cac46437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/975257c84c75b35b22c3dda0a9c2cd03cac46437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26570b21745ef73ffb6df68712cd3fb6932fe602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26570b21745ef73ffb6df68712cd3fb6932fe602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26570b21745ef73ffb6df68712cd3fb6932fe602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26570b21745ef73ffb6df68712cd3fb6932fe602/comments", "author": null, "committer": null, "parents": [{"sha": "7d823354f4372fc03b630275587b4873b9fef031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d823354f4372fc03b630275587b4873b9fef031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d823354f4372fc03b630275587b4873b9fef031"}], "stats": {"total": 73, "additions": 60, "deletions": 13}, "files": [{"sha": "9e8687daad67933da59c1be067a0e7490d7acd4a", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26570b21745ef73ffb6df68712cd3fb6932fe602/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26570b21745ef73ffb6df68712cd3fb6932fe602/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=26570b21745ef73ffb6df68712cd3fb6932fe602", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -720,8 +720,34 @@ package body Sem_Res is\n    --  Start of processing for Check_Infinite_Recursion\n \n    begin\n-      --  Loop moving up tree, quitting if something tells us we are\n-      --  definitely not in an infinite recursion situation.\n+      --  Special case, if this is a procedure call and is a call to the\n+      --  current procedure with the same argument list, then this is for\n+      --  sure an infinite recursion and we insert a call to raise SE.\n+\n+      if Is_List_Member (N)\n+        and then List_Length (List_Containing (N)) = 1\n+        and then Same_Argument_List\n+      then\n+         declare\n+            P : constant Node_Id := Parent (N);\n+         begin\n+            if Nkind (P) = N_Handled_Sequence_Of_Statements\n+              and then Nkind (Parent (P)) = N_Subprogram_Body\n+              and then Is_Empty_List (Declarations (Parent (P)))\n+            then\n+               Error_Msg_N (\"!?infinite recursion\", N);\n+               Error_Msg_N (\"\\!?Storage_Error will be raised at run time\", N);\n+               Insert_Action (N,\n+                 Make_Raise_Storage_Error (Sloc (N),\n+                   Reason => SE_Infinite_Recursion));\n+               return True;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  If not that special case, search up tree, quitting if we reach a\n+      --  construct (e.g. a conditional) that tells us that this is not a\n+      --  case for an infinite recursion warning.\n \n       C := N;\n       loop\n@@ -738,10 +764,10 @@ package body Sem_Res is\n          elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n            and then C /= First (Statements (P))\n          then\n-            --  If the call is the expression of a return statement and\n-            --  the actuals are identical to the formals, it's worth a\n-            --  warning. However, we skip this if there is an immediately\n-            --  preceding raise statement, since the call is never executed.\n+            --  If the call is the expression of a return statement and the\n+            --  actuals are identical to the formals, it's worth a warning.\n+            --  However, we skip this if there is an immediately preceding\n+            --  raise statement, since the call is never executed.\n \n             --  Furthermore, this corresponds to a common idiom:\n \n@@ -3045,6 +3071,21 @@ package body Sem_Res is\n             A_Typ := Etype (A);\n             F_Typ := Etype (F);\n \n+            --  For mode IN, if actual is an entity, and the type of the formal\n+            --  has warnings suppressed, then we reset Never_Set_In_Source for\n+            --  the calling entity. The reason for this is to catch cases like\n+            --  GNAT.Spitbol.Patterns.Vstring_Var where the called subprogram\n+            --  uses trickery to modify an IN parameter.\n+\n+            if Ekind (F) = E_In_Parameter\n+              and then Is_Entity_Name (A)\n+              and then Present (Entity (A))\n+              and then Ekind (Entity (A)) = E_Variable\n+              and then Has_Warnings_Off (F_Typ)\n+            then\n+               Set_Never_Set_In_Source (Entity (A), False);\n+            end if;\n+\n             --  Perform error checks for IN and IN OUT parameters\n \n             if Ekind (F) /= E_Out_Parameter then\n@@ -4625,17 +4666,23 @@ package body Sem_Res is\n       if Comes_From_Source (N) then\n          Scop := Current_Scope;\n \n+         --  Issue warning for possible infinite recursion in the absence\n+         --  of the No_Recursion restriction.\n+\n          if Nam = Scop\n            and then not Restriction_Active (No_Recursion)\n            and then Check_Infinite_Recursion (N)\n          then\n             --  Here we detected and flagged an infinite recursion, so we do\n-            --  not need to test the case below for further warnings.\n+            --  not need to test the case below for further warnings. Also if\n+            --  we now have a raise SE node, we are all done.\n \n-            null;\n+            if Nkind (N) = N_Raise_Storage_Error then\n+               return;\n+            end if;\n \n-            --  If call is to immediately containing subprogram, then check for\n-            --  the case of a possible run-time detectable infinite recursion.\n+         --  If call is to immediately containing subprogram, then check for\n+         --  the case of a possible run-time detectable infinite recursion.\n \n          else\n             Scope_Loop : while Scop /= Standard_Standard loop\n@@ -4761,7 +4808,7 @@ package body Sem_Res is\n       if Is_Inlined (Nam)\n         and then Present (First_Rep_Item (Nam))\n         and then Nkind (First_Rep_Item (Nam)) = N_Pragma\n-        and then Chars (First_Rep_Item (Nam)) = Name_Inline_Always\n+        and then Pragma_Name (First_Rep_Item (Nam)) = Name_Inline_Always\n       then\n          null;\n \n@@ -7196,7 +7243,7 @@ package body Sem_Res is\n             Orig : constant Node_Id := Original_Node (Parent (N));\n          begin\n             if Nkind (Orig) = N_Pragma\n-              and then Chars (Orig) = Name_Assert\n+              and then Pragma_Name (Orig) = Name_Assert\n             then\n                --  Don't want to warn if original condition is explicit False\n "}]}