{"sha": "7426c95997d36c6c6ad738ccbe4a67d739172728", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyNmM5NTk5N2QzNmM2YzZhZDczOGNjYmU0YTY3ZDczOTE3MjcyOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-08-18T06:28:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-08-18T06:28:39Z"}, "message": "pa.c (hppa_legitimize_address): Rework address computation for x[n - m] so that problems with implicit space...\n\n        * pa.c (hppa_legitimize_address): Rework address computation\n        for x[n - m] so that problems with implicit space register\n        selection are avoided.\n\nFrom-SVN: r5172", "tree": {"sha": "2a13f9015dd3548f1e29b9f92de9ea8eb358ae22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a13f9015dd3548f1e29b9f92de9ea8eb358ae22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7426c95997d36c6c6ad738ccbe4a67d739172728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7426c95997d36c6c6ad738ccbe4a67d739172728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7426c95997d36c6c6ad738ccbe4a67d739172728", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7426c95997d36c6c6ad738ccbe4a67d739172728/comments", "author": null, "committer": null, "parents": [{"sha": "e30f390e6fc1ba14d72379e40c9e5c7b2a20d0db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e30f390e6fc1ba14d72379e40c9e5c7b2a20d0db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e30f390e6fc1ba14d72379e40c9e5c7b2a20d0db"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "c4585fc9774059b83d3de6f681d274aa277a014c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7426c95997d36c6c6ad738ccbe4a67d739172728/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7426c95997d36c6c6ad738ccbe4a67d739172728/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7426c95997d36c6c6ad738ccbe4a67d739172728", "patch": "@@ -650,9 +650,21 @@ hppa_legitimize_address (x, oldx, mode)\n \t}\n       return plus_constant (ptr_reg, offset - newoffset);\n     }\n+\n+  /* Try to arrange things so that indexing modes can be used, but\n+     only do so if indexing is safe.  \n+\n+     Indexing is safe when the second operand for the outer PLUS\n+     is a REG, SUBREG, SYMBOL_REF or the like.  \n+\n+     For 2.5, indexing is also safe for (plus (symbol_ref) (const_int)) \n+     if the integer is > 0.  */\n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n+      && (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == 'o'\n+\t  || GET_CODE (XEXP (x, 1)) == SUBREG)\n+      && GET_CODE (XEXP (x, 1)) != CONST)\n     {\n       int val = INTVAL (XEXP (XEXP (x, 0), 1));\n       rtx reg1, reg2;\n@@ -665,6 +677,41 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t\t\t\t  GEN_INT (val)),\n \t\t\t\t reg1));\n     }\n+\n+  /* Uh-oh.  We might have an address for x[n-100000].  This needs \n+     special handling.  */\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+    {\n+      /* Ugly.  We modify things here so that the address offset specified\n+\t by the index expression is computed first, then added to x to form\n+\t the entire address.\n+\n+\t For 2.5, it might be profitable to set things up so that we\n+\t compute the raw (unscaled) index first, then use scaled indexing\n+\t to access memory, or better yet have the MI parts of the compiler\n+\t handle this.  */\n+\n+      rtx regx1, regy1, regy2, y;\n+\n+      /* Strip off any CONST.  */\n+      y = XEXP (x, 1);\n+      if (GET_CODE (y) == CONST)\n+\ty = XEXP (y, 0);\n+\n+      /* 'y' had better be a PLUS or MINUS expression at this point.  */\n+      if (GET_CODE (y) != PLUS && GET_CODE (y) != MINUS)\n+\tabort();\n+\n+      regx1 = force_reg (Pmode, force_operand (XEXP (x, 0), 0));\n+      regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n+      regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n+      regx1 = force_reg (Pmode, gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n+      return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+    }\n+\n   if (flag_pic) \n     return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n "}]}