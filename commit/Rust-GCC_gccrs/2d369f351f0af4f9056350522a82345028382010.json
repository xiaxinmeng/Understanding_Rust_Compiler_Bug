{"sha": "2d369f351f0af4f9056350522a82345028382010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQzNjlmMzUxZjBhZjRmOTA1NjM1MDUyMmE4MjM0NTAyODM4MjAxMA==", "commit": {"author": {"name": "Carlo Wood", "email": "carlo@alinoe.com", "date": "2003-11-07T17:55:27Z"}, "committer": {"name": "Carlo Wood", "email": "carlo@gcc.gnu.org", "date": "2003-11-07T17:55:27Z"}, "message": "re PR libstdc++/12736 (Demangler bug)\n\nPR libstdc++/12736\n* bits/demangle.h (qualifier_list<Allocator>::decode_KVrA): Added.\n(qualifier_list<Allocator>::decode_qualifiers): Collect concatenated\nK, V, r and A qualifiers before processing them as a group.\n* testsuite/demangle/abi_text/01.cc: Reordered CV-qualifiers.\n* testsuite/demangle/regression/cw-16.cc: New.\n\nFrom-SVN: r73339", "tree": {"sha": "23c5c25b00f15b1ab14017f8b266b019de7bbce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c5c25b00f15b1ab14017f8b266b019de7bbce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d369f351f0af4f9056350522a82345028382010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d369f351f0af4f9056350522a82345028382010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d369f351f0af4f9056350522a82345028382010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d369f351f0af4f9056350522a82345028382010/comments", "author": {"login": "CarloWood", "id": 590303, "node_id": "MDQ6VXNlcjU5MDMwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/590303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CarloWood", "html_url": "https://github.com/CarloWood", "followers_url": "https://api.github.com/users/CarloWood/followers", "following_url": "https://api.github.com/users/CarloWood/following{/other_user}", "gists_url": "https://api.github.com/users/CarloWood/gists{/gist_id}", "starred_url": "https://api.github.com/users/CarloWood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CarloWood/subscriptions", "organizations_url": "https://api.github.com/users/CarloWood/orgs", "repos_url": "https://api.github.com/users/CarloWood/repos", "events_url": "https://api.github.com/users/CarloWood/events{/privacy}", "received_events_url": "https://api.github.com/users/CarloWood/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bcc8cc820aee26465255c3aa47d3367fdd4e3885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc8cc820aee26465255c3aa47d3367fdd4e3885", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc8cc820aee26465255c3aa47d3367fdd4e3885"}], "stats": {"total": 192, "additions": 168, "deletions": 24}, "files": [{"sha": "d0c46d0042176bd5d8d1422f46477916a9e09eaf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2d369f351f0af4f9056350522a82345028382010", "patch": "@@ -1,3 +1,12 @@\n+2003-11-07  Carlo Wood  <carlo@alinoe.com>\n+\n+\tPR libstdc++/12736\n+\t* bits/demangle.h (qualifier_list<Allocator>::decode_KVrA): Added.\n+\t(qualifier_list<Allocator>::decode_qualifiers): Collect concatenated\n+\tK, V, r and A qualifiers before processing them as a group.\n+\t* testsuite/demangle/abi_text/01.cc: Reordered CV-qualifiers.\n+\t* testsuite/demangle/regression/cw-16.cc: New.\n+\n 2003-11-07  Robert Millan  <robertmh@gnu.org>\n \n         * configure.host: Add kfreebsd*-gnu and knetbsd*-gnu."}, {"sha": "872948c7d255d1d71fb0e837188bf25e8adde002", "filename": "libstdc++-v3/include/bits/demangle.h", "status": "modified", "additions": 124, "deletions": 23, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h?ref=2d369f351f0af4f9056350522a82345028382010", "patch": "@@ -227,6 +227,10 @@ namespace __gnu_cxx\n \tstd::vector<qualifier<Allocator>, Allocator> M_qualifier_starts;\n \tsession<Allocator>& M_demangler;\n \n+\tvoid decode_KVrA(string_type& prefix, string_type& postfix, int cvq,\n+          typename std::vector<qualifier<Allocator>, Allocator>::\n+\t      const_reverse_iterator const& iter_array) const;\n+\n       public:\n \tqualifier_list(session<Allocator>& demangler_obj)\n \t: M_printing_suppressed(false), M_demangler(demangler_obj)\n@@ -339,11 +343,6 @@ namespace __gnu_cxx\n \tstatic int\n \tdecode_encoding(string_type& output, char const* input, int len);\n \n-\tbool\n-\tdecode_type_with_postfix(string_type& prefix,\n-\t\t                 string_type& postfix,\n-\t            qualifier_list<Allocator>* qualifiers = NULL);\n-\n \tbool\n \tdecode_type(string_type& output,\n \t            qualifier_list<Allocator>* qualifiers = NULL)\n@@ -384,6 +383,8 @@ namespace __gnu_cxx\n \t                 substitution_nt sub_type,\n \t\t\t int number_of_prefixes);\n \n+\tbool decode_type_with_postfix(string_type& prefix,\n+\t    string_type& postfix, qualifier_list<Allocator>* qualifiers = NULL);\n \tbool decode_bare_function_type(string_type& output);\n \tbool decode_builtin_type(string_type& output);\n \tbool decode_call_offset(string_type& output);\n@@ -1382,8 +1383,11 @@ namespace __gnu_cxx\n     // <Q>M<C>\t\t==> C::*Q\t\t\t\"M<C>...\" (<C> recurs.)\n     // A<I>\t\t==>  [I]\t\t\t\"A<I>...\" (<I> recurs.)\n     // <Q>A<I>\t\t==>  (Q) [I]\t\t\t\"A<I>...\" (<I> recurs.)\n-    //   Note that when <Q> ends on an A<I2> then the brackets are omitted:\n-    //   A<I2>A<I>\t  ==> [I2][I]\n+    //   Note that when <Q> ends on an A<I2> then the brackets are omitted\n+    //   and no space is written between the two:\n+    //   A<I2>A<I>\t==>  [I2][I]\n+    //   If <Q> ends on [KVr]+, which can happen in combination with\n+    //   substitutions only, then special handling is required, see below.\n     //  \n     // A <substitution> is handled with an input position switch during which\n     // new substitutions are turned off.  Because recursive handling of types\n@@ -1411,6 +1415,86 @@ namespace __gnu_cxx\n     // For some weird reason, g++ (3.2.1) does not add substitutions for\n     // qualified member function pointers.  I think that is another bug.\n     //\n+\n+    // In the case of\n+    // <Q>A<I>\n+    // where <Q> ends on [K|V|r]+ then that part should be processed as\n+    // if it was behind the A<I> instead of in front of it.  This is\n+    // because a constant array of ints is normally always mangled as\n+    // an array of constant ints.  KVr qualifiers can end up in front\n+    // of an array when the array is part of a substitution or template\n+    // parameter, but the demangling should still result in the same\n+    // syntax; thus KA2_i (const array of ints) must result in the same\n+    // demangling as A2_Ki (array of const ints).  As a result we must\n+    // demangle ...[...[[KVr]+A<I0>][KVr]+A<I1>]...[KVr]+A<In>[KVr]+\n+    // as A<I0>A<I1>...A<In>[KVr]+ where each K, V and r in the series\n+    // collapses to a single character at the right of the string.\n+    // For example:\n+    // VA9_KrA6_KVi --> A9_A6_KVri --> int volatile const restrict [9][6]\n+    // Note that substitutions are still added as usual (the translation\n+    // to A9_A6_KVri does not really happen).\n+    //\n+    // This decoding is achieved by delaying the decoding of any sequence\n+    // of [KVrA]'s and processing them together in the order: first the\n+    // short-circuited KVr part and then the arrays.\n+    static int const cvq_K = 1;\t\t// Saw at least one K\n+    static int const cvq_V = 2;\t\t// Saw at least one V\n+    static int const cvq_r = 4;\t\t// Saw at least one r\n+    static int const cvq_A = 8;\t\t// Saw at least one A\n+    static int const cvq_last = 16;\t// No remaining qualifiers.\n+    static int const cvq_A_cnt = 32;\t// Bit 5 and higher represent the\n+    \t\t\t\t\t//   number of A's in the series.\n+    // In the function below, iter_array points to the first (right most)\n+    // A in the series, if any.\n+    template<typename Allocator>\n+      void\n+      qualifier_list<Allocator>::decode_KVrA(\n+          string_type& prefix, string_type& postfix, int cvq,\n+          typename std::vector<qualifier<Allocator>, Allocator>::\n+\t      const_reverse_iterator const& iter_array) const\n+\t{\n+\t  _GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_KVrA\");\n+\t  if ((cvq & cvq_K))\n+\t    prefix += \" const\";\n+\t  if ((cvq & cvq_V))\n+\t    prefix += \" volatile\";\n+\t  if ((cvq & cvq_r))\n+\t    prefix += \" restrict\";\n+\t  if ((cvq & cvq_A))\n+\t  {\n+\t    int n = cvq >> 5;\n+\t    for (typename std::vector<qualifier<Allocator>, Allocator>::\n+\t        const_reverse_iterator iter = iter_array;\n+\t\titer != M_qualifier_starts.rend(); ++iter)\n+\t    {\n+\t      switch((*iter).first_qualifier())\n+\t      {\n+\t\tcase 'K':\n+\t\tcase 'V':\n+\t\tcase 'r':\n+\t\t  break;\n+\t\tcase 'A':\n+\t\t{\n+\t\t  string_type index = (*iter).get_optional_type();\n+\t\t  if (--n == 0 && (cvq & cvq_last))\n+\t\t    postfix = \" [\" + index + \"]\" + postfix;\n+\t\t  else if (n > 0)\n+\t\t    postfix = \"[\" + index + \"]\" + postfix;\n+\t\t  else\n+\t\t  {\n+\t\t    prefix += \" (\";\n+\t\t    postfix = \") [\" + index + \"]\" + postfix;\n+\t\t  }\n+\t\t  break;\n+\t\t}\n+\t\tdefault:\n+\t\t  _GLIBCXX_DEMANGLER_RETURN3;\n+\t      }\n+\t    }\n+\t  }\n+\t  _GLIBCXX_DEMANGLER_RETURN3;\n+\t}\n+\n     template<typename Allocator>\n       void\n       qualifier_list<Allocator>::decode_qualifiers(\n@@ -1419,9 +1503,12 @@ namespace __gnu_cxx\n \t  bool member_function_pointer_qualifiers = false) const\n       {\n \t_GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_qualifiers\");\n+\tint cvq = 0;\n+\ttypename std::vector<qualifier<Allocator>, Allocator>::\n+\t    const_reverse_iterator iter_array;\n \tfor(typename std::vector<qualifier<Allocator>, Allocator>::\n \t    const_reverse_iterator iter = M_qualifier_starts.rbegin();\n-\t    iter != M_qualifier_starts.rend();)\n+\t    iter != M_qualifier_starts.rend(); ++iter)\n \t{\n \t  if (!member_function_pointer_qualifiers\n \t      && !(*iter).part_of_substitution())\n@@ -1437,40 +1524,54 @@ namespace __gnu_cxx\n \t    switch(qualifier_char)\n \t    {\n \t      case 'P':\n+\t\tif (cvq)\n+\t\t{\n+\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n+\t\t  cvq = 0;\n+\t\t}\n \t\tprefix += \"*\";\n \t\tbreak;\n \t      case 'R':\n+\t\tif (cvq)\n+\t\t{\n+\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n+\t\t  cvq = 0;\n+\t\t}\n \t\tprefix += \"&\";\n \t\tbreak;\n \t      case 'K':\n-\t\tprefix += \" const\";\n+\t\tcvq |= cvq_K;\n \t\tcontinue;\n \t      case 'V':\n-\t\tprefix += \" volatile\";\n+\t\tcvq |= cvq_V;\n \t\tcontinue;\n \t      case 'r':\n-\t\tprefix += \" restrict\";\n+\t\tcvq |= cvq_r;\n \t\tcontinue;\n \t      case 'A':\n-\t      {\n-\t\tstring_type index = (*iter).get_optional_type();\n-\t\tif (++iter == M_qualifier_starts.rend())\n-\t\t  postfix = \" [\" + index + \"]\" + postfix;\n-\t\telse if ((*iter).first_qualifier() == 'A')\n-\t\t  postfix = \"[\" + index + \"]\" + postfix;\n-\t\telse\n+\t        if (!(cvq & cvq_A))\n \t\t{\n-\t\t  prefix += \" (\";\n-\t\t  postfix = \") [\" + index + \"]\" + postfix;\n+\t\t  cvq |= cvq_A;\n+\t\t  iter_array = iter;\n \t\t}\n+\t\tcvq += cvq_A_cnt;\n \t\tbreak;\n-\t      }\n \t      case 'M':\n+\t        if (cvq)\n+\t\t{\n+\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n+\t\t  cvq = 0;\n+\t\t}\n \t\tprefix += \" \";\n \t\tprefix += (*iter).get_optional_type();\n \t\tprefix += \"::*\";\n \t\tbreak;\n \t      case 'U':\n+\t        if (cvq)\n+\t\t{\n+\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n+\t\t  cvq = 0;\n+\t\t}\n \t\tprefix += \" \";\n \t\tprefix += (*iter).get_optional_type();\n \t\tbreak;\n@@ -1479,9 +1580,9 @@ namespace __gnu_cxx\n \t    }\n \t    break;\n \t  }\n-\t  if (qualifier_char != 'A')\n-\t    ++iter;\n \t}\n+\tif (cvq)\n+\t  decode_KVrA(prefix, postfix, cvq|cvq_last, iter_array);\n \tM_printing_suppressed = false;\n \t_GLIBCXX_DEMANGLER_RETURN3;\n       }"}, {"sha": "5563d5093f746b000a67e37c1606d6af97c093a9", "filename": "libstdc++-v3/testsuite/demangle/abi_text/01.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fabi_text%2F01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fabi_text%2F01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fabi_text%2F01.cc?ref=2d369f351f0af4f9056350522a82345028382010", "patch": "@@ -36,7 +36,7 @@ int main()\n   // standard text\n   // verify_demangle(\"U4_farrVKPi\", \"int* volatile const restrict _far\");\n   // new __cxa_demangle\n-  verify_demangle(\"U4_farrVKPi\", \"int* restrict volatile const _far\");\n+  verify_demangle(\"U4_farrVKPi\", \"int* const volatile restrict _far\");\n \n   return 0;\n }"}, {"sha": "866143a76b85f998efdff9fd0ed2ae5429a7baa5", "filename": "libstdc++-v3/testsuite/demangle/regression/cw-16.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d369f351f0af4f9056350522a82345028382010/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc?ref=2d369f351f0af4f9056350522a82345028382010", "patch": "@@ -0,0 +1,34 @@\n+// 2003-10-14  Carlo Wood  <carlo@alinoe.com>\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// IA 64 C++ ABI - 5.1 External Names (a.k.a. Mangling)\n+\n+#include <testsuite_hooks.h>\n+\n+// libcwd tests\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+verify_demangle(\"_Z3fooIA6_KiEvA9_KT_rVPrS4_\",\n+\t\t\"void foo<int const [6]>(int const [9][6], int const restrict (* volatile restrict) [9][6])\");\n+\n+  return 0;\n+}"}]}