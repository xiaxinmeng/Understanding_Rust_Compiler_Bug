{"sha": "0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2M2E3NDAwZDlmNmYwZGU5NzAzYzIwZjQyNGRmNWRhMWFlM2JjZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-11-16T16:06:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-11-16T16:06:29Z"}, "message": "cgraphbuild.c (compute_call_stmt_bb_frequency): Use proper ENTRY_BLOCK_PTR.\n\n\n\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Use proper ENTRY_BLOCK_PTR.\n\t* cgraph.c (cgraph_clone_edge): Avoid freq_scale 0 to completely zero out all\n\tcallees.\n\t* cgraphunit.c (verify_cgraph_node): Verify cgraph nodes for frequency and count match.\n\t* ipa-inline.c (update_noncloned_frequencies): New function.\n\t(cgraph_clone_inlined_nodes): Use it.\n\t* tree-inline.c (copy_bb): Fix frequency scaling; output\n\tdiagnostic on frequency mismatches to dump file.\n\t(initialize_cfun): Do not scale frequency; fix count scaling;\n\tinitialize entry and exit block frequencies; copy profile\n\tinfo.\n\t(copy_cfg_body): Use frequency_scale as argument;\n\tfix count scaling.\n\t(copy_body): Use frequency_scale as argument.\n\t(expand_call_inline): Compute frequency scale and output diagnostic\n\tto dump file.\n\t(delete_unreachable_blocks_update_callgrah): Remove checking that\n\thas to be done after edge redirection.\n\t(tree_function_versioning): Update initialize_cfun and copy_body call.\n\nFrom-SVN: r154205", "tree": {"sha": "67e2fac7c1db371237d730ab058e8d5d1a4d330a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e2fac7c1db371237d730ab058e8d5d1a4d330a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/comments", "author": null, "committer": null, "parents": [{"sha": "3cb9d1d59a14630ef7c7bb6216c719066172ac86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb9d1d59a14630ef7c7bb6216c719066172ac86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb9d1d59a14630ef7c7bb6216c719066172ac86"}], "stats": {"total": 182, "additions": 115, "deletions": 67}, "files": [{"sha": "bee2ebc42d79748348bab85d94e633da39f13e76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "patch": "@@ -1,3 +1,25 @@\n+2009-11-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Use proper ENTRY_BLOCK_PTR.\n+\t* cgraph.c (cgraph_clone_edge): Avoid freq_scale 0 to completely zero out all\n+\tcallees.\n+\t* cgraphunit.c (verify_cgraph_node): Verify cgraph nodes for frequency and count match.\n+\t* ipa-inline.c (update_noncloned_frequencies): New function.\n+\t(cgraph_clone_inlined_nodes): Use it.\n+\t* tree-inline.c (copy_bb): Fix frequency scaling; output\n+\tdiagnostic on frequency mismatches to dump file.\n+\t(initialize_cfun): Do not scale frequency; fix count scaling;\n+\tinitialize entry and exit block frequencies; copy profile\n+\tinfo.\n+\t(copy_cfg_body): Use frequency_scale as argument;\n+\tfix count scaling.\n+\t(copy_body): Use frequency_scale as argument.\n+\t(expand_call_inline): Compute frequency scale and output diagnostic\n+\tto dump file.\n+\t(delete_unreachable_blocks_update_callgrah): Remove checking that\n+\thas to be done after edge redirection.\n+\t(tree_function_versioning): Update initialize_cfun and copy_body call.\n+\n 2009-11-14  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_release_function_body): Update use of"}, {"sha": "f2d76091799cc4c1e8406f6206a9cf805825d1fc", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "patch": "@@ -1641,8 +1641,12 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n {\n   struct cgraph_edge *new_edge;\n   gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n-  gcov_type freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+  gcov_type freq;\n \n+  /* We do not want to ignore loop nest after frequency drops to 0.  */\n+  if (!freq_scale)\n+    freq_scale = 1;\n+  freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n   if (freq > CGRAPH_FREQ_MAX)\n     freq = CGRAPH_FREQ_MAX;\n   new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,"}, {"sha": "0c3bff2f90e875b2a4ee4a65ac64243099878088", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "patch": "@@ -109,7 +109,8 @@ reset_inline_failed (struct cgraph_node *node)\n int\n compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n {\n-  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n+  int entry_freq = ENTRY_BLOCK_PTR_FOR_FUNCTION\n+  \t\t     (DECL_STRUCT_FUNCTION (decl))->frequency;\n   int freq = bb->frequency;\n \n   if (profile_status_for_function (DECL_STRUCT_FUNCTION (decl)) == PROFILE_ABSENT)"}, {"sha": "e9d831153fe44e1c46d36e1520dc956fd43aa3f0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "patch": "@@ -207,6 +207,29 @@ cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n   return size;\n }\n \n+/* Scale frequency of NODE edges by FREQ_SCALE and increase loop nest\n+   by NEST.  */\n+\n+static void\n+update_noncloned_frequencies (struct cgraph_node *node,\n+\t\t\t      int freq_scale, int nest)\n+{\n+  struct cgraph_edge *e;\n+\n+  /* We do not want to ignore high loop nest after freq drops to 0.  */\n+  if (!freq_scale)\n+    freq_scale = 1;\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      e->loop_nest += nest;\n+      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+      if (e->frequency > CGRAPH_FREQ_MAX)\n+        e->frequency = CGRAPH_FREQ_MAX;\n+      if (!e->inline_failed)\n+        update_noncloned_frequencies (e->callee, freq_scale, nest);\n+    }\n+}\n+\n /* E is expected to be an edge being inlined.  Clone destination node of\n    the edge and redirect it to the new clone.\n    DUPLICATE is used for bookkeeping on whether we are actually creating new\n@@ -234,6 +257,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    }\n \t  duplicate = false;\n \t  e->callee->local.externally_visible = false;\n+          update_noncloned_frequencies (e->callee, e->frequency, e->loop_nest);\n \t}\n       else\n \t{"}, {"sha": "34a8e9d8d0743cbc19e701505ded3e17f65dfe29", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d63a7400d9f6f0de9703c20f424df5da1ae3bcf/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0d63a7400d9f6f0de9703c20f424df5da1ae3bcf", "patch": "@@ -1472,6 +1472,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   gimple_stmt_iterator gsi, copy_gsi, seq_gsi;\n   basic_block copy_basic_block;\n   tree decl;\n+  gcov_type freq;\n \n   /* create_basic_block() will append every new block to\n      basic_block_info automatically.  */\n@@ -1481,11 +1482,12 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n   /* We are going to rebuild frequencies from scratch.  These values\n      have just small importance to drive canonicalize_loop_headers.  */\n-  copy_basic_block->frequency = ((gcov_type)bb->frequency\n-\t\t\t\t * frequency_scale / REG_BR_PROB_BASE);\n+  freq = ((gcov_type)bb->frequency * frequency_scale / REG_BR_PROB_BASE);\n \n-  if (copy_basic_block->frequency > BB_FREQ_MAX)\n-    copy_basic_block->frequency = BB_FREQ_MAX;\n+  /* We recompute frequencies after inlining, so this is quite safe.  */\n+  if (freq > BB_FREQ_MAX)\n+    freq = BB_FREQ_MAX;\n+  copy_basic_block->frequency = freq;\n \n   copy_gsi = gsi_start_bb (copy_basic_block);\n \n@@ -1631,10 +1633,34 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tcase CB_CGE_DUPLICATE:\n \t\t  edge = cgraph_edge (id->src_node, orig_stmt);\n \t\t  if (edge)\n-\t\t    edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t\t      gimple_uid (stmt),\n-\t\t\t\t\t      REG_BR_PROB_BASE, 1,\n-\t\t\t\t\t      edge->frequency, true);\n+\t\t    {\n+\t\t      int edge_freq = edge->frequency;\n+\t\t      edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n+\t\t\t\t\t        gimple_uid (stmt),\n+\t\t\t\t\t        REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t        edge->frequency, true);\n+\t\t      /* We could also just rescale the frequency, but\n+\t\t         doing so would introduce roundoff errors and make\n+\t\t\t verifier unhappy.  */\n+\t\t      edge->frequency \n+\t\t        = compute_call_stmt_bb_frequency (id->dst_node->decl,\n+\t\t\t\t\t\t\t  copy_basic_block);\n+\t\t      if (dump_file\n+\t\t      \t  && profile_status_for_function (cfun) != PROFILE_ABSENT\n+\t\t\t  && (edge_freq > edge->frequency + 10\n+\t\t\t      || edge_freq < edge->frequency - 10))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"Edge frequency estimated by \"\n+\t\t\t           \"cgraph %i diverge from inliner's estimate %i\\n\",\n+\t\t\t  \t   edge_freq,\n+\t\t\t\t   edge->frequency);\n+\t\t\t  fprintf (dump_file,\n+\t\t\t  \t   \"Orig bb: %i, orig bb freq %i, new bb freq %i\\n\",\n+\t\t\t\t   bb->index,\n+\t\t\t\t   bb->frequency,\n+\t\t\t\t   copy_basic_block->frequency);\n+\t\t\t}\n+\t\t    }\n \t\t  break;\n \n \t\tcase CB_CGE_MOVE_CLONES:\n@@ -1674,7 +1700,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n \t\t      (id->dst_node, dest, stmt, bb->count,\n-\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl, bb),\n+\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl, \n+\t\t       \t\t\t\t       copy_basic_block),\n \t\t       bb->loop_depth, CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n@@ -1948,24 +1975,16 @@ remap_decl_1 (tree decl, void *data)\n    NEW_FNDECL to be build.  CALLEE_FNDECL is the original */\n \n static void\n-initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n-\t\t int frequency)\n+initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n {\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n-  gcov_type count_scale, frequency_scale;\n+  gcov_type count_scale;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n \t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n   else\n-    count_scale = 1;\n-\n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency)\n-    frequency_scale = (REG_BR_PROB_BASE * frequency\n-\t\t       /\n-\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency);\n-  else\n-    frequency_scale = count_scale;\n+    count_scale = REG_BR_PROB_BASE;\n \n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n@@ -1998,18 +2017,17 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n \n   init_empty_tree_cfg ();\n \n+  profile_status_for_function (cfun) = profile_status_for_function (src_cfun);\n   ENTRY_BLOCK_PTR->count =\n     (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n      REG_BR_PROB_BASE);\n-  ENTRY_BLOCK_PTR->frequency =\n-    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n-     frequency_scale / REG_BR_PROB_BASE);\n+  ENTRY_BLOCK_PTR->frequency\n+    = ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;\n   EXIT_BLOCK_PTR->count =\n     (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n      REG_BR_PROB_BASE);\n   EXIT_BLOCK_PTR->frequency =\n-    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n-     frequency_scale / REG_BR_PROB_BASE);\n+    EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;\n   if (src_cfun->eh)\n     init_eh_for_function ();\n \n@@ -2026,7 +2044,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n static tree\n-copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n+copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t       basic_block entry_block_map, basic_block exit_block_map)\n {\n   tree callee_fndecl = id->src_fn;\n@@ -2035,21 +2053,14 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   struct function *cfun_to_copy;\n   basic_block bb;\n   tree new_fndecl = NULL;\n-  gcov_type count_scale, frequency_scale;\n+  gcov_type count_scale;\n   int last;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n \t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n   else\n-    count_scale = 1;\n-\n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency)\n-    frequency_scale = (REG_BR_PROB_BASE * frequency\n-\t\t       /\n-\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency);\n-  else\n-    frequency_scale = count_scale;\n+    count_scale = REG_BR_PROB_BASE;\n \n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n@@ -2204,15 +2215,15 @@ copy_tree_body (copy_body_data *id)\n    another function.  */\n \n static tree\n-copy_body (copy_body_data *id, gcov_type count, int frequency,\n+copy_body (copy_body_data *id, gcov_type count, int frequency_scale,\n \t   basic_block entry_block_map, basic_block exit_block_map)\n {\n   tree fndecl = id->src_fn;\n   tree body;\n \n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n-  body = copy_cfg_body (id, count, frequency, entry_block_map, exit_block_map);\n+  body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map);\n   copy_debug_stmts (id);\n \n   return body;\n@@ -3732,12 +3743,23 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t\t\t\t       cfun->local_decls);\n     }\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Inlining \");\n+      print_generic_expr (dump_file, id->src_fn, 0); \n+      fprintf (dump_file, \" to \");\n+      print_generic_expr (dump_file, id->dst_fn, 0); \n+      fprintf (dump_file, \" with frequency %i\\n\", cg_edge->frequency);\n+    }\n+\n   /* This is it.  Duplicate the callee body.  Assume callee is\n      pre-gimplified.  Note that we must not alter the caller\n      function in any way before this point, as this CALL_EXPR may be\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n-  copy_body (id, bb->count, bb->frequency, bb, return_block);\n+  copy_body (id, bb->count,\n+  \t     cg_edge->frequency * REG_BR_PROB_BASE / CGRAPH_FREQ_BASE,\n+\t     bb, return_block);\n \n   /* Reset the escaped and callused solutions.  */\n   if (cfun->gimple_df)\n@@ -4732,30 +4754,6 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \n   if (changed)\n     tidy_fallthru_edges ();\n-#ifdef ENABLE_CHECKING0\n-  verify_cgraph_node (id->dst_node);\n-  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n-      && id->dst_node->clones)\n-    {\n-      struct cgraph_node *node;\n-      for (node = id->dst_node->clones; node != id->dst_node;)\n-\t{\n-\t  verify_cgraph_node (node);\n-\t   \n-\t  if (node->clones)\n-\t    node = node->clones;\n-\t  else if (node->next_sibling_clone)\n-\t    node = node->next_sibling_clone;\n-\t  else\n-\t    {\n-\t      while (node != id->dst_node && !node->next_sibling_clone)\n-\t\tnode = node->clone_of;\n-\t      if (node != id->dst_node)\n-\t\tnode = node->next_sibling_clone;\n-\t    }\n-\t}\n-     }\n-#endif\n   return changed;\n }\n \n@@ -4876,8 +4874,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n     (DECL_STRUCT_FUNCTION (old_decl));\n   initialize_cfun (new_decl, old_decl,\n-\t\t   old_entry_block->count,\n-\t\t   old_entry_block->frequency);\n+\t\t   old_entry_block->count);\n   push_cfun (DECL_STRUCT_FUNCTION (new_decl));\n   \n   /* Copy the function's static chain.  */\n@@ -4947,7 +4944,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       }\n   \n   /* Copy the Function's body.  */\n-  copy_body (&id, old_entry_block->count, old_entry_block->frequency,\n+  copy_body (&id, old_entry_block->count, REG_BR_PROB_BASE,\n \t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR);\n   \n   if (DECL_RESULT (old_decl) != NULL_TREE)"}]}