{"sha": "c2047754c300b68c05d65faa8dc2925fe67b71b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwNDc3NTRjMzAwYjY4YzA1ZDY1ZmFhOGRjMjkyNWZlNjdiNzFiNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-01-14T00:05:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-14T00:05:42Z"}, "message": "libgo: update to Go 1.8 release candidate 1\n    \n    Compiler changes:\n      * Change map assignment to use mapassign and assign value directly.\n      * Change string iteration to use decoderune, faster for ASCII strings.\n      * Change makeslice to take int, and use makeslice64 for larger values.\n      * Add new noverflow field to hmap struct used for maps.\n    \n    Unresolved problems, to be fixed later:\n      * Commented out test in go/types/sizes_test.go that doesn't compile.\n      * Commented out reflect.TestStructOf test for padding after zero-sized field.\n    \n    Reviewed-on: https://go-review.googlesource.com/35231\n\ngotools/:\n\tUpdates for Go 1.8rc1.\n\t* Makefile.am (go_cmd_go_files): Add bug.go.\n\t(s-zdefaultcc): Write defaultPkgConfig.\n\t* Makefile.in: Rebuild.\n\nFrom-SVN: r244456", "tree": {"sha": "e183ae81a1f48a02945cb6de463a70c5be1b06f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e183ae81a1f48a02945cb6de463a70c5be1b06f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2047754c300b68c05d65faa8dc2925fe67b71b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2047754c300b68c05d65faa8dc2925fe67b71b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2047754c300b68c05d65faa8dc2925fe67b71b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2047754c300b68c05d65faa8dc2925fe67b71b4/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "829afb8f05602bb31c9c597b24df7377fed4f059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829afb8f05602bb31c9c597b24df7377fed4f059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829afb8f05602bb31c9c597b24df7377fed4f059"}], "stats": {"total": 86708, "additions": 69182, "deletions": 17526}, "files": [{"sha": "d594ded36b34e172700e7f0a1fcca00a5ee29cc8", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,4 +1,4 @@\n-153f7b68c0c4d3cf3da0becf82eb1a3eb8b47d6e\n+0ba4563a4b0dec4c01b90d7b3c9e2ce2cd58a96f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "a90c527a361e7a56715d6e232d222bed4c493899", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -297,6 +297,7 @@ Node::op_format() const\n \t\tcase Runtime::MAKECHAN:\n \t\tcase Runtime::MAKEMAP:\n \t\tcase Runtime::MAKESLICE:\n+\t\tcase Runtime::MAKESLICE64:\n \t\t  op << \"make\";\n \t\t  break;\n \n@@ -418,7 +419,8 @@ Node::is_big(Escape_context* context) const\n \t  Func_expression* fn = call->fn()->func_expression();\n \t  if (fn != NULL\n \t      && fn->is_runtime_function()\n-\t      && fn->runtime_code() == Runtime::MAKESLICE)\n+\t      && (fn->runtime_code() == Runtime::MAKESLICE\n+\t\t  || fn->runtime_code() == Runtime::MAKESLICE64))\n \t    {\n \t      // Second argument is length.\n \t      Expression_list::iterator p = call->args()->begin();\n@@ -1240,6 +1242,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t      case Runtime::MAKECHAN:\n \t      case Runtime::MAKEMAP:\n \t      case Runtime::MAKESLICE:\n+\t      case Runtime::MAKESLICE64:\n \t      case Runtime::SLICEBYTETOSTRING:\n \t      case Runtime::SLICERUNETOSTRING:\n \t      case Runtime::STRINGTOSLICEBYTE:\n@@ -1849,6 +1852,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\t  case Runtime::MAKECHAN:\n \t\t  case Runtime::MAKEMAP:\n \t\t  case Runtime::MAKESLICE:\n+\t\t  case Runtime::MAKESLICE64:\n \t\t    // DST = make(...).\n \t\t  case Runtime::SLICEBYTETOSTRING:\n \t\t    // DST = string([]byte{...}).\n@@ -2623,6 +2627,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t    case Runtime::MAKECHAN:\n \t\t    case Runtime::MAKEMAP:\n \t\t    case Runtime::MAKESLICE:\n+\t\t    case Runtime::MAKESLICE64:\n \t\t    case Runtime::SLICEBYTETOSTRING:\n \t\t    case Runtime::SLICERUNETOSTRING:\n \t\t    case Runtime::STRINGTOSLICEBYTE:"}, {"sha": "8006888b02a36721aac19511a4df8c7bb8a8909a", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7091,7 +7091,7 @@ class Builtin_call_expression : public Call_expression\n   Expression* flatten_append(Gogo*, Named_object*, Statement_inserter*);\n \n   bool\n-  check_int_value(Expression*, bool is_length);\n+  check_int_value(Expression*, bool is_length, bool* small);\n \n   // A pointer back to the general IR structure.  This avoids a global\n   // variable, or passing it around everywhere.\n@@ -7462,6 +7462,7 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n \n   ++parg;\n   Expression* len_arg;\n+  bool len_small = false;\n   if (parg == args->end())\n     {\n       if (is_slice)\n@@ -7475,17 +7476,18 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n     {\n       len_arg = *parg;\n       len_arg->determine_type(&int_context);\n-      if (!this->check_int_value(len_arg, true))\n+      if (!this->check_int_value(len_arg, true, &len_small))\n \treturn Expression::make_error(this->location());\n       ++parg;\n     }\n \n   Expression* cap_arg = NULL;\n+  bool cap_small = false;\n   if (is_slice && parg != args->end())\n     {\n       cap_arg = *parg;\n       cap_arg->determine_type(&int_context);\n-      if (!this->check_int_value(cap_arg, false))\n+      if (!this->check_int_value(cap_arg, false, &cap_small))\n \treturn Expression::make_error(this->location());\n \n       Numeric_constant nclen;\n@@ -7526,9 +7528,13 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n \t  inserter->insert(temp);\n \t  len_arg = Expression::make_temporary_reference(temp, loc);\n \t  cap_arg = Expression::make_temporary_reference(temp, loc);\n+\t  cap_small = len_small;\n \t}\n-      call = Runtime::make_call(Runtime::MAKESLICE, loc, 3, type_arg,\n-\t\t\t\tlen_arg, cap_arg);\n+\n+      Runtime::Function code = Runtime::MAKESLICE;\n+      if (!len_small || !cap_small)\n+\tcode = Runtime::MAKESLICE64;\n+      call = Runtime::make_call(code, loc, 3, type_arg, len_arg, cap_arg);\n     }\n   else if (is_map)\n     {\n@@ -7744,11 +7750,14 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \n // Return whether an expression has an integer value.  Report an error\n // if not.  This is used when handling calls to the predeclared make\n-// function.\n+// function.  Set *SMALL if the value is known to fit in type \"int\".\n \n bool\n-Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n+Builtin_call_expression::check_int_value(Expression* e, bool is_length,\n+\t\t\t\t\t bool *small)\n {\n+  *small = false;\n+\n   Numeric_constant nc;\n   if (e->numeric_constant_value(&nc))\n     {\n@@ -7784,11 +7793,22 @@ Builtin_call_expression::check_int_value(Expression* e, bool is_length)\n \t  return false;\n \t}\n \n+      *small = true;\n       return true;\n     }\n \n   if (e->type()->integer_type() != NULL)\n-    return true;\n+    {\n+      int ebits = e->type()->integer_type()->bits();\n+      int intbits = Type::lookup_integer_type(\"int\")->integer_type()->bits();\n+\n+      // We can treat ebits == intbits as small even for an unsigned\n+      // integer type, because we will convert the value to int and\n+      // then reject it in the runtime if it is negative.\n+      *small = ebits <= intbits;\n+\n+      return true;\n+    }\n \n   go_error_at(e->location(), \"non-integer %s argument to make\",\n \t      is_length ? \"len\" : \"cap\");"}, {"sha": "90bf34f7e99281d119f2a65f94139015db48dd06", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -31,12 +31,9 @@\n // The standard C memcmp function, used for struct comparisons.\n DEF_GO_RUNTIME(MEMCMP, \"__go_memcmp\", P3(POINTER, POINTER, UINTPTR), R1(INT))\n \n-// Range over a string, returning the next index.\n-DEF_GO_RUNTIME(STRINGITER, \"runtime.stringiter\", P2(STRING, INT), R1(INT))\n-\n-// Range over a string, returning the next index and character.\n-DEF_GO_RUNTIME(STRINGITER2, \"runtime.stringiter2\", P2(STRING, INT),\n-\t       R2(INT, RUNE))\n+// Decode a non-ASCII rune from a string.\n+DEF_GO_RUNTIME(DECODERUNE, \"runtime.decoderune\", P2(STRING, INT),\n+\t       R2(RUNE, INT))\n \n // Concatenate strings.\n DEF_GO_RUNTIME(CONCATSTRINGS, \"runtime.concatstrings\", P2(POINTER, SLICE),\n@@ -87,7 +84,10 @@ DEF_GO_RUNTIME(COMPLEX128_DIV, \"__go_complex128_div\",\n \t       P2(COMPLEX128, COMPLEX128), R1(COMPLEX128))\n \n // Make a slice.\n-DEF_GO_RUNTIME(MAKESLICE, \"runtime.makeslice\", P3(TYPE, INT64, INT64),\n+DEF_GO_RUNTIME(MAKESLICE, \"runtime.makeslice\", P3(TYPE, INT, INT),\n+\t       R1(SLICE))\n+\n+DEF_GO_RUNTIME(MAKESLICE64, \"runtime.makeslice64\", P3(TYPE, INT64, INT64),\n \t       R1(SLICE))\n \n \n@@ -119,8 +119,8 @@ DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2_fat\",\n \t       P4(TYPE, MAP, POINTER, POINTER), R2(POINTER, BOOL))\n \n // Assignment to a key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN, \"runtime.mapassign1\",\n-\t       P4(TYPE, MAP, POINTER, POINTER), R0())\n+DEF_GO_RUNTIME(MAPASSIGN, \"runtime.mapassign\", P3(TYPE, MAP, POINTER),\n+\t       R1(POINTER))\n \n // Delete a key from a map.\n DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P3(TYPE, MAP, POINTER), R0())"}, {"sha": "d6ab4ccd674fdcc3237a555a184c6e7404d0d282", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 100, "deletions": 68, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -707,32 +707,38 @@ Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n       Move_ordered_evals moe(b);\n       mie->traverse_subexpressions(&moe);\n \n-      // Copy key and value into temporaries so that we can take their\n-      // address without pushing the value onto the heap.\n+      // Copy the key into a temporary so that we can take its address\n+      // without pushing the value onto the heap.\n \n       // var key_temp KEY_TYPE = MAP_INDEX\n       Temporary_statement* key_temp = Statement::make_temporary(mt->key_type(),\n \t\t\t\t\t\t\t\tmie->index(),\n \t\t\t\t\t\t\t\tloc);\n       b->add_statement(key_temp);\n \n+      // Copy the value into a temporary to ensure that it is\n+      // evaluated before we add the key to the map.  This may matter\n+      // if the value is itself a reference to the map.\n+\n       // var val_temp VAL_TYPE = RHS\n       Temporary_statement* val_temp = Statement::make_temporary(mt->val_type(),\n \t\t\t\t\t\t\t\tthis->rhs_,\n \t\t\t\t\t\t\t\tloc);\n       b->add_statement(val_temp);\n \n-      // mapassign1(TYPE, MAP, &key_temp, &val_temp)\n+      // *mapassign(TYPE, MAP, &key_temp) = RHS\n       Expression* a1 = Expression::make_type_descriptor(mt, loc);\n       Expression* a2 = mie->map();\n       Temporary_reference_expression* ref =\n \tExpression::make_temporary_reference(key_temp, loc);\n       Expression* a3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      Expression* call = Runtime::make_call(Runtime::MAPASSIGN, loc, 3,\n+\t\t\t\t\t    a1, a2, a3);\n+      Type* ptrval_type = Type::make_pointer_type(mt->val_type());\n+      call = Expression::make_cast(ptrval_type, call, loc);\n+      Expression* indir = Expression::make_unary(OPERATOR_MULT, call, loc);\n       ref = Expression::make_temporary_reference(val_temp, loc);\n-      Expression* a4 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-      Expression* call = Runtime::make_call(Runtime::MAPASSIGN, loc, 4,\n-\t\t\t\t\t    a1, a2, a3, a4);\n-      b->add_statement(Statement::make_statement(call, false));\n+      b->add_statement(Statement::make_assignment(indir, ref, loc));\n \n       return Statement::make_block_statement(b, loc);\n     }\n@@ -5313,7 +5319,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n   else if (range_type->is_string_type())\n     {\n       index_type = Type::lookup_integer_type(\"int\");\n-      value_type = Type::lookup_integer_type(\"int32\");\n+      value_type = gogo->lookup_global(\"rune\")->type_value();\n     }\n   else if (range_type->map_type() != NULL)\n     {\n@@ -5458,7 +5464,7 @@ For_range_statement::make_range_ref(Named_object* range_object,\n // Return a call to the predeclared function FUNCNAME passing a\n // reference to the temporary variable ARG.\n \n-Expression*\n+Call_expression*\n For_range_statement::call_builtin(Gogo* gogo, const char* funcname,\n \t\t\t\t  Expression* arg,\n \t\t\t\t  Location loc)\n@@ -5664,7 +5670,7 @@ For_range_statement::lower_range_slice(Gogo* gogo,\n // Lower a for range over a string.\n \n void\n-For_range_statement::lower_range_string(Gogo*,\n+For_range_statement::lower_range_string(Gogo* gogo,\n \t\t\t\t\tBlock* enclosing,\n \t\t\t\t\tBlock* body_block,\n \t\t\t\t\tNamed_object* range_object,\n@@ -5679,94 +5685,121 @@ For_range_statement::lower_range_string(Gogo*,\n   Location loc = this->location();\n \n   // The loop we generate:\n+  //   len_temp := len(range)\n   //   var next_index_temp int\n-  //   for index_temp = 0; ; index_temp = next_index_temp {\n-  //           next_index_temp, value_temp = stringiter2(range, index_temp)\n-  //           if next_index_temp == 0 {\n-  //                   break\n+  //   for index_temp = 0; index_temp < len_temp; index_temp = next_index_temp {\n+  //           value_temp = rune(range[index_temp])\n+  //           if value_temp < utf8.RuneSelf {\n+  //                   next_index_temp = index_temp + 1\n+  //           } else {\n+  //                   value_temp, next_index_temp = decoderune(range, index_temp)\n   //           }\n   //           index = index_temp\n   //           value = value_temp\n-  //           original body\n+  //           // original body\n   //   }\n \n   // Set *PINIT to\n+  //   len_temp := len(range)\n   //   var next_index_temp int\n   //   index_temp = 0\n+  //   var value_temp rune // if value_temp not passed in\n \n   Block* init = new Block(enclosing, loc);\n \n+  Expression* ref = this->make_range_ref(range_object, range_temp, loc);\n+  Call_expression* call = this->call_builtin(gogo, \"len\", ref, loc);\n+  Temporary_statement* len_temp =\n+    Statement::make_temporary(index_temp->type(), call, loc);\n+  init->add_statement(len_temp);\n+\n   Temporary_statement* next_index_temp =\n     Statement::make_temporary(index_temp->type(), NULL, loc);\n   init->add_statement(next_index_temp);\n \n-  Expression* zexpr = Expression::make_integer_ul(0, NULL, loc);\n-\n-  Temporary_reference_expression* ref =\n+  Temporary_reference_expression* index_ref =\n     Expression::make_temporary_reference(index_temp, loc);\n-  ref->set_is_lvalue();\n-  Statement* s = Statement::make_assignment(ref, zexpr, loc);\n-\n+  index_ref->set_is_lvalue();\n+  Expression* zexpr = Expression::make_integer_ul(0, index_temp->type(), loc);\n+  Statement* s = Statement::make_assignment(index_ref, zexpr, loc);\n   init->add_statement(s);\n+\n+  Type* rune_type;\n+  if (value_temp != NULL)\n+    rune_type = value_temp->type();\n+  else\n+    {\n+      rune_type = gogo->lookup_global(\"rune\")->type_value();\n+      value_temp = Statement::make_temporary(rune_type, NULL, loc);\n+      init->add_statement(value_temp);\n+    }\n+\n   *pinit = init;\n \n-  // The loop has no condition.\n+  // Set *PCOND to\n+  //   index_temp < len_temp\n \n-  *pcond = NULL;\n+  index_ref = Expression::make_temporary_reference(index_temp, loc);\n+  Expression* len_ref =\n+    Expression::make_temporary_reference(len_temp, loc);\n+  *pcond = Expression::make_binary(OPERATOR_LT, index_ref, len_ref, loc);\n \n   // Set *PITER_INIT to\n-  //   next_index_temp = runtime.stringiter(range, index_temp)\n-  // or\n-  //   next_index_temp, value_temp = runtime.stringiter2(range, index_temp)\n-  // followed by\n-  //   if next_index_temp == 0 {\n-  //           break\n+  //   value_temp = rune(range[index_temp])\n+  //   if value_temp < utf8.RuneSelf {\n+  //           next_index_temp = index_temp + 1\n+  //   } else {\n+  //           value_temp, next_index_temp = decoderune(range, index_temp)\n   //   }\n \n   Block* iter_init = new Block(body_block, loc);\n \n-  Expression* p1 = this->make_range_ref(range_object, range_temp, loc);\n-  Expression* p2 = Expression::make_temporary_reference(index_temp, loc);\n-  Call_expression* call = Runtime::make_call((value_temp == NULL\n-\t\t\t\t\t      ? Runtime::STRINGITER\n-\t\t\t\t\t      : Runtime::STRINGITER2),\n-\t\t\t\t\t     loc, 2, p1, p2);\n+  ref = this->make_range_ref(range_object, range_temp, loc);\n+  index_ref = Expression::make_temporary_reference(index_temp, loc);\n+  ref = Expression::make_string_index(ref, index_ref, NULL, loc);\n+  ref = Expression::make_cast(rune_type, ref, loc);\n+  Temporary_reference_expression* value_ref =\n+    Expression::make_temporary_reference(value_temp, loc);\n+  value_ref->set_is_lvalue();\n+  s = Statement::make_assignment(value_ref, ref, loc);\n+  iter_init->add_statement(s);\n \n-  if (value_temp == NULL)\n-    {\n-      ref = Expression::make_temporary_reference(next_index_temp, loc);\n-      ref->set_is_lvalue();\n-      s = Statement::make_assignment(ref, call, loc);\n-    }\n-  else\n-    {\n-      Expression_list* lhs = new Expression_list();\n+  value_ref = Expression::make_temporary_reference(value_temp, loc);\n+  Expression* rune_self = Expression::make_integer_ul(0x80, rune_type, loc);\n+  Expression* cond = Expression::make_binary(OPERATOR_LT, value_ref, rune_self,\n+\t\t\t\t\t     loc);\n \n-      ref = Expression::make_temporary_reference(next_index_temp, loc);\n-      ref->set_is_lvalue();\n-      lhs->push_back(ref);\n+  Block* then_block = new Block(iter_init, loc);\n \n-      ref = Expression::make_temporary_reference(value_temp, loc);\n-      ref->set_is_lvalue();\n-      lhs->push_back(ref);\n+  Temporary_reference_expression* lhs =\n+    Expression::make_temporary_reference(next_index_temp, loc);\n+  lhs->set_is_lvalue();\n+  index_ref = Expression::make_temporary_reference(index_temp, loc);\n+  Expression* one = Expression::make_integer_ul(1, index_temp->type(), loc);\n+  Expression* sum = Expression::make_binary(OPERATOR_PLUS, index_ref, one,\n+\t\t\t\t\t    loc);\n+  s = Statement::make_assignment(lhs, sum, loc);\n+  then_block->add_statement(s);\n \n-      Expression_list* rhs = new Expression_list();\n-      rhs->push_back(Expression::make_call_result(call, 0));\n-      rhs->push_back(Expression::make_call_result(call, 1));\n+  Block* else_block = new Block(iter_init, loc);\n \n-      s = Statement::make_tuple_assignment(lhs, rhs, loc);\n-    }\n-  iter_init->add_statement(s);\n+  ref = this->make_range_ref(range_object, range_temp, loc);\n+  index_ref = Expression::make_temporary_reference(index_temp, loc);\n+  call = Runtime::make_call(Runtime::DECODERUNE, loc, 2, ref, index_ref);\n \n-  ref = Expression::make_temporary_reference(next_index_temp, loc);\n-  zexpr = Expression::make_integer_ul(0, NULL, loc);\n-  Expression* equals = Expression::make_binary(OPERATOR_EQEQ, ref, zexpr, loc);\n+  value_ref = Expression::make_temporary_reference(value_temp, loc);\n+  value_ref->set_is_lvalue();\n+  Expression* res = Expression::make_call_result(call, 0);\n+  s = Statement::make_assignment(value_ref, res, loc);\n+  else_block->add_statement(s);\n \n-  Block* then_block = new Block(iter_init, loc);\n-  s = Statement::make_break_statement(this->break_label(), loc);\n-  then_block->add_statement(s);\n+  lhs = Expression::make_temporary_reference(next_index_temp, loc);\n+  lhs->set_is_lvalue();\n+  res = Expression::make_call_result(call, 1);\n+  s = Statement::make_assignment(lhs, res, loc);\n+  else_block->add_statement(s);\n \n-  s = Statement::make_if_statement(equals, then_block, NULL, loc);\n+  s = Statement::make_if_statement(cond, then_block, else_block, loc);\n   iter_init->add_statement(s);\n \n   *piter_init = iter_init;\n@@ -5776,11 +5809,10 @@ For_range_statement::lower_range_string(Gogo*,\n \n   Block* post = new Block(enclosing, loc);\n \n-  Temporary_reference_expression* lhs =\n-    Expression::make_temporary_reference(index_temp, loc);\n-  lhs->set_is_lvalue();\n-  Expression* rhs = Expression::make_temporary_reference(next_index_temp, loc);\n-  s = Statement::make_assignment(lhs, rhs, loc);\n+  index_ref = Expression::make_temporary_reference(index_temp, loc);\n+  index_ref->set_is_lvalue();\n+  ref = Expression::make_temporary_reference(next_index_temp, loc);\n+  s = Statement::make_assignment(index_ref, ref, loc);\n \n   post->add_statement(s);\n   *ppost = post;"}, {"sha": "dac99de4cae0e1f4c768e195d2fa733f0bd7d8d2", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1500,7 +1500,7 @@ class For_range_statement : public Statement\n   Expression*\n   make_range_ref(Named_object*, Temporary_statement*, Location);\n \n-  Expression*\n+  Call_expression*\n   call_builtin(Gogo*, const char* funcname, Expression* arg, Location);\n \n   void"}, {"sha": "0d14adf65b5f63f60f1a5dd205069643706fbfe4", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7319,7 +7319,7 @@ Map_type::do_get_backend(Gogo* gogo)\n   static Btype* backend_map_type;\n   if (backend_map_type == NULL)\n     {\n-      std::vector<Backend::Btyped_identifier> bfields(8);\n+      std::vector<Backend::Btyped_identifier> bfields(9);\n \n       Location bloc = Linemap::predeclared_location();\n \n@@ -7337,30 +7337,35 @@ Map_type::do_get_backend(Gogo* gogo)\n       bfields[2].btype = bfields[1].btype;\n       bfields[2].location = bloc;\n \n-      Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n-      bfields[3].name = \"hash0\";\n-      bfields[3].btype = uint32_type->get_backend(gogo);\n+      Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+      bfields[3].name = \"noverflow\";\n+      bfields[3].btype = uint16_type->get_backend(gogo);\n       bfields[3].location = bloc;\n \n-      Btype* bvt = gogo->backend()->void_type();\n-      Btype* bpvt = gogo->backend()->pointer_type(bvt);\n-      bfields[4].name = \"buckets\";\n-      bfields[4].btype = bpvt;\n+      Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+      bfields[4].name = \"hash0\";\n+      bfields[4].btype = uint32_type->get_backend(gogo);\n       bfields[4].location = bloc;\n \n-      bfields[5].name = \"oldbuckets\";\n+      Btype* bvt = gogo->backend()->void_type();\n+      Btype* bpvt = gogo->backend()->pointer_type(bvt);\n+      bfields[5].name = \"buckets\";\n       bfields[5].btype = bpvt;\n       bfields[5].location = bloc;\n \n-      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-      bfields[6].name = \"nevacuate\";\n-      bfields[6].btype = uintptr_type->get_backend(gogo);\n+      bfields[6].name = \"oldbuckets\";\n+      bfields[6].btype = bpvt;\n       bfields[6].location = bloc;\n \n-      bfields[7].name = \"overflow\";\n-      bfields[7].btype = bpvt;\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      bfields[7].name = \"nevacuate\";\n+      bfields[7].btype = uintptr_type->get_backend(gogo);\n       bfields[7].location = bloc;\n \n+      bfields[8].name = \"overflow\";\n+      bfields[8].btype = bpvt;\n+      bfields[8].location = bloc;\n+\n       Btype *bt = gogo->backend()->struct_type(bfields);\n       bt = gogo->backend()->named_type(\"runtime.hmap\", bt, bloc);\n       backend_map_type = gogo->backend()->pointer_type(bt);"}, {"sha": "5933801ee75b3bf486f0d419eec194614d987715", "filename": "gotools/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,3 +1,10 @@\n+2017-01-13  Ian Lance Taylor  <iant@golang.org>\n+\n+\tUpdates for Go 1.8rc1.\n+\t* Makefile.am (go_cmd_go_files): Add bug.go.\n+\t(s-zdefaultcc): Write defaultPkgConfig.\n+\t* Makefile.in: Rebuild.\n+\n 2016-06-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tUpdate copyrights."}, {"sha": "5f3940a278b3eafbf670ae6ee092ae8ea8e7de01", "filename": "gotools/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -45,6 +45,7 @@ cmdsrcdir = $(srcdir)/../libgo/go/cmd\n \n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/alldocs.go \\\n+\t$(cmdsrcdir)/go/bug.go \\\n \t$(cmdsrcdir)/go/build.go \\\n \t$(cmdsrcdir)/go/clean.go \\\n \t$(cmdsrcdir)/go/context.go \\\n@@ -99,6 +100,7 @@ s-zdefaultcc: Makefile\n \techo 'const defaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n \techo 'const defaultCC = \"$(bindir)/$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n \techo 'const defaultCXX = \"$(bindir)/$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const defaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n "}, {"sha": "4386576b011846c4226f19d926456531b3278083", "filename": "gotools/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -16,7 +16,7 @@\n @SET_MAKE@\n \n # Makefile for gotools\n-#   Copyright 2015 Free Software Foundation, Inc.\n+#   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n #\n # This file is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -263,6 +263,7 @@ GOLINK = $(GOCOMPILER) $(GOCFLAGS) $(AM_GOCFLAGS) $(LDFLAGS) $(AM_LDFLAGS) -o $@\n cmdsrcdir = $(srcdir)/../libgo/go/cmd\n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/alldocs.go \\\n+\t$(cmdsrcdir)/go/bug.go \\\n \t$(cmdsrcdir)/go/build.go \\\n \t$(cmdsrcdir)/go/clean.go \\\n \t$(cmdsrcdir)/go/context.go \\\n@@ -664,6 +665,7 @@ s-zdefaultcc: Makefile\n \techo 'const defaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n \techo 'const defaultCC = \"$(bindir)/$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n \techo 'const defaultCXX = \"$(bindir)/$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const defaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n "}, {"sha": "a126b52ed78969060fb5c2b73a53f83a1e6da70f", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,4 +1,4 @@\n-f75aafdf56dd90eab75cfeac8cf69358f73ba171\n+3de6e96e4b8147f5267a2e8218a7c780b09a434f\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "0d9b7a7f6ad0e972e90945a48ed0cf4c2ae37ad0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -346,7 +346,8 @@ toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n \n toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n-\truntime/pprof.gox\n+\truntime/pprof.gox \\\n+\truntime/trace.gox\n \n toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n \n@@ -669,6 +670,7 @@ PACKAGES = \\\n \tarchive/zip \\\n \tbufio \\\n \tbytes \\\n+\tcmd/internal/browser \\\n \tcompress/bzip2 \\\n \tcompress/flate \\\n \tcompress/gzip \\\n@@ -686,6 +688,7 @@ PACKAGES = \\\n \tcrypto/ecdsa \\\n \tcrypto/elliptic \\\n \tcrypto/hmac \\\n+\tcrypto/internal/cipherhw \\\n \tcrypto/md5 \\\n \tcrypto/rand \\\n \tcrypto/rc4 \\\n@@ -736,8 +739,16 @@ PACKAGES = \\\n \tgo/scanner \\\n \tgo/token \\\n \tgo/types \\\n+\tgolang_org/x/crypto/chacha20poly1305 \\\n+\tgolang_org/x/crypto/chacha20poly1305/internal/chacha20 \\\n+\tgolang_org/x/crypto/curve25519 \\\n+\tgolang_org/x/crypto/poly1305 \\\n \tgolang_org/x/net/http2/hpack \\\n+\tgolang_org/x/net/idna \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/text/transform \\\n+\tgolang_org/x/text/unicode/norm \\\n+\tgolang_org/x/text/width \\\n \thash \\\n \thash/adler32 \\\n \thash/crc32 \\\n@@ -755,6 +766,7 @@ PACKAGES = \\\n \timage/png \\\n \tindex/suffixarray \\\n \tinternal/nettrace \\\n+\tinternal/pprof/profile \\\n \tinternal/race \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n@@ -802,13 +814,16 @@ PACKAGES = \\\n \truntime/internal/atomic \\\n \truntime/internal/sys \\\n \truntime/pprof \\\n+\truntime/pprof/internal/protopprof \\\n+\truntime/trace \\\n \tsort \\\n \tstrconv \\\n \tstrings \\\n \tsync \\\n \tsync/atomic \\\n \tsyscall \\\n \ttesting \\\n+\ttesting/internal/testdeps \\\n \ttesting/iotest \\\n \ttesting/quick \\\n \ttext/scanner \\\n@@ -829,6 +844,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\t$(golang_org_x_net_lif_lo) \\\n \t$(golang_org_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n@@ -1113,7 +1129,7 @@ if LIBGO_IS_BSD\n \n # Build golang_org/x/net/route only on BSD systems.\n \n-$(eval $(call PACKAGE_template,golang_org/x/net/route)\n+$(eval $(call PACKAGE_template,golang_org/x/net/route))\n \n golang_org_x_net_route_lo = \\\n \tgolang_org/x/net/route/route.lo\n@@ -1122,6 +1138,19 @@ golang_org_x_net_route_check = \\\n \n endif\n \n+if LIBGO_IS_SOLARIS\n+\n+# Build golang_org/x/net/lif only on Solaris systems.\n+\n+$(eval $(call PACKAGE_template,golang_org/x/net/lif))\n+\n+golang_org_x_net_lif_lo = \\\n+\tgolang_org/x/net/lif/lif.lo\n+golang_org_x_net_lif_check = \\\n+\tgolang_org/x/net/lif/check\n+\n+endif\n+\n TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n@@ -1209,8 +1238,14 @@ TEST_PACKAGES = \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/types/check \\\n+\tgolang_org/x/crypto/chacha20poly1305/check \\\n+\tgolang_org/x/crypto/chacha20poly1305/internal/chacha20/check \\\n+\tgolang_org/x/crypto/curve25519/check \\\n+\tgolang_org/x/crypto/poly1305/check \\\n \tgolang_org/x/net/http2/hpack/check \\\n+\tgolang_org/x/net/idna/check \\\n \tgolang_org/x/net/lex/httplex/check \\\n+\t$(golang_org_x_net_lif_check) \\\n \t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -1221,6 +1256,7 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n+\tinternal/pprof/profile/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n@@ -1251,9 +1287,10 @@ TEST_PACKAGES = \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \truntime/debug/check \\\n-\truntime/pprof/check \\\n \truntime/internal/atomic/check \\\n \truntime/internal/sys/check \\\n+\truntime/pprof/check \\\n+\truntime/pprof/internal/protopprof/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n \ttext/tabwriter/check \\"}, {"sha": "4b46076b010df151e905b8f83ef31507f1dc8ad9", "filename": "libgo/Makefile.in", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -168,9 +168,9 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) bytes/index.lo \\\n \treflect/makefunc_ffi_c.lo strings/index.lo \\\n \t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo $(golang_org_x_net_route_lo) \\\n-\tlog/syslog/syslog_c.lo runtime/internal/atomic_c.lo \\\n-\tsync/atomic_c.lo\n+\tsyscall/wait.lo $(golang_org_x_net_lif_lo) \\\n+\t$(golang_org_x_net_route_lo) log/syslog/syslog_c.lo \\\n+\truntime/internal/atomic_c.lo sync/atomic_c.lo\n am__DEPENDENCIES_3 =\n am__DEPENDENCIES_4 = $(am__DEPENDENCIES_2) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_3) \\\n@@ -728,7 +728,8 @@ toolexeclibgoregexp_DATA = \\\n toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n-\truntime/pprof.gox\n+\truntime/pprof.gox \\\n+\truntime/trace.gox\n \n toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n toolexeclibgosync_DATA = \\\n@@ -834,6 +835,7 @@ PACKAGES = \\\n \tarchive/zip \\\n \tbufio \\\n \tbytes \\\n+\tcmd/internal/browser \\\n \tcompress/bzip2 \\\n \tcompress/flate \\\n \tcompress/gzip \\\n@@ -851,6 +853,7 @@ PACKAGES = \\\n \tcrypto/ecdsa \\\n \tcrypto/elliptic \\\n \tcrypto/hmac \\\n+\tcrypto/internal/cipherhw \\\n \tcrypto/md5 \\\n \tcrypto/rand \\\n \tcrypto/rc4 \\\n@@ -901,8 +904,16 @@ PACKAGES = \\\n \tgo/scanner \\\n \tgo/token \\\n \tgo/types \\\n+\tgolang_org/x/crypto/chacha20poly1305 \\\n+\tgolang_org/x/crypto/chacha20poly1305/internal/chacha20 \\\n+\tgolang_org/x/crypto/curve25519 \\\n+\tgolang_org/x/crypto/poly1305 \\\n \tgolang_org/x/net/http2/hpack \\\n+\tgolang_org/x/net/idna \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/text/transform \\\n+\tgolang_org/x/text/unicode/norm \\\n+\tgolang_org/x/text/width \\\n \thash \\\n \thash/adler32 \\\n \thash/crc32 \\\n@@ -920,6 +931,7 @@ PACKAGES = \\\n \timage/png \\\n \tindex/suffixarray \\\n \tinternal/nettrace \\\n+\tinternal/pprof/profile \\\n \tinternal/race \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n@@ -967,13 +979,16 @@ PACKAGES = \\\n \truntime/internal/atomic \\\n \truntime/internal/sys \\\n \truntime/pprof \\\n+\truntime/pprof/internal/protopprof \\\n+\truntime/trace \\\n \tsort \\\n \tstrconv \\\n \tstrings \\\n \tsync \\\n \tsync/atomic \\\n \tsyscall \\\n \ttesting \\\n+\ttesting/internal/testdeps \\\n \ttesting/iotest \\\n \ttesting/quick \\\n \ttext/scanner \\\n@@ -994,6 +1009,7 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n+\t$(golang_org_x_net_lif_lo) \\\n \t$(golang_org_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n@@ -1161,6 +1177,12 @@ extra_go_files_runtime_internal_sys = version.go\n @LIBGO_IS_BSD_TRUE@golang_org_x_net_route_check = \\\n @LIBGO_IS_BSD_TRUE@\tgolang_org/x/net/route/check\n \n+@LIBGO_IS_SOLARIS_TRUE@golang_org_x_net_lif_lo = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tgolang_org/x/net/lif/lif.lo\n+\n+@LIBGO_IS_SOLARIS_TRUE@golang_org_x_net_lif_check = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tgolang_org/x/net/lif/check\n+\n TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n@@ -1248,8 +1270,14 @@ TEST_PACKAGES = \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/types/check \\\n+\tgolang_org/x/crypto/chacha20poly1305/check \\\n+\tgolang_org/x/crypto/chacha20poly1305/internal/chacha20/check \\\n+\tgolang_org/x/crypto/curve25519/check \\\n+\tgolang_org/x/crypto/poly1305/check \\\n \tgolang_org/x/net/http2/hpack/check \\\n+\tgolang_org/x/net/idna/check \\\n \tgolang_org/x/net/lex/httplex/check \\\n+\t$(golang_org_x_net_lif_check) \\\n \t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -1260,6 +1288,7 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n+\tinternal/pprof/profile/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n@@ -1290,9 +1319,10 @@ TEST_PACKAGES = \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \truntime/debug/check \\\n-\truntime/pprof/check \\\n \truntime/internal/atomic/check \\\n \truntime/internal/sys/check \\\n+\truntime/pprof/check \\\n+\truntime/pprof/internal/protopprof/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n \ttext/tabwriter/check \\\n@@ -3316,7 +3346,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \n # Build golang_org/x/net/route only on BSD systems.\n \n-@LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/route)\n+@LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/route))\n+\n+# Build golang_org/x/net/lif only on Solaris systems.\n+\n+@LIBGO_IS_SOLARIS_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/lif))\n \n check: check-tail\n check-recursive: check-head"}, {"sha": "3076f40768f2dedd87439587793efd680b895a7e", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1 +1 @@\n-go1.7.1\n+go1.8rc1"}, {"sha": "d2ae66d554d400d90721bad110a4ffa9b427d559", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -13,14 +13,17 @@\n package tar\n \n import (\n-\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"path\"\n \t\"time\"\n )\n \n+// BUG: Use of the Uid and Gid fields in Header could overflow on 32-bit\n+// architectures. If a large value is encountered when decoding, the result\n+// stored in Header will be the truncated version.\n+\n // Header type flags.\n const (\n \tTypeReg           = '0'    // regular file\n@@ -271,28 +274,6 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \treturn h, nil\n }\n \n-func isASCII(s string) bool {\n-\tfor _, c := range s {\n-\t\tif c >= 0x80 {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func toASCII(s string) string {\n-\tif isASCII(s) {\n-\t\treturn s\n-\t}\n-\tvar buf bytes.Buffer\n-\tfor _, c := range s {\n-\t\tif c < 0x80 {\n-\t\t\tbuf.WriteByte(byte(c))\n-\t\t}\n-\t}\n-\treturn buf.String()\n-}\n-\n // isHeaderOnlyType checks if the given type flag is of the type that has no\n // data section even if a size is specified.\n func isHeaderOnlyType(flag byte) bool {"}, {"sha": "9abe888218f8b24c7a18574b2e272414062ccccb", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 203, "deletions": 328, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -22,22 +22,20 @@ var (\n \tErrHeader = errors.New(\"archive/tar: invalid tar header\")\n )\n \n-const maxNanoSecondIntSize = 9\n-\n // A Reader provides sequential access to the contents of a tar archive.\n // A tar archive consists of a sequence of files.\n // The Next method advances to the next file in the archive (including the first),\n // and then it can be treated as an io.Reader to access the file's data.\n type Reader struct {\n \tr    io.Reader\n-\terr  error\n \tpad  int64          // amount of padding (ignored) after current file entry\n \tcurr numBytesReader // reader for current file entry\n \tblk  block          // buffer to use as temporary local storage\n-}\n \n-type parser struct {\n-\terr error // Last error seen\n+\t// err is a persistent error.\n+\t// It is only the responsibility of every exported method of Reader to\n+\t// ensure that this error is sticky.\n+\terr error\n }\n \n // A numBytesReader is an io.Reader with a numBytes method, returning the number\n@@ -108,8 +106,12 @@ func (tr *Reader) Next() (*Header, error) {\n \tif tr.err != nil {\n \t\treturn nil, tr.err\n \t}\n+\thdr, err := tr.next()\n+\ttr.err = err\n+\treturn hdr, err\n+}\n \n-\tvar hdr *Header\n+func (tr *Reader) next() (*Header, error) {\n \tvar extHdrs map[string]string\n \n \t// Externally, Next iterates through the tar archive as if it is a series of\n@@ -119,29 +121,29 @@ func (tr *Reader) Next() (*Header, error) {\n \t// one or more \"header files\" until it finds a \"normal file\".\n loop:\n \tfor {\n-\t\ttr.err = tr.skipUnread()\n-\t\tif tr.err != nil {\n-\t\t\treturn nil, tr.err\n+\t\tif err := tr.skipUnread(); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n-\n-\t\thdr = tr.readHeader()\n-\t\tif tr.err != nil {\n-\t\t\treturn nil, tr.err\n+\t\thdr, rawHdr, err := tr.readHeader()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := tr.handleRegularFile(hdr); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n \n \t\t// Check for PAX/GNU special headers and files.\n \t\tswitch hdr.Typeflag {\n \t\tcase TypeXHeader:\n-\t\t\textHdrs, tr.err = parsePAX(tr)\n-\t\t\tif tr.err != nil {\n-\t\t\t\treturn nil, tr.err\n+\t\t\textHdrs, err = parsePAX(tr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n \t\t\tcontinue loop // This is a meta header affecting the next header\n \t\tcase TypeGNULongName, TypeGNULongLink:\n-\t\t\tvar realname []byte\n-\t\t\trealname, tr.err = ioutil.ReadAll(tr)\n-\t\t\tif tr.err != nil {\n-\t\t\t\treturn nil, tr.err\n+\t\t\trealname, err := ioutil.ReadAll(tr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n \n \t\t\t// Convert GNU extensions to use PAX headers.\n@@ -156,31 +158,73 @@ loop:\n \t\t\t\textHdrs[paxLinkpath] = p.parseString(realname)\n \t\t\t}\n \t\t\tif p.err != nil {\n-\t\t\t\ttr.err = p.err\n-\t\t\t\treturn nil, tr.err\n+\t\t\t\treturn nil, p.err\n \t\t\t}\n \t\t\tcontinue loop // This is a meta header affecting the next header\n \t\tdefault:\n-\t\t\tmergePAX(hdr, extHdrs)\n+\t\t\t// The old GNU sparse format is handled here since it is technically\n+\t\t\t// just a regular file with additional attributes.\n \n-\t\t\t// Check for a PAX format sparse file\n-\t\t\tsp, err := tr.checkForGNUSparsePAXHeaders(hdr, extHdrs)\n-\t\t\tif err != nil {\n-\t\t\t\ttr.err = err\n+\t\t\tif err := mergePAX(hdr, extHdrs); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tif sp != nil {\n-\t\t\t\t// Current file is a PAX format GNU sparse file.\n-\t\t\t\t// Set the current file reader to a sparse file reader.\n-\t\t\t\ttr.curr, tr.err = newSparseFileReader(tr.curr, sp, hdr.Size)\n-\t\t\t\tif tr.err != nil {\n-\t\t\t\t\treturn nil, tr.err\n-\t\t\t\t}\n+\n+\t\t\t// The extended headers may have updated the size.\n+\t\t\t// Thus, setup the regFileReader again after merging PAX headers.\n+\t\t\tif err := tr.handleRegularFile(hdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\t// Sparse formats rely on being able to read from the logical data\n+\t\t\t// section; there must be a preceding call to handleRegularFile.\n+\t\t\tif err := tr.handleSparseFile(hdr, rawHdr, extHdrs); err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tbreak loop // This is a file, so stop\n+\t\t\treturn hdr, nil // This is a file, so stop\n+\t\t}\n+\t}\n+}\n+\n+// handleRegularFile sets up the current file reader and padding such that it\n+// can only read the following logical data section. It will properly handle\n+// special headers that contain no data section.\n+func (tr *Reader) handleRegularFile(hdr *Header) error {\n+\tnb := hdr.Size\n+\tif isHeaderOnlyType(hdr.Typeflag) {\n+\t\tnb = 0\n+\t}\n+\tif nb < 0 {\n+\t\treturn ErrHeader\n+\t}\n+\n+\ttr.pad = -nb & (blockSize - 1) // blockSize is a power of two\n+\ttr.curr = &regFileReader{r: tr.r, nb: nb}\n+\treturn nil\n+}\n+\n+// handleSparseFile checks if the current file is a sparse format of any type\n+// and sets the curr reader appropriately.\n+func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block, extHdrs map[string]string) error {\n+\tvar sp []sparseEntry\n+\tvar err error\n+\tif hdr.Typeflag == TypeGNUSparse {\n+\t\tsp, err = tr.readOldGNUSparseMap(hdr, rawHdr)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\tsp, err = tr.checkForGNUSparsePAXHeaders(hdr, extHdrs)\n+\t\tif err != nil {\n+\t\t\treturn err\n \t\t}\n \t}\n-\treturn hdr, nil\n+\n+\t// If sp is non-nil, then this is a sparse file.\n+\t// Note that it is possible for len(sp) to be zero.\n+\tif sp != nil {\n+\t\ttr.curr, err = newSparseFileReader(tr.curr, sp, hdr.Size)\n+\t}\n+\treturn err\n }\n \n // checkForGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers. If they are found, then\n@@ -219,13 +263,13 @@ func (tr *Reader) checkForGNUSparsePAXHeaders(hdr *Header, headers map[string]st\n \t\thdr.Name = sparseName\n \t}\n \tif sparseSizeOk {\n-\t\trealSize, err := strconv.ParseInt(sparseSize, 10, 0)\n+\t\trealSize, err := strconv.ParseInt(sparseSize, 10, 64)\n \t\tif err != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n \t\thdr.Size = realSize\n \t} else if sparseRealSizeOk {\n-\t\trealSize, err := strconv.ParseInt(sparseRealSize, 10, 0)\n+\t\trealSize, err := strconv.ParseInt(sparseRealSize, 10, 64)\n \t\tif err != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n@@ -249,53 +293,32 @@ func (tr *Reader) checkForGNUSparsePAXHeaders(hdr *Header, headers map[string]st\n // in the header struct overwrite those found in the header\n // struct with higher precision or longer values. Esp. useful\n // for name and linkname fields.\n-func mergePAX(hdr *Header, headers map[string]string) error {\n+func mergePAX(hdr *Header, headers map[string]string) (err error) {\n+\tvar id64 int64\n \tfor k, v := range headers {\n \t\tswitch k {\n \t\tcase paxPath:\n \t\t\thdr.Name = v\n \t\tcase paxLinkpath:\n \t\t\thdr.Linkname = v\n-\t\tcase paxGname:\n-\t\t\thdr.Gname = v\n \t\tcase paxUname:\n \t\t\thdr.Uname = v\n+\t\tcase paxGname:\n+\t\t\thdr.Gname = v\n \t\tcase paxUid:\n-\t\t\tuid, err := strconv.ParseInt(v, 10, 0)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.Uid = int(uid)\n+\t\t\tid64, err = strconv.ParseInt(v, 10, 64)\n+\t\t\thdr.Uid = int(id64) // Integer overflow possible\n \t\tcase paxGid:\n-\t\t\tgid, err := strconv.ParseInt(v, 10, 0)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.Gid = int(gid)\n+\t\t\tid64, err = strconv.ParseInt(v, 10, 64)\n+\t\t\thdr.Gid = int(id64) // Integer overflow possible\n \t\tcase paxAtime:\n-\t\t\tt, err := parsePAXTime(v)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.AccessTime = t\n+\t\t\thdr.AccessTime, err = parsePAXTime(v)\n \t\tcase paxMtime:\n-\t\t\tt, err := parsePAXTime(v)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.ModTime = t\n+\t\t\thdr.ModTime, err = parsePAXTime(v)\n \t\tcase paxCtime:\n-\t\t\tt, err := parsePAXTime(v)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.ChangeTime = t\n+\t\t\thdr.ChangeTime, err = parsePAXTime(v)\n \t\tcase paxSize:\n-\t\t\tsize, err := strconv.ParseInt(v, 10, 0)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\thdr.Size = size\n+\t\t\thdr.Size, err = strconv.ParseInt(v, 10, 64)\n \t\tdefault:\n \t\t\tif strings.HasPrefix(k, paxXattr) {\n \t\t\t\tif hdr.Xattrs == nil {\n@@ -304,44 +327,11 @@ func mergePAX(hdr *Header, headers map[string]string) error {\n \t\t\t\thdr.Xattrs[k[len(paxXattr):]] = v\n \t\t\t}\n \t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// parsePAXTime takes a string of the form %d.%d as described in\n-// the PAX specification.\n-func parsePAXTime(t string) (time.Time, error) {\n-\tbuf := []byte(t)\n-\tpos := bytes.IndexByte(buf, '.')\n-\tvar seconds, nanoseconds int64\n-\tvar err error\n-\tif pos == -1 {\n-\t\tseconds, err = strconv.ParseInt(t, 10, 0)\n-\t\tif err != nil {\n-\t\t\treturn time.Time{}, err\n-\t\t}\n-\t} else {\n-\t\tseconds, err = strconv.ParseInt(string(buf[:pos]), 10, 0)\n-\t\tif err != nil {\n-\t\t\treturn time.Time{}, err\n-\t\t}\n-\t\tnanoBuf := string(buf[pos+1:])\n-\t\t// Pad as needed before converting to a decimal.\n-\t\t// For example .030 -> .030000000 -> 30000000 nanoseconds\n-\t\tif len(nanoBuf) < maxNanoSecondIntSize {\n-\t\t\t// Right pad\n-\t\t\tnanoBuf += strings.Repeat(\"0\", maxNanoSecondIntSize-len(nanoBuf))\n-\t\t} else if len(nanoBuf) > maxNanoSecondIntSize {\n-\t\t\t// Right truncate\n-\t\t\tnanoBuf = nanoBuf[:maxNanoSecondIntSize]\n-\t\t}\n-\t\tnanoseconds, err = strconv.ParseInt(nanoBuf, 10, 0)\n \t\tif err != nil {\n-\t\t\treturn time.Time{}, err\n+\t\t\treturn ErrHeader\n \t\t}\n \t}\n-\tts := time.Unix(seconds, nanoseconds)\n-\treturn ts, nil\n+\treturn nil\n }\n \n // parsePAX parses PAX headers.\n@@ -354,140 +344,41 @@ func parsePAX(r io.Reader) (map[string]string, error) {\n \tsbuf := string(buf)\n \n \t// For GNU PAX sparse format 0.0 support.\n-\t// This function transforms the sparse format 0.0 headers into sparse format 0.1 headers.\n-\tvar sparseMap bytes.Buffer\n+\t// This function transforms the sparse format 0.0 headers into format 0.1\n+\t// headers since 0.0 headers were not PAX compliant.\n+\tvar sparseMap []string\n \n-\theaders := make(map[string]string)\n-\t// Each record is constructed as\n-\t//     \"%d %s=%s\\n\", length, keyword, value\n+\textHdrs := make(map[string]string)\n \tfor len(sbuf) > 0 {\n \t\tkey, value, residual, err := parsePAXRecord(sbuf)\n \t\tif err != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n \t\tsbuf = residual\n \n-\t\tkeyStr := key\n-\t\tif keyStr == paxGNUSparseOffset || keyStr == paxGNUSparseNumBytes {\n-\t\t\t// GNU sparse format 0.0 special key. Write to sparseMap instead of using the headers map.\n-\t\t\tsparseMap.WriteString(value)\n-\t\t\tsparseMap.Write([]byte{','})\n-\t\t} else {\n-\t\t\t// Normal key. Set the value in the headers map.\n-\t\t\theaders[keyStr] = value\n-\t\t}\n-\t}\n-\tif sparseMap.Len() != 0 {\n-\t\t// Add sparse info to headers, chopping off the extra comma\n-\t\tsparseMap.Truncate(sparseMap.Len() - 1)\n-\t\theaders[paxGNUSparseMap] = sparseMap.String()\n-\t}\n-\treturn headers, nil\n-}\n-\n-// parsePAXRecord parses the input PAX record string into a key-value pair.\n-// If parsing is successful, it will slice off the currently read record and\n-// return the remainder as r.\n-//\n-// A PAX record is of the following form:\n-//\t\"%d %s=%s\\n\" % (size, key, value)\n-func parsePAXRecord(s string) (k, v, r string, err error) {\n-\t// The size field ends at the first space.\n-\tsp := strings.IndexByte(s, ' ')\n-\tif sp == -1 {\n-\t\treturn \"\", \"\", s, ErrHeader\n-\t}\n-\n-\t// Parse the first token as a decimal integer.\n-\tn, perr := strconv.ParseInt(s[:sp], 10, 0) // Intentionally parse as native int\n-\tif perr != nil || n < 5 || int64(len(s)) < n {\n-\t\treturn \"\", \"\", s, ErrHeader\n-\t}\n-\n-\t// Extract everything between the space and the final newline.\n-\trec, nl, rem := s[sp+1:n-1], s[n-1:n], s[n:]\n-\tif nl != \"\\n\" {\n-\t\treturn \"\", \"\", s, ErrHeader\n-\t}\n-\n-\t// The first equals separates the key from the value.\n-\teq := strings.IndexByte(rec, '=')\n-\tif eq == -1 {\n-\t\treturn \"\", \"\", s, ErrHeader\n-\t}\n-\treturn rec[:eq], rec[eq+1:], rem, nil\n-}\n-\n-// parseString parses bytes as a NUL-terminated C-style string.\n-// If a NUL byte is not found then the whole slice is returned as a string.\n-func (*parser) parseString(b []byte) string {\n-\tn := 0\n-\tfor n < len(b) && b[n] != 0 {\n-\t\tn++\n-\t}\n-\treturn string(b[0:n])\n-}\n-\n-// parseNumeric parses the input as being encoded in either base-256 or octal.\n-// This function may return negative numbers.\n-// If parsing fails or an integer overflow occurs, err will be set.\n-func (p *parser) parseNumeric(b []byte) int64 {\n-\t// Check for base-256 (binary) format first.\n-\t// If the first bit is set, then all following bits constitute a two's\n-\t// complement encoded number in big-endian byte order.\n-\tif len(b) > 0 && b[0]&0x80 != 0 {\n-\t\t// Handling negative numbers relies on the following identity:\n-\t\t//\t-a-1 == ^a\n-\t\t//\n-\t\t// If the number is negative, we use an inversion mask to invert the\n-\t\t// data bytes and treat the value as an unsigned number.\n-\t\tvar inv byte // 0x00 if positive or zero, 0xff if negative\n-\t\tif b[0]&0x40 != 0 {\n-\t\t\tinv = 0xff\n-\t\t}\n-\n-\t\tvar x uint64\n-\t\tfor i, c := range b {\n-\t\t\tc ^= inv // Inverts c only if inv is 0xff, otherwise does nothing\n-\t\t\tif i == 0 {\n-\t\t\t\tc &= 0x7f // Ignore signal bit in first byte\n+\t\tswitch key {\n+\t\tcase paxGNUSparseOffset, paxGNUSparseNumBytes:\n+\t\t\t// Validate sparse header order and value.\n+\t\t\tif (len(sparseMap)%2 == 0 && key != paxGNUSparseOffset) ||\n+\t\t\t\t(len(sparseMap)%2 == 1 && key != paxGNUSparseNumBytes) ||\n+\t\t\t\tstrings.Contains(value, \",\") {\n+\t\t\t\treturn nil, ErrHeader\n \t\t\t}\n-\t\t\tif (x >> 56) > 0 {\n-\t\t\t\tp.err = ErrHeader // Integer overflow\n-\t\t\t\treturn 0\n+\t\t\tsparseMap = append(sparseMap, value)\n+\t\tdefault:\n+\t\t\t// According to PAX specification, a value is stored only if it is\n+\t\t\t// non-empty. Otherwise, the key is deleted.\n+\t\t\tif len(value) > 0 {\n+\t\t\t\textHdrs[key] = value\n+\t\t\t} else {\n+\t\t\t\tdelete(extHdrs, key)\n \t\t\t}\n-\t\t\tx = x<<8 | uint64(c)\n-\t\t}\n-\t\tif (x >> 63) > 0 {\n-\t\t\tp.err = ErrHeader // Integer overflow\n-\t\t\treturn 0\n \t\t}\n-\t\tif inv == 0xff {\n-\t\t\treturn ^int64(x)\n-\t\t}\n-\t\treturn int64(x)\n-\t}\n-\n-\t// Normal case is base-8 (octal) format.\n-\treturn p.parseOctal(b)\n-}\n-\n-func (p *parser) parseOctal(b []byte) int64 {\n-\t// Because unused fields are filled with NULs, we need\n-\t// to skip leading NULs. Fields may also be padded with\n-\t// spaces or NULs.\n-\t// So we remove leading and trailing NULs and spaces to\n-\t// be sure.\n-\tb = bytes.Trim(b, \" \\x00\")\n-\n-\tif len(b) == 0 {\n-\t\treturn 0\n \t}\n-\tx, perr := strconv.ParseUint(p.parseString(b), 8, 64)\n-\tif perr != nil {\n-\t\tp.err = ErrHeader\n+\tif len(sparseMap) > 0 {\n+\t\textHdrs[paxGNUSparseMap] = strings.Join(sparseMap, \",\")\n \t}\n-\treturn int64(x)\n+\treturn extHdrs, nil\n }\n \n // skipUnread skips any unread bytes in the existing file entry, as well as any\n@@ -516,51 +407,46 @@ func (tr *Reader) skipUnread() error {\n \t\t\t// Seek seems supported, so perform the real Seek.\n \t\t\tpos2, err := sr.Seek(dataSkip-1, io.SeekCurrent)\n \t\t\tif err != nil {\n-\t\t\t\ttr.err = err\n-\t\t\t\treturn tr.err\n+\t\t\t\treturn err\n \t\t\t}\n \t\t\tseekSkipped = pos2 - pos1\n \t\t}\n \t}\n \n-\tvar copySkipped int64 // Number of bytes skipped via CopyN\n-\tcopySkipped, tr.err = io.CopyN(ioutil.Discard, tr.r, totalSkip-seekSkipped)\n-\tif tr.err == io.EOF && seekSkipped+copySkipped < dataSkip {\n-\t\ttr.err = io.ErrUnexpectedEOF\n+\tcopySkipped, err := io.CopyN(ioutil.Discard, tr.r, totalSkip-seekSkipped)\n+\tif err == io.EOF && seekSkipped+copySkipped < dataSkip {\n+\t\terr = io.ErrUnexpectedEOF\n \t}\n-\treturn tr.err\n+\treturn err\n }\n \n // readHeader reads the next block header and assumes that the underlying reader\n-// is already aligned to a block boundary.\n+// is already aligned to a block boundary. It returns the raw block of the\n+// header in case further processing is required.\n //\n // The err will be set to io.EOF only when one of the following occurs:\n //\t* Exactly 0 bytes are read and EOF is hit.\n //\t* Exactly 1 block of zeros is read and EOF is hit.\n //\t* At least 2 blocks of zeros are read.\n-func (tr *Reader) readHeader() *Header {\n-\tif _, tr.err = io.ReadFull(tr.r, tr.blk[:]); tr.err != nil {\n-\t\treturn nil // io.EOF is okay here\n-\t}\n-\n+func (tr *Reader) readHeader() (*Header, *block, error) {\n \t// Two blocks of zero bytes marks the end of the archive.\n+\tif _, err := io.ReadFull(tr.r, tr.blk[:]); err != nil {\n+\t\treturn nil, nil, err // EOF is okay here; exactly 0 bytes read\n+\t}\n \tif bytes.Equal(tr.blk[:], zeroBlock[:]) {\n-\t\tif _, tr.err = io.ReadFull(tr.r, tr.blk[:]); tr.err != nil {\n-\t\t\treturn nil // io.EOF is okay here\n+\t\tif _, err := io.ReadFull(tr.r, tr.blk[:]); err != nil {\n+\t\t\treturn nil, nil, err // EOF is okay here; exactly 1 block of zeros read\n \t\t}\n \t\tif bytes.Equal(tr.blk[:], zeroBlock[:]) {\n-\t\t\ttr.err = io.EOF\n-\t\t} else {\n-\t\t\ttr.err = ErrHeader // zero block and then non-zero block\n+\t\t\treturn nil, nil, io.EOF // normal EOF; exactly 2 block of zeros read\n \t\t}\n-\t\treturn nil\n+\t\treturn nil, nil, ErrHeader // Zero block and then non-zero block\n \t}\n \n \t// Verify the header matches a known format.\n \tformat := tr.blk.GetFormat()\n \tif format == formatUnknown {\n-\t\ttr.err = ErrHeader\n-\t\treturn nil\n+\t\treturn nil, nil, ErrHeader\n \t}\n \n \tvar p parser\n@@ -577,6 +463,26 @@ func (tr *Reader) readHeader() *Header {\n \thdr.Typeflag = v7.TypeFlag()[0]\n \thdr.Linkname = p.parseString(v7.LinkName())\n \n+\t// The atime and ctime fields are often left unused. Some versions of Go\n+\t// had a bug in the tar.Writer where it would output an invalid tar file\n+\t// in certain rare situations because the logic incorrectly believed that\n+\t// the old GNU format had a prefix field. This is wrong and leads to\n+\t// an outputted file that actually mangles the atime and ctime fields.\n+\t//\n+\t// In order to continue reading tar files created by a buggy writer, we\n+\t// try to parse the atime and ctime fields, but just return the zero value\n+\t// of time.Time when we cannot parse them.\n+\t//\n+\t// See https://golang.org/issues/12594\n+\ttryParseTime := func(b []byte) time.Time {\n+\t\tvar p parser\n+\t\tn := p.parseNumeric(b)\n+\t\tif b[0] != 0x00 && p.err == nil {\n+\t\t\treturn time.Unix(n, 0)\n+\t\t}\n+\t\treturn time.Time{}\n+\t}\n+\n \t// Unpack format specific fields.\n \tif format > formatV7 {\n \t\tustar := tr.blk.USTAR()\n@@ -589,107 +495,76 @@ func (tr *Reader) readHeader() *Header {\n \n \t\tvar prefix string\n \t\tswitch format {\n-\t\tcase formatUSTAR, formatGNU:\n-\t\t\t// TODO(dsnet): Do not use the prefix field for the GNU format!\n-\t\t\t// See golang.org/issues/12594\n+\t\tcase formatUSTAR:\n \t\t\tustar := tr.blk.USTAR()\n \t\t\tprefix = p.parseString(ustar.Prefix())\n \t\tcase formatSTAR:\n \t\t\tstar := tr.blk.STAR()\n \t\t\tprefix = p.parseString(star.Prefix())\n \t\t\thdr.AccessTime = time.Unix(p.parseNumeric(star.AccessTime()), 0)\n \t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(star.ChangeTime()), 0)\n+\t\tcase formatGNU:\n+\t\t\tgnu := tr.blk.GNU()\n+\t\t\thdr.AccessTime = tryParseTime(gnu.AccessTime())\n+\t\t\thdr.ChangeTime = tryParseTime(gnu.ChangeTime())\n \t\t}\n \t\tif len(prefix) > 0 {\n \t\t\thdr.Name = prefix + \"/\" + hdr.Name\n \t\t}\n \t}\n+\treturn hdr, &tr.blk, p.err\n+}\n \n-\tnb := hdr.Size\n-\tif isHeaderOnlyType(hdr.Typeflag) {\n-\t\tnb = 0\n-\t}\n-\tif nb < 0 {\n-\t\ttr.err = ErrHeader\n-\t\treturn nil\n-\t}\n-\n-\t// Set the current file reader.\n-\ttr.pad = -nb & (blockSize - 1) // blockSize is a power of two\n-\ttr.curr = &regFileReader{r: tr.r, nb: nb}\n-\n-\t// Check for old GNU sparse format entry.\n-\tif hdr.Typeflag == TypeGNUSparse {\n-\t\t// Get the real size of the file.\n-\t\thdr.Size = p.parseNumeric(tr.blk.GNU().RealSize())\n-\t\tif p.err != nil {\n-\t\t\ttr.err = p.err\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\t// Read the sparse map.\n-\t\tsp := tr.readOldGNUSparseMap(&tr.blk)\n-\t\tif tr.err != nil {\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\t// Current file is a GNU sparse file. Update the current file reader.\n-\t\ttr.curr, tr.err = newSparseFileReader(tr.curr, sp, hdr.Size)\n-\t\tif tr.err != nil {\n-\t\t\treturn nil\n-\t\t}\n+// readOldGNUSparseMap reads the sparse map from the old GNU sparse format.\n+// The sparse map is stored in the tar header if it's small enough.\n+// If it's larger than four entries, then one or more extension headers are used\n+// to store the rest of the sparse map.\n+//\n+// The Header.Size does not reflect the size of any extended headers used.\n+// Thus, this function will read from the raw io.Reader to fetch extra headers.\n+// This method mutates blk in the process.\n+func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) ([]sparseEntry, error) {\n+\t// Make sure that the input format is GNU.\n+\t// Unfortunately, the STAR format also has a sparse header format that uses\n+\t// the same type flag but has a completely different layout.\n+\tif blk.GetFormat() != formatGNU {\n+\t\treturn nil, ErrHeader\n \t}\n \n+\tvar p parser\n+\thdr.Size = p.parseNumeric(blk.GNU().RealSize())\n \tif p.err != nil {\n-\t\ttr.err = p.err\n-\t\treturn nil\n+\t\treturn nil, p.err\n \t}\n-\n-\treturn hdr\n-}\n-\n-// readOldGNUSparseMap reads the sparse map as stored in the old GNU sparse format.\n-// The sparse map is stored in the tar header if it's small enough. If it's larger than four entries,\n-// then one or more extension headers are used to store the rest of the sparse map.\n-func (tr *Reader) readOldGNUSparseMap(blk *block) []sparseEntry {\n-\tvar p parser\n \tvar s sparseArray = blk.GNU().Sparse()\n \tvar sp = make([]sparseEntry, 0, s.MaxEntries())\n-\tfor i := 0; i < s.MaxEntries(); i++ {\n-\t\toffset := p.parseOctal(s.Entry(i).Offset())\n-\t\tnumBytes := p.parseOctal(s.Entry(i).NumBytes())\n-\t\tif p.err != nil {\n-\t\t\ttr.err = p.err\n-\t\t\treturn nil\n-\t\t}\n-\t\tif offset == 0 && numBytes == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n-\t}\n-\n-\tfor s.IsExtended()[0] > 0 {\n-\t\t// There are more entries. Read an extension header and parse its entries.\n-\t\tvar blk block\n-\t\tif _, tr.err = io.ReadFull(tr.r, blk[:]); tr.err != nil {\n-\t\t\treturn nil\n-\t\t}\n-\t\ts = blk.Sparse()\n-\n+\tfor {\n \t\tfor i := 0; i < s.MaxEntries(); i++ {\n-\t\t\toffset := p.parseOctal(s.Entry(i).Offset())\n-\t\t\tnumBytes := p.parseOctal(s.Entry(i).NumBytes())\n-\t\t\tif p.err != nil {\n-\t\t\t\ttr.err = p.err\n-\t\t\t\treturn nil\n+\t\t\t// This termination condition is identical to GNU and BSD tar.\n+\t\t\tif s.Entry(i).Offset()[0] == 0x00 {\n+\t\t\t\tbreak // Don't return, need to process extended headers (even if empty)\n \t\t\t}\n-\t\t\tif offset == 0 && numBytes == 0 {\n-\t\t\t\tbreak\n+\t\t\toffset := p.parseNumeric(s.Entry(i).Offset())\n+\t\t\tnumBytes := p.parseNumeric(s.Entry(i).NumBytes())\n+\t\t\tif p.err != nil {\n+\t\t\t\treturn nil, p.err\n \t\t\t}\n \t\t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n \t\t}\n+\n+\t\tif s.IsExtended()[0] > 0 {\n+\t\t\t// There are more entries. Read an extension header and parse its entries.\n+\t\t\tif _, err := io.ReadFull(tr.r, blk[:]); err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ts = blk.Sparse()\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn sp, nil // Done\n \t}\n-\treturn sp\n }\n \n // readGNUSparseMap1x0 reads the sparse map as stored in GNU's PAX sparse format\n@@ -817,19 +692,19 @@ func (tr *Reader) numBytes() int64 {\n // Calling Read on special types like TypeLink, TypeSymLink, TypeChar,\n // TypeBlock, TypeDir, and TypeFifo returns 0, io.EOF regardless of what\n // the Header.Size claims.\n-func (tr *Reader) Read(b []byte) (n int, err error) {\n+func (tr *Reader) Read(b []byte) (int, error) {\n \tif tr.err != nil {\n \t\treturn 0, tr.err\n \t}\n \tif tr.curr == nil {\n \t\treturn 0, io.EOF\n \t}\n \n-\tn, err = tr.curr.Read(b)\n+\tn, err := tr.curr.Read(b)\n \tif err != nil && err != io.EOF {\n \t\ttr.err = err\n \t}\n-\treturn\n+\treturn n, err\n }\n \n func (rfr *regFileReader) Read(b []byte) (n int, err error) {"}, {"sha": "338686836b6337381bd02ecf0d0cc453594fbcc5", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 372, "deletions": 401, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -18,17 +18,15 @@ import (\n \t\"time\"\n )\n \n-type untarTest struct {\n-\tfile    string    // Test input file\n-\theaders []*Header // Expected output headers\n-\tchksums []string  // MD5 checksum of files, leave as nil if not checked\n-\terr     error     // Expected error to occur\n-}\n-\n-var gnuTarTest = &untarTest{\n-\tfile: \"testdata/gnu.tar\",\n-\theaders: []*Header{\n-\t\t{\n+func TestReader(t *testing.T) {\n+\tvectors := []struct {\n+\t\tfile    string    // Test input file\n+\t\theaders []*Header // Expected output headers\n+\t\tchksums []string  // MD5 checksum of files, leave as nil if not checked\n+\t\terr     error     // Expected error to occur\n+\t}{{\n+\t\tfile: \"testdata/gnu.tar\",\n+\t\theaders: []*Header{{\n \t\t\tName:     \"small.txt\",\n \t\t\tMode:     0640,\n \t\t\tUid:      73025,\n@@ -38,8 +36,7 @@ var gnuTarTest = &untarTest{\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n-\t\t},\n-\t\t{\n+\t\t}, {\n \t\t\tName:     \"small2.txt\",\n \t\t\tMode:     0640,\n \t\t\tUid:      73025,\n@@ -49,18 +46,14 @@ var gnuTarTest = &untarTest{\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n+\t\t}},\n+\t\tchksums: []string{\n+\t\t\t\"e38b27eaccb4391bdec553a7f3ae6b2f\",\n+\t\t\t\"c65bd2e50a56a2138bf1716f2fd56fe9\",\n \t\t},\n-\t},\n-\tchksums: []string{\n-\t\t\"e38b27eaccb4391bdec553a7f3ae6b2f\",\n-\t\t\"c65bd2e50a56a2138bf1716f2fd56fe9\",\n-\t},\n-}\n-\n-var sparseTarTest = &untarTest{\n-\tfile: \"testdata/sparse-formats.tar\",\n-\theaders: []*Header{\n-\t\t{\n+\t}, {\n+\t\tfile: \"testdata/sparse-formats.tar\",\n+\t\theaders: []*Header{{\n \t\t\tName:     \"sparse-gnu\",\n \t\t\tMode:     420,\n \t\t\tUid:      1000,\n@@ -73,8 +66,7 @@ var sparseTarTest = &untarTest{\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n-\t\t},\n-\t\t{\n+\t\t}, {\n \t\t\tName:     \"sparse-posix-0.0\",\n \t\t\tMode:     420,\n \t\t\tUid:      1000,\n@@ -87,8 +79,7 @@ var sparseTarTest = &untarTest{\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n-\t\t},\n-\t\t{\n+\t\t}, {\n \t\t\tName:     \"sparse-posix-0.1\",\n \t\t\tMode:     420,\n \t\t\tUid:      1000,\n@@ -101,8 +92,7 @@ var sparseTarTest = &untarTest{\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n-\t\t},\n-\t\t{\n+\t\t}, {\n \t\t\tName:     \"sparse-posix-1.0\",\n \t\t\tMode:     420,\n \t\t\tUid:      1000,\n@@ -115,8 +105,7 @@ var sparseTarTest = &untarTest{\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n-\t\t},\n-\t\t{\n+\t\t}, {\n \t\t\tName:     \"end\",\n \t\t\tMode:     420,\n \t\t\tUid:      1000,\n@@ -129,209 +118,237 @@ var sparseTarTest = &untarTest{\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t}},\n+\t\tchksums: []string{\n+\t\t\t\"6f53234398c2449fe67c1812d993012f\",\n+\t\t\t\"6f53234398c2449fe67c1812d993012f\",\n+\t\t\t\"6f53234398c2449fe67c1812d993012f\",\n+\t\t\t\"6f53234398c2449fe67c1812d993012f\",\n+\t\t\t\"b0061974914468de549a2af8ced10316\",\n \t\t},\n-\t},\n-\tchksums: []string{\n-\t\t\"6f53234398c2449fe67c1812d993012f\",\n-\t\t\"6f53234398c2449fe67c1812d993012f\",\n-\t\t\"6f53234398c2449fe67c1812d993012f\",\n-\t\t\"6f53234398c2449fe67c1812d993012f\",\n-\t\t\"b0061974914468de549a2af8ced10316\",\n-\t},\n-}\n-\n-var untarTests = []*untarTest{\n-\tgnuTarTest,\n-\tsparseTarTest,\n-\t{\n+\t}, {\n \t\tfile: \"testdata/star.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:       \"small.txt\",\n-\t\t\t\tMode:       0640,\n-\t\t\t\tUid:        73025,\n-\t\t\t\tGid:        5000,\n-\t\t\t\tSize:       5,\n-\t\t\t\tModTime:    time.Unix(1244592783, 0),\n-\t\t\t\tTypeflag:   '0',\n-\t\t\t\tUname:      \"dsymonds\",\n-\t\t\t\tGname:      \"eng\",\n-\t\t\t\tAccessTime: time.Unix(1244592783, 0),\n-\t\t\t\tChangeTime: time.Unix(1244592783, 0),\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tName:       \"small2.txt\",\n-\t\t\t\tMode:       0640,\n-\t\t\t\tUid:        73025,\n-\t\t\t\tGid:        5000,\n-\t\t\t\tSize:       11,\n-\t\t\t\tModTime:    time.Unix(1244592783, 0),\n-\t\t\t\tTypeflag:   '0',\n-\t\t\t\tUname:      \"dsymonds\",\n-\t\t\t\tGname:      \"eng\",\n-\t\t\t\tAccessTime: time.Unix(1244592783, 0),\n-\t\t\t\tChangeTime: time.Unix(1244592783, 0),\n-\t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\theaders: []*Header{{\n+\t\t\tName:       \"small.txt\",\n+\t\t\tMode:       0640,\n+\t\t\tUid:        73025,\n+\t\t\tGid:        5000,\n+\t\t\tSize:       5,\n+\t\t\tModTime:    time.Unix(1244592783, 0),\n+\t\t\tTypeflag:   '0',\n+\t\t\tUname:      \"dsymonds\",\n+\t\t\tGname:      \"eng\",\n+\t\t\tAccessTime: time.Unix(1244592783, 0),\n+\t\t\tChangeTime: time.Unix(1244592783, 0),\n+\t\t}, {\n+\t\t\tName:       \"small2.txt\",\n+\t\t\tMode:       0640,\n+\t\t\tUid:        73025,\n+\t\t\tGid:        5000,\n+\t\t\tSize:       11,\n+\t\t\tModTime:    time.Unix(1244592783, 0),\n+\t\t\tTypeflag:   '0',\n+\t\t\tUname:      \"dsymonds\",\n+\t\t\tGname:      \"eng\",\n+\t\t\tAccessTime: time.Unix(1244592783, 0),\n+\t\t\tChangeTime: time.Unix(1244592783, 0),\n+\t\t}},\n+\t}, {\n \t\tfile: \"testdata/v7.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:     \"small.txt\",\n-\t\t\t\tMode:     0444,\n-\t\t\t\tUid:      73025,\n-\t\t\t\tGid:      5000,\n-\t\t\t\tSize:     5,\n-\t\t\t\tModTime:  time.Unix(1244593104, 0),\n-\t\t\t\tTypeflag: '\\x00',\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tName:     \"small2.txt\",\n-\t\t\t\tMode:     0444,\n-\t\t\t\tUid:      73025,\n-\t\t\t\tGid:      5000,\n-\t\t\t\tSize:     11,\n-\t\t\t\tModTime:  time.Unix(1244593104, 0),\n-\t\t\t\tTypeflag: '\\x00',\n-\t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"small.txt\",\n+\t\t\tMode:     0444,\n+\t\t\tUid:      73025,\n+\t\t\tGid:      5000,\n+\t\t\tSize:     5,\n+\t\t\tModTime:  time.Unix(1244593104, 0),\n+\t\t\tTypeflag: '\\x00',\n+\t\t}, {\n+\t\t\tName:     \"small2.txt\",\n+\t\t\tMode:     0444,\n+\t\t\tUid:      73025,\n+\t\t\tGid:      5000,\n+\t\t\tSize:     11,\n+\t\t\tModTime:  time.Unix(1244593104, 0),\n+\t\t\tTypeflag: '\\x00',\n+\t\t}},\n+\t}, {\n \t\tfile: \"testdata/pax.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:       \"a/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n-\t\t\t\tMode:       0664,\n-\t\t\t\tUid:        1000,\n-\t\t\t\tGid:        1000,\n-\t\t\t\tUname:      \"shane\",\n-\t\t\t\tGname:      \"shane\",\n-\t\t\t\tSize:       7,\n-\t\t\t\tModTime:    time.Unix(1350244992, 23960108),\n-\t\t\t\tChangeTime: time.Unix(1350244992, 23960108),\n-\t\t\t\tAccessTime: time.Unix(1350244992, 23960108),\n-\t\t\t\tTypeflag:   TypeReg,\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tName:       \"a/b\",\n-\t\t\t\tMode:       0777,\n-\t\t\t\tUid:        1000,\n-\t\t\t\tGid:        1000,\n-\t\t\t\tUname:      \"shane\",\n-\t\t\t\tGname:      \"shane\",\n-\t\t\t\tSize:       0,\n-\t\t\t\tModTime:    time.Unix(1350266320, 910238425),\n-\t\t\t\tChangeTime: time.Unix(1350266320, 910238425),\n-\t\t\t\tAccessTime: time.Unix(1350266320, 910238425),\n-\t\t\t\tTypeflag:   TypeSymlink,\n-\t\t\t\tLinkname:   \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n-\t\t\t},\n+\t\theaders: []*Header{{\n+\t\t\tName:       \"a/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n+\t\t\tMode:       0664,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        1000,\n+\t\t\tUname:      \"shane\",\n+\t\t\tGname:      \"shane\",\n+\t\t\tSize:       7,\n+\t\t\tModTime:    time.Unix(1350244992, 23960108),\n+\t\t\tChangeTime: time.Unix(1350244992, 23960108),\n+\t\t\tAccessTime: time.Unix(1350244992, 23960108),\n+\t\t\tTypeflag:   TypeReg,\n+\t\t}, {\n+\t\t\tName:       \"a/b\",\n+\t\t\tMode:       0777,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        1000,\n+\t\t\tUname:      \"shane\",\n+\t\t\tGname:      \"shane\",\n+\t\t\tSize:       0,\n+\t\t\tModTime:    time.Unix(1350266320, 910238425),\n+\t\t\tChangeTime: time.Unix(1350266320, 910238425),\n+\t\t\tAccessTime: time.Unix(1350266320, 910238425),\n+\t\t\tTypeflag:   TypeSymlink,\n+\t\t\tLinkname:   \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n+\t\t}},\n+\t}, {\n+\t\tfile: \"testdata/pax-bad-hdr-file.tar\",\n+\t\terr:  ErrHeader,\n+\t}, {\n+\t\tfile: \"testdata/pax-bad-mtime-file.tar\",\n+\t\terr:  ErrHeader,\n+\t}, {\n+\t\tfile: \"testdata/pax-pos-size-file.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"foo\",\n+\t\t\tMode:     0640,\n+\t\t\tUid:      319973,\n+\t\t\tGid:      5000,\n+\t\t\tSize:     999,\n+\t\t\tModTime:  time.Unix(1442282516, 0),\n+\t\t\tTypeflag: '0',\n+\t\t\tUname:    \"joetsai\",\n+\t\t\tGname:    \"eng\",\n+\t\t}},\n+\t\tchksums: []string{\n+\t\t\t\"0afb597b283fe61b5d4879669a350556\",\n \t\t},\n-\t},\n-\t{\n+\t}, {\n \t\tfile: \"testdata/nil-uid.tar\", // golang.org/issue/5290\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:     \"P1050238.JPG.log\",\n-\t\t\t\tMode:     0664,\n-\t\t\t\tUid:      0,\n-\t\t\t\tGid:      0,\n-\t\t\t\tSize:     14,\n-\t\t\t\tModTime:  time.Unix(1365454838, 0),\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t\tLinkname: \"\",\n-\t\t\t\tUname:    \"eyefi\",\n-\t\t\t\tGname:    \"eyefi\",\n-\t\t\t\tDevmajor: 0,\n-\t\t\t\tDevminor: 0,\n-\t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"P1050238.JPG.log\",\n+\t\t\tMode:     0664,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tSize:     14,\n+\t\t\tModTime:  time.Unix(1365454838, 0),\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tLinkname: \"\",\n+\t\t\tUname:    \"eyefi\",\n+\t\t\tGname:    \"eyefi\",\n+\t\t\tDevmajor: 0,\n+\t\t\tDevminor: 0,\n+\t\t}},\n+\t}, {\n \t\tfile: \"testdata/xattrs.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:       \"small.txt\",\n-\t\t\t\tMode:       0644,\n-\t\t\t\tUid:        1000,\n-\t\t\t\tGid:        10,\n-\t\t\t\tSize:       5,\n-\t\t\t\tModTime:    time.Unix(1386065770, 448252320),\n-\t\t\t\tTypeflag:   '0',\n-\t\t\t\tUname:      \"alex\",\n-\t\t\t\tGname:      \"wheel\",\n-\t\t\t\tAccessTime: time.Unix(1389782991, 419875220),\n-\t\t\t\tChangeTime: time.Unix(1389782956, 794414986),\n-\t\t\t\tXattrs: map[string]string{\n-\t\t\t\t\t\"user.key\":  \"value\",\n-\t\t\t\t\t\"user.key2\": \"value2\",\n-\t\t\t\t\t// Interestingly, selinux encodes the terminating null inside the xattr\n-\t\t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n-\t\t\t\t},\n+\t\theaders: []*Header{{\n+\t\t\tName:       \"small.txt\",\n+\t\t\tMode:       0644,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        10,\n+\t\t\tSize:       5,\n+\t\t\tModTime:    time.Unix(1386065770, 448252320),\n+\t\t\tTypeflag:   '0',\n+\t\t\tUname:      \"alex\",\n+\t\t\tGname:      \"wheel\",\n+\t\t\tAccessTime: time.Unix(1389782991, 419875220),\n+\t\t\tChangeTime: time.Unix(1389782956, 794414986),\n+\t\t\tXattrs: map[string]string{\n+\t\t\t\t\"user.key\":  \"value\",\n+\t\t\t\t\"user.key2\": \"value2\",\n+\t\t\t\t// Interestingly, selinux encodes the terminating null inside the xattr\n+\t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n-\t\t\t{\n-\t\t\t\tName:       \"small2.txt\",\n-\t\t\t\tMode:       0644,\n-\t\t\t\tUid:        1000,\n-\t\t\t\tGid:        10,\n-\t\t\t\tSize:       11,\n-\t\t\t\tModTime:    time.Unix(1386065770, 449252304),\n-\t\t\t\tTypeflag:   '0',\n-\t\t\t\tUname:      \"alex\",\n-\t\t\t\tGname:      \"wheel\",\n-\t\t\t\tAccessTime: time.Unix(1389782991, 419875220),\n-\t\t\t\tChangeTime: time.Unix(1386065770, 449252304),\n-\t\t\t\tXattrs: map[string]string{\n-\t\t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n-\t\t\t\t},\n+\t\t}, {\n+\t\t\tName:       \"small2.txt\",\n+\t\t\tMode:       0644,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        10,\n+\t\t\tSize:       11,\n+\t\t\tModTime:    time.Unix(1386065770, 449252304),\n+\t\t\tTypeflag:   '0',\n+\t\t\tUname:      \"alex\",\n+\t\t\tGname:      \"wheel\",\n+\t\t\tAccessTime: time.Unix(1389782991, 419875220),\n+\t\t\tChangeTime: time.Unix(1386065770, 449252304),\n+\t\t\tXattrs: map[string]string{\n+\t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\t}},\n+\t}, {\n \t\t// Matches the behavior of GNU, BSD, and STAR tar utilities.\n \t\tfile: \"testdata/gnu-multi-hdrs.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:     \"GNU2/GNU2/long-path-name\",\n-\t\t\t\tLinkname: \"GNU4/GNU4/long-linkpath-name\",\n-\t\t\t\tModTime:  time.Unix(0, 0),\n-\t\t\t\tTypeflag: '2',\n-\t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"GNU2/GNU2/long-path-name\",\n+\t\t\tLinkname: \"GNU4/GNU4/long-linkpath-name\",\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tTypeflag: '2',\n+\t\t}},\n+\t}, {\n+\t\t// GNU tar file with atime and ctime fields set.\n+\t\t// Created with the GNU tar v1.27.1.\n+\t\t//\ttar --incremental -S -cvf gnu-incremental.tar test2\n+\t\tfile: \"testdata/gnu-incremental.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:       \"test2/\",\n+\t\t\tMode:       16877,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        1000,\n+\t\t\tSize:       14,\n+\t\t\tModTime:    time.Unix(1441973427, 0),\n+\t\t\tTypeflag:   'D',\n+\t\t\tUname:      \"rawr\",\n+\t\t\tGname:      \"dsnet\",\n+\t\t\tAccessTime: time.Unix(1441974501, 0),\n+\t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t}, {\n+\t\t\tName:       \"test2/foo\",\n+\t\t\tMode:       33188,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        1000,\n+\t\t\tSize:       64,\n+\t\t\tModTime:    time.Unix(1441973363, 0),\n+\t\t\tTypeflag:   '0',\n+\t\t\tUname:      \"rawr\",\n+\t\t\tGname:      \"dsnet\",\n+\t\t\tAccessTime: time.Unix(1441974501, 0),\n+\t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t}, {\n+\t\t\tName:       \"test2/sparse\",\n+\t\t\tMode:       33188,\n+\t\t\tUid:        1000,\n+\t\t\tGid:        1000,\n+\t\t\tSize:       536870912,\n+\t\t\tModTime:    time.Unix(1441973427, 0),\n+\t\t\tTypeflag:   'S',\n+\t\t\tUname:      \"rawr\",\n+\t\t\tGname:      \"dsnet\",\n+\t\t\tAccessTime: time.Unix(1441991948, 0),\n+\t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t}},\n+\t}, {\n \t\t// Matches the behavior of GNU and BSD tar utilities.\n \t\tfile: \"testdata/pax-multi-hdrs.tar\",\n-\t\theaders: []*Header{\n-\t\t\t{\n-\t\t\t\tName:     \"bar\",\n-\t\t\t\tLinkname: \"PAX4/PAX4/long-linkpath-name\",\n-\t\t\t\tModTime:  time.Unix(0, 0),\n-\t\t\t\tTypeflag: '2',\n-\t\t\t},\n-\t\t},\n-\t},\n-\t{\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"bar\",\n+\t\t\tLinkname: \"PAX4/PAX4/long-linkpath-name\",\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tTypeflag: '2',\n+\t\t}},\n+\t}, {\n \t\tfile: \"testdata/neg-size.tar\",\n \t\terr:  ErrHeader,\n-\t},\n-\t{\n+\t}, {\n \t\tfile: \"testdata/issue10968.tar\",\n \t\terr:  ErrHeader,\n-\t},\n-\t{\n+\t}, {\n \t\tfile: \"testdata/issue11169.tar\",\n \t\terr:  ErrHeader,\n-\t},\n-\t{\n+\t}, {\n \t\tfile: \"testdata/issue12435.tar\",\n \t\terr:  ErrHeader,\n-\t},\n-}\n+\t}}\n \n-func TestReader(t *testing.T) {\n-\tfor i, v := range untarTests {\n+\tfor i, v := range vectors {\n \t\tf, err := os.Open(v.file)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"file %s, test %d: unexpected error: %v\", v.file, i, err)\n@@ -440,83 +457,8 @@ func TestPartialRead(t *testing.T) {\n \t}\n }\n \n-func TestParsePAXHeader(t *testing.T) {\n-\tpaxTests := [][3]string{\n-\t\t{\"a\", \"a=name\", \"10 a=name\\n\"}, // Test case involving multiple acceptable lengths\n-\t\t{\"a\", \"a=name\", \"9 a=name\\n\"},  // Test case involving multiple acceptable length\n-\t\t{\"mtime\", \"mtime=1350244992.023960108\", \"30 mtime=1350244992.023960108\\n\"}}\n-\tfor _, test := range paxTests {\n-\t\tkey, expected, raw := test[0], test[1], test[2]\n-\t\treader := bytes.NewReader([]byte(raw))\n-\t\theaders, err := parsePAX(reader)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"Couldn't parse correctly formatted headers: %v\", err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif strings.EqualFold(headers[key], expected) {\n-\t\t\tt.Errorf(\"mtime header incorrectly parsed: got %s, wanted %s\", headers[key], expected)\n-\t\t\tcontinue\n-\t\t}\n-\t\ttrailer := make([]byte, 100)\n-\t\tn, err := reader.Read(trailer)\n-\t\tif err != io.EOF || n != 0 {\n-\t\t\tt.Error(\"Buffer wasn't consumed\")\n-\t\t}\n-\t}\n-\tbadHeaderTests := [][]byte{\n-\t\t[]byte(\"3 somelongkey=\\n\"),\n-\t\t[]byte(\"50 tooshort=\\n\"),\n-\t}\n-\tfor _, test := range badHeaderTests {\n-\t\tif _, err := parsePAX(bytes.NewReader(test)); err != ErrHeader {\n-\t\t\tt.Fatal(\"Unexpected success when parsing bad header\")\n-\t\t}\n-\t}\n-}\n-\n-func TestParsePAXTime(t *testing.T) {\n-\t// Some valid PAX time values\n-\ttimestamps := map[string]time.Time{\n-\t\t\"1350244992.023960108\":  time.Unix(1350244992, 23960108), // The common case\n-\t\t\"1350244992.02396010\":   time.Unix(1350244992, 23960100), // Lower precision value\n-\t\t\"1350244992.0239601089\": time.Unix(1350244992, 23960108), // Higher precision value\n-\t\t\"1350244992\":            time.Unix(1350244992, 0),        // Low precision value\n-\t}\n-\tfor input, expected := range timestamps {\n-\t\tts, err := parsePAXTime(input)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tif !ts.Equal(expected) {\n-\t\t\tt.Fatalf(\"Time parsing failure %s %s\", ts, expected)\n-\t\t}\n-\t}\n-}\n-\n-func TestMergePAX(t *testing.T) {\n-\thdr := new(Header)\n-\t// Test a string, integer, and time based value.\n-\theaders := map[string]string{\n-\t\t\"path\":  \"a/b/c\",\n-\t\t\"uid\":   \"1000\",\n-\t\t\"mtime\": \"1350244992.023960108\",\n-\t}\n-\terr := mergePAX(hdr, headers)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\twant := &Header{\n-\t\tName:    \"a/b/c\",\n-\t\tUid:     1000,\n-\t\tModTime: time.Unix(1350244992, 23960108),\n-\t}\n-\tif !reflect.DeepEqual(hdr, want) {\n-\t\tt.Errorf(\"incorrect merge: got %+v, want %+v\", hdr, want)\n-\t}\n-}\n-\n func TestSparseFileReader(t *testing.T) {\n-\tvar vectors = []struct {\n+\tvectors := []struct {\n \t\trealSize   int64         // Real size of the output file\n \t\tsparseMap  []sparseEntry // Input sparse map\n \t\tsparseData string        // Input compact data\n@@ -639,9 +581,11 @@ func TestSparseFileReader(t *testing.T) {\n \t\tr := bytes.NewReader([]byte(v.sparseData))\n \t\trfr := &regFileReader{r: r, nb: int64(len(v.sparseData))}\n \n-\t\tvar sfr *sparseFileReader\n-\t\tvar err error\n-\t\tvar buf []byte\n+\t\tvar (\n+\t\t\tsfr *sparseFileReader\n+\t\t\terr error\n+\t\t\tbuf []byte\n+\t\t)\n \n \t\tsfr, err = newSparseFileReader(rfr, v.sparseMap, v.realSize)\n \t\tif err != nil {\n@@ -668,6 +612,64 @@ func TestSparseFileReader(t *testing.T) {\n \t}\n }\n \n+func TestReadOldGNUSparseMap(t *testing.T) {\n+\tconst (\n+\t\tt00 = \"00000000000\\x0000000000000\\x00\"\n+\t\tt11 = \"00000000001\\x0000000000001\\x00\"\n+\t\tt12 = \"00000000001\\x0000000000002\\x00\"\n+\t\tt21 = \"00000000002\\x0000000000001\\x00\"\n+\t)\n+\n+\tmkBlk := func(size, sp0, sp1, sp2, sp3, ext string, format int) *block {\n+\t\tvar blk block\n+\t\tcopy(blk.GNU().RealSize(), size)\n+\t\tcopy(blk.GNU().Sparse().Entry(0), sp0)\n+\t\tcopy(blk.GNU().Sparse().Entry(1), sp1)\n+\t\tcopy(blk.GNU().Sparse().Entry(2), sp2)\n+\t\tcopy(blk.GNU().Sparse().Entry(3), sp3)\n+\t\tcopy(blk.GNU().Sparse().IsExtended(), ext)\n+\t\tif format != formatUnknown {\n+\t\t\tblk.SetFormat(format)\n+\t\t}\n+\t\treturn &blk\n+\t}\n+\n+\tvectors := []struct {\n+\t\tdata   string        // Input data\n+\t\trawHdr *block        // Input raw header\n+\t\twant   []sparseEntry // Expected sparse entries to be outputted\n+\t\terr    error         // Expected error to be returned\n+\t}{\n+\t\t{\"\", mkBlk(\"\", \"\", \"\", \"\", \"\", \"\", formatUnknown), nil, ErrHeader},\n+\t\t{\"\", mkBlk(\"1234\", \"fewa\", \"\", \"\", \"\", \"\", formatGNU), nil, ErrHeader},\n+\t\t{\"\", mkBlk(\"0031\", \"\", \"\", \"\", \"\", \"\", formatGNU), nil, nil},\n+\t\t{\"\", mkBlk(\"1234\", t00, t11, \"\", \"\", \"\", formatGNU),\n+\t\t\t[]sparseEntry{{0, 0}, {1, 1}}, nil},\n+\t\t{\"\", mkBlk(\"1234\", t11, t12, t21, t11, \"\", formatGNU),\n+\t\t\t[]sparseEntry{{1, 1}, {1, 2}, {2, 1}, {1, 1}}, nil},\n+\t\t{\"\", mkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n+\t\t\t[]sparseEntry{}, io.ErrUnexpectedEOF},\n+\t\t{t11 + t11,\n+\t\t\tmkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n+\t\t\t[]sparseEntry{}, io.ErrUnexpectedEOF},\n+\t\t{t11 + t21 + strings.Repeat(\"\\x00\", 512),\n+\t\t\tmkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n+\t\t\t[]sparseEntry{{1, 1}, {1, 2}, {2, 1}, {1, 1}, {1, 1}, {2, 1}}, nil},\n+\t}\n+\n+\tfor i, v := range vectors {\n+\t\ttr := Reader{r: strings.NewReader(v.data)}\n+\t\thdr := new(Header)\n+\t\tgot, err := tr.readOldGNUSparseMap(hdr, v.rawHdr)\n+\t\tif !reflect.DeepEqual(got, v.want) && !(len(got) == 0 && len(v.want) == 0) {\n+\t\t\tt.Errorf(\"test %d, readOldGNUSparseMap(...): got %v, want %v\", i, got, v.want)\n+\t\t}\n+\t\tif err != v.err {\n+\t\t\tt.Errorf(\"test %d, unexpected error: got %v, want %v\", i, err, v.err)\n+\t\t}\n+\t}\n+}\n+\n func TestReadGNUSparseMap0x1(t *testing.T) {\n \tconst (\n \t\tmaxUint = ^uint(0)\n@@ -679,7 +681,7 @@ func TestReadGNUSparseMap0x1(t *testing.T) {\n \t\tbig3 = fmt.Sprintf(\"%d\", (int64(maxInt) / 3))\n \t)\n \n-\tvar vectors = []struct {\n+\tvectors := []struct {\n \t\textHdrs   map[string]string // Input data\n \t\tsparseMap []sparseEntry     // Expected sparse entries to be outputted\n \t\terr       error             // Expected errors that may be raised\n@@ -745,12 +747,12 @@ func TestReadGNUSparseMap0x1(t *testing.T) {\n }\n \n func TestReadGNUSparseMap1x0(t *testing.T) {\n-\tvar sp = []sparseEntry{{1, 2}, {3, 4}}\n+\tsp := []sparseEntry{{1, 2}, {3, 4}}\n \tfor i := 0; i < 98; i++ {\n \t\tsp = append(sp, sparseEntry{54321, 12345})\n \t}\n \n-\tvar vectors = []struct {\n+\tvectors := []struct {\n \t\tinput     string        // Input data\n \t\tsparseMap []sparseEntry // Expected sparse entries to be outputted\n \t\tcnt       int           // Expected number of bytes read\n@@ -825,8 +827,7 @@ func TestReadGNUSparseMap1x0(t *testing.T) {\n }\n \n func TestUninitializedRead(t *testing.T) {\n-\ttest := gnuTarTest\n-\tf, err := os.Open(test.file)\n+\tf, err := os.Open(\"testdata/gnu.tar\")\n \tif err != nil {\n \t\tt.Fatalf(\"Unexpected error: %v\", err)\n \t}\n@@ -868,7 +869,7 @@ func TestReadTruncation(t *testing.T) {\n \tdata2 += strings.Repeat(\"\\x00\", 10*512)\n \ttrash := strings.Repeat(\"garbage \", 64) // Exactly 512 bytes\n \n-\tvar vectors = []struct {\n+\tvectors := []struct {\n \t\tinput string // Input stream\n \t\tcnt   int    // Expected number of headers read\n \t\terr   error  // Expected error outcome\n@@ -904,8 +905,7 @@ func TestReadTruncation(t *testing.T) {\n \t\t{pax + trash[:1], 0, io.ErrUnexpectedEOF},\n \t\t{pax + trash[:511], 0, io.ErrUnexpectedEOF},\n \t\t{sparse[:511], 0, io.ErrUnexpectedEOF},\n-\t\t// TODO(dsnet): This should pass, but currently fails.\n-\t\t// {sparse[:512], 0, io.ErrUnexpectedEOF},\n+\t\t{sparse[:512], 0, io.ErrUnexpectedEOF},\n \t\t{sparse[:3584], 1, io.EOF},\n \t\t{sparse[:9200], 1, io.EOF}, // Terminate in padding of sparse header\n \t\t{sparse[:9216], 1, io.EOF},\n@@ -1002,124 +1002,95 @@ func TestReadHeaderOnly(t *testing.T) {\n \t\tt.Fatalf(\"len(hdrs): got %d, want %d\", len(hdrs), 16)\n \t}\n \tfor i := 0; i < 8; i++ {\n-\t\tvar hdr1, hdr2 = hdrs[i+0], hdrs[i+8]\n+\t\thdr1, hdr2 := hdrs[i+0], hdrs[i+8]\n \t\thdr1.Size, hdr2.Size = 0, 0\n \t\tif !reflect.DeepEqual(*hdr1, *hdr2) {\n \t\t\tt.Errorf(\"incorrect header:\\ngot  %+v\\nwant %+v\", *hdr1, *hdr2)\n \t\t}\n \t}\n }\n \n-func TestParsePAXRecord(t *testing.T) {\n-\tvar medName = strings.Repeat(\"CD\", 50)\n-\tvar longName = strings.Repeat(\"AB\", 100)\n-\n-\tvar vectors = []struct {\n-\t\tinput     string\n-\t\tresidual  string\n-\t\toutputKey string\n-\t\toutputVal string\n-\t\tok        bool\n-\t}{\n-\t\t{\"6 k=v\\n\\n\", \"\\n\", \"k\", \"v\", true},\n-\t\t{\"19 path=/etc/hosts\\n\", \"\", \"path\", \"/etc/hosts\", true},\n-\t\t{\"210 path=\" + longName + \"\\nabc\", \"abc\", \"path\", longName, true},\n-\t\t{\"110 path=\" + medName + \"\\n\", \"\", \"path\", medName, true},\n-\t\t{\"9 foo=ba\\n\", \"\", \"foo\", \"ba\", true},\n-\t\t{\"11 foo=bar\\n\\x00\", \"\\x00\", \"foo\", \"bar\", true},\n-\t\t{\"18 foo=b=\\nar=\\n==\\x00\\n\", \"\", \"foo\", \"b=\\nar=\\n==\\x00\", true},\n-\t\t{\"27 foo=hello9 foo=ba\\nworld\\n\", \"\", \"foo\", \"hello9 foo=ba\\nworld\", true},\n-\t\t{\"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\nmeow mix\", \"meow mix\", \"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", true},\n-\t\t{\"17 \\x00hello=\\x00world\\n\", \"\", \"\\x00hello\", \"\\x00world\", true},\n-\t\t{\"1 k=1\\n\", \"1 k=1\\n\", \"\", \"\", false},\n-\t\t{\"6 k~1\\n\", \"6 k~1\\n\", \"\", \"\", false},\n-\t\t{\"6_k=1\\n\", \"6_k=1\\n\", \"\", \"\", false},\n-\t\t{\"6 k=1 \", \"6 k=1 \", \"\", \"\", false},\n-\t\t{\"632 k=1\\n\", \"632 k=1\\n\", \"\", \"\", false},\n-\t\t{\"16 longkeyname=hahaha\\n\", \"16 longkeyname=hahaha\\n\", \"\", \"\", false},\n-\t\t{\"3 somelongkey=\\n\", \"3 somelongkey=\\n\", \"\", \"\", false},\n-\t\t{\"50 tooshort=\\n\", \"50 tooshort=\\n\", \"\", \"\", false},\n-\t}\n+func TestMergePAX(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   map[string]string\n+\t\twant *Header\n+\t\tok   bool\n+\t}{{\n+\t\tin: map[string]string{\n+\t\t\t\"path\":  \"a/b/c\",\n+\t\t\t\"uid\":   \"1000\",\n+\t\t\t\"mtime\": \"1350244992.023960108\",\n+\t\t},\n+\t\twant: &Header{\n+\t\t\tName:    \"a/b/c\",\n+\t\t\tUid:     1000,\n+\t\t\tModTime: time.Unix(1350244992, 23960108),\n+\t\t},\n+\t\tok: true,\n+\t}, {\n+\t\tin: map[string]string{\n+\t\t\t\"gid\": \"gtgergergersagersgers\",\n+\t\t},\n+\t}, {\n+\t\tin: map[string]string{\n+\t\t\t\"missing\":          \"missing\",\n+\t\t\t\"SCHILY.xattr.key\": \"value\",\n+\t\t},\n+\t\twant: &Header{\n+\t\t\tXattrs: map[string]string{\"key\": \"value\"},\n+\t\t},\n+\t\tok: true,\n+\t}}\n \n-\tfor _, v := range vectors {\n-\t\tkey, val, res, err := parsePAXRecord(v.input)\n-\t\tok := (err == nil)\n-\t\tif v.ok != ok {\n-\t\t\tif v.ok {\n-\t\t\t\tt.Errorf(\"parsePAXRecord(%q): got parsing failure, want success\", v.input)\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"parsePAXRecord(%q): got parsing success, want failure\", v.input)\n-\t\t\t}\n-\t\t}\n-\t\tif ok && (key != v.outputKey || val != v.outputVal) {\n-\t\t\tt.Errorf(\"parsePAXRecord(%q): got (%q: %q), want (%q: %q)\",\n-\t\t\t\tv.input, key, val, v.outputKey, v.outputVal)\n+\tfor i, v := range vectors {\n+\t\tgot := new(Header)\n+\t\terr := mergePAX(got, v.in)\n+\t\tif v.ok && !reflect.DeepEqual(*got, *v.want) {\n+\t\t\tt.Errorf(\"test %d, mergePAX(...):\\ngot  %+v\\nwant %+v\", i, *got, *v.want)\n \t\t}\n-\t\tif res != v.residual {\n-\t\t\tt.Errorf(\"parsePAXRecord(%q): got residual %q, want residual %q\",\n-\t\t\t\tv.input, res, v.residual)\n+\t\tif ok := err == nil; ok != v.ok {\n+\t\t\tt.Errorf(\"test %d, mergePAX(...): got %v, want %v\", i, ok, v.ok)\n \t\t}\n \t}\n }\n \n-func TestParseNumeric(t *testing.T) {\n-\tvar vectors = []struct {\n-\t\tinput  string\n-\t\toutput int64\n-\t\tok     bool\n+func TestParsePAX(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   string\n+\t\twant map[string]string\n+\t\tok   bool\n \t}{\n-\t\t// Test base-256 (binary) encoded values.\n-\t\t{\"\", 0, true},\n-\t\t{\"\\x80\", 0, true},\n-\t\t{\"\\x80\\x00\", 0, true},\n-\t\t{\"\\x80\\x00\\x00\", 0, true},\n-\t\t{\"\\xbf\", (1 << 6) - 1, true},\n-\t\t{\"\\xbf\\xff\", (1 << 14) - 1, true},\n-\t\t{\"\\xbf\\xff\\xff\", (1 << 22) - 1, true},\n-\t\t{\"\\xff\", -1, true},\n-\t\t{\"\\xff\\xff\", -1, true},\n-\t\t{\"\\xff\\xff\\xff\", -1, true},\n-\t\t{\"\\xc0\", -1 * (1 << 6), true},\n-\t\t{\"\\xc0\\x00\", -1 * (1 << 14), true},\n-\t\t{\"\\xc0\\x00\\x00\", -1 * (1 << 22), true},\n-\t\t{\"\\x87\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", 537795476381659745, true},\n-\t\t{\"\\x80\\x00\\x00\\x00\\x07\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", 537795476381659745, true},\n-\t\t{\"\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", -615126028225187231, true},\n-\t\t{\"\\xff\\xff\\xff\\xff\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", -615126028225187231, true},\n-\t\t{\"\\x80\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", math.MaxInt64, true},\n-\t\t{\"\\x80\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 0, false},\n-\t\t{\"\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", math.MinInt64, true},\n-\t\t{\"\\xff\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 0, false},\n-\t\t{\"\\xf5\\xec\\xd1\\xc7\\x7e\\x5f\\x26\\x48\\x81\\x9f\\x8f\\x9b\", 0, false},\n-\n-\t\t// Test base-8 (octal) encoded values.\n-\t\t{\"0000000\\x00\", 0, true},\n-\t\t{\" \\x0000000\\x00\", 0, true},\n-\t\t{\" \\x0000003\\x00\", 3, true},\n-\t\t{\"00000000227\\x00\", 0227, true},\n-\t\t{\"032033\\x00 \", 032033, true},\n-\t\t{\"320330\\x00 \", 0320330, true},\n-\t\t{\"0000660\\x00 \", 0660, true},\n-\t\t{\"\\x00 0000660\\x00 \", 0660, true},\n-\t\t{\"0123456789abcdef\", 0, false},\n-\t\t{\"0123456789\\x00abcdef\", 0, false},\n-\t\t{\"01234567\\x0089abcdef\", 342391, true},\n-\t\t{\"0123\\x7e\\x5f\\x264123\", 0, false},\n+\t\t{\"\", nil, true},\n+\t\t{\"6 k=1\\n\", map[string]string{\"k\": \"1\"}, true},\n+\t\t{\"10 a=name\\n\", map[string]string{\"a\": \"name\"}, true},\n+\t\t{\"9 a=name\\n\", map[string]string{\"a\": \"name\"}, true},\n+\t\t{\"30 mtime=1350244992.023960108\\n\", map[string]string{\"mtime\": \"1350244992.023960108\"}, true},\n+\t\t{\"3 somelongkey=\\n\", nil, false},\n+\t\t{\"50 tooshort=\\n\", nil, false},\n+\t\t{\"13 key1=haha\\n13 key2=nana\\n13 key3=kaka\\n\",\n+\t\t\tmap[string]string{\"key1\": \"haha\", \"key2\": \"nana\", \"key3\": \"kaka\"}, true},\n+\t\t{\"13 key1=val1\\n13 key2=val2\\n8 key1=\\n\",\n+\t\t\tmap[string]string{\"key2\": \"val2\"}, true},\n+\t\t{\"22 GNU.sparse.size=10\\n26 GNU.sparse.numblocks=2\\n\" +\n+\t\t\t\"23 GNU.sparse.offset=1\\n25 GNU.sparse.numbytes=2\\n\" +\n+\t\t\t\"23 GNU.sparse.offset=3\\n25 GNU.sparse.numbytes=4\\n\",\n+\t\t\tmap[string]string{paxGNUSparseSize: \"10\", paxGNUSparseNumBlocks: \"2\", paxGNUSparseMap: \"1,2,3,4\"}, true},\n+\t\t{\"22 GNU.sparse.size=10\\n26 GNU.sparse.numblocks=1\\n\" +\n+\t\t\t\"25 GNU.sparse.numbytes=2\\n23 GNU.sparse.offset=1\\n\",\n+\t\t\tnil, false},\n+\t\t{\"22 GNU.sparse.size=10\\n26 GNU.sparse.numblocks=1\\n\" +\n+\t\t\t\"25 GNU.sparse.offset=1,2\\n25 GNU.sparse.numbytes=2\\n\",\n+\t\t\tnil, false},\n \t}\n \n-\tfor _, v := range vectors {\n-\t\tvar p parser\n-\t\tnum := p.parseNumeric([]byte(v.input))\n-\t\tok := (p.err == nil)\n-\t\tif v.ok != ok {\n-\t\t\tif v.ok {\n-\t\t\t\tt.Errorf(\"parseNumeric(%q): got parsing failure, want success\", v.input)\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"parseNumeric(%q): got parsing success, want failure\", v.input)\n-\t\t\t}\n+\tfor i, v := range vectors {\n+\t\tr := strings.NewReader(v.in)\n+\t\tgot, err := parsePAX(r)\n+\t\tif !reflect.DeepEqual(got, v.want) && !(len(got) == 0 && len(v.want) == 0) {\n+\t\t\tt.Errorf(\"test %d, parsePAX(...):\\ngot  %v\\nwant %v\", i, got, v.want)\n \t\t}\n-\t\tif ok && num != v.output {\n-\t\t\tt.Errorf(\"parseNumeric(%q): got %d, want %d\", v.input, num, v.output)\n+\t\tif ok := err == nil; ok != v.ok {\n+\t\t\tt.Errorf(\"test %d, parsePAX(...): got %v, want %v\", i, ok, v.ok)\n \t\t}\n \t}\n }"}, {"sha": "bb5b51c02decfb4f7462f75eb3cf27aaea6f2301", "filename": "libgo/go/archive/tar/strconv.go", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,252 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tar\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func isASCII(s string) bool {\n+\tfor _, c := range s {\n+\t\tif c >= 0x80 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func toASCII(s string) string {\n+\tif isASCII(s) {\n+\t\treturn s\n+\t}\n+\tvar buf bytes.Buffer\n+\tfor _, c := range s {\n+\t\tif c < 0x80 {\n+\t\t\tbuf.WriteByte(byte(c))\n+\t\t}\n+\t}\n+\treturn buf.String()\n+}\n+\n+type parser struct {\n+\terr error // Last error seen\n+}\n+\n+type formatter struct {\n+\terr error // Last error seen\n+}\n+\n+// parseString parses bytes as a NUL-terminated C-style string.\n+// If a NUL byte is not found then the whole slice is returned as a string.\n+func (*parser) parseString(b []byte) string {\n+\tn := 0\n+\tfor n < len(b) && b[n] != 0 {\n+\t\tn++\n+\t}\n+\treturn string(b[0:n])\n+}\n+\n+// Write s into b, terminating it with a NUL if there is room.\n+func (f *formatter) formatString(b []byte, s string) {\n+\tif len(s) > len(b) {\n+\t\tf.err = ErrFieldTooLong\n+\t\treturn\n+\t}\n+\tascii := toASCII(s)\n+\tcopy(b, ascii)\n+\tif len(ascii) < len(b) {\n+\t\tb[len(ascii)] = 0\n+\t}\n+}\n+\n+// fitsInBase256 reports whether x can be encoded into n bytes using base-256\n+// encoding. Unlike octal encoding, base-256 encoding does not require that the\n+// string ends with a NUL character. Thus, all n bytes are available for output.\n+//\n+// If operating in binary mode, this assumes strict GNU binary mode; which means\n+// that the first byte can only be either 0x80 or 0xff. Thus, the first byte is\n+// equivalent to the sign bit in two's complement form.\n+func fitsInBase256(n int, x int64) bool {\n+\tvar binBits = uint(n-1) * 8\n+\treturn n >= 9 || (x >= -1<<binBits && x < 1<<binBits)\n+}\n+\n+// parseNumeric parses the input as being encoded in either base-256 or octal.\n+// This function may return negative numbers.\n+// If parsing fails or an integer overflow occurs, err will be set.\n+func (p *parser) parseNumeric(b []byte) int64 {\n+\t// Check for base-256 (binary) format first.\n+\t// If the first bit is set, then all following bits constitute a two's\n+\t// complement encoded number in big-endian byte order.\n+\tif len(b) > 0 && b[0]&0x80 != 0 {\n+\t\t// Handling negative numbers relies on the following identity:\n+\t\t//\t-a-1 == ^a\n+\t\t//\n+\t\t// If the number is negative, we use an inversion mask to invert the\n+\t\t// data bytes and treat the value as an unsigned number.\n+\t\tvar inv byte // 0x00 if positive or zero, 0xff if negative\n+\t\tif b[0]&0x40 != 0 {\n+\t\t\tinv = 0xff\n+\t\t}\n+\n+\t\tvar x uint64\n+\t\tfor i, c := range b {\n+\t\t\tc ^= inv // Inverts c only if inv is 0xff, otherwise does nothing\n+\t\t\tif i == 0 {\n+\t\t\t\tc &= 0x7f // Ignore signal bit in first byte\n+\t\t\t}\n+\t\t\tif (x >> 56) > 0 {\n+\t\t\t\tp.err = ErrHeader // Integer overflow\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\tx = x<<8 | uint64(c)\n+\t\t}\n+\t\tif (x >> 63) > 0 {\n+\t\t\tp.err = ErrHeader // Integer overflow\n+\t\t\treturn 0\n+\t\t}\n+\t\tif inv == 0xff {\n+\t\t\treturn ^int64(x)\n+\t\t}\n+\t\treturn int64(x)\n+\t}\n+\n+\t// Normal case is base-8 (octal) format.\n+\treturn p.parseOctal(b)\n+}\n+\n+// Write x into b, as binary (GNUtar/star extension).\n+func (f *formatter) formatNumeric(b []byte, x int64) {\n+\tif fitsInBase256(len(b), x) {\n+\t\tfor i := len(b) - 1; i >= 0; i-- {\n+\t\t\tb[i] = byte(x)\n+\t\t\tx >>= 8\n+\t\t}\n+\t\tb[0] |= 0x80 // Highest bit indicates binary format\n+\t\treturn\n+\t}\n+\n+\tf.formatOctal(b, 0) // Last resort, just write zero\n+\tf.err = ErrFieldTooLong\n+}\n+\n+func (p *parser) parseOctal(b []byte) int64 {\n+\t// Because unused fields are filled with NULs, we need\n+\t// to skip leading NULs. Fields may also be padded with\n+\t// spaces or NULs.\n+\t// So we remove leading and trailing NULs and spaces to\n+\t// be sure.\n+\tb = bytes.Trim(b, \" \\x00\")\n+\n+\tif len(b) == 0 {\n+\t\treturn 0\n+\t}\n+\tx, perr := strconv.ParseUint(p.parseString(b), 8, 64)\n+\tif perr != nil {\n+\t\tp.err = ErrHeader\n+\t}\n+\treturn int64(x)\n+}\n+\n+func (f *formatter) formatOctal(b []byte, x int64) {\n+\ts := strconv.FormatInt(x, 8)\n+\t// Add leading zeros, but leave room for a NUL.\n+\tif n := len(b) - len(s) - 1; n > 0 {\n+\t\ts = strings.Repeat(\"0\", n) + s\n+\t}\n+\tf.formatString(b, s)\n+}\n+\n+// parsePAXTime takes a string of the form %d.%d as described in the PAX\n+// specification. Note that this implementation allows for negative timestamps,\n+// which is allowed for by the PAX specification, but not always portable.\n+func parsePAXTime(s string) (time.Time, error) {\n+\tconst maxNanoSecondDigits = 9\n+\n+\t// Split string into seconds and sub-seconds parts.\n+\tss, sn := s, \"\"\n+\tif pos := strings.IndexByte(s, '.'); pos >= 0 {\n+\t\tss, sn = s[:pos], s[pos+1:]\n+\t}\n+\n+\t// Parse the seconds.\n+\tsecs, err := strconv.ParseInt(ss, 10, 64)\n+\tif err != nil {\n+\t\treturn time.Time{}, ErrHeader\n+\t}\n+\tif len(sn) == 0 {\n+\t\treturn time.Unix(secs, 0), nil // No sub-second values\n+\t}\n+\n+\t// Parse the nanoseconds.\n+\tif strings.Trim(sn, \"0123456789\") != \"\" {\n+\t\treturn time.Time{}, ErrHeader\n+\t}\n+\tif len(sn) < maxNanoSecondDigits {\n+\t\tsn += strings.Repeat(\"0\", maxNanoSecondDigits-len(sn)) // Right pad\n+\t} else {\n+\t\tsn = sn[:maxNanoSecondDigits] // Right truncate\n+\t}\n+\tnsecs, _ := strconv.ParseInt(sn, 10, 64) // Must succeed\n+\tif len(ss) > 0 && ss[0] == '-' {\n+\t\treturn time.Unix(secs, -1*int64(nsecs)), nil // Negative correction\n+\t}\n+\treturn time.Unix(secs, int64(nsecs)), nil\n+}\n+\n+// TODO(dsnet): Implement formatPAXTime.\n+\n+// parsePAXRecord parses the input PAX record string into a key-value pair.\n+// If parsing is successful, it will slice off the currently read record and\n+// return the remainder as r.\n+//\n+// A PAX record is of the following form:\n+//\t\"%d %s=%s\\n\" % (size, key, value)\n+func parsePAXRecord(s string) (k, v, r string, err error) {\n+\t// The size field ends at the first space.\n+\tsp := strings.IndexByte(s, ' ')\n+\tif sp == -1 {\n+\t\treturn \"\", \"\", s, ErrHeader\n+\t}\n+\n+\t// Parse the first token as a decimal integer.\n+\tn, perr := strconv.ParseInt(s[:sp], 10, 0) // Intentionally parse as native int\n+\tif perr != nil || n < 5 || int64(len(s)) < n {\n+\t\treturn \"\", \"\", s, ErrHeader\n+\t}\n+\n+\t// Extract everything between the space and the final newline.\n+\trec, nl, rem := s[sp+1:n-1], s[n-1:n], s[n:]\n+\tif nl != \"\\n\" {\n+\t\treturn \"\", \"\", s, ErrHeader\n+\t}\n+\n+\t// The first equals separates the key from the value.\n+\teq := strings.IndexByte(rec, '=')\n+\tif eq == -1 {\n+\t\treturn \"\", \"\", s, ErrHeader\n+\t}\n+\treturn rec[:eq], rec[eq+1:], rem, nil\n+}\n+\n+// formatPAXRecord formats a single PAX record, prefixing it with the\n+// appropriate length.\n+func formatPAXRecord(k, v string) string {\n+\tconst padding = 3 // Extra padding for ' ', '=', and '\\n'\n+\tsize := len(k) + len(v) + padding\n+\tsize += len(strconv.Itoa(size))\n+\trecord := fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n+\n+\t// Final adjustment if adding size field increased the record size.\n+\tif len(record) != size {\n+\t\tsize = len(record)\n+\t\trecord = fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n+\t}\n+\treturn record\n+}"}, {"sha": "beb70938bfdd62b67487ece3b17188f1a9576394", "filename": "libgo/go/archive/tar/strconv_test.go", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tar\n+\n+import (\n+\t\"math\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestFitsInBase256(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin    int64\n+\t\twidth int\n+\t\tok    bool\n+\t}{\n+\t\t{+1, 8, true},\n+\t\t{0, 8, true},\n+\t\t{-1, 8, true},\n+\t\t{1 << 56, 8, false},\n+\t\t{(1 << 56) - 1, 8, true},\n+\t\t{-1 << 56, 8, true},\n+\t\t{(-1 << 56) - 1, 8, false},\n+\t\t{121654, 8, true},\n+\t\t{-9849849, 8, true},\n+\t\t{math.MaxInt64, 9, true},\n+\t\t{0, 9, true},\n+\t\t{math.MinInt64, 9, true},\n+\t\t{math.MaxInt64, 12, true},\n+\t\t{0, 12, true},\n+\t\t{math.MinInt64, 12, true},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tok := fitsInBase256(v.width, v.in)\n+\t\tif ok != v.ok {\n+\t\t\tt.Errorf(\"fitsInBase256(%d, %d): got %v, want %v\", v.in, v.width, ok, v.ok)\n+\t\t}\n+\t}\n+}\n+\n+func TestParseNumeric(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   string\n+\t\twant int64\n+\t\tok   bool\n+\t}{\n+\t\t// Test base-256 (binary) encoded values.\n+\t\t{\"\", 0, true},\n+\t\t{\"\\x80\", 0, true},\n+\t\t{\"\\x80\\x00\", 0, true},\n+\t\t{\"\\x80\\x00\\x00\", 0, true},\n+\t\t{\"\\xbf\", (1 << 6) - 1, true},\n+\t\t{\"\\xbf\\xff\", (1 << 14) - 1, true},\n+\t\t{\"\\xbf\\xff\\xff\", (1 << 22) - 1, true},\n+\t\t{\"\\xff\", -1, true},\n+\t\t{\"\\xff\\xff\", -1, true},\n+\t\t{\"\\xff\\xff\\xff\", -1, true},\n+\t\t{\"\\xc0\", -1 * (1 << 6), true},\n+\t\t{\"\\xc0\\x00\", -1 * (1 << 14), true},\n+\t\t{\"\\xc0\\x00\\x00\", -1 * (1 << 22), true},\n+\t\t{\"\\x87\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", 537795476381659745, true},\n+\t\t{\"\\x80\\x00\\x00\\x00\\x07\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", 537795476381659745, true},\n+\t\t{\"\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", -615126028225187231, true},\n+\t\t{\"\\xff\\xff\\xff\\xff\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", -615126028225187231, true},\n+\t\t{\"\\x80\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", math.MaxInt64, true},\n+\t\t{\"\\x80\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 0, false},\n+\t\t{\"\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", math.MinInt64, true},\n+\t\t{\"\\xff\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 0, false},\n+\t\t{\"\\xf5\\xec\\xd1\\xc7\\x7e\\x5f\\x26\\x48\\x81\\x9f\\x8f\\x9b\", 0, false},\n+\n+\t\t// Test base-8 (octal) encoded values.\n+\t\t{\"0000000\\x00\", 0, true},\n+\t\t{\" \\x0000000\\x00\", 0, true},\n+\t\t{\" \\x0000003\\x00\", 3, true},\n+\t\t{\"00000000227\\x00\", 0227, true},\n+\t\t{\"032033\\x00 \", 032033, true},\n+\t\t{\"320330\\x00 \", 0320330, true},\n+\t\t{\"0000660\\x00 \", 0660, true},\n+\t\t{\"\\x00 0000660\\x00 \", 0660, true},\n+\t\t{\"0123456789abcdef\", 0, false},\n+\t\t{\"0123456789\\x00abcdef\", 0, false},\n+\t\t{\"01234567\\x0089abcdef\", 342391, true},\n+\t\t{\"0123\\x7e\\x5f\\x264123\", 0, false},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tvar p parser\n+\t\tgot := p.parseNumeric([]byte(v.in))\n+\t\tok := (p.err == nil)\n+\t\tif ok != v.ok {\n+\t\t\tif v.ok {\n+\t\t\t\tt.Errorf(\"parseNumeric(%q): got parsing failure, want success\", v.in)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"parseNumeric(%q): got parsing success, want failure\", v.in)\n+\t\t\t}\n+\t\t}\n+\t\tif ok && got != v.want {\n+\t\t\tt.Errorf(\"parseNumeric(%q): got %d, want %d\", v.in, got, v.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestFormatNumeric(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   int64\n+\t\twant string\n+\t\tok   bool\n+\t}{\n+\t\t// Test base-256 (binary) encoded values.\n+\t\t{-1, \"\\xff\", true},\n+\t\t{-1, \"\\xff\\xff\", true},\n+\t\t{-1, \"\\xff\\xff\\xff\", true},\n+\t\t{(1 << 0), \"0\", false},\n+\t\t{(1 << 8) - 1, \"\\x80\\xff\", true},\n+\t\t{(1 << 8), \"0\\x00\", false},\n+\t\t{(1 << 16) - 1, \"\\x80\\xff\\xff\", true},\n+\t\t{(1 << 16), \"00\\x00\", false},\n+\t\t{-1 * (1 << 0), \"\\xff\", true},\n+\t\t{-1*(1<<0) - 1, \"0\", false},\n+\t\t{-1 * (1 << 8), \"\\xff\\x00\", true},\n+\t\t{-1*(1<<8) - 1, \"0\\x00\", false},\n+\t\t{-1 * (1 << 16), \"\\xff\\x00\\x00\", true},\n+\t\t{-1*(1<<16) - 1, \"00\\x00\", false},\n+\t\t{537795476381659745, \"0000000\\x00\", false},\n+\t\t{537795476381659745, \"\\x80\\x00\\x00\\x00\\x07\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", true},\n+\t\t{-615126028225187231, \"0000000\\x00\", false},\n+\t\t{-615126028225187231, \"\\xff\\xff\\xff\\xff\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", true},\n+\t\t{math.MaxInt64, \"0000000\\x00\", false},\n+\t\t{math.MaxInt64, \"\\x80\\x00\\x00\\x00\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", true},\n+\t\t{math.MinInt64, \"0000000\\x00\", false},\n+\t\t{math.MinInt64, \"\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", true},\n+\t\t{math.MaxInt64, \"\\x80\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", true},\n+\t\t{math.MinInt64, \"\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", true},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tvar f formatter\n+\t\tgot := make([]byte, len(v.want))\n+\t\tf.formatNumeric(got, v.in)\n+\t\tok := (f.err == nil)\n+\t\tif ok != v.ok {\n+\t\t\tif v.ok {\n+\t\t\t\tt.Errorf(\"formatNumeric(%d): got formatting failure, want success\", v.in)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"formatNumeric(%d): got formatting success, want failure\", v.in)\n+\t\t\t}\n+\t\t}\n+\t\tif string(got) != v.want {\n+\t\t\tt.Errorf(\"formatNumeric(%d): got %q, want %q\", v.in, got, v.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestParsePAXTime(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   string\n+\t\twant time.Time\n+\t\tok   bool\n+\t}{\n+\t\t{\"1350244992.023960108\", time.Unix(1350244992, 23960108), true},\n+\t\t{\"1350244992.02396010\", time.Unix(1350244992, 23960100), true},\n+\t\t{\"1350244992.0239601089\", time.Unix(1350244992, 23960108), true},\n+\t\t{\"1350244992.3\", time.Unix(1350244992, 300000000), true},\n+\t\t{\"1350244992\", time.Unix(1350244992, 0), true},\n+\t\t{\"-1.000000001\", time.Unix(-1, -1e0+0e0), true},\n+\t\t{\"-1.000001\", time.Unix(-1, -1e3+0e0), true},\n+\t\t{\"-1.001000\", time.Unix(-1, -1e6+0e0), true},\n+\t\t{\"-1\", time.Unix(-1, -0e0+0e0), true},\n+\t\t{\"-1.999000\", time.Unix(-1, -1e9+1e6), true},\n+\t\t{\"-1.999999\", time.Unix(-1, -1e9+1e3), true},\n+\t\t{\"-1.999999999\", time.Unix(-1, -1e9+1e0), true},\n+\t\t{\"0.000000001\", time.Unix(0, 1e0+0e0), true},\n+\t\t{\"0.000001\", time.Unix(0, 1e3+0e0), true},\n+\t\t{\"0.001000\", time.Unix(0, 1e6+0e0), true},\n+\t\t{\"0\", time.Unix(0, 0e0), true},\n+\t\t{\"0.999000\", time.Unix(0, 1e9-1e6), true},\n+\t\t{\"0.999999\", time.Unix(0, 1e9-1e3), true},\n+\t\t{\"0.999999999\", time.Unix(0, 1e9-1e0), true},\n+\t\t{\"1.000000001\", time.Unix(+1, +1e0-0e0), true},\n+\t\t{\"1.000001\", time.Unix(+1, +1e3-0e0), true},\n+\t\t{\"1.001000\", time.Unix(+1, +1e6-0e0), true},\n+\t\t{\"1\", time.Unix(+1, +0e0-0e0), true},\n+\t\t{\"1.999000\", time.Unix(+1, +1e9-1e6), true},\n+\t\t{\"1.999999\", time.Unix(+1, +1e9-1e3), true},\n+\t\t{\"1.999999999\", time.Unix(+1, +1e9-1e0), true},\n+\t\t{\"-1350244992.023960108\", time.Unix(-1350244992, -23960108), true},\n+\t\t{\"-1350244992.02396010\", time.Unix(-1350244992, -23960100), true},\n+\t\t{\"-1350244992.0239601089\", time.Unix(-1350244992, -23960108), true},\n+\t\t{\"-1350244992.3\", time.Unix(-1350244992, -300000000), true},\n+\t\t{\"-1350244992\", time.Unix(-1350244992, 0), true},\n+\t\t{\"\", time.Time{}, false},\n+\t\t{\"0\", time.Unix(0, 0), true},\n+\t\t{\"1.\", time.Unix(1, 0), true},\n+\t\t{\"0.0\", time.Unix(0, 0), true},\n+\t\t{\".5\", time.Time{}, false},\n+\t\t{\"-1.3\", time.Unix(-1, -3e8), true},\n+\t\t{\"-1.0\", time.Unix(-1, -0e0), true},\n+\t\t{\"-0.0\", time.Unix(-0, -0e0), true},\n+\t\t{\"-0.1\", time.Unix(-0, -1e8), true},\n+\t\t{\"-0.01\", time.Unix(-0, -1e7), true},\n+\t\t{\"-0.99\", time.Unix(-0, -99e7), true},\n+\t\t{\"-0.98\", time.Unix(-0, -98e7), true},\n+\t\t{\"-1.1\", time.Unix(-1, -1e8), true},\n+\t\t{\"-1.01\", time.Unix(-1, -1e7), true},\n+\t\t{\"-2.99\", time.Unix(-2, -99e7), true},\n+\t\t{\"-5.98\", time.Unix(-5, -98e7), true},\n+\t\t{\"-\", time.Time{}, false},\n+\t\t{\"+\", time.Time{}, false},\n+\t\t{\"-1.-1\", time.Time{}, false},\n+\t\t{\"99999999999999999999999999999999999999999999999\", time.Time{}, false},\n+\t\t{\"0.123456789abcdef\", time.Time{}, false},\n+\t\t{\"foo\", time.Time{}, false},\n+\t\t{\"\\x00\", time.Time{}, false},\n+\t\t{\"\ud835\udff5\ud835\udff4\ud835\udff3\ud835\udff2\ud835\udff1.\ud835\udff0\ud835\udfef\ud835\udfee\ud835\udfed\ud835\udfec\", time.Time{}, false}, // Unicode numbers (U+1D7EC to U+1D7F5)\n+\t\t{\"98765\ufe5243210\", time.Time{}, false}, // Unicode period (U+FE52)\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tts, err := parsePAXTime(v.in)\n+\t\tok := (err == nil)\n+\t\tif v.ok != ok {\n+\t\t\tif v.ok {\n+\t\t\t\tt.Errorf(\"parsePAXTime(%q): got parsing failure, want success\", v.in)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"parsePAXTime(%q): got parsing success, want failure\", v.in)\n+\t\t\t}\n+\t\t}\n+\t\tif ok && !ts.Equal(v.want) {\n+\t\t\tt.Errorf(\"parsePAXTime(%q): got (%ds %dns), want (%ds %dns)\",\n+\t\t\t\tv.in, ts.Unix(), ts.Nanosecond(), v.want.Unix(), v.want.Nanosecond())\n+\t\t}\n+\t}\n+}\n+\n+func TestParsePAXRecord(t *testing.T) {\n+\tmedName := strings.Repeat(\"CD\", 50)\n+\tlongName := strings.Repeat(\"AB\", 100)\n+\n+\tvectors := []struct {\n+\t\tin      string\n+\t\twantRes string\n+\t\twantKey string\n+\t\twantVal string\n+\t\tok      bool\n+\t}{\n+\t\t{\"6 k=v\\n\\n\", \"\\n\", \"k\", \"v\", true},\n+\t\t{\"19 path=/etc/hosts\\n\", \"\", \"path\", \"/etc/hosts\", true},\n+\t\t{\"210 path=\" + longName + \"\\nabc\", \"abc\", \"path\", longName, true},\n+\t\t{\"110 path=\" + medName + \"\\n\", \"\", \"path\", medName, true},\n+\t\t{\"9 foo=ba\\n\", \"\", \"foo\", \"ba\", true},\n+\t\t{\"11 foo=bar\\n\\x00\", \"\\x00\", \"foo\", \"bar\", true},\n+\t\t{\"18 foo=b=\\nar=\\n==\\x00\\n\", \"\", \"foo\", \"b=\\nar=\\n==\\x00\", true},\n+\t\t{\"27 foo=hello9 foo=ba\\nworld\\n\", \"\", \"foo\", \"hello9 foo=ba\\nworld\", true},\n+\t\t{\"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\nmeow mix\", \"meow mix\", \"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", true},\n+\t\t{\"17 \\x00hello=\\x00world\\n\", \"\", \"\\x00hello\", \"\\x00world\", true},\n+\t\t{\"1 k=1\\n\", \"1 k=1\\n\", \"\", \"\", false},\n+\t\t{\"6 k~1\\n\", \"6 k~1\\n\", \"\", \"\", false},\n+\t\t{\"6_k=1\\n\", \"6_k=1\\n\", \"\", \"\", false},\n+\t\t{\"6 k=1 \", \"6 k=1 \", \"\", \"\", false},\n+\t\t{\"632 k=1\\n\", \"632 k=1\\n\", \"\", \"\", false},\n+\t\t{\"16 longkeyname=hahaha\\n\", \"16 longkeyname=hahaha\\n\", \"\", \"\", false},\n+\t\t{\"3 somelongkey=\\n\", \"3 somelongkey=\\n\", \"\", \"\", false},\n+\t\t{\"50 tooshort=\\n\", \"50 tooshort=\\n\", \"\", \"\", false},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tkey, val, res, err := parsePAXRecord(v.in)\n+\t\tok := (err == nil)\n+\t\tif ok != v.ok {\n+\t\t\tif v.ok {\n+\t\t\t\tt.Errorf(\"parsePAXRecord(%q): got parsing failure, want success\", v.in)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"parsePAXRecord(%q): got parsing success, want failure\", v.in)\n+\t\t\t}\n+\t\t}\n+\t\tif v.ok && (key != v.wantKey || val != v.wantVal) {\n+\t\t\tt.Errorf(\"parsePAXRecord(%q): got (%q: %q), want (%q: %q)\",\n+\t\t\t\tv.in, key, val, v.wantKey, v.wantVal)\n+\t\t}\n+\t\tif res != v.wantRes {\n+\t\t\tt.Errorf(\"parsePAXRecord(%q): got residual %q, want residual %q\",\n+\t\t\t\tv.in, res, v.wantRes)\n+\t\t}\n+\t}\n+}\n+\n+func TestFormatPAXRecord(t *testing.T) {\n+\tmedName := strings.Repeat(\"CD\", 50)\n+\tlongName := strings.Repeat(\"AB\", 100)\n+\n+\tvectors := []struct {\n+\t\tinKey string\n+\t\tinVal string\n+\t\twant  string\n+\t}{\n+\t\t{\"k\", \"v\", \"6 k=v\\n\"},\n+\t\t{\"path\", \"/etc/hosts\", \"19 path=/etc/hosts\\n\"},\n+\t\t{\"path\", longName, \"210 path=\" + longName + \"\\n\"},\n+\t\t{\"path\", medName, \"110 path=\" + medName + \"\\n\"},\n+\t\t{\"foo\", \"ba\", \"9 foo=ba\\n\"},\n+\t\t{\"foo\", \"bar\", \"11 foo=bar\\n\"},\n+\t\t{\"foo\", \"b=\\nar=\\n==\\x00\", \"18 foo=b=\\nar=\\n==\\x00\\n\"},\n+\t\t{\"foo\", \"hello9 foo=ba\\nworld\", \"27 foo=hello9 foo=ba\\nworld\\n\"},\n+\t\t{\"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", \"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\n\"},\n+\t\t{\"\\x00hello\", \"\\x00world\", \"17 \\x00hello=\\x00world\\n\"},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tgot := formatPAXRecord(v.inKey, v.inVal)\n+\t\tif got != v.want {\n+\t\t\tt.Errorf(\"formatPAXRecord(%q, %q): got %q, want %q\",\n+\t\t\t\tv.inKey, v.inVal, got, v.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "cf8337c2ad94038e0f2abdf1314ea8f6f51a06a6", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 112, "deletions": 124, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -135,190 +135,178 @@ type headerRoundTripTest struct {\n }\n \n func TestHeaderRoundTrip(t *testing.T) {\n-\tgolden := []headerRoundTripTest{\n+\tvectors := []headerRoundTripTest{{\n \t\t// regular file.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"test.txt\",\n-\t\t\t\tMode:     0644 | c_ISREG,\n-\t\t\t\tSize:     12,\n-\t\t\t\tModTime:  time.Unix(1360600916, 0),\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t},\n-\t\t\tfm: 0644,\n+\t\th: &Header{\n+\t\t\tName:     \"test.txt\",\n+\t\t\tMode:     0644 | c_ISREG,\n+\t\t\tSize:     12,\n+\t\t\tModTime:  time.Unix(1360600916, 0),\n+\t\t\tTypeflag: TypeReg,\n \t\t},\n+\t\tfm: 0644,\n+\t}, {\n \t\t// symbolic link.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"link.txt\",\n-\t\t\t\tMode:     0777 | c_ISLNK,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360600852, 0),\n-\t\t\t\tTypeflag: TypeSymlink,\n-\t\t\t},\n-\t\t\tfm: 0777 | os.ModeSymlink,\n+\t\th: &Header{\n+\t\t\tName:     \"link.txt\",\n+\t\t\tMode:     0777 | c_ISLNK,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360600852, 0),\n+\t\t\tTypeflag: TypeSymlink,\n \t\t},\n+\t\tfm: 0777 | os.ModeSymlink,\n+\t}, {\n \t\t// character device node.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"dev/null\",\n-\t\t\t\tMode:     0666 | c_ISCHR,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360578951, 0),\n-\t\t\t\tTypeflag: TypeChar,\n-\t\t\t},\n-\t\t\tfm: 0666 | os.ModeDevice | os.ModeCharDevice,\n+\t\th: &Header{\n+\t\t\tName:     \"dev/null\",\n+\t\t\tMode:     0666 | c_ISCHR,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360578951, 0),\n+\t\t\tTypeflag: TypeChar,\n \t\t},\n+\t\tfm: 0666 | os.ModeDevice | os.ModeCharDevice,\n+\t}, {\n \t\t// block device node.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"dev/sda\",\n-\t\t\t\tMode:     0660 | c_ISBLK,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360578954, 0),\n-\t\t\t\tTypeflag: TypeBlock,\n-\t\t\t},\n-\t\t\tfm: 0660 | os.ModeDevice,\n+\t\th: &Header{\n+\t\t\tName:     \"dev/sda\",\n+\t\t\tMode:     0660 | c_ISBLK,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360578954, 0),\n+\t\t\tTypeflag: TypeBlock,\n \t\t},\n+\t\tfm: 0660 | os.ModeDevice,\n+\t}, {\n \t\t// directory.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"dir/\",\n-\t\t\t\tMode:     0755 | c_ISDIR,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360601116, 0),\n-\t\t\t\tTypeflag: TypeDir,\n-\t\t\t},\n-\t\t\tfm: 0755 | os.ModeDir,\n+\t\th: &Header{\n+\t\t\tName:     \"dir/\",\n+\t\t\tMode:     0755 | c_ISDIR,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360601116, 0),\n+\t\t\tTypeflag: TypeDir,\n \t\t},\n+\t\tfm: 0755 | os.ModeDir,\n+\t}, {\n \t\t// fifo node.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"dev/initctl\",\n-\t\t\t\tMode:     0600 | c_ISFIFO,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360578949, 0),\n-\t\t\t\tTypeflag: TypeFifo,\n-\t\t\t},\n-\t\t\tfm: 0600 | os.ModeNamedPipe,\n+\t\th: &Header{\n+\t\t\tName:     \"dev/initctl\",\n+\t\t\tMode:     0600 | c_ISFIFO,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360578949, 0),\n+\t\t\tTypeflag: TypeFifo,\n \t\t},\n+\t\tfm: 0600 | os.ModeNamedPipe,\n+\t}, {\n \t\t// setuid.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"bin/su\",\n-\t\t\t\tMode:     0755 | c_ISREG | c_ISUID,\n-\t\t\t\tSize:     23232,\n-\t\t\t\tModTime:  time.Unix(1355405093, 0),\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t},\n-\t\t\tfm: 0755 | os.ModeSetuid,\n+\t\th: &Header{\n+\t\t\tName:     \"bin/su\",\n+\t\t\tMode:     0755 | c_ISREG | c_ISUID,\n+\t\t\tSize:     23232,\n+\t\t\tModTime:  time.Unix(1355405093, 0),\n+\t\t\tTypeflag: TypeReg,\n \t\t},\n+\t\tfm: 0755 | os.ModeSetuid,\n+\t}, {\n \t\t// setguid.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"group.txt\",\n-\t\t\t\tMode:     0750 | c_ISREG | c_ISGID,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360602346, 0),\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t},\n-\t\t\tfm: 0750 | os.ModeSetgid,\n+\t\th: &Header{\n+\t\t\tName:     \"group.txt\",\n+\t\t\tMode:     0750 | c_ISREG | c_ISGID,\n+\t\t\tSize:     0,\n+\t\t\tModTime:  time.Unix(1360602346, 0),\n+\t\t\tTypeflag: TypeReg,\n \t\t},\n+\t\tfm: 0750 | os.ModeSetgid,\n+\t}, {\n \t\t// sticky.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"sticky.txt\",\n-\t\t\t\tMode:     0600 | c_ISREG | c_ISVTX,\n-\t\t\t\tSize:     7,\n-\t\t\t\tModTime:  time.Unix(1360602540, 0),\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t},\n-\t\t\tfm: 0600 | os.ModeSticky,\n+\t\th: &Header{\n+\t\t\tName:     \"sticky.txt\",\n+\t\t\tMode:     0600 | c_ISREG | c_ISVTX,\n+\t\t\tSize:     7,\n+\t\t\tModTime:  time.Unix(1360602540, 0),\n+\t\t\tTypeflag: TypeReg,\n \t\t},\n+\t\tfm: 0600 | os.ModeSticky,\n+\t}, {\n \t\t// hard link.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"hard.txt\",\n-\t\t\t\tMode:     0644 | c_ISREG,\n-\t\t\t\tSize:     0,\n-\t\t\t\tLinkname: \"file.txt\",\n-\t\t\t\tModTime:  time.Unix(1360600916, 0),\n-\t\t\t\tTypeflag: TypeLink,\n-\t\t\t},\n-\t\t\tfm: 0644,\n+\t\th: &Header{\n+\t\t\tName:     \"hard.txt\",\n+\t\t\tMode:     0644 | c_ISREG,\n+\t\t\tSize:     0,\n+\t\t\tLinkname: \"file.txt\",\n+\t\t\tModTime:  time.Unix(1360600916, 0),\n+\t\t\tTypeflag: TypeLink,\n \t\t},\n+\t\tfm: 0644,\n+\t}, {\n \t\t// More information.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"info.txt\",\n-\t\t\t\tMode:     0600 | c_ISREG,\n-\t\t\t\tSize:     0,\n-\t\t\t\tUid:      1000,\n-\t\t\t\tGid:      1000,\n-\t\t\t\tModTime:  time.Unix(1360602540, 0),\n-\t\t\t\tUname:    \"slartibartfast\",\n-\t\t\t\tGname:    \"users\",\n-\t\t\t\tTypeflag: TypeReg,\n-\t\t\t},\n-\t\t\tfm: 0600,\n+\t\th: &Header{\n+\t\t\tName:     \"info.txt\",\n+\t\t\tMode:     0600 | c_ISREG,\n+\t\t\tSize:     0,\n+\t\t\tUid:      1000,\n+\t\t\tGid:      1000,\n+\t\t\tModTime:  time.Unix(1360602540, 0),\n+\t\t\tUname:    \"slartibartfast\",\n+\t\t\tGname:    \"users\",\n+\t\t\tTypeflag: TypeReg,\n \t\t},\n-\t}\n+\t\tfm: 0600,\n+\t}}\n \n-\tfor i, g := range golden {\n-\t\tfi := g.h.FileInfo()\n+\tfor i, v := range vectors {\n+\t\tfi := v.h.FileInfo()\n \t\th2, err := FileInfoHeader(fi, \"\")\n \t\tif err != nil {\n \t\t\tt.Error(err)\n \t\t\tcontinue\n \t\t}\n \t\tif strings.Contains(fi.Name(), \"/\") {\n-\t\t\tt.Errorf(\"FileInfo of %q contains slash: %q\", g.h.Name, fi.Name())\n+\t\t\tt.Errorf(\"FileInfo of %q contains slash: %q\", v.h.Name, fi.Name())\n \t\t}\n-\t\tname := path.Base(g.h.Name)\n+\t\tname := path.Base(v.h.Name)\n \t\tif fi.IsDir() {\n \t\t\tname += \"/\"\n \t\t}\n \t\tif got, want := h2.Name, name; got != want {\n \t\t\tt.Errorf(\"i=%d: Name: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Size, g.h.Size; got != want {\n+\t\tif got, want := h2.Size, v.h.Size; got != want {\n \t\t\tt.Errorf(\"i=%d: Size: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Uid, g.h.Uid; got != want {\n+\t\tif got, want := h2.Uid, v.h.Uid; got != want {\n \t\t\tt.Errorf(\"i=%d: Uid: got %d, want %d\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Gid, g.h.Gid; got != want {\n+\t\tif got, want := h2.Gid, v.h.Gid; got != want {\n \t\t\tt.Errorf(\"i=%d: Gid: got %d, want %d\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Uname, g.h.Uname; got != want {\n+\t\tif got, want := h2.Uname, v.h.Uname; got != want {\n \t\t\tt.Errorf(\"i=%d: Uname: got %q, want %q\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Gname, g.h.Gname; got != want {\n+\t\tif got, want := h2.Gname, v.h.Gname; got != want {\n \t\t\tt.Errorf(\"i=%d: Gname: got %q, want %q\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Linkname, g.h.Linkname; got != want {\n+\t\tif got, want := h2.Linkname, v.h.Linkname; got != want {\n \t\t\tt.Errorf(\"i=%d: Linkname: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Typeflag, g.h.Typeflag; got != want {\n-\t\t\tt.Logf(\"%#v %#v\", g.h, fi.Sys())\n+\t\tif got, want := h2.Typeflag, v.h.Typeflag; got != want {\n+\t\t\tt.Logf(\"%#v %#v\", v.h, fi.Sys())\n \t\t\tt.Errorf(\"i=%d: Typeflag: got %q, want %q\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.Mode, g.h.Mode; got != want {\n+\t\tif got, want := h2.Mode, v.h.Mode; got != want {\n \t\t\tt.Errorf(\"i=%d: Mode: got %o, want %o\", i, got, want)\n \t\t}\n-\t\tif got, want := fi.Mode(), g.fm; got != want {\n+\t\tif got, want := fi.Mode(), v.fm; got != want {\n \t\t\tt.Errorf(\"i=%d: fi.Mode: got %o, want %o\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.AccessTime, g.h.AccessTime; got != want {\n+\t\tif got, want := h2.AccessTime, v.h.AccessTime; got != want {\n \t\t\tt.Errorf(\"i=%d: AccessTime: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.ChangeTime, g.h.ChangeTime; got != want {\n+\t\tif got, want := h2.ChangeTime, v.h.ChangeTime; got != want {\n \t\t\tt.Errorf(\"i=%d: ChangeTime: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif got, want := h2.ModTime, g.h.ModTime; got != want {\n+\t\tif got, want := h2.ModTime, v.h.ModTime; got != want {\n \t\t\tt.Errorf(\"i=%d: ModTime: got %v, want %v\", i, got, want)\n \t\t}\n-\t\tif sysh, ok := fi.Sys().(*Header); !ok || sysh != g.h {\n+\t\tif sysh, ok := fi.Sys().(*Header); !ok || sysh != v.h {\n \t\t\tt.Errorf(\"i=%d: Sys didn't return original *Header\", i)\n \t\t}\n \t}"}, {"sha": "4c442e5b82d1977231c83167324dc6cbb39f090e", "filename": "libgo/go/archive/tar/testdata/gnu-incremental.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-incremental.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-incremental.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-incremental.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "b97cc981f29b849420ffb5c249103d2990d3ea20", "filename": "libgo/go/archive/tar/testdata/pax-bad-hdr-file.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-hdr-file.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-hdr-file.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-hdr-file.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "9b22f7e8d94389608bbe94974563ab0327e348e5", "filename": "libgo/go/archive/tar/testdata/pax-bad-mtime-file.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-mtime-file.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-mtime-file.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-bad-mtime-file.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "aed9a8aa48f7ab346d4f1bd7588a8060f5c2d6d2", "filename": "libgo/go/archive/tar/testdata/pax-pos-size-file.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c7910ae9f43b54e32b9facf34c9e96a03626adea", "filename": "libgo/go/archive/tar/testdata/ustar.issue12594.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar.issue12594.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar.issue12594.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar.issue12594.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "52bd748f3b286745455e815c63b6801c3fe06e91", "filename": "libgo/go/archive/tar/testdata/writer-big-long.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "596fb8b9e171f6386daa3792e46ff8359c73af05", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 34, "deletions": 72, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -42,10 +42,6 @@ type Writer struct {\n \tpaxHdrBuff block // buffer to use in writeHeader when writing a PAX header\n }\n \n-type formatter struct {\n-\terr error // Last error seen\n-}\n-\n // NewWriter creates a new Writer writing to w.\n func NewWriter(w io.Writer) *Writer { return &Writer{w: w} }\n \n@@ -71,56 +67,6 @@ func (tw *Writer) Flush() error {\n \treturn tw.err\n }\n \n-// Write s into b, terminating it with a NUL if there is room.\n-func (f *formatter) formatString(b []byte, s string) {\n-\tif len(s) > len(b) {\n-\t\tf.err = ErrFieldTooLong\n-\t\treturn\n-\t}\n-\tascii := toASCII(s)\n-\tcopy(b, ascii)\n-\tif len(ascii) < len(b) {\n-\t\tb[len(ascii)] = 0\n-\t}\n-}\n-\n-// Encode x as an octal ASCII string and write it into b with leading zeros.\n-func (f *formatter) formatOctal(b []byte, x int64) {\n-\ts := strconv.FormatInt(x, 8)\n-\t// leading zeros, but leave room for a NUL.\n-\tfor len(s)+1 < len(b) {\n-\t\ts = \"0\" + s\n-\t}\n-\tf.formatString(b, s)\n-}\n-\n-// fitsInBase256 reports whether x can be encoded into n bytes using base-256\n-// encoding. Unlike octal encoding, base-256 encoding does not require that the\n-// string ends with a NUL character. Thus, all n bytes are available for output.\n-//\n-// If operating in binary mode, this assumes strict GNU binary mode; which means\n-// that the first byte can only be either 0x80 or 0xff. Thus, the first byte is\n-// equivalent to the sign bit in two's complement form.\n-func fitsInBase256(n int, x int64) bool {\n-\tvar binBits = uint(n-1) * 8\n-\treturn n >= 9 || (x >= -1<<binBits && x < 1<<binBits)\n-}\n-\n-// Write x into b, as binary (GNUtar/star extension).\n-func (f *formatter) formatNumeric(b []byte, x int64) {\n-\tif fitsInBase256(len(b), x) {\n-\t\tfor i := len(b) - 1; i >= 0; i-- {\n-\t\t\tb[i] = byte(x)\n-\t\t\tx >>= 8\n-\t\t}\n-\t\tb[0] |= 0x80 // Highest bit indicates binary format\n-\t\treturn\n-\t}\n-\n-\tf.formatOctal(b, 0) // Last resort, just write zero\n-\tf.err = ErrFieldTooLong\n-}\n-\n var (\n \tminTime = time.Unix(0, 0)\n \t// There is room for 11 octal digits (33 bits) of mtime.\n@@ -224,9 +170,41 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \tformatNumeric(ustar.DevMajor(), hdr.Devmajor, paxNone)\n \tformatNumeric(ustar.DevMinor(), hdr.Devminor, paxNone)\n \n+\t// TODO(dsnet): The logic surrounding the prefix field is broken when trying\n+\t// to encode the header as GNU format. The challenge with the current logic\n+\t// is that we are unsure what format we are using at any given moment until\n+\t// we have processed *all* of the fields. The problem is that by the time\n+\t// all fields have been processed, some work has already been done to handle\n+\t// each field under the assumption that it is for one given format or\n+\t// another. In some situations, this causes the Writer to be confused and\n+\t// encode a prefix field when the format being used is GNU. Thus, producing\n+\t// an invalid tar file.\n+\t//\n+\t// As a short-term fix, we disable the logic to use the prefix field, which\n+\t// will force the badly generated GNU files to become encoded as being\n+\t// the PAX format.\n+\t//\n+\t// As an alternative fix, we could hard-code preferPax to be true. However,\n+\t// this is problematic for the following reasons:\n+\t//\t* The preferPax functionality is not tested at all.\n+\t//\t* This can result in headers that try to use both the GNU and PAX\n+\t//\tfeatures at the same time, which is also wrong.\n+\t//\n+\t// The proper fix for this is to use a two-pass method:\n+\t//\t* The first pass simply determines what set of formats can possibly\n+\t//\tencode the given header.\n+\t//\t* The second pass actually encodes the header as that given format\n+\t//\twithout worrying about violating the format.\n+\t//\n+\t// See the following:\n+\t//\thttps://golang.org/issue/12594\n+\t//\thttps://golang.org/issue/17630\n+\t//\thttps://golang.org/issue/9683\n+\tconst usePrefix = false\n+\n \t// try to use a ustar header when only the name is too long\n \t_, paxPathUsed := paxHeaders[paxPath]\n-\tif !tw.preferPax && len(paxHeaders) == 1 && paxPathUsed {\n+\tif usePrefix && !tw.preferPax && len(paxHeaders) == 1 && paxPathUsed {\n \t\tprefix, suffix, ok := splitUSTARPath(hdr.Name)\n \t\tif ok {\n \t\t\t// Since we can encode in USTAR format, disable PAX header.\n@@ -317,7 +295,7 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHeaders map[string]string) erro\n \tvar buf bytes.Buffer\n \n \t// Keys are sorted before writing to body to allow deterministic output.\n-\tvar keys []string\n+\tkeys := make([]string, 0, len(paxHeaders))\n \tfor k := range paxHeaders {\n \t\tkeys = append(keys, k)\n \t}\n@@ -340,22 +318,6 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHeaders map[string]string) erro\n \treturn nil\n }\n \n-// formatPAXRecord formats a single PAX record, prefixing it with the\n-// appropriate length.\n-func formatPAXRecord(k, v string) string {\n-\tconst padding = 3 // Extra padding for ' ', '=', and '\\n'\n-\tsize := len(k) + len(v) + padding\n-\tsize += len(strconv.Itoa(size))\n-\trecord := fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n-\n-\t// Final adjustment if adding size field increased the record size.\n-\tif len(record) != size {\n-\t\tsize = len(record)\n-\t\trecord = fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n-\t}\n-\treturn record\n-}\n-\n // Write writes to the current entry in the tar archive.\n // Write returns the error ErrWriteTooLong if more than\n // hdr.Size bytes are written after WriteHeader."}, {"sha": "d88b8f41ca8a8c49ff916dcba20a27b4ac3b17f8", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 204, "deletions": 279, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"math\"\n \t\"os\"\n \t\"reflect\"\n \t\"sort\"\n@@ -19,176 +18,6 @@ import (\n \t\"time\"\n )\n \n-type writerTestEntry struct {\n-\theader   *Header\n-\tcontents string\n-}\n-\n-type writerTest struct {\n-\tfile    string // filename of expected output\n-\tentries []*writerTestEntry\n-}\n-\n-var writerTests = []*writerTest{\n-\t// The writer test file was produced with this command:\n-\t// tar (GNU tar) 1.26\n-\t//   ln -s small.txt link.txt\n-\t//   tar -b 1 --format=ustar -c -f writer.tar small.txt small2.txt link.txt\n-\t{\n-\t\tfile: \"testdata/writer.tar\",\n-\t\tentries: []*writerTestEntry{\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"small.txt\",\n-\t\t\t\t\tMode:     0640,\n-\t\t\t\t\tUid:      73025,\n-\t\t\t\t\tGid:      5000,\n-\t\t\t\t\tSize:     5,\n-\t\t\t\t\tModTime:  time.Unix(1246508266, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"dsymonds\",\n-\t\t\t\t\tGname:    \"eng\",\n-\t\t\t\t},\n-\t\t\t\tcontents: \"Kilts\",\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"small2.txt\",\n-\t\t\t\t\tMode:     0640,\n-\t\t\t\t\tUid:      73025,\n-\t\t\t\t\tGid:      5000,\n-\t\t\t\t\tSize:     11,\n-\t\t\t\t\tModTime:  time.Unix(1245217492, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"dsymonds\",\n-\t\t\t\t\tGname:    \"eng\",\n-\t\t\t\t},\n-\t\t\t\tcontents: \"Google.com\\n\",\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"link.txt\",\n-\t\t\t\t\tMode:     0777,\n-\t\t\t\t\tUid:      1000,\n-\t\t\t\t\tGid:      1000,\n-\t\t\t\t\tSize:     0,\n-\t\t\t\t\tModTime:  time.Unix(1314603082, 0),\n-\t\t\t\t\tTypeflag: '2',\n-\t\t\t\t\tLinkname: \"small.txt\",\n-\t\t\t\t\tUname:    \"strings\",\n-\t\t\t\t\tGname:    \"strings\",\n-\t\t\t\t},\n-\t\t\t\t// no contents\n-\t\t\t},\n-\t\t},\n-\t},\n-\t// The truncated test file was produced using these commands:\n-\t//   dd if=/dev/zero bs=1048576 count=16384 > /tmp/16gig.txt\n-\t//   tar -b 1 -c -f- /tmp/16gig.txt | dd bs=512 count=8 > writer-big.tar\n-\t{\n-\t\tfile: \"testdata/writer-big.tar\",\n-\t\tentries: []*writerTestEntry{\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"tmp/16gig.txt\",\n-\t\t\t\t\tMode:     0640,\n-\t\t\t\t\tUid:      73025,\n-\t\t\t\t\tGid:      5000,\n-\t\t\t\t\tSize:     16 << 30,\n-\t\t\t\t\tModTime:  time.Unix(1254699560, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"dsymonds\",\n-\t\t\t\t\tGname:    \"eng\",\n-\t\t\t\t},\n-\t\t\t\t// fake contents\n-\t\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n-\t\t\t},\n-\t\t},\n-\t},\n-\t// The truncated test file was produced using these commands:\n-\t//   dd if=/dev/zero bs=1048576 count=16384 > (longname/)*15 /16gig.txt\n-\t//   tar -b 1 -c -f- (longname/)*15 /16gig.txt | dd bs=512 count=8 > writer-big-long.tar\n-\t{\n-\t\tfile: \"testdata/writer-big-long.tar\",\n-\t\tentries: []*writerTestEntry{\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"16gig.txt\",\n-\t\t\t\t\tMode:     0644,\n-\t\t\t\t\tUid:      1000,\n-\t\t\t\t\tGid:      1000,\n-\t\t\t\t\tSize:     16 << 30,\n-\t\t\t\t\tModTime:  time.Unix(1399583047, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"guillaume\",\n-\t\t\t\t\tGname:    \"guillaume\",\n-\t\t\t\t},\n-\t\t\t\t// fake contents\n-\t\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n-\t\t\t},\n-\t\t},\n-\t},\n-\t// This file was produced using gnu tar 1.17\n-\t// gnutar  -b 4 --format=ustar (longname/)*15 + file.txt\n-\t{\n-\t\tfile: \"testdata/ustar.tar\",\n-\t\tentries: []*writerTestEntry{\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"file.txt\",\n-\t\t\t\t\tMode:     0644,\n-\t\t\t\t\tUid:      0765,\n-\t\t\t\t\tGid:      024,\n-\t\t\t\t\tSize:     06,\n-\t\t\t\t\tModTime:  time.Unix(1360135598, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"shane\",\n-\t\t\t\t\tGname:    \"staff\",\n-\t\t\t\t},\n-\t\t\t\tcontents: \"hello\\n\",\n-\t\t\t},\n-\t\t},\n-\t},\n-\t// This file was produced using gnu tar 1.26\n-\t// echo \"Slartibartfast\" > file.txt\n-\t// ln file.txt hard.txt\n-\t// tar -b 1 --format=ustar -c -f hardlink.tar file.txt hard.txt\n-\t{\n-\t\tfile: \"testdata/hardlink.tar\",\n-\t\tentries: []*writerTestEntry{\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"file.txt\",\n-\t\t\t\t\tMode:     0644,\n-\t\t\t\t\tUid:      1000,\n-\t\t\t\t\tGid:      100,\n-\t\t\t\t\tSize:     15,\n-\t\t\t\t\tModTime:  time.Unix(1425484303, 0),\n-\t\t\t\t\tTypeflag: '0',\n-\t\t\t\t\tUname:    \"vbatts\",\n-\t\t\t\t\tGname:    \"users\",\n-\t\t\t\t},\n-\t\t\t\tcontents: \"Slartibartfast\\n\",\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\theader: &Header{\n-\t\t\t\t\tName:     \"hard.txt\",\n-\t\t\t\t\tMode:     0644,\n-\t\t\t\t\tUid:      1000,\n-\t\t\t\t\tGid:      100,\n-\t\t\t\t\tSize:     0,\n-\t\t\t\t\tModTime:  time.Unix(1425484303, 0),\n-\t\t\t\t\tTypeflag: '1',\n-\t\t\t\t\tLinkname: \"file.txt\",\n-\t\t\t\t\tUname:    \"vbatts\",\n-\t\t\t\t\tGname:    \"users\",\n-\t\t\t\t},\n-\t\t\t\t// no contents\n-\t\t\t},\n-\t\t},\n-\t},\n-}\n-\n // Render byte array in a two-character hexadecimal string, spaced for easy visual inspection.\n func bytestr(offset int, b []byte) string {\n \tconst rowLen = 32\n@@ -228,9 +57,168 @@ func bytediff(a []byte, b []byte) string {\n }\n \n func TestWriter(t *testing.T) {\n+\ttype entry struct {\n+\t\theader   *Header\n+\t\tcontents string\n+\t}\n+\n+\tvectors := []struct {\n+\t\tfile    string // filename of expected output\n+\t\tentries []*entry\n+\t}{{\n+\t\t// The writer test file was produced with this command:\n+\t\t// tar (GNU tar) 1.26\n+\t\t//   ln -s small.txt link.txt\n+\t\t//   tar -b 1 --format=ustar -c -f writer.tar small.txt small2.txt link.txt\n+\t\tfile: \"testdata/writer.tar\",\n+\t\tentries: []*entry{{\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"small.txt\",\n+\t\t\t\tMode:     0640,\n+\t\t\t\tUid:      73025,\n+\t\t\t\tGid:      5000,\n+\t\t\t\tSize:     5,\n+\t\t\t\tModTime:  time.Unix(1246508266, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"dsymonds\",\n+\t\t\t\tGname:    \"eng\",\n+\t\t\t},\n+\t\t\tcontents: \"Kilts\",\n+\t\t}, {\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"small2.txt\",\n+\t\t\t\tMode:     0640,\n+\t\t\t\tUid:      73025,\n+\t\t\t\tGid:      5000,\n+\t\t\t\tSize:     11,\n+\t\t\t\tModTime:  time.Unix(1245217492, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"dsymonds\",\n+\t\t\t\tGname:    \"eng\",\n+\t\t\t},\n+\t\t\tcontents: \"Google.com\\n\",\n+\t\t}, {\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"link.txt\",\n+\t\t\t\tMode:     0777,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      1000,\n+\t\t\t\tSize:     0,\n+\t\t\t\tModTime:  time.Unix(1314603082, 0),\n+\t\t\t\tTypeflag: '2',\n+\t\t\t\tLinkname: \"small.txt\",\n+\t\t\t\tUname:    \"strings\",\n+\t\t\t\tGname:    \"strings\",\n+\t\t\t},\n+\t\t\t// no contents\n+\t\t}},\n+\t}, {\n+\t\t// The truncated test file was produced using these commands:\n+\t\t//   dd if=/dev/zero bs=1048576 count=16384 > /tmp/16gig.txt\n+\t\t//   tar -b 1 -c -f- /tmp/16gig.txt | dd bs=512 count=8 > writer-big.tar\n+\t\tfile: \"testdata/writer-big.tar\",\n+\t\tentries: []*entry{{\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"tmp/16gig.txt\",\n+\t\t\t\tMode:     0640,\n+\t\t\t\tUid:      73025,\n+\t\t\t\tGid:      5000,\n+\t\t\t\tSize:     16 << 30,\n+\t\t\t\tModTime:  time.Unix(1254699560, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"dsymonds\",\n+\t\t\t\tGname:    \"eng\",\n+\t\t\t},\n+\t\t\t// fake contents\n+\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n+\t\t}},\n+\t}, {\n+\t\t// This truncated file was produced using this library.\n+\t\t// It was verified to work with GNU tar 1.27.1 and BSD tar 3.1.2.\n+\t\t//  dd if=/dev/zero bs=1G count=16 >> writer-big-long.tar\n+\t\t//  gnutar -xvf writer-big-long.tar\n+\t\t//  bsdtar -xvf writer-big-long.tar\n+\t\t//\n+\t\t// This file is in PAX format.\n+\t\tfile: \"testdata/writer-big-long.tar\",\n+\t\tentries: []*entry{{\n+\t\t\theader: &Header{\n+\t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"16gig.txt\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      1000,\n+\t\t\t\tSize:     16 << 30,\n+\t\t\t\tModTime:  time.Unix(1399583047, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"guillaume\",\n+\t\t\t\tGname:    \"guillaume\",\n+\t\t\t},\n+\t\t\t// fake contents\n+\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n+\t\t}},\n+\t}, {\n+\t\t// TODO(dsnet): The Writer output should match the following file.\n+\t\t// To fix an issue (see https://golang.org/issue/12594), we disabled\n+\t\t// prefix support, which alters the generated output.\n+\t\t/*\n+\t\t\t// This file was produced using gnu tar 1.17\n+\t\t\t// gnutar  -b 4 --format=ustar (longname/)*15 + file.txt\n+\t\t\tfile: \"testdata/ustar.tar\"\n+\t\t*/\n+\t\tfile: \"testdata/ustar.issue12594.tar\", // This is a valid tar file, but not expected\n+\t\tentries: []*entry{{\n+\t\t\theader: &Header{\n+\t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"file.txt\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      0765,\n+\t\t\t\tGid:      024,\n+\t\t\t\tSize:     06,\n+\t\t\t\tModTime:  time.Unix(1360135598, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"shane\",\n+\t\t\t\tGname:    \"staff\",\n+\t\t\t},\n+\t\t\tcontents: \"hello\\n\",\n+\t\t}},\n+\t}, {\n+\t\t// This file was produced using gnu tar 1.26\n+\t\t// echo \"Slartibartfast\" > file.txt\n+\t\t// ln file.txt hard.txt\n+\t\t// tar -b 1 --format=ustar -c -f hardlink.tar file.txt hard.txt\n+\t\tfile: \"testdata/hardlink.tar\",\n+\t\tentries: []*entry{{\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"file.txt\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      100,\n+\t\t\t\tSize:     15,\n+\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t\tTypeflag: '0',\n+\t\t\t\tUname:    \"vbatts\",\n+\t\t\t\tGname:    \"users\",\n+\t\t\t},\n+\t\t\tcontents: \"Slartibartfast\\n\",\n+\t\t}, {\n+\t\t\theader: &Header{\n+\t\t\t\tName:     \"hard.txt\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      100,\n+\t\t\t\tSize:     0,\n+\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t\tTypeflag: '1',\n+\t\t\t\tLinkname: \"file.txt\",\n+\t\t\t\tUname:    \"vbatts\",\n+\t\t\t\tGname:    \"users\",\n+\t\t\t},\n+\t\t\t// no contents\n+\t\t}},\n+\t}}\n+\n testLoop:\n-\tfor i, test := range writerTests {\n-\t\texpected, err := ioutil.ReadFile(test.file)\n+\tfor i, v := range vectors {\n+\t\texpected, err := ioutil.ReadFile(v.file)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"test %d: Unexpected error: %v\", i, err)\n \t\t\tcontinue\n@@ -239,7 +227,7 @@ testLoop:\n \t\tbuf := new(bytes.Buffer)\n \t\ttw := NewWriter(iotest.TruncateWriter(buf, 4<<10)) // only catch the first 4 KB\n \t\tbig := false\n-\t\tfor j, entry := range test.entries {\n+\t\tfor j, entry := range v.entries {\n \t\t\tbig = big || entry.header.Size > 1<<10\n \t\t\tif err := tw.WriteHeader(entry.header); err != nil {\n \t\t\t\tt.Errorf(\"test %d, entry %d: Failed writing header: %v\", i, j, err)\n@@ -576,9 +564,9 @@ func TestWriteAfterClose(t *testing.T) {\n }\n \n func TestSplitUSTARPath(t *testing.T) {\n-\tvar sr = strings.Repeat\n+\tsr := strings.Repeat\n \n-\tvar vectors = []struct {\n+\tvectors := []struct {\n \t\tinput  string // Input path\n \t\tprefix string // Expected output prefix\n \t\tsuffix string // Expected output suffix\n@@ -609,114 +597,51 @@ func TestSplitUSTARPath(t *testing.T) {\n \t}\n }\n \n-func TestFormatPAXRecord(t *testing.T) {\n-\tvar medName = strings.Repeat(\"CD\", 50)\n-\tvar longName = strings.Repeat(\"AB\", 100)\n-\n-\tvar vectors = []struct {\n-\t\tinputKey string\n-\t\tinputVal string\n-\t\toutput   string\n-\t}{\n-\t\t{\"k\", \"v\", \"6 k=v\\n\"},\n-\t\t{\"path\", \"/etc/hosts\", \"19 path=/etc/hosts\\n\"},\n-\t\t{\"path\", longName, \"210 path=\" + longName + \"\\n\"},\n-\t\t{\"path\", medName, \"110 path=\" + medName + \"\\n\"},\n-\t\t{\"foo\", \"ba\", \"9 foo=ba\\n\"},\n-\t\t{\"foo\", \"bar\", \"11 foo=bar\\n\"},\n-\t\t{\"foo\", \"b=\\nar=\\n==\\x00\", \"18 foo=b=\\nar=\\n==\\x00\\n\"},\n-\t\t{\"foo\", \"hello9 foo=ba\\nworld\", \"27 foo=hello9 foo=ba\\nworld\\n\"},\n-\t\t{\"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", \"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\n\"},\n-\t\t{\"\\x00hello\", \"\\x00world\", \"17 \\x00hello=\\x00world\\n\"},\n-\t}\n-\n-\tfor _, v := range vectors {\n-\t\toutput := formatPAXRecord(v.inputKey, v.inputVal)\n-\t\tif output != v.output {\n-\t\t\tt.Errorf(\"formatPAXRecord(%q, %q): got %q, want %q\",\n-\t\t\t\tv.inputKey, v.inputVal, output, v.output)\n+// TestIssue12594 tests that the Writer does not attempt to populate the prefix\n+// field when encoding a header in the GNU format. The prefix field is valid\n+// in USTAR and PAX, but not GNU.\n+func TestIssue12594(t *testing.T) {\n+\tnames := []string{\n+\t\t\"0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15/16/17/18/19/20/21/22/23/24/25/26/27/28/29/30/file.txt\",\n+\t\t\"0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15/16/17/18/19/20/21/22/23/24/25/26/27/28/29/30/31/32/33/file.txt\",\n+\t\t\"0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15/16/17/18/19/20/21/22/23/24/25/26/27/28/29/30/31/32/333/file.txt\",\n+\t\t\"0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15/16/17/18/19/20/21/22/23/24/25/26/27/28/29/30/31/32/33/34/35/36/37/38/39/40/file.txt\",\n+\t\t\"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000/file.txt\",\n+\t\t\"/home/support/.openoffice.org/3/user/uno_packages/cache/registry/com.sun.star.comp.deployment.executable.PackageRegistryBackend\",\n+\t}\n+\n+\tfor i, name := range names {\n+\t\tvar b bytes.Buffer\n+\n+\t\ttw := NewWriter(&b)\n+\t\tif err := tw.WriteHeader(&Header{\n+\t\t\tName: name,\n+\t\t\tUid:  1 << 25, // Prevent USTAR format\n+\t\t}); err != nil {\n+\t\t\tt.Errorf(\"test %d, unexpected WriteHeader error: %v\", i, err)\n \t\t}\n-\t}\n-}\n-\n-func TestFitsInBase256(t *testing.T) {\n-\tvar vectors = []struct {\n-\t\tinput int64\n-\t\twidth int\n-\t\tok    bool\n-\t}{\n-\t\t{+1, 8, true},\n-\t\t{0, 8, true},\n-\t\t{-1, 8, true},\n-\t\t{1 << 56, 8, false},\n-\t\t{(1 << 56) - 1, 8, true},\n-\t\t{-1 << 56, 8, true},\n-\t\t{(-1 << 56) - 1, 8, false},\n-\t\t{121654, 8, true},\n-\t\t{-9849849, 8, true},\n-\t\t{math.MaxInt64, 9, true},\n-\t\t{0, 9, true},\n-\t\t{math.MinInt64, 9, true},\n-\t\t{math.MaxInt64, 12, true},\n-\t\t{0, 12, true},\n-\t\t{math.MinInt64, 12, true},\n-\t}\n-\n-\tfor _, v := range vectors {\n-\t\tok := fitsInBase256(v.width, v.input)\n-\t\tif ok != v.ok {\n-\t\t\tt.Errorf(\"checkNumeric(%d, %d): got %v, want %v\", v.input, v.width, ok, v.ok)\n+\t\tif err := tw.Close(); err != nil {\n+\t\t\tt.Errorf(\"test %d, unexpected Close error: %v\", i, err)\n \t\t}\n-\t}\n-}\n \n-func TestFormatNumeric(t *testing.T) {\n-\tvar vectors = []struct {\n-\t\tinput  int64\n-\t\toutput string\n-\t\tok     bool\n-\t}{\n-\t\t// Test base-256 (binary) encoded values.\n-\t\t{-1, \"\\xff\", true},\n-\t\t{-1, \"\\xff\\xff\", true},\n-\t\t{-1, \"\\xff\\xff\\xff\", true},\n-\t\t{(1 << 0), \"0\", false},\n-\t\t{(1 << 8) - 1, \"\\x80\\xff\", true},\n-\t\t{(1 << 8), \"0\\x00\", false},\n-\t\t{(1 << 16) - 1, \"\\x80\\xff\\xff\", true},\n-\t\t{(1 << 16), \"00\\x00\", false},\n-\t\t{-1 * (1 << 0), \"\\xff\", true},\n-\t\t{-1*(1<<0) - 1, \"0\", false},\n-\t\t{-1 * (1 << 8), \"\\xff\\x00\", true},\n-\t\t{-1*(1<<8) - 1, \"0\\x00\", false},\n-\t\t{-1 * (1 << 16), \"\\xff\\x00\\x00\", true},\n-\t\t{-1*(1<<16) - 1, \"00\\x00\", false},\n-\t\t{537795476381659745, \"0000000\\x00\", false},\n-\t\t{537795476381659745, \"\\x80\\x00\\x00\\x00\\x07\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", true},\n-\t\t{-615126028225187231, \"0000000\\x00\", false},\n-\t\t{-615126028225187231, \"\\xff\\xff\\xff\\xff\\xf7\\x76\\xa2\\x22\\xeb\\x8a\\x72\\x61\", true},\n-\t\t{math.MaxInt64, \"0000000\\x00\", false},\n-\t\t{math.MaxInt64, \"\\x80\\x00\\x00\\x00\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", true},\n-\t\t{math.MinInt64, \"0000000\\x00\", false},\n-\t\t{math.MinInt64, \"\\xff\\xff\\xff\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", true},\n-\t\t{math.MaxInt64, \"\\x80\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", true},\n-\t\t{math.MinInt64, \"\\xff\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", true},\n-\t}\n+\t\t// The prefix field should never appear in the GNU format.\n+\t\tvar blk block\n+\t\tcopy(blk[:], b.Bytes())\n+\t\tprefix := string(blk.USTAR().Prefix())\n+\t\tif i := strings.IndexByte(prefix, 0); i >= 0 {\n+\t\t\tprefix = prefix[:i] // Truncate at the NUL terminator\n+\t\t}\n+\t\tif blk.GetFormat() == formatGNU && len(prefix) > 0 && strings.HasPrefix(name, prefix) {\n+\t\t\tt.Errorf(\"test %d, found prefix in GNU format: %s\", i, prefix)\n+\t\t}\n \n-\tfor _, v := range vectors {\n-\t\tvar f formatter\n-\t\toutput := make([]byte, len(v.output))\n-\t\tf.formatNumeric(output, v.input)\n-\t\tok := (f.err == nil)\n-\t\tif ok != v.ok {\n-\t\t\tif v.ok {\n-\t\t\t\tt.Errorf(\"formatNumeric(%d): got formatting failure, want success\", v.input)\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"formatNumeric(%d): got formatting success, want failure\", v.input)\n-\t\t\t}\n+\t\ttr := NewReader(&b)\n+\t\thdr, err := tr.Next()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"test %d, unexpected Next error: %v\", i, err)\n \t\t}\n-\t\tif string(output) != v.output {\n-\t\t\tt.Errorf(\"formatNumeric(%d): got %q, want %q\", v.input, output, v.output)\n+\t\tif hdr.Name != name {\n+\t\t\tt.Errorf(\"test %d, hdr.Name = %s, want %s\", i, hdr.Name, name)\n \t\t}\n \t}\n }"}, {"sha": "8940e25560e4501703a739e1321421deba2cffec", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -22,6 +22,10 @@ type Writer struct {\n \tlast        *fileWriter\n \tclosed      bool\n \tcompressors map[uint16]Compressor\n+\n+\t// testHookCloseSizeOffset if non-nil is called with the size\n+\t// of offset of the central directory at Close.\n+\ttestHookCloseSizeOffset func(size, offset uint64)\n }\n \n type header struct {\n@@ -98,6 +102,7 @@ func (w *Writer) Close() error {\n \t\t\tb.uint32(h.CompressedSize)\n \t\t\tb.uint32(h.UncompressedSize)\n \t\t}\n+\n \t\tb.uint16(uint16(len(h.Name)))\n \t\tb.uint16(uint16(len(h.Extra)))\n \t\tb.uint16(uint16(len(h.Comment)))\n@@ -127,7 +132,11 @@ func (w *Writer) Close() error {\n \tsize := uint64(end - start)\n \toffset := uint64(start)\n \n-\tif records > uint16max || size > uint32max || offset > uint32max {\n+\tif f := w.testHookCloseSizeOffset; f != nil {\n+\t\tf(size, offset)\n+\t}\n+\n+\tif records >= uint16max || size >= uint32max || offset >= uint32max {\n \t\tvar buf [directory64EndLen + directory64LocLen]byte\n \t\tb := writeBuf(buf[:])\n "}, {"sha": "57edb2cabf4c91bb30940e881ef0589e020b50f8", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 300, "deletions": 24, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -8,8 +8,10 @@ package zip\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"hash\"\n+\t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -232,6 +234,7 @@ func TestZip64(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"slow test; skipping\")\n \t}\n+\tt.Parallel()\n \tconst size = 1 << 32 // before the \"END\\n\" part\n \tbuf := testZip64(t, size)\n \ttestZip64DirectoryRecordLength(buf, t)\n@@ -241,6 +244,7 @@ func TestZip64EdgeCase(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"slow test; skipping\")\n \t}\n+\tt.Parallel()\n \t// Test a zip file with uncompressed size 0xFFFFFFFF.\n \t// That's the magic marker for a 64-bit file, so even though\n \t// it fits in a 32-bit field we must use the 64-bit field.\n@@ -251,6 +255,256 @@ func TestZip64EdgeCase(t *testing.T) {\n \ttestZip64DirectoryRecordLength(buf, t)\n }\n \n+// Tests that we generate a zip64 file if the the directory at offset\n+// 0xFFFFFFFF, but not before.\n+func TestZip64DirectoryOffset(t *testing.T) {\n+\tif testing.Short() && race.Enabled {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\tt.Parallel()\n+\tconst filename = \"huge.txt\"\n+\tgen := func(wantOff uint64) func(*Writer) {\n+\t\treturn func(w *Writer) {\n+\t\t\tw.testHookCloseSizeOffset = func(size, off uint64) {\n+\t\t\t\tif off != wantOff {\n+\t\t\t\t\tt.Errorf(\"central directory offset = %d (%x); want %d\", off, off, wantOff)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tf, err := w.CreateHeader(&FileHeader{\n+\t\t\t\tName:   filename,\n+\t\t\t\tMethod: Store,\n+\t\t\t})\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tf.(*fileWriter).crc32 = fakeHash32{}\n+\t\t\tsize := wantOff - fileHeaderLen - uint64(len(filename)) - dataDescriptorLen\n+\t\t\tif _, err := io.CopyN(f, zeros{}, int64(size)); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tt.Run(\"uint32max-2_NoZip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif generatesZip64(t, gen(0xfffffffe)) {\n+\t\t\tt.Error(\"unexpected zip64\")\n+\t\t}\n+\t})\n+\tt.Run(\"uint32max-1_Zip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif !generatesZip64(t, gen(0xffffffff)) {\n+\t\t\tt.Error(\"expected zip64\")\n+\t\t}\n+\t})\n+}\n+\n+// At 16k records, we need to generate a zip64 file.\n+func TestZip64ManyRecords(t *testing.T) {\n+\tif testing.Short() && race.Enabled {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\tt.Parallel()\n+\tgen := func(numRec int) func(*Writer) {\n+\t\treturn func(w *Writer) {\n+\t\t\tfor i := 0; i < numRec; i++ {\n+\t\t\t\t_, err := w.CreateHeader(&FileHeader{\n+\t\t\t\t\tName:   \"a.txt\",\n+\t\t\t\t\tMethod: Store,\n+\t\t\t\t})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// 16k-1 records shouldn't make a zip64:\n+\tt.Run(\"uint16max-1_NoZip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif generatesZip64(t, gen(0xfffe)) {\n+\t\t\tt.Error(\"unexpected zip64\")\n+\t\t}\n+\t})\n+\t// 16k records should make a zip64:\n+\tt.Run(\"uint16max_Zip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif !generatesZip64(t, gen(0xffff)) {\n+\t\t\tt.Error(\"expected zip64\")\n+\t\t}\n+\t})\n+}\n+\n+// suffixSaver is an io.Writer & io.ReaderAt that remembers the last 0\n+// to 'keep' bytes of data written to it. Call Suffix to get the\n+// suffix bytes.\n+type suffixSaver struct {\n+\tkeep  int\n+\tbuf   []byte\n+\tstart int\n+\tsize  int64\n+}\n+\n+func (ss *suffixSaver) Size() int64 { return ss.size }\n+\n+var errDiscardedBytes = errors.New(\"ReadAt of discarded bytes\")\n+\n+func (ss *suffixSaver) ReadAt(p []byte, off int64) (n int, err error) {\n+\tback := ss.size - off\n+\tif back > int64(ss.keep) {\n+\t\treturn 0, errDiscardedBytes\n+\t}\n+\tsuf := ss.Suffix()\n+\tn = copy(p, suf[len(suf)-int(back):])\n+\tif n != len(p) {\n+\t\terr = io.EOF\n+\t}\n+\treturn\n+}\n+\n+func (ss *suffixSaver) Suffix() []byte {\n+\tif len(ss.buf) < ss.keep {\n+\t\treturn ss.buf\n+\t}\n+\tbuf := make([]byte, ss.keep)\n+\tn := copy(buf, ss.buf[ss.start:])\n+\tcopy(buf[n:], ss.buf[:])\n+\treturn buf\n+}\n+\n+func (ss *suffixSaver) Write(p []byte) (n int, err error) {\n+\tn = len(p)\n+\tss.size += int64(len(p))\n+\tif len(ss.buf) < ss.keep {\n+\t\tspace := ss.keep - len(ss.buf)\n+\t\tadd := len(p)\n+\t\tif add > space {\n+\t\t\tadd = space\n+\t\t}\n+\t\tss.buf = append(ss.buf, p[:add]...)\n+\t\tp = p[add:]\n+\t}\n+\tfor len(p) > 0 {\n+\t\tn := copy(ss.buf[ss.start:], p)\n+\t\tp = p[n:]\n+\t\tss.start += n\n+\t\tif ss.start == ss.keep {\n+\t\t\tss.start = 0\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// generatesZip64 reports whether f wrote a zip64 file.\n+// f is also responsible for closing w.\n+func generatesZip64(t *testing.T, f func(w *Writer)) bool {\n+\tss := &suffixSaver{keep: 10 << 20}\n+\tw := NewWriter(ss)\n+\tf(w)\n+\treturn suffixIsZip64(t, ss)\n+}\n+\n+type sizedReaderAt interface {\n+\tio.ReaderAt\n+\tSize() int64\n+}\n+\n+func suffixIsZip64(t *testing.T, zip sizedReaderAt) bool {\n+\td := make([]byte, 1024)\n+\tif _, err := zip.ReadAt(d, zip.Size()-int64(len(d))); err != nil {\n+\t\tt.Fatalf(\"ReadAt: %v\", err)\n+\t}\n+\n+\tsigOff := findSignatureInBlock(d)\n+\tif sigOff == -1 {\n+\t\tt.Errorf(\"failed to find signature in block\")\n+\t\treturn false\n+\t}\n+\n+\tdirOff, err := findDirectory64End(zip, zip.Size()-int64(len(d))+int64(sigOff))\n+\tif err != nil {\n+\t\tt.Fatalf(\"findDirectory64End: %v\", err)\n+\t}\n+\tif dirOff == -1 {\n+\t\treturn false\n+\t}\n+\n+\td = make([]byte, directory64EndLen)\n+\tif _, err := zip.ReadAt(d, dirOff); err != nil {\n+\t\tt.Fatalf(\"ReadAt(off=%d): %v\", dirOff, err)\n+\t}\n+\n+\tb := readBuf(d)\n+\tif sig := b.uint32(); sig != directory64EndSignature {\n+\t\treturn false\n+\t}\n+\n+\tsize := b.uint64()\n+\tif size != directory64EndLen-12 {\n+\t\tt.Errorf(\"expected length of %d, got %d\", directory64EndLen-12, size)\n+\t}\n+\treturn true\n+}\n+\n+// Zip64 is required if the total size of the records is uint32max.\n+func TestZip64LargeDirectory(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\tt.Parallel()\n+\t// gen returns a func that writes a zip with a wantLen bytes\n+\t// of central directory.\n+\tgen := func(wantLen int64) func(*Writer) {\n+\t\treturn func(w *Writer) {\n+\t\t\tw.testHookCloseSizeOffset = func(size, off uint64) {\n+\t\t\t\tif size != uint64(wantLen) {\n+\t\t\t\t\tt.Errorf(\"Close central directory size = %d; want %d\", size, wantLen)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tuint16string := strings.Repeat(\".\", uint16max)\n+\t\t\tremain := wantLen\n+\t\t\tfor remain > 0 {\n+\t\t\t\tcommentLen := int(uint16max) - directoryHeaderLen - 1\n+\t\t\t\tthisRecLen := directoryHeaderLen + int(uint16max) + commentLen\n+\t\t\t\tif int64(thisRecLen) > remain {\n+\t\t\t\t\tremove := thisRecLen - int(remain)\n+\t\t\t\t\tcommentLen -= remove\n+\t\t\t\t\tthisRecLen -= remove\n+\t\t\t\t}\n+\t\t\t\tremain -= int64(thisRecLen)\n+\t\t\t\tf, err := w.CreateHeader(&FileHeader{\n+\t\t\t\t\tName:    uint16string,\n+\t\t\t\t\tComment: uint16string[:commentLen],\n+\t\t\t\t})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"CreateHeader: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tf.(*fileWriter).crc32 = fakeHash32{}\n+\t\t\t}\n+\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\tt.Fatalf(\"Close: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tt.Run(\"uint32max-1_NoZip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif generatesZip64(t, gen(uint32max-1)) {\n+\t\t\tt.Error(\"unexpected zip64\")\n+\t\t}\n+\t})\n+\tt.Run(\"uint32max_HasZip64\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tif !generatesZip64(t, gen(uint32max)) {\n+\t\t\tt.Error(\"expected zip64\")\n+\t\t}\n+\t})\n+}\n+\n func testZip64(t testing.TB, size int64) *rleBuffer {\n \tconst chunkSize = 1024\n \tchunks := int(size / chunkSize)\n@@ -339,30 +593,8 @@ func testZip64(t testing.TB, size int64) *rleBuffer {\n \n // Issue 9857\n func testZip64DirectoryRecordLength(buf *rleBuffer, t *testing.T) {\n-\td := make([]byte, 1024)\n-\tif _, err := buf.ReadAt(d, buf.Size()-int64(len(d))); err != nil {\n-\t\tt.Fatal(\"read:\", err)\n-\t}\n-\n-\tsigOff := findSignatureInBlock(d)\n-\tdirOff, err := findDirectory64End(buf, buf.Size()-int64(len(d))+int64(sigOff))\n-\tif err != nil {\n-\t\tt.Fatal(\"findDirectory64End:\", err)\n-\t}\n-\n-\td = make([]byte, directory64EndLen)\n-\tif _, err := buf.ReadAt(d, dirOff); err != nil {\n-\t\tt.Fatal(\"read:\", err)\n-\t}\n-\n-\tb := readBuf(d)\n-\tif sig := b.uint32(); sig != directory64EndSignature {\n-\t\tt.Fatalf(\"Expected directory64EndSignature (%d), got %d\", directory64EndSignature, sig)\n-\t}\n-\n-\tsize := b.uint64()\n-\tif size != directory64EndLen-12 {\n-\t\tt.Fatalf(\"Expected length of %d, got %d\", directory64EndLen-12, size)\n+\tif !suffixIsZip64(t, buf) {\n+\t\tt.Fatal(\"not a zip64\")\n \t}\n }\n \n@@ -448,3 +680,47 @@ func BenchmarkZip64Test(b *testing.B) {\n \t\ttestZip64(b, 1<<26)\n \t}\n }\n+\n+func TestSuffixSaver(t *testing.T) {\n+\tconst keep = 10\n+\tss := &suffixSaver{keep: keep}\n+\tss.Write([]byte(\"abc\"))\n+\tif got := string(ss.Suffix()); got != \"abc\" {\n+\t\tt.Errorf(\"got = %q; want abc\", got)\n+\t}\n+\tss.Write([]byte(\"defghijklmno\"))\n+\tif got := string(ss.Suffix()); got != \"fghijklmno\" {\n+\t\tt.Errorf(\"got = %q; want fghijklmno\", got)\n+\t}\n+\tif got, want := ss.Size(), int64(len(\"abc\")+len(\"defghijklmno\")); got != want {\n+\t\tt.Errorf(\"Size = %d; want %d\", got, want)\n+\t}\n+\tbuf := make([]byte, ss.Size())\n+\tfor off := int64(0); off < ss.Size(); off++ {\n+\t\tfor size := 1; size <= int(ss.Size()-off); size++ {\n+\t\t\treadBuf := buf[:size]\n+\t\t\tn, err := ss.ReadAt(readBuf, off)\n+\t\t\tif off < ss.Size()-keep {\n+\t\t\t\tif err != errDiscardedBytes {\n+\t\t\t\t\tt.Errorf(\"off %d, size %d = %v, %v (%q); want errDiscardedBytes\", off, size, n, err, readBuf[:n])\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twant := \"abcdefghijklmno\"[off : off+int64(size)]\n+\t\t\tgot := string(readBuf[:n])\n+\t\t\tif err != nil || got != want {\n+\t\t\t\tt.Errorf(\"off %d, size %d = %v, %v (%q); want %q\", off, size, n, err, got, want)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+type zeros struct{}\n+\n+func (zeros) Read(p []byte) (int, error) {\n+\tfor i := range p {\n+\t\tp[i] = 0\n+\t}\n+\treturn len(p), nil\n+}"}, {"sha": "e1e8fb2272076e7f29550e8dc1b23e345471a55f", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -206,10 +206,18 @@ func (b *Reader) Read(p []byte) (n int, err error) {\n \t\t\t}\n \t\t\treturn n, b.readErr()\n \t\t}\n-\t\tb.fill() // buffer is empty\n-\t\tif b.r == b.w {\n+\t\t// One read.\n+\t\t// Do not use b.fill, which will loop.\n+\t\tb.r = 0\n+\t\tb.w = 0\n+\t\tn, b.err = b.rd.Read(b.buf)\n+\t\tif n < 0 {\n+\t\t\tpanic(errNegativeRead)\n+\t\t}\n+\t\tif n == 0 {\n \t\t\treturn 0, b.readErr()\n \t\t}\n+\t\tb.w += n\n \t}\n \n \t// copy as much as we can\n@@ -549,11 +557,6 @@ func (b *Writer) Reset(w io.Writer) {\n \n // Flush writes any buffered data to the underlying io.Writer.\n func (b *Writer) Flush() error {\n-\terr := b.flush()\n-\treturn err\n-}\n-\n-func (b *Writer) flush() error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n@@ -596,7 +599,7 @@ func (b *Writer) Write(p []byte) (nn int, err error) {\n \t\t} else {\n \t\t\tn = copy(b.buf[b.n:], p)\n \t\t\tb.n += n\n-\t\t\tb.flush()\n+\t\t\tb.Flush()\n \t\t}\n \t\tnn += n\n \t\tp = p[n:]\n@@ -615,7 +618,7 @@ func (b *Writer) WriteByte(c byte) error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n-\tif b.Available() <= 0 && b.flush() != nil {\n+\tif b.Available() <= 0 && b.Flush() != nil {\n \t\treturn b.err\n \t}\n \tb.buf[b.n] = c\n@@ -638,7 +641,7 @@ func (b *Writer) WriteRune(r rune) (size int, err error) {\n \t}\n \tn := b.Available()\n \tif n < utf8.UTFMax {\n-\t\tif b.flush(); b.err != nil {\n+\t\tif b.Flush(); b.err != nil {\n \t\t\treturn 0, b.err\n \t\t}\n \t\tn = b.Available()\n@@ -663,7 +666,7 @@ func (b *Writer) WriteString(s string) (int, error) {\n \t\tb.n += n\n \t\tnn += n\n \t\ts = s[n:]\n-\t\tb.flush()\n+\t\tb.Flush()\n \t}\n \tif b.err != nil {\n \t\treturn nn, b.err\n@@ -684,7 +687,7 @@ func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \tvar m int\n \tfor {\n \t\tif b.Available() == 0 {\n-\t\t\tif err1 := b.flush(); err1 != nil {\n+\t\t\tif err1 := b.Flush(); err1 != nil {\n \t\t\t\treturn n, err1\n \t\t\t}\n \t\t}\n@@ -708,7 +711,7 @@ func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \tif err == io.EOF {\n \t\t// If we filled the buffer exactly, flush preemptively.\n \t\tif b.Available() == 0 {\n-\t\t\terr = b.flush()\n+\t\t\terr = b.Flush()\n \t\t} else {\n \t\t\terr = nil\n \t\t}"}, {"sha": "ef0f6c834e86230f9f7d63c3dfd407022afdb8a7", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1236,6 +1236,27 @@ func TestWriterReadFromErrNoProgress(t *testing.T) {\n \t}\n }\n \n+func TestReadZero(t *testing.T) {\n+\tfor _, size := range []int{100, 2} {\n+\t\tt.Run(fmt.Sprintf(\"bufsize=%d\", size), func(t *testing.T) {\n+\t\t\tr := io.MultiReader(strings.NewReader(\"abc\"), &emptyThenNonEmptyReader{r: strings.NewReader(\"def\"), n: 1})\n+\t\t\tbr := NewReaderSize(r, size)\n+\t\t\twant := func(s string, wantErr error) {\n+\t\t\t\tp := make([]byte, 50)\n+\t\t\t\tn, err := br.Read(p)\n+\t\t\t\tif err != wantErr || n != len(s) || string(p[:n]) != s {\n+\t\t\t\t\tt.Fatalf(\"read(%d) = %q, %v, want %q, %v\", len(p), string(p[:n]), err, s, wantErr)\n+\t\t\t\t}\n+\t\t\t\tt.Logf(\"read(%d) = %q, %v\", len(p), string(p[:n]), err)\n+\t\t\t}\n+\t\t\twant(\"abc\", nil)\n+\t\t\twant(\"\", nil)\n+\t\t\twant(\"def\", nil)\n+\t\t\twant(\"\", io.EOF)\n+\t\t})\n+\t}\n+}\n+\n func TestReaderReset(t *testing.T) {\n \tr := NewReader(strings.NewReader(\"foo foo\"))\n \tbuf := make([]byte, 3)"}, {"sha": "9f741c983070159906ed59c24a84cd58fbc5ec95", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -199,7 +199,6 @@ func (s *Scanner) Scan() bool {\n \t\t\ts.buf = newBuf\n \t\t\ts.end -= s.start\n \t\t\ts.start = 0\n-\t\t\tcontinue\n \t\t}\n \t\t// Finally we can read some input. Make sure we don't get stuck with\n \t\t// a misbehaving Reader. Officially we don't need to do this, but let's"}, {"sha": "281de0b436883b22d68c207944635c9f44c8a4a3", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -173,8 +173,8 @@ func cap(v Type) int\n //\tspecify a different capacity; it must be no smaller than the\n //\tlength, so make([]int, 0, 10) allocates a slice of length 0 and\n //\tcapacity 10.\n-//\tMap: An initial allocation is made according to the size but the\n-//\tresulting map has length 0. The size may be omitted, in which case\n+//\tMap: An empty map is allocated with enough space to hold the\n+//\tspecified number of elements. The size may be omitted, in which case\n //\ta small starting size is allocated.\n //\tChannel: The channel's buffer is initialized with the specified\n //\tbuffer capacity. If zero, or the size is omitted, the channel is"}, {"sha": "196419dc3da5999ada51eda442a9d06ff8ae04f3", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -15,22 +15,25 @@ import (\n // A Buffer is a variable-sized buffer of bytes with Read and Write methods.\n // The zero value for Buffer is an empty buffer ready to use.\n type Buffer struct {\n-\tbuf       []byte            // contents are the bytes buf[off : len(buf)]\n-\toff       int               // read at &buf[off], write at &buf[len(buf)]\n-\truneBytes [utf8.UTFMax]byte // avoid allocation of slice on each call to WriteRune\n-\tbootstrap [64]byte          // memory to hold first slice; helps small buffers avoid allocation.\n-\tlastRead  readOp            // last read operation, so that Unread* can work correctly.\n+\tbuf       []byte   // contents are the bytes buf[off : len(buf)]\n+\toff       int      // read at &buf[off], write at &buf[len(buf)]\n+\tbootstrap [64]byte // memory to hold first slice; helps small buffers avoid allocation.\n+\tlastRead  readOp   // last read operation, so that Unread* can work correctly.\n }\n \n // The readOp constants describe the last action performed on\n-// the buffer, so that UnreadRune and UnreadByte can\n-// check for invalid usage.\n+// the buffer, so that UnreadRune and UnreadByte can check for\n+// invalid usage. opReadRuneX constants are chosen such that\n+// converted to int they correspond to the rune size that was read.\n type readOp int\n \n const (\n-\topInvalid  readOp = iota // Non-read operation.\n-\topReadRune               // Read rune.\n-\topRead                   // Any other read operation.\n+\topRead      readOp = -1 // Any other read operation.\n+\topInvalid          = 0  // Non-read operation.\n+\topReadRune1        = 1  // Read rune of size 1.\n+\topReadRune2        = 2  // Read rune of size 2.\n+\topReadRune3        = 3  // Read rune of size 3.\n+\topReadRune4        = 4  // Read rune of size 4.\n )\n \n // ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.\n@@ -246,8 +249,10 @@ func (b *Buffer) WriteRune(r rune) (n int, err error) {\n \t\tb.WriteByte(byte(r))\n \t\treturn 1, nil\n \t}\n-\tn = utf8.EncodeRune(b.runeBytes[0:], r)\n-\tb.Write(b.runeBytes[0:n])\n+\tb.lastRead = opInvalid\n+\tm := b.grow(utf8.UTFMax)\n+\tn = utf8.EncodeRune(b.buf[m:m+utf8.UTFMax], r)\n+\tb.buf = b.buf[:m+n]\n \treturn n, nil\n }\n \n@@ -318,14 +323,15 @@ func (b *Buffer) ReadRune() (r rune, size int, err error) {\n \t\tb.Truncate(0)\n \t\treturn 0, 0, io.EOF\n \t}\n-\tb.lastRead = opReadRune\n \tc := b.buf[b.off]\n \tif c < utf8.RuneSelf {\n \t\tb.off++\n+\t\tb.lastRead = opReadRune1\n \t\treturn rune(c), 1, nil\n \t}\n \tr, n := utf8.DecodeRune(b.buf[b.off:])\n \tb.off += n\n+\tb.lastRead = readOp(n)\n \treturn r, n, nil\n }\n \n@@ -335,22 +341,21 @@ func (b *Buffer) ReadRune() (r rune, size int, err error) {\n // it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n func (b *Buffer) UnreadRune() error {\n-\tif b.lastRead != opReadRune {\n+\tif b.lastRead <= opInvalid {\n \t\treturn errors.New(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n \t}\n-\tb.lastRead = opInvalid\n-\tif b.off > 0 {\n-\t\t_, n := utf8.DecodeLastRune(b.buf[0:b.off])\n-\t\tb.off -= n\n+\tif b.off >= int(b.lastRead) {\n+\t\tb.off -= int(b.lastRead)\n \t}\n+\tb.lastRead = opInvalid\n \treturn nil\n }\n \n // UnreadByte unreads the last byte returned by the most recent\n // read operation. If write has happened since the last read, UnreadByte\n // returns an error.\n func (b *Buffer) UnreadByte() error {\n-\tif b.lastRead != opReadRune && b.lastRead != opRead {\n+\tif b.lastRead == opInvalid {\n \t\treturn errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n \t}\n \tb.lastRead = opInvalid"}, {"sha": "b1b85f979af6502c6d546a0e52a6262c6ec871a1", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -514,6 +514,19 @@ func TestBufferGrowth(t *testing.T) {\n \t}\n }\n \n+func BenchmarkWriteRune(b *testing.B) {\n+\tconst n = 4 << 10\n+\tconst r = '\u263a'\n+\tb.SetBytes(int64(n * utf8.RuneLen(r)))\n+\tbuf := NewBuffer(make([]byte, n*utf8.UTFMax))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tbuf.WriteRune(r)\n+\t\t}\n+\t}\n+}\n+\n // From Issue 5154.\n func BenchmarkBufferNotEmptyWriteRead(b *testing.B) {\n \tbuf := make([]byte, 1024)"}, {"sha": "406a38257a74c420266dc013782fd9c91256686f", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 98, "deletions": 48, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -93,37 +93,6 @@ func ContainsRune(b []byte, r rune) bool {\n \treturn IndexRune(b, r) >= 0\n }\n \n-// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n-func Index(s, sep []byte) int {\n-\tn := len(sep)\n-\tif n == 0 {\n-\t\treturn 0\n-\t}\n-\tif n > len(s) {\n-\t\treturn -1\n-\t}\n-\tc := sep[0]\n-\tif n == 1 {\n-\t\treturn IndexByte(s, c)\n-\t}\n-\ti := 0\n-\tt := s[:len(s)-n+1]\n-\tfor i < len(t) {\n-\t\tif t[i] != c {\n-\t\t\to := IndexByte(t[i:], c)\n-\t\t\tif o < 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ti += o\n-\t\t}\n-\t\tif Equal(s[i:i+n], sep) {\n-\t\t\treturn i\n-\t\t}\n-\t\ti++\n-\t}\n-\treturn -1\n-}\n-\n func indexBytePortable(s []byte, c byte) int {\n \tfor i, b := range s {\n \t\tif b == c {\n@@ -161,15 +130,28 @@ func LastIndexByte(s []byte, c byte) int {\n // IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index of the first occurrence in s of the given rune.\n // It returns -1 if rune is not present in s.\n+// If r is utf8.RuneError, it returns the first instance of any\n+// invalid UTF-8 byte sequence.\n func IndexRune(s []byte, r rune) int {\n-\tfor i := 0; i < len(s); {\n-\t\tr1, size := utf8.DecodeRune(s[i:])\n-\t\tif r == r1 {\n-\t\t\treturn i\n+\tswitch {\n+\tcase 0 <= r && r < utf8.RuneSelf:\n+\t\treturn IndexByte(s, byte(r))\n+\tcase r == utf8.RuneError:\n+\t\tfor i := 0; i < len(s); {\n+\t\t\tr1, n := utf8.DecodeRune(s[i:])\n+\t\t\tif r1 == utf8.RuneError {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t\ti += n\n \t\t}\n-\t\ti += size\n+\t\treturn -1\n+\tcase !utf8.ValidRune(r):\n+\t\treturn -1\n+\tdefault:\n+\t\tvar b [utf8.UTFMax]byte\n+\t\tn := utf8.EncodeRune(b[:], r)\n+\t\treturn Index(s, b[:n])\n \t}\n-\treturn -1\n }\n \n // IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\n@@ -178,10 +160,19 @@ func IndexRune(s []byte, r rune) int {\n // point in common.\n func IndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n-\t\tvar r rune\n+\t\tif len(s) > 8 {\n+\t\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n+\t\t\t\tfor i, c := range s {\n+\t\t\t\t\tif as.contains(c) {\n+\t\t\t\t\t\treturn i\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t}\n \t\tvar width int\n \t\tfor i := 0; i < len(s); i += width {\n-\t\t\tr = rune(s[i])\n+\t\t\tr := rune(s[i])\n \t\t\tif r < utf8.RuneSelf {\n \t\t\t\twidth = 1\n \t\t\t} else {\n@@ -203,11 +194,21 @@ func IndexAny(s []byte, chars string) int {\n // there is no code point in common.\n func LastIndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n+\t\tif len(s) > 8 {\n+\t\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n+\t\t\t\tfor i := len(s) - 1; i >= 0; i-- {\n+\t\t\t\t\tif as.contains(s[i]) {\n+\t\t\t\t\t\treturn i\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t}\n \t\tfor i := len(s); i > 0; {\n-\t\t\tr, size := utf8.DecodeLastRune(s[0:i])\n+\t\t\tr, size := utf8.DecodeLastRune(s[:i])\n \t\t\ti -= size\n-\t\t\tfor _, ch := range chars {\n-\t\t\t\tif r == ch {\n+\t\t\tfor _, c := range chars {\n+\t\t\t\tif r == c {\n \t\t\t\t\treturn i\n \t\t\t\t}\n \t\t\t}\n@@ -398,7 +399,20 @@ func Map(mapping func(r rune) rune, s []byte) []byte {\n }\n \n // Repeat returns a new byte slice consisting of count copies of b.\n+//\n+// It panics if count is negative or if\n+// the result of (len(b) * count) overflows.\n func Repeat(b []byte, count int) []byte {\n+\t// Since we cannot return an error on overflow,\n+\t// we should panic if the repeat will generate\n+\t// an overflow.\n+\t// See Issue golang.org/issue/16237.\n+\tif count < 0 {\n+\t\tpanic(\"bytes: negative Repeat count\")\n+\t} else if count > 0 && len(b)*count/count != len(b) {\n+\t\tpanic(\"bytes: Repeat count causes overflow\")\n+\t}\n+\n \tnb := make([]byte, len(b)*count)\n \tbp := copy(nb, b)\n \tfor bp < len(nb) {\n@@ -419,20 +433,20 @@ func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n \n // ToUpperSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n-func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return _case.ToUpper(r) }, s)\n+func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte {\n+\treturn Map(func(r rune) rune { return c.ToUpper(r) }, s)\n }\n \n // ToLowerSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n-func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return _case.ToLower(r) }, s)\n+func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte {\n+\treturn Map(func(r rune) rune { return c.ToLower(r) }, s)\n }\n \n // ToTitleSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n-func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r rune) rune { return _case.ToTitle(r) }, s)\n+func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte {\n+\treturn Map(func(r rune) rune { return c.ToTitle(r) }, s)\n }\n \n // isSeparator reports whether the rune could mark a word boundary.\n@@ -578,7 +592,43 @@ func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int {\n \treturn -1\n }\n \n+// asciiSet is a 32-byte value, where each bit represents the presence of a\n+// given ASCII character in the set. The 128-bits of the lower 16 bytes,\n+// starting with the least-significant bit of the lowest word to the\n+// most-significant bit of the highest word, map to the full range of all\n+// 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,\n+// ensuring that any non-ASCII character will be reported as not in the set.\n+type asciiSet [8]uint32\n+\n+// makeASCIISet creates a set of ASCII characters and reports whether all\n+// characters in chars are ASCII.\n+func makeASCIISet(chars string) (as asciiSet, ok bool) {\n+\tfor i := 0; i < len(chars); i++ {\n+\t\tc := chars[i]\n+\t\tif c >= utf8.RuneSelf {\n+\t\t\treturn as, false\n+\t\t}\n+\t\tas[c>>5] |= 1 << uint(c&31)\n+\t}\n+\treturn as, true\n+}\n+\n+// contains reports whether c is inside the set.\n+func (as *asciiSet) contains(c byte) bool {\n+\treturn (as[c>>5] & (1 << uint(c&31))) != 0\n+}\n+\n func makeCutsetFunc(cutset string) func(r rune) bool {\n+\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n+\t\treturn func(r rune) bool {\n+\t\t\treturn r == rune(cutset[0])\n+\t\t}\n+\t}\n+\tif as, isASCII := makeASCIISet(cutset); isASCII {\n+\t\treturn func(r rune) bool {\n+\t\t\treturn r < utf8.RuneSelf && as.contains(byte(r))\n+\t\t}\n+\t}\n \treturn func(r rune) bool {\n \t\tfor _, c := range cutset {\n \t\t\tif c == r {"}, {"sha": "58a07efc58fb34b8a55b30b50122a525583ccb5c", "filename": "libgo/go/bytes/bytes_amd64.go", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package bytes\n+\n+//go:noescape\n+\n+// indexShortStr returns the index of the first instance of c in s, or -1 if c is not present in s.\n+// indexShortStr requires 2 <= len(c) <= shortStringLen\n+func indexShortStr(s, c []byte) int // ../runtime/asm_$GOARCH.s\n+func supportAVX2() bool             // ../runtime/asm_$GOARCH.s\n+\n+var shortStringLen int\n+\n+func init() {\n+\tif supportAVX2() {\n+\t\tshortStringLen = 63\n+\t} else {\n+\t\tshortStringLen = 31\n+\t}\n+}\n+\n+// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n+func Index(s, sep []byte) int {\n+\tn := len(sep)\n+\tswitch {\n+\tcase n == 0:\n+\t\treturn 0\n+\tcase n == 1:\n+\t\treturn IndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(sep, s) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n+\t\treturn -1\n+\tcase n <= shortStringLen:\n+\t\t// Use brute force when s and sep both are small\n+\t\tif len(s) <= 64 {\n+\t\t\treturn indexShortStr(s, sep)\n+\t\t}\n+\t\tc := sep[0]\n+\t\ti := 0\n+\t\tt := s[:len(s)-n+1]\n+\t\tfails := 0\n+\t\tfor i < len(t) {\n+\t\t\tif t[i] != c {\n+\t\t\t\t// IndexByte skips 16/32 bytes per iteration,\n+\t\t\t\t// so it's faster than indexShortStr.\n+\t\t\t\to := IndexByte(t[i:], c)\n+\t\t\t\tif o < 0 {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\t\ti += o\n+\t\t\t}\n+\t\t\tif Equal(s[i:i+n], sep) {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t\tfails++\n+\t\t\ti++\n+\t\t\t// Switch to indexShortStr when IndexByte produces too many false positives.\n+\t\t\t// Too many means more that 1 error per 8 characters.\n+\t\t\t// Allow some errors in the beginning.\n+\t\t\tif fails > (i+16)/8 {\n+\t\t\t\tr := indexShortStr(s[i:], sep)\n+\t\t\t\tif r >= 0 {\n+\t\t\t\t\treturn r + i\n+\t\t\t\t}\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\t// Rabin-Karp search\n+\thashsep, pow := hashStr(sep)\n+\tvar h uint32\n+\tfor i := 0; i < n; i++ {\n+\t\th = h*primeRK + uint32(s[i])\n+\t}\n+\tif h == hashsep && Equal(s[:n], sep) {\n+\t\treturn 0\n+\t}\n+\tfor i := n; i < len(s); {\n+\t\th *= primeRK\n+\t\th += uint32(s[i])\n+\t\th -= pow * uint32(s[i-n])\n+\t\ti++\n+\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n+\t\t\treturn i - n\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// primeRK is the prime base used in Rabin-Karp algorithm.\n+const primeRK = 16777619\n+\n+// hashStr returns the hash and the appropriate multiplicative\n+// factor for use in Rabin-Karp algorithm.\n+func hashStr(sep []byte) (uint32, uint32) {\n+\thash := uint32(0)\n+\tfor i := 0; i < len(sep); i++ {\n+\t\thash = hash*primeRK + uint32(sep[i])\n+\t}\n+\tvar pow, sq uint32 = 1, primeRK\n+\tfor i := len(sep); i > 0; i >>= 1 {\n+\t\tif i&1 != 0 {\n+\t\t\tpow *= sq\n+\t\t}\n+\t\tsq *= sq\n+\t}\n+\treturn hash, pow\n+}"}, {"sha": "91baa22aa23cc41fb422dc2579c9630b5d9aa6dd", "filename": "libgo/go/bytes/bytes_generic.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_generic.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// -build !amd64,!s390x\n+\n+package bytes\n+\n+// TODO: implements short string optimization on non amd64 platforms\n+// and get rid of bytes_amd64.go\n+\n+// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n+func Index(s, sep []byte) int {\n+\tn := len(sep)\n+\tif n == 0 {\n+\t\treturn 0\n+\t}\n+\tif n > len(s) {\n+\t\treturn -1\n+\t}\n+\tc := sep[0]\n+\tif n == 1 {\n+\t\treturn IndexByte(s, c)\n+\t}\n+\ti := 0\n+\tt := s[:len(s)-n+1]\n+\tfor i < len(t) {\n+\t\tif t[i] != c {\n+\t\t\to := IndexByte(t[i:], c)\n+\t\t\tif o < 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\ti += o\n+\t\t}\n+\t\tif Equal(s[i:i+n], sep) {\n+\t\t\treturn i\n+\t\t}\n+\t\ti++\n+\t}\n+\treturn -1\n+}"}, {"sha": "a05ca47aa1628ebb930e11ff409fbc745ec7562b", "filename": "libgo/go/bytes/bytes_s390x.go", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package bytes\n+\n+//go:noescape\n+\n+// indexShortStr returns the index of the first instance of sep in s,\n+// or -1 if sep is not present in s.\n+// indexShortStr requires 2 <= len(sep) <= shortStringLen\n+func indexShortStr(s, c []byte) int // ../runtime/asm_s390x.s\n+\n+// supportsVX reports whether the vector facility is available.\n+// indexShortStr must not be called if the vector facility is not\n+// available.\n+func supportsVX() bool // ../runtime/asm_s390x.s\n+\n+var shortStringLen = -1\n+\n+func init() {\n+\tif supportsVX() {\n+\t\tshortStringLen = 64\n+\t}\n+}\n+\n+// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n+func Index(s, sep []byte) int {\n+\tn := len(sep)\n+\tswitch {\n+\tcase n == 0:\n+\t\treturn 0\n+\tcase n == 1:\n+\t\treturn IndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(sep, s) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n+\t\treturn -1\n+\tcase n <= shortStringLen:\n+\t\t// Use brute force when s and sep both are small\n+\t\tif len(s) <= 64 {\n+\t\t\treturn indexShortStr(s, sep)\n+\t\t}\n+\t\tc := sep[0]\n+\t\ti := 0\n+\t\tt := s[:len(s)-n+1]\n+\t\tfails := 0\n+\t\tfor i < len(t) {\n+\t\t\tif t[i] != c {\n+\t\t\t\t// IndexByte skips 16/32 bytes per iteration,\n+\t\t\t\t// so it's faster than indexShortStr.\n+\t\t\t\to := IndexByte(t[i:], c)\n+\t\t\t\tif o < 0 {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\t\ti += o\n+\t\t\t}\n+\t\t\tif Equal(s[i:i+n], sep) {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t\tfails++\n+\t\t\ti++\n+\t\t\t// Switch to indexShortStr when IndexByte produces too many false positives.\n+\t\t\t// Too many means more that 1 error per 8 characters.\n+\t\t\t// Allow some errors in the beginning.\n+\t\t\tif fails > (i+16)/8 {\n+\t\t\t\tr := indexShortStr(s[i:], sep)\n+\t\t\t\tif r >= 0 {\n+\t\t\t\t\treturn r + i\n+\t\t\t\t}\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\t// Rabin-Karp search\n+\thashsep, pow := hashStr(sep)\n+\tvar h uint32\n+\tfor i := 0; i < n; i++ {\n+\t\th = h*primeRK + uint32(s[i])\n+\t}\n+\tif h == hashsep && Equal(s[:n], sep) {\n+\t\treturn 0\n+\t}\n+\tfor i := n; i < len(s); {\n+\t\th *= primeRK\n+\t\th += uint32(s[i])\n+\t\th -= pow * uint32(s[i-n])\n+\t\ti++\n+\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n+\t\t\treturn i - n\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// primeRK is the prime base used in Rabin-Karp algorithm.\n+const primeRK = 16777619\n+\n+// hashStr returns the hash and the appropriate multiplicative\n+// factor for use in Rabin-Karp algorithm.\n+func hashStr(sep []byte) (uint32, uint32) {\n+\thash := uint32(0)\n+\tfor i := 0; i < len(sep); i++ {\n+\t\thash = hash*primeRK + uint32(sep[i])\n+\t}\n+\tvar pow, sq uint32 = 1, primeRK\n+\tfor i := len(sep); i > 0; i >>= 1 {\n+\t\tif i&1 != 0 {\n+\t\t\tpow *= sq\n+\t\t}\n+\t\tsq *= sq\n+\t}\n+\treturn hash, pow\n+}"}, {"sha": "26eac5e08c6df35cb6be2da6a84de310b2ff1ffc", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 178, "deletions": 16, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7,8 +7,10 @@ package bytes_test\n import (\n \t. \"bytes\"\n \t\"fmt\"\n+\t\"internal/testenv\"\n \t\"math/rand\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n@@ -165,8 +167,12 @@ var indexAnyTests = []BinOpTest{\n \t{\"abc\", \"xyz\", -1},\n \t{\"abc\", \"xcz\", 2},\n \t{\"ab\u263ac\", \"x\u263ayz\", 2},\n+\t{\"a\u263ab\u263bc\u2639d\", \"cx\", len(\"a\u263ab\u263b\")},\n+\t{\"a\u263ab\u263bc\u2639d\", \"uvw\u263bxyz\", len(\"a\u263ab\")},\n \t{\"aRegExp*\", \".(|)*+?^$[]\", 7},\n \t{dots + dots + dots, \" \", -1},\n+\t{\"012abcba210\", \"\\xffb\", 4},\n+\t{\"012\\x80bcb\\x80210\", \"\\xffb\", 3},\n }\n \n var lastIndexAnyTests = []BinOpTest{\n@@ -178,18 +184,13 @@ var lastIndexAnyTests = []BinOpTest{\n \t{\"aaa\", \"a\", 2},\n \t{\"abc\", \"xyz\", -1},\n \t{\"abc\", \"ab\", 1},\n-\t{\"a\u263ab\u263bc\u2639d\", \"uvw\u263bxyz\", 2 + len(\"\u263a\")},\n+\t{\"ab\u263ac\", \"x\u263ayz\", 2},\n+\t{\"a\u263ab\u263bc\u2639d\", \"cx\", len(\"a\u263ab\u263b\")},\n+\t{\"a\u263ab\u263bc\u2639d\", \"uvw\u263bxyz\", len(\"a\u263ab\")},\n \t{\"a.RegExp*\", \".(|)*+?^$[]\", 8},\n \t{dots + dots + dots, \" \", -1},\n-}\n-\n-var indexRuneTests = []BinOpTest{\n-\t{\"\", \"a\", -1},\n-\t{\"\", \"\u263a\", -1},\n-\t{\"foo\", \"\u2639\", -1},\n-\t{\"foo\", \"o\", 1},\n-\t{\"foo\u263abar\", \"\u263a\", 3},\n-\t{\"foo\u263a\u263b\u2639bar\", \"\u2639\", 9},\n+\t{\"012abcba210\", \"\\xffb\", 6},\n+\t{\"012\\x80bcb\\x80210\", \"\\xffb\", 7},\n }\n \n // Execute f on each test case.  funcName should be the name of f; it's used\n@@ -346,13 +347,52 @@ func TestIndexByteSmall(t *testing.T) {\n }\n \n func TestIndexRune(t *testing.T) {\n-\tfor _, tt := range indexRuneTests {\n-\t\ta := []byte(tt.a)\n-\t\tr, _ := utf8.DecodeRuneInString(tt.b)\n-\t\tpos := IndexRune(a, r)\n-\t\tif pos != tt.i {\n-\t\t\tt.Errorf(`IndexRune(%q, '%c') = %v`, tt.a, r, pos)\n+\ttests := []struct {\n+\t\tin   string\n+\t\trune rune\n+\t\twant int\n+\t}{\n+\t\t{\"\", 'a', -1},\n+\t\t{\"\", '\u263a', -1},\n+\t\t{\"foo\", '\u2639', -1},\n+\t\t{\"foo\", 'o', 1},\n+\t\t{\"foo\u263abar\", '\u263a', 3},\n+\t\t{\"foo\u263a\u263b\u2639bar\", '\u2639', 9},\n+\t\t{\"a A x\", 'A', 2},\n+\t\t{\"some_text=some_value\", '=', 9},\n+\t\t{\"\u263aa\", 'a', 3},\n+\t\t{\"a\u263b\u263ab\", '\u263a', 4},\n+\n+\t\t// RuneError should match any invalid UTF-8 byte sequence.\n+\t\t{\"\ufffd\", '\ufffd', 0},\n+\t\t{\"\\xff\", '\ufffd', 0},\n+\t\t{\"\u263bx\ufffd\", '\ufffd', len(\"\u263bx\")},\n+\t\t{\"\u263bx\\xe2\\x98\", '\ufffd', len(\"\u263bx\")},\n+\t\t{\"\u263bx\\xe2\\x98\ufffd\", '\ufffd', len(\"\u263bx\")},\n+\t\t{\"\u263bx\\xe2\\x98x\", '\ufffd', len(\"\u263bx\")},\n+\n+\t\t// Invalid rune values should never match.\n+\t\t{\"a\u263ab\u263bc\u2639d\\xe2\\x98\ufffd\\xff\ufffd\\xed\\xa0\\x80\", -1, -1},\n+\t\t{\"a\u263ab\u263bc\u2639d\\xe2\\x98\ufffd\\xff\ufffd\\xed\\xa0\\x80\", 0xD800, -1}, // Surrogate pair\n+\t\t{\"a\u263ab\u263bc\u2639d\\xe2\\x98\ufffd\\xff\ufffd\\xed\\xa0\\x80\", utf8.MaxRune + 1, -1},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tif got := IndexRune([]byte(tt.in), tt.rune); got != tt.want {\n+\t\t\tt.Errorf(\"IndexRune(%q, %d) = %v; want %v\", tt.in, tt.rune, got, tt.want)\n+\t\t}\n+\t}\n+\n+\thaystack := []byte(\"test\u4e16\u754c\")\n+\tallocs := testing.AllocsPerRun(1000, func() {\n+\t\tif i := IndexRune(haystack, 's'); i != 2 {\n+\t\t\tt.Fatalf(\"'s' at %d; want 2\", i)\n+\t\t}\n+\t\tif i := IndexRune(haystack, '\u4e16'); i != 4 {\n+\t\t\tt.Fatalf(\"'\u4e16' at %d; want 4\", i)\n \t\t}\n+\t})\n+\tif allocs != 0 {\n+\t\tt.Errorf(\"expected no allocations, got %f\", allocs)\n \t}\n }\n \n@@ -370,6 +410,9 @@ func valName(x int) string {\n \n func benchBytes(b *testing.B, sizes []int, f func(b *testing.B, n int)) {\n \tfor _, n := range sizes {\n+\t\tif isRaceBuilder && n > 4<<10 {\n+\t\t\tcontinue\n+\t\t}\n \t\tb.Run(valName(n), func(b *testing.B) {\n \t\t\tif len(bmbuf) < n {\n \t\t\t\tbmbuf = make([]byte, n)\n@@ -382,6 +425,8 @@ func benchBytes(b *testing.B, sizes []int, f func(b *testing.B, n int)) {\n \n var indexSizes = []int{10, 32, 4 << 10, 4 << 20, 64 << 20}\n \n+var isRaceBuilder = strings.HasSuffix(testenv.Builder(), \"-race\")\n+\n func BenchmarkIndexByte(b *testing.B) {\n \tbenchBytes(b, indexSizes, bmIndexByte(IndexByte))\n }\n@@ -404,6 +449,44 @@ func bmIndexByte(index func([]byte, byte) int) func(b *testing.B, n int) {\n \t}\n }\n \n+func BenchmarkIndexRune(b *testing.B) {\n+\tbenchBytes(b, indexSizes, bmIndexRune(IndexRune))\n+}\n+\n+func BenchmarkIndexRuneASCII(b *testing.B) {\n+\tbenchBytes(b, indexSizes, bmIndexRuneASCII(IndexRune))\n+}\n+\n+func bmIndexRuneASCII(index func([]byte, rune) int) func(b *testing.B, n int) {\n+\treturn func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := index(buf, 'x')\n+\t\t\tif j != n-1 {\n+\t\t\t\tb.Fatal(\"bad index\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-1] = '\\x00'\n+\t}\n+}\n+\n+func bmIndexRune(index func([]byte, rune) int) func(b *testing.B, n int) {\n+\treturn func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tutf8.EncodeRune(buf[n-3:], '\u4e16')\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := index(buf, '\u4e16')\n+\t\t\tif j != n-3 {\n+\t\t\t\tb.Fatal(\"bad index\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-3] = '\\x00'\n+\t\tbuf[n-2] = '\\x00'\n+\t\tbuf[n-1] = '\\x00'\n+\t}\n+}\n+\n func BenchmarkEqual(b *testing.B) {\n \tb.Run(\"0\", func(b *testing.B) {\n \t\tvar buf [4]byte\n@@ -844,6 +927,54 @@ func TestRepeat(t *testing.T) {\n \t}\n }\n \n+func repeat(b []byte, count int) (err error) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tswitch v := r.(type) {\n+\t\t\tcase error:\n+\t\t\t\terr = v\n+\t\t\tdefault:\n+\t\t\t\terr = fmt.Errorf(\"%s\", v)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tRepeat(b, count)\n+\n+\treturn\n+}\n+\n+// See Issue golang.org/issue/16237\n+func TestRepeatCatchesOverflow(t *testing.T) {\n+\ttests := [...]struct {\n+\t\ts      string\n+\t\tcount  int\n+\t\terrStr string\n+\t}{\n+\t\t0: {\"--\", -2147483647, \"negative\"},\n+\t\t1: {\"\", int(^uint(0) >> 1), \"\"},\n+\t\t2: {\"-\", 10, \"\"},\n+\t\t3: {\"gopher\", 0, \"\"},\n+\t\t4: {\"-\", -1, \"negative\"},\n+\t\t5: {\"--\", -102, \"negative\"},\n+\t\t6: {string(make([]byte, 255)), int((^uint(0))/255 + 1), \"overflow\"},\n+\t}\n+\n+\tfor i, tt := range tests {\n+\t\terr := repeat([]byte(tt.s), tt.count)\n+\t\tif tt.errStr == \"\" {\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"#%d panicked %v\", i, err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err == nil || !strings.Contains(err.Error(), tt.errStr) {\n+\t\t\tt.Errorf(\"#%d expected %q got %q\", i, tt.errStr, err)\n+\t\t}\n+\t}\n+}\n+\n func runesEqual(a, b []rune) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n@@ -906,6 +1037,9 @@ var trimTests = []TrimTest{\n \t{\"Trim\", \"* listitem\", \" *\", \"listitem\"},\n \t{\"Trim\", `\"quote\"`, `\"`, \"quote\"},\n \t{\"Trim\", \"\\u2C6F\\u2C6F\\u0250\\u0250\\u2C6F\\u2C6F\", \"\\u2C6F\", \"\\u0250\\u0250\"},\n+\t{\"Trim\", \"\\x80test\\xff\", \"\\xff\", \"test\"},\n+\t{\"Trim\", \" \u0120 \", \" \", \"\u0120\"},\n+\t{\"Trim\", \" \u0120\u01300\", \"0 \", \"\u0120\u0130\"},\n \t//empty string tests\n \t{\"Trim\", \"abba\", \"\", \"abba\"},\n \t{\"Trim\", \"\", \"123\", \"\"},\n@@ -1325,3 +1459,31 @@ func BenchmarkBytesCompare(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+func BenchmarkIndexAnyASCII(b *testing.B) {\n+\tx := Repeat([]byte{'#'}, 4096) // Never matches set\n+\tcs := \"0123456789abcdef\"\n+\tfor k := 1; k <= 4096; k <<= 4 {\n+\t\tfor j := 1; j <= 16; j <<= 1 {\n+\t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tIndexAny(x[:k], cs[:j])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkTrimASCII(b *testing.B) {\n+\tcs := \"0123456789abcdef\"\n+\tfor k := 1; k <= 4096; k <<= 4 {\n+\t\tfor j := 1; j <= 16; j <<= 1 {\n+\t\t\tb.Run(fmt.Sprintf(\"%d:%d\", k, j), func(b *testing.B) {\n+\t\t\t\tx := Repeat([]byte(cs[:j]), k) // Always matches set\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tTrim(x[:k], cs[:j])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}"}, {"sha": "0d35a0dc9c5c1b473807139411fd5d36912fed2e", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"sort\"\n+\t\"unicode\"\n )\n \n func ExampleBuffer() {\n@@ -83,3 +84,205 @@ func ExampleTrimPrefix() {\n \tfmt.Printf(\"Hello%s\", b)\n \t// Output: Hello, world!\n }\n+\n+func ExampleFields() {\n+\tfmt.Printf(\"Fields are: %q\", bytes.Fields([]byte(\"  foo bar  baz   \")))\n+\t// Output: Fields are: [\"foo\" \"bar\" \"baz\"]\n+}\n+\n+func ExampleFieldsFunc() {\n+\tf := func(c rune) bool {\n+\t\treturn !unicode.IsLetter(c) && !unicode.IsNumber(c)\n+\t}\n+\tfmt.Printf(\"Fields are: %q\", bytes.FieldsFunc([]byte(\"  foo1;bar2,baz3...\"), f))\n+\t// Output: Fields are: [\"foo1\" \"bar2\" \"baz3\"]\n+}\n+\n+func ExampleContains() {\n+\tfmt.Println(bytes.Contains([]byte(\"seafood\"), []byte(\"foo\")))\n+\tfmt.Println(bytes.Contains([]byte(\"seafood\"), []byte(\"bar\")))\n+\tfmt.Println(bytes.Contains([]byte(\"seafood\"), []byte(\"\")))\n+\tfmt.Println(bytes.Contains([]byte(\"\"), []byte(\"\")))\n+\t// Output:\n+\t// true\n+\t// false\n+\t// true\n+\t// true\n+}\n+\n+func ExampleCount() {\n+\tfmt.Println(bytes.Count([]byte(\"cheese\"), []byte(\"e\")))\n+\tfmt.Println(bytes.Count([]byte(\"five\"), []byte(\"\"))) // before & after each rune\n+\t// Output:\n+\t// 3\n+\t// 5\n+}\n+\n+func ExampleEqualFold() {\n+\tfmt.Println(bytes.EqualFold([]byte(\"Go\"), []byte(\"go\")))\n+\t// Output: true\n+}\n+\n+func ExampleHasPrefix() {\n+\tfmt.Println(bytes.HasPrefix([]byte(\"Gopher\"), []byte(\"Go\")))\n+\tfmt.Println(bytes.HasPrefix([]byte(\"Gopher\"), []byte(\"C\")))\n+\tfmt.Println(bytes.HasPrefix([]byte(\"Gopher\"), []byte(\"\")))\n+\t// Output:\n+\t// true\n+\t// false\n+\t// true\n+}\n+\n+func ExampleHasSuffix() {\n+\tfmt.Println(bytes.HasSuffix([]byte(\"Amigo\"), []byte(\"go\")))\n+\tfmt.Println(bytes.HasSuffix([]byte(\"Amigo\"), []byte(\"O\")))\n+\tfmt.Println(bytes.HasSuffix([]byte(\"Amigo\"), []byte(\"Ami\")))\n+\tfmt.Println(bytes.HasSuffix([]byte(\"Amigo\"), []byte(\"\")))\n+\t// Output:\n+\t// true\n+\t// false\n+\t// false\n+\t// true\n+}\n+\n+func ExampleIndex() {\n+\tfmt.Println(bytes.Index([]byte(\"chicken\"), []byte(\"ken\")))\n+\tfmt.Println(bytes.Index([]byte(\"chicken\"), []byte(\"dmr\")))\n+\t// Output:\n+\t// 4\n+\t// -1\n+}\n+\n+func ExampleIndexFunc() {\n+\tf := func(c rune) bool {\n+\t\treturn unicode.Is(unicode.Han, c)\n+\t}\n+\tfmt.Println(bytes.IndexFunc([]byte(\"Hello, \u4e16\u754c\"), f))\n+\tfmt.Println(bytes.IndexFunc([]byte(\"Hello, world\"), f))\n+\t// Output:\n+\t// 7\n+\t// -1\n+}\n+\n+func ExampleIndexAny() {\n+\tfmt.Println(bytes.IndexAny([]byte(\"chicken\"), \"aeiouy\"))\n+\tfmt.Println(bytes.IndexAny([]byte(\"crwth\"), \"aeiouy\"))\n+\t// Output:\n+\t// 2\n+\t// -1\n+}\n+\n+func ExampleIndexRune() {\n+\tfmt.Println(bytes.IndexRune([]byte(\"chicken\"), 'k'))\n+\tfmt.Println(bytes.IndexRune([]byte(\"chicken\"), 'd'))\n+\t// Output:\n+\t// 4\n+\t// -1\n+}\n+\n+func ExampleLastIndex() {\n+\tfmt.Println(bytes.Index([]byte(\"go gopher\"), []byte(\"go\")))\n+\tfmt.Println(bytes.LastIndex([]byte(\"go gopher\"), []byte(\"go\")))\n+\tfmt.Println(bytes.LastIndex([]byte(\"go gopher\"), []byte(\"rodent\")))\n+\t// Output:\n+\t// 0\n+\t// 3\n+\t// -1\n+}\n+\n+func ExampleJoin() {\n+\ts := [][]byte{[]byte(\"foo\"), []byte(\"bar\"), []byte(\"baz\")}\n+\tfmt.Printf(\"%s\", bytes.Join(s, []byte(\", \")))\n+\t// Output: foo, bar, baz\n+}\n+\n+func ExampleRepeat() {\n+\tfmt.Printf(\"ba%s\", bytes.Repeat([]byte(\"na\"), 2))\n+\t// Output: banana\n+}\n+\n+func ExampleReplace() {\n+\tfmt.Printf(\"%s\\n\", bytes.Replace([]byte(\"oink oink oink\"), []byte(\"k\"), []byte(\"ky\"), 2))\n+\tfmt.Printf(\"%s\\n\", bytes.Replace([]byte(\"oink oink oink\"), []byte(\"oink\"), []byte(\"moo\"), -1))\n+\t// Output:\n+\t// oinky oinky oink\n+\t// moo moo moo\n+}\n+\n+func ExampleSplit() {\n+\tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\"a,b,c\"), []byte(\",\")))\n+\tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\"a man a plan a canal panama\"), []byte(\"a \")))\n+\tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\" xyz \"), []byte(\"\")))\n+\tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\"\"), []byte(\"Bernardo O'Higgins\")))\n+\t// Output:\n+\t// [\"a\" \"b\" \"c\"]\n+\t// [\"\" \"man \" \"plan \" \"canal panama\"]\n+\t// [\" \" \"x\" \"y\" \"z\" \" \"]\n+\t// [\"\"]\n+}\n+\n+func ExampleSplitN() {\n+\tfmt.Printf(\"%q\\n\", bytes.SplitN([]byte(\"a,b,c\"), []byte(\",\"), 2))\n+\tz := bytes.SplitN([]byte(\"a,b,c\"), []byte(\",\"), 0)\n+\tfmt.Printf(\"%q (nil = %v)\\n\", z, z == nil)\n+\t// Output:\n+\t// [\"a\" \"b,c\"]\n+\t// [] (nil = true)\n+}\n+\n+func ExampleSplitAfter() {\n+\tfmt.Printf(\"%q\\n\", bytes.SplitAfter([]byte(\"a,b,c\"), []byte(\",\")))\n+\t// Output: [\"a,\" \"b,\" \"c\"]\n+}\n+\n+func ExampleSplitAfterN() {\n+\tfmt.Printf(\"%q\\n\", bytes.SplitAfterN([]byte(\"a,b,c\"), []byte(\",\"), 2))\n+\t// Output: [\"a,\" \"b,c\"]\n+}\n+\n+func ExampleTitle() {\n+\tfmt.Printf(\"%s\", bytes.Title([]byte(\"her royal highness\")))\n+\t// Output: Her Royal Highness\n+}\n+\n+func ExampleToTitle() {\n+\tfmt.Printf(\"%s\\n\", bytes.ToTitle([]byte(\"loud noises\")))\n+\tfmt.Printf(\"%s\\n\", bytes.ToTitle([]byte(\"\u0445\u043b\u0435\u0431\")))\n+\t// Output:\n+\t// LOUD NOISES\n+\t// \u0425\u041b\u0415\u0411\n+}\n+\n+func ExampleTrim() {\n+\tfmt.Printf(\"[%q]\", bytes.Trim([]byte(\" !!! Achtung! Achtung! !!! \"), \"! \"))\n+\t// Output: [\"Achtung! Achtung\"]\n+}\n+\n+func ExampleMap() {\n+\trot13 := func(r rune) rune {\n+\t\tswitch {\n+\t\tcase r >= 'A' && r <= 'Z':\n+\t\t\treturn 'A' + (r-'A'+13)%26\n+\t\tcase r >= 'a' && r <= 'z':\n+\t\t\treturn 'a' + (r-'a'+13)%26\n+\t\t}\n+\t\treturn r\n+\t}\n+\tfmt.Printf(\"%s\", bytes.Map(rot13, []byte(\"'Twas brillig and the slithy gopher...\")))\n+\t// Output: 'Gjnf oevyyvt naq gur fyvgul tbcure...\n+}\n+\n+func ExampleTrimSpace() {\n+\tfmt.Printf(\"%s\", bytes.TrimSpace([]byte(\" \\t\\n a lone gopher \\n\\t\\r\\n\")))\n+\t// Output: a lone gopher\n+}\n+\n+func ExampleToUpper() {\n+\tfmt.Printf(\"%s\", bytes.ToUpper([]byte(\"Gopher\")))\n+\t// Output: GOPHER\n+}\n+\n+func ExampleToLower() {\n+\tfmt.Printf(\"%s\", bytes.ToLower([]byte(\"Gopher\")))\n+\t// Output: gopher\n+}"}, {"sha": "8ce824196d9a6cfd2e20f3bc149a835559813649", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -87,6 +87,7 @@ func (f *File) ReadGo(name string) {\n \t\t\tif cg != nil {\n \t\t\t\tf.Preamble += fmt.Sprintf(\"#line %d %q\\n\", sourceLine(cg), name)\n \t\t\t\tf.Preamble += commentText(cg) + \"\\n\"\n+\t\t\t\tf.Preamble += \"#line 1 \\\"cgo-generated-wrapper\\\"\\n\"\n \t\t\t}\n \t\t}\n \t}\n@@ -296,7 +297,7 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \n \t// everything else just recurs\n \tdefault:\n-\t\terror_(token.NoPos, \"unexpected type %T in walk\", x, visit)\n+\t\terror_(token.NoPos, \"unexpected type %T in walk\", x)\n \t\tpanic(\"unexpected type\")\n \n \tcase nil:"}, {"sha": "85441e61c04ce7c36d2e9c2d4ee55b06094a9052", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -53,6 +53,8 @@ For example:\n \t// #include <png.h>\n \timport \"C\"\n \n+The default pkg-config tool may be changed by setting the PKG_CONFIG environment variable.\n+\n When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and\n CGO_LDFLAGS environment variables are added to the flags derived from\n these directives.  Package-specific flags should be set using the\n@@ -214,6 +216,13 @@ by making copies of the data.  In pseudo-Go definitions:\n \t// C data with explicit length to Go []byte\n \tfunc C.GoBytes(unsafe.Pointer, C.int) []byte\n \n+As a special case, C.malloc does not call the C library malloc directly\n+but instead calls a Go helper function that wraps the C library malloc\n+but guarantees never to return nil. If C's malloc indicates out of memory,\n+the helper function crashes the program, like when Go itself runs out\n+of memory. Because C.malloc cannot fail, it has no two-result form\n+that returns errno.\n+\n C references to Go\n \n Go functions can be exported for use by C code in the following way:\n@@ -317,6 +326,9 @@ The following options are available when running cgo directly:\n \t\tWrite out input file in Go syntax replacing C package\n \t\tnames with real values. Used to generate files in the\n \t\tsyscall package when bootstrapping a new target.\n+\t-srcdir directory\n+\t\tFind the Go input files, listed on the command line,\n+\t\tin directory.\n \t-objdir directory\n \t\tPut all generated files in directory.\n \t-importpath string"}, {"sha": "5ea2d941ca2ea9f9609c2c3531f7373ebd31aeb4", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 267, "deletions": 162, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -167,7 +167,23 @@ func (p *Package) Translate(f *File) {\n \tif len(needType) > 0 {\n \t\tp.loadDWARF(f, needType)\n \t}\n-\tp.rewriteCalls(f)\n+\tif p.rewriteCalls(f) {\n+\t\t// Add `import _cgo_unsafe \"unsafe\"` as the first decl\n+\t\t// after the package statement.\n+\t\timp := &ast.GenDecl{\n+\t\t\tTok: token.IMPORT,\n+\t\t\tSpecs: []ast.Spec{\n+\t\t\t\t&ast.ImportSpec{\n+\t\t\t\t\tName: ast.NewIdent(\"_cgo_unsafe\"),\n+\t\t\t\t\tPath: &ast.BasicLit{\n+\t\t\t\t\t\tKind:  token.STRING,\n+\t\t\t\t\t\tValue: `\"unsafe\"`,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tf.AST.Decls = append([]ast.Decl{imp}, f.AST.Decls...)\n+\t}\n \tp.rewriteRef(f)\n }\n \n@@ -413,6 +429,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \tvar b bytes.Buffer\n \tb.WriteString(f.Preamble)\n \tb.WriteString(builtinProlog)\n+\tb.WriteString(\"#line 1 \\\"cgo-dwarf-inference\\\"\\n\")\n \tfor i, n := range names {\n \t\tfmt.Fprintf(&b, \"__typeof__(%s) *__cgo__%d;\\n\", n.C, i)\n \t\tif n.Kind == \"const\" {\n@@ -578,7 +595,9 @@ func (p *Package) mangleName(n *Name) {\n \n // rewriteCalls rewrites all calls that pass pointers to check that\n // they follow the rules for passing pointers between Go and C.\n-func (p *Package) rewriteCalls(f *File) {\n+// This returns whether the package needs to import unsafe as _cgo_unsafe.\n+func (p *Package) rewriteCalls(f *File) bool {\n+\tneedsUnsafe := false\n \tfor _, call := range f.Calls {\n \t\t// This is a call to C.xxx; set goname to \"xxx\".\n \t\tgoname := call.Call.Fun.(*ast.SelectorExpr).Sel.Name\n@@ -590,18 +609,24 @@ func (p *Package) rewriteCalls(f *File) {\n \t\t\t// Probably a type conversion.\n \t\t\tcontinue\n \t\t}\n-\t\tp.rewriteCall(f, call, name)\n+\t\tif p.rewriteCall(f, call, name) {\n+\t\t\tneedsUnsafe = true\n+\t\t}\n \t}\n+\treturn needsUnsafe\n }\n \n-// rewriteCall rewrites one call to add pointer checks. We replace\n-// each pointer argument x with _cgoCheckPointer(x).(T).\n-func (p *Package) rewriteCall(f *File, call *Call, name *Name) {\n+// rewriteCall rewrites one call to add pointer checks.\n+// If any pointer checks are required, we rewrite the call into a\n+// function literal that calls _cgoCheckPointer for each pointer\n+// argument and then calls the original function.\n+// This returns whether the package needs to import unsafe as _cgo_unsafe.\n+func (p *Package) rewriteCall(f *File, call *Call, name *Name) bool {\n \t// Avoid a crash if the number of arguments is\n \t// less than the number of parameters.\n \t// This will be caught when the generated file is compiled.\n \tif len(call.Call.Args) < len(name.FuncType.Params) {\n-\t\treturn\n+\t\treturn false\n \t}\n \n \tany := false\n@@ -612,134 +637,144 @@ func (p *Package) rewriteCall(f *File, call *Call, name *Name) {\n \t\t}\n \t}\n \tif !any {\n-\t\treturn\n+\t\treturn false\n \t}\n \n \t// We need to rewrite this call.\n \t//\n-\t// We are going to rewrite C.f(p) to C.f(_cgoCheckPointer(p)).\n-\t// If the call to C.f is deferred, that will check p at the\n-\t// point of the defer statement, not when the function is called, so\n-\t// rewrite to func(_cgo0 ptype) { C.f(_cgoCheckPointer(_cgo0)) }(p)\n-\n-\tvar dargs []ast.Expr\n-\tif call.Deferred {\n-\t\tdargs = make([]ast.Expr, len(name.FuncType.Params))\n-\t}\n+\t// We are going to rewrite C.f(p) to\n+\t//    func (_cgo0 ptype) {\n+\t//            _cgoCheckPointer(_cgo0)\n+\t//            C.f(_cgo0)\n+\t//    }(p)\n+\t// Using a function literal like this lets us do correct\n+\t// argument type checking, and works correctly if the call is\n+\t// deferred.\n+\tneedsUnsafe := false\n+\tparams := make([]*ast.Field, len(name.FuncType.Params))\n+\tnargs := make([]ast.Expr, len(name.FuncType.Params))\n+\tvar stmts []ast.Stmt\n \tfor i, param := range name.FuncType.Params {\n+\t\t// params is going to become the parameters of the\n+\t\t// function literal.\n+\t\t// nargs is going to become the list of arguments made\n+\t\t// by the call within the function literal.\n+\t\t// nparam is the parameter of the function literal that\n+\t\t// corresponds to param.\n+\n \t\torigArg := call.Call.Args[i]\n-\t\tdarg := origArg\n+\t\tnparam := ast.NewIdent(fmt.Sprintf(\"_cgo%d\", i))\n+\t\tnargs[i] = nparam\n \n-\t\tif call.Deferred {\n-\t\t\tdargs[i] = darg\n-\t\t\tdarg = ast.NewIdent(fmt.Sprintf(\"_cgo%d\", i))\n-\t\t\tcall.Call.Args[i] = darg\n+\t\t// The Go version of the C type might use unsafe.Pointer,\n+\t\t// but the file might not import unsafe.\n+\t\t// Rewrite the Go type if necessary to use _cgo_unsafe.\n+\t\tptype := p.rewriteUnsafe(param.Go)\n+\t\tif ptype != param.Go {\n+\t\t\tneedsUnsafe = true\n+\t\t}\n+\n+\t\tparams[i] = &ast.Field{\n+\t\t\tNames: []*ast.Ident{nparam},\n+\t\t\tType:  ptype,\n \t\t}\n \n \t\tif !p.needsPointerCheck(f, param.Go, origArg) {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// Run the cgo pointer checks on nparam.\n+\n+\t\t// Change the function literal to call the real function\n+\t\t// with the parameter passed through _cgoCheckPointer.\n \t\tc := &ast.CallExpr{\n \t\t\tFun: ast.NewIdent(\"_cgoCheckPointer\"),\n \t\t\tArgs: []ast.Expr{\n-\t\t\t\tdarg,\n+\t\t\t\tnparam,\n \t\t\t},\n \t\t}\n \n \t\t// Add optional additional arguments for an address\n \t\t// expression.\n \t\tc.Args = p.checkAddrArgs(f, c.Args, origArg)\n \n-\t\t// _cgoCheckPointer returns interface{}.\n-\t\t// We need to type assert that to the type we want.\n-\t\t// If the Go version of this C type uses\n-\t\t// unsafe.Pointer, we can't use a type assertion,\n-\t\t// because the Go file might not import unsafe.\n-\t\t// Instead we use a local variant of _cgoCheckPointer.\n-\n-\t\tvar arg ast.Expr\n-\t\tif n := p.unsafeCheckPointerName(param.Go, call.Deferred); n != \"\" {\n-\t\t\tc.Fun = ast.NewIdent(n)\n-\t\t\targ = c\n-\t\t} else {\n-\t\t\t// In order for the type assertion to succeed,\n-\t\t\t// we need it to match the actual type of the\n-\t\t\t// argument. The only type we have is the\n-\t\t\t// type of the function parameter. We know\n-\t\t\t// that the argument type must be assignable\n-\t\t\t// to the function parameter type, or the code\n-\t\t\t// would not compile, but there is nothing\n-\t\t\t// requiring that the types be exactly the\n-\t\t\t// same. Add a type conversion to the\n-\t\t\t// argument so that the type assertion will\n-\t\t\t// succeed.\n-\t\t\tc.Args[0] = &ast.CallExpr{\n-\t\t\t\tFun: param.Go,\n-\t\t\t\tArgs: []ast.Expr{\n-\t\t\t\t\tc.Args[0],\n-\t\t\t\t},\n-\t\t\t}\n-\n-\t\t\targ = &ast.TypeAssertExpr{\n-\t\t\t\tX:    c,\n-\t\t\t\tType: param.Go,\n-\t\t\t}\n+\t\tstmt := &ast.ExprStmt{\n+\t\t\tX: c,\n \t\t}\n-\n-\t\tcall.Call.Args[i] = arg\n+\t\tstmts = append(stmts, stmt)\n \t}\n \n-\tif call.Deferred {\n-\t\tparams := make([]*ast.Field, len(name.FuncType.Params))\n-\t\tfor i, param := range name.FuncType.Params {\n-\t\t\tptype := param.Go\n-\t\t\tif p.hasUnsafePointer(ptype) {\n-\t\t\t\t// Avoid generating unsafe.Pointer by using\n-\t\t\t\t// interface{}. This works because we are\n-\t\t\t\t// going to call a _cgoCheckPointer function\n-\t\t\t\t// anyhow.\n-\t\t\t\tptype = &ast.InterfaceType{\n-\t\t\t\t\tMethods: &ast.FieldList{},\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tparams[i] = &ast.Field{\n-\t\t\t\tNames: []*ast.Ident{\n-\t\t\t\t\tast.NewIdent(fmt.Sprintf(\"_cgo%d\", i)),\n-\t\t\t\t},\n-\t\t\t\tType: ptype,\n-\t\t\t}\n-\t\t}\n-\n-\t\tdbody := &ast.CallExpr{\n-\t\t\tFun:  call.Call.Fun,\n-\t\t\tArgs: call.Call.Args,\n+\tfcall := &ast.CallExpr{\n+\t\tFun:  call.Call.Fun,\n+\t\tArgs: nargs,\n+\t}\n+\tftype := &ast.FuncType{\n+\t\tParams: &ast.FieldList{\n+\t\t\tList: params,\n+\t\t},\n+\t}\n+\tif name.FuncType.Result != nil {\n+\t\trtype := p.rewriteUnsafe(name.FuncType.Result.Go)\n+\t\tif rtype != name.FuncType.Result.Go {\n+\t\t\tneedsUnsafe = true\n \t\t}\n-\t\tcall.Call.Fun = &ast.FuncLit{\n-\t\t\tType: &ast.FuncType{\n-\t\t\t\tParams: &ast.FieldList{\n-\t\t\t\t\tList: params,\n-\t\t\t\t},\n-\t\t\t},\n-\t\t\tBody: &ast.BlockStmt{\n-\t\t\t\tList: []ast.Stmt{\n-\t\t\t\t\t&ast.ExprStmt{\n-\t\t\t\t\t\tX: dbody,\n-\t\t\t\t\t},\n+\t\tftype.Results = &ast.FieldList{\n+\t\t\tList: []*ast.Field{\n+\t\t\t\t&ast.Field{\n+\t\t\t\t\tType: rtype,\n \t\t\t\t},\n \t\t\t},\n \t\t}\n-\t\tcall.Call.Args = dargs\n-\t\tcall.Call.Lparen = token.NoPos\n-\t\tcall.Call.Rparen = token.NoPos\n+\t}\n \n-\t\t// There is a Ref pointing to the old call.Call.Fun.\n-\t\tfor _, ref := range f.Ref {\n-\t\t\tif ref.Expr == &call.Call.Fun {\n-\t\t\t\tref.Expr = &dbody.Fun\n+\t// There is a Ref pointing to the old call.Call.Fun.\n+\tfor _, ref := range f.Ref {\n+\t\tif ref.Expr == &call.Call.Fun {\n+\t\t\tref.Expr = &fcall.Fun\n+\n+\t\t\t// If this call expects two results, we have to\n+\t\t\t// adjust the results of the function we generated.\n+\t\t\tif ref.Context == \"call2\" {\n+\t\t\t\tif ftype.Results == nil {\n+\t\t\t\t\t// An explicit void argument\n+\t\t\t\t\t// looks odd but it seems to\n+\t\t\t\t\t// be how cgo has worked historically.\n+\t\t\t\t\tftype.Results = &ast.FieldList{\n+\t\t\t\t\t\tList: []*ast.Field{\n+\t\t\t\t\t\t\t&ast.Field{\n+\t\t\t\t\t\t\t\tType: ast.NewIdent(\"_Ctype_void\"),\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tftype.Results.List = append(ftype.Results.List,\n+\t\t\t\t\t&ast.Field{\n+\t\t\t\t\t\tType: ast.NewIdent(\"error\"),\n+\t\t\t\t\t})\n \t\t\t}\n \t\t}\n \t}\n+\n+\tvar fbody ast.Stmt\n+\tif ftype.Results == nil {\n+\t\tfbody = &ast.ExprStmt{\n+\t\t\tX: fcall,\n+\t\t}\n+\t} else {\n+\t\tfbody = &ast.ReturnStmt{\n+\t\t\tResults: []ast.Expr{fcall},\n+\t\t}\n+\t}\n+\tcall.Call.Fun = &ast.FuncLit{\n+\t\tType: ftype,\n+\t\tBody: &ast.BlockStmt{\n+\t\t\tList: append(stmts, fbody),\n+\t\t},\n+\t}\n+\tcall.Call.Lparen = token.NoPos\n+\tcall.Call.Rparen = token.NoPos\n+\n+\treturn needsUnsafe\n }\n \n // needsPointerCheck returns whether the type t needs a pointer check.\n@@ -782,6 +817,11 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n \t\tif !top {\n \t\t\treturn true\n \t\t}\n+\t\t// Check whether this is a pointer to a C union (or class)\n+\t\t// type that contains a pointer.\n+\t\tif unionWithPointer[t.X] {\n+\t\t\treturn true\n+\t\t}\n \t\treturn p.hasPointer(f, t.X, false)\n \tcase *ast.FuncType, *ast.InterfaceType, *ast.MapType, *ast.ChanType:\n \t\treturn true\n@@ -935,69 +975,52 @@ func (p *Package) isType(t ast.Expr) bool {\n \treturn false\n }\n \n-// unsafeCheckPointerName is given the Go version of a C type. If the\n-// type uses unsafe.Pointer, we arrange to build a version of\n-// _cgoCheckPointer that returns that type. This avoids using a type\n-// assertion to unsafe.Pointer in our copy of user code. We return\n-// the name of the _cgoCheckPointer function we are going to build, or\n-// the empty string if the type does not use unsafe.Pointer.\n-//\n-// The deferred parameter is true if this check is for the argument of\n-// a deferred function. In that case we need to use an empty interface\n-// as the argument type, because the deferred function we introduce in\n-// rewriteCall will use an empty interface type, and we can't add a\n-// type assertion. This is handled by keeping a separate list, and\n-// writing out the lists separately in writeDefs.\n-func (p *Package) unsafeCheckPointerName(t ast.Expr, deferred bool) string {\n-\tif !p.hasUnsafePointer(t) {\n-\t\treturn \"\"\n-\t}\n-\tvar buf bytes.Buffer\n-\tconf.Fprint(&buf, fset, t)\n-\ts := buf.String()\n-\tchecks := &p.CgoChecks\n-\tif deferred {\n-\t\tchecks = &p.DeferredCgoChecks\n-\t}\n-\tfor i, t := range *checks {\n-\t\tif s == t {\n-\t\t\treturn p.unsafeCheckPointerNameIndex(i, deferred)\n-\t\t}\n-\t}\n-\t*checks = append(*checks, s)\n-\treturn p.unsafeCheckPointerNameIndex(len(*checks)-1, deferred)\n-}\n-\n-// hasUnsafePointer returns whether the Go type t uses unsafe.Pointer.\n-// t is the Go version of a C type, so we don't need to handle every case.\n-// We only care about direct references, not references via typedefs.\n-func (p *Package) hasUnsafePointer(t ast.Expr) bool {\n+// rewriteUnsafe returns a version of t with references to unsafe.Pointer\n+// rewritten to use _cgo_unsafe.Pointer instead.\n+func (p *Package) rewriteUnsafe(t ast.Expr) ast.Expr {\n \tswitch t := t.(type) {\n \tcase *ast.Ident:\n \t\t// We don't see a SelectorExpr for unsafe.Pointer;\n \t\t// this is created by code in this file.\n-\t\treturn t.Name == \"unsafe.Pointer\"\n+\t\tif t.Name == \"unsafe.Pointer\" {\n+\t\t\treturn ast.NewIdent(\"_cgo_unsafe.Pointer\")\n+\t\t}\n \tcase *ast.ArrayType:\n-\t\treturn p.hasUnsafePointer(t.Elt)\n+\t\tt1 := p.rewriteUnsafe(t.Elt)\n+\t\tif t1 != t.Elt {\n+\t\t\tr := *t\n+\t\t\tr.Elt = t1\n+\t\t\treturn &r\n+\t\t}\n \tcase *ast.StructType:\n+\t\tchanged := false\n+\t\tfields := *t.Fields\n+\t\tfields.List = nil\n \t\tfor _, f := range t.Fields.List {\n-\t\t\tif p.hasUnsafePointer(f.Type) {\n-\t\t\t\treturn true\n+\t\t\tft := p.rewriteUnsafe(f.Type)\n+\t\t\tif ft == f.Type {\n+\t\t\t\tfields.List = append(fields.List, f)\n+\t\t\t} else {\n+\t\t\t\tfn := *f\n+\t\t\t\tfn.Type = ft\n+\t\t\t\tfields.List = append(fields.List, &fn)\n+\t\t\t\tchanged = true\n \t\t\t}\n \t\t}\n+\t\tif changed {\n+\t\t\tr := *t\n+\t\t\tr.Fields = &fields\n+\t\t\treturn &r\n+\t\t}\n \tcase *ast.StarExpr: // Pointer type.\n-\t\treturn p.hasUnsafePointer(t.X)\n-\t}\n-\treturn false\n-}\n-\n-// unsafeCheckPointerNameIndex returns the name to use for a\n-// _cgoCheckPointer variant based on the index in the CgoChecks slice.\n-func (p *Package) unsafeCheckPointerNameIndex(i int, deferred bool) string {\n-\tif deferred {\n-\t\treturn fmt.Sprintf(\"_cgoCheckPointerInDefer%d\", i)\n+\t\tx1 := p.rewriteUnsafe(t.X)\n+\t\tif x1 != t.X {\n+\t\t\tr := *t\n+\t\t\tr.X = x1\n+\t\t\treturn &r\n+\t\t}\n \t}\n-\treturn fmt.Sprintf(\"_cgoCheckPointer%d\", i)\n+\treturn t\n }\n \n // rewriteRef rewrites all the C.xxx references in f.AST to refer to the\n@@ -1187,6 +1210,8 @@ func (p *Package) gccMachine() []string {\n \t\treturn []string{\"-m64\"}\n \tcase \"mips64\", \"mips64le\":\n \t\treturn []string{\"-mabi=64\"}\n+\tcase \"mips\", \"mipsle\":\n+\t\treturn []string{\"-mabi=32\"}\n \t}\n \treturn nil\n }\n@@ -1415,6 +1440,10 @@ var tagGen int\n var typedef = make(map[string]*Type)\n var goIdent = make(map[string]*ast.Ident)\n \n+// unionWithPointer is true for a Go type that represents a C union (or class)\n+// that may contain a pointer. This is used for cgo pointer checking.\n+var unionWithPointer = make(map[ast.Expr]bool)\n+\n func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.ptrSize = ptrSize\n \tc.intSize = intSize\n@@ -1464,6 +1493,19 @@ func base(dt dwarf.Type) dwarf.Type {\n \treturn dt\n }\n \n+// unqual strips away qualifiers from a DWARF type.\n+// In general we don't care about top-level qualifiers.\n+func unqual(dt dwarf.Type) dwarf.Type {\n+\tfor {\n+\t\tif d, ok := dt.(*dwarf.QualType); ok {\n+\t\t\tdt = d.Type\n+\t\t} else {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn dt\n+}\n+\n // Map from dwarf text names to aliases we use in package \"C\".\n var dwarfToName = map[string]string{\n \t\"long int\":               \"long\",\n@@ -1641,7 +1683,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tcase 16:\n \t\t\tt.Go = c.complex128\n \t\t}\n-\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\tif t.Align = t.Size / 2; t.Align >= c.ptrSize {\n \t\t\tt.Align = c.ptrSize\n \t\t}\n \n@@ -1687,6 +1729,15 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tif _, ok := base(dt.Type).(*dwarf.VoidType); ok {\n \t\t\tt.Go = c.goVoidPtr\n \t\t\tt.C.Set(\"void*\")\n+\t\t\tdq := dt.Type\n+\t\t\tfor {\n+\t\t\t\tif d, ok := dq.(*dwarf.QualType); ok {\n+\t\t\t\t\tt.C.Set(d.Qual + \" \" + t.C.String())\n+\t\t\t\t\tdq = d.Type\n+\t\t\t\t} else {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tbreak\n \t\t}\n \n@@ -1699,9 +1750,16 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tc.ptrs[dt.Type] = append(c.ptrs[dt.Type], t)\n \n \tcase *dwarf.QualType:\n-\t\t// Ignore qualifier.\n-\t\tt = c.Type(dt.Type, pos)\n-\t\tc.m[dtype] = t\n+\t\tt1 := c.Type(dt.Type, pos)\n+\t\tt.Size = t1.Size\n+\t\tt.Align = t1.Align\n+\t\tt.Go = t1.Go\n+\t\tif unionWithPointer[t1.Go] {\n+\t\t\tunionWithPointer[t.Go] = true\n+\t\t}\n+\t\tt.EnumValues = nil\n+\t\tt.Typedef = \"\"\n+\t\tt.C.Set(\"%s \"+dt.Qual, t1.C)\n \t\treturn t\n \n \tcase *dwarf.StructType:\n@@ -1733,6 +1791,9 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tswitch dt.Kind {\n \t\tcase \"class\", \"union\":\n \t\t\tt.Go = c.Opaque(t.Size)\n+\t\t\tif c.dwarfHasPointer(dt, pos) {\n+\t\t\t\tunionWithPointer[t.Go] = true\n+\t\t\t}\n \t\t\tif t.C.Empty() {\n \t\t\t\tt.C.Set(\"__typeof__(unsigned char[%d])\", t.Size)\n \t\t\t}\n@@ -1775,6 +1836,9 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tgoIdent[name.Name] = name\n \t\tsub := c.Type(dt.Type, pos)\n \t\tt.Go = name\n+\t\tif unionWithPointer[sub.Go] {\n+\t\t\tunionWithPointer[t.Go] = true\n+\t\t}\n \t\tt.Size = sub.Size\n \t\tt.Align = sub.Align\n \t\toldType := typedef[name.Name]\n@@ -1905,7 +1969,7 @@ func isStructUnionClass(x ast.Expr) bool {\n // FuncArg returns a Go type with the same memory layout as\n // dtype when used as the type of a C function argument.\n func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n-\tt := c.Type(dtype, pos)\n+\tt := c.Type(unqual(dtype), pos)\n \tswitch dt := dtype.(type) {\n \tcase *dwarf.ArrayType:\n \t\t// Arrays are passed implicitly as pointers in C.\n@@ -1935,9 +1999,12 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t\treturn nil\n \t\t\t}\n \n-\t\t\t// Remember the C spelling, in case the struct\n-\t\t\t// has __attribute__((unavailable)) on it. See issue 2888.\n-\t\t\tt.Typedef = dt.Name\n+\t\t\t// For a struct/union/class, remember the C spelling,\n+\t\t\t// in case it has __attribute__((unavailable)).\n+\t\t\t// See issue 2888.\n+\t\t\tif isStructUnionClass(t.Go) {\n+\t\t\t\tt.Typedef = dt.Name\n+\t\t\t}\n \t\t}\n \t}\n \treturn t\n@@ -1966,7 +2033,7 @@ func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType {\n \tif _, ok := dtype.ReturnType.(*dwarf.VoidType); ok {\n \t\tgr = []*ast.Field{{Type: c.goVoid}}\n \t} else if dtype.ReturnType != nil {\n-\t\tr = c.Type(dtype.ReturnType, pos)\n+\t\tr = c.Type(unqual(dtype.ReturnType), pos)\n \t\tgr = []*ast.Field{{Type: r.Go}}\n \t}\n \treturn &FuncType{\n@@ -2153,6 +2220,44 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \treturn\n }\n \n+// dwarfHasPointer returns whether the DWARF type dt contains a pointer.\n+func (c *typeConv) dwarfHasPointer(dt dwarf.Type, pos token.Pos) bool {\n+\tswitch dt := dt.(type) {\n+\tdefault:\n+\t\tfatalf(\"%s: unexpected type: %s\", lineno(pos), dt)\n+\t\treturn false\n+\n+\tcase *dwarf.AddrType, *dwarf.BoolType, *dwarf.CharType, *dwarf.EnumType,\n+\t\t*dwarf.FloatType, *dwarf.ComplexType, *dwarf.FuncType,\n+\t\t*dwarf.IntType, *dwarf.UcharType, *dwarf.UintType, *dwarf.VoidType:\n+\n+\t\treturn false\n+\n+\tcase *dwarf.ArrayType:\n+\t\treturn c.dwarfHasPointer(dt.Type, pos)\n+\n+\tcase *dwarf.PtrType:\n+\t\treturn true\n+\n+\tcase *dwarf.QualType:\n+\t\treturn c.dwarfHasPointer(dt.Type, pos)\n+\n+\tcase *dwarf.StructType:\n+\t\tfor _, f := range dt.Field {\n+\t\t\tif c.dwarfHasPointer(f.Type, pos) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\n+\tcase *dwarf.TypedefType:\n+\t\tif dt.Name == \"_GoString_\" || dt.Name == \"_GoBytes_\" {\n+\t\t\treturn true\n+\t\t}\n+\t\treturn c.dwarfHasPointer(dt.Type, pos)\n+\t}\n+}\n+\n func upper(s string) string {\n \tif s == \"\" {\n \t\treturn \"\""}, {"sha": "c91c830260fac95e7bae0a84e4abd6810a0aa6cf", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -42,10 +42,6 @@ type Package struct {\n \tGoFiles     []string // list of Go files\n \tGccFiles    []string // list of gcc output files\n \tPreamble    string   // collected preamble for _cgo_export.h\n-\n-\t// See unsafeCheckPointerName.\n-\tCgoChecks         []string\n-\tDeferredCgoChecks []string\n }\n \n // A File collects information about a single Go input file.\n@@ -153,6 +149,8 @@ var ptrSizeMap = map[string]int64{\n \t\"mipsn32\":  4,\n \t\"mipso64\":  8,\n \t\"mipsn64\":  8,\n+\t\"mips\":     4,\n+\t\"mipsle\":   4,\n \t\"mips64\":   8,\n \t\"mips64le\": 8,\n \t\"ppc\":      4,\n@@ -175,6 +173,8 @@ var intSizeMap = map[string]int64{\n \t\"mipsn32\":  4,\n \t\"mipso64\":  8,\n \t\"mipsn64\":  8,\n+\t\"mips\":     4,\n+\t\"mipsle\":   4,\n \t\"mips64\":   8,\n \t\"mips64le\": 8,\n \t\"ppc\":      4,\n@@ -200,6 +200,7 @@ var dynlinker = flag.Bool(\"dynlinker\", false, \"record dynamic linker information\n // constant values used in the host's C libraries and system calls.\n var godefs = flag.Bool(\"godefs\", false, \"for bootstrap: write Go definitions for C file to standard output\")\n \n+var srcDir = flag.String(\"srcdir\", \"\", \"source directory\")\n var objDir = flag.String(\"objdir\", \"\", \"object directory\")\n var importPath = flag.String(\"importpath\", \"\", \"import path of package being built (for comments in generated files)\")\n var exportHeader = flag.String(\"exportheader\", \"\", \"where to write export header if any exported functions\")\n@@ -278,6 +279,9 @@ func main() {\n \t// Use the beginning of the md5 of the input to disambiguate.\n \th := md5.New()\n \tfor _, input := range goFiles {\n+\t\tif *srcDir != \"\" {\n+\t\t\tinput = filepath.Join(*srcDir, input)\n+\t\t}\n \t\tf, err := os.Open(input)\n \t\tif err != nil {\n \t\t\tfatalf(\"%s\", err)\n@@ -289,6 +293,9 @@ func main() {\n \n \tfs := make([]*File, len(goFiles))\n \tfor i, input := range goFiles {\n+\t\tif *srcDir != \"\" {\n+\t\t\tinput = filepath.Join(*srcDir, input)\n+\t\t}\n \t\tf := new(File)\n \t\tf.ReadGo(input)\n \t\tf.DiscardCgoDirectives()"}, {"sha": "e82ec375a274510a6f0d120b5b59e0a6daa59f19", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -19,7 +19,10 @@ import (\n \t\"strings\"\n )\n \n-var conf = printer.Config{Mode: printer.SourcePos, Tabwidth: 8}\n+var (\n+\tconf         = printer.Config{Mode: printer.SourcePos, Tabwidth: 8}\n+\tnoSourceConf = printer.Config{Tabwidth: 8}\n+)\n \n // writeDefs creates output files to be compiled by gc and gcc.\n func (p *Package) writeDefs() {\n@@ -95,7 +98,19 @@ func (p *Package) writeDefs() {\n \tfor _, name := range typedefNames {\n \t\tdef := typedef[name]\n \t\tfmt.Fprintf(fgo2, \"type %s \", name)\n-\t\tconf.Fprint(fgo2, fset, def.Go)\n+\t\t// We don't have source info for these types, so write them out without source info.\n+\t\t// Otherwise types would look like:\n+\t\t//\n+\t\t// type _Ctype_struct_cb struct {\n+\t\t// //line :1\n+\t\t//        on_test *[0]byte\n+\t\t// //line :1\n+\t\t// }\n+\t\t//\n+\t\t// Which is not useful. Moreover we never override source info,\n+\t\t// so subsequent source code uses the same source info.\n+\t\t// Moreover, empty file name makes compile emit no source debug info at all.\n+\t\tnoSourceConf.Fprint(fgo2, fset, def.Go)\n \t\tfmt.Fprintf(fgo2, \"\\n\\n\")\n \t}\n \tif *gccgo {\n@@ -111,17 +126,11 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprint(fgo2, goProlog)\n \t}\n \n-\tfor i, t := range p.CgoChecks {\n-\t\tn := p.unsafeCheckPointerNameIndex(i, false)\n-\t\tfmt.Fprintf(fgo2, \"\\nfunc %s(p %s, args ...interface{}) %s {\\n\", n, t, t)\n-\t\tfmt.Fprintf(fgo2, \"\\treturn _cgoCheckPointer(p, args...).(%s)\\n\", t)\n-\t\tfmt.Fprintf(fgo2, \"}\\n\")\n+\tif fc != nil {\n+\t\tfmt.Fprintf(fc, \"#line 1 \\\"cgo-generated-wrappers\\\"\\n\")\n \t}\n-\tfor i, t := range p.DeferredCgoChecks {\n-\t\tn := p.unsafeCheckPointerNameIndex(i, true)\n-\t\tfmt.Fprintf(fgo2, \"\\nfunc %s(p interface{}, args ...interface{}) %s {\\n\", n, t)\n-\t\tfmt.Fprintf(fgo2, \"\\treturn _cgoCheckPointer(p, args...).(%s)\\n\", t)\n-\t\tfmt.Fprintf(fgo2, \"}\\n\")\n+\tif fm != nil {\n+\t\tfmt.Fprintf(fm, \"#line 1 \\\"cgo-generated-wrappers\\\"\\n\")\n \t}\n \n \tgccgoSymbolPrefix := p.gccgoSymbolPrefix()\n@@ -346,11 +355,7 @@ func (p *Package) structType(n *Name) (string, int64) {\n \t\t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n \t\t\toff += pad\n \t\t}\n-\t\tqual := \"\"\n-\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n-\t\t\tqual = \"const \"\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"\\t\\t%s%s r;\\n\", qual, t.C)\n+\t\tfmt.Fprintf(&buf, \"\\t\\t%s r;\\n\", t.C)\n \t\toff += t.Size\n \t}\n \tif off%p.PtrSize != 0 {\n@@ -611,20 +616,10 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\t}\n \t}\n \tfmt.Fprintf(fgcc, \"%s(\", n.C)\n-\tfor i, t := range n.FuncType.Params {\n+\tfor i := range n.FuncType.Params {\n \t\tif i > 0 {\n \t\t\tfmt.Fprintf(fgcc, \", \")\n \t\t}\n-\t\t// We know the type params are correct, because\n-\t\t// the Go equivalents had good type params.\n-\t\t// However, our version of the type omits the magic\n-\t\t// words const and volatile, which can provoke\n-\t\t// C compiler warnings. Silence them by casting\n-\t\t// all pointers to void*.  (Eventually that will produce\n-\t\t// other warnings.)\n-\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n-\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n-\t\t}\n \t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n \t}\n \tfmt.Fprintf(fgcc, \");\\n\")\n@@ -684,14 +679,10 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \t\t}\n \t}\n \tfmt.Fprintf(fgcc, \"%s(\", n.C)\n-\tfor i, t := range n.FuncType.Params {\n+\tfor i := range n.FuncType.Params {\n \t\tif i > 0 {\n \t\t\tfmt.Fprintf(fgcc, \", \")\n \t\t}\n-\t\t// Cast to void* to avoid warnings due to omitted qualifiers.\n-\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n-\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n-\t\t}\n \t\tfmt.Fprintf(fgcc, \"p%d\", i)\n \t}\n \tfmt.Fprintf(fgcc, \");\\n\")\n@@ -1217,8 +1208,8 @@ var goTypes = map[string]*Type{\n \t\"uint64\":     {Size: 8, Align: 8, C: c(\"GoUint64\")},\n \t\"float32\":    {Size: 4, Align: 4, C: c(\"GoFloat32\")},\n \t\"float64\":    {Size: 8, Align: 8, C: c(\"GoFloat64\")},\n-\t\"complex64\":  {Size: 8, Align: 8, C: c(\"GoComplex64\")},\n-\t\"complex128\": {Size: 16, Align: 16, C: c(\"GoComplex128\")},\n+\t\"complex64\":  {Size: 8, Align: 4, C: c(\"GoComplex64\")},\n+\t\"complex128\": {Size: 16, Align: 8, C: c(\"GoComplex128\")},\n }\n \n // Map an ast type to a Type.\n@@ -1299,6 +1290,7 @@ func (p *Package) cgoType(e ast.Expr) *Type {\n }\n \n const gccProlog = `\n+#line 1 \"cgo-gcc-prolog\"\n /*\n   If x and y are not equal, the type will be invalid\n   (have a negative array count) and an inscrutable error will come\n@@ -1332,6 +1324,7 @@ const noTsanProlog = `\n \n // This must match the TSAN code in runtime/cgo/libcgo.h.\n const yesTsanProlog = `\n+#line 1 \"cgo-tsan-prolog\"\n #define CGO_NO_SANITIZE_THREAD __attribute__ ((no_sanitize_thread))\n \n long long _cgo_sync __attribute__ ((common));\n@@ -1354,6 +1347,7 @@ static void _cgo_tsan_release() {\n var tsanProlog = noTsanProlog\n \n const builtinProlog = `\n+#line 1 \"cgo-builtin-prolog\"\n #include <stddef.h> /* for ptrdiff_t and size_t below */\n \n /* Define intgo when compiling with GCC.  */\n@@ -1377,14 +1371,14 @@ func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32\n func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr, uintptr)\n \n //go:linkname _cgoCheckPointer runtime.cgoCheckPointer\n-func _cgoCheckPointer(interface{}, ...interface{}) interface{}\n+func _cgoCheckPointer(interface{}, ...interface{})\n \n //go:linkname _cgoCheckResult runtime.cgoCheckResult\n func _cgoCheckResult(interface{})\n `\n \n const gccgoGoProlog = `\n-func _cgoCheckPointer(interface{}, ...interface{}) interface{}\n+func _cgoCheckPointer(interface{}, ...interface{})\n \n func _cgoCheckResult(interface{})\n `\n@@ -1461,9 +1455,15 @@ const cMallocDefGo = `\n var __cgofn__cgoPREFIX_Cfunc__Cmalloc byte\n var _cgoPREFIX_Cfunc__Cmalloc = unsafe.Pointer(&__cgofn__cgoPREFIX_Cfunc__Cmalloc)\n \n+//go:linkname runtime_throw runtime.throw\n+func runtime_throw(string)\n+\n //go:cgo_unsafe_args\n func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) {\n \t_cgo_runtime_cgocall(_cgoPREFIX_Cfunc__Cmalloc, uintptr(unsafe.Pointer(&p0)))\n+\tif r1 == nil {\n+\t\truntime_throw(\"runtime: C malloc failed\")\n+\t}\n \treturn\n }\n `\n@@ -1500,6 +1500,7 @@ func (p *Package) cPrologGccgo() string {\n }\n \n const cPrologGccgo = `\n+#line 1 \"cgo-c-prolog-gccgo\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -1564,18 +1565,17 @@ typedef struct __go_empty_interface {\n \tvoid *__object;\n } Eface;\n \n-extern Eface runtimeCgoCheckPointer(Eface, Slice)\n+extern void runtimeCgoCheckPointer(Eface, Slice)\n \t__asm__(\"runtime.cgoCheckPointer\")\n \t__attribute__((weak));\n \n-extern Eface localCgoCheckPointer(Eface, Slice)\n+extern void localCgoCheckPointer(Eface, Slice)\n \t__asm__(\"GCCGOSYMBOLPREF._cgoCheckPointer\");\n \n-Eface localCgoCheckPointer(Eface ptr, Slice args) {\n+void localCgoCheckPointer(Eface ptr, Slice args) {\n \tif(runtimeCgoCheckPointer) {\n-\t\treturn runtimeCgoCheckPointer(ptr, args);\n+\t\truntimeCgoCheckPointer(ptr, args);\n \t}\n-\treturn ptr;\n }\n \n extern void runtimeCgoCheckResult(Eface)\n@@ -1598,6 +1598,7 @@ func (p *Package) gccExportHeaderProlog() string {\n \n const gccExportHeaderProlog = `\n /* Start of boilerplate cgo prologue.  */\n+#line 1 \"cgo-gcc-export-header-prolog\"\n \n #ifndef GO_CGO_PROLOGUE_H\n #define GO_CGO_PROLOGUE_H\n@@ -1651,6 +1652,7 @@ const gccExportHeaderEpilog = `\n // We use weak declarations, and test the addresses, so that this code\n // works with older versions of gccgo.\n const gccgoExportFileProlog = `\n+#line 1 \"cgo-gccgo-export-file-prolog\"\n extern _Bool runtime_iscgo __attribute__ ((weak));\n \n static void GoInit(void) __attribute__ ((constructor));"}, {"sha": "e93fd6ebed7775157cdfd0c143d43cac6759fa2b", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 127, "deletions": 69, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -17,6 +17,7 @@\n // \tclean       remove object files\n // \tdoc         show documentation for package or symbol\n // \tenv         print Go environment information\n+// \tbug         print information for bug reports\n // \tfix         run go tool fix on packages\n // \tfmt         run gofmt on package sources\n // \tgenerate    generate Go files by processing source\n@@ -323,6 +324,17 @@\n // each named variable on its own line.\n //\n //\n+// Print information for bug reports\n+//\n+// Usage:\n+//\n+// \tgo bug\n+//\n+// Bug prints information that helps file effective bug reports.\n+//\n+// Bugs may be reported at https://golang.org/issue/new.\n+//\n+//\n // Run go tool fix on packages\n //\n // Usage:\n@@ -367,7 +379,7 @@\n //\n // Generate runs commands described by directives within existing\n // files. Those commands can run any process but the intent is to\n-// create or update Go source files, for instance by running yacc.\n+// create or update Go source files.\n //\n // Go generate is never run automatically by go build, go get, go test,\n // and so on. It must be run explicitly.\n@@ -430,10 +442,10 @@\n // can be used to create aliases or to handle multiword generators.\n // For example,\n //\n-// \t//go:generate -command yacc go tool yacc\n+// \t//go:generate -command foo go tool foo\n //\n-// specifies that the command \"yacc\" represents the generator\n-// \"go tool yacc\".\n+// specifies that the command \"foo\" represents the generator\n+// \"go tool foo\".\n //\n // Generate processes packages in the order given on the command line,\n // one at a time. If the command line lists .go files, they are treated\n@@ -496,11 +508,13 @@\n // and their dependencies.  By default, get uses the network to check out\n // missing packages but does not use it to look for updates to existing packages.\n //\n+// The -v flag enables verbose progress and debug output.\n+//\n // Get also accepts build flags to control the installation. See 'go help build'.\n //\n // When checking out a new package, get creates the target directory\n // GOPATH/src/<import-path>. If the GOPATH contains multiple entries,\n-// get uses the first one. See 'go help gopath'.\n+// get uses the first one. For more details see: 'go help gopath'.\n //\n // When checking out or updating a package, get looks for a branch or tag\n // that matches the locally installed version of Go. The most important\n@@ -584,6 +598,8 @@\n //         SwigFiles      []string // .swig files\n //         SwigCXXFiles   []string // .swigcxx files\n //         SysoFiles      []string // .syso object files to add to archive\n+//         TestGoFiles    []string // _test.go files in package\n+//         XTestGoFiles   []string // _test.go files outside package\n //\n //         // Cgo directives\n //         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -594,20 +610,23 @@\n //         CgoPkgConfig []string // cgo: pkg-config names\n //\n //         // Dependency information\n-//         Imports []string // import paths used by this package\n-//         Deps    []string // all (recursively) imported dependencies\n+//         Imports      []string // import paths used by this package\n+//         Deps         []string // all (recursively) imported dependencies\n+//         TestImports  []string // imports from TestGoFiles\n+//         XTestImports []string // imports from XTestGoFiles\n //\n //         // Error information\n //         Incomplete bool            // this package or a dependency has an error\n //         Error      *PackageError   // error loading package\n //         DepsErrors []*PackageError // errors loading dependencies\n-//\n-//         TestGoFiles  []string // _test.go files in package\n-//         TestImports  []string // imports from TestGoFiles\n-//         XTestGoFiles []string // _test.go files outside package\n-//         XTestImports []string // imports from XTestGoFiles\n //     }\n //\n+// Packages stored in vendor directories report an ImportPath that includes the\n+// path to the vendor directory (for example, \"d/vendor/p\" instead of \"p\"),\n+// so that the ImportPath uniquely identifies a given copy of a package.\n+// The Imports, Deps, TestImports, and XTestImports lists also contain these\n+// expanded imports paths. See golang.org/s/go15vendor for more about vendoring.\n+//\n // The error information, if any, is\n //\n //     type PackageError struct {\n@@ -852,6 +871,10 @@\n // \t\tposition independent executables (PIE). Packages not named\n // \t\tmain are ignored.\n //\n+// \t-buildmode=plugin\n+// \t\tBuild the listed main packages, plus all packages that they\n+// \t\timport, into a Go plugin. Packages not named main are ignored.\n+//\n //\n // File types\n //\n@@ -906,8 +929,13 @@\n // On Windows, the value is a semicolon-separated string.\n // On Plan 9, the value is a list.\n //\n-// GOPATH must be set to get, build and install packages outside the\n-// standard Go tree.\n+// If the environment variable is unset, GOPATH defaults\n+// to a subdirectory named \"go\" in the user's home directory\n+// ($HOME/go on Unix, %USERPROFILE%\\go on Windows),\n+// unless that directory holds a Go distribution.\n+// Run \"go env GOPATH\" to see the current GOPATH.\n+//\n+// See https://golang.org/wiki/SettingGOPATH to set a custom GOPATH.\n //\n // Each directory listed in GOPATH must have a prescribed structure:\n //\n@@ -935,9 +963,9 @@\n //\n // Here's an example directory layout:\n //\n-//     GOPATH=/home/user/gocode\n+//     GOPATH=/home/user/go\n //\n-//     /home/user/gocode/\n+//     /home/user/go/\n //         src/\n //             foo/\n //                 bar/               (go code in package bar)\n@@ -963,7 +991,7 @@\n // by code in the directory tree rooted at the parent of \"internal\".\n // Here's an extended version of the directory layout above:\n //\n-//     /home/user/gocode/\n+//     /home/user/go/\n //         src/\n //             crash/\n //                 bang/              (go code in package bang)\n@@ -1001,7 +1029,7 @@\n // but with the \"internal\" directory renamed to \"vendor\"\n // and a new foo/vendor/crash/bang directory added:\n //\n-//     /home/user/gocode/\n+//     /home/user/go/\n //         src/\n //             crash/\n //                 bang/              (go code in package bang)\n@@ -1060,7 +1088,7 @@\n // \t\tThe operating system for which to compile code.\n // \t\tExamples are linux, darwin, windows, netbsd.\n // \tGOPATH\n-// \t\tSee 'go help gopath'.\n+// \t\tFor more details see: 'go help gopath'.\n // \tGORACE\n // \t\tOptions for the race detector.\n // \t\tSee https://golang.org/doc/articles/race_detector.html.\n@@ -1082,10 +1110,15 @@\n // \tCGO_CXXFLAGS\n // \t\tFlags that cgo will pass to the compiler when compiling\n // \t\tC++ code.\n+// \tCGO_FFLAGS\n+// \t\tFlags that cgo will pass to the compiler when compiling\n+// \t\tFortran code.\n // \tCGO_LDFLAGS\n // \t\tFlags that cgo will pass to the compiler when linking.\n // \tCXX\n // \t\tThe command to use to compile C++ code.\n+// \tPKG_CONFIG\n+// \t\tPath to pkg-config tool.\n //\n // Architecture-specific environment variables:\n //\n@@ -1107,14 +1140,18 @@\n // \t\tWhether the linker should use external linking mode\n // \t\twhen using -linkmode=auto with code that uses cgo.\n // \t\tSet to 0 to disable external linking mode, 1 to enable it.\n+// \tGIT_ALLOW_PROTOCOL\n+// \t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n+// \t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n+// \t\tconsidered insecure by 'go get'.\n //\n //\n // Import path syntax\n //\n-// An import path (see 'go help packages') denotes a package\n-// stored in the local file system.  In general, an import path denotes\n-// either a standard package (such as \"unicode/utf8\") or a package\n-// found in one of the work spaces (see 'go help gopath').\n+// An import path (see 'go help packages') denotes a package stored in the local\n+// file system.  In general, an import path denotes either a standard package (such\n+// as \"unicode/utf8\") or a package found in one of the work spaces (For more\n+// details see: 'go help gopath').\n //\n // Relative import paths\n //\n@@ -1206,6 +1243,11 @@\n // each is tried in turn when downloading.  For example, a Git\n // download tries https://, then git+ssh://.\n //\n+// By default, downloads are restricted to known secure protocols\n+// (e.g. https, ssh). To override this setting for Git downloads, the\n+// GIT_ALLOW_PROTOCOL environment variable can be set (For more details see:\n+// 'go help environment').\n+//\n // If the import path is not a known code hosting site and also lacks a\n // version control qualifier, the go tool attempts to fetch the import\n // over https/http and looks for a <meta> tag in the document's HTML\n@@ -1246,8 +1288,8 @@\n // same meta tag and then git clone https://code.org/r/p/exproj into\n // GOPATH/src/example.org.\n //\n-// New downloaded packages are written to the first directory\n-// listed in the GOPATH environment variable (see 'go help gopath').\n+// New downloaded packages are written to the first directory listed in the GOPATH\n+// environment variable (For more details see: 'go help gopath').\n //\n // The go command attempts to download the version of the\n // package appropriate for the Go release being used.\n@@ -1291,7 +1333,7 @@\n //\n // Otherwise, the import path P denotes the package found in\n // the directory DIR/src/P for some DIR listed in the GOPATH\n-// environment variable (see 'go help gopath').\n+// environment variable (For more details see: 'go help gopath').\n //\n // If no import paths are given, the action applies to the\n // package in the current directory.\n@@ -1311,6 +1353,9 @@\n // - \"cmd\" expands to the Go repository's commands and their\n // internal libraries.\n //\n+// Import paths beginning with \"cmd/\" only match source code in\n+// the Go repository.\n+//\n // An import path is a pattern if it includes one or more \"...\" wildcards,\n // each of which can match any string, including the empty string and\n // strings containing slashes.  Such a pattern expands to all package\n@@ -1366,28 +1411,11 @@\n // \t    By default, no benchmarks run. To run all benchmarks,\n // \t    use '-bench .' or '-bench=.'.\n //\n-// \t-benchmem\n-// \t    Print memory allocation statistics for benchmarks.\n-//\n // \t-benchtime t\n // \t    Run enough iterations of each benchmark to take t, specified\n // \t    as a time.Duration (for example, -benchtime 1h30s).\n // \t    The default is 1 second (1s).\n //\n-// \t-blockprofile block.out\n-// \t    Write a goroutine blocking profile to the specified file\n-// \t    when all tests are complete.\n-// \t    Writes test binary as -c would.\n-//\n-// \t-blockprofilerate n\n-// \t    Control the detail provided in goroutine blocking profiles by\n-// \t    calling runtime.SetBlockProfileRate with n.\n-// \t    See 'go doc runtime.SetBlockProfileRate'.\n-// \t    The profiler aims to sample, on average, one blocking event every\n-// \t    n nanoseconds the program spends blocked.  By default,\n-// \t    if -test.blockprofile is set without this flag, all blocking events\n-// \t    are recorded, equivalent to -test.blockprofilerate=1.\n-//\n // \t-count n\n // \t    Run each test and benchmark n times (default 1).\n // \t    If -cpu is set, run n times for each GOMAXPROCS value.\n@@ -1413,33 +1441,11 @@\n // \t    Packages are specified as import paths.\n // \t    Sets -cover.\n //\n-// \t-coverprofile cover.out\n-// \t    Write a coverage profile to the file after all tests have passed.\n-// \t    Sets -cover.\n-//\n // \t-cpu 1,2,4\n // \t    Specify a list of GOMAXPROCS values for which the tests or\n // \t    benchmarks should be executed.  The default is the current value\n // \t    of GOMAXPROCS.\n //\n-// \t-cpuprofile cpu.out\n-// \t    Write a CPU profile to the specified file before exiting.\n-// \t    Writes test binary as -c would.\n-//\n-// \t-memprofile mem.out\n-// \t    Write a memory profile to the file after all tests have passed.\n-// \t    Writes test binary as -c would.\n-//\n-// \t-memprofilerate n\n-// \t    Enable more precise (and expensive) memory profiles by setting\n-// \t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n-// \t    To profile all memory allocations, use -test.memprofilerate=1\n-// \t    and pass --alloc_space flag to the pprof tool.\n-//\n-// \t-outputdir directory\n-// \t    Place output files from profiling in the specified directory,\n-// \t    by default the directory in which \"go test\" is running.\n-//\n // \t-parallel n\n // \t    Allow parallel execution of test functions that call t.Parallel.\n // \t    The value of this flag is the maximum number of tests to run\n@@ -1465,13 +1471,64 @@\n // \t    If a test runs longer than t, panic.\n // \t    The default is 10 minutes (10m).\n //\n-// \t-trace trace.out\n-// \t    Write an execution trace to the specified file before exiting.\n-//\n // \t-v\n // \t    Verbose output: log all tests as they are run. Also print all\n // \t    text from Log and Logf calls even if the test succeeds.\n //\n+// The following flags are also recognized by 'go test' and can be used to\n+// profile the tests during execution:\n+//\n+// \t-benchmem\n+// \t    Print memory allocation statistics for benchmarks.\n+//\n+// \t-blockprofile block.out\n+// \t    Write a goroutine blocking profile to the specified file\n+// \t    when all tests are complete.\n+// \t    Writes test binary as -c would.\n+//\n+// \t-blockprofilerate n\n+// \t    Control the detail provided in goroutine blocking profiles by\n+// \t    calling runtime.SetBlockProfileRate with n.\n+// \t    See 'go doc runtime.SetBlockProfileRate'.\n+// \t    The profiler aims to sample, on average, one blocking event every\n+// \t    n nanoseconds the program spends blocked.  By default,\n+// \t    if -test.blockprofile is set without this flag, all blocking events\n+// \t    are recorded, equivalent to -test.blockprofilerate=1.\n+//\n+// \t-coverprofile cover.out\n+// \t    Write a coverage profile to the file after all tests have passed.\n+// \t    Sets -cover.\n+//\n+// \t-cpuprofile cpu.out\n+// \t    Write a CPU profile to the specified file before exiting.\n+// \t    Writes test binary as -c would.\n+//\n+// \t-memprofile mem.out\n+// \t    Write a memory profile to the file after all tests have passed.\n+// \t    Writes test binary as -c would.\n+//\n+// \t-memprofilerate n\n+// \t    Enable more precise (and expensive) memory profiles by setting\n+// \t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n+// \t    To profile all memory allocations, use -test.memprofilerate=1\n+// \t    and pass --alloc_space flag to the pprof tool.\n+//\n+// \t-mutexprofile mutex.out\n+// \t    Write a mutex contention profile to the specified file\n+// \t    when all tests are complete.\n+// \t    Writes test binary as -c would.\n+//\n+// \t-mutexprofilefraction n\n+// \t    Sample 1 in n stack traces of goroutines holding a\n+// \t    contended mutex.\n+//\n+// \t-outputdir directory\n+// \t    Place output files from profiling in the specified directory,\n+// \t    by default the directory in which \"go test\" is running.\n+//\n+// \t-trace trace.out\n+// \t    Write an execution trace to the specified file before exiting.\n+//\n // Each of these flags is also recognized with an optional 'test.' prefix,\n // as in -test.v. When invoking the generated test binary (the result of\n // 'go test -c') directly, however, the prefix is mandatory.\n@@ -1551,7 +1608,8 @@\n // is compared exactly against the comment (see examples below). If the last\n // comment begins with \"Unordered output:\" then the output is compared to the\n // comment, however the order of the lines is ignored. An example with no such\n-// comment, or with no text after \"Output:\" is compiled but not executed.\n+// comment is compiled but not executed. An example with no text after\n+// \"Output:\" is compiled, executed, and expected to produce no output.\n //\n // Godoc displays the body of ExampleXXX to demonstrate the use\n // of the function, constant, or variable XXX.  An example of a method M with"}, {"sha": "2148d12685a184724a290709c9f2f6ce714119c8", "filename": "libgo/go/cmd/go/bootstrap.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -36,3 +36,6 @@ func httpsOrHTTP(importPath string, security securityMode) (string, io.ReadClose\n func parseMetaGoImports(r io.Reader) ([]metaImport, error) {\n \tpanic(\"unreachable\")\n }\n+\n+func queryEscape(s string) string { panic(\"unreachable\") }\n+func openBrowser(url string) bool { panic(\"unreachable\") }"}, {"sha": "cbd258b80bde5f030f5f791ec831e368c89bed6a", "filename": "libgo/go/cmd/go/bug.go", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbug.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,213 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strings\"\n+)\n+\n+var cmdBug = &Command{\n+\tRun:       runBug,\n+\tUsageLine: \"bug\",\n+\tShort:     \"print information for bug reports\",\n+\tLong: `\n+Bug prints information that helps file effective bug reports.\n+\n+Bugs may be reported at https://golang.org/issue/new.\n+\t`,\n+}\n+\n+func init() {\n+\tcmdBug.Flag.BoolVar(&buildV, \"v\", false, \"\")\n+}\n+\n+func runBug(cmd *Command, args []string) {\n+\tvar buf bytes.Buffer\n+\tbuf.WriteString(bugHeader)\n+\tinspectGoVersion(&buf)\n+\tfmt.Fprint(&buf, \"#### System details\\n\\n\")\n+\tfmt.Fprintln(&buf, \"```\")\n+\tfmt.Fprintf(&buf, \"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n+\tenv := newEnv\n+\tenv = append(env, extraEnvVars()...)\n+\tfor _, e := range env {\n+\t\t// Hide the TERM environment variable from \"go bug\".\n+\t\t// See issue #18128\n+\t\tif e.name != \"TERM\" {\n+\t\t\tfmt.Fprintf(&buf, \"%s=\\\"%s\\\"\\n\", e.name, e.value)\n+\t\t}\n+\t}\n+\tprintGoDetails(&buf)\n+\tprintOSDetails(&buf)\n+\tprintCDetails(&buf)\n+\tfmt.Fprintln(&buf, \"```\")\n+\n+\tbody := buf.String()\n+\turl := \"https://github.com/golang/go/issues/new?body=\" + queryEscape(body)\n+\tif !openBrowser(url) {\n+\t\tfmt.Print(\"Please file a new issue at golang.org/issue/new using this template:\\n\\n\")\n+\t\tfmt.Print(body)\n+\t}\n+}\n+\n+const bugHeader = `Please answer these questions before submitting your issue. Thanks!\n+\n+#### What did you do?\n+If possible, provide a recipe for reproducing the error.\n+A complete runnable program is good.\n+A link on play.golang.org is best.\n+\n+\n+#### What did you expect to see?\n+\n+\n+#### What did you see instead?\n+\n+\n+`\n+\n+func printGoDetails(w io.Writer) {\n+\tprintCmdOut(w, \"GOROOT/bin/go version: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"version\")\n+\tprintCmdOut(w, \"GOROOT/bin/go tool compile -V: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"tool\", \"compile\", \"-V\")\n+}\n+\n+func printOSDetails(w io.Writer) {\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\":\n+\t\tprintCmdOut(w, \"uname -v: \", \"uname\", \"-v\")\n+\t\tprintCmdOut(w, \"\", \"sw_vers\")\n+\tcase \"linux\":\n+\t\tprintCmdOut(w, \"uname -sr: \", \"uname\", \"-sr\")\n+\t\tprintCmdOut(w, \"\", \"lsb_release\", \"-a\")\n+\t\tprintGlibcVersion(w)\n+\tcase \"openbsd\", \"netbsd\", \"freebsd\", \"dragonfly\":\n+\t\tprintCmdOut(w, \"uname -v: \", \"uname\", \"-v\")\n+\tcase \"solaris\":\n+\t\tout, err := ioutil.ReadFile(\"/etc/release\")\n+\t\tif err == nil {\n+\t\t\tfmt.Fprintf(w, \"/etc/release: %s\\n\", out)\n+\t\t} else {\n+\t\t\tif buildV {\n+\t\t\t\tfmt.Printf(\"failed to read /etc/release: %v\\n\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func printCDetails(w io.Writer) {\n+\tprintCmdOut(w, \"lldb --version: \", \"lldb\", \"--version\")\n+\tcmd := exec.Command(\"gdb\", \"--version\")\n+\tout, err := cmd.Output()\n+\tif err == nil {\n+\t\t// There's apparently no combination of command line flags\n+\t\t// to get gdb to spit out its version without the license and warranty.\n+\t\t// Print up to the first newline.\n+\t\tfmt.Fprintf(w, \"gdb --version: %s\\n\", firstLine(out))\n+\t} else {\n+\t\tif buildV {\n+\t\t\tfmt.Printf(\"failed to run gdb --version: %v\\n\", err)\n+\t\t}\n+\t}\n+}\n+\n+func inspectGoVersion(w io.Writer) {\n+\tdata, err := httpGET(\"https://golang.org/VERSION?m=text\")\n+\tif err != nil {\n+\t\tif buildV {\n+\t\t\tfmt.Printf(\"failed to read from golang.org/VERSION: %v\\n\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\t// golang.org/VERSION currently returns a whitespace-free string,\n+\t// but just in case, protect against that changing.\n+\t// Similarly so for runtime.Version.\n+\trelease := string(bytes.TrimSpace(data))\n+\tvers := strings.TrimSpace(runtime.Version())\n+\n+\tif vers == release {\n+\t\t// Up to date\n+\t\treturn\n+\t}\n+\n+\t// Devel version or outdated release. Either way, this request is apropos.\n+\tfmt.Fprintf(w, \"#### Does this issue reproduce with the latest release (%s)?\\n\\n\\n\", release)\n+}\n+\n+// printCmdOut prints the output of running the given command.\n+// It ignores failures; 'go bug' is best effort.\n+func printCmdOut(w io.Writer, prefix, path string, args ...string) {\n+\tcmd := exec.Command(path, args...)\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\tif buildV {\n+\t\t\tfmt.Printf(\"%s %s: %v\\n\", path, strings.Join(args, \" \"), err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tfmt.Fprintf(w, \"%s%s\\n\", prefix, bytes.TrimSpace(out))\n+}\n+\n+// firstLine returns the first line of a given byte slice.\n+func firstLine(buf []byte) []byte {\n+\tidx := bytes.IndexByte(buf, '\\n')\n+\tif idx > 0 {\n+\t\tbuf = buf[:idx]\n+\t}\n+\treturn bytes.TrimSpace(buf)\n+}\n+\n+// printGlibcVersion prints information about the glibc version.\n+// It ignores failures.\n+func printGlibcVersion(w io.Writer) {\n+\ttempdir := os.TempDir()\n+\tif tempdir == \"\" {\n+\t\treturn\n+\t}\n+\tsrc := []byte(`int main() {}`)\n+\tsrcfile := filepath.Join(tempdir, \"go-bug.c\")\n+\toutfile := filepath.Join(tempdir, \"go-bug\")\n+\terr := ioutil.WriteFile(srcfile, src, 0644)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer os.Remove(srcfile)\n+\tcmd := exec.Command(\"gcc\", \"-o\", outfile, srcfile)\n+\tif _, err = cmd.CombinedOutput(); err != nil {\n+\t\treturn\n+\t}\n+\tdefer os.Remove(outfile)\n+\n+\tcmd = exec.Command(\"ldd\", outfile)\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tre := regexp.MustCompile(`libc\\.so[^ ]* => ([^ ]+)`)\n+\tm := re.FindStringSubmatch(string(out))\n+\tif m == nil {\n+\t\treturn\n+\t}\n+\tcmd = exec.Command(m[1])\n+\tout, err = cmd.Output()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfmt.Fprintf(w, \"%s: %s\\n\", m[1], firstLine(out))\n+\n+\t// print another line (the one containing version string) in case of musl libc\n+\tif idx := bytes.IndexByte(out, '\\n'); bytes.Index(out, []byte(\"musl\")) != -1 && idx > -1 {\n+\t\tfmt.Fprintf(w, \"%s\\n\", firstLine(out[idx+1:]))\n+\t}\n+}"}, {"sha": "a8f90344c30ab4c2e1b649cc9bbc935cf68d90c4", "filename": "libgo/go/cmd/go/build.go", "status": "modified", "additions": 286, "deletions": 169, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -346,6 +346,13 @@ func buildModeInit() {\n \t\tcase \"darwin/arm\", \"darwin/arm64\":\n \t\t\tcodegenArg = \"-shared\"\n \t\tdefault:\n+\t\t\tswitch goos {\n+\t\t\tcase \"dragonfly\", \"freebsd\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n+\t\t\t\t// Use -shared so that the result is\n+\t\t\t\t// suitable for inclusion in a PIE or\n+\t\t\t\t// shared library.\n+\t\t\t\tcodegenArg = \"-shared\"\n+\t\t\t}\n \t\t}\n \t\texeSuffix = \".a\"\n \t\tldBuildmode = \"c-archive\"\n@@ -407,6 +414,21 @@ func buildModeInit() {\n \t\t\tfatalf(\"-buildmode=shared and -o not supported together\")\n \t\t}\n \t\tldBuildmode = \"shared\"\n+\tcase \"plugin\":\n+\t\tpkgsFilter = pkgsMain\n+\t\tif gccgo {\n+\t\t\tcodegenArg = \"-fPIC\"\n+\t\t} else {\n+\t\t\tswitch platform {\n+\t\t\tcase \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/386\",\n+\t\t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\":\n+\t\t\tdefault:\n+\t\t\t\tfatalf(\"-buildmode=plugin not supported on %s\\n\", platform)\n+\t\t\t}\n+\t\t\tcodegenArg = \"-dynlink\"\n+\t\t}\n+\t\texeSuffix = \".so\"\n+\t\tldBuildmode = \"plugin\"\n \tdefault:\n \t\tfatalf(\"buildmode=%s not supported\", buildBuildmode)\n \t}\n@@ -432,10 +454,13 @@ func buildModeInit() {\n \t\t\tbuildAsmflags = append(buildAsmflags, codegenArg)\n \t\t\tbuildGcflags = append(buildGcflags, codegenArg)\n \t\t}\n-\t\tif buildContext.InstallSuffix != \"\" {\n-\t\t\tbuildContext.InstallSuffix += \"_\"\n+\t\t// Don't alter InstallSuffix when modifying default codegen args.\n+\t\tif buildBuildmode != \"default\" || buildLinkshared {\n+\t\t\tif buildContext.InstallSuffix != \"\" {\n+\t\t\t\tbuildContext.InstallSuffix += \"_\"\n+\t\t\t}\n+\t\t\tbuildContext.InstallSuffix += codegenArg[1:]\n \t\t}\n-\t\tbuildContext.InstallSuffix += codegenArg[1:]\n \t}\n }\n \n@@ -452,6 +477,11 @@ func runBuild(cmd *Command, args []string) {\n \t\t*buildO += exeSuffix\n \t}\n \n+\t// Special case -o /dev/null by not writing at all.\n+\tif *buildO == os.DevNull {\n+\t\t*buildO = \"\"\n+\t}\n+\n \t// sanity check some often mis-used options\n \tswitch buildContext.Compiler {\n \tcase \"gccgo\":\n@@ -580,6 +610,10 @@ func libname(args []string, pkgs []*Package) (string, error) {\n }\n \n func runInstall(cmd *Command, args []string) {\n+\tinstallPackages(args, false)\n+}\n+\n+func installPackages(args []string, forGet bool) {\n \tif gobin != \"\" && !filepath.IsAbs(gobin) {\n \t\tfatalf(\"cannot install, GOBIN must be an absolute path\")\n \t}\n@@ -599,14 +633,16 @@ func runInstall(cmd *Command, args []string) {\n \t\t\t\terrorf(\"go install: no install location for %s: hidden by %s\", p.Dir, p.ConflictDir)\n \t\t\tdefault:\n \t\t\t\terrorf(\"go install: no install location for directory %s outside GOPATH\\n\"+\n-\t\t\t\t\t\"\\tFor more details see: go help gopath\", p.Dir)\n+\t\t\t\t\t\"\\tFor more details see: 'go help gopath'\", p.Dir)\n \t\t\t}\n \t\t}\n \t}\n \texitIfErrors()\n \n \tvar b builder\n \tb.init()\n+\t// Set the behavior for `go get` to not error on packages with test files only.\n+\tb.testFilesOnlyOK = forGet\n \tvar a *action\n \tif buildBuildmode == \"shared\" {\n \t\tif libName, err := libname(args, pkgs); err != nil {\n@@ -697,6 +733,8 @@ type builder struct {\n \tflagCache   map[string]bool      // a cache of supported compiler flags\n \tprint       func(args ...interface{}) (int, error)\n \n+\ttestFilesOnlyOK bool // do not error if the packages only have test files\n+\n \toutput    sync.Mutex\n \tscriptDir string // current directory in printed script\n \n@@ -1283,6 +1321,8 @@ func (b *builder) do(root *action) {\n \t\tif err != nil {\n \t\t\tif err == errPrintedOutput {\n \t\t\t\tsetExitStatus(2)\n+\t\t\t} else if _, ok := err.(*build.NoGoError); ok && len(a.p.TestGoFiles) > 0 && b.testFilesOnlyOK {\n+\t\t\t\t// Ignore the \"no buildable Go source files\" error for a package with only test files.\n \t\t\t} else {\n \t\t\t\terrorf(\"%s\", err)\n \t\t\t}\n@@ -1369,7 +1409,7 @@ func (b *builder) build(a *action) (err error) {\n \t}\n \n \tdefer func() {\n-\t\tif err != nil && err != errPrintedOutput {\n+\t\tif _, ok := err.(*build.NoGoError); err != nil && err != errPrintedOutput && !(ok && b.testFilesOnlyOK && len(a.p.TestGoFiles) > 0) {\n \t\t\terr = fmt.Errorf(\"go build %s: %v\", a.p.ImportPath, err)\n \t\t}\n \t}()\n@@ -1400,7 +1440,7 @@ func (b *builder) build(a *action) (err error) {\n \t\t}\n \t}\n \n-\tvar gofiles, cgofiles, cfiles, sfiles, cxxfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string\n+\tvar gofiles, cgofiles, objdirCgofiles, cfiles, sfiles, cxxfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string\n \n \tgofiles = append(gofiles, a.p.GoFiles...)\n \tcgofiles = append(cgofiles, a.p.CgoFiles...)\n@@ -1422,7 +1462,7 @@ func (b *builder) build(a *action) (err error) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tcgofiles = append(cgofiles, outGo...)\n+\t\tobjdirCgofiles = append(objdirCgofiles, outGo...)\n \t\tcfiles = append(cfiles, outC...)\n \t\tcxxfiles = append(cxxfiles, outCXX...)\n \t}\n@@ -1457,7 +1497,7 @@ func (b *builder) build(a *action) (err error) {\n \t\tif a.cgo != nil && a.cgo.target != \"\" {\n \t\t\tcgoExe = a.cgo.target\n \t\t}\n-\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, cxxfiles, a.p.MFiles, a.p.FFiles)\n+\t\toutGo, outObj, err := b.cgo(a, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, objdirCgofiles, gccfiles, cxxfiles, a.p.MFiles, a.p.FFiles)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1555,12 +1595,12 @@ func (b *builder) build(a *action) (err error) {\n \t}\n \n \t// Assemble .s files.\n-\tfor _, file := range sfiles {\n-\t\tout := file[:len(file)-len(\".s\")] + \".o\"\n-\t\tif err := buildToolchain.asm(b, a.p, obj, obj+out, file); err != nil {\n+\tif len(sfiles) > 0 {\n+\t\tofiles, err := buildToolchain.asm(b, a.p, obj, sfiles)\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tobjects = append(objects, out)\n+\t\tobjects = append(objects, ofiles...)\n \t}\n \n \t// NOTE(rsc): On Windows, it is critically important that the\n@@ -1599,23 +1639,62 @@ func (b *builder) build(a *action) (err error) {\n \treturn nil\n }\n \n+// pkgconfigCmd returns a pkg-config binary name\n+// defaultPkgConfig is defined in zdefaultcc.go, written by cmd/dist.\n+func (b *builder) pkgconfigCmd() string {\n+\treturn envList(\"PKG_CONFIG\", defaultPkgConfig)[0]\n+}\n+\n+// splitPkgConfigOutput parses the pkg-config output into a slice of\n+// flags. pkg-config always uses \\ to escape special characters.\n+func splitPkgConfigOutput(out []byte) []string {\n+\tif len(out) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar flags []string\n+\tflag := make([]byte, len(out))\n+\tr, w := 0, 0\n+\tfor r < len(out) {\n+\t\tswitch out[r] {\n+\t\tcase ' ', '\\t', '\\r', '\\n':\n+\t\t\tif w > 0 {\n+\t\t\t\tflags = append(flags, string(flag[:w]))\n+\t\t\t}\n+\t\t\tw = 0\n+\t\tcase '\\\\':\n+\t\t\tr++\n+\t\t\tfallthrough\n+\t\tdefault:\n+\t\t\tif r < len(out) {\n+\t\t\t\tflag[w] = out[r]\n+\t\t\t\tw++\n+\t\t\t}\n+\t\t}\n+\t\tr++\n+\t}\n+\tif w > 0 {\n+\t\tflags = append(flags, string(flag[:w]))\n+\t}\n+\treturn flags\n+}\n+\n // Calls pkg-config if needed and returns the cflags/ldflags needed to build the package.\n func (b *builder) getPkgConfigFlags(p *Package) (cflags, ldflags []string, err error) {\n \tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n \t\tvar out []byte\n-\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--cflags\", pkgs)\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.pkgconfigCmd(), \"--cflags\", pkgs)\n \t\tif err != nil {\n-\t\t\tb.showOutput(p.Dir, \"pkg-config --cflags \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.showOutput(p.Dir, b.pkgconfigCmd()+\" --cflags \"+strings.Join(pkgs, \" \"), string(out))\n \t\t\tb.print(err.Error() + \"\\n\")\n \t\t\terr = errPrintedOutput\n \t\t\treturn\n \t\t}\n \t\tif len(out) > 0 {\n-\t\t\tcflags = strings.Fields(string(out))\n+\t\t\tcflags = splitPkgConfigOutput(out)\n \t\t}\n-\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--libs\", pkgs)\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, b.pkgconfigCmd(), \"--libs\", pkgs)\n \t\tif err != nil {\n-\t\t\tb.showOutput(p.Dir, \"pkg-config --libs \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.showOutput(p.Dir, b.pkgconfigCmd()+\" --libs \"+strings.Join(pkgs, \" \"), string(out))\n \t\t\tb.print(err.Error() + \"\\n\")\n \t\t\terr = errPrintedOutput\n \t\t\treturn\n@@ -1656,7 +1735,7 @@ func (b *builder) install(a *action) (err error) {\n \tperm := os.FileMode(0666)\n \tif a1.link {\n \t\tswitch buildBuildmode {\n-\t\tcase \"c-archive\", \"c-shared\":\n+\t\tcase \"c-archive\", \"c-shared\", \"plugin\":\n \t\tdefault:\n \t\t\tperm = 0777\n \t\t}\n@@ -2197,9 +2276,9 @@ type toolchain interface {\n \t// cc runs the toolchain's C compiler in a directory on a C file\n \t// to produce an output file.\n \tcc(b *builder, p *Package, objdir, ofile, cfile string) error\n-\t// asm runs the assembler in a specific directory on a specific file\n-\t// to generate the named output file.\n-\tasm(b *builder, p *Package, obj, ofile, sfile string) error\n+\t// asm runs the assembler in a specific directory on specific files\n+\t// and returns a list of named output files.\n+\tasm(b *builder, p *Package, obj string, sfiles []string) ([]string, error)\n \t// pkgpath builds an appropriate path for a temporary package file.\n \tpkgpath(basedir string, p *Package) string\n \t// pack runs the archive packer in a specific directory to create\n@@ -2236,8 +2315,8 @@ func (noToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool,\n \treturn \"\", nil, noCompiler()\n }\n \n-func (noToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n-\treturn noCompiler()\n+func (noToolchain) asm(b *builder, p *Package, obj string, sfiles []string) ([]string, error) {\n+\treturn nil, noCompiler()\n }\n \n func (noToolchain) pkgpath(basedir string, p *Package) string {\n@@ -2342,23 +2421,27 @@ func (gcToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool,\n \treturn ofile, output, err\n }\n \n-func (gcToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n+func (gcToolchain) asm(b *builder, p *Package, obj string, sfiles []string) ([]string, error) {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n \tinc := filepath.Join(goroot, \"pkg\", \"include\")\n-\tsfile = mkAbs(p.Dir, sfile)\n-\targs := []interface{}{buildToolExec, tool(\"asm\"), \"-o\", ofile, \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch, buildAsmflags}\n+\targs := []interface{}{buildToolExec, tool(\"asm\"), \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch, buildAsmflags}\n \tif p.ImportPath == \"runtime\" && goarch == \"386\" {\n \t\tfor _, arg := range buildAsmflags {\n \t\t\tif arg == \"-dynlink\" {\n \t\t\t\targs = append(args, \"-D=GOBUILDMODE_shared=1\")\n \t\t\t}\n \t\t}\n \t}\n-\targs = append(args, sfile)\n-\tif err := b.run(p.Dir, p.ImportPath, nil, args...); err != nil {\n-\t\treturn err\n+\tvar ofiles []string\n+\tfor _, sfile := range sfiles {\n+\t\tofile := obj + sfile[:len(sfile)-len(\".s\")] + \".o\"\n+\t\tofiles = append(ofiles, ofile)\n+\t\ta := append(args, \"-o\", ofile, mkAbs(p.Dir, sfile))\n+\t\tif err := b.run(p.Dir, p.ImportPath, nil, a...); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n-\treturn nil\n+\treturn ofiles, nil\n }\n \n // toolVerify checks that the command line args writes the same output file\n@@ -2516,6 +2599,13 @@ func (gcToolchain) ld(b *builder, root *action, out string, allactions []*action\n \tif root.p.omitDWARF {\n \t\tldflags = append(ldflags, \"-w\")\n \t}\n+\tif buildBuildmode == \"plugin\" {\n+\t\tpluginpath := root.p.ImportPath\n+\t\tif pluginpath == \"command-line-arguments\" {\n+\t\t\tpluginpath = \"plugin/unnamed-\" + root.p.buildID\n+\t\t}\n+\t\tldflags = append(ldflags, \"-pluginpath\", pluginpath)\n+\t}\n \n \t// If the user has not specified the -extld option, then specify the\n \t// appropriate linker. In case of C++ code, use the compiler named\n@@ -2625,15 +2715,24 @@ func (tools gccgoToolchain) gc(b *builder, p *Package, archive, obj string, asmh\n \treturn ofile, output, err\n }\n \n-func (tools gccgoToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n-\tsfile = mkAbs(p.Dir, sfile)\n-\tdefs := []string{\"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch}\n-\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n-\t\tdefs = append(defs, `-D`, `GOPKGPATH=`+pkgpath)\n+func (tools gccgoToolchain) asm(b *builder, p *Package, obj string, sfiles []string) ([]string, error) {\n+\tvar ofiles []string\n+\tfor _, sfile := range sfiles {\n+\t\tofile := obj + sfile[:len(sfile)-len(\".s\")] + \".o\"\n+\t\tofiles = append(ofiles, ofile)\n+\t\tsfile = mkAbs(p.Dir, sfile)\n+\t\tdefs := []string{\"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch}\n+\t\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n+\t\t\tdefs = append(defs, `-D`, `GOPKGPATH=`+pkgpath)\n+\t\t}\n+\t\tdefs = tools.maybePIC(defs)\n+\t\tdefs = append(defs, b.gccArchArgs()...)\n+\t\terr := b.run(p.Dir, p.ImportPath, nil, tools.compiler(), \"-xassembler-with-cpp\", \"-I\", obj, \"-c\", \"-o\", ofile, defs, sfile)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n-\tdefs = tools.maybePIC(defs)\n-\tdefs = append(defs, b.gccArchArgs()...)\n-\treturn b.run(p.Dir, p.ImportPath, nil, tools.compiler(), \"-xassembler-with-cpp\", \"-I\", obj, \"-c\", \"-o\", ofile, defs, sfile)\n+\treturn ofiles, nil\n }\n \n func (gccgoToolchain) pkgpath(basedir string, p *Package) string {\n@@ -2755,7 +2854,7 @@ func (tools gccgoToolchain) link(b *builder, root *action, out string, allaction\n \t\t\tif !apackagePathsSeen[a.p.ImportPath] {\n \t\t\t\tapackagePathsSeen[a.p.ImportPath] = true\n \t\t\t\ttarget := a.target\n-\t\t\t\tif len(a.p.CgoFiles) > 0 {\n+\t\t\t\tif len(a.p.CgoFiles) > 0 || a.p.usesSwig() {\n \t\t\t\t\ttarget, err = readAndRemoveCgoFlags(target)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\treturn\n@@ -2947,7 +3046,7 @@ func (tools gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile stri\n // maybePIC adds -fPIC to the list of arguments if needed.\n func (tools gccgoToolchain) maybePIC(args []string) []string {\n \tswitch buildBuildmode {\n-\tcase \"c-shared\", \"shared\":\n+\tcase \"c-shared\", \"shared\", \"plugin\":\n \t\targs = append(args, \"-fPIC\")\n \t}\n \treturn args\n@@ -2988,9 +3087,19 @@ func (b *builder) gfortran(p *Package, out string, flags []string, ffile string)\n }\n \n // ccompile runs the given C or C++ compiler and creates an object from a single source file.\n-func (b *builder) ccompile(p *Package, out string, flags []string, file string, compiler []string) error {\n+func (b *builder) ccompile(p *Package, outfile string, flags []string, file string, compiler []string) error {\n \tfile = mkAbs(p.Dir, file)\n-\treturn b.run(p.Dir, p.ImportPath, nil, compiler, flags, \"-o\", out, \"-c\", file)\n+\tdesc := p.ImportPath\n+\toutput, err := b.runOut(p.Dir, desc, nil, compiler, flags, \"-o\", outfile, \"-c\", file)\n+\tif len(output) > 0 {\n+\t\tb.showOutput(p.Dir, desc, b.processOutput(output))\n+\t\tif err != nil {\n+\t\t\terr = errPrintedOutput\n+\t\t} else if os.Getenv(\"GO_BUILDER_NAME\") != \"\" {\n+\t\t\treturn errors.New(\"C compiler warning promoted to error on Go builders\")\n+\t\t}\n+\t}\n+\treturn err\n }\n \n // gccld runs the gcc linker to create an executable from a set of object files.\n@@ -3129,6 +3238,8 @@ func (b *builder) gccArchArgs() []string {\n \t\treturn []string{\"-m64\", \"-march=z196\"}\n \tcase \"mips64\", \"mips64le\":\n \t\treturn []string{\"-mabi=64\"}\n+\tcase \"mips\", \"mipsle\":\n+\t\treturn []string{\"-mabi=32\", \"-march=mips32\"}\n \t}\n \treturn nil\n }\n@@ -3144,11 +3255,8 @@ func envList(key, def string) []string {\n }\n \n // Return the flags to use when invoking the C, C++ or Fortran compilers, or cgo.\n-func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, fflags, ldflags []string) {\n-\tvar defaults string\n-\tif def {\n-\t\tdefaults = \"-g -O2\"\n-\t}\n+func (b *builder) cflags(p *Package) (cppflags, cflags, cxxflags, fflags, ldflags []string) {\n+\tdefaults := \"-g -O2\"\n \n \tcppflags = stringList(envList(\"CGO_CPPFLAGS\", \"\"), p.CgoCPPFLAGS)\n \tcflags = stringList(envList(\"CGO_CFLAGS\", defaults), p.CgoCFLAGS)\n@@ -3160,9 +3268,9 @@ func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, ffla\n \n var cgoRe = regexp.MustCompile(`[/\\\\:]`)\n \n-func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS := b.cflags(p, true)\n-\t_, cgoexeCFLAGS, _, _, _ := b.cflags(p, false)\n+func (b *builder) cgo(a *action, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, objdirCgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {\n+\tp := a.p\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS := b.cflags(p)\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)\n \tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n \t// If we are compiling Objective-C code, then we need to link against libobjc\n@@ -3183,28 +3291,41 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\n \t\t}\n \t}\n \n-\tif buildMSan && p.ImportPath != \"runtime/cgo\" {\n+\tif buildMSan {\n \t\tcgoCFLAGS = append([]string{\"-fsanitize=memory\"}, cgoCFLAGS...)\n \t\tcgoLDFLAGS = append([]string{\"-fsanitize=memory\"}, cgoLDFLAGS...)\n \t}\n \n \t// Allows including _cgo_export.h from .[ch] files in the package.\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, \"-I\", obj)\n \n+\t// If we have cgo files in the object directory, then copy any\n+\t// other cgo files into the object directory, and pass a\n+\t// -srcdir option to cgo.\n+\tvar srcdirarg []string\n+\tif len(objdirCgofiles) > 0 {\n+\t\tfor _, fn := range cgofiles {\n+\t\t\tif err := b.copyFile(a, obj+filepath.Base(fn), filepath.Join(p.Dir, fn), 0666, false); err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\t}\n+\t\tcgofiles = append(cgofiles, objdirCgofiles...)\n+\t\tsrcdirarg = []string{\"-srcdir\", obj}\n+\t}\n+\n \t// cgo\n \t// TODO: CGO_FLAGS?\n \tgofiles := []string{obj + \"_cgo_gotypes.go\"}\n-\tcfiles := []string{\"_cgo_main.c\", \"_cgo_export.c\"}\n+\tcfiles := []string{\"_cgo_export.c\"}\n \tfor _, fn := range cgofiles {\n \t\tf := cgoRe.ReplaceAllString(fn[:len(fn)-2], \"_\")\n \t\tgofiles = append(gofiles, obj+f+\"cgo1.go\")\n \t\tcfiles = append(cfiles, f+\"cgo2.c\")\n \t}\n-\tdefunC := obj + \"_cgo_defun.c\"\n \n-\tcgoflags := []string{}\n \t// TODO: make cgo not depend on $GOARCH?\n \n+\tcgoflags := []string{}\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n \t\tcgoflags = append(cgoflags, \"-import_runtime_cgo=false\")\n \t}\n@@ -3241,165 +3362,166 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\n \t\tcgoflags = append(cgoflags, \"-exportheader=\"+obj+\"_cgo_install.h\")\n \t}\n \n-\tif err := b.run(p.Dir, p.ImportPath, cgoenv, buildToolExec, cgoExe, \"-objdir\", obj, \"-importpath\", p.ImportPath, cgoflags, \"--\", cgoCPPFLAGS, cgoexeCFLAGS, cgofiles); err != nil {\n+\tif err := b.run(p.Dir, p.ImportPath, cgoenv, buildToolExec, cgoExe, srcdirarg, \"-objdir\", obj, \"-importpath\", p.ImportPath, cgoflags, \"--\", cgoCPPFLAGS, cgoCFLAGS, cgofiles); err != nil {\n \t\treturn nil, nil, err\n \t}\n \toutGo = append(outGo, gofiles...)\n \n-\t// cc _cgo_defun.c\n-\t_, gccgo := buildToolchain.(gccgoToolchain)\n-\tif gccgo {\n-\t\tdefunObj := obj + \"_cgo_defun.o\"\n-\t\tif err := buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\toutObj = append(outObj, defunObj)\n-\t}\n-\n \t// gcc\n-\tvar linkobj []string\n-\n-\tvar bareLDFLAGS []string\n-\t// When linking relocatable objects, various flags need to be\n-\t// filtered out as they are inapplicable and can cause some linkers\n-\t// to fail.\n-\tfor i := 0; i < len(cgoLDFLAGS); i++ {\n-\t\tf := cgoLDFLAGS[i]\n-\t\tswitch {\n-\t\t// skip \"-lc\" or \"-l somelib\"\n-\t\tcase strings.HasPrefix(f, \"-l\"):\n-\t\t\tif f == \"-l\" {\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t// skip \"-framework X\" on Darwin\n-\t\tcase goos == \"darwin\" && f == \"-framework\":\n-\t\t\ti++\n-\t\t// skip \"*.{dylib,so,dll}\"\n-\t\tcase strings.HasSuffix(f, \".dylib\"),\n-\t\t\tstrings.HasSuffix(f, \".so\"),\n-\t\t\tstrings.HasSuffix(f, \".dll\"):\n-\t\t// Remove any -fsanitize=foo flags.\n-\t\t// Otherwise the compiler driver thinks that we are doing final link\n-\t\t// and links sanitizer runtime into the object file. But we are not doing\n-\t\t// the final link, we will link the resulting object file again. And\n-\t\t// so the program ends up with two copies of sanitizer runtime.\n-\t\t// See issue 8788 for details.\n-\t\tcase strings.HasPrefix(f, \"-fsanitize=\"):\n-\t\t\tcontinue\n-\t\t// runpath flags not applicable unless building a shared\n-\t\t// object or executable; see issue 12115 for details. This\n-\t\t// is necessary as Go currently does not offer a way to\n-\t\t// specify the set of LDFLAGS that only apply to shared\n-\t\t// objects.\n-\t\tcase strings.HasPrefix(f, \"-Wl,-rpath\"):\n-\t\t\tif f == \"-Wl,-rpath\" || f == \"-Wl,-rpath-link\" {\n-\t\t\t\t// Skip following argument to -rpath* too.\n-\t\t\t\ti++\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tbareLDFLAGS = append(bareLDFLAGS, f)\n-\t\t}\n-\t}\n-\n-\tvar staticLibs []string\n-\tif goos == \"windows\" {\n-\t\t// libmingw32 and libmingwex have some inter-dependencies,\n-\t\t// so must use linker groups.\n-\t\tstaticLibs = []string{\"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\"}\n-\t}\n-\n \tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\n \tfor _, cfile := range cfiles {\n \t\tofile := obj + cfile[:len(cfile)-1] + \"o\"\n \t\tif err := b.gcc(p, ofile, cflags, obj+cfile); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n-\t\tlinkobj = append(linkobj, ofile)\n-\t\tif !strings.HasSuffix(ofile, \"_cgo_main.o\") {\n-\t\t\toutObj = append(outObj, ofile)\n-\t\t}\n+\t\toutObj = append(outObj, ofile)\n \t}\n \n \tfor _, file := range gccfiles {\n-\t\tofile := obj + cgoRe.ReplaceAllString(file[:len(file)-1], \"_\") + \"o\"\n+\t\tbase := filepath.Base(file)\n+\t\tofile := obj + cgoRe.ReplaceAllString(base[:len(base)-1], \"_\") + \"o\"\n \t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n-\t\tlinkobj = append(linkobj, ofile)\n \t\toutObj = append(outObj, ofile)\n \t}\n \n \tcxxflags := stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n \tfor _, file := range gxxfiles {\n \t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n-\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tofile := obj + cgoRe.ReplaceAllString(filepath.Base(file), \"_\") + \".o\"\n \t\tif err := b.gxx(p, ofile, cxxflags, file); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n-\t\tlinkobj = append(linkobj, ofile)\n \t\toutObj = append(outObj, ofile)\n \t}\n \n \tfor _, file := range mfiles {\n \t\t// Append .o to the file, just in case the pkg has file.c and file.m\n-\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tofile := obj + cgoRe.ReplaceAllString(filepath.Base(file), \"_\") + \".o\"\n \t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n-\t\tlinkobj = append(linkobj, ofile)\n \t\toutObj = append(outObj, ofile)\n \t}\n \n \tfflags := stringList(cgoCPPFLAGS, cgoFFLAGS)\n \tfor _, file := range ffiles {\n \t\t// Append .o to the file, just in case the pkg has file.c and file.f\n-\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tofile := obj + cgoRe.ReplaceAllString(filepath.Base(file), \"_\") + \".o\"\n \t\tif err := b.gfortran(p, ofile, fflags, file); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n-\t\tlinkobj = append(linkobj, ofile)\n \t\toutObj = append(outObj, ofile)\n \t}\n \n-\tlinkobj = append(linkobj, p.SysoFiles...)\n-\tdynobj := obj + \"_cgo_.o\"\n-\tpie := (goarch == \"arm\" && goos == \"linux\") || goos == \"android\"\n-\tif pie { // we need to use -pie for Linux/ARM to get accurate imported sym\n-\t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-pie\")\n-\t}\n-\tif err := b.gccld(p, dynobj, cgoLDFLAGS, linkobj); err != nil {\n-\t\treturn nil, nil, err\n+\tswitch buildToolchain.(type) {\n+\tcase gcToolchain:\n+\t\timportGo := obj + \"_cgo_import.go\"\n+\t\tif err := b.dynimport(p, obj, importGo, cgoExe, cflags, cgoLDFLAGS, outObj); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutGo = append(outGo, importGo)\n+\n+\t\tofile := obj + \"_all.o\"\n+\t\tif err := b.collect(p, obj, ofile, cgoLDFLAGS, outObj); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = []string{ofile}\n+\n+\tcase gccgoToolchain:\n+\t\tdefunC := obj + \"_cgo_defun.c\"\n+\t\tdefunObj := obj + \"_cgo_defun.o\"\n+\t\tif err := buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = append(outObj, defunObj)\n+\n+\tdefault:\n+\t\tnoCompiler()\n \t}\n-\tif pie { // but we don't need -pie for normal cgo programs\n-\t\tcgoLDFLAGS = cgoLDFLAGS[0 : len(cgoLDFLAGS)-1]\n+\n+\treturn outGo, outObj, nil\n+}\n+\n+// dynimport creates a Go source file named importGo containing\n+// //go:cgo_import_dynamic directives for each symbol or library\n+// dynamically imported by the object files outObj.\n+func (b *builder) dynimport(p *Package, obj, importGo, cgoExe string, cflags, cgoLDFLAGS, outObj []string) error {\n+\tcfile := obj + \"_cgo_main.c\"\n+\tofile := obj + \"_cgo_main.o\"\n+\tif err := b.gcc(p, ofile, cflags, cfile); err != nil {\n+\t\treturn err\n \t}\n \n-\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n-\t\t// we don't use dynimport when using gccgo.\n-\t\treturn outGo, outObj, nil\n+\tlinkobj := stringList(ofile, outObj, p.SysoFiles)\n+\tdynobj := obj + \"_cgo_.o\"\n+\n+\t// we need to use -pie for Linux/ARM to get accurate imported sym\n+\tldflags := cgoLDFLAGS\n+\tif (goarch == \"arm\" && goos == \"linux\") || goos == \"android\" {\n+\t\tldflags = append(ldflags, \"-pie\")\n+\t}\n+\tif err := b.gccld(p, dynobj, ldflags, linkobj); err != nil {\n+\t\treturn err\n \t}\n \n \t// cgo -dynimport\n-\timportGo := obj + \"_cgo_import.go\"\n-\tcgoflags = []string{}\n+\tvar cgoflags []string\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n-\t\tcgoflags = append(cgoflags, \"-dynlinker\") // record path to dynamic linker\n-\t}\n-\tif err := b.run(p.Dir, p.ImportPath, nil, buildToolExec, cgoExe, \"-objdir\", obj, \"-dynpackage\", p.Name, \"-dynimport\", dynobj, \"-dynout\", importGo, cgoflags); err != nil {\n-\t\treturn nil, nil, err\n+\t\tcgoflags = []string{\"-dynlinker\"} // record path to dynamic linker\n \t}\n-\toutGo = append(outGo, importGo)\n+\treturn b.run(p.Dir, p.ImportPath, nil, buildToolExec, cgoExe, \"-dynpackage\", p.Name, \"-dynimport\", dynobj, \"-dynout\", importGo, cgoflags)\n+}\n \n-\tofile := obj + \"_all.o\"\n-\tvar gccObjs, nonGccObjs []string\n-\tfor _, f := range outObj {\n-\t\tif strings.HasSuffix(f, \".o\") {\n-\t\t\tgccObjs = append(gccObjs, f)\n-\t\t} else {\n-\t\t\tnonGccObjs = append(nonGccObjs, f)\n+// collect partially links the object files outObj into a single\n+// relocatable object file named ofile.\n+func (b *builder) collect(p *Package, obj, ofile string, cgoLDFLAGS, outObj []string) error {\n+\t// When linking relocatable objects, various flags need to be\n+\t// filtered out as they are inapplicable and can cause some linkers\n+\t// to fail.\n+\tvar ldflags []string\n+\tfor i := 0; i < len(cgoLDFLAGS); i++ {\n+\t\tf := cgoLDFLAGS[i]\n+\t\tswitch {\n+\t\t// skip \"-lc\" or \"-l somelib\"\n+\t\tcase strings.HasPrefix(f, \"-l\"):\n+\t\t\tif f == \"-l\" {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t// skip \"-framework X\" on Darwin\n+\t\tcase goos == \"darwin\" && f == \"-framework\":\n+\t\t\ti++\n+\t\t// skip \"*.{dylib,so,dll,o,a}\"\n+\t\tcase strings.HasSuffix(f, \".dylib\"),\n+\t\t\tstrings.HasSuffix(f, \".so\"),\n+\t\t\tstrings.HasSuffix(f, \".dll\"),\n+\t\t\tstrings.HasSuffix(f, \".o\"),\n+\t\t\tstrings.HasSuffix(f, \".a\"):\n+\t\t// Remove any -fsanitize=foo flags.\n+\t\t// Otherwise the compiler driver thinks that we are doing final link\n+\t\t// and links sanitizer runtime into the object file. But we are not doing\n+\t\t// the final link, we will link the resulting object file again. And\n+\t\t// so the program ends up with two copies of sanitizer runtime.\n+\t\t// See issue 8788 for details.\n+\t\tcase strings.HasPrefix(f, \"-fsanitize=\"):\n+\t\t\tcontinue\n+\t\t// runpath flags not applicable unless building a shared\n+\t\t// object or executable; see issue 12115 for details. This\n+\t\t// is necessary as Go currently does not offer a way to\n+\t\t// specify the set of LDFLAGS that only apply to shared\n+\t\t// objects.\n+\t\tcase strings.HasPrefix(f, \"-Wl,-rpath\"):\n+\t\t\tif f == \"-Wl,-rpath\" || f == \"-Wl,-rpath-link\" {\n+\t\t\t\t// Skip following argument to -rpath* too.\n+\t\t\t\ti++\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tldflags = append(ldflags, f)\n \t\t}\n \t}\n-\tldflags := stringList(bareLDFLAGS, \"-Wl,-r\", \"-nostdlib\", staticLibs)\n+\n+\tldflags = append(ldflags, \"-Wl,-r\", \"-nostdlib\")\n \n \tif b.gccSupportsNoPie() {\n \t\tldflags = append(ldflags, \"-no-pie\")\n@@ -3408,16 +3530,7 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\n \t// We are creating an object file, so we don't want a build ID.\n \tldflags = b.disableBuildID(ldflags)\n \n-\tif err := b.gccld(p, ofile, ldflags, gccObjs); err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\t// NOTE(rsc): The importObj is a 5c/6c/8c object and on Windows\n-\t// must be processed before the gcc-generated objects.\n-\t// Put it first.  https://golang.org/issue/2601\n-\toutObj = stringList(nonGccObjs, ofile)\n-\n-\treturn outGo, outObj, nil\n+\treturn b.gccld(p, ofile, ldflags, outObj)\n }\n \n // Run SWIG on all SWIG input files.\n@@ -3570,7 +3683,7 @@ func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n \n // Run SWIG on one SWIG input file.\n func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _ := b.cflags(p, true)\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _ := b.cflags(p)\n \tvar cflags []string\n \tif cxx {\n \t\tcflags = stringList(cgoCPPFLAGS, pcCFLAGS, cgoCXXFLAGS)\n@@ -3633,7 +3746,7 @@ func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx b\n \t\tb.showOutput(p.Dir, p.ImportPath, b.processOutput(out)) // swig warning\n \t}\n \n-\treturn obj + goFile, obj + gccBase + gccExt, nil\n+\treturn goFile, obj + gccBase + gccExt, nil\n }\n \n // disableBuildID adjusts a linker command line to avoid creating a\n@@ -3682,7 +3795,11 @@ func instrumentInit() {\n \t\treturn\n \t}\n \tif buildRace && buildMSan {\n-\t\tfmt.Fprintf(os.Stderr, \"go %s: may not use -race and -msan simultaneously\", flag.Args()[0])\n+\t\tfmt.Fprintf(os.Stderr, \"go %s: may not use -race and -msan simultaneously\\n\", flag.Args()[0])\n+\t\tos.Exit(2)\n+\t}\n+\tif buildMSan && (goos != \"linux\" || goarch != \"amd64\") {\n+\t\tfmt.Fprintf(os.Stderr, \"-msan is not supported on %s/%s\\n\", goos, goarch)\n \t\tos.Exit(2)\n \t}\n \tif goarch != \"amd64\" || goos != \"linux\" && goos != \"freebsd\" && goos != \"darwin\" && goos != \"windows\" {"}, {"sha": "79bbd545915badb95a7b60a876946451873b802b", "filename": "libgo/go/cmd/go/build_test.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"os\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+func TestRemoveDevNull(t *testing.T) {\n+\tfi, err := os.Lstat(os.DevNull)\n+\tif err != nil {\n+\t\tt.Skip(err)\n+\t}\n+\tif fi.Mode().IsRegular() {\n+\t\tt.Errorf(\"Lstat(%s).Mode().IsRegular() = true; expected false\", os.DevNull)\n+\t}\n+\tmayberemovefile(os.DevNull)\n+\t_, err = os.Lstat(os.DevNull)\n+\tif err != nil {\n+\t\tt.Errorf(\"mayberemovefile(%s) did remove it; oops\", os.DevNull)\n+\t}\n+}\n+\n+func TestSplitPkgConfigOutput(t *testing.T) {\n+\tfor _, test := range []struct {\n+\t\tin   []byte\n+\t\twant []string\n+\t}{\n+\t\t{[]byte(`-r:foo -L/usr/white\\ space/lib -lfoo\\ bar -lbar\\ baz`), []string{\"-r:foo\", \"-L/usr/white space/lib\", \"-lfoo bar\", \"-lbar baz\"}},\n+\t\t{[]byte(`-lextra\\ fun\\ arg\\\\`), []string{`-lextra fun arg\\`}},\n+\t\t{[]byte(`broken flag\\`), []string{\"broken\", \"flag\"}},\n+\t\t{[]byte(\"\\textra     whitespace\\r\\n\"), []string{\"extra\", \"whitespace\"}},\n+\t\t{[]byte(\"     \\r\\n      \"), nil},\n+\t} {\n+\t\tgot := splitPkgConfigOutput(test.in)\n+\t\tif !reflect.DeepEqual(got, test.want) {\n+\t\t\tt.Errorf(\"splitPkgConfigOutput(%v) = %v; want %v\", test.in, got, test.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "31710b7e6d62fbf36da4931daec635e6fef434ca", "filename": "libgo/go/cmd/go/env.go", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -40,7 +40,7 @@ func mkEnv() []envVar {\n \t\t{\"GOHOSTARCH\", runtime.GOARCH},\n \t\t{\"GOHOSTOS\", runtime.GOOS},\n \t\t{\"GOOS\", goos},\n-\t\t{\"GOPATH\", os.Getenv(\"GOPATH\")},\n+\t\t{\"GOPATH\", buildContext.GOPATH},\n \t\t{\"GORACE\", os.Getenv(\"GORACE\")},\n \t\t{\"GOROOT\", goroot},\n \t\t{\"GOTOOLDIR\", toolDir},\n@@ -49,14 +49,25 @@ func mkEnv() []envVar {\n \t\t{\"TERM\", \"dumb\"},\n \t}\n \n-\tif goos != \"plan9\" {\n-\t\tcmd := b.gccCmd(\".\")\n-\t\tenv = append(env, envVar{\"CC\", cmd[0]})\n-\t\tenv = append(env, envVar{\"GOGCCFLAGS\", strings.Join(cmd[3:], \" \")})\n-\t\tcmd = b.gxxCmd(\".\")\n-\t\tenv = append(env, envVar{\"CXX\", cmd[0]})\n+\tif gccgoBin != \"\" {\n+\t\tenv = append(env, envVar{\"GCCGO\", gccgoBin})\n+\t} else {\n+\t\tenv = append(env, envVar{\"GCCGO\", gccgoName})\n+\t}\n+\n+\tswitch goarch {\n+\tcase \"arm\":\n+\t\tenv = append(env, envVar{\"GOARM\", os.Getenv(\"GOARM\")})\n+\tcase \"386\":\n+\t\tenv = append(env, envVar{\"GO386\", os.Getenv(\"GO386\")})\n \t}\n \n+\tcmd := b.gccCmd(\".\")\n+\tenv = append(env, envVar{\"CC\", cmd[0]})\n+\tenv = append(env, envVar{\"GOGCCFLAGS\", strings.Join(cmd[3:], \" \")})\n+\tcmd = b.gxxCmd(\".\")\n+\tenv = append(env, envVar{\"CXX\", cmd[0]})\n+\n \tif buildContext.CgoEnabled {\n \t\tenv = append(env, envVar{\"CGO_ENABLED\", \"1\"})\n \t} else {\n@@ -75,8 +86,24 @@ func findEnv(env []envVar, name string) string {\n \treturn \"\"\n }\n \n+// extraEnvVars returns environment variables that should not leak into child processes.\n+func extraEnvVars() []envVar {\n+\tvar b builder\n+\tb.init()\n+\tcppflags, cflags, cxxflags, fflags, ldflags := b.cflags(&Package{})\n+\treturn []envVar{\n+\t\t{\"PKG_CONFIG\", b.pkgconfigCmd()},\n+\t\t{\"CGO_CFLAGS\", strings.Join(cflags, \" \")},\n+\t\t{\"CGO_CPPFLAGS\", strings.Join(cppflags, \" \")},\n+\t\t{\"CGO_CXXFLAGS\", strings.Join(cxxflags, \" \")},\n+\t\t{\"CGO_FFLAGS\", strings.Join(fflags, \" \")},\n+\t\t{\"CGO_LDFLAGS\", strings.Join(ldflags, \" \")},\n+\t}\n+}\n+\n func runEnv(cmd *Command, args []string) {\n-\tenv := mkEnv()\n+\tenv := newEnv\n+\tenv = append(env, extraEnvVars()...)\n \tif len(args) > 0 {\n \t\tfor _, name := range args {\n \t\t\tfmt.Printf(\"%s\\n\", findEnv(env, name))"}, {"sha": "2d92a0c100ca169f21afeb9a91bef16e579832eb", "filename": "libgo/go/cmd/go/generate.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -25,7 +25,7 @@ var cmdGenerate = &Command{\n \tLong: `\n Generate runs commands described by directives within existing\n files. Those commands can run any process but the intent is to\n-create or update Go source files, for instance by running yacc.\n+create or update Go source files.\n \n Go generate is never run automatically by go build, go get, go test,\n and so on. It must be run explicitly.\n@@ -88,10 +88,10 @@ string xxx represents the command identified by the arguments. This\n can be used to create aliases or to handle multiword generators.\n For example,\n \n-\t//go:generate -command yacc go tool yacc\n+\t//go:generate -command foo go tool foo\n \n-specifies that the command \"yacc\" represents the generator\n-\"go tool yacc\".\n+specifies that the command \"foo\" represents the generator\n+\"go tool foo\".\n \n Generate processes packages in the order given on the command line,\n one at a time. If the command line lists .go files, they are treated\n@@ -136,6 +136,8 @@ func init() {\n }\n \n func runGenerate(cmd *Command, args []string) {\n+\tignoreImports = true\n+\n \tif generateRunFlag != \"\" {\n \t\tvar err error\n \t\tgenerateRunRE, err = regexp.Compile(generateRunFlag)"}, {"sha": "1d7677c615c176e0150576e831bc58ae5f83db52", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -43,11 +43,13 @@ The -u flag instructs get to use the network to update the named packages\n and their dependencies.  By default, get uses the network to check out\n missing packages but does not use it to look for updates to existing packages.\n \n+The -v flag enables verbose progress and debug output.\n+\n Get also accepts build flags to control the installation. See 'go help build'.\n \n When checking out a new package, get creates the target directory\n GOPATH/src/<import-path>. If the GOPATH contains multiple entries,\n-get uses the first one. See 'go help gopath'.\n+get uses the first one. For more details see: 'go help gopath'.\n \n When checking out or updating a package, get looks for a branch or tag\n that matches the locally installed version of Go. The most important\n@@ -96,13 +98,31 @@ func runGet(cmd *Command, args []string) {\n \t\tos.Setenv(\"GIT_TERMINAL_PROMPT\", \"0\")\n \t}\n \n+\t// Disable any ssh connection pooling by Git.\n+\t// If a Git subprocess forks a child into the background to cache a new connection,\n+\t// that child keeps stdout/stderr open. After the Git subprocess exits,\n+\t// os /exec expects to be able to read from the stdout/stderr pipe\n+\t// until EOF to get all the data that the Git subprocess wrote before exiting.\n+\t// The EOF doesn't come until the child exits too, because the child\n+\t// is holding the write end of the pipe.\n+\t// This is unfortunate, but it has come up at least twice\n+\t// (see golang.org/issue/13453 and golang.org/issue/16104)\n+\t// and confuses users when it does.\n+\t// If the user has explicitly set GIT_SSH or GIT_SSH_COMMAND,\n+\t// assume they know what they are doing and don't step on it.\n+\t// But default to turning off ControlMaster.\n+\tif os.Getenv(\"GIT_SSH\") == \"\" && os.Getenv(\"GIT_SSH_COMMAND\") == \"\" {\n+\t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n+\t}\n+\n \t// Phase 1.  Download/update.\n \tvar stk importStack\n \tmode := 0\n \tif *getT {\n \t\tmode |= getTestDeps\n \t}\n-\tfor _, arg := range downloadPaths(args) {\n+\targs = downloadPaths(args)\n+\tfor _, arg := range args {\n \t\tdownload(arg, nil, &stk, mode)\n \t}\n \texitIfErrors()\n@@ -137,7 +157,7 @@ func runGet(cmd *Command, args []string) {\n \t\treturn\n \t}\n \n-\trunInstall(cmd, args)\n+\tinstallPackages(args, true)\n }\n \n // downloadPaths prepares the list of paths to pass to download.\n@@ -177,14 +197,18 @@ var downloadCache = map[string]bool{}\n \n // downloadRootCache records the version control repository\n // root directories we have already considered during the download.\n-// For example, all the packages in the code.google.com/p/codesearch repo\n+// For example, all the packages in the github.com/google/codesearch repo\n // share the same root (the directory for that path), and we only need\n // to run the hg commands to consider each repository once.\n var downloadRootCache = map[string]bool{}\n \n // download runs the download half of the get command\n // for the package named by the argument.\n func download(arg string, parent *Package, stk *importStack, mode int) {\n+\tif mode&useVendor != 0 {\n+\t\t// Caller is responsible for expanding vendor paths.\n+\t\tpanic(\"internal error: download mode has useVendor set\")\n+\t}\n \tload := func(path string, mode int) *Package {\n \t\tif parent == nil {\n \t\t\treturn loadPackage(path, stk)\n@@ -295,32 +319,42 @@ func download(arg string, parent *Package, stk *importStack, mode int) {\n \t\t}\n \n \t\t// Process dependencies, now that we know what they are.\n-\t\tfor _, path := range p.Imports {\n+\t\timports := p.Imports\n+\t\tif mode&getTestDeps != 0 {\n+\t\t\t// Process test dependencies when -t is specified.\n+\t\t\t// (But don't get test dependencies for test dependencies:\n+\t\t\t// we always pass mode 0 to the recursive calls below.)\n+\t\t\timports = stringList(imports, p.TestImports, p.XTestImports)\n+\t\t}\n+\t\tfor i, path := range imports {\n \t\t\tif path == \"C\" {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\t// Don't get test dependencies recursively.\n-\t\t\t// Imports is already vendor-expanded.\n-\t\t\tdownload(path, p, stk, 0)\n-\t\t}\n-\t\tif mode&getTestDeps != 0 {\n-\t\t\t// Process test dependencies when -t is specified.\n-\t\t\t// (Don't get test dependencies for test dependencies.)\n-\t\t\t// We pass useVendor here because p.load does not\n-\t\t\t// vendor-expand TestImports and XTestImports.\n-\t\t\t// The call to loadImport inside download needs to do that.\n-\t\t\tfor _, path := range p.TestImports {\n-\t\t\t\tif path == \"C\" {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tdownload(path, p, stk, useVendor)\n+\t\t\t// Fail fast on import naming full vendor path.\n+\t\t\t// Otherwise expand path as needed for test imports.\n+\t\t\t// Note that p.Imports can have additional entries beyond p.build.Imports.\n+\t\t\torig := path\n+\t\t\tif i < len(p.build.Imports) {\n+\t\t\t\torig = p.build.Imports[i]\n \t\t\t}\n-\t\t\tfor _, path := range p.XTestImports {\n-\t\t\t\tif path == \"C\" {\n-\t\t\t\t\tcontinue\n+\t\t\tif j, ok := findVendor(orig); ok {\n+\t\t\t\tstk.push(path)\n+\t\t\t\terr := &PackageError{\n+\t\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\t\tErr:         \"must be imported as \" + path[j+len(\"vendor/\"):],\n \t\t\t\t}\n-\t\t\t\tdownload(path, p, stk, useVendor)\n+\t\t\t\tstk.pop()\n+\t\t\t\terrorf(\"%s\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// If this is a test import, apply vendor lookup now.\n+\t\t\t// We cannot pass useVendor to download, because\n+\t\t\t// download does caching based on the value of path,\n+\t\t\t// so it must be the fully qualified path already.\n+\t\t\tif i >= len(p.Imports) {\n+\t\t\t\tpath = vendoredImportPath(p, path)\n \t\t\t}\n+\t\t\tdownload(path, p, stk, 0)\n \t\t}\n \n \t\tif isWildcard {\n@@ -368,7 +402,7 @@ func downloadPackage(p *Package) error {\n \t\t\t\t\t\t\trepo = resolved\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif remote != repo && p.ImportComment != \"\" {\n+\t\t\t\t\tif remote != repo && rr.isCustom {\n \t\t\t\t\t\treturn fmt.Errorf(\"%s is a custom import path for %s, but %s is checked out from %s\", rr.root, repo, dir, remote)\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -391,12 +425,16 @@ func downloadPackage(p *Package) error {\n \t\t// Package not found. Put in first directory of $GOPATH.\n \t\tlist := filepath.SplitList(buildContext.GOPATH)\n \t\tif len(list) == 0 {\n-\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: go help gopath\")\n+\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: 'go help gopath'\")\n \t\t}\n \t\t// Guard against people setting GOPATH=$GOROOT.\n \t\tif list[0] == goroot {\n-\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH must not be set to $GOROOT. For more details see: go help gopath\")\n+\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'\")\n \t\t}\n+\t\tif _, err := os.Stat(filepath.Join(list[0], \"src/cmd/go/alldocs.go\")); err == nil {\n+\t\t\treturn fmt.Errorf(\"cannot download, %s is a GOROOT, not a GOPATH. For more details see: 'go help gopath'\", list[0])\n+\t\t}\n+\t\tp.build.Root = list[0]\n \t\tp.build.SrcRoot = filepath.Join(list[0], \"src\")\n \t\tp.build.PkgRoot = filepath.Join(list[0], \"pkg\")\n \t}\n@@ -425,11 +463,19 @@ func downloadPackage(p *Package) error {\n \t\tif _, err := os.Stat(root); err == nil {\n \t\t\treturn fmt.Errorf(\"%s exists but %s does not - stale checkout?\", root, meta)\n \t\t}\n+\n+\t\t_, err := os.Stat(p.build.Root)\n+\t\tgopathExisted := err == nil\n+\n \t\t// Some version control tools require the parent of the target to exist.\n \t\tparent, _ := filepath.Split(root)\n \t\tif err = os.MkdirAll(parent, 0777); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif buildV && !gopathExisted && p.build.Root == buildContext.GOPATH {\n+\t\t\tfmt.Fprintf(os.Stderr, \"created GOPATH=%s; see 'go help gopath'\\n\", p.build.Root)\n+\t\t}\n+\n \t\tif err = vcs.create(root, repo); err != nil {\n \t\t\treturn err\n \t\t}"}, {"sha": "5727eb094e5473a1b5eadaed70a53e16aa9f0ef9", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 886, "deletions": 53, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -6,7 +6,6 @@ package main_test\n \n import (\n \t\"bytes\"\n-\t\"flag\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/format\"\n@@ -50,6 +49,17 @@ func init() {\n \t\t\t// many linux/arm machines are too slow to run\n \t\t\t// the full set of external tests.\n \t\t\tskipExternal = true\n+\t\tcase \"mips\", \"mipsle\", \"mips64\", \"mips64le\":\n+\t\t\t// Also slow.\n+\t\t\tskipExternal = true\n+\t\t\tif testenv.Builder() != \"\" {\n+\t\t\t\t// On the builders, skip the cmd/go\n+\t\t\t\t// tests. They're too slow and already\n+\t\t\t\t// covered by other ports. There's\n+\t\t\t\t// nothing os/arch specific in the\n+\t\t\t\t// tests.\n+\t\t\t\tcanRun = false\n+\t\t\t}\n \t\t}\n \tcase \"freebsd\":\n \t\tswitch runtime.GOARCH {\n@@ -67,8 +77,6 @@ func init() {\n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n func TestMain(m *testing.M) {\n-\tflag.Parse()\n-\n \tif canRun {\n \t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\" + exeSuffix}\n \t\tif race.Enabled {\n@@ -99,6 +107,14 @@ func TestMain(m *testing.M) {\n \t// Don't let these environment variables confuse the test.\n \tos.Unsetenv(\"GOBIN\")\n \tos.Unsetenv(\"GOPATH\")\n+\tos.Unsetenv(\"GIT_ALLOW_PROTOCOL\")\n+\tif home, ccacheDir := os.Getenv(\"HOME\"), os.Getenv(\"CCACHE_DIR\"); home != \"\" && ccacheDir == \"\" {\n+\t\t// On some systems the default C compiler is ccache.\n+\t\t// Setting HOME to a non-existent directory will break\n+\t\t// those systems.  Set CCACHE_DIR to cope.  Issue 17668.\n+\t\tos.Setenv(\"CCACHE_DIR\", filepath.Join(home, \".ccache\"))\n+\t}\n+\tos.Setenv(\"HOME\", \"/test-go-home-does-not-exist\")\n \n \tr := m.Run()\n \n@@ -627,6 +643,7 @@ func TestProgramNameInCrashMessages(t *testing.T) {\n func TestBrokenTestsWithoutTestFunctionsAllFail(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.runFail(\"test\", \"./testdata/src/badtest/...\")\n \ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n \ttg.grepBoth(\"FAIL.*badtest/badexec\", \"test did not run everything\")\n@@ -742,6 +759,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n func TestGoListStandard(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.cd(runtime.GOROOT() + \"/src\")\n \ttg.run(\"list\", \"-f\", \"{{if not .Standard}}{{.ImportPath}}{{end}}\", \"./...\")\n \tstdout := tg.getStdout()\n@@ -766,6 +784,7 @@ func TestGoListStandard(t *testing.T) {\n func TestGoInstallCleansUpAfterGoBuild(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.tempFile(\"src/mycmd/main.go\", `package main; func main(){}`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.cd(tg.path(\"src/mycmd\"))\n@@ -857,6 +876,7 @@ func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n func TestWildcardMatchesSyntaxErrorDirs(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.tempFile(\"src/mypkg/x.go\", `package mypkg`)\n \ttg.tempFile(\"src/mypkg/y.go\", `pkg mypackage`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n@@ -1013,6 +1033,7 @@ func copyBad(tg *testgoData) {\n func TestBadImportsEasy(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \tcopyBad(tg)\n \ttestLocalEasy(tg, badDirName)\n }\n@@ -1042,14 +1063,14 @@ func TestInternalPackagesInGOROOTAreRespected(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal\")\n-\ttg.grepBoth(\"use of internal package not allowed\", \"wrong error message for testdata/testinternal\")\n+\ttg.grepBoth(`testinternal(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package not allowed`, \"wrong error message for testdata/testinternal\")\n }\n \n func TestInternalPackagesOutsideGOROOTAreRespected(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal2\")\n-\ttg.grepBoth(\"use of internal package not allowed\", \"wrote error message for testdata/testinternal2\")\n+\ttg.grepBoth(`testinternal2(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package not allowed`, \"wrote error message for testdata/testinternal2\")\n }\n \n func TestRunInternal(t *testing.T) {\n@@ -1059,7 +1080,7 @@ func TestRunInternal(t *testing.T) {\n \ttg.setenv(\"GOPATH\", dir)\n \ttg.run(\"run\", filepath.Join(dir, \"src/run/good.go\"))\n \ttg.runFail(\"run\", filepath.Join(dir, \"src/run/bad.go\"))\n-\ttg.grepStderr(\"use of internal package not allowed\", \"unexpected error for run/bad.go\")\n+\ttg.grepStderr(`testdata(\\/|\\\\)src(\\/|\\\\)run(\\/|\\\\)bad\\.go\\:3\\:8\\: use of internal package not allowed`, \"unexpected error for run/bad.go\")\n }\n \n func testMove(t *testing.T, vcs, url, base, config string) {\n@@ -1180,6 +1201,23 @@ func TestIssue10952(t *testing.T) {\n \ttg.run(\"get\", \"-d\", \"-u\", importPath)\n }\n \n+func TestIssue16471(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.must(os.MkdirAll(tg.path(\"src/rsc.io/go-get-issue-10952\"), 0755))\n+\ttg.runGit(tg.path(\"src/rsc.io\"), \"clone\", \"https://github.com/zombiezen/go-get-issue-10952\")\n+\ttg.runFail(\"get\", \"-u\", \"rsc.io/go-get-issue-10952\")\n+\ttg.grepStderr(\"rsc.io/go-get-issue-10952 is a custom import path for https://github.com/rsc/go-get-issue-10952, but .* is checked out from https://github.com/zombiezen/go-get-issue-10952\", \"did not detect updated import path\")\n+}\n+\n // Test git clone URL that uses SCP-like syntax and custom import path checking.\n func TestIssue11457(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -1192,7 +1230,7 @@ func TestIssue11457(t *testing.T) {\n \ttg.parallel()\n \ttg.tempDir(\"src\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\tconst importPath = \"github.com/rsc/go-get-issue-11457\"\n+\tconst importPath = \"rsc.io/go-get-issue-11457\"\n \ttg.run(\"get\", \"-d\", \"-u\", importPath)\n \trepoDir := tg.path(\"src/\" + importPath)\n \ttg.runGit(repoDir, \"remote\", \"set-url\", \"origin\", \"git@github.com:rsc/go-get-issue-11457\")\n@@ -1267,11 +1305,23 @@ func TestRelativeImportsGoTestDashI(t *testing.T) {\n func TestRelativeImportsInCommandLinePackage(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \tfiles, err := filepath.Glob(\"./testdata/testimport/*.go\")\n \ttg.must(err)\n \ttg.run(append([]string{\"test\"}, files...)...)\n }\n \n+func TestNonCanonicalImportPaths(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"canonical/d\")\n+\ttg.grepStderr(\"package canonical/d\", \"did not report canonical/d\")\n+\ttg.grepStderr(\"imports canonical/b\", \"did not report canonical/b\")\n+\ttg.grepStderr(\"imports canonical/a/: non-canonical\", \"did not report canonical/a/\")\n+}\n+\n func TestVersionControlErrorMessageIncludesCorrectDirectory(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1317,9 +1367,6 @@ func TestInstallIntoGOPATH(t *testing.T) {\n \n // Issue 12407\n func TestBuildOutputToDevNull(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n-\t\tt.Skip(\"skipping because /dev/null is a regular file on plan9\")\n-\t}\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n@@ -1430,6 +1477,17 @@ func TestGoGetNonPkg(t *testing.T) {\n \ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n }\n \n+func TestGoGetTestOnlyPkg(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"gopath\")\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath\"))\n+\ttg.run(\"get\", \"golang.org/x/tour/content\")\n+\ttg.run(\"get\", \"-t\", \"golang.org/x/tour/content\")\n+}\n+\n func TestInstalls(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"don't install into GOROOT in short mode\")\n@@ -1511,6 +1569,7 @@ func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n func TestGoListHasAConsistentOrder(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.run(\"list\", \"std\")\n \tfirst := tg.getStdout()\n \ttg.run(\"list\", \"std\")\n@@ -1522,13 +1581,15 @@ func TestGoListHasAConsistentOrder(t *testing.T) {\n func TestGoListStdDoesNotIncludeCommands(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.run(\"list\", \"std\")\n \ttg.grepStdoutNot(\"cmd/\", \"go list std shows commands\")\n }\n \n func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.run(\"list\", \"cmd\")\n \tout := strings.TrimSpace(tg.getStdout())\n \tfor _, line := range strings.Split(out, \"\\n\") {\n@@ -1542,6 +1603,7 @@ func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n func TestGoListDedupsPackages(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.run(\"list\", \"xtestonly\", \"./testdata/src/xtestonly/...\")\n \tgot := strings.TrimSpace(tg.getStdout())\n@@ -1555,6 +1617,7 @@ func TestGoListDedupsPackages(t *testing.T) {\n func TestUnsuccessfulGoInstallShouldMentionMissingPackage(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.runFail(\"install\", \"foo/quxx\")\n \tif tg.grepCountBoth(`cannot find package \"foo/quxx\" in any of`) != 1 {\n \t\tt.Error(`go install foo/quxx expected error: .*cannot find package \"foo/quxx\" in any of`)\n@@ -1564,6 +1627,7 @@ func TestUnsuccessfulGoInstallShouldMentionMissingPackage(t *testing.T) {\n func TestGOROOTSearchFailureReporting(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.runFail(\"install\", \"foo/quxx\")\n \tif tg.grepCountBoth(regexp.QuoteMeta(filepath.Join(\"foo\", \"quxx\"))+` \\(from \\$GOROOT\\)$`) != 1 {\n \t\tt.Error(`go install foo/quxx expected error: .*foo/quxx (from $GOROOT)`)\n@@ -1573,6 +1637,7 @@ func TestGOROOTSearchFailureReporting(t *testing.T) {\n func TestMultipleGOPATHEntriesReportedSeparately(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n \ttg.runFail(\"install\", \"foo/quxx\")\n@@ -1585,6 +1650,7 @@ func TestMultipleGOPATHEntriesReportedSeparately(t *testing.T) {\n func TestMentionGOPATHInFirstGOPATHEntry(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n \ttg.runFail(\"install\", \"foo/quxx\")\n@@ -1597,6 +1663,7 @@ func TestMentionGOPATHInFirstGOPATHEntry(t *testing.T) {\n func TestMentionGOPATHNotOnSecondEntry(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n \ttg.runFail(\"install\", \"foo/quxx\")\n@@ -1605,14 +1672,156 @@ func TestMentionGOPATHNotOnSecondEntry(t *testing.T) {\n \t}\n }\n \n-// Test missing GOPATH is reported.\n-func TestMissingGOPATHIsReported(t *testing.T) {\n+func homeEnvName() string {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\treturn \"USERPROFILE\"\n+\tcase \"plan9\":\n+\t\treturn \"home\"\n+\tdefault:\n+\t\treturn \"HOME\"\n+\t}\n+}\n+\n+// Test go env missing GOPATH shows default.\n+func TestMissingGOPATHEnvShowsDefault(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.setenv(\"GOPATH\", \"\")\n-\ttg.runFail(\"install\", \"foo/quxx\")\n-\tif tg.grepCountBoth(`\\(\\$GOPATH not set\\)$`) != 1 {\n-\t\tt.Error(`go install foo/quxx expected error: ($GOPATH not set)`)\n+\ttg.run(\"env\", \"GOPATH\")\n+\n+\twant := filepath.Join(os.Getenv(homeEnvName()), \"go\")\n+\tgot := strings.TrimSpace(tg.getStdout())\n+\tif got != want {\n+\t\tt.Errorf(\"got %q; want %q\", got, want)\n+\t}\n+}\n+\n+// Test go get missing GOPATH causes go get to warn if directory doesn't exist.\n+func TestMissingGOPATHGetWarnsIfNotExists(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\t// setenv variables for test and defer deleting temporary home directory.\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttmp, err := ioutil.TempDir(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(tmp)\n+\ttg.setenv(homeEnvName(), tmp)\n+\n+\ttg.run(\"get\", \"-v\", \"github.com/golang/example/hello\")\n+\n+\twant := fmt.Sprintf(\"created GOPATH=%s; see 'go help gopath'\", filepath.Join(tmp, \"go\"))\n+\tgot := strings.TrimSpace(tg.getStderr())\n+\tif !strings.Contains(got, want) {\n+\t\tt.Errorf(\"got %q; want %q\", got, want)\n+\t}\n+}\n+\n+// Test go get missing GOPATH causes no warning if directory exists.\n+func TestMissingGOPATHGetDoesntWarnIfExists(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\t// setenv variables for test and defer resetting them.\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttmp, err := ioutil.TempDir(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(tmp)\n+\tif err := os.Mkdir(filepath.Join(tmp, \"go\"), 0777); err != nil {\n+\t\tt.Fatalf(\"could not create $HOME/go: %v\", err)\n+\t}\n+\n+\ttg.setenv(homeEnvName(), tmp)\n+\n+\ttg.run(\"get\", \"github.com/golang/example/hello\")\n+\n+\tgot := strings.TrimSpace(tg.getStderr())\n+\tif got != \"\" {\n+\t\tt.Errorf(\"got %q; wants empty\", got)\n+\t}\n+}\n+\n+// Test go get missing GOPATH fails if pointed file is not a directory.\n+func TestMissingGOPATHGetFailsIfItsNotDirectory(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\t// setenv variables for test and defer resetting them.\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttmp, err := ioutil.TempDir(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(tmp)\n+\n+\tpath := filepath.Join(tmp, \"go\")\n+\tif err := ioutil.WriteFile(path, nil, 0777); err != nil {\n+\t\tt.Fatalf(\"could not create GOPATH at %s: %v\", path, err)\n+\t}\n+\ttg.setenv(homeEnvName(), tmp)\n+\n+\tconst pkg = \"github.com/golang/example/hello\"\n+\ttg.runFail(\"get\", pkg)\n+\n+\tmsg := \"not a directory\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\tmsg = \"The system cannot find the path specified.\"\n+\t}\n+\twant := fmt.Sprintf(\"package %s: mkdir %s: %s\", pkg, filepath.Join(tmp, \"go\"), msg)\n+\tgot := strings.TrimSpace(tg.getStderr())\n+\tif got != want {\n+\t\tt.Errorf(\"got %q; wants %q\", got, want)\n+\t}\n+}\n+\n+// Test go install of missing package when missing GOPATH fails and shows default GOPATH.\n+func TestMissingGOPATHInstallMissingPackageFailsAndShowsDefault(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\t// setenv variables for test and defer resetting them.\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttmp, err := ioutil.TempDir(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"could not create tmp home: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(tmp)\n+\tif err := os.Mkdir(filepath.Join(tmp, \"go\"), 0777); err != nil {\n+\t\tt.Fatalf(\"could not create $HOME/go: %v\", err)\n+\t}\n+\ttg.setenv(homeEnvName(), tmp)\n+\n+\tconst pkg = \"github.com/golang/example/hello\"\n+\ttg.runFail(\"install\", pkg)\n+\n+\tpkgPath := filepath.Join(strings.Split(pkg, \"/\")...)\n+\twant := fmt.Sprintf(\"can't load package: package %s: cannot find package \\\"%s\\\" in any of:\", pkg, pkg) +\n+\t\tfmt.Sprintf(\"\\n\\t%s (from $GOROOT)\", filepath.Join(runtime.GOROOT(), \"src\", pkgPath)) +\n+\t\tfmt.Sprintf(\"\\n\\t%s (from $GOPATH)\", filepath.Join(tmp, \"go\", \"src\", pkgPath))\n+\n+\tgot := strings.TrimSpace(tg.getStderr())\n+\tif got != want {\n+\t\tt.Errorf(\"got %q; wants %q\", got, want)\n \t}\n }\n \n@@ -1659,6 +1868,7 @@ func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.makeTempdir()\n \ttg.cd(tg.path(\".\"))\n \ttg.run(\"test\", \"-cpuprofile\", \"errors.prof\", \"errors\")\n@@ -1668,12 +1878,33 @@ func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n func TestGoTestCpuprofileDashOControlsBinaryLocation(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.makeTempdir()\n \ttg.cd(tg.path(\".\"))\n \ttg.run(\"test\", \"-cpuprofile\", \"errors.prof\", \"-o\", \"myerrors.test\"+exeSuffix, \"errors\")\n \ttg.wantExecutable(\"myerrors.test\"+exeSuffix, \"go test -cpuprofile -o myerrors.test did not create myerrors.test\")\n }\n \n+func TestGoTestMutexprofileLeavesBinaryBehind(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.run(\"test\", \"-mutexprofile\", \"errors.prof\", \"errors\")\n+\ttg.wantExecutable(\"errors.test\"+exeSuffix, \"go test -mutexprofile did not create errors.test\")\n+}\n+\n+func TestGoTestMutexprofileDashOControlsBinaryLocation(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.run(\"test\", \"-mutexprofile\", \"errors.prof\", \"-o\", \"myerrors.test\"+exeSuffix, \"errors\")\n+\ttg.wantExecutable(\"myerrors.test\"+exeSuffix, \"go test -mutexprofile -o myerrors.test did not create myerrors.test\")\n+}\n+\n func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1692,6 +1923,16 @@ func TestGoTestDashOWritesBinary(t *testing.T) {\n \ttg.wantExecutable(tg.path(\"myerrors.test\"+exeSuffix), \"go test -o myerrors.test did not create myerrors.test\")\n }\n \n+func TestGoTestDashIDashOWritesBinary(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.run(\"test\", \"-v\", \"-i\", \"-o\", tg.path(\"myerrors.test\"+exeSuffix), \"errors\")\n+\ttg.grepBothNot(\"PASS|FAIL\", \"test should not have run\")\n+\ttg.wantExecutable(tg.path(\"myerrors.test\"+exeSuffix), \"go test -o myerrors.test did not create myerrors.test\")\n+}\n+\n // Issue 4568.\n func TestSymlinksList(t *testing.T) {\n \tswitch runtime.GOOS {\n@@ -1701,6 +1942,7 @@ func TestSymlinksList(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.tempDir(\"src\")\n \ttg.must(os.Symlink(tg.path(\".\"), tg.path(\"src/dir1\")))\n \ttg.tempFile(\"src/dir1/p.go\", \"package p\")\n@@ -1721,6 +1963,7 @@ func TestSymlinksVendor(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.tempDir(\"gopath/src/dir1/vendor/v\")\n \ttg.tempFile(\"gopath/src/dir1/p.go\", \"package main\\nimport _ `v`\\nfunc main(){}\")\n \ttg.tempFile(\"gopath/src/dir1/vendor/v/v.go\", \"package v\")\n@@ -1738,6 +1981,27 @@ func TestSymlinksVendor(t *testing.T) {\n \ttg.run(\"install\")\n }\n \n+// Issue 15201.\n+func TestSymlinksVendor15201(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempDir(\"gopath/src/x/y/_vendor/src/x\")\n+\ttg.must(os.Symlink(\"../../..\", tg.path(\"gopath/src/x/y/_vendor/src/x/y\")))\n+\ttg.tempFile(\"gopath/src/x/y/w/w.go\", \"package w\\nimport \\\"x/y/z\\\"\\n\")\n+\ttg.must(os.Symlink(\"../_vendor/src\", tg.path(\"gopath/src/x/y/w/vendor\")))\n+\ttg.tempFile(\"gopath/src/x/y/z/z.go\", \"package z\\n\")\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath/src/x/y/_vendor\")+string(filepath.ListSeparator)+tg.path(\"gopath\"))\n+\ttg.cd(tg.path(\"gopath/src\"))\n+\ttg.run(\"list\", \"./...\")\n+}\n+\n func TestSymlinksInternal(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n@@ -1829,9 +2093,7 @@ func TestCaseCollisions(t *testing.T) {\n \n // Issue 8181.\n func TestGoGetDashTIssue8181(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping test that uses network in short mode\")\n-\t}\n+\ttestenv.MustHaveExternalNetwork(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1840,14 +2102,12 @@ func TestGoGetDashTIssue8181(t *testing.T) {\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"get\", \"-v\", \"-t\", \"github.com/rsc/go-get-issue-8181/a\", \"github.com/rsc/go-get-issue-8181/b\")\n \ttg.run(\"list\", \"...\")\n-\ttg.grepStdout(\"x/build/cmd/cl\", \"missing expected x/build/cmd/cl\")\n+\ttg.grepStdout(\"x/build/gerrit\", \"missing expected x/build/gerrit\")\n }\n \n func TestIssue11307(t *testing.T) {\n \t// go get -u was not working except in checkout directory\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping test that uses network in short mode\")\n-\t}\n+\ttestenv.MustHaveExternalNetwork(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1997,6 +2257,38 @@ func TestCoverageUsesActualSettingToOverrideEvenForRace(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n+func TestCoverageImportMainLoop(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"importmain/test\")\n+\ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n+\ttg.runFail(\"test\", \"-cover\", \"importmain/test\")\n+\ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n+}\n+\n+func TestTestEmpty(t *testing.T) {\n+\tif !canRace {\n+\t\tt.Skip(\"no race detector\")\n+\t}\n+\n+\twd, _ := os.Getwd()\n+\ttestdata := filepath.Join(wd, \"testdata\")\n+\n+\tfor _, dir := range []string{\"pkg\", \"test\", \"xtest\", \"pkgtest\", \"pkgxtest\", \"pkgtestxtest\", \"testxtest\"} {\n+\t\tt.Run(dir, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.setenv(\"GOPATH\", testdata)\n+\t\t\ttg.cd(filepath.Join(testdata, \"src/empty/\"+dir))\n+\t\t\ttg.run(\"test\", \"-cover\", \"-coverpkg=.\", \"-race\")\n+\t\t})\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n func TestBuildDryRunWithCgo(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n@@ -2023,11 +2315,17 @@ func TestCoverageWithCgo(t *testing.T) {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n \n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"test\", \"-short\", \"-cover\", \"./testdata/cgocover\")\n-\tdata := tg.getStdout() + tg.getStderr()\n-\tcheckCoverage(tg, data)\n+\tfor _, dir := range []string{\"cgocover\", \"cgocover2\", \"cgocover3\", \"cgocover4\"} {\n+\t\tt.Run(dir, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\ttg.parallel()\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\t\t\ttg.run(\"test\", \"-short\", \"-cover\", dir)\n+\t\t\tdata := tg.getStdout() + tg.getStderr()\n+\t\t\tcheckCoverage(tg, data)\n+\t\t})\n+\t}\n }\n \n func TestCgoDependsOnSyscall(t *testing.T) {\n@@ -2090,10 +2388,57 @@ func TestCgoHandlesWlORIGIN(t *testing.T) {\n \ttg.run(\"build\", \"origin\")\n }\n \n+func TestCgoPkgConfig(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.run(\"env\", \"PKG_CONFIG\")\n+\tpkgConfig := strings.TrimSpace(tg.getStdout())\n+\tif out, err := exec.Command(pkgConfig, \"--atleast-pkgconfig-version\", \"0.24\").CombinedOutput(); err != nil {\n+\t\tt.Skipf(\"%s --atleast-pkgconfig-version 0.24: %v\\n%s\", pkgConfig, err, out)\n+\t}\n+\n+\t// OpenBSD's pkg-config is strict about whitespace and only\n+\t// supports backslash-escaped whitespace. It does not support\n+\t// quotes, which the normal freedesktop.org pkg-config does\n+\t// support. See http://man.openbsd.org/pkg-config.1\n+\ttg.tempFile(\"foo.pc\", `\n+Name: foo\n+Description: The foo library\n+Version: 1.0.0\n+Cflags: -Dhello=10 -Dworld=+32 -DDEFINED_FROM_PKG_CONFIG=hello\\ world\n+`)\n+\ttg.tempFile(\"foo.go\", `package main\n+\n+/*\n+#cgo pkg-config: foo\n+int value() {\n+\treturn DEFINED_FROM_PKG_CONFIG;\n+}\n+*/\n+import \"C\"\n+import \"os\"\n+\n+func main() {\n+\tif C.value() != 42 {\n+\t\tprintln(\"value() =\", C.value(), \"wanted 42\")\n+\t\tos.Exit(1)\n+\t}\n+}\n+`)\n+\ttg.setenv(\"PKG_CONFIG_PATH\", tg.path(\".\"))\n+\ttg.run(\"run\", tg.path(\"foo.go\"))\n+}\n+\n // \"go test -c -test.bench=XXX errors\" should not hang\n func TestIssue6480(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n \ttg.makeTempdir()\n \ttg.cd(tg.path(\".\"))\n \ttg.run(\"test\", \"-c\", \"-test.bench=XXX\", \"errors\")\n@@ -2124,8 +2469,7 @@ func main() { C.f() }`)\n }\n \n func TestListTemplateContextFunction(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n+\tt.Parallel()\n \tfor _, tt := range []struct {\n \t\tv    string\n \t\twant string\n@@ -2141,14 +2485,20 @@ func TestListTemplateContextFunction(t *testing.T) {\n \t\t{\"ReleaseTags\", \"\"},\n \t\t{\"InstallSuffix\", \"\"},\n \t} {\n-\t\ttmpl := \"{{context.\" + tt.v + \"}}\"\n-\t\ttg.run(\"list\", \"-f\", tmpl)\n-\t\tif tt.want == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif got := strings.TrimSpace(tg.getStdout()); got != tt.want {\n-\t\t\tt.Errorf(\"go list -f %q: got %q; want %q\", tmpl, got, tt.want)\n-\t\t}\n+\t\ttt := tt\n+\t\tt.Run(tt.v, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\ttg.parallel()\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttmpl := \"{{context.\" + tt.v + \"}}\"\n+\t\t\ttg.run(\"list\", \"-f\", tmpl)\n+\t\t\tif tt.want == \"\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif got := strings.TrimSpace(tg.getStdout()); got != tt.want {\n+\t\t\t\tt.Errorf(\"go list -f %q: got %q; want %q\", tmpl, got, tt.want)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -2307,6 +2657,20 @@ func TestGoGenerateEnv(t *testing.T) {\n \t}\n }\n \n+func TestGoGenerateBadImports(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\t// This package has an invalid import causing an import cycle,\n+\t// but go generate is supposed to still run.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"generate\", \"gencycle\")\n+\ttg.grepStdout(\"hello world\", \"go generate gencycle did not run generator\")\n+}\n+\n func TestGoGetCustomDomainWildcard(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n@@ -2382,35 +2746,254 @@ func TestGoGetHTTPS404(t *testing.T) {\n }\n \n // Test that you cannot import a main package.\n-func TestIssue4210(t *testing.T) {\n+// See golang.org/issue/4210 and golang.org/issue/17475.\n+func TestImportMain(t *testing.T) {\n \ttg := testgo(t)\n+\ttg.parallel()\n \tdefer tg.cleanup()\n+\n+\t// Importing package main from that package main's test should work.\n \ttg.tempFile(\"src/x/main.go\", `package main\n \t\tvar X int\n \t\tfunc main() {}`)\n-\ttg.tempFile(\"src/y/main.go\", `package main\n-\t\timport \"fmt\"\n+\ttg.tempFile(\"src/x/main_test.go\", `package main_test\n \t\timport xmain \"x\"\n-\t\tfunc main() {\n-\t\t\tfmt.Println(xmain.X)\n-\t\t}`)\n+\t\timport \"testing\"\n+\t\tvar _ = xmain.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.creatingTemp(\"x\")\n+\ttg.run(\"build\", \"x\")\n+\ttg.run(\"test\", \"x\")\n+\n+\t// Importing package main from another package should fail.\n+\ttg.tempFile(\"src/p1/p.go\", `package p1\n+\t\timport xmain \"x\"\n+\t\tvar _ = xmain.X\n+\t`)\n+\ttg.runFail(\"build\", \"p1\")\n+\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n+\n+\t// ... even in that package's test.\n+\ttg.tempFile(\"src/p2/p.go\", `package p2\n+\t`)\n+\ttg.tempFile(\"src/p2/p_test.go\", `package p2\n+\t\timport xmain \"x\"\n+\t\timport \"testing\"\n+\t\tvar _ = xmain.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"p2\")\n+\ttg.runFail(\"test\", \"p2\")\n+\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n+\n+\t// ... even if that package's test is an xtest.\n+\ttg.tempFile(\"src/p3/p.go\", `package p\n+\t`)\n+\ttg.tempFile(\"src/p3/p_test.go\", `package p_test\n+\t\timport xmain \"x\"\n+\t\timport \"testing\"\n+\t\tvar _ = xmain.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"p3\")\n+\ttg.runFail(\"test\", \"p3\")\n+\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n+\n+\t// ... even if that package is a package main\n+\ttg.tempFile(\"src/p4/p.go\", `package main\n+\tfunc main() {}\n+\t`)\n+\ttg.tempFile(\"src/p4/p_test.go\", `package main\n+\t\timport xmain \"x\"\n+\t\timport \"testing\"\n+\t\tvar _ = xmain.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.creatingTemp(\"p4\" + exeSuffix)\n+\ttg.run(\"build\", \"p4\")\n+\ttg.runFail(\"test\", \"p4\")\n+\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n+\n+\t// ... even if that package is a package main using an xtest.\n+\ttg.tempFile(\"src/p5/p.go\", `package main\n+\tfunc main() {}\n+\t`)\n+\ttg.tempFile(\"src/p5/p_test.go\", `package main_test\n+\t\timport xmain \"x\"\n+\t\timport \"testing\"\n+\t\tvar _ = xmain.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.creatingTemp(\"p5\" + exeSuffix)\n+\ttg.run(\"build\", \"p5\")\n+\ttg.runFail(\"test\", \"p5\")\n+\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n+}\n+\n+// Test that you cannot use a local import in a package\n+// accessed by a non-local import (found in a GOPATH/GOROOT).\n+// See golang.org/issue/17475.\n+func TestImportLocal(t *testing.T) {\n+\ttg := testgo(t)\n+\ttg.parallel()\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"src/dir/x/x.go\", `package x\n+\t\tvar X int\n+\t`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.runFail(\"build\", \"y\")\n-\ttg.grepBoth(\"is a program\", `did not find expected error message (\"is a program\")`)\n+\ttg.run(\"build\", \"dir/x\")\n+\n+\t// Ordinary import should work.\n+\ttg.tempFile(\"src/dir/p0/p.go\", `package p0\n+\t\timport \"dir/x\"\n+\t\tvar _ = x.X\n+\t`)\n+\ttg.run(\"build\", \"dir/p0\")\n+\n+\t// Relative import should not.\n+\ttg.tempFile(\"src/dir/p1/p.go\", `package p1\n+\t\timport \"../x\"\n+\t\tvar _ = x.X\n+\t`)\n+\ttg.runFail(\"build\", \"dir/p1\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in a test.\n+\ttg.tempFile(\"src/dir/p2/p.go\", `package p2\n+\t`)\n+\ttg.tempFile(\"src/dir/p2/p_test.go\", `package p2\n+\t\timport \"../x\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/p2\")\n+\ttg.runFail(\"test\", \"dir/p2\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in an xtest.\n+\ttg.tempFile(\"src/dir/p2/p_test.go\", `package p2_test\n+\t\timport \"../x\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/p2\")\n+\ttg.runFail(\"test\", \"dir/p2\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// Relative import starting with ./ should not work either.\n+\ttg.tempFile(\"src/dir/d.go\", `package dir\n+\t\timport \"./x\"\n+\t\tvar _ = x.X\n+\t`)\n+\ttg.runFail(\"build\", \"dir\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in a test.\n+\ttg.tempFile(\"src/dir/d.go\", `package dir\n+\t`)\n+\ttg.tempFile(\"src/dir/d_test.go\", `package dir\n+\t\timport \"./x\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir\")\n+\ttg.runFail(\"test\", \"dir\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in an xtest.\n+\ttg.tempFile(\"src/dir/d_test.go\", `package dir_test\n+\t\timport \"./x\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir\")\n+\ttg.runFail(\"test\", \"dir\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// Relative import plain \"..\" should not work.\n+\ttg.tempFile(\"src/dir/x/y/y.go\", `package dir\n+\t\timport \"..\"\n+\t\tvar _ = x.X\n+\t`)\n+\ttg.runFail(\"build\", \"dir/x/y\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in a test.\n+\ttg.tempFile(\"src/dir/x/y/y.go\", `package y\n+\t`)\n+\ttg.tempFile(\"src/dir/x/y/y_test.go\", `package y\n+\t\timport \"..\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/x/y\")\n+\ttg.runFail(\"test\", \"dir/x/y\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in an x test.\n+\ttg.tempFile(\"src/dir/x/y/y_test.go\", `package y_test\n+\t\timport \"..\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/x/y\")\n+\ttg.runFail(\"test\", \"dir/x/y\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// Relative import \".\" should not work.\n+\ttg.tempFile(\"src/dir/x/xx.go\", `package x\n+\t\timport \".\"\n+\t\tvar _ = x.X\n+\t`)\n+\ttg.runFail(\"build\", \"dir/x\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in a test.\n+\ttg.tempFile(\"src/dir/x/xx.go\", `package x\n+\t`)\n+\ttg.tempFile(\"src/dir/x/xx_test.go\", `package x\n+\t\timport \".\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/x\")\n+\ttg.runFail(\"test\", \"dir/x\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\n+\t// ... even in an xtest.\n+\ttg.tempFile(\"src/dir/x/xx.go\", `package x\n+\t`)\n+\ttg.tempFile(\"src/dir/x/xx_test.go\", `package x_test\n+\t\timport \".\"\n+\t\timport \"testing\"\n+\t\tvar _ = x.X\n+\t\tfunc TestFoo(t *testing.T) {}\n+\t`)\n+\ttg.run(\"build\", \"dir/x\")\n+\ttg.runFail(\"test\", \"dir/x\")\n+\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n }\n \n func TestGoGetInsecure(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\tt.Skip(\"golang.org/issue/15410\")\n-\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.failSSH()\n \n-\tconst repo = \"wh3rd.net/git.git\"\n+\tconst repo = \"insecure.go-get-issue-15410.appspot.com/pkg/p\"\n \n \t// Try go get -d of HTTP-only repo (should fail).\n \ttg.runFail(\"get\", \"-d\", repo)\n@@ -2454,7 +3037,7 @@ func TestGoGetInsecureCustomDomain(t *testing.T) {\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \n-\tconst repo = \"wh3rd.net/repo\"\n+\tconst repo = \"insecure.go-get-issue-15410.appspot.com/pkg/p\"\n \ttg.runFail(\"get\", \"-d\", repo)\n \ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n }\n@@ -2471,6 +3054,7 @@ func TestGoRunDirs(t *testing.T) {\n \n func TestGoInstallPkgdir(t *testing.T) {\n \ttg := testgo(t)\n+\ttg.parallel()\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \tpkg := tg.path(\".\")\n@@ -2509,6 +3093,27 @@ func TestGoTestRaceInstallCgo(t *testing.T) {\n \t}\n }\n \n+func TestGoTestRaceFailures(t *testing.T) {\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\ttg.parallel()\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\ttg.run(\"test\", \"testrace\")\n+\n+\ttg.runFail(\"test\", \"-race\", \"testrace\")\n+\ttg.grepStdout(\"FAIL: TestRace\", \"TestRace did not fail\")\n+\ttg.grepBothNot(\"PASS\", \"something passed\")\n+\n+\ttg.runFail(\"test\", \"-race\", \"testrace\", \"-run\", \"XXX\", \"-bench\", \".\")\n+\ttg.grepStdout(\"FAIL: BenchmarkRace\", \"BenchmarkRace did not fail\")\n+\ttg.grepBothNot(\"PASS\", \"something passed\")\n+}\n+\n func TestGoTestImportErrorStack(t *testing.T) {\n \tconst out = `package testdep/p1 (test)\n \timports testdep/p2\n@@ -2773,6 +3378,7 @@ func TestIssue13655(t *testing.T) {\n // For issue 14337.\n func TestParallelTest(t *testing.T) {\n \ttg := testgo(t)\n+\ttg.parallel()\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \tconst testSrc = `package package_test\n@@ -2793,9 +3399,11 @@ func TestCgoConsistentResults(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n-\tif runtime.GOOS == \"solaris\" {\n-\t\t// See https://golang.org/issue/13247\n-\t\tt.Skip(\"skipping because Solaris builds are known to be inconsistent; see #13247\")\n+\tswitch runtime.GOOS {\n+\tcase \"freebsd\":\n+\t\ttestenv.SkipFlaky(t, 15405)\n+\tcase \"solaris\":\n+\t\ttestenv.SkipFlaky(t, 13247)\n \t}\n \n \ttg := testgo(t)\n@@ -2832,17 +3440,31 @@ func TestGoGetUpdateAllDoesNotTryToLoadDuplicates(t *testing.T) {\n \ttg.grepStderrNot(\"duplicate loads of\", \"did not remove old packages from cache\")\n }\n \n+// Issue 17119 more duplicate load errors\n+func TestIssue17119(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"dupload\")\n+\ttg.grepBothNot(\"duplicate load|internal error\", \"internal error\")\n+}\n+\n func TestFatalInBenchmarkCauseNonZeroExitStatus(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\ttg.runFail(\"test\", \"-bench\", \".\", \"./testdata/src/benchfatal\")\n+\t// TODO: tg.parallel()\n+\ttg.runFail(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"./testdata/src/benchfatal\")\n \ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n \ttg.grepBoth(\"FAIL.*benchfatal\", \"test did not run everything\")\n }\n \n func TestBinaryOnlyPackages(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \n@@ -2907,6 +3529,16 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \n \ttg.run(\"run\", tg.path(\"src/p3/p3.go\"))\n \ttg.grepStdout(\"hello from p1\", \"did not see message from p1\")\n+\n+\ttg.tempFile(\"src/p4/p4.go\", `package main`)\n+\ttg.tempFile(\"src/p4/p4not.go\", `//go:binary-only-package\n+\n+\t\t// +build asdf\n+\n+\t\tpackage main\n+\t`)\n+\ttg.run(\"list\", \"-f\", \"{{.BinaryOnly}}\", \"p4\")\n+\ttg.grepStdout(\"false\", \"did not see BinaryOnly=false for p4\")\n }\n \n // Issue 16050.\n@@ -2954,3 +3586,204 @@ func TestGenerateUsesBuildContext(t *testing.T) {\n \ttg.run(\"generate\", \"gen\")\n \ttg.grepStdout(\"darwin 386\", \"unexpected GOOS/GOARCH combination\")\n }\n+\n+// Issue 14450: go get -u .../ tried to import not downloaded package\n+func TestGoGetUpdateWithWildcard(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\tconst aPkgImportPath = \"github.com/tmwh/go-get-issue-14450/a\"\n+\ttg.run(\"get\", aPkgImportPath)\n+\ttg.run(\"get\", \"-u\", \".../\")\n+\ttg.grepStderrNot(\"cannot find package\", \"did not update packages given wildcard path\")\n+\n+\tvar expectedPkgPaths = []string{\n+\t\t\"src/github.com/tmwh/go-get-issue-14450/b\",\n+\t\t\"src/github.com/tmwh/go-get-issue-14450-b-dependency/c\",\n+\t\t\"src/github.com/tmwh/go-get-issue-14450-b-dependency/d\",\n+\t}\n+\n+\tfor _, importPath := range expectedPkgPaths {\n+\t\t_, err := os.Stat(tg.path(importPath))\n+\t\ttg.must(err)\n+\t}\n+\tconst notExpectedPkgPath = \"src/github.com/tmwh/go-get-issue-14450-c-dependency/e\"\n+\ttg.mustNotExist(tg.path(notExpectedPkgPath))\n+}\n+\n+func TestGoEnv(t *testing.T) {\n+\ttg := testgo(t)\n+\ttg.parallel()\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOARCH\", \"arm\")\n+\ttg.run(\"env\", \"GOARCH\")\n+\ttg.grepStdout(\"^arm$\", \"GOARCH not honored\")\n+\n+\ttg.run(\"env\", \"GCCGO\")\n+\ttg.grepStdout(\".\", \"GCCGO unexpectedly empty\")\n+\n+\ttg.run(\"env\", \"CGO_CFLAGS\")\n+\ttg.grepStdout(\".\", \"default CGO_CFLAGS unexpectedly empty\")\n+\n+\ttg.setenv(\"CGO_CFLAGS\", \"-foobar\")\n+\ttg.run(\"env\", \"CGO_CFLAGS\")\n+\ttg.grepStdout(\"^-foobar$\", \"CGO_CFLAGS not honored\")\n+\n+\ttg.setenv(\"CC\", \"gcc -fmust -fgo -ffaster\")\n+\ttg.run(\"env\", \"CC\")\n+\ttg.grepStdout(\"gcc\", \"CC not found\")\n+\ttg.run(\"env\", \"GOGCCFLAGS\")\n+\ttg.grepStdout(\"-ffaster\", \"CC arguments not found\")\n+}\n+\n+const (\n+\tnoMatchesPattern = `(?m)^ok.*\\[no tests to run\\]`\n+\tokPattern        = `(?m)^ok`\n+)\n+\n+func TestMatchesNoTests(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"ThisWillNotMatch\", \"testdata/standalone_test.go\")\n+\ttg.grepBoth(noMatchesPattern, \"go test did not say [no tests to run]\")\n+}\n+\n+func TestMatchesNoTestsDoesNotOverrideBuildFailure(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"-run\", \"ThisWillNotMatch\", \"syntaxerror\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(\"FAIL\", \"go test did not say FAIL\")\n+}\n+\n+func TestMatchesNoBenchmarksIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"^$\", \"-bench\", \"ThisWillNotMatch\", \"testdata/standalone_benchmark_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestMatchesOnlyExampleIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"Example\", \"testdata/example1_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestMatchesOnlyBenchmarkIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"testdata/standalone_benchmark_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestMatchesOnlyTestIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"Test\", \"testdata/standalone_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestMatchesNoTestsWithSubtests(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-run\", \"ThisWillNotMatch\", \"testdata/standalone_sub_test.go\")\n+\ttg.grepBoth(noMatchesPattern, \"go test did not say [no tests to run]\")\n+}\n+\n+func TestMatchesNoSubtestsMatch(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-run\", \"Test/ThisWillNotMatch\", \"testdata/standalone_sub_test.go\")\n+\ttg.grepBoth(noMatchesPattern, \"go test did not say [no tests to run]\")\n+}\n+\n+func TestMatchesNoSubtestsDoesNotOverrideFailure(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"test\", \"-run\", \"TestThatFails/ThisWillNotMatch\", \"testdata/standalone_fail_sub_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(\"FAIL\", \"go test did not say FAIL\")\n+}\n+\n+func TestMatchesOnlySubtestIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-run\", \"Test/Sub\", \"testdata/standalone_sub_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestMatchesNoSubtestsParallel(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-run\", \"Test/Sub/ThisWillNotMatch\", \"testdata/standalone_parallel_sub_test.go\")\n+\ttg.grepBoth(noMatchesPattern, \"go test did not say [no tests to run]\")\n+}\n+\n+func TestMatchesOnlySubtestParallelIsOK(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-run\", \"Test/Sub/Nested\", \"testdata/standalone_parallel_sub_test.go\")\n+\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n+func TestLinkXImportPathEscape(t *testing.T) {\n+\t// golang.org/issue/16710\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\texe := \"./linkx\" + exeSuffix\n+\ttg.creatingTemp(exe)\n+\ttg.run(\"build\", \"-o\", exe, \"-ldflags\", \"-X=my.pkg.Text=linkXworked\", \"my.pkg/main\")\n+\tout, err := exec.Command(exe).CombinedOutput()\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+\tif string(out) != \"linkXworked\\n\" {\n+\t\ttg.t.Log(string(out))\n+\t\ttg.t.Fatal(`incorrect output: expected \"linkXworked\\n\"`)\n+\t}\n+}\n+\n+// Issue 18044.\n+func TestLdBindNow(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"LD_BIND_NOW\", \"1\")\n+\ttg.run(\"help\")\n+}\n+\n+// Issue 18225.\n+// This is really a cmd/asm issue but this is a convenient place to test it.\n+func TestConcurrentAsm(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\tasm := `DATA \u00b7constants<>+0x0(SB)/8,$0\n+GLOBL \u00b7constants<>(SB),8,$8\n+`\n+\ttg.tempFile(\"go/src/p/a.s\", asm)\n+\ttg.tempFile(\"go/src/p/b.s\", asm)\n+\ttg.tempFile(\"go/src/p/p.go\", `package p`)\n+\ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n+\ttg.run(\"build\", \"p\")\n+}"}, {"sha": "d8d04aaf497e210bbdde93df4a5a356c87bc3eff", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -5,6 +5,7 @@\n package main\n \n import (\n+\t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n@@ -45,7 +46,7 @@ func TestAbsolutePath(t *testing.T) {\n \n \tnoVolume := file[len(filepath.VolumeName(file)):]\n \twrongPath := filepath.Join(dir, noVolume)\n-\toutput, err := exec.Command(\"go\", \"build\", noVolume).CombinedOutput()\n+\toutput, err := exec.Command(testenv.GoToolPath(t), \"build\", noVolume).CombinedOutput()\n \tif err == nil {\n \t\tt.Fatal(\"build should fail\")\n \t}"}, {"sha": "0c663ad463f679302a8280c85f8e32fad32844b7", "filename": "libgo/go/cmd/go/help.go", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -42,7 +42,7 @@ denotes the package in that directory.\n \n Otherwise, the import path P denotes the package found in\n the directory DIR/src/P for some DIR listed in the GOPATH\n-environment variable (see 'go help gopath').\n+environment variable (For more details see: 'go help gopath').\n \n If no import paths are given, the action applies to the\n package in the current directory.\n@@ -62,6 +62,9 @@ Go library.\n - \"cmd\" expands to the Go repository's commands and their\n internal libraries.\n \n+Import paths beginning with \"cmd/\" only match source code in\n+the Go repository.\n+\n An import path is a pattern if it includes one or more \"...\" wildcards,\n each of which can match any string, including the empty string and\n strings containing slashes.  Such a pattern expands to all package\n@@ -102,10 +105,10 @@ var helpImportPath = &Command{\n \tShort:     \"import path syntax\",\n \tLong: `\n \n-An import path (see 'go help packages') denotes a package\n-stored in the local file system.  In general, an import path denotes\n-either a standard package (such as \"unicode/utf8\") or a package\n-found in one of the work spaces (see 'go help gopath').\n+An import path (see 'go help packages') denotes a package stored in the local\n+file system.  In general, an import path denotes either a standard package (such\n+as \"unicode/utf8\") or a package found in one of the work spaces (For more\n+details see: 'go help gopath').\n \n Relative import paths\n \n@@ -197,6 +200,11 @@ When a version control system supports multiple protocols,\n each is tried in turn when downloading.  For example, a Git\n download tries https://, then git+ssh://.\n \n+By default, downloads are restricted to known secure protocols\n+(e.g. https, ssh). To override this setting for Git downloads, the\n+GIT_ALLOW_PROTOCOL environment variable can be set (For more details see:\n+'go help environment').\n+\n If the import path is not a known code hosting site and also lacks a\n version control qualifier, the go tool attempts to fetch the import\n over https/http and looks for a <meta> tag in the document's HTML\n@@ -237,8 +245,8 @@ the go tool will verify that https://example.org/?go-get=1 contains the\n same meta tag and then git clone https://code.org/r/p/exproj into\n GOPATH/src/example.org.\n \n-New downloaded packages are written to the first directory\n-listed in the GOPATH environment variable (see 'go help gopath').\n+New downloaded packages are written to the first directory listed in the GOPATH\n+environment variable (For more details see: 'go help gopath').\n \n The go command attempts to download the version of the\n package appropriate for the Go release being used.\n@@ -281,8 +289,13 @@ On Unix, the value is a colon-separated string.\n On Windows, the value is a semicolon-separated string.\n On Plan 9, the value is a list.\n \n-GOPATH must be set to get, build and install packages outside the\n-standard Go tree.\n+If the environment variable is unset, GOPATH defaults\n+to a subdirectory named \"go\" in the user's home directory\n+($HOME/go on Unix, %USERPROFILE%\\go on Windows),\n+unless that directory holds a Go distribution.\n+Run \"go env GOPATH\" to see the current GOPATH.\n+\n+See https://golang.org/wiki/SettingGOPATH to set a custom GOPATH.\n \n Each directory listed in GOPATH must have a prescribed structure:\n \n@@ -310,9 +323,9 @@ of DIR/bin. GOBIN must be an absolute path.\n \n Here's an example directory layout:\n \n-    GOPATH=/home/user/gocode\n+    GOPATH=/home/user/go\n \n-    /home/user/gocode/\n+    /home/user/go/\n         src/\n             foo/\n                 bar/               (go code in package bar)\n@@ -338,7 +351,7 @@ Code in or below a directory named \"internal\" is importable only\n by code in the directory tree rooted at the parent of \"internal\".\n Here's an extended version of the directory layout above:\n \n-    /home/user/gocode/\n+    /home/user/go/\n         src/\n             crash/\n                 bang/              (go code in package bang)\n@@ -376,7 +389,7 @@ Here's the example from the previous section,\n but with the \"internal\" directory renamed to \"vendor\"\n and a new foo/vendor/crash/bang directory added:\n \n-    /home/user/gocode/\n+    /home/user/go/\n         src/\n             crash/\n                 bang/              (go code in package bang)\n@@ -439,7 +452,7 @@ General-purpose environment variables:\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n \tGOPATH\n-\t\tSee 'go help gopath'.\n+\t\tFor more details see: 'go help gopath'.\n \tGORACE\n \t\tOptions for the race detector.\n \t\tSee https://golang.org/doc/articles/race_detector.html.\n@@ -461,10 +474,15 @@ Environment variables for use with cgo:\n \tCGO_CXXFLAGS\n \t\tFlags that cgo will pass to the compiler when compiling\n \t\tC++ code.\n+\tCGO_FFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tFortran code.\n \tCGO_LDFLAGS\n \t\tFlags that cgo will pass to the compiler when linking.\n \tCXX\n \t\tThe command to use to compile C++ code.\n+\tPKG_CONFIG\n+\t\tPath to pkg-config tool.\n \n Architecture-specific environment variables:\n \n@@ -486,6 +504,10 @@ Special-purpose environment variables:\n \t\tWhether the linker should use external linking mode\n \t\twhen using -linkmode=auto with code that uses cgo.\n \t\tSet to 0 to disable external linking mode, 1 to enable it.\n+\tGIT_ALLOW_PROTOCOL\n+\t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n+\t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n+\t\tconsidered insecure by 'go get'.\n \t`,\n }\n \n@@ -577,5 +599,9 @@ are:\n \t\tBuild the listed main packages and everything they import into\n \t\tposition independent executables (PIE). Packages not named\n \t\tmain are ignored.\n+\n+\t-buildmode=plugin\n+\t\tBuild the listed main packages, plus all packages that they\n+\t\timport, into a Go plugin. Packages not named main are ignored.\n `,\n }"}, {"sha": "dcb4e9fea5f9fa0ec8e75add4516566ef712c43d", "filename": "libgo/go/cmd/go/http.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -12,6 +12,7 @@\n package main\n \n import (\n+\t\"cmd/internal/browser\"\n \t\"crypto/tls\"\n \t\"fmt\"\n \t\"io\"\n@@ -32,6 +33,7 @@ var httpClient = http.DefaultClient\n var impatientInsecureHTTPClient = &http.Client{\n \tTimeout: 5 * time.Second,\n \tTransport: &http.Transport{\n+\t\tProxy: http.ProxyFromEnvironment,\n \t\tTLSClientConfig: &tls.Config{\n \t\t\tInsecureSkipVerify: true,\n \t\t},\n@@ -113,3 +115,6 @@ func httpsOrHTTP(importPath string, security securityMode) (urlStr string, body\n \t}\n \treturn urlStr, res.Body, nil\n }\n+\n+func queryEscape(s string) string { return url.QueryEscape(s) }\n+func openBrowser(url string) bool { return browser.Open(url) }"}, {"sha": "2f240834b2a4486ddd1c1e5b02bac5c7a08e7ca8", "filename": "libgo/go/cmd/go/list.go", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -59,6 +59,8 @@ syntax of package template.  The default output is equivalent to -f\n         SwigFiles      []string // .swig files\n         SwigCXXFiles   []string // .swigcxx files\n         SysoFiles      []string // .syso object files to add to archive\n+        TestGoFiles    []string // _test.go files in package\n+        XTestGoFiles   []string // _test.go files outside package\n \n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -69,20 +71,23 @@ syntax of package template.  The default output is equivalent to -f\n         CgoPkgConfig []string // cgo: pkg-config names\n \n         // Dependency information\n-        Imports []string // import paths used by this package\n-        Deps    []string // all (recursively) imported dependencies\n+        Imports      []string // import paths used by this package\n+        Deps         []string // all (recursively) imported dependencies\n+        TestImports  []string // imports from TestGoFiles\n+        XTestImports []string // imports from XTestGoFiles\n \n         // Error information\n         Incomplete bool            // this package or a dependency has an error\n         Error      *PackageError   // error loading package\n         DepsErrors []*PackageError // errors loading dependencies\n-\n-        TestGoFiles  []string // _test.go files in package\n-        TestImports  []string // imports from TestGoFiles\n-        XTestGoFiles []string // _test.go files outside package\n-        XTestImports []string // imports from XTestGoFiles\n     }\n \n+Packages stored in vendor directories report an ImportPath that includes the\n+path to the vendor directory (for example, \"d/vendor/p\" instead of \"p\"),\n+so that the ImportPath uniquely identifies a given copy of a package.\n+The Imports, Deps, TestImports, and XTestImports lists also contain these\n+expanded imports paths. See golang.org/s/go15vendor for more about vendoring.\n+\n The error information, if any, is\n \n     type PackageError struct {"}, {"sha": "07fc4e2a9050d836efba2df98be15d40218ed29f", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -79,6 +79,7 @@ var commands = []*Command{\n \tcmdClean,\n \tcmdDoc,\n \tcmdEnv,\n+\tcmdBug,\n \tcmdFix,\n \tcmdFmt,\n \tcmdGenerate,\n@@ -114,6 +115,7 @@ func setExitStatus(n int) {\n }\n \n var origEnv []string\n+var newEnv []envVar\n \n func main() {\n \t_ = go11tag\n@@ -134,7 +136,7 @@ func main() {\n \t// Diagnose common mistake: GOPATH==GOROOT.\n \t// This setting is equivalent to not setting GOPATH at all,\n \t// which is not what most people want when they do it.\n-\tif gopath := os.Getenv(\"GOPATH\"); gopath == runtime.GOROOT() {\n+\tif gopath := buildContext.GOPATH; gopath == runtime.GOROOT() {\n \t\tfmt.Fprintf(os.Stderr, \"warning: GOPATH set to GOROOT (%s) has no effect\\n\", gopath)\n \t} else {\n \t\tfor _, p := range filepath.SplitList(gopath) {\n@@ -146,7 +148,7 @@ func main() {\n \t\t\t\tos.Exit(2)\n \t\t\t}\n \t\t\tif !filepath.IsAbs(p) {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry is relative; must be absolute path: %q.\\nRun 'go help gopath' for usage.\\n\", p)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry is relative; must be absolute path: %q.\\nFor more details see: 'go help gopath'\\n\", p)\n \t\t\t\tos.Exit(2)\n \t\t\t}\n \t\t}\n@@ -163,7 +165,8 @@ func main() {\n \t// but in practice there might be skew\n \t// This makes sure we all agree.\n \torigEnv = os.Environ()\n-\tfor _, env := range mkEnv() {\n+\tnewEnv = mkEnv()\n+\tfor _, env := range newEnv {\n \t\tif os.Getenv(env.name) != env.value {\n \t\t\tos.Setenv(env.name, env.value)\n \t\t}"}, {"sha": "af8c1d959fa2f07b4827b1a0d526fc58b78e19a5", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 165, "deletions": 98, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -24,6 +24,8 @@ import (\n \t\"unicode\"\n )\n \n+var ignoreImports bool // control whether we ignore imports in packages\n+\n // A Package describes a single package found in a directory.\n type Package struct {\n \t// Note: These fields are part of the go command's public API.\n@@ -180,11 +182,18 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.CgoCXXFLAGS = pp.CgoCXXFLAGS\n \tp.CgoLDFLAGS = pp.CgoLDFLAGS\n \tp.CgoPkgConfig = pp.CgoPkgConfig\n-\tp.Imports = pp.Imports\n+\t// We modify p.Imports in place, so make copy now.\n+\tp.Imports = make([]string, len(pp.Imports))\n+\tcopy(p.Imports, pp.Imports)\n \tp.TestGoFiles = pp.TestGoFiles\n \tp.TestImports = pp.TestImports\n \tp.XTestGoFiles = pp.XTestGoFiles\n \tp.XTestImports = pp.XTestImports\n+\tif ignoreImports {\n+\t\tp.Imports = nil\n+\t\tp.TestImports = nil\n+\t\tp.XTestImports = nil\n+\t}\n }\n \n // isStandardImportPath reports whether $GOROOT/src/path should be considered\n@@ -338,62 +347,98 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \t\timportPath = path\n \t}\n \n-\tif p := packageCache[importPath]; p != nil {\n-\t\tif perr := disallowInternal(srcDir, p, stk); perr != p {\n-\t\t\treturn perr\n+\tp := packageCache[importPath]\n+\tif p != nil {\n+\t\tp = reusePackage(p, stk)\n+\t} else {\n+\t\tp = new(Package)\n+\t\tp.local = isLocal\n+\t\tp.ImportPath = importPath\n+\t\tpackageCache[importPath] = p\n+\n+\t\t// Load package.\n+\t\t// Import always returns bp != nil, even if an error occurs,\n+\t\t// in order to return partial information.\n+\t\t//\n+\t\t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n+\t\t// See issue 3268 for mistakes to avoid.\n+\t\tbuildMode := build.ImportComment\n+\t\tif mode&useVendor == 0 || path != origPath {\n+\t\t\t// Not vendoring, or we already found the vendored path.\n+\t\t\tbuildMode |= build.IgnoreVendor\n \t\t}\n-\t\tif mode&useVendor != 0 {\n-\t\t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n-\t\t\t\treturn perr\n-\t\t\t}\n+\t\tbp, err := buildContext.Import(path, srcDir, buildMode)\n+\t\tbp.ImportPath = importPath\n+\t\tif gobin != \"\" {\n+\t\t\tbp.BinDir = gobin\n+\t\t}\n+\t\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n+\t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n+\t\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n+\t\t}\n+\t\tp.load(stk, bp, err)\n+\t\tif p.Error != nil && p.Error.Pos == \"\" {\n+\t\t\tp = setErrorPos(p, importPos)\n \t\t}\n-\t\treturn reusePackage(p, stk)\n-\t}\n-\n-\tp := new(Package)\n-\tp.local = isLocal\n-\tp.ImportPath = importPath\n-\tpackageCache[importPath] = p\n \n-\t// Load package.\n-\t// Import always returns bp != nil, even if an error occurs,\n-\t// in order to return partial information.\n-\t//\n-\t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n-\t// See issue 3268 for mistakes to avoid.\n-\tbuildMode := build.ImportComment\n-\tif mode&useVendor == 0 || path != origPath {\n-\t\t// Not vendoring, or we already found the vendored path.\n-\t\tbuildMode |= build.IgnoreVendor\n-\t}\n-\tbp, err := buildContext.Import(path, srcDir, buildMode)\n-\tbp.ImportPath = importPath\n-\tif gobin != \"\" {\n-\t\tbp.BinDir = gobin\n-\t}\n-\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n-\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n-\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n-\t}\n-\tp.load(stk, bp, err)\n-\tif p.Error != nil && p.Error.Pos == \"\" && len(importPos) > 0 {\n-\t\tpos := importPos[0]\n-\t\tpos.Filename = shortPath(pos.Filename)\n-\t\tp.Error.Pos = pos.String()\n+\t\tif origPath != cleanImport(origPath) {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n+\t\t\t}\n+\t\t\tp.Incomplete = true\n+\t\t}\n \t}\n \n+\t// Checked on every import because the rules depend on the code doing the importing.\n \tif perr := disallowInternal(srcDir, p, stk); perr != p {\n-\t\treturn perr\n+\t\treturn setErrorPos(perr, importPos)\n \t}\n \tif mode&useVendor != 0 {\n \t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n-\t\t\treturn perr\n+\t\t\treturn setErrorPos(perr, importPos)\n+\t\t}\n+\t}\n+\n+\tif p.Name == \"main\" && parent != nil && parent.Dir != p.Dir {\n+\t\tperr := *p\n+\t\tperr.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         fmt.Sprintf(\"import %q is a program, not an importable package\", path),\n \t\t}\n+\t\treturn setErrorPos(&perr, importPos)\n \t}\n \n+\tif p.local && parent != nil && !parent.local {\n+\t\tperr := *p\n+\t\tperr.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         fmt.Sprintf(\"local import %q in non-local package\", path),\n+\t\t}\n+\t\treturn setErrorPos(&perr, importPos)\n+\t}\n+\n+\treturn p\n+}\n+\n+func setErrorPos(p *Package, importPos []token.Position) *Package {\n+\tif len(importPos) > 0 {\n+\t\tpos := importPos[0]\n+\t\tpos.Filename = shortPath(pos.Filename)\n+\t\tp.Error.Pos = pos.String()\n+\t}\n \treturn p\n }\n \n+func cleanImport(path string) string {\n+\torig := path\n+\tpath = pathpkg.Clean(path)\n+\tif strings.HasPrefix(orig, \"./\") && path != \"..\" && path != \".\" && !strings.HasPrefix(path, \"../\") {\n+\t\tpath = \"./\" + path\n+\t}\n+\treturn path\n+}\n+\n var isDirCache = map[string]bool{}\n \n func isDir(path string) bool {\n@@ -419,13 +464,26 @@ func vendoredImportPath(parent *Package, path string) (found string) {\n \n \tdir := filepath.Clean(parent.Dir)\n \troot := filepath.Join(parent.Root, \"src\")\n-\tif !hasFilePathPrefix(dir, root) {\n+\tif !hasFilePathPrefix(dir, root) || parent.ImportPath != \"command-line-arguments\" && filepath.Join(root, parent.ImportPath) != dir {\n \t\t// Look for symlinks before reporting error.\n \t\tdir = expandPath(dir)\n \t\troot = expandPath(root)\n \t}\n-\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator {\n-\t\tfatalf(\"invalid vendoredImportPath: dir=%q root=%q separator=%q\", dir, root, string(filepath.Separator))\n+\n+\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.local && filepath.Join(root, parent.ImportPath) != dir {\n+\t\tfatalf(\"unexpected directory layout:\\n\"+\n+\t\t\t\"\timport path: %s\\n\"+\n+\t\t\t\"\troot: %s\\n\"+\n+\t\t\t\"\tdir: %s\\n\"+\n+\t\t\t\"\texpand root: %s\\n\"+\n+\t\t\t\"\texpand dir: %s\\n\"+\n+\t\t\t\"\tseparator: %s\",\n+\t\t\tparent.ImportPath,\n+\t\t\tfilepath.Join(parent.Root, \"src\"),\n+\t\t\tfilepath.Clean(parent.Dir),\n+\t\t\troot,\n+\t\t\tdir,\n+\t\t\tstring(filepath.Separator))\n \t}\n \n \tvpath := \"vendor/\" + path\n@@ -523,6 +581,14 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t\treturn p\n \t}\n \n+\t// The generated 'testmain' package is allowed to access testing/internal/...,\n+\t// as if it were generated into the testing directory tree\n+\t// (it's actually in a temporary directory outside any Go tree).\n+\t// This cleans up a former kludge in passing functionality to the testing package.\n+\tif strings.HasPrefix(p.ImportPath, \"testing/internal\") && len(*stk) >= 2 && (*stk)[len(*stk)-2] == \"testmain\" {\n+\t\treturn p\n+\t}\n+\n \t// We can't check standard packages with gccgo.\n \tif buildContext.Compiler == \"gccgo\" && p.Standard {\n \t\treturn p\n@@ -700,24 +766,23 @@ const (\n \n // goTools is a map of Go program import path to install target directory.\n var goTools = map[string]targetDir{\n-\t\"cmd/addr2line\":                        toTool,\n-\t\"cmd/api\":                              toTool,\n-\t\"cmd/asm\":                              toTool,\n-\t\"cmd/compile\":                          toTool,\n-\t\"cmd/cgo\":                              toTool,\n-\t\"cmd/cover\":                            toTool,\n-\t\"cmd/dist\":                             toTool,\n-\t\"cmd/doc\":                              toTool,\n-\t\"cmd/fix\":                              toTool,\n-\t\"cmd/link\":                             toTool,\n-\t\"cmd/newlink\":                          toTool,\n-\t\"cmd/nm\":                               toTool,\n-\t\"cmd/objdump\":                          toTool,\n-\t\"cmd/pack\":                             toTool,\n-\t\"cmd/pprof\":                            toTool,\n-\t\"cmd/trace\":                            toTool,\n-\t\"cmd/vet\":                              toTool,\n-\t\"cmd/yacc\":                             toTool,\n+\t\"cmd/addr2line\": toTool,\n+\t\"cmd/api\":       toTool,\n+\t\"cmd/asm\":       toTool,\n+\t\"cmd/compile\":   toTool,\n+\t\"cmd/cgo\":       toTool,\n+\t\"cmd/cover\":     toTool,\n+\t\"cmd/dist\":      toTool,\n+\t\"cmd/doc\":       toTool,\n+\t\"cmd/fix\":       toTool,\n+\t\"cmd/link\":      toTool,\n+\t\"cmd/newlink\":   toTool,\n+\t\"cmd/nm\":        toTool,\n+\t\"cmd/objdump\":   toTool,\n+\t\"cmd/pack\":      toTool,\n+\t\"cmd/pprof\":     toTool,\n+\t\"cmd/trace\":     toTool,\n+\t\"cmd/vet\":       toTool,\n \t\"code.google.com/p/go.tools/cmd/cover\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/godoc\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/vet\":   stalePath,\n@@ -792,7 +857,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \tuseBindir := p.Name == \"main\"\n \tif !p.Standard {\n \t\tswitch buildBuildmode {\n-\t\tcase \"c-archive\", \"c-shared\":\n+\t\tcase \"c-archive\", \"c-shared\", \"plugin\":\n \t\t\tuseBindir = false\n \t\t}\n \t}\n@@ -867,11 +932,25 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\timportPaths = append(importPaths, \"syscall\")\n \t}\n \n-\t// Currently build modes c-shared, pie, and -linkshared force\n-\t// external linking mode, and external linking mode forces an\n-\t// import of runtime/cgo.\n-\tif p.Name == \"main\" && !p.Goroot && (buildBuildmode == \"c-shared\" || buildBuildmode == \"pie\" || buildLinkshared) {\n-\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\tif buildContext.CgoEnabled && p.Name == \"main\" && !p.Goroot {\n+\t\t// Currently build modes c-shared, pie (on systems that do not\n+\t\t// support PIE with internal linking mode), plugin, and\n+\t\t// -linkshared force external linking mode, as of course does\n+\t\t// -ldflags=-linkmode=external. External linking mode forces\n+\t\t// an import of runtime/cgo.\n+\t\tpieCgo := buildBuildmode == \"pie\" && (buildContext.GOOS != \"linux\" || buildContext.GOARCH != \"amd64\")\n+\t\tlinkmodeExternal := false\n+\t\tfor i, a := range buildLdflags {\n+\t\t\tif a == \"-linkmode=external\" {\n+\t\t\t\tlinkmodeExternal = true\n+\t\t\t}\n+\t\t\tif a == \"-linkmode\" && i+1 < len(buildLdflags) && buildLdflags[i+1] == \"external\" {\n+\t\t\t\tlinkmodeExternal = true\n+\t\t\t}\n+\t\t}\n+\t\tif buildBuildmode == \"c-shared\" || buildBuildmode == \"plugin\" || pieCgo || buildLinkshared || linkmodeExternal {\n+\t\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\t\t}\n \t}\n \n \t// Everything depends on runtime, except runtime, its internal\n@@ -891,6 +970,10 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif p.Name == \"main\" && goarch == \"arm\" {\n \t\t\timportPaths = append(importPaths, \"math\")\n \t\t}\n+\t\t// In coverage atomic mode everything depends on sync/atomic.\n+\t\tif testCoverMode == \"atomic\" && (!p.Standard || (p.ImportPath != \"runtime/cgo\" && p.ImportPath != \"runtime/race\" && p.ImportPath != \"sync/atomic\")) {\n+\t\t\timportPaths = append(importPaths, \"sync/atomic\")\n+\t\t}\n \t}\n \n \t// Runtime and its internal packages depend on runtime/internal/sys,\n@@ -953,6 +1036,16 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t// Build list of imported packages and full dependency list.\n \timports := make([]*Package, 0, len(p.Imports))\n \tdeps := make(map[string]*Package)\n+\tsave := func(path string, p1 *Package) {\n+\t\t// The same import path could produce an error or not,\n+\t\t// depending on what tries to import it.\n+\t\t// Prefer to record entries with errors, so we can report them.\n+\t\tp0 := deps[path]\n+\t\tif p0 == nil || p1.Error != nil && (p0.Error == nil || len(p0.Error.ImportStack) > len(p1.Error.ImportStack)) {\n+\t\t\tdeps[path] = p1\n+\t\t}\n+\t}\n+\n \tfor i, path := range importPaths {\n \t\tif path == \"C\" {\n \t\t\tcontinue\n@@ -961,28 +1054,6 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif !reqStdPkgSrc && p1.Standard {\n \t\t\tcontinue\n \t\t}\n-\t\tif p1.Name == \"main\" {\n-\t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"import %q is a program, not an importable package\", path),\n-\t\t\t}\n-\t\t\tpos := p.build.ImportPos[path]\n-\t\t\tif len(pos) > 0 {\n-\t\t\t\tp.Error.Pos = pos[0].String()\n-\t\t\t}\n-\t\t}\n-\t\tif p1.local {\n-\t\t\tif !p.local && p.Error == nil {\n-\t\t\t\tp.Error = &PackageError{\n-\t\t\t\t\tImportStack: stk.copy(),\n-\t\t\t\t\tErr:         fmt.Sprintf(\"local import %q in non-local package\", path),\n-\t\t\t\t}\n-\t\t\t\tpos := p.build.ImportPos[path]\n-\t\t\t\tif len(pos) > 0 {\n-\t\t\t\t\tp.Error.Pos = pos[0].String()\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.copy(),\n@@ -999,15 +1070,11 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif i < len(p.Imports) {\n \t\t\tp.Imports[i] = path\n \t\t}\n-\t\tdeps[path] = p1\n+\n+\t\tsave(path, p1)\n \t\timports = append(imports, p1)\n \t\tfor _, dep := range p1.deps {\n-\t\t\t// The same import path could produce an error or not,\n-\t\t\t// depending on what tries to import it.\n-\t\t\t// Prefer to record entries with errors, so we can report them.\n-\t\t\tif deps[dep.ImportPath] == nil || dep.Error != nil {\n-\t\t\t\tdeps[dep.ImportPath] = dep\n-\t\t\t}\n+\t\t\tsave(dep.ImportPath, dep)\n \t\t}\n \t\tif p1.Incomplete {\n \t\t\tp.Incomplete = true"}, {"sha": "37f6327fffe2bf6b79058f34dfb50802bdef3856", "filename": "libgo/go/cmd/go/test.go", "status": "modified", "additions": 75, "deletions": 71, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -135,28 +135,11 @@ const testFlag2 = `\n \t    By default, no benchmarks run. To run all benchmarks,\n \t    use '-bench .' or '-bench=.'.\n \n-\t-benchmem\n-\t    Print memory allocation statistics for benchmarks.\n-\n \t-benchtime t\n \t    Run enough iterations of each benchmark to take t, specified\n \t    as a time.Duration (for example, -benchtime 1h30s).\n \t    The default is 1 second (1s).\n \n-\t-blockprofile block.out\n-\t    Write a goroutine blocking profile to the specified file\n-\t    when all tests are complete.\n-\t    Writes test binary as -c would.\n-\n-\t-blockprofilerate n\n-\t    Control the detail provided in goroutine blocking profiles by\n-\t    calling runtime.SetBlockProfileRate with n.\n-\t    See 'go doc runtime.SetBlockProfileRate'.\n-\t    The profiler aims to sample, on average, one blocking event every\n-\t    n nanoseconds the program spends blocked.  By default,\n-\t    if -test.blockprofile is set without this flag, all blocking events\n-\t    are recorded, equivalent to -test.blockprofilerate=1.\n-\n \t-count n\n \t    Run each test and benchmark n times (default 1).\n \t    If -cpu is set, run n times for each GOMAXPROCS value.\n@@ -182,33 +165,11 @@ const testFlag2 = `\n \t    Packages are specified as import paths.\n \t    Sets -cover.\n \n-\t-coverprofile cover.out\n-\t    Write a coverage profile to the file after all tests have passed.\n-\t    Sets -cover.\n-\n \t-cpu 1,2,4\n \t    Specify a list of GOMAXPROCS values for which the tests or\n \t    benchmarks should be executed.  The default is the current value\n \t    of GOMAXPROCS.\n \n-\t-cpuprofile cpu.out\n-\t    Write a CPU profile to the specified file before exiting.\n-\t    Writes test binary as -c would.\n-\n-\t-memprofile mem.out\n-\t    Write a memory profile to the file after all tests have passed.\n-\t    Writes test binary as -c would.\n-\n-\t-memprofilerate n\n-\t    Enable more precise (and expensive) memory profiles by setting\n-\t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n-\t    To profile all memory allocations, use -test.memprofilerate=1\n-\t    and pass --alloc_space flag to the pprof tool.\n-\n-\t-outputdir directory\n-\t    Place output files from profiling in the specified directory,\n-\t    by default the directory in which \"go test\" is running.\n-\n \t-parallel n\n \t    Allow parallel execution of test functions that call t.Parallel.\n \t    The value of this flag is the maximum number of tests to run\n@@ -234,13 +195,64 @@ const testFlag2 = `\n \t    If a test runs longer than t, panic.\n \t    The default is 10 minutes (10m).\n \n-\t-trace trace.out\n-\t    Write an execution trace to the specified file before exiting.\n-\n \t-v\n \t    Verbose output: log all tests as they are run. Also print all\n \t    text from Log and Logf calls even if the test succeeds.\n \n+The following flags are also recognized by 'go test' and can be used to\n+profile the tests during execution:\n+\n+\t-benchmem\n+\t    Print memory allocation statistics for benchmarks.\n+\n+\t-blockprofile block.out\n+\t    Write a goroutine blocking profile to the specified file\n+\t    when all tests are complete.\n+\t    Writes test binary as -c would.\n+\n+\t-blockprofilerate n\n+\t    Control the detail provided in goroutine blocking profiles by\n+\t    calling runtime.SetBlockProfileRate with n.\n+\t    See 'go doc runtime.SetBlockProfileRate'.\n+\t    The profiler aims to sample, on average, one blocking event every\n+\t    n nanoseconds the program spends blocked.  By default,\n+\t    if -test.blockprofile is set without this flag, all blocking events\n+\t    are recorded, equivalent to -test.blockprofilerate=1.\n+\n+\t-coverprofile cover.out\n+\t    Write a coverage profile to the file after all tests have passed.\n+\t    Sets -cover.\n+\n+\t-cpuprofile cpu.out\n+\t    Write a CPU profile to the specified file before exiting.\n+\t    Writes test binary as -c would.\n+\n+\t-memprofile mem.out\n+\t    Write a memory profile to the file after all tests have passed.\n+\t    Writes test binary as -c would.\n+\n+\t-memprofilerate n\n+\t    Enable more precise (and expensive) memory profiles by setting\n+\t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n+\t    To profile all memory allocations, use -test.memprofilerate=1\n+\t    and pass --alloc_space flag to the pprof tool.\n+\n+\t-mutexprofile mutex.out\n+\t    Write a mutex contention profile to the specified file\n+\t    when all tests are complete.\n+\t    Writes test binary as -c would.\n+\n+\t-mutexprofilefraction n\n+\t    Sample 1 in n stack traces of goroutines holding a\n+\t    contended mutex.\n+\n+\t-outputdir directory\n+\t    Place output files from profiling in the specified directory,\n+\t    by default the directory in which \"go test\" is running.\n+\n+\t-trace trace.out\n+\t    Write an execution trace to the specified file before exiting.\n+\n Each of these flags is also recognized with an optional 'test.' prefix,\n as in -test.v. When invoking the generated test binary (the result of\n 'go test -c') directly, however, the prefix is mandatory.\n@@ -322,7 +334,8 @@ If the last comment in the function starts with \"Output:\" then the output\n is compared exactly against the comment (see examples below). If the last\n comment begins with \"Unordered output:\" then the output is compared to the\n comment, however the order of the lines is ignored. An example with no such\n-comment, or with no text after \"Output:\" is compiled but not executed.\n+comment is compiled but not executed. An example with no text after\n+\"Output:\" is compiled, executed, and expected to produce no output.\n \n Godoc displays the body of ExampleXXX to demonstrate the use\n of the function, constant, or variable XXX.  An example of a method M with\n@@ -381,9 +394,9 @@ var (\n \n var testMainDeps = map[string]bool{\n \t// Dependencies for testmain.\n-\t\"testing\": true,\n-\t\"regexp\":  true,\n-\t\"os\":      true,\n+\t\"testing\":                   true,\n+\t\"testing/internal/testdeps\": true,\n+\t\"os\": true,\n }\n \n func runTest(cmd *Command, args []string) {\n@@ -432,6 +445,11 @@ func runTest(cmd *Command, args []string) {\n \ttestStreamOutput = len(pkgArgs) == 0 || testBench ||\n \t\t(testShowPass && (len(pkgs) == 1 || buildP == 1))\n \n+\t// For 'go test -i -o x.test', we want to build x.test. Imply -c to make the logic easier.\n+\tif buildI && testO != \"\" {\n+\t\ttestC = true\n+\t}\n+\n \tvar b builder\n \tb.init()\n \n@@ -861,7 +879,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n-\tif len(ptest.GoFiles) > 0 {\n+\tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n \t\tpmain.imports = append(pmain.imports, ptest)\n \t\tt.ImportTest = true\n \t}\n@@ -1089,6 +1107,8 @@ func declareCoverVars(importPath string, files ...string) map[string]*CoverVar {\n \treturn coverVars\n }\n \n+var noTestsToRun = []byte(\"\\ntesting: warning: no tests to run\\n\")\n+\n // runTest is the action for running a test binary.\n func (b *builder) runTest(a *action) error {\n \targs := stringList(findExecCmd(), a.deps[0].target, testArgs)\n@@ -1179,10 +1199,14 @@ func (b *builder) runTest(a *action) error {\n \tout := buf.Bytes()\n \tt := fmt.Sprintf(\"%.3fs\", time.Since(t0).Seconds())\n \tif err == nil {\n+\t\tnorun := \"\"\n \t\tif testShowPass {\n \t\t\ta.testOutput.Write(out)\n \t\t}\n-\t\tfmt.Fprintf(a.testOutput, \"ok  \\t%s\\t%s%s\\n\", a.p.ImportPath, t, coveragePercentage(out))\n+\t\tif bytes.HasPrefix(out, noTestsToRun[1:]) || bytes.Contains(out, noTestsToRun) {\n+\t\t\tnorun = \" [no tests to run]\"\n+\t\t}\n+\t\tfmt.Fprintf(a.testOutput, \"ok  \\t%s\\t%s%s%s\\n\", a.p.ImportPath, t, coveragePercentage(out), norun)\n \t\treturn nil\n \t}\n \n@@ -1406,7 +1430,7 @@ func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \t\t}\n \t}\n \tex := doc.Examples(f)\n-\tsort.Sort(byOrder(ex))\n+\tsort.Slice(ex, func(i, j int) bool { return ex[i].Order < ex[j].Order })\n \tfor _, e := range ex {\n \t\t*doImport = true // import test file whether executed or not\n \t\tif e.Output == \"\" && !e.EmptyOutput {\n@@ -1428,21 +1452,15 @@ func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n \treturn nil\n }\n \n-type byOrder []*doc.Example\n-\n-func (x byOrder) Len() int           { return len(x) }\n-func (x byOrder) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n-func (x byOrder) Less(i, j int) bool { return x[i].Order < x[j].Order }\n-\n var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n package main\n \n import (\n {{if not .TestMain}}\n \t\"os\"\n {{end}}\n-\t\"regexp\"\n \t\"testing\"\n+\t\"testing/internal/testdeps\"\n \n {{if .ImportTest}}\n \t{{if .NeedTest}}_test{{else}}_{{end}} {{.Package.ImportPath | printf \"%q\"}}\n@@ -1477,20 +1495,6 @@ var examples = []testing.InternalExample{\n {{end}}\n }\n \n-var matchPat string\n-var matchRe *regexp.Regexp\n-\n-func matchString(pat, str string) (result bool, err error) {\n-\tif matchRe == nil || matchPat != pat {\n-\t\tmatchPat = pat\n-\t\tmatchRe, err = regexp.Compile(matchPat)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\treturn matchRe.MatchString(str), nil\n-}\n-\n {{if .CoverEnabled}}\n \n // Only updated by init functions, so no need for atomicity.\n@@ -1539,7 +1543,7 @@ func main() {\n \t\tCoveredPackages: {{printf \"%q\" .Covered}},\n \t})\n {{end}}\n-\tm := testing.MainStart(matchString, tests, benchmarks, examples)\n+\tm := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, examples)\n {{with .TestMain}}\n \t{{.Package}}.{{.Name}}(m)\n {{else}}"}, {"sha": "486cc4843fde6b06b11027696038b7afb8d1bab1", "filename": "libgo/go/cmd/go/testdata/src/canonical/a/a.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,3 @@\n+package a\n+\n+import _ \"c\""}, {"sha": "7f96c221c2d20dffc1a31ba53fb8476b3a8d0f8a", "filename": "libgo/go/cmd/go/testdata/src/canonical/a/c/c.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fc%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fc%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fc%2Fc.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package c"}, {"sha": "ce0f4ce3035ccf146ea7ff390f09bff38f06678f", "filename": "libgo/go/cmd/go/testdata/src/canonical/b/b.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,3 @@\n+package b\n+\n+import _ \"canonical/a/\""}, {"sha": "ef7dd7dd4616f46a2d6ae0c0b68b917445caf5fa", "filename": "libgo/go/cmd/go/testdata/src/canonical/d/d.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,3 @@\n+package d\n+\n+import _ \"canonical/b\""}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover/p.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "previous_filename": "libgo/go/cmd/go/testdata/cgocover/p.go"}, {"sha": "a8f057e358767230643d2cb226c69cfb75303b52", "filename": "libgo/go/cmd/go/testdata/src/cgocover/p_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "previous_filename": "libgo/go/cmd/go/testdata/cgocover/p_test.go"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover2/p.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,19 @@\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}"}, {"sha": "f4790d2367bbe59e313765d4cfdbf42f1f846818", "filename": "libgo/go/cmd/go/testdata/src/cgocover2/x_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,10 @@\n+package p_test\n+\n+import (\n+\t. \"cgocover2\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/p.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,19 @@\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/p_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "97d0e0f0989b0adf5c01131c02e1b8bf52769f08", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/x_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,10 @@\n+package p_test\n+\n+import (\n+\t. \"cgocover3\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/notcgo.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/p.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,19 @@\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}"}, {"sha": "fd9bae743cc28c696c74d75722dbf7f038008369", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/x_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,10 @@\n+package p_test\n+\n+import (\n+\t. \"cgocover4\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "2f078525b9de63095992379c996abab455afc1bf", "filename": "libgo/go/cmd/go/testdata/src/dupload/dupload.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,8 @@\n+package main\n+\n+import (\n+\t_ \"dupload/p2\"\n+\t_ \"p\"\n+)\n+\n+func main() {}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/dupload/p/p.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "8a80979b4e6c6866fc34f40a4ae13ff5176c3953", "filename": "libgo/go/cmd/go/testdata/src/dupload/p2/p2.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,3 @@\n+package p2\n+\n+import _ \"dupload/vendor/p\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkg/pkg.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkg%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtest/pkg.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtest/test_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtest%2Ftest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/pkg.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/test_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Ftest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgtestxtest/xtest_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgtestxtest%2Fxtest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p_test"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgxtest/pkg.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/pkgxtest/xtest_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fpkgxtest%2Fxtest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p_test"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/test/test_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftest%2Ftest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/empty/testxtest/test_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Ftest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/testxtest/xtest_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Ftestxtest%2Fxtest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p_test"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/empty/xtest/xtest_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fempty%2Fxtest%2Fxtest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package p_test"}, {"sha": "600afd93e93a6c9af1ed79a33a43f4ed5640dc30", "filename": "libgo/go/cmd/go/testdata/src/gencycle/gencycle.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,5 @@\n+//go:generate echo hello world\n+\n+package gencycle\n+\n+import _ \"gencycle\""}, {"sha": "bf019076dd57d3592fd70bc143dbbc52a65a9845", "filename": "libgo/go/cmd/go/testdata/src/importmain/ismain/main.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,5 @@\n+package main\n+\n+import _ \"importmain/test\"\n+\n+func main() {}"}, {"sha": "56e54040790227aab12ae1b2f43991b9f00f87f6", "filename": "libgo/go/cmd/go/testdata/src/importmain/test/test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1 @@\n+package test"}, {"sha": "2268a8267edd1e02db3f5b94d4e938f82980287e", "filename": "libgo/go/cmd/go/testdata/src/importmain/test/test_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,6 @@\n+package test_test\n+\n+import \"testing\"\n+import _ \"importmain/ismain\"\n+\n+func TestCase(t *testing.T) {}"}, {"sha": "c3e8de1276db3233b292cd796911c9f686e2bfcf", "filename": "libgo/go/cmd/go/testdata/src/my.pkg/main/main.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fmain%2Fmain.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+import \"my.pkg\"\n+\n+func main() {\n+\tprintln(pkg.Text)\n+}"}, {"sha": "17702a680bbcbabb5c7b30768cdcff1ad20ead4b", "filename": "libgo/go/cmd/go/testdata/src/my.pkg/pkg.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmy.pkg%2Fpkg.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,3 @@\n+package pkg\n+\n+var Text = \"unset\""}, {"sha": "264dcf0d8a0e1f589402f90774d34d591ed2fe23", "filename": "libgo/go/cmd/go/testdata/src/testrace/race_test.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,29 @@\n+package testrace\n+\n+import \"testing\"\n+\n+func TestRace(t *testing.T) {\n+\tfor i := 0; i < 10; i++ {\n+\t\tc := make(chan int)\n+\t\tx := 1\n+\t\tgo func() {\n+\t\t\tx = 2\n+\t\t\tc <- 1\n+\t\t}()\n+\t\tx = 3\n+\t\t<-c\n+\t}\n+}\n+\n+func BenchmarkRace(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc := make(chan int)\n+\t\tx := 1\n+\t\tgo func() {\n+\t\t\tx = 2\n+\t\t\tc <- 1\n+\t\t}()\n+\t\tx = 3\n+\t\t<-c\n+\t}\n+}"}, {"sha": "4850f98d80ccf089fad35000a2043c400ddc2cdf", "filename": "libgo/go/cmd/go/testdata/standalone_benchmark_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_benchmark_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,6 @@\n+package standalone_benchmark\n+\n+import \"testing\"\n+\n+func Benchmark(b *testing.B) {\n+}"}, {"sha": "ac483f9e0c4341bfc42c9bf6c1948fa860ed4a21", "filename": "libgo/go/cmd/go/testdata/standalone_fail_sub_test.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_fail_sub_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,8 @@\n+package standalone_fail_sub_test\n+\n+import \"testing\"\n+\n+func TestThatFails(t *testing.T) {\n+\tt.Run(\"Sub\", func(t *testing.T) {})\n+\tt.Fail()\n+}"}, {"sha": "d326de0a5aca0fb9a9fd9337b19fa90a082bb271", "filename": "libgo/go/cmd/go/testdata/standalone_parallel_sub_test.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_parallel_sub_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,14 @@\n+package standalone_parallel_sub_test\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+\tch := make(chan bool, 1)\n+\tt.Run(\"Sub\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\t<-ch\n+\t\tt.Run(\"Nested\", func(t *testing.T) {})\n+\t})\n+\t// Ensures that Sub will finish after its t.Run call already returned.\n+\tch <- true\n+}"}, {"sha": "f6c31db9c81e9727bf0c01e654a20c9bb80e51af", "filename": "libgo/go/cmd/go/testdata/standalone_sub_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_sub_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,7 @@\n+package standalone_sub_test\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+\tt.Run(\"Sub\", func(t *testing.T) {})\n+}"}, {"sha": "d662e55ee552bd91c14e3c69fe7d78e47dc056ad", "filename": "libgo/go/cmd/go/testdata/testterminal18153/terminal_test.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestterminal18153%2Fterminal_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+// This test is run by src/cmd/dist/test.go (cmd_go_test_terminal),\n+// and not by cmd/go's tests. This is because this test requires that\n+// that it be called with its stdout and stderr being a terminal.\n+// dist doesn't run `cmd/go test` against this test directory if\n+// dist's stdout/stderr aren't terminals.\n+//\n+// See issue 18153.\n+\n+package p\n+\n+import (\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+const ioctlReadTermios = syscall.TCGETS\n+\n+// isTerminal reports whether fd is a terminal.\n+func isTerminal(fd uintptr) bool {\n+\tvar termios syscall.Termios\n+\t_, _, err := syscall.Syscall6(syscall.SYS_IOCTL, fd, ioctlReadTermios, uintptr(unsafe.Pointer(&termios)), 0, 0, 0)\n+\treturn err == 0\n+}\n+\n+func TestIsTerminal(t *testing.T) {\n+\tif !isTerminal(1) {\n+\t\tt.Errorf(\"stdout is not a terminal\")\n+\t}\n+\tif !isTerminal(2) {\n+\t\tt.Errorf(\"stderr is not a terminal\")\n+\t}\n+}"}, {"sha": "fa53bfcdf095b3ddfa2000016eb440478da79807", "filename": "libgo/go/cmd/go/testflag.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -50,6 +50,8 @@ var testFlagDefn = []*testFlagSpec{\n \t{name: \"memprofilerate\", passToTest: true},\n \t{name: \"blockprofile\", passToTest: true},\n \t{name: \"blockprofilerate\", passToTest: true},\n+\t{name: \"mutexprofile\", passToTest: true},\n+\t{name: \"mutexprofilefraction\", passToTest: true},\n \t{name: \"outputdir\", passToTest: true},\n \t{name: \"parallel\", passToTest: true},\n \t{name: \"run\", passToTest: true},\n@@ -149,7 +151,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\t\ttestBench = true\n \t\t\tcase \"timeout\":\n \t\t\t\ttestTimeout = value\n-\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\":\n+\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"mutexprofile\":\n \t\t\t\ttestProfile = true\n \t\t\t\ttestNeedBinary = true\n \t\t\tcase \"trace\":"}, {"sha": "6e2c68fbf53125c16af63ae5b63c43e5eb82091f", "filename": "libgo/go/cmd/go/tool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -66,7 +66,7 @@ func tool(toolName string) string {\n \t\t} else {\n \t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n \t\t}\n-\t\tsetExitStatus(3)\n+\t\tsetExitStatus(2)\n \t\texit()\n \t}\n \treturn toolPath"}, {"sha": "fcdce220a7c478af19e21616891f54ed91f5fb3d", "filename": "libgo/go/cmd/go/vcs.go", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -41,7 +41,7 @@ type vcsCmd struct {\n \tresolveRepo func(v *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error)\n }\n \n-var isSecureScheme = map[string]bool{\n+var defaultSecureScheme = map[string]bool{\n \t\"https\":   true,\n \t\"git+ssh\": true,\n \t\"bzr+ssh\": true,\n@@ -55,7 +55,25 @@ func (v *vcsCmd) isSecure(repo string) bool {\n \t\t// If repo is not a URL, it's not secure.\n \t\treturn false\n \t}\n-\treturn isSecureScheme[u.Scheme]\n+\treturn v.isSecureScheme(u.Scheme)\n+}\n+\n+func (v *vcsCmd) isSecureScheme(scheme string) bool {\n+\tswitch v.cmd {\n+\tcase \"git\":\n+\t\t// GIT_ALLOW_PROTOCOL is an environment variable defined by Git. It is a\n+\t\t// colon-separated list of schemes that are allowed to be used with git\n+\t\t// fetch/clone. Any scheme not mentioned will be considered insecure.\n+\t\tif allow := os.Getenv(\"GIT_ALLOW_PROTOCOL\"); allow != \"\" {\n+\t\t\tfor _, s := range strings.Split(allow, \":\") {\n+\t\t\t\tif s == scheme {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn defaultSecureScheme[scheme]\n }\n \n // A tagCmd describes a command to list available tags\n@@ -482,7 +500,7 @@ func vcsFromDir(dir, srcRoot string) (vcs *vcsCmd, root string, err error) {\n \torigDir := dir\n \tfor len(dir) > len(srcRoot) {\n \t\tfor _, vcs := range vcsList {\n-\t\t\tif fi, err := os.Stat(filepath.Join(dir, \".\"+vcs.cmd)); err == nil && fi.IsDir() {\n+\t\t\tif _, err := os.Stat(filepath.Join(dir, \".\"+vcs.cmd)); err == nil {\n \t\t\t\treturn vcs, filepath.ToSlash(dir[len(srcRoot)+1:]), nil\n \t\t\t}\n \t\t}\n@@ -510,6 +528,9 @@ type repoRoot struct {\n \t// root is the import path corresponding to the root of the\n \t// repository\n \troot string\n+\n+\t// isCustom is true for custom import paths (those defined by HTML meta tags)\n+\tisCustom bool\n }\n \n var httpPrefixRE = regexp.MustCompile(`^https?:`)\n@@ -612,7 +633,7 @@ func repoRootFromVCSPaths(importPath, scheme string, security securityMode, vcsP\n \t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n \t\t\t} else {\n \t\t\t\tfor _, scheme := range vcs.scheme {\n-\t\t\t\t\tif security == secure && !isSecureScheme[scheme] {\n+\t\t\t\t\tif security == secure && !vcs.isSecureScheme(scheme) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t\tif vcs.ping(scheme, match[\"repo\"]) == nil {\n@@ -661,10 +682,10 @@ func repoRootForImportDynamic(importPath string, security securityMode) (*repoRo\n \t// Find the matched meta import.\n \tmmi, err := matchGoImport(imports, importPath)\n \tif err != nil {\n-\t\tif err != errNoMatch {\n+\t\tif _, ok := err.(ImportMismatchError); !ok {\n \t\t\treturn nil, fmt.Errorf(\"parse %s: %v\", urlStr, err)\n \t\t}\n-\t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags\", urlStr)\n+\t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags (%s)\", urlStr, err)\n \t}\n \tif buildV {\n \t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, mmi, urlStr)\n@@ -695,9 +716,10 @@ func repoRootForImportDynamic(importPath string, security securityMode) (*repoRo\n \t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q; no scheme\", urlStr, mmi.RepoRoot)\n \t}\n \trr := &repoRoot{\n-\t\tvcs:  vcsByCmd(mmi.VCS),\n-\t\trepo: mmi.RepoRoot,\n-\t\troot: mmi.Prefix,\n+\t\tvcs:      vcsByCmd(mmi.VCS),\n+\t\trepo:     mmi.RepoRoot,\n+\t\troot:     mmi.Prefix,\n+\t\tisCustom: true,\n \t}\n \tif rr.vcs == nil {\n \t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, mmi.VCS)\n@@ -764,9 +786,6 @@ type metaImport struct {\n \tPrefix, VCS, RepoRoot string\n }\n \n-// errNoMatch is returned from matchGoImport when there's no applicable match.\n-var errNoMatch = errors.New(\"no import match\")\n-\n func splitPathHasPrefix(path, prefix []string) bool {\n \tif len(path) < len(prefix) {\n \t\treturn false\n@@ -779,28 +798,45 @@ func splitPathHasPrefix(path, prefix []string) bool {\n \treturn true\n }\n \n+// A ImportMismatchError is returned where metaImport/s are present\n+// but none match our import path.\n+type ImportMismatchError struct {\n+\timportPath string\n+\tmismatches []string // the meta imports that were discarded for not matching our importPath\n+}\n+\n+func (m ImportMismatchError) Error() string {\n+\tformattedStrings := make([]string, len(m.mismatches))\n+\tfor i, pre := range m.mismatches {\n+\t\tformattedStrings[i] = fmt.Sprintf(\"meta tag %s did not match import path %s\", pre, m.importPath)\n+\t}\n+\treturn strings.Join(formattedStrings, \", \")\n+}\n+\n // matchGoImport returns the metaImport from imports matching importPath.\n // An error is returned if there are multiple matches.\n // errNoMatch is returned if none match.\n-func matchGoImport(imports []metaImport, importPath string) (_ metaImport, err error) {\n+func matchGoImport(imports []metaImport, importPath string) (metaImport, error) {\n \tmatch := -1\n \timp := strings.Split(importPath, \"/\")\n+\n+\terrImportMismatch := ImportMismatchError{importPath: importPath}\n \tfor i, im := range imports {\n \t\tpre := strings.Split(im.Prefix, \"/\")\n \n \t\tif !splitPathHasPrefix(imp, pre) {\n+\t\t\terrImportMismatch.mismatches = append(errImportMismatch.mismatches, im.Prefix)\n \t\t\tcontinue\n \t\t}\n \n \t\tif match != -1 {\n-\t\t\terr = fmt.Errorf(\"multiple meta tags match import path %q\", importPath)\n-\t\t\treturn\n+\t\t\treturn metaImport{}, fmt.Errorf(\"multiple meta tags match import path %q\", importPath)\n \t\t}\n \t\tmatch = i\n \t}\n+\n \tif match == -1 {\n-\t\terr = errNoMatch\n-\t\treturn\n+\t\treturn metaImport{}, errImportMismatch\n \t}\n \treturn imports[match], nil\n }"}, {"sha": "c73f5d0e85b41b53a1fffccdcf0697959a012855", "filename": "libgo/go/cmd/go/vcs_test.go", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -102,7 +102,7 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\"git.openstack.org/openstack/swift.git\",\n \t\t\t&repoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t\trepo: \"https://git.openstack.org/openstack/swift.git\",\n \t\t\t},\n \t\t},\n \t\t{\n@@ -174,11 +174,23 @@ func TestFromDir(t *testing.T) {\n \t}\n \tdefer os.RemoveAll(tempDir)\n \n-\tfor _, vcs := range vcsList {\n+\tfor j, vcs := range vcsList {\n \t\tdir := filepath.Join(tempDir, \"example.com\", vcs.name, \".\"+vcs.cmd)\n-\t\terr := os.MkdirAll(dir, 0755)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n+\t\tif j&1 == 0 {\n+\t\t\terr := os.MkdirAll(dir, 0755)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\terr := os.MkdirAll(filepath.Dir(dir), 0755)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tf, err := os.Create(dir)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tf.Close()\n \t\t}\n \n \t\twant := repoRoot{\n@@ -229,6 +241,46 @@ func TestIsSecure(t *testing.T) {\n \t}\n }\n \n+func TestIsSecureGitAllowProtocol(t *testing.T) {\n+\ttests := []struct {\n+\t\tvcs    *vcsCmd\n+\t\turl    string\n+\t\tsecure bool\n+\t}{\n+\t\t// Same as TestIsSecure to verify same behavior.\n+\t\t{vcsGit, \"http://example.com/foo.git\", false},\n+\t\t{vcsGit, \"https://example.com/foo.git\", true},\n+\t\t{vcsBzr, \"http://example.com/foo.bzr\", false},\n+\t\t{vcsBzr, \"https://example.com/foo.bzr\", true},\n+\t\t{vcsSvn, \"http://example.com/svn\", false},\n+\t\t{vcsSvn, \"https://example.com/svn\", true},\n+\t\t{vcsHg, \"http://example.com/foo.hg\", false},\n+\t\t{vcsHg, \"https://example.com/foo.hg\", true},\n+\t\t{vcsGit, \"user@server:path/to/repo.git\", false},\n+\t\t{vcsGit, \"user@server:\", false},\n+\t\t{vcsGit, \"server:repo.git\", false},\n+\t\t{vcsGit, \"server:path/to/repo.git\", false},\n+\t\t{vcsGit, \"example.com:path/to/repo.git\", false},\n+\t\t{vcsGit, \"path/that/contains/a:colon/repo.git\", false},\n+\t\t{vcsHg, \"ssh://user@example.com/path/to/repo.hg\", true},\n+\t\t// New behavior.\n+\t\t{vcsGit, \"ssh://user@example.com/foo.git\", false},\n+\t\t{vcsGit, \"foo://example.com/bar.git\", true},\n+\t\t{vcsHg, \"foo://example.com/bar.hg\", false},\n+\t\t{vcsSvn, \"foo://example.com/svn\", false},\n+\t\t{vcsBzr, \"foo://example.com/bar.bzr\", false},\n+\t}\n+\n+\tdefer os.Unsetenv(\"GIT_ALLOW_PROTOCOL\")\n+\tos.Setenv(\"GIT_ALLOW_PROTOCOL\", \"https:foo\")\n+\tfor _, test := range tests {\n+\t\tsecure := test.vcs.isSecure(test.url)\n+\t\tif secure != test.secure {\n+\t\t\tt.Errorf(\"%s isSecure(%q) = %t; want %t\", test.vcs, test.url, secure, test.secure)\n+\t\t}\n+\t}\n+}\n+\n func TestMatchGoImport(t *testing.T) {\n \ttests := []struct {\n \t\timports []metaImport\n@@ -306,6 +358,13 @@ func TestMatchGoImport(t *testing.T) {\n \t\t\tpath: \"example.com\",\n \t\t\terr:  errors.New(\"pathologically short path\"),\n \t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"different.example.com/user/foo\",\n+\t\t\terr:  errors.New(\"meta tags do not match import path\"),\n+\t\t},\n \t}\n \n \tfor _, test := range tests {"}, {"sha": "deec02e3413d6809f5b0209b7dd9101ca91bd124", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -188,6 +188,42 @@ func TestVendorGetUpdate(t *testing.T) {\n \ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n }\n \n+func TestVendorGetU(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n+}\n+\n+func TestVendorGetTU(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-t\", \"-u\", \"github.com/rsc/go-get-issue-11864/...\")\n+}\n+\n+func TestVendorGetBadVendor(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\tfor _, suffix := range []string{\"bad/imp\", \"bad/imp2\", \"bad/imp3\", \"...\"} {\n+\t\tt.Run(suffix, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.makeTempdir()\n+\t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\t\t\ttg.runFail(\"get\", \"-t\", \"-u\", \"github.com/rsc/go-get-issue-18219/\"+suffix)\n+\t\t\ttg.grepStderr(\"must be imported as\", \"did not find error about vendor import\")\n+\t\t\ttg.mustNotExist(tg.path(\"src/github.com/rsc/vendor\"))\n+\t\t})\n+\t}\n+}\n+\n func TestGetSubmodules(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n "}, {"sha": "8b22f03f653c3d2763871a06dcd7f987e2ead519", "filename": "libgo/go/cmd/gofmt/doc.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -32,7 +32,8 @@ The flags are:\n \t-w\n \t\tDo not print reformatted sources to standard output.\n \t\tIf a file's formatting is different from gofmt's, overwrite it\n-\t\twith gofmt's version.\n+\t\twith gofmt's version. If an error occurred during overwriting,\n+\t\tthe original file is restored from an automatic backup.\n \n Debugging support:\n \t-cpuprofile filename\n@@ -98,3 +99,5 @@ This may result in changes that are incompatible with earlier versions of Go.\n package main\n \n // BUG(rsc): The implementation of -r is a bit slow.\n+// BUG(gri): If -w fails, the restored original file may not have some of the\n+//           original file attributes."}, {"sha": "e1ef0ddb83717ae0210f4f8d1899afbd9d5587af", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -18,6 +18,7 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"runtime/pprof\"\n \t\"strings\"\n )\n@@ -72,13 +73,19 @@ func isGoFile(f os.FileInfo) bool {\n \n // If in == nil, the source is the contents of the file with the given filename.\n func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error {\n+\tvar perm os.FileMode = 0644\n \tif in == nil {\n \t\tf, err := os.Open(filename)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\tdefer f.Close()\n+\t\tfi, err := f.Stat()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\tin = f\n+\t\tperm = fi.Mode().Perm()\n \t}\n \n \tsrc, err := ioutil.ReadAll(in)\n@@ -116,7 +123,17 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\t\tfmt.Fprintln(out, filename)\n \t\t}\n \t\tif *write {\n-\t\t\terr = ioutil.WriteFile(filename, res, 0644)\n+\t\t\t// make a temporary backup before overwriting original\n+\t\t\tbakname, err := backupFile(filename+\".\", src, perm)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\terr = ioutil.WriteFile(filename, res, perm)\n+\t\t\tif err != nil {\n+\t\t\t\tos.Rename(bakname, filename)\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\terr = os.Remove(bakname)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -235,3 +252,36 @@ func diff(b1, b2 []byte) (data []byte, err error) {\n \treturn\n \n }\n+\n+const chmodSupported = runtime.GOOS != \"windows\"\n+\n+// backupFile writes data to a new file named filename<number> with permissions perm,\n+// with <number randomly chosen such that the file name is unique. backupFile returns\n+// the chosen file name.\n+func backupFile(filename string, data []byte, perm os.FileMode) (string, error) {\n+\t// create backup file\n+\tf, err := ioutil.TempFile(filepath.Dir(filename), filepath.Base(filename))\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tbakname := f.Name()\n+\tif chmodSupported {\n+\t\terr = f.Chmod(perm)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\tos.Remove(bakname)\n+\t\t\treturn bakname, err\n+\t\t}\n+\t}\n+\n+\t// write data to backup file\n+\tn, err := f.Write(data)\n+\tif err == nil && n < len(data) {\n+\t\terr = io.ErrShortWrite\n+\t}\n+\tif err1 := f.Close(); err == nil {\n+\t\terr = err1\n+\t}\n+\n+\treturn bakname, err\n+}"}, {"sha": "b7ca9e8d119082875c93bd36f108466104346185", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -171,3 +171,16 @@ func TestCRLF(t *testing.T) {\n \t\tt.Errorf(\"%s contains CR's\", golden)\n \t}\n }\n+\n+func TestBackupFile(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"gofmt_test\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tname, err := backupFile(filepath.Join(dir, \"foo.go\"), []byte(\"  package main\"), 0644)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tt.Logf(\"Created: %s\", name)\n+}"}, {"sha": "1a0e8174afa384fad243c46fa56c8cd845d761d3", "filename": "libgo/go/cmd/gofmt/simplify.go", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -17,47 +17,33 @@ func (s simplifier) Visit(node ast.Node) ast.Visitor {\n \tcase *ast.CompositeLit:\n \t\t// array, slice, and map composite literals may be simplified\n \t\touter := n\n-\t\tvar eltType ast.Expr\n+\t\tvar keyType, eltType ast.Expr\n \t\tswitch typ := outer.Type.(type) {\n \t\tcase *ast.ArrayType:\n \t\t\teltType = typ.Elt\n \t\tcase *ast.MapType:\n+\t\t\tkeyType = typ.Key\n \t\t\teltType = typ.Value\n \t\t}\n \n \t\tif eltType != nil {\n+\t\t\tvar ktyp reflect.Value\n+\t\t\tif keyType != nil {\n+\t\t\t\tktyp = reflect.ValueOf(keyType)\n+\t\t\t}\n \t\t\ttyp := reflect.ValueOf(eltType)\n \t\t\tfor i, x := range outer.Elts {\n \t\t\t\tpx := &outer.Elts[i]\n \t\t\t\t// look at value of indexed/named elements\n \t\t\t\tif t, ok := x.(*ast.KeyValueExpr); ok {\n+\t\t\t\t\tif keyType != nil {\n+\t\t\t\t\t\ts.simplifyLiteral(ktyp, keyType, t.Key, &t.Key)\n+\t\t\t\t\t}\n \t\t\t\t\tx = t.Value\n \t\t\t\t\tpx = &t.Value\n \t\t\t\t}\n-\t\t\t\tast.Walk(s, x) // simplify x\n-\t\t\t\t// if the element is a composite literal and its literal type\n-\t\t\t\t// matches the outer literal's element type exactly, the inner\n-\t\t\t\t// literal type may be omitted\n-\t\t\t\tif inner, ok := x.(*ast.CompositeLit); ok {\n-\t\t\t\t\tif match(nil, typ, reflect.ValueOf(inner.Type)) {\n-\t\t\t\t\t\tinner.Type = nil\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// if the outer literal's element type is a pointer type *T\n-\t\t\t\t// and the element is & of a composite literal of type T,\n-\t\t\t\t// the inner &T may be omitted.\n-\t\t\t\tif ptr, ok := eltType.(*ast.StarExpr); ok {\n-\t\t\t\t\tif addr, ok := x.(*ast.UnaryExpr); ok && addr.Op == token.AND {\n-\t\t\t\t\t\tif inner, ok := addr.X.(*ast.CompositeLit); ok {\n-\t\t\t\t\t\t\tif match(nil, reflect.ValueOf(ptr.X), reflect.ValueOf(inner.Type)) {\n-\t\t\t\t\t\t\t\tinner.Type = nil // drop T\n-\t\t\t\t\t\t\t\t*px = inner      // drop &\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\ts.simplifyLiteral(typ, eltType, x, px)\n \t\t\t}\n-\n \t\t\t// node was simplified - stop walk (there are no subnodes to simplify)\n \t\t\treturn nil\n \t\t}\n@@ -113,6 +99,32 @@ func (s simplifier) Visit(node ast.Node) ast.Visitor {\n \treturn s\n }\n \n+func (s simplifier) simplifyLiteral(typ reflect.Value, astType, x ast.Expr, px *ast.Expr) {\n+\tast.Walk(s, x) // simplify x\n+\n+\t// if the element is a composite literal and its literal type\n+\t// matches the outer literal's element type exactly, the inner\n+\t// literal type may be omitted\n+\tif inner, ok := x.(*ast.CompositeLit); ok {\n+\t\tif match(nil, typ, reflect.ValueOf(inner.Type)) {\n+\t\t\tinner.Type = nil\n+\t\t}\n+\t}\n+\t// if the outer literal's element type is a pointer type *T\n+\t// and the element is & of a composite literal of type T,\n+\t// the inner &T may be omitted.\n+\tif ptr, ok := astType.(*ast.StarExpr); ok {\n+\t\tif addr, ok := x.(*ast.UnaryExpr); ok && addr.Op == token.AND {\n+\t\t\tif inner, ok := addr.X.(*ast.CompositeLit); ok {\n+\t\t\t\tif match(nil, reflect.ValueOf(ptr.X), reflect.ValueOf(inner.Type)) {\n+\t\t\t\t\tinner.Type = nil // drop T\n+\t\t\t\t\t*px = inner      // drop &\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func isBlank(x ast.Expr) bool {\n \tident, ok := x.(*ast.Ident)\n \treturn ok && ident.Name == \"_\""}, {"sha": "a06a69d0965ed26233fe0a8ff243581e84456703", "filename": "libgo/go/cmd/gofmt/testdata/composites.golden", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -6,6 +6,10 @@ type T struct {\n \tx, y int\n }\n \n+type T2 struct {\n+\tw, z int\n+}\n+\n var _ = [42]T{\n \t{},\n \t{1, 2},\n@@ -202,3 +206,13 @@ var pieces4 = []*Piece{\n \t{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n \t{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n }\n+\n+var _ = map[T]T2{\n+\t{1, 2}: {3, 4},\n+\t{5, 6}: {7, 8},\n+}\n+\n+var _ = map[*T]*T2{\n+\t{1, 2}: {3, 4},\n+\t{5, 6}: {7, 8},\n+}"}, {"sha": "9d28ac7ed31256463839d13e357e9557b29d3dea", "filename": "libgo/go/cmd/gofmt/testdata/composites.input", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -6,6 +6,10 @@ type T struct {\n \tx, y int\n }\n \n+type T2 struct {\n+\tw, z int\n+}\n+\n var _ = [42]T{\n \tT{},\n \tT{1, 2},\n@@ -202,3 +206,13 @@ var pieces4 = []*Piece{\n \t&Piece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},\n \t&Piece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},\n }\n+\n+var _ = map[T]T2{\n+\tT{1, 2}: T2{3, 4},\n+\tT{5, 6}: T2{7, 8},\n+}\n+\n+var _ = map[*T]*T2{\n+\t&T{1, 2}: &T2{3, 4},\n+\t&T{5, 6}: &T2{7, 8},\n+}"}, {"sha": "897086f47177ddf06193a194610206fc659cfda5", "filename": "libgo/go/cmd/internal/browser/browser.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package browser provides utilities for interacting with users' browsers.\n+package browser\n+\n+import (\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+)\n+\n+// Commands returns a list of possible commands to use to open a url.\n+func Commands() [][]string {\n+\tvar cmds [][]string\n+\tif exe := os.Getenv(\"BROWSER\"); exe != \"\" {\n+\t\tcmds = append(cmds, []string{exe})\n+\t}\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\":\n+\t\tcmds = append(cmds, []string{\"/usr/bin/open\"})\n+\tcase \"windows\":\n+\t\tcmds = append(cmds, []string{\"cmd\", \"/c\", \"start\"})\n+\tdefault:\n+\t\tcmds = append(cmds, []string{\"xdg-open\"})\n+\t}\n+\tcmds = append(cmds,\n+\t\t[]string{\"chrome\"},\n+\t\t[]string{\"google-chrome\"},\n+\t\t[]string{\"chromium\"},\n+\t\t[]string{\"firefox\"},\n+\t)\n+\treturn cmds\n+}\n+\n+// Open tries to open url in a browser and reports whether it succeeded.\n+func Open(url string) bool {\n+\tfor _, args := range Commands() {\n+\t\tcmd := exec.Command(args[0], append(args[1:], url)...)\n+\t\tif cmd.Start() == nil {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "97265b3ca27ad091af42e7bf2ff120dd5e54f277", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -84,9 +84,10 @@ type compressor struct {\n \tbulkHasher func([]byte, []uint32)\n \n \t// compression algorithm\n-\tfill func(*compressor, []byte) int // copy data to window\n-\tstep func(*compressor)             // process window\n-\tsync bool                          // requesting flush\n+\tfill      func(*compressor, []byte) int // copy data to window\n+\tstep      func(*compressor)             // process window\n+\tsync      bool                          // requesting flush\n+\tbestSpeed *deflateFast                  // Encoder for BestSpeed\n \n \t// Input hash chains\n \t// hashHead[hashValue] contains the largest inputIndex with the specified hash value\n@@ -346,12 +347,13 @@ func (d *compressor) encSpeed() {\n \t\t\t\td.err = d.w.err\n \t\t\t}\n \t\t\td.windowEnd = 0\n+\t\t\td.bestSpeed.reset()\n \t\t\treturn\n \t\t}\n \n \t}\n \t// Encode the block.\n-\td.tokens = encodeBestSpeed(d.tokens[:0], d.window[:d.windowEnd])\n+\td.tokens = d.bestSpeed.encode(d.tokens[:0], d.window[:d.windowEnd])\n \n \t// If we removed less than 1/16th, Huffman compress the block.\n \tif len(d.tokens) > d.windowEnd-(d.windowEnd>>4) {\n@@ -519,10 +521,10 @@ func (d *compressor) fillStore(b []byte) int {\n }\n \n func (d *compressor) store() {\n-\tif d.windowEnd > 0 {\n+\tif d.windowEnd > 0 && (d.windowEnd == maxStoreBlockSize || d.sync) {\n \t\td.err = d.writeStoredBlock(d.window[:d.windowEnd])\n+\t\td.windowEnd = 0\n \t}\n-\td.windowEnd = 0\n }\n \n // storeHuff compresses and stores the currently added data\n@@ -584,6 +586,7 @@ func (d *compressor) init(w io.Writer, level int) (err error) {\n \t\td.window = make([]byte, maxStoreBlockSize)\n \t\td.fill = (*compressor).fillStore\n \t\td.step = (*compressor).encSpeed\n+\t\td.bestSpeed = newDeflateFast()\n \t\td.tokens = make([]token, maxStoreBlockSize)\n \tcase level == DefaultCompression:\n \t\tlevel = 6\n@@ -609,6 +612,7 @@ func (d *compressor) reset(w io.Writer) {\n \tcase BestSpeed:\n \t\td.windowEnd = 0\n \t\td.tokens = d.tokens[:0]\n+\t\td.bestSpeed.reset()\n \tdefault:\n \t\td.chainHead = -1\n \t\tfor i := range d.hashHead {\n@@ -702,10 +706,12 @@ func (w *Writer) Write(data []byte) (n int, err error) {\n \treturn w.d.write(data)\n }\n \n-// Flush flushes any pending compressed data to the underlying writer.\n+// Flush flushes any pending data to the underlying writer.\n // It is useful mainly in compressed network protocols, to ensure that\n // a remote reader has enough data to reconstruct a packet.\n // Flush does not return until the data has been written.\n+// Calling Flush when there is no pending data still causes the Writer\n+// to emit a sync marker of at least 4 bytes.\n // If the underlying writer returns an error, Flush returns that error.\n //\n // In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH."}, {"sha": "521a2603658b9bba53c7138f2c950750a2eecba9", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -342,6 +342,7 @@ func testToFromWithLimit(t *testing.T, input []byte, name string, limit [11]int)\n }\n \n func TestDeflateInflate(t *testing.T) {\n+\tt.Parallel()\n \tfor i, h := range deflateInflateTests {\n \t\ttestToFromWithLimit(t, h.in, fmt.Sprintf(\"#%d\", i), [11]int{})\n \t}\n@@ -376,6 +377,7 @@ var deflateInflateStringTests = []deflateInflateStringTest{\n }\n \n func TestDeflateInflateString(t *testing.T) {\n+\tt.Parallel()\n \tif testing.Short() && testenv.Builder() == \"\" {\n \t\tt.Skip(\"skipping in short mode\")\n \t}\n@@ -463,6 +465,7 @@ func TestRegression2508(t *testing.T) {\n }\n \n func TestWriterReset(t *testing.T) {\n+\tt.Parallel()\n \tfor level := 0; level <= 9; level++ {\n \t\tif testing.Short() && level > 1 {\n \t\t\tbreak\n@@ -490,6 +493,7 @@ func TestWriterReset(t *testing.T) {\n \t\tw.d.fill, wref.d.fill = nil, nil\n \t\tw.d.step, wref.d.step = nil, nil\n \t\tw.d.bulkHasher, wref.d.bulkHasher = nil, nil\n+\t\tw.d.bestSpeed, wref.d.bestSpeed = nil, nil\n \t\t// hashMatch is always overwritten when used.\n \t\tcopy(w.d.hashMatch[:], wref.d.hashMatch[:])\n \t\tif len(w.d.tokens) != 0 {\n@@ -558,6 +562,7 @@ func testResetOutput(t *testing.T, newWriter func(w io.Writer) (*Writer, error))\n // compressor.encSpeed method (0, 16, 128), as well as near maxStoreBlockSize\n // (65535).\n func TestBestSpeed(t *testing.T) {\n+\tt.Parallel()\n \tabc := make([]byte, 128)\n \tfor i := range abc {\n \t\tabc[i] = byte(i)\n@@ -647,6 +652,7 @@ func (w *failWriter) Write(b []byte) (int, error) {\n }\n \n func TestWriterPersistentError(t *testing.T) {\n+\tt.Parallel()\n \td, err := ioutil.ReadFile(\"../testdata/Mark.Twain-Tom.Sawyer.txt\")\n \tif err != nil {\n \t\tt.Fatalf(\"ReadFile: %v\", err)\n@@ -681,3 +687,180 @@ func TestWriterPersistentError(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBestSpeedMatch(t *testing.T) {\n+\tt.Parallel()\n+\tcases := []struct {\n+\t\tprevious, current []byte\n+\t\tt, s, want        int32\n+\t}{{\n+\t\tprevious: []byte{0, 0, 0, 1, 2},\n+\t\tcurrent:  []byte{3, 4, 5, 0, 1, 2, 3, 4, 5},\n+\t\tt:        -3,\n+\t\ts:        3,\n+\t\twant:     6,\n+\t}, {\n+\t\tprevious: []byte{0, 0, 0, 1, 2},\n+\t\tcurrent:  []byte{2, 4, 5, 0, 1, 2, 3, 4, 5},\n+\t\tt:        -3,\n+\t\ts:        3,\n+\t\twant:     3,\n+\t}, {\n+\t\tprevious: []byte{0, 0, 0, 1, 1},\n+\t\tcurrent:  []byte{3, 4, 5, 0, 1, 2, 3, 4, 5},\n+\t\tt:        -3,\n+\t\ts:        3,\n+\t\twant:     2,\n+\t}, {\n+\t\tprevious: []byte{0, 0, 0, 1, 2},\n+\t\tcurrent:  []byte{2, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        -1,\n+\t\ts:        0,\n+\t\twant:     4,\n+\t}, {\n+\t\tprevious: []byte{0, 0, 0, 1, 2, 3, 4, 5, 2, 2},\n+\t\tcurrent:  []byte{2, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        -7,\n+\t\ts:        4,\n+\t\twant:     5,\n+\t}, {\n+\t\tprevious: []byte{9, 9, 9, 9, 9},\n+\t\tcurrent:  []byte{2, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        -1,\n+\t\ts:        0,\n+\t\twant:     0,\n+\t}, {\n+\t\tprevious: []byte{9, 9, 9, 9, 9},\n+\t\tcurrent:  []byte{9, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        0,\n+\t\ts:        1,\n+\t\twant:     0,\n+\t}, {\n+\t\tprevious: []byte{},\n+\t\tcurrent:  []byte{9, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        -5,\n+\t\ts:        1,\n+\t\twant:     0,\n+\t}, {\n+\t\tprevious: []byte{},\n+\t\tcurrent:  []byte{9, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        -1,\n+\t\ts:        1,\n+\t\twant:     0,\n+\t}, {\n+\t\tprevious: []byte{},\n+\t\tcurrent:  []byte{2, 2, 2, 2, 1, 2, 3, 4, 5},\n+\t\tt:        0,\n+\t\ts:        1,\n+\t\twant:     3,\n+\t}, {\n+\t\tprevious: []byte{3, 4, 5},\n+\t\tcurrent:  []byte{3, 4, 5},\n+\t\tt:        -3,\n+\t\ts:        0,\n+\t\twant:     3,\n+\t}, {\n+\t\tprevious: make([]byte, 1000),\n+\t\tcurrent:  make([]byte, 1000),\n+\t\tt:        -1000,\n+\t\ts:        0,\n+\t\twant:     maxMatchLength - 4,\n+\t}, {\n+\t\tprevious: make([]byte, 200),\n+\t\tcurrent:  make([]byte, 500),\n+\t\tt:        -200,\n+\t\ts:        0,\n+\t\twant:     maxMatchLength - 4,\n+\t}, {\n+\t\tprevious: make([]byte, 200),\n+\t\tcurrent:  make([]byte, 500),\n+\t\tt:        0,\n+\t\ts:        1,\n+\t\twant:     maxMatchLength - 4,\n+\t}, {\n+\t\tprevious: make([]byte, maxMatchLength-4),\n+\t\tcurrent:  make([]byte, 500),\n+\t\tt:        -(maxMatchLength - 4),\n+\t\ts:        0,\n+\t\twant:     maxMatchLength - 4,\n+\t}, {\n+\t\tprevious: make([]byte, 200),\n+\t\tcurrent:  make([]byte, 500),\n+\t\tt:        -200,\n+\t\ts:        400,\n+\t\twant:     100,\n+\t}, {\n+\t\tprevious: make([]byte, 10),\n+\t\tcurrent:  make([]byte, 500),\n+\t\tt:        200,\n+\t\ts:        400,\n+\t\twant:     100,\n+\t}}\n+\tfor i, c := range cases {\n+\t\te := deflateFast{prev: c.previous}\n+\t\tgot := e.matchLen(c.s, c.t, c.current)\n+\t\tif got != c.want {\n+\t\t\tt.Errorf(\"Test %d: match length, want %d, got %d\", i, c.want, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestBestSpeedMaxMatchOffset(t *testing.T) {\n+\tt.Parallel()\n+\tconst abc, xyz = \"abcdefgh\", \"stuvwxyz\"\n+\tfor _, matchBefore := range []bool{false, true} {\n+\t\tfor _, extra := range []int{0, inputMargin - 1, inputMargin, inputMargin + 1, 2 * inputMargin} {\n+\t\t\tfor offsetAdj := -5; offsetAdj <= +5; offsetAdj++ {\n+\t\t\t\treport := func(desc string, err error) {\n+\t\t\t\t\tt.Errorf(\"matchBefore=%t, extra=%d, offsetAdj=%d: %s%v\",\n+\t\t\t\t\t\tmatchBefore, extra, offsetAdj, desc, err)\n+\t\t\t\t}\n+\n+\t\t\t\toffset := maxMatchOffset + offsetAdj\n+\n+\t\t\t\t// Make src to be a []byte of the form\n+\t\t\t\t//\t\"%s%s%s%s%s\" % (abc, zeros0, xyzMaybe, abc, zeros1)\n+\t\t\t\t// where:\n+\t\t\t\t//\tzeros0 is approximately maxMatchOffset zeros.\n+\t\t\t\t//\txyzMaybe is either xyz or the empty string.\n+\t\t\t\t//\tzeros1 is between 0 and 30 zeros.\n+\t\t\t\t// The difference between the two abc's will be offset, which\n+\t\t\t\t// is maxMatchOffset plus or minus a small adjustment.\n+\t\t\t\tsrc := make([]byte, offset+len(abc)+extra)\n+\t\t\t\tcopy(src, abc)\n+\t\t\t\tif !matchBefore {\n+\t\t\t\t\tcopy(src[offset-len(xyz):], xyz)\n+\t\t\t\t}\n+\t\t\t\tcopy(src[offset:], abc)\n+\n+\t\t\t\tbuf := new(bytes.Buffer)\n+\t\t\t\tw, err := NewWriter(buf, BestSpeed)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treport(\"NewWriter: \", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif _, err := w.Write(src); err != nil {\n+\t\t\t\t\treport(\"Write: \", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\t\treport(\"Writer.Close: \", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tr := NewReader(buf)\n+\t\t\t\tdst, err := ioutil.ReadAll(r)\n+\t\t\t\tr.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treport(\"ReadAll: \", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif !bytes.Equal(dst, src) {\n+\t\t\t\t\treport(\"\", fmt.Errorf(\"bytes differ after round-tripping\"))\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "a1636a37d67cfa9826e78de10618c94faa12f5d6", "filename": "libgo/go/compress/flate/deflatefast.go", "status": "modified", "additions": 141, "deletions": 45, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -14,12 +14,12 @@ const (\n \ttableShift = 32 - tableBits // Right-shift to get the tableBits most significant bits of a uint32.\n )\n \n-func load32(b []byte, i int) uint32 {\n+func load32(b []byte, i int32) uint32 {\n \tb = b[i : i+4 : len(b)] // Help the compiler eliminate bounds checks on the next line.\n \treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n }\n \n-func load64(b []byte, i int) uint64 {\n+func load64(b []byte, i int32) uint64 {\n \tb = b[i : i+8 : len(b)] // Help the compiler eliminate bounds checks on the next line.\n \treturn uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |\n \t\tuint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n@@ -38,31 +38,49 @@ const (\n \tminNonLiteralBlockSize = 1 + 1 + inputMargin\n )\n \n-func encodeBestSpeed(dst []token, src []byte) []token {\n+type tableEntry struct {\n+\tval    uint32 // Value at destination\n+\toffset int32\n+}\n+\n+// deflateFast maintains the table for matches,\n+// and the previous byte block for cross block matching.\n+type deflateFast struct {\n+\ttable [tableSize]tableEntry\n+\tprev  []byte // Previous block, zero length if unknown.\n+\tcur   int32  // Current match offset.\n+}\n+\n+func newDeflateFast() *deflateFast {\n+\treturn &deflateFast{cur: maxStoreBlockSize, prev: make([]byte, 0, maxStoreBlockSize)}\n+}\n+\n+// encode encodes a block given in src and appends tokens\n+// to dst and returns the result.\n+func (e *deflateFast) encode(dst []token, src []byte) []token {\n+\t// Ensure that e.cur doesn't wrap.\n+\tif e.cur > 1<<30 {\n+\t\t*e = deflateFast{cur: maxStoreBlockSize, prev: e.prev[:0]}\n+\t}\n+\n \t// This check isn't in the Snappy implementation, but there, the caller\n \t// instead of the callee handles this case.\n \tif len(src) < minNonLiteralBlockSize {\n+\t\te.cur += maxStoreBlockSize\n+\t\te.prev = e.prev[:0]\n \t\treturn emitLiteral(dst, src)\n \t}\n \n-\t// Initialize the hash table.\n-\t//\n-\t// The table element type is uint16, as s < sLimit and sLimit < len(src)\n-\t// and len(src) <= maxStoreBlockSize and maxStoreBlockSize == 65535.\n-\tvar table [tableSize]uint16\n-\n \t// sLimit is when to stop looking for offset/length copies. The inputMargin\n \t// lets us use a fast path for emitLiteral in the main loop, while we are\n \t// looking for copies.\n-\tsLimit := len(src) - inputMargin\n+\tsLimit := int32(len(src) - inputMargin)\n \n \t// nextEmit is where in src the next emitLiteral should start from.\n-\tnextEmit := 0\n-\n-\t// The encoded form must start with a literal, as there are no previous\n-\t// bytes to copy, so we start looking for hash matches at s == 1.\n-\ts := 1\n-\tnextHash := hash(load32(src, s))\n+\tnextEmit := int32(0)\n+\ts := int32(0)\n+\tcv := load32(src, s)\n+\tnextHash := hash(cv)\n \n \tfor {\n \t\t// Copied from the C++ snappy implementation:\n@@ -80,10 +98,10 @@ func encodeBestSpeed(dst []token, src []byte) []token {\n \t\t// The \"skip\" variable keeps track of how many bytes there are since\n \t\t// the last match; dividing it by 32 (ie. right-shifting by five) gives\n \t\t// the number of bytes to move ahead for each iteration.\n-\t\tskip := 32\n+\t\tskip := int32(32)\n \n \t\tnextS := s\n-\t\tcandidate := 0\n+\t\tvar candidate tableEntry\n \t\tfor {\n \t\t\ts = nextS\n \t\t\tbytesBetweenHashLookups := skip >> 5\n@@ -92,13 +110,18 @@ func encodeBestSpeed(dst []token, src []byte) []token {\n \t\t\tif nextS > sLimit {\n \t\t\t\tgoto emitRemainder\n \t\t\t}\n-\t\t\tcandidate = int(table[nextHash&tableMask])\n-\t\t\ttable[nextHash&tableMask] = uint16(s)\n-\t\t\tnextHash = hash(load32(src, nextS))\n-\t\t\t// TODO: < should be <=, and add a test for that.\n-\t\t\tif s-candidate < maxMatchOffset && load32(src, s) == load32(src, candidate) {\n-\t\t\t\tbreak\n+\t\t\tcandidate = e.table[nextHash&tableMask]\n+\t\t\tnow := load32(src, nextS)\n+\t\t\te.table[nextHash&tableMask] = tableEntry{offset: s + e.cur, val: cv}\n+\t\t\tnextHash = hash(now)\n+\n+\t\t\toffset := s - (candidate.offset - e.cur)\n+\t\t\tif offset > maxMatchOffset || cv != candidate.val {\n+\t\t\t\t// Out of range or not matched.\n+\t\t\t\tcv = now\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tbreak\n \t\t}\n \n \t\t// A 4-byte match has been found. We'll later see if more than 4 bytes\n@@ -117,22 +140,16 @@ func encodeBestSpeed(dst []token, src []byte) []token {\n \t\tfor {\n \t\t\t// Invariant: we have a 4-byte match at s, and no need to emit any\n \t\t\t// literal bytes prior to s.\n-\t\t\tbase := s\n \n \t\t\t// Extend the 4-byte match as long as possible.\n \t\t\t//\n-\t\t\t// This is an inlined version of Snappy's:\n-\t\t\t//\ts = extendMatch(src, candidate+4, s+4)\n \t\t\ts += 4\n-\t\t\ts1 := base + maxMatchLength\n-\t\t\tif s1 > len(src) {\n-\t\t\t\ts1 = len(src)\n-\t\t\t}\n-\t\t\tfor i := candidate + 4; s < s1 && src[i] == src[s]; i, s = i+1, s+1 {\n-\t\t\t}\n+\t\t\tt := candidate.offset - e.cur + 4\n+\t\t\tl := e.matchLen(s, t, src)\n \n-\t\t\t// matchToken is flate's equivalent of Snappy's emitCopy.\n-\t\t\tdst = append(dst, matchToken(uint32(s-base-baseMatchLength), uint32(base-candidate-baseMatchOffset)))\n+\t\t\t// matchToken is flate's equivalent of Snappy's emitCopy. (length,offset)\n+\t\t\tdst = append(dst, matchToken(uint32(l+4-baseMatchLength), uint32(s-t-baseMatchOffset)))\n+\t\t\ts += l\n \t\t\tnextEmit = s\n \t\t\tif s >= sLimit {\n \t\t\t\tgoto emitRemainder\n@@ -145,30 +162,109 @@ func encodeBestSpeed(dst []token, src []byte) []token {\n \t\t\t// are faster as one load64 call (with some shifts) instead of\n \t\t\t// three load32 calls.\n \t\t\tx := load64(src, s-1)\n-\t\t\tprevHash := hash(uint32(x >> 0))\n-\t\t\ttable[prevHash&tableMask] = uint16(s - 1)\n-\t\t\tcurrHash := hash(uint32(x >> 8))\n-\t\t\tcandidate = int(table[currHash&tableMask])\n-\t\t\ttable[currHash&tableMask] = uint16(s)\n-\t\t\t// TODO: >= should be >, and add a test for that.\n-\t\t\tif s-candidate >= maxMatchOffset || uint32(x>>8) != load32(src, candidate) {\n-\t\t\t\tnextHash = hash(uint32(x >> 16))\n+\t\t\tprevHash := hash(uint32(x))\n+\t\t\te.table[prevHash&tableMask] = tableEntry{offset: e.cur + s - 1, val: uint32(x)}\n+\t\t\tx >>= 8\n+\t\t\tcurrHash := hash(uint32(x))\n+\t\t\tcandidate = e.table[currHash&tableMask]\n+\t\t\te.table[currHash&tableMask] = tableEntry{offset: e.cur + s, val: uint32(x)}\n+\n+\t\t\toffset := s - (candidate.offset - e.cur)\n+\t\t\tif offset > maxMatchOffset || uint32(x) != candidate.val {\n+\t\t\t\tcv = uint32(x >> 8)\n+\t\t\t\tnextHash = hash(cv)\n \t\t\t\ts++\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n \n emitRemainder:\n-\tif nextEmit < len(src) {\n+\tif int(nextEmit) < len(src) {\n \t\tdst = emitLiteral(dst, src[nextEmit:])\n \t}\n+\te.cur += int32(len(src))\n+\te.prev = e.prev[:len(src)]\n+\tcopy(e.prev, src)\n \treturn dst\n }\n \n func emitLiteral(dst []token, lit []byte) []token {\n \tfor _, v := range lit {\n-\t\tdst = append(dst, token(v))\n+\t\tdst = append(dst, literalToken(uint32(v)))\n \t}\n \treturn dst\n }\n+\n+// matchLen returns the match length between src[s:] and src[t:].\n+// t can be negative to indicate the match is starting in e.prev.\n+// We assume that src[s-4:s] and src[t-4:t] already match.\n+func (e *deflateFast) matchLen(s, t int32, src []byte) int32 {\n+\ts1 := int(s) + maxMatchLength - 4\n+\tif s1 > len(src) {\n+\t\ts1 = len(src)\n+\t}\n+\n+\t// If we are inside the current block\n+\tif t >= 0 {\n+\t\tb := src[t:]\n+\t\ta := src[s:s1]\n+\t\tb = b[:len(a)]\n+\t\t// Extend the match to be as long as possible.\n+\t\tfor i := range a {\n+\t\t\tif a[i] != b[i] {\n+\t\t\t\treturn int32(i)\n+\t\t\t}\n+\t\t}\n+\t\treturn int32(len(a))\n+\t}\n+\n+\t// We found a match in the previous block.\n+\ttp := int32(len(e.prev)) + t\n+\tif tp < 0 {\n+\t\treturn 0\n+\t}\n+\n+\t// Extend the match to be as long as possible.\n+\ta := src[s:s1]\n+\tb := e.prev[tp:]\n+\tif len(b) > len(a) {\n+\t\tb = b[:len(a)]\n+\t}\n+\ta = a[:len(b)]\n+\tfor i := range b {\n+\t\tif a[i] != b[i] {\n+\t\t\treturn int32(i)\n+\t\t}\n+\t}\n+\n+\t// If we reached our limit, we matched everything we are\n+\t// allowed to in the previous block and we return.\n+\tn := int32(len(b))\n+\tif int(s+n) == s1 {\n+\t\treturn n\n+\t}\n+\n+\t// Continue looking for more matches in the current block.\n+\ta = src[s+n : s1]\n+\tb = src[:len(a)]\n+\tfor i := range a {\n+\t\tif a[i] != b[i] {\n+\t\t\treturn int32(i) + n\n+\t\t}\n+\t}\n+\treturn int32(len(a)) + n\n+}\n+\n+// Reset resets the encoding history.\n+// This ensures that no matches are made to the previous block.\n+func (e *deflateFast) reset() {\n+\te.prev = e.prev[:0]\n+\t// Bump the offset, so all matches will fail distance check.\n+\te.cur += maxMatchOffset\n+\n+\t// Protect against e.cur wraparound.\n+\tif e.cur > 1<<30 {\n+\t\t*e = deflateFast{cur: maxStoreBlockSize, prev: e.prev[:0]}\n+\t}\n+}"}, {"sha": "3d44dde7ae1f6d4896b54109a06cceb99ac08d41", "filename": "libgo/go/compress/flate/example_test.go", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,245 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package flate_test\n+\n+import (\n+\t\"bytes\"\n+\t\"compress/flate\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// In performance critical applications, Reset can be used to discard the\n+// current compressor or decompressor state and reinitialize them quickly\n+// by taking advantage of previously allocated memory.\n+func Example_reset() {\n+\tproverbs := []string{\n+\t\t\"Don't communicate by sharing memory, share memory by communicating.\\n\",\n+\t\t\"Concurrency is not parallelism.\\n\",\n+\t\t\"The bigger the interface, the weaker the abstraction.\\n\",\n+\t\t\"Documentation is for users.\\n\",\n+\t}\n+\n+\tvar r strings.Reader\n+\tvar b bytes.Buffer\n+\tbuf := make([]byte, 32<<10)\n+\n+\tzw, err := flate.NewWriter(nil, flate.DefaultCompression)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tzr := flate.NewReader(nil)\n+\n+\tfor _, s := range proverbs {\n+\t\tr.Reset(s)\n+\t\tb.Reset()\n+\n+\t\t// Reset the compressor and encode from some input stream.\n+\t\tzw.Reset(&b)\n+\t\tif _, err := io.CopyBuffer(zw, &r, buf); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tif err := zw.Close(); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\n+\t\t// Reset the decompressor and decode to some output stream.\n+\t\tif err := zr.(flate.Resetter).Reset(&b, nil); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tif _, err := io.CopyBuffer(os.Stdout, zr, buf); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tif err := zr.Close(); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t}\n+\n+\t// Output:\n+\t// Don't communicate by sharing memory, share memory by communicating.\n+\t// Concurrency is not parallelism.\n+\t// The bigger the interface, the weaker the abstraction.\n+\t// Documentation is for users.\n+}\n+\n+// A preset dictionary can be used to improve the compression ratio.\n+// The downside to using a dictionary is that the compressor and decompressor\n+// must agree in advance what dictionary to use.\n+func Example_dictionary() {\n+\t// The dictionary is a string of bytes. When compressing some input data,\n+\t// the compressor will attempt to substitute substrings with matches found\n+\t// in the dictionary. As such, the dictionary should only contain substrings\n+\t// that are expected to be found in the actual data stream.\n+\tconst dict = `<?xml version=\"1.0\"?>` + `<book>` + `<data>` + `<meta name=\"` + `\" content=\"`\n+\n+\t// The data to compress should (but is not required to) contain frequent\n+\t// substrings that match those in the dictionary.\n+\tconst data = `<?xml version=\"1.0\"?>\n+<book>\n+\t<meta name=\"title\" content=\"The Go Programming Language\"/>\n+\t<meta name=\"authors\" content=\"Alan Donovan and Brian Kernighan\"/>\n+\t<meta name=\"published\" content=\"2015-10-26\"/>\n+\t<meta name=\"isbn\" content=\"978-0134190440\"/>\n+\t<data>...</data>\n+</book>\n+`\n+\n+\tvar b bytes.Buffer\n+\n+\t// Compress the data using the specially crafted dictionary.\n+\tzw, err := flate.NewWriterDict(&b, flate.DefaultCompression, []byte(dict))\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif _, err := io.Copy(zw, strings.NewReader(data)); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif err := zw.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\t// The decompressor must use the same dictionary as the compressor.\n+\t// Otherwise, the input may appear as corrupted.\n+\tfmt.Println(\"Decompressed output using the dictionary:\")\n+\tzr := flate.NewReaderDict(bytes.NewReader(b.Bytes()), []byte(dict))\n+\tif _, err := io.Copy(os.Stdout, zr); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif err := zr.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tfmt.Println()\n+\n+\t// Substitute all of the bytes in the dictionary with a '#' to visually\n+\t// demonstrate the approximate effectiveness of using a preset dictionary.\n+\tfmt.Println(\"Substrings matched by the dictionary are marked with #:\")\n+\thashDict := []byte(dict)\n+\tfor i := range hashDict {\n+\t\thashDict[i] = '#'\n+\t}\n+\tzr = flate.NewReaderDict(&b, hashDict)\n+\tif _, err := io.Copy(os.Stdout, zr); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif err := zr.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\t// Output:\n+\t// Decompressed output using the dictionary:\n+\t// <?xml version=\"1.0\"?>\n+\t// <book>\n+\t// \t<meta name=\"title\" content=\"The Go Programming Language\"/>\n+\t// \t<meta name=\"authors\" content=\"Alan Donovan and Brian Kernighan\"/>\n+\t// \t<meta name=\"published\" content=\"2015-10-26\"/>\n+\t// \t<meta name=\"isbn\" content=\"978-0134190440\"/>\n+\t// \t<data>...</data>\n+\t// </book>\n+\t//\n+\t// Substrings matched by the dictionary are marked with #:\n+\t// #####################\n+\t// ######\n+\t// \t############title###########The Go Programming Language\"/#\n+\t// \t############authors###########Alan Donovan and Brian Kernighan\"/#\n+\t// \t############published###########2015-10-26\"/#\n+\t// \t############isbn###########978-0134190440\"/#\n+\t// \t######...</#####\n+\t// </#####\n+}\n+\n+// DEFLATE is suitable for transmitting compressed data across the network.\n+func Example_synchronization() {\n+\tvar wg sync.WaitGroup\n+\tdefer wg.Wait()\n+\n+\t// Use io.Pipe to simulate a network connection.\n+\t// A real network application should take care to properly close the\n+\t// underlying connection.\n+\trp, wp := io.Pipe()\n+\n+\t// Start a goroutine to act as the transmitter.\n+\twg.Add(1)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\n+\t\tzw, err := flate.NewWriter(wp, flate.BestSpeed)\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\n+\t\tb := make([]byte, 256)\n+\t\tfor _, m := range strings.Fields(\"A long time ago in a galaxy far, far away...\") {\n+\t\t\t// We use a simple framing format where the first byte is the\n+\t\t\t// message length, followed the message itself.\n+\t\t\tb[0] = uint8(copy(b[1:], m))\n+\n+\t\t\tif _, err := zw.Write(b[:1+len(m)]); err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Flush ensures that the receiver can read all data sent so far.\n+\t\t\tif err := zw.Flush(); err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif err := zw.Close(); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t}()\n+\n+\t// Start a goroutine to act as the receiver.\n+\twg.Add(1)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\n+\t\tzr := flate.NewReader(rp)\n+\n+\t\tb := make([]byte, 256)\n+\t\tfor {\n+\t\t\t// Read the message length.\n+\t\t\t// This is guaranteed to return for every corresponding\n+\t\t\t// Flush and Close on the transmitter side.\n+\t\t\tif _, err := io.ReadFull(zr, b[:1]); err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\tbreak // The transmitter closed the stream\n+\t\t\t\t}\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Read the message content.\n+\t\t\tn := int(b[0])\n+\t\t\tif _, err := io.ReadFull(zr, b[:n]); err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n+\n+\t\t\tfmt.Printf(\"Received %d bytes: %s\\n\", n, b[:n])\n+\t\t}\n+\t\tfmt.Println()\n+\n+\t\tif err := zr.Close(); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t}()\n+\n+\t// Output:\n+\t// Received 1 bytes: A\n+\t// Received 4 bytes: long\n+\t// Received 4 bytes: time\n+\t// Received 3 bytes: ago\n+\t// Received 2 bytes: in\n+\t// Received 1 bytes: a\n+\t// Received 6 bytes: galaxy\n+\t// Received 4 bytes: far,\n+\t// Received 3 bytes: far\n+\t// Received 7 bytes: away...\n+}"}, {"sha": "1e45077bd5b67b34adc7aa61d27786a24d013048", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -281,6 +281,7 @@ func TestTruncatedStreams(t *testing.T) {\n //\n // See https://github.com/google/go-github/pull/317 for background.\n func TestReaderEarlyEOF(t *testing.T) {\n+\tt.Parallel()\n \ttestSizes := []int{\n \t\t1, 2, 3, 4, 5, 6, 7, 8,\n \t\t100, 1000, 10000, 100000,"}, {"sha": "6cd6281249b8d5af20215893253270d1936f90e6", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -520,7 +520,7 @@ func (w *huffmanBitWriter) writeBlockDynamic(tokens []token, eof bool, input []b\n \t// the literalEncoding and the offsetEncoding.\n \tw.generateCodegen(numLiterals, numOffsets, w.literalEncoding, w.offsetEncoding)\n \tw.codegenEncoding.generate(w.codegenFreq[:], 7)\n-\tsize, numCodegens := w.dynamicSize(w.literalEncoding, huffOffset, 0)\n+\tsize, numCodegens := w.dynamicSize(w.literalEncoding, w.offsetEncoding, 0)\n \n \t// Store bytes, if we don't get a reasonable improvement.\n \tif ssize, storable := w.storedSize(input); storable && ssize < (size+size>>4) {"}, {"sha": "9a8c4fc455a4e6930f0b47e03b317898063b51b9", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -344,6 +344,9 @@ func (f *decompressor) Read(b []byte) (int, error) {\n \t\t\treturn 0, f.err\n \t\t}\n \t\tf.step(f)\n+\t\tif f.err != nil && len(f.toRead) == 0 {\n+\t\t\tf.toRead = f.dict.readFlush() // Flush what's left in case of error\n+\t\t}\n \t}\n }\n "}, {"sha": "951decd7754bb6aee7d1737bed6ada770c741e05", "filename": "libgo/go/compress/flate/inflate_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7,6 +7,8 @@ package flate\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"io/ioutil\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -38,6 +40,33 @@ func TestReset(t *testing.T) {\n \t}\n }\n \n+func TestReaderTruncated(t *testing.T) {\n+\tvectors := []struct{ input, output string }{\n+\t\t{\"\\x00\", \"\"},\n+\t\t{\"\\x00\\f\", \"\"},\n+\t\t{\"\\x00\\f\\x00\", \"\"},\n+\t\t{\"\\x00\\f\\x00\\xf3\\xff\", \"\"},\n+\t\t{\"\\x00\\f\\x00\\xf3\\xffhello\", \"hello\"},\n+\t\t{\"\\x00\\f\\x00\\xf3\\xffhello, world\", \"hello, world\"},\n+\t\t{\"\\x02\", \"\"},\n+\t\t{\"\\xf2H\\xcd\", \"He\"},\n+\t\t{\"\\xf2H\u03590a\\u0084\\t\", \"Hel\\x90\\x90\\x90\\x90\\x90\"},\n+\t\t{\"\\xf2H\u03590a\\u0084\\t\\x00\", \"Hel\\x90\\x90\\x90\\x90\\x90\"},\n+\t}\n+\n+\tfor i, v := range vectors {\n+\t\tr := strings.NewReader(v.input)\n+\t\tzr := NewReader(r)\n+\t\tb, err := ioutil.ReadAll(zr)\n+\t\tif err != io.ErrUnexpectedEOF {\n+\t\t\tt.Errorf(\"test %d, error mismatch: got %v, want io.ErrUnexpectedEOF\", i, err)\n+\t\t}\n+\t\tif string(b) != v.output {\n+\t\t\tt.Errorf(\"test %d, output mismatch: got %q, want %q\", i, b, v.output)\n+\t\t}\n+\t}\n+}\n+\n func TestResetDict(t *testing.T) {\n \tdict := []byte(\"the lorem fox\")\n \tss := []string{"}, {"sha": "c4d36aa37e9b6fcb743ddfb840134c7e14ed8363", "filename": "libgo/go/compress/flate/writer_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -56,6 +56,7 @@ func (e *errorWriter) Write(b []byte) (int, error) {\n \n // Test if errors from the underlying writer is passed upwards.\n func TestWriteError(t *testing.T) {\n+\tt.Parallel()\n \tbuf := new(bytes.Buffer)\n \tn := 65536\n \tif !testing.Short() {\n@@ -75,7 +76,7 @@ func TestWriteError(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"NewWriter: level %d: %v\", l, err)\n \t\t\t}\n-\t\t\tn, err := io.CopyBuffer(w, bytes.NewBuffer(in), copyBuffer)\n+\t\t\tn, err := io.CopyBuffer(w, struct{ io.Reader }{bytes.NewBuffer(in)}, copyBuffer)\n \t\t\tif err == nil {\n \t\t\t\tt.Fatalf(\"Level %d: Expected an error, writer was %#v\", l, ew)\n \t\t\t}\n@@ -113,13 +114,15 @@ func TestWriteError(t *testing.T) {\n // Test if two runs produce identical results\n // even when writing different sizes to the Writer.\n func TestDeterministic(t *testing.T) {\n+\tt.Parallel()\n \tfor i := 0; i <= 9; i++ {\n \t\tt.Run(fmt.Sprint(\"L\", i), func(t *testing.T) { testDeterministic(i, t) })\n \t}\n \tt.Run(\"LM2\", func(t *testing.T) { testDeterministic(-2, t) })\n }\n \n func testDeterministic(i int, t *testing.T) {\n+\tt.Parallel()\n \t// Test so much we cross a good number of block boundaries.\n \tvar length = maxStoreBlockSize*30 + 500\n \tif testing.Short() {\n@@ -142,7 +145,7 @@ func testDeterministic(i int, t *testing.T) {\n \t}\n \t// Use a very small prime sized buffer.\n \tcbuf := make([]byte, 787)\n-\t_, err = io.CopyBuffer(w, br, cbuf)\n+\t_, err = io.CopyBuffer(w, struct{ io.Reader }{br}, cbuf)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -157,7 +160,7 @@ func testDeterministic(i int, t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\t_, err = io.CopyBuffer(w2, br2, cbuf)\n+\t_, err = io.CopyBuffer(w2, struct{ io.Reader }{br2}, cbuf)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "4764bcb090adff2cf2567ee29919cb00b2586f8f", "filename": "libgo/go/compress/gzip/example_test.go", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package gzip_test\n+\n+import (\n+\t\"bytes\"\n+\t\"compress/gzip\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+func Example_writerReader() {\n+\tvar buf bytes.Buffer\n+\tzw := gzip.NewWriter(&buf)\n+\n+\t// Setting the Header fields is optional.\n+\tzw.Name = \"a-new-hope.txt\"\n+\tzw.Comment = \"an epic space opera by George Lucas\"\n+\tzw.ModTime = time.Date(1977, time.May, 25, 0, 0, 0, 0, time.UTC)\n+\n+\t_, err := zw.Write([]byte(\"A long time ago in a galaxy far, far away...\"))\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tif err := zw.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tzr, err := gzip.NewReader(&buf)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tfmt.Printf(\"Name: %s\\nComment: %s\\nModTime: %s\\n\\n\", zr.Name, zr.Comment, zr.ModTime.UTC())\n+\n+\tif _, err := io.Copy(os.Stdout, zr); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tif err := zr.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\t// Output:\n+\t// Name: a-new-hope.txt\n+\t// Comment: an epic space opera by George Lucas\n+\t// ModTime: 1977-05-25 00:00:00 +0000 UTC\n+\t//\n+\t// A long time ago in a galaxy far, far away...\n+}\n+\n+func ExampleReader_Multistream() {\n+\tvar buf bytes.Buffer\n+\tzw := gzip.NewWriter(&buf)\n+\n+\tvar files = []struct {\n+\t\tname    string\n+\t\tcomment string\n+\t\tmodTime time.Time\n+\t\tdata    string\n+\t}{\n+\t\t{\"file-1.txt\", \"file-header-1\", time.Date(2006, time.February, 1, 3, 4, 5, 0, time.UTC), \"Hello Gophers - 1\"},\n+\t\t{\"file-2.txt\", \"file-header-2\", time.Date(2007, time.March, 2, 4, 5, 6, 1, time.UTC), \"Hello Gophers - 2\"},\n+\t}\n+\n+\tfor _, file := range files {\n+\t\tzw.Name = file.name\n+\t\tzw.Comment = file.comment\n+\t\tzw.ModTime = file.modTime\n+\n+\t\tif _, err := zw.Write([]byte(file.data)); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\n+\t\tif err := zw.Close(); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\n+\t\tzw.Reset(&buf)\n+\t}\n+\n+\tzr, err := gzip.NewReader(&buf)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tfor {\n+\t\tzr.Multistream(false)\n+\t\tfmt.Printf(\"Name: %s\\nComment: %s\\nModTime: %s\\n\\n\", zr.Name, zr.Comment, zr.ModTime.UTC())\n+\n+\t\tif _, err := io.Copy(os.Stdout, zr); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\n+\t\tfmt.Print(\"\\n\\n\")\n+\n+\t\terr = zr.Reset(&buf)\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t}\n+\n+\tif err := zr.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\t// Output:\n+\t// Name: file-1.txt\n+\t// Comment: file-header-1\n+\t// ModTime: 2006-02-01 03:04:05 +0000 UTC\n+\t//\n+\t// Hello Gophers - 1\n+\t//\n+\t// Name: file-2.txt\n+\t// Comment: file-header-2\n+\t// ModTime: 2007-03-02 04:05:06 +0000 UTC\n+\t//\n+\t// Hello Gophers - 2\n+}"}, {"sha": "8bd750bd8b3a006c8fa4b114c3d842962c3562a6", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -186,7 +186,11 @@ func (z *Reader) readHeader() (hdr Header, err error) {\n \t\treturn hdr, ErrHeader\n \t}\n \tflg := z.buf[3]\n-\thdr.ModTime = time.Unix(int64(le.Uint32(z.buf[4:8])), 0)\n+\tif t := int64(le.Uint32(z.buf[4:8])); t > 0 {\n+\t\t// Section 2.3.1, the zero value for MTIME means that the\n+\t\t// modified time is not set.\n+\t\thdr.ModTime = time.Unix(t, 0)\n+\t}\n \t// z.buf[8] is XFL and is currently ignored.\n \thdr.OS = z.buf[9]\n \tz.digest = crc32.ChecksumIEEE(z.buf[:10])\n@@ -238,6 +242,7 @@ func (z *Reader) readHeader() (hdr Header, err error) {\n \treturn hdr, nil\n }\n \n+// Read implements io.Reader, reading uncompressed bytes from its underlying Reader.\n func (z *Reader) Read(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err"}, {"sha": "fdea0c5d5ff82a81130928061b4f674acf9dd9ba", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -339,6 +339,26 @@ var gunzipTests = []gunzipTest{\n \t\t},\n \t\tnil,\n \t},\n+\t{\n+\t\t\"\",\n+\t\t\"truncated gzip file amid raw-block\",\n+\t\t\"hello\",\n+\t\t[]byte{\n+\t\t\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n+\t\t\t0x00, 0x0c, 0x00, 0xf3, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f,\n+\t\t},\n+\t\tio.ErrUnexpectedEOF,\n+\t},\n+\t{\n+\t\t\"\",\n+\t\t\"truncated gzip file amid fixed-block\",\n+\t\t\"He\",\n+\t\t[]byte{\n+\t\t\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n+\t\t\t0xf2, 0x48, 0xcd,\n+\t\t},\n+\t\tio.ErrUnexpectedEOF,\n+\t},\n }\n \n func TestDecompressor(t *testing.T) {"}, {"sha": "aafb442a66747512ae1358c0ec47ac8a959de6b4", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"hash/crc32\"\n \t\"io\"\n+\t\"time\"\n )\n \n // These constants are copied from the flate package, so that code that imports\n@@ -19,6 +20,7 @@ const (\n \tBestSpeed          = flate.BestSpeed\n \tBestCompression    = flate.BestCompression\n \tDefaultCompression = flate.DefaultCompression\n+\tHuffmanOnly        = flate.HuffmanOnly\n )\n \n // A Writer is an io.WriteCloser.\n@@ -52,11 +54,11 @@ func NewWriter(w io.Writer) *Writer {\n // NewWriterLevel is like NewWriter but specifies the compression level instead\n // of assuming DefaultCompression.\n //\n-// The compression level can be DefaultCompression, NoCompression, or any\n-// integer value between BestSpeed and BestCompression inclusive. The error\n-// returned will be nil if the level is valid.\n+// The compression level can be DefaultCompression, NoCompression, HuffmanOnly\n+// or any integer value between BestSpeed and BestCompression inclusive.\n+// The error returned will be nil if the level is valid.\n func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n-\tif level < DefaultCompression || level > BestCompression {\n+\tif level < HuffmanOnly || level > BestCompression {\n \t\treturn nil, fmt.Errorf(\"gzip: invalid compression level: %d\", level)\n \t}\n \tz := new(Writer)\n@@ -142,10 +144,7 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t// Write the GZIP header lazily.\n \tif !z.wroteHeader {\n \t\tz.wroteHeader = true\n-\t\tz.buf[0] = gzipID1\n-\t\tz.buf[1] = gzipID2\n-\t\tz.buf[2] = gzipDeflate\n-\t\tz.buf[3] = 0\n+\t\tz.buf = [10]byte{0: gzipID1, 1: gzipID2, 2: gzipDeflate}\n \t\tif z.Extra != nil {\n \t\t\tz.buf[3] |= 0x04\n \t\t}\n@@ -155,13 +154,15 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t\tif z.Comment != \"\" {\n \t\t\tz.buf[3] |= 0x10\n \t\t}\n-\t\tle.PutUint32(z.buf[4:8], uint32(z.ModTime.Unix()))\n+\t\tif z.ModTime.After(time.Unix(0, 0)) {\n+\t\t\t// Section 2.3.1, the zero value for MTIME means that the\n+\t\t\t// modified time is not set.\n+\t\t\tle.PutUint32(z.buf[4:8], uint32(z.ModTime.Unix()))\n+\t\t}\n \t\tif z.level == BestCompression {\n \t\t\tz.buf[8] = 2\n \t\t} else if z.level == BestSpeed {\n \t\t\tz.buf[8] = 4\n-\t\t} else {\n-\t\t\tz.buf[8] = 0\n \t\t}\n \t\tz.buf[9] = z.OS\n \t\tn, z.err = z.w.Write(z.buf[:10])"}, {"sha": "865c529f55c240bf46238fa03690c38bb8033b93", "filename": "libgo/go/compress/gzip/gzip_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"io/ioutil\"\n+\t\"reflect\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -24,6 +25,9 @@ func TestEmpty(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"NewReader: %v\", err)\n \t}\n+\tif want := (Header{OS: 255}); !reflect.DeepEqual(r.Header, want) {\n+\t\tt.Errorf(\"Header mismatch:\\ngot  %#v\\nwant %#v\", r.Header, want)\n+\t}\n \tb, err := ioutil.ReadAll(r)\n \tif err != nil {\n \t\tt.Fatalf(\"ReadAll: %v\", err)"}, {"sha": "e76d47cc4ee5700d9faedfeb8b94a3c7370ac3ae", "filename": "libgo/go/compress/gzip/issue14937_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7,7 +7,6 @@ import (\n \t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n-\t\"time\"\n )\n \n // Per golang.org/issue/14937, check that every .gz file\n@@ -16,8 +15,12 @@ func TestGZIPFilesHaveZeroMTimes(t *testing.T) {\n \tif testing.Short() && testenv.Builder() == \"\" {\n \t\tt.Skip(\"skipping in short mode\")\n \t}\n+\tgoroot, err := filepath.EvalSymlinks(runtime.GOROOT())\n+\tif err != nil {\n+\t\tt.Fatal(\"error evaluating GOROOT: \", err)\n+\t}\n \tvar files []string\n-\terr := filepath.Walk(runtime.GOROOT(), func(path string, info os.FileInfo, err error) error {\n+\terr = filepath.Walk(goroot, func(path string, info os.FileInfo, err error) error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -53,7 +56,7 @@ func checkZeroMTime(t *testing.T, path string) {\n \t\treturn\n \t}\n \tdefer gz.Close()\n-\tif !gz.ModTime.Equal(time.Unix(0, 0)) {\n+\tif !gz.ModTime.IsZero() {\n \t\tt.Errorf(\"gzip file %s has non-zero mtime (%s)\", path, gz.ModTime)\n \t}\n }"}, {"sha": "7e27aecb47d1b864d167bbccd4a3dd31f925e6f1", "filename": "libgo/go/compress/zlib/reader_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -121,6 +121,24 @@ var zlibTests = []zlibTest{\n \t\t},\n \t\tErrDictionary,\n \t},\n+\t{\n+\t\t\"truncated zlib stream amid raw-block\",\n+\t\t\"hello\",\n+\t\t[]byte{\n+\t\t\t0x78, 0x9c, 0x00, 0x0c, 0x00, 0xf3, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f,\n+\t\t},\n+\t\tnil,\n+\t\tio.ErrUnexpectedEOF,\n+\t},\n+\t{\n+\t\t\"truncated zlib stream amid fixed-block\",\n+\t\t\"He\",\n+\t\t[]byte{\n+\t\t\t0x78, 0x9c, 0xf2, 0x48, 0xcd,\n+\t\t},\n+\t\tnil,\n+\t\tio.ErrUnexpectedEOF,\n+\t},\n }\n \n func TestDecompressor(t *testing.T) {"}, {"sha": "1620c00c523eb0adb1cd786368e455f6bc28dd41", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -19,6 +19,7 @@ const (\n \tBestSpeed          = flate.BestSpeed\n \tBestCompression    = flate.BestCompression\n \tDefaultCompression = flate.DefaultCompression\n+\tHuffmanOnly        = flate.HuffmanOnly\n )\n \n // A Writer takes data written to it and writes the compressed\n@@ -47,9 +48,9 @@ func NewWriter(w io.Writer) *Writer {\n // NewWriterLevel is like NewWriter but specifies the compression level instead\n // of assuming DefaultCompression.\n //\n-// The compression level can be DefaultCompression, NoCompression, or any\n-// integer value between BestSpeed and BestCompression inclusive. The error\n-// returned will be nil if the level is valid.\n+// The compression level can be DefaultCompression, NoCompression, HuffmanOnly\n+// or any integer value between BestSpeed and BestCompression inclusive.\n+// The error returned will be nil if the level is valid.\n func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n \treturn NewWriterLevelDict(w, level, nil)\n }\n@@ -60,7 +61,7 @@ func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n // The dictionary may be nil. If not, its contents should not be modified until\n // the Writer is closed.\n func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n-\tif level < DefaultCompression || level > BestCompression {\n+\tif level < HuffmanOnly || level > BestCompression {\n \t\treturn nil, fmt.Errorf(\"zlib: invalid compression level: %d\", level)\n \t}\n \treturn &Writer{\n@@ -99,7 +100,7 @@ func (z *Writer) writeHeader() (err error) {\n \t// The next bit, FDICT, is set if a dictionary is given.\n \t// The final five FCHECK bits form a mod-31 checksum.\n \tswitch z.level {\n-\tcase 0, 1:\n+\tcase -2, 0, 1:\n \t\tz.scratch[1] = 0 << 6\n \tcase 2, 3, 4, 5:\n \t\tz.scratch[1] = 1 << 6"}, {"sha": "d5019740783f16b4a5864d04b721489d43ba068b", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -147,6 +147,7 @@ func TestWriter(t *testing.T) {\n \t\ttag := fmt.Sprintf(\"#%d\", i)\n \t\ttestLevelDict(t, tag, b, DefaultCompression, \"\")\n \t\ttestLevelDict(t, tag, b, NoCompression, \"\")\n+\t\ttestLevelDict(t, tag, b, HuffmanOnly, \"\")\n \t\tfor level := BestSpeed; level <= BestCompression; level++ {\n \t\t\ttestLevelDict(t, tag, b, level, \"\")\n \t\t}\n@@ -157,6 +158,7 @@ func TestWriterBig(t *testing.T) {\n \tfor i, fn := range filenames {\n \t\ttestFileLevelDict(t, fn, DefaultCompression, \"\")\n \t\ttestFileLevelDict(t, fn, NoCompression, \"\")\n+\t\ttestFileLevelDict(t, fn, HuffmanOnly, \"\")\n \t\tfor level := BestSpeed; level <= BestCompression; level++ {\n \t\t\ttestFileLevelDict(t, fn, level, \"\")\n \t\t\tif level >= 1 && testing.Short() && testenv.Builder() == \"\" {\n@@ -174,6 +176,7 @@ func TestWriterDict(t *testing.T) {\n \tfor i, fn := range filenames {\n \t\ttestFileLevelDict(t, fn, DefaultCompression, dictionary)\n \t\ttestFileLevelDict(t, fn, NoCompression, dictionary)\n+\t\ttestFileLevelDict(t, fn, HuffmanOnly, dictionary)\n \t\tfor level := BestSpeed; level <= BestCompression; level++ {\n \t\t\ttestFileLevelDict(t, fn, level, dictionary)\n \t\t\tif level >= 1 && testing.Short() && testenv.Builder() == \"\" {\n@@ -191,8 +194,10 @@ func TestWriterReset(t *testing.T) {\n \tfor _, fn := range filenames {\n \t\ttestFileLevelDictReset(t, fn, NoCompression, nil)\n \t\ttestFileLevelDictReset(t, fn, DefaultCompression, nil)\n+\t\ttestFileLevelDictReset(t, fn, HuffmanOnly, nil)\n \t\ttestFileLevelDictReset(t, fn, NoCompression, []byte(dictionary))\n \t\ttestFileLevelDictReset(t, fn, DefaultCompression, []byte(dictionary))\n+\t\ttestFileLevelDictReset(t, fn, HuffmanOnly, []byte(dictionary))\n \t\tif testing.Short() {\n \t\t\tbreak\n \t\t}"}, {"sha": "7110c513f0870fd86493fc1f32aee41bdffc7fdd", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -83,8 +83,9 @@ func Remove(h Interface, i int) interface{} {\n // but less expensive than, calling Remove(h, i) followed by a Push of the new value.\n // The complexity is O(log(n)) where n = h.Len().\n func Fix(h Interface, i int) {\n-\tdown(h, i, h.Len())\n-\tup(h, i)\n+\tif !down(h, i, h.Len()) {\n+\t\tup(h, i)\n+\t}\n }\n \n func up(h Interface, j int) {\n@@ -98,7 +99,8 @@ func up(h Interface, j int) {\n \t}\n }\n \n-func down(h Interface, i, n int) {\n+func down(h Interface, i0, n int) bool {\n+\ti := i0\n \tfor {\n \t\tj1 := 2*i + 1\n \t\tif j1 >= n || j1 < 0 { // j1 < 0 after int overflow\n@@ -114,4 +116,5 @@ func down(h Interface, i, n int) {\n \t\th.Swap(i, j)\n \t\ti = j\n \t}\n+\treturn i > i0\n }"}, {"sha": "99e006f39fdafddc07ba9ffd506dfbf920abe516", "filename": "libgo/go/container/list/list_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -271,19 +271,19 @@ func TestMove(t *testing.T) {\n \n \tl.MoveBefore(e2, e4)\n \tcheckListPointers(t, l, []*Element{e1, e3, e2, e4})\n-\te1, e2, e3, e4 = e1, e3, e2, e4\n+\te2, e3 = e3, e2\n \n \tl.MoveBefore(e4, e1)\n \tcheckListPointers(t, l, []*Element{e4, e1, e2, e3})\n \te1, e2, e3, e4 = e4, e1, e2, e3\n \n \tl.MoveAfter(e4, e1)\n \tcheckListPointers(t, l, []*Element{e1, e4, e2, e3})\n-\te1, e2, e3, e4 = e1, e4, e2, e3\n+\te2, e3, e4 = e4, e2, e3\n \n \tl.MoveAfter(e2, e3)\n \tcheckListPointers(t, l, []*Element{e1, e3, e2, e4})\n-\te1, e2, e3, e4 = e1, e3, e2, e4\n+\te2, e3 = e3, e2\n }\n \n // Test PushFront, PushBack, PushFrontList, PushBackList with uninitialized List"}, {"sha": "b79232704eb7d14257f69e4bae80dc3b88f30439", "filename": "libgo/go/context/benchmark_test.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fbenchmark_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fbenchmark_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fbenchmark_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package context_test\n+\n+import (\n+\t. \"context\"\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func BenchmarkContextCancelTree(b *testing.B) {\n+\tdepths := []int{1, 10, 100, 1000}\n+\tfor _, d := range depths {\n+\t\tb.Run(fmt.Sprintf(\"depth=%d\", d), func(b *testing.B) {\n+\t\t\tb.Run(\"Root=Background\", func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tbuildContextTree(Background(), d)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tb.Run(\"Root=OpenCanceler\", func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tctx, cancel := WithCancel(Background())\n+\t\t\t\t\tbuildContextTree(ctx, d)\n+\t\t\t\t\tcancel()\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tb.Run(\"Root=ClosedCanceler\", func(b *testing.B) {\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tctx, cancel := WithCancel(Background())\n+\t\t\t\t\tcancel()\n+\t\t\t\t\tbuildContextTree(ctx, d)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t})\n+\t}\n+}\n+\n+func buildContextTree(root Context, depth int) {\n+\tfor d := 0; d < depth; d++ {\n+\t\troot, _ = WithCancel(root)\n+\t}\n+}"}, {"sha": "0aa7c24df9a0343b6fa983ed1efe92bcc4f5a808", "filename": "libgo/go/context/context.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -159,9 +159,9 @@ var DeadlineExceeded error = deadlineExceededError{}\n \n type deadlineExceededError struct{}\n \n-func (deadlineExceededError) Error() string { return \"context deadline exceeded\" }\n-\n-func (deadlineExceededError) Timeout() bool { return true }\n+func (deadlineExceededError) Error() string   { return \"context deadline exceeded\" }\n+func (deadlineExceededError) Timeout() bool   { return true }\n+func (deadlineExceededError) Temporary() bool { return true }\n \n // An emptyCtx is never canceled, has no values, and has no deadline. It is not\n // struct{}, since vars of this type must have distinct addresses.\n@@ -252,9 +252,9 @@ func propagateCancel(parent Context, child canceler) {\n \t\t\tchild.cancel(false, p.err)\n \t\t} else {\n \t\t\tif p.children == nil {\n-\t\t\t\tp.children = make(map[canceler]bool)\n+\t\t\t\tp.children = make(map[canceler]struct{})\n \t\t\t}\n-\t\t\tp.children[child] = true\n+\t\t\tp.children[child] = struct{}{}\n \t\t}\n \t\tp.mu.Unlock()\n \t} else {\n@@ -314,8 +314,8 @@ type cancelCtx struct {\n \tdone chan struct{} // closed by the first cancel call.\n \n \tmu       sync.Mutex\n-\tchildren map[canceler]bool // set to nil by the first cancel call\n-\terr      error             // set to non-nil by the first cancel call\n+\tchildren map[canceler]struct{} // set to nil by the first cancel call\n+\terr      error                 // set to non-nil by the first cancel call\n }\n \n func (c *cancelCtx) Done() <-chan struct{} {\n@@ -376,7 +376,7 @@ func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {\n \t\tdeadline:  deadline,\n \t}\n \tpropagateCancel(parent, c)\n-\td := deadline.Sub(time.Now())\n+\td := time.Until(deadline)\n \tif d <= 0 {\n \t\tc.cancel(true, DeadlineExceeded) // deadline has already passed\n \t\treturn c, func() { c.cancel(true, Canceled) }\n@@ -406,7 +406,7 @@ func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {\n }\n \n func (c *timerCtx) String() string {\n-\treturn fmt.Sprintf(\"%v.WithDeadline(%s [%s])\", c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))\n+\treturn fmt.Sprintf(\"%v.WithDeadline(%s [%s])\", c.cancelCtx.Context, c.deadline, time.Until(c.deadline))\n }\n \n func (c *timerCtx) cancel(removeFromParent bool, err error) {\n@@ -443,7 +443,13 @@ func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n // Use context Values only for request-scoped data that transits processes and\n // APIs, not for passing optional parameters to functions.\n //\n-// The provided key must be comparable.\n+// The provided key must be comparable and should not be of type\n+// string or any other built-in type to avoid collisions between\n+// packages using context. Users of WithValue should define their own\n+// types for keys. To avoid allocating when assigning to an\n+// interface{}, context keys often have concrete type\n+// struct{}. Alternatively, exported context key variables' static\n+// type should be a pointer or interface.\n func WithValue(parent Context, key, val interface{}) Context {\n \tif key == nil {\n \t\tpanic(\"nil key\")"}, {"sha": "b5e599fe82f1648405b7029e9432ccf94ff0bc11", "filename": "libgo/go/context/context_test.go", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -10,18 +10,34 @@ import (\n \t\"runtime\"\n \t\"strings\"\n \t\"sync\"\n-\t\"testing\"\n \t\"time\"\n )\n \n+type testingT interface {\n+\tError(args ...interface{})\n+\tErrorf(format string, args ...interface{})\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...interface{})\n+\tFatalf(format string, args ...interface{})\n+\tLog(args ...interface{})\n+\tLogf(format string, args ...interface{})\n+\tName() string\n+\tSkip(args ...interface{})\n+\tSkipNow()\n+\tSkipf(format string, args ...interface{})\n+\tSkipped() bool\n+}\n+\n // otherContext is a Context that's not one of the types defined in context.go.\n // This lets us test code paths that differ based on the underlying type of the\n // Context.\n type otherContext struct {\n \tContext\n }\n \n-func TestBackground(t *testing.T) {\n+func XTestBackground(t testingT) {\n \tc := Background()\n \tif c == nil {\n \t\tt.Fatalf(\"Background returned nil\")\n@@ -36,7 +52,7 @@ func TestBackground(t *testing.T) {\n \t}\n }\n \n-func TestTODO(t *testing.T) {\n+func XTestTODO(t testingT) {\n \tc := TODO()\n \tif c == nil {\n \t\tt.Fatalf(\"TODO returned nil\")\n@@ -51,7 +67,7 @@ func TestTODO(t *testing.T) {\n \t}\n }\n \n-func TestWithCancel(t *testing.T) {\n+func XTestWithCancel(t testingT) {\n \tc1, cancel := WithCancel(Background())\n \n \tif got, want := fmt.Sprint(c1), \"context.Background.WithCancel\"; got != want {\n@@ -92,7 +108,12 @@ func TestWithCancel(t *testing.T) {\n \t}\n }\n \n-func TestParentFinishesChild(t *testing.T) {\n+func contains(m map[canceler]struct{}, key canceler) bool {\n+\t_, ret := m[key]\n+\treturn ret\n+}\n+\n+func XTestParentFinishesChild(t testingT) {\n \t// Context tree:\n \t// parent -> cancelChild\n \t// parent -> valueChild -> timerChild\n@@ -120,7 +141,7 @@ func TestParentFinishesChild(t *testing.T) {\n \tcc := cancelChild.(*cancelCtx)\n \ttc := timerChild.(*timerCtx)\n \tpc.mu.Lock()\n-\tif len(pc.children) != 2 || !pc.children[cc] || !pc.children[tc] {\n+\tif len(pc.children) != 2 || !contains(pc.children, cc) || !contains(pc.children, tc) {\n \t\tt.Errorf(\"bad linkage: pc.children = %v, want %v and %v\",\n \t\t\tpc.children, cc, tc)\n \t}\n@@ -169,7 +190,7 @@ func TestParentFinishesChild(t *testing.T) {\n \t}\n }\n \n-func TestChildFinishesFirst(t *testing.T) {\n+func XTestChildFinishesFirst(t testingT) {\n \tcancelable, stop := WithCancel(Background())\n \tdefer stop()\n \tfor _, parent := range []Context{Background(), cancelable} {\n@@ -191,7 +212,7 @@ func TestChildFinishesFirst(t *testing.T) {\n \n \t\tif pcok {\n \t\t\tpc.mu.Lock()\n-\t\t\tif len(pc.children) != 1 || !pc.children[cc] {\n+\t\t\tif len(pc.children) != 1 || !contains(pc.children, cc) {\n \t\t\t\tt.Errorf(\"bad linkage: pc.children = %v, cc = %v\", pc.children, cc)\n \t\t\t}\n \t\t\tpc.mu.Unlock()\n@@ -229,7 +250,7 @@ func TestChildFinishesFirst(t *testing.T) {\n \t}\n }\n \n-func testDeadline(c Context, name string, failAfter time.Duration, t *testing.T) {\n+func testDeadline(c Context, name string, failAfter time.Duration, t testingT) {\n \tselect {\n \tcase <-time.After(failAfter):\n \t\tt.Fatalf(\"%s: context should have timed out\", name)\n@@ -240,7 +261,7 @@ func testDeadline(c Context, name string, failAfter time.Duration, t *testing.T)\n \t}\n }\n \n-func TestDeadline(t *testing.T) {\n+func XTestDeadline(t testingT) {\n \tc, _ := WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n \tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n \t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n@@ -263,7 +284,7 @@ func TestDeadline(t *testing.T) {\n \ttestDeadline(c, \"WithDeadline+now\", time.Second, t)\n }\n \n-func TestTimeout(t *testing.T) {\n+func XTestTimeout(t testingT) {\n \tc, _ := WithTimeout(Background(), 50*time.Millisecond)\n \tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n \t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n@@ -280,7 +301,7 @@ func TestTimeout(t *testing.T) {\n \ttestDeadline(c, \"WithTimeout+otherContext+WithTimeout\", 2*time.Second, t)\n }\n \n-func TestCanceledTimeout(t *testing.T) {\n+func XTestCanceledTimeout(t testingT) {\n \tc, _ := WithTimeout(Background(), time.Second)\n \to := otherContext{c}\n \tc, cancel := WithTimeout(o, 2*time.Second)\n@@ -303,7 +324,7 @@ var k1 = key1(1)\n var k2 = key2(1) // same int as k1, different type\n var k3 = key2(3) // same type as k2, different int\n \n-func TestValues(t *testing.T) {\n+func XTestValues(t testingT) {\n \tcheck := func(c Context, nm, v1, v2, v3 string) {\n \t\tif v, ok := c.Value(k1).(string); ok == (len(v1) == 0) || v != v1 {\n \t\t\tt.Errorf(`%s.Value(k1).(string) = %q, %t want %q, %t`, nm, v, ok, v1, len(v1) != 0)\n@@ -351,7 +372,7 @@ func TestValues(t *testing.T) {\n \tcheck(o4, \"o4\", \"\", \"c2k2\", \"\")\n }\n \n-func TestAllocs(t *testing.T) {\n+func XTestAllocs(t testingT, testingShort func() bool, testingAllocsPerRun func(int, func()) float64) {\n \tbg := Background()\n \tfor _, test := range []struct {\n \t\tdesc       string\n@@ -411,16 +432,16 @@ func TestAllocs(t *testing.T) {\n \t\t\tlimit = test.gccgoLimit\n \t\t}\n \t\tnumRuns := 100\n-\t\tif testing.Short() {\n+\t\tif testingShort() {\n \t\t\tnumRuns = 10\n \t\t}\n-\t\tif n := testing.AllocsPerRun(numRuns, test.f); n > limit {\n+\t\tif n := testingAllocsPerRun(numRuns, test.f); n > limit {\n \t\t\tt.Errorf(\"%s allocs = %f want %d\", test.desc, n, int(limit))\n \t\t}\n \t}\n }\n \n-func TestSimultaneousCancels(t *testing.T) {\n+func XTestSimultaneousCancels(t testingT) {\n \troot, cancel := WithCancel(Background())\n \tm := map[Context]CancelFunc{root: cancel}\n \tq := []Context{root}\n@@ -468,7 +489,7 @@ func TestSimultaneousCancels(t *testing.T) {\n \t}\n }\n \n-func TestInterlockedCancels(t *testing.T) {\n+func XTestInterlockedCancels(t testingT) {\n \tparent, cancelParent := WithCancel(Background())\n \tchild, cancelChild := WithCancel(parent)\n \tgo func() {\n@@ -485,15 +506,15 @@ func TestInterlockedCancels(t *testing.T) {\n \t}\n }\n \n-func TestLayersCancel(t *testing.T) {\n+func XTestLayersCancel(t testingT) {\n \ttestLayers(t, time.Now().UnixNano(), false)\n }\n \n-func TestLayersTimeout(t *testing.T) {\n+func XTestLayersTimeout(t testingT) {\n \ttestLayers(t, time.Now().UnixNano(), true)\n }\n \n-func testLayers(t *testing.T, seed int64, testTimeout bool) {\n+func testLayers(t testingT, seed int64, testTimeout bool) {\n \trand.Seed(seed)\n \terrorf := func(format string, a ...interface{}) {\n \t\tt.Errorf(fmt.Sprintf(\"seed=%d: %s\", seed, format), a...)\n@@ -562,7 +583,7 @@ func testLayers(t *testing.T, seed int64, testTimeout bool) {\n \t}\n }\n \n-func TestCancelRemoves(t *testing.T) {\n+func XTestCancelRemoves(t testingT) {\n \tcheckChildren := func(when string, ctx Context, want int) {\n \t\tif got := len(ctx.(*cancelCtx).children); got != want {\n \t\t\tt.Errorf(\"%s: context has %d children, want %d\", when, got, want)\n@@ -574,17 +595,32 @@ func TestCancelRemoves(t *testing.T) {\n \t_, cancel := WithCancel(ctx)\n \tcheckChildren(\"with WithCancel child \", ctx, 1)\n \tcancel()\n-\tcheckChildren(\"after cancelling WithCancel child\", ctx, 0)\n+\tcheckChildren(\"after canceling WithCancel child\", ctx, 0)\n \n \tctx, _ = WithCancel(Background())\n \tcheckChildren(\"after creation\", ctx, 0)\n \t_, cancel = WithTimeout(ctx, 60*time.Minute)\n \tcheckChildren(\"with WithTimeout child \", ctx, 1)\n \tcancel()\n-\tcheckChildren(\"after cancelling WithTimeout child\", ctx, 0)\n+\tcheckChildren(\"after canceling WithTimeout child\", ctx, 0)\n+}\n+\n+func XTestWithCancelCanceledParent(t testingT) {\n+\tparent, pcancel := WithCancel(Background())\n+\tpcancel()\n+\n+\tc, _ := WithCancel(parent)\n+\tselect {\n+\tcase <-c.Done():\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"timeout waiting for Done\")\n+\t}\n+\tif got, want := c.Err(), Canceled; got != want {\n+\t\tt.Errorf(\"child not cancelled; got = %v, want = %v\", got, want)\n+\t}\n }\n \n-func TestWithValueChecksKey(t *testing.T) {\n+func XTestWithValueChecksKey(t testingT) {\n \tpanicVal := recoveredValue(func() { WithValue(Background(), []byte(\"foo\"), \"bar\") })\n \tif panicVal == nil {\n \t\tt.Error(\"expected panic\")\n@@ -601,7 +637,7 @@ func recoveredValue(fn func()) (v interface{}) {\n \treturn\n }\n \n-func TestDeadlineExceededSupportsTimeout(t *testing.T) {\n+func XTestDeadlineExceededSupportsTimeout(t testingT) {\n \ti, ok := DeadlineExceeded.(interface {\n \t\tTimeout() bool\n \t})"}, {"sha": "2d48d4e82bb56538683168158b3ba45c776af052", "filename": "libgo/go/context/example_test.go", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package context_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+// This example demonstrates the use of a cancelable context to prevent a\n+// goroutine leak. By the end of the example function, the goroutine started\n+// by gen will return without leaking.\n+func ExampleWithCancel() {\n+\t// gen generates integers in a separate goroutine and\n+\t// sends them to the returned channel.\n+\t// The callers of gen need to cancel the context once\n+\t// they are done consuming generated integers not to leak\n+\t// the internal goroutine started by gen.\n+\tgen := func(ctx context.Context) <-chan int {\n+\t\tdst := make(chan int)\n+\t\tn := 1\n+\t\tgo func() {\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-ctx.Done():\n+\t\t\t\t\treturn // returning not to leak the goroutine\n+\t\t\t\tcase dst <- n:\n+\t\t\t\t\tn++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t\treturn dst\n+\t}\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel() // cancel when we are finished consuming integers\n+\n+\tfor n := range gen(ctx) {\n+\t\tfmt.Println(n)\n+\t\tif n == 5 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t// Output:\n+\t// 1\n+\t// 2\n+\t// 3\n+\t// 4\n+\t// 5\n+}\n+\n+// This example passes a context with a arbitrary deadline to tell a blocking\n+// function that it should abandon its work as soon as it gets to it.\n+func ExampleWithDeadline() {\n+\td := time.Now().Add(50 * time.Millisecond)\n+\tctx, cancel := context.WithDeadline(context.Background(), d)\n+\n+\t// Even though ctx will be expired, it is good practice to call its\n+\t// cancelation function in any case. Failure to do so may keep the\n+\t// context and its parent alive longer than necessary.\n+\tdefer cancel()\n+\n+\tselect {\n+\tcase <-time.After(1 * time.Second):\n+\t\tfmt.Println(\"overslept\")\n+\tcase <-ctx.Done():\n+\t\tfmt.Println(ctx.Err())\n+\t}\n+\n+\t// Output:\n+\t// context deadline exceeded\n+}\n+\n+// This example passes a context with a timeout to tell a blocking function that\n+// it should abandon its work after the timeout elapses.\n+func ExampleWithTimeout() {\n+\t// Pass a context with a timeout to tell a blocking function that it\n+\t// should abandon its work after the timeout elapses.\n+\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n+\tdefer cancel()\n+\n+\tselect {\n+\tcase <-time.After(1 * time.Second):\n+\t\tfmt.Println(\"overslept\")\n+\tcase <-ctx.Done():\n+\t\tfmt.Println(ctx.Err()) // prints \"context deadline exceeded\"\n+\t}\n+\n+\t// Output:\n+\t// context deadline exceeded\n+}\n+\n+func ExampleWithValue() {\n+\ttype favContextKey string\n+\n+\tf := func(ctx context.Context, k favContextKey) {\n+\t\tif v := ctx.Value(k); v != nil {\n+\t\t\tfmt.Println(\"found value:\", v)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Println(\"key not found:\", k)\n+\t}\n+\n+\tk := favContextKey(\"language\")\n+\tctx := context.WithValue(context.Background(), k, \"Go\")\n+\n+\tf(ctx, k)\n+\tf(ctx, favContextKey(\"color\"))\n+\n+\t// Output:\n+\t// found value: Go\n+\t// key not found: color\n+}"}, {"sha": "a007689d363713a4c548623ef934c6bb83918ade", "filename": "libgo/go/context/net_test.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fnet_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package context_test\n+\n+import (\n+\t\"context\"\n+\t\"net\"\n+\t\"testing\"\n+)\n+\n+func TestDeadlineExceededIsNetError(t *testing.T) {\n+\terr, ok := context.DeadlineExceeded.(net.Error)\n+\tif !ok {\n+\t\tt.Fatal(\"DeadlineExceeded does not implement net.Error\")\n+\t}\n+\tif !err.Timeout() || !err.Temporary() {\n+\t\tt.Fatalf(\"Timeout() = %v, Temporary() = %v, want true, true\", err.Timeout(), err.Temporary())\n+\t}\n+}"}, {"sha": "c74600b47b4561711d1fc54a20d5d65495fb7feb", "filename": "libgo/go/context/withtimeout_test.go", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829afb8f05602bb31c9c597b24df7377fed4f059/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829afb8f05602bb31c9c597b24df7377fed4f059/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go?ref=829afb8f05602bb31c9c597b24df7377fed4f059", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package context_test\n-\n-import (\n-\t\"context\"\n-\t\"fmt\"\n-\t\"time\"\n-)\n-\n-func ExampleWithTimeout() {\n-\t// Pass a context with a timeout to tell a blocking function that it\n-\t// should abandon its work after the timeout elapses.\n-\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n-\n-\tselect {\n-\tcase <-time.After(1 * time.Second):\n-\t\tfmt.Println(\"overslept\")\n-\tcase <-ctx.Done():\n-\t\tfmt.Println(ctx.Err()) // prints \"context deadline exceeded\"\n-\t}\n-\n-\t// Even though ctx should have expired already, it is good\n-\t// practice to call its cancelation function in any case.\n-\t// Failure to do so may keep the context and its parent alive\n-\t// longer than necessary.\n-\tcancel()\n-\n-\t// Output:\n-\t// context deadline exceeded\n-}"}, {"sha": "d14b6f1a32b8d52a62adc9a8b3b99720ac8830a1", "filename": "libgo/go/context/x_test.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcontext%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fx_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package context_test\n+\n+import (\n+\t. \"context\"\n+\t\"testing\"\n+)\n+\n+func TestBackground(t *testing.T)                      { XTestBackground(t) }\n+func TestTODO(t *testing.T)                            { XTestTODO(t) }\n+func TestWithCancel(t *testing.T)                      { XTestWithCancel(t) }\n+func TestParentFinishesChild(t *testing.T)             { XTestParentFinishesChild(t) }\n+func TestChildFinishesFirst(t *testing.T)              { XTestChildFinishesFirst(t) }\n+func TestDeadline(t *testing.T)                        { XTestDeadline(t) }\n+func TestTimeout(t *testing.T)                         { XTestTimeout(t) }\n+func TestCanceledTimeout(t *testing.T)                 { XTestCanceledTimeout(t) }\n+func TestValues(t *testing.T)                          { XTestValues(t) }\n+func TestAllocs(t *testing.T)                          { XTestAllocs(t, testing.Short, testing.AllocsPerRun) }\n+func TestSimultaneousCancels(t *testing.T)             { XTestSimultaneousCancels(t) }\n+func TestInterlockedCancels(t *testing.T)              { XTestInterlockedCancels(t) }\n+func TestLayersCancel(t *testing.T)                    { XTestLayersCancel(t) }\n+func TestLayersTimeout(t *testing.T)                   { XTestLayersTimeout(t) }\n+func TestCancelRemoves(t *testing.T)                   { XTestCancelRemoves(t) }\n+func TestWithCancelCanceledParent(t *testing.T)        { XTestWithCancelCanceledParent(t) }\n+func TestWithValueChecksKey(t *testing.T)              { XTestWithValueChecksKey(t) }\n+func TestDeadlineExceededSupportsTimeout(t *testing.T) { XTestDeadlineExceededSupportsTimeout(t) }"}, {"sha": "3e5e2359d86a095332e0c56e5331cf6d699cba85", "filename": "libgo/go/crypto/aes/aes_gcm.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -100,6 +100,9 @@ func (g *gcmAsm) Seal(dst, nonce, plaintext, data []byte) []byte {\n \tif len(nonce) != g.nonceSize {\n \t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n \t}\n+\tif uint64(len(plaintext)) > ((1<<32)-2)*BlockSize {\n+\t\tpanic(\"cipher: message too large for GCM\")\n+\t}\n \n \tvar counter, tagMask [gcmBlockSize]byte\n \n@@ -138,6 +141,10 @@ func (g *gcmAsm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n \tif len(ciphertext) < gcmTagSize {\n \t\treturn nil, errOpen\n \t}\n+\tif uint64(len(ciphertext)) > ((1<<32)-2)*BlockSize+gcmTagSize {\n+\t\treturn nil, errOpen\n+\t}\n+\n \ttag := ciphertext[len(ciphertext)-gcmTagSize:]\n \tciphertext = ciphertext[:len(ciphertext)-gcmTagSize]\n "}, {"sha": "6b011b28b5f0f16328b11fb3a5a946937805aeee", "filename": "libgo/go/crypto/aes/cbc_s390x.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -50,7 +50,9 @@ func (x *cbc) CryptBlocks(dst, src []byte) {\n \tif len(dst) < len(src) {\n \t\tpanic(\"crypto/cipher: output smaller than input\")\n \t}\n-\tcryptBlocksChain(x.c, &x.iv[0], &x.b.key[0], &dst[0], &src[0], len(src))\n+\tif len(src) > 0 {\n+\t\tcryptBlocksChain(x.c, &x.iv[0], &x.b.key[0], &dst[0], &src[0], len(src))\n+\t}\n }\n \n func (x *cbc) SetIV(iv []byte) {"}, {"sha": "fbd157e49e7d4423924472fcb8500164e434428e", "filename": "libgo/go/crypto/aes/cipher_amd64.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -8,10 +8,10 @@ package aes\n \n import (\n \t\"crypto/cipher\"\n+\t\"crypto/internal/cipherhw\"\n )\n \n // defined in asm_amd64.s\n-func hasAsm() bool\n func encryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n func decryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n func expandKeyAsm(nr int, key *byte, enc *uint32, dec *uint32)\n@@ -20,7 +20,7 @@ type aesCipherAsm struct {\n \taesCipher\n }\n \n-var useAsm = hasAsm()\n+var useAsm = cipherhw.AESGCMSupport()\n \n func newCipher(key []byte) (cipher.Block, error) {\n \tif !useAsm {"}, {"sha": "253ce89389269f0c07b56b8a5e2f91efd64bfb1f", "filename": "libgo/go/crypto/aes/cipher_s390x.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -8,6 +8,7 @@ package aes\n \n import (\n \t\"crypto/cipher\"\n+\t\"crypto/internal/cipherhw\"\n )\n \n type code int\n@@ -25,18 +26,13 @@ type aesCipherAsm struct {\n \tstorage  [256]byte // array backing key slice\n }\n \n-// hasAsm reports whether the AES-128, AES-192 and AES-256\n-// cipher message (KM) function codes are supported.\n-// Note: this function call is expensive.\n-func hasAsm() bool\n-\n // cryptBlocks invokes the cipher message (KM) instruction with\n // the given function code. This is equivalent to AES in ECB\n // mode. The length must be a multiple of BlockSize (16).\n-//go:noesape\n+//go:noescape\n func cryptBlocks(c code, key, dst, src *byte, length int)\n \n-var useAsm = hasAsm()\n+var useAsm = cipherhw.AESGCMSupport()\n \n func newCipher(key []byte) (cipher.Block, error) {\n \tif !useAsm {"}, {"sha": "cbac5ff0ea155feaa14bfbdf372876aaf56cb0e5", "filename": "libgo/go/crypto/aes/const.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -4,6 +4,13 @@\n \n // Package aes implements AES encryption (formerly Rijndael), as defined in\n // U.S. Federal Information Processing Standards Publication 197.\n+//\n+// The AES operations in this package are not implemented using constant-time algorithms.\n+// An exception is when running on systems with enabled hardware support for AES\n+// that makes these operations constant-time. Examples include amd64 systems using AES-NI\n+// extensions and s390x systems using Message-Security-Assist extensions.\n+// On such systems, when the result of NewCipher is passed to cipher.NewGCM,\n+// the GHASH operation used by GCM is also constant-time.\n package aes\n \n // This file contains AES constants - 8720 bytes of initialized data."}, {"sha": "ca7f6a778dc0cd24da91bc5249350512da657938", "filename": "libgo/go/crypto/aes/gcm_s390x.go", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fgcm_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,272 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"crypto/subtle\"\n+\t\"errors\"\n+)\n+\n+// gcmCount represents a 16-byte big-endian count value.\n+type gcmCount [16]byte\n+\n+// inc increments the rightmost 32-bits of the count value by 1.\n+func (x *gcmCount) inc() {\n+\t// The compiler should optimize this to a 32-bit addition.\n+\tn := uint32(x[15]) | uint32(x[14])<<8 | uint32(x[13])<<16 | uint32(x[12])<<24\n+\tn += 1\n+\tx[12] = byte(n >> 24)\n+\tx[13] = byte(n >> 16)\n+\tx[14] = byte(n >> 8)\n+\tx[15] = byte(n)\n+}\n+\n+// gcmLengths writes len0 || len1 as big-endian values to a 16-byte array.\n+func gcmLengths(len0, len1 uint64) [16]byte {\n+\treturn [16]byte{\n+\t\tbyte(len0 >> 56),\n+\t\tbyte(len0 >> 48),\n+\t\tbyte(len0 >> 40),\n+\t\tbyte(len0 >> 32),\n+\t\tbyte(len0 >> 24),\n+\t\tbyte(len0 >> 16),\n+\t\tbyte(len0 >> 8),\n+\t\tbyte(len0),\n+\t\tbyte(len1 >> 56),\n+\t\tbyte(len1 >> 48),\n+\t\tbyte(len1 >> 40),\n+\t\tbyte(len1 >> 32),\n+\t\tbyte(len1 >> 24),\n+\t\tbyte(len1 >> 16),\n+\t\tbyte(len1 >> 8),\n+\t\tbyte(len1),\n+\t}\n+}\n+\n+// gcmHashKey represents the 16-byte hash key required by the GHASH algorithm.\n+type gcmHashKey [16]byte\n+\n+type gcmAsm struct {\n+\tblock     *aesCipherAsm\n+\thashKey   gcmHashKey\n+\tnonceSize int\n+}\n+\n+const (\n+\tgcmBlockSize         = 16\n+\tgcmTagSize           = 16\n+\tgcmStandardNonceSize = 12\n+)\n+\n+var errOpen = errors.New(\"cipher: message authentication failed\")\n+\n+// Assert that aesCipherAsm implements the gcmAble interface.\n+var _ gcmAble = (*aesCipherAsm)(nil)\n+\n+// NewGCM returns the AES cipher wrapped in Galois Counter Mode. This is only\n+// called by crypto/cipher.NewGCM via the gcmAble interface.\n+func (c *aesCipherAsm) NewGCM(nonceSize int) (cipher.AEAD, error) {\n+\tvar hk gcmHashKey\n+\tc.Encrypt(hk[:], hk[:])\n+\tg := &gcmAsm{\n+\t\tblock:     c,\n+\t\thashKey:   hk,\n+\t\tnonceSize: nonceSize,\n+\t}\n+\treturn g, nil\n+}\n+\n+func (g *gcmAsm) NonceSize() int {\n+\treturn g.nonceSize\n+}\n+\n+func (*gcmAsm) Overhead() int {\n+\treturn gcmTagSize\n+}\n+\n+// sliceForAppend takes a slice and a requested number of bytes. It returns a\n+// slice with the contents of the given slice followed by that many bytes and a\n+// second slice that aliases into it and contains only the extra bytes. If the\n+// original slice has sufficient capacity then no allocation is performed.\n+func sliceForAppend(in []byte, n int) (head, tail []byte) {\n+\tif total := len(in) + n; cap(in) >= total {\n+\t\thead = in[:total]\n+\t} else {\n+\t\thead = make([]byte, total)\n+\t\tcopy(head, in)\n+\t}\n+\ttail = head[len(in):]\n+\treturn\n+}\n+\n+// ghash uses the GHASH algorithm to hash data with the given key. The initial\n+// hash value is given by hash which will be updated with the new hash value.\n+// The length of data must be a multiple of 16-bytes.\n+//go:noescape\n+func ghash(key *gcmHashKey, hash *[16]byte, data []byte)\n+\n+// paddedGHASH pads data with zeroes until its length is a multiple of\n+// 16-bytes. It then calculates a new value for hash using the GHASH algorithm.\n+func (g *gcmAsm) paddedGHASH(hash *[16]byte, data []byte) {\n+\tsiz := len(data) &^ 0xf // align size to 16-bytes\n+\tif siz > 0 {\n+\t\tghash(&g.hashKey, hash, data[:siz])\n+\t\tdata = data[siz:]\n+\t}\n+\tif len(data) > 0 {\n+\t\tvar s [16]byte\n+\t\tcopy(s[:], data)\n+\t\tghash(&g.hashKey, hash, s[:])\n+\t}\n+}\n+\n+// cryptBlocksGCM encrypts src using AES in counter mode using the given\n+// function code and key. The rightmost 32-bits of the counter are incremented\n+// between each block as required by the GCM spec. The initial counter value\n+// is given by cnt, which is updated with the value of the next counter value\n+// to use.\n+//\n+// The lengths of both dst and buf must be greater than or equal to the length\n+// of src. buf may be partially or completely overwritten during the execution\n+// of the function.\n+//go:noescape\n+func cryptBlocksGCM(fn code, key, dst, src, buf []byte, cnt *gcmCount)\n+\n+// counterCrypt encrypts src using AES in counter mode and places the result\n+// into dst. cnt is the initial count value and will be updated with the next\n+// count value. The length of dst must be greater than or equal to the length\n+// of src.\n+func (g *gcmAsm) counterCrypt(dst, src []byte, cnt *gcmCount) {\n+\t// Copying src into a buffer improves performance on some models when\n+\t// src and dst point to the same underlying array. We also need a\n+\t// buffer for counter values.\n+\tvar ctrbuf, srcbuf [2048]byte\n+\tfor len(src) >= 16 {\n+\t\tsiz := len(src)\n+\t\tif len(src) > len(ctrbuf) {\n+\t\t\tsiz = len(ctrbuf)\n+\t\t}\n+\t\tsiz &^= 0xf // align siz to 16-bytes\n+\t\tcopy(srcbuf[:], src[:siz])\n+\t\tcryptBlocksGCM(g.block.function, g.block.key, dst[:siz], srcbuf[:siz], ctrbuf[:], cnt)\n+\t\tsrc = src[siz:]\n+\t\tdst = dst[siz:]\n+\t}\n+\tif len(src) > 0 {\n+\t\tvar x [16]byte\n+\t\tg.block.Encrypt(x[:], cnt[:])\n+\t\tfor i := range src {\n+\t\t\tdst[i] = src[i] ^ x[i]\n+\t\t}\n+\t\tcnt.inc()\n+\t}\n+}\n+\n+// deriveCounter computes the initial GCM counter state from the given nonce.\n+// See NIST SP 800-38D, section 7.1.\n+func (g *gcmAsm) deriveCounter(nonce []byte) gcmCount {\n+\t// GCM has two modes of operation with respect to the initial counter\n+\t// state: a \"fast path\" for 96-bit (12-byte) nonces, and a \"slow path\"\n+\t// for nonces of other lengths. For a 96-bit nonce, the nonce, along\n+\t// with a four-byte big-endian counter starting at one, is used\n+\t// directly as the starting counter. For other nonce sizes, the counter\n+\t// is computed by passing it through the GHASH function.\n+\tvar counter gcmCount\n+\tif len(nonce) == gcmStandardNonceSize {\n+\t\tcopy(counter[:], nonce)\n+\t\tcounter[gcmBlockSize-1] = 1\n+\t} else {\n+\t\tvar hash [16]byte\n+\t\tg.paddedGHASH(&hash, nonce)\n+\t\tlens := gcmLengths(0, uint64(len(nonce))*8)\n+\t\tg.paddedGHASH(&hash, lens[:])\n+\t\tcopy(counter[:], hash[:])\n+\t}\n+\treturn counter\n+}\n+\n+// auth calculates GHASH(ciphertext, additionalData), masks the result with\n+// tagMask and writes the result to out.\n+func (g *gcmAsm) auth(out, ciphertext, additionalData []byte, tagMask *[gcmTagSize]byte) {\n+\tvar hash [16]byte\n+\tg.paddedGHASH(&hash, additionalData)\n+\tg.paddedGHASH(&hash, ciphertext)\n+\tlens := gcmLengths(uint64(len(additionalData))*8, uint64(len(ciphertext))*8)\n+\tg.paddedGHASH(&hash, lens[:])\n+\n+\tcopy(out, hash[:])\n+\tfor i := range out {\n+\t\tout[i] ^= tagMask[i]\n+\t}\n+}\n+\n+// Seal encrypts and authenticates plaintext. See the cipher.AEAD interface for\n+// details.\n+func (g *gcmAsm) Seal(dst, nonce, plaintext, data []byte) []byte {\n+\tif len(nonce) != g.nonceSize {\n+\t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n+\t}\n+\tif uint64(len(plaintext)) > ((1<<32)-2)*BlockSize {\n+\t\tpanic(\"cipher: message too large for GCM\")\n+\t}\n+\n+\tret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)\n+\n+\tcounter := g.deriveCounter(nonce)\n+\n+\tvar tagMask [gcmBlockSize]byte\n+\tg.block.Encrypt(tagMask[:], counter[:])\n+\tcounter.inc()\n+\n+\tg.counterCrypt(out, plaintext, &counter)\n+\tg.auth(out[len(plaintext):], out[:len(plaintext)], data, &tagMask)\n+\n+\treturn ret\n+}\n+\n+// Open authenticates and decrypts ciphertext. See the cipher.AEAD interface\n+// for details.\n+func (g *gcmAsm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n+\tif len(nonce) != g.nonceSize {\n+\t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n+\t}\n+\tif len(ciphertext) < gcmTagSize {\n+\t\treturn nil, errOpen\n+\t}\n+\tif uint64(len(ciphertext)) > ((1<<32)-2)*BlockSize+gcmTagSize {\n+\t\treturn nil, errOpen\n+\t}\n+\n+\ttag := ciphertext[len(ciphertext)-gcmTagSize:]\n+\tciphertext = ciphertext[:len(ciphertext)-gcmTagSize]\n+\n+\tcounter := g.deriveCounter(nonce)\n+\n+\tvar tagMask [gcmBlockSize]byte\n+\tg.block.Encrypt(tagMask[:], counter[:])\n+\tcounter.inc()\n+\n+\tvar expectedTag [gcmTagSize]byte\n+\tg.auth(expectedTag[:], ciphertext, data, &tagMask)\n+\n+\tret, out := sliceForAppend(dst, len(ciphertext))\n+\n+\tif subtle.ConstantTimeCompare(expectedTag[:], tag) != 1 {\n+\t\t// The AESNI code decrypts and authenticates concurrently, and\n+\t\t// so overwrites dst in the event of a tag mismatch. That\n+\t\t// behavior is mimicked here in order to be consistent across\n+\t\t// platforms.\n+\t\tfor i := range out {\n+\t\t\tout[i] = 0\n+\t\t}\n+\t\treturn nil, errOpen\n+\t}\n+\n+\tg.counterCrypt(out, ciphertext, &counter)\n+\treturn ret, nil\n+}"}, {"sha": "4d7cd6b5dd93de98d1feb0da38487253495c93b9", "filename": "libgo/go/crypto/cipher/cipher_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -5,8 +5,10 @@\n package cipher_test\n \n import (\n+\t\"bytes\"\n \t\"crypto/aes\"\n \t\"crypto/cipher\"\n+\t\"crypto/des\"\n \t\"testing\"\n )\n \n@@ -34,3 +36,55 @@ func mustPanic(t *testing.T, msg string, f func()) {\n \t}()\n \tf()\n }\n+\n+func TestEmptyPlaintext(t *testing.T) {\n+\tvar key [16]byte\n+\ta, err := aes.NewCipher(key[:16])\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\td, err := des.NewCipher(key[:8])\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\ts := 16\n+\tpt := make([]byte, s)\n+\tct := make([]byte, s)\n+\tfor i := 0; i < 16; i++ {\n+\t\tpt[i], ct[i] = byte(i), byte(i)\n+\t}\n+\n+\tassertEqual := func(name string, got, want []byte) {\n+\t\tif !bytes.Equal(got, want) {\n+\t\t\tt.Fatalf(\"%s: got %v, want %v\", name, got, want)\n+\t\t}\n+\t}\n+\n+\tfor _, b := range []cipher.Block{a, d} {\n+\t\tiv := make([]byte, b.BlockSize())\n+\t\tcbce := cipher.NewCBCEncrypter(b, iv)\n+\t\tcbce.CryptBlocks(ct, pt[:0])\n+\t\tassertEqual(\"CBC encrypt\", ct, pt)\n+\n+\t\tcbcd := cipher.NewCBCDecrypter(b, iv)\n+\t\tcbcd.CryptBlocks(ct, pt[:0])\n+\t\tassertEqual(\"CBC decrypt\", ct, pt)\n+\n+\t\tcfbe := cipher.NewCFBEncrypter(b, iv)\n+\t\tcfbe.XORKeyStream(ct, pt[:0])\n+\t\tassertEqual(\"CFB encrypt\", ct, pt)\n+\n+\t\tcfbd := cipher.NewCFBDecrypter(b, iv)\n+\t\tcfbd.XORKeyStream(ct, pt[:0])\n+\t\tassertEqual(\"CFB decrypt\", ct, pt)\n+\n+\t\tctr := cipher.NewCTR(b, iv)\n+\t\tctr.XORKeyStream(ct, pt[:0])\n+\t\tassertEqual(\"CTR\", ct, pt)\n+\n+\t\tofb := cipher.NewOFB(b, iv)\n+\t\tofb.XORKeyStream(ct, pt[:0])\n+\t\tassertEqual(\"OFB\", ct, pt)\n+\t}\n+}"}, {"sha": "956cc2eaca6333c065f2dda51e0e90c0349399c7", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -14,7 +14,7 @@ import (\n \t\"os\"\n )\n \n-func ExampleNewGCMEncrypter() {\n+func ExampleNewGCM_encrypt() {\n \t// The key argument should be the AES key, either 16 or 32 bytes\n \t// to select AES-128 or AES-256.\n \tkey := []byte(\"AES256Key-32Characters1234567890\")\n@@ -40,7 +40,7 @@ func ExampleNewGCMEncrypter() {\n \tfmt.Printf(\"%x\\n\", ciphertext)\n }\n \n-func ExampleNewGCMDecrypter() {\n+func ExampleNewGCM_decrypt() {\n \t// The key argument should be the AES key, either 16 or 32 bytes\n \t// to select AES-128 or AES-256.\n \tkey := []byte(\"AES256Key-32Characters1234567890\")"}, {"sha": "62085aac0fe58b68bd4095fd24b3bc92823369b1", "filename": "libgo/go/crypto/cipher/gcm.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -74,6 +74,10 @@ type gcm struct {\n \n // NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\n // with the standard nonce length.\n+//\n+// In general, the GHASH operation performed by this implementation of GCM is not constant-time.\n+// An exception is when the underlying Block was created by aes.NewCipher\n+// on systems with hardware support for AES. See the crypto/aes package documentation for details.\n func NewGCM(cipher Block) (AEAD, error) {\n \treturn NewGCMWithNonceSize(cipher, gcmStandardNonceSize)\n }\n@@ -135,6 +139,10 @@ func (g *gcm) Seal(dst, nonce, plaintext, data []byte) []byte {\n \tif len(nonce) != g.nonceSize {\n \t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n \t}\n+\tif uint64(len(plaintext)) > ((1<<32)-2)*uint64(g.cipher.BlockSize()) {\n+\t\tpanic(\"cipher: message too large for GCM\")\n+\t}\n+\n \tret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)\n \n \tvar counter, tagMask [gcmBlockSize]byte\n@@ -159,6 +167,10 @@ func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n \tif len(ciphertext) < gcmTagSize {\n \t\treturn nil, errOpen\n \t}\n+\tif uint64(len(ciphertext)) > ((1<<32)-2)*uint64(g.cipher.BlockSize())+gcmTagSize {\n+\t\treturn nil, errOpen\n+\t}\n+\n \ttag := ciphertext[len(ciphertext)-gcmTagSize:]\n \tciphertext = ciphertext[:len(ciphertext)-gcmTagSize]\n \n@@ -176,7 +188,7 @@ func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n \tif subtle.ConstantTimeCompare(expectedTag[:], tag) != 1 {\n \t\t// The AESNI code decrypts and authenticates concurrently, and\n \t\t// so overwrites dst in the event of a tag mismatch. That\n-\t\t// behaviour is mimicked here in order to be consistent across\n+\t\t// behavior is mimicked here in order to be consistent across\n \t\t// platforms.\n \t\tfor i := range out {\n \t\t\tout[i] = 0"}, {"sha": "6878b4cb42bdf96b1c52bf866a687b1652a4eb0f", "filename": "libgo/go/crypto/cipher/gcm_test.go", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -8,7 +8,11 @@ import (\n \t\"bytes\"\n \t\"crypto/aes\"\n \t\"crypto/cipher\"\n+\t\"crypto/rand\"\n \t\"encoding/hex\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"reflect\"\n \t\"testing\"\n )\n \n@@ -274,3 +278,157 @@ func TestTagFailureOverwrite(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestGCMCounterWrap(t *testing.T) {\n+\t// Test that the last 32-bits of the counter wrap correctly.\n+\ttests := []struct {\n+\t\tnonce, tag string\n+\t}{\n+\t\t{\"0fa72e25\", \"37e1948cdfff09fbde0c40ad99fee4a7\"},   // counter: 7eb59e4d961dad0dfdd75aaffffffff0\n+\t\t{\"afe05cc1\", \"438f3aa9fee5e54903b1927bca26bbdf\"},   // counter: 75d492a7e6e6bfc979ad3a8ffffffff4\n+\t\t{\"9ffecbef\", \"7b88ca424df9703e9e8611071ec7e16e\"},   // counter: c8bb108b0ecdc71747b9d57ffffffff5\n+\t\t{\"ffc3e5b3\", \"38d49c86e0abe853ac250e66da54c01a\"},   // counter: 706414d2de9b36ab3b900a9ffffffff6\n+\t\t{\"cfdd729d\", \"e08402eaac36a1a402e09b1bd56500e8\"},   // counter: cd0b96fe36b04e750584e56ffffffff7\n+\t\t{\"010ae3d486\", \"5405bb490b1f95d01e2ba735687154bc\"}, // counter: e36c18e69406c49722808104fffffff8\n+\t\t{\"01b1107a9d\", \"939a585f342e01e17844627492d44dbf\"}, // counter: e6d56eaf9127912b6d62c6dcffffffff\n+\t}\n+\tkey, err := aes.NewCipher(make([]byte, 16))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tplaintext := make([]byte, 16*17+1)\n+\tfor i, test := range tests {\n+\t\tnonce, _ := hex.DecodeString(test.nonce)\n+\t\twant, _ := hex.DecodeString(test.tag)\n+\t\taead, err := cipher.NewGCMWithNonceSize(key, len(nonce))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tgot := aead.Seal(nil, nonce, plaintext, nil)\n+\t\tif !bytes.Equal(got[len(plaintext):], want) {\n+\t\t\tt.Errorf(\"test[%v]: got: %x, want: %x\", i, got[len(plaintext):], want)\n+\t\t}\n+\t\t_, err = aead.Open(nil, nonce, got, nil)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"test[%v]: authentication failed\", i)\n+\t\t}\n+\t}\n+}\n+\n+var _ cipher.Block = (*wrapper)(nil)\n+\n+type wrapper struct {\n+\tblock cipher.Block\n+}\n+\n+func (w *wrapper) BlockSize() int          { return w.block.BlockSize() }\n+func (w *wrapper) Encrypt(dst, src []byte) { w.block.Encrypt(dst, src) }\n+func (w *wrapper) Decrypt(dst, src []byte) { w.block.Decrypt(dst, src) }\n+\n+// wrap wraps the Block interface so that it does not fulfill\n+// any optimizing interfaces such as gcmAble.\n+func wrap(b cipher.Block) cipher.Block {\n+\treturn &wrapper{b}\n+}\n+\n+func TestGCMAsm(t *testing.T) {\n+\t// Create a new pair of AEADs, one using the assembly implementation\n+\t// and one using the generic Go implementation.\n+\tnewAESGCM := func(key []byte) (asm, generic cipher.AEAD, err error) {\n+\t\tblock, err := aes.NewCipher(key[:])\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tasm, err = cipher.NewGCM(block)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tgeneric, err = cipher.NewGCM(wrap(block))\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\treturn asm, generic, nil\n+\t}\n+\n+\t// check for assembly implementation\n+\tvar key [16]byte\n+\tasm, generic, err := newAESGCM(key[:])\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif reflect.TypeOf(asm) == reflect.TypeOf(generic) {\n+\t\tt.Skipf(\"no assembly implementation of GCM\")\n+\t}\n+\n+\t// generate permutations\n+\ttype pair struct{ align, length int }\n+\tlengths := []int{0, 8192, 8193, 8208}\n+\tkeySizes := []int{16, 24, 32}\n+\talignments := []int{0, 1, 2, 3}\n+\tif testing.Short() {\n+\t\tkeySizes = []int{16}\n+\t\talignments = []int{1}\n+\t}\n+\tperms := make([]pair, 0)\n+\tfor _, l := range lengths {\n+\t\tfor _, a := range alignments {\n+\t\t\tif a != 0 && l == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tperms = append(perms, pair{align: a, length: l})\n+\t\t}\n+\t}\n+\n+\t// run test for all permutations\n+\ttest := func(ks int, pt, ad []byte) error {\n+\t\tkey := make([]byte, ks)\n+\t\tif _, err := io.ReadFull(rand.Reader, key); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tasm, generic, err := newAESGCM(key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := io.ReadFull(rand.Reader, pt); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := io.ReadFull(rand.Reader, ad); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tnonce := make([]byte, 12)\n+\t\tif _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\twant := generic.Seal(nil, nonce, pt, ad)\n+\t\tgot := asm.Seal(nil, nonce, pt, ad)\n+\t\tif !bytes.Equal(want, got) {\n+\t\t\treturn errors.New(\"incorrect Seal output\")\n+\t\t}\n+\t\tgot, err = asm.Open(nil, nonce, want, ad)\n+\t\tif err != nil {\n+\t\t\treturn errors.New(\"authentication failed\")\n+\t\t}\n+\t\tif !bytes.Equal(pt, got) {\n+\t\t\treturn errors.New(\"incorrect Open output\")\n+\t\t}\n+\t\treturn nil\n+\t}\n+\tfor _, a := range perms {\n+\t\tad := make([]byte, a.align+a.length)\n+\t\tad = ad[a.align:]\n+\t\tfor _, p := range perms {\n+\t\t\tpt := make([]byte, p.align+p.length)\n+\t\t\tpt = pt[p.align:]\n+\t\t\tfor _, ks := range keySizes {\n+\t\t\t\tif err := test(ks, pt, ad); err != nil {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t\tt.Errorf(\"\tkey size: %v\", ks)\n+\t\t\t\t\tt.Errorf(\"\tplaintext alignment: %v\", p.align)\n+\t\t\t\t\tt.Errorf(\"\tplaintext length: %v\", p.length)\n+\t\t\t\t\tt.Errorf(\"\tadditionalData alignment: %v\", a.align)\n+\t\t\t\t\tt.Fatalf(\"\tadditionalData length: %v\", a.length)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "bc0c3e34629d377e6d0ea125d3f7333ab79ad635", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -3,6 +3,8 @@\n // license that can be found in the LICENSE file.\n \n // Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n+//\n+// The DSA operations in this package are not implemented using constant-time algorithms.\n package dsa\n \n import (\n@@ -189,17 +191,21 @@ func fermatInverse(k, P *big.Int) *big.Int {\n // Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated\n // to the byte-length of the subgroup. This function does not perform that\n // truncation itself.\n+//\n+// Be aware that calling Sign with an attacker-controlled PrivateKey may\n+// require an arbitrary amount of CPU.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \t// FIPS 186-3, section 4.6\n \n \tn := priv.Q.BitLen()\n-\tif n&7 != 0 {\n+\tif priv.Q.Sign() <= 0 || priv.P.Sign() <= 0 || priv.G.Sign() <= 0 || priv.X.Sign() <= 0 || n&7 != 0 {\n \t\terr = ErrInvalidPublicKey\n \t\treturn\n \t}\n \tn >>= 3\n \n-\tfor {\n+\tvar attempts int\n+\tfor attempts = 10; attempts > 0; attempts-- {\n \t\tk := new(big.Int)\n \t\tbuf := make([]byte, n)\n \t\tfor {\n@@ -208,6 +214,10 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \t\t\t\treturn\n \t\t\t}\n \t\t\tk.SetBytes(buf)\n+\t\t\t// priv.Q must be >= 128 because the test above\n+\t\t\t// requires it to be > 0 and that\n+\t\t\t//    ceil(log_2(Q)) mod 8 = 0\n+\t\t\t// Thus this loop will quickly terminate.\n \t\t\tif k.Sign() > 0 && k.Cmp(priv.Q) < 0 {\n \t\t\t\tbreak\n \t\t\t}\n@@ -235,6 +245,12 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \t\t}\n \t}\n \n+\t// Only degenerate private keys will require more than a handful of\n+\t// attempts.\n+\tif attempts == 0 {\n+\t\treturn nil, nil, ErrInvalidPublicKey\n+\t}\n+\n \treturn\n }\n "}, {"sha": "8600059f0329fe26271a1d726e0923bcd9288ce5", "filename": "libgo/go/crypto/dsa/dsa_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -73,6 +73,14 @@ func TestParameterGeneration(t *testing.T) {\n \ttestParameterGeneration(t, L3072N256, 3072, 256)\n }\n \n+func fromHex(s string) *big.Int {\n+\tresult, ok := new(big.Int).SetString(s, 16)\n+\tif !ok {\n+\t\tpanic(s)\n+\t}\n+\treturn result\n+}\n+\n func TestSignAndVerify(t *testing.T) {\n \tvar priv PrivateKey\n \tpriv.P, _ = new(big.Int).SetString(\"A9B5B793FB4785793D246BAE77E8FF63CA52F442DA763C440259919FE1BC1D6065A9350637A04F75A2F039401D49F08E066C4D275A5A65DA5684BC563C14289D7AB8A67163BFBF79D85972619AD2CFF55AB0EE77A9002B0EF96293BDD0F42685EBB2C66C327079F6C98000FBCB79AACDE1BC6F9D5C7B1A97E3D9D54ED7951FEF\", 16)\n@@ -83,3 +91,33 @@ func TestSignAndVerify(t *testing.T) {\n \n \ttestSignAndVerify(t, 0, &priv)\n }\n+\n+func TestSigningWithDegenerateKeys(t *testing.T) {\n+\t// Signing with degenerate private keys should not cause an infinite\n+\t// loop.\n+\tbadKeys := []struct {\n+\t\tp, q, g, y, x string\n+\t}{\n+\t\t{\"00\", \"01\", \"00\", \"00\", \"00\"},\n+\t\t{\"01\", \"ff\", \"00\", \"00\", \"00\"},\n+\t}\n+\n+\tfor i, test := range badKeys {\n+\t\tpriv := PrivateKey{\n+\t\t\tPublicKey: PublicKey{\n+\t\t\t\tParameters: Parameters{\n+\t\t\t\t\tP: fromHex(test.p),\n+\t\t\t\t\tQ: fromHex(test.q),\n+\t\t\t\t\tG: fromHex(test.g),\n+\t\t\t\t},\n+\t\t\t\tY: fromHex(test.y),\n+\t\t\t},\n+\t\t\tX: fromHex(test.x),\n+\t\t}\n+\n+\t\thashed := []byte(\"testing\")\n+\t\tif _, _, err := Sign(rand.Reader, &priv, hashed); err == nil {\n+\t\t\tt.Errorf(\"#%d: unexpected success\", i)\n+\t\t}\n+\t}\n+}"}, {"sha": "02848fd5954f81826ad1b8ba2700481fb26268e6", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -149,7 +149,7 @@ var errZeroParam = errors.New(\"zero parameter\")\n // returns the signature as a pair of integers. The security of the private key\n // depends on the entropy of rand.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n-\t// Get max(log2(q) / 2, 256) bits of entropy from rand.\n+\t// Get min(log2(q) / 2, 256) bits of entropy from rand.\n \tentropylen := (priv.Curve.Params().BitSize + 7) / 16\n \tif entropylen > 32 {\n \t\tentropylen = 32"}, {"sha": "9546f67c68b4e3e408a0d10831db476c5870f2f5", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -54,6 +54,18 @@ func BenchmarkSignP256(b *testing.B) {\n \t}\n }\n \n+func BenchmarkSignP384(b *testing.B) {\n+\tb.ResetTimer()\n+\tp384 := elliptic.P384()\n+\thashed := []byte(\"testing\")\n+\tpriv, _ := GenerateKey(p384, rand.Reader)\n+\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_, _, _ = Sign(rand.Reader, priv, hashed)\n+\t}\n+}\n+\n func BenchmarkVerifyP256(b *testing.B) {\n \tb.ResetTimer()\n \tp256 := elliptic.P256()"}, {"sha": "d3527243e78a4f5fc755a91ed556b5f266eab101", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -367,18 +367,24 @@ func initP521() {\n }\n \n // P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n+//\n+// The cryptographic operations are implemented using constant-time algorithms.\n func P256() Curve {\n \tinitonce.Do(initAll)\n \treturn p256\n }\n \n // P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n+//\n+// The cryptographic operations do not use constant-time algorithms.\n func P384() Curve {\n \tinitonce.Do(initAll)\n \treturn p384\n }\n \n // P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n+//\n+// The cryptographic operations do not use constant-time algorithms.\n func P521() Curve {\n \tinitonce.Do(initAll)\n \treturn p521"}, {"sha": "902c414383753cc4332c461228fb373682dc5ca2", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -28,7 +28,7 @@ func TestOffCurve(t *testing.T) {\n \tb := Marshal(p224, x, y)\n \tx1, y1 := Unmarshal(p224, b)\n \tif x1 != nil || y1 != nil {\n-\t\tt.Errorf(\"FAIL: unmarshalling a point not on the curve succeeded\")\n+\t\tt.Errorf(\"FAIL: unmarshaling a point not on the curve succeeded\")\n \t}\n }\n "}, {"sha": "22d0e2429cdfb292106804d7b23b24eb3b5087bb", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -35,7 +35,9 @@ func initP224() {\n \tp224FromBig(&p224.b, p224.B)\n }\n \n-// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2)\n+// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n+//\n+// The cryptographic operations are implemented using constant-time algorithms.\n func P224() Curve {\n \tinitonce.Do(initAll)\n \treturn p224"}, {"sha": "a0933dc6fb1cfa757e0fa438b1a14a66bbe7b870", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -17,23 +17,27 @@ type p256Curve struct {\n }\n \n var (\n-\tp256 p256Curve\n+\tp256Params *CurveParams\n+\n \t// RInverse contains 1/R mod p - the inverse of the Montgomery constant\n \t// (2**257).\n \tp256RInverse *big.Int\n )\n \n func initP256() {\n \t// See FIPS 186-3, section D.2.3\n-\tp256.CurveParams = &CurveParams{Name: \"P-256\"}\n-\tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n-\tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n-\tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n-\tp256.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n-\tp256.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n-\tp256.BitSize = 256\n+\tp256Params = &CurveParams{Name: \"P-256\"}\n+\tp256Params.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n+\tp256Params.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n+\tp256Params.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n+\tp256Params.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n+\tp256Params.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n+\tp256Params.BitSize = 256\n \n \tp256RInverse, _ = new(big.Int).SetString(\"7fffffff00000001fffffffe8000000100000000ffffffff0000000180000000\", 16)\n+\n+\t// Arch-specific initialization, i.e. let a platform dynamically pick a P256 implementation\n+\tinitP256Arch()\n }\n \n func (curve p256Curve) Params() *CurveParams {\n@@ -47,8 +51,8 @@ func p256GetScalar(out *[32]byte, in []byte) {\n \tn := new(big.Int).SetBytes(in)\n \tvar scalarBytes []byte\n \n-\tif n.Cmp(p256.N) >= 0 {\n-\t\tn.Mod(n, p256.N)\n+\tif n.Cmp(p256Params.N) >= 0 {\n+\t\tn.Mod(n, p256Params.N)\n \t\tscalarBytes = n.Bytes()\n \t} else {\n \t\tscalarBytes = in\n@@ -1143,7 +1147,7 @@ func p256ScalarMult(xOut, yOut, zOut, x, y *[p256Limbs]uint32, scalar *[32]uint8\n // p256FromBig sets out = R*in.\n func p256FromBig(out *[p256Limbs]uint32, in *big.Int) {\n \ttmp := new(big.Int).Lsh(in, 257)\n-\ttmp.Mod(tmp, p256.P)\n+\ttmp.Mod(tmp, p256Params.P)\n \n \tfor i := 0; i < p256Limbs; i++ {\n \t\tif bits := tmp.Bits(); len(bits) > 0 {\n@@ -1183,6 +1187,6 @@ func p256ToBig(in *[p256Limbs]uint32) *big.Int {\n \t}\n \n \tresult.Mul(result, p256RInverse)\n-\tresult.Mod(result, p256.P)\n+\tresult.Mod(result, p256Params.P)\n \treturn result\n }"}, {"sha": "49445c3999f83c9cb99640e2fbf9da374e800e6d", "filename": "libgo/go/crypto/elliptic/p256_generic.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_generic.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// -build !amd64,!s390x\n+\n+package elliptic\n+\n+var (\n+\tp256 p256Curve\n+)\n+\n+func initP256Arch() {\n+\t// Use pure Go implementation.\n+\tp256 = p256Curve{p256Params}\n+}"}, {"sha": "a824454d7da544a381472042d51d1a32e28bbeaa", "filename": "libgo/go/crypto/elliptic/p256_s390x.go", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,513 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// -build s390x\n+\n+package elliptic\n+\n+import (\n+\t\"math/big\"\n+)\n+\n+type p256CurveFast struct {\n+\t*CurveParams\n+}\n+\n+type p256Point struct {\n+\tx [32]byte\n+\ty [32]byte\n+\tz [32]byte\n+}\n+\n+var (\n+\tp256        Curve\n+\tp256PreFast *[37][64]p256Point\n+)\n+\n+// hasVectorFacility reports whether the machine has the z/Architecture\n+// vector facility installed and enabled.\n+func hasVectorFacility() bool\n+\n+var hasVX = hasVectorFacility()\n+\n+func initP256Arch() {\n+\tif hasVX {\n+\t\tp256 = p256CurveFast{p256Params}\n+\t\tinitTable()\n+\t\treturn\n+\t}\n+\n+\t// No vector support, use pure Go implementation.\n+\tp256 = p256Curve{p256Params}\n+\treturn\n+}\n+\n+func (curve p256CurveFast) Params() *CurveParams {\n+\treturn curve.CurveParams\n+}\n+\n+// Functions implemented in p256_asm_s390x.s\n+// Montgomery multiplication modulo P256\n+func p256MulAsm(res, in1, in2 []byte)\n+\n+// Montgomery square modulo P256\n+func p256Sqr(res, in []byte) {\n+\tp256MulAsm(res, in, in)\n+}\n+\n+// Montgomery multiplication by 1\n+func p256FromMont(res, in []byte)\n+\n+// iff cond == 1  val <- -val\n+func p256NegCond(val *p256Point, cond int)\n+\n+// if cond == 0 res <- b; else res <- a\n+func p256MovCond(res, a, b *p256Point, cond int)\n+\n+// Constant time table access\n+func p256Select(point *p256Point, table []p256Point, idx int)\n+func p256SelectBase(point *p256Point, table []p256Point, idx int)\n+\n+// Montgomery multiplication modulo Ord(G)\n+func p256OrdMul(res, in1, in2 []byte)\n+\n+// Montgomery square modulo Ord(G), repeated n times\n+func p256OrdSqr(res, in []byte, n int) {\n+\tcopy(res, in)\n+\tfor i := 0; i < n; i += 1 {\n+\t\tp256OrdMul(res, res, res)\n+\t}\n+}\n+\n+// Point add with P2 being affine point\n+// If sign == 1 -> P2 = -P2\n+// If sel == 0 -> P3 = P1\n+// if zero == 0 -> P3 = P2\n+func p256PointAddAffineAsm(P3, P1, P2 *p256Point, sign, sel, zero int)\n+\n+// Point add\n+func p256PointAddAsm(P3, P1, P2 *p256Point)\n+func p256PointDoubleAsm(P3, P1 *p256Point)\n+\n+func (curve p256CurveFast) Inverse(k *big.Int) *big.Int {\n+\tif k.Cmp(p256Params.N) >= 0 {\n+\t\t// This should never happen.\n+\t\treducedK := new(big.Int).Mod(k, p256Params.N)\n+\t\tk = reducedK\n+\t}\n+\n+\t// table will store precomputed powers of x. The 32 bytes at index\n+\t// i store x^(i+1).\n+\tvar table [15][32]byte\n+\n+\tx := fromBig(k)\n+\t// This code operates in the Montgomery domain where R = 2^256 mod n\n+\t// and n is the order of the scalar field. (See initP256 for the\n+\t// value.) Elements in the Montgomery domain take the form a\u00d7R and\n+\t// multiplication of x and y in the calculates (x \u00d7 y \u00d7 R^-1) mod n. RR\n+\t// is R\u00d7R mod n thus the Montgomery multiplication x and RR gives x\u00d7R,\n+\t// i.e. converts x into the Montgomery domain. Stored in BigEndian form\n+\tRR := []byte{0x66, 0xe1, 0x2d, 0x94, 0xf3, 0xd9, 0x56, 0x20, 0x28, 0x45, 0xb2, 0x39, 0x2b, 0x6b, 0xec, 0x59,\n+\t\t0x46, 0x99, 0x79, 0x9c, 0x49, 0xbd, 0x6f, 0xa6, 0x83, 0x24, 0x4c, 0x95, 0xbe, 0x79, 0xee, 0xa2}\n+\n+\tp256OrdMul(table[0][:], x, RR)\n+\n+\t// Prepare the table, no need in constant time access, because the\n+\t// power is not a secret. (Entry 0 is never used.)\n+\tfor i := 2; i < 16; i += 2 {\n+\t\tp256OrdSqr(table[i-1][:], table[(i/2)-1][:], 1)\n+\t\tp256OrdMul(table[i][:], table[i-1][:], table[0][:])\n+\t}\n+\n+\tcopy(x, table[14][:]) // f\n+\n+\tp256OrdSqr(x[0:32], x[0:32], 4)\n+\tp256OrdMul(x[0:32], x[0:32], table[14][:]) // ff\n+\tt := make([]byte, 32)\n+\tcopy(t, x)\n+\n+\tp256OrdSqr(x, x, 8)\n+\tp256OrdMul(x, x, t) // ffff\n+\tcopy(t, x)\n+\n+\tp256OrdSqr(x, x, 16)\n+\tp256OrdMul(x, x, t) // ffffffff\n+\tcopy(t, x)\n+\n+\tp256OrdSqr(x, x, 64) // ffffffff0000000000000000\n+\tp256OrdMul(x, x, t)  // ffffffff00000000ffffffff\n+\tp256OrdSqr(x, x, 32) // ffffffff00000000ffffffff00000000\n+\tp256OrdMul(x, x, t)  // ffffffff00000000ffffffffffffffff\n+\n+\t// Remaining 32 windows\n+\texpLo := [32]byte{0xb, 0xc, 0xe, 0x6, 0xf, 0xa, 0xa, 0xd, 0xa, 0x7, 0x1, 0x7, 0x9, 0xe, 0x8, 0x4,\n+\t\t0xf, 0x3, 0xb, 0x9, 0xc, 0xa, 0xc, 0x2, 0xf, 0xc, 0x6, 0x3, 0x2, 0x5, 0x4, 0xf}\n+\tfor i := 0; i < 32; i++ {\n+\t\tp256OrdSqr(x, x, 4)\n+\t\tp256OrdMul(x, x, table[expLo[i]-1][:])\n+\t}\n+\n+\t// Multiplying by one in the Montgomery domain converts a Montgomery\n+\t// value out of the domain.\n+\tone := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n+\tp256OrdMul(x, x, one)\n+\n+\treturn new(big.Int).SetBytes(x)\n+}\n+\n+// fromBig converts a *big.Int into a format used by this code.\n+func fromBig(big *big.Int) []byte {\n+\t// This could be done a lot more efficiently...\n+\tres := big.Bytes()\n+\tif 32 == len(res) {\n+\t\treturn res\n+\t}\n+\tt := make([]byte, 32)\n+\toffset := 32 - len(res)\n+\tfor i := len(res) - 1; i >= 0; i-- {\n+\t\tt[i+offset] = res[i]\n+\t}\n+\treturn t\n+}\n+\n+// p256GetMultiplier makes sure byte array will have 32 byte elements, If the scalar\n+// is equal or greater than the order of the group, it's reduced modulo that order.\n+func p256GetMultiplier(in []byte) []byte {\n+\tn := new(big.Int).SetBytes(in)\n+\n+\tif n.Cmp(p256Params.N) >= 0 {\n+\t\tn.Mod(n, p256Params.N)\n+\t}\n+\treturn fromBig(n)\n+}\n+\n+// p256MulAsm operates in a Montgomery domain with R = 2^256 mod p, where p is the\n+// underlying field of the curve. (See initP256 for the value.) Thus rr here is\n+// R\u00d7R mod p. See comment in Inverse about how this is used.\n+var rr = []byte{0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+\t0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n+\n+// (This is one, in the Montgomery domain.)\n+var one = []byte{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}\n+\n+func maybeReduceModP(in *big.Int) *big.Int {\n+\tif in.Cmp(p256Params.P) < 0 {\n+\t\treturn in\n+\t}\n+\treturn new(big.Int).Mod(in, p256Params.P)\n+}\n+\n+func (curve p256CurveFast) CombinedMult(bigX, bigY *big.Int, baseScalar, scalar []byte) (x, y *big.Int) {\n+\tvar r1, r2 p256Point\n+\tr1.p256BaseMult(p256GetMultiplier(baseScalar))\n+\n+\tcopy(r2.x[:], fromBig(maybeReduceModP(bigX)))\n+\tcopy(r2.y[:], fromBig(maybeReduceModP(bigY)))\n+\tcopy(r2.z[:], one)\n+\tp256MulAsm(r2.x[:], r2.x[:], rr[:])\n+\tp256MulAsm(r2.y[:], r2.y[:], rr[:])\n+\n+\tr2.p256ScalarMult(p256GetMultiplier(scalar))\n+\tp256PointAddAsm(&r1, &r1, &r2)\n+\treturn r1.p256PointToAffine()\n+}\n+\n+func (curve p256CurveFast) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n+\tvar r p256Point\n+\tr.p256BaseMult(p256GetMultiplier(scalar))\n+\treturn r.p256PointToAffine()\n+}\n+\n+func (curve p256CurveFast) ScalarMult(bigX, bigY *big.Int, scalar []byte) (x, y *big.Int) {\n+\tvar r p256Point\n+\tcopy(r.x[:], fromBig(maybeReduceModP(bigX)))\n+\tcopy(r.y[:], fromBig(maybeReduceModP(bigY)))\n+\tcopy(r.z[:], one)\n+\tp256MulAsm(r.x[:], r.x[:], rr[:])\n+\tp256MulAsm(r.y[:], r.y[:], rr[:])\n+\tr.p256ScalarMult(p256GetMultiplier(scalar))\n+\treturn r.p256PointToAffine()\n+}\n+\n+func (p *p256Point) p256PointToAffine() (x, y *big.Int) {\n+\tzInv := make([]byte, 32)\n+\tzInvSq := make([]byte, 32)\n+\n+\tp256Inverse(zInv, p.z[:])\n+\tp256Sqr(zInvSq, zInv)\n+\tp256MulAsm(zInv, zInv, zInvSq)\n+\n+\tp256MulAsm(zInvSq, p.x[:], zInvSq)\n+\tp256MulAsm(zInv, p.y[:], zInv)\n+\n+\tp256FromMont(zInvSq, zInvSq)\n+\tp256FromMont(zInv, zInv)\n+\n+\treturn new(big.Int).SetBytes(zInvSq), new(big.Int).SetBytes(zInv)\n+}\n+\n+// p256Inverse sets out to in^-1 mod p.\n+func p256Inverse(out, in []byte) {\n+\tvar stack [6 * 32]byte\n+\tp2 := stack[32*0 : 32*0+32]\n+\tp4 := stack[32*1 : 32*1+32]\n+\tp8 := stack[32*2 : 32*2+32]\n+\tp16 := stack[32*3 : 32*3+32]\n+\tp32 := stack[32*4 : 32*4+32]\n+\n+\tp256Sqr(out, in)\n+\tp256MulAsm(p2, out, in) // 3*p\n+\n+\tp256Sqr(out, p2)\n+\tp256Sqr(out, out)\n+\tp256MulAsm(p4, out, p2) // f*p\n+\n+\tp256Sqr(out, p4)\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256MulAsm(p8, out, p4) // ff*p\n+\n+\tp256Sqr(out, p8)\n+\n+\tfor i := 0; i < 7; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(p16, out, p8) // ffff*p\n+\n+\tp256Sqr(out, p16)\n+\tfor i := 0; i < 15; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(p32, out, p16) // ffffffff*p\n+\n+\tp256Sqr(out, p32)\n+\n+\tfor i := 0; i < 31; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(out, out, in)\n+\n+\tfor i := 0; i < 32*4; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(out, out, p32)\n+\n+\tfor i := 0; i < 32; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(out, out, p32)\n+\n+\tfor i := 0; i < 16; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(out, out, p16)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tp256Sqr(out, out)\n+\t}\n+\tp256MulAsm(out, out, p8)\n+\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256MulAsm(out, out, p4)\n+\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256MulAsm(out, out, p2)\n+\n+\tp256Sqr(out, out)\n+\tp256Sqr(out, out)\n+\tp256MulAsm(out, out, in)\n+}\n+\n+func boothW5(in uint) (int, int) {\n+\tvar s uint = ^((in >> 5) - 1)\n+\tvar d uint = (1 << 6) - in - 1\n+\td = (d & s) | (in & (^s))\n+\td = (d >> 1) + (d & 1)\n+\treturn int(d), int(s & 1)\n+}\n+\n+func boothW7(in uint) (int, int) {\n+\tvar s uint = ^((in >> 7) - 1)\n+\tvar d uint = (1 << 8) - in - 1\n+\td = (d & s) | (in & (^s))\n+\td = (d >> 1) + (d & 1)\n+\treturn int(d), int(s & 1)\n+}\n+\n+func initTable() {\n+\tp256PreFast = new([37][64]p256Point) //z coordinate not used\n+\tbasePoint := p256Point{\n+\t\tx: [32]byte{0x18, 0x90, 0x5f, 0x76, 0xa5, 0x37, 0x55, 0xc6, 0x79, 0xfb, 0x73, 0x2b, 0x77, 0x62, 0x25, 0x10,\n+\t\t\t0x75, 0xba, 0x95, 0xfc, 0x5f, 0xed, 0xb6, 0x01, 0x79, 0xe7, 0x30, 0xd4, 0x18, 0xa9, 0x14, 0x3c}, //(p256.x*2^256)%p\n+\t\ty: [32]byte{0x85, 0x71, 0xff, 0x18, 0x25, 0x88, 0x5d, 0x85, 0xd2, 0xe8, 0x86, 0x88, 0xdd, 0x21, 0xf3, 0x25,\n+\t\t\t0x8b, 0x4a, 0xb8, 0xe4, 0xba, 0x19, 0xe4, 0x5c, 0xdd, 0xf2, 0x53, 0x57, 0xce, 0x95, 0x56, 0x0a}, //(p256.y*2^256)%p\n+\t\tz: [32]byte{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}, //(p256.z*2^256)%p\n+\t}\n+\n+\tt1 := new(p256Point)\n+\tt2 := new(p256Point)\n+\t*t2 = basePoint\n+\n+\tzInv := make([]byte, 32)\n+\tzInvSq := make([]byte, 32)\n+\tfor j := 0; j < 64; j++ {\n+\t\t*t1 = *t2\n+\t\tfor i := 0; i < 37; i++ {\n+\t\t\t// The window size is 7 so we need to double 7 times.\n+\t\t\tif i != 0 {\n+\t\t\t\tfor k := 0; k < 7; k++ {\n+\t\t\t\t\tp256PointDoubleAsm(t1, t1)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// Convert the point to affine form. (Its values are\n+\t\t\t// still in Montgomery form however.)\n+\t\t\tp256Inverse(zInv, t1.z[:])\n+\t\t\tp256Sqr(zInvSq, zInv)\n+\t\t\tp256MulAsm(zInv, zInv, zInvSq)\n+\n+\t\t\tp256MulAsm(t1.x[:], t1.x[:], zInvSq)\n+\t\t\tp256MulAsm(t1.y[:], t1.y[:], zInv)\n+\n+\t\t\tcopy(t1.z[:], basePoint.z[:])\n+\t\t\t// Update the table entry\n+\t\t\tcopy(p256PreFast[i][j].x[:], t1.x[:])\n+\t\t\tcopy(p256PreFast[i][j].y[:], t1.y[:])\n+\t\t}\n+\t\tif j == 0 {\n+\t\t\tp256PointDoubleAsm(t2, &basePoint)\n+\t\t} else {\n+\t\t\tp256PointAddAsm(t2, t2, &basePoint)\n+\t\t}\n+\t}\n+}\n+\n+func (p *p256Point) p256BaseMult(scalar []byte) {\n+\twvalue := (uint(scalar[31]) << 1) & 0xff\n+\tsel, sign := boothW7(uint(wvalue))\n+\tp256SelectBase(p, p256PreFast[0][:], sel)\n+\tp256NegCond(p, sign)\n+\n+\tcopy(p.z[:], one[:])\n+\tvar t0 p256Point\n+\n+\tcopy(t0.z[:], one[:])\n+\n+\tindex := uint(6)\n+\tzero := sel\n+\n+\tfor i := 1; i < 37; i++ {\n+\t\tif index < 247 {\n+\t\t\twvalue = ((uint(scalar[31-index/8]) >> (index % 8)) + (uint(scalar[31-index/8-1]) << (8 - (index % 8)))) & 0xff\n+\t\t} else {\n+\t\t\twvalue = (uint(scalar[31-index/8]) >> (index % 8)) & 0xff\n+\t\t}\n+\t\tindex += 7\n+\t\tsel, sign = boothW7(uint(wvalue))\n+\t\tp256SelectBase(&t0, p256PreFast[i][:], sel)\n+\t\tp256PointAddAffineAsm(p, p, &t0, sign, sel, zero)\n+\t\tzero |= sel\n+\t}\n+}\n+\n+func (p *p256Point) p256ScalarMult(scalar []byte) {\n+\t// precomp is a table of precomputed points that stores powers of p\n+\t// from p^1 to p^16.\n+\tvar precomp [16]p256Point\n+\tvar t0, t1, t2, t3 p256Point\n+\n+\t// Prepare the table\n+\t*&precomp[0] = *p\n+\n+\tp256PointDoubleAsm(&t0, p)\n+\tp256PointDoubleAsm(&t1, &t0)\n+\tp256PointDoubleAsm(&t2, &t1)\n+\tp256PointDoubleAsm(&t3, &t2)\n+\t*&precomp[1] = t0  // 2\n+\t*&precomp[3] = t1  // 4\n+\t*&precomp[7] = t2  // 8\n+\t*&precomp[15] = t3 // 16\n+\n+\tp256PointAddAsm(&t0, &t0, p)\n+\tp256PointAddAsm(&t1, &t1, p)\n+\tp256PointAddAsm(&t2, &t2, p)\n+\t*&precomp[2] = t0 // 3\n+\t*&precomp[4] = t1 // 5\n+\t*&precomp[8] = t2 // 9\n+\n+\tp256PointDoubleAsm(&t0, &t0)\n+\tp256PointDoubleAsm(&t1, &t1)\n+\t*&precomp[5] = t0 // 6\n+\t*&precomp[9] = t1 // 10\n+\n+\tp256PointAddAsm(&t2, &t0, p)\n+\tp256PointAddAsm(&t1, &t1, p)\n+\t*&precomp[6] = t2  // 7\n+\t*&precomp[10] = t1 // 11\n+\n+\tp256PointDoubleAsm(&t0, &t0)\n+\tp256PointDoubleAsm(&t2, &t2)\n+\t*&precomp[11] = t0 // 12\n+\t*&precomp[13] = t2 // 14\n+\n+\tp256PointAddAsm(&t0, &t0, p)\n+\tp256PointAddAsm(&t2, &t2, p)\n+\t*&precomp[12] = t0 // 13\n+\t*&precomp[14] = t2 // 15\n+\n+\t// Start scanning the window from top bit\n+\tindex := uint(254)\n+\tvar sel, sign int\n+\n+\twvalue := (uint(scalar[31-index/8]) >> (index % 8)) & 0x3f\n+\tsel, _ = boothW5(uint(wvalue))\n+\tp256Select(p, precomp[:], sel)\n+\tzero := sel\n+\n+\tfor index > 4 {\n+\t\tindex -= 5\n+\t\tp256PointDoubleAsm(p, p)\n+\t\tp256PointDoubleAsm(p, p)\n+\t\tp256PointDoubleAsm(p, p)\n+\t\tp256PointDoubleAsm(p, p)\n+\t\tp256PointDoubleAsm(p, p)\n+\n+\t\tif index < 247 {\n+\t\t\twvalue = ((uint(scalar[31-index/8]) >> (index % 8)) + (uint(scalar[31-index/8-1]) << (8 - (index % 8)))) & 0x3f\n+\t\t} else {\n+\t\t\twvalue = (uint(scalar[31-index/8]) >> (index % 8)) & 0x3f\n+\t\t}\n+\n+\t\tsel, sign = boothW5(uint(wvalue))\n+\n+\t\tp256Select(&t0, precomp[:], sel)\n+\t\tp256NegCond(&t0, sign)\n+\t\tp256PointAddAsm(&t1, p, &t0)\n+\t\tp256MovCond(&t1, &t1, p, sel)\n+\t\tp256MovCond(p, &t1, &t0, zero)\n+\t\tzero |= sel\n+\t}\n+\n+\tp256PointDoubleAsm(p, p)\n+\tp256PointDoubleAsm(p, p)\n+\tp256PointDoubleAsm(p, p)\n+\tp256PointDoubleAsm(p, p)\n+\tp256PointDoubleAsm(p, p)\n+\n+\twvalue = (uint(scalar[31]) << 1) & 0x3f\n+\tsel, sign = boothW5(uint(wvalue))\n+\n+\tp256Select(&t0, precomp[:], sel)\n+\tp256NegCond(&t0, sign)\n+\tp256PointAddAsm(&t1, p, &t0)\n+\tp256MovCond(&t1, &t1, p, sel)\n+\tp256MovCond(p, &t1, &t0, zero)\n+}"}, {"sha": "9ef9c448ee20b1d8fac437e385748e1c8e4b9568", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -94,5 +94,5 @@ func Equal(mac1, mac2 []byte) bool {\n \t// We don't have to be constant time if the lengths of the MACs are\n \t// different as that suggests that a completely different hash function\n \t// was used.\n-\treturn len(mac1) == len(mac2) && subtle.ConstantTimeCompare(mac1, mac2) == 1\n+\treturn subtle.ConstantTimeCompare(mac1, mac2) == 1\n }"}, {"sha": "be0d490a221786f1bef3c0c6ed19787300b44203", "filename": "libgo/go/crypto/internal/cipherhw/cipherhw_amd64.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_amd64.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build amd64,!gccgo,!appengine\n+\n+package cipherhw\n+\n+// defined in asm_amd64.s\n+func hasAESNI() bool\n+\n+// AESGCMSupport returns true if the Go standard library supports AES-GCM in\n+// hardware.\n+func AESGCMSupport() bool {\n+\treturn hasAESNI()\n+}"}, {"sha": "9cd76795985bef0bc8ccd7e68a21920f40f9b7ad", "filename": "libgo/go/crypto/internal/cipherhw/cipherhw_s390x.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fcipherhw_s390x.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build s390x,!gccgo,!appengine\n+\n+package cipherhw\n+\n+// hasHWSupport reports whether the AES-128, AES-192 and AES-256 cipher message\n+// (KM) function codes are supported. Note that this function is expensive.\n+// defined in asm_s390x.s\n+func hasHWSupport() bool\n+\n+var hwSupport = hasHWSupport()\n+\n+func AESGCMSupport() bool {\n+\treturn hwSupport\n+}"}, {"sha": "a75fcf64962a1ac6483f4d1039b231e514ba5b95", "filename": "libgo/go/crypto/internal/cipherhw/doc.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fdoc.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cipherhw exposes common functions for detecting whether hardware\n+// support for certain ciphers and authenticators is present.\n+package cipherhw"}, {"sha": "64d90d3b41eaa31753694f290596d30bcb8b28ac", "filename": "libgo/go/crypto/internal/cipherhw/generic.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fgeneric.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fgeneric.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Finternal%2Fcipherhw%2Fgeneric.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !amd64,!s390x gccgo appengine\n+\n+package cipherhw\n+\n+func AESGCMSupport() bool {\n+\treturn false\n+}"}, {"sha": "48a2c3fc0cb73bc2013cc575bde087e1cf01eea0", "filename": "libgo/go/crypto/rand/util_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7,7 +7,9 @@ package rand_test\n import (\n \t\"crypto/rand\"\n \t\"math/big\"\n+\tmathrand \"math/rand\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // https://golang.org/issue/6849.\n@@ -63,3 +65,10 @@ func TestIntNegativeMaxPanics(t *testing.T) {\n \tb := new(big.Int).SetInt64(int64(-1))\n \ttestIntPanics(t, b)\n }\n+\n+func BenchmarkPrime(b *testing.B) {\n+\tr := mathrand.New(mathrand.NewSource(time.Now().UnixNano()))\n+\tfor i := 0; i < b.N; i++ {\n+\t\trand.Prime(r, 1024)\n+\t}\n+}"}, {"sha": "1de4fcb473eab9dda4bc88b0c2fe0a13dcb27662", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -18,6 +18,8 @@\n // with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\n // over the public-key primitive, the PrivateKey struct implements the\n // Decrypter and Signer interfaces from the crypto package.\n+//\n+// The RSA operations in this package are not implemented using constant-time algorithms.\n package rsa\n \n import (\n@@ -27,6 +29,7 @@ import (\n \t\"errors\"\n \t\"hash\"\n \t\"io\"\n+\t\"math\"\n \t\"math/big\"\n )\n \n@@ -214,6 +217,21 @@ func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey\n \t\treturn nil, errors.New(\"crypto/rsa: GenerateMultiPrimeKey: nprimes must be >= 2\")\n \t}\n \n+\tif bits < 64 {\n+\t\tprimeLimit := float64(uint64(1) << uint(bits/nprimes))\n+\t\t// pi approximates the number of primes less than primeLimit\n+\t\tpi := primeLimit / (math.Log(primeLimit) - 1)\n+\t\t// Generated primes start with 11 (in binary) so we can only\n+\t\t// use a quarter of them.\n+\t\tpi /= 4\n+\t\t// Use a factor of two to ensure that key generation terminates\n+\t\t// in a reasonable amount of time.\n+\t\tpi /= 2\n+\t\tif pi <= float64(nprimes) {\n+\t\t\treturn nil, errors.New(\"crypto/rsa: too few primes of given length to generate an RSA key\")\n+\t\t}\n+\t}\n+\n \tprimes := make([]*big.Int, nprimes)\n \n NextSetOfPrimes:\n@@ -268,9 +286,8 @@ NextSetOfPrimes:\n \n \t\tg := new(big.Int)\n \t\tpriv.D = new(big.Int)\n-\t\ty := new(big.Int)\n \t\te := big.NewInt(int64(priv.E))\n-\t\tg.GCD(priv.D, y, e, totient)\n+\t\tg.GCD(priv.D, nil, e, totient)\n \n \t\tif g.Cmp(bigOne) == 0 {\n \t\t\tif priv.D.Sign() < 0 {\n@@ -347,8 +364,8 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n // values could be used to ensure that a ciphertext for one purpose cannot be\n // used for another by an attacker. If not required it can be empty.\n //\n-// The message must be no longer than the length of the public modulus less\n-// twice the hash length plus 2.\n+// The message must be no longer than the length of the public modulus minus\n+// twice the hash length, minus a further 2.\n func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error) {\n \tif err := checkPub(pub); err != nil {\n \t\treturn nil, err"}, {"sha": "84b167455f02f64ddc5ad5efa7df0b5d65954661", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -73,6 +73,17 @@ func TestNPrimeKeyGeneration(t *testing.T) {\n \t}\n }\n \n+func TestImpossibleKeyGeneration(t *testing.T) {\n+\t// This test ensures that trying to generate toy RSA keys doesn't enter\n+\t// an infinite loop.\n+\tfor i := 0; i < 32; i++ {\n+\t\tGenerateKey(rand.Reader, i)\n+\t\tGenerateMultiPrimeKey(rand.Reader, 3, i)\n+\t\tGenerateMultiPrimeKey(rand.Reader, 4, i)\n+\t\tGenerateMultiPrimeKey(rand.Reader, 5, i)\n+\t}\n+}\n+\n func TestGnuTLSKey(t *testing.T) {\n \t// This is a key generated by `certtool --generate-privkey --bits 128`.\n \t// It's such that de \u2262 1 mod \u03c6(n), but is congruent mod the order of"}, {"sha": "fbb2f946132fd3cf0ed2f5810cb2797b8aae72ef", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -90,7 +90,7 @@ func (d0 *digest) Sum(in []byte) []byte {\n \n func (d *digest) checkSum() [Size]byte {\n \tlen := d.len\n-\t// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.\n+\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tvar tmp [64]byte\n \ttmp[0] = 0x80\n \tif len%64 < 56 {\n@@ -121,6 +121,74 @@ func (d *digest) checkSum() [Size]byte {\n \treturn digest\n }\n \n+// ConstantTimeSum computes the same result of Sum() but in constant time\n+func (d0 *digest) ConstantTimeSum(in []byte) []byte {\n+\td := *d0\n+\thash := d.constSum()\n+\treturn append(in, hash[:]...)\n+}\n+\n+func (d *digest) constSum() [Size]byte {\n+\tvar length [8]byte\n+\tl := d.len << 3\n+\tfor i := uint(0); i < 8; i++ {\n+\t\tlength[i] = byte(l >> (56 - 8*i))\n+\t}\n+\n+\tnx := byte(d.nx)\n+\tt := nx - 56                 // if nx < 56 then the MSB of t is one\n+\tmask1b := byte(int8(t) >> 7) // mask1b is 0xFF iff one block is enough\n+\n+\tseparator := byte(0x80) // gets reset to 0x00 once used\n+\tfor i := byte(0); i < chunk; i++ {\n+\t\tmask := byte(int8(i-nx) >> 7) // 0x00 after the end of data\n+\n+\t\t// if we reached the end of the data, replace with 0x80 or 0x00\n+\t\td.x[i] = (^mask & separator) | (mask & d.x[i])\n+\n+\t\t// zero the separator once used\n+\t\tseparator &= mask\n+\n+\t\tif i >= 56 {\n+\t\t\t// we might have to write the length here if all fit in one block\n+\t\t\td.x[i] |= mask1b & length[i-56]\n+\t\t}\n+\t}\n+\n+\t// compress, and only keep the digest if all fit in one block\n+\tblock(d, d.x[:])\n+\n+\tvar digest [Size]byte\n+\tfor i, s := range d.h {\n+\t\tdigest[i*4] = mask1b & byte(s>>24)\n+\t\tdigest[i*4+1] = mask1b & byte(s>>16)\n+\t\tdigest[i*4+2] = mask1b & byte(s>>8)\n+\t\tdigest[i*4+3] = mask1b & byte(s)\n+\t}\n+\n+\tfor i := byte(0); i < chunk; i++ {\n+\t\t// second block, it's always past the end of data, might start with 0x80\n+\t\tif i < 56 {\n+\t\t\td.x[i] = separator\n+\t\t\tseparator = 0\n+\t\t} else {\n+\t\t\td.x[i] = length[i-56]\n+\t\t}\n+\t}\n+\n+\t// compress, and only keep the digest if we actually needed the second block\n+\tblock(d, d.x[:])\n+\n+\tfor i, s := range d.h {\n+\t\tdigest[i*4] |= ^mask1b & byte(s>>24)\n+\t\tdigest[i*4+1] |= ^mask1b & byte(s>>16)\n+\t\tdigest[i*4+2] |= ^mask1b & byte(s>>8)\n+\t\tdigest[i*4+3] |= ^mask1b & byte(s)\n+\t}\n+\n+\treturn digest\n+}\n+\n // Sum returns the SHA1 checksum of the data.\n func Sum(data []byte) [Size]byte {\n \tvar d digest"}, {"sha": "3e59a5defe35e56a05b06b143262bd95da8e09e7", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -61,15 +61,24 @@ func TestGolden(t *testing.T) {\n \t\t\tt.Fatalf(\"Sum function: sha1(%s) = %s want %s\", g.in, s, g.out)\n \t\t}\n \t\tc := New()\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tif j < 2 {\n+\t\tfor j := 0; j < 4; j++ {\n+\t\t\tvar sum []byte\n+\t\t\tswitch j {\n+\t\t\tcase 0, 1:\n \t\t\t\tio.WriteString(c, g.in)\n-\t\t\t} else {\n+\t\t\t\tsum = c.Sum(nil)\n+\t\t\tcase 2:\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n \t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n+\t\t\t\tsum = c.Sum(nil)\n+\t\t\tcase 3:\n+\t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n+\t\t\t\tc.(*digest).ConstantTimeSum(nil)\n+\t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n+\t\t\t\tsum = c.(*digest).ConstantTimeSum(nil)\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n+\t\t\ts := fmt.Sprintf(\"%x\", sum)\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha1[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "8ef8b1faffcf7fcd139f3a7c16e422db2e5c27e1", "filename": "libgo/go/crypto/sha1/sha1block_amd64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Go Authors.  All rights reserved.\n+// Copyright 2016 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "89d5c977787ba00162bd5da5c6733b1678a5202f", "filename": "libgo/go/crypto/sha256/example_test.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fexample_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package sha256_test\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+func ExampleSum256() {\n+\tsum := sha256.Sum256([]byte(\"hello world\\n\"))\n+\tfmt.Printf(\"%x\", sum)\n+\t// Output: a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447\n+}\n+\n+func ExampleNew() {\n+\th := sha256.New()\n+\th.Write([]byte(\"hello world\\n\"))\n+\tfmt.Printf(\"%x\", h.Sum(nil))\n+\t// Output: a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447\n+}\n+\n+func ExampleNew_file() {\n+\tf, err := os.Open(\"file.txt\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tfmt.Printf(\"%x\", h.Sum(nil))\n+}"}, {"sha": "e283c412c183ad4a7ad9523ee54cd0e3ffd340b1", "filename": "libgo/go/crypto/sha256/sha256block_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // +build ignore\n-// +build 386 amd64 s390x\n+// +build 386 amd64 s390x ppc64le\n \n package sha256\n "}, {"sha": "5cd022d2697c09f80fc53b0f2abb88756eb3d6fd", "filename": "libgo/go/crypto/sha256/sha256block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// -build !amd64,!386,!s390x\n+// -build !amd64,!386,!s390x,!ppc64le\n \n package sha256\n "}, {"sha": "3859a40e32884a045f15e9621cf4cd1a4b28e2a7", "filename": "libgo/go/crypto/sha512/sha512block_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // +build ignore\n-// -build amd64 s390x\n+// +build amd64 s390x ppc64le\n \n package sha512\n "}, {"sha": "fb2e6c6bf5d6f1b4caebcadb6f606d4037f7d113", "filename": "libgo/go/crypto/sha512/sha512block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// -build !amd64,!s390x\n+// -build !amd64,!s390x,!ppc64le\n \n package sha512\n "}, {"sha": "49298682574234604db81df9f31abf6d4ab929f1", "filename": "libgo/go/crypto/tls/alert.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -38,6 +38,7 @@ const (\n \talertInappropriateFallback  alert = 86\n \talertUserCanceled           alert = 90\n \talertNoRenegotiation        alert = 100\n+\talertNoApplicationProtocol  alert = 120\n )\n \n var alertText = map[alert]string{\n@@ -64,6 +65,7 @@ var alertText = map[alert]string{\n \talertInappropriateFallback:  \"inappropriate fallback\",\n \talertUserCanceled:           \"user canceled\",\n \talertNoRenegotiation:        \"no renegotiation\",\n+\talertNoApplicationProtocol:  \"no application protocol\",\n }\n \n func (e alert) String() string {"}, {"sha": "05146743acbba6010f3ac868bf2184303e11cf92", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 130, "deletions": 25, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -11,8 +11,11 @@ import (\n \t\"crypto/hmac\"\n \t\"crypto/rc4\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n \t\"crypto/x509\"\n \t\"hash\"\n+\n+\t\"golang_org/x/crypto/chacha20poly1305\"\n )\n \n // a keyAgreement implements the client and server side of a TLS key agreement\n@@ -73,25 +76,32 @@ type cipherSuite struct {\n }\n \n var cipherSuites = []*cipherSuite{\n-\t// Ciphersuite order is chosen so that ECDHE comes before plain RSA\n-\t// and RC4 comes before AES-CBC (because of the Lucky13 attack).\n+\t// Ciphersuite order is chosen so that ECDHE comes before plain RSA and\n+\t// AEADs are the top preference.\n+\t{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, 32, 0, 12, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadChaCha20Poly1305},\n+\t{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, 32, 0, 12, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadChaCha20Poly1305},\n \t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n-\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE | suiteDefaultOff, cipherRC4, macSHA1, nil},\n-\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteDefaultOff, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, ecdheRSAKA, suiteECDHE | suiteTLS12, cipherAES, macSHA256, nil},\n \t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, cipherAES, macSHA256, nil},\n \t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n \t{TLS_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, rsaKA, suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, rsaKA, suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n-\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, suiteDefaultOff, cipherRC4, macSHA1, nil},\n+\t{TLS_RSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, rsaKA, suiteTLS12, cipherAES, macSHA256, nil},\n \t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n \t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},\n \t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},\n+\n+\t// RC4-based cipher suites are disabled by default.\n+\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, suiteDefaultOff, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE | suiteDefaultOff, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteDefaultOff, cipherRC4, macSHA1, nil},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n@@ -125,35 +135,84 @@ func macSHA1(version uint16, key []byte) macFunction {\n \t\tcopy(mac.key, key)\n \t\treturn mac\n \t}\n-\treturn tls10MAC{hmac.New(sha1.New, key)}\n+\treturn tls10MAC{hmac.New(newConstantTimeHash(sha1.New), key)}\n+}\n+\n+// macSHA256 returns a SHA-256 based MAC. These are only supported in TLS 1.2\n+// so the given version is ignored.\n+func macSHA256(version uint16, key []byte) macFunction {\n+\treturn tls10MAC{hmac.New(sha256.New, key)}\n }\n \n type macFunction interface {\n \tSize() int\n-\tMAC(digestBuf, seq, header, data []byte) []byte\n+\tMAC(digestBuf, seq, header, data, extra []byte) []byte\n+}\n+\n+type aead interface {\n+\tcipher.AEAD\n+\n+\t// explicitIVLen returns the number of bytes used by the explicit nonce\n+\t// that is included in the record. This is eight for older AEADs and\n+\t// zero for modern ones.\n+\texplicitNonceLen() int\n }\n \n // fixedNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to\n // each call.\n type fixedNonceAEAD struct {\n-\t// sealNonce and openNonce are buffers where the larger nonce will be\n-\t// constructed. Since a seal and open operation may be running\n-\t// concurrently, there is a separate buffer for each.\n-\tsealNonce, openNonce []byte\n-\taead                 cipher.AEAD\n+\t// nonce contains the fixed part of the nonce in the first four bytes.\n+\tnonce [12]byte\n+\taead  cipher.AEAD\n }\n \n-func (f *fixedNonceAEAD) NonceSize() int { return 8 }\n-func (f *fixedNonceAEAD) Overhead() int  { return f.aead.Overhead() }\n+func (f *fixedNonceAEAD) NonceSize() int        { return 8 }\n+func (f *fixedNonceAEAD) Overhead() int         { return f.aead.Overhead() }\n+func (f *fixedNonceAEAD) explicitNonceLen() int { return 8 }\n \n func (f *fixedNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {\n-\tcopy(f.sealNonce[len(f.sealNonce)-8:], nonce)\n-\treturn f.aead.Seal(out, f.sealNonce, plaintext, additionalData)\n+\tcopy(f.nonce[4:], nonce)\n+\treturn f.aead.Seal(out, f.nonce[:], plaintext, additionalData)\n }\n \n func (f *fixedNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) {\n-\tcopy(f.openNonce[len(f.openNonce)-8:], nonce)\n-\treturn f.aead.Open(out, f.openNonce, plaintext, additionalData)\n+\tcopy(f.nonce[4:], nonce)\n+\treturn f.aead.Open(out, f.nonce[:], plaintext, additionalData)\n+}\n+\n+// xoredNonceAEAD wraps an AEAD by XORing in a fixed pattern to the nonce\n+// before each call.\n+type xorNonceAEAD struct {\n+\tnonceMask [12]byte\n+\taead      cipher.AEAD\n+}\n+\n+func (f *xorNonceAEAD) NonceSize() int        { return 8 }\n+func (f *xorNonceAEAD) Overhead() int         { return f.aead.Overhead() }\n+func (f *xorNonceAEAD) explicitNonceLen() int { return 0 }\n+\n+func (f *xorNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {\n+\tfor i, b := range nonce {\n+\t\tf.nonceMask[4+i] ^= b\n+\t}\n+\tresult := f.aead.Seal(out, f.nonceMask[:], plaintext, additionalData)\n+\tfor i, b := range nonce {\n+\t\tf.nonceMask[4+i] ^= b\n+\t}\n+\n+\treturn result\n+}\n+\n+func (f *xorNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) {\n+\tfor i, b := range nonce {\n+\t\tf.nonceMask[4+i] ^= b\n+\t}\n+\tresult, err := f.aead.Open(out, f.nonceMask[:], plaintext, additionalData)\n+\tfor i, b := range nonce {\n+\t\tf.nonceMask[4+i] ^= b\n+\t}\n+\n+\treturn result, err\n }\n \n func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD {\n@@ -166,11 +225,20 @@ func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD {\n \t\tpanic(err)\n \t}\n \n-\tnonce1, nonce2 := make([]byte, 12), make([]byte, 12)\n-\tcopy(nonce1, fixedNonce)\n-\tcopy(nonce2, fixedNonce)\n+\tret := &fixedNonceAEAD{aead: aead}\n+\tcopy(ret.nonce[:], fixedNonce)\n+\treturn ret\n+}\n+\n+func aeadChaCha20Poly1305(key, fixedNonce []byte) cipher.AEAD {\n+\taead, err := chacha20poly1305.New(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n \n-\treturn &fixedNonceAEAD{nonce1, nonce2, aead}\n+\tret := &xorNonceAEAD{aead: aead}\n+\tcopy(ret.nonceMask[:], fixedNonce)\n+\treturn ret\n }\n \n // ssl30MAC implements the SSLv3 MAC function, as defined in\n@@ -188,7 +256,9 @@ var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0\n \n var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}\n \n-func (s ssl30MAC) MAC(digestBuf, seq, header, data []byte) []byte {\n+// MAC does not offer constant timing guarantees for SSL v3.0, since it's deemed\n+// useless considering the similar, protocol-level POODLE vulnerability.\n+func (s ssl30MAC) MAC(digestBuf, seq, header, data, extra []byte) []byte {\n \tpadLength := 48\n \tif s.h.Size() == 20 {\n \t\tpadLength = 40\n@@ -210,6 +280,29 @@ func (s ssl30MAC) MAC(digestBuf, seq, header, data []byte) []byte {\n \treturn s.h.Sum(digestBuf[:0])\n }\n \n+type constantTimeHash interface {\n+\thash.Hash\n+\tConstantTimeSum(b []byte) []byte\n+}\n+\n+// cthWrapper wraps any hash.Hash that implements ConstantTimeSum, and replaces\n+// with that all calls to Sum. It's used to obtain a ConstantTimeSum-based HMAC.\n+type cthWrapper struct {\n+\th constantTimeHash\n+}\n+\n+func (c *cthWrapper) Size() int                   { return c.h.Size() }\n+func (c *cthWrapper) BlockSize() int              { return c.h.BlockSize() }\n+func (c *cthWrapper) Reset()                      { c.h.Reset() }\n+func (c *cthWrapper) Write(p []byte) (int, error) { return c.h.Write(p) }\n+func (c *cthWrapper) Sum(b []byte) []byte         { return c.h.ConstantTimeSum(b) }\n+\n+func newConstantTimeHash(h func() hash.Hash) func() hash.Hash {\n+\treturn func() hash.Hash {\n+\t\treturn &cthWrapper{h().(constantTimeHash)}\n+\t}\n+}\n+\n // tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.\n type tls10MAC struct {\n \th hash.Hash\n@@ -219,12 +312,19 @@ func (s tls10MAC) Size() int {\n \treturn s.h.Size()\n }\n \n-func (s tls10MAC) MAC(digestBuf, seq, header, data []byte) []byte {\n+// MAC is guaranteed to take constant time, as long as\n+// len(seq)+len(header)+len(data)+len(extra) is constant. extra is not fed into\n+// the MAC, but is only provided to make the timing profile constant.\n+func (s tls10MAC) MAC(digestBuf, seq, header, data, extra []byte) []byte {\n \ts.h.Reset()\n \ts.h.Write(seq)\n \ts.h.Write(header)\n \ts.h.Write(data)\n-\treturn s.h.Sum(digestBuf[:0])\n+\tres := s.h.Sum(digestBuf[:0])\n+\tif extra != nil {\n+\t\ts.h.Write(extra)\n+\t}\n+\treturn res\n }\n \n func rsaKA(version uint16) keyAgreement {\n@@ -270,6 +370,7 @@ const (\n \tTLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a\n \tTLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f\n \tTLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035\n+\tTLS_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0x003c\n \tTLS_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0x009c\n \tTLS_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0x009d\n \tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA        uint16 = 0xc007\n@@ -279,10 +380,14 @@ const (\n \tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0xc012\n \tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013\n \tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014\n+\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc023\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   uint16 = 0xc027\n \tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f\n \tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n \tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   uint16 = 0xc030\n \tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c\n+\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305    uint16 = 0xcca8\n+\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305  uint16 = 0xcca9\n \n \t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n \t// that the client is doing version fallback. See"}, {"sha": "276d1761ea04033672d5ad0354327fa36bd34a4c", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 218, "deletions": 12, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -7,13 +7,15 @@ package tls\n import (\n \t\"container/list\"\n \t\"crypto\"\n+\t\"crypto/internal/cipherhw\"\n \t\"crypto/rand\"\n \t\"crypto/sha512\"\n \t\"crypto/x509\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"math/big\"\n+\t\"net\"\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n@@ -95,6 +97,7 @@ const (\n \tCurveP256 CurveID = 23\n \tCurveP384 CurveID = 24\n \tCurveP521 CurveID = 25\n+\tX25519    CurveID = 29\n )\n \n // TLS Elliptic Curve Point Formats\n@@ -213,6 +216,25 @@ type ClientSessionCache interface {\n \tPut(sessionKey string, cs *ClientSessionState)\n }\n \n+// SignatureScheme identifies a signature algorithm supported by TLS. See\n+// https://tools.ietf.org/html/draft-ietf-tls-tls13-18#section-4.2.3.\n+type SignatureScheme uint16\n+\n+const (\n+\tPKCS1WithSHA1   SignatureScheme = 0x0201\n+\tPKCS1WithSHA256 SignatureScheme = 0x0401\n+\tPKCS1WithSHA384 SignatureScheme = 0x0501\n+\tPKCS1WithSHA512 SignatureScheme = 0x0601\n+\n+\tPSSWithSHA256 SignatureScheme = 0x0804\n+\tPSSWithSHA384 SignatureScheme = 0x0805\n+\tPSSWithSHA512 SignatureScheme = 0x0806\n+\n+\tECDSAWithP256AndSHA256 SignatureScheme = 0x0403\n+\tECDSAWithP384AndSHA384 SignatureScheme = 0x0503\n+\tECDSAWithP521AndSHA512 SignatureScheme = 0x0603\n+)\n+\n // ClientHelloInfo contains information from a ClientHello message in order to\n // guide certificate selection in the GetCertificate callback.\n type ClientHelloInfo struct {\n@@ -237,6 +259,47 @@ type ClientHelloInfo struct {\n \t// is being used (see\n \t// http://tools.ietf.org/html/rfc4492#section-5.1.2).\n \tSupportedPoints []uint8\n+\n+\t// SignatureSchemes lists the signature and hash schemes that the client\n+\t// is willing to verify. SignatureSchemes is set only if the Signature\n+\t// Algorithms Extension is being used (see\n+\t// https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1).\n+\tSignatureSchemes []SignatureScheme\n+\n+\t// SupportedProtos lists the application protocols supported by the client.\n+\t// SupportedProtos is set only if the Application-Layer Protocol\n+\t// Negotiation Extension is being used (see\n+\t// https://tools.ietf.org/html/rfc7301#section-3.1).\n+\t//\n+\t// Servers can select a protocol by setting Config.NextProtos in a\n+\t// GetConfigForClient return value.\n+\tSupportedProtos []string\n+\n+\t// SupportedVersions lists the TLS versions supported by the client.\n+\t// For TLS versions less than 1.3, this is extrapolated from the max\n+\t// version advertised by the client, so values other than the greatest\n+\t// might be rejected if used.\n+\tSupportedVersions []uint16\n+\n+\t// Conn is the underlying net.Conn for the connection. Do not read\n+\t// from, or write to, this connection; that will cause the TLS\n+\t// connection to fail.\n+\tConn net.Conn\n+}\n+\n+// CertificateRequestInfo contains information from a server's\n+// CertificateRequest message, which is used to demand a certificate and proof\n+// of control from a client.\n+type CertificateRequestInfo struct {\n+\t// AcceptableCAs contains zero or more, DER-encoded, X.501\n+\t// Distinguished Names. These are the names of root or intermediate CAs\n+\t// that the server wishes the returned certificate to be signed by. An\n+\t// empty slice indicates that the server has no preference.\n+\tAcceptableCAs [][]byte\n+\n+\t// SignatureSchemes lists the signature schemes that the server is\n+\t// willing to verify.\n+\tSignatureSchemes []SignatureScheme\n }\n \n // RenegotiationSupport enumerates the different levels of support for TLS\n@@ -281,10 +344,11 @@ type Config struct {\n \t// If Time is nil, TLS uses time.Now.\n \tTime func() time.Time\n \n-\t// Certificates contains one or more certificate chains\n-\t// to present to the other side of the connection.\n-\t// Server configurations must include at least one certificate\n-\t// or else set GetCertificate.\n+\t// Certificates contains one or more certificate chains to present to\n+\t// the other side of the connection. Server configurations must include\n+\t// at least one certificate or else set GetCertificate. Clients doing\n+\t// client-authentication may set either Certificates or\n+\t// GetClientCertificate.\n \tCertificates []Certificate\n \n \t// NameToCertificate maps from a certificate name to an element of\n@@ -302,7 +366,54 @@ type Config struct {\n \t// If GetCertificate is nil or returns nil, then the certificate is\n \t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n \t// first element of Certificates will be used.\n-\tGetCertificate func(clientHello *ClientHelloInfo) (*Certificate, error)\n+\tGetCertificate func(*ClientHelloInfo) (*Certificate, error)\n+\n+\t// GetClientCertificate, if not nil, is called when a server requests a\n+\t// certificate from a client. If set, the contents of Certificates will\n+\t// be ignored.\n+\t//\n+\t// If GetClientCertificate returns an error, the handshake will be\n+\t// aborted and that error will be returned. Otherwise\n+\t// GetClientCertificate must return a non-nil Certificate. If\n+\t// Certificate.Certificate is empty then no certificate will be sent to\n+\t// the server. If this is unacceptable to the server then it may abort\n+\t// the handshake.\n+\t//\n+\t// GetClientCertificate may be called multiple times for the same\n+\t// connection if renegotiation occurs or if TLS 1.3 is in use.\n+\tGetClientCertificate func(*CertificateRequestInfo) (*Certificate, error)\n+\n+\t// GetConfigForClient, if not nil, is called after a ClientHello is\n+\t// received from a client. It may return a non-nil Config in order to\n+\t// change the Config that will be used to handle this connection. If\n+\t// the returned Config is nil, the original Config will be used. The\n+\t// Config returned by this callback may not be subsequently modified.\n+\t//\n+\t// If GetConfigForClient is nil, the Config passed to Server() will be\n+\t// used for all connections.\n+\t//\n+\t// Uniquely for the fields in the returned Config, session ticket keys\n+\t// will be duplicated from the original Config if not set.\n+\t// Specifically, if SetSessionTicketKeys was called on the original\n+\t// config but not on the returned config then the ticket keys from the\n+\t// original config will be copied into the new config before use.\n+\t// Otherwise, if SessionTicketKey was set in the original config but\n+\t// not in the returned config then it will be copied into the returned\n+\t// config before use. If neither of those cases applies then the key\n+\t// material from the returned config will be used for session tickets.\n+\tGetConfigForClient func(*ClientHelloInfo) (*Config, error)\n+\n+\t// VerifyPeerCertificate, if not nil, is called after normal\n+\t// certificate verification by either a TLS client or server. It\n+\t// receives the raw ASN.1 certificates provided by the peer and also\n+\t// any verified chains that normal processing found. If it returns a\n+\t// non-nil error, the handshake is aborted and that error results.\n+\t//\n+\t// If normal verification fails then the handshake will abort before\n+\t// considering this callback. If normal verification is disabled by\n+\t// setting InsecureSkipVerify then this callback will be considered but\n+\t// the verifiedChains argument will always be nil.\n+\tVerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n \n \t// RootCAs defines the set of root certificate authorities\n \t// that clients use when verifying server certificates.\n@@ -387,15 +498,27 @@ type Config struct {\n \t// The default, none, is correct for the vast majority of applications.\n \tRenegotiation RenegotiationSupport\n \n+\t// KeyLogWriter optionally specifies a destination for TLS master secrets\n+\t// in NSS key log format that can be used to allow external programs\n+\t// such as Wireshark to decrypt TLS connections.\n+\t// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n+\t// Use of KeyLogWriter compromises security and should only be\n+\t// used for debugging.\n+\tKeyLogWriter io.Writer\n+\n \tserverInitOnce sync.Once // guards calling (*Config).serverInit\n \n-\t// mutex protects sessionTicketKeys\n+\t// mutex protects sessionTicketKeys and originalConfig.\n \tmutex sync.RWMutex\n \t// sessionTicketKeys contains zero or more ticket keys. If the length\n \t// is zero, SessionTicketsDisabled must be true. The first key is used\n \t// for new tickets and any subsequent keys can be used to decrypt old\n \t// tickets.\n \tsessionTicketKeys []ticketKey\n+\t// originalConfig is set to the Config that was passed to Server if\n+\t// this Config is returned by a GetConfigForClient callback. It's used\n+\t// by serverInit in order to copy session ticket keys if needed.\n+\toriginalConfig *Config\n }\n \n // ticketKeyNameLen is the number of bytes of identifier that is prepended to\n@@ -422,14 +545,26 @@ func ticketKeyFromBytes(b [32]byte) (key ticketKey) {\n \treturn key\n }\n \n-// clone returns a copy of c. Only the exported fields are copied.\n-func (c *Config) clone() *Config {\n+// Clone returns a shallow clone of c. It is safe to clone a Config that is\n+// being used concurrently by a TLS client or server.\n+func (c *Config) Clone() *Config {\n+\t// Running serverInit ensures that it's safe to read\n+\t// SessionTicketsDisabled.\n+\tc.serverInitOnce.Do(c.serverInit)\n+\n+\tvar sessionTicketKeys []ticketKey\n+\tc.mutex.RLock()\n+\tsessionTicketKeys = c.sessionTicketKeys\n+\tc.mutex.RUnlock()\n+\n \treturn &Config{\n \t\tRand:                        c.Rand,\n \t\tTime:                        c.Time,\n \t\tCertificates:                c.Certificates,\n \t\tNameToCertificate:           c.NameToCertificate,\n \t\tGetCertificate:              c.GetCertificate,\n+\t\tGetConfigForClient:          c.GetConfigForClient,\n+\t\tVerifyPeerCertificate:       c.VerifyPeerCertificate,\n \t\tRootCAs:                     c.RootCAs,\n \t\tNextProtos:                  c.NextProtos,\n \t\tServerName:                  c.ServerName,\n@@ -446,14 +581,22 @@ func (c *Config) clone() *Config {\n \t\tCurvePreferences:            c.CurvePreferences,\n \t\tDynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,\n \t\tRenegotiation:               c.Renegotiation,\n+\t\tKeyLogWriter:                c.KeyLogWriter,\n+\t\tsessionTicketKeys:           sessionTicketKeys,\n+\t\t// originalConfig is deliberately not duplicated.\n \t}\n }\n \n func (c *Config) serverInit() {\n-\tif c.SessionTicketsDisabled {\n+\tif c.SessionTicketsDisabled || len(c.ticketKeys()) != 0 {\n \t\treturn\n \t}\n \n+\tvar originalConfig *Config\n+\tc.mutex.Lock()\n+\toriginalConfig, c.originalConfig = c.originalConfig, nil\n+\tc.mutex.Unlock()\n+\n \talreadySet := false\n \tfor _, b := range c.SessionTicketKey {\n \t\tif b != 0 {\n@@ -463,13 +606,21 @@ func (c *Config) serverInit() {\n \t}\n \n \tif !alreadySet {\n-\t\tif _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {\n+\t\tif originalConfig != nil {\n+\t\t\tcopy(c.SessionTicketKey[:], originalConfig.SessionTicketKey[:])\n+\t\t} else if _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {\n \t\t\tc.SessionTicketsDisabled = true\n \t\t\treturn\n \t\t}\n \t}\n \n-\tc.sessionTicketKeys = []ticketKey{ticketKeyFromBytes(c.SessionTicketKey)}\n+\tif originalConfig != nil {\n+\t\toriginalConfig.mutex.RLock()\n+\t\tc.sessionTicketKeys = originalConfig.sessionTicketKeys\n+\t\toriginalConfig.mutex.RUnlock()\n+\t} else {\n+\t\tc.sessionTicketKeys = []ticketKey{ticketKeyFromBytes(c.SessionTicketKey)}\n+\t}\n }\n \n func (c *Config) ticketKeys() []ticketKey {\n@@ -539,7 +690,7 @@ func (c *Config) maxVersion() uint16 {\n \treturn c.MaxVersion\n }\n \n-var defaultCurvePreferences = []CurveID{CurveP256, CurveP384, CurveP521}\n+var defaultCurvePreferences = []CurveID{X25519, CurveP256, CurveP384, CurveP521}\n \n func (c *Config) curvePreferences() []CurveID {\n \tif c == nil || len(c.CurvePreferences) == 0 {\n@@ -627,6 +778,26 @@ func (c *Config) BuildNameToCertificate() {\n \t}\n }\n \n+// writeKeyLog logs client random and master secret if logging was enabled by\n+// setting c.KeyLogWriter.\n+func (c *Config) writeKeyLog(clientRandom, masterSecret []byte) error {\n+\tif c.KeyLogWriter == nil {\n+\t\treturn nil\n+\t}\n+\n+\tlogLine := []byte(fmt.Sprintf(\"CLIENT_RANDOM %x %x\\n\", clientRandom, masterSecret))\n+\n+\twriterMutex.Lock()\n+\t_, err := c.KeyLogWriter.Write(logLine)\n+\twriterMutex.Unlock()\n+\n+\treturn err\n+}\n+\n+// writerMutex protects all KeyLogWriters globally. It is rarely enabled,\n+// and is only for debugging, so a global mutex saves space.\n+var writerMutex sync.Mutex\n+\n // A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n \tCertificate [][]byte\n@@ -749,11 +920,46 @@ func defaultCipherSuites() []uint16 {\n }\n \n func initDefaultCipherSuites() {\n+\tvar topCipherSuites []uint16\n+\tif cipherhw.AESGCMSupport() {\n+\t\t// If AES-GCM hardware is provided then prioritise AES-GCM\n+\t\t// cipher suites.\n+\t\ttopCipherSuites = []uint16{\n+\t\t\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n+\t\t\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n+\t\t\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n+\t\t}\n+\t} else {\n+\t\t// Without AES-GCM hardware, we put the ChaCha20-Poly1305\n+\t\t// cipher suites first.\n+\t\ttopCipherSuites = []uint16{\n+\t\t\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n+\t\t\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n+\t\t\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n+\t\t\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n+\t\t}\n+\t}\n+\n \tvarDefaultCipherSuites = make([]uint16, 0, len(cipherSuites))\n+\tfor _, topCipher := range topCipherSuites {\n+\t\tvarDefaultCipherSuites = append(varDefaultCipherSuites, topCipher)\n+\t}\n+\n+NextCipherSuite:\n \tfor _, suite := range cipherSuites {\n \t\tif suite.flags&suiteDefaultOff != 0 {\n \t\t\tcontinue\n \t\t}\n+\t\tfor _, existing := range varDefaultCipherSuites {\n+\t\t\tif existing == suite.id {\n+\t\t\t\tcontinue NextCipherSuite\n+\t\t\t}\n+\t\t}\n \t\tvarDefaultCipherSuites = append(varDefaultCipherSuites, suite.id)\n \t}\n }"}, {"sha": "03895a723fa25670946dd973378014c9ed04f901", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 152, "deletions": 62, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -29,11 +29,15 @@ type Conn struct {\n \n \t// constant after handshake; protected by handshakeMutex\n \thandshakeMutex sync.Mutex // handshakeMutex < in.Mutex, out.Mutex, errMutex\n-\thandshakeErr   error      // error resulting from handshake\n-\tvers           uint16     // TLS version\n-\thaveVers       bool       // version has been negotiated\n-\tconfig         *Config    // configuration passed to constructor\n-\t// handshakeComplete is true if the connection is currently transfering\n+\t// handshakeCond, if not nil, indicates that a goroutine is committed\n+\t// to running the handshake for this Conn. Other goroutines that need\n+\t// to wait for the handshake can wait on this, under handshakeMutex.\n+\thandshakeCond *sync.Cond\n+\thandshakeErr  error   // error resulting from handshake\n+\tvers          uint16  // TLS version\n+\thaveVers      bool    // version has been negotiated\n+\tconfig        *Config // configuration passed to constructor\n+\t// handshakeComplete is true if the connection is currently transferring\n \t// application data (i.e. is not currently processing a handshake).\n \thandshakeComplete bool\n \t// handshakes counts the number of handshakes performed on the\n@@ -60,6 +64,13 @@ type Conn struct {\n \t// the first transmitted Finished message is the tls-unique\n \t// channel-binding value.\n \tclientFinishedIsFirst bool\n+\n+\t// closeNotifyErr is any error from sending the alertCloseNotify record.\n+\tcloseNotifyErr error\n+\t// closeNotifySent is true if the Conn attempted to send an\n+\t// alertCloseNotify record.\n+\tcloseNotifySent bool\n+\n \t// clientFinished and serverFinished contain the Finished message sent\n \t// by the client or server in the most recent handshake. This is\n \t// retained to support the renegotiation extension and tls-unique\n@@ -189,18 +200,18 @@ func (hc *halfConn) incSeq() {\n \tpanic(\"TLS: sequence number wraparound\")\n }\n \n-// removePadding returns an unpadded slice, in constant time, which is a prefix\n-// of the input. It also returns a byte which is equal to 255 if the padding\n-// was valid and 0 otherwise. See RFC 2246, section 6.2.3.2\n-func removePadding(payload []byte) ([]byte, byte) {\n+// extractPadding returns, in constant time, the length of the padding to remove\n+// from the end of payload. It also returns a byte which is equal to 255 if the\n+// padding was valid and 0 otherwise. See RFC 2246, section 6.2.3.2\n+func extractPadding(payload []byte) (toRemove int, good byte) {\n \tif len(payload) < 1 {\n-\t\treturn payload, 0\n+\t\treturn 0, 0\n \t}\n \n \tpaddingLen := payload[len(payload)-1]\n \tt := uint(len(payload)-1) - uint(paddingLen)\n \t// if len(payload) >= (paddingLen - 1) then the MSB of t is zero\n-\tgood := byte(int32(^t) >> 31)\n+\tgood = byte(int32(^t) >> 31)\n \n \ttoCheck := 255 // the maximum possible padding length\n \t// The length of the padded data is public, so we can use an if here\n@@ -223,24 +234,24 @@ func removePadding(payload []byte) ([]byte, byte) {\n \tgood &= good << 1\n \tgood = uint8(int8(good) >> 7)\n \n-\ttoRemove := good&paddingLen + 1\n-\treturn payload[:len(payload)-int(toRemove)], good\n+\ttoRemove = int(paddingLen) + 1\n+\treturn\n }\n \n-// removePaddingSSL30 is a replacement for removePadding in the case that the\n+// extractPaddingSSL30 is a replacement for extractPadding in the case that the\n // protocol version is SSLv3. In this version, the contents of the padding\n // are random and cannot be checked.\n-func removePaddingSSL30(payload []byte) ([]byte, byte) {\n+func extractPaddingSSL30(payload []byte) (toRemove int, good byte) {\n \tif len(payload) < 1 {\n-\t\treturn payload, 0\n+\t\treturn 0, 0\n \t}\n \n \tpaddingLen := int(payload[len(payload)-1]) + 1\n \tif paddingLen > len(payload) {\n-\t\treturn payload, 0\n+\t\treturn 0, 0\n \t}\n \n-\treturn payload[:len(payload)-paddingLen], 255\n+\treturn paddingLen, 255\n }\n \n func roundUp(a, b int) int {\n@@ -266,20 +277,25 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)\n \t}\n \n \tpaddingGood := byte(255)\n+\tpaddingLen := 0\n \texplicitIVLen := 0\n \n \t// decrypt\n \tif hc.cipher != nil {\n \t\tswitch c := hc.cipher.(type) {\n \t\tcase cipher.Stream:\n \t\t\tc.XORKeyStream(payload, payload)\n-\t\tcase cipher.AEAD:\n-\t\t\texplicitIVLen = 8\n+\t\tcase aead:\n+\t\t\texplicitIVLen = c.explicitNonceLen()\n \t\t\tif len(payload) < explicitIVLen {\n \t\t\t\treturn false, 0, alertBadRecordMAC\n \t\t\t}\n-\t\t\tnonce := payload[:8]\n-\t\t\tpayload = payload[8:]\n+\t\t\tnonce := payload[:explicitIVLen]\n+\t\t\tpayload = payload[explicitIVLen:]\n+\n+\t\t\tif len(nonce) == 0 {\n+\t\t\t\tnonce = hc.seq[:]\n+\t\t\t}\n \n \t\t\tcopy(hc.additionalData[:], hc.seq[:])\n \t\t\tcopy(hc.additionalData[8:], b.data[:3])\n@@ -308,22 +324,17 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)\n \t\t\t}\n \t\t\tc.CryptBlocks(payload, payload)\n \t\t\tif hc.version == VersionSSL30 {\n-\t\t\t\tpayload, paddingGood = removePaddingSSL30(payload)\n+\t\t\t\tpaddingLen, paddingGood = extractPaddingSSL30(payload)\n \t\t\t} else {\n-\t\t\t\tpayload, paddingGood = removePadding(payload)\n+\t\t\t\tpaddingLen, paddingGood = extractPadding(payload)\n+\n+\t\t\t\t// To protect against CBC padding oracles like Lucky13, the data\n+\t\t\t\t// past paddingLen (which is secret) is passed to the MAC\n+\t\t\t\t// function as extra data, to be fed into the HMAC after\n+\t\t\t\t// computing the digest. This makes the MAC constant time as\n+\t\t\t\t// long as the digest computation is constant time and does not\n+\t\t\t\t// affect the subsequent write.\n \t\t\t}\n-\t\t\tb.resize(recordHeaderLen + explicitIVLen + len(payload))\n-\n-\t\t\t// note that we still have a timing side-channel in the\n-\t\t\t// MAC check, below. An attacker can align the record\n-\t\t\t// so that a correct padding will cause one less hash\n-\t\t\t// block to be calculated. Then they can iteratively\n-\t\t\t// decrypt a record by breaking each byte. See\n-\t\t\t// \"Password Interception in a SSL/TLS Channel\", Brice\n-\t\t\t// Canvel et al.\n-\t\t\t//\n-\t\t\t// However, our behavior matches OpenSSL, so we leak\n-\t\t\t// only as much as they do.\n \t\tdefault:\n \t\t\tpanic(\"unknown cipher type\")\n \t\t}\n@@ -336,17 +347,19 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)\n \t\t}\n \n \t\t// strip mac off payload, b.data\n-\t\tn := len(payload) - macSize\n+\t\tn := len(payload) - macSize - paddingLen\n+\t\tn = subtle.ConstantTimeSelect(int(uint32(n)>>31), 0, n) // if n < 0 { n = 0 }\n \t\tb.data[3] = byte(n >> 8)\n \t\tb.data[4] = byte(n)\n-\t\tb.resize(recordHeaderLen + explicitIVLen + n)\n-\t\tremoteMAC := payload[n:]\n-\t\tlocalMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], payload[:n])\n+\t\tremoteMAC := payload[n : n+macSize]\n+\t\tlocalMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], payload[:n], payload[n+macSize:])\n \n \t\tif subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 {\n \t\t\treturn false, 0, alertBadRecordMAC\n \t\t}\n \t\thc.inDigestBuf = localMAC\n+\n+\t\tb.resize(recordHeaderLen + explicitIVLen + n)\n \t}\n \thc.incSeq()\n \n@@ -374,7 +387,7 @@ func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {\n func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {\n \t// mac\n \tif hc.mac != nil {\n-\t\tmac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])\n+\t\tmac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:], nil)\n \n \t\tn := len(b.data)\n \t\tb.resize(n + len(mac))\n@@ -389,10 +402,13 @@ func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {\n \t\tswitch c := hc.cipher.(type) {\n \t\tcase cipher.Stream:\n \t\t\tc.XORKeyStream(payload, payload)\n-\t\tcase cipher.AEAD:\n+\t\tcase aead:\n \t\t\tpayloadLen := len(b.data) - recordHeaderLen - explicitIVLen\n \t\t\tb.resize(len(b.data) + c.Overhead())\n \t\t\tnonce := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]\n+\t\t\tif len(nonce) == 0 {\n+\t\t\t\tnonce = hc.seq[:]\n+\t\t\t}\n \t\t\tpayload := b.data[recordHeaderLen+explicitIVLen:]\n \t\t\tpayload = payload[:payloadLen]\n \n@@ -628,9 +644,10 @@ Again:\n \n \t// Process message.\n \tb, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)\n-\tok, off, err := c.in.decrypt(b)\n+\tok, off, alertValue := c.in.decrypt(b)\n \tif !ok {\n-\t\tc.in.setErrorLocked(c.sendAlert(err))\n+\t\tc.in.freeBlock(b)\n+\t\treturn c.in.setErrorLocked(c.sendAlert(alertValue))\n \t}\n \tb.off = off\n \tdata := b.data[b.off:]\n@@ -849,15 +866,16 @@ func (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error) {\n \t\t\t}\n \t\t}\n \t\tif explicitIVLen == 0 {\n-\t\t\tif _, ok := c.out.cipher.(cipher.AEAD); ok {\n-\t\t\t\texplicitIVLen = 8\n+\t\t\tif c, ok := c.out.cipher.(aead); ok {\n+\t\t\t\texplicitIVLen = c.explicitNonceLen()\n+\n \t\t\t\t// The AES-GCM construction in TLS has an\n \t\t\t\t// explicit nonce so that the nonce can be\n \t\t\t\t// random. However, the nonce is only 8 bytes\n \t\t\t\t// which is too small for a secure, random\n \t\t\t\t// nonce. Therefore we use the sequence number\n \t\t\t\t// as the nonce.\n-\t\t\t\texplicitIVIsSeq = true\n+\t\t\t\texplicitIVIsSeq = explicitIVLen > 0\n \t\t\t}\n \t\t}\n \t\tm := len(data)\n@@ -978,7 +996,7 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \t\treturn nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n \t}\n \n-\t// The handshake message unmarshallers\n+\t// The handshake message unmarshalers\n \t// expect to be able to keep references to data,\n \t// so pass in a fresh copy that won't be overwritten.\n \tdata = append([]byte(nil), data...)\n@@ -989,7 +1007,10 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \treturn m, nil\n }\n \n-var errClosed = errors.New(\"tls: use of closed connection\")\n+var (\n+\terrClosed   = errors.New(\"tls: use of closed connection\")\n+\terrShutdown = errors.New(\"tls: protocol is shutdown\")\n+)\n \n // Write writes data to the connection.\n func (c *Conn) Write(b []byte) (int, error) {\n@@ -1020,6 +1041,10 @@ func (c *Conn) Write(b []byte) (int, error) {\n \t\treturn 0, alertInternalError\n \t}\n \n+\tif c.closeNotifySent {\n+\t\treturn 0, errShutdown\n+\t}\n+\n \t// SSL 3.0 and TLS 1.0 are susceptible to a chosen-plaintext\n \t// attack when using block mode ciphers due to predictable IVs.\n \t// This can be prevented by splitting each Application Data\n@@ -1183,7 +1208,7 @@ func (c *Conn) Close() error {\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \tif c.handshakeComplete {\n-\t\talertErr = c.sendAlert(alertCloseNotify)\n+\t\talertErr = c.closeNotify()\n \t}\n \n \tif err := c.conn.Close(); err != nil {\n@@ -1192,6 +1217,32 @@ func (c *Conn) Close() error {\n \treturn alertErr\n }\n \n+var errEarlyCloseWrite = errors.New(\"tls: CloseWrite called before handshake complete\")\n+\n+// CloseWrite shuts down the writing side of the connection. It should only be\n+// called once the handshake has completed and does not call CloseWrite on the\n+// underlying connection. Most callers should just use Close.\n+func (c *Conn) CloseWrite() error {\n+\tc.handshakeMutex.Lock()\n+\tdefer c.handshakeMutex.Unlock()\n+\tif !c.handshakeComplete {\n+\t\treturn errEarlyCloseWrite\n+\t}\n+\n+\treturn c.closeNotify()\n+}\n+\n+func (c *Conn) closeNotify() error {\n+\tc.out.Lock()\n+\tdefer c.out.Unlock()\n+\n+\tif !c.closeNotifySent {\n+\t\tc.closeNotifyErr = c.sendAlertLocked(alertCloseNotify)\n+\t\tc.closeNotifySent = true\n+\t}\n+\treturn c.closeNotifyErr\n+}\n+\n // Handshake runs the client or server handshake\n // protocol if it has not yet been run.\n // Most uses of this package need not call Handshake\n@@ -1206,26 +1257,50 @@ func (c *Conn) Handshake() error {\n \t// need to check whether a handshake is pending (such as Write) to\n \t// block.\n \t//\n-\t// Thus we take c.handshakeMutex first and, if we find that a handshake\n-\t// is needed, then we unlock, acquire c.in and c.handshakeMutex in the\n-\t// correct order, and check again.\n+\t// Thus we first take c.handshakeMutex to check whether a handshake is\n+\t// needed.\n+\t//\n+\t// If so then, previously, this code would unlock handshakeMutex and\n+\t// then lock c.in and handshakeMutex in the correct order to run the\n+\t// handshake. The problem was that it was possible for a Read to\n+\t// complete the handshake once handshakeMutex was unlocked and then\n+\t// keep c.in while waiting for network data. Thus a concurrent\n+\t// operation could be blocked on c.in.\n+\t//\n+\t// Thus handshakeCond is used to signal that a goroutine is committed\n+\t// to running the handshake and other goroutines can wait on it if they\n+\t// need. handshakeCond is protected by handshakeMutex.\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \n-\tfor i := 0; i < 2; i++ {\n-\t\tif i == 1 {\n-\t\t\tc.handshakeMutex.Unlock()\n-\t\t\tc.in.Lock()\n-\t\t\tdefer c.in.Unlock()\n-\t\t\tc.handshakeMutex.Lock()\n-\t\t}\n-\n+\tfor {\n \t\tif err := c.handshakeErr; err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif c.handshakeComplete {\n \t\t\treturn nil\n \t\t}\n+\t\tif c.handshakeCond == nil {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tc.handshakeCond.Wait()\n+\t}\n+\n+\t// Set handshakeCond to indicate that this goroutine is committing to\n+\t// running the handshake.\n+\tc.handshakeCond = sync.NewCond(&c.handshakeMutex)\n+\tc.handshakeMutex.Unlock()\n+\n+\tc.in.Lock()\n+\tdefer c.in.Unlock()\n+\n+\tc.handshakeMutex.Lock()\n+\n+\t// The handshake cannot have completed when handshakeMutex was unlocked\n+\t// because this goroutine set handshakeCond.\n+\tif c.handshakeErr != nil || c.handshakeComplete {\n+\t\tpanic(\"handshake should not have been able to complete after handshakeCond was set\")\n \t}\n \n \tif c.isClient {\n@@ -1235,7 +1310,21 @@ func (c *Conn) Handshake() error {\n \t}\n \tif c.handshakeErr == nil {\n \t\tc.handshakes++\n+\t} else {\n+\t\t// If an error occurred during the hadshake try to flush the\n+\t\t// alert that might be left in the buffer.\n+\t\tc.flush()\n+\t}\n+\n+\tif c.handshakeErr == nil && !c.handshakeComplete {\n+\t\tpanic(\"handshake should have had a result.\")\n \t}\n+\n+\t// Wake any other goroutines that are waiting for this handshake to\n+\t// complete.\n+\tc.handshakeCond.Broadcast()\n+\tc.handshakeCond = nil\n+\n \treturn c.handshakeErr\n }\n \n@@ -1246,6 +1335,8 @@ func (c *Conn) ConnectionState() ConnectionState {\n \n \tvar state ConnectionState\n \tstate.HandshakeComplete = c.handshakeComplete\n+\tstate.ServerName = c.serverName\n+\n \tif c.handshakeComplete {\n \t\tstate.Version = c.vers\n \t\tstate.NegotiatedProtocol = c.clientProtocol\n@@ -1254,7 +1345,6 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.CipherSuite = c.cipherSuite\n \t\tstate.PeerCertificates = c.peerCertificates\n \t\tstate.VerifiedChains = c.verifiedChains\n-\t\tstate.ServerName = c.serverName\n \t\tstate.SignedCertificateTimestamps = c.scts\n \t\tstate.OCSPResponse = c.ocspResponse\n \t\tif !c.didResume {"}, {"sha": "5e5c7a2e96e9bf1e6b9b17930937898e2e58b60e", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -40,27 +40,27 @@ var paddingTests = []struct {\n \n func TestRemovePadding(t *testing.T) {\n \tfor i, test := range paddingTests {\n-\t\tpayload, good := removePadding(test.in)\n+\t\tpaddingLen, good := extractPadding(test.in)\n \t\texpectedGood := byte(255)\n \t\tif !test.good {\n \t\t\texpectedGood = 0\n \t\t}\n \t\tif good != expectedGood {\n \t\t\tt.Errorf(\"#%d: wrong validity, want:%d got:%d\", i, expectedGood, good)\n \t\t}\n-\t\tif good == 255 && len(payload) != test.expectedLen {\n-\t\t\tt.Errorf(\"#%d: got %d, want %d\", i, len(payload), test.expectedLen)\n+\t\tif good == 255 && len(test.in)-paddingLen != test.expectedLen {\n+\t\t\tt.Errorf(\"#%d: got %d, want %d\", i, len(test.in)-paddingLen, test.expectedLen)\n \t\t}\n \t}\n }\n \n-var certExampleCom = `308201403081eda003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313138353835325a170d3132303933303138353835325a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31a301830160603551d11040f300d820b6578616d706c652e636f6d300b06092a864886f70d0101050341001a0b419d2c74474c6450654e5f10b32bf426ffdf55cad1c52602e7a9151513a3424c70f5960dcd682db0c33769cc1daa3fcdd3db10809d2392ed4a1bf50ced18`\n+var certExampleCom = `308201713082011ba003020102021005a75ddf21014d5f417083b7a010ba2e300d06092a864886f70d01010b050030123110300e060355040a130741636d6520436f301e170d3136303831373231343135335a170d3137303831373231343135335a30123110300e060355040a130741636d6520436f305c300d06092a864886f70d0101010500034b003048024100b37f0fdd67e715bf532046ac34acbd8fdc4dabe2b598588f3f58b1f12e6219a16cbfe54d2b4b665396013589262360b6721efa27d546854f17cc9aeec6751db10203010001a34d304b300e0603551d0f0101ff0404030205a030130603551d25040c300a06082b06010505070301300c0603551d130101ff0402300030160603551d11040f300d820b6578616d706c652e636f6d300d06092a864886f70d01010b050003410059fc487866d3d855503c8e064ca32aac5e9babcece89ec597f8b2b24c17867f4a5d3b4ece06e795bfc5448ccbd2ffca1b3433171ebf3557a4737b020565350a0`\n \n-var certWildcardExampleCom = `308201423081efa003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303034365a170d3132303933303139303034365a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31c301a30180603551d110411300f820d2a2e6578616d706c652e636f6d300b06092a864886f70d0101050341001676f0c9e7c33c1b656ed5a6476c4e2ee9ec8e62df7407accb1875272b2edd0a22096cb2c22598d11604104d604f810eb4b5987ca6bb319c7e6ce48725c54059`\n+var certWildcardExampleCom = `308201743082011ea003020102021100a7aa6297c9416a4633af8bec2958c607300d06092a864886f70d01010b050030123110300e060355040a130741636d6520436f301e170d3136303831373231343231395a170d3137303831373231343231395a30123110300e060355040a130741636d6520436f305c300d06092a864886f70d0101010500034b003048024100b105afc859a711ee864114e7d2d46c2dcbe392d3506249f6c2285b0eb342cc4bf2d803677c61c0abde443f084745c1a6d62080e5664ef2cc8f50ad8a0ab8870b0203010001a34f304d300e0603551d0f0101ff0404030205a030130603551d25040c300a06082b06010505070301300c0603551d130101ff0402300030180603551d110411300f820d2a2e6578616d706c652e636f6d300d06092a864886f70d01010b0500034100af26088584d266e3f6566360cf862c7fecc441484b098b107439543144a2b93f20781988281e108c6d7656934e56950e1e5f2bcf38796b814ccb729445856c34`\n \n-var certFooExampleCom = `308201443081f1a003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303131345a170d3132303933303139303131345a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31e301c301a0603551d1104133011820f666f6f2e6578616d706c652e636f6d300b06092a864886f70d010105034100646a2a51f2aa2477add854b462cf5207ba16d3213ffb5d3d0eed473fbf09935019192d1d5b8ca6a2407b424cf04d97c4cd9197c83ecf81f0eab9464a1109d09f`\n+var certFooExampleCom = `308201753082011fa00302010202101bbdb6070b0aeffc49008cde74deef29300d06092a864886f70d01010b050030123110300e060355040a130741636d6520436f301e170d3136303831373231343234345a170d3137303831373231343234345a30123110300e060355040a130741636d6520436f305c300d06092a864886f70d0101010500034b003048024100f00ac69d8ca2829f26216c7b50f1d4bbabad58d447706476cd89a2f3e1859943748aa42c15eedc93ac7c49e40d3b05ed645cb6b81c4efba60d961f44211a54eb0203010001a351304f300e0603551d0f0101ff0404030205a030130603551d25040c300a06082b06010505070301300c0603551d130101ff04023000301a0603551d1104133011820f666f6f2e6578616d706c652e636f6d300d06092a864886f70d01010b0500034100a0957fca6d1e0f1ef4b247348c7a8ca092c29c9c0ecc1898ea6b8065d23af6d922a410dd2335a0ea15edd1394cef9f62c9e876a21e35250a0b4fe1ddceba0f36`\n \n-var certDoubleWildcardExampleCom = `308201443081f1a003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303134315a170d3132303933303139303134315a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31e301c301a0603551d1104133011820f2a2e2a2e6578616d706c652e636f6d300b06092a864886f70d0101050341001c3de267975f56ef57771c6218ef95ecc65102e57bd1defe6f7efea90d9b26cf40de5bd7ad75e46201c7f2a92aaa3e907451e9409f65e28ddb6db80d726290f6`\n+var certDoubleWildcardExampleCom = `308201753082011fa003020102021039d262d8538db8ffba30d204e02ddeb5300d06092a864886f70d01010b050030123110300e060355040a130741636d6520436f301e170d3136303831373231343331335a170d3137303831373231343331335a30123110300e060355040a130741636d6520436f305c300d06092a864886f70d0101010500034b003048024100abb6bd84b8b9be3fb9415d00f22b4ddcaec7c99855b9d818c09003e084578430e5cfd2e35faa3561f036d496aa43a9ca6e6cf23c72a763c04ae324004f6cbdbb0203010001a351304f300e0603551d0f0101ff0404030205a030130603551d25040c300a06082b06010505070301300c0603551d130101ff04023000301a0603551d1104133011820f2a2e2a2e6578616d706c652e636f6d300d06092a864886f70d01010b05000341004837521004a5b6bc7ad5d6c0dae60bb7ee0fa5e4825be35e2bb6ef07ee29396ca30ceb289431bcfd363888ba2207139933ac7c6369fa8810c819b2e2966abb4b`\n \n func TestCertificateSelection(t *testing.T) {\n \tconfig := Config{\n@@ -124,7 +124,7 @@ func TestCertificateSelection(t *testing.T) {\n func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n \tclientConn, serverConn := net.Pipe()\n \n-\tserverConfig := config.clone()\n+\tserverConfig := config.Clone()\n \tserverConfig.DynamicRecordSizingDisabled = false\n \ttlsConn := Server(serverConn, serverConfig)\n \n@@ -225,19 +225,19 @@ func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n }\n \n func TestDynamicRecordSizingWithStreamCipher(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}\n \trunDynamicRecordSizingTest(t, config)\n }\n \n func TestDynamicRecordSizingWithCBC(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.CipherSuites = []uint16{TLS_RSA_WITH_AES_256_CBC_SHA}\n \trunDynamicRecordSizingTest(t, config)\n }\n \n func TestDynamicRecordSizingWithAEAD(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}\n \trunDynamicRecordSizingTest(t, config)\n }"}, {"sha": "6eda18dbfce9eaaf86dd6b0c8d9a0bede2e17106", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 129, "deletions": 69, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -115,7 +115,7 @@ NextCipherSuite:\n \n \t// Session resumption is not allowed if renegotiating because\n \t// renegotiation is primarily used to allow a client to send a client\n-\t// certificate, which would be skipped if session resumption occured.\n+\t// certificate, which would be skipped if session resumption occurred.\n \tif sessionCache != nil && c.handshakes == 0 {\n \t\t// Try to resume a previously negotiated TLS session, if\n \t\t// available.\n@@ -199,7 +199,7 @@ NextCipherSuite:\n \t// Otherwise, in a full handshake, if we don't have any certificates\n \t// configured then we will never send a CertificateVerify message and\n \t// thus no signatures are needed in that case either.\n-\tif isResume || len(c.config.Certificates) == 0 {\n+\tif isResume || (len(c.config.Certificates) == 0 && c.config.GetClientCertificate == nil) {\n \t\ths.finishedHash.discardHandshakeBuffer()\n \t}\n \n@@ -304,6 +304,13 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t\t}\n \t\t}\n \n+\t\tif c.config.VerifyPeerCertificate != nil {\n+\t\t\tif err := c.config.VerifyPeerCertificate(certMsg.certificates, c.verifiedChains); err != nil {\n+\t\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\n \t\tswitch certs[0].PublicKey.(type) {\n \t\tcase *rsa.PublicKey, *ecdsa.PublicKey:\n \t\t\tbreak\n@@ -370,71 +377,11 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \tcertReq, ok := msg.(*certificateRequestMsg)\n \tif ok {\n \t\tcertRequested = true\n-\n-\t\t// RFC 4346 on the certificateAuthorities field:\n-\t\t// A list of the distinguished names of acceptable certificate\n-\t\t// authorities. These distinguished names may specify a desired\n-\t\t// distinguished name for a root CA or for a subordinate CA;\n-\t\t// thus, this message can be used to describe both known roots\n-\t\t// and a desired authorization space. If the\n-\t\t// certificate_authorities list is empty then the client MAY\n-\t\t// send any certificate of the appropriate\n-\t\t// ClientCertificateType, unless there is some external\n-\t\t// arrangement to the contrary.\n-\n \t\ths.finishedHash.Write(certReq.marshal())\n \n-\t\tvar rsaAvail, ecdsaAvail bool\n-\t\tfor _, certType := range certReq.certificateTypes {\n-\t\t\tswitch certType {\n-\t\t\tcase certTypeRSASign:\n-\t\t\t\trsaAvail = true\n-\t\t\tcase certTypeECDSASign:\n-\t\t\t\tecdsaAvail = true\n-\t\t\t}\n-\t\t}\n-\n-\t\t// We need to search our list of client certs for one\n-\t\t// where SignatureAlgorithm is acceptable to the server and the\n-\t\t// Issuer is in certReq.certificateAuthorities\n-\tfindCert:\n-\t\tfor i, chain := range c.config.Certificates {\n-\t\t\tif !rsaAvail && !ecdsaAvail {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tfor j, cert := range chain.Certificate {\n-\t\t\t\tx509Cert := chain.Leaf\n-\t\t\t\t// parse the certificate if this isn't the leaf\n-\t\t\t\t// node, or if chain.Leaf was nil\n-\t\t\t\tif j != 0 || x509Cert == nil {\n-\t\t\t\t\tif x509Cert, err = x509.ParseCertificate(cert); err != nil {\n-\t\t\t\t\t\tc.sendAlert(alertInternalError)\n-\t\t\t\t\t\treturn errors.New(\"tls: failed to parse client certificate #\" + strconv.Itoa(i) + \": \" + err.Error())\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tswitch {\n-\t\t\t\tcase rsaAvail && x509Cert.PublicKeyAlgorithm == x509.RSA:\n-\t\t\t\tcase ecdsaAvail && x509Cert.PublicKeyAlgorithm == x509.ECDSA:\n-\t\t\t\tdefault:\n-\t\t\t\t\tcontinue findCert\n-\t\t\t\t}\n-\n-\t\t\t\tif len(certReq.certificateAuthorities) == 0 {\n-\t\t\t\t\t// they gave us an empty list, so just take the\n-\t\t\t\t\t// first cert from c.config.Certificates\n-\t\t\t\t\tchainToSend = &chain\n-\t\t\t\t\tbreak findCert\n-\t\t\t\t}\n-\n-\t\t\t\tfor _, ca := range certReq.certificateAuthorities {\n-\t\t\t\t\tif bytes.Equal(x509Cert.RawIssuer, ca) {\n-\t\t\t\t\t\tchainToSend = &chain\n-\t\t\t\t\t\tbreak findCert\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif chainToSend, err = hs.getCertificate(certReq); err != nil {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn err\n \t\t}\n \n \t\tmsg, err = c.readHandshake()\n@@ -455,9 +402,7 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t// certificate to send.\n \tif certRequested {\n \t\tcertMsg = new(certificateMsg)\n-\t\tif chainToSend != nil {\n-\t\t\tcertMsg.certificates = chainToSend.Certificate\n-\t\t}\n+\t\tcertMsg.certificates = chainToSend.Certificate\n \t\ths.finishedHash.Write(certMsg.marshal())\n \t\tif _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {\n \t\t\treturn err\n@@ -476,7 +421,7 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t}\n \t}\n \n-\tif chainToSend != nil {\n+\tif chainToSend != nil && len(chainToSend.Certificate) > 0 {\n \t\tcertVerify := &certificateVerifyMsg{\n \t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n \t\t}\n@@ -521,6 +466,10 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t}\n \n \ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.hello.random, hs.serverHello.random)\n+\tif err := c.config.writeKeyLog(hs.hello.random, hs.masterSecret); err != nil {\n+\t\tc.sendAlert(alertInternalError)\n+\t\treturn errors.New(\"tls: failed to write to key log: \" + err.Error())\n+\t}\n \n \ths.finishedHash.discardHandshakeBuffer()\n \n@@ -716,6 +665,117 @@ func (hs *clientHandshakeState) sendFinished(out []byte) error {\n \treturn nil\n }\n \n+// tls11SignatureSchemes contains the signature schemes that we synthesise for\n+// a TLS <= 1.1 connection, based on the supported certificate types.\n+var tls11SignatureSchemes = []SignatureScheme{ECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512, PKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1}\n+\n+const (\n+\t// tls11SignatureSchemesNumECDSA is the number of initial elements of\n+\t// tls11SignatureSchemes that use ECDSA.\n+\ttls11SignatureSchemesNumECDSA = 3\n+\t// tls11SignatureSchemesNumRSA is the number of trailing elements of\n+\t// tls11SignatureSchemes that use RSA.\n+\ttls11SignatureSchemesNumRSA = 4\n+)\n+\n+func (hs *clientHandshakeState) getCertificate(certReq *certificateRequestMsg) (*Certificate, error) {\n+\tc := hs.c\n+\n+\tvar rsaAvail, ecdsaAvail bool\n+\tfor _, certType := range certReq.certificateTypes {\n+\t\tswitch certType {\n+\t\tcase certTypeRSASign:\n+\t\t\trsaAvail = true\n+\t\tcase certTypeECDSASign:\n+\t\t\tecdsaAvail = true\n+\t\t}\n+\t}\n+\n+\tif c.config.GetClientCertificate != nil {\n+\t\tvar signatureSchemes []SignatureScheme\n+\n+\t\tif !certReq.hasSignatureAndHash {\n+\t\t\t// Prior to TLS 1.2, the signature schemes were not\n+\t\t\t// included in the certificate request message. In this\n+\t\t\t// case we use a plausible list based on the acceptable\n+\t\t\t// certificate types.\n+\t\t\tsignatureSchemes = tls11SignatureSchemes\n+\t\t\tif !ecdsaAvail {\n+\t\t\t\tsignatureSchemes = signatureSchemes[tls11SignatureSchemesNumECDSA:]\n+\t\t\t}\n+\t\t\tif !rsaAvail {\n+\t\t\t\tsignatureSchemes = signatureSchemes[:len(signatureSchemes)-tls11SignatureSchemesNumRSA]\n+\t\t\t}\n+\t\t} else {\n+\t\t\tsignatureSchemes = make([]SignatureScheme, 0, len(certReq.signatureAndHashes))\n+\t\t\tfor _, sah := range certReq.signatureAndHashes {\n+\t\t\t\tsignatureSchemes = append(signatureSchemes, SignatureScheme(sah.hash)<<8+SignatureScheme(sah.signature))\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn c.config.GetClientCertificate(&CertificateRequestInfo{\n+\t\t\tAcceptableCAs:    certReq.certificateAuthorities,\n+\t\t\tSignatureSchemes: signatureSchemes,\n+\t\t})\n+\t}\n+\n+\t// RFC 4346 on the certificateAuthorities field: A list of the\n+\t// distinguished names of acceptable certificate authorities.\n+\t// These distinguished names may specify a desired\n+\t// distinguished name for a root CA or for a subordinate CA;\n+\t// thus, this message can be used to describe both known roots\n+\t// and a desired authorization space. If the\n+\t// certificate_authorities list is empty then the client MAY\n+\t// send any certificate of the appropriate\n+\t// ClientCertificateType, unless there is some external\n+\t// arrangement to the contrary.\n+\n+\t// We need to search our list of client certs for one\n+\t// where SignatureAlgorithm is acceptable to the server and the\n+\t// Issuer is in certReq.certificateAuthorities\n+findCert:\n+\tfor i, chain := range c.config.Certificates {\n+\t\tif !rsaAvail && !ecdsaAvail {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor j, cert := range chain.Certificate {\n+\t\t\tx509Cert := chain.Leaf\n+\t\t\t// parse the certificate if this isn't the leaf\n+\t\t\t// node, or if chain.Leaf was nil\n+\t\t\tif j != 0 || x509Cert == nil {\n+\t\t\t\tvar err error\n+\t\t\t\tif x509Cert, err = x509.ParseCertificate(cert); err != nil {\n+\t\t\t\t\tc.sendAlert(alertInternalError)\n+\t\t\t\t\treturn nil, errors.New(\"tls: failed to parse client certificate #\" + strconv.Itoa(i) + \": \" + err.Error())\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tswitch {\n+\t\t\tcase rsaAvail && x509Cert.PublicKeyAlgorithm == x509.RSA:\n+\t\t\tcase ecdsaAvail && x509Cert.PublicKeyAlgorithm == x509.ECDSA:\n+\t\t\tdefault:\n+\t\t\t\tcontinue findCert\n+\t\t\t}\n+\n+\t\t\tif len(certReq.certificateAuthorities) == 0 {\n+\t\t\t\t// they gave us an empty list, so just take the\n+\t\t\t\t// first cert from c.config.Certificates\n+\t\t\t\treturn &chain, nil\n+\t\t\t}\n+\n+\t\t\tfor _, ca := range certReq.certificateAuthorities {\n+\t\t\t\tif bytes.Equal(x509Cert.RawIssuer, ca) {\n+\t\t\t\t\treturn &chain, nil\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// No acceptable certificate found. Don't send a certificate.\n+\treturn new(Certificate), nil\n+}\n+\n // clientSessionCacheKey returns a key used to cache sessionTickets that could\n // be used to resume previously negotiated TLS sessions with a server.\n func clientSessionCacheKey(serverAddr net.Addr, config *Config) string {"}, {"sha": "5851f897f96932502968e0881e778963447aaf13", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 555, "deletions": 37, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -15,12 +15,14 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"math/big\"\n \t\"net\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -76,7 +78,7 @@ func newOpensslOutputSink() *opensslOutputSink {\n \n // opensslEndOfHandshake is a message that the \u201copenssl s_server\u201d tool will\n // print when a handshake completes if run with \u201c-state\u201d.\n-const opensslEndOfHandshake = \"SSL_accept:SSLv3 write finished A\"\n+const opensslEndOfHandshake = \"SSL_accept:SSLv3/TLS write finished\"\n \n func (o *opensslOutputSink) Write(data []byte) (n int, err error) {\n \to.line = append(o.line, data...)\n@@ -275,6 +277,8 @@ func (test *clientTest) loadData() (flows [][]byte, err error) {\n }\n \n func (test *clientTest) run(t *testing.T, write bool) {\n+\tcheckOpenSSLVersion(t)\n+\n \tvar clientConn, serverConn net.Conn\n \tvar recordingConn *recordingConn\n \tvar childProcess *exec.Cmd\n@@ -355,7 +359,7 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \t\t\t\t}\n \n \t\t\t\tif expected := i + 1; client.handshakes != expected {\n-\t\t\t\t\tt.Errorf(\"client should have recorded %d handshakes, but believes that %d have occured\", expected, client.handshakes)\n+\t\t\t\t\tt.Errorf(\"client should have recorded %d handshakes, but believes that %d have occurred\", expected, client.handshakes)\n \t\t\t\t}\n \t\t\t}()\n \n@@ -409,15 +413,34 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \t\tchildProcess.Process.Kill()\n \t\tchildProcess.Wait()\n \t\tif len(recordingConn.flows) < 3 {\n-\t\t\tchildProcess.Stdout.(*bytes.Buffer).WriteTo(os.Stdout)\n+\t\t\tos.Stdout.Write(childProcess.Stdout.(*opensslOutputSink).all)\n \t\t\tt.Fatalf(\"Client connection didn't work\")\n \t\t}\n \t\trecordingConn.WriteTo(out)\n \t\tfmt.Printf(\"Wrote %s\\n\", path)\n \t}\n }\n \n+var (\n+\tdidParMu sync.Mutex\n+\tdidPar   = map[*testing.T]bool{}\n+)\n+\n+// setParallel calls t.Parallel once. If you call it twice, it would\n+// panic.\n+func setParallel(t *testing.T) {\n+\tdidParMu.Lock()\n+\tv := didPar[t]\n+\tdidPar[t] = true\n+\tdidParMu.Unlock()\n+\tif !v {\n+\t\tt.Parallel()\n+\t}\n+}\n+\n func runClientTestForVersion(t *testing.T, template *clientTest, prefix, option string) {\n+\tsetParallel(t)\n+\n \ttest := *template\n \ttest.name = prefix + test.name\n \tif len(test.command) == 0 {\n@@ -508,14 +531,81 @@ func TestHandshakeClientAES256GCMSHA384(t *testing.T) {\n \trunClientTestTLS12(t, test)\n }\n \n+func TestHandshakeClientAES128CBCSHA256(t *testing.T) {\n+\ttest := &clientTest{\n+\t\tname:    \"AES128-SHA256\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"AES128-SHA256\"},\n+\t}\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientECDHERSAAES128CBCSHA256(t *testing.T) {\n+\ttest := &clientTest{\n+\t\tname:    \"ECDHE-RSA-AES128-SHA256\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-RSA-AES128-SHA256\"},\n+\t}\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientECDHEECDSAAES128CBCSHA256(t *testing.T) {\n+\ttest := &clientTest{\n+\t\tname:    \"ECDHE-ECDSA-AES128-SHA256\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-ECDSA-AES128-SHA256\"},\n+\t\tcert:    testECDSACertificate,\n+\t\tkey:     testECDSAPrivateKey,\n+\t}\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientX25519(t *testing.T) {\n+\tconfig := testConfig.Clone()\n+\tconfig.CurvePreferences = []CurveID{X25519}\n+\n+\ttest := &clientTest{\n+\t\tname:    \"X25519-ECDHE-RSA-AES-GCM\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\"},\n+\t\tconfig:  config,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientECDHERSAChaCha20(t *testing.T) {\n+\tconfig := testConfig.Clone()\n+\tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305}\n+\n+\ttest := &clientTest{\n+\t\tname:    \"ECDHE-RSA-CHACHA20-POLY1305\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-RSA-CHACHA20-POLY1305\"},\n+\t\tconfig:  config,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientECDHEECDSAChaCha20(t *testing.T) {\n+\tconfig := testConfig.Clone()\n+\tconfig.CipherSuites = []uint16{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305}\n+\n+\ttest := &clientTest{\n+\t\tname:    \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-ECDSA-CHACHA20-POLY1305\"},\n+\t\tconfig:  config,\n+\t\tcert:    testECDSACertificate,\n+\t\tkey:     testECDSAPrivateKey,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n func TestHandshakeClientCertRSA(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n \tconfig.Certificates = []Certificate{cert}\n \n \ttest := &clientTest{\n \t\tname:    \"ClientCert-RSA-RSA\",\n-\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"RC4-SHA\", \"-verify\", \"1\"},\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"AES128\", \"-verify\", \"1\"},\n \t\tconfig:  config,\n \t}\n \n@@ -545,13 +635,13 @@ func TestHandshakeClientCertRSA(t *testing.T) {\n }\n \n func TestHandshakeClientCertECDSA(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tcert, _ := X509KeyPair([]byte(clientECDSACertificatePEM), []byte(clientECDSAKeyPEM))\n \tconfig.Certificates = []Certificate{cert}\n \n \ttest := &clientTest{\n \t\tname:    \"ClientCert-ECDSA-RSA\",\n-\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"RC4-SHA\", \"-verify\", \"1\"},\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"AES128\", \"-verify\", \"1\"},\n \t\tconfig:  config,\n \t}\n \n@@ -622,20 +712,31 @@ func TestClientResumption(t *testing.T) {\n \t\tt.Fatal(\"first ticket doesn't match ticket after resumption\")\n \t}\n \n-\tkey2 := randomKey()\n-\tserverConfig.SetSessionTicketKeys([][32]byte{key2})\n+\tkey1 := randomKey()\n+\tserverConfig.SetSessionTicketKeys([][32]byte{key1})\n \n \ttestResumeState(\"InvalidSessionTicketKey\", false)\n \ttestResumeState(\"ResumeAfterInvalidSessionTicketKey\", true)\n \n-\tserverConfig.SetSessionTicketKeys([][32]byte{randomKey(), key2})\n+\tkey2 := randomKey()\n+\tserverConfig.SetSessionTicketKeys([][32]byte{key2, key1})\n \tticket = getTicket()\n \ttestResumeState(\"KeyChange\", true)\n \tif bytes.Equal(ticket, getTicket()) {\n \t\tt.Fatal(\"new ticket wasn't included while resuming\")\n \t}\n \ttestResumeState(\"KeyChangeFinish\", true)\n \n+\t// Reset serverConfig to ensure that calling SetSessionTicketKeys\n+\t// before the serverConfig is used works.\n+\tserverConfig = &Config{\n+\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n+\t\tCertificates: testConfig.Certificates,\n+\t}\n+\tserverConfig.SetSessionTicketKeys([][32]byte{key2})\n+\n+\ttestResumeState(\"FreshConfig\", true)\n+\n \tclientConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n \ttestResumeState(\"DifferentCipherSuite\", false)\n \ttestResumeState(\"DifferentCipherSuiteRecovers\", true)\n@@ -690,8 +791,59 @@ func TestLRUClientSessionCache(t *testing.T) {\n \t}\n }\n \n+func TestKeyLog(t *testing.T) {\n+\tvar serverBuf, clientBuf bytes.Buffer\n+\n+\tclientConfig := testConfig.Clone()\n+\tclientConfig.KeyLogWriter = &clientBuf\n+\n+\tserverConfig := testConfig.Clone()\n+\tserverConfig.KeyLogWriter = &serverBuf\n+\n+\tc, s := net.Pipe()\n+\tdone := make(chan bool)\n+\n+\tgo func() {\n+\t\tdefer close(done)\n+\n+\t\tif err := Server(s, serverConfig).Handshake(); err != nil {\n+\t\t\tt.Errorf(\"server: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\t\ts.Close()\n+\t}()\n+\n+\tif err := Client(c, clientConfig).Handshake(); err != nil {\n+\t\tt.Fatalf(\"client: %s\", err)\n+\t}\n+\n+\tc.Close()\n+\t<-done\n+\n+\tcheckKeylogLine := func(side, loggedLine string) {\n+\t\tif len(loggedLine) == 0 {\n+\t\t\tt.Fatalf(\"%s: no keylog line was produced\", side)\n+\t\t}\n+\t\tconst expectedLen = 13 /* \"CLIENT_RANDOM\" */ +\n+\t\t\t1 /* space */ +\n+\t\t\t32*2 /* hex client nonce */ +\n+\t\t\t1 /* space */ +\n+\t\t\t48*2 /* hex master secret */ +\n+\t\t\t1 /* new line */\n+\t\tif len(loggedLine) != expectedLen {\n+\t\t\tt.Fatalf(\"%s: keylog line has incorrect length (want %d, got %d): %q\", side, expectedLen, len(loggedLine), loggedLine)\n+\t\t}\n+\t\tif !strings.HasPrefix(loggedLine, \"CLIENT_RANDOM \"+strings.Repeat(\"0\", 64)+\" \") {\n+\t\t\tt.Fatalf(\"%s: keylog line has incorrect structure or nonce: %q\", side, loggedLine)\n+\t\t}\n+\t}\n+\n+\tcheckKeylogLine(\"client\", string(clientBuf.Bytes()))\n+\tcheckKeylogLine(\"server\", string(serverBuf.Bytes()))\n+}\n+\n func TestHandshakeClientALPNMatch(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.NextProtos = []string{\"proto2\", \"proto1\"}\n \n \ttest := &clientTest{\n@@ -711,32 +863,11 @@ func TestHandshakeClientALPNMatch(t *testing.T) {\n \trunClientTestTLS12(t, test)\n }\n \n-func TestHandshakeClientALPNNoMatch(t *testing.T) {\n-\tconfig := testConfig.clone()\n-\tconfig.NextProtos = []string{\"proto3\"}\n-\n-\ttest := &clientTest{\n-\t\tname: \"ALPN-NoMatch\",\n-\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n-\t\t// version that supports the -alpn flag.\n-\t\tcommand: []string{\"openssl\", \"s_server\", \"-alpn\", \"proto1,proto2\"},\n-\t\tconfig:  config,\n-\t\tvalidate: func(state ConnectionState) error {\n-\t\t\t// There's no overlap so OpenSSL will not select a protocol.\n-\t\t\tif state.NegotiatedProtocol != \"\" {\n-\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted ''\", state.NegotiatedProtocol)\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t},\n-\t}\n-\trunClientTestTLS12(t, test)\n-}\n-\n // sctsBase64 contains data from `openssl s_client -serverinfo 18 -connect ritter.vg:443`\n const sctsBase64 = \"ABIBaQFnAHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFHl5nuFgAABAMARjBEAiAcS4JdlW5nW9sElUv2zvQyPoZ6ejKrGGB03gjaBZFMLwIgc1Qbbn+hsH0RvObzhS+XZhr3iuQQJY8S9G85D9KeGPAAdgBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAUeX4bVwAAAEAwBHMEUCIDIhFDgG2HIuADBkGuLobU5a4dlCHoJLliWJ1SYT05z6AiEAjxIoZFFPRNWMGGIjskOTMwXzQ1Wh2e7NxXE1kd1J0QsAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMAxHuJeqj9ywAAAUhcZIqHAAAEAwBHMEUCICmJ1rBT09LpkbzxtUC+Hi7nXLR0J+2PmwLp+sJMuqK+AiEAr0NkUnEVKVhAkccIFpYDqHOlZaBsuEhWWrYpg2RtKp0=\"\n \n func TestHandshakClientSCTs(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \n \tscts, err := base64.StdEncoding.DecodeString(sctsBase64)\n \tif err != nil {\n@@ -771,7 +902,7 @@ func TestHandshakClientSCTs(t *testing.T) {\n }\n \n func TestRenegotiationRejected(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \ttest := &clientTest{\n \t\tname:                        \"RenegotiationRejected\",\n \t\tcommand:                     []string{\"openssl\", \"s_server\", \"-state\"},\n@@ -793,7 +924,7 @@ func TestRenegotiationRejected(t *testing.T) {\n }\n \n func TestRenegotiateOnce(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.Renegotiation = RenegotiateOnceAsClient\n \n \ttest := &clientTest{\n@@ -807,7 +938,7 @@ func TestRenegotiateOnce(t *testing.T) {\n }\n \n func TestRenegotiateTwice(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.Renegotiation = RenegotiateFreelyAsClient\n \n \ttest := &clientTest{\n@@ -821,7 +952,7 @@ func TestRenegotiateTwice(t *testing.T) {\n }\n \n func TestRenegotiateTwiceRejected(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.Renegotiation = RenegotiateOnceAsClient\n \n \ttest := &clientTest{\n@@ -956,6 +1087,160 @@ func TestServerSelectingUnconfiguredCipherSuite(t *testing.T) {\n \t}\n }\n \n+func TestVerifyPeerCertificate(t *testing.T) {\n+\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\trootCAs := x509.NewCertPool()\n+\trootCAs.AddCert(issuer)\n+\n+\tnow := func() time.Time { return time.Unix(1476984729, 0) }\n+\n+\tsentinelErr := errors.New(\"TestVerifyPeerCertificate\")\n+\n+\tverifyCallback := func(called *bool, rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\tif l := len(rawCerts); l != 1 {\n+\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n+\t\t}\n+\t\tif len(validatedChains) == 0 {\n+\t\t\treturn errors.New(\"got len(validatedChains) = 0, wanted non-zero\")\n+\t\t}\n+\t\t*called = true\n+\t\treturn nil\n+\t}\n+\n+\ttests := []struct {\n+\t\tconfigureServer func(*Config, *bool)\n+\t\tconfigureClient func(*Config, *bool)\n+\t\tvalidate        func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error)\n+\t}{\n+\t\t{\n+\t\t\tconfigureServer: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = false\n+\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\t\t\t\treturn verifyCallback(called, rawCerts, validatedChains)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tconfigureClient: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = false\n+\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\t\t\t\treturn verifyCallback(called, rawCerts, validatedChains)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n+\t\t\t\tif clientErr != nil {\n+\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n+\t\t\t\t}\n+\t\t\t\tif serverErr != nil {\n+\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n+\t\t\t\t}\n+\t\t\t\tif !clientCalled {\n+\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n+\t\t\t\t}\n+\t\t\t\tif !serverCalled {\n+\t\t\t\t\tt.Errorf(\"test[%d]: server did not call callback\", testNo)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tconfigureServer: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = false\n+\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\t\t\t\treturn sentinelErr\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tconfigureClient: func(config *Config, called *bool) {\n+\t\t\t\tconfig.VerifyPeerCertificate = nil\n+\t\t\t},\n+\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n+\t\t\t\tif serverErr != sentinelErr {\n+\t\t\t\t\tt.Errorf(\"#%d: got server error %v, wanted sentinelErr\", testNo, serverErr)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tconfigureServer: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = false\n+\t\t\t},\n+\t\t\tconfigureClient: func(config *Config, called *bool) {\n+\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\t\t\t\treturn sentinelErr\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n+\t\t\t\tif clientErr != sentinelErr {\n+\t\t\t\t\tt.Errorf(\"#%d: got client error %v, wanted sentinelErr\", testNo, clientErr)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tconfigureServer: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = false\n+\t\t\t},\n+\t\t\tconfigureClient: func(config *Config, called *bool) {\n+\t\t\t\tconfig.InsecureSkipVerify = true\n+\t\t\t\tconfig.VerifyPeerCertificate = func(rawCerts [][]byte, validatedChains [][]*x509.Certificate) error {\n+\t\t\t\t\tif l := len(rawCerts); l != 1 {\n+\t\t\t\t\t\treturn fmt.Errorf(\"got len(rawCerts) = %d, wanted 1\", l)\n+\t\t\t\t\t}\n+\t\t\t\t\t// With InsecureSkipVerify set, this\n+\t\t\t\t\t// callback should still be called but\n+\t\t\t\t\t// validatedChains must be empty.\n+\t\t\t\t\tif l := len(validatedChains); l != 0 {\n+\t\t\t\t\t\treturn errors.New(\"got len(validatedChains) = 0, wanted zero\")\n+\t\t\t\t\t}\n+\t\t\t\t\t*called = true\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tvalidate: func(t *testing.T, testNo int, clientCalled, serverCalled bool, clientErr, serverErr error) {\n+\t\t\t\tif clientErr != nil {\n+\t\t\t\t\tt.Errorf(\"test[%d]: client handshake failed: %v\", testNo, clientErr)\n+\t\t\t\t}\n+\t\t\t\tif serverErr != nil {\n+\t\t\t\t\tt.Errorf(\"test[%d]: server handshake failed: %v\", testNo, serverErr)\n+\t\t\t\t}\n+\t\t\t\tif !clientCalled {\n+\t\t\t\t\tt.Errorf(\"test[%d]: client did not call callback\", testNo)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor i, test := range tests {\n+\t\tc, s := net.Pipe()\n+\t\tdone := make(chan error)\n+\n+\t\tvar clientCalled, serverCalled bool\n+\n+\t\tgo func() {\n+\t\t\tconfig := testConfig.Clone()\n+\t\t\tconfig.ServerName = \"example.golang\"\n+\t\t\tconfig.ClientAuth = RequireAndVerifyClientCert\n+\t\t\tconfig.ClientCAs = rootCAs\n+\t\t\tconfig.Time = now\n+\t\t\ttest.configureServer(config, &serverCalled)\n+\n+\t\t\terr = Server(s, config).Handshake()\n+\t\t\ts.Close()\n+\t\t\tdone <- err\n+\t\t}()\n+\n+\t\tconfig := testConfig.Clone()\n+\t\tconfig.ServerName = \"example.golang\"\n+\t\tconfig.RootCAs = rootCAs\n+\t\tconfig.Time = now\n+\t\ttest.configureClient(config, &clientCalled)\n+\t\tclientErr := Client(c, config).Handshake()\n+\t\tc.Close()\n+\t\tserverErr := <-done\n+\n+\t\ttest.validate(t, i, clientCalled, serverCalled, clientErr, serverErr)\n+\t}\n+}\n+\n // brokenConn wraps a net.Conn and causes all Writes after a certain number to\n // fail with brokenConnErr.\n type brokenConn struct {\n@@ -1045,3 +1330,236 @@ func TestBuffering(t *testing.T) {\n \t\tt.Errorf(\"expected server handshake to complete with only two writes, but saw %d\", n)\n \t}\n }\n+\n+func TestAlertFlushing(t *testing.T) {\n+\tc, s := net.Pipe()\n+\tdone := make(chan bool)\n+\n+\tclientWCC := &writeCountingConn{Conn: c}\n+\tserverWCC := &writeCountingConn{Conn: s}\n+\n+\tserverConfig := testConfig.Clone()\n+\n+\t// Cause a signature-time error\n+\tbrokenKey := rsa.PrivateKey{PublicKey: testRSAPrivateKey.PublicKey}\n+\tbrokenKey.D = big.NewInt(42)\n+\tserverConfig.Certificates = []Certificate{{\n+\t\tCertificate: [][]byte{testRSACertificate},\n+\t\tPrivateKey:  &brokenKey,\n+\t}}\n+\n+\tgo func() {\n+\t\tServer(serverWCC, serverConfig).Handshake()\n+\t\tserverWCC.Close()\n+\t\tdone <- true\n+\t}()\n+\n+\terr := Client(clientWCC, testConfig).Handshake()\n+\tif err == nil {\n+\t\tt.Fatal(\"client unexpectedly returned no error\")\n+\t}\n+\n+\tconst expectedError = \"remote error: tls: handshake failure\"\n+\tif e := err.Error(); !strings.Contains(e, expectedError) {\n+\t\tt.Fatalf(\"expected to find %q in error but error was %q\", expectedError, e)\n+\t}\n+\tclientWCC.Close()\n+\t<-done\n+\n+\tif n := clientWCC.numWrites; n != 1 {\n+\t\tt.Errorf(\"expected client handshake to complete with one write, but saw %d\", n)\n+\t}\n+\n+\tif n := serverWCC.numWrites; n != 1 {\n+\t\tt.Errorf(\"expected server handshake to complete with one write, but saw %d\", n)\n+\t}\n+}\n+\n+func TestHandshakeRace(t *testing.T) {\n+\tt.Parallel()\n+\t// This test races a Read and Write to try and complete a handshake in\n+\t// order to provide some evidence that there are no races or deadlocks\n+\t// in the handshake locking.\n+\tfor i := 0; i < 32; i++ {\n+\t\tc, s := net.Pipe()\n+\n+\t\tgo func() {\n+\t\t\tserver := Server(s, testConfig)\n+\t\t\tif err := server.Handshake(); err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\n+\t\t\tvar request [1]byte\n+\t\t\tif n, err := server.Read(request[:]); err != nil || n != 1 {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\n+\t\t\tserver.Write(request[:])\n+\t\t\tserver.Close()\n+\t\t}()\n+\n+\t\tstartWrite := make(chan struct{})\n+\t\tstartRead := make(chan struct{})\n+\t\treadDone := make(chan struct{})\n+\n+\t\tclient := Client(c, testConfig)\n+\t\tgo func() {\n+\t\t\t<-startWrite\n+\t\t\tvar request [1]byte\n+\t\t\tclient.Write(request[:])\n+\t\t}()\n+\n+\t\tgo func() {\n+\t\t\t<-startRead\n+\t\t\tvar reply [1]byte\n+\t\t\tif n, err := client.Read(reply[:]); err != nil || n != 1 {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tc.Close()\n+\t\t\treadDone <- struct{}{}\n+\t\t}()\n+\n+\t\tif i&1 == 1 {\n+\t\t\tstartWrite <- struct{}{}\n+\t\t\tstartRead <- struct{}{}\n+\t\t} else {\n+\t\t\tstartRead <- struct{}{}\n+\t\t\tstartWrite <- struct{}{}\n+\t\t}\n+\t\t<-readDone\n+\t}\n+}\n+\n+func TestTLS11SignatureSchemes(t *testing.T) {\n+\texpected := tls11SignatureSchemesNumECDSA + tls11SignatureSchemesNumRSA\n+\tif expected != len(tls11SignatureSchemes) {\n+\t\tt.Errorf(\"expected to find %d TLS 1.1 signature schemes, but found %d\", expected, len(tls11SignatureSchemes))\n+\t}\n+}\n+\n+var getClientCertificateTests = []struct {\n+\tsetup               func(*Config)\n+\texpectedClientError string\n+\tverify              func(*testing.T, int, *ConnectionState)\n+}{\n+\t{\n+\t\tfunc(clientConfig *Config) {\n+\t\t\t// Returning a Certificate with no certificate data\n+\t\t\t// should result in an empty message being sent to the\n+\t\t\t// server.\n+\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n+\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n+\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n+\t\t\t\t}\n+\t\t\t\treturn new(Certificate), nil\n+\t\t\t}\n+\t\t},\n+\t\t\"\",\n+\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n+\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n+\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n+\t\t\t}\n+\t\t},\n+\t},\n+\t{\n+\t\tfunc(clientConfig *Config) {\n+\t\t\t// With TLS 1.1, the SignatureSchemes should be\n+\t\t\t// synthesised from the supported certificate types.\n+\t\t\tclientConfig.MaxVersion = VersionTLS11\n+\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n+\t\t\t\tif len(cri.SignatureSchemes) == 0 {\n+\t\t\t\t\tpanic(\"empty SignatureSchemes\")\n+\t\t\t\t}\n+\t\t\t\treturn new(Certificate), nil\n+\t\t\t}\n+\t\t},\n+\t\t\"\",\n+\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n+\t\t\tif l := len(cs.PeerCertificates); l != 0 {\n+\t\t\t\tt.Errorf(\"#%d: expected no certificates but got %d\", testNum, l)\n+\t\t\t}\n+\t\t},\n+\t},\n+\t{\n+\t\tfunc(clientConfig *Config) {\n+\t\t\t// Returning an error should abort the handshake with\n+\t\t\t// that error.\n+\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n+\t\t\t\treturn nil, errors.New(\"GetClientCertificate\")\n+\t\t\t}\n+\t\t},\n+\t\t\"GetClientCertificate\",\n+\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n+\t\t},\n+\t},\n+\t{\n+\t\tfunc(clientConfig *Config) {\n+\t\t\tclientConfig.GetClientCertificate = func(cri *CertificateRequestInfo) (*Certificate, error) {\n+\t\t\t\treturn &testConfig.Certificates[0], nil\n+\t\t\t}\n+\t\t},\n+\t\t\"\",\n+\t\tfunc(t *testing.T, testNum int, cs *ConnectionState) {\n+\t\t\tif l := len(cs.VerifiedChains); l != 0 {\n+\t\t\t\tt.Errorf(\"#%d: expected some verified chains, but found none\", testNum)\n+\t\t\t}\n+\t\t},\n+\t},\n+}\n+\n+func TestGetClientCertificate(t *testing.T) {\n+\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tfor i, test := range getClientCertificateTests {\n+\t\tserverConfig := testConfig.Clone()\n+\t\tserverConfig.ClientAuth = RequestClientCert\n+\t\tserverConfig.RootCAs = x509.NewCertPool()\n+\t\tserverConfig.RootCAs.AddCert(issuer)\n+\n+\t\tclientConfig := testConfig.Clone()\n+\n+\t\ttest.setup(clientConfig)\n+\n+\t\ttype serverResult struct {\n+\t\t\tcs  ConnectionState\n+\t\t\terr error\n+\t\t}\n+\n+\t\tc, s := net.Pipe()\n+\t\tdone := make(chan serverResult)\n+\n+\t\tgo func() {\n+\t\t\tdefer s.Close()\n+\t\t\tserver := Server(s, serverConfig)\n+\t\t\terr := server.Handshake()\n+\n+\t\t\tvar cs ConnectionState\n+\t\t\tif err == nil {\n+\t\t\t\tcs = server.ConnectionState()\n+\t\t\t}\n+\t\t\tdone <- serverResult{cs, err}\n+\t\t}()\n+\n+\t\tclientErr := Client(c, clientConfig).Handshake()\n+\t\tc.Close()\n+\n+\t\tresult := <-done\n+\n+\t\tif clientErr != nil {\n+\t\t\tif len(test.expectedClientError) == 0 {\n+\t\t\t\tt.Errorf(\"#%d: client error: %v\", i, clientErr)\n+\t\t\t} else if got := clientErr.Error(); got != test.expectedClientError {\n+\t\t\t\tt.Errorf(\"#%d: expected client error %q, but got %q\", i, test.expectedClientError, got)\n+\t\t\t}\n+\t\t} else if len(test.expectedClientError) > 0 {\n+\t\t\tt.Errorf(\"#%d: expected client error %q, but got no error\", i, test.expectedClientError)\n+\t\t} else if err := result.err; err != nil {\n+\t\t\tt.Errorf(\"#%d: server error: %v\", i, err)\n+\t\t} else {\n+\t\t\ttest.verify(t, i, &result.cs)\n+\t\t}\n+\t}\n+}"}, {"sha": "694bd918d85b612891587224ddbbac77def3c346", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -802,12 +802,9 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\t\t}\n \t\t\tl := int(d[0])<<8 | int(d[1])\n \t\t\td = d[2:]\n-\t\t\tif len(d) != l {\n+\t\t\tif len(d) != l || l == 0 {\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tif l == 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n \n \t\t\tm.scts = make([][]byte, 0, 3)\n \t\t\tfor len(d) != 0 {\n@@ -816,7 +813,7 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\t\t\t}\n \t\t\t\tsctLen := int(d[0])<<8 | int(d[1])\n \t\t\t\td = d[2:]\n-\t\t\t\tif len(d) < sctLen {\n+\t\t\t\tif sctLen == 0 || len(d) < sctLen {\n \t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\tm.scts = append(m.scts, d[:sctLen])"}, {"sha": "f1154d4d01d7be3b85dd62742b9e261e69cf9cbb", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -5,6 +5,7 @@\n package tls\n \n import (\n+\t\"bytes\"\n \t\"math/rand\"\n \t\"reflect\"\n \t\"testing\"\n@@ -260,3 +261,65 @@ func (*sessionState) Generate(rand *rand.Rand, size int) reflect.Value {\n \t}\n \treturn reflect.ValueOf(s)\n }\n+\n+func TestRejectEmptySCTList(t *testing.T) {\n+\t// https://tools.ietf.org/html/rfc6962#section-3.3.1 specifies that\n+\t// empty SCT lists are invalid.\n+\n+\tvar random [32]byte\n+\tsct := []byte{0x42, 0x42, 0x42, 0x42}\n+\tserverHello := serverHelloMsg{\n+\t\tvers:   VersionTLS12,\n+\t\trandom: random[:],\n+\t\tscts:   [][]byte{sct},\n+\t}\n+\tserverHelloBytes := serverHello.marshal()\n+\n+\tvar serverHelloCopy serverHelloMsg\n+\tif !serverHelloCopy.unmarshal(serverHelloBytes) {\n+\t\tt.Fatal(\"Failed to unmarshal initial message\")\n+\t}\n+\n+\t// Change serverHelloBytes so that the SCT list is empty\n+\ti := bytes.Index(serverHelloBytes, sct)\n+\tif i < 0 {\n+\t\tt.Fatal(\"Cannot find SCT in ServerHello\")\n+\t}\n+\n+\tvar serverHelloEmptySCT []byte\n+\tserverHelloEmptySCT = append(serverHelloEmptySCT, serverHelloBytes[:i-6]...)\n+\t// Append the extension length and SCT list length for an empty list.\n+\tserverHelloEmptySCT = append(serverHelloEmptySCT, []byte{0, 2, 0, 0}...)\n+\tserverHelloEmptySCT = append(serverHelloEmptySCT, serverHelloBytes[i+4:]...)\n+\n+\t// Update the handshake message length.\n+\tserverHelloEmptySCT[1] = byte((len(serverHelloEmptySCT) - 4) >> 16)\n+\tserverHelloEmptySCT[2] = byte((len(serverHelloEmptySCT) - 4) >> 8)\n+\tserverHelloEmptySCT[3] = byte(len(serverHelloEmptySCT) - 4)\n+\n+\t// Update the extensions length\n+\tserverHelloEmptySCT[42] = byte((len(serverHelloEmptySCT) - 44) >> 8)\n+\tserverHelloEmptySCT[43] = byte((len(serverHelloEmptySCT) - 44))\n+\n+\tif serverHelloCopy.unmarshal(serverHelloEmptySCT) {\n+\t\tt.Fatal(\"Unmarshaled ServerHello with empty SCT list\")\n+\t}\n+}\n+\n+func TestRejectEmptySCT(t *testing.T) {\n+\t// Not only must the SCT list be non-empty, but the SCT elements must\n+\t// not be zero length.\n+\n+\tvar random [32]byte\n+\tserverHello := serverHelloMsg{\n+\t\tvers:   VersionTLS12,\n+\t\trandom: random[:],\n+\t\tscts:   [][]byte{nil},\n+\t}\n+\tserverHelloBytes := serverHello.marshal()\n+\n+\tvar serverHelloCopy serverHelloMsg\n+\tif serverHelloCopy.unmarshal(serverHelloBytes) {\n+\t\tt.Fatal(\"Unmarshaled ServerHello with zero-length SCT\")\n+\t}\n+}"}, {"sha": "b786c3083a2d636dc4004b5da87682450a3eeb5c", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 91, "deletions": 39, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -19,29 +19,28 @@ import (\n // serverHandshakeState contains details of a server handshake in progress.\n // It's discarded once the handshake has completed.\n type serverHandshakeState struct {\n-\tc               *Conn\n-\tclientHello     *clientHelloMsg\n-\thello           *serverHelloMsg\n-\tsuite           *cipherSuite\n-\tellipticOk      bool\n-\tecdsaOk         bool\n-\trsaDecryptOk    bool\n-\trsaSignOk       bool\n-\tsessionState    *sessionState\n-\tfinishedHash    finishedHash\n-\tmasterSecret    []byte\n-\tcertsFromClient [][]byte\n-\tcert            *Certificate\n+\tc                     *Conn\n+\tclientHello           *clientHelloMsg\n+\thello                 *serverHelloMsg\n+\tsuite                 *cipherSuite\n+\tellipticOk            bool\n+\tecdsaOk               bool\n+\trsaDecryptOk          bool\n+\trsaSignOk             bool\n+\tsessionState          *sessionState\n+\tfinishedHash          finishedHash\n+\tmasterSecret          []byte\n+\tcertsFromClient       [][]byte\n+\tcert                  *Certificate\n+\tcachedClientHelloInfo *ClientHelloInfo\n }\n \n // serverHandshake performs a TLS handshake as a server.\n // c.out.Mutex <= L; c.handshakeMutex <= L.\n func (c *Conn) serverHandshake() error {\n-\tconfig := c.config\n-\n \t// If this is the first server handshake, we generate a random key to\n \t// encrypt the tickets with.\n-\tconfig.serverInitOnce.Do(config.serverInit)\n+\tc.config.serverInitOnce.Do(c.config.serverInit)\n \n \ths := serverHandshakeState{\n \t\tc: c,\n@@ -112,7 +111,6 @@ func (c *Conn) serverHandshake() error {\n // readClientHello reads a ClientHello message from the client and decides\n // whether we will perform session resumption.\n func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n-\tconfig := hs.c.config\n \tc := hs.c\n \n \tmsg, err := c.readHandshake()\n@@ -125,7 +123,22 @@ func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n \t\tc.sendAlert(alertUnexpectedMessage)\n \t\treturn false, unexpectedMessageError(hs.clientHello, msg)\n \t}\n-\tc.vers, ok = config.mutualVersion(hs.clientHello.vers)\n+\n+\tif c.config.GetConfigForClient != nil {\n+\t\tif newConfig, err := c.config.GetConfigForClient(hs.clientHelloInfo()); err != nil {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn false, err\n+\t\t} else if newConfig != nil {\n+\t\t\tnewConfig.mutex.Lock()\n+\t\t\tnewConfig.originalConfig = c.config\n+\t\t\tnewConfig.mutex.Unlock()\n+\n+\t\t\tnewConfig.serverInitOnce.Do(newConfig.serverInit)\n+\t\t\tc.config = newConfig\n+\t\t}\n+\t}\n+\n+\tc.vers, ok = c.config.mutualVersion(hs.clientHello.vers)\n \tif !ok {\n \t\tc.sendAlert(alertProtocolVersion)\n \t\treturn false, fmt.Errorf(\"tls: client offered an unsupported, maximum protocol version of %x\", hs.clientHello.vers)\n@@ -135,7 +148,7 @@ func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n \ths.hello = new(serverHelloMsg)\n \n \tsupportedCurve := false\n-\tpreferredCurves := config.curvePreferences()\n+\tpreferredCurves := c.config.curvePreferences()\n Curves:\n \tfor _, curve := range hs.clientHello.supportedCurves {\n \t\tfor _, supported := range preferredCurves {\n@@ -171,7 +184,7 @@ Curves:\n \n \ths.hello.vers = c.vers\n \ths.hello.random = make([]byte, 32)\n-\t_, err = io.ReadFull(config.rand(), hs.hello.random)\n+\t_, err = io.ReadFull(c.config.rand(), hs.hello.random)\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n \t\treturn false, err\n@@ -196,20 +209,15 @@ Curves:\n \t} else {\n \t\t// Although sending an empty NPN extension is reasonable, Firefox has\n \t\t// had a bug around this. Best to send nothing at all if\n-\t\t// config.NextProtos is empty. See\n+\t\t// c.config.NextProtos is empty. See\n \t\t// https://golang.org/issue/5445.\n-\t\tif hs.clientHello.nextProtoNeg && len(config.NextProtos) > 0 {\n+\t\tif hs.clientHello.nextProtoNeg && len(c.config.NextProtos) > 0 {\n \t\t\ths.hello.nextProtoNeg = true\n-\t\t\ths.hello.nextProtos = config.NextProtos\n+\t\t\ths.hello.nextProtos = c.config.NextProtos\n \t\t}\n \t}\n \n-\ths.cert, err = config.getCertificate(&ClientHelloInfo{\n-\t\tCipherSuites:    hs.clientHello.cipherSuites,\n-\t\tServerName:      hs.clientHello.serverName,\n-\t\tSupportedCurves: hs.clientHello.supportedCurves,\n-\t\tSupportedPoints: hs.clientHello.supportedPoints,\n-\t})\n+\ths.cert, err = c.config.getCertificate(hs.clientHelloInfo())\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n \t\treturn false, err\n@@ -354,18 +362,17 @@ func (hs *serverHandshakeState) doResumeHandshake() error {\n }\n \n func (hs *serverHandshakeState) doFullHandshake() error {\n-\tconfig := hs.c.config\n \tc := hs.c\n \n \tif hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {\n \t\ths.hello.ocspStapling = true\n \t}\n \n-\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !config.SessionTicketsDisabled\n+\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !c.config.SessionTicketsDisabled\n \ths.hello.cipherSuite = hs.suite.id\n \n \ths.finishedHash = newFinishedHash(hs.c.vers, hs.suite)\n-\tif config.ClientAuth == NoClientCert {\n+\tif c.config.ClientAuth == NoClientCert {\n \t\t// No need to keep a full record of the handshake if client\n \t\t// certificates won't be used.\n \t\ths.finishedHash.discardHandshakeBuffer()\n@@ -394,7 +401,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t}\n \n \tkeyAgreement := hs.suite.ka(c.vers)\n-\tskx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)\n+\tskx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n@@ -406,7 +413,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\t}\n \t}\n \n-\tif config.ClientAuth >= RequestClientCert {\n+\tif c.config.ClientAuth >= RequestClientCert {\n \t\t// Request a client certificate\n \t\tcertReq := new(certificateRequestMsg)\n \t\tcertReq.certificateTypes = []byte{\n@@ -423,8 +430,8 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\t// to our request. When we know the CAs we trust, then\n \t\t// we can send them down, so that the client can choose\n \t\t// an appropriate certificate to give to us.\n-\t\tif config.ClientCAs != nil {\n-\t\t\tcertReq.certificateAuthorities = config.ClientCAs.Subjects()\n+\t\tif c.config.ClientCAs != nil {\n+\t\t\tcertReq.certificateAuthorities = c.config.ClientCAs.Subjects()\n \t\t}\n \t\ths.finishedHash.Write(certReq.marshal())\n \t\tif _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil {\n@@ -452,7 +459,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \tvar ok bool\n \t// If we requested a client certificate, then the client must send a\n \t// certificate message, even if it's empty.\n-\tif config.ClientAuth >= RequestClientCert {\n+\tif c.config.ClientAuth >= RequestClientCert {\n \t\tif certMsg, ok = msg.(*certificateMsg); !ok {\n \t\t\tc.sendAlert(alertUnexpectedMessage)\n \t\t\treturn unexpectedMessageError(certMsg, msg)\n@@ -461,7 +468,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \n \t\tif len(certMsg.certificates) == 0 {\n \t\t\t// The client didn't actually send a certificate\n-\t\t\tswitch config.ClientAuth {\n+\t\t\tswitch c.config.ClientAuth {\n \t\t\tcase RequireAnyClientCert, RequireAndVerifyClientCert:\n \t\t\t\tc.sendAlert(alertBadCertificate)\n \t\t\t\treturn errors.New(\"tls: client didn't provide a certificate\")\n@@ -487,12 +494,16 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t}\n \ths.finishedHash.Write(ckx.marshal())\n \n-\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)\n+\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n \t}\n \ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.clientHello.random, hs.hello.random)\n+\tif err := c.config.writeKeyLog(hs.clientHello.random, hs.masterSecret); err != nil {\n+\t\tc.sendAlert(alertInternalError)\n+\t\treturn err\n+\t}\n \n \t// If we received a client cert in response to our certificate request message,\n \t// the client will send us a certificateVerifyMsg immediately after the\n@@ -730,6 +741,13 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (c\n \t\tc.verifiedChains = chains\n \t}\n \n+\tif c.config.VerifyPeerCertificate != nil {\n+\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n+\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n \tif len(certs) == 0 {\n \t\treturn nil, nil\n \t}\n@@ -788,3 +806,37 @@ func (hs *serverHandshakeState) setCipherSuite(id uint16, supportedCipherSuites\n \t}\n \treturn false\n }\n+\n+// suppVersArray is the backing array of ClientHelloInfo.SupportedVersions\n+var suppVersArray = [...]uint16{VersionTLS12, VersionTLS11, VersionTLS10, VersionSSL30}\n+\n+func (hs *serverHandshakeState) clientHelloInfo() *ClientHelloInfo {\n+\tif hs.cachedClientHelloInfo != nil {\n+\t\treturn hs.cachedClientHelloInfo\n+\t}\n+\n+\tvar supportedVersions []uint16\n+\tif hs.clientHello.vers > VersionTLS12 {\n+\t\tsupportedVersions = suppVersArray[:]\n+\t} else if hs.clientHello.vers >= VersionSSL30 {\n+\t\tsupportedVersions = suppVersArray[VersionTLS12-hs.clientHello.vers:]\n+\t}\n+\n+\tsignatureSchemes := make([]SignatureScheme, 0, len(hs.clientHello.signatureAndHashes))\n+\tfor _, sah := range hs.clientHello.signatureAndHashes {\n+\t\tsignatureSchemes = append(signatureSchemes, SignatureScheme(sah.hash)<<8+SignatureScheme(sah.signature))\n+\t}\n+\n+\ths.cachedClientHelloInfo = &ClientHelloInfo{\n+\t\tCipherSuites:      hs.clientHello.cipherSuites,\n+\t\tServerName:        hs.clientHello.serverName,\n+\t\tSupportedCurves:   hs.clientHello.supportedCurves,\n+\t\tSupportedPoints:   hs.clientHello.supportedPoints,\n+\t\tSignatureSchemes:  signatureSchemes,\n+\t\tSupportedProtos:   hs.clientHello.alpnProtocols,\n+\t\tSupportedVersions: supportedVersions,\n+\t\tConn:              hs.c.conn,\n+\t}\n+\n+\treturn hs.cachedClientHelloInfo\n+}"}, {"sha": "bcd3d43ea3cbe08d7a8b8abd466b1ca7f544e4d6", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 250, "deletions": 57, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -130,7 +130,7 @@ func TestNoRC4ByDefault(t *testing.T) {\n \t\tcipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n \t\tcompressionMethods: []uint8{compressionNone},\n \t}\n-\tserverConfig := testConfig.clone()\n+\tserverConfig := testConfig.Clone()\n \t// Reset the enabled cipher suites to nil in order to test the\n \t// defaults.\n \tserverConfig.CipherSuites = nil\n@@ -147,7 +147,7 @@ func TestDontSelectECDSAWithRSAKey(t *testing.T) {\n \t\tsupportedCurves:    []CurveID{CurveP256},\n \t\tsupportedPoints:    []uint8{pointFormatUncompressed},\n \t}\n-\tserverConfig := testConfig.clone()\n+\tserverConfig := testConfig.Clone()\n \tserverConfig.CipherSuites = clientHello.cipherSuites\n \tserverConfig.Certificates = make([]Certificate, 1)\n \tserverConfig.Certificates[0].Certificate = [][]byte{testECDSACertificate}\n@@ -172,7 +172,7 @@ func TestDontSelectRSAWithECDSAKey(t *testing.T) {\n \t\tsupportedCurves:    []CurveID{CurveP256},\n \t\tsupportedPoints:    []uint8{pointFormatUncompressed},\n \t}\n-\tserverConfig := testConfig.clone()\n+\tserverConfig := testConfig.Clone()\n \tserverConfig.CipherSuites = clientHello.cipherSuites\n \t// First test that it *does* work when the server's key is RSA.\n \ttestClientHello(t, serverConfig, clientHello)\n@@ -206,7 +206,8 @@ func TestRenegotiationExtension(t *testing.T) {\n \t\tbuf = make([]byte, 1024)\n \t\tn, err := c.Read(buf)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"Server read returned error: %s\", err)\n+\t\t\tt.Errorf(\"Server read returned error: %s\", err)\n+\t\t\treturn\n \t\t}\n \t\tbuf = buf[:n]\n \t\tc.Close()\n@@ -265,7 +266,7 @@ func TestTLS12OnlyCipherSuites(t *testing.T) {\n \t\treply, clientErr = cli.readHandshake()\n \t\tc.Close()\n \t}()\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.CipherSuites = clientHello.cipherSuites\n \tServer(s, config).Handshake()\n \ts.Close()\n@@ -558,6 +559,8 @@ func (test *serverTest) loadData() (flows [][]byte, err error) {\n }\n \n func (test *serverTest) run(t *testing.T, write bool) {\n+\tcheckOpenSSLVersion(t)\n+\n \tvar clientConn, serverConn net.Conn\n \tvar recordingConn *recordingConn\n \tvar childProcess *exec.Cmd\n@@ -658,6 +661,7 @@ func (test *serverTest) run(t *testing.T, write bool) {\n }\n \n func runServerTestForVersion(t *testing.T, template *serverTest, prefix, option string) {\n+\tsetParallel(t)\n \ttest := *template\n \ttest.name = prefix + test.name\n \tif len(test.command) == 0 {\n@@ -732,7 +736,7 @@ func TestHandshakeServerAES256GCMSHA384(t *testing.T) {\n }\n \n func TestHandshakeServerECDHEECDSAAES(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.Certificates = make([]Certificate, 1)\n \tconfig.Certificates[0].Certificate = [][]byte{testECDSACertificate}\n \tconfig.Certificates[0].PrivateKey = testECDSAPrivateKey\n@@ -747,8 +751,20 @@ func TestHandshakeServerECDHEECDSAAES(t *testing.T) {\n \trunServerTestTLS12(t, test)\n }\n \n+func TestHandshakeServerX25519(t *testing.T) {\n+\tconfig := testConfig.Clone()\n+\tconfig.CurvePreferences = []CurveID{X25519}\n+\n+\ttest := &serverTest{\n+\t\tname:    \"X25519-ECDHE-RSA-AES-GCM\",\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\"},\n+\t\tconfig:  config,\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n func TestHandshakeServerALPN(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.NextProtos = []string{\"proto1\", \"proto2\"}\n \n \ttest := &serverTest{\n@@ -769,7 +785,7 @@ func TestHandshakeServerALPN(t *testing.T) {\n }\n \n func TestHandshakeServerALPNNoMatch(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.NextProtos = []string{\"proto3\"}\n \n \ttest := &serverTest{\n@@ -804,7 +820,7 @@ func TestHandshakeServerSNI(t *testing.T) {\n // TestHandshakeServerSNICertForName is similar to TestHandshakeServerSNI, but\n // tests the dynamic GetCertificate method\n func TestHandshakeServerSNIGetCertificate(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \n \t// Replace the NameToCertificate map with a GetCertificate function\n \tnameToCert := config.NameToCertificate\n@@ -826,7 +842,7 @@ func TestHandshakeServerSNIGetCertificate(t *testing.T) {\n // GetCertificate method doesn't return a cert, we fall back to what's in\n // the NameToCertificate map.\n func TestHandshakeServerSNIGetCertificateNotFound(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \n \tconfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n \t\treturn nil, nil\n@@ -844,7 +860,7 @@ func TestHandshakeServerSNIGetCertificateNotFound(t *testing.T) {\n func TestHandshakeServerSNIGetCertificateError(t *testing.T) {\n \tconst errMsg = \"TestHandshakeServerSNIGetCertificateError error\"\n \n-\tserverConfig := testConfig.clone()\n+\tserverConfig := testConfig.Clone()\n \tserverConfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n \t\treturn nil, errors.New(errMsg)\n \t}\n@@ -863,7 +879,7 @@ func TestHandshakeServerSNIGetCertificateError(t *testing.T) {\n func TestHandshakeServerEmptyCertificates(t *testing.T) {\n \tconst errMsg = \"TestHandshakeServerEmptyCertificates error\"\n \n-\tserverConfig := testConfig.clone()\n+\tserverConfig := testConfig.Clone()\n \tserverConfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n \t\treturn nil, errors.New(errMsg)\n \t}\n@@ -891,7 +907,7 @@ func TestHandshakeServerEmptyCertificates(t *testing.T) {\n // TestCipherSuiteCertPreferance ensures that we select an RSA ciphersuite with\n // an RSA certificate and an ECDSA ciphersuite with an ECDSA certificate.\n func TestCipherSuiteCertPreferenceECDSA(t *testing.T) {\n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.CipherSuites = []uint16{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA}\n \tconfig.PreferServerCipherSuites = true\n \n@@ -901,7 +917,7 @@ func TestCipherSuiteCertPreferenceECDSA(t *testing.T) {\n \t}\n \trunServerTestTLS12(t, test)\n \n-\tconfig = testConfig.clone()\n+\tconfig = testConfig.Clone()\n \tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA}\n \tconfig.Certificates = []Certificate{\n \t\t{\n@@ -925,13 +941,13 @@ func TestResumption(t *testing.T) {\n \n \ttest := &serverTest{\n \t\tname:    \"IssueTicket\",\n-\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"RC4-SHA\", \"-sess_out\", sessionFilePath},\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"AES128-SHA\", \"-sess_out\", sessionFilePath},\n \t}\n \trunServerTestTLS12(t, test)\n \n \ttest = &serverTest{\n \t\tname:    \"Resume\",\n-\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"RC4-SHA\", \"-sess_in\", sessionFilePath},\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"AES128-SHA\", \"-sess_in\", sessionFilePath},\n \t}\n \trunServerTestTLS12(t, test)\n }\n@@ -940,11 +956,11 @@ func TestResumptionDisabled(t *testing.T) {\n \tsessionFilePath := tempFile(\"\")\n \tdefer os.Remove(sessionFilePath)\n \n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \n \ttest := &serverTest{\n \t\tname:    \"IssueTicketPreDisable\",\n-\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"RC4-SHA\", \"-sess_out\", sessionFilePath},\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"AES128-SHA\", \"-sess_out\", sessionFilePath},\n \t\tconfig:  config,\n \t}\n \trunServerTestTLS12(t, test)\n@@ -953,7 +969,7 @@ func TestResumptionDisabled(t *testing.T) {\n \n \ttest = &serverTest{\n \t\tname:    \"ResumeDisabled\",\n-\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"RC4-SHA\", \"-sess_in\", sessionFilePath},\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-cipher\", \"AES128-SHA\", \"-sess_in\", sessionFilePath},\n \t\tconfig:  config,\n \t}\n \trunServerTestTLS12(t, test)\n@@ -976,40 +992,40 @@ func TestFallbackSCSV(t *testing.T) {\n \trunServerTestTLS11(t, test)\n }\n \n-// cert.pem and key.pem were generated with generate_cert.go\n-// Thus, they have no ExtKeyUsage fields and trigger an error\n-// when verification is turned on.\n+// clientCertificatePEM and clientKeyPEM were generated with generate_cert.go\n+// Thus, they have no ExtKeyUsage fields and trigger an error when verification\n+// is turned on.\n \n const clientCertificatePEM = `\n -----BEGIN CERTIFICATE-----\n-MIIB7TCCAVigAwIBAgIBADALBgkqhkiG9w0BAQUwJjEQMA4GA1UEChMHQWNtZSBD\n-bzESMBAGA1UEAxMJMTI3LjAuMC4xMB4XDTExMTIwODA3NTUxMloXDTEyMTIwNzA4\n-MDAxMlowJjEQMA4GA1UEChMHQWNtZSBDbzESMBAGA1UEAxMJMTI3LjAuMC4xMIGc\n-MAsGCSqGSIb3DQEBAQOBjAAwgYgCgYBO0Hsx44Jk2VnAwoekXh6LczPHY1PfZpIG\n-hPZk1Y/kNqcdK+izIDZFI7Xjla7t4PUgnI2V339aEu+H5Fto5OkOdOwEin/ekyfE\n-ARl6vfLcPRSr0FTKIQzQTW6HLlzF0rtNS0/Otiz3fojsfNcCkXSmHgwa2uNKWi7e\n-E5xMQIhZkwIDAQABozIwMDAOBgNVHQ8BAf8EBAMCAKAwDQYDVR0OBAYEBAECAwQw\n-DwYDVR0jBAgwBoAEAQIDBDALBgkqhkiG9w0BAQUDgYEANh+zegx1yW43RmEr1b3A\n-p0vMRpqBWHyFeSnIyMZn3TJWRSt1tukkqVCavh9a+hoV2cxVlXIWg7nCto/9iIw4\n-hB2rXZIxE0/9gzvGnfERYraL7KtnvshksBFQRlgXa5kc0x38BvEO5ZaoDPl4ILdE\n-GFGNEH5PlGffo05wc46QkYU=\n+MIIB7zCCAVigAwIBAgIQXBnBiWWDVW/cC8m5k5/pvDANBgkqhkiG9w0BAQsFADAS\n+MRAwDgYDVQQKEwdBY21lIENvMB4XDTE2MDgxNzIxNTIzMVoXDTE3MDgxNzIxNTIz\n+MVowEjEQMA4GA1UEChMHQWNtZSBDbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC\n+gYEAum+qhr3Pv5/y71yUYHhv6BPy0ZZvzdkybiI3zkH5yl0prOEn2mGi7oHLEMff\n+NFiVhuk9GeZcJ3NgyI14AvQdpJgJoxlwaTwlYmYqqyIjxXuFOE8uCXMyp70+m63K\n+hAfmDzr/d8WdQYUAirab7rCkPy1MTOZCPrtRyN1IVPQMjkcCAwEAAaNGMEQwDgYD\n+VR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAw\n+DwYDVR0RBAgwBocEfwAAATANBgkqhkiG9w0BAQsFAAOBgQBGq0Si+yhU+Fpn+GKU\n+8ZqyGJ7ysd4dfm92lam6512oFmyc9wnTN+RLKzZ8Aa1B0jLYw9KT+RBrjpW5LBeK\n+o0RIvFkTgxYEiKSBXCUNmAysEbEoVr4dzWFihAm/1oDGRY2CLLTYg5vbySK3KhIR\n+e/oCO8HJ/+rJnahJ05XX1Q7lNQ==\n -----END CERTIFICATE-----`\n \n const clientKeyPEM = `\n -----BEGIN RSA PRIVATE KEY-----\n-MIICWgIBAAKBgE7QezHjgmTZWcDCh6ReHotzM8djU99mkgaE9mTVj+Q2px0r6LMg\n-NkUjteOVru3g9SCcjZXff1oS74fkW2jk6Q507ASKf96TJ8QBGXq98tw9FKvQVMoh\n-DNBNbocuXMXSu01LT862LPd+iOx81wKRdKYeDBra40paLt4TnExAiFmTAgMBAAEC\n-gYBxvXd8yNteFTns8A/2yomEMC4yeosJJSpp1CsN3BJ7g8/qTnrVPxBy+RU+qr63\n-t2WquaOu/cr5P8iEsa6lk20tf8pjKLNXeX0b1RTzK8rJLbS7nGzP3tvOhL096VtQ\n-dAo4ROEaro0TzYpHmpciSvxVIeEIAAdFDObDJPKqcJAxyQJBAJizfYgK8Gzx9fsx\n-hxp+VteCbVPg2euASH5Yv3K5LukRdKoSzHE2grUVQgN/LafC0eZibRanxHegYSr7\n-7qaswKUCQQCEIWor/X4XTMdVj3Oj+vpiw75y/S9gh682+myZL+d/02IEkwnB098P\n-RkKVpenBHyrGg0oeN5La7URILWKj7CPXAkBKo6F+d+phNjwIFoN1Xb/RA32w/D1I\n-saG9sF+UEhRt9AxUfW/U/tIQ9V0ZHHcSg1XaCM5Nvp934brdKdvTOKnJAkBD5h/3\n-Rybatlvg/fzBEaJFyq09zhngkxlZOUtBVTqzl17RVvY2orgH02U4HbCHy4phxOn7\n-qTdQRYlHRftgnWK1AkANibn9PRYJ7mJyJ9Dyj2QeNcSkSTzrt0tPvUMf4+meJymN\n-1Ntu5+S1DLLzfxlaljWG6ylW6DNxujCyuXIV2rvA\n+MIICXQIBAAKBgQC6b6qGvc+/n/LvXJRgeG/oE/LRlm/N2TJuIjfOQfnKXSms4Sfa\n+YaLugcsQx980WJWG6T0Z5lwnc2DIjXgC9B2kmAmjGXBpPCViZiqrIiPFe4U4Ty4J\n+czKnvT6brcqEB+YPOv93xZ1BhQCKtpvusKQ/LUxM5kI+u1HI3UhU9AyORwIDAQAB\n+AoGAEJZ03q4uuMb7b26WSQsOMeDsftdatT747LGgs3pNRkMJvTb/O7/qJjxoG+Mc\n+qeSj0TAZXp+PXXc3ikCECAc+R8rVMfWdmp903XgO/qYtmZGCorxAHEmR80SrfMXv\n+PJnznLQWc8U9nphQErR+tTESg7xWEzmFcPKwnZd1xg8ERYkCQQDTGtrFczlB2b/Z\n+9TjNMqUlMnTLIk/a/rPE2fLLmAYhK5sHnJdvDURaH2mF4nso0EGtENnTsh6LATnY\n+dkrxXGm9AkEA4hXHG2q3MnhgK1Z5hjv+Fnqd+8bcbII9WW4flFs15EKoMgS1w/PJ\n+zbsySaSy5IVS8XeShmT9+3lrleed4sy+UwJBAJOOAbxhfXP5r4+5R6ql66jES75w\n+jUCVJzJA5ORJrn8g64u2eGK28z/LFQbv9wXgCwfc72R468BdawFSLa/m2EECQGbZ\n+rWiFla26IVXV0xcD98VWJsTBZMlgPnSOqoMdM1kSEd4fUmlAYI/dFzV1XYSkOmVr\n+FhdZnklmpVDeu27P4c0CQQCuCOup0FlJSBpWY1TTfun/KMBkBatMz0VMA3d7FKIU\n+csPezl677Yjo8u1r/KzeI6zLg87Z8E6r6ZWNc9wBSZK6\n -----END RSA PRIVATE KEY-----`\n \n const clientECDSACertificatePEM = `\n@@ -1040,6 +1056,7 @@ FMBexFe01MNvja5oHt1vzobhfm6ySD6B5U7ixohLZNz1MLvT/2XMW/TdtWo+PtAd\n -----END EC PRIVATE KEY-----`\n \n func TestClientAuth(t *testing.T) {\n+\tsetParallel(t)\n \tvar certPath, keyPath, ecdsaCertPath, ecdsaKeyPath string\n \n \tif *update {\n@@ -1053,33 +1070,209 @@ func TestClientAuth(t *testing.T) {\n \t\tdefer os.Remove(ecdsaKeyPath)\n \t}\n \n-\tconfig := testConfig.clone()\n+\tconfig := testConfig.Clone()\n \tconfig.ClientAuth = RequestClientCert\n \n \ttest := &serverTest{\n \t\tname:    \"ClientAuthRequestedNotGiven\",\n-\t\tcommand: []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"RC4-SHA\"},\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\"},\n \t\tconfig:  config,\n \t}\n \trunServerTestTLS12(t, test)\n \n \ttest = &serverTest{\n \t\tname:              \"ClientAuthRequestedAndGiven\",\n-\t\tcommand:           []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"RC4-SHA\", \"-cert\", certPath, \"-key\", keyPath},\n+\t\tcommand:           []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\", \"-cert\", certPath, \"-key\", keyPath},\n \t\tconfig:            config,\n \t\texpectedPeerCerts: []string{clientCertificatePEM},\n \t}\n \trunServerTestTLS12(t, test)\n \n \ttest = &serverTest{\n \t\tname:              \"ClientAuthRequestedAndECDSAGiven\",\n-\t\tcommand:           []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"RC4-SHA\", \"-cert\", ecdsaCertPath, \"-key\", ecdsaKeyPath},\n+\t\tcommand:           []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\", \"-cert\", ecdsaCertPath, \"-key\", ecdsaKeyPath},\n \t\tconfig:            config,\n \t\texpectedPeerCerts: []string{clientECDSACertificatePEM},\n \t}\n \trunServerTestTLS12(t, test)\n }\n \n+func TestSNIGivenOnFailure(t *testing.T) {\n+\tconst expectedServerName = \"test.testing\"\n+\n+\tclientHello := &clientHelloMsg{\n+\t\tvers:               VersionTLS10,\n+\t\tcipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n+\t\tcompressionMethods: []uint8{compressionNone},\n+\t\tserverName:         expectedServerName,\n+\t}\n+\n+\tserverConfig := testConfig.Clone()\n+\t// Erase the server's cipher suites to ensure the handshake fails.\n+\tserverConfig.CipherSuites = nil\n+\n+\tc, s := net.Pipe()\n+\tgo func() {\n+\t\tcli := Client(c, testConfig)\n+\t\tcli.vers = clientHello.vers\n+\t\tcli.writeRecord(recordTypeHandshake, clientHello.marshal())\n+\t\tc.Close()\n+\t}()\n+\ths := serverHandshakeState{\n+\t\tc: Server(s, serverConfig),\n+\t}\n+\t_, err := hs.readClientHello()\n+\tdefer s.Close()\n+\n+\tif err == nil {\n+\t\tt.Error(\"No error reported from server\")\n+\t}\n+\n+\tcs := hs.c.ConnectionState()\n+\tif cs.HandshakeComplete {\n+\t\tt.Error(\"Handshake registered as complete\")\n+\t}\n+\n+\tif cs.ServerName != expectedServerName {\n+\t\tt.Errorf(\"Expected ServerName of %q, but got %q\", expectedServerName, cs.ServerName)\n+\t}\n+}\n+\n+var getConfigForClientTests = []struct {\n+\tsetup          func(config *Config)\n+\tcallback       func(clientHello *ClientHelloInfo) (*Config, error)\n+\terrorSubstring string\n+\tverify         func(config *Config) error\n+}{\n+\t{\n+\t\tnil,\n+\t\tfunc(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\treturn nil, nil\n+\t\t},\n+\t\t\"\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\tnil,\n+\t\tfunc(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\treturn nil, errors.New(\"should bubble up\")\n+\t\t},\n+\t\t\"should bubble up\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\tnil,\n+\t\tfunc(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\tconfig := testConfig.Clone()\n+\t\t\t// Setting a maximum version of TLS 1.1 should cause\n+\t\t\t// the handshake to fail.\n+\t\t\tconfig.MaxVersion = VersionTLS11\n+\t\t\treturn config, nil\n+\t\t},\n+\t\t\"version 301 when expecting version 302\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\tfunc(config *Config) {\n+\t\t\tfor i := range config.SessionTicketKey {\n+\t\t\t\tconfig.SessionTicketKey[i] = byte(i)\n+\t\t\t}\n+\t\t\tconfig.sessionTicketKeys = nil\n+\t\t},\n+\t\tfunc(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\tconfig := testConfig.Clone()\n+\t\t\tfor i := range config.SessionTicketKey {\n+\t\t\t\tconfig.SessionTicketKey[i] = 0\n+\t\t\t}\n+\t\t\tconfig.sessionTicketKeys = nil\n+\t\t\treturn config, nil\n+\t\t},\n+\t\t\"\",\n+\t\tfunc(config *Config) error {\n+\t\t\t// The value of SessionTicketKey should have been\n+\t\t\t// duplicated into the per-connection Config.\n+\t\t\tfor i := range config.SessionTicketKey {\n+\t\t\t\tif b := config.SessionTicketKey[i]; b != byte(i) {\n+\t\t\t\t\treturn fmt.Errorf(\"SessionTicketKey was not duplicated from original Config: byte %d has value %d\", i, b)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t},\n+\t{\n+\t\tfunc(config *Config) {\n+\t\t\tvar dummyKey [32]byte\n+\t\t\tfor i := range dummyKey {\n+\t\t\t\tdummyKey[i] = byte(i)\n+\t\t\t}\n+\n+\t\t\tconfig.SetSessionTicketKeys([][32]byte{dummyKey})\n+\t\t},\n+\t\tfunc(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\tconfig := testConfig.Clone()\n+\t\t\tconfig.sessionTicketKeys = nil\n+\t\t\treturn config, nil\n+\t\t},\n+\t\t\"\",\n+\t\tfunc(config *Config) error {\n+\t\t\t// The session ticket keys should have been duplicated\n+\t\t\t// into the per-connection Config.\n+\t\t\tif l := len(config.sessionTicketKeys); l != 1 {\n+\t\t\t\treturn fmt.Errorf(\"got len(sessionTicketKeys) == %d, wanted 1\", l)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t},\n+}\n+\n+func TestGetConfigForClient(t *testing.T) {\n+\tserverConfig := testConfig.Clone()\n+\tclientConfig := testConfig.Clone()\n+\tclientConfig.MinVersion = VersionTLS12\n+\n+\tfor i, test := range getConfigForClientTests {\n+\t\tif test.setup != nil {\n+\t\t\ttest.setup(serverConfig)\n+\t\t}\n+\n+\t\tvar configReturned *Config\n+\t\tserverConfig.GetConfigForClient = func(clientHello *ClientHelloInfo) (*Config, error) {\n+\t\t\tconfig, err := test.callback(clientHello)\n+\t\t\tconfigReturned = config\n+\t\t\treturn config, err\n+\t\t}\n+\t\tc, s := net.Pipe()\n+\t\tdone := make(chan error)\n+\n+\t\tgo func() {\n+\t\t\tdefer s.Close()\n+\t\t\tdone <- Server(s, serverConfig).Handshake()\n+\t\t}()\n+\n+\t\tclientErr := Client(c, clientConfig).Handshake()\n+\t\tc.Close()\n+\n+\t\tserverErr := <-done\n+\n+\t\tif len(test.errorSubstring) == 0 {\n+\t\t\tif serverErr != nil || clientErr != nil {\n+\t\t\t\tt.Errorf(\"test[%d]: expected no error but got serverErr: %q, clientErr: %q\", i, serverErr, clientErr)\n+\t\t\t}\n+\t\t\tif test.verify != nil {\n+\t\t\t\tif err := test.verify(configReturned); err != nil {\n+\t\t\t\t\tt.Errorf(\"test[%d]: verify returned error: %v\", i, err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif serverErr == nil {\n+\t\t\t\tt.Errorf(\"test[%d]: expected error containing %q but got no error\", i, test.errorSubstring)\n+\t\t\t} else if !strings.Contains(serverErr.Error(), test.errorSubstring) {\n+\t\t\t\tt.Errorf(\"test[%d]: expected error to contain %q but it was %q\", i, test.errorSubstring, serverErr)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func bigFromString(s string) *big.Int {\n \tret := new(big.Int)\n \tret.SetString(s, 10)\n@@ -1091,23 +1284,23 @@ func fromHex(s string) []byte {\n \treturn b\n }\n \n-var testRSACertificate = fromHex(\"30820263308201cca003020102020900a273000c8100cbf3300d06092a864886f70d01010b0500302b31173015060355040a130e476f6f676c652054455354494e473110300e06035504031307476f20526f6f74301e170d3135303130313030303030305a170d3235303130313030303030305a302631173015060355040a130e476f6f676c652054455354494e47310b300906035504031302476f30819f300d06092a864886f70d010101050003818d0030818902818100af8788f6201b95656c14ab4405af3b4514e3b76dfd00634d957ffe6a623586c04af9187cf6aa255e7a64316600baf48e92afc76bd876d4f35f41cb6e5615971b97c13c123921663d2b16d1bcdb1cc0a7dab7caadbadacbd52150ecde8dabd16b814b8902f3c4bec16c89b14484bd21d1047d9d164df98215f6effad60947f2fb0203010001a38193308190300e0603551d0f0101ff0404030205a0301d0603551d250416301406082b0601050507030106082b06010505070302300c0603551d130101ff0402300030190603551d0e0412041012508d896f1bd1dc544d6ecb695e06f4301b0603551d23041430128010bf3db6a966f2b840cfeab40378481a4130190603551d1104123010820e6578616d706c652e676f6c616e67300d06092a864886f70d01010b050003818100927caf91551218965931a64840d52dd5eebb02a0f5c21e7c9bb3307d3cdc76da4f3dc0faae2d33246b037b1b67591121b511bc77b9d9e06ea82d2e35fa645f223e63106bbeff14866d0df01531a814381e3b84872ccb98ed5176b9b14fdddb9b84048640fa51ddbab48debe346de46b94f86c7f9a4c24134acccf6eab0ab3918\")\n+var testRSACertificate = fromHex(\"3082024b308201b4a003020102020900e8f09d3fe25beaa6300d06092a864886f70d01010b0500301f310b3009060355040a1302476f3110300e06035504031307476f20526f6f74301e170d3136303130313030303030305a170d3235303130313030303030305a301a310b3009060355040a1302476f310b300906035504031302476f30819f300d06092a864886f70d010101050003818d0030818902818100db467d932e12270648bc062821ab7ec4b6a25dfe1e5245887a3647a5080d92425bc281c0be97799840fb4f6d14fd2b138bc2a52e67d8d4099ed62238b74a0b74732bc234f1d193e596d9747bf3589f6c613cc0b041d4d92b2b2423775b1c3bbd755dce2054cfa163871d1e24c4f31d1a508baab61443ed97a77562f414c852d70203010001a38193308190300e0603551d0f0101ff0404030205a0301d0603551d250416301406082b0601050507030106082b06010505070302300c0603551d130101ff0402300030190603551d0e041204109f91161f43433e49a6de6db680d79f60301b0603551d230414301280104813494d137e1631bba301d5acab6e7b30190603551d1104123010820e6578616d706c652e676f6c616e67300d06092a864886f70d01010b0500038181009d30cc402b5b50a061cbbae55358e1ed8328a9581aa938a495a1ac315a1a84663d43d32dd90bf297dfd320643892243a00bccf9c7db74020015faad3166109a276fd13c3cce10c5ceeb18782f16c04ed73bbb343778d0c1cf10fa1d8408361c94c722b9daedb4606064df4c1b33ec0d1bd42d4dbfe3d1360845c21d33be9fae7\")\n \n-var testRSACertificateIssuer = fromHex(\"3082024d308201b6a003020102020827326bd913b7c43d300d06092a864886f70d01010b0500302b31173015060355040a130e476f6f676c652054455354494e473110300e06035504031307476f20526f6f74301e170d3135303130313030303030305a170d3235303130313030303030305a302b31173015060355040a130e476f6f676c652054455354494e473110300e06035504031307476f20526f6f7430819f300d06092a864886f70d010101050003818d0030818902818100f0429a7b9f66a222c8453800452db355b34c4409fee09af2510a6589bfa35bdb4d453200d1de24338d6d5e5a91cc8301628445d6eb4e675927b9c1ea5c0f676acfb0f708ce4f19827e321c1898bf86df9823d5f0b05df2b6779888eff8abbc7f41c6e7d2667386a579b8cbaad3f6fd597cd7c4b187911a425aed1b555c1965190203010001a37a3078300e0603551d0f0101ff040403020204301d0603551d250416301406082b0601050507030106082b06010505070302300f0603551d130101ff040530030101ff30190603551d0e04120410bf3db6a966f2b840cfeab40378481a41301b0603551d23041430128010bf3db6a966f2b840cfeab40378481a41300d06092a864886f70d01010b050003818100586e68c1219ed4f5782b7cfd53cf1a55750a98781b2023f8694bb831fff6d7d4aad1f0ac782b1ec787f00a8956bdd06b4a1063444fcafe955c07d679163a730802c568886a2cf8a3c2ab41176957131c4b9e077ebd7ffbb91fdad8b08b932e9aeefac04923ffdc0aa145563f7f061995317400203578f350e3e566deb29dec5e\")\n+var testRSACertificateIssuer = fromHex(\"3082021930820182a003020102020900ca5e4e811a965964300d06092a864886f70d01010b0500301f310b3009060355040a1302476f3110300e06035504031307476f20526f6f74301e170d3136303130313030303030305a170d3235303130313030303030305a301f310b3009060355040a1302476f3110300e06035504031307476f20526f6f7430819f300d06092a864886f70d010101050003818d0030818902818100d667b378bb22f34143b6cd2008236abefaf2852adf3ab05e01329e2c14834f5105df3f3073f99dab5442d45ee5f8f57b0111c8cb682fbb719a86944eebfffef3406206d898b8c1b1887797c9c5006547bb8f00e694b7a063f10839f269f2c34fff7a1f4b21fbcd6bfdfb13ac792d1d11f277b5c5b48600992203059f2a8f8cc50203010001a35d305b300e0603551d0f0101ff040403020204301d0603551d250416301406082b0601050507030106082b06010505070302300f0603551d130101ff040530030101ff30190603551d0e041204104813494d137e1631bba301d5acab6e7b300d06092a864886f70d01010b050003818100c1154b4bab5266221f293766ae4138899bd4c5e36b13cee670ceeaa4cbdf4f6679017e2fe649765af545749fe4249418a56bd38a04b81e261f5ce86b8d5c65413156a50d12449554748c59a30c515bc36a59d38bddf51173e899820b282e40aa78c806526fd184fb6b4cf186ec728edffa585440d2b3225325f7ab580e87dd76\")\n \n var testECDSACertificate = fromHex(\"3082020030820162020900b8bf2d47a0d2ebf4300906072a8648ce3d04013045310b3009060355040613024155311330110603550408130a536f6d652d53746174653121301f060355040a1318496e7465726e6574205769646769747320507479204c7464301e170d3132313132323135303633325a170d3232313132303135303633325a3045310b3009060355040613024155311330110603550408130a536f6d652d53746174653121301f060355040a1318496e7465726e6574205769646769747320507479204c746430819b301006072a8648ce3d020106052b81040023038186000400c4a1edbe98f90b4873367ec316561122f23d53c33b4d213dcd6b75e6f6b0dc9adf26c1bcb287f072327cb3642f1c90bcea6823107efee325c0483a69e0286dd33700ef0462dd0da09c706283d881d36431aa9e9731bd96b068c09b23de76643f1a5c7fe9120e5858b65f70dd9bd8ead5d7f5d5ccb9b69f30665b669a20e227e5bffe3b300906072a8648ce3d040103818c0030818802420188a24febe245c5487d1bacf5ed989dae4770c05e1bb62fbdf1b64db76140d311a2ceee0b7e927eff769dc33b7ea53fcefa10e259ec472d7cacda4e970e15a06fd00242014dfcbe67139c2d050ebd3fa38c25c13313830d9406bbd4377af6ec7ac9862eddd711697f857c56defb31782be4c7780daecbbe9e4e3624317b6a0f399512078f2a\")\n \n-var testSNICertificate = fromHex(\"308201f23082015da003020102020100300b06092a864886f70d01010530283110300e060355040a130741636d6520436f311430120603550403130b736e69746573742e636f6d301e170d3132303431313137343033355a170d3133303431313137343533355a30283110300e060355040a130741636d6520436f311430120603550403130b736e69746573742e636f6d30819d300b06092a864886f70d01010103818d0030818902818100bb79d6f517b5e5bf4610d0dc69bee62b07435ad0032d8a7a4385b71452e7a5654c2c78b8238cb5b482e5de1f953b7e62a52ca533d6fe125c7a56fcf506bffa587b263fb5cd04d3d0c921964ac7f4549f5abfef427100fe1899077f7e887d7df10439c4a22edb51c97ce3c04c3b326601cfafb11db8719a1ddbdb896baeda2d790203010001a3323030300e0603551d0f0101ff0404030200a0300d0603551d0e0406040401020304300f0603551d2304083006800401020304300b06092a864886f70d0101050381810089c6455f1c1f5ef8eb1ab174ee2439059f5c4259bb1a8d86cdb1d056f56a717da40e95ab90f59e8deaf627c157995094db0802266eb34fc6842dea8a4b68d9c1389103ab84fb9e1f85d9b5d23ff2312c8670fbb540148245a4ebafe264d90c8a4cf4f85b0fac12ac2fc4a3154bad52462868af96c62c6525d652b6e31845bdcc\")\n+var testSNICertificate = fromHex(\"0441883421114c81480804c430820237308201a0a003020102020900e8f09d3fe25beaa6300d06092a864886f70d01010b0500301f310b3009060355040a1302476f3110300e06035504031307476f20526f6f74301e170d3136303130313030303030305a170d3235303130313030303030305a3023310b3009060355040a1302476f311430120603550403130b736e69746573742e636f6d30819f300d06092a864886f70d010101050003818d0030818902818100db467d932e12270648bc062821ab7ec4b6a25dfe1e5245887a3647a5080d92425bc281c0be97799840fb4f6d14fd2b138bc2a52e67d8d4099ed62238b74a0b74732bc234f1d193e596d9747bf3589f6c613cc0b041d4d92b2b2423775b1c3bbd755dce2054cfa163871d1e24c4f31d1a508baab61443ed97a77562f414c852d70203010001a3773075300e0603551d0f0101ff0404030205a0301d0603551d250416301406082b0601050507030106082b06010505070302300c0603551d130101ff0402300030190603551d0e041204109f91161f43433e49a6de6db680d79f60301b0603551d230414301280104813494d137e1631bba301d5acab6e7b300d06092a864886f70d01010b0500038181007beeecff0230dbb2e7a334af65430b7116e09f327c3bbf918107fc9c66cb497493207ae9b4dbb045cb63d605ec1b5dd485bb69124d68fa298dc776699b47632fd6d73cab57042acb26f083c4087459bc5a3bb3ca4d878d7fe31016b7bc9a627438666566e3389bfaeebe6becc9a0093ceed18d0f9ac79d56f3a73f18188988ed\")\n \n var testRSAPrivateKey = &rsa.PrivateKey{\n \tPublicKey: rsa.PublicKey{\n-\t\tN: bigFromString(\"123260960069105588390096594560395120585636206567569540256061833976822892593755073841963170165000086278069699238754008398039246547214989242849418349143232951701395321381739566687846006911427966669790845430647688107009232778985142860108863460556510585049041936029324503323373417214453307648498561956908810892027L\"),\n+\t\tN: bigFromString(\"153980389784927331788354528594524332344709972855165340650588877572729725338415474372475094155672066328274535240275856844648695200875763869073572078279316458648124537905600131008790701752441155668003033945258023841165089852359980273279085783159654751552359397986180318708491098942831252291841441726305535546071\"),\n \t\tE: 65537,\n \t},\n-\tD: bigFromString(\"73196363031103823625826315929954946106043759818067219550565550066527203472294428548476778865091068522665312037075674791871635825938217363523103946045078950060973913307430314113074463630778799389010335923241901501086246276485964417618981733827707048660375428006201525399194575538037883519254056917253456403553L\"),\n+\tD: bigFromString(\"7746362285745539358014631136245887418412633787074173796862711588221766398229333338511838891484974940633857861775630560092874987828057333663969469797013996401149696897591265769095952887917296740109742927689053276850469671231961384712725169432413343763989564437170644270643461665184965150423819594083121075825\"),\n \tPrimes: []*big.Int{\n-\t\tbigFromString(\"11157426355495284553529769521954035649776033703833034489026848970480272318436419662860715175517581249375929775774910501512841707465207184924996975125010787L\"),\n-\t\tbigFromString(\"11047436580963564307160117670964629323534448585520694947919342920137706075617545637058809770319843170934495909554506529982972972247390145716507031692656521L\"),\n+\t\tbigFromString(\"13299275414352936908236095374926261633419699590839189494995965049151460173257838079863316944311313904000258169883815802963543635820059341150014695560313417\"),\n+\t\tbigFromString(\"11578103692682951732111718237224894755352163854919244905974423810539077224889290605729035287537520656160688625383765857517518932447378594964220731750802463\"),\n \t},\n }\n "}, {"sha": "8e5410a17de80f18a35c07e192a0eec5e33f3f54", "filename": "libgo/go/crypto/tls/handshake_test.go", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -13,9 +13,11 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net\"\n+\t\"os/exec\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"testing\"\n )\n \n // TLS reference tests run a connection against a reference implementation\n@@ -35,7 +37,52 @@ import (\n // generate fresh random numbers, large parts of the reference connection will\n // always change.\n \n-var update = flag.Bool(\"update\", false, \"update golden files on disk\")\n+var (\n+\tupdate = flag.Bool(\"update\", false, \"update golden files on disk\")\n+\n+\topensslVersionTestOnce sync.Once\n+\topensslVersionTestErr  error\n+)\n+\n+func checkOpenSSLVersion(t *testing.T) {\n+\topensslVersionTestOnce.Do(testOpenSSLVersion)\n+\tif opensslVersionTestErr != nil {\n+\t\tt.Fatal(opensslVersionTestErr)\n+\t}\n+}\n+\n+func testOpenSSLVersion() {\n+\t// This test ensures that the version of OpenSSL looks reasonable\n+\t// before updating the test data.\n+\n+\tif !*update {\n+\t\treturn\n+\t}\n+\n+\topenssl := exec.Command(\"openssl\", \"version\")\n+\toutput, err := openssl.CombinedOutput()\n+\tif err != nil {\n+\t\topensslVersionTestErr = err\n+\t\treturn\n+\t}\n+\n+\tversion := string(output)\n+\tif strings.HasPrefix(version, \"OpenSSL 1.1.0\") {\n+\t\treturn\n+\t}\n+\n+\tprintln(\"***********************************************\")\n+\tprintln(\"\")\n+\tprintln(\"You need to build OpenSSL 1.1.0 from source in order\")\n+\tprintln(\"to update the test data.\")\n+\tprintln(\"\")\n+\tprintln(\"Configure it with:\")\n+\tprintln(\"./Configure enable-weak-ssl-ciphers enable-ssl3 enable-ssl3-method -static linux-x86_64\")\n+\tprintln(\"and then add the apps/ directory at the front of your PATH.\")\n+\tprintln(\"***********************************************\")\n+\n+\topensslVersionTestErr = errors.New(\"version of OpenSSL does not appear to be suitable for updating test data\")\n+}\n \n // recordingConn is a net.Conn that records the traffic that passes through it.\n // WriteTo can be used to produce output that can be later be loaded with\n@@ -88,21 +135,33 @@ func (r *recordingConn) Write(b []byte) (n int, err error) {\n }\n \n // WriteTo writes Go source code to w that contains the recorded traffic.\n-func (r *recordingConn) WriteTo(w io.Writer) {\n+func (r *recordingConn) WriteTo(w io.Writer) (int64, error) {\n \t// TLS always starts with a client to server flow.\n \tclientToServer := true\n-\n+\tvar written int64\n \tfor i, flow := range r.flows {\n \t\tsource, dest := \"client\", \"server\"\n \t\tif !clientToServer {\n \t\t\tsource, dest = dest, source\n \t\t}\n-\t\tfmt.Fprintf(w, \">>> Flow %d (%s to %s)\\n\", i+1, source, dest)\n+\t\tn, err := fmt.Fprintf(w, \">>> Flow %d (%s to %s)\\n\", i+1, source, dest)\n+\t\twritten += int64(n)\n+\t\tif err != nil {\n+\t\t\treturn written, err\n+\t\t}\n \t\tdumper := hex.Dumper(w)\n-\t\tdumper.Write(flow)\n-\t\tdumper.Close()\n+\t\tn, err = dumper.Write(flow)\n+\t\twritten += int64(n)\n+\t\tif err != nil {\n+\t\t\treturn written, err\n+\t\t}\n+\t\terr = dumper.Close()\n+\t\tif err != nil {\n+\t\t\treturn written, err\n+\t\t}\n \t\tclientToServer = !clientToServer\n \t}\n+\treturn written, nil\n }\n \n func parseTestData(r io.Reader) (flows [][]byte, err error) {"}, {"sha": "1b27c049ed3d56154cbfc82614610d617e9d1286", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 112, "deletions": 44, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -16,6 +16,8 @@ import (\n \t\"errors\"\n \t\"io\"\n \t\"math/big\"\n+\n+\t\"golang_org/x/crypto/curve25519\"\n )\n \n var errClientKeyExchange = errors.New(\"tls: invalid ClientKeyExchange message\")\n@@ -177,52 +179,71 @@ type ecdheKeyAgreement struct {\n \tversion    uint16\n \tsigType    uint8\n \tprivateKey []byte\n-\tcurve      elliptic.Curve\n-\tx, y       *big.Int\n+\tcurveid    CurveID\n+\n+\t// publicKey is used to store the peer's public value when X25519 is\n+\t// being used.\n+\tpublicKey []byte\n+\t// x and y are used to store the peer's public value when one of the\n+\t// NIST curves is being used.\n+\tx, y *big.Int\n }\n \n func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n-\tvar curveid CurveID\n \tpreferredCurves := config.curvePreferences()\n \n NextCandidate:\n \tfor _, candidate := range preferredCurves {\n \t\tfor _, c := range clientHello.supportedCurves {\n \t\t\tif candidate == c {\n-\t\t\t\tcurveid = c\n+\t\t\t\tka.curveid = c\n \t\t\t\tbreak NextCandidate\n \t\t\t}\n \t\t}\n \t}\n \n-\tif curveid == 0 {\n+\tif ka.curveid == 0 {\n \t\treturn nil, errors.New(\"tls: no supported elliptic curves offered\")\n \t}\n \n-\tvar ok bool\n-\tif ka.curve, ok = curveForCurveID(curveid); !ok {\n-\t\treturn nil, errors.New(\"tls: preferredCurves includes unsupported curve\")\n-\t}\n+\tvar ecdhePublic []byte\n \n-\tvar x, y *big.Int\n-\tvar err error\n-\tka.privateKey, x, y, err = elliptic.GenerateKey(ka.curve, config.rand())\n-\tif err != nil {\n-\t\treturn nil, err\n+\tif ka.curveid == X25519 {\n+\t\tvar scalar, public [32]byte\n+\t\tif _, err := io.ReadFull(config.rand(), scalar[:]); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tcurve25519.ScalarBaseMult(&public, &scalar)\n+\t\tka.privateKey = scalar[:]\n+\t\tecdhePublic = public[:]\n+\t} else {\n+\t\tcurve, ok := curveForCurveID(ka.curveid)\n+\t\tif !ok {\n+\t\t\treturn nil, errors.New(\"tls: preferredCurves includes unsupported curve\")\n+\t\t}\n+\n+\t\tvar x, y *big.Int\n+\t\tvar err error\n+\t\tka.privateKey, x, y, err = elliptic.GenerateKey(curve, config.rand())\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tecdhePublic = elliptic.Marshal(curve, x, y)\n \t}\n-\tecdhePublic := elliptic.Marshal(ka.curve, x, y)\n \n \t// http://tools.ietf.org/html/rfc4492#section-5.4\n \tserverECDHParams := make([]byte, 1+2+1+len(ecdhePublic))\n \tserverECDHParams[0] = 3 // named curve\n-\tserverECDHParams[1] = byte(curveid >> 8)\n-\tserverECDHParams[2] = byte(curveid)\n+\tserverECDHParams[1] = byte(ka.curveid >> 8)\n+\tserverECDHParams[2] = byte(ka.curveid)\n \tserverECDHParams[3] = byte(len(ecdhePublic))\n \tcopy(serverECDHParams[4:], ecdhePublic)\n \n \tsigAndHash := signatureAndHash{signature: ka.sigType}\n \n \tif ka.version >= VersionTLS12 {\n+\t\tvar err error\n \t\tif sigAndHash.hash, err = pickTLS12HashForSignature(ka.sigType, clientHello.signatureAndHashes); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -281,15 +302,32 @@ func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Cert\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n \t\treturn nil, errClientKeyExchange\n \t}\n-\tx, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])\n+\n+\tif ka.curveid == X25519 {\n+\t\tif len(ckx.ciphertext) != 1+32 {\n+\t\t\treturn nil, errClientKeyExchange\n+\t\t}\n+\n+\t\tvar theirPublic, sharedKey, scalar [32]byte\n+\t\tcopy(theirPublic[:], ckx.ciphertext[1:])\n+\t\tcopy(scalar[:], ka.privateKey)\n+\t\tcurve25519.ScalarMult(&sharedKey, &scalar, &theirPublic)\n+\t\treturn sharedKey[:], nil\n+\t}\n+\n+\tcurve, ok := curveForCurveID(ka.curveid)\n+\tif !ok {\n+\t\tpanic(\"internal error\")\n+\t}\n+\tx, y := elliptic.Unmarshal(curve, ckx.ciphertext[1:])\n \tif x == nil {\n \t\treturn nil, errClientKeyExchange\n \t}\n-\tif !ka.curve.IsOnCurve(x, y) {\n+\tif !curve.IsOnCurve(x, y) {\n \t\treturn nil, errClientKeyExchange\n \t}\n-\tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n-\tpreMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)\n+\tx, _ = curve.ScalarMult(x, y, ka.privateKey)\n+\tpreMasterSecret := make([]byte, (curve.Params().BitSize+7)>>3)\n \txBytes := x.Bytes()\n \tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n \n@@ -303,31 +341,40 @@ func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHell\n \tif skx.key[0] != 3 { // named curve\n \t\treturn errors.New(\"tls: server selected unsupported curve\")\n \t}\n-\tcurveid := CurveID(skx.key[1])<<8 | CurveID(skx.key[2])\n-\n-\tvar ok bool\n-\tif ka.curve, ok = curveForCurveID(curveid); !ok {\n-\t\treturn errors.New(\"tls: server selected unsupported curve\")\n-\t}\n+\tka.curveid = CurveID(skx.key[1])<<8 | CurveID(skx.key[2])\n \n \tpublicLen := int(skx.key[3])\n \tif publicLen+4 > len(skx.key) {\n \t\treturn errServerKeyExchange\n \t}\n-\tka.x, ka.y = elliptic.Unmarshal(ka.curve, skx.key[4:4+publicLen])\n-\tif ka.x == nil {\n-\t\treturn errServerKeyExchange\n-\t}\n-\tif !ka.curve.IsOnCurve(ka.x, ka.y) {\n-\t\treturn errServerKeyExchange\n-\t}\n \tserverECDHParams := skx.key[:4+publicLen]\n+\tpublicKey := serverECDHParams[4:]\n \n \tsig := skx.key[4+publicLen:]\n \tif len(sig) < 2 {\n \t\treturn errServerKeyExchange\n \t}\n \n+\tif ka.curveid == X25519 {\n+\t\tif len(publicKey) != 32 {\n+\t\t\treturn errors.New(\"tls: bad X25519 public value\")\n+\t\t}\n+\t\tka.publicKey = publicKey\n+\t} else {\n+\t\tcurve, ok := curveForCurveID(ka.curveid)\n+\t\tif !ok {\n+\t\t\treturn errors.New(\"tls: server selected unsupported curve\")\n+\t\t}\n+\n+\t\tka.x, ka.y = elliptic.Unmarshal(curve, publicKey)\n+\t\tif ka.x == nil {\n+\t\t\treturn errServerKeyExchange\n+\t\t}\n+\t\tif !curve.IsOnCurve(ka.x, ka.y) {\n+\t\t\treturn errServerKeyExchange\n+\t\t}\n+\t}\n+\n \tsigAndHash := signatureAndHash{signature: ka.sigType}\n \tif ka.version >= VersionTLS12 {\n \t\t// handle SignatureAndHashAlgorithm\n@@ -382,19 +429,40 @@ func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHell\n }\n \n func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n-\tif ka.curve == nil {\n+\tif ka.curveid == 0 {\n \t\treturn nil, nil, errors.New(\"tls: missing ServerKeyExchange message\")\n \t}\n-\tpriv, mx, my, err := elliptic.GenerateKey(ka.curve, config.rand())\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\tx, _ := ka.curve.ScalarMult(ka.x, ka.y, priv)\n-\tpreMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)\n-\txBytes := x.Bytes()\n-\tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n \n-\tserialized := elliptic.Marshal(ka.curve, mx, my)\n+\tvar serialized, preMasterSecret []byte\n+\n+\tif ka.curveid == X25519 {\n+\t\tvar ourPublic, theirPublic, sharedKey, scalar [32]byte\n+\n+\t\tif _, err := io.ReadFull(config.rand(), scalar[:]); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\n+\t\tcopy(theirPublic[:], ka.publicKey)\n+\t\tcurve25519.ScalarBaseMult(&ourPublic, &scalar)\n+\t\tcurve25519.ScalarMult(&sharedKey, &scalar, &theirPublic)\n+\t\tserialized = ourPublic[:]\n+\t\tpreMasterSecret = sharedKey[:]\n+\t} else {\n+\t\tcurve, ok := curveForCurveID(ka.curveid)\n+\t\tif !ok {\n+\t\t\tpanic(\"internal error\")\n+\t\t}\n+\t\tpriv, mx, my, err := elliptic.GenerateKey(curve, config.rand())\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tx, _ := curve.ScalarMult(ka.x, ka.y, priv)\n+\t\tpreMasterSecret = make([]byte, (curve.Params().BitSize+7)>>3)\n+\t\txBytes := x.Bytes()\n+\t\tcopy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)\n+\n+\t\tserialized = elliptic.Marshal(curve, mx, my)\n+\t}\n \n \tckx := new(clientKeyExchangeMsg)\n \tckx.ciphertext = make([]byte, 1+len(serialized))"}, {"sha": "099cef4ba9aa36ff4114c007c495e0e602efec1f", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-ECDSA-ECDSA", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,19 +1,20 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 59 02 00 00  55 03 01 38 1a 94 8d 84  |....Y...U..8....|\n-00000010  d7 a4 29 89 50 ad 07 97  5b c0 2c 7b 8c a6 75 0e  |..).P...[.,{..u.|\n-00000020  97 51 62 10 07 87 c5 6f  0a 5f 86 20 1d ac 1d 05  |.Qb....o._. ....|\n-00000030  ea 85 48 84 73 d9 07 8d  d0 81 56 99 81 10 7b 18  |..H.s.....V...{.|\n-00000040  e8 5e da a9 fe cd f9 91  88 31 9b 6e c0 09 00 00  |.^.......1.n....|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 4f 5d 09 43 37  |....Y...U..O].C7|\n+00000010  70 c6 d9 8b 07 ca 1a f0  fb a7 05 51 53 67 7a 7e  |p..........QSgz~|\n+00000020  c9 c6 68 10 10 2a 69 bd  47 db 8e 20 f2 13 5b 26  |..h..*i.G.. ..[&|\n+00000030  e6 8e 19 b0 bc b5 ee 1f  ca 44 5d 32 11 37 b0 78  |.........D]2.7.x|\n+00000040  49 16 6e c2 44 86 52 3f  9f 05 15 aa c0 09 00 00  |I.n.D.R?........|\n 00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n 00000060  01 02 0e 0b 00 02 0a 00  02 07 00 02 04 30 82 02  |.............0..|\n 00000070  00 30 82 01 62 02 09 00  b8 bf 2d 47 a0 d2 eb f4  |.0..b.....-G....|\n@@ -48,21 +49,20 @@\n 00000240  13 83 0d 94 06 bb d4 37  7a f6 ec 7a c9 86 2e dd  |.......7z..z....|\n 00000250  d7 11 69 7f 85 7c 56 de  fb 31 78 2b e4 c7 78 0d  |..i..|V..1x+..x.|\n 00000260  ae cb be 9e 4e 36 24 31  7b 6a 0f 39 95 12 07 8f  |....N6$1{j.9....|\n-00000270  2a 16 03 01 00 d5 0c 00  00 d1 03 00 17 41 04 68  |*............A.h|\n-00000280  37 18 3d 57 d2 5a 39 75  1e 7f 0a 3a 47 65 36 2e  |7.=W.Z9u...:Ge6.|\n-00000290  6d cb 8f aa 0f 0d 45 5e  3f 14 82 f5 8c b1 11 0a  |m.....E^?.......|\n-000002a0  8f e0 bc e4 07 d3 d5 bf  2d f4 82 ba cf c9 1c 88  |........-.......|\n-000002b0  33 72 a8 49 39 48 40 74  c6 96 c3 30 72 31 34 00  |3r.I9H@t...0r14.|\n-000002c0  8a 30 81 87 02 41 0e 43  2d 29 81 e9 c3 07 fc 5c  |.0...A.C-).....\\|\n-000002d0  ad c0 51 9e 0f cf c5 77  e4 bf 00 b6 66 f9 0e c6  |..Q....w....f...|\n-000002e0  40 c6 b5 49 a4 04 05 31  2c 7c 1f 24 38 80 1b 3f  |@..I...1,|.$8..?|\n-000002f0  16 5f c7 4d a8 7d 98 50  7f 7d 6d ed e9 19 1d 19  |._.M.}.P.}m.....|\n-00000300  7b fd ec c5 4d 18 ab 02  42 01 00 db 37 b7 fa 39  |{...M...B...7..9|\n-00000310  4b 3f 16 06 eb b8 4a 22  c6 de 00 d8 a7 eb a2 9e  |K?....J\"........|\n-00000320  e1 6f f4 a4 32 e2 ca d0  72 3a e5 f3 14 27 a0 dd  |.o..2...r:...'..|\n-00000330  c4 26 34 b3 6c a3 d0 03  90 7a 2e 0e bf 0b 63 63  |.&4.l....z....cc|\n-00000340  77 66 37 dd 1a 0f 7a 90  3f c8 a9 16 03 01 00 0e  |wf7...z.?.......|\n-00000350  0d 00 00 06 03 01 02 40  00 00 0e 00 00 00        |.......@......|\n+00000270  2a 16 03 01 00 b5 0c 00  00 b1 03 00 1d 20 56 b4  |*............ V.|\n+00000280  39 d4 8f 18 79 87 89 d0  04 ee 12 54 20 2b be c1  |9...y......T +..|\n+00000290  94 99 40 a2 73 df 1e 92  66 0b d1 f1 d6 38 00 8b  |..@.s...f....8..|\n+000002a0  30 81 88 02 42 01 38 12  59 bd ea 44 59 f4 6f a9  |0...B.8.Y..DY.o.|\n+000002b0  8e 9e a0 85 b5 b3 55 3e  76 49 b7 75 98 6e 81 30  |......U>vI.u.n.0|\n+000002c0  c4 73 bd 54 78 39 f7 e2  22 49 4c 93 0d c1 26 89  |.s.Tx9..\"IL...&.|\n+000002d0  08 b9 9c 8b 86 3e 81 2c  a5 50 7c e9 88 ec c0 ad  |.....>.,.P|.....|\n+000002e0  9e e0 40 ac 4e 0a fd 02  42 01 2e 0d 37 73 6a 0d  |..@.N...B...7sj.|\n+000002f0  a4 60 08 a0 2b 32 0f 87  8d f8 9b c7 68 cf 50 79  |.`..+2......h.Py|\n+00000300  73 f7 cf 93 aa 75 57 20  58 3d 13 c0 f3 66 7d 59  |s....uW X=...f}Y|\n+00000310  15 73 d4 29 03 34 df 33  00 c0 b5 71 bc 2a 90 ef  |.s.).4.3...q.*..|\n+00000320  3c 02 5e ea 9d 29 93 1c  18 db 04 16 03 01 00 0a  |<.^..)..........|\n+00000330  0d 00 00 06 03 01 02 40  00 00 16 03 01 00 04 0e  |.......@........|\n+00000340  00 00 00                                          |...|\n >>> Flow 3 (client to server)\n 00000000  16 03 01 02 0a 0b 00 02  06 00 02 03 00 02 00 30  |...............0|\n 00000010  82 01 fc 30 82 01 5e 02  09 00 9a 30 84 6c 26 35  |...0..^....0.l&5|\n@@ -97,34 +97,32 @@\n 000001e0  be e8 91 b3 da 1a f5 5d  a3 23 f5 26 8b 45 70 8d  |.......].#.&.Ep.|\n 000001f0  65 62 9b 7e 01 99 3d 18  f6 10 9a 38 61 9b 2e 57  |eb.~..=....8a..W|\n 00000200  e4 fa cc b1 8a ce e2 23  a0 87 f0 e1 67 51 eb 16  |.......#....gQ..|\n-00000210  03 01 00 46 10 00 00 42  41 04 1e 18 37 ef 0d 19  |...F...BA...7...|\n-00000220  51 88 35 75 71 b5 e5 54  5b 12 2e 8f 09 67 fd a7  |Q.5uq..T[....g..|\n-00000230  24 20 3e b2 56 1c ce 97  28 5e f8 2b 2d 4f 9e f1  |$ >.V...(^.+-O..|\n-00000240  07 9f 6c 4b 5b 83 56 e2  32 42 e9 58 b6 d7 49 a6  |..lK[.V.2B.X..I.|\n-00000250  b5 68 1a 41 03 56 6b dc  5a 89 16 03 01 00 90 0f  |.h.A.Vk.Z.......|\n-00000260  00 00 8c 00 8a 30 81 87  02 41 51 c5 53 a8 0f cb  |.....0...AQ.S...|\n-00000270  18 79 4a 59 53 62 17 bb  29 39 fa cd 56 6c 5c 29  |.yJYSb..)9..Vl\\)|\n-00000280  1f e3 bc df fb 9a 29 fa  38 1a 73 aa 4c 79 6b 1c  |......).8.s.Lyk.|\n-00000290  9f 1c 8e 95 c7 11 cc df  5d e9 c7 93 ce a3 9b e6  |........].......|\n-000002a0  94 17 24 3a 8e f8 9a a9  46 01 f9 02 42 01 a1 df  |..$:....F...B...|\n-000002b0  c5 cc fe 8d 5b 34 fb 89  2f f5 b3 3f 75 d7 19 1b  |....[4../..?u...|\n-000002c0  5e 0f 1a 2e 8f 2d 62 61  73 85 2c 03 3b 22 07 2f  |^....-bas.,.;\"./|\n-000002d0  6b f3 5c fb ba b2 87 54  1c ef d2 f8 82 f3 9e f8  |k.\\....T........|\n-000002e0  ce 1b fa ce b0 6d d0 85  f8 62 6e d6 ba 93 cc 14  |.....m...bn.....|\n-000002f0  03 01 00 01 01 16 03 01  00 30 76 90 a8 a2 8d 25  |.........0v....%|\n-00000300  c5 c2 ff ef 2b 76 83 2c  7a 0d 44 37 99 67 02 d3  |....+v.,z.D7.g..|\n-00000310  6e 3b 28 83 21 cf f5 6a  71 61 2d 5b 24 57 b2 19  |n;(.!..jqa-[$W..|\n-00000320  63 d4 e5 96 0c 0c e1 f3  3a 99                    |c.......:.|\n+00000210  03 01 00 25 10 00 00 21  20 2f e5 7d a3 47 cd 62  |...%...! /.}.G.b|\n+00000220  43 15 28 da ac 5f bb 29  07 30 ff f6 84 af c4 cf  |C.(.._.).0......|\n+00000230  c2 ed 90 99 5f 58 cb 3b  74 16 03 01 00 91 0f 00  |...._X.;t.......|\n+00000240  00 8d 00 8b 30 81 88 02  42 01 53 2c a8 59 57 d2  |....0...B.S,.YW.|\n+00000250  fc 0b 12 27 6f 9a f7 4e  a0 dd 2c af 1b 4c 81 0b  |...'o..N..,..L..|\n+00000260  97 79 7e 6f dd a1 cf cb  e2 14 4d af 76 99 d8 06  |.y~o......M.v...|\n+00000270  4f 8d 4f 86 d3 25 04 ea  80 02 ae 25 10 9d 2d 59  |O.O..%.....%..-Y|\n+00000280  11 39 65 6b 83 d0 16 7d  bf a8 a4 02 42 01 f2 16  |.9ek...}....B...|\n+00000290  6c f1 e6 3b b1 af fb 3f  99 f0 8a e3 c8 62 ba 71  |l..;...?.....b.q|\n+000002a0  12 a1 2c 1e 15 74 d5 98  b5 ae 9f 50 a2 15 9b 73  |..,..t.....P...s|\n+000002b0  9a 5f 2c 90 d4 9d 20 6f  35 b6 32 3e f4 b7 dd 50  |._,... o5.2>...P|\n+000002c0  64 42 e3 4e 51 f3 11 4b  b4 9e a3 92 a2 10 59 14  |dB.NQ..K......Y.|\n+000002d0  03 01 00 01 01 16 03 01  00 30 78 8c 7c 31 ce 16  |.........0x.|1..|\n+000002e0  8f 1f 2a b9 ee cb 72 7f  1e 59 5b ad c2 58 32 77  |..*...r..Y[..X2w|\n+000002f0  fa 46 83 b9 67 0c 5f 41  25 6a 38 ec 20 d2 80 e6  |.F..g._A%j8. ...|\n+00000300  be 85 ce 94 b1 89 5f 8d  17 9b                    |......_...|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 30 37 f0 ad 4c 11  |..........07..L.|\n-00000010  6d fb 54 90 13 d2 10 93  43 d8 be 3b d0 2b 14 a5  |m.T.....C..;.+..|\n-00000020  9d fb a6 5d 38 e0 f5 e9  a6 0a 8e 3d 99 a2 ec 96  |...]8......=....|\n-00000030  d8 ff 90 13 03 99 33 d7  15 29 5f                 |......3..)_|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 95 d6 f2 a2 75  |..........0....u|\n+00000010  0e f8 c7 7c f9 1d 65 b4  82 08 c9 62 aa 93 24 8f  |...|..e....b..$.|\n+00000020  4d 11 c7 b0 17 04 f1 0a  8b be 64 06 f9 07 20 0b  |M.........d... .|\n+00000030  f0 3b 92 db 62 ba 63 91  a1 58 fe                 |.;..b.c..X.|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 20 f9 59 b0  e2 8b f9 2c dd 30 1b 8f  |.... .Y....,.0..|\n-00000010  df 85 0f 17 88 23 5e ca  c9 d3 ca 5f 52 d4 33 e0  |.....#^...._R.3.|\n-00000020  d2 62 54 17 f2 17 03 01  00 20 62 2d 28 d2 55 68  |.bT...... b-(.Uh|\n-00000030  77 ab 6e c0 ac d9 cd 31  1c 38 aa 07 b3 e8 0d 89  |w.n....1.8......|\n-00000040  7e e4 f3 a0 65 84 f6 b8  c8 91 15 03 01 00 20 b5  |~...e......... .|\n-00000050  95 69 90 d7 32 d1 5a a5  e0 e2 6c 0a dc 00 1c 5e  |.i..2.Z...l....^|\n-00000060  d2 10 2b a2 3e ae a5 b2  63 9f c4 4e 62 56 db     |..+.>...c..NbV.|\n+00000000  17 03 01 00 20 3e a4 b5  b5 2f 4f c8 e0 08 cf 8a  |.... >.../O.....|\n+00000010  9c f6 69 94 a9 91 0f 5d  c5 06 ee 71 e2 42 11 b4  |..i....]...q.B..|\n+00000020  a8 17 54 19 3d 17 03 01  00 20 ce d2 8d 8a 78 e4  |..T.=.... ....x.|\n+00000030  15 a4 ab 83 0d 9c fa 47  1c 8f 2d 87 a8 55 65 9d  |.......G..-..Ue.|\n+00000040  7f 03 75 11 62 83 0b 44  0b f1 15 03 01 00 20 eb  |..u.b..D...... .|\n+00000050  1a 46 95 1e 1b 10 b7 25  a8 c4 5b db 8b 3c 61 c9  |.F.....%..[..<a.|\n+00000060  25 38 27 1e 69 11 18 16  0a 25 44 ad 9f 52 64     |%8'.i....%D..Rd|"}, {"sha": "7e9c2724abd82b297eb0049d29d606369a97ac94", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-ECDSA-RSA", "status": "modified", "additions": 93, "deletions": 82, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,60 +1,72 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 51 02 00 00  4d 03 01 4e 15 d3 06 f6  |....Q...M..N....|\n-00000010  ec 13 16 c5 fa 59 cf 5e  2f ad 85 b9 38 e7 7f fb  |.....Y.^/...8...|\n-00000020  85 cb da eb f2 2e 17 51  a2 b0 be 20 61 e4 32 c9  |.......Q... a.2.|\n-00000030  66 92 36 89 0c 0c f4 00  15 47 86 d9 e9 90 ab 2d  |f.6......G.....-|\n-00000040  8f a3 e2 5e f6 44 2c 6a  1d 98 88 5c 00 05 00 00  |...^.D,j...\\....|\n-00000050  05 ff 01 00 01 00 16 03  01 02 71 0b 00 02 6d 00  |..........q...m.|\n-00000060  02 6a 00 02 67 30 82 02  63 30 82 01 cc a0 03 02  |.j..g0..c0......|\n-00000070  01 02 02 09 00 a2 73 00  0c 81 00 cb f3 30 0d 06  |......s......0..|\n-00000080  09 2a 86 48 86 f7 0d 01  01 0b 05 00 30 2b 31 17  |.*.H........0+1.|\n-00000090  30 15 06 03 55 04 0a 13  0e 47 6f 6f 67 6c 65 20  |0...U....Google |\n-000000a0  54 45 53 54 49 4e 47 31  10 30 0e 06 03 55 04 03  |TESTING1.0...U..|\n-000000b0  13 07 47 6f 20 52 6f 6f  74 30 1e 17 0d 31 35 30  |..Go Root0...150|\n-000000c0  31 30 31 30 30 30 30 30  30 5a 17 0d 32 35 30 31  |101000000Z..2501|\n-000000d0  30 31 30 30 30 30 30 30  5a 30 26 31 17 30 15 06  |01000000Z0&1.0..|\n-000000e0  03 55 04 0a 13 0e 47 6f  6f 67 6c 65 20 54 45 53  |.U....Google TES|\n-000000f0  54 49 4e 47 31 0b 30 09  06 03 55 04 03 13 02 47  |TING1.0...U....G|\n-00000100  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n-00000110  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 af 87  |.......0........|\n-00000120  88 f6 20 1b 95 65 6c 14  ab 44 05 af 3b 45 14 e3  |.. ..el..D..;E..|\n-00000130  b7 6d fd 00 63 4d 95 7f  fe 6a 62 35 86 c0 4a f9  |.m..cM...jb5..J.|\n-00000140  18 7c f6 aa 25 5e 7a 64  31 66 00 ba f4 8e 92 af  |.|..%^zd1f......|\n-00000150  c7 6b d8 76 d4 f3 5f 41  cb 6e 56 15 97 1b 97 c1  |.k.v.._A.nV.....|\n-00000160  3c 12 39 21 66 3d 2b 16  d1 bc db 1c c0 a7 da b7  |<.9!f=+.........|\n-00000170  ca ad ba da cb d5 21 50  ec de 8d ab d1 6b 81 4b  |......!P.....k.K|\n-00000180  89 02 f3 c4 be c1 6c 89  b1 44 84 bd 21 d1 04 7d  |......l..D..!..}|\n-00000190  9d 16 4d f9 82 15 f6 ef  fa d6 09 47 f2 fb 02 03  |..M........G....|\n-000001a0  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n-000001b0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n-000001c0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n-000001d0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n-000001e0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n-000001f0  10 12 50 8d 89 6f 1b d1  dc 54 4d 6e cb 69 5e 06  |..P..o...TMn.i^.|\n-00000200  f4 30 1b 06 03 55 1d 23  04 14 30 12 80 10 bf 3d  |.0...U.#..0....=|\n-00000210  b6 a9 66 f2 b8 40 cf ea  b4 03 78 48 1a 41 30 19  |..f..@....xH.A0.|\n-00000220  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n-00000230  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n-00000240  86 f7 0d 01 01 0b 05 00  03 81 81 00 92 7c af 91  |.............|..|\n-00000250  55 12 18 96 59 31 a6 48  40 d5 2d d5 ee bb 02 a0  |U...Y1.H@.-.....|\n-00000260  f5 c2 1e 7c 9b b3 30 7d  3c dc 76 da 4f 3d c0 fa  |...|..0}<.v.O=..|\n-00000270  ae 2d 33 24 6b 03 7b 1b  67 59 11 21 b5 11 bc 77  |.-3$k.{.gY.!...w|\n-00000280  b9 d9 e0 6e a8 2d 2e 35  fa 64 5f 22 3e 63 10 6b  |...n.-.5.d_\">c.k|\n-00000290  be ff 14 86 6d 0d f0 15  31 a8 14 38 1e 3b 84 87  |....m...1..8.;..|\n-000002a0  2c cb 98 ed 51 76 b9 b1  4f dd db 9b 84 04 86 40  |,...Qv..O......@|\n-000002b0  fa 51 dd ba b4 8d eb e3  46 de 46 b9 4f 86 c7 f9  |.Q......F.F.O...|\n-000002c0  a4 c2 41 34 ac cc f6 ea  b0 ab 39 18 16 03 01 00  |..A4......9.....|\n-000002d0  0e 0d 00 00 06 03 01 02  40 00 00 0e 00 00 00     |........@......|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 32 7c 5c ac bd  |....Y...U..2|\\..|\n+00000010  77 70 c2 f8 f0 20 37 e4  e8 45 db be 97 22 e4 f3  |wp... 7..E...\"..|\n+00000020  24 1c c1 29 8f 02 e1 bc  ba 4a 1e 20 81 6f b5 12  |$..).....J. .o..|\n+00000030  c0 9d 9e de 2f b6 04 b2  74 34 da 2b 04 55 2c 4f  |..../...t4.+.U,O|\n+00000040  dd 01 8a 30 d9 67 45 9f  f1 31 f1 78 c0 13 00 00  |...0.gE..1.x....|\n+00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n+00000060  01 02 59 0b 00 02 55 00  02 52 00 02 4f 30 82 02  |..Y...U..R..O0..|\n+00000070  4b 30 82 01 b4 a0 03 02  01 02 02 09 00 e8 f0 9d  |K0..............|\n+00000080  3f e2 5b ea a6 30 0d 06  09 2a 86 48 86 f7 0d 01  |?.[..0...*.H....|\n+00000090  01 0b 05 00 30 1f 31 0b  30 09 06 03 55 04 0a 13  |....0.1.0...U...|\n+000000a0  02 47 6f 31 10 30 0e 06  03 55 04 03 13 07 47 6f  |.Go1.0...U....Go|\n+000000b0  20 52 6f 6f 74 30 1e 17  0d 31 36 30 31 30 31 30  | Root0...1601010|\n+000000c0  30 30 30 30 30 5a 17 0d  32 35 30 31 30 31 30 30  |00000Z..25010100|\n+000000d0  30 30 30 30 5a 30 1a 31  0b 30 09 06 03 55 04 0a  |0000Z0.1.0...U..|\n+000000e0  13 02 47 6f 31 0b 30 09  06 03 55 04 03 13 02 47  |..Go1.0...U....G|\n+000000f0  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n+00000100  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 db 46  |.......0.......F|\n+00000110  7d 93 2e 12 27 06 48 bc  06 28 21 ab 7e c4 b6 a2  |}...'.H..(!.~...|\n+00000120  5d fe 1e 52 45 88 7a 36  47 a5 08 0d 92 42 5b c2  |]..RE.z6G....B[.|\n+00000130  81 c0 be 97 79 98 40 fb  4f 6d 14 fd 2b 13 8b c2  |....y.@.Om..+...|\n+00000140  a5 2e 67 d8 d4 09 9e d6  22 38 b7 4a 0b 74 73 2b  |..g.....\"8.J.ts+|\n+00000150  c2 34 f1 d1 93 e5 96 d9  74 7b f3 58 9f 6c 61 3c  |.4......t{.X.la<|\n+00000160  c0 b0 41 d4 d9 2b 2b 24  23 77 5b 1c 3b bd 75 5d  |..A..++$#w[.;.u]|\n+00000170  ce 20 54 cf a1 63 87 1d  1e 24 c4 f3 1d 1a 50 8b  |. T..c...$....P.|\n+00000180  aa b6 14 43 ed 97 a7 75  62 f4 14 c8 52 d7 02 03  |...C...ub...R...|\n+00000190  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n+000001a0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n+000001b0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n+000001c0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n+000001d0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n+000001e0  10 9f 91 16 1f 43 43 3e  49 a6 de 6d b6 80 d7 9f  |.....CC>I..m....|\n+000001f0  60 30 1b 06 03 55 1d 23  04 14 30 12 80 10 48 13  |`0...U.#..0...H.|\n+00000200  49 4d 13 7e 16 31 bb a3  01 d5 ac ab 6e 7b 30 19  |IM.~.1......n{0.|\n+00000210  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n+00000220  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n+00000230  86 f7 0d 01 01 0b 05 00  03 81 81 00 9d 30 cc 40  |.............0.@|\n+00000240  2b 5b 50 a0 61 cb ba e5  53 58 e1 ed 83 28 a9 58  |+[P.a...SX...(.X|\n+00000250  1a a9 38 a4 95 a1 ac 31  5a 1a 84 66 3d 43 d3 2d  |..8....1Z..f=C.-|\n+00000260  d9 0b f2 97 df d3 20 64  38 92 24 3a 00 bc cf 9c  |...... d8.$:....|\n+00000270  7d b7 40 20 01 5f aa d3  16 61 09 a2 76 fd 13 c3  |}.@ ._...a..v...|\n+00000280  cc e1 0c 5c ee b1 87 82  f1 6c 04 ed 73 bb b3 43  |...\\.....l..s..C|\n+00000290  77 8d 0c 1c f1 0f a1 d8  40 83 61 c9 4c 72 2b 9d  |w.......@.a.Lr+.|\n+000002a0  ae db 46 06 06 4d f4 c1  b3 3e c0 d1 bd 42 d4 db  |..F..M...>...B..|\n+000002b0  fe 3d 13 60 84 5c 21 d3  3b e9 fa e7 16 03 01 00  |.=.`.\\!.;.......|\n+000002c0  aa 0c 00 00 a6 03 00 1d  20 2f f7 3b 44 1a 47 85  |........ /.;D.G.|\n+000002d0  d7 db 40 28 4e 6a f1 2f  1e b5 cc b0 58 0d 92 93  |..@(Nj./....X...|\n+000002e0  30 41 65 08 05 f7 51 23  57 00 80 87 0d c3 22 ff  |0Ae...Q#W.....\".|\n+000002f0  aa d1 3f 55 09 cf 98 dc  91 f8 d0 63 58 da dc 52  |..?U.......cX..R|\n+00000300  03 f0 06 a6 4e 7e 5b 96  a1 3b d7 8e 1e 68 50 ef  |....N~[..;...hP.|\n+00000310  59 3f 78 06 eb 9a 33 c5  01 3c e0 fb c6 f1 b6 bc  |Y?x...3..<......|\n+00000320  5a bc 95 e8 43 d9 ab 36  05 26 13 c5 a6 68 9b e2  |Z...C..6.&...h..|\n+00000330  b1 42 6e 89 60 5c b3 91  02 c5 8b ab 53 d1 d9 79  |.Bn.`\\......S..y|\n+00000340  d0 37 b5 5e 2c 16 72 29  f8 9c d0 4a 46 87 46 f4  |.7.^,.r)...JF.F.|\n+00000350  01 2b e8 6a 4f 59 d1 2d  3d de 4b 3b 0e c7 cd 42  |.+.jOY.-=.K;...B|\n+00000360  ae d2 94 e9 a6 6b 65 ad  3f 77 57 16 03 01 00 0a  |.....ke.?wW.....|\n+00000370  0d 00 00 06 03 01 02 40  00 00 16 03 01 00 04 0e  |.......@........|\n+00000380  00 00 00                                          |...|\n >>> Flow 3 (client to server)\n 00000000  16 03 01 02 0a 0b 00 02  06 00 02 03 00 02 00 30  |...............0|\n 00000010  82 01 fc 30 82 01 5e 02  09 00 9a 30 84 6c 26 35  |...0..^....0.l&5|\n@@ -89,33 +101,32 @@\n 000001e0  be e8 91 b3 da 1a f5 5d  a3 23 f5 26 8b 45 70 8d  |.......].#.&.Ep.|\n 000001f0  65 62 9b 7e 01 99 3d 18  f6 10 9a 38 61 9b 2e 57  |eb.~..=....8a..W|\n 00000200  e4 fa cc b1 8a ce e2 23  a0 87 f0 e1 67 51 eb 16  |.......#....gQ..|\n-00000210  03 01 00 86 10 00 00 82  00 80 73 bd 73 65 92 86  |..........s.se..|\n-00000220  23 41 14 79 7f d5 c1 10  ce 94 4d ad 9c c3 a9 87  |#A.y......M.....|\n-00000230  b5 32 52 f8 6b 11 93 2d  9b 98 0b 8b 1d c0 f6 53  |.2R.k..-.......S|\n-00000240  17 6d c7 9c 2e ae c9 6f  cc 99 23 38 37 1a 10 fe  |.m.....o..#87...|\n-00000250  05 0b b5 55 0a 14 e9 60  7d 70 26 98 e2 54 d9 65  |...U...`}p&..T.e|\n-00000260  cf 2e f4 53 5f 1d aa 3a  f6 33 7b eb 4c 0e b3 ff  |...S_..:.3{.L...|\n-00000270  5a db 36 2a 47 f3 df f9  fc f5 31 78 83 aa 6b 52  |Z.6*G.....1x..kR|\n-00000280  b7 ba 1a 96 bc fa c1 a1  a9 bb 2b f5 38 89 00 4d  |..........+.8..M|\n-00000290  e5 78 13 4e a4 38 46 42  dc 16 16 03 01 00 91 0f  |.x.N.8FB........|\n-000002a0  00 00 8d 00 8b 30 81 88  02 42 01 45 b9 8f b1 1f  |.....0...B.E....|\n-000002b0  72 80 2c 4f 2c 65 58 db  40 7e f1 d5 14 0b cc 4c  |r.,O,eX.@~.....L|\n-000002c0  8b 50 5c ee 93 45 95 3d  fe 00 5e 5e ca 13 56 8d  |.P\\..E.=..^^..V.|\n-000002d0  2b b3 1a 22 70 3f d2 41  cf 74 8f c3 0f 37 ba 97  |+..\"p?.A.t...7..|\n-000002e0  cb 29 16 77 92 df 19 35  f9 8a a0 8e 02 42 01 00  |.).w...5.....B..|\n-000002f0  3f 8b ce b1 2a 01 43 e8  2c b5 27 d1 19 bc 04 b3  |?...*.C.,.'.....|\n-00000300  c3 ad bf e8 12 37 57 6f  c9 01 7c 8e f4 4d 88 39  |.....7Wo..|..M.9|\n-00000310  4b 00 f6 ff fd 38 39 f8  3e 7f 49 d4 6a 82 94 6a  |K....89.>.I.j..j|\n-00000320  d3 f4 17 f2 a9 e0 ef 85  1e 01 85 b6 ca 89 91 ee  |................|\n-00000330  14 03 01 00 01 01 16 03  01 00 24 8d 82 24 82 55  |..........$..$.U|\n-00000340  c4 0e 45 8c f0 f3 e3 29  4e ff 6c ee 43 4b ca 68  |..E....)N.l.CK.h|\n-00000350  2e 12 98 cf ce b6 7e fa  73 07 e1 0f aa 7f 80     |......~.s......|\n+00000210  03 01 00 25 10 00 00 21  20 2f e5 7d a3 47 cd 62  |...%...! /.}.G.b|\n+00000220  43 15 28 da ac 5f bb 29  07 30 ff f6 84 af c4 cf  |C.(.._.).0......|\n+00000230  c2 ed 90 99 5f 58 cb 3b  74 16 03 01 00 91 0f 00  |...._X.;t.......|\n+00000240  00 8d 00 8b 30 81 88 02  42 01 b3 df 59 06 71 e6  |....0...B...Y.q.|\n+00000250  74 c9 9d d5 2c b0 a7 f8  1e ac bc f3 5a e2 ed 0b  |t...,.......Z...|\n+00000260  f2 e9 37 82 c6 fe 7c 23  b9 63 6e 88 1d 63 31 ad  |..7...|#.cn..c1.|\n+00000270  d3 29 48 eb f3 5d 52 f5  76 ab fc 16 9e 09 4f 49  |.)H..]R.v.....OI|\n+00000280  cf b4 03 6a ed db e5 13  ea 67 74 02 42 01 8e 2f  |...j.....gt.B../|\n+00000290  b8 12 38 c9 a6 8c 77 40  85 89 ef d8 ac 08 00 c0  |..8...w@........|\n+000002a0  ee 70 68 a6 88 1f d1 67  0d 1b 7b 1f be e0 a7 b9  |.ph....g..{.....|\n+000002b0  c3 7d ff 6a 39 3c b9 aa  f6 78 ac 9a ca 67 55 0c  |.}.j9<...x...gU.|\n+000002c0  38 23 cc ab 18 c0 b9 ea  9c 84 61 32 0a 0d f3 14  |8#........a2....|\n+000002d0  03 01 00 01 01 16 03 01  00 30 73 12 76 94 30 37  |.........0s.v.07|\n+000002e0  e5 e3 30 59 88 2f 5f e9  f2 7b 3d 02 88 65 09 14  |..0Y./_..{=..e..|\n+000002f0  68 23 02 d0 ae e5 7f 7f  8d 95 3b 1c 75 f5 1f 24  |h#........;.u..$|\n+00000300  43 60 29 bb 0e 69 88 36  a9 68                    |C`)..i.6.h|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 24 21 a3 eb a6 f5  |..........$!....|\n-00000010  d0 17 38 9b 89 ec f3 39  23 33 f6 49 51 41 97 92  |..8....9#3.IQA..|\n-00000020  a6 64 bd 60 68 9d 0e 45  06 2f dd ff 79 b6 50     |.d.`h..E./..y.P|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 a0 5f 7f 59 e0  |..........0._.Y.|\n+00000010  b1 7e ed ad de 6a 47 94  21 e5 1b 77 a7 d0 88 fd  |.~...jG.!..w....|\n+00000020  9e 4e 48 87 1d cf 40 e4  b9 38 a3 2e e4 00 c3 94  |.NH...@..8......|\n+00000030  95 20 1c 97 d2 a9 3a 11  86 30 5f                 |. ....:..0_|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 1a d2 72 d5  91 9d fc 6c 22 02 cc 32  |......r....l\"..2|\n-00000010  58 5c 8a f6 75 11 48 e1  3f e4 e5 81 29 63 62 15  |X\\..u.H.?...)cb.|\n-00000020  03 01 00 16 b6 9a 1f 43  d4 ae b7 16 25 ce ae b7  |.......C....%...|\n-00000030  6c 37 f7 35 0a 26 7d ea  1f 80                    |l7.5.&}...|\n+00000000  17 03 01 00 20 ca 4c f5  cb 81 66 2f 97 e3 5d 8b  |.... .L...f/..].|\n+00000010  dd 7d dd fa fe 8c 98 45  3f 3d 16 17 98 4d b5 15  |.}.....E?=...M..|\n+00000020  6c 91 8a 79 7a 17 03 01  00 20 96 ec 30 cb d3 78  |l..yz.... ..0..x|\n+00000030  b9 0a a1 ab fd 12 25 d5  82 7b 7a 3c 17 56 7b b7  |......%..{z<.V{.|\n+00000040  c4 6e ea a2 5b d7 6b b6  22 a9 15 03 01 00 20 ba  |.n..[.k.\"..... .|\n+00000050  ff fe 2b 60 83 34 ad 45  75 15 d5 95 b3 27 92 46  |..+`.4.Eu....'.F|\n+00000060  47 ae f1 d4 a4 9d 63 ef  db d9 b5 37 0f f1 74     |G.....c....7..t|"}, {"sha": "67772e174aade91ab740004fade84738573f9862", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-RSA-ECDSA", "status": "modified", "additions": 87, "deletions": 89, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,19 +1,20 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 59 02 00 00  55 03 01 eb ed 76 6a 07  |....Y...U....vj.|\n-00000010  65 02 ec 6f 93 a0 38 21  09 0d d7 bf 11 20 51 eb  |e..o..8!..... Q.|\n-00000020  cc 00 08 9b 7a 98 c4 c5  02 ff c1 20 f9 1b c7 66  |....z...... ...f|\n-00000030  35 40 8c 67 8d 7f d5 c8  28 f0 cb d2 f9 da af 7a  |5@.g....(......z|\n-00000040  ea 4e 42 f2 5d 44 1c cc  92 36 b1 10 c0 09 00 00  |.NB.]D...6......|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 ed 13 de 15 cc  |....Y...U.......|\n+00000010  90 4f f3 72 5a d4 7a 01  26 fa 7a ae 38 92 a0 d6  |.O.rZ.z.&.z.8...|\n+00000020  70 4a 20 f6 7e 11 f7 ac  e6 94 87 20 9f 37 0f 8f  |pJ .~...... .7..|\n+00000030  55 a6 6a 97 b8 0f 56 aa  2d 69 c5 79 01 d5 c0 01  |U.j...V.-i.y....|\n+00000040  2c 2b 0e 16 d8 79 a3 f3  44 99 7c 01 c0 09 00 00  |,+...y..D.|.....|\n 00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n 00000060  01 02 0e 0b 00 02 0a 00  02 07 00 02 04 30 82 02  |.............0..|\n 00000070  00 30 82 01 62 02 09 00  b8 bf 2d 47 a0 d2 eb f4  |.0..b.....-G....|\n@@ -48,82 +49,79 @@\n 00000240  13 83 0d 94 06 bb d4 37  7a f6 ec 7a c9 86 2e dd  |.......7z..z....|\n 00000250  d7 11 69 7f 85 7c 56 de  fb 31 78 2b e4 c7 78 0d  |..i..|V..1x+..x.|\n 00000260  ae cb be 9e 4e 36 24 31  7b 6a 0f 39 95 12 07 8f  |....N6$1{j.9....|\n-00000270  2a 16 03 01 00 d5 0c 00  00 d1 03 00 17 41 04 34  |*............A.4|\n-00000280  47 57 64 b3 20 6d eb 17  9c 36 d4 aa 78 8b 20 26  |GWd. m...6..x. &|\n-00000290  6f 22 10 79 5f 96 69 62  1d ae 9f c7 40 17 1e 30  |o\".y_.ib....@..0|\n-000002a0  10 db d1 13 51 d8 63 61  ef 8e fb 34 d6 02 95 ac  |....Q.ca...4....|\n-000002b0  fb 33 72 a9 46 ff 27 b1  15 ca dd 81 8f 5a 58 00  |.3r.F.'......ZX.|\n-000002c0  8a 30 81 87 02 41 5c 09  1a 87 40 f3 1a 87 84 31  |.0...A\\...@....1|\n-000002d0  62 6c e5 a5 c0 3c cc ba  5d 4a 5e 65 ea e0 60 83  |bl...<..]J^e..`.|\n-000002e0  fe fe 99 1d 66 4a bb 6c  0d 5e 25 64 e3 92 ce eb  |....fJ.l.^%d....|\n-000002f0  15 39 42 a6 b0 98 a1 d3  79 65 c7 fc e7 c7 64 c7  |.9B.....ye....d.|\n-00000300  69 9c 2f 7e 00 c1 a3 02  42 01 f2 61 91 ae 8e f6  |i./~....B..a....|\n-00000310  88 99 70 55 32 4a fe 08  31 f0 8d d6 e6 1d fa a1  |..pU2J..1.......|\n-00000320  76 b6 16 98 58 8e 46 30  b1 00 b6 dd 5d 70 bb e1  |v...X.F0....]p..|\n-00000330  81 89 bd aa ac b5 7f 9b  d3 c0 8b 4b c3 36 00 87  |...........K.6..|\n-00000340  47 0c 34 92 27 c3 aa bd  0d 7c 36 16 03 01 00 0e  |G.4.'....|6.....|\n-00000350  0d 00 00 06 03 01 02 40  00 00 0e 00 00 00        |.......@......|\n+00000270  2a 16 03 01 00 b4 0c 00  00 b0 03 00 1d 20 ca e8  |*............ ..|\n+00000280  ef 79 56 cd aa eb 12 8f  e1 89 d1 3c 63 1f c8 54  |.yV........<c..T|\n+00000290  5f 4e cf 6b 72 7d 1c bb  f6 80 ae 17 33 69 00 8a  |_N.kr}......3i..|\n+000002a0  30 81 87 02 42 01 d1 45  df fc 46 21 5b 9b 49 f0  |0...B..E..F![.I.|\n+000002b0  3c f2 16 65 1e 33 90 d8  be 1d 65 12 2f 46 93 5b  |<..e.3....e./F.[|\n+000002c0  e2 14 67 b8 67 9b c1 10  31 a1 96 b8 86 c3 8b 26  |..g.g...1......&|\n+000002d0  3f da 5e 86 e7 b1 f9 3f  f1 04 57 ed e6 6f a5 86  |?.^....?..W..o..|\n+000002e0  f7 58 38 6e 0d ae 42 02  41 05 1b 07 9b 4c 4d 39  |.X8n..B.A....LM9|\n+000002f0  2d 0c 4e d7 94 d6 86 c9  6c b9 4d 54 a2 56 87 12  |-.N.....l.MT.V..|\n+00000300  08 ec 4e f1 a4 19 5e 52  69 ed 9f 6c 59 5f 31 0f  |..N...^Ri..lY_1.|\n+00000310  8d 33 1f a7 42 e5 56 9d  54 f4 18 9b 33 31 97 b9  |.3..B.V.T...31..|\n+00000320  57 55 c9 9f ea 7d f2 9e  24 e0 16 03 01 00 0a 0d  |WU...}..$.......|\n+00000330  00 00 06 03 01 02 40 00  00 16 03 01 00 04 0e 00  |......@.........|\n+00000340  00 00                                             |..|\n >>> Flow 3 (client to server)\n-00000000  16 03 01 01 fb 0b 00 01  f7 00 01 f4 00 01 f1 30  |...............0|\n-00000010  82 01 ed 30 82 01 58 a0  03 02 01 02 02 01 00 30  |...0..X........0|\n-00000020  0b 06 09 2a 86 48 86 f7  0d 01 01 05 30 26 31 10  |...*.H......0&1.|\n-00000030  30 0e 06 03 55 04 0a 13  07 41 63 6d 65 20 43 6f  |0...U....Acme Co|\n-00000040  31 12 30 10 06 03 55 04  03 13 09 31 32 37 2e 30  |1.0...U....127.0|\n-00000050  2e 30 2e 31 30 1e 17 0d  31 31 31 32 30 38 30 37  |.0.10...11120807|\n-00000060  35 35 31 32 5a 17 0d 31  32 31 32 30 37 30 38 30  |5512Z..121207080|\n-00000070  30 31 32 5a 30 26 31 10  30 0e 06 03 55 04 0a 13  |012Z0&1.0...U...|\n-00000080  07 41 63 6d 65 20 43 6f  31 12 30 10 06 03 55 04  |.Acme Co1.0...U.|\n-00000090  03 13 09 31 32 37 2e 30  2e 30 2e 31 30 81 9c 30  |...127.0.0.10..0|\n-000000a0  0b 06 09 2a 86 48 86 f7  0d 01 01 01 03 81 8c 00  |...*.H..........|\n-000000b0  30 81 88 02 81 80 4e d0  7b 31 e3 82 64 d9 59 c0  |0.....N.{1..d.Y.|\n-000000c0  c2 87 a4 5e 1e 8b 73 33  c7 63 53 df 66 92 06 84  |...^..s3.cS.f...|\n-000000d0  f6 64 d5 8f e4 36 a7 1d  2b e8 b3 20 36 45 23 b5  |.d...6..+.. 6E#.|\n-000000e0  e3 95 ae ed e0 f5 20 9c  8d 95 df 7f 5a 12 ef 87  |...... .....Z...|\n-000000f0  e4 5b 68 e4 e9 0e 74 ec  04 8a 7f de 93 27 c4 01  |.[h...t......'..|\n-00000100  19 7a bd f2 dc 3d 14 ab  d0 54 ca 21 0c d0 4d 6e  |.z...=...T.!..Mn|\n-00000110  87 2e 5c c5 d2 bb 4d 4b  4f ce b6 2c f7 7e 88 ec  |..\\...MKO..,.~..|\n-00000120  7c d7 02 91 74 a6 1e 0c  1a da e3 4a 5a 2e de 13  ||...t......JZ...|\n-00000130  9c 4c 40 88 59 93 02 03  01 00 01 a3 32 30 30 30  |.L@.Y.......2000|\n-00000140  0e 06 03 55 1d 0f 01 01  ff 04 04 03 02 00 a0 30  |...U...........0|\n-00000150  0d 06 03 55 1d 0e 04 06  04 04 01 02 03 04 30 0f  |...U..........0.|\n-00000160  06 03 55 1d 23 04 08 30  06 80 04 01 02 03 04 30  |..U.#..0.......0|\n-00000170  0b 06 09 2a 86 48 86 f7  0d 01 01 05 03 81 81 00  |...*.H..........|\n-00000180  36 1f b3 7a 0c 75 c9 6e  37 46 61 2b d5 bd c0 a7  |6..z.u.n7Fa+....|\n-00000190  4b cc 46 9a 81 58 7c 85  79 29 c8 c8 c6 67 dd 32  |K.F..X|.y)...g.2|\n-000001a0  56 45 2b 75 b6 e9 24 a9  50 9a be 1f 5a fa 1a 15  |VE+u..$.P...Z...|\n-000001b0  d9 cc 55 95 72 16 83 b9  c2 b6 8f fd 88 8c 38 84  |..U.r.........8.|\n-000001c0  1d ab 5d 92 31 13 4f fd  83 3b c6 9d f1 11 62 b6  |..].1.O..;....b.|\n-000001d0  8b ec ab 67 be c8 64 b0  11 50 46 58 17 6b 99 1c  |...g..d..PFX.k..|\n-000001e0  d3 1d fc 06 f1 0e e5 96  a8 0c f9 78 20 b7 44 18  |...........x .D.|\n-000001f0  51 8d 10 7e 4f 94 67 df  a3 4e 70 73 8e 90 91 85  |Q..~O.g..Nps....|\n-00000200  16 03 01 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n-00000210  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n-00000220  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n-00000230  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n-00000240  a6 b5 68 1a 41 03 56 6b  dc 5a 89 16 03 01 00 86  |..h.A.Vk.Z......|\n-00000250  0f 00 00 82 00 80 1e 4d  89 4e e2 82 ca 5d 31 8a  |.......M.N...]1.|\n-00000260  66 c7 c2 d6 00 4d 2e 1e  94 34 61 6b 86 3d 78 60  |f....M...4ak.=x`|\n-00000270  70 e1 71 93 22 df 5d 81  d3 d7 33 10 f5 01 f9 1d  |p.q.\".]...3.....|\n-00000280  e2 4a 91 22 67 ae 5b 2f  4c d9 43 31 35 c6 01 ad  |.J.\"g.[/L.C15...|\n-00000290  59 86 03 a1 9b c5 ea a5  2d aa ef 46 5a a8 70 57  |Y.......-..FZ.pW|\n-000002a0  50 59 ea 7a 07 32 bb a6  a1 11 33 05 d8 88 2e 42  |PY.z.2....3....B|\n-000002b0  d8 7b f7 34 be 5e 5f 42  9f 6a 90 ed d7 4b c4 7e  |.{.4.^_B.j...K.~|\n-000002c0  f9 5c a5 ff 28 f8 a1 f1  8f 1c e0 7a 37 a0 49 e5  |.\\..(......z7.I.|\n-000002d0  ce 11 46 ef 5f 06 14 03  01 00 01 01 16 03 01 00  |..F._...........|\n-000002e0  30 cb 08 f0 3c d4 21 f2  3a 7d db 59 75 80 48 24  |0...<.!.:}.Yu.H$|\n-000002f0  27 6f 2c 26 50 a4 7d 6c  91 d5 5d f7 c9 b4 bd 15  |'o,&P.}l..].....|\n-00000300  a8 8a 12 d5 40 8c 9a 0f  56 67 66 89 dd 12 36 d8  |....@...Vgf...6.|\n-00000310  d3                                                |.|\n+00000000  16 03 01 01 fd 0b 00 01  f9 00 01 f6 00 01 f3 30  |...............0|\n+00000010  82 01 ef 30 82 01 58 a0  03 02 01 02 02 10 5c 19  |...0..X.......\\.|\n+00000020  c1 89 65 83 55 6f dc 0b  c9 b9 93 9f e9 bc 30 0d  |..e.Uo........0.|\n+00000030  06 09 2a 86 48 86 f7 0d  01 01 0b 05 00 30 12 31  |..*.H........0.1|\n+00000040  10 30 0e 06 03 55 04 0a  13 07 41 63 6d 65 20 43  |.0...U....Acme C|\n+00000050  6f 30 1e 17 0d 31 36 30  38 31 37 32 31 35 32 33  |o0...16081721523|\n+00000060  31 5a 17 0d 31 37 30 38  31 37 32 31 35 32 33 31  |1Z..170817215231|\n+00000070  5a 30 12 31 10 30 0e 06  03 55 04 0a 13 07 41 63  |Z0.1.0...U....Ac|\n+00000080  6d 65 20 43 6f 30 81 9f  30 0d 06 09 2a 86 48 86  |me Co0..0...*.H.|\n+00000090  f7 0d 01 01 01 05 00 03  81 8d 00 30 81 89 02 81  |...........0....|\n+000000a0  81 00 ba 6f aa 86 bd cf  bf 9f f2 ef 5c 94 60 78  |...o........\\.`x|\n+000000b0  6f e8 13 f2 d1 96 6f cd  d9 32 6e 22 37 ce 41 f9  |o.....o..2n\"7.A.|\n+000000c0  ca 5d 29 ac e1 27 da 61  a2 ee 81 cb 10 c7 df 34  |.])..'.a.......4|\n+000000d0  58 95 86 e9 3d 19 e6 5c  27 73 60 c8 8d 78 02 f4  |X...=..\\'s`..x..|\n+000000e0  1d a4 98 09 a3 19 70 69  3c 25 62 66 2a ab 22 23  |......pi<%bf*.\"#|\n+000000f0  c5 7b 85 38 4f 2e 09 73  32 a7 bd 3e 9b ad ca 84  |.{.8O..s2..>....|\n+00000100  07 e6 0f 3a ff 77 c5 9d  41 85 00 8a b6 9b ee b0  |...:.w..A.......|\n+00000110  a4 3f 2d 4c 4c e6 42 3e  bb 51 c8 dd 48 54 f4 0c  |.?-LL.B>.Q..HT..|\n+00000120  8e 47 02 03 01 00 01 a3  46 30 44 30 0e 06 03 55  |.G......F0D0...U|\n+00000130  1d 0f 01 01 ff 04 04 03  02 05 a0 30 13 06 03 55  |...........0...U|\n+00000140  1d 25 04 0c 30 0a 06 08  2b 06 01 05 05 07 03 01  |.%..0...+.......|\n+00000150  30 0c 06 03 55 1d 13 01  01 ff 04 02 30 00 30 0f  |0...U.......0.0.|\n+00000160  06 03 55 1d 11 04 08 30  06 87 04 7f 00 00 01 30  |..U....0.......0|\n+00000170  0d 06 09 2a 86 48 86 f7  0d 01 01 0b 05 00 03 81  |...*.H..........|\n+00000180  81 00 46 ab 44 a2 fb 28  54 f8 5a 67 f8 62 94 f1  |..F.D..(T.Zg.b..|\n+00000190  9a b2 18 9e f2 b1 de 1d  7e 6f 76 95 a9 ba e7 5d  |........~ov....]|\n+000001a0  a8 16 6c 9c f7 09 d3 37  e4 4b 2b 36 7c 01 ad 41  |..l....7.K+6|..A|\n+000001b0  d2 32 d8 c3 d2 93 f9 10  6b 8e 95 b9 2c 17 8a a3  |.2......k...,...|\n+000001c0  44 48 bc 59 13 83 16 04  88 a4 81 5c 25 0d 98 0c  |DH.Y.......\\%...|\n+000001d0  ac 11 b1 28 56 be 1d cd  61 62 84 09 bf d6 80 c6  |...(V...ab......|\n+000001e0  45 8d 82 2c b4 d8 83 9b  db c9 22 b7 2a 12 11 7b  |E..,......\".*..{|\n+000001f0  fa 02 3b c1 c9 ff ea c9  9d a8 49 d3 95 d7 d5 0e  |..;.......I.....|\n+00000200  e5 35 16 03 01 00 25 10  00 00 21 20 2f e5 7d a3  |.5....%...! /.}.|\n+00000210  47 cd 62 43 15 28 da ac  5f bb 29 07 30 ff f6 84  |G.bC.(.._.).0...|\n+00000220  af c4 cf c2 ed 90 99 5f  58 cb 3b 74 16 03 01 00  |......._X.;t....|\n+00000230  86 0f 00 00 82 00 80 8f  6f 77 5d d5 99 28 0c 7a  |........ow]..(.z|\n+00000240  36 f2 50 ec 9a e6 eb 88  ac 45 f7 9b 6f 98 84 ba  |6.P......E..o...|\n+00000250  fb 3c b8 d6 54 61 b8 87  25 50 3c 31 5a d2 c1 54  |.<..Ta..%P<1Z..T|\n+00000260  e8 ed c3 93 cc 98 b1 c3  d4 84 11 d8 a0 c7 ae 67  |...............g|\n+00000270  67 35 6a 0f 93 18 bb 18  52 f8 25 88 1f d2 19 4d  |g5j.....R.%....M|\n+00000280  3b 4c f2 0f f7 06 68 57  cf 45 20 e0 57 75 37 e9  |;L....hW.E .Wu7.|\n+00000290  cd 86 1f e5 d2 90 1e cf  3a 18 fd 45 bc a1 84 63  |........:..E...c|\n+000002a0  36 d8 ac 6b 09 41 da 0a  87 7f ab ce 8e 49 e6 c8  |6..k.A.......I..|\n+000002b0  bf fb 2c 3b 7b e9 ae 14  03 01 00 01 01 16 03 01  |..,;{...........|\n+000002c0  00 30 7d 65 9c c1 25 e4  85 d7 39 d4 67 cf eb f1  |.0}e..%...9.g...|\n+000002d0  b7 c2 4d e6 5d bd 13 74  55 22 f0 8a 7e a6 a2 eb  |..M.]..tU\"..~...|\n+000002e0  93 cc b7 fa 86 b1 b5 e0  a3 ef ee 56 f0 cd f7 a5  |...........V....|\n+000002f0  d8 9e                                             |..|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 30 02 e3 be 9d 2d  |..........0....-|\n-00000010  6f 2c 9a b7 b4 f1 a5 30  ec 3e ae 05 e6 02 19 2f  |o,.....0.>...../|\n-00000020  a4 ac d1 6e ac de 75 4e  cc 14 e6 78 5a ea 27 7f  |...n..uN...xZ.'.|\n-00000030  4e 45 c4 9d b2 da a6 ea  b7 d2 7e                 |NE........~|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 ff 13 14 c5 ad  |..........0.....|\n+00000010  88 ec a1 cf cc 0d 3f 7b  ec 50 4a 25 69 1f 18 dc  |......?{.PJ%i...|\n+00000020  b1 99 1f 3b 78 60 e0 83  c0 cd 9a b3 0d 59 0b f8  |...;x`.......Y..|\n+00000030  8a b7 7c 2c b4 2c e4 d0  49 82 82                 |..|,.,..I..|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 20 e0 71 e9  54 11 6e 48 4b be a2 2a  |.... .q.T.nHK..*|\n-00000010  b1 70 d2 2c 74 c0 f4 74  05 f1 d3 d6 84 29 58 f7  |.p.,t..t.....)X.|\n-00000020  87 90 84 2b c8 17 03 01  00 20 b6 a2 e9 e0 f0 0d  |...+..... ......|\n-00000030  d5 ef d7 32 6d cb 99 5d  a6 37 c2 6e f9 c3 8e 6f  |...2m..].7.n...o|\n-00000040  76 71 d8 a6 c5 ae 4e 04  77 06 15 03 01 00 20 f2  |vq....N.w..... .|\n-00000050  09 ab dc 37 90 78 3a 2a  41 ab 9b a9 c1 78 2a 64  |...7.x:*A....x*d|\n-00000060  a8 3f 21 c4 bb af 76 b3  c6 2f e1 20 a3 b1 1e     |.?!...v../. ...|\n+00000000  17 03 01 00 20 51 91 74  f6 31 07 15 6b 9e 0b 28  |.... Q.t.1..k..(|\n+00000010  02 b8 ec 9d c6 e3 15 24  d3 ea 4b 27 d0 fa 9f c2  |.......$..K'....|\n+00000020  c4 8d 37 b3 d9 17 03 01  00 20 7d 97 75 fe de 3f  |..7...... }.u..?|\n+00000030  ae ab e6 a8 1d 76 1c 06  9c 02 61 cc f5 1d fe c8  |.....v....a.....|\n+00000040  a2 dc ae 97 7f 1c 05 19  e5 14 15 03 01 00 20 4a  |.............. J|\n+00000050  bc 45 97 6b 09 8e 47 5f  d5 a0 97 78 79 67 09 8d  |.E.k..G_...xyg..|\n+00000060  d3 80 38 58 5c cc ae 8e  d4 67 1d 93 2b 20 79     |..8X\\....g..+ y|"}, {"sha": "e585894db7e635e4f6a8112c20add1a507669070", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-RSA-RSA", "status": "modified", "additions": 125, "deletions": 114, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,120 +1,131 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 51 02 00 00  4d 03 01 e5 d7 4b 56 7b  |....Q...M....KV{|\n-00000010  a8 2c 07 33 fc 66 d7 79  e9 26 91 56 7d 9d 99 1d  |.,.3.f.y.&.V}...|\n-00000020  b2 24 36 2c f6 78 3a e7  63 15 f6 20 9f e1 d4 07  |.$6,.x:.c.. ....|\n-00000030  a9 75 3d b9 3b 8c 46 cb  a7 37 36 56 af 4e 99 cf  |.u=.;.F..76V.N..|\n-00000040  90 49 e1 e9 69 25 81 0f  fd 22 48 e6 00 05 00 00  |.I..i%...\"H.....|\n-00000050  05 ff 01 00 01 00 16 03  01 02 71 0b 00 02 6d 00  |..........q...m.|\n-00000060  02 6a 00 02 67 30 82 02  63 30 82 01 cc a0 03 02  |.j..g0..c0......|\n-00000070  01 02 02 09 00 a2 73 00  0c 81 00 cb f3 30 0d 06  |......s......0..|\n-00000080  09 2a 86 48 86 f7 0d 01  01 0b 05 00 30 2b 31 17  |.*.H........0+1.|\n-00000090  30 15 06 03 55 04 0a 13  0e 47 6f 6f 67 6c 65 20  |0...U....Google |\n-000000a0  54 45 53 54 49 4e 47 31  10 30 0e 06 03 55 04 03  |TESTING1.0...U..|\n-000000b0  13 07 47 6f 20 52 6f 6f  74 30 1e 17 0d 31 35 30  |..Go Root0...150|\n-000000c0  31 30 31 30 30 30 30 30  30 5a 17 0d 32 35 30 31  |101000000Z..2501|\n-000000d0  30 31 30 30 30 30 30 30  5a 30 26 31 17 30 15 06  |01000000Z0&1.0..|\n-000000e0  03 55 04 0a 13 0e 47 6f  6f 67 6c 65 20 54 45 53  |.U....Google TES|\n-000000f0  54 49 4e 47 31 0b 30 09  06 03 55 04 03 13 02 47  |TING1.0...U....G|\n-00000100  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n-00000110  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 af 87  |.......0........|\n-00000120  88 f6 20 1b 95 65 6c 14  ab 44 05 af 3b 45 14 e3  |.. ..el..D..;E..|\n-00000130  b7 6d fd 00 63 4d 95 7f  fe 6a 62 35 86 c0 4a f9  |.m..cM...jb5..J.|\n-00000140  18 7c f6 aa 25 5e 7a 64  31 66 00 ba f4 8e 92 af  |.|..%^zd1f......|\n-00000150  c7 6b d8 76 d4 f3 5f 41  cb 6e 56 15 97 1b 97 c1  |.k.v.._A.nV.....|\n-00000160  3c 12 39 21 66 3d 2b 16  d1 bc db 1c c0 a7 da b7  |<.9!f=+.........|\n-00000170  ca ad ba da cb d5 21 50  ec de 8d ab d1 6b 81 4b  |......!P.....k.K|\n-00000180  89 02 f3 c4 be c1 6c 89  b1 44 84 bd 21 d1 04 7d  |......l..D..!..}|\n-00000190  9d 16 4d f9 82 15 f6 ef  fa d6 09 47 f2 fb 02 03  |..M........G....|\n-000001a0  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n-000001b0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n-000001c0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n-000001d0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n-000001e0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n-000001f0  10 12 50 8d 89 6f 1b d1  dc 54 4d 6e cb 69 5e 06  |..P..o...TMn.i^.|\n-00000200  f4 30 1b 06 03 55 1d 23  04 14 30 12 80 10 bf 3d  |.0...U.#..0....=|\n-00000210  b6 a9 66 f2 b8 40 cf ea  b4 03 78 48 1a 41 30 19  |..f..@....xH.A0.|\n-00000220  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n-00000230  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n-00000240  86 f7 0d 01 01 0b 05 00  03 81 81 00 92 7c af 91  |.............|..|\n-00000250  55 12 18 96 59 31 a6 48  40 d5 2d d5 ee bb 02 a0  |U...Y1.H@.-.....|\n-00000260  f5 c2 1e 7c 9b b3 30 7d  3c dc 76 da 4f 3d c0 fa  |...|..0}<.v.O=..|\n-00000270  ae 2d 33 24 6b 03 7b 1b  67 59 11 21 b5 11 bc 77  |.-3$k.{.gY.!...w|\n-00000280  b9 d9 e0 6e a8 2d 2e 35  fa 64 5f 22 3e 63 10 6b  |...n.-.5.d_\">c.k|\n-00000290  be ff 14 86 6d 0d f0 15  31 a8 14 38 1e 3b 84 87  |....m...1..8.;..|\n-000002a0  2c cb 98 ed 51 76 b9 b1  4f dd db 9b 84 04 86 40  |,...Qv..O......@|\n-000002b0  fa 51 dd ba b4 8d eb e3  46 de 46 b9 4f 86 c7 f9  |.Q......F.F.O...|\n-000002c0  a4 c2 41 34 ac cc f6 ea  b0 ab 39 18 16 03 01 00  |..A4......9.....|\n-000002d0  0e 0d 00 00 06 03 01 02  40 00 00 0e 00 00 00     |........@......|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 61 6b 2e 41 7f  |....Y...U..ak.A.|\n+00000010  af 26 6f a2 8b 63 ee e4  b1 76 19 3a 6d a3 c2 30  |.&o..c...v.:m..0|\n+00000020  37 e8 47 c2 90 10 7e e8  c5 b2 eb 20 00 1c 8f 70  |7.G...~.... ...p|\n+00000030  0d 15 4a c7 7d ab ca 79  a7 d8 c2 01 62 6e 6f aa  |..J.}..y....bno.|\n+00000040  df a2 1c 8f 7c 27 d9 e6  fe e9 c8 ab c0 13 00 00  |....|'..........|\n+00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n+00000060  01 02 59 0b 00 02 55 00  02 52 00 02 4f 30 82 02  |..Y...U..R..O0..|\n+00000070  4b 30 82 01 b4 a0 03 02  01 02 02 09 00 e8 f0 9d  |K0..............|\n+00000080  3f e2 5b ea a6 30 0d 06  09 2a 86 48 86 f7 0d 01  |?.[..0...*.H....|\n+00000090  01 0b 05 00 30 1f 31 0b  30 09 06 03 55 04 0a 13  |....0.1.0...U...|\n+000000a0  02 47 6f 31 10 30 0e 06  03 55 04 03 13 07 47 6f  |.Go1.0...U....Go|\n+000000b0  20 52 6f 6f 74 30 1e 17  0d 31 36 30 31 30 31 30  | Root0...1601010|\n+000000c0  30 30 30 30 30 5a 17 0d  32 35 30 31 30 31 30 30  |00000Z..25010100|\n+000000d0  30 30 30 30 5a 30 1a 31  0b 30 09 06 03 55 04 0a  |0000Z0.1.0...U..|\n+000000e0  13 02 47 6f 31 0b 30 09  06 03 55 04 03 13 02 47  |..Go1.0...U....G|\n+000000f0  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n+00000100  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 db 46  |.......0.......F|\n+00000110  7d 93 2e 12 27 06 48 bc  06 28 21 ab 7e c4 b6 a2  |}...'.H..(!.~...|\n+00000120  5d fe 1e 52 45 88 7a 36  47 a5 08 0d 92 42 5b c2  |]..RE.z6G....B[.|\n+00000130  81 c0 be 97 79 98 40 fb  4f 6d 14 fd 2b 13 8b c2  |....y.@.Om..+...|\n+00000140  a5 2e 67 d8 d4 09 9e d6  22 38 b7 4a 0b 74 73 2b  |..g.....\"8.J.ts+|\n+00000150  c2 34 f1 d1 93 e5 96 d9  74 7b f3 58 9f 6c 61 3c  |.4......t{.X.la<|\n+00000160  c0 b0 41 d4 d9 2b 2b 24  23 77 5b 1c 3b bd 75 5d  |..A..++$#w[.;.u]|\n+00000170  ce 20 54 cf a1 63 87 1d  1e 24 c4 f3 1d 1a 50 8b  |. T..c...$....P.|\n+00000180  aa b6 14 43 ed 97 a7 75  62 f4 14 c8 52 d7 02 03  |...C...ub...R...|\n+00000190  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n+000001a0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n+000001b0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n+000001c0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n+000001d0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n+000001e0  10 9f 91 16 1f 43 43 3e  49 a6 de 6d b6 80 d7 9f  |.....CC>I..m....|\n+000001f0  60 30 1b 06 03 55 1d 23  04 14 30 12 80 10 48 13  |`0...U.#..0...H.|\n+00000200  49 4d 13 7e 16 31 bb a3  01 d5 ac ab 6e 7b 30 19  |IM.~.1......n{0.|\n+00000210  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n+00000220  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n+00000230  86 f7 0d 01 01 0b 05 00  03 81 81 00 9d 30 cc 40  |.............0.@|\n+00000240  2b 5b 50 a0 61 cb ba e5  53 58 e1 ed 83 28 a9 58  |+[P.a...SX...(.X|\n+00000250  1a a9 38 a4 95 a1 ac 31  5a 1a 84 66 3d 43 d3 2d  |..8....1Z..f=C.-|\n+00000260  d9 0b f2 97 df d3 20 64  38 92 24 3a 00 bc cf 9c  |...... d8.$:....|\n+00000270  7d b7 40 20 01 5f aa d3  16 61 09 a2 76 fd 13 c3  |}.@ ._...a..v...|\n+00000280  cc e1 0c 5c ee b1 87 82  f1 6c 04 ed 73 bb b3 43  |...\\.....l..s..C|\n+00000290  77 8d 0c 1c f1 0f a1 d8  40 83 61 c9 4c 72 2b 9d  |w.......@.a.Lr+.|\n+000002a0  ae db 46 06 06 4d f4 c1  b3 3e c0 d1 bd 42 d4 db  |..F..M...>...B..|\n+000002b0  fe 3d 13 60 84 5c 21 d3  3b e9 fa e7 16 03 01 00  |.=.`.\\!.;.......|\n+000002c0  aa 0c 00 00 a6 03 00 1d  20 29 0b ca 37 f3 a1 52  |........ )..7..R|\n+000002d0  49 1c 84 9a e4 74 6b 4b  2d 1f e6 e9 83 1d 5d 59  |I....tkK-.....]Y|\n+000002e0  5a 2f 09 9f bc a4 30 af  71 00 80 d9 bb 6d 09 a7  |Z/....0.q....m..|\n+000002f0  ab 47 6f e8 a6 1a da fb  66 7d a5 f0 c9 c3 24 4c  |.Go.....f}....$L|\n+00000300  99 56 c6 29 71 27 08 0b  c1 60 44 cc 6d 42 1b 5e  |.V.)q'...`D.mB.^|\n+00000310  cd 9f 82 24 38 23 ec d9  fa 32 49 2f 16 5d d2 9d  |...$8#...2I/.]..|\n+00000320  e9 13 4e 66 3d f8 bf 30  2e 8c eb 35 4c e8 81 86  |..Nf=..0...5L...|\n+00000330  c0 de c7 0d a9 60 7e 7c  4a c4 1d a0 89 70 de 82  |.....`~|J....p..|\n+00000340  1b 37 a0 ea 7f 20 a5 fe  d4 20 1d 6f 1a 84 dd a4  |.7... ... .o....|\n+00000350  13 46 18 c6 31 14 81 4b  a4 bb 43 5c c4 49 1c 5a  |.F..1..K..C\\.I.Z|\n+00000360  8d 12 57 e0 1d 9a b6 cd  f1 39 ff 16 03 01 00 0a  |..W......9......|\n+00000370  0d 00 00 06 03 01 02 40  00 00 16 03 01 00 04 0e  |.......@........|\n+00000380  00 00 00                                          |...|\n >>> Flow 3 (client to server)\n-00000000  16 03 01 01 fb 0b 00 01  f7 00 01 f4 00 01 f1 30  |...............0|\n-00000010  82 01 ed 30 82 01 58 a0  03 02 01 02 02 01 00 30  |...0..X........0|\n-00000020  0b 06 09 2a 86 48 86 f7  0d 01 01 05 30 26 31 10  |...*.H......0&1.|\n-00000030  30 0e 06 03 55 04 0a 13  07 41 63 6d 65 20 43 6f  |0...U....Acme Co|\n-00000040  31 12 30 10 06 03 55 04  03 13 09 31 32 37 2e 30  |1.0...U....127.0|\n-00000050  2e 30 2e 31 30 1e 17 0d  31 31 31 32 30 38 30 37  |.0.10...11120807|\n-00000060  35 35 31 32 5a 17 0d 31  32 31 32 30 37 30 38 30  |5512Z..121207080|\n-00000070  30 31 32 5a 30 26 31 10  30 0e 06 03 55 04 0a 13  |012Z0&1.0...U...|\n-00000080  07 41 63 6d 65 20 43 6f  31 12 30 10 06 03 55 04  |.Acme Co1.0...U.|\n-00000090  03 13 09 31 32 37 2e 30  2e 30 2e 31 30 81 9c 30  |...127.0.0.10..0|\n-000000a0  0b 06 09 2a 86 48 86 f7  0d 01 01 01 03 81 8c 00  |...*.H..........|\n-000000b0  30 81 88 02 81 80 4e d0  7b 31 e3 82 64 d9 59 c0  |0.....N.{1..d.Y.|\n-000000c0  c2 87 a4 5e 1e 8b 73 33  c7 63 53 df 66 92 06 84  |...^..s3.cS.f...|\n-000000d0  f6 64 d5 8f e4 36 a7 1d  2b e8 b3 20 36 45 23 b5  |.d...6..+.. 6E#.|\n-000000e0  e3 95 ae ed e0 f5 20 9c  8d 95 df 7f 5a 12 ef 87  |...... .....Z...|\n-000000f0  e4 5b 68 e4 e9 0e 74 ec  04 8a 7f de 93 27 c4 01  |.[h...t......'..|\n-00000100  19 7a bd f2 dc 3d 14 ab  d0 54 ca 21 0c d0 4d 6e  |.z...=...T.!..Mn|\n-00000110  87 2e 5c c5 d2 bb 4d 4b  4f ce b6 2c f7 7e 88 ec  |..\\...MKO..,.~..|\n-00000120  7c d7 02 91 74 a6 1e 0c  1a da e3 4a 5a 2e de 13  ||...t......JZ...|\n-00000130  9c 4c 40 88 59 93 02 03  01 00 01 a3 32 30 30 30  |.L@.Y.......2000|\n-00000140  0e 06 03 55 1d 0f 01 01  ff 04 04 03 02 00 a0 30  |...U...........0|\n-00000150  0d 06 03 55 1d 0e 04 06  04 04 01 02 03 04 30 0f  |...U..........0.|\n-00000160  06 03 55 1d 23 04 08 30  06 80 04 01 02 03 04 30  |..U.#..0.......0|\n-00000170  0b 06 09 2a 86 48 86 f7  0d 01 01 05 03 81 81 00  |...*.H..........|\n-00000180  36 1f b3 7a 0c 75 c9 6e  37 46 61 2b d5 bd c0 a7  |6..z.u.n7Fa+....|\n-00000190  4b cc 46 9a 81 58 7c 85  79 29 c8 c8 c6 67 dd 32  |K.F..X|.y)...g.2|\n-000001a0  56 45 2b 75 b6 e9 24 a9  50 9a be 1f 5a fa 1a 15  |VE+u..$.P...Z...|\n-000001b0  d9 cc 55 95 72 16 83 b9  c2 b6 8f fd 88 8c 38 84  |..U.r.........8.|\n-000001c0  1d ab 5d 92 31 13 4f fd  83 3b c6 9d f1 11 62 b6  |..].1.O..;....b.|\n-000001d0  8b ec ab 67 be c8 64 b0  11 50 46 58 17 6b 99 1c  |...g..d..PFX.k..|\n-000001e0  d3 1d fc 06 f1 0e e5 96  a8 0c f9 78 20 b7 44 18  |...........x .D.|\n-000001f0  51 8d 10 7e 4f 94 67 df  a3 4e 70 73 8e 90 91 85  |Q..~O.g..Nps....|\n-00000200  16 03 01 00 86 10 00 00  82 00 80 73 bd 73 65 92  |...........s.se.|\n-00000210  86 23 41 14 79 7f d5 c1  10 ce 94 4d ad 9c c3 a9  |.#A.y......M....|\n-00000220  87 b5 32 52 f8 6b 11 93  2d 9b 98 0b 8b 1d c0 f6  |..2R.k..-.......|\n-00000230  53 17 6d c7 9c 2e ae c9  6f cc 99 23 38 37 1a 10  |S.m.....o..#87..|\n-00000240  fe 05 0b b5 55 0a 14 e9  60 7d 70 26 98 e2 54 d9  |....U...`}p&..T.|\n-00000250  65 cf 2e f4 53 5f 1d aa  3a f6 33 7b eb 4c 0e b3  |e...S_..:.3{.L..|\n-00000260  ff 5a db 36 2a 47 f3 df  f9 fc f5 31 78 83 aa 6b  |.Z.6*G.....1x..k|\n-00000270  52 b7 ba 1a 96 bc fa c1  a1 a9 bb 2b f5 38 89 00  |R..........+.8..|\n-00000280  4d e5 78 13 4e a4 38 46  42 dc 16 16 03 01 00 86  |M.x.N.8FB.......|\n-00000290  0f 00 00 82 00 80 3d f7  ff c1 72 82 b8 90 42 a3  |......=...r...B.|\n-000002a0  10 24 b5 01 44 60 98 39  e4 36 86 56 09 55 e5 73  |.$..D`.9.6.V.U.s|\n-000002b0  3a d9 9d 00 ae 05 23 6f  78 4e 49 28 c1 cc 7a ff  |:.....#oxNI(..z.|\n-000002c0  8f 67 92 cd 94 c0 d2 68  7f 48 ec 10 83 48 9e 02  |.g.....h.H...H..|\n-000002d0  b8 10 b2 1b f0 ba 8f 5a  c8 85 d9 19 53 c2 8d 37  |.......Z....S..7|\n-000002e0  8e 86 4c ca ee 0f c4 97  20 f9 a5 4e 94 b8 c5 c5  |..L..... ..N....|\n-000002f0  53 0c c1 b6 e5 a1 4e d6  15 b3 6b 08 c2 25 c3 de  |S.....N...k..%..|\n-00000300  e7 69 85 85 56 31 16 ad  68 7e 00 8f 1b fc f8 9f  |.i..V1..h~......|\n-00000310  d7 50 87 08 0d c5 14 03  01 00 01 01 16 03 01 00  |.P..............|\n-00000320  24 eb 0c f3 4f 56 04 e3  54 b0 a8 e4 bb af 3a 44  |$...OV..T.....:D|\n-00000330  c7 d6 f0 24 2f fc e6 79  93 f4 4e ec c5 1f 5b 99  |...$/..y..N...[.|\n-00000340  32 37 c2 f1 ad                                    |27...|\n+00000000  16 03 01 01 fd 0b 00 01  f9 00 01 f6 00 01 f3 30  |...............0|\n+00000010  82 01 ef 30 82 01 58 a0  03 02 01 02 02 10 5c 19  |...0..X.......\\.|\n+00000020  c1 89 65 83 55 6f dc 0b  c9 b9 93 9f e9 bc 30 0d  |..e.Uo........0.|\n+00000030  06 09 2a 86 48 86 f7 0d  01 01 0b 05 00 30 12 31  |..*.H........0.1|\n+00000040  10 30 0e 06 03 55 04 0a  13 07 41 63 6d 65 20 43  |.0...U....Acme C|\n+00000050  6f 30 1e 17 0d 31 36 30  38 31 37 32 31 35 32 33  |o0...16081721523|\n+00000060  31 5a 17 0d 31 37 30 38  31 37 32 31 35 32 33 31  |1Z..170817215231|\n+00000070  5a 30 12 31 10 30 0e 06  03 55 04 0a 13 07 41 63  |Z0.1.0...U....Ac|\n+00000080  6d 65 20 43 6f 30 81 9f  30 0d 06 09 2a 86 48 86  |me Co0..0...*.H.|\n+00000090  f7 0d 01 01 01 05 00 03  81 8d 00 30 81 89 02 81  |...........0....|\n+000000a0  81 00 ba 6f aa 86 bd cf  bf 9f f2 ef 5c 94 60 78  |...o........\\.`x|\n+000000b0  6f e8 13 f2 d1 96 6f cd  d9 32 6e 22 37 ce 41 f9  |o.....o..2n\"7.A.|\n+000000c0  ca 5d 29 ac e1 27 da 61  a2 ee 81 cb 10 c7 df 34  |.])..'.a.......4|\n+000000d0  58 95 86 e9 3d 19 e6 5c  27 73 60 c8 8d 78 02 f4  |X...=..\\'s`..x..|\n+000000e0  1d a4 98 09 a3 19 70 69  3c 25 62 66 2a ab 22 23  |......pi<%bf*.\"#|\n+000000f0  c5 7b 85 38 4f 2e 09 73  32 a7 bd 3e 9b ad ca 84  |.{.8O..s2..>....|\n+00000100  07 e6 0f 3a ff 77 c5 9d  41 85 00 8a b6 9b ee b0  |...:.w..A.......|\n+00000110  a4 3f 2d 4c 4c e6 42 3e  bb 51 c8 dd 48 54 f4 0c  |.?-LL.B>.Q..HT..|\n+00000120  8e 47 02 03 01 00 01 a3  46 30 44 30 0e 06 03 55  |.G......F0D0...U|\n+00000130  1d 0f 01 01 ff 04 04 03  02 05 a0 30 13 06 03 55  |...........0...U|\n+00000140  1d 25 04 0c 30 0a 06 08  2b 06 01 05 05 07 03 01  |.%..0...+.......|\n+00000150  30 0c 06 03 55 1d 13 01  01 ff 04 02 30 00 30 0f  |0...U.......0.0.|\n+00000160  06 03 55 1d 11 04 08 30  06 87 04 7f 00 00 01 30  |..U....0.......0|\n+00000170  0d 06 09 2a 86 48 86 f7  0d 01 01 0b 05 00 03 81  |...*.H..........|\n+00000180  81 00 46 ab 44 a2 fb 28  54 f8 5a 67 f8 62 94 f1  |..F.D..(T.Zg.b..|\n+00000190  9a b2 18 9e f2 b1 de 1d  7e 6f 76 95 a9 ba e7 5d  |........~ov....]|\n+000001a0  a8 16 6c 9c f7 09 d3 37  e4 4b 2b 36 7c 01 ad 41  |..l....7.K+6|..A|\n+000001b0  d2 32 d8 c3 d2 93 f9 10  6b 8e 95 b9 2c 17 8a a3  |.2......k...,...|\n+000001c0  44 48 bc 59 13 83 16 04  88 a4 81 5c 25 0d 98 0c  |DH.Y.......\\%...|\n+000001d0  ac 11 b1 28 56 be 1d cd  61 62 84 09 bf d6 80 c6  |...(V...ab......|\n+000001e0  45 8d 82 2c b4 d8 83 9b  db c9 22 b7 2a 12 11 7b  |E..,......\".*..{|\n+000001f0  fa 02 3b c1 c9 ff ea c9  9d a8 49 d3 95 d7 d5 0e  |..;.......I.....|\n+00000200  e5 35 16 03 01 00 25 10  00 00 21 20 2f e5 7d a3  |.5....%...! /.}.|\n+00000210  47 cd 62 43 15 28 da ac  5f bb 29 07 30 ff f6 84  |G.bC.(.._.).0...|\n+00000220  af c4 cf c2 ed 90 99 5f  58 cb 3b 74 16 03 01 00  |......._X.;t....|\n+00000230  86 0f 00 00 82 00 80 12  76 af 25 e4 e7 ff d6 e4  |........v.%.....|\n+00000240  27 58 31 0f 6b 1e 84 13  2f d0 60 80 18 c3 f8 c1  |'X1.k.../.`.....|\n+00000250  f8 04 39 d4 07 05 d3 96  e2 b2 10 de 1f 68 88 67  |..9..........h.g|\n+00000260  1d dd 0a 11 52 9d 16 0e  af 07 de cb f1 7c f4 b4  |....R........|..|\n+00000270  5d 0f 4f 43 5b 3c 25 07  32 13 f2 ab 9b 2d d0 a8  |].OC[<%.2....-..|\n+00000280  28 90 cb 04 48 c3 43 bd  2b b4 ef b9 7b cd bd d5  |(...H.C.+...{...|\n+00000290  bc d1 cc 00 17 46 fa 9b  1f 44 58 b7 6c de 1b 7a  |.....F...DX.l..z|\n+000002a0  e0 d7 12 38 a3 09 f8 7a  9b 26 0b ee 37 bc 79 1b  |...8...z.&..7.y.|\n+000002b0  51 9f 9a 1f f9 a9 51 14  03 01 00 01 01 16 03 01  |Q.....Q.........|\n+000002c0  00 30 97 df fb 79 78 a8  27 fd 2b 68 6b ec 4d 29  |.0...yx.'.+hk.M)|\n+000002d0  a1 02 59 ae 18 0b 46 62  af 61 53 2f 95 50 f2 ac  |..Y...Fb.aS/.P..|\n+000002e0  c8 c3 5e 78 ca b0 e2 5d  ff d7 1b 9b 00 30 f6 da  |..^x...].....0..|\n+000002f0  d7 91                                             |..|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 24 75 ac 09 a6 28  |..........$u...(|\n-00000010  60 ce 7f 81 a2 75 86 af  84 95 dc 3f e1 07 1c 02  |`....u.....?....|\n-00000020  bc 3c 90 db 1e 1a 35 06  93 60 22 69 b9 05 bb     |.<....5..`\"i...|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 f9 e9 d7 8c 4a  |..........0....J|\n+00000010  6b f4 c9 88 d6 98 70 53  13 fc 51 9c 81 14 cf 71  |k.....pS..Q....q|\n+00000020  d9 30 7a d9 2c 34 96 00  a4 a0 2b 1e 7d ff d0 f2  |.0z.,4....+.}...|\n+00000030  b7 81 ed 86 c5 e1 09 16  82 47 20                 |.........G |\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 1a f4 67 a7  d8 0a 67 8d 3a 11 53 7e  |......g...g.:.S~|\n-00000010  49 91 bf 92 85 e0 35 24  25 72 92 26 63 9b 09 15  |I.....5$%r.&c...|\n-00000020  03 01 00 16 98 bb a0 ca  40 70 26 6f 2d 73 35 3d  |........@p&o-s5=|\n-00000030  90 8c ff 01 e0 b1 50 52  e3 57                    |......PR.W|\n+00000000  17 03 01 00 20 db b5 66  4e fb b1 47 8a 8e 6b a8  |.... ..fN..G..k.|\n+00000010  03 53 1a 51 22 8e 47 a3  3a 74 ed a4 6a aa 79 fd  |.S.Q\".G.:t..j.y.|\n+00000020  55 0f ac 35 a9 17 03 01  00 20 3e 0b 39 f5 5a 03  |U..5..... >.9.Z.|\n+00000030  43 d9 e2 7d 1c dc 3b 42  82 2a 2d d4 04 0a 76 97  |C..}..;B.*-...v.|\n+00000040  70 ed ee 99 58 15 40 c1  3a d5 15 03 01 00 20 bf  |p...X.@.:..... .|\n+00000050  ea e8 93 67 a4 91 1a b5  f5 03 a5 94 50 95 41 16  |...g........P.A.|\n+00000060  b0 2a 74 d9 32 65 94 35  45 b9 0f 2e 80 87 fd     |.*t.2e.5E......|"}, {"sha": "529b7cef48bd506bf3bd6d6e208c2f52c5a92ce8", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ECDHE-ECDSA-AES", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,19 +1,20 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 59 02 00 00  55 03 01 78 09 57 86 09  |....Y...U..x.W..|\n-00000010  64 7e 35 c7 c7 b9 44 9c  09 ae f0 49 cb 1c 1f 58  |d~5...D....I...X|\n-00000020  89 ef 65 16 9e 32 73 cd  4d 1b 8f 20 10 4d 5b cf  |..e..2s.M.. .M[.|\n-00000030  d0 24 59 dd e8 47 c9 a2  ad 9c 98 b5 eb 16 46 6b  |.$Y..G........Fk|\n-00000040  7d 33 6e 53 0a 3d 81 71  a1 bc 43 7a c0 09 00 00  |}3nS.=.q..Cz....|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 b0 ec 4b 2e 9e  |....Y...U....K..|\n+00000010  19 7d 7b 7e 7c 52 8a d2  2e 8a 97 05 8a c6 ae aa  |.}{~|R..........|\n+00000020  c5 62 bd 6f bd 7e fe 6b  c6 9f d4 20 74 db 02 b1  |.b.o.~.k... t...|\n+00000030  65 88 41 bb 9a 55 22 f3  01 c4 5c ca 39 86 b1 77  |e.A..U\"...\\.9..w|\n+00000040  c4 b3 45 16 eb 55 d8 15  b8 4d ac 12 c0 09 00 00  |..E..U...M......|\n 00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n 00000060  01 02 0e 0b 00 02 0a 00  02 07 00 02 04 30 82 02  |.............0..|\n 00000070  00 30 82 01 62 02 09 00  b8 bf 2d 47 a0 d2 eb f4  |.0..b.....-G....|\n@@ -48,41 +49,37 @@\n 00000240  13 83 0d 94 06 bb d4 37  7a f6 ec 7a c9 86 2e dd  |.......7z..z....|\n 00000250  d7 11 69 7f 85 7c 56 de  fb 31 78 2b e4 c7 78 0d  |..i..|V..1x+..x.|\n 00000260  ae cb be 9e 4e 36 24 31  7b 6a 0f 39 95 12 07 8f  |....N6$1{j.9....|\n-00000270  2a 16 03 01 00 d6 0c 00  00 d2 03 00 17 41 04 51  |*............A.Q|\n-00000280  39 70 43 9c 01 de 29 df  3c d0 f8 31 54 70 34 53  |9pC...).<..1Tp4S|\n-00000290  0e ab e8 e0 b0 8b 21 66  63 ac a9 68 7c 92 6f f8  |......!fc..h|.o.|\n-000002a0  cf a3 ba cb 6d 39 f4 5c  f5 2e ff 1d d7 1b b9 e7  |....m9.\\........|\n-000002b0  08 13 59 f8 64 7e 23 e0  1d 04 cf 37 47 d6 b7 00  |..Y.d~#....7G...|\n-000002c0  8b 30 81 88 02 42 01 cd  1d 01 46 68 da 4c b6 0d  |.0...B....Fh.L..|\n-000002d0  67 05 39 0d aa 6c c5 40  e4 5d bf 4f 2a 92 78 8d  |g.9..l.@.].O*.x.|\n-000002e0  08 0e c0 07 8c 68 cc 55  4e 54 a9 9d 22 f9 a6 4a  |.....h.UNT..\"..J|\n-000002f0  e4 38 9f 53 4a 60 e8 eb  81 02 50 75 7e 13 31 2a  |.8.SJ`....Pu~.1*|\n-00000300  ff 3e 17 cd b4 d1 d4 75  02 42 01 95 ba b6 a0 12  |.>.....u.B......|\n-00000310  23 59 9f ae 1c c0 60 d2  8f 59 6b 35 ee b3 3f ac  |#Y....`..Yk5..?.|\n-00000320  e4 42 9a 23 d0 f4 fd a1  3c 36 1b 31 33 76 8d f0  |.B.#....<6.13v..|\n-00000330  b6 66 fd 92 9a 2a 27 8b  06 11 72 41 09 bd 27 55  |.f...*'...rA..'U|\n-00000340  c7 1b a9 d1 49 5e 8f 85  dc aa 9d be 16 03 01 00  |....I^..........|\n-00000350  04 0e 00 00 00                                    |.....|\n+00000270  2a 16 03 01 00 b5 0c 00  00 b1 03 00 1d 20 7d 74  |*............ }t|\n+00000280  bf aa a8 b6 c0 1f 78 0c  1a ee c5 b7 56 ff 5c aa  |......x.....V.\\.|\n+00000290  f4 e3 a5 0c f7 64 31 eb  85 8a c9 bd 05 1b 00 8b  |.....d1.........|\n+000002a0  30 81 88 02 42 00 f8 5d  e5 bf 2e 70 79 f4 36 90  |0...B..]...py.6.|\n+000002b0  fc 6e 9a cc f1 c4 01 50  8c b9 92 4e bd e0 82 2d  |.n.....P...N...-|\n+000002c0  1b ab 30 71 d1 db 76 af  50 75 08 fb cb 50 5b 00  |..0q..v.Pu...P[.|\n+000002d0  49 72 f5 d7 d9 44 48 94  ac 1d 8d 2e 50 90 ad a3  |Ir...DH.....P...|\n+000002e0  42 2b 5f 57 48 5e 9e 02  42 00 bb 0b 9a d7 25 53  |B+_WH^..B.....%S|\n+000002f0  04 5c 58 01 07 8e 3d ee  f5 4f 0b 80 bd 02 07 3e  |.\\X...=..O.....>|\n+00000300  ff b9 01 ac 7a 49 be 94  fa cf 58 5c 59 91 b5 5d  |....zI....X\\Y..]|\n+00000310  cc 61 b9 e3 2f 53 7d 3c  3f 41 c5 31 1a 90 fc fa  |.a../S}<?A.1....|\n+00000320  f7 0b eb e9 01 17 ab 23  ab 28 63 16 03 01 00 04  |.......#.(c.....|\n+00000330  0e 00 00 00                                       |....|\n >>> Flow 3 (client to server)\n-00000000  16 03 01 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n-00000010  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n-00000020  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n-00000030  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n-00000040  a6 b5 68 1a 41 03 56 6b  dc 5a 89 14 03 01 00 01  |..h.A.Vk.Z......|\n-00000050  01 16 03 01 00 30 64 61  7f ea 98 8e e7 c9 0f ea  |.....0da........|\n-00000060  0a b3 52 ba 3d 01 36 a4  47 24 7b 2d 19 b5 7e 92  |..R.=.6.G${-..~.|\n-00000070  04 b7 8c 4f fc 02 5d 79  15 3e 50 72 05 3c df d2  |...O..]y.>Pr.<..|\n-00000080  c6 a3 b3 c8 7c 48                                 |....|H|\n+00000000  16 03 01 00 25 10 00 00  21 20 2f e5 7d a3 47 cd  |....%...! /.}.G.|\n+00000010  62 43 15 28 da ac 5f bb  29 07 30 ff f6 84 af c4  |bC.(.._.).0.....|\n+00000020  cf c2 ed 90 99 5f 58 cb  3b 74 14 03 01 00 01 01  |....._X.;t......|\n+00000030  16 03 01 00 30 f5 d0 86  ef 96 7e b9 94 cc 19 62  |....0.....~....b|\n+00000040  cc 3a 14 f1 74 a2 0d c8  b9 4c 5d 8a c5 80 60 23  |.:..t....L]...`#|\n+00000050  d5 f5 04 06 16 e2 69 ca  4d 99 1b a0 b5 3b 7d 62  |......i.M....;}b|\n+00000060  51 62 ee d9 60                                    |Qb..`|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 30 7d 49 8d e9 da  |..........0}I...|\n-00000010  87 77 18 4d 10 63 17 ed  1f 34 7a d4 be e3 dd b6  |.w.M.c...4z.....|\n-00000020  8b f3 a7 06 bc de 76 8e  04 be 8a 95 5b 24 19 ec  |......v.....[$..|\n-00000030  66 55 8a 1b e0 df 0b a1  57 cb 67                 |fU......W.g|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 4d f9 c2 63 4f  |..........0M..cO|\n+00000010  98 1b 02 ce df ca d1 15  a2 4f 6f 4c 2c b8 1a 88  |.........OoL,...|\n+00000020  11 c9 b3 45 e6 1d cf e8  6b dd 8c 89 c6 1d 0b 66  |...E....k......f|\n+00000030  82 d5 1d c6 55 14 1c 56  59 3e 69                 |....U..VY>i|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 20 2d a3 e5  55 13 3f 73 8e ba 41 79  |.... -..U.?s..Ay|\n-00000010  65 e0 83 d5 3a ea cd e9  a8 b4 4b 3c d0 0c bf 06  |e...:.....K<....|\n-00000020  75 2a 67 f2 f7 17 03 01  00 20 a0 8d 3c a2 ca b3  |u*g...... ..<...|\n-00000030  f3 e5 36 dc 44 a4 3b ad  cd 03 be a9 70 a8 75 51  |..6.D.;.....p.uQ|\n-00000040  0f 8e 9f 7c a7 3c 03 84  38 88 15 03 01 00 20 75  |...|.<..8..... u|\n-00000050  0f db fe 48 b4 7e 04 3b  f5 5b 47 5b 0a ab 69 18  |...H.~.;.[G[..i.|\n-00000060  37 bb 89 d3 a8 40 ba 53  3b 5f 6d 8b 06 ff ae     |7....@.S;_m....|\n+00000000  17 03 01 00 20 12 be 42  b4 31 07 55 8e f9 a1 64  |.... ..B.1.U...d|\n+00000010  96 70 46 68 3e fd 4e 4f  9c af b3 11 de fc 80 f1  |.pFh>.NO........|\n+00000020  c8 11 84 ba ae 17 03 01  00 20 2f f9 ec dd 50 97  |......... /...P.|\n+00000030  1e a4 f1 66 fe 28 e3 c1  51 8d c0 f6 c3 d8 b3 ad  |...f.(..Q.......|\n+00000040  7d dc a5 98 87 90 34 71  b4 73 15 03 01 00 20 d1  |}.....4q.s.... .|\n+00000050  6f 91 91 01 68 c4 11 6a  e5 a2 ed 20 3f 3a 3d b7  |o...h..j... ?:=.|\n+00000060  d9 7f c3 b3 29 c3 df 3e  17 69 76 9f 04 f8 58     |....)..>.iv...X|"}, {"sha": "78947ace0e8782773c1ab73c34012e9d79f0e9a9", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ECDHE-RSA-AES", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,93 +1,89 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 59 02 00 00  55 03 01 90 3d f6 98 16  |....Y...U...=...|\n-00000010  55 0f 73 94 05 96 4c ab  ad f4 98 7a db c5 ca 26  |U.s...L....z...&|\n-00000020  1b c8 d9 15 a8 79 8e 2b  10 67 54 20 b2 8e 45 24  |.....y.+.gT ..E$|\n-00000030  6d 82 ec f5 30 41 2e 32  10 fa c0 76 3f 84 81 39  |m...0A.2...v?..9|\n-00000040  1e 5d 98 c1 33 d9 0d 4f  21 e1 0d 47 c0 13 00 00  |.]..3..O!..G....|\n+00000000  16 03 01 00 59 02 00 00  55 03 01 45 04 14 a2 70  |....Y...U..E...p|\n+00000010  3e 1e d9 2c d4 bd f3 e8  9c f3 e0 08 d8 0f 7f 82  |>..,............|\n+00000020  2b 07 a0 bd 47 56 a0 e1  06 0d 36 20 fc 0f 5b 85  |+...GV....6 ..[.|\n+00000030  8e 17 20 f1 f6 1e 80 c3  79 1a e1 86 c3 ed e9 24  |.. .....y......$|\n+00000040  6d bb 24 3c 0c 8d 2c 79  f2 03 27 b0 c0 13 00 00  |m.$<..,y..'.....|\n 00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n-00000060  01 02 71 0b 00 02 6d 00  02 6a 00 02 67 30 82 02  |..q...m..j..g0..|\n-00000070  63 30 82 01 cc a0 03 02  01 02 02 09 00 a2 73 00  |c0............s.|\n-00000080  0c 81 00 cb f3 30 0d 06  09 2a 86 48 86 f7 0d 01  |.....0...*.H....|\n-00000090  01 0b 05 00 30 2b 31 17  30 15 06 03 55 04 0a 13  |....0+1.0...U...|\n-000000a0  0e 47 6f 6f 67 6c 65 20  54 45 53 54 49 4e 47 31  |.Google TESTING1|\n-000000b0  10 30 0e 06 03 55 04 03  13 07 47 6f 20 52 6f 6f  |.0...U....Go Roo|\n-000000c0  74 30 1e 17 0d 31 35 30  31 30 31 30 30 30 30 30  |t0...15010100000|\n-000000d0  30 5a 17 0d 32 35 30 31  30 31 30 30 30 30 30 30  |0Z..250101000000|\n-000000e0  5a 30 26 31 17 30 15 06  03 55 04 0a 13 0e 47 6f  |Z0&1.0...U....Go|\n-000000f0  6f 67 6c 65 20 54 45 53  54 49 4e 47 31 0b 30 09  |ogle TESTING1.0.|\n-00000100  06 03 55 04 03 13 02 47  6f 30 81 9f 30 0d 06 09  |..U....Go0..0...|\n-00000110  2a 86 48 86 f7 0d 01 01  01 05 00 03 81 8d 00 30  |*.H............0|\n-00000120  81 89 02 81 81 00 af 87  88 f6 20 1b 95 65 6c 14  |.......... ..el.|\n-00000130  ab 44 05 af 3b 45 14 e3  b7 6d fd 00 63 4d 95 7f  |.D..;E...m..cM..|\n-00000140  fe 6a 62 35 86 c0 4a f9  18 7c f6 aa 25 5e 7a 64  |.jb5..J..|..%^zd|\n-00000150  31 66 00 ba f4 8e 92 af  c7 6b d8 76 d4 f3 5f 41  |1f.......k.v.._A|\n-00000160  cb 6e 56 15 97 1b 97 c1  3c 12 39 21 66 3d 2b 16  |.nV.....<.9!f=+.|\n-00000170  d1 bc db 1c c0 a7 da b7  ca ad ba da cb d5 21 50  |..............!P|\n-00000180  ec de 8d ab d1 6b 81 4b  89 02 f3 c4 be c1 6c 89  |.....k.K......l.|\n-00000190  b1 44 84 bd 21 d1 04 7d  9d 16 4d f9 82 15 f6 ef  |.D..!..}..M.....|\n-000001a0  fa d6 09 47 f2 fb 02 03  01 00 01 a3 81 93 30 81  |...G..........0.|\n-000001b0  90 30 0e 06 03 55 1d 0f  01 01 ff 04 04 03 02 05  |.0...U..........|\n-000001c0  a0 30 1d 06 03 55 1d 25  04 16 30 14 06 08 2b 06  |.0...U.%..0...+.|\n-000001d0  01 05 05 07 03 01 06 08  2b 06 01 05 05 07 03 02  |........+.......|\n-000001e0  30 0c 06 03 55 1d 13 01  01 ff 04 02 30 00 30 19  |0...U.......0.0.|\n-000001f0  06 03 55 1d 0e 04 12 04  10 12 50 8d 89 6f 1b d1  |..U.......P..o..|\n-00000200  dc 54 4d 6e cb 69 5e 06  f4 30 1b 06 03 55 1d 23  |.TMn.i^..0...U.#|\n-00000210  04 14 30 12 80 10 bf 3d  b6 a9 66 f2 b8 40 cf ea  |..0....=..f..@..|\n-00000220  b4 03 78 48 1a 41 30 19  06 03 55 1d 11 04 12 30  |..xH.A0...U....0|\n-00000230  10 82 0e 65 78 61 6d 70  6c 65 2e 67 6f 6c 61 6e  |...example.golan|\n-00000240  67 30 0d 06 09 2a 86 48  86 f7 0d 01 01 0b 05 00  |g0...*.H........|\n-00000250  03 81 81 00 92 7c af 91  55 12 18 96 59 31 a6 48  |.....|..U...Y1.H|\n-00000260  40 d5 2d d5 ee bb 02 a0  f5 c2 1e 7c 9b b3 30 7d  |@.-........|..0}|\n-00000270  3c dc 76 da 4f 3d c0 fa  ae 2d 33 24 6b 03 7b 1b  |<.v.O=...-3$k.{.|\n-00000280  67 59 11 21 b5 11 bc 77  b9 d9 e0 6e a8 2d 2e 35  |gY.!...w...n.-.5|\n-00000290  fa 64 5f 22 3e 63 10 6b  be ff 14 86 6d 0d f0 15  |.d_\">c.k....m...|\n-000002a0  31 a8 14 38 1e 3b 84 87  2c cb 98 ed 51 76 b9 b1  |1..8.;..,...Qv..|\n-000002b0  4f dd db 9b 84 04 86 40  fa 51 dd ba b4 8d eb e3  |O......@.Q......|\n-000002c0  46 de 46 b9 4f 86 c7 f9  a4 c2 41 34 ac cc f6 ea  |F.F.O.....A4....|\n-000002d0  b0 ab 39 18 16 03 01 00  cb 0c 00 00 c7 03 00 17  |..9.............|\n-000002e0  41 04 d9 ae 3f 05 64 d3  77 d9 1d b8 37 8a d4 ac  |A...?.d.w...7...|\n-000002f0  51 f4 af 65 70 da c0 64  76 00 53 50 a2 d4 6c bc  |Q..ep..dv.SP..l.|\n-00000300  9c 62 ab 2f 7b 02 48 fe  b2 0d 0b bb be 8f 34 55  |.b./{.H.......4U|\n-00000310  fb ce ee 93 43 76 d5 ce  3b b5 79 ab 3d 74 6e 19  |....Cv..;.y.=tn.|\n-00000320  a9 7d 00 80 05 cf 57 f2  f7 e0 ad 71 f1 75 d0 8b  |.}....W....q.u..|\n-00000330  f5 9d 83 1a 7e 0a 71 10  d7 9e fe bd 9d 47 62 45  |....~.q......GbE|\n-00000340  8d 1b 9c 33 fa 2c 5c aa  ce 9e 62 dc ad 56 ac 87  |...3.,\\...b..V..|\n-00000350  84 54 f5 32 87 d1 bb 8b  d9 d7 6d 3c 6c 6d b7 79  |.T.2......m<lm.y|\n-00000360  05 4d 55 f1 7c ef b1 fc  e7 35 5d 41 66 60 44 4f  |.MU.|....5]Af`DO|\n-00000370  f3 dd de 25 f4 73 12 c2  b6 cc 61 d5 14 5a ff 88  |...%.s....a..Z..|\n-00000380  ae f5 04 62 ac 2d 10 a0  95 c1 8e fa e6 db fe 41  |...b.-.........A|\n-00000390  46 98 f1 3d 2e e3 2a 5a  ea 87 26 6e 7a 4f 38 6c  |F..=..*Z..&nzO8l|\n-000003a0  4b 1f 1b 56 16 03 01 00  04 0e 00 00 00           |K..V.........|\n+00000060  01 02 59 0b 00 02 55 00  02 52 00 02 4f 30 82 02  |..Y...U..R..O0..|\n+00000070  4b 30 82 01 b4 a0 03 02  01 02 02 09 00 e8 f0 9d  |K0..............|\n+00000080  3f e2 5b ea a6 30 0d 06  09 2a 86 48 86 f7 0d 01  |?.[..0...*.H....|\n+00000090  01 0b 05 00 30 1f 31 0b  30 09 06 03 55 04 0a 13  |....0.1.0...U...|\n+000000a0  02 47 6f 31 10 30 0e 06  03 55 04 03 13 07 47 6f  |.Go1.0...U....Go|\n+000000b0  20 52 6f 6f 74 30 1e 17  0d 31 36 30 31 30 31 30  | Root0...1601010|\n+000000c0  30 30 30 30 30 5a 17 0d  32 35 30 31 30 31 30 30  |00000Z..25010100|\n+000000d0  30 30 30 30 5a 30 1a 31  0b 30 09 06 03 55 04 0a  |0000Z0.1.0...U..|\n+000000e0  13 02 47 6f 31 0b 30 09  06 03 55 04 03 13 02 47  |..Go1.0...U....G|\n+000000f0  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n+00000100  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 db 46  |.......0.......F|\n+00000110  7d 93 2e 12 27 06 48 bc  06 28 21 ab 7e c4 b6 a2  |}...'.H..(!.~...|\n+00000120  5d fe 1e 52 45 88 7a 36  47 a5 08 0d 92 42 5b c2  |]..RE.z6G....B[.|\n+00000130  81 c0 be 97 79 98 40 fb  4f 6d 14 fd 2b 13 8b c2  |....y.@.Om..+...|\n+00000140  a5 2e 67 d8 d4 09 9e d6  22 38 b7 4a 0b 74 73 2b  |..g.....\"8.J.ts+|\n+00000150  c2 34 f1 d1 93 e5 96 d9  74 7b f3 58 9f 6c 61 3c  |.4......t{.X.la<|\n+00000160  c0 b0 41 d4 d9 2b 2b 24  23 77 5b 1c 3b bd 75 5d  |..A..++$#w[.;.u]|\n+00000170  ce 20 54 cf a1 63 87 1d  1e 24 c4 f3 1d 1a 50 8b  |. T..c...$....P.|\n+00000180  aa b6 14 43 ed 97 a7 75  62 f4 14 c8 52 d7 02 03  |...C...ub...R...|\n+00000190  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n+000001a0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n+000001b0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n+000001c0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n+000001d0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n+000001e0  10 9f 91 16 1f 43 43 3e  49 a6 de 6d b6 80 d7 9f  |.....CC>I..m....|\n+000001f0  60 30 1b 06 03 55 1d 23  04 14 30 12 80 10 48 13  |`0...U.#..0...H.|\n+00000200  49 4d 13 7e 16 31 bb a3  01 d5 ac ab 6e 7b 30 19  |IM.~.1......n{0.|\n+00000210  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n+00000220  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n+00000230  86 f7 0d 01 01 0b 05 00  03 81 81 00 9d 30 cc 40  |.............0.@|\n+00000240  2b 5b 50 a0 61 cb ba e5  53 58 e1 ed 83 28 a9 58  |+[P.a...SX...(.X|\n+00000250  1a a9 38 a4 95 a1 ac 31  5a 1a 84 66 3d 43 d3 2d  |..8....1Z..f=C.-|\n+00000260  d9 0b f2 97 df d3 20 64  38 92 24 3a 00 bc cf 9c  |...... d8.$:....|\n+00000270  7d b7 40 20 01 5f aa d3  16 61 09 a2 76 fd 13 c3  |}.@ ._...a..v...|\n+00000280  cc e1 0c 5c ee b1 87 82  f1 6c 04 ed 73 bb b3 43  |...\\.....l..s..C|\n+00000290  77 8d 0c 1c f1 0f a1 d8  40 83 61 c9 4c 72 2b 9d  |w.......@.a.Lr+.|\n+000002a0  ae db 46 06 06 4d f4 c1  b3 3e c0 d1 bd 42 d4 db  |..F..M...>...B..|\n+000002b0  fe 3d 13 60 84 5c 21 d3  3b e9 fa e7 16 03 01 00  |.=.`.\\!.;.......|\n+000002c0  aa 0c 00 00 a6 03 00 1d  20 85 05 5f e3 a2 b2 12  |........ .._....|\n+000002d0  c8 82 53 2b c2 38 e1 a8  08 87 a7 d5 b3 98 6f 81  |..S+.8........o.|\n+000002e0  ce 81 6b 78 3e 3a b7 1d  71 00 80 43 81 fb 47 5e  |..kx>:..q..C..G^|\n+000002f0  08 16 39 35 d3 c2 f3 ea  bb 2c 7d bc 01 9b 35 5d  |..95.....,}...5]|\n+00000300  63 7e c3 38 f3 04 96 eb  d7 3f d1 df 71 97 ec 22  |c~.8.....?..q..\"|\n+00000310  1b 4a 89 14 4d e5 44 08  87 52 69 ea 28 f8 6a ea  |.J..M.D..Ri.(.j.|\n+00000320  3e ff 17 de 4d 20 95 e3  6e 3f af 05 20 9b a3 ac  |>...M ..n?.. ...|\n+00000330  70 1b 1c bf f9 52 d6 11  6d d9 85 90 08 4d 64 1f  |p....R..m....Md.|\n+00000340  c5 35 34 37 11 b8 44 a3  ef 93 a6 b6 87 58 0b c4  |.547..D......X..|\n+00000350  8e 94 d8 67 4d 09 7a 2a  aa 95 db e6 af 29 21 a2  |...gM.z*.....)!.|\n+00000360  ee c3 90 ef c6 53 46 12  fb 87 06 16 03 01 00 04  |.....SF.........|\n+00000370  0e 00 00 00                                       |....|\n >>> Flow 3 (client to server)\n-00000000  16 03 01 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n-00000010  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n-00000020  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n-00000030  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n-00000040  a6 b5 68 1a 41 03 56 6b  dc 5a 89 14 03 01 00 01  |..h.A.Vk.Z......|\n-00000050  01 16 03 01 00 30 73 96  2d 54 e3 9a bc 54 f5 9e  |.....0s.-T...T..|\n-00000060  e5 c7 46 35 b8 e1 d6 f6  14 95 92 f1 95 81 5a 9d  |..F5..........Z.|\n-00000070  4b df cc 96 77 f2 39 60  5d 5d da 94 b0 bf a0 80  |K...w.9`]]......|\n-00000080  bd 28 55 b1 6a c3                                 |.(U.j.|\n+00000000  16 03 01 00 25 10 00 00  21 20 2f e5 7d a3 47 cd  |....%...! /.}.G.|\n+00000010  62 43 15 28 da ac 5f bb  29 07 30 ff f6 84 af c4  |bC.(.._.).0.....|\n+00000020  cf c2 ed 90 99 5f 58 cb  3b 74 14 03 01 00 01 01  |....._X.;t......|\n+00000030  16 03 01 00 30 50 f5 a9  34 25 ed a2 fb c8 7f 35  |....0P..4%.....5|\n+00000040  08 57 59 da 54 c1 8d 92  ec 23 73 af f3 92 8d 19  |.WY.T....#s.....|\n+00000050  03 ce ab 5b eb dc 5b 81  3f 51 a1 20 31 3f 33 da  |...[..[.?Q. 1?3.|\n+00000060  27 c5 c3 9c fd                                    |'....|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 30 c9 46 7a 8b be  |..........0.Fz..|\n-00000010  cd eb 5c 83 13 9c 9b 9f  70 84 38 3b 48 8c f4 11  |..\\.....p.8;H...|\n-00000020  b3 ca 10 09 38 d0 8e c8  9f 66 db b9 8a 95 15 6b  |....8....f.....k|\n-00000030  5e f8 1d 39 25 75 3d f1  b9 32 a3                 |^..9%u=..2.|\n+00000000  14 03 01 00 01 01 16 03  01 00 30 b1 61 9b 63 4e  |..........0.a.cN|\n+00000010  43 96 80 49 ac 2d 93 7d  b9 f2 bb 81 79 5e 94 bf  |C..I.-.}....y^..|\n+00000020  06 d0 a6 14 46 91 cd 90  b0 8a 85 ee fe 41 a7 4d  |....F........A.M|\n+00000030  97 d7 4d 40 5e f4 5b bd  d3 0c db                 |..M@^.[....|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 20 04 69 a9  01 42 f4 1a fd 5a 4e 12  |.... .i..B...ZN.|\n-00000010  2b 6d cd 68 6b 94 70 b2  80 07 cf 79 a4 43 69 bf  |+m.hk.p....y.Ci.|\n-00000020  27 25 b5 ae e7 17 03 01  00 20 bf 1e cd 83 64 af  |'%....... ....d.|\n-00000030  6f cc 89 21 bf 16 e7 e8  86 29 f3 0a 36 ab a4 e3  |o..!.....)..6...|\n-00000040  fa c0 7e 7a 78 ca 29 17  11 9c 15 03 01 00 20 94  |..~zx.)....... .|\n-00000050  7a dd 17 eb fd 67 b1 cc  58 c9 c3 ae db b6 b0 a4  |z....g..X.......|\n-00000060  68 15 36 ca 33 22 ec 03  fb cf 2f f5 70 d6 9d     |h.6.3\"..../.p..|\n+00000000  17 03 01 00 20 49 21 bc  a5 4c 96 41 3f 22 87 0a  |.... I!..L.A?\"..|\n+00000010  c0 4e 0e 54 cb c2 27 8a  4f b0 37 fb b4 1f c1 4e  |.N.T..'.O.7....N|\n+00000020  77 e1 09 57 23 17 03 01  00 20 f0 f0 3b 78 a8 ae  |w..W#.... ..;x..|\n+00000030  ef b1 e0 f4 29 0f 90 4a  0f e5 48 34 84 5e 4f d8  |....)..J..H4.^O.|\n+00000040  53 46 f8 29 64 2b 8e 87  79 0a 15 03 01 00 20 71  |SF.)d+..y..... q|\n+00000050  32 6c 08 2a f7 18 c8 d5  48 a8 c7 d1 68 7a 65 ec  |2l.*....H...hze.|\n+00000060  3e fa 4b fe ff 76 1a 57  64 22 61 27 a0 5d b6     |>.K..v.Wd\"a'.].|"}, {"sha": "7ecfbde86a4a780e94d956c61b98b77db391dac2", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-RSA-RC4", "status": "modified", "additions": 72, "deletions": 73, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,79 +1,78 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 01 00 51 02 00 00  4d 03 01 1c 0e e9 7a c6  |....Q...M.....z.|\n-00000010  91 fe 7e 8c 6f 0b 8e cf  23 f5 07 29 10 de 05 a6  |..~.o...#..)....|\n-00000020  20 72 11 65 4f 2b 45 95  96 02 62 20 43 a8 93 34  | r.eO+E...b C..4|\n-00000030  e7 c0 29 d5 fb 26 f9 c2  59 37 94 dc e6 b5 c4 ed  |..)..&..Y7......|\n-00000040  ae 7a d7 94 d1 f4 d8 0b  02 ad 20 1b 00 05 00 00  |.z........ .....|\n-00000050  05 ff 01 00 01 00 16 03  01 02 71 0b 00 02 6d 00  |..........q...m.|\n-00000060  02 6a 00 02 67 30 82 02  63 30 82 01 cc a0 03 02  |.j..g0..c0......|\n-00000070  01 02 02 09 00 a2 73 00  0c 81 00 cb f3 30 0d 06  |......s......0..|\n-00000080  09 2a 86 48 86 f7 0d 01  01 0b 05 00 30 2b 31 17  |.*.H........0+1.|\n-00000090  30 15 06 03 55 04 0a 13  0e 47 6f 6f 67 6c 65 20  |0...U....Google |\n-000000a0  54 45 53 54 49 4e 47 31  10 30 0e 06 03 55 04 03  |TESTING1.0...U..|\n-000000b0  13 07 47 6f 20 52 6f 6f  74 30 1e 17 0d 31 35 30  |..Go Root0...150|\n-000000c0  31 30 31 30 30 30 30 30  30 5a 17 0d 32 35 30 31  |101000000Z..2501|\n-000000d0  30 31 30 30 30 30 30 30  5a 30 26 31 17 30 15 06  |01000000Z0&1.0..|\n-000000e0  03 55 04 0a 13 0e 47 6f  6f 67 6c 65 20 54 45 53  |.U....Google TES|\n-000000f0  54 49 4e 47 31 0b 30 09  06 03 55 04 03 13 02 47  |TING1.0...U....G|\n-00000100  6f 30 81 9f 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |o0..0...*.H.....|\n-00000110  01 05 00 03 81 8d 00 30  81 89 02 81 81 00 af 87  |.......0........|\n-00000120  88 f6 20 1b 95 65 6c 14  ab 44 05 af 3b 45 14 e3  |.. ..el..D..;E..|\n-00000130  b7 6d fd 00 63 4d 95 7f  fe 6a 62 35 86 c0 4a f9  |.m..cM...jb5..J.|\n-00000140  18 7c f6 aa 25 5e 7a 64  31 66 00 ba f4 8e 92 af  |.|..%^zd1f......|\n-00000150  c7 6b d8 76 d4 f3 5f 41  cb 6e 56 15 97 1b 97 c1  |.k.v.._A.nV.....|\n-00000160  3c 12 39 21 66 3d 2b 16  d1 bc db 1c c0 a7 da b7  |<.9!f=+.........|\n-00000170  ca ad ba da cb d5 21 50  ec de 8d ab d1 6b 81 4b  |......!P.....k.K|\n-00000180  89 02 f3 c4 be c1 6c 89  b1 44 84 bd 21 d1 04 7d  |......l..D..!..}|\n-00000190  9d 16 4d f9 82 15 f6 ef  fa d6 09 47 f2 fb 02 03  |..M........G....|\n-000001a0  01 00 01 a3 81 93 30 81  90 30 0e 06 03 55 1d 0f  |......0..0...U..|\n-000001b0  01 01 ff 04 04 03 02 05  a0 30 1d 06 03 55 1d 25  |.........0...U.%|\n-000001c0  04 16 30 14 06 08 2b 06  01 05 05 07 03 01 06 08  |..0...+.........|\n-000001d0  2b 06 01 05 05 07 03 02  30 0c 06 03 55 1d 13 01  |+.......0...U...|\n-000001e0  01 ff 04 02 30 00 30 19  06 03 55 1d 0e 04 12 04  |....0.0...U.....|\n-000001f0  10 12 50 8d 89 6f 1b d1  dc 54 4d 6e cb 69 5e 06  |..P..o...TMn.i^.|\n-00000200  f4 30 1b 06 03 55 1d 23  04 14 30 12 80 10 bf 3d  |.0...U.#..0....=|\n-00000210  b6 a9 66 f2 b8 40 cf ea  b4 03 78 48 1a 41 30 19  |..f..@....xH.A0.|\n-00000220  06 03 55 1d 11 04 12 30  10 82 0e 65 78 61 6d 70  |..U....0...examp|\n-00000230  6c 65 2e 67 6f 6c 61 6e  67 30 0d 06 09 2a 86 48  |le.golang0...*.H|\n-00000240  86 f7 0d 01 01 0b 05 00  03 81 81 00 92 7c af 91  |.............|..|\n-00000250  55 12 18 96 59 31 a6 48  40 d5 2d d5 ee bb 02 a0  |U...Y1.H@.-.....|\n-00000260  f5 c2 1e 7c 9b b3 30 7d  3c dc 76 da 4f 3d c0 fa  |...|..0}<.v.O=..|\n-00000270  ae 2d 33 24 6b 03 7b 1b  67 59 11 21 b5 11 bc 77  |.-3$k.{.gY.!...w|\n-00000280  b9 d9 e0 6e a8 2d 2e 35  fa 64 5f 22 3e 63 10 6b  |...n.-.5.d_\">c.k|\n-00000290  be ff 14 86 6d 0d f0 15  31 a8 14 38 1e 3b 84 87  |....m...1..8.;..|\n-000002a0  2c cb 98 ed 51 76 b9 b1  4f dd db 9b 84 04 86 40  |,...Qv..O......@|\n-000002b0  fa 51 dd ba b4 8d eb e3  46 de 46 b9 4f 86 c7 f9  |.Q......F.F.O...|\n-000002c0  a4 c2 41 34 ac cc f6 ea  b0 ab 39 18 16 03 01 00  |..A4......9.....|\n-000002d0  04 0e 00 00 00                                    |.....|\n+00000000  16 03 01 00 51 02 00 00  4d 03 01 4c 98 ce a5 80  |....Q...M..L....|\n+00000010  84 dc d3 70 de 75 bf 26  5c 15 8b b7 2c 78 30 a7  |...p.u.&\\...,x0.|\n+00000020  65 1a 0c f7 1a e5 51 91  7c cb ca 20 83 2c 90 3b  |e.....Q.|.. .,.;|\n+00000030  cf dd 4e 51 8b 27 98 95  aa d9 1d da 4d 3d e1 18  |..NQ.'......M=..|\n+00000040  f5 58 fd 85 c5 ed c9 5f  12 2f 4b b3 00 05 00 00  |.X....._./K.....|\n+00000050  05 ff 01 00 01 00 16 03  01 02 59 0b 00 02 55 00  |..........Y...U.|\n+00000060  02 52 00 02 4f 30 82 02  4b 30 82 01 b4 a0 03 02  |.R..O0..K0......|\n+00000070  01 02 02 09 00 e8 f0 9d  3f e2 5b ea a6 30 0d 06  |........?.[..0..|\n+00000080  09 2a 86 48 86 f7 0d 01  01 0b 05 00 30 1f 31 0b  |.*.H........0.1.|\n+00000090  30 09 06 03 55 04 0a 13  02 47 6f 31 10 30 0e 06  |0...U....Go1.0..|\n+000000a0  03 55 04 03 13 07 47 6f  20 52 6f 6f 74 30 1e 17  |.U....Go Root0..|\n+000000b0  0d 31 36 30 31 30 31 30  30 30 30 30 30 5a 17 0d  |.160101000000Z..|\n+000000c0  32 35 30 31 30 31 30 30  30 30 30 30 5a 30 1a 31  |250101000000Z0.1|\n+000000d0  0b 30 09 06 03 55 04 0a  13 02 47 6f 31 0b 30 09  |.0...U....Go1.0.|\n+000000e0  06 03 55 04 03 13 02 47  6f 30 81 9f 30 0d 06 09  |..U....Go0..0...|\n+000000f0  2a 86 48 86 f7 0d 01 01  01 05 00 03 81 8d 00 30  |*.H............0|\n+00000100  81 89 02 81 81 00 db 46  7d 93 2e 12 27 06 48 bc  |.......F}...'.H.|\n+00000110  06 28 21 ab 7e c4 b6 a2  5d fe 1e 52 45 88 7a 36  |.(!.~...]..RE.z6|\n+00000120  47 a5 08 0d 92 42 5b c2  81 c0 be 97 79 98 40 fb  |G....B[.....y.@.|\n+00000130  4f 6d 14 fd 2b 13 8b c2  a5 2e 67 d8 d4 09 9e d6  |Om..+.....g.....|\n+00000140  22 38 b7 4a 0b 74 73 2b  c2 34 f1 d1 93 e5 96 d9  |\"8.J.ts+.4......|\n+00000150  74 7b f3 58 9f 6c 61 3c  c0 b0 41 d4 d9 2b 2b 24  |t{.X.la<..A..++$|\n+00000160  23 77 5b 1c 3b bd 75 5d  ce 20 54 cf a1 63 87 1d  |#w[.;.u]. T..c..|\n+00000170  1e 24 c4 f3 1d 1a 50 8b  aa b6 14 43 ed 97 a7 75  |.$....P....C...u|\n+00000180  62 f4 14 c8 52 d7 02 03  01 00 01 a3 81 93 30 81  |b...R.........0.|\n+00000190  90 30 0e 06 03 55 1d 0f  01 01 ff 04 04 03 02 05  |.0...U..........|\n+000001a0  a0 30 1d 06 03 55 1d 25  04 16 30 14 06 08 2b 06  |.0...U.%..0...+.|\n+000001b0  01 05 05 07 03 01 06 08  2b 06 01 05 05 07 03 02  |........+.......|\n+000001c0  30 0c 06 03 55 1d 13 01  01 ff 04 02 30 00 30 19  |0...U.......0.0.|\n+000001d0  06 03 55 1d 0e 04 12 04  10 9f 91 16 1f 43 43 3e  |..U..........CC>|\n+000001e0  49 a6 de 6d b6 80 d7 9f  60 30 1b 06 03 55 1d 23  |I..m....`0...U.#|\n+000001f0  04 14 30 12 80 10 48 13  49 4d 13 7e 16 31 bb a3  |..0...H.IM.~.1..|\n+00000200  01 d5 ac ab 6e 7b 30 19  06 03 55 1d 11 04 12 30  |....n{0...U....0|\n+00000210  10 82 0e 65 78 61 6d 70  6c 65 2e 67 6f 6c 61 6e  |...example.golan|\n+00000220  67 30 0d 06 09 2a 86 48  86 f7 0d 01 01 0b 05 00  |g0...*.H........|\n+00000230  03 81 81 00 9d 30 cc 40  2b 5b 50 a0 61 cb ba e5  |.....0.@+[P.a...|\n+00000240  53 58 e1 ed 83 28 a9 58  1a a9 38 a4 95 a1 ac 31  |SX...(.X..8....1|\n+00000250  5a 1a 84 66 3d 43 d3 2d  d9 0b f2 97 df d3 20 64  |Z..f=C.-...... d|\n+00000260  38 92 24 3a 00 bc cf 9c  7d b7 40 20 01 5f aa d3  |8.$:....}.@ ._..|\n+00000270  16 61 09 a2 76 fd 13 c3  cc e1 0c 5c ee b1 87 82  |.a..v......\\....|\n+00000280  f1 6c 04 ed 73 bb b3 43  77 8d 0c 1c f1 0f a1 d8  |.l..s..Cw.......|\n+00000290  40 83 61 c9 4c 72 2b 9d  ae db 46 06 06 4d f4 c1  |@.a.Lr+...F..M..|\n+000002a0  b3 3e c0 d1 bd 42 d4 db  fe 3d 13 60 84 5c 21 d3  |.>...B...=.`.\\!.|\n+000002b0  3b e9 fa e7 16 03 01 00  04 0e 00 00 00           |;............|\n >>> Flow 3 (client to server)\n-00000000  16 03 01 00 86 10 00 00  82 00 80 73 bd 73 65 92  |...........s.se.|\n-00000010  86 23 41 14 79 7f d5 c1  10 ce 94 4d ad 9c c3 a9  |.#A.y......M....|\n-00000020  87 b5 32 52 f8 6b 11 93  2d 9b 98 0b 8b 1d c0 f6  |..2R.k..-.......|\n-00000030  53 17 6d c7 9c 2e ae c9  6f cc 99 23 38 37 1a 10  |S.m.....o..#87..|\n-00000040  fe 05 0b b5 55 0a 14 e9  60 7d 70 26 98 e2 54 d9  |....U...`}p&..T.|\n-00000050  65 cf 2e f4 53 5f 1d aa  3a f6 33 7b eb 4c 0e b3  |e...S_..:.3{.L..|\n-00000060  ff 5a db 36 2a 47 f3 df  f9 fc f5 31 78 83 aa 6b  |.Z.6*G.....1x..k|\n-00000070  52 b7 ba 1a 96 bc fa c1  a1 a9 bb 2b f5 38 89 00  |R..........+.8..|\n-00000080  4d e5 78 13 4e a4 38 46  42 dc 16 14 03 01 00 01  |M.x.N.8FB.......|\n-00000090  01 16 03 01 00 24 ae a9  da 45 6b 5e 76 57 02 62  |.....$...Ek^vW.b|\n-000000a0  63 d4 1f 40 bf c9 47 27  a9 7a 24 c0 f0 e9 c2 c4  |c..@..G'.z$.....|\n-000000b0  9c 07 84 df ae c7 66 40  d2 b0                    |......f@..|\n+00000000  16 03 01 00 86 10 00 00  82 00 80 b9 65 8d bf a7  |............e...|\n+00000010  c8 4b 79 ce 6f cb 8b 13  1c ac b9 7d 66 5e e9 ba  |.Ky.o......}f^..|\n+00000020  1d 71 4e a9 e9 34 ae f6  64 65 90 3b d8 16 52 a2  |.qN..4..de.;..R.|\n+00000030  6f f4 cb 8a 13 74 a2 ee  b7 27 69 b4 41 c0 90 68  |o....t...'i.A..h|\n+00000040  bc 02 69 e1 c6 48 4f 39  36 30 25 ca 4c 17 ce 83  |..i..HO960%.L...|\n+00000050  9e 08 56 e3 05 49 93 9e  2e c4 fb e6 c8 01 f1 0f  |..V..I..........|\n+00000060  c5 70 0f 08 83 48 e9 48  ef 6e 50 8b 05 7e e5 84  |.p...H.H.nP..~..|\n+00000070  25 fa 55 c7 ae 31 02 27  00 ef 3f 98 86 20 12 89  |%.U..1.'..?.. ..|\n+00000080  91 59 28 b4 f7 d7 af d2  69 61 35 14 03 01 00 01  |.Y(.....ia5.....|\n+00000090  01 16 03 01 00 24 0e 4d  ff 2c 39 80 ba a5 96 18  |.....$.M.,9.....|\n+000000a0  56 15 94 9f e2 1e 7d 13  62 51 d5 e1 05 f8 d8 b3  |V.....}.bQ......|\n+000000b0  bd 77 58 38 95 b4 7d 37  66 8a                    |.wX8..}7f.|\n >>> Flow 4 (server to client)\n-00000000  14 03 01 00 01 01 16 03  01 00 24 e9 84 92 41 c5  |..........$...A.|\n-00000010  31 e1 3c a9 78 18 d1 7b  e1 b1 0b 0a ef 18 54 19  |1.<.x..{......T.|\n-00000020  7c ba c7 59 ca c8 7b 4d  c9 f4 ad d6 7b 77 fb     ||..Y..{M....{w.|\n+00000000  14 03 01 00 01 01 16 03  01 00 24 dc 6f da 57 0d  |..........$.o.W.|\n+00000010  f8 b8 aa d5 e5 0a 2e 81  ed 2a b7 f8 0e 2a f1 05  |.........*...*..|\n+00000020  76 8d 4f b0 0e db 16 c5  d7 c8 5e f9 fb 9e e0     |v.O.......^....|\n >>> Flow 5 (client to server)\n-00000000  17 03 01 00 1a 1a dc 95  e2 4f ec f1 f6 68 9d 15  |.........O...h..|\n-00000010  56 d5 7b 06 1a f5 be bb  b1 ca b2 a6 d3 9e 28 15  |V.{...........(.|\n-00000020  03 01 00 16 64 fe 4a 37  d3 32 a8 55 38 9e 0f 76  |....d.J7.2.U8..v|\n-00000030  50 de e2 2e aa 77 15 2b  e5 21                    |P....w.+.!|\n+00000000  17 03 01 00 1a 47 97 4d  e6 59 d4 2f bb 60 56 69  |.....G.M.Y./.`Vi|\n+00000010  d8 bc 8d 91 44 7c cd 85  7e c5 18 5f 57 8e 08 15  |....D|..~.._W...|\n+00000020  03 01 00 16 f7 79 56 72  e6 77 8d af 94 55 d7 0e  |.....yVr.w...U..|\n+00000030  96 c8 3b 35 52 ea f7 e7  b8 d6                    |..;5R.....|"}, {"sha": "5232ad57df81627b03c853f19d91a5991c1e0310", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-ECDHE-ECDSA-AES", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4", "patch": "@@ -1,19 +1,20 @@\n >>> Flow 1 (client to server)\n-00000000  16 03 01 00 85 01 00 00  81 03 03 00 00 00 00 00  |................|\n+00000000  16 03 01 00 91 01 00 00  8d 03 03 00 00 00 00 00  |................|\n 00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 22 c0 2f  |.............\"./|\n-00000030  c0 2b c0 30 c0 2c c0 11  c0 07 c0 13 c0 09 c0 14  |.+.0.,..........|\n-00000040  c0 0a 00 9c 00 9d 00 05  00 2f 00 35 c0 12 00 0a  |........./.5....|\n-00000050  01 00 00 36 00 05 00 05  01 00 00 00 00 00 0a 00  |...6............|\n-00000060  08 00 06 00 17 00 18 00  19 00 0b 00 02 01 00 00  |................|\n-00000070  0d 00 0e 00 0c 04 01 04  03 05 01 05 03 02 01 02  |................|\n-00000080  03 ff 01 00 01 00 00 12  00 00                    |..........|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 2c cc a8  |.............,..|\n+00000030  cc a9 c0 2f c0 2b c0 30  c0 2c c0 27 c0 13 c0 23  |.../.+.0.,.'...#|\n+00000040  c0 09 c0 14 c0 0a 00 9c  00 9d 00 3c 00 2f 00 35  |...........<./.5|\n+00000050  c0 12 00 0a 00 05 c0 11  c0 07 01 00 00 38 00 05  |.............8..|\n+00000060  00 05 01 00 00 00 00 00  0a 00 0a 00 08 00 1d 00  |................|\n+00000070  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0e 00  |................|\n+00000080  0c 04 01 04 03 05 01 05  03 02 01 02 03 ff 01 00  |................|\n+00000090  01 00 00 12 00 00                                 |......|\n >>> Flow 2 (server to client)\n-00000000  16 03 02 00 59 02 00 00  55 03 02 07 ae a6 e4 1a  |....Y...U.......|\n-00000010  f7 7a 0c bc ea 21 0e 86  e3 d0 b4 2c fc d9 97 a3  |.z...!.....,....|\n-00000020  8b 29 5f 59 3e a9 06 fb  ca d9 57 20 cd 45 e7 cd  |.)_Y>.....W .E..|\n-00000030  6c 4c 56 cd 7c 4c 51 2c  8f 8c 67 a2 05 51 26 f5  |lLV.|LQ,..g..Q&.|\n-00000040  17 cc 18 c2 a1 29 94 4b  e2 02 cc 1c c0 09 00 00  |.....).K........|\n+00000000  16 03 02 00 59 02 00 00  55 03 02 30 f8 f6 b2 af  |....Y...U..0....|\n+00000010  99 b0 e0 f6 9a eb 47 6f  2f ad 2f 45 18 56 b3 dd  |......Go/./E.V..|\n+00000020  b6 b9 20 fb af 97 43 1f  0e 51 c0 20 fe 6c 12 64  |.. ...C..Q. .l.d|\n+00000030  8e cc a4 24 d6 e6 80 cf  f2 9e 74 3f a7 1e 8b da  |...$......t?....|\n+00000040  0e 3c 58 74 f4 8f be 1f  60 86 57 c6 c0 09 00 00  |.<Xt....`.W.....|\n 00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n 00000060  02 02 0e 0b 00 02 0a 00  02 07 00 02 04 30 82 02  |.............0..|\n 00000070  00 30 82 01 62 02 09 00  b8 bf 2d 47 a0 d2 eb f4  |.0..b.....-G....|\n@@ -48,43 +49,39 @@\n 00000240  13 83 0d 94 06 bb d4 37  7a f6 ec 7a c9 86 2e dd  |.......7z..z....|\n 00000250  d7 11 69 7f 85 7c 56 de  fb 31 78 2b e4 c7 78 0d  |..i..|V..1x+..x.|\n 00000260  ae cb be 9e 4e 36 24 31  7b 6a 0f 39 95 12 07 8f  |....N6$1{j.9....|\n-00000270  2a 16 03 02 00 d6 0c 00  00 d2 03 00 17 41 04 cd  |*............A..|\n-00000280  9d 30 75 8d 98 17 b5 1b  2f 4e af ea 69 52 a1 c1  |.0u...../N..iR..|\n-00000290  86 73 6a 56 54 f8 ed b6  35 e5 4e 34 a0 6f b1 85  |.sjVT...5.N4.o..|\n-000002a0  95 8e be 77 c5 1a 56 9a  59 d1 69 79 ea d6 2b c7  |...w..V.Y.iy..+.|\n-000002b0  c1 4a fb bc f8 98 c3 49  1c f3 ce 33 ef 98 20 00  |.J.....I...3.. .|\n-000002c0  8b 30 81 88 02 42 00 8b  15 7e 3b 4f 73 b0 8e ca  |.0...B...~;Os...|\n-000002d0  67 e0 7c d8 89 70 f1 b2  6b 9c 19 84 fa aa 6e 15  |g.|..p..k.....n.|\n-000002e0  8b 46 95 57 d5 ac 79 f3  e8 2a e5 7a a8 1e c3 d7  |.F.W..y..*.z....|\n-000002f0  0a b2 02 cd d6 32 34 2f  37 65 41 c8 61 c6 ed e5  |.....24/7eA.a...|\n-00000300  d2 6f 0f e8 1a 49 b6 c7  02 42 00 d1 00 f4 05 65  |.o...I...B.....e|\n-00000310  dd 43 42 db 8b 0b 95 9d  f5 62 51 e6 58 60 20 9b  |.CB......bQ.X` .|\n-00000320  46 84 e6 1f 76 4a 92 42  e4 4d 77 5b 76 a5 78 a0  |F...vJ.B.Mw[v.x.|\n-00000330  b0 f0 50 7d f9 4f ca 43  9d c2 50 cb 20 1c 40 52  |..P}.O.C..P. .@R|\n-00000340  0f a8 c4 43 7a 9d d5 61  de 26 30 b5 16 03 02 00  |...Cz..a.&0.....|\n-00000350  04 0e 00 00 00                                    |.....|\n+00000270  2a 16 03 02 00 b3 0c 00  00 af 03 00 1d 20 4b 2d  |*............ K-|\n+00000280  60 48 54 b4 48 42 10 de  e1 98 f0 fb 73 d9 49 16  |`HT.HB......s.I.|\n+00000290  3e a2 11 b3 84 50 de 26  00 09 d8 36 34 04 00 89  |>....P.&...64...|\n+000002a0  30 81 86 02 41 24 90 6f  3e 1a 2c a5 7f 08 dc b2  |0...A$.o>.,.....|\n+000002b0  d3 46 27 5e cb 1f 2a 6d  92 ba 1b fe e3 c5 64 79  |.F'^..*m......dy|\n+000002c0  31 50 8c 43 4b b1 ee 0d  6f 53 ad 6f e9 db 86 e7  |1P.CK...oS.o....|\n+000002d0  1f e3 77 f1 8d a8 ab 81  2a d6 fa e7 98 d5 bc 0d  |..w.....*.......|\n+000002e0  ec af ea 84 c4 f8 02 41  6a d2 66 32 e1 d7 46 1a  |.......Aj.f2..F.|\n+000002f0  95 5a 91 c3 76 82 20 c2  a3 a2 32 f5 fd eb a2 0e  |.Z..v. ...2.....|\n+00000300  0f d8 a9 31 7a ef a8 05  6c 5d bf 27 d0 2d 94 ca  |...1z...l].'.-..|\n+00000310  fb d6 62 7a 1c 6a 46 20  fe ed a6 60 a3 db b1 bd  |..bz.jF ...`....|\n+00000320  11 82 05 c3 db 0c 4a 2d  6c 16 03 02 00 04 0e 00  |......J-l.......|\n+00000330  00 00                                             |..|\n >>> Flow 3 (client to server)\n-00000000  16 03 02 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n-00000010  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n-00000020  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n-00000030  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n-00000040  a6 b5 68 1a 41 03 56 6b  dc 5a 89 14 03 02 00 01  |..h.A.Vk.Z......|\n-00000050  01 16 03 02 00 40 00 00  00 00 00 00 00 00 00 00  |.....@..........|\n-00000060  00 00 00 00 00 00 c0 81  e7 e8 40 f3 24 45 ed 74  |..........@.$E.t|\n-00000070  86 31 7b 39 d1 3c a2 67  99 28 06 b1 34 b6 3c a6  |.1{9.<.g.(..4.<.|\n-00000080  1d ce 39 aa 56 c9 72 0d  f1 e0 c1 5a 51 a0 5d f2  |..9.V.r....ZQ.].|\n-00000090  44 4d e6 d7 0e 84                                 |DM....|\n+00000000  16 03 02 00 25 10 00 00  21 20 2f e5 7d a3 47 cd  |....%...! /.}.G.|\n+00000010  62 43 15 28 da ac 5f bb  29 07 30 ff f6 84 af c4  |bC.(.._.).0.....|\n+00000020  cf c2 ed 90 99 5f 58 cb  3b 74 14 03 02 00 01 01  |....._X.;t......|\n+00000030  16 03 02 00 40 00 00 00  00 00 00 00 00 00 00 00  |....@...........|\n+00000040  00 00 00 00 00 22 71 28  3d 07 73 61 5e 84 72 36  |.....\"q(=.sa^.r6|\n+00000050  c0 87 37 4a 5b c2 d9 40  96 a2 01 20 b2 04 23 2f  |..7J[..@... ..#/|\n+00000060  c1 6f 1e 7c a1 77 20 0f  87 46 98 a2 5c aa 35 37  |.o.|.w ..F..\\.57|\n+00000070  37 87 5a 75 33                                    |7.Zu3|\n >>> Flow 4 (server to client)\n-00000000  14 03 02 00 01 01 16 03  02 00 40 82 8d c7 e3 7b  |..........@....{|\n-00000010  f8 9d 33 a1 c2 08 8c 24  d9 af 66 64 6e e8 61 8e  |..3....$..fdn.a.|\n-00000020  3c 03 65 2d c3 64 a2 26  23 a5 25 3f a2 a4 f9 40  |<.e-.d.&#.%?...@|\n-00000030  ec 9f 0e b8 57 b1 5f 84  ea 94 72 1a 3e 60 f1 dd  |....W._...r.>`..|\n-00000040  af 2e 81 f7 16 de 43 85  21 51 49                 |......C.!QI|\n+00000000  14 03 02 00 01 01 16 03  02 00 40 21 b5 1f 8d 4b  |..........@!...K|\n+00000010  1c a7 28 4e 73 3e d7 c5  75 6e eb e4 b3 95 02 4e  |..(Ns>..un.....N|\n+00000020  a3 47 03 44 97 69 c9 89  f5 ac e2 29 5e 22 e7 2c  |.G.D.i.....)^\".,|\n+00000030  a2 2d e3 ac 64 45 ae 9d  07 9e fe f8 c6 85 47 4d  |.-..dE........GM|\n+00000040  59 be 72 8d e6 50 da c7  83 91 14                 |Y.r..P.....|\n >>> Flow 5 (client to server)\n 00000000  17 03 02 00 30 00 00 00  00 00 00 00 00 00 00 00  |....0...........|\n-00000010  00 00 00 00 00 43 8f 88  82 c8 e1 55 37 76 d7 a5  |.....C.....U7v..|\n-00000020  83 c6 d2 94 26 fe 30 1f  e2 24 ca d7 27 22 33 47  |....&.0..$..'\"3G|\n-00000030  5f a9 74 9d ad 15 03 02  00 30 00 00 00 00 00 00  |_.t......0......|\n-00000040  00 00 00 00 00 00 00 00  00 00 49 8e ee 5c ec 86  |..........I..\\..|\n-00000050  e7 64 a7 ac 0d 5c c4 43  a6 45 a4 22 b7 3d 21 06  |.d...\\.C.E.\".=!.|\n-00000060  11 67 08 99 9a 08 a1 7c  e0 1e                    |.g.....|..|\n+00000010  00 00 00 00 00 57 45 25  4c 1b 90 d3 28 e1 69 43  |.....WE%L...(.iC|\n+00000020  c5 28 d9 d5 15 35 cf 41  bb 38 f2 12 c6 18 a5 a2  |.(...5.A.8......|\n+00000030  f5 e4 64 1d 59 15 03 02  00 30 00 00 00 00 00 00  |..d.Y....0......|\n+00000040  00 00 00 00 00 00 00 00  00 00 35 06 5f e3 ff e7  |..........5._...|\n+00000050  f0 f1 0c d5 b1 59 42 80  19 8d 67 1b 18 18 5c 18  |.....YB...g...\\.|\n+00000060  42 38 67 85 c3 ab e2 dc  60 d4                    |B8g.....`.|"}, {"sha": "48ff7bce3203c90a1b0e047e6db0c3a95d5ca337", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-ECDHE-RSA-AES", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "2e9c49e27ad5194e65d72a764ffb11e04b43fa42", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-RSA-RC4", "status": "modified", "additions": 72, "deletions": 73, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c20dcc658f3b2734acd6508e615741e31777377b", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-AES128-GCM-SHA256", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-GCM-SHA256", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-GCM-SHA256", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-GCM-SHA256?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "774481e84a79464c9b85e34c79003a918c0f71d9", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-AES128-SHA256", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-SHA256", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-SHA256", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES128-SHA256?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "6d2674639a2831eda5d33fe232d8f7c75a8f8218", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-AES256-GCM-SHA384", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-AES256-GCM-SHA384?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "9f90ff269ad2ef3fcfae87d11e41db9cf1b43883", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "62e7d11bb8d86219e8d30b78a0707bcf77d692ca", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN-NoMatch", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "336e10da83addd2c48ff936e3ad938e38e47b74d", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-ECDSA-ECDSA", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "fb6c940a5f96f4e8df7d2f600cc54d261cb7c2c7", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-ECDSA-RSA", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "17fc8f8e118f93f8e1a934fe6188547bcddce2b0", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "status": "modified", "additions": 123, "deletions": 127, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "1ff91986d28605ee686cd73c35d66c843e4df7bd", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-ECDSA", "status": "modified", "additions": 90, "deletions": 93, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "76f0c2511babe615b901c2f2c2105a8a090e6fc6", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-RSA", "status": "modified", "additions": 124, "deletions": 116, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "5d795e791f058d438dabdca5db2857bd96376fc2", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "28a9ef7c6598c87bcdee70e93d1fcde529e45d40", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES-GCM", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "831fa2101fe820449165fb4654d6260787ec7636", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES128-SHA256", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES128-SHA256", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES128-SHA256", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES128-SHA256?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c22edd05e002582007d3663b16a8ff11ea740ada", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "61e665721a2e05cea39ed319fbf8bd43a76c6d97", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-CHACHA20-POLY1305", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-CHACHA20-POLY1305", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-CHACHA20-POLY1305", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-CHACHA20-POLY1305?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "45728cfbe73b7faae94dfa9b45ca680f49901008", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-RSA-AES", "status": "modified", "additions": 83, "deletions": 87, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "6b02249f3fc0e6b0868c9322e570ebec3f596c81", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-RSA-AES128-SHA256", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES128-SHA256", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES128-SHA256", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES128-SHA256?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "64f999a05ad4564a0607c72797dc9fb2017a7111", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-RSA-CHACHA20-POLY1305", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-CHACHA20-POLY1305", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-CHACHA20-POLY1305", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-CHACHA20-POLY1305?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "74282d4b1a5e66bc2c9916605789a27a4e09b6e3", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RSA-RC4", "status": "modified", "additions": 72, "deletions": 73, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8a9ac3605827aeabecff06679c534b1a1de8be16", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateOnce", "status": "modified", "additions": 218, "deletions": 238, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c2f4e4aca901b05ded3a26382ac6ad94b8d6918b", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateTwice", "status": "modified", "additions": 359, "deletions": 392, "changes": 751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "737ccc61baaf9a4f5b3f9ca0e8fb3c53b49dc79e", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateTwiceRejected", "status": "modified", "additions": 221, "deletions": 242, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "cb964324fd23a48f5a7f831faa64470ec0530be5", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiationRejected", "status": "modified", "additions": 80, "deletions": 88, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "a0f6a090af2ed4e7ef44e20231b3955153668326", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-SCT", "status": "modified", "additions": 78, "deletions": 84, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "90541fd16e0eab7b4c815876575ffd1307579d94", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-X25519-ECDHE-RSA-AES-GCM", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-X25519-ECDHE-RSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-X25519-ECDHE-RSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-X25519-ECDHE-RSA-AES-GCM?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "11a8a1c8cb25a6d9e71d9ce9dda3ab8745e5ec49", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-3DES", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "771373c27fbe6b35ad2129a8374c9af023766bb7", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-AES", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "f5674ccd670c7e209b2a64932d005937b5d17193", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-RC4", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "3e170818a05dd29f8ded53ccbbd74d152c3ff378", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-ECDHE-ECDSA-AES", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "9590b0daa1ebc990ee05515848c691dbebcb1d6b", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-3DES", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c1750292d731a62ba9d0f49c2a36b8a7f3218534", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-AES", "status": "modified", "additions": 68, "deletions": 70, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "3d788c35d2341913b0d5811f7b5377b03a3871a8", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-RC4", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "209e6216cfd54bf049460e660a21c0cf781ec861", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv11-FallbackSCSV", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "18debc470ce1805b9065c6414ab3acbf4f7a0ce1", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv11-RSA-RC4", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "3e90ebd90f8c3b042fe23c1b2273cd0b8adbfd96", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN", "status": "modified", "additions": 83, "deletions": 98, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "d40300e839593138fd5b2c646d2bf3530ce76054", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN-NoMatch", "status": "modified", "additions": 84, "deletions": 98, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "e2864070a4a0e5c78b4d1bbc439b6eb06ee99ebd", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-CipherSuiteCertPreferenceECDSA", "status": "modified", "additions": 42, "deletions": 55, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "1f9fbc1abb82c391fc4dd94396547a1fd038e8b9", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-CipherSuiteCertPreferenceRSA", "status": "modified", "additions": 79, "deletions": 94, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "7a950db0ac9ff9e28e0ddea20b97dbacaecdec54", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedAndECDSAGiven", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c81acc8992fd0c6595657e90bc76986355b85b04", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedAndGiven", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "091de9081ebdbd5084cf92b9344c049fe50b5e5c", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedNotGiven", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "b412980e2afa2669c5aefb0b9a86358c3205243d", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ECDHE-ECDSA-AES", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "feced4bb8ff623e21a2f8c9bf11efdfe1897260c", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-IssueTicket", "status": "modified", "additions": 80, "deletions": 74, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "467e33248983b7d3a6f82eddfb20dfcfc430775b", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-IssueTicketPreDisable", "status": "modified", "additions": 80, "deletions": 74, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "af50381abc843af9b20ac39ed814071bf3ab608d", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-3DES", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "813f7489c8040ceb0d4fa8dae42eb426fd283167", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES", "status": "modified", "additions": 70, "deletions": 71, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "4e52915ac5fba5842c69d8590e29ed907f2ad72b", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES-GCM", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "36be9da0d083b9b69849d235f46290743606368f", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES256-GCM-SHA384", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "e49d1bcbbc45d7443406246220c41f3d643ef9cf", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-RC4", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "366ca8f75d93a323e4a3c06d030a0b21c12fa30a", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-Resume", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "34748371cff575f1a89aa4902a3332ef25e78b64", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ResumeDisabled", "status": "modified", "additions": 83, "deletions": 77, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "852cc63d03d023ceba3555374845a3b0a4d9c5b6", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "b35cd8de2680f2da62661e93940e4764a3283a22", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI-GetCertificate", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8ba207b25397d7a9a25f5bcbc85c18e8f9658840", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI-GetCertificateNotFound", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "89587e9b8dcc37ce3af35dd6fc9f3d719c8bb002", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-X25519-ECDHE-RSA-AES-GCM", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-X25519-ECDHE-RSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-X25519-ECDHE-RSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-X25519-ECDHE-RSA-AES-GCM?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "f2e5aea2bce5ed6d7305c2d8fdfd233b0d63c2fd", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8933f4f2015e1be457e55d2ad7fb8e66e23cb460", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 135, "deletions": 15, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "fea33df379aebdce57f78c6cc6a412e61acea99d", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "39fd78df596078fb3f192251dbed09edc778d6b8", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8e80533590478ce9ec83d72e6faf39396a3de48c", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "66cdb5ea261f0d2535224bbce4fa186872291f8f", "filename": "libgo/go/crypto/x509/root_darwin.go", "status": "modified", "additions": 222, "deletions": 3, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "38dd72d3ed66623a82226197c00ca18b80eeeffd", "filename": "libgo/go/crypto/x509/root_linux.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "ca2fba5cb421fe7b7925358fa50d15061da99cc5", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "29345a1755c8e1cde125946ae1cd3eb3299256e7", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "15c40914444075b47c5857a0bb26b38ed68a48ea", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 300, "deletions": 9, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "949ce0185615516f5bdbede356e5f9f5d84eb70d", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 198, "deletions": 29, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "aa30d85b7da06de25236732d0536b7c572831454", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 223, "deletions": 25, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "ea2f377810eac95f479066cb70024f8bc28f25dc", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 76, "deletions": 15, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "4dfab1f6bef6a8d400ed92634e0c8900354bc078", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "1071446227fb4f25caf22600715e0c47fde02ce3", "filename": "libgo/go/database/sql/ctxutil.go", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fctxutil.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "d66196fd48174811613d330dd1ae0e44d809dfbf", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 194, "deletions": 1, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8b3cb6c8f6115a4378fafef45ef4f759626f1f73", "filename": "libgo/go/database/sql/driver/types.go", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "0379bf8892f54d304ba1c2e83fb885682351b8de", "filename": "libgo/go/database/sql/driver/types_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "4b15f5bec7bfb273aeb8b40bcc08b10387107934", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 276, "deletions": 99, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "0fa7c34a13e3bb7ee209b9b01a33befe2f414e80", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 691, "deletions": 225, "changes": 916, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "63e1292cb1f2c50591f2e1f63f2606a879de5e95", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 533, "deletions": 22, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "8eeab65df89054aa0494e281683b22d244d15b00", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "58bdf277d36b39ae495febfe8c2d1b58781c41a2", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "a5fbcfbbdd24265cf41850440a90719d2545e263", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc492-mipsle.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-mipsle.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-mipsle.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-mipsle.obj?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "270c7775968f0e6d74875fa017d5f153e88e0cf8", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc540-mips.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc540-mips.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc540-mips.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc540-mips.obj?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "ba1cf8b699afa5911b9e02597eb3e884a46ac3d0", "filename": "libgo/go/debug/gosym/pclntab.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "7e7cee6793474583751dac688d668ad380a5dbb8", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "40ac74e9a141f6a2558011f30032d14a2874fb42", "filename": "libgo/go/debug/macho/macho.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Fmacho.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "87f225cb3981008af03e24905ee4d4142b59114c", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "5a740c87050c4291a364564356f67a47b81c900a", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "b641158eccb850e65e1ba4bcbd0b2709c90548d9", "filename": "libgo/go/debug/pe/section.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fsection.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fsection.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Fsection.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c30255f341aeae50a563bdc11ae8fbf46f400d11", "filename": "libgo/go/debug/pe/string.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Fstring.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "7fa5948641f8476279486fe1067098516c0a3ec7", "filename": "libgo/go/debug/pe/symbol.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fsymbol.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fdebug%2Fpe%2Fsymbol.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Fsymbol.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "044f74ab469d2968c05339808c15bc970447d4d5", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "9976656df8938aeb374b263f383dbd80a6b280c8", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "225fd0849c6f28f59b220e2e41c79c5775f71320", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 313, "deletions": 310, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "10db1aa575afea00dee83128de81e9077e40d376", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "d2efad4518b5f9d4a77f7c8c8b257cbcd70049d8", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "e2e1d59f3c0d5c547e7332d32f40ae7e15a2fc5b", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "383425459666a220d827df5cab7832ad14f16da4", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "fc7f2765efbcf147dbf213d7bc4081ca961ad287", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "c8c4ca775832dfe750e512b720ac6e44c122fe5e", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}, {"sha": "7b3aca4c5f3771cbec52beb09d6e1174b3b0ec14", "filename": "libgo/go/encoding/csv/reader_test.go", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2047754c300b68c05d65faa8dc2925fe67b71b4/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go?ref=c2047754c300b68c05d65faa8dc2925fe67b71b4"}]}