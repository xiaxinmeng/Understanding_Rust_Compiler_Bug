{"sha": "71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFmYTAyZTBkODkzMmRlNGJhMWE1MjdmNTBkZjk4YmYyMTFmMmZmZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-02T12:33:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-02T12:33:02Z"}, "message": "re PR debug/65549 (crash in htab_hash_string with -flto -g)\n\n2015-06-02  Richard Biener  <rguenther@suse.de>\n\n\tPR debug/65549\n\t* dwarf2out.c (lookup_context_die): New function.\n\t(resolve_addr): Avoid forcing a full DIE for the\n\ttarget of a DW_TAG_GNU_call_site during late compilation.\n\tInstead create a stub DIE without a type if we have a\n\tcontext DIE present.\n\n\t* g++.dg/lto/pr65549_0.C: New testcase.\n\nFrom-SVN: r224029", "tree": {"sha": "22931bbee0d1b3cac750714c57949b3adf241f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22931bbee0d1b3cac750714c57949b3adf241f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1817fe58f258d6de8b7716927bad077d811fe39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1817fe58f258d6de8b7716927bad077d811fe39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1817fe58f258d6de8b7716927bad077d811fe39a"}], "stats": {"total": 196, "additions": 193, "deletions": 3}, "files": [{"sha": "e22dbb9481e756fd5504f43ca972958cda2b74a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "patch": "@@ -1,3 +1,12 @@\n+2015-06-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR debug/65549\n+\t* dwarf2out.c (lookup_context_die): New function.\n+\t(resolve_addr): Avoid forcing a full DIE for the\n+\ttarget of a DW_TAG_GNU_call_site during late compilation.\n+\tInstead create a stub DIE without a type if we have a\n+\tcontext DIE present.\n+\n 2015-06-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* df-scan.c (df_scan_start_dump): Add space between regno and regname."}, {"sha": "1116f86a13701f6a195808a95b3a923b3c6a89e2", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "patch": "@@ -20621,6 +20621,28 @@ is_naming_typedef_decl (const_tree decl)\n \t      != TYPE_NAME (TREE_TYPE (decl))));\n }\n \n+/* Looks up the DIE for a context.  */\n+\n+static inline dw_die_ref\n+lookup_context_die (tree context)\n+{\n+  if (context)\n+    {\n+      /* Find die that represents this context.  */\n+      if (TYPE_P (context))\n+\t{\n+\t  context = TYPE_MAIN_VARIANT (context);\n+\t  dw_die_ref ctx = lookup_type_die (context);\n+\t  if (!ctx)\n+\t    return NULL;\n+\t  return strip_naming_typedef (context, ctx);\n+\t}\n+      else\n+\treturn lookup_decl_die (context);\n+    }\n+  return comp_unit_die ();\n+}\n+\n /* Returns the DIE for a context.  */\n \n static inline dw_die_ref\n@@ -23949,12 +23971,22 @@ resolve_addr (dw_die_ref die)\n \t  {\n \t    tree tdecl = SYMBOL_REF_DECL (a->dw_attr_val.v.val_addr);\n \t    dw_die_ref tdie = lookup_decl_die (tdecl);\n+\t    dw_die_ref cdie;\n \t    if (tdie == NULL\n \t\t&& DECL_EXTERNAL (tdecl)\n-\t\t&& DECL_ABSTRACT_ORIGIN (tdecl) == NULL_TREE)\n+\t\t&& DECL_ABSTRACT_ORIGIN (tdecl) == NULL_TREE\n+\t\t&& (cdie = lookup_context_die (DECL_CONTEXT (tdecl))))\n \t      {\n-\t\tforce_decl_die (tdecl);\n-\t\ttdie = lookup_decl_die (tdecl);\n+\t\t/* Creating a full DIE for tdecl is overly expensive and\n+\t\t   at this point even wrong when in the LTO phase\n+\t\t   as it can end up generating new type DIEs we didn't\n+\t\t   output and thus optimize_external_refs will crash.  */\n+\t\ttdie = new_die (DW_TAG_subprogram, cdie, NULL_TREE);\n+\t\tadd_AT_flag (tdie, DW_AT_external, 1);\n+\t\tadd_AT_flag (tdie, DW_AT_declaration, 1);\n+\t\tadd_linkage_attr (tdie, tdecl);\n+\t\tadd_name_and_src_coords_attributes (tdie, tdecl);\n+\t\tequate_decl_number_to_die (tdecl, tdie);\n \t      }\n \t    if (tdie)\n \t      {"}, {"sha": "4dd3014c91e61d4e2b28905aec8a6e76623a15b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "patch": "@@ -1,3 +1,8 @@\n+2015-06-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR debug/65549\n+\t* g++.dg/lto/pr65549_0.C: New testcase.\n+\n 2015-06-02  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR libgomp/65742"}, {"sha": "4c6358dc7b90d049689da9556ba9655338f376b0", "filename": "gcc/testsuite/g++.dg/lto/pr65549_0.C", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fa02e0d8932de4ba1a527f50df98bf211f2ffd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C?ref=71fa02e0d8932de4ba1a527f50df98bf211f2ffd", "patch": "@@ -0,0 +1,144 @@\n+// { dg-lto-do link }\n+// { dg-lto-options { { -std=gnu++14 -flto -g } { -std=gnu++14 -flto -g -O2 -fno-inline -flto-partition=max } } }\n+// { dg-extra-ld-options \"-r -nostdlib\" }\n+\n+namespace std {\n+inline namespace __cxx11 {}\n+template <typename _Tp, _Tp> struct integral_constant {\n+  static constexpr _Tp value = 0;\n+};\n+template <typename> struct __and_;\n+struct is_member_object_pointer : integral_constant<bool, false> {};\n+template <typename>\n+struct is_member_function_pointer : integral_constant<bool, false> {};\n+template <typename> struct remove_reference { typedef int type; };\n+template <typename> class C;\n+template <bool, int, typename...> struct __result_of_impl;\n+template <typename _Functor, typename... _ArgTypes>\n+struct __result_of_impl<false, 0, _Functor, _ArgTypes...> {\n+  typedef decltype(0) type;\n+};\n+template <typename _Functor, typename... _ArgTypes>\n+struct C<_Functor(_ArgTypes...)>\n+    : __result_of_impl<is_member_object_pointer::value,\n+                       is_member_function_pointer<\n+                           typename remove_reference<_Functor>::type>::value,\n+                       _Functor> {};\n+template <typename _Tp> using result_of_t = typename C<_Tp>::type;\n+template <typename> void forward();\n+template <typename _Tp> _Tp move(_Tp) {}\n+namespace __cxx11 {\n+class basic_string typedef string;\n+}\n+template <typename> struct allocator_traits { typedef decltype(0) pointer; };\n+}\n+struct F : std::allocator_traits<int> {};\n+namespace std {\n+namespace __cxx11 {\n+class basic_string {\n+public:\n+  struct _Alloc_hider : F {\n+    _Alloc_hider(pointer);\n+  } _M_dataplus;\n+  basic_string(int) : _M_dataplus(0) {}\n+  ~basic_string();\n+};\n+}\n+template <typename> class function;\n+template <typename _Functor> class _Base_manager {\n+protected:\n+  static _Functor *_M_get_pointer(int) {}\n+};\n+template <typename, typename> class _Function_handler;\n+template <typename _Res, typename _Functor, typename... _ArgTypes>\n+class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : _Base_manager<_Functor> {\n+public:\n+  static _Res _M_invoke(const int &) {\n+    (*_Base_manager<_Functor>::_M_get_pointer(0))();\n+  }\n+};\n+template <typename, typename> using __check_func_return_type = int;\n+template <typename _Res, typename... _ArgTypes>\n+class function<_Res(_ArgTypes...)> {\n+  template <typename> using _Invoke = decltype(0);\n+  template <typename _Functor>\n+  using _Callable = __and_<__check_func_return_type<_Invoke<_Functor>, _Res>>;\n+  template <typename, typename> using _Requires = int;\n+\n+public:\n+  template <typename _Functor, typename = _Requires<_Callable<_Functor>, void>>\n+  function(_Functor);\n+  using _Invoker_type = _Res (*)(const int &);\n+  _Invoker_type _M_invoker;\n+};\n+template <typename _Res, typename... _ArgTypes>\n+template <typename _Functor, typename>\n+function<_Res(_ArgTypes...)>::function(_Functor) {\n+  _M_invoker = _Function_handler<_Res(), _Functor>::_M_invoke;\n+}\n+class unique_ptr {\n+public:\n+  ~unique_ptr();\n+};\n+template <typename _Tp, typename... _Args> _Tp make_unique(_Args... __args) {\n+  _Tp(__args...);\n+}\n+}\n+class A {\n+public:\n+  template <class T> T as();\n+};\n+class variables_map {\n+public:\n+  A operator[](std::basic_string);\n+};\n+class B {\n+public:\n+  variables_map configuration();\n+  void run(int, int, std::function<void()>);\n+};\n+class H;\n+struct G {\n+  enum {} _state;\n+};\n+class D {\n+  G _local_state;\n+  std::unique_ptr _task;\n+  template <typename Func> void schedule(Func func) {\n+    struct task_with_state {\n+      task_with_state(Func func) : _func(func) {}\n+      Func _func;\n+    } tws = std::make_unique<task_with_state>(std::move(func));\n+  }\n+  friend H;\n+};\n+template <typename> using futurize_t = H;\n+class H {\n+  D *_promise;\n+  template <typename Func> void schedule(Func func) {\n+    G __trans_tmp_1;\n+    struct task_with_ready_state {\n+      task_with_ready_state(Func, G);\n+    };\n+    std::make_unique<task_with_ready_state>(std::move(func), __trans_tmp_1);\n+    _promise->schedule(std::move(func));\n+  }\n+  template <typename Func, typename Param> void then(Func func, Param) {\n+    using P = D;\n+    P pr;\n+    schedule([ pr = std::move(pr), func, param = std::forward<Param> ]{});\n+  }\n+\n+public:\n+  template <typename Func> futurize_t<std::result_of_t<Func()>> then(Func) {\n+    then(0, [] {});\n+  }\n+} clients;\n+main() {\n+  B app;\n+  app.run(0, 0, [&] {\n+    auto config = app.configuration()[0].as<std::string>();\n+    clients.then([] {});\n+  });\n+}"}]}