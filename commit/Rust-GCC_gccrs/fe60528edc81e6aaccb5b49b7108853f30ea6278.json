{"sha": "fe60528edc81e6aaccb5b49b7108853f30ea6278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2MDUyOGVkYzgxZTZhYWNjYjViNDliNzEwODg1M2YzMGVhNjI3OA==", "commit": {"author": {"name": "Kyle Galloway", "email": "kgallowa@redhat.com", "date": "2007-02-15T15:08:27Z"}, "committer": {"name": "Kyle Galloway", "email": "kgallowa@gcc.gnu.org", "date": "2007-02-15T15:08:27Z"}, "message": "defineclass.cc (_Jv_ClassReader::read_one_code_attribute): Added LocalVariableTable attribute handling.\n\n2007-02-15  Kyle Galloway  <kgallowa@redhat.com>\n\n\t* defineclass.cc (_Jv_ClassReader::read_one_code_attribute):\n    Added LocalVariableTable attribute handling.\n    (_Jv_ClassReader::pool_Utf8_to_char_arr): New method.\n    * jvmti.cc (_Jv_JVMTI_GetLocalVariableTable): New method.\n    * include/java-interp.h: Added local_var_table and\n    local_var_table_len fields to _Jv_InterpMethod.\n    (_Jv_InterpMethod::get_local_var_table): New method.\n    * testsuite/libjava.jvmti/interp/getlocalvartable.java: New\n    test.\n    * testsuite/libjava.jvmti/interp/getlocalvartable.jar: New test.\n    * testsuite/libjava.jvmti/interp/getlocalvartable.out: Output\n    for new test.\n    * testsuite/libjava.jvmti/interp/getlocalvartable.h: New test.\n    * testsuite/libjava.jvmti/interp/natgetlocalvartable.cc: New\n    test.\n\nFrom-SVN: r121999", "tree": {"sha": "d582917d66a2280e29d258af271b3d5500823c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d582917d66a2280e29d258af271b3d5500823c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe60528edc81e6aaccb5b49b7108853f30ea6278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe60528edc81e6aaccb5b49b7108853f30ea6278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe60528edc81e6aaccb5b49b7108853f30ea6278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe60528edc81e6aaccb5b49b7108853f30ea6278/comments", "author": null, "committer": null, "parents": [{"sha": "ed765125f2981bc0c2976b5650ba54abc3cb5f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed765125f2981bc0c2976b5650ba54abc3cb5f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed765125f2981bc0c2976b5650ba54abc3cb5f2e"}], "stats": {"total": 205, "additions": 202, "deletions": 3}, "files": [{"sha": "f86ef8594bfac8f594cdeea09528447154551c05", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fe60528edc81e6aaccb5b49b7108853f30ea6278", "patch": "@@ -1,3 +1,21 @@\n+2007-02-15  Kyle Galloway  <kgallowa@redhat.com>\n+\n+\t* defineclass.cc (_Jv_ClassReader::read_one_code_attribute):\n+    Added LocalVariableTable attribute handling.\n+    (_Jv_ClassReader::pool_Utf8_to_char_arr): New method.\n+    * jvmti.cc (_Jv_JVMTI_GetLocalVariableTable): New method.\n+    * include/java-interp.h: Added local_var_table and\n+    local_var_table_len fields to _Jv_InterpMethod.\n+    (_Jv_InterpMethod::get_local_var_table): New method.\n+    * testsuite/libjava.jvmti/interp/getlocalvartable.java: New\n+    test.\n+    * testsuite/libjava.jvmti/interp/getlocalvartable.jar: New test.\n+    * testsuite/libjava.jvmti/interp/getlocalvartable.out: Output\n+    for new test.\n+    * testsuite/libjava.jvmti/interp/getlocalvartable.h: New test.\n+    * testsuite/libjava.jvmti/interp/natgetlocalvartable.cc: New\n+    test.\n+\n 2007-02-15  Kyle Galloway  <kgallowa@redhat.com>\n  \n    * gnu/classpath/jdwp/natVMVirtualMachine (getFrames): Implement."}, {"sha": "c66fff84b7f70bad11573dec002322aaf62bc826", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=fe60528edc81e6aaccb5b49b7108853f30ea6278", "patch": "@@ -299,6 +299,9 @@ struct _Jv_ClassReader\n \n   /** check an utf8 entry, without creating a Utf8Const object */\n   bool is_attribute_name (int index, const char *name);\n+  \n+  /** return the value of a utf8 entry in the passed array */\n+  int pool_Utf8_to_char_arr (int index, char **entry);\n \n   /** here goes the class-loader members defined out-of-line */\n   void handleConstantPool ();\n@@ -784,6 +787,18 @@ _Jv_ClassReader::is_attribute_name (int index, const char *name)\n     return !memcmp (bytes+offsets[index]+2, name, len);\n }\n \n+// Get a UTF8 value from the constant pool and turn it into a garbage\n+// collected char array.\n+int _Jv_ClassReader::pool_Utf8_to_char_arr (int index, char** entry)\n+{\n+  check_tag (index, JV_CONSTANT_Utf8);\n+  int len = get2u (bytes + offsets[index]);\n+  *entry = reinterpret_cast<char *> (_Jv_AllocBytes (len + 1));\n+  (*entry)[len] = '\\0';\n+  memcpy (*entry, bytes + offsets[index] + 2, len);\n+  return len + 1;\n+}\n+\n void _Jv_ClassReader::read_one_field_attribute (int field_index,\n \t\t\t\t\t\tbool *found_value)\n {\n@@ -979,6 +994,34 @@ void _Jv_ClassReader::read_one_code_attribute (int method_index)\n       method->line_table_len = table_len;\n       method->line_table = table;\n     }\n+  else if (is_attribute_name (name, \"LocalVariableTable\"))\n+    {\n+      _Jv_InterpMethod *method = reinterpret_cast<_Jv_InterpMethod *>\n+\t                       (def_interp->interpreted_methods[method_index]);\n+      if (method->local_var_table != NULL)\n+        throw_class_format_error (\"Method already has LocalVariableTable\");\n+\t\n+      int table_len = read2u ();\n+      _Jv_LocalVarTableEntry *table \n+        = reinterpret_cast<_Jv_LocalVarTableEntry *>\n+            (_Jv_AllocRawObj (table_len * sizeof (_Jv_LocalVarTableEntry)));\n+                               \n+      for (int i = 0; i < table_len; i++)\n+        {\n+          table[i].bytecode_start_pc = read2u ();\n+          table[i].length = read2u ();\n+          int len;\n+          len = pool_Utf8_to_char_arr (read2u (), &table[i].name);\n+          len = pool_Utf8_to_char_arr (read2u (), &table[i].descriptor);\n+          table[i].slot = read2u ();\n+          \n+          if (table[i].slot > method->max_locals || table[i].slot < 0)\n+            throw_class_format_error (\"Malformed Local Variable Table: Invalid Slot\");\n+        }\n+\t    \n+      method->local_var_table_len = table_len;\n+      method->local_var_table = table;\n+    }\n   else\n     {\n       /* ignore unknown code attributes */"}, {"sha": "40c3b281896b1e35afa13a85cd2624110364bf96", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=fe60528edc81e6aaccb5b49b7108853f30ea6278", "patch": "@@ -137,6 +137,21 @@ struct  _Jv_LineTableEntry\n   int line;\n };\n \n+// This structure holds local variable information.\n+// The pc value is the first pc where the variable must have a value and it\n+// must continue to have a value until (start_pc + length).\n+// The name is the variable name, and the descriptor contains type information.\n+// The slot is the index in the local variable array of this method, long and\n+// double occupy slot and slot+1.\n+struct _Jv_LocalVarTableEntry\n+{\n+  int bytecode_start_pc;\n+  int length;\n+  char *name;\n+  char *descriptor;\n+  int slot;\n+};\n+\n class _Jv_InterpMethod : public _Jv_MethodBase\n {\n   // Breakpoint instruction\n@@ -157,6 +172,10 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   // Length of the line_table - when this is zero then line_table is NULL.\n   int line_table_len;  \n   _Jv_LineTableEntry *line_table;\n+  \n+  // The local variable table length and the table itself\n+  int local_var_table_len;\n+  _Jv_LocalVarTableEntry *local_var_table;\n \n   pc_t prepared;\n   int number_insn_slots;\n@@ -224,6 +243,20 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   {\n     return static_cast<int> (max_locals);\n   }\n+  \n+  /* Get info for a local variable of this method.\n+   * If there is no loca_var_table for this method it will return -1.\n+   * table_slot  indicates which slot in the local_var_table to get, if there is\n+   * no variable at this location it will return 0.\n+   * Otherwise, it will return the number of table slots after the selected\n+   * slot, indexed from 0.\n+   * \n+   * Example: there are 5 slots in the table, you request slot 0 so it will\n+   * return 4.\n+   */\n+  int get_local_var_table (char **name, char **sig, char **generic_sig,\n+                           jlong *startloc, jint *length, jint *slot,\n+                           int table_slot);\n \n   /* Installs a break instruction at the given code index. Returns\n      the pc_t of the breakpoint or NULL if index is invalid. */"}, {"sha": "8a4edace5946664bc1055e75fb6a2f11ee89cebb", "filename": "libjava/interpret.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=fe60528edc81e6aaccb5b49b7108853f30ea6278", "patch": "@@ -1414,6 +1414,30 @@ _Jv_InterpMethod::get_line_table (jlong& start, jlong& end,\n #endif // !DIRECT_THREADED\n }\n \n+int \n+_Jv_InterpMethod::get_local_var_table (char **name, char **sig, \n+                                       char **generic_sig, jlong *startloc,\n+                                       jint *length, jint *slot, \n+                                       int table_slot)\n+{  \t\n+  if (local_var_table == NULL)\n+    return -2;\n+  if (table_slot >= local_var_table_len)\n+    return -1;\n+  else\n+    {\n+      *name = local_var_table[table_slot].name;\n+      *sig = local_var_table[table_slot].descriptor;\n+      *generic_sig = local_var_table[table_slot].descriptor;\n+\n+      *startloc = static_cast<jlong> \n+                    (local_var_table[table_slot].bytecode_start_pc);\n+      *length = static_cast<jint> (local_var_table[table_slot].length);\n+      *slot = static_cast<jint> (local_var_table[table_slot].slot);\n+    }\n+  return local_var_table_len - table_slot -1;\n+}\n+\n pc_t\n _Jv_InterpMethod::install_break (jlong index)\n {"}, {"sha": "ae906a0da464e10899de54650aa8bad89f8b6d59", "filename": "libjava/jvmti.cc", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Fjvmti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe60528edc81e6aaccb5b49b7108853f30ea6278/libjava%2Fjvmti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjvmti.cc?ref=fe60528edc81e6aaccb5b49b7108853f30ea6278", "patch": "@@ -703,6 +703,88 @@ _Jv_JVMTI_GetLineNumberTable (jvmtiEnv *env, jmethodID method,\n   return JVMTI_ERROR_NONE;\n }\n \n+static jvmtiError JNICALL\n+_Jv_JVMTI_GetLocalVariableTable (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,\n+                                 jint *num_locals,\n+                                 jvmtiLocalVariableEntry **locals)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);\n+  NULL_CHECK (num_locals);\n+  NULL_CHECK (locals);\n+  \n+  CHECK_FOR_NATIVE_METHOD(method);\n+  \n+  jclass klass;\n+  jvmtiError jerr = env->GetMethodDeclaringClass (method, &klass);\n+  if (jerr != JVMTI_ERROR_NONE)\n+    return jerr;\n+\n+  _Jv_InterpMethod *imeth = reinterpret_cast<_Jv_InterpMethod *> \n+                              (_Jv_FindInterpreterMethod (klass, method));\n+  \n+  if (imeth == NULL)\n+    return JVMTI_ERROR_INVALID_METHODID;\n+  \n+  jerr = env->GetMaxLocals (method, num_locals);\n+  if (jerr != JVMTI_ERROR_NONE)\n+    return jerr;\n+  \n+  jerr = env->Allocate (static_cast<jlong> \n+                          ((*num_locals) * sizeof (jvmtiLocalVariableEntry)),\n+                        reinterpret_cast<unsigned char **> (locals));\n+  \n+  if (jerr != JVMTI_ERROR_NONE)\n+    return jerr;\n+  \n+  //the slot in the methods local_var_table to get\n+  int table_slot = 0;\n+  char *name;\n+  char *sig;\n+  char *generic_sig;\n+  \n+  while (table_slot < *num_locals \n+         && imeth->get_local_var_table (&name, &sig, &generic_sig,\n+                                 &((((*locals)[table_slot].start_location))),\n+                                 &((*locals)[table_slot].length), \n+                                 &((*locals)[table_slot].slot),\n+                                 table_slot) \n+            >= 0)\n+    {\n+      jerr = env->Allocate (static_cast<jlong> (strlen (name) + 1),\n+                             reinterpret_cast<unsigned char **>\n+                               (&(*locals)[table_slot].name));\n+      if (jerr != JVMTI_ERROR_NONE)\n+        return jerr;\n+      strcpy ((*locals)[table_slot].name, name);\n+\n+      jerr = env->Allocate (static_cast<jlong> (strlen (name) + 1),\n+                               reinterpret_cast<unsigned char **>\n+                                 (&(*locals)[table_slot].signature));\n+      if (jerr != JVMTI_ERROR_NONE)\n+        return jerr;\n+      strcpy ((*locals)[table_slot].signature, sig);\n+  \n+      jerr = env->Allocate (static_cast<jlong> (strlen (name) + 1),\n+                               reinterpret_cast<unsigned char **>\n+                               (&(*locals)[table_slot].generic_signature));\n+      if (jerr != JVMTI_ERROR_NONE)\n+        return jerr;\n+      strcpy ((*locals)[table_slot].generic_signature, generic_sig);\n+      \n+      table_slot++;\n+    }\n+\n+  if (table_slot == 0)\n+    return JVMTI_ERROR_ABSENT_INFORMATION;\n+  \n+  // If there are double or long variables in the table, the the table will be\n+  // smaller than the max number of slots, so correct for this here.\n+  if ((table_slot) < *num_locals)\n+    *num_locals = table_slot;\n+  \n+  return JVMTI_ERROR_NONE;\n+}\n+\n static jvmtiError JNICALL\n _Jv_JVMTI_IsMethodNative (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,\n \t\t\t  jboolean *result)\n@@ -733,8 +815,7 @@ _Jv_JVMTI_IsMethodSynthetic (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,\n }\n \n static jvmtiError JNICALL\n-_Jv_JVMTI_GetMaxLocals (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,\n-                        jint *max_locals)\n+_Jv_JVMTI_GetMaxLocals (jvmtiEnv *env, jmethodID method, jint *max_locals)\n {\n   REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);\n   NULL_CHECK (max_locals);\n@@ -1686,7 +1767,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   UNIMPLEMENTED,\t\t// GetArgumentsSize\n   _Jv_JVMTI_GetLineNumberTable,\t// GetLineNumberTable\n   UNIMPLEMENTED,\t\t// GetMethodLocation\n-  UNIMPLEMENTED,\t\t// GetLocalVariableTable\n+  _Jv_JVMTI_GetLocalVariableTable,\t\t// GetLocalVariableTable\n   RESERVED,\t\t\t// reserved73\n   RESERVED,\t\t\t// reserved74\n   UNIMPLEMENTED,\t\t// GetBytecodes"}]}