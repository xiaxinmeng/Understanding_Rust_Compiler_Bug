{"sha": "bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ0Mjg4YzAyYjQ4N2NjOGE5YWZjZmE5YzIxYmZlNTk0YTc4ZTI2ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T15:25:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T15:25:38Z"}, "message": "Add a partial_subreg_p predicate\n\nThis patch adds a partial_subreg_p predicate to go alongside\nparadoxical_subreg_p.\n\nLike the paradoxical_subreg_p patch, this one replaces some tests that\nwere based on GET_MODE_SIZE rather than GET_MODE_PRECISION.  In each\ncase the change should be a no-op or an improvement.\n\nThe regcprop.c patch prevents some replacements of the 82-bit RFmode\nwith the 80-bit XFmode on ia64.  I don't understand the target details\nhere particularly well, but from the way the modes are described in\nia64-modes.def, it isn't valid to assume that an XFmode can carry an\nRFmode payload.  A comparison of the testsuite assembly output for one\ntarget per CPU showed no other differences.\n\nSome of the places changed here are tracking the widest access mode\nfound for a register.  The series tries to standardise on:\n\n  if (partial_subreg_p (widest_seen, new_mode))\n    widest_seen = new_mode;\n\nrather than:\n\n  if (paradoxical_subreg_p (new_mode, widest_seen))\n    widest_seen = new_mode;\n\nEither would have been OK.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (partial_subreg_p): New function.\n\t* caller-save.c (save_call_clobbered_regs): Use it.\n\t* calls.c (expand_call): Likewise.\n\t* combine.c (combinable_i3pat): Likewise.\n\t(simplify_set): Likewise.\n\t(make_extraction): Likewise.\n\t(make_compound_operation_int): Likewise.\n\t(gen_lowpart_or_truncate): Likewise.\n\t(force_to_mode): Likewise.\n\t(make_field_assignment): Likewise.\n\t(reg_truncated_to_mode): Likewise.\n\t(record_truncated_value): Likewise.\n\t(move_deaths): Likewise.\n\t* cse.c (record_jump_cond): Likewise.\n\t(cse_insn): Likewise.\n\t* cselib.c (cselib_lookup_1): Likewise.\n\t* expmed.c (extract_bit_field_using_extv): Likewise.\n\t* function.c (assign_parm_setup_reg): Likewise.\n\t* ifcvt.c (noce_convert_multiple_sets): Likewise.\n\t* ira-build.c (create_insn_allocnos): Likewise.\n\t* lra-coalesce.c (merge_pseudos): Likewise.\n\t* lra-constraints.c (match_reload): Likewise.\n\t(simplify_operand_subreg): Likewise.\n\t(curr_insn_transform): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* lra.c (new_insn_reg): Likewise.\n\t(lra_substitute_pseudo): Likewise.\n\t* regcprop.c (mode_change_ok): Likewise.\n\t(maybe_mode_change): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\t* reload.c (push_reload): Likewise.\n\t(find_reloads): Likewise.\n\t(find_reloads_subreg_address): Likewise.\n\t* reload1.c (alter_reg): Likewise.\n\t(eliminate_regs_1): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251536", "tree": {"sha": "9d9683180c8d4eb77c41fbb539c214855b182e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d9683180c8d4eb77c41fbb539c214855b182e6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/comments", "author": null, "committer": null, "parents": [{"sha": "432ebb1dea041cce8322e78cb394d41970387bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432ebb1dea041cce8322e78cb394d41970387bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432ebb1dea041cce8322e78cb394d41970387bae"}], "stats": {"total": 254, "additions": 148, "deletions": 106}, "files": [{"sha": "a726d8e690b8e6e47914f9f7c39793174387164f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -1,3 +1,44 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (partial_subreg_p): New function.\n+\t* caller-save.c (save_call_clobbered_regs): Use it.\n+\t* calls.c (expand_call): Likewise.\n+\t* combine.c (combinable_i3pat): Likewise.\n+\t(simplify_set): Likewise.\n+\t(make_extraction): Likewise.\n+\t(make_compound_operation_int): Likewise.\n+\t(gen_lowpart_or_truncate): Likewise.\n+\t(force_to_mode): Likewise.\n+\t(make_field_assignment): Likewise.\n+\t(reg_truncated_to_mode): Likewise.\n+\t(record_truncated_value): Likewise.\n+\t(move_deaths): Likewise.\n+\t* cse.c (record_jump_cond): Likewise.\n+\t(cse_insn): Likewise.\n+\t* cselib.c (cselib_lookup_1): Likewise.\n+\t* expmed.c (extract_bit_field_using_extv): Likewise.\n+\t* function.c (assign_parm_setup_reg): Likewise.\n+\t* ifcvt.c (noce_convert_multiple_sets): Likewise.\n+\t* ira-build.c (create_insn_allocnos): Likewise.\n+\t* lra-coalesce.c (merge_pseudos): Likewise.\n+\t* lra-constraints.c (match_reload): Likewise.\n+\t(simplify_operand_subreg): Likewise.\n+\t(curr_insn_transform): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* lra.c (new_insn_reg): Likewise.\n+\t(lra_substitute_pseudo): Likewise.\n+\t* regcprop.c (mode_change_ok): Likewise.\n+\t(maybe_mode_change): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t* reload.c (push_reload): Likewise.\n+\t(find_reloads): Likewise.\n+\t(find_reloads_subreg_address): Likewise.\n+\t* reload1.c (alter_reg): Likewise.\n+\t(eliminate_regs_1): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\n 2017-08-30  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Revert"}, {"sha": "65a498d0d0cc499f4c0d8ff8f3b595da3c156994", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -837,8 +837,7 @@ save_call_clobbered_regs (void)\n \t\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n \t\t  mode = HARD_REGNO_CALLER_SAVE_MODE\n \t\t    (r, nregs, PSEUDO_REGNO_MODE (regno));\n-\t\t  if (GET_MODE_BITSIZE (mode)\n-\t\t      > GET_MODE_BITSIZE (save_mode[r]))\n+\t\t  if (partial_subreg_p (save_mode[r], mode))\n \t\t    save_mode[r] = mode;\n \t\t  while (nregs-- > 0)\n \t\t    SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);"}, {"sha": "79b6e25ac9addd09033a9b07a97f6734ecabf381", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -3357,8 +3357,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t      || ((caller_mode != caller_promoted_mode\n \t\t   || callee_mode != callee_promoted_mode)\n \t\t  && (caller_unsignedp != callee_unsignedp\n-\t\t      || GET_MODE_BITSIZE (caller_mode)\n-\t\t\t < GET_MODE_BITSIZE (callee_mode)))))\n+\t\t      || partial_subreg_p (caller_mode, callee_mode)))))\n \t{\n \t  try_tail_call = 0;\n \t  maybe_complain_about_tail_call (exp,"}, {"sha": "86055385d78f51bfe35f8631651ad9d862dc5997", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -2224,9 +2224,7 @@ combinable_i3pat (rtx_insn *i3, rtx *loc, rtx i2dest, rtx i1dest, rtx i0dest,\n \t STACK_POINTER_REGNUM, since these are always considered to be\n \t live.  Similarly for ARG_POINTER_REGNUM if it is fixed.  */\n       subdest = dest;\n-      if (GET_CODE (subdest) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (subdest))\n-\t      >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (subdest)))))\n+      if (GET_CODE (subdest) == SUBREG && !partial_subreg_p (subdest))\n \tsubdest = SUBREG_REG (subdest);\n       if (pi3dest_killed\n \t  && REG_P (subdest)\n@@ -6882,10 +6880,8 @@ simplify_set (rtx x)\n   /* If we have (set (cc0) (subreg ...)), we try to remove the subreg\n      in SRC.  */\n   if (dest == cc0_rtx\n-      && GET_CODE (src) == SUBREG\n-      && subreg_lowpart_p (src)\n-      && (GET_MODE_PRECISION (GET_MODE (src))\n-\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (src)))))\n+      && partial_subreg_p (src)\n+      && subreg_lowpart_p (src))\n     {\n       rtx inner = SUBREG_REG (src);\n       machine_mode inner_mode = GET_MODE (inner);\n@@ -7634,7 +7630,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   /* Never narrow an object, since that might not be safe.  */\n \n   if (mode != VOIDmode\n-      && GET_MODE_SIZE (extraction_mode) < GET_MODE_SIZE (mode))\n+      && partial_subreg_p (extraction_mode, mode))\n     extraction_mode = mode;\n \n   if (!MEM_P (inner))\n@@ -7681,7 +7677,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   if (wanted_inner_mode != VOIDmode\n       && inner_mode != wanted_inner_mode\n       && ! pos_rtx\n-      && GET_MODE_SIZE (wanted_inner_mode) < GET_MODE_SIZE (is_mode)\n+      && partial_subreg_p (wanted_inner_mode, is_mode)\n       && MEM_P (inner)\n       && ! mode_dependent_address_p (XEXP (inner, 0), MEM_ADDR_SPACE (inner))\n       && ! MEM_VOLATILE_P (inner))\n@@ -8201,7 +8197,7 @@ make_compound_operation_int (scalar_int_mode mode, rtx *x_ptr,\n \t\t   to (subreg:QI (lshiftrt:SI (reg:SI) (const_int 7)) 0).  */\n \t\t|| (GET_CODE (inner) == AND\n \t\t    && CONST_INT_P (XEXP (inner, 1))\n-\t\t    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (inner))\n+\t\t    && partial_subreg_p (x)\n \t\t    && exact_log2 (UINTVAL (XEXP (inner, 1)))\n \t\t       >= GET_MODE_BITSIZE (mode) - 1)))\n \t  subreg_code = SET;\n@@ -8214,7 +8210,7 @@ make_compound_operation_int (scalar_int_mode mode, rtx *x_ptr,\n \t  tem = simplified;\n \n \tif (GET_CODE (tem) != GET_CODE (inner)\n-\t    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (inner))\n+\t    && partial_subreg_p (x)\n \t    && subreg_lowpart_p (x))\n \t  {\n \t    rtx newer\n@@ -8225,8 +8221,9 @@ make_compound_operation_int (scalar_int_mode mode, rtx *x_ptr,\n \t    if (GET_CODE (newer) != SUBREG)\n \t      newer = make_compound_operation (newer, in_code);\n \n-\t    /* force_to_mode can expand compounds.  If it just re-expanded the\n-\t       compound, use gen_lowpart to convert to the desired mode.  */\n+\t    /* force_to_mode can expand compounds.  If it just re-expanded\n+\t       the compound, use gen_lowpart to convert to the desired\n+\t       mode.  */\n \t    if (rtx_equal_p (newer, x)\n \t\t/* Likewise if it re-expanded the compound only partially.\n \t\t   This happens for SUBREG of ZERO_EXTRACT if they extract\n@@ -8468,7 +8465,7 @@ static rtx\n gen_lowpart_or_truncate (machine_mode mode, rtx x)\n {\n   if (!CONST_INT_P (x)\n-      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x))\n+      && partial_subreg_p (mode, GET_MODE (x))\n       && !TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (x))\n       && !(REG_P (x) && reg_truncated_to_mode (mode, x)))\n     {\n@@ -8523,7 +8520,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n   /* It is not valid to do a right-shift in a narrower mode\n      than the one it came in with.  */\n   if ((code == LSHIFTRT || code == ASHIFTRT)\n-      && GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (GET_MODE (x)))\n+      && partial_subreg_p (mode, GET_MODE (x)))\n     op_mode = GET_MODE (x);\n \n   /* Truncate MASK to fit OP_MODE.  */\n@@ -8560,8 +8557,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n      if the constant masks to zero all the bits the mode doesn't have.  */\n   if (GET_CODE (x) == SUBREG\n       && subreg_lowpart_p (x)\n-      && ((GET_MODE_SIZE (GET_MODE (x))\n-\t   < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+      && (partial_subreg_p (x)\n \t  || (0 == (mask\n \t\t    & GET_MODE_MASK (GET_MODE (x))\n \t\t    & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n@@ -9555,8 +9551,7 @@ make_field_assignment (rtx x)\n \n   if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == SUBREG\n       && subreg_lowpart_p (XEXP (src, 0))\n-      && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n-\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n+      && partial_subreg_p (XEXP (src, 0))\n       && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n       && CONST_INT_P (XEXP (SUBREG_REG (XEXP (src, 0)), 0))\n       && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n@@ -13325,7 +13320,7 @@ reg_truncated_to_mode (machine_mode mode, const_rtx x)\n   if (truncated == 0\n       || rsp->truncation_label < label_tick_ebb_start)\n     return false;\n-  if (GET_MODE_SIZE (truncated) <= GET_MODE_SIZE (mode))\n+  if (!partial_subreg_p (mode, truncated))\n     return true;\n   if (TRULY_NOOP_TRUNCATION_MODES_P (mode, truncated))\n     return true;\n@@ -13348,9 +13343,10 @@ record_truncated_value (rtx x)\n       machine_mode original_mode = GET_MODE (SUBREG_REG (x));\n       truncated_mode = GET_MODE (x);\n \n-      if (GET_MODE_SIZE (original_mode) <= GET_MODE_SIZE (truncated_mode))\n+      if (!partial_subreg_p (truncated_mode, original_mode))\n \treturn true;\n \n+      truncated_mode = GET_MODE (x);\n       if (TRULY_NOOP_TRUNCATION_MODES_P (truncated_mode, original_mode))\n \treturn true;\n \n@@ -13366,8 +13362,7 @@ record_truncated_value (rtx x)\n   rsp = &reg_stat[REGNO (x)];\n   if (rsp->truncated_to_mode == 0\n       || rsp->truncation_label < label_tick_ebb_start\n-      || (GET_MODE_SIZE (truncated_mode)\n-\t  < GET_MODE_SIZE (rsp->truncated_to_mode)))\n+      || partial_subreg_p (truncated_mode, rsp->truncated_to_mode))\n     {\n       rsp->truncated_to_mode = truncated_mode;\n       rsp->truncation_label = label_tick;\n@@ -13891,8 +13886,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n \t     the remaining registers in place of NOTE.  */\n \n \t  if (note != 0 && regno < FIRST_PSEUDO_REGISTER\n-\t      && (GET_MODE_SIZE (GET_MODE (XEXP (note, 0)))\n-\t\t  > GET_MODE_SIZE (GET_MODE (x))))\n+\t      && partial_subreg_p (GET_MODE (x), GET_MODE (XEXP (note, 0))))\n \t    {\n \t      unsigned int deadregno = REGNO (XEXP (note, 0));\n \t      unsigned int deadend = END_REGNO (XEXP (note, 0));\n@@ -13911,8 +13905,8 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n \t     their own REG_DEAD notes lying around.  */\n \t  else if ((note == 0\n \t\t    || (note != 0\n-\t\t\t&& (GET_MODE_SIZE (GET_MODE (XEXP (note, 0)))\n-\t\t\t    < GET_MODE_SIZE (GET_MODE (x)))))\n+\t\t\t&& partial_subreg_p (GET_MODE (XEXP (note, 0)),\n+\t\t\t\t\t     GET_MODE (x))))\n \t\t   && regno < FIRST_PSEUDO_REGISTER\n \t\t   && REG_NREGS (x) > 1)\n \t    {"}, {"sha": "672fd2eaea970e408525d1f6d0baed53f0a57a09", "filename": "gcc/cse.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -3953,10 +3953,9 @@ record_jump_cond (enum rtx_code code, machine_mode mode, rtx op0,\n      if we test MODE instead, we can get an infinite recursion\n      alternating between two modes each wider than MODE.  */\n \n-  if (code == NE && GET_CODE (op0) == SUBREG\n-      && subreg_lowpart_p (op0)\n-      && (GET_MODE_SIZE (GET_MODE (op0))\n-\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n+  if (code == NE\n+      && partial_subreg_p (op0)\n+      && subreg_lowpart_p (op0))\n     {\n       machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n       rtx tem = record_jump_cond_subreg (inner_mode, op1);\n@@ -3965,10 +3964,9 @@ record_jump_cond (enum rtx_code code, machine_mode mode, rtx op0,\n \t\t\t  reversed_nonequality);\n     }\n \n-  if (code == NE && GET_CODE (op1) == SUBREG\n-      && subreg_lowpart_p (op1)\n-      && (GET_MODE_SIZE (GET_MODE (op1))\n-\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n+  if (code == NE\n+      && partial_subreg_p (op1)\n+      && subreg_lowpart_p (op1))\n     {\n       machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n       rtx tem = record_jump_cond_subreg (inner_mode, op0);\n@@ -5013,8 +5011,8 @@ cse_insn (rtx_insn *insn)\n \t      && ! (src != 0\n \t\t    && GET_CODE (src) == SUBREG\n \t\t    && GET_MODE (src) == GET_MODE (p->exp)\n-\t\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n-\t\t\t< GET_MODE_SIZE (GET_MODE (SUBREG_REG (p->exp))))))\n+\t\t    && partial_subreg_p (GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (p->exp)))))\n \t    continue;\n \n \t  if (src && GET_CODE (src) == code && rtx_equal_p (src, p->exp))\n@@ -5124,8 +5122,8 @@ cse_insn (rtx_insn *insn)\n \t      && ! (src != 0\n \t\t    && GET_CODE (src) == SUBREG\n \t\t    && GET_MODE (src) == GET_MODE (elt->exp)\n-\t\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n-\t\t\t< GET_MODE_SIZE (GET_MODE (SUBREG_REG (elt->exp))))))\n+\t\t    && partial_subreg_p (GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (elt->exp)))))\n \t    {\n \t      elt = elt->next_same_value;\n \t      continue;\n@@ -5967,8 +5965,7 @@ cse_insn (rtx_insn *insn)\n \t    && (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) - 1)\n \t\t / UNITS_PER_WORD)\n \t\t== (GET_MODE_SIZE (GET_MODE (dest)) - 1) / UNITS_PER_WORD)\n-\t    && (GET_MODE_SIZE (GET_MODE (dest))\n-\t\t>= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))\n+\t    && !partial_subreg_p (dest)\n \t    && sets[i].src_elt != 0)\n \t  {\n \t    machine_mode new_mode = GET_MODE (SUBREG_REG (dest));"}, {"sha": "d20e4bb662b43deb07cc39021e9438dcc4852221", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -2035,8 +2035,8 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \t    if (is_int_mode (GET_MODE (l->elt->val_rtx), &lmode)\n \t\t&& GET_MODE_SIZE (lmode) > GET_MODE_SIZE (int_mode)\n \t\t&& (lwider == NULL\n-\t\t    || GET_MODE_SIZE (lmode)\n-\t\t       < GET_MODE_SIZE (GET_MODE (lwider->elt->val_rtx))))\n+\t\t    || partial_subreg_p (lmode,\n+\t\t\t\t\t GET_MODE (lwider->elt->val_rtx))))\n \t      {\n \t\tstruct elt_loc_list *el;\n \t\tif (i < FIRST_PSEUDO_REGISTER"}, {"sha": "ff9eb5b2c71dcd005bd5186891d4b2b52548911f", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -1528,8 +1528,7 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n \t  && TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (target), ext_mode))\n \t{\n \t  target = gen_lowpart (ext_mode, target);\n-\t  if (GET_MODE_PRECISION (ext_mode)\n-\t      > GET_MODE_PRECISION (GET_MODE (spec_target)))\n+\t  if (partial_subreg_p (GET_MODE (spec_target), ext_mode))\n \t    spec_target_subreg = target;\n \t}\n       else"}, {"sha": "7d952e7994b48739ddd6d3f1133f4cb442488d03", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -3262,13 +3262,11 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);\n       tempreg = convert_to_mode (data->nominal_mode, tempreg, unsignedp);\n \n-      if (GET_CODE (tempreg) == SUBREG\n+      if (partial_subreg_p (tempreg)\n \t  && GET_MODE (tempreg) == data->nominal_mode\n \t  && REG_P (SUBREG_REG (tempreg))\n \t  && data->nominal_mode == data->passed_mode\n-\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (data->entry_parm)\n-\t  && GET_MODE_SIZE (GET_MODE (tempreg))\n-\t     < GET_MODE_SIZE (GET_MODE (data->entry_parm)))\n+\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (data->entry_parm))\n \t{\n \t  /* The argument is already sign/zero extended, so note it\n \t     into the subreg.  */"}, {"sha": "e1b163cd42eec8015857597db0a67db243b9da14", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -3198,7 +3198,7 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t{\n \t  machine_mode src_mode = GET_MODE (new_val);\n \t  machine_mode dst_mode = GET_MODE (temp);\n-\t  if (GET_MODE_SIZE (src_mode) <= GET_MODE_SIZE (dst_mode))\n+\t  if (!partial_subreg_p (dst_mode, src_mode))\n \t    {\n \t      end_sequence ();\n \t      return FALSE;\n@@ -3209,7 +3209,7 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t{\n \t  machine_mode src_mode = GET_MODE (old_val);\n \t  machine_mode dst_mode = GET_MODE (temp);\n-\t  if (GET_MODE_SIZE (src_mode) <= GET_MODE_SIZE (dst_mode))\n+\t  if (!partial_subreg_p (dst_mode, src_mode))\n \t    {\n \t      end_sequence ();\n \t      return FALSE;"}, {"sha": "5c428539e9c93af5fa8084a0ef86d3d6dc966126", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -1853,7 +1853,7 @@ create_insn_allocnos (rtx x, rtx outer, bool output_p)\n \t      if (outer != NULL && GET_CODE (outer) == SUBREG)\n \t\t{\n \t\t  machine_mode wmode = GET_MODE (outer);\n-\t\t  if (GET_MODE_SIZE (wmode) > GET_MODE_SIZE (ALLOCNO_WMODE (a)))\n+\t\t  if (partial_subreg_p (ALLOCNO_WMODE (a), wmode))\n \t\t    ALLOCNO_WMODE (a) = wmode;\n \t\t}\n \t    }"}, {"sha": "7af10d8d2648e1dc3bdea6dd30a630574d49b048", "filename": "gcc/lra-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-coalesce.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -112,8 +112,8 @@ merge_pseudos (int regno1, int regno2)\n     = (lra_merge_live_ranges\n        (lra_reg_info[first].live_ranges,\n \tlra_copy_live_range_list (lra_reg_info[first2].live_ranges)));\n-  if (GET_MODE_SIZE (lra_reg_info[first].biggest_mode)\n-      < GET_MODE_SIZE (lra_reg_info[first2].biggest_mode))\n+  if (partial_subreg_p (lra_reg_info[first].biggest_mode,\n+\t\t\tlra_reg_info[first2].biggest_mode))\n     lra_reg_info[first].biggest_mode = lra_reg_info[first2].biggest_mode;\n }\n "}, {"sha": "6da910e33a8720c023f6827b0f1ba6f7f30e8f24", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -928,7 +928,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n   push_to_sequence (*before);\n   if (inmode != outmode)\n     {\n-      if (GET_MODE_SIZE (inmode) > GET_MODE_SIZE (outmode))\n+      if (partial_subreg_p (outmode, inmode))\n \t{\n \t  reg = new_in_reg\n \t    = lra_create_new_reg_with_unique_value (inmode, in_rtx,\n@@ -1579,8 +1579,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t      bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n \n \t      insert_before = (type != OP_OUT\n-\t\t\t       || GET_MODE_SIZE (innermode)\n-\t\t\t\t    > GET_MODE_SIZE (mode));\n+\t\t\t       || partial_subreg_p (mode, innermode));\n \t      insert_after = type != OP_IN;\n \t      insert_move_for_subreg (insert_before ? &before : NULL,\n \t\t\t\t      insert_after ? &after : NULL,\n@@ -3939,8 +3938,7 @@ curr_insn_transform (bool check_only_p)\n       lra_assert (out >= 0 && in >= 0\n \t\t  && curr_static_id->operand[out].type == OP_OUT\n \t\t  && curr_static_id->operand[in].type == OP_IN);\n-      rld = (GET_MODE_SIZE (GET_MODE (dest)) <= GET_MODE_SIZE (GET_MODE (src))\n-\t     ? dest : src);\n+      rld = partial_subreg_p (GET_MODE (src), GET_MODE (dest)) ? src : dest;\n       rld_mode = GET_MODE (rld);\n #ifdef SECONDARY_MEMORY_NEEDED_MODE\n       sec_mode = SECONDARY_MEMORY_NEEDED_MODE (rld_mode);\n@@ -3950,7 +3948,7 @@ curr_insn_transform (bool check_only_p)\n       new_reg = lra_create_new_reg (sec_mode, NULL_RTX,\n \t\t\t\t    NO_REGS, \"secondary\");\n       /* If the mode is changed, it should be wider.  */\n-      lra_assert (GET_MODE_SIZE (sec_mode) >= GET_MODE_SIZE (rld_mode));\n+      lra_assert (!partial_subreg_p (sec_mode, rld_mode));\n       if (sec_mode != rld_mode)\n         {\n \t  /* If the target says specifically to use another mode for"}, {"sha": "8650dc7fca7520656579053b164a6f00b9eeaeea", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -717,9 +717,9 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t{\n \t  int i, regno = reg->regno;\n-\t  \n-\t  if (GET_MODE_SIZE (reg->biggest_mode)\n-\t      > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode))\n+\n+\t  if (partial_subreg_p (lra_reg_info[regno].biggest_mode,\n+\t\t\t\treg->biggest_mode))\n \t    lra_reg_info[regno].biggest_mode = reg->biggest_mode;\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    {\n@@ -729,8 +729,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t part of multi-register group.  Process this case\n \t\t here.  */\n \t      for (i = 1; i < hard_regno_nregs[regno][reg->biggest_mode]; i++)\n-\t\tif (GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno + i]))\n-\t\t    > GET_MODE_SIZE (lra_reg_info[regno + i].biggest_mode))\n+\t\tif (partial_subreg_p (lra_reg_info[regno + i].biggest_mode,\n+\t\t\t\t      GET_MODE (regno_reg_rtx[regno + i])))\n \t\t  lra_reg_info[regno + i].biggest_mode\n \t\t    = GET_MODE (regno_reg_rtx[regno + i]);\n \t    }"}, {"sha": "61e40eebe3ff949be1dc82db8e118bf3cda5095b", "filename": "gcc/lra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -546,8 +546,8 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n   lra_insn_reg *ir = lra_insn_reg_pool.allocate ();\n   ir->type = type;\n   ir->biggest_mode = mode;\n-  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n-      && NONDEBUG_INSN_P (insn))\n+  if (NONDEBUG_INSN_P (insn)\n+      && partial_subreg_p (lra_reg_info[regno].biggest_mode, mode))\n     lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n   ir->early_clobber = early_clobber;\n@@ -1913,7 +1913,7 @@ lra_substitute_pseudo (rtx *loc, int old_regno, rtx new_reg, bool subreg_p)\n       if (mode != inner_mode\n \t  && ! (CONST_INT_P (new_reg) && SCALAR_INT_MODE_P (mode)))\n \t{\n-\t  if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (inner_mode)\n+\t  if (!partial_subreg_p (mode, inner_mode)\n \t      || ! SCALAR_INT_MODE_P (inner_mode))\n \t    new_reg = gen_rtx_SUBREG (mode, new_reg, 0);\n \t  else"}, {"sha": "0d4ec172aee22d53e166c41fdabca6e063c6bcb4", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -372,7 +372,7 @@ static bool\n mode_change_ok (machine_mode orig_mode, machine_mode new_mode,\n \t\tunsigned int regno ATTRIBUTE_UNUSED)\n {\n-  if (GET_MODE_SIZE (orig_mode) < GET_MODE_SIZE (new_mode))\n+  if (partial_subreg_p (orig_mode, new_mode))\n     return false;\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n@@ -392,8 +392,8 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n \t\t   machine_mode new_mode, unsigned int regno,\n \t\t   unsigned int copy_regno ATTRIBUTE_UNUSED)\n {\n-  if (GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (orig_mode)\n-      && GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (new_mode))\n+  if (partial_subreg_p (copy_mode, orig_mode)\n+      && partial_subreg_p (copy_mode, new_mode))\n     return NULL_RTX;\n \n   /* Avoid creating multiple copies of the stack pointer.  Some ports\n@@ -1076,8 +1076,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       /* If a noop move is using narrower mode than we have recorded,\n \t we need to either remove the noop move, or kill_set_value.  */\n       if (noop_p\n-\t  && (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set)))\n-\t      < GET_MODE_BITSIZE (vd->e[REGNO (SET_DEST (set))].mode)))\n+\t  && partial_subreg_p (GET_MODE (SET_DEST (set)),\n+\t\t\t       vd->e[REGNO (SET_DEST (set))].mode))\n \t{\n \t  if (noop_move_p (insn))\n \t    {"}, {"sha": "e0793cff8b9dd6d75a95076cf7ae8dcf283611bd", "filename": "gcc/reload.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -1071,8 +1071,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t      && paradoxical_subreg_p (inmode, inner_mode)\n \t\t      && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)\n \t\t  || (WORD_REGISTER_OPERATIONS\n-\t\t      && (GET_MODE_PRECISION (inmode)\n-\t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n+\t\t      && partial_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n \t\t      && ((GET_MODE_SIZE (inmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1)\n \t\t\t   / UNITS_PER_WORD)))))\n@@ -1171,8 +1170,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       || MEM_P (SUBREG_REG (out)))\n \t      && (paradoxical_subreg_p (outmode, GET_MODE (SUBREG_REG (out)))\n \t\t  || (WORD_REGISTER_OPERATIONS\n-\t\t      && (GET_MODE_PRECISION (outmode)\n-\t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n+\t\t      && partial_subreg_p (outmode, GET_MODE (SUBREG_REG (out)))\n \t\t      && ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n \t\t\t   / UNITS_PER_WORD)))))\n@@ -1417,10 +1415,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       /* The modes can be different.  If they are, we want to reload in\n \t the larger mode, so that the value is valid for both modes.  */\n       if (inmode != VOIDmode\n-\t  && GET_MODE_SIZE (inmode) > GET_MODE_SIZE (rld[i].inmode))\n+\t  && partial_subreg_p (rld[i].inmode, inmode))\n \trld[i].inmode = inmode;\n       if (outmode != VOIDmode\n-\t  && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (rld[i].outmode))\n+\t  && partial_subreg_p (rld[i].outmode, outmode))\n \trld[i].outmode = outmode;\n       if (in != 0)\n \t{\n@@ -1462,26 +1460,25 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t     overwrite the operands only when the new mode is larger.\n \t     See also PR33613.  */\n \t  if (!rld[i].in\n-\t      || GET_MODE_SIZE (GET_MODE (in))\n-\t           > GET_MODE_SIZE (GET_MODE (rld[i].in)))\n+\t      || partial_subreg_p (GET_MODE (rld[i].in), GET_MODE (in)))\n \t    rld[i].in = in;\n \t  if (!rld[i].in_reg\n \t      || (in_reg\n-\t\t  && GET_MODE_SIZE (GET_MODE (in_reg))\n-\t             > GET_MODE_SIZE (GET_MODE (rld[i].in_reg))))\n+\t\t  && partial_subreg_p (GET_MODE (rld[i].in_reg),\n+\t\t\t\t       GET_MODE (in_reg))))\n \t    rld[i].in_reg = in_reg;\n \t}\n       if (out != 0)\n \t{\n \t  if (!rld[i].out\n \t      || (out\n-\t\t  && GET_MODE_SIZE (GET_MODE (out))\n-\t             > GET_MODE_SIZE (GET_MODE (rld[i].out))))\n+\t\t  && partial_subreg_p (GET_MODE (rld[i].out),\n+\t\t\t\t       GET_MODE (out))))\n \t    rld[i].out = out;\n \t  if (outloc\n \t      && (!rld[i].out_reg\n-\t\t  || GET_MODE_SIZE (GET_MODE (*outloc))\n-\t\t     > GET_MODE_SIZE (GET_MODE (rld[i].out_reg))))\n+\t\t  || partial_subreg_p (GET_MODE (rld[i].out_reg),\n+\t\t\t\t       GET_MODE (*outloc))))\n \t    rld[i].out_reg = *outloc;\n \t}\n       if (reg_class_subset_p (rclass, rld[i].rclass))\n@@ -1587,7 +1584,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       int regno;\n       machine_mode rel_mode = inmode;\n \n-      if (out && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (inmode))\n+      if (out && partial_subreg_p (rel_mode, outmode))\n \trel_mode = outmode;\n \n       for (note = REG_NOTES (this_insn); note; note = XEXP (note, 1))\n@@ -4554,11 +4551,10 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n   /* Compute reload_mode and reload_nregs.  */\n   for (i = 0; i < n_reloads; i++)\n     {\n-      rld[i].mode\n-\t= (rld[i].inmode == VOIDmode\n-\t   || (GET_MODE_SIZE (rld[i].outmode)\n-\t       > GET_MODE_SIZE (rld[i].inmode)))\n-\t  ? rld[i].outmode : rld[i].inmode;\n+      rld[i].mode = rld[i].inmode;\n+      if (rld[i].mode == VOIDmode\n+\t  || partial_subreg_p (rld[i].mode, rld[i].outmode))\n+\trld[i].mode = rld[i].outmode;\n \n       rld[i].nregs = ira_reg_class_max_nregs [rld[i].rclass][rld[i].mode];\n     }\n@@ -6162,7 +6158,7 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n     return NULL;\n \n   if (WORD_REGISTER_OPERATIONS\n-      && GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode)\n+      && partial_subreg_p (outer_mode, inner_mode)\n       && ((GET_MODE_SIZE (outer_mode) - 1) / UNITS_PER_WORD\n           == (GET_MODE_SIZE (inner_mode) - 1) / UNITS_PER_WORD))\n     return NULL;"}, {"sha": "023eaeea63e38ea04818c5dda97c53706983e059", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -2218,8 +2218,8 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \n \t  if (spill_stack_slot[from_reg])\n \t    {\n-\t      if (GET_MODE_SIZE (GET_MODE (spill_stack_slot[from_reg]))\n-\t\t  > inherent_size)\n+\t      if (partial_subreg_p (mode,\n+\t\t\t\t    GET_MODE (spill_stack_slot[from_reg])))\n \t\tmode = GET_MODE (spill_stack_slot[from_reg]);\n \t      if (spill_stack_slot_width[from_reg] > total_size)\n \t\ttotal_size = spill_stack_slot_width[from_reg];\n@@ -2817,7 +2817,7 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \t  int new_size = GET_MODE_SIZE (GET_MODE (new_rtx));\n \n \t  if (MEM_P (new_rtx)\n-\t      && ((x_size < new_size\n+\t      && ((partial_subreg_p (GET_MODE (x), GET_MODE (new_rtx))\n \t\t   /* On RISC machines, combine can create rtl of the form\n \t\t      (set (subreg:m1 (reg:m2 R) 0) ...)\n \t\t      where m1 < m2, and expects something interesting to"}, {"sha": "79abfa35fb444288b64565bee95465630dff3e3d", "filename": "gcc/rtl.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -2823,6 +2823,30 @@ extern rtx operand_subword_force (rtx, unsigned int, machine_mode);\n extern int subreg_lowpart_p (const_rtx);\n extern unsigned int subreg_size_lowpart_offset (unsigned int, unsigned int);\n \n+/* Return true if a subreg of mode OUTERMODE would only access part of\n+   an inner register with mode INNERMODE.  The other bits of the inner\n+   register would then be \"don't care\" on read.  The behavior for writes\n+   depends on REGMODE_NATURAL_SIZE; bits in the same REGMODE_NATURAL_SIZE-d\n+   chunk would be clobbered but other bits would be preserved.  */\n+\n+inline bool\n+partial_subreg_p (machine_mode outermode, machine_mode innermode)\n+{\n+  return GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode);\n+}\n+\n+/* Likewise return true if X is a subreg that is smaller than the inner\n+   register.  Use df_read_modify_subreg_p to test whether writing to such\n+   a subreg preserves any part of the inner register.  */\n+\n+inline bool\n+partial_subreg_p (const_rtx x)\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  return partial_subreg_p (GET_MODE (x), GET_MODE (SUBREG_REG (x)));\n+}\n+\n /* Return true if a subreg with the given outer and inner modes is\n    paradoxical.  */\n "}, {"sha": "6f4398e06ff4cd64023a708dd3361b34469c2cbb", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4288c02b487cc8a9afcfa9c21bfe594a78e26d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=bd4288c02b487cc8a9afcfa9c21bfe594a78e26d", "patch": "@@ -995,10 +995,8 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t\t\t\t\tXEXP (op, 0), const0_rtx);\n \n \n-      if (GET_CODE (op) == SUBREG\n+      if (partial_subreg_p (op)\n \t  && subreg_lowpart_p (op)\n-\t  && (GET_MODE_SIZE (GET_MODE (op))\n-\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n \t  && GET_CODE (SUBREG_REG (op)) == ASHIFT\n \t  && XEXP (SUBREG_REG (op), 0) == const1_rtx)\n \t{\n@@ -1640,10 +1638,9 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t of mode N.  E.g.\n \t (zero_extend:SI (subreg:QI (and:SI (reg:SI) (const_int 63)) 0)) is\n \t (and:SI (reg:SI) (const_int 63)).  */\n-      if (GET_CODE (op) == SUBREG\n+      if (partial_subreg_p (op)\n \t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op)), &op0_mode)\n-\t  && GET_MODE_PRECISION (GET_MODE (op)) < GET_MODE_PRECISION (op0_mode)\n \t  && GET_MODE_PRECISION (op0_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && GET_MODE_PRECISION (int_mode) >= GET_MODE_PRECISION (op0_mode)\n \t  && subreg_lowpart_p (op)"}]}