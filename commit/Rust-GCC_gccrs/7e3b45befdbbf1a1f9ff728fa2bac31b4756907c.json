{"sha": "7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "node_id": "C_kwDOANBUbNoAKDdlM2I0NWJlZmRiYmYxYTFmOWZmNzI4ZmEyYmFjMzFiNDc1NjkwN2M", "commit": {"author": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-08-12T08:27:16Z"}, "committer": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-08-12T08:46:12Z"}, "message": "analyzer: out-of-bounds checker [PR106000]\n\nThis patch adds an experimental out-of-bounds checker to the analyzer.\n\nThe checker was tested on coreutils, curl, httpd and openssh. It is mostly\naccurate but does produce false-positives on yacc-generated files and\nsometimes when the analyzer misses an invariant. These cases will be\ndocumented in bugzilla.\nRegression-tested on Linux x86-64, further ran the analyzer tests with\nthe -m32 option.\n\n2022-08-11  Tim Lange  <mail@tim-lange.me>\n\ngcc/analyzer/ChangeLog:\n\n\tPR analyzer/106000\n\t* analyzer.opt: Add Wanalyzer-out-of-bounds.\n\t* region-model.cc (class out_of_bounds): Diagnostics base class\n\tfor all out-of-bounds diagnostics.\n\t(class past_the_end): Base class derived from out_of_bounds for\n\tthe buffer_overflow and buffer_overread diagnostics.\n\t(class buffer_overflow): Buffer overflow diagnostics.\n\t(class buffer_overread): Buffer overread diagnostics.\n\t(class buffer_underflow): Buffer underflow diagnostics.\n\t(class buffer_underread): Buffer overread diagnostics.\n\t(region_model::check_region_bounds): New function to check region\n\tbounds for out-of-bounds accesses.\n\t(region_model::check_region_access):\n\tAdd call to check_region_bounds.\n\t(region_model::get_representative_tree): New function that accepts\n\ta region instead of an svalue.\n\t* region-model.h (class region_model):\n\tAdd region_model::check_region_bounds.\n\t* region.cc (region::symbolic_p): New predicate.\n\t(offset_region::get_byte_size_sval): Only return the remaining\n\tbyte size on offset_regions.\n\t* region.h: Add region::symbolic_p.\n\t* store.cc (byte_range::intersects_p):\n\tAdd new function equivalent to bit_range::intersects_p.\n\t(byte_range::exceeds_p): New function.\n\t(byte_range::falls_short_of_p): New function.\n\t* store.h (struct byte_range): Add byte_range::intersects_p,\n\tbyte_range::exceeds_p and byte_range::falls_short_of_p.\n\ngcc/ChangeLog:\n\n\tPR analyzer/106000\n\t* doc/invoke.texi: Add Wanalyzer-out-of-bounds.\n\ngcc/testsuite/ChangeLog:\n\n\tPR analyzer/106000\n\t* g++.dg/analyzer/pr100244.C: Disable out-of-bounds warning.\n\t* gcc.dg/analyzer/allocation-size-3.c:\n\tDisable out-of-bounds warning.\n\t* gcc.dg/analyzer/memcpy-2.c: Disable out-of-bounds warning.\n\t* gcc.dg/analyzer/pr101962.c: Add dg-warning.\n\t* gcc.dg/analyzer/pr96764.c: Disable out-of-bounds warning.\n\t* gcc.dg/analyzer/pr97029.c:\n\tAdd dummy buffer to prevent an out-of-bounds warning.\n\t* gcc.dg/analyzer/realloc-5.c: Add dg-warning.\n\t* gcc.dg/analyzer/test-setjmp.h:\n\tAdd dummy buffer to prevent an out-of-bounds warning.\n\t* gcc.dg/analyzer/zlib-3.c: Add dg-bogus.\n\t* g++.dg/analyzer/out-of-bounds-placement-new.C: New test.\n\t* gcc.dg/analyzer/out-of-bounds-1.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-2.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-3.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-container_of.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-coreutils.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-curl.c: New test.", "tree": {"sha": "6312f12e99ee27d3827ce85d61bc2036dca97c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6312f12e99ee27d3827ce85d61bc2036dca97c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/comments", "author": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b75b3b6a4ddc0d65a84a0cc4b00c47ae70e52c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b75b3b6a4ddc0d65a84a0cc4b00c47ae70e52c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b75b3b6a4ddc0d65a84a0cc4b00c47ae70e52c0"}], "stats": {"total": 1020, "additions": 1013, "deletions": 7}, "files": [{"sha": "61b58c575ff3add9cf5224bd92a3730cff8f4dc9", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -110,6 +110,10 @@ Wanalyzer-mismatching-deallocation\n Common Var(warn_analyzer_mismatching_deallocation) Init(1) Warning\n Warn about code paths in which the wrong deallocation function is called.\n \n+Wanalyzer-out-of-bounds\n+Common Var(warn_analyzer_out_of_bounds) Init(1) Warning\n+Warn about code paths in which a write or read to a buffer is out-of-bounds.\n+\n Wanalyzer-possible-null-argument\n Common Var(warn_analyzer_possible_null_argument) Init(1) Warning\n Warn about code paths in which a possibly-NULL value is passed to a must-not-be-NULL function argument."}, {"sha": "7e7077696f7a079db8cf1d144359edf8fb11285f", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1268,6 +1268,414 @@ region_model::on_stmt_pre (const gimple *stmt,\n     }\n }\n \n+/* Abstract base class for all out-of-bounds warnings.  */\n+\n+class out_of_bounds : public pending_diagnostic_subclass<out_of_bounds>\n+{\n+public:\n+  out_of_bounds (const region *reg, tree diag_arg,\n+\t\t byte_range out_of_bounds_range)\n+  : m_reg (reg), m_diag_arg (diag_arg),\n+    m_out_of_bounds_range (out_of_bounds_range)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"out_of_bounds_diagnostic\";\n+  }\n+\n+  bool operator== (const out_of_bounds &other) const\n+  {\n+    return m_reg == other.m_reg\n+\t   && m_out_of_bounds_range == other.m_out_of_bounds_range\n+\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_out_of_bounds;\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    interest->add_region_creation (m_reg);\n+  }\n+\n+protected:\n+  const region *m_reg;\n+  tree m_diag_arg;\n+  byte_range m_out_of_bounds_range;\n+};\n+\n+/* Abstract subclass to complaing about out-of-bounds\n+   past the end of the buffer.  */\n+\n+class past_the_end : public out_of_bounds\n+{\n+public:\n+  past_the_end (const region *reg, tree diag_arg, byte_range range,\n+\t\ttree byte_bound)\n+  : out_of_bounds (reg, diag_arg, range), m_byte_bound (byte_bound)\n+  {}\n+\n+  bool operator== (const past_the_end &other) const\n+  {\n+    return out_of_bounds::operator== (other)\n+\t   && pending_diagnostic::same_tree_p (m_byte_bound,\n+\t\t\t\t\t       other.m_byte_bound);\n+  }\n+\n+  label_text\n+  describe_region_creation_event (const evdesc::region_creation &ev) final\n+  override\n+  {\n+    if (m_byte_bound && TREE_CODE (m_byte_bound) == INTEGER_CST)\n+      return ev.formatted_print (\"capacity is %E bytes\", m_byte_bound);\n+\n+    return label_text ();\n+  }\n+\n+protected:\n+  tree m_byte_bound;\n+};\n+\n+/* Concrete subclass to complain about buffer overflows.  */\n+\n+class buffer_overflow : public past_the_end\n+{\n+public:\n+  buffer_overflow (const region *reg, tree diag_arg,\n+\t\t   byte_range range, tree byte_bound)\n+  : past_the_end (reg, diag_arg, range, byte_bound)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    bool warned;\n+    switch (m_reg->get_memory_space ())\n+      {\n+      default:\n+\tm.add_cwe (787);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"buffer overflow\");\n+\tbreak;\n+      case MEMSPACE_STACK:\n+\tm.add_cwe (121);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"stack-based buffer overflow\");\n+\tbreak;\n+      case MEMSPACE_HEAP:\n+\tm.add_cwe (122);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"heap-based buffer overflow\");\n+\tbreak;\n+      }\n+\n+    if (warned)\n+      {\n+\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n+\t\t   num_bytes_past_buf, UNSIGNED);\n+\tif (m_diag_arg)\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n+\t\t\t\t\t\t   m_diag_arg);\n+\telse\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\"of the region\",\n+\t\t\t\t\tnum_bytes_past_buf);\n+      }\n+\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n+\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n+\t\t\t\t\t\t\t m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n+\t\t\t\t   \" ends at byte %E\", start_buf,\n+\t\t\t\t\t\t       m_byte_bound);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg,\n+\t\t\t\t     m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t   \" byte %s but region ends at byte %E\",\n+\t\t\t\t   start_buf, end_buf, m_byte_bound);\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer overreads.  */\n+\n+class buffer_overread : public past_the_end\n+{\n+public:\n+  buffer_overread (const region *reg, tree diag_arg,\n+\t\t   byte_range range, tree byte_bound)\n+  : past_the_end (reg, diag_arg, range, byte_bound)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (126);\n+    bool warned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t\t\"buffer overread\");\n+\n+    if (warned)\n+      {\n+\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n+\t\t   num_bytes_past_buf, UNSIGNED);\n+\tif (m_diag_arg)\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n+\t\t\t\t\t\t    m_diag_arg);\n+\telse\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\"of the region\",\n+\t\t\t\t\tnum_bytes_past_buf);\n+      }\n+\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n+\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n+\t\t\t\t\t\t\t m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n+\t\t\t\t   \" ends at byte %E\", start_buf,\n+\t\t\t\t\t\t       m_byte_bound);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg,\n+\t\t\t\t     m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t   \" byte %s but region ends at byte %E\",\n+\t\t\t\t   start_buf, end_buf, m_byte_bound);\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer underflows.  */\n+\n+class buffer_underflow : public out_of_bounds\n+{\n+public:\n+  buffer_underflow (const region *reg, tree diag_arg, byte_range range)\n+  : out_of_bounds (reg, diag_arg, range)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (124);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer underflow\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n+\t\t\t\t     \" starts at byte 0\", start_buf,\n+\t\t\t\t\t\t\t  m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n+\t\t\t\t   \" starts at byte 0\", start_buf);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t   \" byte %s but region starts at byte 0\",\n+\t\t\t\t   start_buf, end_buf);;\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer underreads.  */\n+\n+class buffer_underread : public out_of_bounds\n+{\n+public:\n+  buffer_underread (const region *reg, tree diag_arg, byte_range range)\n+  : out_of_bounds (reg, diag_arg, range)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (127);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer underread\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n+\t\t\t\t     \" starts at byte 0\", start_buf,\n+\t\t\t\t\t\t\t  m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n+\t\t\t\t  \" starts at byte 0\", start_buf);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t   \" byte %s but region starts at byte 0\",\n+\t\t\t\t   start_buf, end_buf);;\n+      }\n+  }\n+};\n+\n+/* May complain when the access on REG is out-of-bounds.  */\n+\n+void region_model::check_region_bounds (const region *reg,\n+\t\t\t\t\tenum access_direction dir,\n+\t\t\t\t\tregion_model_context *ctxt) const\n+{\n+  gcc_assert (ctxt);\n+\n+  region_offset reg_offset = reg->get_offset ();\n+  const region *base_reg = reg_offset.get_base_region ();\n+\n+  /* Bail out on symbolic offsets or symbolic regions.\n+     (e.g. because the analyzer did not see previous offsets on the latter,\n+     it might think that a negative access is before the buffer).  */\n+  if (reg_offset.symbolic_p () || base_reg->symbolic_p ())\n+    return;\n+  byte_offset_t offset_unsigned\n+    = reg_offset.get_bit_offset () >> LOG2_BITS_PER_UNIT;\n+  /* The constant offset from a pointer is represented internally as a sizetype\n+     but should be interpreted as a signed value here.  The statement below\n+     converts the offset to a signed integer with the same precision the\n+     sizetype has on the target system.\n+\n+     For example, this is needed for out-of-bounds-3.c test1 to pass when\n+     compiled with a 64-bit gcc build targeting 32-bit systems.  */\n+  byte_offset_t offset\n+    = offset_unsigned.to_shwi (TYPE_PRECISION (size_type_node));\n+\n+  /* Find out how many bytes were accessed.  */\n+  const svalue *num_bytes_sval = reg->get_byte_size_sval (m_mgr);\n+  tree num_bytes_tree = num_bytes_sval->maybe_get_constant ();\n+  if (!num_bytes_tree || TREE_CODE (num_bytes_tree) != INTEGER_CST)\n+    /* If we do not know how many bytes were read/written,\n+       assume that at least one byte was read/written.  */\n+    num_bytes_tree = integer_one_node;\n+\n+  byte_range out (0, 0);\n+  /* NUM_BYTES_TREE should always be interpreted as unsigned.  */\n+  byte_range read_bytes (offset, wi::to_offset (num_bytes_tree).to_uhwi ());\n+  /* If read_bytes has a subset < 0, we do have an underflow.  */\n+  if (read_bytes.falls_short_of_p (0, &out))\n+    {\n+      tree diag_arg = get_representative_tree (reg->get_base_region ());\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (new buffer_underread (reg, diag_arg, out));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (new buffer_underflow (reg, diag_arg, out));\n+\t  break;\n+\t}\n+    }\n+\n+  const svalue *capacity = get_capacity (base_reg);\n+  tree cst_capacity_tree = capacity->maybe_get_constant ();\n+  if (!cst_capacity_tree || TREE_CODE (cst_capacity_tree) != INTEGER_CST)\n+    return;\n+\n+  byte_range buffer (0, wi::to_offset (cst_capacity_tree));\n+  /* If READ_BYTES exceeds BUFFER, we do have an overflow.  */\n+  if (read_bytes.exceeds_p (buffer, &out))\n+    {\n+      tree byte_bound = wide_int_to_tree (size_type_node,\n+\t\t\t\t\t  buffer.get_next_byte_offset ());\n+      tree diag_arg = get_representative_tree (reg->get_base_region ());\n+\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (new buffer_overread (reg, diag_arg, out, byte_bound));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (new buffer_overflow (reg, diag_arg, out, byte_bound));\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Ensure that all arguments at the call described by CD are checked\n    for poisoned values, by calling get_rvalue on each argument.  */\n \n@@ -2825,6 +3233,7 @@ region_model::check_region_access (const region *reg,\n     return;\n \n   check_region_for_taint (reg, dir, ctxt);\n+  check_region_bounds (reg, dir, ctxt);\n \n   switch (dir)\n     {\n@@ -3820,6 +4229,19 @@ region_model::get_representative_tree (const svalue *sval) const\n   return fixup_tree_for_diagnostic (expr);\n }\n \n+tree\n+region_model::get_representative_tree (const region *reg) const\n+{\n+  svalue_set visited;\n+  tree expr = get_representative_path_var (reg, &visited).m_tree;\n+\n+  /* Strip off any top-level cast.  */\n+  if (expr && TREE_CODE (expr) == NOP_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  return fixup_tree_for_diagnostic (expr);\n+}\n+\n /* Implementation of region_model::get_representative_path_var.\n \n    Attempt to return a path_var that represents REG, or return"}, {"sha": "cdf10872c0f6e8cc8217000ce226e77606e02892", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -733,6 +733,7 @@ class region_model\n \t\t\t\t\t  region_model_context *ctxt);\n \n   tree get_representative_tree (const svalue *sval) const;\n+  tree get_representative_tree (const region *reg) const;\n   path_var\n   get_representative_path_var (const svalue *sval,\n \t\t\t       svalue_set *visited) const;\n@@ -868,6 +869,8 @@ class region_model\n \t\t\t      region_model_context *ctxt) const;\n   void check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n \t\t\t  region_model_context *ctxt) const;\n+  void check_region_bounds (const region *reg, enum access_direction dir,\n+\t\t\t    region_model_context *ctxt) const;\n \n   void check_call_args (const call_details &cd) const;\n   void check_external_function_for_access_attr (const gcall *call,"}, {"sha": "f4aba6b9c8803907525bbf29a80470eccfe55c33", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -629,6 +629,14 @@ region::symbolic_for_unknown_ptr_p () const\n   return false;\n }\n \n+/* Return true if this is a symbolic region.  */\n+\n+bool\n+region::symbolic_p () const\n+{\n+  return get_kind () == RK_SYMBOLIC;\n+}\n+\n /* Return true if this is a region for a decl with name DECL_NAME.\n    Intended for use when debugging (for assertions and conditional\n    breakpoints).  */\n@@ -1430,6 +1438,30 @@ offset_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return false;\n }\n \n+/* Implementation of region::get_byte_size_sval vfunc for offset_region.  */\n+\n+const svalue *\n+offset_region::get_byte_size_sval (region_model_manager *mgr) const\n+{\n+  tree offset_cst = get_byte_offset ()->maybe_get_constant ();\n+  byte_size_t byte_size;\n+  /* If the offset points in the middle of the region,\n+     return the remaining bytes.  */\n+  if (get_byte_size (&byte_size) && offset_cst)\n+    {\n+      byte_size_t offset = wi::to_offset (offset_cst);\n+      byte_range r (0, byte_size);\n+      if (r.contains_p (offset))\n+\t{\n+\t  tree remaining_byte_size = wide_int_to_tree (size_type_node,\n+\t\t\t\t\t\t       byte_size - offset);\n+\t  return mgr->get_or_create_constant_svalue (remaining_byte_size);\n+\t}\n+    }\n+\n+  return region::get_byte_size_sval (mgr);\n+}\n+\n /* class sized_region : public region.  */\n \n /* Implementation of region::accept vfunc for sized_region.  */"}, {"sha": "20dffc7f57777fcbfca95b845b32fa2eb3f7b2fa", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -211,6 +211,8 @@ class region\n \n   bool symbolic_for_unknown_ptr_p () const;\n \n+  bool symbolic_p () const;\n+\n   /* For most base regions it makes sense to track the bindings of the region\n      within the store.  As an optimization, some are not tracked (to avoid\n      bloating the store object with redundant binding clusters).  */\n@@ -917,6 +919,8 @@ class offset_region : public region\n   const svalue *get_byte_offset () const { return m_byte_offset; }\n \n   bool get_relative_concrete_offset (bit_offset_t *out) const final override;\n+  const svalue * get_byte_size_sval (region_model_manager *mgr) const;\n+\n \n private:\n   const svalue *m_byte_offset;"}, {"sha": "848c5e1aaff0f70c6a033704e5d205989751a6b2", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -424,6 +424,73 @@ byte_range::contains_p (const byte_range &other, byte_range *out) const\n     return false;\n }\n \n+/* Return true if THIS and OTHER intersect and write the number\n+   of bytes both buffers overlap to *OUT_NUM_OVERLAP_BYTES.\n+\n+   Otherwise return false.  */\n+\n+bool\n+byte_range::intersects_p (const byte_range &other,\n+\t\t\t  byte_size_t *out_num_overlap_bytes) const\n+{\n+  if (get_start_byte_offset () < other.get_next_byte_offset ()\n+      && other.get_start_byte_offset () < get_next_byte_offset ())\n+    {\n+      byte_offset_t overlap_start = MAX (get_start_byte_offset (),\n+\t\t\t\t\t other.get_start_byte_offset ());\n+      byte_offset_t overlap_next = MIN (get_next_byte_offset (),\n+\t\t\t\t\tother.get_next_byte_offset ());\n+      gcc_assert (overlap_next > overlap_start);\n+      *out_num_overlap_bytes = overlap_next - overlap_start;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Return true if THIS exceeds OTHER and write the overhanging\n+   byte range to OUT_OVERHANGING_BYTE_RANGE.  */\n+\n+bool\n+byte_range::exceeds_p (const byte_range &other,\n+\t\t       byte_range *out_overhanging_byte_range) const\n+{\n+  if (other.get_last_byte_offset () < get_last_byte_offset ())\n+    {\n+      /* THIS definitely exceeds OTHER.  */\n+      byte_offset_t start = MAX (get_start_byte_offset (),\n+\t\t\t\t other.get_next_byte_offset ());\n+      byte_offset_t size = get_next_byte_offset () - start;\n+      gcc_assert (size > 0);\n+      out_overhanging_byte_range->m_start_byte_offset = start;\n+      out_overhanging_byte_range->m_size_in_bytes = size;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Return true if THIS falls short of OFFSET and write the\n+   byte range fallen short to OUT_FALL_SHORT_BYTES.  */\n+\n+bool\n+byte_range::falls_short_of_p (byte_offset_t offset,\n+\t\t\t      byte_range *out_fall_short_bytes) const\n+{\n+  if (get_start_byte_offset () < offset)\n+    {\n+      /* THIS falls short of OFFSET.  */\n+      byte_offset_t start = get_start_byte_offset ();\n+      byte_offset_t size = MIN (offset, get_next_byte_offset ()) - start;\n+      gcc_assert (size > 0);\n+      out_fall_short_bytes->m_start_byte_offset = start;\n+      out_fall_short_bytes->m_size_in_bytes = size;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n /* qsort comparator for byte ranges.  */\n \n int"}, {"sha": "ac8b6853f4ba99a3447d589ce9f592c3b989ecb2", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -310,6 +310,15 @@ struct byte_range\n \t    && m_size_in_bytes == other.m_size_in_bytes);\n   }\n \n+  bool intersects_p (const byte_range &other,\n+\t\t     byte_size_t *out_num_overlap_bytes) const;\n+\n+  bool exceeds_p (const byte_range &other,\n+\t\t  byte_range *out_overhanging_byte_range) const;\n+\n+  bool falls_short_of_p (byte_offset_t offset,\n+\t\t\t byte_range *out_fall_short_bytes) const;\n+\n   byte_offset_t get_start_byte_offset () const\n   {\n     return m_start_byte_offset;"}, {"sha": "3b529c420c94f70519abfd79acd90d216203c8a7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -458,6 +458,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-mismatching-deallocation @gol\n -Wno-analyzer-null-argument @gol\n -Wno-analyzer-null-dereference @gol\n+-Wno-analyzer-out-of-bounds @gol\n -Wno-analyzer-possible-null-argument @gol\n -Wno-analyzer-possible-null-dereference @gol\n -Wno-analyzer-putenv-of-auto-var @gol\n@@ -9762,6 +9763,7 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-mismatching-deallocation @gol\n -Wanalyzer-null-argument @gol\n -Wanalyzer-null-dereference @gol\n+-Wanalyzer-out-of-bounds @gol\n -Wanalyzer-possible-null-argument @gol\n -Wanalyzer-possible-null-dereference @gol\n -Wanalyzer-putenv-of-auto-var @gol\n@@ -9983,6 +9985,19 @@ pairs using attribute @code{malloc}.\n \n See @uref{https://cwe.mitre.org/data/definitions/762.html, CWE-762: Mismatched Memory Management Routines}.\n \n+@item -Wno-analyzer-out-of-bounds\n+@opindex Wanalyzer-out-of-bounds\n+@opindex Wno-analyzer-out-of-bounds\n+This warning requires @option{-fanalyzer} to enable it; use\n+@option{-Wno-analyzer-out-of-bounds} to disable it.\n+\n+This diagnostic warns for path through the code in which a buffer is\n+definitely read or written out-of-bounds.  The diagnostic only applies\n+for cases where the analyzer is able to determine a constant offset and\n+for accesses past the end of a buffer, also a constant capacity.\n+\n+See @uref{https://cwe.mitre.org/data/definitions/119.html, CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer}.\n+\n @item -Wno-analyzer-possible-null-argument\n @opindex Wanalyzer-possible-null-argument\n @opindex Wno-analyzer-possible-null-argument"}, {"sha": "d3076c3cf25b6439784acfe9e8198b370149ae71", "filename": "gcc/testsuite/g++.dg/analyzer/out-of-bounds-placement-new.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fout-of-bounds-placement-new.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fout-of-bounds-placement-new.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fout-of-bounds-placement-new.C?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,19 @@\n+/* Reduced from pr100244.C.  */\n+inline void *operator new (__SIZE_TYPE__, void *__p) { return __p; }\n+\n+struct int_container {\n+  int i;\n+  int *addr () { return &i; }\n+};\n+\n+struct int_and_addr {\n+  int i;\n+  int *addr;\n+  int_and_addr () { addr = &i; } /* { dg-warning \"overflow\" } */\n+};\n+\n+int test (int_container ic)\n+{\n+  int_and_addr *iaddr = new (ic.addr ()) int_and_addr;\n+  return iaddr->i;\n+}"}, {"sha": "6e2ac4c65bd0bcd12320d398d96a77a7241310c8", "filename": "gcc/testsuite/g++.dg/analyzer/pr100244.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1,4 +1,7 @@\n-// { dg-additional-options \"-O1 -Wno-free-nonheap-object\" }\n+// { dg-additional-options \"-O1 -Wno-free-nonheap-object -Wno-analyzer-out-of-bounds\" }\n+/* Disabled out-of-bounds checker because the output relied\n+   on optimizations.  out-of-bounds-placement-new.C tests\n+   the same pattern but without optimizations.  */\n \n inline void *operator new (__SIZE_TYPE__, void *__p) { return __p; }\n "}, {"sha": "9590e3137e0a9d619302f450347e56580a300bb7", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options -Wno-analyzer-out-of-bounds } */\n+\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>"}, {"sha": "51e4a69495171c88f09eefe14bf62a6fd5f72b38", "filename": "gcc/testsuite/gcc.dg/analyzer/memcpy-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-2.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-additional-options \"-Wno-stringop-overflow\" } */\n+/* { dg-additional-options \"-Wno-stringop-overflow -Wno-analyzer-out-of-bounds\" } */\n \n void\n main (int c, void *v)"}, {"sha": "9f3cda6e02b9dc3a0af17b7ae315aa2394347fef", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-1.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-1.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,120 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+/* Wanalyzer-out-of-bounds tests for buffer overflows.  */\n+\n+/* Avoid folding of memcpy.  */\n+typedef void * (*memcpy_t) (void *dst, const void *src, size_t n);\n+\n+static memcpy_t __attribute__((noinline))\n+get_memcpy (void)\n+{\n+  return memcpy;\n+}\n+\n+\n+/* Taken from CWE-787.  */\n+void test1 (void)\n+{\n+  int id_sequence[3];\n+\n+  id_sequence[0] = 123;\n+  id_sequence[1] = 234;\n+  id_sequence[2] = 345;\n+  id_sequence[3] = 456; /* { dg-line test1 } */\n+\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test1 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test1 } */\n+}\n+\n+void test2 (void)\n+{\n+  int n = 4;\n+  int arr[4];\n+\n+  for (int i = n - 1; i >= 0; i--)\n+    arr[i] = i;\n+}\n+\n+void test3 (void)\n+{\n+  int n = 4;\n+  int arr[4];\n+\n+  for (int i = n; i >= 0; i--)\n+    arr[i] = i; /* { dg-line test3 } */\n+\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test3 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test3 } */\n+}\n+\n+void test4 (void)\n+{\n+  int *arr = malloc (4 * sizeof (int));\n+  if (!arr)\n+    return;\n+  \n+  int *last_el = arr + 3;\n+  *last_el = 3;\n+\n+  free (arr);\n+}\n+\n+void test5 (void)\n+{\n+  int *arr = malloc (4 * sizeof (int));\n+  if (!arr)\n+    return;\n+  \n+  int *last_el = arr + 4;\n+  *last_el = 4; /* { dg-line test5 } */\n+\n+  free (arr);\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test5 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test5 } */\n+}\n+\n+/* Taken from \"A Provenance-aware Memory Object Model for C\".  */\n+int y = 2, x = 1; /* { dg-message \"capacity\" } */\n+void test6 (void)\n+{\n+  int *p = &x + 1;\n+  int *q = &y;\n+  printf (\"Addresses: p=% p q=% p \\n\" , (void *) p, (void *) q);\n+  if (memcmp (&p , &q , sizeof (p)) == 0)\n+  {\n+    *p = 11; /* { dg-line test6b } */\n+    printf (\"x=%d y=%d *p=%d *q=%d\\n\" , x, y, *p, *q);  /* { dg-line test6c } */\n+  }\n+\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test6b } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test6b } */\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test6c } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test6c } */\n+}\n+\n+extern int is_valid (void);\n+\n+int returnChunkSize (void *ptr)\n+{\n+  /* If chunk info is valid, return the size of usable memory,\n+     else, return -1 to indicate an error.  */\n+  return is_valid () ? sizeof (*ptr) : -1;\n+}\n+\n+/* Taken from CWE-787.  */\n+void test7 (void)\n+{\n+  memcpy_t fn = get_memcpy ();\n+\n+  int destBuf[4];\n+  int srcBuf[4];\n+  fn (destBuf, srcBuf, returnChunkSize (destBuf)); /* { dg-line test7 } */\n+\n+  // TODO: Should we handle widening_svalues as a follow-up?\n+  /* { dg-warning \"overread\" \"warning\" { xfail *-*-* } test7 } */\n+  /* { dg-warning \"overflow\" \"warning\" { xfail *-*-* } test7 } */\n+  /* { dg-message \"\" \"note\" { xfail *-*-* } test7 } */\n+}"}, {"sha": "0df9364c5c1b7edfb872328306b930730b67799c", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-2.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-2.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,83 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdint.h>\n+\n+/* Wanalyzer-out-of-bounds tests for buffer overreads.  */\n+\n+/* Avoid folding of memcpy.  */\n+typedef void * (*memcpy_t) (void *dst, const void *src, size_t n);\n+\n+static memcpy_t __attribute__((noinline))\n+get_memcpy (void)\n+{\n+  return memcpy;\n+}\n+\n+\n+void test1 (void)\n+{\n+  int id_sequence[3];\n+  memset (id_sequence, 0, 3 * sizeof(int));\n+  printf (\"%i\", id_sequence[3]); /* { dg-line test1 } */\n+\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test1 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test1 } */\n+}\n+\n+void test2 (void)\n+{\n+  int n = 4;\n+  int arr[n];\n+  memset (arr, 0, n * sizeof (int));\n+\n+  int sum = 0;\n+  for (int i = n - 1; i >= 0; i--)\n+    sum += arr[i];\n+}\n+\n+void test3 (void)\n+{\n+  int n = 4;\n+  int arr[4];\n+  memset (arr, 0, n * sizeof (int));\n+\n+  int sum = 0;\n+  for (int i = n; i > 0; i--)\n+    sum += arr[i]; /* { dg-line test3 } */\n+\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test3 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test3 } */\n+}\n+\n+void test4 (void)\n+{\n+  int n = 4;\n+  int *arr = malloc (n * sizeof (int));\n+  if (!arr)\n+    return;\n+  memset (arr, 0, n * sizeof(int));\n+  \n+  int sum = 0;\n+  for (int i = n - 1; i >= 0; i--)\n+    sum += *(arr + i);\n+\n+  free (arr);\n+}\n+\n+void test5 (void)\n+{\n+  int n = 4;\n+  int *arr = malloc (n * sizeof (int));\n+  if (!arr)\n+    return;\n+  memset (arr, 0, n * sizeof(int));\n+  \n+  int sum = 0;\n+  for (int i = n; i > 0; i--)\n+    sum += *(arr + i); /* { dg-line test5 } */\n+\n+  free (arr);\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test5 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test5 } */\n+}"}, {"sha": "7446b182e481395694bc837e7a024a828b8adad0", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-3.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-3.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,91 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdint.h>\n+\n+/* Wanalyzer-out-of-bounds tests for buffer underreads and writes.  */\n+\n+/* Avoid folding of memcpy.  */\n+typedef void * (*memcpy_t) (void *dst, const void *src, size_t n);\n+static memcpy_t __attribute__((noinline))\n+get_memcpy (void)\n+{\n+  return memcpy;\n+}\n+\n+\n+void test1 (void)\n+{\n+  int buf[4];\n+  int *e = buf - 1;\n+  *e = 42; /* { dg-line test1 } */\n+\n+  /* { dg-warning \"underflow\" \"warning\" { target *-*-* } test1 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test1 } */\n+}\n+\n+void test2 (void)\n+{\n+  int buf[4];\n+  int *e = buf + 1;\n+  *e = 123;\n+  *(e - 1) = 321;\n+}\n+\n+void test3 (void)\n+{\n+  int buf[4];\n+  int *e = buf + 1;\n+  *e = 123;\n+  *(e - 2) = 321; /* { dg-line test3 } */\n+\n+  /* { dg-warning \"underflow\" \"warning\" { target *-*-* } test3 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test3 } */\n+}\n+\n+void test4 (void)\n+{\n+  memcpy_t fn = get_memcpy ();\n+  int buf[4];\n+  memset (buf, 1, 4 * sizeof (int));\n+  int n = -4;\n+  fn (&(buf[n]), buf, sizeof (int));  /* { dg-line test4 } */\n+\n+  /* { dg-warning \"underflow\" \"warning\" { target *-*-* } test4 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test4 } */\n+}\n+\n+void test5 (void)\n+{\n+  int buf[4];\n+  memset (buf, 1, 4 * sizeof (int));\n+\n+  int sum = 0;\n+  for (int i = 4; i >= 0; i++)\n+    sum += *(buf - i); /* { dg-line test5 } */\n+\n+  /* { dg-warning \"underread\" \"warning\" { target *-*-* } test5 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test5 } */\n+}\n+\n+void test6 (void)\n+{\n+  int buf[4];\n+  memset (buf, 1, 4 * sizeof (int));\n+\n+  int *view = buf + 1;\n+  int sum = 0;\n+  for (int i = 0; i < 4; i++)\n+    sum += *(view++);\n+}\n+\n+void test8 (void)\n+{\n+  memcpy_t fn = get_memcpy ();\n+  int buf[4];\n+  memset (buf, 1, 4 * sizeof (int));\n+  int n = -4;\n+  fn (buf, &(buf[n]), sizeof (int));  /* { dg-line test8 } */\n+\n+  /* { dg-warning \"underread\" \"warning\" { target *-*-* } test8 } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } test8 } */\n+}"}, {"sha": "172ec474c4287e55e2c401040cb1d1f09237161b", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-container_of.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-container_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-container_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-container_of.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,51 @@\n+/* Further reduced container_of pattern from the Linux Kernel.  */\n+\n+struct inner {\n+  /* Don't care */\n+};\n+\n+struct outer {\n+  int i;\n+  struct inner inner_struct;\n+};\n+\n+struct outer *container_of (struct inner *ptr_to_inner)\n+{\n+  struct outer *ptr_to_outer = ((struct outer *) (((void *) ptr_to_inner) - __builtin_offsetof(struct outer, inner_struct)));\n+  return ptr_to_outer;\n+}\n+\n+int test (struct outer *outer_p, struct inner *inner_p)\n+{\n+  struct outer test;\n+  test.i = 42;\n+  struct inner test2;\n+  int sum = 0;\n+  struct outer *o;\n+\n+  /* Symbolic inner struct.  */\n+  o = container_of (inner_p);\n+  sum += o->i; // ok\n+  /* Not ok, but we can't be sure that outer\n+     is actually the container of inner.  */\n+  sum += (o - 1)->i;\n+  /* Symbolic outer struct.  */\n+  o = container_of (&(outer_p->inner_struct));\n+  sum += o->i; // ok\n+  /* Not ok, but indistinguishable from the case above.  */\n+  sum += (o - 1)->i;\n+  /* Concrete outer struct.  */\n+  o = container_of (&(test.inner_struct));\n+  sum += o->i;  // ok\n+  /* Not ok and we do have a concrete region.  */\n+  sum += (o - 1)->i; /* { dg-line testA } */\n+  /* Concrete inner struct, has no container.  */\n+  o = container_of (&test2);\n+  sum += o->i; /* { dg-line testB } */\n+\n+  return sum;\n+  /* { dg-warning \"underread\" \"warning\" { target *-*-* } testA } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } testA } */\n+  /* { dg-warning \"underread\" \"warning\" { target *-*-* } testB } */\n+  /* { dg-message \"\" \"note\" { target *-*-* } testB } */\n+}"}, {"sha": "cd0f4b7f7b26f8e3c6a435034741bca5a5fb8c3e", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-coreutils.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-coreutils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-coreutils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-coreutils.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,29 @@\n+/* Reduced from coreutils/ls.c attach.  */\n+\n+void add_zero_terminator (char *buf)\n+{\n+  char *end = buf;\n+  while (end++);\n+  if (buf < end)\n+    end[-1] = '\\0';\n+}\n+\n+/* Reduced from coreutils/cat.c.  */\n+\n+#define LINE_COUNTER_BUF_LEN 20\n+static char line_buf[LINE_COUNTER_BUF_LEN] =\n+  {\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0',\n+    '\\t', '\\0'\n+  };\n+\n+/* Position of the first digit in 'line_buf'.  */\n+static char *line_num_start = line_buf + LINE_COUNTER_BUF_LEN - 3;\n+\n+static void\n+next_line_num (void)\n+{\n+  if (line_num_start > line_buf)\n+    *--line_num_start = '1';\n+}"}, {"sha": "e34b572966e23e8cf2af5339d42569efbd605c72", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-curl.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-curl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-curl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-curl.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-additional-options \"-O2\" } */\n+#include <string.h>\n+\n+/* Reduced from curl lib/smb.c.  */\n+typedef int CURLcode;\n+\n+struct smb_conn {\n+  // [...]\n+  char *user;\n+};\n+\n+struct smb_setup {\n+  // [...]\n+  char bytes[48];\n+} __attribute__((packed));\n+\n+struct connectdata {\n+  // [...]\n+  struct smb_conn *smbc;\n+};\n+\n+CURLcode smb_send_setup (struct connectdata *conn)\n+{\n+  struct smb_conn *smbc = conn->smbc;\n+  struct smb_setup msg;\n+  char *p = msg.bytes;\n+  unsigned char lm[24];\n+\n+  /* Init to prevent uninit warning.  */\n+  memset(&msg, 0, sizeof(msg));\n+  memset (&lm, 0, sizeof(lm));\n+\n+  memcpy(p, lm, sizeof(lm));\n+  p += sizeof(lm);\n+  /* Had a false-positive overflow at p. Checker had a number of bytes copied\n+     relative to the start but offset points in the middle the field.  */\n+  strcpy(p, (smbc->user));\n+  p += strlen(smbc->user) + 1;\n+\n+  return 1;\n+}"}, {"sha": "cf0041b2fcd898cddfcaa3c56d6efb51930109b9", "filename": "gcc/testsuite/gcc.dg/analyzer/pr101962.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101962.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101962.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101962.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -22,8 +22,10 @@ test_1 (void)\n   a = maybe_inc_int_ptr (a);\n   __analyzer_eval (a == NULL); /* { dg-warning \"FALSE\" } */\n   __analyzer_eval (a != NULL); /* { dg-warning \"TRUE\" } */\n-  return *a; /* { dg-warning \"use of uninitialized value '\\\\*a'\" } */\n-  /* TODO: a complaint about out-of-bounds would be a better warning.  */\n+  return *a; /* { dg-line test_1 } */\n+\n+  /* { dg-warning \"use of uninitialized value '\\\\*a'\" \"warning\" { target *-*-* } test_1 } */\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test_1 } */\n }\n \n static const char * __attribute__((noinline))"}, {"sha": "6024ebaaa2abbaf7b11f88b889630667f9b67b38", "filename": "gcc/testsuite/gcc.dg/analyzer/pr96764.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96764.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96764.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96764.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-Wno-analyzer-out-of-bounds\" } */\n+\n void\n ar (int *hd)\n {"}, {"sha": "e3b453117791173a7bff8ec23ce1219b172da4b5", "filename": "gcc/testsuite/gcc.dg/analyzer/pr97029.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -1,4 +1,6 @@\n-struct vj {};\n+struct vj {\n+  char buf[1];\n+};\n \n void\n setjmp (struct vj pl)"}, {"sha": "2efe3371e12bd91e73e44d676c8342cf0623f330", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-5.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-5.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -37,6 +37,7 @@ void test_1 ()\n       __analyzer_eval (q[8] == 1); /* { dg-line eval } */\n     \n       /* { dg-warning \"UNKNOWN\" \"warning\" { target *-*-* } eval } */\n+      /* { dg-warning \"overread\" \"warning\" { target *-*-* } eval } */\n       /* { dg-warning \"use of uninitialized value\" \"warning\" { target *-*-* } eval } */\n     }\n "}, {"sha": "52c57d02b709845e9ded3ce2dc870b31d54384c5", "filename": "gcc/testsuite/gcc.dg/analyzer/test-setjmp.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-setjmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-setjmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-setjmp.h?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -12,7 +12,9 @@\n \n #pragma GCC system_header\n \n-struct __jmp_buf_tag {};\n+struct __jmp_buf_tag {\n+  char buf[1];\n+};\n typedef struct __jmp_buf_tag jmp_buf[1];\n typedef struct __jmp_buf_tag sigjmp_buf[1];\n "}, {"sha": "b05b8629a7f9503b9d14497d45a9e4aa9e699d29", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-3.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3b45befdbbf1a1f9ff728fa2bac31b4756907c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c?ref=7e3b45befdbbf1a1f9ff728fa2bac31b4756907c", "patch": "@@ -182,7 +182,9 @@ static int huft_build(uInt *b, uInt n, uInt s, const uInt *d, const uInt *e,\n         q[j] = r; /* { dg-warning \"use of uninitialized value 'r.base'\" } */\n \n       mask = (1 << w) - 1;\n-      while ((i & mask) != x[h]) {\n+      /* The analyzer thinks that h can be -1 here.\n+         This is probably a false positive. */\n+      while ((i & mask) !=  x[h]) { /* { dg-bogus \"underread\" \"\" { xfail *-*-* } } */\n         h--;\n         w -= l;\n         mask = (1 << w) - 1;"}]}