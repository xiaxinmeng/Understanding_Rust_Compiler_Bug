{"sha": "e4ea09d6b8e501dc7bd7046da641b70e02814b09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRlYTA5ZDZiOGU1MDFkYzdiZDcwNDZkYTY0MWI3MGUwMjgxNGIwOQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-03-26T15:23:57Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-27T18:55:14Z"}, "message": "Add Generic Impl block support\n\nThis extends the support from #237 to extend this to MethodCallExpr, this\nnow follows a similar path to normal CallExprs and ensures the used\narguments in substitution are preserved during unification of types. Part\nof method resolution is fixed here by taking advantage if is_equal instead\nof unify calls which could result in bad errors which are just part of the\nprobe process to lookup possible candidates for method resolution.\n\nFixes #306", "tree": {"sha": "a01041da77d9276a52d0dbcb08d6a5c3913b03fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a01041da77d9276a52d0dbcb08d6a5c3913b03fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4ea09d6b8e501dc7bd7046da641b70e02814b09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ea09d6b8e501dc7bd7046da641b70e02814b09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ea09d6b8e501dc7bd7046da641b70e02814b09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ea09d6b8e501dc7bd7046da641b70e02814b09/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "380c8295051c6b42adb4f703268c7465aed57c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380c8295051c6b42adb4f703268c7465aed57c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/380c8295051c6b42adb4f703268c7465aed57c44"}], "stats": {"total": 431, "additions": 304, "deletions": 127}, "files": [{"sha": "c8542d984ae362f7979f5985a8699b53030d054f", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -198,6 +198,8 @@ struct GenericArgs\n   std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n \n   std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; };\n+\n+  Location get_locus () { return locus; }\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe\n@@ -206,13 +208,9 @@ class PathExprSegment\n { // or should this extend PathIdentSegment?\n private:\n   PathIdentSegment segment_name;\n-\n-  // bool has_generic_args;\n   GenericArgs generic_args;\n-\n   Location locus;\n-\n-  // TODO: does this require visitor? pretty sure not polymorphic\n+  NodeId node_id;\n \n public:\n   // Returns true if there are any generic arguments\n@@ -222,7 +220,8 @@ class PathExprSegment\n   PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n \t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n     : segment_name (std::move (segment_name)),\n-      generic_args (std::move (generic_args)), locus (locus)\n+      generic_args (std::move (generic_args)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   /* Constructor for segment with generic arguments (from segment name and all\n@@ -238,7 +237,7 @@ class PathExprSegment\n       generic_args (GenericArgs (std::move (lifetime_args),\n \t\t\t\t std::move (type_args),\n \t\t\t\t std::move (binding_args))),\n-      locus (locus)\n+      locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Returns whether path expression segment is in an error state.\n@@ -262,6 +261,8 @@ class PathExprSegment\n   }\n \n   PathIdentSegment &get_ident_segment () { return segment_name; }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class"}, {"sha": "cee3a3ba5518b02a4661a7930acf51e9d188e26a", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -272,6 +272,21 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// we cant do anything for this only when it is used\n+\tif (concrete == nullptr)\n+\t  return;\n+\telse\n+\t  {\n+\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+\t    // override the Hir Lookups for the substituions in this context\n+\t    fntype->override_context ();\n+\t  }\n+      }\n+\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n "}, {"sha": "a2f524725a663cdd13e8909aa019d3a13d50bbd8", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -122,9 +122,17 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       return;\n     }\n \n+  // lookup the expected function type\n+  TyTy::BaseType *lookup_fntype = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n+  rust_assert (ok);\n+  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n+\n   // lookup compiled functions\n   Bfunction *fn = nullptr;\n-  if (!ctx->lookup_function_decl (ref, &fn))\n+  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n       // this might fail because its a forward decl so we can attempt to\n       // resolve it now\n@@ -146,8 +154,13 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  return;\n \t}\n \n-      CompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n-      if (!ctx->lookup_function_decl (ref, &fn))\n+      if (!fntype->has_subsititions_defined ())\n+\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n+      else\n+\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true,\n+\t\t\t\t\t  fntype);\n+\n+      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n \t  return;"}, {"sha": "b127ec4957938e882dc47dd6683770aa66d0f57b", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -284,6 +284,13 @@ class ASTLoweringBase : public AST::ASTVisitor\n \n     return HIR::LoopLabel (mapping, std::move (life), loop_label.get_locus ());\n   }\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam> > lower_generic_params (\n+    std::vector<std::unique_ptr<AST::GenericParam> > &params);\n+\n+  HIR::PathExprSegment lower_path_expr_seg (AST::PathExprSegment &s);\n+\n+  HIR::GenericArgs lower_generic_args (AST::GenericArgs &args);\n };\n \n } // namespace HIR"}, {"sha": "1922a3bcb6883810cc001b82779cbce29d1ba1e9", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -40,8 +40,6 @@ class ArrayCapacityConstant : public ASTLoweringBase\n     return folder.ok;\n   }\n \n-  virtual ~ArrayCapacityConstant () {}\n-\n   void visit (AST::LiteralExpr &expr) override\n   {\n     switch (expr.get_lit_type ())\n@@ -226,9 +224,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n   {\n     std::vector<HIR::Attribute> outer_attribs;\n \n-    HIR::PathExprSegment method_path (\n-      expr.get_method_name ().get_ident_segment ().as_string (),\n-      expr.get_method_name ().get_locus ());\n+    HIR::PathExprSegment method_path\n+      = lower_path_expr_seg (expr.get_method_name ());\n \n     HIR::Expr *receiver\n       = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());"}, {"sha": "7f6594d106e6ae25afbe8d59162d26a197e091fd", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -351,19 +351,6 @@ class ASTLoweringItem : public ASTLoweringBase\n   }\n \n private:\n-  std::vector<std::unique_ptr<HIR::GenericParam> > lower_generic_params (\n-    std::vector<std::unique_ptr<AST::GenericParam> > &params)\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > lowered;\n-    for (auto &ast_param : params)\n-      {\n-\tauto hir_param = ASTLowerGenericParam::translate (ast_param.get ());\n-\tlowered.push_back (std::unique_ptr<HIR::GenericParam> (hir_param));\n-      }\n-\n-    return lowered;\n-  }\n-\n   ASTLoweringItem () : translated (nullptr) {}\n \n   HIR::Item *translated;"}, {"sha": "0bacdd216d7bf87eca7b974e36fc1a6b8e7b8de5", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -276,32 +276,7 @@ ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n {\n   std::vector<HIR::PathExprSegment> path_segments;\n   expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n-    std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n-\n-    std::vector<HIR::Lifetime> lifetime_args;\n-    if (s.has_generic_args ())\n-      {\n-\tfor (auto &lifetime : s.get_generic_args ().get_lifetime_args ())\n-\t  {\n-\t    HIR::Lifetime l = lower_lifetime (lifetime);\n-\t    lifetime_args.push_back (std::move (l));\n-\t  }\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::Type> > type_args;\n-    if (s.has_generic_args ())\n-      {\n-\tfor (auto &type : s.get_generic_args ().get_type_args ())\n-\t  {\n-\t    HIR::Type *t = ASTLoweringType::translate (type.get ());\n-\t    type_args.push_back (std::unique_ptr<HIR::Type> (t));\n-\t  }\n-      }\n-\n-    PathExprSegment seg (s.get_ident_segment ().as_string (), s.get_locus (),\n-\t\t\t std::move (lifetime_args), std::move (type_args),\n-\t\t\t std::move (binding_args));\n-    path_segments.push_back (seg);\n+    path_segments.push_back (lower_path_expr_seg (s));\n     return true;\n   });\n \n@@ -315,5 +290,59 @@ ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n \t\t\t\t\t  expr.opening_scope_resolution ());\n }\n \n+// rust-ast-lower-base.h\n+\n+std::vector<std::unique_ptr<HIR::GenericParam> >\n+ASTLoweringBase::lower_generic_params (\n+  std::vector<std::unique_ptr<AST::GenericParam> > &params)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam> > lowered;\n+  for (auto &ast_param : params)\n+    {\n+      auto hir_param = ASTLowerGenericParam::translate (ast_param.get ());\n+      lowered.push_back (std::unique_ptr<HIR::GenericParam> (hir_param));\n+    }\n+\n+  return lowered;\n+}\n+\n+HIR::PathExprSegment\n+ASTLoweringBase::lower_path_expr_seg (AST::PathExprSegment &s)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, s.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::PathExprSegment (\n+    std::move (mapping),\n+    HIR::PathIdentSegment (s.get_ident_segment ().as_string ()), s.get_locus (),\n+    s.has_generic_args () ? lower_generic_args (s.get_generic_args ())\n+\t\t\t  : HIR::GenericArgs::create_empty ());\n+}\n+\n+HIR::GenericArgs\n+ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+  std::vector<HIR::Lifetime> lifetime_args;\n+  for (auto &lifetime : args.get_lifetime_args ())\n+    {\n+      HIR::Lifetime l = lower_lifetime (lifetime);\n+      lifetime_args.push_back (std::move (l));\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::Type> > type_args;\n+  for (auto &type : args.get_type_args ())\n+    {\n+      HIR::Type *t = ASTLoweringType::translate (type.get ());\n+      type_args.push_back (std::unique_ptr<HIR::Type> (t));\n+    }\n+\n+  return HIR::GenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t\t   std::move (binding_args), args.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "093fcef833ea99f4011e004ae5b2e8d3b37b159a", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -2692,8 +2692,7 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n   for (const auto &segment : segments)\n     {\n       // return empty path if doesn't meet simple path segment requirements\n-      if (segment.is_error () || segment.has_generic_args ()\n-\t  || segment.as_string () == \"Self\")\n+      if (segment.has_generic_args () || segment.as_string () == \"Self\")\n \t{\n \t  return SimplePath::create_empty ();\n \t}"}, {"sha": "2affb686dd826f228e37c5b11d1d2946949a1635", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -192,60 +192,34 @@ struct GenericArgs\n /* A segment of a path in expression, including an identifier aspect and maybe\n  * generic args */\n class PathExprSegment\n-{ // or should this extend PathIdentSegment?\n+{\n private:\n+  Analysis::NodeMapping mappings;\n   PathIdentSegment segment_name;\n-\n-  // bool has_generic_args;\n   GenericArgs generic_args;\n-\n   Location locus;\n \n-  // TODO: does this require visitor? pretty sure not polymorphic\n-\n public:\n   // Returns true if there are any generic arguments\n   bool has_generic_args () const { return generic_args.has_generic_args (); }\n \n   // Constructor for segment (from IdentSegment and GenericArgs)\n-  PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n+  PathExprSegment (Analysis::NodeMapping mappings,\n+\t\t   PathIdentSegment segment_name, Location locus = Location (),\n \t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n-    : segment_name (std::move (segment_name)),\n+    : mappings (std::move (mappings)), segment_name (std::move (segment_name)),\n       generic_args (std::move (generic_args)), locus (locus)\n   {}\n \n-  /* Constructor for segment with generic arguments (from segment name and all\n-   * args) */\n-  PathExprSegment (std::string segment_name, Location locus,\n-\t\t   std::vector<Lifetime> lifetime_args\n-\t\t   = std::vector<Lifetime> (),\n-\t\t   std::vector<std::unique_ptr<Type> > type_args\n-\t\t   = std::vector<std::unique_ptr<Type> > (),\n-\t\t   std::vector<GenericArgsBinding> binding_args\n-\t\t   = std::vector<GenericArgsBinding> ())\n-    : segment_name (PathIdentSegment (std::move (segment_name))),\n-      generic_args (GenericArgs (std::move (lifetime_args),\n-\t\t\t\t std::move (type_args),\n-\t\t\t\t std::move (binding_args))),\n-      locus (locus)\n-  {}\n-\n-  // Returns whether path expression segment is in an error state.\n-  bool is_error () const { return segment_name.is_error (); }\n-\n-  // Creates an error-state path expression segment.\n-  static PathExprSegment create_error ()\n-  {\n-    return PathExprSegment (PathIdentSegment::create_error ());\n-  }\n-\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n \n   PathIdentSegment get_segment () const { return segment_name; }\n \n   GenericArgs &get_generic_args () { return generic_args; }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n };\n \n // HIR node representing a pattern that involves a \"path\" - abstract base class\n@@ -335,6 +309,15 @@ class PathInExpression : public PathPattern, public PathExpr\n \n   bool opening_scope_resolution () { return has_opening_scope_resolution; }\n \n+  bool is_self () const\n+  {\n+    if (!is_single_segment ())\n+      return false;\n+\n+    return get_final_segment ().get_segment ().as_string ().compare (\"self\")\n+\t   == 0;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "ca5dbe5e4094962d816d5fb0ea8811f5f1d1bacb", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -66,16 +67,25 @@ class MethodResolution : public TypeCheckBase\n \treturn;\n       }\n \n-    // FIXME this can be simplified with\n-    // https://github.com/Rust-GCC/gccrs/issues/187\n-    auto unified_ty = receiver->unify (self_lookup);\n-    if (unified_ty == nullptr)\n+    if (self_lookup->get_kind () != receiver->get_kind ())\n+      return;\n+\n+    if (receiver->has_subsititions_defined ()\n+\t!= self_lookup->has_subsititions_defined ())\n+      return;\n+\n+    if (self_lookup->has_subsititions_defined ())\n+      {\n+\t// we assume the receiver should be fully substituted at this stage\n+\tself_lookup = SubstMapperFromExisting::Resolve (receiver, self_lookup);\n+      }\n+\n+    if (!receiver->is_equal (*self_lookup))\n       {\n \t// incompatible self argument then this is not a valid method for this\n \t// receiver\n \treturn;\n       }\n-    delete unified_ty;\n \n     probed.push_back (&method);\n   }"}, {"sha": "836328f5637cec01885a04e8814339cccca80f82", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -77,7 +77,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n       {\n-\tTyTy::TupleType *tuple = (TyTy::TupleType *) resolved;\n+\tTyTy::TupleType *tuple = static_cast<TyTy::TupleType *> (resolved);\n \tTupleIndex index = expr.get_tuple_index ();\n \tif ((size_t) index >= tuple->num_fields ())\n \t  {\n@@ -98,7 +98,7 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::ADTType *adt = (TyTy::ADTType *) resolved;\n+    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n     TupleIndex index = expr.get_tuple_index ();\n     if ((size_t) index >= adt->num_fields ())\n       {\n@@ -115,6 +115,10 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = field_tyty->get_field_type ();\n+    printf (\"ZXZX resolved: %s to: \\n\", expr.as_string ().c_str ());\n+    adt->debug ();\n+    infered->debug ();\n+    printf (\"ZXZX done\\n\");\n   }\n \n   void visit (HIR::TupleExpr &expr) override\n@@ -220,35 +224,58 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \trust_error_at (\n \t  expr.get_locus (),\n-\t  \"Generics and Traits are not implemented yet for MethodCall\");\n+\t  \"multiple candidates in MethodCallExpr have been probed is \"\n+\t  \"not currently supported\");\n \treturn;\n       }\n \n     auto resolved_method = probes.at (0);\n-    TyTy::BaseType *lookup;\n+    TyTy::BaseType *lookup_tyty;\n     if (!context->lookup_type (resolved_method->get_mappings ().get_hirid (),\n-\t\t\t       &lookup))\n+\t\t\t       &lookup_tyty))\n       {\n \trust_error_at (resolved_method->get_locus (),\n \t\t       \"failed to lookup type for CallExpr: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n \n-    infered = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n-    if (infered == nullptr)\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    if (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+      {\n+\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+\tif (receiver_tyty->get_kind () == TyTy::TypeKind::ADT)\n+\t  {\n+\t    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver_tyty);\n+\t    if (adt->has_substitutions ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\t\tlookup\n+\t\t  = fn->handle_substitions (adt->get_substitution_arguments ());\n+\t      }\n+\t  }\n+      }\n+\n+    TyTy::BaseType *function_ret_tyty\n+      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n+    if (function_ret_tyty == nullptr\n+\t|| function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failed to lookup type to MethodCallExpr\");\n \treturn;\n       }\n \n-    infered->set_ref (expr.get_mappings ().get_hirid ());\n+    // store the expected fntype\n+    context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n \n     // set up the resolved name on the path\n     resolver->insert_resolved_name (\n       expr.get_mappings ().get_nodeid (),\n       resolved_method->get_mappings ().get_nodeid ());\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n   }\n \n   void visit (HIR::AssignmentExpr &expr) override\n@@ -357,9 +384,7 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    lookup->append_reference (lookup->get_ref ());\n     infered = lookup->clone ();\n-    infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::LiteralExpr &expr) override\n@@ -788,6 +813,9 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    if (expr.is_self ())\n+      return;\n+\n     if (infered->has_subsititions_defined ())\n       {\n \tif (!infered->can_substitute ())"}, {"sha": "dd6262242368df5c78f58f6fb89c87721aef1afc", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -212,15 +212,12 @@ class TypeCheckImplItem : public TypeCheckBase\n     auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n-    auto result\n+    auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n-    auto ret_resolved = expected_ret_tyty->unify (result);\n-    if (ret_resolved == nullptr)\n-      return;\n-\n-    context->peek_return_type ()->append_reference (ret_resolved->get_ref ());\n \n     context->pop_return_type ();\n+\n+    expected_ret_tyty->unify (block_expr_ty);\n   }\n \n   void visit (HIR::Method &method) override\n@@ -245,15 +242,15 @@ class TypeCheckImplItem : public TypeCheckBase\n     auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n-    auto result\n-      = TypeCheckExpr::Resolve (method.get_function_body ().get (), false);\n-    auto ret_resolved = expected_ret_tyty->unify (result);\n-    if (ret_resolved == nullptr)\n-      return;\n+    printf (\"XXXX method body boyo: 1!!\\n\");\n \n-    context->peek_return_type ()->append_reference (ret_resolved->get_ref ());\n+    auto block_expr_ty\n+      = TypeCheckExpr::Resolve (method.get_definition ().get (), false);\n \n     context->pop_return_type ();\n+\n+    expected_ret_tyty->unify (block_expr_ty);\n+    printf (\"XXXX method body boyo: 2!!\\n\");\n   }\n \n private:"}, {"sha": "d449c728c0db16338efdff6743998304ea476ff0", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -162,6 +162,62 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   TyTy::SubstitutionArgumentMappings &mappings;\n };\n \n+class SubstMapperFromExisting : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *concrete,\n+\t\t\t\t  TyTy::BaseType *receiver)\n+  {\n+    rust_assert (concrete->get_kind () == receiver->get_kind ());\n+\n+    SubstMapperFromExisting mapper (concrete, receiver);\n+    concrete->accept_vis (mapper);\n+    return mapper.resolved;\n+  }\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    rust_assert (type.was_substituted ());\n+\n+    TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n+    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    rust_assert (type.was_substituted ());\n+\n+    TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n+    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+  }\n+\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n+  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n+  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n+  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n+\n+private:\n+  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n+    : concrete (concrete), receiver (receiver), resolved (nullptr)\n+  {}\n+\n+  TyTy::BaseType *concrete;\n+  TyTy::BaseType *receiver;\n+\n+  TyTy::BaseType *resolved;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "4171da5e94e02b5d4c722c779cb250f4a0d98c69", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -76,6 +76,7 @@ class TypeCheckCallExpr : private TyVisitor\n class TypeCheckMethodCallExpr : private TyVisitor\n {\n public:\n+  // Resolve the Method parameters and return back the return type\n   static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n \t\t       Resolver::TypeCheckContext *context)\n   {"}, {"sha": "58baee908332d318681867a439a861ae2d3ea427", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -354,7 +354,8 @@ ADTType::clone ()\n     cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n   return new ADTType (get_ref (), get_ty_ref (), identifier, get_is_tuple (),\n-\t\t      cloned_fields, clone_substs (), get_combined_refs ());\n+\t\t      cloned_fields, clone_substs (), used_arguments,\n+\t\t      get_combined_refs ());\n }\n \n ADTType *\n@@ -368,6 +369,8 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       return nullptr;\n     }\n \n+  used_arguments = subst_mappings;\n+\n   ADTType *adt = static_cast<ADTType *> (clone ());\n   adt->set_ty_ref (mappings->get_next_hir_id ());\n \n@@ -568,6 +571,8 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       return nullptr;\n     }\n \n+  used_arguments = subst_mappings;\n+\n   FnType *fn = static_cast<FnType *> (clone ());\n   fn->set_ty_ref (mappings->get_next_hir_id ());\n "}, {"sha": "ac5a7662a1728405b27e87fb52ce3d0fb74fc39e", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -423,6 +423,18 @@ class SubstitutionArgumentMappings\n     : mappings (mappings), locus (locus)\n   {}\n \n+  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n+    : mappings (other.mappings), locus (other.locus)\n+  {}\n+\n+  SubstitutionArgumentMappings &\n+  operator= (const SubstitutionArgumentMappings &other)\n+  {\n+    mappings = other.mappings;\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n   static SubstitutionArgumentMappings error ()\n   {\n     return SubstitutionArgumentMappings ({}, Location ());\n@@ -471,8 +483,9 @@ class SubstitutionArgumentMappings\n class SubstitutionRef\n {\n public:\n-  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions)\n-    : substitutions (substitutions)\n+  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n+\t\t   SubstitutionArgumentMappings arguments)\n+    : substitutions (substitutions), used_arguments (arguments)\n   {}\n \n   bool has_substitutions () const { return substitutions.size () > 0; }\n@@ -514,6 +527,13 @@ class SubstitutionRef\n       }\n   }\n \n+  bool was_substituted () const { return !used_arguments.is_error (); }\n+\n+  SubstitutionArgumentMappings get_substitution_arguments ()\n+  {\n+    return used_arguments;\n+  }\n+\n   // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n   // in the case of Foo<i32,f32>{...}\n   //\n@@ -548,28 +568,32 @@ class SubstitutionRef\n \n protected:\n   std::vector<SubstitutionParamMapping> substitutions;\n+  SubstitutionArgumentMappings used_arguments;\n };\n \n class ADTType : public BaseType, public SubstitutionRef\n-\n {\n public:\n   ADTType (HirId ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n+\t   SubstitutionArgumentMappings generic_arguments\n+\t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ADT, refs),\n-      SubstitutionRef (std::move (subst_refs)), identifier (identifier),\n-      fields (fields), is_tuple (is_tuple)\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      identifier (identifier), fields (fields), is_tuple (is_tuple)\n   {}\n \n   ADTType (HirId ref, HirId ty_ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n+\t   SubstitutionArgumentMappings generic_arguments\n+\t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n-      SubstitutionRef (std::move (subst_refs)), identifier (identifier),\n-      fields (fields), is_tuple (is_tuple)\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      identifier (identifier), fields (fields), is_tuple (is_tuple)\n   {}\n \n   bool get_is_tuple () { return is_tuple; }\n@@ -651,16 +675,19 @@ class FnType : public BaseType, public SubstitutionRef\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n-      SubstitutionRef (std::move (subst_refs)), params (std::move (params)),\n-      type (type)\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      params (std::move (params)), type (type)\n   {}\n \n   FnType (HirId ref, HirId ty_ref,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n-      SubstitutionRef (std::move (subst_refs)), params (params), type (type)\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      params (params), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;"}, {"sha": "0399a6274956c5f7c0fcf6bfee666797065874ba", "filename": "gcc/testsuite/rust.test/compile/generics9.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea09d6b8e501dc7bd7046da641b70e02814b09/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics9.rs?ref=e4ea09d6b8e501dc7bd7046da641b70e02814b09", "patch": "@@ -0,0 +1,22 @@\n+struct GenericStruct<T>(T, usize);\n+\n+impl<T> GenericStruct<T> {\n+    fn new(a: T, b: usize) -> Self {\n+        GenericStruct(a, b)\n+    }\n+\n+    fn get(self) -> T {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a: GenericStruct<i32> = GenericStruct::<i32>::new(123, 456);\n+    let aa: i32 = a.get();\n+\n+    let b: GenericStruct<u32> = GenericStruct::<_>::new(123, 456);\n+    let bb: u32 = b.get();\n+\n+    let c: GenericStruct<f32> = GenericStruct::new(123f32, 456);\n+    let cc: f32 = c.get();\n+}"}]}