{"sha": "073a544dd99d1526bbf8906e8ac13d42a752d200", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczYTU0NGRkOTlkMTUyNmJiZjg5MDZlOGFjMTNkNDJhNzUyZDIwMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-11-18T17:33:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-11-18T17:33:01Z"}, "message": "machmode.h (bit_field_mode_iterator): New class.\n\ngcc/\n\t* machmode.h (bit_field_mode_iterator): New class.\n\t(get_best_mode): Change final parameter to bool.\n\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator)\n\t(bit_field_mode_iterator::next_mode): New functions, split out from...\n\t(get_best_mode): ...here.  Change final parameter to bool.\n\tUse bit_field_mode_iterator.\n\nFrom-SVN: r193603", "tree": {"sha": "0b688b615d5b6c61e00dcdc137907a0f3f33d947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b688b615d5b6c61e00dcdc137907a0f3f33d947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/073a544dd99d1526bbf8906e8ac13d42a752d200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073a544dd99d1526bbf8906e8ac13d42a752d200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/073a544dd99d1526bbf8906e8ac13d42a752d200", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073a544dd99d1526bbf8906e8ac13d42a752d200/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26f8b976309c42177332866ae3c6bf5a257c61fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f8b976309c42177332866ae3c6bf5a257c61fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26f8b976309c42177332866ae3c6bf5a257c61fc"}], "stats": {"total": 195, "additions": 134, "deletions": 61}, "files": [{"sha": "d240dd5814a48dc6d9f1a53508abb7f870cb052a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=073a544dd99d1526bbf8906e8ac13d42a752d200", "patch": "@@ -1,3 +1,12 @@\n+2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* machmode.h (bit_field_mode_iterator): New class.\n+\t(get_best_mode): Change final parameter to bool.\n+\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator)\n+\t(bit_field_mode_iterator::next_mode): New functions, split out from...\n+\t(get_best_mode): ...here.  Change final parameter to bool.\n+\tUse bit_field_mode_iterator.\n+\n 2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* expmed.c (narrow_bit_field_mem): New function."}, {"sha": "f1c89cc8a638c182986c89d01e3fb2ea41bd2592", "filename": "gcc/machmode.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=073a544dd99d1526bbf8906e8ac13d42a752d200", "patch": "@@ -259,13 +259,36 @@ extern enum machine_mode int_mode_for_mode (enum machine_mode);\n \n extern enum machine_mode mode_for_vector (enum machine_mode, unsigned);\n \n+/* A class for iterating through possible bitfield modes.  */\n+class bit_field_mode_iterator\n+{\n+public:\n+  bit_field_mode_iterator (HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   unsigned int, bool);\n+  bool next_mode (enum machine_mode *);\n+  bool prefer_smaller_modes ();\n+\n+private:\n+  enum machine_mode mode_;\n+  /* We use signed values here because the bit position can be negative\n+     for invalid input such as gcc.dg/pr48335-8.c.  */\n+  HOST_WIDE_INT bitsize_;\n+  HOST_WIDE_INT bitpos_;\n+  HOST_WIDE_INT bitregion_start_;\n+  HOST_WIDE_INT bitregion_end_;\n+  unsigned int align_;\n+  bool volatilep_;\n+  int count_;\n+};\n+\n /* Find the best mode to use to access a bit field.  */\n \n extern enum machine_mode get_best_mode (int, int,\n \t\t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned int,\n-\t\t\t\t\tenum machine_mode, int);\n+\t\t\t\t\tenum machine_mode, bool);\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n "}, {"sha": "b69c915c8ce47b47eb12072a5ffc93086c566f9f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 101, "deletions": 60, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a544dd99d1526bbf8906e8ac13d42a752d200/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=073a544dd99d1526bbf8906e8ac13d42a752d200", "patch": "@@ -2624,14 +2624,103 @@ fixup_unsigned_type (tree type)\n   layout_type (type);\n }\n \f\n+/* Construct an iterator for a bitfield that spans BITSIZE bits,\n+   starting at BITPOS.\n+\n+   BITREGION_START is the bit position of the first bit in this\n+   sequence of bit fields.  BITREGION_END is the last bit in this\n+   sequence.  If these two fields are non-zero, we should restrict the\n+   memory access to that range.  Otherwise, we are allowed to touch\n+   any adjacent non bit-fields.\n+\n+   ALIGN is the alignment of the underlying object in bits.\n+   VOLATILEP says whether the bitfield is volatile.  */\n+\n+bit_field_mode_iterator\n+::bit_field_mode_iterator (HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n+\t\t\t   HOST_WIDE_INT bitregion_start,\n+\t\t\t   HOST_WIDE_INT bitregion_end,\n+\t\t\t   unsigned int align, bool volatilep)\n+: mode_ (GET_CLASS_NARROWEST_MODE (MODE_INT)), bitsize_ (bitsize),\n+  bitpos_ (bitpos), bitregion_start_ (bitregion_start),\n+  bitregion_end_ (bitregion_end), align_ (MIN (align, BIGGEST_ALIGNMENT)),\n+  volatilep_ (volatilep), count_ (0)\n+{\n+}\n+\n+/* Calls to this function return successively larger modes that can be used\n+   to represent the bitfield.  Return true if another bitfield mode is\n+   available, storing it in *OUT_MODE if so.  */\n+\n+bool\n+bit_field_mode_iterator::next_mode (enum machine_mode *out_mode)\n+{\n+  for (; mode_ != VOIDmode; mode_ = GET_MODE_WIDER_MODE (mode_))\n+    {\n+      unsigned int unit = GET_MODE_BITSIZE (mode_);\n+\n+      /* Skip modes that don't have full precision.  */\n+      if (unit != GET_MODE_PRECISION (mode_))\n+\tcontinue;\n+\n+      /* Skip modes that are too small.  */\n+      if ((bitpos_ % unit) + bitsize_ > unit)\n+\tcontinue;\n+\n+      /* Stop if the mode is too wide to handle efficiently.  */\n+      if (unit > MAX_FIXED_MODE_SIZE)\n+\tbreak;\n+\n+      /* Don't deliver more than one multiword mode; the smallest one\n+\t should be used.  */\n+      if (count_ > 0 && unit > BITS_PER_WORD)\n+\tbreak;\n+\n+      /* Stop if the mode is wider than the alignment of the containing\n+\t object.\n+\n+\t It is tempting to omit the following line unless STRICT_ALIGNMENT\n+\t is true.  But that is incorrect, since if the bitfield uses part\n+\t of 3 bytes and we use a 4-byte mode, we could get a spurious segv\n+\t if the extra 4th byte is past the end of memory.\n+\t (Though at least one Unix compiler ignores this problem:\n+\t that on the Sequent 386 machine.  */\n+      if (unit > align_)\n+\tbreak;\n+\n+      /* Stop if the mode goes outside the bitregion.  */\n+      HOST_WIDE_INT start = bitpos_ - (bitpos_ % unit);\n+      if (bitregion_start_ && start < bitregion_start_)\n+\tbreak;\n+      if (bitregion_end_ && start + unit > bitregion_end_ + 1)\n+\tbreak;\n+\n+      *out_mode = mode_;\n+      mode_ = GET_MODE_WIDER_MODE (mode_);\n+      count_++;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if smaller modes are generally preferred for this kind\n+   of bitfield.  */\n+\n+bool\n+bit_field_mode_iterator::prefer_smaller_modes ()\n+{\n+  return (volatilep_\n+\t  ? targetm.narrow_volatile_bitfield ()\n+\t  : !SLOW_BYTE_ACCESS);\n+}\n+\n /* Find the best machine mode to use when referencing a bit field of length\n    BITSIZE bits starting at BITPOS.\n \n    BITREGION_START is the bit position of the first bit in this\n    sequence of bit fields.  BITREGION_END is the last bit in this\n    sequence.  If these two fields are non-zero, we should restrict the\n-   memory access to a maximum sized chunk of\n-   BITREGION_END - BITREGION_START + 1.  Otherwise, we are allowed to touch\n+   memory access to that range.  Otherwise, we are allowed to touch\n    any adjacent non bit-fields.\n \n    The underlying object is known to be aligned to a boundary of ALIGN bits.\n@@ -2655,69 +2744,21 @@ get_best_mode (int bitsize, int bitpos,\n \t       unsigned HOST_WIDE_INT bitregion_start,\n \t       unsigned HOST_WIDE_INT bitregion_end,\n \t       unsigned int align,\n-\t       enum machine_mode largest_mode, int volatilep)\n+\t       enum machine_mode largest_mode, bool volatilep)\n {\n+  bit_field_mode_iterator iter (bitsize, bitpos, bitregion_start,\n+\t\t\t\tbitregion_end, align, volatilep);\n+  enum machine_mode widest_mode = VOIDmode;\n   enum machine_mode mode;\n-  unsigned int unit = 0;\n-  unsigned HOST_WIDE_INT maxbits;\n-\n-  /* If unset, no restriction.  */\n-  if (!bitregion_end)\n-    maxbits = MAX_FIXED_MODE_SIZE;\n-  else\n-    maxbits = bitregion_end - bitregion_start + 1;\n-\n-  /* Find the narrowest integer mode that contains the bit field.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  while (iter.next_mode (&mode)\n+\t && (largest_mode == VOIDmode\n+\t     || GET_MODE_SIZE (mode) <= GET_MODE_SIZE (largest_mode)))\n     {\n-      unit = GET_MODE_BITSIZE (mode);\n-      if (unit == GET_MODE_PRECISION (mode)\n-\t  && (bitpos % unit) + bitsize <= unit)\n+      widest_mode = mode;\n+      if (iter.prefer_smaller_modes ())\n \tbreak;\n     }\n-\n-  if (mode == VOIDmode\n-      /* It is tempting to omit the following line\n-\t if STRICT_ALIGNMENT is true.\n-\t But that is incorrect, since if the bitfield uses part of 3 bytes\n-\t and we use a 4-byte mode, we could get a spurious segv\n-\t if the extra 4th byte is past the end of memory.\n-\t (Though at least one Unix compiler ignores this problem:\n-\t that on the Sequent 386 machine.  */\n-      || MIN (unit, BIGGEST_ALIGNMENT) > align\n-      || (largest_mode != VOIDmode && unit > GET_MODE_BITSIZE (largest_mode))\n-      || unit > maxbits\n-      || (bitregion_end\n-\t  && bitpos - (bitpos % unit) + unit > bitregion_end + 1))\n-    return VOIDmode;\n-\n-  if ((SLOW_BYTE_ACCESS && ! volatilep)\n-      || (volatilep && !targetm.narrow_volatile_bitfield ()))\n-    {\n-      enum machine_mode wide_mode = VOIDmode, tmode;\n-\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT); tmode != VOIDmode;\n-\t   tmode = GET_MODE_WIDER_MODE (tmode))\n-\t{\n-\t  unit = GET_MODE_BITSIZE (tmode);\n-\t  if (unit == GET_MODE_PRECISION (tmode)\n-\t      && bitpos / unit == (bitpos + bitsize - 1) / unit\n-\t      && unit <= BITS_PER_WORD\n-\t      && unit <= MIN (align, BIGGEST_ALIGNMENT)\n-\t      && unit <= maxbits\n-\t      && (largest_mode == VOIDmode\n-\t\t  || unit <= GET_MODE_BITSIZE (largest_mode))\n-\t      && (bitregion_end == 0\n-\t\t  || bitpos - (bitpos % unit) + unit <= bitregion_end + 1))\n-\t    wide_mode = tmode;\n-\t}\n-\n-      if (wide_mode != VOIDmode)\n-\treturn wide_mode;\n-    }\n-\n-  return mode;\n+  return widest_mode;\n }\n \n /* Gets minimal and maximal values for MODE (signed or unsigned depending on"}]}