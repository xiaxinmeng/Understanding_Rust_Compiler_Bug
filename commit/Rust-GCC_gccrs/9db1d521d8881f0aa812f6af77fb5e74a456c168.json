{"sha": "9db1d521d8881f0aa812f6af77fb5e74a456c168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiMWQ1MjFkODg4MWYwYWE4MTJmNmFmNzdmYjVlNzRhNDU2YzE2OA==", "commit": {"author": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2001-07-13T13:10:42Z"}, "committer": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2001-07-13T13:10:42Z"}, "message": "s390.c: New.\n\n        * config/s390/s390.c: New. Subroutines for code generation.\n        * config/s390/s390.h: New. Definitions for s/390.\n        * config/s390/s390-protos.h: New. Prototypes.\n        * config/s390/linux.h: New. Definitions for linux for s/390.\n        * config/s390/linux64.h: New. Definitions for linux for zSeries.\n        * config/s390/t-linux: New. Makefile fragment.\n        * config/s390/s390.md: New. Machine description for s/390 and zSeries.\n        * config/s390/fixdfdi.h: New. Fix L_fix*di.\n---------------------------------------------------------------------\n\nFrom-SVN: r43980", "tree": {"sha": "1556e53d53a36e463eeff2ba15e5f8813f177630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1556e53d53a36e463eeff2ba15e5f8813f177630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db1d521d8881f0aa812f6af77fb5e74a456c168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db1d521d8881f0aa812f6af77fb5e74a456c168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db1d521d8881f0aa812f6af77fb5e74a456c168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db1d521d8881f0aa812f6af77fb5e74a456c168/comments", "author": null, "committer": null, "parents": [{"sha": "f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc"}], "stats": {"total": 11383, "additions": 11383, "deletions": 0}, "files": [{"sha": "3e1ad496052dc00294b852f92ce58b76ef677e35", "filename": "gcc/config/s390/fixdfdi.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,134 @@\n+#ifdef L_fixunsdfdi\n+#define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n+#define EXCESSD\t\t1022\n+#define SIGNBIT\t\t0x80000000\n+#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n+#define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n+#define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n+#define HIDDEND_LL\t((long long)1 << 52)\n+\n+union double_long {\n+    double d;\n+    struct {\n+      long upper;\n+      unsigned long lower;\n+    } l;\n+    long long ll;\n+};\n+\n+\n+/* convert double to unsigned int */\n+unsigned long long\n+__fixunsdfdi (double a1)\n+{\n+    register union double_long dl1;\n+    register int exp;\n+    register long long l;\n+\n+    dl1.d = a1;\n+\n+    /* +/- 0, denormalized, negativ */\n+\n+    if (!EXPD (dl1) || SIGND(dl1))\n+      return 0;\n+\n+    exp = EXPD (dl1) - EXCESSD - 53;\n+\n+    /* number < 1 */\n+\n+    if (exp < -53)\n+      return 0;\n+\n+    /* NaN */\n+\n+    if ((EXPD(dl1) == 0x7ff) && (FRACD_LL(dl1) != 0)) /* NaN */\n+      return 0x0ULL;\n+\n+    /* Number big number & + inf */\n+\n+    if (exp >= 12) {\n+      return 0xFFFFFFFFFFFFFFFFULL;\n+    }\n+\n+    l = MANTD_LL(dl1);\n+\n+    /* shift down until exp < 12 or l = 0 */\n+    if (exp > 0)\n+      l <<= exp;\n+    else \n+      l >>= -exp;\n+\n+    return l;\n+}\n+#define __fixunsdfdi ___fixunsdfdi\n+#endif\n+#undef L_fixunsdfdi\n+\n+#ifdef L_fixdfdi\n+#define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n+#define EXCESSD\t\t1022\n+#define SIGNBIT\t\t0x80000000\n+#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n+#define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n+#define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n+#define HIDDEND_LL\t((long long)1 << 52)\n+\n+union double_long {\n+    double d;\n+    struct {\n+      long upper;\n+      unsigned long lower;\n+    } l;\n+    long long ll;\n+};\n+\n+/* convert double to int */\n+long long\n+__fixdfdi (double a1)\n+{\n+    register union double_long dl1;\n+    register int exp;\n+    register long long l;\n+\n+    dl1.d = a1;\n+\n+    /* +/- 0, denormalized */\n+\n+    if (!EXPD (dl1))\n+      return 0;\n+\n+    exp = EXPD (dl1) - EXCESSD - 53;\n+\n+    /* number < 1 */\n+\n+    if (exp < -53)\n+      return 0;\n+\n+    /* NaN */\n+\n+    if ((EXPD(dl1) == 0x7ff) && (FRACD_LL(dl1) != 0)) /* NaN */\n+      return 0x8000000000000000ULL;\n+\n+    /* Number big number & +/- inf */\n+\n+    if (exp >= 11) {\n+\tl = (long long)1<<63;\n+\tif (!SIGND(dl1))\n+\t    l--;\n+\treturn l;\n+    }\n+\n+    l = MANTD_LL(dl1);\n+\n+    /* shift down until exp < 12 or l = 0 */\n+    if (exp > 0)\n+      l <<= exp;\n+    else \n+      l >>= -exp;\n+\n+    return (SIGND (dl1) ? -l : l);\n+}\n+#define __fixdfdi ___fixdfdi\n+#endif\n+#undef L_fixdfdi\n+"}, {"sha": "36ae80d7f29dd64889280958c544c2215a35fde7", "filename": "gcc/config/s390/linux.h", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,387 @@\n+/* Definitions for Linux for S/390.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+                  Ulrich Weigand (weigand@de.ibm.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _LINUX_H\n+#define _LINUX_H\n+\n+#define IEEE_FLOAT 1\n+#define TARGET_IBM_FLOAT           0\n+#define TARGET_IEEE_FLOAT          1\n+\n+#include <s390/s390.h>              /* Base s390 target machine definitions*/\n+\n+#include <linux.h>\n+\n+#undef SIZE_TYPE                       /* use default                      */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (Linux for S/390)\");\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dlinux -Asystem(linux) -Acpu(s390) -Amachine(s390) -D__s390__ -Asystem(unix) -Dunix -D__ELF__\"\n+\n+/* \n+ * Caller save not (always) working in gcc-2.95.2\n+ */\n+\n+#undef CC1_SPEC\n+#define CC1_SPEC \"-fno-caller-saves\"\n+#define CC1PLUS_SPEC \"-fno-caller-saves\"\n+\n+#undef\tLINK_SPEC\n+#ifdef CROSS_COMPILE\n+#define LINK_SPEC \"-m elf_s390 %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld.so.1 \\\n+        -rpath-link=/usr/local/s390-ibm-linux/lib}} \\\n+\t%{static:-static}}}\"\n+#else\n+#define LINK_SPEC \"-m elf_s390 %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \\\n+\t%{static:-static}}}\"\n+#endif\n+\n+/* Need to define this. Otherwise define to BITS_PER_WORD in cexp.c.\n+   But BITS_PER_WORD depends on target flags, which are not defined in \n+   cexpc.c.  */\n+\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+/* Character to start a comment.  */\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+\n+/* Assembler pseudos to introduce constants of various size.  */\n+\n+#define ASM_SHORT \"\\t.word\"\n+#define ASM_LONG \"\\t.long\"\n+#define ASM_QUAD \"\\t.quad\"\n+#define ASM_DOUBLE \"\\t.double\"\n+\n+\n+/* Prefix for internally generated assembler labels.  */\n+#define LPREFIX \".L\"\n+\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+  fprintf (FILE, \"%s\", NAME);  \n+\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#undef ASM_OUTPUT_LABEL\n+#define ASM_OUTPUT_LABEL(FILE, NAME)     \\\n+  (assemble_name (FILE, NAME), fputs (\":\\n\", FILE))\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    long t[2];\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\",\t\\\n+\t     t[0] & 0xffffffff, t[1] & 0xffffffff);\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    long t;\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\\\n+  }\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),    \\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+\n+#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)      \\\n+do { fprintf (FILE, \"%s\\t\", ASM_QUAD);          \\\n+  output_addr_const (FILE,(VALUE));             \\\n+  putc ('\\n',FILE);                             \\\n+ } while (0)\n+\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#undef ASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE, VALUE)             \\\n+do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n+  output_addr_const (FILE,(VALUE));             \\\n+  putc ('\\n',FILE);                             \\\n+ } while (0)\n+\n+/* Likewise for `char' and `short' constants. \n+   is this supposed to do align too?? */\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)           \\\n+( fprintf (FILE, \"%s \", ASM_SHORT),             \\\n+  output_addr_const (FILE,(VALUE)),             \\\n+  putc ('\\n',FILE))\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)            \\\n+( fprintf (FILE, \"%s \", ASM_BYTE_OP),           \\\n+  output_addr_const (FILE, (VALUE)),            \\\n+  putc ('\\n', FILE))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+     /* internal macro to output long */\n+#define _ASM_OUTPUT_LONG(FILE, VALUE)                                   \\\n+      fprintf (FILE, \"\\t.long\\t0x%lX\\n\", VALUE);\n+\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\\\n+  fprintf (FILE, \"%s %s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+\t   LPREFIX, VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n+  fprintf (FILE, \"%s %s%d-.LT%X_%X\\n\" ,TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+\t   LPREFIX, VALUE, s390_function_count,s390_pool_count)\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#undef ASM_OPEN_PAREN\n+#undef ASM_CLOSE_PAREN\n+#define ASM_OPEN_PAREN \"\"\n+#define ASM_CLOSE_PAREN \"\"\n+\n+\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)      \\\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#undef ASM_OUTPUT_SKIP \n+#define ASM_OUTPUT_SKIP(FILE, SIZE)  \\\n+  fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE, SIZE)  \\\n+  fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)                             \\\n+do {                                                                    \\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);   \\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);          \\\n+      register unsigned bytes_in_chunk = 0;                             \\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)                      \\\n+        {                                                               \\\n+          register unsigned char *p;                                    \\\n+          if (bytes_in_chunk >= 64)                                     \\\n+            {                                                           \\\n+              fputc ('\\n', (FILE));                                     \\\n+              bytes_in_chunk = 0;                                       \\\n+            }                                                           \\\n+          for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)          \\\n+            continue;                                                   \\\n+          if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)          \\\n+            {                                                           \\\n+              if (bytes_in_chunk > 0)                                   \\\n+                {                                                       \\\n+                  fputc ('\\n', (FILE));                                 \\\n+                  bytes_in_chunk = 0;                                   \\\n+                }                                                       \\\n+              ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);         \\\n+              _ascii_bytes = p;                                         \\\n+            }                                                           \\\n+          else                                                          \\\n+            {                                                           \\\n+              if (bytes_in_chunk == 0)                                  \\\n+                fprintf ((FILE), \"%s\\t\", ASM_BYTE_OP);                  \\\n+              else                                                      \\\n+                fputc (',', (FILE));                                    \\\n+              fprintf ((FILE), \"0x%02x\", *_ascii_bytes);                \\\n+              bytes_in_chunk += 5;                                      \\\n+            }                                                           \\\n+        }                                                               \\\n+      if (bytes_in_chunk > 0)                                           \\\n+        fprintf ((FILE), \"\\n\");                                         \\\n+} while (0)\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable (initialized) data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Output before writable (uninitialized) data.  */\n+\n+#define BSS_SECTION_ASM_OP \".bss\"\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)  \\\n+  (fputs (\".globl \", FILE), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/*\n+ * This macro generates the assembly code for function entry.\n+ */\n+\n+#define FUNCTION_PROLOGUE(FILE, LSIZE) s390_function_prologue (FILE, LSIZE)\n+\n+/* This macro generates the assembly code for function exit, on machines\n+   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n+   return instructions are generated for each return statement.  Args are\n+   same as for FUNCTION_PROLOGUE.\n+  \n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, LSIZE) s390_function_epilogue(FILE, LSIZE)\n+\n+/* Select section for constant in constant pool. \n+   We are in the right section. \n+   undef for 64 bit mode (linux64.h).\n+ */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, X)\n+\n+\f\n+/* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n+   Used for C++ multiple inheritance.  */\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)              \\\n+do {                                                                          \\\n+  if (TARGET_64BIT)                                                           \\\n+    {                                                                         \\\n+      if (flag_pic)                                                           \\\n+        {                                                                     \\\n+          fprintf (FILE, \"\\tlarl  1,0f\\n\");                                   \\\n+          fprintf (FILE, \"\\tagf   %d,0(1)\\n\",                                 \\\n+                   aggregate_value_p (TREE_TYPE                               \\\n+                                      (TREE_TYPE (FUNCTION))) ? 3 :2 );       \\\n+          fprintf (FILE, \"\\tlarl  1,\");                                       \\\n+          assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));      \\\n+          fprintf (FILE, \"@GOTENT\\n\");                                        \\\n+          fprintf (FILE, \"\\tlg    1,0(1)\\n\");                                 \\\n+          fprintf (FILE, \"\\tbr    1\\n\");                                      \\\n+          fprintf (FILE, \"0:\\t.long  %d\\n\",DELTA);                            \\\n+        }                                                                     \\\n+      else                                                                    \\\n+        {                                                                     \\\n+          fprintf (FILE, \"\\tlarl  1,0f\\n\");                                   \\\n+          fprintf (FILE, \"\\tagf   %d,0(1)\\n\",                                 \\\n+          aggregate_value_p (TREE_TYPE                                        \\\n+                             (TREE_TYPE (FUNCTION))) ? 3 :2 );                \\\n+          fprintf (FILE, \"\\tjg  \");                                           \\\n+          assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));      \\\n+          fprintf (FILE, \"\\n\");                                               \\\n+          fprintf (FILE, \"0:\\t.long  %d\\n\",DELTA);                            \\\n+        }                                                                     \\\n+    }                                                                         \\\n+  else                                                                        \\\n+    {                                                                         \\\n+      if (flag_pic)                                                           \\\n+        {                                                                     \\\n+          fprintf (FILE, \"\\tbras  1,0f\\n\");                                   \\\n+          fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_-.\\n\");                \\\n+          fprintf (FILE, \"\\t.long  \");                                        \\\n+          assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));      \\\n+          fprintf (FILE, \"@GOT\\n\");                                           \\\n+          fprintf (FILE, \"\\t.long  %d\\n\",DELTA);                              \\\n+          fprintf (FILE, \"0:\\tal  %d,8(1)\\n\",                                 \\\n+                   aggregate_value_p (TREE_TYPE                               \\\n+                                      (TREE_TYPE (FUNCTION))) ? 3 : 2 );      \\\n+          fprintf (FILE, \"\\tl     0,4(1)\\n\");                                 \\\n+          fprintf (FILE, \"\\tal    1,0(1)\\n\");                                 \\\n+          fprintf (FILE, \"\\talr   1,0\\n\");                                    \\\n+          fprintf (FILE, \"\\tl     1,0(1)\\n\");                                 \\\n+          fprintf (FILE, \"\\tbr    1\\n\");                                      \\\n+        } else {                                                              \\\n+          fprintf (FILE, \"\\tbras  1,0f\\n\");                                   \\\n+          fprintf (FILE, \"\\t.long  \");                                        \\\n+          assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));      \\\n+          fprintf (FILE, \"-.\\n\");                                             \\\n+          fprintf (FILE, \"\\t.long  %d\\n\",DELTA);                              \\\n+          fprintf (FILE, \"0:\\tal  %d,4(1)\\n\",                                 \\\n+                   aggregate_value_p (TREE_TYPE                               \\\n+                                      (TREE_TYPE (FUNCTION))) ? 3 : 2 );      \\\n+          fprintf (FILE, \"\\tal    1,0(1)\\n\");                                 \\\n+          fprintf (FILE, \"\\tbr    1\\n\");                                      \\\n+       }                                                                      \\\n+    }                                                                         \\\n+} while (0)\n+\n+#endif"}, {"sha": "ab518c2ea1ffbcecaa755adeccc2a7cb11b842f9", "filename": "gcc/config/s390/linux64.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux64.h?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,82 @@\n+/* Definitions for Linux for s/390 zSeries\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+                  Ulrich Weigand (weigand@de.ibm.com).\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _LINUX64_H\n+#define _LINUX64_H\n+\n+#include <s390/linux.h>              /* Base linux target machine definitions*/\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT             0x13\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (Linux for S/390 zSeries 64 bit)\");\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dlinux -Asystem(linux) -Acpu(s390) -Amachine(s390) -D__s390x__ -Asystem(unix) -Dunix -D__ELF__\"\n+\n+\n+#undef\tLINK_SPEC\n+#ifdef CROSS_COMPILE\n+#define LINK_SPEC \"-m elf64_s390 %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld64.so.1 \\\n+        -rpath-link=/usr/local/s390x-ibm-linux/lib}} \\\n+\t%{static:-static}}}\"\n+#else\n+#define LINK_SPEC \"-m elf64_s390 %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld64.so.1}} \\\n+\t%{static:-static}}}\"\n+#endif\n+\n+#undef INT_ASM_OP\n+#define INT_ASM_OP \"\\t.quad\\t\"\n+\n+#undef PROMOTE_PROTOTYPES \n+#undef MASK_RETURN_ADDR \n+#undef SELECT_SECTION\n+\n+/* With 64 bit new linkage for floating point registers.  */\n+#undef CALL_USED_REGISTERS\t\t\t\n+#define CALL_USED_REGISTERS\t\t\t\\\n+{ 1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  1 }\n+\n+#endif"}, {"sha": "c733ca83ff2a8422d22aa9912f07fd5024550fd3", "filename": "gcc/config/s390/s390-protos.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,88 @@\n+/* Definitions of target machine for GNU compiler, for IBM S/390.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Declare functions in s390.c and linux.c */\n+\n+#ifdef RTX_CODE\n+\n+#ifdef TREE_CODE\n+extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx, int));\n+extern void s390_va_start PARAMS ((int, tree, rtx));\n+\n+#endif /* TREE_CODE */\n+\n+extern int fp_operand PARAMS ((rtx, enum machine_mode));\n+extern int s_operand PARAMS ((rtx, enum machine_mode));\n+extern int larl_operand PARAMS ((rtx, enum machine_mode));\n+extern int r_or_im8_operand PARAMS ((rtx, enum machine_mode));\n+extern int r_or_s_operand PARAMS ((rtx, enum machine_mode)); \n+extern int r_or_s_or_im8_operand PARAMS ((rtx, enum machine_mode));\n+extern int r_or_x_or_im16_operand PARAMS ((rtx, enum machine_mode));\n+extern int bras_sym_operand PARAMS ((rtx, enum machine_mode));\n+extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n+extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n+extern int dead_p PARAMS ((rtx, rtx));\n+extern void print_operand PARAMS ((FILE *, rtx, char));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern int legitimate_pic_operand_p PARAMS ((rtx));\n+extern int legitimate_constant_p PARAMS ((rtx));\n+\n+extern int unsigned_comparison_operator PARAMS ((rtx));\n+extern int unsigned_jump_follows_p PARAMS ((rtx));\n+\n+extern void update_cc PARAMS ((rtx, rtx));\n+\n+extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n+extern int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+\n+extern int s390_stop_dump_lit_p PARAMS ((rtx));\n+extern void s390_dump_literal_pool PARAMS ((rtx, rtx));\n+extern void s390_expand_eh_epilogue PARAMS ((rtx, rtx, rtx));\n+extern void s390_asm_output_external_libcall PARAMS ((FILE *, rtx));\n+\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern void s390_function_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t       tree, int));\n+extern struct rtx_def *s390_function_arg PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t     enum machine_mode, tree, int));\n+extern int s390_function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t       enum machine_mode, tree, int));\n+extern int s390_function_arg_pass_by_reference PARAMS ((enum machine_mode, tree));\n+extern void setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t    enum machine_mode, tree,\n+\t\t\t\t\t    int *, int));\n+extern struct rtx_def *s390_va_arg PARAMS ((tree, tree));\n+extern union tree_node *s390_build_va_list PARAMS ((void));\n+extern void s390_asm_output_pool_prologue PARAMS ((FILE *, char *, tree, int));\n+extern void encode_section_info PARAMS ((tree));\n+\n+#endif /* TREE_CODE */\n+\n+\n+extern void s390_trampoline_template PARAMS ((FILE *));\n+extern void s390_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void s390_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void s390_final_chunkify PARAMS ((int));\n+extern int s390_arg_frame_offset PARAMS ((void));"}, {"sha": "c80dc2a275d73b02512c8c6b384029153d582c0d", "filename": "gcc/config/s390/s390.c", "status": "added", "additions": 2981, "deletions": 0, "changes": 2981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,2981 @@\n+/* Subroutines used for code generation on IBM S/390 and zSeries\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+                  Ulrich Weigand (weigand@de.ibm.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <setjmp.h>\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+\n+\n+\n+\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE \n+#define TARGET_ASM_FUNCTION_PROLOGUE s390_function_prologue\n+\n+#undef  TARGET_ASM_FUNCTION_EPILOGUE \n+#define TARGET_ASM_FUNCTION_EPILOGUE s390_function_epilogue\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+extern int reload_completed;\n+\n+/* Function count for creating unique internal labels in a compile unit.  */\n+int  s390_function_count = 0;\n+\n+/* Save information from a \"cmpxx\" operation until the branch or scc is\n+   emitted.  */\n+rtx s390_compare_op0, s390_compare_op1;\n+\n+\n+struct s390_address\n+{\n+  rtx base;\n+  rtx indx;\n+  rtx disp;\n+};\n+\n+static int s390_match_ccmode_set \n+  PARAMS ((rtx set, int req_mode));\n+static int base_n_index_p \n+  PARAMS ((rtx op));\n+static int check_mode \n+  PARAMS ((register rtx op, enum machine_mode *mode));\n+static int s390_decompose_address \n+  PARAMS ((register rtx addr, struct s390_address *out, int strict));\n+static int check_mode \n+  PARAMS ((register rtx op, enum machine_mode *mode));\n+ \n+/* Return TRUE or FALSE depending on whether every SET in INSN that\n+   set the CC register has source and destination with matching CC modes, \n+   and that the CC mode is at least as constrained as REQ_MODE.  */\n+ \n+static int\n+s390_match_ccmode_set (set, req_mode)\n+     rtx set;\n+     int req_mode;\n+{\n+  unsigned int set_mode;\n+\n+  if (GET_CODE (set) != SET)\n+    abort();\n+\n+  if (GET_CODE (SET_DEST (set)) != REG || !CC_REGNO_P (REGNO (SET_DEST (set))))\n+    return 1;\n+\n+  set_mode = GET_MODE (SET_DEST (set));\n+  switch (set_mode)\n+    {\n+    case CCmode:\n+      return 0;\n+\n+    case CCSmode:\n+      if (req_mode != CCSmode)\n+        return 0;\n+      break;\n+    case CCUmode:\n+      if (req_mode != CCUmode)\n+        return 0;\n+      break;\n+    case CCZmode:\n+      if (req_mode != CCSmode && req_mode != CCUmode && req_mode != CCTmode)\n+        return 0;\n+      break;\n+ \n+    default:\n+      abort ();\n+    }\n+ \n+  return (GET_MODE (SET_SRC (set)) == set_mode);\n+}\n+\n+int\n+s390_match_ccmode (insn, req_mode)\n+     rtx insn;\n+     int req_mode;\n+{\n+  int i;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    return s390_match_ccmode_set (PATTERN (insn), req_mode);\n+\n+  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+        {\n+          rtx set = XVECEXP (PATTERN (insn), 0, i);\n+          if (GET_CODE (set) == SET)\n+            if (!s390_match_ccmode_set (set, req_mode))\n+              return 0;\n+        }\n+\n+  return 1;\n+}\n+\n+\n+void\n+optimization_options (level, size)\n+     int level;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+#ifdef HAVE_decrement_and_branch_on_count\n+  /* When optimizing, enable use of BRCT instruction.  */\n+  if (level >= 1)\n+      flag_branch_on_count_reg = 1;\n+#endif\n+}\n+\n+\n+/* Map for smallest class containing reg regno.  */\n+\n+enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n+{ GENERAL_REGS, ADDR_REGS, ADDR_REGS, ADDR_REGS,\n+  ADDR_REGS,    ADDR_REGS, ADDR_REGS, ADDR_REGS,\n+  ADDR_REGS,    ADDR_REGS, ADDR_REGS, ADDR_REGS,\n+  ADDR_REGS,    ADDR_REGS, ADDR_REGS, ADDR_REGS,\n+  FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n+  FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n+  FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n+  FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n+  ADDR_REGS,    CC_REGS \n+};\n+\n+\n+/* Match exactly zero.  */\n+ \n+int\n+const0_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return op == CONST0_RTX (mode);\n+}\n+\n+/* Match exactly one.  */\n+ \n+int\n+const1_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return op == CONST1_RTX (mode);\n+}\n+ \n+\n+/* Return 1 if OP needs base and index register.  */\n+\n+static int \n+base_n_index_p (rtx op)\n+{\n+  if ((GET_CODE (op) == PLUS) &&\n+      (GET_CODE (XEXP (op, 0)) == PLUS ||\n+       GET_CODE (XEXP (op, 1)) == PLUS ||\n+       GET_CODE (XEXP (op, 1)) == REG ))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Check mode and mode of op, set it to mode of op, if VOIDmode.  */ \n+\n+static int\n+check_mode (op, mode)\n+     register rtx op;\n+     enum machine_mode *mode;\n+{\n+  if (*mode == VOIDmode)\n+      *mode = GET_MODE (op);\n+  else\n+  {\n+    if (GET_MODE (op) != VOIDmode && GET_MODE (op) != *mode)\n+       return 0;\n+  }\n+  return 1;\n+}\n+\n+\n+/* Return 1 if OP a valid operand for the LARL instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+larl_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx sym;\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (! check_mode (op, &mode))\n+    return 0;\n+\n+  /* Allow labels and local symbols.  */\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+  if (GET_CODE (op) == SYMBOL_REF\n+      && (!flag_pic || SYMBOL_REF_FLAG (op) \n+          || CONSTANT_POOL_ADDRESS_P (op)))\n+    return 1;\n+\n+  /* Everything else must have a CONST, so strip it.  */\n+  if (GET_CODE (op) != CONST)\n+    return 0;\n+  op = XEXP (op, 0);\n+\n+  /* Allow adding *even* constants.  */\n+  if (GET_CODE (op) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+          || (INTVAL (XEXP (op, 1)) & 1) != 0)\n+        return 0;\n+      op = XEXP (op, 0);\n+    }\n+\n+  /* Labels and local symbols allowed here as well.  */\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+  if (GET_CODE (op) == SYMBOL_REF\n+      && (!flag_pic || SYMBOL_REF_FLAG (op)\n+          || CONSTANT_POOL_ADDRESS_P (op)))\n+    return 1;\n+\n+  /* Now we must have a @GOTENT offset or @PLT stub.  */\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == 111)\n+    return 1;\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == 113)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a valid FP-Register.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+fp_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+  if (! check_mode (op, &mode))\n+    return 0;\n+  if (code == REG && REGNO_OK_FOR_FP_P (REGNO (op)))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.  */\n+\n+int\n+s_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (! check_mode (op,&mode))\n+    return 0;\n+\n+  if (code == MEM) {\n+    if (base_n_index_p (XEXP (op, 0)))\n+      return 0;\n+  }\n+\n+  return memory_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n+   instruction.  */\n+\n+int\n+r_or_s_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (!general_operand (op, mode))\n+    return 0;\n+\n+  if (code == MEM) {\n+    if (base_n_index_p (XEXP (op, 0)))\n+      return 0;\n+    else\n+      return memory_operand (op, mode);\n+  }\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid R or S or immediate operand for \n+   RS, SI or SS type instruction.  */\n+\n+int\n+r_or_s_or_im8_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (!general_operand (op, mode))\n+    return 0;\n+\n+  if (code == MEM) {\n+    if (base_n_index_p (XEXP (op, 0)))\n+      return 0;\n+    else\n+      return memory_operand (op, mode);\n+  }\n+  return register_operand (op, mode) || immediate_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid R or X or 16 bit immediate operand for \n+   RX, RR or RI type instruction.  */\n+\n+int\n+r_or_x_or_im16_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+\n+  if (! general_operand (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'));\n+  return register_operand (op, mode) || memory_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid R or 8 bit immediate operand for \n+   !!!!!!! type instruction.  */\n+\n+int\n+r_or_im8_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+\n+  if (!general_operand (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'J'));\n+  return register_operand (op, mode) || memory_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid operand for the 'test under mask'\n+   instruction with 16 bit immediate.  \n+   The value should only have set bits in one halfword.  */ \n+\n+int\n+tmxx_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx con;\n+  if (GET_CODE (op) == CONST_INT)\n+    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'));\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == SYMBOL_REF &&\n+      CONSTANT_POOL_ADDRESS_P (XEXP (op, 0))) \n+    {\n+      con = get_pool_constant (XEXP (op, 0));\n+\n+      if (GET_CODE (con) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDEST_INT c;\n+\t  \n+\t  c = (unsigned HOST_WIDEST_INT) INTVAL (con);\n+\t  \n+\t  return ((c & 0xffff) ? ((c & 0xffffffffffff0000ULL)==0) : \n+\t\t  (c & 0xffff0000) ? ((c & 0xffffffff0000ffffULL)==0) :\n+\t\t  (c & 0xffff00000000ULL) ? ((c & 0xffff0000ffffffffULL)==0) :\n+\t\t  (c & 0xffff000000000000ULL) ? ((c & 0xffffffffffffULL)==0) : 1);\n+\t\t  \n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* Return 1 if valid operand for BRAS\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+bras_sym_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  /* Allow SYMBOL_REFs.  */\n+  if (code == SYMBOL_REF)\n+    return 1;\n+\n+  /* Allow @PLT stubs.  */\n+  if (code == CONST\n+      && GET_CODE (XEXP (op, 0)) == UNSPEC\n+      && XINT (XEXP (op, 0), 1) == 113)\n+    return 1;\n+  return 0;\n+}\n+\n+\f\n+/* Return 1 if OP is a load multiple operation.  It is known to be a\n+   PARALLEL and the first section will be tested.  */\n+\n+int\n+load_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != Pmode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != Pmode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Similar, but tests for store multiple.  */\n+\n+int\n+store_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0) - 1;\n+  unsigned int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != Pmode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != Pmode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+\n+/* Returns 1 if OP contains a symbol reference */\n+\n+int\n+symbolic_reference_mentioned_p (op)\n+     rtx op;\n+{\n+  register char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return 1;\n+\t}\n+\n+      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+\n+int\n+legitimate_pic_operand_p (op)\n+     register rtx op;\n+{\n+  /* All non-symbolic constants that made it \n+     up to here are fine.  */\n+  if (!SYMBOLIC_CONST (op))\n+    return 1;\n+\n+  /* Accept immediate LARL operands.  */\n+  if (TARGET_64BIT)\n+    return larl_operand (op, VOIDmode);\n+\n+  /* Reject everything else; must be handled \n+     via emit_pic_move.  */\n+  return 0;\n+}\n+\n+int\n+legitimate_constant_p (op)\n+     register rtx op;\n+{\n+  /* Reject doubles and integers out of range.  */\n+  if (GET_CODE (op) == CONST_DOUBLE ||\n+      (GET_CODE (op) == CONST_INT &&\n+       (INTVAL (op) < -32768 || INTVAL (op) > 32767)))\n+    return 0;\n+\n+  /* Accept all other non-symbolic constants.  */\n+  if (!SYMBOLIC_CONST (op))\n+    return 1;\n+\n+  /* In the PIC case, symbolic constants must *not* be\n+     forced into the literal pool.  We accept them here,\n+     so that they will be handled by emit_pic_move.  */\n+  if (flag_pic)\n+    return 1;\n+\n+  /* Even in the non-PIC case, we can accept immediate\n+     LARL operands here.  */\n+  if (TARGET_64BIT)\n+    return larl_operand (op, VOIDmode);\n+\n+  /* All remaining non-PIC symbolic constants are\n+     forced into the literal pool.  */\n+  return 0;\n+}\n+\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On S/390, legitimate addresses are:\n+\tbase\t\t\t\tl    reg,(base)\n+\tdisplacement\t\t\tl    reg,disp\n+\tbase + displacement\t\tl    reg,disp(base)\n+\tindex + base\t\t\tl    reg,(base,index),reg\n+\t(index + base) + displacement\tl    reg,disp(base,index)\n+\n+   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n+   convert common non-canonical forms to canonical form so that they will\n+   be recognized.  */\n+\n+\n+static int\n+s390_decompose_address (addr, out, strict)\n+     register rtx addr;\n+     struct s390_address *out;\n+     int strict;\n+{\n+  rtx base = NULL_RTX;\n+  rtx indx = NULL_RTX;\n+  rtx disp = NULL_RTX;\n+\n+  /* Decompose address into base + index + displacement.  */\n+\n+  if (GET_CODE (addr) == REG || GET_CODE (addr) == UNSPEC)\n+    base = addr;\n+\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+      enum rtx_code code0 = GET_CODE (op0);\n+      enum rtx_code code1 = GET_CODE (op1);\n+\n+      if (code0 == REG || code0 == UNSPEC)\n+\t{\n+\t  if (code1 == REG || code1 == UNSPEC)\n+\t    {\n+\t      indx = op0;\t/* index + base */\n+\t      base = op1;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      base = op0;\t/* base + displacement */\n+\t      disp = op1;\n+\t    }\n+\t}\n+\n+      else if (code0 == PLUS)\n+\t{\n+\t  indx = XEXP (op0, 0);\t/* index + base + disp */\n+\t  base = XEXP (op0, 1);\n+\t  disp = op1;\n+\t}\n+\n+      else\n+\t{\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  else\n+    disp = addr;\t\t/* displacement */\n+\n+\n+  /* Validate base register.  */\n+  if (base)\n+    {\n+      if (GET_CODE (base) == UNSPEC)\n+        {\n+          if (XVECLEN (base, 0) != 1 || XINT (base, 1) != 101)\n+\t      return FALSE;\n+\t  base = XVECEXP (base, 0, 0);\n+\t}\n+\n+      if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n+\t  return FALSE;\n+\n+      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n+\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n+\t  return FALSE;\n+    }\n+\n+  /* Validate index register.  */\n+  if (indx)\n+    {\n+      if (GET_CODE (indx) == UNSPEC)\n+        {\n+          if (XVECLEN (indx, 0) != 1 || XINT (indx, 1) != 101)\n+\t      return FALSE;\n+\t  indx = XVECEXP (indx, 0, 0);\n+\t}\n+\n+      if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n+\t  return FALSE;\n+\n+      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (indx))\n+\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (indx)))\n+\t  return FALSE;\n+    }\n+\n+  /* Validate displacement.  */\n+  if (disp)\n+    {\n+      /* Allow integer constant in range.  */\n+      if (GET_CODE (disp) == CONST_INT)\n+        {\n+          if (INTVAL (disp) < 0 || INTVAL (disp) >= 4096)\n+              return FALSE;\n+        }\n+\n+      /* In the small-PIC case, the linker converts @GOT12 \n+         offsets to possible displacements.  */\n+      else if (GET_CODE (disp) == CONST\n+               && GET_CODE (XEXP (disp, 0)) == UNSPEC\n+               && XINT (XEXP (disp, 0), 1) == 110)\n+        {\n+          if (flag_pic != 1)\n+            return FALSE;\n+        }\n+\n+      /* We can convert literal pool addresses to \n+         displacements by basing them off the base register.  */\n+      else\n+        {\n+          /* In some cases, we can accept an additional\n+             small constant offset.  Split these off here.  */\n+\n+          int offset = 0;\n+\n+          if (GET_CODE (disp) == CONST\n+              && GET_CODE (XEXP (disp, 0)) == PLUS\n+              && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT)\n+            {\n+              offset = INTVAL (XEXP (XEXP (disp, 0), 1));\n+              disp = XEXP (XEXP (disp, 0), 0);\n+            }\n+\n+          /* Now we must have a literal pool address.  */\n+          if (GET_CODE (disp) != SYMBOL_REF\n+              || !CONSTANT_POOL_ADDRESS_P (disp))\n+            return FALSE;\n+\n+          /* In 64-bit PIC mode we cannot accept symbolic \n+             constants in the constant pool.  */\n+          if (TARGET_64BIT && flag_pic\n+              && SYMBOLIC_CONST (get_pool_constant (disp)))\n+            return FALSE;\n+\n+          /* If we have an offset, make sure it does not\n+             exceed the size of the constant pool entry.  */\n+          if (offset && offset >= GET_MODE_SIZE (get_pool_mode (disp)))\n+            return FALSE;\n+\n+          /* Either base or index must be free to \n+             hold the base register.  */\n+          if (base && indx)\n+            return FALSE;\n+\n+          /* Convert the address.  */\n+          if (base)\n+            indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n+          else\n+            base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\n+          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp), 100);\n+          disp = gen_rtx_CONST (Pmode, disp);\n+\n+          if (offset)\n+            disp = plus_constant (disp, offset);\n+        }\n+    }\n+\n+  if (out)\n+    {\n+      out->base = base;\n+      out->indx = indx;\n+      out->disp = disp;\n+    }\n+\n+  return TRUE;\n+}\n+\n+int\n+legitimate_address_p (mode, addr, strict)\n+     enum machine_mode mode;\n+     register rtx addr;\n+     int strict;\n+{\n+  return s390_decompose_address (addr, NULL, strict);\n+}\n+\n+/* Return a legitimate reference for ORIG (an address) using the\n+   register REG.  If REG is 0, a new pseudo is generated.\n+\n+   There are two types of references that must be handled:\n+\n+   1. Global data references must load the address from the GOT, via\n+      the PIC reg.  An insn is emitted to do this load, and the reg is\n+      returned.\n+\n+   2. Static data references, constant pool addresses, and code labels\n+      compute the address as an offset from the GOT, whose base is in\n+      the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to\n+      differentiate them from global data objects.  The returned\n+      address is the PIC reg + an unspec constant.\n+\n+   GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n+   reg also appears in the address.  */\n+\n+rtx\n+legitimize_pic_address (orig, reg)\n+     rtx orig;\n+     rtx reg;\n+{\n+  rtx addr = orig;\n+  rtx new = orig;\n+  rtx base;\n+\n+  if (GET_CODE (addr) == LABEL_REF\n+      || (GET_CODE (addr) == SYMBOL_REF\n+\t  && (SYMBOL_REF_FLAG (addr) \n+              || CONSTANT_POOL_ADDRESS_P (addr))))\n+    {\n+      /* This is a local symbol.  */\n+      if (TARGET_64BIT)\n+        {\n+          /* Access local symbols PC-relative via LARL.  \n+             This is the same as in the non-PIC case, so it is \n+             handled automatically ... */\n+        }\n+      else\n+        {\n+          /* Access local symbols relative to the literal pool.  */\n+\n+          rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+          addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 100);\n+          addr = gen_rtx_CONST (SImode, addr);\n+          addr = force_const_mem (SImode, addr);\n+\t  emit_move_insn (temp, addr);\n+\n+          base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+          base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n+          new = gen_rtx_PLUS (Pmode, base, temp);\n+\n+          if (reg != 0)\n+            {\n+              emit_move_insn (reg, new);\n+              new = reg;\n+            }\n+        }\n+    }\n+  else if (GET_CODE (addr) == SYMBOL_REF)\n+    {\n+      if (reg == 0)\n+        reg = gen_reg_rtx (Pmode);\n+\n+      if (flag_pic == 1)\n+        {\n+          /* Assume GOT offset < 4k.  This is handled the same way\n+             in both 31- and 64-bit code (@GOT12).  */\n+\n+          current_function_uses_pic_offset_table = 1;\n+\n+          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 110);\n+          new = gen_rtx_CONST (Pmode, new);\n+          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+          new = gen_rtx_MEM (Pmode, new);\n+          RTX_UNCHANGING_P (new) = 1;\n+          emit_move_insn (reg, new);\n+          new = reg;\n+        }\n+      else if (TARGET_64BIT)\n+        {\n+          /* If the GOT offset might be >= 4k, we determine the position\n+             of the GOT entry via a PC-relative LARL (@GOTENT).  */\n+\n+          rtx temp = gen_reg_rtx (Pmode);\n+\n+          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 111);\n+          new = gen_rtx_CONST (Pmode, new);\n+          emit_move_insn (temp, new);\n+\n+          new = gen_rtx_MEM (Pmode, temp);\n+          RTX_UNCHANGING_P (new) = 1;\n+          emit_move_insn (reg, new);\n+          new = reg;\n+        }\n+      else\n+        {\n+          /* If the GOT offset might be >= 4k, we have to load it \n+             from the literal pool (@GOT).  */\n+\n+          rtx temp = gen_reg_rtx (Pmode);\n+\n+          current_function_uses_pic_offset_table = 1;\n+\n+          addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 112);\n+          addr = gen_rtx_CONST (SImode, addr);\n+          addr = force_const_mem (SImode, addr);\n+          emit_move_insn (temp, addr);\n+\n+          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+          new = gen_rtx_MEM (Pmode, new);\n+          RTX_UNCHANGING_P (new) = 1;\n+          emit_move_insn (reg, new);\n+          new = reg;\n+        }\n+    }      \n+  else\n+    {\n+      if (GET_CODE (addr) == CONST)\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  if (GET_CODE (addr) == UNSPEC)\n+\t    {\n+\t      if (XVECLEN (addr, 0) != 1)\n+                abort();\n+              switch (XINT (addr, 1))\n+                {\n+                  /* If someone moved an @GOT or lt-relative UNSPEC\n+                     out of the literal pool, force them back in.  */\n+                  case 100:\n+                  case 112:\n+                  case 114:\n+                    new = force_const_mem (SImode, orig);\n+                    if (reg != 0)\n+                      {\n+                        emit_move_insn (reg, new);\n+                        new = reg;\n+                      }\n+                    break;\n+\n+                  /* @GOTENT is OK as is.  */\n+                  case 111:\n+                    break;\n+\n+                  /* @PLT is OK as is on 64-bit, must be converted to\n+                     lt-relative PLT on 31-bit.  */\n+                  case 113:\n+                    if (!TARGET_64BIT)\n+                      {\n+                        rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+                        addr = XVECEXP (addr, 0, 0);\n+                        addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 114);\n+                        addr = gen_rtx_CONST (SImode, addr);\n+                        addr = force_const_mem (SImode, addr);\n+\t                emit_move_insn (temp, addr);\n+\n+                        base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+                        base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n+                        new = gen_rtx_PLUS (Pmode, base, temp);\n+\n+                        if (reg != 0)\n+                          {\n+                            emit_move_insn (reg, new);\n+                            new = reg;\n+                          }\n+                      }\n+                    break;\n+\n+                  /* Everything else cannot happen.  */\n+                  default:\n+                    abort ();\n+                }\n+\t    }\n+\t  else if (GET_CODE (addr) != PLUS)\n+\t    abort();\n+\t}\n+      if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n+\t  /* Check first to see if this is a constant offset \n+             from a local symbol reference.  */\n+\t  if ((GET_CODE (op0) == LABEL_REF\n+\t\t|| (GET_CODE (op0) == SYMBOL_REF\n+\t\t    && (SYMBOL_REF_FLAG (op0)\n+                        || CONSTANT_POOL_ADDRESS_P (op0))))\n+\t      && GET_CODE (op1) == CONST_INT)\n+\t    {\n+              if (TARGET_64BIT)\n+                {\n+                  if (INTVAL (op1) & 1)\n+                    {\n+                      /* LARL can't handle odd offsets, so emit a \n+                         pair of LARL and LA.  */\n+                      rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+                      if (INTVAL (op1) < 0 || INTVAL (op1) >= 4096)\n+                        {\n+                          int even = INTVAL (op1) - 1;\n+                          op0 = gen_rtx_PLUS (Pmode, op0, GEN_INT (even));\n+                          op1 = GEN_INT (1);\n+                        }\n+\n+                      emit_move_insn (temp, op0);\n+                      new = gen_rtx_PLUS (Pmode, temp, op1);\n+\n+                      if (reg != 0)\n+                        {\n+                          emit_move_insn (reg, new);\n+                          new = reg;\n+                        }\n+                    }\n+                  else\n+                    {\n+                      /* If the offset is even, we can just use LARL.\n+                         This will happen automatically.  */\n+                    }\n+                }\n+              else\n+                {\n+                  /* Access local symbols relative to the literal pool.  */\n+\n+                  rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+                  addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, op0), 100);\n+                  addr = gen_rtx_PLUS (SImode, addr, op1);\n+                  addr = gen_rtx_CONST (SImode, addr);\n+                  addr = force_const_mem (SImode, addr);\n+        \t  emit_move_insn (temp, addr);\n+\n+                  base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+                  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n+                  new = gen_rtx_PLUS (Pmode, base, temp);\n+\n+                  if (reg != 0)\n+                    {\n+                      emit_move_insn (reg, new);\n+                      new = reg;\n+                    }\n+                }\n+\t    }\n+\n+          /* Now, check whether it is an LT-relative symbol plus offset\n+             that was pulled out of the literal pool.  Force it back in.  */\n+\n+\t  else if (GET_CODE (op0) == UNSPEC\n+\t           && GET_CODE (op1) == CONST_INT)\n+            {\n+\t      if (XVECLEN (op0, 0) != 1)\n+                abort();\n+              if (XINT (op0, 1) != 100)\n+                abort();\n+\n+              new = force_const_mem (SImode, orig);\n+              if (reg != 0)\n+                {\n+                  emit_move_insn (reg, new);\n+                  new = reg;\n+                }\n+            }\n+\n+          /* Otherwise, compute the sum.  */\n+\t  else\n+\t    {\n+\t      base = legitimize_pic_address (XEXP (addr, 0), reg);\n+\t      new  = legitimize_pic_address (XEXP (addr, 1),\n+\t\t\t\t\t     base == reg ? NULL_RTX : reg);\n+\t      if (GET_CODE (new) == CONST_INT)\n+\t\tnew = plus_constant (base, INTVAL (new));\n+\t      else\n+\t\t{\n+\t\t  if (GET_CODE (new) == PLUS && CONSTANT_P (XEXP (new, 1)))\n+\t\t    {\n+\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new, 0));\n+\t\t      new = XEXP (new, 1);\n+\t\t    }\n+\t\t  new = gen_rtx_PLUS (Pmode, base, new);\n+\t\t}\n+\n+\t      if (GET_CODE (new) == CONST)\n+\t\tnew = XEXP (new, 0);\n+              new = force_operand (new, 0);\n+\t    }\n+\t}\n+    }\n+  return new;\n+}\n+\n+/* Emit insns to move operands[1] into operands[0].  */\n+\n+void\n+emit_pic_move (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+    operands[1] = force_reg (Pmode, operands[1]);\n+  else\n+    operands[1] = legitimize_pic_address (operands[1], temp);\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   When -fpic is used, special handling is needed for symbolic references.\n+   See comments by legitimize_pic_address for details.  */\n+\n+rtx\n+legitimize_address (x, oldx, mode)\n+     register rtx x;\n+     register rtx oldx ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n+{\n+  if (flag_pic && SYMBOLIC_CONST (x))\n+    return legitimize_pic_address (x, 0);\n+\n+  return x;\n+}\n+\n+\n+/* Output branch conditions.  */\n+\n+static void\n+output_branch_condition (FILE *file, rtx code)\n+{\n+  switch (GET_CODE (code)) \n+    {\n+    case EQ:\n+      fprintf (file, \"e\");\n+      break;\n+    case NE:\n+      fprintf (file, \"ne\");\n+      break;\n+    case GT:\n+    case GTU:\n+      fprintf (file, \"h\");\n+      break;\n+    case LT:\n+    case LTU:\n+      fprintf (file, \"l\");\n+      break;\n+    case GE:\n+    case GEU:\n+      fprintf (file, \"he\");\n+      break;\n+    case LE:\n+    case LEU:\n+      fprintf (file, \"le\");\n+      break;\n+    default:\n+      fatal_insn (\"Unknown CC code\", code);\n+    }\n+}\n+\n+static void\n+output_inverse_branch_condition (FILE *file, rtx code)\n+{\n+  switch (GET_CODE (code)) \n+    {\n+    case EQ:\n+      fprintf (file, \"ne\");\n+      break;\n+    case NE:\n+      fprintf (file, \"e\");\n+      break;\n+    case GT:\n+    case GTU:\n+      fprintf (file, \"nh\");\n+      break;\n+    case LT:\n+    case LTU:\n+      fprintf (file, \"nl\");\n+      break;\n+    case GE:\n+    case GEU:\n+      fprintf (file, \"nhe\");\n+      break;\n+    case LE:\n+    case LEU:\n+      fprintf (file, \"nle\");\n+      break;\n+    default:\n+      fatal_insn (\"Unknown CC code\", code);\n+    }\n+}\n+\n+/* Output a symbolic constant.  */\n+\n+void\n+s390_output_symbolic_const (FILE *file, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      s390_output_symbolic_const (file, XEXP (x, 0));\n+      break;\n+\n+    case PLUS:\n+      s390_output_symbolic_const (file, XEXP (x, 0));\n+      fprintf (file, \"+\");\n+      s390_output_symbolic_const (file, XEXP (x, 1));\n+      break;\n+\n+    case MINUS:\n+      s390_output_symbolic_const (file, XEXP (x, 0));\n+      fprintf (file, \"-\");\n+      s390_output_symbolic_const (file, XEXP (x, 1));\n+      break;\n+\n+    case CONST_INT:\n+      output_addr_const (file, x);\n+      break;\n+\n+    case LABEL_REF:\n+    case CODE_LABEL:\n+      output_addr_const (file, x);\n+      break;\n+\n+    case SYMBOL_REF:\n+      output_addr_const (file, x);\n+      if (CONSTANT_POOL_ADDRESS_P (x) && s390_pool_count != 0)\n+        fprintf (file, \"_%X\", s390_pool_count);\n+      break;\n+\n+    case UNSPEC:\n+      if (XVECLEN (x, 0) != 1)\n+        output_operand_lossage (\"invalid UNSPEC as operand (1)\");\n+      switch (XINT (x, 1))\n+        {\n+        case 100:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+          fprintf (file, \"-.LT%X_%X\", \n+                   s390_function_count, s390_pool_count);\n+\t  break;\n+\tcase 110:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@GOT12\");\n+\t  break;\n+\tcase 111:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@GOTENT\");\n+\t  break;\n+\tcase 112:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@GOT\");\n+\t  break;\n+\tcase 113:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@PLT\");\n+\t  break;\n+\tcase 114:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+          fprintf (file, \"@PLT-.LT%X_%X\",\n+\t           s390_function_count, s390_pool_count);\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid UNSPEC as operand (2)\");\n+\t  break;\n+        }\n+      break;\n+\n+    default:\n+      fatal_insn (\"UNKNOWN in s390_output_symbolic_const !?\", x);\n+      break;\n+    }\n+}\n+\n+/* Output an address operand.  */\n+\n+void\n+print_operand_address (FILE *file, rtx addr)\n+{\n+  struct s390_address ad;\n+\n+  if (!s390_decompose_address (addr, &ad, TRUE))\n+    output_operand_lossage (\"Cannot decompose address.\\n\");\n+ \n+  if (ad.disp)\n+    s390_output_symbolic_const (file, ad.disp);\n+  else\n+    fprintf (file, \"0\");\n+\n+  if (ad.base && ad.indx)\n+    fprintf (file, \"(%s,%s)\", reg_names[REGNO (ad.indx)],\n+                              reg_names[REGNO (ad.base)]);\n+  else if (ad.base)\n+    fprintf (file, \"(%s)\", reg_names[REGNO (ad.base)]);\n+}\n+\n+/* Output an operand.  */\n+\n+void\n+print_operand (FILE *file, rtx x, char code)\n+{\n+  switch (code)\n+    {\n+    case 'C':\n+      output_branch_condition (file, x);\n+      return;\n+\n+    case 'D':\n+      output_inverse_branch_condition (file, x);\n+      return;\n+\n+    case 'Y':\n+      fprintf (file, \".LT%X_%X-.\", s390_function_count, s390_pool_count);\n+      return;\n+\n+    case 'y':\n+      fprintf (file, \".LT%X_%X\", s390_function_count, s390_pool_count);\n+      return;\n+\n+    case 'O':\n+      {\n+        struct s390_address ad;\n+\n+        if (GET_CODE (x) != MEM\n+            || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n+            || ad.indx)\n+          abort();\n+\n+        if (ad.disp)\n+          s390_output_symbolic_const (file, ad.disp);\n+        else\n+          fprintf (file, \"0\");\n+      }\n+      return;\n+\n+    case 'R':\n+      {\n+        struct s390_address ad;\n+\n+        if (GET_CODE (x) != MEM\n+            || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n+            || ad.indx)\n+          abort();\n+\n+        if (ad.base)\n+          fprintf (file, \"%s\", reg_names[REGNO (ad.base)]);\n+        else\n+          fprintf (file, \"0\");\n+      }\n+      return;\n+\n+    case 'N':\n+      if (GET_CODE (x) == REG)\n+\tx = gen_rtx_REG (GET_MODE (x), REGNO (x) + 1);\n+      else if (GET_CODE (x) == MEM)\n+\tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 4));\n+      else\n+        abort();\n+      break;\n+\n+    case 'M':\n+      if (GET_CODE (x) == REG)\n+\tx = gen_rtx_REG (GET_MODE (x), REGNO (x) + 1);\n+      else if (GET_CODE (x) == MEM)\n+\tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 8));\n+      else\n+        abort();\n+      break;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      break;\n+\n+    case MEM:\n+      output_address (XEXP (x, 0));\n+      break;\n+\n+    case CONST:\n+    case CODE_LABEL:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      s390_output_symbolic_const (file, x);\n+      break;\n+\n+    case CONST_INT:\n+      if (code == 'b')\n+        fprintf (file, \"%d\", INTVAL (x) & 0xff);\n+      else if (code == 'X')\n+        fprintf (file, \"%d\", INTVAL (x) & 0xff);\n+      else if (code == 'x')\n+        fprintf (file, \"0x%x\", INTVAL (x) & 0xffff);\n+      else if (code == 'h')\n+        fprintf (file, \"%d\", (INTVAL (x) << 16) >> 16);\n+      else\n+        fprintf (file, \"%d\", INTVAL (x));\n+      break;\n+\n+    default:\n+      fatal_insn (\"UNKNOWN in print_operand !?\", x);\n+      break;\n+    }\n+}\n+\n+#define DEBUG_SCHED 0\n+\n+/* True, if register regno is used  for forming a memory address in\n+   a expression x.  */\n+\n+static int\n+reg_used_in_mem_p (int regno, rtx x)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  const char *fmt;\n+  \n+  if (code == MEM)\n+    {\n+      if (refers_to_regno_p (regno, regno+1,\n+\t\t\t     XEXP (x, 0), 0))\n+\treturn 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e'\n+\t  && reg_used_in_mem_p (regno, XEXP (x, i)))\n+\treturn 1;\n+      \n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (reg_used_in_mem_p (regno, XVECEXP (x, i, j)))\n+\t    return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Returns true, if expression dep_rtx sets a address register\n+   used by instruction insn to address memory.  */\n+\n+static int \n+addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n+{\n+  rtx target;\n+\n+  if (GET_CODE (dep_rtx) == SET)\n+    {\n+      target = SET_DEST (dep_rtx);\n+      \n+      if (GET_CODE (target) == REG)\n+\t{\n+\t  int regno = REGNO (target);\n+\n+\t  if (get_attr_type (insn) == TYPE_LA)\n+\t    return refers_to_regno_p (regno, regno+1,\n+\t\t\t\t      SET_SRC (PATTERN (insn)), 0);\n+\t  else if (get_attr_atype (insn) == ATYPE_MEM)\n+\t    return reg_used_in_mem_p (regno, PATTERN (insn));\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* Data dependencies are all handled without delay. But if an register\n+   is changed for a memory access, at least 4 cycle need to be put\n+   between the set of the register and the use. Because of that,\n+   the delays specified in the .md file needs to check and adjust\n+   to the right cost.  */\n+\n+int\n+s390_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost )\n+{\n+  rtx dep_rtx, dest, x;\n+  int i;\n+\n+  /* If the dependence is an anti-dependence, there is no cost.  For an\n+     output dependence, there is sometimes a cost, but it doesn't seem\n+     worth handling those few cases.  */\n+\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\n+\n+  /* If we can't recognize the insns, we can't really do anything.  */\n+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n+    return cost;\n+\n+  /* If cost equal 1 nothing needs to be checked. */\n+\n+  if (cost == 1)\n+    {\n+      return cost;\n+    }\n+\n+  dep_rtx = PATTERN (dep_insn);\n+\n+  if (GET_CODE (dep_rtx) == SET)\n+    {\n+      if (addr_generation_dependency_p (dep_rtx, insn))\n+\t{\n+\t  if (DEBUG_SCHED)\n+\t    {\n+\t      fprintf (stderr, \"\\n\\nAddress dependency detected: cost %d\\n\",\n+\t\t       cost);\n+\t      debug_rtx (dep_insn);\n+\t      debug_rtx (insn);\n+\t    }\n+\t  return cost;\n+\t}\n+    }\n+\n+  else if (GET_CODE (dep_rtx) == PARALLEL)\n+    {\n+      for (i = 0; i < XVECLEN (dep_rtx, 0); i++)\n+\t{\n+\t  if (addr_generation_dependency_p (XVECEXP (dep_rtx, 0, i),\n+\t\t\t\t\t    insn))\n+\t    {\n+\t      if (DEBUG_SCHED)\n+\t\t{\n+\t\t  fprintf (stderr, \"\\n\\nAddress dependency detected: cost %d\\n\"\n+\t\t\t   ,cost);\n+\t\t  debug_rtx (dep_insn);\n+\t\t  debug_rtx (insn);\n+\t\t}\n+\t      return cost;\n+\t    }\n+\t}\n+    }\n+\n+  /* default cost.  */\n+  return 1;\n+}\n+\n+/* Pool concept for Linux 390:\n+   - Function prologue saves used register \n+   - literal pool is dumped in prologue and  jump across with bras\n+   - If function has more than 4 k literals, at about every \n+     S390_CHUNK_MAX offset in the function a literal pool will be\n+     dumped\n+     - in this case, a branch from one chunk to other chunk needs\n+       a reload of base register at the code label branched to.  */\n+\n+\n+\n+rtx s390_pool_start_insn = NULL_RTX;\n+\n+/* Count of actual pool in function (-1 -> before function).  */\n+\n+int s390_pool_count = -1;\n+\n+\n+static int pool_stop_uid;\n+\n+\n+void \n+s390_asm_output_pool_prologue (FILE *file, char *fname, tree fndecl, int size)\n+{\n+\n+  if (s390_pool_count>0) {\n+    /*\n+     * We are in an internal pool, branch over\n+     */\n+    if (TARGET_64BIT)\n+      {\n+\tfprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", \n+\t\t reg_names[BASE_REGISTER],\n+\t\t s390_function_count, s390_pool_count);\n+\treadonly_data_section();\n+\tASM_OUTPUT_ALIGN (file, floor_log2 (3));\n+\tfprintf (file, \".LT%X_%X:\\t# Pool %d\\n\",\n+\t\t s390_function_count, s390_pool_count, s390_pool_count);\n+      }\n+    else\n+    fprintf (file,\"\\t.align 4\\n\\tbras\\t%s,0f\\n.LT%X_%X:\\t# Pool %d \\n\",\n+\t     reg_names[BASE_REGISTER],\n+\t     s390_function_count, s390_pool_count, s390_pool_count);\n+  }\n+  if (!TARGET_64BIT)\n+    function_section (fndecl);\n+}\n+\n+/* Check if other addr is in different chunk than my addr,\n+   return symbol_ref to other pool in that case.  */\n+\n+\n+static int\n+other_chunk (int *ltorg, int my_addr, int other_addr)\n+{\n+  int ad, i=0, j=0;\n+\n+  while ((ad = ltorg[i++])) {\n+    if (INSN_ADDRESSES (ad) >= my_addr)\n+      break;\n+  }\n+\n+  while ((ad = ltorg[j++])) {\n+    if (INSN_ADDRESSES (ad) > other_addr)\n+      break;\n+  }\n+  \n+  if (i==j)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Check, if other label is to far away to branch relative.  */\n+\n+static int \n+far_away (int my_addr, int other_addr)\n+{\n+  /* In 64 bit mode we can jump +- 4GB.  */\n+  if (TARGET_64BIT)\n+    return 0;\n+  if (abs (my_addr - other_addr) > S390_REL_MAX)\n+    return 1;\n+  return 0;\n+}\n+\n+\n+\n+static rtx \n+check_and_change_labels (rtx insn, int *ltorg_uids)\n+{\n+  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  rtx target, jump;\n+  rtx pattern, tmp, body, label1;\n+  int addr0, addr1;\n+\n+  if (GET_CODE (insn) != JUMP_INSN) \n+    return insn;\n+\n+  pattern = PATTERN (insn);\n+  \n+  addr0 = INSN_ADDRESSES (INSN_UID (insn));\n+  if (GET_CODE (pattern) == SET) \n+    {\n+      body = XEXP (pattern, 1);\n+      if (GET_CODE (body) == LABEL_REF) \n+\t{\n+\t  addr1 = INSN_ADDRESSES (INSN_UID (XEXP (body, 0)));\n+\t  \n+\t  if (other_chunk (ltorg_uids, addr0, addr1)) \n+\t    {\n+\t      SYMBOL_REF_USED (XEXP (body, 0)) = 1;\n+\t    } \n+\t  if (far_away (addr0, addr1)) \n+\t    {\n+\t      if (flag_pic) \n+\t\t{\n+\t\t  target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, body), 100);\n+\t\t  target = gen_rtx_CONST (SImode, target);\n+\t\t  target = force_const_mem (SImode, target);\n+\t\t  jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t\t  jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  target = force_const_mem (Pmode, body);\n+\t\t  jump = temp_reg;\n+\t\t}\n+\t      \n+\t      emit_insn_before (gen_movsi (temp_reg, target), insn);\n+\t      tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t      remove_insn (insn);\n+\t      INSN_ADDRESSES_NEW (tmp, -1);\n+\t      return tmp;\n+\t    }\n+\t} \n+      else if (GET_CODE (body) == IF_THEN_ELSE) \n+\t{\n+\t  if (GET_CODE (XEXP (body, 1)) == LABEL_REF) \n+\t    {\n+\t      addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XEXP (body, 1), 0)));\n+\t      \n+\t      if (other_chunk (ltorg_uids, addr0, addr1)) \n+\t\t{\n+\t\t  SYMBOL_REF_USED (XEXP (XEXP (body, 1), 0)) = 1;\n+\t\t} \n+\t      \n+\t      if (far_away (addr0, addr1)) \n+\t\t{\n+\t\t  if (flag_pic) \n+\t\t    {\n+\t\t      target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, XEXP (body, 1)), 100);\n+\t\t      target = gen_rtx_CONST (SImode, target);\n+\t\t      target = force_const_mem (SImode, target);\n+\t\t      jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t\t      jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n+\t\t    } \n+\t\t  else \n+\t\t    {\n+\t\t      target = force_const_mem (Pmode, XEXP (body, 1));\n+\t\t      jump = temp_reg;\n+\t\t    }\n+\t\t  \n+\t\t  label1 = gen_label_rtx ();\n+\t\t  emit_jump_insn_before (gen_icjump (label1, XEXP (body, 0)), insn);\n+\t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n+\t\t  tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n+\t\t  remove_insn (insn);\n+\t\t  return tmp;\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (body, 2)) == LABEL_REF) \n+\t    {\n+\t      addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XEXP (body, 2), 0)));\n+\t      \n+\t      if (other_chunk (ltorg_uids, addr0, addr1)) \n+\t\t{\n+\t\t  SYMBOL_REF_USED (XEXP (XEXP (body, 2), 0)) = 1;\n+\t\t} \n+\t      \n+\t      if (far_away (addr0, addr1)) \n+\t\t{\n+\t\t  if (flag_pic) \n+\t\t    {\n+\t\t      target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, XEXP (body, 2)), 100);\n+\t\t      target = gen_rtx_CONST (SImode, target);\n+\t\t      target = force_const_mem (SImode, target);\n+\t\t      jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t\t      jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n+\t\t    } \n+\t\t  else \n+\t\t    {\n+\t\t      target = force_const_mem (Pmode, XEXP (body, 2));\n+\t\t      jump = temp_reg;\n+\t\t    }\n+\t\t  \n+\t\t  label1 = gen_label_rtx ();\n+\t\t  emit_jump_insn_before (gen_cjump (label1, XEXP (body, 0)), insn);\n+\t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n+\t\t  tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n+\t\t  remove_insn (insn);\n+\t\t  return tmp;\n+\t\t}\n+\t    }\n+\t}\n+    } \n+  else if (GET_CODE (pattern) == ADDR_VEC || \n+\t   GET_CODE (pattern) == ADDR_DIFF_VEC) \n+    {\n+      int i, diff_vec_p = GET_CODE (pattern) == ADDR_DIFF_VEC;\n+      int len = XVECLEN (pattern, diff_vec_p);\n+      \n+      for (i = 0; i < len; i++) \n+\t{\n+\t  addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XVECEXP (pattern, diff_vec_p, i), 0)));\n+\t  if (other_chunk (ltorg_uids, addr0, addr1)) \n+\t    {\n+\t      SYMBOL_REF_USED (XEXP (XVECEXP (pattern, diff_vec_p, i), 0)) = 1;\n+\t    } \n+\t}\n+    }\n+  return insn;\n+}\n+\n+static int chunk_max=0;\n+\n+void\n+s390_final_chunkify (int chunkify)\n+{\n+  rtx insn, ninsn, tmp;\n+  int addr, naddr, uids;\n+\n+  const char *asms;\n+\n+  int size = insn_current_address;\n+\n+  int *ltorg_uids;\n+  int max_ltorg=0;\n+\n+  ltorg_uids = alloca (size / 1024 + 1024);\n+  memset (ltorg_uids, 0, size / 1024 + 1024);\n+\n+  if (chunkify == 1) \n+    {\n+      chunk_max = size * 2048 / get_pool_size ();\n+      chunk_max = chunk_max > S390_CHUNK_MAX \n+\t? S390_CHUNK_MAX : chunk_max;\n+    } \n+  \n+  for (insn=get_insns (); insn;insn = next_real_insn (insn)) \n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      \n+      addr = INSN_ADDRESSES (INSN_UID (insn));\n+      if ((ninsn = next_real_insn (insn))) \n+\t{\n+\t  naddr = INSN_ADDRESSES (INSN_UID (ninsn));\n+\t}\n+      \n+      if (chunkify && (addr / chunk_max != naddr / chunk_max)) \n+\t{\n+\t  for (tmp = insn; tmp; tmp = NEXT_INSN (tmp)) \n+\t    {\n+\t      if (GET_CODE (tmp) == CODE_LABEL && \n+\t\t  GET_CODE (NEXT_INSN (tmp)) != JUMP_INSN) \n+\t\t{\n+\t\t  ltorg_uids[max_ltorg++] = INSN_UID (prev_real_insn (tmp));\n+\t\t  break;\n+\t\t} \n+\t      if (GET_CODE (tmp) == CALL_INSN) \n+\t\t{\n+\t\t  ltorg_uids[max_ltorg++] = INSN_UID (tmp);\n+\t\t  break;\n+\t\t} \n+\t      if (INSN_ADDRESSES (INSN_UID (tmp)) - naddr > S390_CHUNK_OV) \n+\t\t{\n+\t\t  debug_rtx (insn);\n+\t\t  debug_rtx (tmp);\n+\t\t  fprintf (stderr, \"s390 multiple literalpool support:\"\n+\t\t\t   \"\\n No code label between this insn %X %X\",\n+\t\t\t   naddr, INSN_ADDRESSES (INSN_UID (tmp)));\n+\t\t  abort();\n+\t\t}\n+\t    }\n+\t  if (tmp == NULL) \n+\t    {\n+\t      warning (\"no code label found\");\n+\t    }\n+\t} \n+      else if (GET_CODE (PATTERN (insn)) == ASM_INPUT) \n+\t{\n+\t  asms = XSTR (PATTERN (insn),0);\n+\t  \n+\t  if ((memcmp (asms,\".section\",8) == 0) ||\n+\t      (memcmp (asms,\".text\",5) == 0)    ||\n+\t      (memcmp (asms,\"\\t.section\",9) == 0) ||\n+\t      (memcmp (asms,\"\\t.text\",6) == 0))  {\n+\t    ltorg_uids[max_ltorg++] = INSN_UID (insn);\n+\t    INSN_ADDRESSES_NEW (emit_insn_before (gen_rtx_ASM_INPUT (VOIDmode,\n+\t\t\t\t\t   \".align 4\"), insn), -1);\n+\t  }\n+\t}\n+    }\n+  ltorg_uids[max_ltorg] = 0;\n+  for (insn=get_insns (),uids=0; insn;insn = next_real_insn (insn)) \n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      if (INSN_UID (insn) == ltorg_uids[uids]) \n+\t{\n+\t  INSN_ADDRESSES_NEW (emit_insn_after (gen_ltorg (\n+\t\t\t      gen_rtx_CONST_INT (Pmode, ltorg_uids[++uids])),\n+\t\t\t\t\t       insn), -1);\n+\t} \n+      if (GET_CODE (insn) == JUMP_INSN) \n+\t{\n+\t  insn = check_and_change_labels (insn, ltorg_uids);\n+\t}\n+    }\n+  if (chunkify) \n+    {\n+    for (insn=get_insns (); insn;insn = next_insn (insn)) \n+      {\n+      if (GET_CODE (insn) == CODE_LABEL) \n+\t{\n+\tif (SYMBOL_REF_USED (insn)) \n+\t  {\n+\t    INSN_ADDRESSES_NEW (emit_insn_after (gen_reload_base (\n+\t\t\t\t\t\t\t\t  gen_rtx_LABEL_REF (Pmode, XEXP (insn, 0))), insn), -1);\n+\t  }\n+\t}\n+      }\n+    }\n+  pool_stop_uid = ltorg_uids[0];\n+}\n+\n+/* Return 1 if next literal pool is reached (check for ltorg insn)\n+   maybe should use unspec insn.  */\n+\n+\n+int \n+s390_stop_dump_lit_p (rtx insn)\n+{\n+  rtx body=PATTERN (insn);\n+  if (GET_CODE (body) == PARALLEL\n+      && GET_CODE (XVECEXP (body, 0, 0)) == SET\n+      && GET_CODE (XVECEXP (body, 0, 1)) == USE\n+      && GET_CODE (XEXP ((XVECEXP (body, 0, 1)),0)) == CONST_INT\n+      && GET_CODE (SET_DEST (XVECEXP (body, 0, 0))) == REG\n+      && REGNO (SET_DEST (XVECEXP (body, 0, 0))) == BASE_REGISTER\n+      && SET_SRC (XVECEXP (body, 0, 0)) == pc_rtx) {\n+    return 1;\n+  }\n+  else\n+    return 0;   \n+}\n+\n+void\n+s390_dump_literal_pool (rtx act_insn, rtx stop)\n+{\n+  s390_pool_start_insn = act_insn;\n+  pool_stop_uid = INTVAL (stop);\n+  s390_pool_count++;\n+  output_constant_pool (current_function_name, current_function_decl);\n+  function_section (current_function_decl);\n+}\n+\n+\n+#ifdef DWARF2_DEBUGGING_INFO\n+extern char *dwarf2out_cfi_label PARAMS ((void));\n+#endif\n+\n+/* Flag set in prologue, used in epilog to know\n+  if stack is allocated or not.  */\n+\n+static int leaf_function_flag;\n+rtx s390_got_label;\n+rtx s390_profile[10];\n+int s390_nr_constants;\n+\n+/* Returns 1 if floating point registers need to be saved.  */\n+\n+static int save_fprs_p()\n+{\n+  int i;\n+  if (!TARGET_64BIT)\n+    return 0;\n+  for (i=24; i<=31; i++) \n+    {\n+      if (regs_ever_live[i] == 1)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Current function is a leaf function, without automatics,\n+   alloca or vararg stuff.  */\n+\n+static int\n+cur_is_leaf_function ()\n+{\n+  int lsize =  get_frame_size () + current_function_outgoing_args_size\n+    + save_fprs_p () * 64;\n+\n+  if (leaf_function_p () && ((lsize) == 0) &&\n+      ! (current_function_calls_alloca) &&\n+      ! (current_function_stdarg) && ! (current_function_varargs))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Calculate offset between argument pointer and frame pointer \n+   initialy after prologue.  */\n+\n+int s390_arg_frame_offset ()\n+{\n+  int lsize =  get_frame_size () + current_function_outgoing_args_size\n+    + save_fprs_p () * 64;\n+\n+  if (cur_is_leaf_function ())\n+    return STACK_POINTER_OFFSET;\n+  else\n+    return 2*STACK_POINTER_OFFSET + lsize;\n+}\n+\n+/* Save Floating point register on current stack.  */\n+\n+static int save_fprs(FILE *file, long offset, int fp)\n+{\n+  int i;\n+\n+  if (!TARGET_64BIT)\n+    return 0;\n+\n+  for (i=24; i<=31; i++) \n+    {\n+      if (regs_ever_live[i] == 1)\n+\t{\n+\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", reg_names[i], \n+\t\t   (i-24) * 8 + offset, reg_names[fp]); \n+\t}\n+    }\n+}\n+\n+/* Restore Floating point register on current stack.  */\n+\n+static int restore_fprs(FILE *file, long offset, int fp)\n+{\n+  int i;\n+\n+  if (!TARGET_64BIT)\n+    return 0;\n+\n+  if (!save_fprs_p())\n+    return 0;\n+\n+  if (offset < 0) \n+    {\n+      fp = 1;\n+      offset = 0;\n+      fprintf (file, \"\\tlgr\\t%s,%s\\n\", reg_names[fp], \n+\t       reg_names[STACK_POINTER_REGNUM]); \n+      fprintf (file, \"\\taghi\\t%s,-64\\n\", reg_names[fp]); \n+    }\n+\n+  for (i=24; i<=31; i++) \n+    {\n+      if (regs_ever_live[i] == 1)\n+\t{\n+\t  fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", reg_names[i], \n+\t\t   (i-24) * 8 + offset, reg_names[fp]); \n+\t}\n+    }\n+}\n+\n+/* Output constant pool in function prologue (31 bit) or in readonly section.  */ \n+\n+static int\n+s390_output_constant_pool(FILE* file)\n+{\n+  /* Output constant pool.  */\n+  if (s390_nr_constants || regs_ever_live[BASE_REGISTER])\n+    {\n+      s390_pool_count = 0;\n+      if (TARGET_64BIT)\n+\t{\n+\t  fprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", reg_names[BASE_REGISTER],\n+\t\t   s390_function_count, s390_pool_count);\n+\t  readonly_data_section();\n+\t  ASM_OUTPUT_ALIGN (file, floor_log2 (3));\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tbras\\t%s,.LTN%X_%X\\n\", reg_names[BASE_REGISTER],\n+\t\t   s390_function_count, s390_pool_count);\n+\t}\n+      fprintf (file, \".LT%X_%X:\\n\", s390_function_count, s390_pool_count);\n+      output_constant_pool (current_function_name, current_function_decl);\n+      fprintf (file, \".LTN%X_%X:\\n\", s390_function_count,\n+\t       s390_pool_count);\n+      if (TARGET_64BIT)\n+\tfunction_section(current_function_decl);\n+      \n+      regs_ever_live[BASE_REGISTER] = 1;\n+    }\n+}\n+\n+\n+/* This function generates the assembly code for function entry.  */\n+\n+static rtx\n+s390_force_const_mem_late (rtx cst)\n+{\n+  cst = force_const_mem (Pmode, cst);\n+\n+  s390_nr_constants++;\n+  regs_ever_live[BASE_REGISTER] = 1;\n+\n+  emit_insn_before (gen_rtx (USE, Pmode, cst), get_insns ());\n+\n+  return cst;\n+}\n+\n+static rtx\n+s390_force_const_mem_symbol (char *name, int func, int global)\n+{\n+  rtx symbol;\n+\n+  if (TARGET_64BIT)\n+    abort ();\n+\n+  symbol = gen_rtx (SYMBOL_REF, Pmode, name);\n+  SYMBOL_REF_FLAG (symbol) = !global;\n+\n+  if (flag_pic)\n+    {\n+      if (global)\n+        {\n+          current_function_uses_pic_offset_table = 1;\n+          symbol = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, symbol), func? 114 : 112);\n+          symbol = gen_rtx_CONST (VOIDmode, symbol);\n+        }\n+      else\n+        {\n+          symbol = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, symbol), 100);\n+          symbol = gen_rtx_CONST (VOIDmode, symbol);\n+        }\n+    }\n+\n+  return s390_force_const_mem_late (symbol);\n+}\n+\n+/* This function generates the assembly code for function entry.  */\n+\n+void\n+s390_function_prologue (FILE *file, HOST_WIDE_INT lsize)\n+{\n+  extern int profile_label_no;\n+  int i, j;\n+  long frame_size;\n+  rtx stack_label = 0, got_label = 0, tmp;\n+  char *l;\n+  char b64[2] = \" \";\n+  b64[0] = TARGET_64BIT ? 'g' : '\\0';\n+\n+  /* Check for too large size of local variables */\n+\n+  if (lsize > 0x7fff0000)\n+    fatal_error (\"Total size of local variables exceeds architecture limit.\");\n+\n+  /* Profile code (-p, -a, -ax needs some literals).  */\n+\n+  if (profile_block_flag && !TARGET_64BIT)\n+    {\n+      s390_profile[0] = s390_force_const_mem_symbol (\"__bb_init_func\", 1, 1);\n+      s390_profile[1] = s390_force_const_mem_symbol (\"__bb_init_trace_func\", 1, 1);\n+      s390_profile[2] = s390_force_const_mem_symbol (\"__bb_trace_func\", 1, 1);\n+      s390_profile[3] = s390_force_const_mem_symbol (\"__bb_trace_ret\", 1, 1);\n+      s390_profile[5] = s390_force_const_mem_symbol (\"__bb\", 0, 1);\n+      s390_profile[6] = s390_force_const_mem_symbol (\".LPBX0\", 0, 0);\n+      s390_profile[7] = s390_force_const_mem_symbol (\".LPBX2\", 0, 0);\n+    }\n+\n+  if (profile_flag && !TARGET_64BIT)\n+    {\n+      static char label[128];\n+      sprintf (label, \"%sP%d\", LPREFIX, profile_label_no);\n+\n+      s390_profile[4] = s390_force_const_mem_symbol (\"_mcount\", 1, 1);\n+      s390_profile[9] = s390_force_const_mem_symbol (label, 0, 0);\n+    }\n+\n+  if (get_pool_size () > S390_POOL_MAX)\n+    s390_final_chunkify (1);\n+  else\n+    s390_final_chunkify (0);\n+\n+  if (current_function_uses_pic_offset_table)\n+    regs_ever_live[12] = 1;\n+\n+  if (!TARGET_64BIT && current_function_uses_pic_offset_table)\n+    {\n+      got_label = s390_force_const_mem_symbol (\"_GLOBAL_OFFSET_TABLE_\", 0, 0);\n+    }\n+\n+  if ((frame_size = \n+       STARTING_FRAME_OFFSET + lsize + save_fprs_p () * 64) > 0x7fff)\n+    {\n+      stack_label = s390_force_const_mem_late (GEN_INT (frame_size));\n+    }\n+\n+  if (!optimize)\n+    {\n+      /* Stupid register allocation is stupid ...\n+         It does not always recognize the base register is used. */\n+      \n+      regs_ever_live[BASE_REGISTER] = 1;\n+    }\n+\n+ if (cur_is_leaf_function ())\n+   {\n+      leaf_function_flag = 1;\n+      fprintf (file, \"%s\\tleaf function\\n\", ASM_COMMENT_START);\n+      fprintf (file, \"%s\\thas varargs             %d\\n\", ASM_COMMENT_START,\n+\t       current_function_stdarg);\n+      fprintf (file, \"%s\\tincoming args (stack)   %d\\n\", ASM_COMMENT_START,\n+\t       current_function_args_size);\n+      fprintf (file, \"%s\\tfunction length         %d\\n\", ASM_COMMENT_START,\n+\t       insn_current_address);\n+      fprintf (file, \"%s\\tregister live           \", ASM_COMMENT_START);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tfprintf (file, \"%d\", regs_ever_live[i]);\n+      fputc   ('\\n',file);\n+      \n+      /* Save gprs 6 - 15 and fprs 4 and 6.  */\n+      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\n+      if (s390_nr_constants || regs_ever_live[13] || i != 13)\n+\t{\n+\t  fprintf (file, \"\\tstm%s\\t%s,%s,%d(%s)\\n\", \n+                         b64, reg_names[i], reg_names[13],\n+                         i * UNITS_PER_WORD,\n+\t\t         reg_names[STACK_POINTER_REGNUM]);\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+\t  if (dwarf2out_do_frame ())\n+\t    {\n+\t      l = dwarf2out_cfi_label ();\n+\t      dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, \n+\t\t\t\t STACK_POINTER_OFFSET);\n+\t      for (j = i; j <= 14; j++)\n+\t\tdwarf2out_reg_save (l, j, (TARGET_64BIT ? (j-20) : (j-24))\n+\t\t\t\t    * UNITS_PER_WORD);\n+\t      if (regs_ever_live[18])\n+\t\tdwarf2out_reg_save (l, 18, -16);\n+\t      if (regs_ever_live[19])\n+\t\tdwarf2out_reg_save (l, 19, -8);\n+\t    }\n+#endif\n+\t}\n+\n+      s390_output_constant_pool (file);\n+\n+      /* Save fprs.  */\n+\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (regs_ever_live[18])\n+\t    fprintf (file, \"\\tstd\\t4,80(%s)\\n\", reg_names[STACK_POINTER_REGNUM]);\n+\t  if (regs_ever_live[19])\n+\t    fprintf (file, \"\\tstd\\t6,88(%s)\\n\", reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+    }\n+  else\n+    {\t\t\t\t/* No leaf function.  */\n+      fprintf (file, \"%s\\tleaf function           %d\\n\", ASM_COMMENT_START,\n+\t       leaf_function_p ());\n+      fprintf (file, \"%s\\tautomatics              %d\\n\", ASM_COMMENT_START,\n+\t       lsize);\n+      fprintf (file, \"%s\\toutgoing args           %d\\n\", ASM_COMMENT_START,\n+\t       current_function_outgoing_args_size);\n+      fprintf (file, \"%s\\tneed frame pointer      %d\\n\", ASM_COMMENT_START,\n+\t       frame_pointer_needed);\n+      fprintf (file, \"%s\\tcall alloca             %d\\n\", ASM_COMMENT_START,\n+\t       current_function_calls_alloca);\n+      fprintf (file, \"%s\\thas varargs             %d\\n\", ASM_COMMENT_START,\n+\t       current_function_stdarg || current_function_varargs);\n+      fprintf (file, \"%s\\tincoming args (stack)   %d\\n\", ASM_COMMENT_START,\n+\t       current_function_args_size);\n+      fprintf (file, \"%s\\tfunction length         %d\\n\", ASM_COMMENT_START,\n+\t       insn_current_address);\n+      fprintf (file, \"%s\\tregister live           \", ASM_COMMENT_START);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tfprintf (file, \"%d\", regs_ever_live[i]);\n+      fputc   ('\\n',file);\n+\n+      /* Save gprs 6 - 15 and fprs 4 and 6.  */\n+      \n+      if (current_function_stdarg || current_function_varargs)\n+\t{\n+\t  i = 2;\n+\t}\n+      else\n+\t{\n+\t  for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\t}\n+\n+      fprintf (file, \"\\tstm%s\\t%s,%s,%d(%s)\\n\", \n+                     b64, reg_names[i], reg_names[15], i * UNITS_PER_WORD,\n+\t             reg_names[STACK_POINTER_REGNUM]);\n+\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+      if (dwarf2out_do_frame ())\n+\t{\n+\t  l = dwarf2out_cfi_label ();\n+\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, STACK_POINTER_OFFSET);\n+\t  for (j = i; j <= 15; j++)\n+\t    dwarf2out_reg_save (l, j, (TARGET_64BIT ? (j-20) : (j-24)) *\n+\t\t\t\tUNITS_PER_WORD);\n+\t  if (regs_ever_live[18])\n+\t    dwarf2out_reg_save (l, 18, -16);\n+\t  if (regs_ever_live[19])\n+\t    dwarf2out_reg_save (l, 19, -8);\n+\t}\n+#endif\n+\n+      s390_output_constant_pool (file);\n+\n+      /* Save fprs.  */\n+\n+      if (current_function_stdarg || current_function_varargs)\n+\t{\n+\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n+\t\t   reg_names[16],\n+\t\t   STACK_POINTER_OFFSET-32,\n+\t\t   reg_names[STACK_POINTER_REGNUM]);\n+\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\",\n+\t\t   reg_names[17],\n+\t\t   STACK_POINTER_OFFSET-24,\n+\t\t   reg_names[STACK_POINTER_REGNUM]);\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n+\t\t       reg_names[18],\n+\t\t       STACK_POINTER_OFFSET-16,\n+\t\t       reg_names[STACK_POINTER_REGNUM]);\n+\t      fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n+\t\t       reg_names[19],\n+\t\t       STACK_POINTER_OFFSET-8,\n+\t\t       reg_names[STACK_POINTER_REGNUM]);\n+\t    }\n+\t}\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (regs_ever_live[18])\n+\t    fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n+\t\t     reg_names[18],\n+\t\t     STACK_POINTER_OFFSET-16,\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t  if (regs_ever_live[19])\n+\t    fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\",\n+\t\t     reg_names[19],\n+\t\t     STACK_POINTER_OFFSET-8,\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+\n+      \n+      if (save_fprs_p() && frame_size > 4095) \n+\t{\n+\t  int fp = 1;\n+\t  int offset = 0;\n+\t  fprintf (file, \"\\tlgr\\t%s,%s\\n\", reg_names[fp], \n+\t\t   reg_names[STACK_POINTER_REGNUM]); \n+\t  fprintf (file, \"\\taghi\\t%s,-64\\n\", reg_names[fp]);\n+\t  save_fprs(file, 0, fp);\n+\t}\n+\n+      /* Decrement stack.  */\n+\n+      if (TARGET_BACKCHAIN || (STARTING_FRAME_OFFSET +\n+\t\t\t       lsize + STACK_POINTER_OFFSET > 4095\n+\t\t\t       || frame_pointer_needed\n+\t\t\t       || current_function_calls_alloca))\n+\t{\n+\n+\t  fprintf (file, \"\\tl%sr\\t%s,%s\\n\", b64, \n+\t\t\t reg_names[1], reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+\n+      if (stack_label)\n+\t{\n+\t  rtx operands[2];\n+\n+\t  operands[0] = stack_pointer_rtx;\n+\t  operands[1] = stack_label;\n+\t  if (TARGET_64BIT)\n+\t    output_asm_insn (\"sg\\t%0,%1\", operands);\n+\t  else\n+\t    output_asm_insn (\"s\\t%0,%1\", operands);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\ta%shi\\t%s,-%d\\n\",b64, \n+\t\t   reg_names[STACK_POINTER_REGNUM], frame_size);\n+\t}\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+      if (dwarf2out_do_frame ())\n+\t{\n+\t  if (frame_pointer_needed)\n+\t    dwarf2out_def_cfa (\"\", HARD_FRAME_POINTER_REGNUM,\n+\t\t\t       STACK_POINTER_OFFSET+frame_size);\n+\t  else\n+\t    dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM,\n+\t\t\t       STACK_POINTER_OFFSET+frame_size);\n+\t}\n+#endif\n+\n+\n+      /* Generate backchain.  */\n+\n+      if (TARGET_BACKCHAIN || (STARTING_FRAME_OFFSET + \n+\t\t\t       lsize + STACK_POINTER_OFFSET > 4095\n+\t\t\t       || frame_pointer_needed\n+\t\t\t       || current_function_calls_alloca))\n+\t{\n+\t  fprintf (file, \"\\tst%s\\t%s,0(%s)\\n\", \n+                         b64, reg_names[1], reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (file, \"\\tl%sr\\t%s,%s\\n\", b64, \n+                     reg_names[FRAME_POINTER_REGNUM], \n+                     reg_names[STACK_POINTER_REGNUM]);\n+    }\n+\n+  /* Load GOT if used and emit use insn that optimizer does not\n+     erase literal pool entry.  */\n+\n+  if (current_function_uses_pic_offset_table)\n+    {\n+      rtx operands[3];\n+      if (TARGET_64BIT)\n+\t{\n+\t  fprintf (file, \"\\tlarl\\t%s,_GLOBAL_OFFSET_TABLE_\\n\",\n+\t\t\t reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t}\n+      else\n+\t{\n+\t  operands[0] = gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM);\n+\t  operands[1] = got_label;\n+\t  operands[2] = gen_rtx (REG, Pmode, BASE_REGISTER);\n+\t  output_asm_insn (\"l\\t%0,%1\\n\\tar\\t%0,%2\", operands);\n+\t}\n+    }\n+  /* Save FPRs below save area.  */\n+\n+  if (frame_size <= 4095)\n+    save_fprs (file, frame_size - 64, STACK_POINTER_REGNUM);\n+\n+  return;\n+}\n+\n+/* This function generates the assembly code for function exit.  */\n+\n+void\n+s390_function_epilogue (FILE *file, HOST_WIDE_INT lsize)\n+{\n+/* Register is call clobbered and not used for eh or return.  */\n+#define FREE_REG 4\n+\n+  int i;\n+  long frame_size;\n+  int return_reg = RETURN_REGNUM;\n+  int fp, offset;\n+  char b64[2] = \" \";\n+\n+  b64[0] = TARGET_64BIT ? 'g' : '\\0';\n+  frame_size = STARTING_FRAME_OFFSET + lsize + save_fprs_p () * 64;\n+  \n+  if (current_function_uses_pic_offset_table)\n+    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+  \n+  if (leaf_function_flag)\n+    {\n+      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\n+      if (s390_nr_constants || regs_ever_live[13] || i != 13)\n+\t{\n+\t    fprintf (file, \"\\tlm%s\\t%s,%s,%d(%s)\\n\", b64, \n+                     reg_names[i], reg_names[13],\n+\t\t     UNITS_PER_WORD * i,\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (regs_ever_live[18])\n+\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", \n+\t\t     reg_names[18],\n+\t\t     STACK_POINTER_OFFSET-16,\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t  if (regs_ever_live[19])\n+\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\",\n+\t\t     reg_names[19],\n+\t\t     STACK_POINTER_OFFSET-8,\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\n+      if (frame_size + STACK_POINTER_OFFSET > 4095)    \n+\t{\n+\t  offset = 0;\n+\t  fp = STACK_POINTER_REGNUM;\n+\t}\n+      else if (frame_pointer_needed || current_function_calls_alloca)\n+\t{\n+\t  offset = frame_size;\n+\t  fp = FRAME_POINTER_REGNUM;\n+\t}\n+      else\n+\t{\n+\t  offset = frame_size;\n+\t  fp = STACK_POINTER_REGNUM;\n+\t}\n+\n+      /* Restore from offset below save area.  */\n+\n+      if (offset == 0)\n+\tfprintf (file, \"\\tl%s\\t%s,0(%s)\\n\", b64, \n+\t\t       reg_names[fp], reg_names[fp]);\n+      restore_fprs (file, offset-64, fp);\n+      return_reg = FREE_REG;\n+      fprintf (file, \"\\tl%s\\t%s,%d(%s)\\n\", b64, reg_names[return_reg], \n+\t       UNITS_PER_WORD*RETURN_REGNUM+offset, reg_names[fp]);\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (regs_ever_live[18])\n+\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", \n+\t\t     reg_names[18],\n+\t\t     offset+STACK_POINTER_OFFSET-16, reg_names[fp]);\n+\t  if (regs_ever_live[19])\n+\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\",\n+\t\t     reg_names[19],\n+\t\t     offset+STACK_POINTER_OFFSET-8, reg_names[fp]);\n+\t}\n+      fprintf (file, \"\\tlm%s\\t%s,%s,%d(%s)\\n\", b64, \n+\t\t     reg_names[i], reg_names[15],\n+\t             (UNITS_PER_WORD * i) + offset, reg_names[fp]);\n+    }\n+  \n+  fprintf (file, \"\\tbr\\t%s\\n\", reg_names[return_reg]);\n+\n+  current_function_uses_pic_offset_table = 0;\n+  leaf_function_flag = 0;\n+  s390_pool_start_insn = NULL_RTX;\n+  s390_pool_count = -1;\n+  s390_function_count++;\n+  return;\n+}\n+\n+/* For structs of odd size the address is passed as reference. \n+   Complex number are also passes on the stack. \n+\n+   Note: We don't use mode, since a struct with the following format \n+   is BLKmode, but has size 4.\n+   struct \n+     {\n+       char a;\n+       char b[3]\n+     }. \n+   The ABI states, that this value has to be passed in register.  */\n+\n+\n+static int\n+s390_function_arg_size (enum machine_mode mode, tree type)\n+{\n+  if (type)\n+    return int_size_in_bytes (type);\n+\n+  /* No type info available for some library calls ... */\n+  if (mode != BLKmode)\n+    return GET_MODE_SIZE (mode);\n+\n+  /* If we have neither type nor mode, abort */\n+  fatal_error (\"no type info available for BLKmode\\n\");\n+}\n+\n+int\n+s390_function_arg_pass_by_reference (enum machine_mode mode, tree type)\n+{\n+  int size = s390_function_arg_size (mode, type);\n+\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type) &&\n+          size != 1 && size != 2 && size != 4 && size != 8)\n+        return 1;\n+\n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+        return 1;\n+    }\n+  return 0;\n+\n+}\n+\n+/* Update the data in CUM to advance over an argument of mode MODE and\n+   data type TYPE.  (TYPE is null for libcalls where that information\n+   may not be available.).  */\n+\n+void\n+s390_function_arg_advance (CUMULATIVE_ARGS * cum,\n+\t\t      enum machine_mode mode, tree type, int named)\n+{\n+  if (! TARGET_SOFT_FLOAT && (mode == DFmode || mode == SFmode))\n+    {\n+      cum->fprs++;\n+    }\n+  else if (s390_function_arg_pass_by_reference (mode, type))\n+    {\n+      cum->gprs += 1;\n+    }\n+  else\n+    {\n+      int size = s390_function_arg_size (mode, type);\n+      cum->gprs += ((size + UNITS_PER_WORD-1) / UNITS_PER_WORD);\n+    }\n+}\n+\n+\n+\n+/* Define where to put the arguments to a function.  Value is zero to push\n+   the argument on the stack, or a hard register in which to store the\n+   argument. Gprs 2-6 and Fprs 0 and 2 are used as arguments.\n+   All integral values go into register, until all are used up, the rest\n+   goes onto stack. The same is valid for floating-point values.  */\n+\n+rtx\n+s390_function_arg (CUMULATIVE_ARGS * cum,\n+\t      enum machine_mode mode, tree type, int named)\n+{\n+  if (s390_function_arg_pass_by_reference (mode, type))\n+      return 0;\n+\n+  if (! TARGET_SOFT_FLOAT && (mode == DFmode || mode == SFmode))\n+    {\n+      if (cum->fprs + 1 > (TARGET_64BIT? 4 : 2))\n+\treturn 0;\n+      else\n+\treturn gen_rtx (REG, mode, cum->fprs + 16);\n+    }\n+  else\n+    {\n+      int size = s390_function_arg_size (mode, type);\n+      int n_gprs = (size + UNITS_PER_WORD-1) / UNITS_PER_WORD;\n+\n+      if (cum->gprs + n_gprs > 5)\n+\treturn 0;\n+      else\n+\treturn gen_rtx (REG, mode, cum->gprs + 2);\n+    }\n+}\n+\n+\n+/* Builtin va_list stuff\n+   va_list is a structure of four elements:\n+      __gpr:  number of named args passed in general purpose register \n+      __gpr:  number of named args passed in floating purpose register \n+      __overflow_arg_area:  address of area, where arguments are passed\n+                          if they do not fit in gprs 2 to 6 and fpr 0 and 2\n+      __reg_save_area:  address, where register passed args are saved \n+                      in prologue.  */\n+\n+tree\n+s390_build_va_list ()\n+{\n+  tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n+\n+  record = make_lang_type (RECORD_TYPE);\n+\n+  type_decl =\n+    build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n+\n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"__gpr\"), \n+\t\t      long_integer_type_node);\n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"__fpr\"), \n+\t\t      long_integer_type_node);\n+  f_ovf = build_decl (FIELD_DECL, get_identifier (\"__overflow_arg_area\"),\n+\t\t      ptr_type_node);\n+  f_sav = build_decl (FIELD_DECL, get_identifier (\"__reg_save_area\"),\n+\t\t      ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_gpr) = record;\n+  DECL_FIELD_CONTEXT (f_fpr) = record;\n+  DECL_FIELD_CONTEXT (f_ovf) = record;\n+  DECL_FIELD_CONTEXT (f_sav) = record;\n+\n+  TREE_CHAIN (record) = type_decl;\n+  TYPE_NAME (record) = type_decl;\n+  TYPE_FIELDS (record) = f_gpr;\n+  TREE_CHAIN (f_gpr) = f_fpr;\n+  TREE_CHAIN (f_fpr) = f_ovf;\n+  TREE_CHAIN (f_ovf) = f_sav;\n+\n+  layout_type (record);\n+\n+  /* The correct type is an array type of one element.  */\n+  return build_array_type (record, build_index_type (size_zero_node));\n+}\n+\n+/* Builtin va_start \n+   The va_list struct is set with the values.\n+   gpr: compile time known got out of  current_function_args_info\n+   fpr: compile time known got out of  current_function_args_info\n+   overflow_arg_area: address passed with register 7 (incoming args register)\n+                  (setup in prologue)\n+   reg_save_area: address of save area where first 5 gprs and 2 fprs sare \n+                  saved (saved in prologue).  */\n+\n+void\n+s390_va_start (int stdarg_p, tree valist, rtx nextarg)\n+{\n+  HOST_WIDE_INT n_gpr, n_fpr;\n+  int off;\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, t;\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  /* Count number of gp and fp argument registers used.  */\n+\n+  n_gpr = current_function_args_info.gprs;\n+  n_fpr = current_function_args_info.fprs;\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, build_int_2 (n_gpr, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, build_int_2 (n_fpr, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the overflow area.  */\n+  t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+\n+  off = INTVAL (current_function_arg_offset_rtx);\n+  off = off < 0 ? 0 : off;\n+  if (! stdarg_p)\n+    off = off > 0 ? off - 4 : off;\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\",\n+\t     n_gpr, n_fpr, off);\n+\n+  t = build (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_2 (off, 0));\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the register save area.  */\n+  t = make_tree (TREE_TYPE (sav), virtual_incoming_args_rtx);\n+  t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t     build_int_2 (-STACK_POINTER_OFFSET, -1));\n+  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+\n+/* Builtin va_arg.  \n+   \n+   Works like following:\n+   \n+   if (integral value) {\n+     if (size  <= 4 && args.gpr < 5 ||\n+         size  > 4 && args.gpr < 4 ) \n+       ret = args.reg_save_area[args.gpr+8]\n+     else\n+       ret = *args.overflow_arg_area++;\n+   } else if (float value) {\n+     if (args.fgpr < 2)\n+       ret = args.reg_save_area[args.fpr+64]\n+     else\n+       ret = *args.overflow_arg_area++;\n+   } else if (aggregate value) {\n+     if (args.gpr < 5)\n+       ret = *args.reg_save_area[args.gpr]\n+     else\n+       ret = **args.overflow_arg_area++;\n+   } */\n+\n+\n+rtx\n+s390_va_arg (tree valist, tree type)\n+{\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, reg, t, u;\n+  int indirect_p, size, n_reg, sav_ofs, sav_scale, max_reg;\n+  rtx lab_false, lab_over, addr_rtx, r;\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  size = int_size_in_bytes (type);\n+\n+  if (s390_function_arg_pass_by_reference (TYPE_MODE (type), type))\n+    {\n+      if (TARGET_DEBUG_ARG)\n+\t{\n+\t  fprintf (stderr, \"va_arg: aggregate type\");\n+\t  debug_tree (type);\n+\t}\n+\n+      /* Aggregates are passed by reference.  */\n+      indirect_p = 1;\n+      reg = gpr;\n+      n_reg = 1;\n+      sav_ofs = 8;\n+      sav_scale = UNITS_PER_WORD;\n+      size = UNITS_PER_WORD;\n+      max_reg = 4;\n+    }\n+  else if (FLOAT_TYPE_P (type) && ! TARGET_SOFT_FLOAT)\n+    {\n+      if (TARGET_DEBUG_ARG)\n+\t{\n+\t  fprintf (stderr, \"va_arg: float type\");\n+\t  debug_tree (type);\n+\t}\n+\n+      /* FP args go in FP registers, if present.  */\n+      indirect_p = 0;\n+      reg = fpr;\n+      n_reg = 1;\n+      sav_ofs = 16 * UNITS_PER_WORD;;\n+      sav_scale = 8;\n+      /* TARGET_64BIT has up to 4 parameter in fprs */\n+      max_reg = TARGET_64BIT ? 3 : 1;\n+    }\n+  else\n+    {\n+      if (TARGET_DEBUG_ARG)\n+\t{\n+\t  fprintf (stderr, \"va_arg: other type\");\n+\t  debug_tree (type);\n+\t}\n+\n+      /* Otherwise into GP registers.  */\n+      indirect_p = 0;\n+      reg = gpr;\n+      n_reg = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      sav_ofs = 2 * UNITS_PER_WORD;\n+      if (TARGET_64BIT)\n+\tsav_ofs += TYPE_MODE (type) == SImode ? 4 : \n+\t           TYPE_MODE (type) == HImode ? 6 : \n+\t           TYPE_MODE (type) == QImode ? 7 : 0;\n+      else\n+\tsav_ofs += TYPE_MODE (type) == HImode ? 2 : \n+\t           TYPE_MODE (type) == QImode ? 3 : 0;\n+\n+      sav_scale = UNITS_PER_WORD;\n+      if (n_reg > 1)\n+\tmax_reg = 3;\n+      else\n+\tmax_reg = 4;\n+    }\n+\n+  /* Pull the value out of the saved registers ...  */\n+\n+  lab_false = gen_label_rtx ();\n+  lab_over = gen_label_rtx ();\n+  addr_rtx = gen_reg_rtx (Pmode);\n+\n+  emit_cmp_and_jump_insns (expand_expr (reg, NULL_RTX, Pmode, EXPAND_NORMAL),\n+\t\t\t   GEN_INT (max_reg),\n+\t\t\t   GT, const1_rtx, Pmode, 0, 1, lab_false);\n+\n+  if (sav_ofs)\n+    t = build (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n+  else\n+    t = sav;\n+\n+  u = build (MULT_EXPR, long_integer_type_node,\n+\t     reg, build_int_2 (sav_scale, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n+\n+  t = build (PLUS_EXPR, ptr_type_node, t, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+\n+  emit_jump_insn (gen_jump (lab_over));\n+  emit_barrier ();\n+  emit_label (lab_false);\n+\n+  /* ... Otherwise out of the overflow area.  */\n+\n+  t = save_expr (ovf);\n+\n+\n+  /* In 64 BIT for each argument on stack, a full 64 bit slot is allocated.  */\n+  if (size < UNITS_PER_WORD)\n+    {\n+      t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (UNITS_PER_WORD-size, 0));\n+      t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      t = save_expr (ovf);\n+    }\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+  t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (size, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  emit_label (lab_over);\n+\n+  /* If less than max_regs a registers are retrieved out \n+     of register save area, increment.  */\n+\n+  u = build (PREINCREMENT_EXPR, TREE_TYPE (reg), reg, \n+\t     build_int_2 (n_reg, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n+  expand_expr (u, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  if (indirect_p)\n+    {\n+      r = gen_rtx_MEM (Pmode, addr_rtx);\n+      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+      emit_move_insn (addr_rtx, r);\n+    }\n+\n+\n+  return addr_rtx;\n+}\n+\n+/* Implementation of Trampoline\n+   Gpr 1 is used as base register and for the jump\n+   to the nested function. \n+   Gpr 0 is static chain.  */\n+\n+void\n+s390_trampoline_template (FILE * file)\n+{\n+  if (TARGET_64BIT)\n+    {\n+      fprintf (file, \"larl\\t%s,0f\\n\", reg_names[1]);\n+      fprintf (file, \"lg\\t%s,0(%s)\\n\", reg_names[0], reg_names[1]);\n+      fprintf (file, \"lg\\t%s,8(%s)\\n\", reg_names[1], reg_names[1]);\n+      fprintf (file, \"br\\t%s\\n\", reg_names[1]);\n+      fprintf (file, \"0:\\t.quad\\t0\\n\");\n+      fprintf (file, \".quad\\t0\\n\");\n+    }\n+  else\n+    {\n+      fprintf (file, \"basr\\t%s,0\\n\", reg_names[1]);\n+      fprintf (file, \"l\\t%s,10(%s)\\n\", reg_names[0], reg_names[1]);\n+      fprintf (file, \"l\\t%s,14(%s)\\n\", reg_names[1], reg_names[1]);\n+      fprintf (file, \"br\\t%s\\n\", reg_names[1]);\n+      fprintf (file, \".long\\t0\\n\");\n+      fprintf (file, \".long\\t0\\n\");\n+    }\n+}\n+\n+void\n+s390_initialize_trampoline (addr, fnaddr, cxt)\n+     rtx addr;\n+     rtx fnaddr;\n+     rtx cxt;\n+{\n+  emit_move_insn (gen_rtx \n+\t\t  (MEM, Pmode,\n+\t\t   memory_address (Pmode, \n+\t\t   plus_constant (addr,(TARGET_64BIT ? 20 : 12) ))), cxt);\n+  emit_move_insn (gen_rtx\n+\t\t  (MEM, Pmode,\n+\t\t   memory_address (Pmode, \n+\t\t   plus_constant (addr,(TARGET_64BIT ? 28 : 16) ))), fnaddr);\n+}"}, {"sha": "8cb03e8918e4115f63c1951aeba2f2ebf0b496b2", "filename": "gcc/config/s390/s390.h", "status": "added", "additions": 1866, "deletions": 0, "changes": 1866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,1866 @@\n+/* Definitions of target machine for GNU compiler, for IBM S/390\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+                  Ulrich Weigand (weigand@de.ibm.com).\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _S390_H\n+#define _S390_H\n+\n+#define TARGET_VERSION fprintf (stderr, \" (S/390)\");\n+\n+extern int flag_pic; \n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Target macros checked at runtime of compiler.  */\n+\n+#define TARGET_HARD_FLOAT          (target_flags & 1)\n+#define TARGET_BACKCHAIN           (target_flags & 2)\n+#define TARGET_SMALL_EXEC          (target_flags & 4)\n+#define TARGET_DEBUG_ARG           (target_flags & 8)\n+#define TARGET_64BIT               (target_flags & 16)\n+#define TARGET_MVCLE               (target_flags & 32)\n+\n+#define TARGET_DEFAULT             0x3\n+#define TARGET_SOFT_FLOAT          (!(target_flags & 1))\n+\n+/* Macro to define tables used to set the flags.  This is a list in braces\n+   of pairs in braces, each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES           \t\t       \t\t       \\\n+{ { \"hard-float\",    1,N_(\"Use hardware fp\")},         \t\t       \\\n+  { \"soft-float\",   -1,N_(\"Don't use hardware fp\")},\t      \t       \\\n+  { \"backchain\",     2,N_(\"Set backchain\")},           \t\t       \\\n+  { \"no-backchain\", -2,N_(\"Don't set backchain (faster, but debug harder\")}, \\\n+  { \"small-exec\",    4,N_(\"Use bras for execucable < 64k\")},           \\\n+  { \"no-small-exec\",-4,N_(\"Don't use bras\")},            \t       \\\n+  { \"debug_arg\",     8,N_(\"Additional debug prints\")},        \t       \\\n+  { \"no-debug_arg\", -8,N_(\"Don't print additional debug prints\")},     \\\n+  { \"64\",           16,N_(\"64 bit mode\")},         \t               \\\n+  { \"31\",          -16,N_(\"31 bit mode\")},                             \\\n+  { \"mvcle\",        32,N_(\"mvcle use\")},         \t               \\\n+  { \"no-mvcle\",    -32,N_(\"mvc&ex\")},                                  \\\n+  { \"\", TARGET_DEFAULT, 0 } }\n+\n+/* Define this to change the optimizations performed by default.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) optimization_options(LEVEL,SIZE)\n+\n+/* The current function count for create unique internal labels.  */\n+\n+extern int s390_function_count;\n+\n+/* The amount of space used for outgoing arguments.  */\n+\n+extern int current_function_outgoing_args_size;\n+\n+/* Target machine storage layout.  */\n+\n+/* Define this if most significant bit is lowest numbered in instructions\n+   that operate on numbered bit-fields.  */\n+\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if MS word of a multiword is the lowest numbered.  */\n+\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressable storage unit.  */\n+\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.  */\n+\n+#define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define MIN_UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n+\n+#define POINTER_SIZE (TARGET_64BIT ? 64 : 32)\n+\n+/* A C expression for the size in bits of the type `short' on the\n+   target machine.  If you don't define this, the default is half a\n+   word.  (If this would be less than one storage unit, it is\n+   rounded up to one unit.)  */\n+#define SHORT_TYPE_SIZE 16\n+\n+/* A C expression for the size in bits of the type `int' on the\n+   target machine.  If you don't define this, the default is one\n+   word.  */\n+#define INT_TYPE_SIZE 32\n+\n+/* A C expression for the size in bits of the type `long' on the\n+   target machine.  If you don't define this, the default is one\n+   word.  */\n+#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define MAX_LONG_TYPE_SIZE 32\n+\n+/* A C expression for the size in bits of the type `long long' on the\n+   target machine.  If you don't define this, the default is two\n+   words.  */\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* Right now we only support two floating point formats, the \n+   32 and 64 bit ieee formats.  */\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\\\n+if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n+    GET_MODE_SIZE (MODE) < UNITS_PER_WORD) { \t\t\\\n+  (MODE) = Pmode;\t\t\t\t\t\\\n+\t  }\n+\n+/* Defining PROMOTE_FUNCTION_ARGS eliminates some unnecessary zero/sign\n+   extensions applied to char/short functions arguments.  Defining\n+   PROMOTE_FUNCTION_RETURN does the same for function returns.  */\n+\n+#define PROMOTE_FUNCTION_ARGS\n+#define PROMOTE_FUNCTION_RETURN\n+#define PROMOTE_FOR_CALL_ONLY\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+\n+#define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+\n+#define STACK_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+\n+#define FUNCTION_BOUNDARY 32\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Alignment on even adresses for LARL instruction.  */\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n+\n+#define DATA_ALIGNMENT(TYPE, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n+\n+/* Define this if move instructions will actually fail to work when given\n+   unaligned data.  */\n+\n+#define STRICT_ALIGNMENT 0\n+\n+/* real arithmetic */\n+\n+#define REAL_ARITHMETIC\n+\n+/* Define target floating point format.  */\n+\n+#undef TARGET_FLOAT_FORMAT\n+#ifdef IEEE_FLOAT\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+#else\n+#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n+#endif\n+\n+/* Define if special allocation order desired.  */\n+\n+#define REG_ALLOC_ORDER                                         \\\n+{  1, 2, 3, 4, 5, 0, 14, 13, 12, 11, 10, 9, 8, 7, 6,            \\\n+   16, 17, 18, 19, 20, 21, 22, 23,                              \\\n+   24, 25, 26, 27, 28, 29, 30, 31,                              \\\n+   15, 32, 33 }\n+\n+/* Standard register usage.  */\n+ \n+#define INT_REGNO_P(N)   ( (N) >= 0 && (N) < 16 )\n+#ifdef IEEE_FLOAT\n+#define FLOAT_REGNO_P(N) ( (N) >= 16 && (N) < 32 )\n+#else\n+#define FLOAT_REGNO_P(N) ( (N) >= 16 && (N) < 20 )\n+#endif\n+#define CC_REGNO_P(N)    ( (N) == 33 )\n+\n+/* Number of actual hardware registers.  The hardware registers are\n+   assigned numbers for the compiler from 0 to just below\n+   FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+   For the 390, we give the data registers numbers 0-15,\n+   and the floating point registers numbers 16-19.\n+   G5 and following have 16 IEEE floating point register,\n+   which get numbers 16-31.  */\n+\n+#define FIRST_PSEUDO_REGISTER 34\n+\n+/* The following register have a fix usage\n+   GPR 12: GOT register points to the GOT, setup in prologue,\n+           GOT contains pointer to variables in shared libraries \n+   GPR 13: Base register setup in prologue to point to the\n+           literal table of each function\n+   GPR 14: Return registers holds the return address\n+   GPR 15: Stack pointer */\n+\n+#define PIC_OFFSET_TABLE_REGNUM 12\n+#define BASE_REGISTER 13\n+#define RETURN_REGNUM 14\n+#define STACK_POINTER_REGNUM 15\n+\n+#define FIXED_REGISTERS\t\t\t\t\\\n+{ 0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 1, 1, 1,\t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  1, 1 }\n+\n+/* 1 for registers not available across function calls.  These must include\n+   the FIXED_REGISTERS and also any registers that can be used without being\n+   saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.  */\n+\n+#define CALL_USED_REGISTERS\t\t\t\\\n+{ 1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 0, 0, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1 }\n+\n+/* If not pic code, gpr 12 can be used.  */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+ } while (0)\n+\n+/* The following register have a special usage\n+   GPR 11: Frame pointer if needed to point to automatic variables. \n+   GPR 32: In functions with more the 5 args this register\n+           points to that arguments, it is always eliminated\n+\t   with stack- or frame-pointer. \n+   GPR 33: Condition code 'register' */\n+\n+#define FRAME_POINTER_REGNUM 11\n+\n+#define ARG_POINTER_REGNUM 32\n+\n+#define CC_REGNUM 33\n+\n+/* We use the register %r0 to pass the static chain to a nested function.\n+  \n+   Note: It is assumed that this register is call-clobbered!\n+         We can't use any of the function-argument registers either,\n+         and register 1 is needed by the trampoline code, so we have\n+         no other choice but using this one ...  */\n+\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n+  (FLOAT_REGNO_P(REGNO)?                                        \\\n+    (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :      \\\n+   INT_REGNO_P(REGNO)?                                          \\\n+    ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n+   1)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   The gprs can hold QI, HI, SI, SF, DF, SC and DC.\n+   Even gprs can hold DI.\n+   The floating point registers can hold DF, SF, DC and SC.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n+  (FLOAT_REGNO_P(REGNO)?                                            \\\n+   (GET_MODE_CLASS(MODE) == MODE_FLOAT ||                           \\\n+    GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT) :                   \\\n+   INT_REGNO_P(REGNO)?                                              \\\n+    (!((TARGET_64BIT && (MODE) == TImode) ||                        \\\n+     (!TARGET_64BIT && (MODE) == DImode)) || ((REGNO) & 1) == 0 ) : \\\n+   CC_REGNO_P(REGNO)?                                               \\\n+     GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n+   0)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n+   mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n+   (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n+   == ((MODE2) == SFmode || (MODE2) == DFmode))\n+\n+\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   On s390, if using PIC, mark a SYMBOL_REF for a non-global symbol\n+   so that we may access it directly in the GOT.  */\n+\n+#define ENCODE_SECTION_INFO(DECL)                               \\\n+do                                                              \\\n+  {                                                             \\\n+    if (flag_pic)                                               \\\n+      {                                                         \\\n+        rtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'    \\\n+                   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));    \\\n+                                                                \\\n+        if (GET_CODE (rtl) == MEM)                              \\\n+          {                                                     \\\n+            SYMBOL_REF_FLAG (XEXP (rtl, 0))                     \\\n+              = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'      \\\n+                 || ! TREE_PUBLIC (DECL));                      \\\n+          }                                                     \\\n+      }                                                         \\\n+  }                                                             \\\n+while (0)\n+  \n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t        \\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}}  \n+\n+#define CAN_ELIMINATE(FROM, TO) (1)\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t  \\\n+{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \t  \\\n+  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)  \\\n+  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)  \\\n+  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n+}\n+\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be\n+   accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+  \n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+ \n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+  \n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+  \n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/*#define SMALL_REGISTER_CLASSES 1*/\n+\n+enum reg_class\n+{\n+  NO_REGS, ADDR_REGS, GENERAL_REGS,\n+  FP_REGS, CC_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.  */\n+\n+#define REG_CLASS_NAMES                                                 \\\n+{ \"NO_REGS\",\"ADDR_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"CC_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.  This is an initializer for\n+   a vector of HARD_REG_SET of length N_REG_CLASSES.\n+   G5 and latter have 16 register and support IEEE floating point operations.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t       \t\t\t\\\n+  { 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n+  { 0x0000fffe, 0x00000001 },\t/* ADDR_REGS */\t\t\\\n+  { 0x0000ffff, 0x00000001 },\t/* GENERAL_REGS */\t\\\n+  { 0xffff0000, 0x00000000 },\t/* FP_REGS */\t\t\\\n+  { 0x00000000, 0x00000002 },\t/* CC_REGS */\t\t\\\n+  { 0xffffffff, 0x00000003 },\t/* ALL_REGS */\t\t\\\n+}\n+\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n+\n+extern enum reg_class regclass_map[];\t/* smalled class containing REGNO   */\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS ADDR_REGS\n+#define BASE_REG_CLASS ADDR_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)                                        \\\n+  ((C) == 'a' ? ADDR_REGS :                                             \\\n+   (C) == 'd' ? GENERAL_REGS :                                          \\\n+   (C) == 'f' ? FP_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string can be used\n+   to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)                                 \\\n+  ((C) == 'I' ? (unsigned long) (VALUE) < 256 :                         \\\n+   (C) == 'J' ? (unsigned long) (VALUE) < 4096 :                        \\\n+   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 :                  \\\n+   (C) == 'L' ? (unsigned long) (VALUE) < 65536 : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n+\n+/* 'Q' means a memory-reference for a S-type operand.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C)                               \t\\\n+     ((C) == 'Q' ?  s_operand (OP, GET_MODE (OP)) : \t\t\\\n+      (C) == 'S' ?  larl_operand (OP, GET_MODE (OP)) : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n+   return the class of reg to actually use.  In general this is just CLASS;\n+   but on some machines in some cases it is preferable to use a more\n+   restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)                                 \\\n+    (GET_CODE (X) == CONST_DOUBLE ?                                      \\\n+     (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? FP_REGS : ADDR_REGS) :\\\n+     (GET_CODE (X) == CONST_INT ?                                        \\\n+     (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? FP_REGS : ADDR_REGS) :\\\n+     GET_CODE (X) == PLUS ||                                            \\\n+     GET_CODE (X) == LABEL_REF ||                                        \\\n+     GET_CODE (X) == SYMBOL_REF ||                                       \\\n+     GET_CODE (X) == CONST ? ADDR_REGS : (CLASS)))\n+\n+/* Return the maximum number of consecutive registers needed to represent\n+   mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n+     ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n+      (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n+      (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* If we are copying between FP registers and anything else, we need a memory\n+   location.  */\n+\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+ ((CLASS1) != (CLASS2) && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS))\n+\n+/* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n+   because the movsi and movsf patterns don't handle r/f moves. */\n+\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n+ (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n+  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\\\n+  : MODE)\n+\n+\n+/* A C expression whose value is nonzero if pseudos that have been\n+   assigned to registers of class CLASS would likely be spilled\n+   because registers of CLASS are needed for spill registers.\n+\n+   The default value of this macro returns 1 if CLASS has exactly one\n+   register and zero otherwise.  On most machines, this default\n+   should be used.  Only define this macro to some other expression\n+   if pseudo allocated by `local-alloc.c' end up in memory because\n+   their hard registers were needed for spill registers.  If this\n+   macro returns nonzero for those classes, those pseudos will only\n+   be allocated by `global.c', which knows how to reallocate the\n+   pseudo to another register.  If there would not be another\n+   register available for reallocation, you should not change the\n+   definition of this macro since the only effect of such a\n+   definition would be to slow down register allocation.  */\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* The current return address is on Offset 56 of the current frame\n+   if we are in an leaf_function. Otherwise we have to go one stack\n+   back.\n+   The return address of anything farther back is accessed normally\n+   at an offset of 56 from the frame pointer.\n+\n+   FIXME: builtin_return_addr does not work correctly in a leaf\n+          function, we need to find way to find out, if we\n+          are in a leaf function\n+  */\n+\n+#define _RETURN_ADDR_OFFSET (TARGET_64BIT ? 112 : 56)\n+\n+#define RETURN_ADDR_RTX(count, frame)                                   \\\n+   gen_rtx (MEM, Pmode,                                                 \\\n+            memory_address (Pmode,                                      \\\n+                              plus_constant (                           \\\n+                              copy_to_reg (gen_rtx (MEM, Pmode,         \\\n+                              memory_address (Pmode, frame))),          \\\n+                              _RETURN_ADDR_OFFSET)));\n+\n+/* The following macros will turn on dwarf2 exception hndling\n+   Other code location for this exception handling are \n+   in s390.md (eh_return insn) and in linux.c in the prologue.  */\n+\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, RETURN_REGNUM)\n+\n+/* We have 31 bit mode.  */\n+\n+#define MASK_RETURN_ADDR (GEN_INT (0x7fffffff))\n+\n+/* Location, from where return address to load.  */\n+\n+#define DWARF_FRAME_RETURN_COLUMN  14\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 6 : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 10)\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -40))\n+\n+/* Define this if pushing a word on the stack makes the stack pointer a\n+   smaller address.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame is at the\n+   high-address end of the local variables; that is, each additional local\n+   variable allocated goes at a more negative offset in the frame.  */\n+\n+/* #define FRAME_GROWS_DOWNWARD   */\n+\n+/* Offset from stack-pointer to first location of outgoing args.  */\n+\n+#define STACK_POINTER_OFFSET (TARGET_64BIT ? 160 : 96)\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET \\\n+     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0\n+\n+/* If we generate an insn to push BYTES bytes, this says how many the stack\n+   pointer really advances by.  On S/390, we have no push instruction.  */\n+\n+/* #define PUSH_ROUNDING(BYTES) */\n+\n+/* Accumulate the outgoing argument count so we can request the right\n+   DSA size and determine stack offset.  */\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Offset from the stack pointer register to an item dynamically\n+   allocated on the stack, e.g., by `alloca'.\n+\n+   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n+   length of the outgoing arguments.  The default is correct for most\n+   machines.  See `function.c' for details.  */\n+#define STACK_DYNAMIC_OFFSET(FUNDECL) (STARTING_FRAME_OFFSET)\n+\n+/* Offset of first parameter from the argument pointer register value. \n+   On the S/390, we define the argument pointer to the start of the fixed\n+   area.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register.  The value is the number of bytes allocated to this\n+   area.  */\n+/* #define REG_PARM_STACK_SPACE(FNDECL)    32 */\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+/* #define OUTGOING_REG_PARM_STACK_SPACE */\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On S390, general registers 2 - 6 and floating point register 0 and 2\n+   are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) (((N) >=2 && (N) <7) || \\\n+                                 (N) == 16 || (N) == 17)\n+\n+/* Define a data type for recording info about an argument list during\n+   the scan of that argument list.  This data type should hold all\n+   necessary information about the function itself and about the args\n+   processed so far, enough to enable macros such as FUNCTION_ARG to\n+   determine where the next arg should go.  */\n+\n+typedef struct s390_arg_structure\n+{\n+  int gprs;\t\t\t/* gpr so far */\n+  int fprs;\t\t\t/* fpr so far */\n+}\n+CUMULATIVE_ARGS;\n+\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n+   a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, NN) \\\n+  ((CUM).gprs=0, (CUM).fprs=0)\n+\n+/* Update the data in CUM to advance over an argument of mode MODE and\n+   data type TYPE.  (TYPE is null for libcalls where that information\n+   may not be available.) */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)                    \\\n+  s390_function_arg_advance(&CUM, MODE, TYPE, NAMED)\n+\n+/* Define where to put the arguments to a function.  Value is zero to push\n+   the argument on the stack, or a hard register in which to store the\n+   argument.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)   \\\n+  s390_function_arg(&CUM, MODE, TYPE, NAMED)\n+\n+/* Define where to expect the arguments of a function.  Value is zero, if\n+   the argument is on the stack, or a hard register in which the argument\n+   is stored. It is the same like FUNCTION_ARG, except for unnamed args\n+   That means, that all in case of varargs used, the arguments are expected\n+   from the stack. \n+   S/390 has already space on the stack for args coming in registers, \n+   they are pushed in prologue, if needed.  */  \n+\n+\n+/* Define the `__builtin_va_list' type.  */\n+\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = s390_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  s390_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  s390_va_arg (valist, type)\n+\n+/* For an arg passed partly in registers and partly in memory, this is the\n+   number of registers used.  For args passed entirely in registers or\n+   entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+\n+/* Define if returning from a function call automatically pops the\n+   arguments described by the number-of-args field in the call.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n+\n+\n+/* Define how to find the value returned by a function.  VALTYPE is the\n+   data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 15.  */\n+\n+#define RET_REG(MODE) ((GET_MODE_CLASS (MODE) == MODE_INT       \\\n+                       || TARGET_SOFT_FLOAT ) ? 2 : 16)\n+\n+\n+/* for structs the address is passed, and the Callee makes a\n+   copy, only if needed */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+  s390_function_arg_pass_by_reference (MODE, TYPE)\n+\n+\n+/* Register 2 (and 3) for integral values\n+   or floating point register 0 (and 2) for fp values are used.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n+  gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n+\t\t&& TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n+\t       || POINTER_TYPE_P (VALTYPE)\t\t\t\\\n+\t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n+\t       TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_HARD_FLOAT ? 16 : 2)\n+\n+/* Define how to find the value returned by a library function assuming\n+   the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, RET_REG (MODE))\n+\n+/* 1 if N is a possible register number for a function value.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 2 || (N) == 16)\n+\n+/* The definition of this macro implies that there are cases where\n+   a scalar value cannot be returned in registers.  */\n+\n+#define RETURN_IN_MEMORY(type)       \t\t\\\n+  (TYPE_MODE (type) == BLKmode || \t\t\\\n+   TYPE_MODE (type) == DCmode  || \t\t\\\n+   TYPE_MODE (type) == SCmode)\n+\n+/* Mode of stack savearea.\n+   FUNCTION is VOIDmode because calling convention maintains SP.\n+   BLOCK needs Pmode for SP.\n+   NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n+\n+#define STACK_SAVEAREA_MODE(LEVEL)      \\\n+  (LEVEL == SAVE_FUNCTION ? VOIDmode    \\\n+  : LEVEL == SAVE_NONLOCAL ? (TARGET_64BIT ? TImode : DImode) : Pmode)\n+\n+/* Structure value address is passed as invisible first argument (gpr 2).  */\n+\n+#define STRUCT_VALUE 0\n+\n+/* This macro definition sets up a default value for `main' to return.  */\n+\n+#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 36 : 20)\n+\n+/* Initialize the dynamic part of trampoline.  */\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)                       \\\n+   s390_initialize_trampoline ((ADDR), (FNADDR), (CXT))\n+\n+/* Template for constant part of trampoline.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)                                       \\\n+   s390_trampoline_template (FILE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n+do {                                     \t\t\t\\\n+  extern rtx s390_profile[];  \t\t\t\t\t\\\n+  extern s390_pool_count;     \t\t\t\t\t\\\n+  rtx tmp;                                    \t\t\t\\\n+  static char label[128];                     \t\t\t\\\n+  fprintf (FILE, \"# function profiler \\n\");   \t\t\t\\\n+  if (TARGET_64BIT) \t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      rtx tmp[1];\t\t\t\t\t\t\\\n+      output_asm_insn (\"stg\\t14,8(15)\", tmp);\t\t\t\\\n+      sprintf (label, \"%sP%d\", LPREFIX, LABELNO);       \t\\\n+      tmp[0] = gen_rtx_SYMBOL_REF (Pmode, label);\t\t\\\n+      SYMBOL_REF_FLAG (tmp[0]) = 1;\t\t\t\t\\\n+      output_asm_insn (\"larl\\t1,%0\", tmp);      \t\t\\\n+      tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\t        \\\n+      if (flag_pic)\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \\\n+          tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t\\\n+      output_asm_insn (\"lg\\t14,8(15)\", tmp);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {  \t\t\t\t\t\t\t\t\\\n+      output_asm_insn (\"l     14,4(15)\", s390_profile);\t\t\\\n+      s390_pool_count = 0;                             \t\t\\\n+      output_asm_insn (\"st    14,4(15)\", s390_profile);\t\t\\\n+      output_asm_insn (\"l     14,%4\", s390_profile);\t\t\\\n+      output_asm_insn (\"l     1,%9\", s390_profile);\t\t\\\n+      if (flag_pic) \t\t\t\t\t\t\\\n+\t{   \t\t\t\t\t\t\t\\\n+\t  output_asm_insn (\"ar    1,13\", s390_profile);   \t\\\n+\t  output_asm_insn (\"bas   14,0(14,13)\", s390_profile); \t\\\n+\t} \t\t\t\t\t\t\t\\\n+      else \t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  output_asm_insn (\"basr  14,14\", s390_profile);\t\\\n+\t}                  \t\t\t\t\t\\\n+      output_asm_insn (\"l     14,4(15)\", s390_profile);\t\t\\\n+    }                     \t\t\t\t\t\\\n+} while (0)\n+\n+/* #define PROFILE_BEFORE_PROLOGUE */\n+\n+/* There are three profiling modes for basic blocks available.\n+   The modes are selected at compile time by using the options\n+   -a or -ax of the gnu compiler.\n+   The variable `profile_block_flag' will be set according to the\n+   selected option.\n+\n+   profile_block_flag == 0, no option used:\n+\n+      No profiling done.\n+\n+   profile_block_flag == 1, -a option used.\n+\n+      Count frequency of execution of every basic block.\n+\n+   profile_block_flag == 2, -ax option used.\n+\n+      Generate code to allow several different profiling modes at run time. \n+      Available modes are:\n+             Produce a trace of all basic blocks.\n+             Count frequency of jump instructions executed.\n+      In every mode it is possible to start profiling upon entering\n+      certain functions and to disable profiling of some other functions.\n+\n+    The result of basic-block profiling will be written to a file `bb.out'.\n+    If the -ax option is used parameters for the profiling will be read\n+    from file `bb.in'.\n+\n+*/\n+\n+/* The following macro shall output assembler code to FILE\n+   to initialize basic-block profiling.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to call the subroutine `__bb_init_trace_func'\n+\tand pass two parameters to it. The first parameter is\n+\tthe address of a block allocated in the object module.\n+\tThe second parameter is the number of the first basic block\n+\tof the function.\n+\n+\tThe name of the block is a local symbol made with this statement:\n+\t\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tThe number of the first basic block of the function is\n+\tpassed to the macro in BLOCK_OR_LABEL.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tparameter1 <- LPBX0\n+\t\tparameter2 <- BLOCK_OR_LABEL\n+\t\tcall __bb_init_trace_func\n+\n+    else if profile_block_flag != 0\n+\n+\tOutput code to call the subroutine `__bb_init_func'\n+\tand pass one single parameter to it, which is the same\n+\tas the first parameter to `__bb_init_trace_func'.\n+\n+\tThe first word of this parameter is a flag which will be nonzero if\n+\tthe object module has already been initialized.  So test this word\n+\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n+\tNote: When profile_block_flag == 2 the test need not be done\n+\tbut `__bb_init_trace_func' *must* be called.\n+\n+\tBLOCK_OR_LABEL may be used to generate a label number as a\n+\tbranch destination in case `__bb_init_func' will not be called.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tcmp (LPBX0),0\n+\t\tjne local_label\n+\t\tparameter1 <- LPBX0\n+\t\tcall __bb_init_func\n+local_label:\n+\n+*/\n+\n+#undef\tFUNCTION_BLOCK_PROFILER\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\t\t            \\\n+do\t\t\t\t\t\t\t\t\t            \\\n+  {\t\t\t\t\t\t\t\t\t            \\\n+    if (TARGET_64BIT) \t\t\t\t\t\t                    \\\n+      {\t\t\t\t\t\t\t\t                    \\\n+    \trtx tmp[1];\t                                                            \\\n+\tfprintf (FILE, \"# function block profiler %d \\n\", profile_block_flag);      \\\n+\toutput_asm_insn (\"ipm   0\", tmp);              \t\t    \t            \\\n+\toutput_asm_insn (\"aghi  15,-224\", tmp);                           \t    \\\n+\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);             \t\t    \\\n+\toutput_asm_insn (\"larl  2,.LPBX0\", tmp);               \t\t    \t    \\\n+\tswitch (profile_block_flag) \t\t\t\t\t            \\\n+\t  {\t\t\t\t\t\t\t\t\t    \\\n+\t  case 2:\t\t\t\t\t\t\t\t    \\\n+\t    if (BLOCK_OR_LABEL < 0x10000) {                                         \\\n+\t      tmp[0] = gen_rtx_CONST_INT (Pmode, (BLOCK_OR_LABEL));                 \\\n+\t      output_asm_insn (\"llill 3,%x0\", tmp);                                 \\\n+\t    } else {                                         \t     \t            \\\n+\t      int bo = BLOCK_OR_LABEL;                                              \\\n+\t      tmp[0] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);                        \\\n+\t      output_asm_insn (\"llill 3,%x0\", tmp);                                 \\\n+\t      tmp[0] = gen_rtx_CONST_INT (Pmode, (bo&0xffff0000)>>16);              \\\n+\t      output_asm_insn (\"iilh 3,%x0\", tmp);                                  \\\n+ \t    }                                                                       \\\n+            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_init_trace_func\");            \\\n+            if (flag_pic)\t\t\t\t\t\t\t    \\\n+              {\t\t\t\t\t\t\t\t\t    \\\n+                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t    \\\n+                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t    \\\n+              }\t\t\t\t\t\t\t\t\t    \\\n+            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t            \\\n+\t    break;\t\t\t\t\t\t\t\t    \\\n+\t  default:\t\t\t\t\t\t\t\t    \\\n+\t    output_asm_insn (\"cli   7(2),0\", tmp);                       \t    \\\n+\t    output_asm_insn (\"jne   2f\", tmp);\t        \t\t            \\\n+            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_init_func\");                  \\\n+            if (flag_pic)\t\t\t\t\t\t\t    \\\n+              {\t\t\t\t\t\t\t\t\t    \\\n+                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t    \\\n+                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t    \\\n+              }\t\t\t\t\t\t\t\t\t    \\\n+            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t            \\\n+\t    break;\t\t\t\t\t\t\t\t    \\\n+\t  }\t\t\t\t\t\t\t\t\t    \\\n+\toutput_asm_insn (\"2:\", tmp);                                                \\\n+\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);                                \\\n+\toutput_asm_insn (\"aghi  15,224\", tmp);    \t\t                    \\\n+\toutput_asm_insn (\"spm   0\", tmp);       \t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t                    \\\n+    else                                                                            \\\n+      {\t\t\t\t\t\t\t\t                    \\\n+    \textern rtx s390_profile[];\t\t\t\t\t\t    \\\n+\tfprintf (FILE, \"# function block profiler %d \\n\", profile_block_flag);      \\\n+\toutput_asm_insn (\"ipm   0\", s390_profile);     \t\t    \t            \\\n+\toutput_asm_insn (\"ahi   15,-128\", s390_profile);                  \t    \\\n+\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t\t    \\\n+\toutput_asm_insn (\"l     2,%6\", s390_profile);     \t\t    \t    \\\n+\tif (flag_pic)\t\t\t\t\t\t\t            \\\n+\t  output_asm_insn (\"ar    2,13\", s390_profile);\t\t\t            \\\n+\tswitch (profile_block_flag) \t\t\t\t\t            \\\n+\t  {\t\t\t\t\t\t\t\t\t    \\\n+\t  case 2:\t\t\t\t\t\t\t\t    \\\n+\t    output_asm_insn (\"l     4,%1\", s390_profile);\t\t       \t    \\\n+\t    if (BLOCK_OR_LABEL < 0x8000) {                                          \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (BLOCK_OR_LABEL));        \\\n+\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                         \\\n+\t    } else {                                         \t     \t            \\\n+\t      int bo = BLOCK_OR_LABEL;                                              \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);     \\\n+\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                         \\\n+\t      output_asm_insn (\"sll   3,15\", s390_profile);                         \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);               \\\n+\t      output_asm_insn (\"ahi   3,%8\", s390_profile);                         \\\n+\t    }                                                                       \\\n+\t    break;\t\t\t\t\t\t\t\t    \\\n+\t  default:\t\t\t\t\t\t\t\t    \\\n+\t    output_asm_insn (\"l     4,%0\", s390_profile);\t      \t\t    \\\n+\t    output_asm_insn (\"cli   3(2),0\", s390_profile);              \t    \\\n+\t    output_asm_insn (\"jne   2f\", s390_profile);\t\t\t            \\\n+\t    break;\t\t\t\t\t\t\t\t    \\\n+\t  }\t\t\t\t\t\t\t\t\t    \\\n+\tif (flag_pic)\t\t\t\t\t\t\t            \\\n+\t  output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t       \t            \\\n+\telse\t\t\t\t\t\t\t\t            \\\n+\t  output_asm_insn (\"basr  14,4\", s390_profile);\t                            \\\n+\toutput_asm_insn (\"2:\", s390_profile);                                       \\\n+\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);                        \\\n+\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t                    \\\n+\toutput_asm_insn (\"spm   0\", s390_profile);\t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t                    \\\n+  } while (0)\n+\n+/* The following macro shall output assembler code to FILE\n+   to increment a counter associated with basic block number BLOCKNO.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to initialize the global structure `__bb' and\n+\tcall the function `__bb_trace_func' which will increment the\n+\tcounter.\n+\n+\t`__bb' consists of two words. In the first word the number\n+\tof the basic block has to be stored. In the second word\n+\tthe address of a block allocated in the object module \n+\thas to be stored.\n+\n+\tThe basic block number is given by BLOCKNO.\n+\n+\tThe address of the block is given by the label created with \n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tby FUNCTION_BLOCK_PROFILER.\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tmove BLOCKNO -> (__bb)\n+\t\tmove LPBX0 -> (__bb+4)\n+\t\tcall __bb_trace_func\n+\n+\tNote that function `__bb_trace_func' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE\n+\tand MACHINE_STATE_RESTORE. The last two macros will be\n+\tused in the function `__bb_trace_func', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE.\n+\n+   else if profile_block_flag != 0\n+\n+\tOutput code to increment the counter directly.\n+\tBasic blocks are numbered separately from zero within each\n+\tcompiled object module. The count associated with block number\n+\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n+\tthis array is a local symbol made with this statement:\n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result. \n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tinc (LPBX2+4*BLOCKNO)\n+\n+*/\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t                \t           \\\n+do\t\t\t\t\t\t\t\t\t           \\\n+  {\t\t\t\t\t\t\t\t\t           \\\n+    if (TARGET_64BIT)\t\t\t\t                                   \\\n+      {\t\t\t\t\t\t                                   \\\n+    \trtx tmp[1];\t                                                           \\\n+\tfprintf (FILE, \"# block profiler %d block %d \\n\",                          \\\n+\t\t\t profile_block_flag,BLOCKNO); \t                           \\\n+\toutput_asm_insn (\"ipm   14\", tmp);              \t\t           \\\n+\toutput_asm_insn (\"aghi  15,-224\", tmp);                           \t   \\\n+\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);             \t\t   \\\n+\toutput_asm_insn (\"larl  2,_bb\", tmp);                      \t\t   \\\n+        if ((BLOCKNO*8) < 0x10000) {                                               \\\n+\t  tmp[0] = gen_rtx_CONST_INT (Pmode, (BLOCKNO*8));                         \\\n+\t  output_asm_insn (\"llill 3,%x0\", tmp);                                    \\\n+\t} else {                                              \t                   \\\n+\t  int bo = BLOCKNO*8;                                                      \\\n+\t  tmp[0] = gen_rtx_CONST_INT (Pmode, bo&0xffff);                           \\\n+\t  output_asm_insn (\"llill 3,%x0\", tmp);                                    \\\n+\t  tmp[0] = gen_rtx_CONST_INT (Pmode, (bo&0xffff0000)>>16);                 \\\n+\t  output_asm_insn (\"iilh 3,%x0\", tmp);                                     \\\n+\t}                                                       \t           \\\n+    \tswitch (profile_block_flag) \t\t\t\t\t           \\\n+\t  {\t\t\t\t\t\t\t\t\t   \\\n+\t  case 2:\t\t\t\t\t\t\t\t   \\\n+\t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n+    \t    output_asm_insn (\"larl  3,.LPBX0\", tmp);                   \t\t   \\\n+\t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n+            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_trace_func\");                \\\n+            if (flag_pic)\t\t\t\t\t\t\t   \\\n+              {\t\t\t\t\t\t\t\t\t   \\\n+                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t   \\\n+                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t   \\\n+              }\t\t\t\t\t\t\t\t\t   \\\n+            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t           \\\n+\t    break;\t\t\t\t\t\t\t\t   \\\n+\t  default:\t\t\t\t\t\t\t\t   \\\n+            output_asm_insn (\"larl  2,.LPBX2\", tmp);                   \t\t   \\\n+            output_asm_insn (\"la    2,0(2,3)\", tmp);                   \t\t   \\\n+\t    output_asm_insn (\"lg    3,0(2)\", tmp);              \t     \t   \\\n+    \t    output_asm_insn (\"aghi  3,1\", tmp);                  \t     \t   \\\n+    \t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n+    \t    break;\t\t\t\t\t\t\t\t   \\\n+         }\t\t\t\t\t                                   \\\n+\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);                               \\\n+\toutput_asm_insn (\"ahi   15,224\", tmp);          \t                   \\\n+\toutput_asm_insn (\"spm   14\", tmp);          \t\t\t\t   \\\n+      }\t\t\t\t\t\t                                   \\\n+    else\t\t\t\t\t                                   \\\n+      {\t\t\t\t\t\t                                   \\\n+    \textern rtx s390_profile[];                                                 \\\n+\tfprintf (FILE, \"# block profiler %d block %d \\n\",                          \\\n+\t\t\t profile_block_flag,BLOCKNO); \t                           \\\n+\toutput_asm_insn (\"ipm   14\", s390_profile);     \t\t    \t   \\\n+\toutput_asm_insn (\"ahi   15,-128\", s390_profile);     \t       \t           \\\n+\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t\t   \\\n+\tswitch (profile_block_flag) \t\t\t\t\t           \\\n+\t  {\t\t\t\t\t\t\t\t\t   \\\n+\t  case 2:\t\t\t\t\t\t\t\t   \\\n+\t    output_asm_insn (\"l     4,%2\", s390_profile);     \t     \t           \\\n+\t    output_asm_insn (\"l     2,%5\", s390_profile);     \t     \t           \\\n+\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n+\t      output_asm_insn (\"ar    2,13\", s390_profile);\t\t\t   \\\n+\t    if (BLOCKNO < 0x8000) {                                                \\\n+\t      s390_profile[7] = gen_rtx_CONST_INT (Pmode, (BLOCKNO)*4);            \\\n+\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                        \\\n+\t    } else {                                         \t     \t           \\\n+\t      int bo = BLOCKNO;                                                    \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);    \\\n+\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                        \\\n+\t      output_asm_insn (\"sll   3,15\", s390_profile);                        \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);              \\\n+\t      output_asm_insn (\"ahi   3,%7\", s390_profile);                        \\\n+\t    }                                                                      \\\n+\t    output_asm_insn (\"st    3,0(2)\", s390_profile);     \t     \t   \\\n+\t    output_asm_insn (\"mvc   0(4,2),%5\", s390_profile);     \t     \t   \\\n+\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n+\t      output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t\t   \\\n+\t    else\t\t\t\t\t\t\t\t   \\\n+\t      output_asm_insn (\"basr  14,4\", s390_profile);\t                   \\\n+\t    break;\t\t\t\t\t\t\t\t   \\\n+\t  default:\t\t\t\t\t\t\t\t   \\\n+\t    if (BLOCKNO < 0x2000) {                                                \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (BLOCKNO)*4);            \\\n+\t      output_asm_insn (\"lhi   2,%8\", s390_profile);                        \\\n+\t    } else {                                         \t     \t           \\\n+\t      int bo = BLOCKNO*4;                                                  \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);    \\\n+\t      output_asm_insn (\"lhi   2,%8\", s390_profile);                        \\\n+\t      output_asm_insn (\"sll   2,15\", s390_profile);                        \\\n+\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);              \\\n+\t      output_asm_insn (\"ahi   2,%8\", s390_profile);                        \\\n+\t    }                                                                      \\\n+\t    output_asm_insn (\"a     2,%7\", s390_profile);     \t     \t           \\\n+\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n+\t      output_asm_insn (\"l     3,0(2,13)\", s390_profile);           \t   \\\n+\t    else                                                                   \\\n+\t      output_asm_insn (\"l     3,0(2)\", s390_profile);     \t     \t   \\\n+\t    output_asm_insn (\"ahi   3,1\", s390_profile);         \t     \t   \\\n+\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n+\t      output_asm_insn (\"st    3,0(2,13)\", s390_profile);          \t   \\\n+\t    else                                                                   \\\n+\t      output_asm_insn (\"st    3,0(2)\", s390_profile);     \t     \t   \\\n+\t    break;\t\t\t\t\t\t\t\t   \\\n+\t  }\t\t\t\t\t\t\t\t\t   \\\n+\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);                       \\\n+\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t                   \\\n+\toutput_asm_insn (\"spm   14\", s390_profile);\t\t\t\t   \\\n+     }                                                                             \\\n+  } while (0)\n+\n+\n+/* The following macro shall output assembler code to FILE\n+   to indicate a return from function during basic-block profiling.\n+\n+   If profiling_block_flag == 2:\n+\n+\tOutput assembler code to call function `__bb_trace_ret'.\n+\n+\tNote that function `__bb_trace_ret' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n+\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n+\tused in the function `__bb_trace_ret', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n+\n+   else if profiling_block_flag != 0:\n+\n+\tThe macro will not be used, so it need not distinguish\n+\tthese cases.\n+*/\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n+do {                                                                       \\\n+    if (TARGET_64BIT)\t\t\t\t                           \\\n+      {\t\t\t\t\t\t                           \\\n+    \trtx tmp[1];\t                                                   \\\n+\tfprintf (FILE, \"# block profiler exit \\n\");                        \\\n+\toutput_asm_insn (\"ipm   14\", tmp);                                 \\\n+\toutput_asm_insn (\"aghi  15,-224\", tmp);              \t       \t   \\\n+\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);              \t   \\\n+        tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_trace_ret\");             \\\n+        if (flag_pic)\t\t\t\t\t\t\t   \\\n+          {\t\t\t\t\t\t\t\t   \\\n+            tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113);   \\\n+            tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t   \\\n+          }\t\t\t\t\t\t\t\t   \\\n+    \toutput_asm_insn (\"brasl 14,%0\", tmp);                       \t   \\\n+\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);              \t   \\\n+\toutput_asm_insn (\"aghi  15,224\", tmp);              \t       \t   \\\n+    \toutput_asm_insn (\"spm   14\", tmp);                                 \\\n+      }                                                                    \\\n+    else                                                                   \\\n+      {                                                                    \\\n+    \textern rtx s390_profile[];\t\t\t\t           \\\n+\tfprintf (FILE, \"# block profiler exit \\n\");                        \\\n+\toutput_asm_insn (\"ipm   14\", s390_profile);     \t\t   \\\n+\toutput_asm_insn (\"ahi   15,-128\", s390_profile);     \t       \t   \\\n+\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t   \\\n+\toutput_asm_insn (\"l     4,%3\", s390_profile);\t\t      \t   \\\n+\tif (flag_pic)\t\t\t\t\t\t\t   \\\n+\t  output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t           \\\n+\telse\t\t\t\t\t\t\t\t   \\\n+\t  output_asm_insn (\"basr  14,4\", s390_profile);\t                   \\\n+\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);               \\\n+\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t           \\\n+\toutput_asm_insn (\"spm   14\", s390_profile);\t\t\t   \\\n+     }                                                                     \\\n+  } while (0)\n+\n+/* The function `__bb_trace_func' is called in every basic block\n+   and is not allowed to change the machine state. Saving (restoring)\n+   the state can either be done in the BLOCK_PROFILER macro,\n+   before calling function (rsp. after returning from function)\n+   `__bb_trace_func', or it can be done inside the function by\n+   defining the macros:\n+\n+\tMACHINE_STATE_SAVE(ID)\n+\tMACHINE_STATE_RESTORE(ID)\n+\n+   In the latter case care must be taken, that the prologue code\n+   of function `__bb_trace_func' does not already change the\n+   state prior to saving it with MACHINE_STATE_SAVE.\n+\n+   The parameter `ID' is a string identifying a unique macro use.\n+\n+   On the s390 all save/restore is done in macros above\n+*/\n+\n+/*\n+#define MACHINE_STATE_SAVE(ID) \\\n+      fprintf (FILE, \"\\tahi   15,-128 # save state\\n\");\t\t\t  \\\n+      fprintf (FILE, \"\\tstm   14,5,96(15)\\n\");\t\t\t\t  \\\n+\n+#define MACHINE_STATE_RESTORE(ID) \\\n+      fprintf (FILE, \"\\tlm    14,5,96(15) # restore state\\n\");            \\\n+      fprintf (FILE, \"\\tahi   15,128\\n\");\t\t \t\t  \\\n+*/\n+\n+\n+/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n+   pointer does not matter (provided there is a frame pointer).  */\n+\n+#define EXIT_IGNORE_STACK       1\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.  They give\n+   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n+   reg currently allocated to a suitable hard reg.\n+   These definitions are NOT overridden anywhere.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)                                     \\\n+  (((REGNO) > 0 && (REGNO) < 16) || (REGNO) == ARG_POINTER_REGNUM       \\\n+   /* || (REGNO) == FRAME_POINTER_REGNUM */                                 \\\n+    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n+\n+#define REGNO_OK_FOR_DATA_P(REGNO)                                      \\\n+  ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n+\n+#define REGNO_OK_FOR_FP_P(REGNO)                                        \\\n+  FLOAT_REGNO_P(REGNO)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.  */\n+\n+/* 1 if X is a data register.  */\n+\n+#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\n+/* 1 if X is an address register.  */\n+\n+#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) 0\n+\n+#define SYMBOLIC_CONST(X)       \\\n+(GET_CODE (X) == SYMBOL_REF                                             \\\n+ || GET_CODE (X) == LABEL_REF                                           \\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+\n+/* General operand is everything except SYMBOL_REF, CONST and CONST_DOUBLE\n+   they have to be forced to constant pool\n+   CONST_INT have to be forced into constant pool, if greater than\n+   64k. Depending on the insn they have to be force into constant pool\n+   for smaller value; in this case we have to work with nonimmediate operand.  */\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)  \\\n+      legitimate_pic_operand_p (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+     legitimate_constant_p (X)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n+   its validity for a certain class.  We have two alternate definitions\n+   for each of them.  The usual definition accepts all pseudo regs; the\n+   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n+   definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that they will\n+   get allocated to the class that the insn wants them to be in.\n+   Some source files that are used after register allocation\n+   need to be strict.  */\n+\n+/* \n+ * Nonzero if X is a hard reg that can be used as an index or if it is\n+ * a pseudo reg.  \n+ */\n+\n+#define REG_OK_FOR_INDEX_NONSTRICT_P(X)               \t\t\t\\\n+((GET_MODE (X) == Pmode) &&\t\t\t\t\t\t\\\n+ ((REGNO (X) > 0 && REGNO (X) < 16) ||\t\t\t\t\t\\\n+  (REGNO (X) == ARG_POINTER_REGNUM) ||\t\t\t\t\t\\\n+  (REGNO (X) >= FIRST_PSEUDO_REGISTER)))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n+   a pseudo reg.  */\n+\n+#define REG_OK_FOR_BASE_NONSTRICT_P(X)    REG_OK_FOR_INDEX_NONSTRICT_P (X)\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+\n+#define REG_OK_FOR_INDEX_STRICT_P(X) \t\t\t\t\\\n+((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_INDEX_P (REGNO (X))))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+\n+#define REG_OK_FOR_BASE_STRICT_P(X)\t\t\t\t\\\n+((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_BASE_P (REGNO (X))))\n+\n+\n+#ifndef REG_OK_STRICT\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n+#else\n+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n+#endif\n+\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+   valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                         \\\n+{                                                                       \\\n+  if (legitimate_address_p (MODE, X, 1))                                \\\n+    goto ADDR;                                                          \\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                         \\\n+{                                                                       \\\n+  if (legitimate_address_p (MODE, X, 0))                                \\\n+    goto ADDR;                                                          \\\n+}\n+#endif\n+\n+\n+/* S/390 has no mode dependent addresses.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.  */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)                          \\\n+{                                                                       \\\n+  (X) = legitimize_address (X, OLDX, MODE);                             \\\n+  if (memory_address_p (MODE, X))                                       \\\n+    goto WIN;                                                           \\\n+}\n+\n+/* Specify the machine mode that this machine uses for the index in the\n+   tablejump instruction.  */\n+\n+#define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n+\n+/* Define this if the tablejump instruction expects the table to contain\n+   offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Load from integral MODE < SI from memory into register makes sign_extend\n+   or zero_extend  \n+   In our case sign_extension happens for Halfwords, other no extension.  */\n+\n+#define LOAD_EXTEND_OP(MODE) \t\t\t\t\t\\\n+(TARGET_64BIT ? ((MODE) == QImode ? ZERO_EXTEND :               \\\n+                 (MODE) == HImode ? SIGN_EXTEND : NIL)          \\\n+              : ((MODE) == HImode ? SIGN_EXTEND : NIL))\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* Define this if fixuns_trunc is the same as fix_trunc.  */\n+\n+/* #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */\n+\n+/* We use \"unsigned char\" as default.  */\n+\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory in one reasonably\n+   fast instruction.  */\n+\n+#define MOVE_MAX 256\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+\n+#define SLOW_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define if shifts truncate the shift count which implies one can omit\n+   a sign-extension or zero-extension of a shift count.  */\n+\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+/* #define STORE_FLAG_VALUE -1 */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* Don't perform CSE on function addresses.  */\n+\n+#define NO_FUNCTION_CSE\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+\n+#define Pmode (TARGET_64BIT ? DImode : SImode)\n+\n+/* A function address in a call instruction is a byte address (for\n+   indexing purposes) so give the MEM rtx a byte's mode.  */\n+\n+#define FUNCTION_MODE QImode\n+\n+\n+/* A part of a C `switch' statement that describes the relative costs\n+   of constant RTL expressions.  It must contain `case' labels for\n+   expression codes `const_int', `const', `symbol_ref', `label_ref'\n+   and `const_double'.  Each case must ultimately reach a `return'\n+   statement to return the relative cost of the use of that kind of\n+   constant value in an expression.  The cost may depend on the\n+   precise value of the constant, which is available for examination\n+   in X, and the rtx code of the expression in which it is contained,\n+   found in OUTER_CODE.\n+\n+   CODE is the expression code--redundant, since it can be obtained\n+   with `GET_CODE (X)'.  */\n+/* Force_const_mem does not work out of reload, because the saveable_obstack\n+   is set to reload_obstack, which does not live long enough. \n+   Because of this we cannot use force_const_mem in addsi3.\n+   This leads to problems with gen_add2_insn with a constant greater\n+   than a short. Because of that we give a addition of greater\n+   constants a cost of 3 (reload1.c 10096).  */\n+\n+\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)                      \\\n+  case CONST:                                                   \\\n+    if ((GET_CODE (XEXP (RTX, 0)) == MINUS) &&                  \\\n+\t(GET_CODE (XEXP (XEXP (RTX, 0), 1)) != CONST_INT))      \\\n+     return 1000;                                               \\\n+  case CONST_INT:                                               \\\n+       if ((OUTER_CODE == PLUS) &&                              \\\n+\t   ((INTVAL (RTX) > 32767) ||                           \\\n+\t   (INTVAL (RTX) < -32768))) \t                        \\\n+         return 3;                                              \\\n+  case LABEL_REF:                                               \\\n+  case SYMBOL_REF:                                              \\\n+  case CONST_DOUBLE:                                            \\\n+    return 1;                                                   \\\n+\n+\n+/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n+   This can be used, for example, to indicate how costly a multiply\n+   instruction is.  In writing this macro, you can use the construct\n+   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n+   instructions.  OUTER_CODE is the code of the expression in which X\n+   is contained.\n+\n+   This macro is optional; do not define it if the default cost\n+   assumptions are adequate for the target machine.  */\n+\n+#define RTX_COSTS(X, CODE, OUTER_CODE)                                  \\\n+  case ASHIFT:                                                          \\\n+  case ASHIFTRT:                                                        \\\n+  case LSHIFTRT:                                                        \\\n+  case PLUS:                                                            \\\n+  case AND:                                                             \\\n+  case IOR:                                                             \\\n+  case XOR:                                                             \\\n+  case MINUS:                                                           \\\n+  case NEG:                                                             \\\n+  case NOT:                                                             \\\n+          return 1;                                                     \\\n+  case MULT:                                                            \\\n+    if (GET_MODE (XEXP (X, 0)) == DImode)                               \\\n+      return 40;                                                        \\\n+        else                                                            \\\n+      return 7;                                                         \\\n+  case DIV:                                                             \\\n+  case UDIV:                                                            \\\n+  case MOD:                                                             \\\n+  case UMOD:                                                            \\\n+          return 33;\n+\n+\n+/* An expression giving the cost of an addressing mode that contains\n+   ADDRESS.  If not defined, the cost is computed from the ADDRESS\n+   expression and the `CONST_COSTS' values.\n+\n+   For most CISC machines, the default cost is a good approximation\n+   of the true cost of the addressing mode.  However, on RISC\n+   machines, all instructions normally have the same length and\n+   execution time.  Hence all addresses will have equal costs.\n+\n+   In cases where more than one form of an address is known, the form\n+   with the lowest cost will be used.  If multiple forms have the\n+   same, lowest, cost, the one that is the most complex will be used.\n+\n+   For example, suppose an address that is equal to the sum of a\n+   register and a constant is used twice in the same basic block.\n+   When this macro is not defined, the address will be computed in a\n+   register and memory references will be indirect through that\n+   register.  On machines where the cost of the addressing mode\n+   containing the sum is no higher than that of a simple indirect\n+   reference, this will produce an additional instruction and\n+   possibly require an additional register.  Proper specification of\n+   this macro eliminates this overhead for such machines.\n+\n+   Similar use of this macro is made in strength reduction of loops.\n+\n+   ADDRESS need not be valid as an address.  In such a case, the cost\n+   is not relevant and can be any value; invalid addresses need not be\n+   assigned a different cost.\n+\n+   On machines where an address involving more than one register is as\n+   cheap as an address computation involving only one register,\n+   defining `ADDRESS_COST' to reflect this can cause two registers to\n+   be live over a region of code where only one would have been if\n+   `ADDRESS_COST' were not defined in that manner.  This effect should\n+   be considered in the definition of this macro.  Equivalent costs\n+   should probably only be given to addresses with different numbers\n+   of registers on machines with lots of registers.\n+\n+   This macro will normally either not be defined or be defined as a\n+   constant.\n+\n+   On s390 symbols are expensive if compiled with fpic\n+   lifetimes.  */\n+\n+#define ADDRESS_COST(RTX) \\\n+  ((flag_pic && GET_CODE (RTX) == SYMBOL_REF) ? 2 : 1)\n+\n+/* On s390, copy between fprs and gprs is expensive.  */\n+\n+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)                        \\\n+  (((CLASS1 != CLASS2) &&                                               \\\n+   (CLASS1 == FP_REGS || CLASS2 == FP_REGS)) ? 10 : 1)\n+\n+\n+/* A C expression for the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.  */\n+\n+#define MEMORY_MOVE_COST(M, C, I) 1\n+\n+/* A C expression for the cost of a branch instruction.  A value of 1\n+   is the default; other values are interpreted relative to that.  */\n+\n+#define BRANCH_COST 1\n+\n+/* Add any extra modes needed to represent the condition code. */\n+#define EXTRA_CC_MODES \\\n+\tCC (CCZmode, \"CCZ\") \\\n+\tCC (CCAmode, \"CCA\") \\\n+\tCC (CCUmode, \"CCU\") \\\n+\tCC (CCSmode, \"CCS\") \\\n+\tCC (CCTmode, \"CCT\")\n+ \n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison. */\n+ \n+#define SELECT_CC_MODE(OP,X,Y)              \\\n+ (   (OP) == EQ  || (OP) == NE  ? CCZmode   \\\n+   : (OP) == LE  || (OP) == LT  ||          \\\n+     (OP) == GE  || (OP) == GT  ? CCSmode   \\\n+   : (OP) == LEU || (OP) == LTU ||          \\\n+     (OP) == GEU || (OP) == GTU ? CCUmode   \\\n+   : CCmode )\n+ \n+ \n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+ \n+extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n+ \n+extern int s390_match_ccmode PARAMS ((struct rtx_def *, int));\n+\n+\n+/* How to refer to registers in assembler output.  This sequence is\n+   indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{ \"%r0\",  \"%r1\",  \"%r2\",  \"%r3\",  \"%r4\",  \"%r5\",  \"%r6\",  \"%r7\",\t\\\n+  \"%r8\",  \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\\\n+  \"%f0\",  \"%f2\",  \"%f4\",  \"%f6\",  \"%f1\",  \"%f3\",  \"%f5\",  \"%f7\",\t\\\n+  \"%f8\",  \"%f10\", \"%f12\", \"%f14\", \"%f9\", \"%f11\", \"%f13\", \"%f15\",\t\\\n+  \"%ap\", \"%cc\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* implicit call of memcpy, not bcopy   */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+\n+/* Define the codes that are matched by predicates in aux-output.c.  */\n+\n+#define PREDICATE_CODES                                                 \\\n+  {\"s_operand\",       { MEM }},                                          \\\n+  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},                            \\\n+  {\"r_or_s_operand\",  { MEM, SUBREG, REG }},                             \\\n+  {\"r_or_im8_operand\",  { CONST_INT, SUBREG, REG }},                     \\\n+  {\"r_or_s_or_im8_operand\",  { MEM, SUBREG, REG, CONST_INT }},           \\\n+  {\"r_or_x_or_im16_operand\", { MEM, SUBREG, REG, CONST_INT }},           \\\n+  {\"const0_operand\", { CONST_INT, CONST_DOUBLE }},\t                 \\\n+  {\"const1_operand\", { CONST_INT, CONST_DOUBLE }},\t                 \\\n+  {\"tmxx_operand\", { CONST_INT, MEM }},\n+\n+\n+/* A C statement (sans semicolon) to update the integer variable COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  This can be used for example to specify to\n+   the scheduler that an output- or anti-dependence does not incur\n+   the same cost as a data-dependence.  */\n+\n+#define ADJUST_COST(insn, link, dep_insn, cost) \\\n+  (cost) = s390_adjust_cost (insn, link, dep_insn, cost)\n+\n+\n+/* Constant Pool for all symbols operands which are changed with\n+   force_const_mem during insn generation (expand_insn).  */\n+\n+extern struct rtx_def *s390_pool_start_insn;\n+extern int s390_pool_count;\n+extern int s390_nr_constants;\n+\n+/* Function is splitted in chunk, if literal pool could overflow\n+   Value need to be lowered, if problems with displacement overflow.  */\n+\n+#define S390_REL_MAX 55000\n+#define S390_CHUNK_MAX 0x2000\n+#define S390_CHUNK_OV 0x8000\n+#define S390_POOL_MAX 0xe00\n+\n+#define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, fndecl, size)  \t        \\\n+{\t\t\t\t\t\t\t\t       \t\\\n+  register rtx insn;\t\t\t\t\t\t       \t\\\n+  struct pool_constant *pool;\t\t\t\t\t       \t\\\n+\t\t\t\t\t\t\t\t        \\\n+    if (s390_pool_count == -1)                                        \t\\\n+     {\t\t\t\t\t\t\t                \\\n+       s390_nr_constants = 0;\t\t\t\t                \\\n+       for (pool = first_pool; pool; pool = pool->next)\t                \\\n+\t if (pool->mark) s390_nr_constants++;\t\t                \\\n+       return;                                      \t                \\\n+     }                                                                  \\\n+    if (first_pool == 0) {                                              \\\n+      s390_asm_output_pool_prologue (FILE, FUNNAME, fndecl, size);    \t\\\n+      return;\t\t\t\t\t\t\t      \t\\\n+    }\t\t\t\t\t\t\t\t       \t\\\n+    for (pool = first_pool; pool; pool = pool->next)\t\t       \t\\\n+      pool->mark = 0;\t\t\t\t\t\t       \t\\\n+  \t\t\t\t\t\t\t\t       \t\\\n+    insn = s390_pool_start_insn;\t\t\t\t       \t\\\n+  \t\t\t\t\t\t\t\t       \t\\\n+    if (insn==NULL_RTX)\t \t\t\t\t\t       \t\\\n+      insn = get_insns ();\t\t \t\t                \\\n+    else\t\t       \t\t\t                        \\\n+      insn = NEXT_INSN (insn);\t\t                                \\\n+    for (; insn; insn = NEXT_INSN (insn)) {    \t\t                \\\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i') {\t\t       \t\\\n+        if (s390_stop_dump_lit_p (insn)) { \t       \t\t       \t\\\n+\t  mark_constants (PATTERN (insn));\t\t\t       \t\\\n+\t  break;\t\t\t\t\t\t       \t\\\n+        } else\t\t\t\t\t\t\t       \t\\\n+\t  mark_constants (PATTERN (insn));\t\t\t       \t\\\n+      }\t\t\t\t\t\t\t\t       \t\\\n+    }\t\t\t\t\t\t\t\t       \t\\\n+\t\t\t\t\t\t\t\t       \t\\\n+    /* Mark entries referenced by other entries */\t\t\t\\\n+    for (pool = first_pool; pool; pool = pool->next)\t\t       \t\\\n+      if (pool->mark)\t\t\t\t\t\t\t\\\n+        mark_constants(pool->constant);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t       \t\\\n+    s390_asm_output_pool_prologue (FILE, FUNNAME, fndecl, size);     \t\\\n+}\n+\n+/* We need to return, because otherwise the pool is deleted of the \n+   constant pool after the first output.  */\n+\n+#define ASM_OUTPUT_POOL_EPILOGUE(FILE, FUNNAME, fndecl, size) return;\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, EXP, MODE, ALIGN, LABELNO, WIN) \\\n+{                                                                       \\\n+  if ((s390_pool_count == 0) || (s390_pool_count > 0 && LABELNO >= 0)) \t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \".LC%d:\\n\", LABELNO);                              \\\n+      LABELNO = ~LABELNO;                                               \\\n+    }                                                                   \\\n+  if (s390_pool_count > 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \".LC%d_%X:\\n\", ~LABELNO, s390_pool_count);         \\\n+    }                            \t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Output the value of the constant itself.  */\t\t\t\\\n+  switch (GET_MODE_CLASS (pool->mode))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case MODE_FLOAT:\t\t\t\t\t\t\t\\\n+      if (GET_CODE (x) != CONST_DOUBLE)\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\t\\\n+      assemble_real (u.d, pool->mode);\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+    case MODE_INT:\t\t\t\t\t\t\t\\\n+    case MODE_PARTIAL_INT:\t\t\t\t\t\t\\\n+      if (flag_pic && (GET_CODE (x) == CONST ||                         \\\n+\t\t   GET_CODE (x) == SYMBOL_REF ||                        \\\n+                   GET_CODE (x) == LABEL_REF ))                         \\\n+        {\t\t\t\t\t\t\t\t\\\n+          fprintf (FILE, \"%s\\t\",TARGET_64BIT ? ASM_QUAD : ASM_LONG);\t\\\n+          s390_output_symbolic_const (FILE, x); \t\t\t\\\n+          fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+\t}                                                               \\\n+      else                                                              \\\n+        assemble_integer (x, GET_MODE_SIZE (pool->mode), 1);\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  goto WIN;\t\t\t\t\t\t\t\t\\\n+}\n+\n+#endif "}, {"sha": "5c6b1830829ecd446935de41e3a2a64d69daa67f", "filename": "gcc/config/s390/s390.md", "status": "added", "additions": 5834, "deletions": 0, "changes": 5834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168"}, {"sha": "07c772775ce0e65123a80fb19fc956ed33ca191d", "filename": "gcc/config/s390/t-linux", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db1d521d8881f0aa812f6af77fb5e74a456c168/gcc%2Fconfig%2Fs390%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-linux?ref=9db1d521d8881f0aa812f6af77fb5e74a456c168", "patch": "@@ -0,0 +1,11 @@\n+# The crtbegin and crtend must not depend on a small GOT\n+CRTSTUFF_T_CFLAGS = -O2 -fPIC\n+\n+linux.o: $(srcdir)/config/s390/linux.c $(CONFIG_H) \n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/s390/linux.c\n+\n+# Compile libgcc2.a with pic.\n+TARGET_LIBGCC2_CFLAGS = -fPIC -include $(srcdir)/config/s390/fixdfdi.h\n+\n+\n+"}]}