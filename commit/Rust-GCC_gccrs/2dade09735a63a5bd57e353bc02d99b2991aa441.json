{"sha": "2dade09735a63a5bd57e353bc02d99b2991aa441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhZGUwOTczNWE2M2E1YmQ1N2UzNTNiYzAyZDk5YjI5OTFhYTQ0MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-02-24T17:07:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T17:07:48Z"}, "message": "sem_ch6.adb (Analyze_Subprogram_Body_Contract): Do not enforce global and dependence refinement when SPARK_Mode is off.\n\n2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Do not enforce\n\tglobal and dependence refinement when SPARK_Mode is off.\n\t* sem_ch7.adb (Analyze_Package_Body_Contract): Do not enforce\n\tstate refinement when SPARK_Mode is off.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add local\n\tvariable Decl. Insert the generated pragma for Refined_State\n\tafter a potential pragma SPARK_Mode.\n\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Add local\n\tconstant Deps. Remove local variable Expr. Check the syntax\n\tof pragma Depends when SPARK_Mode is off. Factor out the\n\tprocessing for extra parenthesis around individual clauses.\n\t(Analyze_Global_In_Decl_List): Items is now a constant. Check\n\tthe syntax of pragma Global when SPARK_Mode is off.\n\t(Analyze_Initializes_In_Decl_Part): Check the syntax of pragma\n\tInitializes when SPARK_Mode is off.\n\t(Analyze_Part_Of): Check\n\tthe syntax of the encapsulating state when SPARK_Mode is off.\n\t(Analyze_Pragma): Check the syntax of pragma Abstract_State when\n\tSPARK_Mode is off. Move the declaration order check with respect\n\tto pragma Initializes to the end of the processing. Do not verify\n\tthe declaration order for pragma Initial_Condition when SPARK_Mode\n\tis off. Do not complain about a useless package refinement when\n\tSPARK_Mode is off.\n\t(Analyze_Refined_Depends_In_Decl_Part): Refs\n\tis now a constant. Check the syntax of pragma Refined_Depends\n\twhen SPARK_Mode is off.\n\t(Analyze_Refined_Global_In_Decl_Part):\n\tCheck the syntax of pragma Refined_Global when SPARK_Mode is off.\n\t(Analyze_Refined_State_In_Decl_Part): Check the syntax of pragma\n\tRefined_State when SPARK_Mode is off.\n\t(Check_Dependence_List_Syntax): New routine.\n\t(Check_Global_List_Syntax): New routine.\n\t(Check_Initialization_List_Syntax): New routine.\n\t(Check_Item_Syntax): New routine.\n\t(Check_State_Declaration_Syntax): New routine.\n\t(Check_Refinement_List_Syntax): New routine.\n\t(Has_Extra_Parentheses): Moved to the top level of Sem_Prag.\n\nFrom-SVN: r208087", "tree": {"sha": "9875799cdb5f5c19cd90b9c5af60bc4c90c5602e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9875799cdb5f5c19cd90b9c5af60bc4c90c5602e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dade09735a63a5bd57e353bc02d99b2991aa441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dade09735a63a5bd57e353bc02d99b2991aa441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dade09735a63a5bd57e353bc02d99b2991aa441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dade09735a63a5bd57e353bc02d99b2991aa441/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "158d55fa393867c794df5aa43b693f61e5916b83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158d55fa393867c794df5aa43b693f61e5916b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158d55fa393867c794df5aa43b693f61e5916b83"}], "stats": {"total": 701, "additions": 607, "deletions": 94}, "files": [{"sha": "be02a0e4d14a58b9a41947942f2d02d418770ade", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2dade09735a63a5bd57e353bc02d99b2991aa441", "patch": "@@ -1,3 +1,43 @@\n+2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Do not enforce\n+\tglobal and dependence refinement when SPARK_Mode is off.\n+\t* sem_ch7.adb (Analyze_Package_Body_Contract): Do not enforce\n+\tstate refinement when SPARK_Mode is off.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add local\n+\tvariable Decl. Insert the generated pragma for Refined_State\n+\tafter a potential pragma SPARK_Mode.\n+\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Add local\n+\tconstant Deps. Remove local variable Expr. Check the syntax\n+\tof pragma Depends when SPARK_Mode is off. Factor out the\n+\tprocessing for extra parenthesis around individual clauses.\n+\t(Analyze_Global_In_Decl_List): Items is now a constant. Check\n+\tthe syntax of pragma Global when SPARK_Mode is off.\n+\t(Analyze_Initializes_In_Decl_Part): Check the syntax of pragma\n+\tInitializes when SPARK_Mode is off.\n+\t(Analyze_Part_Of): Check\n+\tthe syntax of the encapsulating state when SPARK_Mode is off.\n+\t(Analyze_Pragma): Check the syntax of pragma Abstract_State when\n+\tSPARK_Mode is off. Move the declaration order check with respect\n+\tto pragma Initializes to the end of the processing. Do not verify\n+\tthe declaration order for pragma Initial_Condition when SPARK_Mode\n+\tis off. Do not complain about a useless package refinement when\n+\tSPARK_Mode is off.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Refs\n+\tis now a constant. Check the syntax of pragma Refined_Depends\n+\twhen SPARK_Mode is off.\n+\t(Analyze_Refined_Global_In_Decl_Part):\n+\tCheck the syntax of pragma Refined_Global when SPARK_Mode is off.\n+\t(Analyze_Refined_State_In_Decl_Part): Check the syntax of pragma\n+\tRefined_State when SPARK_Mode is off.\n+\t(Check_Dependence_List_Syntax): New routine.\n+\t(Check_Global_List_Syntax): New routine.\n+\t(Check_Initialization_List_Syntax): New routine.\n+\t(Check_Item_Syntax): New routine.\n+\t(Check_State_Declaration_Syntax): New routine.\n+\t(Check_Refinement_List_Syntax): New routine.\n+\t(Has_Extra_Parentheses): Moved to the top level of Sem_Prag.\n+\n 2014-02-24  Robert Dewar  <dewar@adacore.com>\n \n \t* a-tags.adb, s-os_lib.adb: Minor reformatting."}, {"sha": "efa359fdb970323337410c30d82bfa9586ce4b59", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2dade09735a63a5bd57e353bc02d99b2991aa441", "patch": "@@ -2343,6 +2343,7 @@ package body Sem_Ch13 is\n                --  Refined_State\n \n                when Aspect_Refined_State => Refined_State : declare\n+                  Decl  : Node_Id;\n                   Decls : List_Id;\n \n                begin\n@@ -2352,21 +2353,38 @@ package body Sem_Ch13 is\n                   --  the pragma.\n \n                   if Nkind (N) = N_Package_Body then\n-                     Decls := Declarations (N);\n-\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Refined_State);\n                      Decorate_Aspect_And_Pragma (Aspect, Aitem);\n \n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Declarations (N, Decls);\n-                     end if;\n+                     Decls := Declarations (N);\n \n-                     Prepend_To (Decls, Aitem);\n+                     --  When the package body is subject to pragma SPARK_Mode,\n+                     --  insert pragma Refined_State after SPARK_Mode.\n+\n+                     if Present (Decls) then\n+                        Decl := First (Decls);\n+\n+                        if Nkind (Decl) = N_Pragma\n+                          and then Pragma_Name (Decl) = Name_SPARK_Mode\n+                        then\n+                           Insert_After (Decl, Aitem);\n+\n+                        --  The related package body lacks SPARK_Mode, the\n+                        --  corresponding pragma must be the first declaration.\n+\n+                        else\n+                           Prepend_To (Decls, Aitem);\n+                        end if;\n+\n+                     --  Otherwise the pragma forms a new declarative list\n+\n+                     else\n+                        Set_Declarations (N, New_List (Aitem));\n+                     end if;\n \n                   else\n                      Error_Msg_NE"}, {"sha": "eea32001c054028c76fdd5ddab0f586e9cf261d0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2dade09735a63a5bd57e353bc02d99b2991aa441", "patch": "@@ -2062,12 +2062,16 @@ package body Sem_Ch6 is\n          Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n \n       --  When the corresponding Global aspect/pragma references a state with\n-      --  visible refinement, the body requires Refined_Global.\n+      --  visible refinement, the body requires Refined_Global. Refinement is\n+      --  not required when SPARK checks are suppressed.\n \n       elsif Present (Spec_Id) then\n          Prag := Get_Pragma (Spec_Id, Pragma_Global);\n \n-         if Present (Prag) and then Contains_Refined_State (Prag) then\n+         if SPARK_Mode /= Off\n+           and then Present (Prag)\n+           and then Contains_Refined_State (Prag)\n+         then\n             Error_Msg_NE\n               (\"body of subprogram & requires global refinement\",\n                Body_Decl, Spec_Id);\n@@ -2081,12 +2085,16 @@ package body Sem_Ch6 is\n          Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n \n       --  When the corresponding Depends aspect/pragma references a state with\n-      --  visible refinement, the body requires Refined_Depends.\n+      --  visible refinement, the body requires Refined_Depends. Refinement is\n+      --  not required when SPARK checks are suppressed.\n \n       elsif Present (Spec_Id) then\n          Prag := Get_Pragma (Spec_Id, Pragma_Depends);\n \n-         if Present (Prag) and then Contains_Refined_State (Prag) then\n+         if SPARK_Mode /= Off\n+           and then Present (Prag)\n+           and then Contains_Refined_State (Prag)\n+         then\n             Error_Msg_NE\n               (\"body of subprogram & requires dependance refinement\",\n                Body_Decl, Spec_Id);"}, {"sha": "f5d146ffe00f991a0810a4ed56fc36fe9d4fabf9", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=2dade09735a63a5bd57e353bc02d99b2991aa441", "patch": "@@ -191,10 +191,13 @@ package body Sem_Ch7 is\n       if Present (Prag) then\n          Analyze_Refined_State_In_Decl_Part (Prag);\n \n-      --  State refinement is required when the package declaration has\n-      --  abstract states. Null states are not considered.\n+      --  State refinement is required when the package declaration defines at\n+      --  least one abstract state. Null states are not considered. Refinement\n+      --  is not envorced when SPARK checks are turned off.\n \n-      elsif Requires_State_Refinement (Spec_Id, Body_Id) then\n+      elsif SPARK_Mode /= Off\n+        and then Requires_State_Refinement (Spec_Id, Body_Id)\n+      then\n          Error_Msg_N (\"package & requires state refinement\", Spec_Id);\n       end if;\n    end Analyze_Package_Body_Contract;"}, {"sha": "a4c247dfa0f4ff1b648a030f153c6dea3e85dfaf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 524, "deletions": 80, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dade09735a63a5bd57e353bc02d99b2991aa441/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2dade09735a63a5bd57e353bc02d99b2991aa441", "patch": "@@ -184,6 +184,19 @@ package body Sem_Prag is\n    --  whether a particular item appears in a mixed list of nodes and entities.\n    --  It is assumed that all nodes in the list have entities.\n \n+   procedure Check_Dependence_List_Syntax (List : Node_Id);\n+   --  Subsidiary to the analysis of pragmas Depends and Refined_Depends.\n+   --  Verify the syntax of dependence relation List.\n+\n+   procedure Check_Global_List_Syntax (List : Node_Id);\n+   --  Subsidiary to the analysis of pragmas Global and Refined_Global. Verify\n+   --  the syntax of global list List.\n+\n+   procedure Check_Item_Syntax (Item : Node_Id);\n+   --  Subsidiary to the analysis of pragmas Depends, Global, Initializes,\n+   --  Part_Of, Refined_Depends, Refined_Depends and Refined_State. Verify the\n+   --  syntax of a SPARK annotation item.\n+\n    function Check_Kind (Nam : Name_Id) return Name_Id;\n    --  This function is used in connection with pragmas Assert, Check,\n    --  and assertion aspects and pragmas, to determine if Check pragmas\n@@ -268,6 +281,11 @@ package body Sem_Prag is\n    --  Get_SPARK_Mode_Type. Convert a name into a corresponding value of type\n    --  SPARK_Mode_Type.\n \n+   function Has_Extra_Parentheses (Clause : Node_Id) return Boolean;\n+   --  Subsidiary to the analysis of pragmas Depends and Refined_Depends.\n+   --  Determine whether dependency clause Clause is surrounded by extra\n+   --  parentheses. If this is the case, issue an error message.\n+\n    function Is_Unconstrained_Or_Tagged_Item (Item : Entity_Id) return Boolean;\n    --  Subsidiary to Collect_Subprogram_Inputs_Outputs and the analysis of\n    --  pragma Depends. Determine whether the type of dependency item Item is\n@@ -986,9 +1004,9 @@ package body Sem_Prag is\n          Analyze_Input_List (Inputs);\n       end Analyze_Dependency_Clause;\n \n-      ----------------------------\n-      --  Check_Function_Return --\n-      ----------------------------\n+      ---------------------------\n+      -- Check_Function_Return --\n+      ---------------------------\n \n       procedure Check_Function_Return is\n       begin\n@@ -1659,9 +1677,11 @@ package body Sem_Prag is\n \n       --  Local variables\n \n+      Deps        : constant Node_Id :=\n+                      Get_Pragma_Arg\n+                        (First (Pragma_Argument_Associations (N)));\n       Clause      : Node_Id;\n       Errors      : Nat;\n-      Expr        : Node_Id;\n       Last_Clause : Node_Id;\n       Subp_Decl   : Node_Id;\n \n@@ -1673,6 +1693,14 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n+      --  Verify the syntax of pragma Depends when SPARK checks are suppressed.\n+      --  Semantic analysis and normalization are disabled in this mode.\n+\n+      if SPARK_Mode = Off then\n+         Check_Dependence_List_Syntax (Deps);\n+         return;\n+      end if;\n+\n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n       Subp_Id   := Defining_Entity (Subp_Decl);\n \n@@ -1693,11 +1721,9 @@ package body Sem_Prag is\n          Spec_Id := Subp_Id;\n       end if;\n \n-      Clause := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n-\n       --  Empty dependency list\n \n-      if Nkind (Clause) = N_Null then\n+      if Nkind (Deps) = N_Null then\n \n          --  Gather all states, variables and formal parameters that the\n          --  subprogram may depend on. These items are obtained from the\n@@ -1718,51 +1744,17 @@ package body Sem_Prag is\n \n       --  Dependency clauses appear as component associations of an aggregate\n \n-      elsif Nkind (Clause) = N_Aggregate then\n-\n-         --  The aggregate should not have an expression list because a clause\n-         --  is always interpreted as a component association. The only way an\n-         --  expression list can sneak in is by adding extra parenthesis around\n-         --  the individual clauses:\n-\n-         --    Depends  (Output => Input)   --  proper form\n-         --    Depends ((Output => Input))  --  extra parenthesis\n-\n-         --  Since the extra parenthesis are not allowed by the syntax of the\n-         --  pragma, flag them now to avoid emitting misleading errors down the\n-         --  line.\n-\n-         if Present (Expressions (Clause)) then\n-            Expr := First (Expressions (Clause));\n-            while Present (Expr) loop\n-\n-               --  A dependency clause surrounded by extra parenthesis appears\n-               --  as an aggregate of component associations with an optional\n-               --  Paren_Count set.\n+      elsif Nkind (Deps) = N_Aggregate then\n \n-               if Nkind (Expr) = N_Aggregate\n-                 and then Present (Component_Associations (Expr))\n-               then\n-                  Error_Msg_N\n-                    (\"dependency clause contains extra parentheses\", Expr);\n-\n-               --  Otherwise the expression is a malformed construct\n-\n-               else\n-                  Error_Msg_N (\"malformed dependency clause\", Expr);\n-               end if;\n-\n-               Next (Expr);\n-            end loop;\n-\n-            --  Do not attempt to perform analysis of syntactically illegal\n-            --  clauses as this will lead to misleading errors.\n+         --  Do not attempt to perform analysis of a syntactically illegal\n+         --  clause as this will lead to misleading errors.\n \n+         if Has_Extra_Parentheses (Deps) then\n             return;\n          end if;\n \n-         if Present (Component_Associations (Clause)) then\n-            Last_Clause := Last (Component_Associations (Clause));\n+         if Present (Component_Associations (Deps)) then\n+            Last_Clause := Last (Component_Associations (Deps));\n \n             --  Gather all states, variables and formal parameters that the\n             --  subprogram may depend on. These items are obtained from the\n@@ -1785,7 +1777,7 @@ package body Sem_Prag is\n                Install_Formals (Spec_Id);\n             end if;\n \n-            Clause := First (Component_Associations (Clause));\n+            Clause := First (Component_Associations (Deps));\n             while Present (Clause) loop\n                Errors := Serious_Errors_Detected;\n \n@@ -1825,14 +1817,14 @@ package body Sem_Prag is\n          --  The dependency list is malformed\n \n          else\n-            Error_Msg_N (\"malformed dependency relation\", Clause);\n+            Error_Msg_N (\"malformed dependency relation\", Deps);\n             return;\n          end if;\n \n       --  The top level dependency relation is malformed\n \n       else\n-         Error_Msg_N (\"malformed dependency relation\", Clause);\n+         Error_Msg_N (\"malformed dependency relation\", Deps);\n          return;\n       end if;\n \n@@ -2318,13 +2310,14 @@ package body Sem_Prag is\n          --  Any other attempt to declare a global item is erroneous\n \n          else\n-            Error_Msg_N (\"malformed global list declaration\", List);\n+            Error_Msg_N (\"malformed global list\", List);\n          end if;\n       end Analyze_Global_List;\n \n       --  Local variables\n \n-      Items     : Node_Id;\n+      Items     : constant Node_Id :=\n+                    Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n       Subp_Decl : Node_Id;\n \n       Restore_Scope : Boolean := False;\n@@ -2335,6 +2328,14 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n+      --  Verify the syntax of pragma Global when SPARK checks are suppressed.\n+      --  Semantic analysis is disabled in this mode.\n+\n+      if SPARK_Mode = Off then\n+         Check_Global_List_Syntax (Items);\n+         return;\n+      end if;\n+\n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n       Subp_Id   := Defining_Entity (Subp_Decl);\n \n@@ -2355,8 +2356,6 @@ package body Sem_Prag is\n          Spec_Id := Subp_Id;\n       end if;\n \n-      Items := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n-\n       --  There is nothing to be done for a null global list\n \n       if Nkind (Items) = N_Null then\n@@ -2449,6 +2448,9 @@ package body Sem_Prag is\n       --  Verify the legality of a single initialization item followed by a\n       --  list of input items.\n \n+      procedure Check_Initialization_List_Syntax (List : Node_Id);\n+      --  Verify the syntax of initialization list List\n+\n       procedure Collect_States_And_Variables;\n       --  Inspect the visible declarations of the related package and gather\n       --  the entities of all abstract states and variables in States_And_Vars.\n@@ -2695,6 +2697,61 @@ package body Sem_Prag is\n          end if;\n       end Analyze_Initialization_Item_With_Inputs;\n \n+      --------------------------------------\n+      -- Check_Initialization_List_Syntax --\n+      --------------------------------------\n+\n+      procedure Check_Initialization_List_Syntax (List : Node_Id) is\n+         Init  : Node_Id;\n+         Input : Node_Id;\n+\n+      begin\n+         --  Null initialization list\n+\n+         if Nkind (List) = N_Null then\n+            null;\n+\n+         elsif Nkind (List) = N_Aggregate then\n+\n+            --  Simple initialization items\n+\n+            if Present (Expressions (List)) then\n+               Init := First (Expressions (List));\n+               while Present (Init) loop\n+                  Check_Item_Syntax (Init);\n+                  Next (Init);\n+               end loop;\n+            end if;\n+\n+            --  Initialization items with a input lists\n+\n+            if Present (Component_Associations (List)) then\n+               Init := First (Component_Associations (List));\n+               while Present (Init) loop\n+                  Check_Item_Syntax (First (Choices (Init)));\n+\n+                  if Nkind (Expression (Init)) = N_Aggregate\n+                    and then Present (Expressions (Expression (Init)))\n+                  then\n+                     Input := First (Expressions (Expression (Init)));\n+                     while Present (Input) loop\n+                        Check_Item_Syntax (Input);\n+                        Next (Input);\n+                     end loop;\n+\n+                  else\n+                     Error_Msg_N (\"malformed initialization item\", Init);\n+                  end if;\n+\n+                  Next (Init);\n+               end loop;\n+            end if;\n+\n+         else\n+            Error_Msg_N (\"malformed initialization list\", List);\n+         end if;\n+      end Check_Initialization_List_Syntax;\n+\n       ----------------------------------\n       -- Collect_States_And_Variables --\n       ----------------------------------\n@@ -2742,6 +2799,13 @@ package body Sem_Prag is\n \n       if Nkind (Inits) = N_Null then\n          return;\n+\n+      --  Verify the syntax of pragma Initializes when SPARK checks are\n+      --  suppressed. Semantic analysis is disabled in this mode.\n+\n+      elsif SPARK_Mode = Off then\n+         Check_Initialization_List_Syntax (Inits);\n+         return;\n       end if;\n \n       --  Single and multiple initialization clauses appear as an aggregate. If\n@@ -3403,6 +3467,14 @@ package body Sem_Prag is\n \n          Legal := False;\n \n+         --  Verify the syntax of the encapsulating state when SPARK check are\n+         --  suppressed. Semantic analysis is disabled in this mode.\n+\n+         if SPARK_Mode = Off then\n+            Check_Item_Syntax (State);\n+            return;\n+         end if;\n+\n          Analyze       (State);\n          Resolve_State (State);\n \n@@ -10037,6 +10109,9 @@ package body Sem_Prag is\n             --  decorate a state abstraction entity and introduce it into the\n             --  visibility chain.\n \n+            procedure Check_State_Declaration_Syntax (State : Node_Id);\n+            --  Verify the syntex of state declaration State\n+\n             ----------------------------\n             -- Analyze_Abstract_State --\n             ----------------------------\n@@ -10542,6 +10617,49 @@ package body Sem_Prag is\n                end if;\n             end Analyze_Abstract_State;\n \n+            ------------------------------------\n+            -- Check_State_Declaration_Syntax --\n+            ------------------------------------\n+\n+            procedure Check_State_Declaration_Syntax (State : Node_Id) is\n+               Decl : Node_Id;\n+\n+            begin\n+               --  Null abstract state\n+\n+               if Nkind (State) = N_Null then\n+                  null;\n+\n+               --  Single state\n+\n+               elsif Nkind (State) = N_Identifier then\n+                  null;\n+\n+               --  State with various options\n+\n+               elsif Nkind (State) = N_Extension_Aggregate then\n+                  if Nkind (Ancestor_Part (State)) /= N_Identifier then\n+                     Error_Msg_N\n+                       (\"state name must be an identifier\",\n+                        Ancestor_Part (State));\n+                  end if;\n+\n+               --  Multiple states\n+\n+               elsif Nkind (State) = N_Aggregate\n+                 and then Present (Expressions (State))\n+               then\n+                  Decl := First (Expressions (State));\n+                  while Present (Decl) loop\n+                     Check_State_Declaration_Syntax (Decl);\n+                     Next (Decl);\n+                  end loop;\n+\n+               else\n+                  Error_Msg_N (\"malformed abstract state\", State);\n+               end if;\n+            end Check_State_Declaration_Syntax;\n+\n             --  Local variables\n \n             Context : constant Node_Id := Parent (Parent (N));\n@@ -10564,17 +10682,17 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Pack_Id := Defining_Entity (Context);\n-            Add_Contract_Item (N, Pack_Id);\n+            State := Expression (Arg1);\n \n-            --  Verify the declaration order of pragmas Abstract_State and\n-            --  Initializes.\n+            --  Verify the syntax of pragma Abstract_State when SPARK checks\n+            --  are suppressed. Semantic analysis is disabled in this mode.\n \n-            Check_Declaration_Order\n-              (First  => N,\n-               Second => Get_Pragma (Pack_Id, Pragma_Initializes));\n+            if SPARK_Mode = Off then\n+               Check_State_Declaration_Syntax (State);\n+               return;\n+            end if;\n \n-            State := Expression (Arg1);\n+            Pack_Id := Defining_Entity (Context);\n \n             --  Multiple non-null abstract states appear as an aggregate\n \n@@ -10591,6 +10709,17 @@ package body Sem_Prag is\n             else\n                Analyze_Abstract_State (State);\n             end if;\n+\n+            --  Save the pragma for retrieval by other tools\n+\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  Verify the declaration order of pragmas Abstract_State and\n+            --  Initializes.\n+\n+            Check_Declaration_Order\n+              (First  => N,\n+               Second => Get_Pragma (Pack_Id, Pragma_Initializes));\n          end Abstract_State;\n \n          ------------\n@@ -14891,15 +15020,18 @@ package body Sem_Prag is\n             Add_Contract_Item (N, Pack_Id);\n \n             --  Verify the declaration order of pragma Initial_Condition with\n-            --  respect to pragmas Abstract_State and Initializes.\n+            --  respect to pragmas Abstract_State and Initializes when SPARK\n+            --  checks are enabled.\n \n-            Check_Declaration_Order\n-              (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n-               Second => N);\n+            if SPARK_Mode /= Off then\n+               Check_Declaration_Order\n+                 (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n+                  Second => N);\n \n-            Check_Declaration_Order\n-              (First  => Get_Pragma (Pack_Id, Pragma_Initializes),\n-               Second => N);\n+               Check_Declaration_Order\n+                 (First  => Get_Pragma (Pack_Id, Pragma_Initializes),\n+                  Second => N);\n+            end if;\n          end Initial_Condition;\n \n          ------------------------\n@@ -15003,11 +15135,13 @@ package body Sem_Prag is\n             Add_Contract_Item (N, Pack_Id);\n \n             --  Verify the declaration order of pragmas Abstract_State and\n-            --  Initializes.\n+            --  Initializes when SPARK checks are enabled.\n \n-            Check_Declaration_Order\n-              (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n-               Second => N);\n+            if SPARK_Mode /= Off then\n+               Check_Declaration_Order\n+                 (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n+                  Second => N);\n+            end if;\n          end Initializes;\n \n          ------------\n@@ -18778,13 +18912,16 @@ package body Sem_Prag is\n                Stmt := Prev (Stmt);\n             end loop;\n \n-            --  State refinement is allowed only when the corresponding package\n-            --  declaration has a non-null pragma Abstract_State.\n-\n             Spec_Id := Corresponding_Spec (Context);\n \n-            if No (Abstract_States (Spec_Id))\n-              or else Has_Null_Abstract_State (Spec_Id)\n+            --  State refinement is allowed only when the corresponding package\n+            --  declaration has a non-null pragma Abstract_State. Refinement is\n+            --  not enforced when SPARK checks are suppressed.\n+\n+            if SPARK_Mode /= Off\n+              and then\n+                (No (Abstract_States (Spec_Id))\n+                   or else Has_Null_Abstract_State (Spec_Id))\n             then\n                Error_Msg_NE\n                  (\"useless refinement, package & does not define abstract \"\n@@ -22184,13 +22321,22 @@ package body Sem_Prag is\n \n       Body_Decl : constant Node_Id := Parent (N);\n       Errors    : constant Nat     := Serious_Errors_Detected;\n+      Refs      : constant Node_Id :=\n+                    Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n       Clause    : Node_Id;\n       Deps      : Node_Id;\n-      Refs      : Node_Id;\n \n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n    begin\n+      --  Verify the syntax of pragma Refined_Depends when SPARK checks are\n+      --  suppressed. Semantic analysis is disabled in this mode.\n+\n+      if SPARK_Mode = Off then\n+         Check_Dependence_List_Syntax (Refs);\n+         return;\n+      end if;\n+\n       Spec_Id := Corresponding_Spec (Body_Decl);\n       Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n \n@@ -22228,7 +22374,6 @@ package body Sem_Prag is\n       --  is consistent with their role.\n \n       Analyze_Depends_In_Decl_Part (N);\n-      Refs := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       if Serious_Errors_Detected = Errors then\n          if Nkind (Refs) = N_Null then\n@@ -22950,6 +23095,14 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_Global_In_Decl_Part\n \n    begin\n+      --  Verify the syntax of pragma Refined_Global when SPARK checks are\n+      --  suppressed. Semantic analysis is disabled in this mode.\n+\n+      if SPARK_Mode = Off then\n+         Check_Global_List_Syntax (Items);\n+         return;\n+      end if;\n+\n       Global := Get_Pragma (Spec_Id, Pragma_Global);\n \n       --  The subprogram declaration lacks pragma Global. This renders\n@@ -23090,6 +23243,9 @@ package body Sem_Prag is\n       procedure Analyze_Refinement_Clause (Clause : Node_Id);\n       --  Perform full analysis of a single refinement clause\n \n+      procedure Check_Refinement_List_Syntax (List : Node_Id);\n+      --  Verify the syntax of refinement clause list List\n+\n       function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id;\n       --  Gather the entities of all abstract states and variables declared in\n       --  the body state space of package Pack_Id.\n@@ -23651,6 +23807,70 @@ package body Sem_Prag is\n          Report_Unused_Constituents (Part_Of_Constits);\n       end Analyze_Refinement_Clause;\n \n+      ----------------------------------\n+      -- Check_Refinement_List_Syntax --\n+      ----------------------------------\n+\n+      procedure Check_Refinement_List_Syntax (List : Node_Id) is\n+         procedure Check_Clause_Syntax (Clause : Node_Id);\n+         --  Verify the syntax of state refinement clause Clause\n+\n+         -------------------------\n+         -- Check_Clause_Syntax --\n+         -------------------------\n+\n+         procedure Check_Clause_Syntax (Clause : Node_Id) is\n+            Constits : constant Node_Id := Expression (Clause);\n+            Constit  : Node_Id;\n+\n+         begin\n+            --  State to be refined\n+\n+            Check_Item_Syntax (First (Choices (Clause)));\n+\n+            --  Multiple constituents\n+\n+            if Nkind (Constits) = N_Aggregate\n+              and then Present (Expressions (Constits))\n+            then\n+               Constit := First (Expressions (Constits));\n+               while Present (Constit) loop\n+                  Check_Item_Syntax (Constit);\n+                  Next (Constit);\n+               end loop;\n+\n+            --  Single constituent\n+\n+            else\n+               Check_Item_Syntax (Constits);\n+            end if;\n+         end Check_Clause_Syntax;\n+\n+         --  Local variables\n+\n+         Clause : Node_Id;\n+\n+      --  Start of processing for Check_Refinement_List_Syntax\n+\n+      begin\n+         --  Multiple state refinement clauses\n+\n+         if Nkind (List) = N_Aggregate\n+           and then Present (Component_Associations (List))\n+         then\n+            Clause := First (Component_Associations (List));\n+            while Present (Clause) loop\n+               Check_Clause_Syntax (Clause);\n+               Next (Clause);\n+            end loop;\n+\n+         --  Single state refinement clause\n+\n+         else\n+            Check_Clause_Syntax (List);\n+         end if;\n+      end Check_Refinement_List_Syntax;\n+\n       -------------------------\n       -- Collect_Body_States --\n       -------------------------\n@@ -23813,6 +24033,14 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n+      --  Verify the syntax of pragma Refined_State when SPARK checks are\n+      --  suppressed. Semantic analysis is disabled in this mode.\n+\n+      if SPARK_Mode = Off then\n+         Check_Refinement_List_Syntax (Clauses);\n+         return;\n+      end if;\n+\n       Body_Id := Defining_Entity (Body_Decl);\n       Spec_Id := Corresponding_Spec (Body_Decl);\n \n@@ -23997,6 +24225,89 @@ package body Sem_Prag is\n       end if;\n    end Check_Applicable_Policy;\n \n+   ----------------------------------\n+   -- Check_Dependence_List_Syntax --\n+   ----------------------------------\n+\n+   procedure Check_Dependence_List_Syntax (List : Node_Id) is\n+      procedure Check_Clause_Syntax (Clause : Node_Id);\n+      --  Verify the syntax of a dependency clause Clause\n+\n+      -------------------------\n+      -- Check_Clause_Syntax --\n+      -------------------------\n+\n+      procedure Check_Clause_Syntax (Clause : Node_Id) is\n+         Input  : Node_Id;\n+         Inputs : Node_Id;\n+         Output : Node_Id;\n+\n+      begin\n+         --  Output items\n+\n+         Output := First (Choices (Clause));\n+         while Present (Output) loop\n+            Check_Item_Syntax (Output);\n+            Next (Output);\n+         end loop;\n+\n+         Inputs := Expression (Clause);\n+\n+         --  A self-dependency appears as operator \"+\"\n+\n+         if Nkind (Inputs) = N_Op_Plus then\n+            Inputs := Right_Opnd (Inputs);\n+         end if;\n+\n+         --  Input items\n+\n+         if Nkind (Inputs) = N_Aggregate\n+           and then Present (Expressions (Inputs))\n+         then\n+            Input := First (Expressions (Inputs));\n+            while Present (Input) loop\n+               Check_Item_Syntax (Input);\n+               Next (Input);\n+            end loop;\n+\n+         else\n+            Error_Msg_N (\"malformed input dependency list\", Inputs);\n+         end if;\n+      end Check_Clause_Syntax;\n+\n+      --  Local variables\n+\n+      Clause : Node_Id;\n+\n+   --  Start of processing for Check_Dependence_List_Syntax\n+\n+   begin\n+      --  Null dependency relation\n+\n+      if Nkind (List) = N_Null then\n+         null;\n+\n+      --  Verify the syntax of a single or multiple dependency clauses\n+\n+      elsif Nkind (List) = N_Aggregate\n+        and then Present (Component_Associations (List))\n+      then\n+         Clause := First (Component_Associations (List));\n+         while Present (Clause) loop\n+            if Has_Extra_Parentheses (Clause) then\n+               null;\n+            else\n+               Check_Clause_Syntax (Clause);\n+            end if;\n+\n+            Next (Clause);\n+         end loop;\n+\n+      else\n+         Error_Msg_N (\"malformed dependency relation\", List);\n+      end if;\n+   end Check_Dependence_List_Syntax;\n+\n    -------------------------------\n    -- Check_External_Properties --\n    -------------------------------\n@@ -24048,6 +24359,88 @@ package body Sem_Prag is\n       end if;\n    end Check_External_Properties;\n \n+   ------------------------------\n+   -- Check_Global_List_Syntax --\n+   ------------------------------\n+\n+   procedure Check_Global_List_Syntax (List : Node_Id) is\n+      Assoc : Node_Id;\n+      Item  : Node_Id;\n+\n+   begin\n+      --  Null global list\n+\n+      if Nkind (List) = N_Null then\n+         null;\n+\n+      --  Single global item\n+\n+      elsif Nkind_In (List, N_Expanded_Name,\n+                            N_Identifier,\n+                            N_Selected_Component)\n+      then\n+         null;\n+\n+      elsif Nkind (List) = N_Aggregate then\n+\n+         --  Items in a simple global list\n+\n+         if Present (Expressions (List)) then\n+            Item := First (Expressions (List));\n+            while Present (Item) loop\n+               Check_Item_Syntax (Item);\n+               Next (Item);\n+            end loop;\n+\n+         --  Items in a moded global list\n+\n+         elsif Present (Component_Associations (List)) then\n+            Assoc := First (Component_Associations (List));\n+            while Present (Assoc) loop\n+               Check_Item_Syntax (First (Choices (Assoc)));\n+               Check_Global_List_Syntax (Expression (Assoc));\n+\n+               Next (Assoc);\n+            end loop;\n+         end if;\n+      else\n+         Error_Msg_N (\"malformed global list\", List);\n+      end if;\n+   end Check_Global_List_Syntax;\n+\n+   -----------------------\n+   -- Check_Item_Syntax --\n+   -----------------------\n+\n+   procedure Check_Item_Syntax (Item : Node_Id) is\n+   begin\n+      --  Null can appear in various annotation lists to denote a missing or\n+      --  optional relation.\n+\n+      if Nkind (Item) = N_Null then\n+         null;\n+\n+      --  Formal parameter, state or variable nodes\n+\n+      elsif Nkind_In (Item, N_Expanded_Name,\n+                            N_Identifier,\n+                            N_Selected_Component)\n+      then\n+         null;\n+\n+      --  Attribute 'Result can appear in annotations to denote the outcome of\n+      --  a function call.\n+\n+      elsif Is_Attribute_Result (Item) then\n+         null;\n+\n+      --  Any other node cannot possibly denote a legal SPARK item\n+\n+      else\n+         Error_Msg_N (\"malformed item\", Item);\n+      end if;\n+   end Check_Item_Syntax;\n+\n    ----------------\n    -- Check_Kind --\n    ----------------\n@@ -24845,6 +25238,57 @@ package body Sem_Prag is\n       end if;\n    end Get_SPARK_Mode_From_Pragma;\n \n+   ---------------------------\n+   -- Has_Extra_Parentheses --\n+   ---------------------------\n+\n+   function Has_Extra_Parentheses (Clause : Node_Id) return Boolean is\n+      Expr : Node_Id;\n+\n+   begin\n+      --  The aggregate should not have an expression list because a clause\n+      --  is always interpreted as a component association. The only way an\n+      --  expression list can sneak in is by adding extra parentheses around\n+      --  the individual clauses:\n+\n+      --    Depends  (Output => Input)   --  proper form\n+      --    Depends ((Output => Input))  --  extra parentheses\n+\n+      --  Since the extra parentheses are not allowed by the syntax of the\n+      --  pragma, flag them now to avoid emitting misleading errors down the\n+      --  line.\n+\n+      if Nkind (Clause) = N_Aggregate\n+        and then Present (Expressions (Clause))\n+      then\n+         Expr := First (Expressions (Clause));\n+         while Present (Expr) loop\n+\n+            --  A dependency clause surrounded by extra parentheses appears\n+            --  as an aggregate of component associations with an optional\n+            --  Paren_Count set.\n+\n+            if Nkind (Expr) = N_Aggregate\n+              and then Present (Component_Associations (Expr))\n+            then\n+               Error_Msg_N\n+                 (\"dependency clause contains extra parentheses\", Expr);\n+\n+            --  Otherwise the expression is a malformed construct\n+\n+            else\n+               Error_Msg_N (\"malformed dependency clause\", Expr);\n+            end if;\n+\n+            Next (Expr);\n+         end loop;\n+\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Has_Extra_Parentheses;\n+\n    ----------------\n    -- Initialize --\n    ----------------"}]}