{"sha": "a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmNzNmOTZmMTgyZDlhZmY2ZWM2M2MzOTI2YTc3M2EyYTJjNDA3NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-02-06T21:03:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-02-06T21:03:03Z"}, "message": "i386.c (ix86_expand_prologue): Emit a memory blockage after restoring registers saved to allocate the frame on...\n\n\t* config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage\n\tafter restoring registers saved to allocate the frame on Windows.\n\nFrom-SVN: r268593", "tree": {"sha": "dfe40150450a0acc1279ff8091d5adbf57afa31f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe40150450a0acc1279ff8091d5adbf57afa31f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/comments", "author": null, "committer": null, "parents": [{"sha": "2f2205e2ff78eb54a2aa2c8c2dc64aee7b1a8dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2205e2ff78eb54a2aa2c8c2dc64aee7b1a8dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2205e2ff78eb54a2aa2c8c2dc64aee7b1a8dbe"}], "stats": {"total": 52, "additions": 50, "deletions": 2}, "files": [{"sha": "21d1434ce6f96548887a87932d3bef16b96f5701", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "patch": "@@ -1,3 +1,8 @@\n+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage\n+\tafter restoring registers saved to allocate the frame on Windows.\n+\n 2019-02-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/89182"}, {"sha": "579a3ee3037af9668da9bf05e0ed7454fe84ca64", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "patch": "@@ -13579,8 +13579,9 @@ ix86_expand_prologue (void)\n \t}\n       m->fs.sp_offset += allocate;\n \n-      /* Use stack_pointer_rtx for relative addressing so that code\n-\t works for realigned stack, too.  */\n+      /* Use stack_pointer_rtx for relative addressing so that code works for\n+\t realigned stack.  But this means that we need a blockage to prevent\n+\t stores based on the frame pointer from being scheduled before.  */\n       if (r10_live && eax_live)\n         {\n \t  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, eax);\n@@ -13589,13 +13590,15 @@ ix86_expand_prologue (void)\n \t  t = plus_constant (Pmode, t, UNITS_PER_WORD);\n \t  emit_move_insn (gen_rtx_REG (word_mode, AX_REG),\n \t\t\t  gen_frame_mem (word_mode, t));\n+\t  emit_insn (gen_memory_blockage ());\n \t}\n       else if (eax_live || r10_live)\n \t{\n \t  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, eax);\n \t  emit_move_insn (gen_rtx_REG (word_mode,\n \t\t\t\t       (eax_live ? AX_REG : R10_REG)),\n \t\t\t  gen_frame_mem (word_mode, t));\n+\t  emit_insn (gen_memory_blockage ());\n \t}\n     }\n   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);"}, {"sha": "ad12b335f581b4343ad07c39f2b98774d45597e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "patch": "@@ -1,3 +1,7 @@\n+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt76.adb: New test.\n+\n 2019-02-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/71860"}, {"sha": "50f3cee9ed9548ba159b8771947c30e6a656fa16", "filename": "gcc/testsuite/gnat.dg/opt76.adb", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Ftestsuite%2Fgnat.dg%2Fopt76.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f73f96f182d9aff6ec63c3926a773a2a2c4075/gcc%2Ftestsuite%2Fgnat.dg%2Fopt76.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt76.adb?ref=a4f73f96f182d9aff6ec63c3926a773a2a2c4075", "patch": "@@ -0,0 +1,36 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -gnatp -fno-omit-frame-pointer\" }\n+\n+procedure Opt76 is\n+\n+   type Integer_Access is access Integer;\n+   type Registry_Array is array (Natural range <>) of Integer_Access;\n+\n+   procedure Nested (Input, Parser : Integer; A, B : Boolean) is\n+\n+      Index : Registry_Array (1 .. 1024);\n+      Not_B : constant Boolean := not B;\n+\n+      procedure Inner (Input : Integer) is\n+      begin\n+         if Input /= 1 then\n+            raise Program_Error;\n+         end if;\n+\n+         if Parser = 128 and then A and then Not_B then\n+            Inner (Input);\n+            Index (Index'First) := null;\n+         end if;\n+      end;\n+\n+   begin\n+      Inner (Input);\n+   end;\n+\n+   Input : Integer := 1 with Volatile;\n+   Parser : Integer := 2 with Volatile;\n+      \n+begin\n+   Nested (Input, Parser, False, True);\n+   Nested (Input, Parser, True, False);\n+end;"}]}