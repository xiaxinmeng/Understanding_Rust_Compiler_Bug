{"sha": "9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlYjIwMGY4YTEyNzBlODRkMGIxYzU2YWEzMWQ1YTkzZTdhM2U4Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-08-21T03:20:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-08-21T03:20:54Z"}, "message": "semantics.c (simplify_aggr_init_expr): Split out from simplify_aggr_init_exprs_r.\n\n        * semantics.c (simplify_aggr_init_expr): Split out from\n        simplify_aggr_init_exprs_r.  Convert slot address to match\n        the return type.\n        * cp-tree.h: Declare it.\n        * tree.c (cp_copy_res_decl_for_inlining): Don't clobber the\n        DECL_NAME of a user variable.\n\nFrom-SVN: r70635", "tree": {"sha": "4cc303464599d82c38a0015e1eadce58b1248567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cc303464599d82c38a0015e1eadce58b1248567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e50084fa44cb68c447efc11e53ec16bf09a578c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50084fa44cb68c447efc11e53ec16bf09a578c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50084fa44cb68c447efc11e53ec16bf09a578c0"}], "stats": {"total": 82, "additions": 56, "deletions": 26}, "files": [{"sha": "59a81c13d8c1e26247983581a49d9ca511ac30fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "patch": "@@ -1,3 +1,12 @@\n+2003-08-20  Jason Merrill  <jason@redhat.com>\n+\n+\t* semantics.c (simplify_aggr_init_expr): Split out from\n+\tsimplify_aggr_init_exprs_r.  Convert slot address to match\n+\tthe return type.\n+\t* cp-tree.h: Declare it.\n+\t* tree.c (cp_copy_res_decl_for_inlining): Don't clobber the\n+\tDECL_NAME of a user variable.\n+\n 2003-08-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/11945"}, {"sha": "9cda7696e77230a1ddf0df8e19f5cdfdc669019b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "patch": "@@ -4147,6 +4147,7 @@ extern tree check_template_template_default_arg (tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n extern tree finish_qualified_id_expr            (tree, tree, bool, bool);\n+extern void simplify_aggr_init_expr\t\t(tree *);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,"}, {"sha": "d5de76aad440a0efc98c3a048734bdc8583d5094", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "patch": "@@ -2713,37 +2713,46 @@ cp_expand_stmt (tree t)\n \n static tree\n simplify_aggr_init_exprs_r (tree* tp, \n-                            int* walk_subtrees ATTRIBUTE_UNUSED , \n-                            void* data ATTRIBUTE_UNUSED )\n+                            int* walk_subtrees,\n+                            void* data ATTRIBUTE_UNUSED)\n {\n-  tree aggr_init_expr;\n-  tree call_expr;\n-  tree fn;\n-  tree args;\n-  tree slot;\n-  tree type;\n-  enum style_t { ctor, arg, pcc } style;\n-\n-  aggr_init_expr = *tp;\n   /* We don't need to walk into types; there's nothing in a type that\n      needs simplification.  (And, furthermore, there are places we\n      actively don't want to go.  For example, we don't want to wander\n      into the default arguments for a FUNCTION_DECL that appears in a\n      CALL_EXPR.)  */\n-  if (TYPE_P (aggr_init_expr))\n+  if (TYPE_P (*tp))\n     {\n       *walk_subtrees = 0;\n       return NULL_TREE;\n     }\n   /* Only AGGR_INIT_EXPRs are interesting.  */\n-  else if (TREE_CODE (aggr_init_expr) != AGGR_INIT_EXPR)\n+  else if (TREE_CODE (*tp) != AGGR_INIT_EXPR)\n     return NULL_TREE;\n \n+  simplify_aggr_init_expr (tp);\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n+}\n+\n+/* Replace the AGGR_INIT_EXPR at *TP with an equivalent CALL_EXPR.  This\n+   function is broken out from the above for the benefit of the tree-ssa\n+   project.  */\n+\n+void\n+simplify_aggr_init_expr (tree *tp)\n+{\n+  tree aggr_init_expr = *tp;\n+\n   /* Form an appropriate CALL_EXPR.  */\n-  fn = TREE_OPERAND (aggr_init_expr, 0);\n-  args = TREE_OPERAND (aggr_init_expr, 1);\n-  slot = TREE_OPERAND (aggr_init_expr, 2);\n-  type = TREE_TYPE (aggr_init_expr);\n+  tree fn = TREE_OPERAND (aggr_init_expr, 0);\n+  tree args = TREE_OPERAND (aggr_init_expr, 1);\n+  tree slot = TREE_OPERAND (aggr_init_expr, 2);\n+  tree type = TREE_TYPE (aggr_init_expr);\n+\n+  tree call_expr;\n+  enum style_t { ctor, arg, pcc } style;\n \n   if (AGGR_INIT_VIA_CTOR_P (aggr_init_expr))\n     style = ctor;\n@@ -2762,15 +2771,26 @@ simplify_aggr_init_exprs_r (tree* tp,\n     {\n       /* Pass the address of the slot.  If this is a constructor, we\n \t replace the first argument; otherwise, we tack on a new one.  */\n+      tree addr;\n+\n       if (style == ctor)\n \targs = TREE_CHAIN (args);\n \n       cxx_mark_addressable (slot);\n-      args = tree_cons (NULL_TREE, \n-\t\t\tbuild1 (ADDR_EXPR, \n-\t\t\t\tbuild_pointer_type (TREE_TYPE (slot)),\n-\t\t\t\tslot),\n-\t\t\targs);\n+      addr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (slot)), slot);\n+      if (style == arg)\n+\t{\n+\t  /* The return type might have different cv-quals from the slot.  */\n+\t  tree fntype = TREE_TYPE (TREE_TYPE (fn));\n+#ifdef ENABLE_CHECKING\n+\t  if (TREE_CODE (fntype) != FUNCTION_TYPE\n+\t      && TREE_CODE (fntype) != METHOD_TYPE)\n+\t    abort ();\n+#endif\n+\t  addr = convert (build_pointer_type (TREE_TYPE (fntype)), addr);\n+\t}\n+\n+      args = tree_cons (NULL_TREE, addr, args);\n     }\n \n   call_expr = build (CALL_EXPR, \n@@ -2801,9 +2821,6 @@ simplify_aggr_init_exprs_r (tree* tp,\n   /* Replace the AGGR_INIT_EXPR with the CALL_EXPR.  */\n   TREE_CHAIN (call_expr) = TREE_CHAIN (aggr_init_expr);\n   *tp = call_expr;\n-\n-  /* Keep iterating.  */\n-  return NULL_TREE;\n }\n \n /* Emit all thunks to FN that should be emitted when FN is emitted.  */"}, {"sha": "cd1ea240c4997e770cbd7ce13b576465e0eadb6f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9eeb200f8a1270e84d0b1c56aa31d5a93e7a3e86", "patch": "@@ -2193,7 +2193,10 @@ cp_copy_res_decl_for_inlining (tree result,\n \t  /* We have a named return value; copy the name and source\n \t     position so we can get reasonable debugging information, and\n \t     register the return variable as its equivalent.  */\n-\t  if (TREE_CODE (var) == VAR_DECL)\n+\t  if (TREE_CODE (var) == VAR_DECL\n+\t      /* But not if we're initializing a variable from the\n+\t\t enclosing function which already has its own name.  */\n+\t      && DECL_NAME (var) == NULL_TREE)\n \t    {\n \t      DECL_NAME (var) = DECL_NAME (nrv);\n \t      DECL_SOURCE_LOCATION (var) = DECL_SOURCE_LOCATION (nrv);"}]}