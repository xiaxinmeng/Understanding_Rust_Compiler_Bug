{"sha": "b61461ac7f9bdd0e98145be79423d19b933afaa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYxNDYxYWM3ZjliZGQwZTk4MTQ1YmU3OTQyM2QxOWI5MzNhZmFhMA==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2021-03-02T22:37:26Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2021-03-23T18:44:22Z"}, "message": "fwprop: Fix single_use_p calculation\n\nCommit efb6bc55a93a (\"fwprop: Allow (subreg (mem)) simplifications\")\nintroduced a check that was supposed to look at the propagated def's\nnumber of uses.  It uses insn_info::num_uses (), which in reality\nreturns the number of uses def's insn has.  The whole change therefore\nworks only by accident.\n\nFix by looking at set_info's uses instead of insn_info's uses.  This\nrequires passing around set_info instead of insn_info.\n\ngcc/ChangeLog:\n\n2021-03-02  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* fwprop.c (fwprop_propagation::fwprop_propagation): Look at\n\tset_info's uses.\n\t(try_fwprop_subst_note): Use set_info instead of insn_info.\n\t(try_fwprop_subst_pattern): Likewise.\n\t(try_fwprop_subst_notes): Likewise.\n\t(try_fwprop_subst): Likewise.\n\t(forward_propagate_subreg): Likewise.\n\t(forward_propagate_and_simplify): Likewise.\n\t(forward_propagate_into): Likewise.\n\t* rtl-ssa/accesses.h (set_info::single_nondebug_use) New\n\tmethod.\n\t(set_info::single_nondebug_insn_use): Likewise.\n\t(set_info::single_phi_use): Likewise.\n\t* rtl-ssa/member-fns.inl (set_info::single_nondebug_use) New\n\tmethod.\n\t(set_info::single_nondebug_insn_use): Likewise.\n\t(set_info::single_phi_use): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/vector/long-double-asm-abi.c: New test.", "tree": {"sha": "32bdc72e60004b8cb1085701134a8b35f850f600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32bdc72e60004b8cb1085701134a8b35f850f600"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b61461ac7f9bdd0e98145be79423d19b933afaa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61461ac7f9bdd0e98145be79423d19b933afaa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61461ac7f9bdd0e98145be79423d19b933afaa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61461ac7f9bdd0e98145be79423d19b933afaa0/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1aa5f57db7c14a62e9b7e2a2aa8a9c402a89363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1aa5f57db7c14a62e9b7e2a2aa8a9c402a89363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1aa5f57db7c14a62e9b7e2a2aa8a9c402a89363"}], "stats": {"total": 148, "additions": 107, "deletions": 41}, "files": [{"sha": "d720367288654b88ded10985d566cd5eedc28dca", "filename": "gcc/fwprop.c", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b61461ac7f9bdd0e98145be79423d19b933afaa0", "patch": "@@ -175,7 +175,7 @@ namespace\n     static const uint16_t CONSTANT = FIRST_SPARE_RESULT << 1;\n     static const uint16_t PROFITABLE = FIRST_SPARE_RESULT << 2;\n \n-    fwprop_propagation (insn_info *, insn_info *, rtx, rtx);\n+    fwprop_propagation (insn_info *, set_info *, rtx, rtx);\n \n     bool changed_mem_p () const { return result_flags & CHANGED_MEM; }\n     bool folded_to_constants_p () const;\n@@ -191,13 +191,13 @@ namespace\n   };\n }\n \n-/* Prepare to replace FROM with TO in INSN.  */\n+/* Prepare to replace FROM with TO in USE_INSN.  */\n \n fwprop_propagation::fwprop_propagation (insn_info *use_insn,\n-\t\t\t\t\tinsn_info *def_insn, rtx from, rtx to)\n+\t\t\t\t\tset_info *def, rtx from, rtx to)\n   : insn_propagation (use_insn->rtl (), from, to),\n-    single_use_p (def_insn->num_uses () == 1),\n-    single_ebb_p (use_insn->ebb () == def_insn->ebb ())\n+    single_use_p (def->single_nondebug_use ()),\n+    single_ebb_p (use_insn->ebb () == def->ebb ())\n {\n   should_check_mems = true;\n   should_note_simplifications = true;\n@@ -368,24 +368,25 @@ contains_paradoxical_subreg_p (rtx x)\n   return false;\n }\n \n-/* Try to substitute (set DEST SRC) from DEF_INSN into note NOTE of USE_INSN.\n-   Return the number of substitutions on success, otherwise return -1 and\n-   leave USE_INSN unchanged.\n+/* Try to substitute (set DEST SRC), which defines DEF, into note NOTE of\n+   USE_INSN.  Return the number of substitutions on success, otherwise return\n+   -1 and leave USE_INSN unchanged.\n \n-   If REQUIRE_CONSTANT is true, require all substituted occurences of SRC\n+   If REQUIRE_CONSTANT is true, require all substituted occurrences of SRC\n    to fold to a constant, so that the note does not use any more registers\n    than it did previously.  If REQUIRE_CONSTANT is false, also allow the\n    substitution if it's something we'd normally allow for the main\n    instruction pattern.  */\n \n static int\n-try_fwprop_subst_note (insn_info *use_insn, insn_info *def_insn,\n+try_fwprop_subst_note (insn_info *use_insn, set_info *def,\n \t\t       rtx note, rtx dest, rtx src, bool require_constant)\n {\n   rtx_insn *use_rtl = use_insn->rtl ();\n+  insn_info *def_insn = def->insn ();\n \n   insn_change_watermark watermark;\n-  fwprop_propagation prop (use_insn, def_insn, dest, src);\n+  fwprop_propagation prop (use_insn, def, dest, src);\n   if (!prop.apply_to_rvalue (&XEXP (note, 0)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -436,19 +437,20 @@ try_fwprop_subst_note (insn_info *use_insn, insn_info *def_insn,\n   return prop.num_replacements;\n }\n \n-/* Try to substitute (set DEST SRC) from DEF_INSN into location LOC of\n+/* Try to substitute (set DEST SRC), which defines DEF, into location LOC of\n    USE_INSN's pattern.  Return true on success, otherwise leave USE_INSN\n    unchanged.  */\n \n static bool\n try_fwprop_subst_pattern (obstack_watermark &attempt, insn_change &use_change,\n-\t\t\t  insn_info *def_insn, rtx *loc, rtx dest, rtx src)\n+\t\t\t  set_info *def, rtx *loc, rtx dest, rtx src)\n {\n   insn_info *use_insn = use_change.insn ();\n   rtx_insn *use_rtl = use_insn->rtl ();\n+  insn_info *def_insn = def->insn ();\n \n   insn_change_watermark watermark;\n-  fwprop_propagation prop (use_insn, def_insn, dest, src);\n+  fwprop_propagation prop (use_insn, def, dest, src);\n   if (!prop.apply_to_pattern (loc))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -538,8 +540,7 @@ try_fwprop_subst_pattern (obstack_watermark &attempt, insn_change &use_change,\n     {\n       if ((REG_NOTE_KIND (note) == REG_EQUAL\n \t   || REG_NOTE_KIND (note) == REG_EQUIV)\n-\t  && try_fwprop_subst_note (use_insn, def_insn, note,\n-\t\t\t\t    dest, src, false) < 0)\n+\t  && try_fwprop_subst_note (use_insn, def, note, dest, src, false) < 0)\n \t{\n \t  *note_ptr = XEXP (note, 1);\n \t  free_EXPR_LIST_node (note);\n@@ -554,20 +555,19 @@ try_fwprop_subst_pattern (obstack_watermark &attempt, insn_change &use_change,\n   return true;\n }\n \n-/* Try to substitute (set DEST SRC) from DEF_INSN into USE_INSN's notes,\n+/* Try to substitute (set DEST SRC), which defines DEF, into USE_INSN's notes,\n    given that it was not possible to do this for USE_INSN's main pattern.\n    Return true on success, otherwise leave USE_INSN unchanged.  */\n \n static bool\n-try_fwprop_subst_notes (insn_info *use_insn, insn_info *def_insn,\n+try_fwprop_subst_notes (insn_info *use_insn, set_info *def,\n \t\t\trtx dest, rtx src)\n {\n   rtx_insn *use_rtl = use_insn->rtl ();\n   for (rtx note = REG_NOTES (use_rtl); note; note = XEXP (note, 1))\n     if ((REG_NOTE_KIND (note) == REG_EQUAL\n \t || REG_NOTE_KIND (note) == REG_EQUIV)\n-\t&& try_fwprop_subst_note (use_insn, def_insn, note,\n-\t\t\t\t  dest, src, true) > 0)\n+\t&& try_fwprop_subst_note (use_insn, def, note, dest, src, true) > 0)\n       {\n \tconfirm_change_group ();\n \treturn true;\n@@ -576,18 +576,19 @@ try_fwprop_subst_notes (insn_info *use_insn, insn_info *def_insn,\n   return false;\n }\n \n-/* Check whether we could validly substitute (set DEST SRC) from DEF_INSN\n+/* Check whether we could validly substitute (set DEST SRC), which defines DEF,\n    into USE.  If so, first try performing the substitution in location LOC\n    of USE->insn ()'s pattern.  If that fails, try instead to substitute\n    into the notes.\n \n    Return true on success, otherwise leave USE_INSN unchanged.  */\n \n static bool\n-try_fwprop_subst (use_info *use, insn_info *def_insn,\n+try_fwprop_subst (use_info *use, set_info *def,\n \t\t  rtx *loc, rtx dest, rtx src)\n {\n   insn_info *use_insn = use->insn ();\n+  insn_info *def_insn = def->insn ();\n \n   auto attempt = crtl->ssa->new_change_attempt ();\n   use_array src_uses = remove_note_accesses (attempt, def_insn->uses ());\n@@ -622,9 +623,8 @@ try_fwprop_subst (use_info *use, insn_info *def_insn,\n   if (!restrict_movement (use_change))\n     return false;\n \n-  return (try_fwprop_subst_pattern (attempt, use_change, def_insn,\n-\t\t\t\t    loc, dest, src)\n-\t  || try_fwprop_subst_notes (use_insn, def_insn, dest, src));\n+  return (try_fwprop_subst_pattern (attempt, use_change, def, loc, dest, src)\n+\t  || try_fwprop_subst_notes (use_insn, def, dest, src));\n }\n \n /* For the given single_set INSN, containing SRC known to be a\n@@ -671,7 +671,7 @@ free_load_extend (rtx src, insn_info *insn)\n    in REF.  The other parameters are the same.  */\n \n static bool\n-forward_propagate_subreg (use_info *use, insn_info *def_insn,\n+forward_propagate_subreg (use_info *use, set_info *def,\n \t\t\t  rtx dest, rtx src, df_ref ref)\n {\n   scalar_int_mode int_use_mode, src_mode;\n@@ -697,8 +697,7 @@ forward_propagate_subreg (use_info *use, insn_info *def_insn,\n \t  && REGNO (SUBREG_REG (src)) >= FIRST_PSEUDO_REGISTER\n \t  && GET_MODE (SUBREG_REG (src)) == use_mode\n \t  && subreg_lowpart_p (src))\n-\treturn try_fwprop_subst (use, def_insn, loc,\n-\t\t\t\t use_reg, SUBREG_REG (src));\n+\treturn try_fwprop_subst (use, def, loc, use_reg, SUBREG_REG (src));\n     }\n \n   /* If this is a SUBREG of a ZERO_EXTEND or SIGN_EXTEND, and the SUBREG\n@@ -725,22 +724,21 @@ forward_propagate_subreg (use_info *use, insn_info *def_insn,\n \t  && REG_P (XEXP (src, 0))\n \t  && REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n \t  && GET_MODE (XEXP (src, 0)) == use_mode\n-\t  && !free_load_extend (src, def_insn)\n+\t  && !free_load_extend (src, def->insn ())\n \t  && (targetm.mode_rep_extended (int_use_mode, src_mode)\n \t      != (int) GET_CODE (src)))\n-\treturn try_fwprop_subst (use, def_insn, loc, use_reg, XEXP (src, 0));\n+\treturn try_fwprop_subst (use, def, loc, use_reg, XEXP (src, 0));\n     }\n \n   return false;\n }\n \n-/* Try to substitute (set DEST SRC) from DEF_INSN into USE and simplify\n+/* Try to substitute (set DEST SRC), which defines DEF, into USE and simplify\n    the result, handling cases where DEST is used in a subreg and where\n    applying that subreg to SRC results in a useful simplification.  */\n \n static bool\n-forward_propagate_subreg (use_info *use, insn_info *def_insn,\n-\t\t\t  rtx dest, rtx src)\n+forward_propagate_subreg (use_info *use, set_info *def, rtx dest, rtx src)\n {\n   if (!use->includes_subregs () || !REG_P (dest))\n     return false;\n@@ -755,26 +753,27 @@ forward_propagate_subreg (use_info *use, insn_info *def_insn,\n \n   FOR_EACH_INSN_USE (ref, use_rtl)\n     if (DF_REF_REGNO (ref) == use->regno ()\n-\t&& forward_propagate_subreg (use, def_insn, dest, src, ref))\n+\t&& forward_propagate_subreg (use, def, dest, src, ref))\n       return true;\n \n   FOR_EACH_INSN_EQ_USE (ref, use_rtl)\n     if (DF_REF_REGNO (ref) == use->regno ()\n-\t&& forward_propagate_subreg (use, def_insn, dest, src, ref))\n+\t&& forward_propagate_subreg (use, def, dest, src, ref))\n       return true;\n \n   return false;\n }\n \n-/* Try to substitute (set DEST SRC) from DEF_INSN into USE and\n+/* Try to substitute (set DEST SRC), which defines DEF, into USE and\n    simplify the result.  */\n \n static bool\n-forward_propagate_and_simplify (use_info *use, insn_info *def_insn,\n+forward_propagate_and_simplify (use_info *use, set_info *def,\n \t\t\t\trtx dest, rtx src)\n {\n   insn_info *use_insn = use->insn ();\n   rtx_insn *use_rtl = use_insn->rtl ();\n+  insn_info *def_insn = def->insn ();\n \n   /* ??? This check seems unnecessary.  We should be able to propagate\n      into any kind of instruction, regardless of whether it's a single set.\n@@ -820,7 +819,7 @@ forward_propagate_and_simplify (use_info *use, insn_info *def_insn,\n   /* ??? Unconditionally propagating into PATTERN would work better\n      for instructions that have match_dups.  */\n   rtx *loc = need_single_set ? &use_set : &PATTERN (use_rtl);\n-  return try_fwprop_subst (use, def_insn, loc, dest, src);\n+  return try_fwprop_subst (use, def, loc, dest, src);\n }\n \n /* Given a use USE of an insn, if it has a single reaching\n@@ -836,7 +835,7 @@ forward_propagate_into (use_info *use, bool reg_prop_only = false)\n     return false;\n \n   /* Disregard uninitialized uses.  */\n-  def_info *def = use->def ();\n+  set_info *def = use->def ();\n   if (!def)\n     return false;\n \n@@ -880,8 +879,8 @@ forward_propagate_into (use_info *use, bool reg_prop_only = false)\n       && find_reg_note (use_rtl, REG_NON_LOCAL_GOTO, NULL_RTX))\n     return false;\n \n-  if (forward_propagate_and_simplify (use, def_insn, dest, src)\n-      || forward_propagate_subreg (use, def_insn, dest, src))\n+  if (forward_propagate_and_simplify (use, def, dest, src)\n+      || forward_propagate_subreg (use, def, dest, src))\n     return true;\n \n   return false;"}, {"sha": "91e64f3321f300796b396c2841d43fd7e0772a16", "filename": "gcc/rtl-ssa/accesses.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Frtl-ssa%2Faccesses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Frtl-ssa%2Faccesses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Faccesses.h?ref=b61461ac7f9bdd0e98145be79423d19b933afaa0", "patch": "@@ -705,6 +705,19 @@ class set_info : public def_info\n   // Return true if at least one phi node uses the set's result.\n   bool has_phi_uses () const;\n \n+  // If there is exactly one nondebug use of the set's result, return that use,\n+  // otherwise return null.  The use might be in an instruction or in a phi\n+  // node.\n+  use_info *single_nondebug_use () const;\n+\n+  // If exactly one nondebug instruction uses the set's result, return the use\n+  // by that instruction, otherwise return null.\n+  use_info *single_nondebug_insn_use () const;\n+\n+  // If exactly one phi node uses the set's result, return the use by that phi\n+  // node, otherwise return null.\n+  use_info *single_phi_use () const;\n+\n   // Return true if the set and its uses are contained within a single\n   // extended basic block, with the set coming first.  This implies\n   // that all uses are by instructions rather than phi nodes."}, {"sha": "0b821ae1a77687a357a9d516407513d1e1094b25", "filename": "gcc/rtl-ssa/member-fns.inl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Frtl-ssa%2Fmember-fns.inl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Frtl-ssa%2Fmember-fns.inl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Fmember-fns.inl?ref=b61461ac7f9bdd0e98145be79423d19b933afaa0", "patch": "@@ -250,6 +250,34 @@ set_info::has_phi_uses () const\n   return m_first_use && m_first_use->last_use ()->is_in_phi ();\n }\n \n+inline use_info *\n+set_info::single_nondebug_use () const\n+{\n+  if (!has_phi_uses ())\n+    return single_nondebug_insn_use ();\n+  if (!has_nondebug_insn_uses ())\n+    return single_phi_use ();\n+  return nullptr;\n+}\n+\n+inline use_info *\n+set_info::single_nondebug_insn_use () const\n+{\n+  use_info *first = first_nondebug_insn_use ();\n+  if (first && !first->next_nondebug_insn_use ())\n+    return first;\n+  return nullptr;\n+}\n+\n+inline use_info *\n+set_info::single_phi_use () const\n+{\n+  use_info *last = last_phi_use ();\n+  if (last && !last->prev_phi_use ())\n+    return last;\n+  return nullptr;\n+}\n+\n inline bool\n set_info::is_local_to_ebb () const\n {"}, {"sha": "f9f2d1286e2da7bfd3f2e9a490f75aa39d953e27", "filename": "gcc/testsuite/gcc.target/s390/vector/long-double-asm-abi.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61461ac7f9bdd0e98145be79423d19b933afaa0/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Flong-double-asm-abi.c?ref=b61461ac7f9bdd0e98145be79423d19b933afaa0", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z14 -mzarch --save-temps\" } */\n+/* { dg-do run { target { s390_z14_hw } } } */\n+#include <assert.h>\n+#include <stdint.h>\n+\n+__attribute__ ((noipa)) static long double\n+xsqrt (long double x)\n+{\n+  long double res;\n+  asm(\"sqxbr\\t%0,%1\" : \"=f\"(res) : \"f\"(x));\n+  return res;\n+}\n+\n+/* Check that the generated code is very small and straightforward.  In\n+   particular, there must be no unnecessary copying and no stack frame.  */\n+/* { dg-final { scan-assembler {\\n\\tld\\t[^\\n]*\\n\\tld\\t[^\\n]*\\n(#[^\\n]*\\n)*\\tsqxbr\\t.*\\n(#[^\\n]*\\n)*\\tstd\\t[^\\n]*\\n\\tstd\\t[^\\n]*\\n\\tbr\\t%r14\\n} } } */\n+\n+int\n+main (void)\n+{\n+  long double res, x = 0x1.0000000000001p+0L,\n+\t\t   exp = 1.00000000000000011102230246251564788e+0L;\n+  res = xsqrt (x);\n+  assert (res == exp);\n+}"}]}