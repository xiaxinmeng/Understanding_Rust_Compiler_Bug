{"sha": "f255541fb7bdd1b1da1a8c661967021164fa515b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1NTU0MWZiN2JkZDFiMWRhMWE4YzY2MTk2NzAyMTE2NGZhNTE1Yg==", "commit": {"author": {"name": "Roberto Costa", "email": "roberto.costa@st.com", "date": "2007-01-08T13:52:42Z"}, "committer": {"name": "Roberto Costa", "email": "robc@gcc.gnu.org", "date": "2007-01-08T13:52:42Z"}, "message": "Better handling of COND_EXPRs in rhs\n\nFrom-SVN: r120581", "tree": {"sha": "dcb7083fc910095eb2aebe069e3d37af32897742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcb7083fc910095eb2aebe069e3d37af32897742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f255541fb7bdd1b1da1a8c661967021164fa515b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f255541fb7bdd1b1da1a8c661967021164fa515b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f255541fb7bdd1b1da1a8c661967021164fa515b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f255541fb7bdd1b1da1a8c661967021164fa515b/comments", "author": null, "committer": null, "parents": [{"sha": "feb8476ac4b9534b99b222ff42ea40900fd7bfe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb8476ac4b9534b99b222ff42ea40900fd7bfe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb8476ac4b9534b99b222ff42ea40900fd7bfe3"}], "stats": {"total": 121, "additions": 113, "deletions": 8}, "files": [{"sha": "a0b92c9af7e65f428af0b379bb3351263e3b0b2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f255541fb7bdd1b1da1a8c661967021164fa515b", "patch": "@@ -1,3 +1,16 @@\n+2007-01-08  Roberto Costa  <roberto.costa@st.com>\n+\n+\t* tree-vrp.c (extract_range_from_cond_expr): New.\n+\t(extract_range_from_expr): Handle COND_EXPR nodes used as expressions.\n+\t* tree-ssa-ccp.c (get_maxval_strlen): Handle COND_EXPR nodes used\n+\tas expressions.\n+\t(fold_stmt): Bug fix, avoid infinite recursion when folding COND_EXPRs.\n+\t* tree-ssa-forwprop.c (simplify_cond, forward_propagate_into_cond,\n+\ttree_ssa_forward_propagate_single_use_vars): Handle COND_EXPR nodes\n+\tused as expressions.\n+\t* tree-object-size.c (cond_expr_object_size): New.\n+\t(collect_object_sizes_for): Handle COND_EXPR nodes used as expressions.\n+\n 2007-01-08  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-forwprop.c (forward_propagate_into_cond,"}, {"sha": "a93464b22fa73f0cc4fbc9bc6542ddfa466484ad", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=f255541fb7bdd1b1da1a8c661967021164fa515b", "patch": "@@ -50,6 +50,7 @@ static void expr_object_size (struct object_size_info *, tree, tree);\n static bool merge_object_sizes (struct object_size_info *, tree, tree,\n \t\t\t\tunsigned HOST_WIDE_INT);\n static bool plus_expr_object_size (struct object_size_info *, tree, tree);\n+static bool cond_expr_object_size (struct object_size_info *, tree, tree);\n static unsigned int compute_object_sizes (void);\n static void init_offset_limit (void);\n static void check_for_plus_in_loops (struct object_size_info *, tree);\n@@ -621,6 +622,40 @@ plus_expr_object_size (struct object_size_info *osi, tree var, tree value)\n }\n \n \n+/* Compute object_sizes for PTR, defined to VALUE, which is\n+   a COND_EXPR.  Return true if the object size might need reexamination\n+   later.  */\n+\n+static bool\n+cond_expr_object_size (struct object_size_info *osi, tree var, tree value)\n+{\n+  tree then_, else_;\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (var);\n+  bool reexamine = false;\n+\n+  gcc_assert (TREE_CODE (value) == COND_EXPR);\n+\n+  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+    return false;\n+\n+  then_ = COND_EXPR_THEN (value);\n+  else_ = COND_EXPR_ELSE (value);\n+\n+  if (TREE_CODE (then_) == SSA_NAME)\n+    reexamine |= merge_object_sizes (osi, var, then_, 0);\n+  else\n+    expr_object_size (osi, var, then_);\n+\n+  if (TREE_CODE (else_) == SSA_NAME)\n+    reexamine |= merge_object_sizes (osi, var, else_, 0);\n+  else\n+    expr_object_size (osi, var, else_);\n+\n+  return reexamine;\n+}\n+\n+\n /* Compute object sizes for VAR.\n    For ADDR_EXPR an object size is the number of remaining bytes\n    to the end of the object (where what is considered an object depends on\n@@ -711,6 +746,9 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \telse if (TREE_CODE (rhs) == PLUS_EXPR)\n \t  reexamine = plus_expr_object_size (osi, var, rhs);\n \n+        else if (TREE_CODE (rhs) == COND_EXPR)\n+\t  reexamine = cond_expr_object_size (osi, var, rhs);\n+\n \telse\n \t  expr_object_size (osi, var, rhs);\n \tbreak;"}, {"sha": "0f02b8c865155b6302859e29cd152ac5cf7fba5f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f255541fb7bdd1b1da1a8c661967021164fa515b", "patch": "@@ -2109,6 +2109,10 @@ get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n   \n   if (TREE_CODE (arg) != SSA_NAME)\n     {\n+      if (TREE_CODE (arg) == COND_EXPR)\n+        return get_maxval_strlen (COND_EXPR_THEN (arg), length, visited, type)\n+               && get_maxval_strlen (COND_EXPR_ELSE (arg), length, visited, type);\n+\n       if (type == 2)\n \t{\n \t  val = arg;\n@@ -2438,6 +2442,13 @@ fold_stmt (tree *stmt_p)\n \t    }\n \t}\n     }\n+  else if (TREE_CODE (rhs) == COND_EXPR)\n+    {\n+      tree temp = fold (COND_EXPR_COND (rhs));\n+      if (temp != COND_EXPR_COND (rhs))\n+        result = fold_build3 (COND_EXPR, TREE_TYPE (rhs), temp,\n+                              COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n+    }\n \n   /* If we couldn't fold the RHS, hand over to the generic fold routines.  */\n   if (result == NULL_TREE)"}, {"sha": "39653fcfc794dfe1811d00c1bcae209568bb4418", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=f255541fb7bdd1b1da1a8c661967021164fa515b", "patch": "@@ -490,15 +490,16 @@ find_equivalent_equality_comparison (tree cond)\n   return NULL;\n }\n \n-/* STMT is a COND_EXPR\n+/* EXPR is a COND_EXPR\n+   STMT is the statement containing EXPR.\n \n    This routine attempts to find equivalent forms of the condition\n    which we may be able to optimize better.  */\n \n static void\n-simplify_cond (tree stmt)\n+simplify_cond (tree cond_expr, tree stmt)\n {\n-  tree cond = COND_EXPR_COND (stmt);\n+  tree cond = COND_EXPR_COND (cond_expr);\n \n   if (COMPARISON_CLASS_P (cond))\n     {\n@@ -517,7 +518,7 @@ simplify_cond (tree stmt)\n \n \t      if (new_cond)\n \t\t{\n-\t\t  COND_EXPR_COND (stmt) = new_cond;\n+\t\t  COND_EXPR_COND (cond_expr) = new_cond;\n \t\t  update_stmt (stmt);\n \t\t}\n \t    }\n@@ -529,7 +530,7 @@ simplify_cond (tree stmt)\n    times as possible.  */\n \n static void\n-forward_propagate_into_cond (tree cond_expr)\n+forward_propagate_into_cond (tree cond_expr, tree stmt)\n {\n   gcc_assert (TREE_CODE (cond_expr) == COND_EXPR);\n \n@@ -554,7 +555,7 @@ forward_propagate_into_cond (tree cond_expr)\n \t}\n \n       COND_EXPR_COND (cond_expr) = new_cond;\n-      update_stmt (cond_expr);\n+      update_stmt (stmt);\n \n       if (has_zero_uses (test_var))\n \t{\n@@ -570,7 +571,7 @@ forward_propagate_into_cond (tree cond_expr)\n      against a constant where the SSA_NAME is the result of a\n      conversion.  Perhaps this should be folded into the rest\n      of the COND_EXPR simplification code.  */\n-  simplify_cond (cond_expr);\n+  simplify_cond (cond_expr, stmt);\n }\n \n /* We've just substituted an ADDR_EXPR into stmt.  Update all the \n@@ -1016,6 +1017,11 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t\t  simplify_not_neg_expr (stmt);\n \t\t  bsi_next (&bsi);\n \t\t}\n+              else if (TREE_CODE (rhs) == COND_EXPR)\n+                {\n+                  forward_propagate_into_cond (rhs, stmt);\n+\t\t  bsi_next (&bsi);\n+                }\n \t      else\n \t\tbsi_next (&bsi);\n \t    }\n@@ -1026,7 +1032,7 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t    }\n \t  else if (TREE_CODE (stmt) == COND_EXPR)\n \t    {\n-\t      forward_propagate_into_cond (stmt);\n+\t      forward_propagate_into_cond (stmt, stmt);\n \t      bsi_next (&bsi);\n \t    }\n \t  else"}, {"sha": "ed0a97c7533f468206508e3be00c48f2e3398697", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f255541fb7bdd1b1da1a8c661967021164fa515b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f255541fb7bdd1b1da1a8c661967021164fa515b", "patch": "@@ -43,6 +43,7 @@ static sbitmap found_in_subgraph;\n \n /* Local functions.  */\n static int compare_values (tree val1, tree val2);\n+static void vrp_meet (value_range_t *, value_range_t *);\n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n@@ -1919,6 +1920,40 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n }\n \n \n+/* Extract range information from a conditional expression EXPR based on\n+   the ranges of each of its operands and the expression code.  */\n+\n+static void\n+extract_range_from_cond_expr (value_range_t *vr, tree expr)\n+{\n+  tree op0, op1;\n+  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+  value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\n+  /* Get value ranges for each operand.  For constant operands, create\n+     a new value range with the operand to simplify processing.  */\n+  op0 = COND_EXPR_THEN (expr);\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *(get_value_range (op0));\n+  else if (is_gimple_min_invariant (op0))\n+    set_value_range (&vr0, VR_RANGE, op0, op0, NULL);\n+  else\n+    set_value_range_to_varying (&vr0);\n+\n+  op1 = COND_EXPR_ELSE (expr);\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    vr1 = *(get_value_range (op1));\n+  else if (is_gimple_min_invariant (op1))\n+    set_value_range (&vr1, VR_RANGE, op1, op1, NULL);\n+  else\n+    set_value_range_to_varying (&vr1);\n+\n+  /* The resulting value range is the union of the operand ranges */\n+  vrp_meet (&vr0, &vr1);\n+  copy_value_range (vr, &vr0);\n+}\n+\n+\n /* Extract range information from a comparison expression EXPR based\n    on the range of its operand and the expression code.  */\n \n@@ -1961,6 +1996,8 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n     extract_range_from_binary_expr (vr, expr);\n   else if (TREE_CODE_CLASS (code) == tcc_unary)\n     extract_range_from_unary_expr (vr, expr);\n+  else if (code == COND_EXPR)\n+    extract_range_from_cond_expr (vr, expr);\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     extract_range_from_comparison (vr, expr);\n   else if (is_gimple_min_invariant (expr))"}]}