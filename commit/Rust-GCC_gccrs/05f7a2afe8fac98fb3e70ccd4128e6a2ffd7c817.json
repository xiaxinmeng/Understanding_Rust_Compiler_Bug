{"sha": "05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVmN2EyYWZlOGZhYzk4ZmIzZTcwY2NkNDEyOGU2YTJmZmQ3YzgxNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-02T13:52:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-02T14:19:43Z"}, "message": "C++ Module Binding Vector\n\nThis adds the vector necessary to hold different module's namespace\nbindings.  We add a new tree-node 'tree_binding_vec', which contains a\nsparse array, indexed by module number.  To avoid space wasting, this\nis allocated in clusters using 'unsigned short' as the index value (so\nthat's one of the upper bounds on module importing).  If there are\nonly bindings from the current TU, there is no vector, so we have the\nsame representation as a non-module compilation.\n\nTo support lazy loading, a binding slot can contain either a tree (the\nbinding), or a cookie that the module machinery uses to load the\nrequired binding on demand.\n\nThe first 2 or 3 slots end up being reserved for fixed meanings.\nThere are a couple of flags we have to record on a binding, to know\nwhether the same declaration could appear in two different slots.\n\n\tgcc/cp/\n\t* cp-tree.def (BINDING_VECTOR): New.\n\t* name-lookup.h (struct binding_slot): New.\n\t(BINDING_VECTOR_SLOTS_PER_CLUSTER): New.\n\t(struct binding_index, struct binding_cluster): New.\n\t(BINDING_VECTOR_ALLOC_CLUSTERS, BINDING_VECTOR_CLUSTER_BASE)\n\t(BINDING_VECTOR_CLUSTER): New.\n\t(struct tree_binding_vec): New.\n\t(BINDING_VECTOR_NAME, BINDING_VECTOR_GLOBAL_DUPS_P)\n\t(BINDING_VECTOR_PARTITION_DUPS_P): New.\n\t(BINDING_BINDING_GLOBAL_P, BINDING_BINDING_PARTITION_P): New.\n\t(BINDING_VECTOR_PENDING_SPECIALIZATIONS)\n\t(BINDING_VECTOR_PENDING_IS_HEADER_P)\n\t(BINDING_VECTOR_PENDING_IS_PARTITION_P): New.\n\t* cp-tree.h (enum cp_tree_node_structure_enum): Add\n\tTS_CP_BINDING_VECTOR.\n\t(union lang_tree_node): Add binding_vec field.\n\t(make_binding_vec): Declare.\n\t(named_decl_hash::hash, named_decl_hash::equal): Check for binding\n\tvector.\n\t* decl.c (cp_tree_node_structure): Add BINDING_VECTOR case.\n\t* ptree.c (cxx_print_xnode): Add BINDING_VECTOR case.\n\t* tree.c (make_binding_vec): New.", "tree": {"sha": "2753d28aa61361463b46bf83033ed9ca2a5c478f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2753d28aa61361463b46bf83033ed9ca2a5c478f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6725994fe99a75728b408ef104ae354df673ed69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6725994fe99a75728b408ef104ae354df673ed69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6725994fe99a75728b408ef104ae354df673ed69"}], "stats": {"total": 187, "additions": 185, "deletions": 2}, "files": [{"sha": "4e73e46b4a04a5245625b3e4abb12da66f5d1c07", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -233,6 +233,9 @@ DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", tcc_expression, 2)\n /* One of a set of overloaded functions.  */\n DEFTREECODE (OVERLOAD, \"overload\", tcc_exceptional, 0)\n \n+/* A vector of binding slots.  */\n+DEFTREECODE (BINDING_VECTOR, \"binding_vector\", tcc_exceptional, 0)\n+\n /* A pseudo-destructor, of the form \"OBJECT.~DESTRUCTOR\" or\n    \"OBJECT.SCOPE::~DESTRUCTOR.  The first operand is the OBJECT.  The\n    second operand (if non-NULL) is the SCOPE.  The third operand is"}, {"sha": "b5d4fc0aba16b53f46aad280290342f3ba5d26d1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -1665,6 +1665,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_TPI,\n   TS_CP_PTRMEM,\n   TS_CP_OVERLOAD,\n+  TS_CP_BINDING_VECTOR,\n   TS_CP_BASELINK,\n   TS_CP_TEMPLATE_DECL,\n   TS_CP_DEFERRED_PARSE,\n@@ -1686,6 +1687,7 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n   struct template_parm_index GTY ((tag (\"TS_CP_TPI\"))) tpi;\n   struct ptrmem_cst GTY ((tag (\"TS_CP_PTRMEM\"))) ptrmem;\n   struct tree_overload GTY ((tag (\"TS_CP_OVERLOAD\"))) overload;\n+  struct tree_binding_vec GTY ((tag (\"TS_CP_BINDING_VECTOR\"))) binding_vec;\n   struct tree_baselink GTY ((tag (\"TS_CP_BASELINK\"))) baselink;\n   struct tree_template_decl GTY ((tag (\"TS_CP_TEMPLATE_DECL\"))) template_decl;\n   struct tree_deferred_parse GTY ((tag (\"TS_CP_DEFERRED_PARSE\"))) deferred_parse;\n@@ -7386,6 +7388,7 @@ extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n extern tree build_ref_qualified_type\t\t(tree, cp_ref_qualifier);\n+extern tree make_binding_vec\t\t\t(tree, unsigned clusters);\n inline tree ovl_first\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree ovl_make\t\t\t\t(tree fn,\n \t\t\t\t\t\t tree next = NULL_TREE);\n@@ -8020,14 +8023,16 @@ type_unknown_p (const_tree expr)\n inline hashval_t\n named_decl_hash::hash (const value_type decl)\n {\n-  tree name = OVL_NAME (decl);\n+  tree name = (TREE_CODE (decl) == BINDING_VECTOR\n+\t       ? BINDING_VECTOR_NAME (decl) : OVL_NAME (decl));\n   return name ? IDENTIFIER_HASH_VALUE (name) : 0;\n }\n \n inline bool\n named_decl_hash::equal (const value_type existing, compare_type candidate)\n {\n-  tree name = OVL_NAME (existing);\n+  tree name = (TREE_CODE (existing) == BINDING_VECTOR\n+\t       ? BINDING_VECTOR_NAME (existing) : OVL_NAME (existing));\n   return candidate == name;\n }\n "}, {"sha": "df76155a2433cf112ecdc89ae7ee4f24c0515257", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -17594,6 +17594,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case DEFERRED_PARSE:\treturn TS_CP_DEFERRED_PARSE;\n     case IDENTIFIER_NODE:\treturn TS_CP_IDENTIFIER;\n     case LAMBDA_EXPR:\t\treturn TS_CP_LAMBDA_EXPR;\n+    case BINDING_VECTOR:\t\treturn TS_CP_BINDING_VECTOR;\n     case OVERLOAD:\t\treturn TS_CP_OVERLOAD;\n     case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;\n     case STATIC_ASSERT:\t\treturn TS_CP_STATIC_ASSERT;"}, {"sha": "9cc8a42f4bdd05ea350a901b3a2eb9333589639d", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -68,6 +68,125 @@ struct GTY(()) cxx_saved_binding {\n   tree real_type_value;\n };\n \n+/* To support lazy module loading, we squirrel away a section number\n+   (and a couple of flags) in the binding slot of unloaded bindings.\n+   We rely on pointers being aligned and setting the bottom bit to\n+   mark a lazy value.  GTY doesn't like an array of union, so we have\n+   a containing struct.  */\n+\n+struct GTY(()) binding_slot {\n+  union GTY((desc (\"%1.is_lazy ()\"))) binding_slot_lazy {\n+    tree GTY((tag (\"false\"))) binding;\n+  } u;\n+\n+  operator tree & ()\n+  {\n+    gcc_checking_assert (!is_lazy ());\n+    return u.binding;\n+  }\n+  binding_slot &operator= (tree t)\n+  {\n+    u.binding = t;\n+    return *this;\n+  }\n+  bool is_lazy () const\n+  {\n+    return bool (uintptr_t (u.binding) & 1);\n+  }\n+  void set_lazy (unsigned snum)\n+  {\n+    gcc_checking_assert (!u.binding);\n+    u.binding = tree (uintptr_t ((snum << 1) | 1));\n+  }\n+  void or_lazy (unsigned snum)\n+  {\n+    gcc_checking_assert (is_lazy ());\n+    u.binding = tree (uintptr_t (u.binding) | (snum << 1));\n+  }\n+  unsigned get_lazy () const\n+  {\n+    gcc_checking_assert (is_lazy ());\n+    return unsigned (uintptr_t (u.binding) >> 1);\n+  }\n+};\n+\n+/* Bindings for modules are held in a sparse array.  There is always a\n+   current TU slot, others are allocated as needed.  By construction\n+   of the importing mechanism we only ever need to append to the\n+   array.  Rather than have straight index/slot tuples, we bunch them\n+   up for greater packing.\n+\n+   The cluster representation packs well on a 64-bit system.  */\n+\n+#define BINDING_VECTOR_SLOTS_PER_CLUSTER 2\n+struct binding_index {\n+  unsigned short base;\n+  unsigned short span;\n+};\n+\n+struct GTY(()) binding_cluster\n+{\n+  binding_index GTY((skip)) indices[BINDING_VECTOR_SLOTS_PER_CLUSTER];\n+  binding_slot slots[BINDING_VECTOR_SLOTS_PER_CLUSTER];\n+};\n+\n+/* These two fields overlay lang flags.  So don't use those.  */\n+#define BINDING_VECTOR_ALLOC_CLUSTERS(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.u.dependence_info.clique)\n+#define BINDING_VECTOR_NUM_CLUSTERS(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.u.dependence_info.base)\n+#define BINDING_VECTOR_CLUSTER_BASE(NODE) \\\n+  (((tree_binding_vec *)BINDING_VECTOR_CHECK (NODE))->vec)\n+#define BINDING_VECTOR_CLUSTER_LAST(NODE) \\\n+  (&BINDING_VECTOR_CLUSTER (NODE, BINDING_VECTOR_NUM_CLUSTERS (NODE) - 1))\n+#define BINDING_VECTOR_CLUSTER(NODE,IX) \\\n+  (((tree_binding_vec *)BINDING_VECTOR_CHECK (NODE))->vec[IX])\n+\n+struct GTY(()) tree_binding_vec {\n+  struct tree_base base;\n+  tree name;\n+  binding_cluster GTY((length (\"%h.base.u.dependence_info.base\"))) vec[1];\n+};\n+\n+/* The name of a module vector.  */\n+#define BINDING_VECTOR_NAME(NODE) \\\n+  (((tree_binding_vec *)BINDING_VECTOR_CHECK (NODE))->name)\n+\n+/* tree_binding_vec does uses  base.u.dependence_info.base field for\n+   length.  It does not have lang_flag etc available!  */\n+\n+/* These two flags note if a module-vector contains deduplicated\n+   bindings (i.e. multiple declarations in different imports).  */\n+/* This binding contains duplicate references to a global module\n+   entity.  */\n+#define BINDING_VECTOR_GLOBAL_DUPS_P(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.static_flag)\n+/* This binding contains duplicate references to a partioned module\n+   entity.  */\n+#define BINDING_VECTOR_PARTITION_DUPS_P(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.volatile_flag)\n+\n+/* These two flags indicate the provenence of the bindings on this\n+   particular vector slot.  We can of course determine this from slot\n+   number, but that's a relatively expensive lookup.  This avoids\n+   that when iterating.  */\n+/* This slot is part of the global module (a header unit).  */\n+#define MODULE_BINDING_GLOBAL_P(NODE) \\\n+  (OVERLOAD_CHECK (NODE)->base.static_flag)\n+/* This slot is part of the current module (a partition or primary).  */\n+#define MODULE_BINDING_PARTITION_P(NODE)\t\t\\\n+  (OVERLOAD_CHECK (NODE)->base.volatile_flag)\n+\n+/* There are specializations of a template keyed to this binding.  */\n+#define BINDING_VECTOR_PENDING_SPECIALIZATIONS_P(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.public_flag)\n+/* The key is in a header unit (not a named module partition or\n+   primary).  */\n+#define BINDING_VECTOR_PENDING_IS_HEADER_P(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.protected_flag)\n+/* The key is in a named module (primary or partition).  */\n+#define BINDING_VECTOR_PENDING_IS_PARTITION_P(NODE) \\\n+  (BINDING_VECTOR_CHECK (NODE)->base.private_flag)\n \n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);"}, {"sha": "1ee107f23ccba91b8c386c1f3ea8ef3c7e2a8815", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -250,6 +250,44 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n       print_node (file, \"function\", OVL_FUNCTION (node), indent + 4);\n       print_node (file, \"next\", OVL_CHAIN (node), indent + 4);\n       break;\n+    case BINDING_VECTOR:\n+      {\n+\tunsigned len = BINDING_VECTOR_NUM_CLUSTERS (node);\n+\tprint_node (file, \"name\", BINDING_VECTOR_NAME (node), indent + 4);\n+\tfprintf (file, \" clusters %u, alloc %u\", len,\n+\t\t BINDING_VECTOR_ALLOC_CLUSTERS (node));\n+\tfor (unsigned ix = 0; ix != len; ix++)\n+\t  {\n+\t    binding_cluster *cluster = &BINDING_VECTOR_CLUSTER (node, ix);\n+\t    char pfx[20];\n+\t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t      if (cluster->indices[jx].span)\n+\t\t{\n+\t\t  int len = sprintf (pfx, \"module:%u\",\n+\t\t\t\t     cluster->indices[jx].base);\n+\t\t  if (cluster->indices[jx].span > 1)\n+\t\t    len\n+\t\t      += sprintf (&pfx[len], \"(+%u)\", cluster->indices[jx].span);\n+\t\t  len += sprintf (&pfx[len], \" cluster:%u/%u\", ix, jx);\n+\t\t  binding_slot &slot = cluster->slots[jx];\n+\t\t  if (slot.is_lazy ())\n+\t\t    {\n+\t\t      indent_to (file, indent + 4);\n+\t\t      unsigned lazy = slot.get_lazy ();\n+\t\t      fprintf (file, \"%s snum:%u flags:%d\",\n+\t\t\t       pfx, lazy >> 2, lazy & 3);\n+\t\t    }\n+\t\t  else if (slot)\n+\t\t    print_node (file, pfx, slot, indent + 4);\n+\t\t  else\n+\t\t    {\n+\t\t      indent_to (file, indent + 4);\n+\t\t      fprintf (file, \"%s NULL\", pfx);\n+\t\t    }\n+\t\t}\n+\t  }\n+      }\n+      break;\n     case TEMPLATE_PARM_INDEX:\n       print_node (file, \"decl\", TEMPLATE_PARM_DECL (node), indent+4);\n       indent_to (file, indent + 3);"}, {"sha": "4113a34b0c1267e552da8c6d3456ee6b1f6844d1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=05f7a2afe8fac98fb3e70ccd4128e6a2ffd7c817", "patch": "@@ -2218,6 +2218,23 @@ build_ref_qualified_type (tree type, cp_ref_qualifier rqual)\n   return build_cp_fntype_variant (type, rqual, raises, late);\n }\n \n+tree\n+make_binding_vec (tree name, unsigned clusters MEM_STAT_DECL)\n+{\n+  /* Stored in an unsigned short, but we're limited to the number of\n+     modules anyway.  */\n+  gcc_checking_assert (clusters <= (unsigned short)(~0));\n+  size_t length = (offsetof (tree_binding_vec, vec)\n+\t\t   + clusters * sizeof (binding_cluster));\n+  tree vec = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n+  TREE_SET_CODE (vec, BINDING_VECTOR);\n+  BINDING_VECTOR_NAME (vec) = name;\n+  BINDING_VECTOR_ALLOC_CLUSTERS (vec) = clusters;\n+  BINDING_VECTOR_NUM_CLUSTERS (vec) = 0;\n+\n+  return vec;\n+}\n+\n /* Make a raw overload node containing FN.  */\n \n tree"}]}