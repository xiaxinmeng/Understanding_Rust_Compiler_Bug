{"sha": "d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZmMjkyMmU5MTkyOGI1MTkxYTVjNWYxYjNhNmIzMjA3MTJiNWNlMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-29T20:52:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-29T20:52:43Z"}, "message": "libgo: Update Go library to master revision 15489/921e53d4863c.\n\nFrom-SVN: r195560", "tree": {"sha": "4f2fad1f4b778519bdd5941185c7e1d032af055b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f2fad1f4b778519bdd5941185c7e1d032af055b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/comments", "author": null, "committer": null, "parents": [{"sha": "91bfca59095b1cca9d4364996866848eaaf76c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bfca59095b1cca9d4364996866848eaaf76c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bfca59095b1cca9d4364996866848eaaf76c26"}], "stats": {"total": 110360, "additions": 61013, "deletions": 49347}, "files": [{"sha": "b69bf8437f9ae6078cb58109cff099079d54754b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -1,4 +1,4 @@\n-6fdc1974457c\n+921e53d4863c\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "8a54d9eb43ae9eb666f711050c2d733e431d6d15", "filename": "libgo/Makefile.am", "status": "modified", "additions": 73, "deletions": 31, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -227,8 +227,8 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n+\texp/ssa.gox \\\n \texp/terminal.gox \\\n-\texp/types.gox \\\n \texp/utf8string.gox\n \n toolexeclibgoexphtmldir = $(toolexeclibgoexpdir)/html\n@@ -256,7 +256,8 @@ toolexeclibgogo_DATA = \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox\n+\tgo/token.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n \n@@ -682,7 +683,7 @@ go_net_fd_os_file = go/net/fd_linux.go\n go_net_newpollserver_file = go/net/newpollserver_unix.go\n else # !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n if LIBGO_IS_NETBSD\n-go_net_fd_os_file = go/net/fd_netbsd.go\n+go_net_fd_os_file = go/net/fd_bsd.go\n go_net_newpollserver_file = go/net/newpollserver_unix.go\n else # !LIBGO_IS_NETBSD && !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n # By default use select with pipes.  Most systems should have\n@@ -753,9 +754,16 @@ go_net_interface_file = go/net/interface_stub.go\n endif\n endif\n \n+if LIBGO_IS_LINUX\n+go_net_cloexec_file = go/net/sock_cloexec.go\n+else\n+go_net_cloexec_file = go/net/sys_cloexec.go\n+endif\n+\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n+\t$(go_net_cloexec_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n@@ -856,6 +864,12 @@ endif\n endif\n endif\n \n+if LIBGO_IS_LINUX\n+go_os_pipe_file = go/os/pipe_linux.go\n+else\n+go_os_pipe_file = go/os/pipe_bsd.go\n+endif\n+\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -872,6 +886,7 @@ go_os_files = \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n \tgo/os/path_unix.go \\\n+\t$(go_os_pipe_file) \\\n \tgo/os/proc.go \\\n \t$(go_os_stat_file) \\\n \tgo/os/str.go \\\n@@ -1026,6 +1041,7 @@ go_compress_bzip2_files = \\\n go_compress_flate_files = \\\n \tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n+\tgo/compress/flate/fixedhuff.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n@@ -1222,8 +1238,10 @@ go_exp_inotify_files = \\\n go_exp_locale_collate_files = \\\n \tgo/exp/locale/collate/colelem.go \\\n \tgo/exp/locale/collate/collate.go \\\n+\tgo/exp/locale/collate/colltab.go \\\n \tgo/exp/locale/collate/contract.go \\\n \tgo/exp/locale/collate/export.go \\\n+\tgo/exp/locale/collate/sort.go \\\n \tgo/exp/locale/collate/table.go \\\n \tgo/exp/locale/collate/tables.go \\\n \tgo/exp/locale/collate/trie.go\n@@ -1248,23 +1266,18 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/per_host.go \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n+go_exp_ssa_files = \\\n+\tgo/exp/ssa/blockopt.go \\\n+\tgo/exp/ssa/doc.go \\\n+\tgo/exp/ssa/func.go \\\n+\tgo/exp/ssa/sanity.go \\\n+\tgo/exp/ssa/ssa.go \\\n+\tgo/exp/ssa/literal.go \\\n+\tgo/exp/ssa/print.go \\\n+\tgo/exp/ssa/util.go\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n-go_exp_types_files = \\\n-\tgo/exp/types/builtins.go \\\n-\tgo/exp/types/check.go \\\n-\tgo/exp/types/const.go \\\n-\tgo/exp/types/conversions.go \\\n-\tgo/exp/types/errors.go \\\n-\tgo/exp/types/exportdata.go \\\n-\tgo/exp/types/expr.go \\\n-\tgo/exp/types/gcimporter.go \\\n-\tgo/exp/types/operand.go \\\n-\tgo/exp/types/predicates.go \\\n-\tgo/exp/types/stmt.go \\\n-\tgo/exp/types/types.go \\\n-\tgo/exp/types/universe.go\n go_exp_utf8string_files = \\\n \tgo/exp/utf8string/string.go\n \n@@ -1305,6 +1318,24 @@ go_go_token_files = \\\n \tgo/go/token/position.go \\\n \tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n+go_go_types_files = \\\n+\tgo/go/types/api.go \\\n+\tgo/go/types/builtins.go \\\n+\tgo/go/types/check.go \\\n+\tgo/go/types/const.go \\\n+\tgo/go/types/conversions.go \\\n+\tgo/go/types/errors.go \\\n+\tgo/go/types/exportdata.go \\\n+\tgo/go/types/expr.go \\\n+\tgo/go/types/gcimporter.go \\\n+\tgo/go/types/objects.go \\\n+\tgo/go/types/operand.go \\\n+\tgo/go/types/predicates.go \\\n+\tgo/go/types/resolve.go \\\n+\tgo/go/types/scope.go \\\n+\tgo/go/types/stmt.go \\\n+\tgo/go/types/types.go \\\n+\tgo/go/types/universe.go\n \n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n@@ -1848,8 +1879,8 @@ libgo_go_objs = \\\n \texp/locale/collate/build.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n+\texp/ssa.lo \\\n \texp/terminal.lo \\\n-\texp/types.lo \\\n \texp/utf8string.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n@@ -1860,6 +1891,7 @@ libgo_go_objs = \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -2751,6 +2783,15 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n+@go_include@ exp/ssa.lo.dep\n+exp/ssa.lo.dep: $(go_exp_ssa_files)\n+\t$(BUILDDEPS)\n+exp/ssa.lo: $(go_exp_ssa_files)\n+\t$(BUILDPACKAGE)\n+exp/ssa/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/ssa/check\n+\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -2760,15 +2801,6 @@ exp/terminal/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/terminal/check\n \n-@go_include@ exp/types.lo.dep\n-exp/types.lo.dep: $(go_exp_types_files)\n-\t$(BUILDDEPS)\n-exp/types.lo: $(go_exp_types_files)\n-\t$(BUILDPACKAGE)\n-exp/types/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: exp/types/check\n-\n @go_include@ exp/utf8string.lo.dep\n exp/utf8string.lo.dep: $(go_exp_utf8string_files)\n \t$(BUILDDEPS)\n@@ -2877,6 +2909,15 @@ go/token/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/token/check\n \n+@go_include@ go/types.lo.dep\n+go/types.lo.dep: $(go_go_types_files)\n+\t$(BUILDDEPS)\n+go/types.lo: $(go_go_types_files)\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -3507,9 +3548,9 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/terminal.gox: exp/terminal.lo\n+exp/ssa.gox: exp/ssa.lo\n \t$(BUILDGOX)\n-exp/types.gox: exp/types.lo\n+exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/utf8string.gox: exp/utf8string.lo\t\n \t$(BUILDGOX)\n@@ -3533,6 +3574,8 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -3734,7 +3777,6 @@ TEST_PACKAGES = \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/terminal/check \\\n-\texp/types/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n@@ -3745,7 +3787,7 @@ TEST_PACKAGES = \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n-\t$(go_types_check_omitted_since_it_calls_6g) \\\n+\tgo/types/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\"}, {"sha": "88c09a4ee4f54d99e875bb44aeb56ac38b92f79e", "filename": "libgo/Makefile.in", "status": "modified", "additions": 73, "deletions": 38, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -156,14 +156,14 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo \\\n \texp/cookiejar.lo exp/ebnf.lo exp/html.lo exp/html/atom.lo \\\n \texp/locale/collate.lo exp/locale/collate/build.lo exp/norm.lo \\\n-\texp/proxy.lo exp/terminal.lo exp/types.lo exp/utf8string.lo \\\n+\texp/proxy.lo exp/ssa.lo exp/terminal.lo exp/utf8string.lo \\\n \thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/format.lo \\\n \tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n-\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n-\tnet/http/cgi.lo net/http/fcgi.lo net/http/httptest.lo \\\n-\tnet/http/httputil.lo net/http/pprof.lo image/color.lo \\\n-\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n+\tgo/types.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n+\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n+\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n+\timage/color.lo image/draw.lo image/gif.lo image/jpeg.lo \\\n+\timage/png.lo index/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n \tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n \tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n \tnet/smtp.lo net/textproto.lo net/url.lo old/netchan.lo \\\n@@ -617,8 +617,8 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n+\texp/ssa.gox \\\n \texp/terminal.gox \\\n-\texp/types.gox \\\n \texp/utf8string.gox\n \n toolexeclibgoexphtmldir = $(toolexeclibgoexpdir)/html\n@@ -642,7 +642,8 @@ toolexeclibgogo_DATA = \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox\n+\tgo/token.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n@@ -973,7 +974,7 @@ go_mime_files = \\\n # By default use select with pipes.  Most systems should have\n # something better.\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_select.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_netbsd.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_bsd.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_linux.go\n @LIBGO_IS_RTEMS_TRUE@go_net_fd_os_file = go/net/fd_select.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver_unix.go\n@@ -1010,9 +1011,12 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_netbsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n+@LIBGO_IS_LINUX_FALSE@go_net_cloexec_file = go/net/sys_cloexec.go\n+@LIBGO_IS_LINUX_TRUE@go_net_cloexec_file = go/net/sock_cloexec.go\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n+\t$(go_net_cloexec_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n@@ -1068,6 +1072,8 @@ go_net_files = \\\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atim.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atim.go\n @LIBGO_IS_SOLARIS_TRUE@go_os_stat_file = go/os/stat_solaris.go\n+@LIBGO_IS_LINUX_FALSE@go_os_pipe_file = go/os/pipe_bsd.go\n+@LIBGO_IS_LINUX_TRUE@go_os_pipe_file = go/os/pipe_linux.go\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -1084,6 +1090,7 @@ go_os_files = \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n \tgo/os/path_unix.go \\\n+\t$(go_os_pipe_file) \\\n \tgo/os/proc.go \\\n \t$(go_os_stat_file) \\\n \tgo/os/str.go \\\n@@ -1208,6 +1215,7 @@ go_compress_bzip2_files = \\\n go_compress_flate_files = \\\n \tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n+\tgo/compress/flate/fixedhuff.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n@@ -1439,8 +1447,10 @@ go_exp_inotify_files = \\\n go_exp_locale_collate_files = \\\n \tgo/exp/locale/collate/colelem.go \\\n \tgo/exp/locale/collate/collate.go \\\n+\tgo/exp/locale/collate/colltab.go \\\n \tgo/exp/locale/collate/contract.go \\\n \tgo/exp/locale/collate/export.go \\\n+\tgo/exp/locale/collate/sort.go \\\n \tgo/exp/locale/collate/table.go \\\n \tgo/exp/locale/collate/tables.go \\\n \tgo/exp/locale/collate/trie.go\n@@ -1469,25 +1479,20 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n \n+go_exp_ssa_files = \\\n+\tgo/exp/ssa/blockopt.go \\\n+\tgo/exp/ssa/doc.go \\\n+\tgo/exp/ssa/func.go \\\n+\tgo/exp/ssa/sanity.go \\\n+\tgo/exp/ssa/ssa.go \\\n+\tgo/exp/ssa/literal.go \\\n+\tgo/exp/ssa/print.go \\\n+\tgo/exp/ssa/util.go\n+\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n \n-go_exp_types_files = \\\n-\tgo/exp/types/builtins.go \\\n-\tgo/exp/types/check.go \\\n-\tgo/exp/types/const.go \\\n-\tgo/exp/types/conversions.go \\\n-\tgo/exp/types/errors.go \\\n-\tgo/exp/types/exportdata.go \\\n-\tgo/exp/types/expr.go \\\n-\tgo/exp/types/gcimporter.go \\\n-\tgo/exp/types/operand.go \\\n-\tgo/exp/types/predicates.go \\\n-\tgo/exp/types/stmt.go \\\n-\tgo/exp/types/types.go \\\n-\tgo/exp/types/universe.go\n-\n go_exp_utf8string_files = \\\n \tgo/exp/utf8string/string.go\n \n@@ -1536,6 +1541,25 @@ go_go_token_files = \\\n \tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n \n+go_go_types_files = \\\n+\tgo/go/types/api.go \\\n+\tgo/go/types/builtins.go \\\n+\tgo/go/types/check.go \\\n+\tgo/go/types/const.go \\\n+\tgo/go/types/conversions.go \\\n+\tgo/go/types/errors.go \\\n+\tgo/go/types/exportdata.go \\\n+\tgo/go/types/expr.go \\\n+\tgo/go/types/gcimporter.go \\\n+\tgo/go/types/objects.go \\\n+\tgo/go/types/operand.go \\\n+\tgo/go/types/predicates.go \\\n+\tgo/go/types/resolve.go \\\n+\tgo/go/types/scope.go \\\n+\tgo/go/types/stmt.go \\\n+\tgo/go/types/types.go \\\n+\tgo/go/types/universe.go\n+\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n@@ -1976,8 +2000,8 @@ libgo_go_objs = \\\n \texp/locale/collate/build.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n+\texp/ssa.lo \\\n \texp/terminal.lo \\\n-\texp/types.lo \\\n \texp/utf8string.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n@@ -1988,6 +2012,7 @@ libgo_go_objs = \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -2233,7 +2258,6 @@ TEST_PACKAGES = \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/terminal/check \\\n-\texp/types/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n@@ -2244,7 +2268,7 @@ TEST_PACKAGES = \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n-\t$(go_types_check_omitted_since_it_calls_6g) \\\n+\tgo/types/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n@@ -5201,6 +5225,15 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n+@go_include@ exp/ssa.lo.dep\n+exp/ssa.lo.dep: $(go_exp_ssa_files)\n+\t$(BUILDDEPS)\n+exp/ssa.lo: $(go_exp_ssa_files)\n+\t$(BUILDPACKAGE)\n+exp/ssa/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/ssa/check\n+\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -5210,15 +5243,6 @@ exp/terminal/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/terminal/check\n \n-@go_include@ exp/types.lo.dep\n-exp/types.lo.dep: $(go_exp_types_files)\n-\t$(BUILDDEPS)\n-exp/types.lo: $(go_exp_types_files)\n-\t$(BUILDPACKAGE)\n-exp/types/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: exp/types/check\n-\n @go_include@ exp/utf8string.lo.dep\n exp/utf8string.lo.dep: $(go_exp_utf8string_files)\n \t$(BUILDDEPS)\n@@ -5327,6 +5351,15 @@ go/token/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/token/check\n \n+@go_include@ go/types.lo.dep\n+go/types.lo.dep: $(go_go_types_files)\n+\t$(BUILDDEPS)\n+go/types.lo: $(go_go_types_files)\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -5949,9 +5982,9 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/terminal.gox: exp/terminal.lo\n+exp/ssa.gox: exp/ssa.lo\n \t$(BUILDGOX)\n-exp/types.gox: exp/types.lo\n+exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/utf8string.gox: exp/utf8string.lo\t\n \t$(BUILDGOX)\n@@ -5975,6 +6008,8 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)"}, {"sha": "349ace6a2ade2342e4a0fb42d32b30c1a79a3fa7", "filename": "libgo/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -3,6 +3,9 @@\n /* Define if building universal (internal helper macro) */\n #undef AC_APPLE_UNIVERSAL_BUILD\n \n+/* Define to 1 if you have the `accept4' function. */\n+#undef HAVE_ACCEPT4\n+\n /* Define to 1 if you have the `acosl' function. */\n #undef HAVE_ACOSL\n \n@@ -153,6 +156,9 @@\n /* Define to 1 if you have the `openat' function. */\n #undef HAVE_OPENAT\n \n+/* Define to 1 if you have the `pipe2' function. */\n+#undef HAVE_PIPE2\n+\n /* Define to 1 if you have the `renameat' function. */\n #undef HAVE_RENAMEAT\n \n@@ -283,6 +289,9 @@\n /* Define to 1 if you have the <ustat.h> header file and it works. */\n #undef HAVE_USTAT_H\n \n+/* Define to 1 if you have the `utimensat' function. */\n+#undef HAVE_UTIMENSAT\n+\n /* Define to 1 if you have the <utime.h> header file. */\n #undef HAVE_UTIME_H\n "}, {"sha": "79c3a425f10e2f80d00eba52628814954090a726", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -14635,7 +14635,7 @@ else\n fi\n \n \n-for ac_func in epoll_create1 faccessat fallocate fchmodat fchownat futimesat inotify_add_watch inotify_init inotify_init1 inotify_rm_watch mkdirat mknodat openat renameat sync_file_range splice tee unlinkat unshare\n+for ac_func in accept4 epoll_create1 faccessat fallocate fchmodat fchownat futimesat inotify_add_watch inotify_init inotify_init1 inotify_rm_watch mkdirat mknodat openat pipe2 renameat sync_file_range splice tee unlinkat unshare utimensat\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\""}, {"sha": "6cc2307bc5274f61664732a454db7ccd91a1ad88", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -491,7 +491,7 @@ AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv dl_iterate_phdr)\n AM_CONDITIONAL(HAVE_STRERROR_R, test \"$ac_cv_func_strerror_r\" = yes)\n AM_CONDITIONAL(HAVE_WAIT4, test \"$ac_cv_func_wait4\" = yes)\n \n-AC_CHECK_FUNCS(epoll_create1 faccessat fallocate fchmodat fchownat futimesat inotify_add_watch inotify_init inotify_init1 inotify_rm_watch mkdirat mknodat openat renameat sync_file_range splice tee unlinkat unshare)\n+AC_CHECK_FUNCS(accept4 epoll_create1 faccessat fallocate fchmodat fchownat futimesat inotify_add_watch inotify_init inotify_init1 inotify_rm_watch mkdirat mknodat openat pipe2 renameat sync_file_range splice tee unlinkat unshare utimensat)\n AC_TYPE_OFF_T\n AC_CHECK_TYPES([loff_t])\n "}, {"sha": "a8af206a88fcfa1e9a4a5ba1c066285110bc2b77", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -18,8 +18,7 @@ import (\n \n func TestOver65kFiles(t *testing.T) {\n \tif testing.Short() {\n-\t\tt.Logf(\"slow test; skipping\")\n-\t\treturn\n+\t\tt.Skip(\"slow test; skipping\")\n \t}\n \tbuf := new(bytes.Buffer)\n \tw := NewWriter(buf)\n@@ -108,8 +107,7 @@ func TestFileHeaderRoundTrip64(t *testing.T) {\n \n func TestZip64(t *testing.T) {\n \tif testing.Short() {\n-\t\tt.Logf(\"slow test; skipping\")\n-\t\treturn\n+\t\tt.Skip(\"slow test; skipping\")\n \t}\n \t// write 2^32 bytes plus \"END\\n\" to a zip file\n \tbuf := new(bytes.Buffer)"}, {"sha": "33779014c9c90b855c95459d86ac28026e2cd0b1", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -76,13 +76,13 @@ func (b *Reader) fill() {\n \t}\n \n \t// Read new data.\n-\tn, e := b.rd.Read(b.buf[b.w:])\n+\tn, err := b.rd.Read(b.buf[b.w:])\n \tif n < 0 {\n \t\tpanic(errNegativeRead)\n \t}\n \tb.w += n\n-\tif e != nil {\n-\t\tb.err = e\n+\tif err != nil {\n+\t\tb.err = err\n \t}\n }\n \n@@ -379,8 +379,8 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n // ReadString returns err != nil if and only if the returned data does not end in\n // delim.\n func (b *Reader) ReadString(delim byte) (line string, err error) {\n-\tbytes, e := b.ReadBytes(delim)\n-\treturn string(bytes), e\n+\tbytes, err := b.ReadBytes(delim)\n+\treturn string(bytes), err\n }\n \n // WriteTo implements io.WriterTo.\n@@ -461,17 +461,17 @@ func (b *Writer) Flush() error {\n \tif b.n == 0 {\n \t\treturn nil\n \t}\n-\tn, e := b.wr.Write(b.buf[0:b.n])\n-\tif n < b.n && e == nil {\n-\t\te = io.ErrShortWrite\n+\tn, err := b.wr.Write(b.buf[0:b.n])\n+\tif n < b.n && err == nil {\n+\t\terr = io.ErrShortWrite\n \t}\n-\tif e != nil {\n+\tif err != nil {\n \t\tif n > 0 && n < b.n {\n \t\t\tcopy(b.buf[0:b.n-n], b.buf[n:b.n])\n \t\t}\n \t\tb.n -= n\n-\t\tb.err = e\n-\t\treturn e\n+\t\tb.err = err\n+\t\treturn err\n \t}\n \tb.n = 0\n \treturn nil"}, {"sha": "418690aa454d3b0cde67cbd17455be090487dccb", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -28,9 +28,9 @@ func newRot13Reader(r io.Reader) *rot13Reader {\n }\n \n func (r13 *rot13Reader) Read(p []byte) (int, error) {\n-\tn, e := r13.r.Read(p)\n-\tif e != nil {\n-\t\treturn n, e\n+\tn, err := r13.r.Read(p)\n+\tif err != nil {\n+\t\treturn n, err\n \t}\n \tfor i := 0; i < n; i++ {\n \t\tc := p[i] | 0x20 // lowercase byte\n@@ -48,15 +48,15 @@ func readBytes(buf *Reader) string {\n \tvar b [1000]byte\n \tnb := 0\n \tfor {\n-\t\tc, e := buf.ReadByte()\n-\t\tif e == io.EOF {\n+\t\tc, err := buf.ReadByte()\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n-\t\tif e == nil {\n+\t\tif err == nil {\n \t\t\tb[nb] = c\n \t\t\tnb++\n-\t\t} else if e != iotest.ErrTimeout {\n-\t\t\tpanic(\"Data: \" + e.Error())\n+\t\t} else if err != iotest.ErrTimeout {\n+\t\t\tpanic(\"Data: \" + err.Error())\n \t\t}\n \t}\n \treturn string(b[0:nb])\n@@ -93,12 +93,12 @@ var readMakers = []readMaker{\n func readLines(b *Reader) string {\n \ts := \"\"\n \tfor {\n-\t\ts1, e := b.ReadString('\\n')\n-\t\tif e == io.EOF {\n+\t\ts1, err := b.ReadString('\\n')\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n-\t\tif e != nil && e != iotest.ErrTimeout {\n-\t\t\tpanic(\"GetLines: \" + e.Error())\n+\t\tif err != nil && err != iotest.ErrTimeout {\n+\t\t\tpanic(\"GetLines: \" + err.Error())\n \t\t}\n \t\ts += s1\n \t}\n@@ -110,9 +110,9 @@ func reads(buf *Reader, m int) string {\n \tvar b [1000]byte\n \tnb := 0\n \tfor {\n-\t\tn, e := buf.Read(b[nb : nb+m])\n+\t\tn, err := buf.Read(b[nb : nb+m])\n \t\tnb += n\n-\t\tif e == io.EOF {\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -748,7 +748,7 @@ func testReadLineNewlines(t *testing.T, input string, expect []readLineResult) {\n \tb := NewReaderSize(strings.NewReader(input), minReadBufferSize)\n \tfor i, e := range expect {\n \t\tline, isPrefix, err := b.ReadLine()\n-\t\tif bytes.Compare(line, e.line) != 0 {\n+\t\tif !bytes.Equal(line, e.line) {\n \t\t\tt.Errorf(\"%q call %d, line == %q, want %q\", input, i, line, e.line)\n \t\t\treturn\n \t\t}"}, {"sha": "85c1577985d574543f940f8a690b0dd1669cb2df", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -367,7 +367,7 @@ func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n \treturn\n }\n \n-// readSlice is like readBytes but returns a reference to internal buffer data.\n+// readSlice is like ReadBytes but returns a reference to internal buffer data.\n func (b *Buffer) readSlice(delim byte) (line []byte, err error) {\n \ti := IndexByte(b.buf[b.off:], delim)\n \tend := b.off + i + 1\n@@ -377,6 +377,7 @@ func (b *Buffer) readSlice(delim byte) (line []byte, err error) {\n \t}\n \tline = b.buf[b.off:end]\n \tb.off = end\n+\tb.lastRead = opRead\n \treturn line, err\n }\n "}, {"sha": "f9fb2625a0f39f1fbfe1df0728eeeb451657cc7b", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -260,7 +260,7 @@ func TestWriteTo(t *testing.T) {\n \n func TestRuneIO(t *testing.T) {\n \tconst NRune = 1000\n-\t// Built a test array while we write the data\n+\t// Built a test slice while we write the data\n \tb := make([]byte, utf8.UTFMax*NRune)\n \tvar buf Buffer\n \tn := 0\n@@ -453,3 +453,25 @@ func TestReadEmptyAtEOF(t *testing.T) {\n \t\tt.Errorf(\"wrong count; got %d want 0\", n)\n \t}\n }\n+\n+func TestUnreadByte(t *testing.T) {\n+\tb := new(Buffer)\n+\tb.WriteString(\"abcdefghijklmnopqrstuvwxyz\")\n+\n+\t_, err := b.ReadBytes('m')\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadBytes: %v\", err)\n+\t}\n+\n+\terr = b.UnreadByte()\n+\tif err != nil {\n+\t\tt.Fatalf(\"UnreadByte: %v\", err)\n+\t}\n+\tc, err := b.ReadByte()\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadByte: %v\", err)\n+\t}\n+\tif c != 'm' {\n+\t\tt.Errorf(\"ReadByte = %q; want %q\", c, 'm')\n+\t}\n+}"}, {"sha": "e3ee5b1d88a63712f5e84bbc6d59af3240fcda02", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -11,8 +11,8 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// Compare returns an integer comparing the two byte arrays lexicographically.\n-// The result will be 0 if a==b, -1 if a < b, and +1 if a > b\n+// Compare returns an integer comparing two byte slices lexicographically.\n+// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n // A nil argument is equivalent to an empty slice.\n func Compare(a, b []byte) int {\n \tm := len(a)\n@@ -53,8 +53,8 @@ func equalPortable(a, b []byte) bool {\n \treturn true\n }\n \n-// explode splits s into an array of UTF-8 sequences, one per Unicode character (still arrays of bytes),\n-// up to a maximum of n byte arrays. Invalid UTF-8 sequences are chopped into individual bytes.\n+// explode splits s into a slice of UTF-8 sequences, one per Unicode character (still slices of bytes),\n+// up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes.\n func explode(s []byte, n int) [][]byte {\n \tif n <= 0 {\n \t\tn = len(s)\n@@ -226,7 +226,7 @@ func LastIndexAny(s []byte, chars string) int {\n }\n \n // Generic split: splits after each instance of sep,\n-// including sepSave bytes of sep in the subarrays.\n+// including sepSave bytes of sep in the subslices.\n func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n \tif n == 0 {\n \t\treturn nil\n@@ -287,15 +287,15 @@ func SplitAfter(s, sep []byte) [][]byte {\n \treturn genSplit(s, sep, len(sep), -1)\n }\n \n-// Fields splits the array s around each instance of one or more consecutive white space\n-// characters, returning a slice of subarrays of s or an empty list if s contains only white space.\n+// Fields splits the slice s around each instance of one or more consecutive white space\n+// characters, returning a slice of subslices of s or an empty list if s contains only white space.\n func Fields(s []byte) [][]byte {\n \treturn FieldsFunc(s, unicode.IsSpace)\n }\n \n // FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n-// It splits the array s at each run of code points c satisfying f(c) and\n-// returns a slice of subarrays of s.  If no code points in s satisfy f(c), an\n+// It splits the slice s at each run of code points c satisfying f(c) and\n+// returns a slice of subslices of s.  If no code points in s satisfy f(c), an\n // empty slice is returned.\n func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \tn := 0\n@@ -333,46 +333,46 @@ func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \treturn a[0:na]\n }\n \n-// Join concatenates the elements of a to create a new byte array. The separator\n-// sep is placed between elements in the resulting array.\n-func Join(a [][]byte, sep []byte) []byte {\n-\tif len(a) == 0 {\n+// Join concatenates the elements of s to create a new byte slice. The separator\n+// sep is placed between elements in the resulting slice.\n+func Join(s [][]byte, sep []byte) []byte {\n+\tif len(s) == 0 {\n \t\treturn []byte{}\n \t}\n-\tif len(a) == 1 {\n+\tif len(s) == 1 {\n \t\t// Just return a copy.\n-\t\treturn append([]byte(nil), a[0]...)\n+\t\treturn append([]byte(nil), s[0]...)\n \t}\n-\tn := len(sep) * (len(a) - 1)\n-\tfor i := 0; i < len(a); i++ {\n-\t\tn += len(a[i])\n+\tn := len(sep) * (len(s) - 1)\n+\tfor _, v := range s {\n+\t\tn += len(v)\n \t}\n \n \tb := make([]byte, n)\n-\tbp := copy(b, a[0])\n-\tfor _, s := range a[1:] {\n+\tbp := copy(b, s[0])\n+\tfor _, v := range s[1:] {\n \t\tbp += copy(b[bp:], sep)\n-\t\tbp += copy(b[bp:], s)\n+\t\tbp += copy(b[bp:], v)\n \t}\n \treturn b\n }\n \n-// HasPrefix tests whether the byte array s begins with prefix.\n+// HasPrefix tests whether the byte slice s begins with prefix.\n func HasPrefix(s, prefix []byte) bool {\n \treturn len(s) >= len(prefix) && Equal(s[0:len(prefix)], prefix)\n }\n \n-// HasSuffix tests whether the byte array s ends with suffix.\n+// HasSuffix tests whether the byte slice s ends with suffix.\n func HasSuffix(s, suffix []byte) bool {\n \treturn len(s) >= len(suffix) && Equal(s[len(s)-len(suffix):], suffix)\n }\n \n-// Map returns a copy of the byte array s with all its characters modified\n+// Map returns a copy of the byte slice s with all its characters modified\n // according to the mapping function. If mapping returns a negative value, the character is\n // dropped from the string with no replacement.  The characters in s and the\n // output are interpreted as UTF-8-encoded Unicode code points.\n func Map(mapping func(r rune) rune, s []byte) []byte {\n-\t// In the worst case, the array can grow when mapped, making\n+\t// In the worst case, the slice can grow when mapped, making\n \t// things unpleasant.  But it's so rare we barge in assuming it's\n \t// fine.  It could also shrink but that falls out naturally.\n \tmaxbytes := len(s) // length of b\n@@ -413,28 +413,28 @@ func Repeat(b []byte, count int) []byte {\n \treturn nb\n }\n \n-// ToUpper returns a copy of the byte array s with all Unicode letters mapped to their upper case.\n+// ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.\n func ToUpper(s []byte) []byte { return Map(unicode.ToUpper, s) }\n \n-// ToLower returns a copy of the byte array s with all Unicode letters mapped to their lower case.\n+// ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.\n func ToLower(s []byte) []byte { return Map(unicode.ToLower, s) }\n \n-// ToTitle returns a copy of the byte array s with all Unicode letters mapped to their title case.\n+// ToTitle returns a copy of the byte slice s with all Unicode letters mapped to their title case.\n func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n \n-// ToUpperSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n+// ToUpperSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return _case.ToUpper(r) }, s)\n }\n \n-// ToLowerSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n+// ToLowerSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return _case.ToLower(r) }, s)\n }\n \n-// ToTitleSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n+// ToTitleSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return _case.ToTitle(r) }, s)"}, {"sha": "05956d460a90db9e339f27c8cbaf7eccb4eb5994", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -25,16 +25,16 @@ func eq(a, b []string) bool {\n \treturn true\n }\n \n-func arrayOfString(a [][]byte) []string {\n-\tresult := make([]string, len(a))\n-\tfor j := 0; j < len(a); j++ {\n-\t\tresult[j] = string(a[j])\n+func sliceOfString(s [][]byte) []string {\n+\tresult := make([]string, len(s))\n+\tfor i, v := range s {\n+\t\tresult[i] = string(v)\n \t}\n \treturn result\n }\n \n // For ease of reading, the test cases use strings that are converted to byte\n-// arrays before invoking the functions.\n+// slices before invoking the functions.\n \n var abcd = \"abcd\"\n var faces = \"\u263a\u263b\u2639\"\n@@ -435,7 +435,7 @@ var explodetests = []ExplodeTest{\n func TestExplode(t *testing.T) {\n \tfor _, tt := range explodetests {\n \t\ta := SplitN([]byte(tt.s), nil, tt.n)\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Explode(\"%s\", %d) = %v; want %v`, tt.s, tt.n, result, tt.a)\n \t\t\tcontinue\n@@ -473,7 +473,7 @@ var splittests = []SplitTest{\n func TestSplit(t *testing.T) {\n \tfor _, tt := range splittests {\n \t\ta := SplitN([]byte(tt.s), []byte(tt.sep), tt.n)\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n \t\t\tcontinue\n@@ -519,7 +519,7 @@ var splitaftertests = []SplitTest{\n func TestSplitAfter(t *testing.T) {\n \tfor _, tt := range splitaftertests {\n \t\ta := SplitAfterN([]byte(tt.s), []byte(tt.sep), tt.n)\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n \t\t\tcontinue\n@@ -559,7 +559,7 @@ var fieldstests = []FieldsTest{\n func TestFields(t *testing.T) {\n \tfor _, tt := range fieldstests {\n \t\ta := Fields([]byte(tt.s))\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(\"Fields(%q) = %v; want %v\", tt.s, a, tt.a)\n \t\t\tcontinue\n@@ -570,7 +570,7 @@ func TestFields(t *testing.T) {\n func TestFieldsFunc(t *testing.T) {\n \tfor _, tt := range fieldstests {\n \t\ta := FieldsFunc([]byte(tt.s), unicode.IsSpace)\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(\"FieldsFunc(%q, unicode.IsSpace) = %v; want %v\", tt.s, a, tt.a)\n \t\t\tcontinue\n@@ -585,15 +585,15 @@ func TestFieldsFunc(t *testing.T) {\n \t}\n \tfor _, tt := range fieldsFuncTests {\n \t\ta := FieldsFunc([]byte(tt.s), pred)\n-\t\tresult := arrayOfString(a)\n+\t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(\"FieldsFunc(%q) = %v, want %v\", tt.s, a, tt.a)\n \t\t}\n \t}\n }\n \n-// Test case for any function which accepts and returns a byte array.\n-// For ease of creation, we write the byte arrays as strings.\n+// Test case for any function which accepts and returns a byte slice.\n+// For ease of creation, we write the byte slices as strings.\n type StringTest struct {\n \tin, out string\n }"}, {"sha": "dc66b6a40f67b73c24bd9c158bb82bded3f8d064", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n+\t\"sort\"\n )\n \n func ExampleBuffer() {\n@@ -27,3 +28,41 @@ func ExampleBuffer_reader() {\n \tio.Copy(os.Stdout, dec)\n \t// Output: Gophers rule!\n }\n+\n+func ExampleCompare() {\n+\t// Interpret Compare's result by comparing it to zero.\n+\tvar a, b []byte\n+\tif bytes.Compare(a, b) < 0 {\n+\t\t// a less b\n+\t}\n+\tif bytes.Compare(a, b) <= 0 {\n+\t\t// a less or equal b\n+\t}\n+\tif bytes.Compare(a, b) > 0 {\n+\t\t// a greater b\n+\t}\n+\tif bytes.Compare(a, b) >= 0 {\n+\t\t// a greater or equal b\n+\t}\n+\n+\t// Prefer Equal to Compare for equality comparisons.\n+\tif bytes.Equal(a, b) {\n+\t\t// a equal b\n+\t}\n+\tif !bytes.Equal(a, b) {\n+\t\t// a not equal b\n+\t}\n+}\n+\n+func ExampleCompare_search() {\n+\t// Binary search to find a matching byte slice.\n+\tvar needle []byte\n+\tvar haystack [][]byte // Assume sorted\n+\ti := sort.Search(len(haystack), func(i int) bool {\n+\t\t// Return haystack[i] >= needle.\n+\t\treturn bytes.Compare(haystack[i], needle) >= 0\n+\t})\n+\tif i < len(haystack) && bytes.Equal(haystack[i], needle) {\n+\t\t// Found it!\n+\t}\n+}"}, {"sha": "8f4e196b4274ee3fe459086169fb26dafd166e33", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -124,8 +124,7 @@ func (r *sparseReader) Read(b []byte) (n int, err error) {\n \n func TestVeryLongSparseChunk(t *testing.T) {\n \tif testing.Short() {\n-\t\tt.Logf(\"skipping sparse chunk during short test\")\n-\t\treturn\n+\t\tt.Skip(\"skipping sparse chunk during short test\")\n \t}\n \tw, err := NewWriter(ioutil.Discard, 1)\n \tif err != nil {"}, {"sha": "41a6b25dfdbcfe6730b0a3d602514e0734d146c7", "filename": "libgo/go/compress/flate/fixedhuff.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,74 @@\n+package flate\n+\n+// autogenerated by gen.go, DO NOT EDIT\n+\n+var fixedHuffmanDecoder = huffmanDecoder{\n+\t7,\n+\t[huffmanNumChunks]uint32{\n+\t\t0x1007, 0x0508, 0x0108, 0x1188, 0x1107, 0x0708, 0x0308, 0x0c09,\n+\t\t0x1087, 0x0608, 0x0208, 0x0a09, 0x0008, 0x0808, 0x0408, 0x0e09,\n+\t\t0x1047, 0x0588, 0x0188, 0x0909, 0x1147, 0x0788, 0x0388, 0x0d09,\n+\t\t0x10c7, 0x0688, 0x0288, 0x0b09, 0x0088, 0x0888, 0x0488, 0x0f09,\n+\t\t0x1027, 0x0548, 0x0148, 0x11c8, 0x1127, 0x0748, 0x0348, 0x0c89,\n+\t\t0x10a7, 0x0648, 0x0248, 0x0a89, 0x0048, 0x0848, 0x0448, 0x0e89,\n+\t\t0x1067, 0x05c8, 0x01c8, 0x0989, 0x1167, 0x07c8, 0x03c8, 0x0d89,\n+\t\t0x10e7, 0x06c8, 0x02c8, 0x0b89, 0x00c8, 0x08c8, 0x04c8, 0x0f89,\n+\t\t0x1017, 0x0528, 0x0128, 0x11a8, 0x1117, 0x0728, 0x0328, 0x0c49,\n+\t\t0x1097, 0x0628, 0x0228, 0x0a49, 0x0028, 0x0828, 0x0428, 0x0e49,\n+\t\t0x1057, 0x05a8, 0x01a8, 0x0949, 0x1157, 0x07a8, 0x03a8, 0x0d49,\n+\t\t0x10d7, 0x06a8, 0x02a8, 0x0b49, 0x00a8, 0x08a8, 0x04a8, 0x0f49,\n+\t\t0x1037, 0x0568, 0x0168, 0x11e8, 0x1137, 0x0768, 0x0368, 0x0cc9,\n+\t\t0x10b7, 0x0668, 0x0268, 0x0ac9, 0x0068, 0x0868, 0x0468, 0x0ec9,\n+\t\t0x1077, 0x05e8, 0x01e8, 0x09c9, 0x1177, 0x07e8, 0x03e8, 0x0dc9,\n+\t\t0x10f7, 0x06e8, 0x02e8, 0x0bc9, 0x00e8, 0x08e8, 0x04e8, 0x0fc9,\n+\t\t0x1007, 0x0518, 0x0118, 0x1198, 0x1107, 0x0718, 0x0318, 0x0c29,\n+\t\t0x1087, 0x0618, 0x0218, 0x0a29, 0x0018, 0x0818, 0x0418, 0x0e29,\n+\t\t0x1047, 0x0598, 0x0198, 0x0929, 0x1147, 0x0798, 0x0398, 0x0d29,\n+\t\t0x10c7, 0x0698, 0x0298, 0x0b29, 0x0098, 0x0898, 0x0498, 0x0f29,\n+\t\t0x1027, 0x0558, 0x0158, 0x11d8, 0x1127, 0x0758, 0x0358, 0x0ca9,\n+\t\t0x10a7, 0x0658, 0x0258, 0x0aa9, 0x0058, 0x0858, 0x0458, 0x0ea9,\n+\t\t0x1067, 0x05d8, 0x01d8, 0x09a9, 0x1167, 0x07d8, 0x03d8, 0x0da9,\n+\t\t0x10e7, 0x06d8, 0x02d8, 0x0ba9, 0x00d8, 0x08d8, 0x04d8, 0x0fa9,\n+\t\t0x1017, 0x0538, 0x0138, 0x11b8, 0x1117, 0x0738, 0x0338, 0x0c69,\n+\t\t0x1097, 0x0638, 0x0238, 0x0a69, 0x0038, 0x0838, 0x0438, 0x0e69,\n+\t\t0x1057, 0x05b8, 0x01b8, 0x0969, 0x1157, 0x07b8, 0x03b8, 0x0d69,\n+\t\t0x10d7, 0x06b8, 0x02b8, 0x0b69, 0x00b8, 0x08b8, 0x04b8, 0x0f69,\n+\t\t0x1037, 0x0578, 0x0178, 0x11f8, 0x1137, 0x0778, 0x0378, 0x0ce9,\n+\t\t0x10b7, 0x0678, 0x0278, 0x0ae9, 0x0078, 0x0878, 0x0478, 0x0ee9,\n+\t\t0x1077, 0x05f8, 0x01f8, 0x09e9, 0x1177, 0x07f8, 0x03f8, 0x0de9,\n+\t\t0x10f7, 0x06f8, 0x02f8, 0x0be9, 0x00f8, 0x08f8, 0x04f8, 0x0fe9,\n+\t\t0x1007, 0x0508, 0x0108, 0x1188, 0x1107, 0x0708, 0x0308, 0x0c19,\n+\t\t0x1087, 0x0608, 0x0208, 0x0a19, 0x0008, 0x0808, 0x0408, 0x0e19,\n+\t\t0x1047, 0x0588, 0x0188, 0x0919, 0x1147, 0x0788, 0x0388, 0x0d19,\n+\t\t0x10c7, 0x0688, 0x0288, 0x0b19, 0x0088, 0x0888, 0x0488, 0x0f19,\n+\t\t0x1027, 0x0548, 0x0148, 0x11c8, 0x1127, 0x0748, 0x0348, 0x0c99,\n+\t\t0x10a7, 0x0648, 0x0248, 0x0a99, 0x0048, 0x0848, 0x0448, 0x0e99,\n+\t\t0x1067, 0x05c8, 0x01c8, 0x0999, 0x1167, 0x07c8, 0x03c8, 0x0d99,\n+\t\t0x10e7, 0x06c8, 0x02c8, 0x0b99, 0x00c8, 0x08c8, 0x04c8, 0x0f99,\n+\t\t0x1017, 0x0528, 0x0128, 0x11a8, 0x1117, 0x0728, 0x0328, 0x0c59,\n+\t\t0x1097, 0x0628, 0x0228, 0x0a59, 0x0028, 0x0828, 0x0428, 0x0e59,\n+\t\t0x1057, 0x05a8, 0x01a8, 0x0959, 0x1157, 0x07a8, 0x03a8, 0x0d59,\n+\t\t0x10d7, 0x06a8, 0x02a8, 0x0b59, 0x00a8, 0x08a8, 0x04a8, 0x0f59,\n+\t\t0x1037, 0x0568, 0x0168, 0x11e8, 0x1137, 0x0768, 0x0368, 0x0cd9,\n+\t\t0x10b7, 0x0668, 0x0268, 0x0ad9, 0x0068, 0x0868, 0x0468, 0x0ed9,\n+\t\t0x1077, 0x05e8, 0x01e8, 0x09d9, 0x1177, 0x07e8, 0x03e8, 0x0dd9,\n+\t\t0x10f7, 0x06e8, 0x02e8, 0x0bd9, 0x00e8, 0x08e8, 0x04e8, 0x0fd9,\n+\t\t0x1007, 0x0518, 0x0118, 0x1198, 0x1107, 0x0718, 0x0318, 0x0c39,\n+\t\t0x1087, 0x0618, 0x0218, 0x0a39, 0x0018, 0x0818, 0x0418, 0x0e39,\n+\t\t0x1047, 0x0598, 0x0198, 0x0939, 0x1147, 0x0798, 0x0398, 0x0d39,\n+\t\t0x10c7, 0x0698, 0x0298, 0x0b39, 0x0098, 0x0898, 0x0498, 0x0f39,\n+\t\t0x1027, 0x0558, 0x0158, 0x11d8, 0x1127, 0x0758, 0x0358, 0x0cb9,\n+\t\t0x10a7, 0x0658, 0x0258, 0x0ab9, 0x0058, 0x0858, 0x0458, 0x0eb9,\n+\t\t0x1067, 0x05d8, 0x01d8, 0x09b9, 0x1167, 0x07d8, 0x03d8, 0x0db9,\n+\t\t0x10e7, 0x06d8, 0x02d8, 0x0bb9, 0x00d8, 0x08d8, 0x04d8, 0x0fb9,\n+\t\t0x1017, 0x0538, 0x0138, 0x11b8, 0x1117, 0x0738, 0x0338, 0x0c79,\n+\t\t0x1097, 0x0638, 0x0238, 0x0a79, 0x0038, 0x0838, 0x0438, 0x0e79,\n+\t\t0x1057, 0x05b8, 0x01b8, 0x0979, 0x1157, 0x07b8, 0x03b8, 0x0d79,\n+\t\t0x10d7, 0x06b8, 0x02b8, 0x0b79, 0x00b8, 0x08b8, 0x04b8, 0x0f79,\n+\t\t0x1037, 0x0578, 0x0178, 0x11f8, 0x1137, 0x0778, 0x0378, 0x0cf9,\n+\t\t0x10b7, 0x0678, 0x0278, 0x0af9, 0x0078, 0x0878, 0x0478, 0x0ef9,\n+\t\t0x1077, 0x05f8, 0x01f8, 0x09f9, 0x1177, 0x07f8, 0x03f8, 0x0df9,\n+\t\t0x10f7, 0x06f8, 0x02f8, 0x0bf9, 0x00f8, 0x08f8, 0x04f8, 0x0ff9,\n+\t},\n+\tnil, 0,\n+}"}, {"sha": "aba820a1f95387c4d3fbe771073c72dec7934527", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -10,122 +10,9 @@ package flate\n \n import (\n \t\"bytes\"\n-\t\"reflect\"\n \t\"testing\"\n )\n \n-// The Huffman code lengths used by the fixed-format Huffman blocks.\n-var fixedHuffmanBits = [...]int{\n-\t// 0-143 length 8\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n-\n-\t// 144-255 length 9\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\t9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n-\n-\t// 256-279 length 7\n-\t7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n-\t7, 7, 7, 7, 7, 7, 7, 7,\n-\n-\t// 280-287 length 8\n-\t8, 8, 8, 8, 8, 8, 8, 8,\n-}\n-\n-type InitDecoderTest struct {\n-\tin  []int\n-\tout huffmanDecoder\n-\tok  bool\n-}\n-\n-var initDecoderTests = []*InitDecoderTest{\n-\t// Example from Connell 1973,\n-\t{\n-\t\t[]int{3, 5, 2, 4, 3, 5, 5, 4, 4, 3, 4, 5},\n-\t\thuffmanDecoder{\n-\t\t\t2, 5,\n-\t\t\t[maxCodeLen + 1]int{2: 0, 4, 13, 31},\n-\t\t\t[maxCodeLen + 1]int{2: 0, 1, 6, 20},\n-\t\t\t// Paper used different code assignment:\n-\t\t\t// 2, 9, 4, 0, 10, 8, 3, 7, 1, 5, 11, 6\n-\t\t\t// Reordered here so that codes of same length\n-\t\t\t// are assigned to increasing numbers.\n-\t\t\t[]int{2, 0, 4, 9, 3, 7, 8, 10, 1, 5, 6, 11},\n-\t\t},\n-\t\ttrue,\n-\t},\n-\n-\t// Example from RFC 1951 section 3.2.2\n-\t{\n-\t\t[]int{2, 1, 3, 3},\n-\t\thuffmanDecoder{\n-\t\t\t1, 3,\n-\t\t\t[maxCodeLen + 1]int{1: 0, 2, 7},\n-\t\t\t[maxCodeLen + 1]int{1: 0, 1, 4},\n-\t\t\t[]int{1, 0, 2, 3},\n-\t\t},\n-\t\ttrue,\n-\t},\n-\n-\t// Second example from RFC 1951 section 3.2.2\n-\t{\n-\t\t[]int{3, 3, 3, 3, 3, 2, 4, 4},\n-\t\thuffmanDecoder{\n-\t\t\t2, 4,\n-\t\t\t[maxCodeLen + 1]int{2: 0, 6, 15},\n-\t\t\t[maxCodeLen + 1]int{2: 0, 1, 8},\n-\t\t\t[]int{5, 0, 1, 2, 3, 4, 6, 7},\n-\t\t},\n-\t\ttrue,\n-\t},\n-\n-\t// Static Huffman codes (RFC 1951 section 3.2.6)\n-\t{\n-\t\tfixedHuffmanBits[0:],\n-\t\tfixedHuffmanDecoder,\n-\t\ttrue,\n-\t},\n-\n-\t// Illegal input.\n-\t{\n-\t\t[]int{},\n-\t\thuffmanDecoder{},\n-\t\tfalse,\n-\t},\n-\n-\t// Illegal input.\n-\t{\n-\t\t[]int{0, 0, 0, 0, 0, 0, 0},\n-\t\thuffmanDecoder{},\n-\t\tfalse,\n-\t},\n-}\n-\n-func TestInitDecoder(t *testing.T) {\n-\tfor i, tt := range initDecoderTests {\n-\t\tvar h huffmanDecoder\n-\t\tif h.init(tt.in) != tt.ok {\n-\t\t\tt.Errorf(\"test %d: init = %v\", i, !tt.ok)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !reflect.DeepEqual(&h, &tt.out) {\n-\t\t\tt.Errorf(\"test %d:\\nhave %v\\nwant %v\", i, h, tt.out)\n-\t\t}\n-\t}\n-}\n-\n func TestUncompressedSource(t *testing.T) {\n \tdecoder := NewReader(bytes.NewBuffer([]byte{0x01, 0x01, 0x00, 0xfe, 0xff, 0x11}))\n \toutput := make([]byte, 1)"}, {"sha": "1427557f807e265cc84c006104450b5ae5dd83c8", "filename": "libgo/go/compress/flate/gen.go", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,165 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// This program generates fixedhuff.go\n+// Invoke as\n+//\n+//      go run gen.go |gofmt >fixedhuff.go\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+const maxCodeLen = 16\n+\n+// Note: the definition of the huffmanDecoder struct is copied from\n+// inflate.go, as it is private to the implementation.\n+\n+// chunk & 15 is number of bits\n+// chunk >> 4 is value, including table link\n+\n+const (\n+\thuffmanChunkBits  = 9\n+\thuffmanNumChunks  = 1 << huffmanChunkBits\n+\thuffmanCountMask  = 15\n+\thuffmanValueShift = 4\n+)\n+\n+type huffmanDecoder struct {\n+\tmin      int                      // the minimum code length\n+\tchunks   [huffmanNumChunks]uint32 // chunks as described above\n+\tlinks    [][]uint32               // overflow links\n+\tlinkMask uint32                   // mask the width of the link table\n+}\n+\n+// Initialize Huffman decoding tables from array of code lengths.\n+func (h *huffmanDecoder) init(bits []int) bool {\n+\t// Count number of codes of each length,\n+\t// compute min and max length.\n+\tvar count [maxCodeLen]int\n+\tvar min, max int\n+\tfor _, n := range bits {\n+\t\tif n == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif min == 0 || n < min {\n+\t\t\tmin = n\n+\t\t}\n+\t\tif n > max {\n+\t\t\tmax = n\n+\t\t}\n+\t\tcount[n]++\n+\t}\n+\tif max == 0 {\n+\t\treturn false\n+\t}\n+\n+\th.min = min\n+\tvar linkBits uint\n+\tvar numLinks int\n+\tif max > huffmanChunkBits {\n+\t\tlinkBits = uint(max) - huffmanChunkBits\n+\t\tnumLinks = 1 << linkBits\n+\t\th.linkMask = uint32(numLinks - 1)\n+\t}\n+\tcode := 0\n+\tvar nextcode [maxCodeLen]int\n+\tfor i := min; i <= max; i++ {\n+\t\tif i == huffmanChunkBits+1 {\n+\t\t\t// create link tables\n+\t\t\tlink := code >> 1\n+\t\t\th.links = make([][]uint32, huffmanNumChunks-link)\n+\t\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n+\t\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n+\t\t\t\treverse >>= uint(16 - huffmanChunkBits)\n+\t\t\t\toff := j - uint(link)\n+\t\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift + uint(i))\n+\t\t\t\th.links[off] = make([]uint32, 1<<linkBits)\n+\t\t\t}\n+\t\t}\n+\t\tn := count[i]\n+\t\tnextcode[i] = code\n+\t\tcode += n\n+\t\tcode <<= 1\n+\t}\n+\n+\tfor i, n := range bits {\n+\t\tif n == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tcode := nextcode[n]\n+\t\tnextcode[n]++\n+\t\tchunk := uint32(i<<huffmanValueShift | n)\n+\t\treverse := int(reverseByte[code>>8]) | int(reverseByte[code&0xff])<<8\n+\t\treverse >>= uint(16 - n)\n+\t\tif n <= huffmanChunkBits {\n+\t\t\tfor off := reverse; off < huffmanNumChunks; off += 1 << uint(n) {\n+\t\t\t\th.chunks[off] = chunk\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlinktab := h.links[h.chunks[reverse&(huffmanNumChunks-1)]>>huffmanValueShift]\n+\t\t\treverse >>= huffmanChunkBits\n+\t\t\tfor off := reverse; off < numLinks; off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\t\tlinktab[off] = chunk\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func main() {\n+\tvar h huffmanDecoder\n+\tvar bits [288]int\n+\tinitReverseByte()\n+\tfor i := 0; i < 144; i++ {\n+\t\tbits[i] = 8\n+\t}\n+\tfor i := 144; i < 256; i++ {\n+\t\tbits[i] = 9\n+\t}\n+\tfor i := 256; i < 280; i++ {\n+\t\tbits[i] = 7\n+\t}\n+\tfor i := 280; i < 288; i++ {\n+\t\tbits[i] = 8\n+\t}\n+\th.init(bits[:])\n+\tfmt.Println(\"package flate\")\n+\tfmt.Println()\n+\tfmt.Println(\"// autogenerated by gen.go, DO NOT EDIT\")\n+\tfmt.Println()\n+\tfmt.Println(\"var fixedHuffmanDecoder = huffmanDecoder{\")\n+\tfmt.Printf(\"\\t%d,\\n\", h.min)\n+\tfmt.Println(\"\\t[huffmanNumChunks]uint32{\")\n+\tfor i := 0; i < huffmanNumChunks; i++ {\n+\t\tif i&7 == 0 {\n+\t\t\tfmt.Printf(\"\\t\\t\")\n+\t\t} else {\n+\t\t\tfmt.Printf(\" \")\n+\t\t}\n+\t\tfmt.Printf(\"0x%04x,\", h.chunks[i])\n+\t\tif i&7 == 7 {\n+\t\t\tfmt.Println()\n+\t\t}\n+\t}\n+\tfmt.Println(\"\\t},\")\n+\tfmt.Println(\"\\tnil, 0,\")\n+\tfmt.Println(\"}\")\n+}\n+\n+var reverseByte [256]byte\n+\n+func initReverseByte() {\n+\tfor x := 0; x < 256; x++ {\n+\t\tvar result byte\n+\t\tfor i := uint(0); i < 8; i++ {\n+\t\t\tresult |= byte(((x >> i) & 1) << (7 - i))\n+\t\t}\n+\t\treverseByte[x] = result\n+\t}\n+}"}, {"sha": "a8d64601925377cc8db8bf70ad110fbae293b0c0", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 75, "deletions": 96, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -54,32 +54,46 @@ func (e *WriteError) Error() string {\n \treturn \"flate: write error at offset \" + strconv.FormatInt(e.Offset, 10) + \": \" + e.Err.Error()\n }\n \n-// Huffman decoder is based on\n-// J. Brian Connell, ``A Huffman-Shannon-Fano Code,''\n-// Proceedings of the IEEE, 61(7) (July 1973), pp 1046-1047.\n-type huffmanDecoder struct {\n-\t// min, max code length\n-\tmin, max int\n-\n-\t// limit[i] = largest code word of length i\n-\t// Given code v of length n,\n-\t// need more bits if v > limit[n].\n-\tlimit [maxCodeLen + 1]int\n+// Note that much of the implemenation of huffmanDecoder is also copied\n+// into gen.go (in package main) for the purpose of precomputing the\n+// fixed huffman tables so they can be included statically.\n+\n+// The data structure for decoding Huffman tables is based on that of\n+// zlib. There is a lookup table of a fixed bit width (huffmanChunkBits),\n+// For codes smaller than the table width, there are multiple entries\n+// (each combination of trailing bits has the same value). For codes\n+// larger than the table width, the table contains a link to an overflow\n+// table. The width of each entry in the link table is the maximum code\n+// size minus the chunk width.\n+\n+// Note that you can do a lookup in the table even without all bits\n+// filled. Since the extra bits are zero, and the DEFLATE Huffman codes\n+// have the property that shorter codes come before longer ones, the\n+// bit length estimate in the result is a lower bound on the actual\n+// number of bits.\n+\n+// chunk & 15 is number of bits\n+// chunk >> 4 is value, including table link\n \n-\t// base[i] = smallest code word of length i - seq number\n-\tbase [maxCodeLen + 1]int\n+const (\n+\thuffmanChunkBits  = 9\n+\thuffmanNumChunks  = 1 << huffmanChunkBits\n+\thuffmanCountMask  = 15\n+\thuffmanValueShift = 4\n+)\n \n-\t// codes[seq number] = output code.\n-\t// Given code v of length n, value is\n-\t// codes[v - base[n]].\n-\tcodes []int\n+type huffmanDecoder struct {\n+\tmin      int                      // the minimum code length\n+\tchunks   [huffmanNumChunks]uint32 // chunks as described above\n+\tlinks    [][]uint32               // overflow links\n+\tlinkMask uint32                   // mask the width of the link table\n }\n \n // Initialize Huffman decoding tables from array of code lengths.\n func (h *huffmanDecoder) init(bits []int) bool {\n \t// Count number of codes of each length,\n \t// compute min and max length.\n-\tvar count [maxCodeLen + 1]int\n+\tvar count [maxCodeLen]int\n \tvar min, max int\n \tfor _, n := range bits {\n \t\tif n == 0 {\n@@ -98,93 +112,58 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t}\n \n \th.min = min\n-\th.max = max\n-\n-\t// For each code range, compute\n-\t// nextcode (first code of that length),\n-\t// limit (last code of that length), and\n-\t// base (offset from first code to sequence number).\n+\tvar linkBits uint\n+\tvar numLinks int\n+\tif max > huffmanChunkBits {\n+\t\tlinkBits = uint(max) - huffmanChunkBits\n+\t\tnumLinks = 1 << linkBits\n+\t\th.linkMask = uint32(numLinks - 1)\n+\t}\n \tcode := 0\n-\tseq := 0\n \tvar nextcode [maxCodeLen]int\n \tfor i := min; i <= max; i++ {\n+\t\tif i == huffmanChunkBits+1 {\n+\t\t\t// create link tables\n+\t\t\tlink := code >> 1\n+\t\t\th.links = make([][]uint32, huffmanNumChunks-link)\n+\t\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n+\t\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n+\t\t\t\treverse >>= uint(16 - huffmanChunkBits)\n+\t\t\t\toff := j - uint(link)\n+\t\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift + uint(i))\n+\t\t\t\th.links[off] = make([]uint32, 1<<linkBits)\n+\t\t\t}\n+\t\t}\n \t\tn := count[i]\n \t\tnextcode[i] = code\n-\t\th.base[i] = code - seq\n \t\tcode += n\n-\t\tseq += n\n-\t\th.limit[i] = code - 1\n \t\tcode <<= 1\n \t}\n \n-\t// Make array mapping sequence numbers to codes.\n-\tif len(h.codes) < len(bits) {\n-\t\th.codes = make([]int, len(bits))\n-\t}\n \tfor i, n := range bits {\n \t\tif n == 0 {\n \t\t\tcontinue\n \t\t}\n \t\tcode := nextcode[n]\n \t\tnextcode[n]++\n-\t\tseq := code - h.base[n]\n-\t\th.codes[seq] = i\n+\t\tchunk := uint32(i<<huffmanValueShift | n)\n+\t\treverse := int(reverseByte[code>>8]) | int(reverseByte[code&0xff])<<8\n+\t\treverse >>= uint(16 - n)\n+\t\tif n <= huffmanChunkBits {\n+\t\t\tfor off := reverse; off < huffmanNumChunks; off += 1 << uint(n) {\n+\t\t\t\th.chunks[off] = chunk\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlinktab := h.links[h.chunks[reverse&(huffmanNumChunks-1)]>>huffmanValueShift]\n+\t\t\treverse >>= huffmanChunkBits\n+\t\t\tfor off := reverse; off < numLinks; off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\t\tlinktab[off] = chunk\n+\t\t\t}\n+\t\t}\n \t}\n \treturn true\n }\n \n-// Hard-coded Huffman tables for DEFLATE algorithm.\n-// See RFC 1951, section 3.2.6.\n-var fixedHuffmanDecoder = huffmanDecoder{\n-\t7, 9,\n-\t[maxCodeLen + 1]int{7: 23, 199, 511},\n-\t[maxCodeLen + 1]int{7: 0, 24, 224},\n-\t[]int{\n-\t\t// length 7: 256-279\n-\t\t256, 257, 258, 259, 260, 261, 262,\n-\t\t263, 264, 265, 266, 267, 268, 269,\n-\t\t270, 271, 272, 273, 274, 275, 276,\n-\t\t277, 278, 279,\n-\n-\t\t// length 8: 0-143\n-\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n-\t\t12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n-\t\t22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n-\t\t32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n-\t\t42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\n-\t\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n-\t\t62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\n-\t\t72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\n-\t\t82, 83, 84, 85, 86, 87, 88, 89, 90, 91,\n-\t\t92, 93, 94, 95, 96, 97, 98, 99, 100,\n-\t\t101, 102, 103, 104, 105, 106, 107, 108,\n-\t\t109, 110, 111, 112, 113, 114, 115, 116,\n-\t\t117, 118, 119, 120, 121, 122, 123, 124,\n-\t\t125, 126, 127, 128, 129, 130, 131, 132,\n-\t\t133, 134, 135, 136, 137, 138, 139, 140,\n-\t\t141, 142, 143,\n-\n-\t\t// length 8: 280-287\n-\t\t280, 281, 282, 283, 284, 285, 286, 287,\n-\n-\t\t// length 9: 144-255\n-\t\t144, 145, 146, 147, 148, 149, 150, 151,\n-\t\t152, 153, 154, 155, 156, 157, 158, 159,\n-\t\t160, 161, 162, 163, 164, 165, 166, 167,\n-\t\t168, 169, 170, 171, 172, 173, 174, 175,\n-\t\t176, 177, 178, 179, 180, 181, 182, 183,\n-\t\t184, 185, 186, 187, 188, 189, 190, 191,\n-\t\t192, 193, 194, 195, 196, 197, 198, 199,\n-\t\t200, 201, 202, 203, 204, 205, 206, 207,\n-\t\t208, 209, 210, 211, 212, 213, 214, 215,\n-\t\t216, 217, 218, 219, 220, 221, 222, 223,\n-\t\t224, 225, 226, 227, 228, 229, 230, 231,\n-\t\t232, 233, 234, 235, 236, 237, 238, 239,\n-\t\t240, 241, 242, 243, 244, 245, 246, 247,\n-\t\t248, 249, 250, 251, 252, 253, 254, 255,\n-\t},\n-}\n-\n // The actual read interface needed by NewReader.\n // If the passed in io.Reader does not also have ReadByte,\n // the NewReader will introduce its own buffering.\n@@ -644,23 +623,23 @@ func (f *decompressor) moreBits() error {\n \n // Read the next Huffman-encoded symbol from f according to h.\n func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n-\tfor n := uint(h.min); n <= uint(h.max); n++ {\n-\t\tlim := h.limit[n]\n-\t\tif lim == -1 {\n-\t\t\tcontinue\n-\t\t}\n+\tn := uint(h.min)\n+\tfor {\n \t\tfor f.nb < n {\n \t\t\tif err := f.moreBits(); err != nil {\n \t\t\t\treturn 0, err\n \t\t\t}\n \t\t}\n-\t\tv := int(f.b & uint32(1<<n-1))\n-\t\tv <<= 16 - n\n-\t\tv = int(reverseByte[v>>8]) | int(reverseByte[v&0xFF])<<8 // reverse bits\n-\t\tif v <= lim {\n+\t\tchunk := h.chunks[f.b&(huffmanNumChunks-1)]\n+\t\tn = uint(chunk & huffmanCountMask)\n+\t\tif n > huffmanChunkBits {\n+\t\t\tchunk = h.links[chunk>>huffmanValueShift][(f.b>>huffmanChunkBits)&h.linkMask]\n+\t\t\tn = uint(chunk & huffmanCountMask)\n+\t\t}\n+\t\tif n <= f.nb {\n \t\t\tf.b >>= n\n \t\t\tf.nb -= n\n-\t\t\treturn h.codes[v-h.base[n]], nil\n+\t\t\treturn int(chunk >> huffmanValueShift), nil\n \t\t}\n \t}\n \treturn 0, CorruptInputError(f.roffset)"}, {"sha": "b20691864b586d45aac9eba1224e21cd5a89bd16", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -13,7 +13,7 @@ import (\n \n // A writer is a buffered, flushable writer.\n type writer interface {\n-\tWriteByte(byte) error\n+\tio.ByteWriter\n \tFlush() error\n }\n "}, {"sha": "562a5badbd3e209d34056261fbc7c9a19b2c1a8e", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -108,6 +108,8 @@ func (l *List) insertValue(v interface{}, at *Element) *Element {\n func (l *List) remove(e *Element) *Element {\n \te.prev.next = e.next\n \te.next.prev = e.prev\n+\te.next = nil // avoid memory leaks\n+\te.prev = nil // avoid memory leaks\n \te.list = nil\n \tl.len--\n \treturn e"}, {"sha": "807e8daeaf45a9681b28ef386c075f76c5b4beff", "filename": "libgo/go/crypto/cipher/io.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -28,21 +28,17 @@ func (r StreamReader) Read(dst []byte) (n int, err error) {\n type StreamWriter struct {\n \tS   Stream\n \tW   io.Writer\n-\tErr error\n+\tErr error // unused\n }\n \n func (w StreamWriter) Write(src []byte) (n int, err error) {\n-\tif w.Err != nil {\n-\t\treturn 0, w.Err\n-\t}\n \tc := make([]byte, len(src))\n \tw.S.XORKeyStream(c, src)\n \tn, err = w.W.Write(c)\n \tif n != len(src) {\n \t\tif err == nil { // should never happen\n \t\t\terr = io.ErrShortWrite\n \t\t}\n-\t\tw.Err = err\n \t}\n \treturn\n }"}, {"sha": "2e87e99b67f126ac30f20bd6b7aff9885bb1db9f", "filename": "libgo/go/crypto/des/des_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -1503,3 +1503,21 @@ func TestSubstitutionTableKnownAnswerDecrypt(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func ExampleNewTripleDESCipher() {\n+\t// NewTripleDESCipher can also be used when EDE2 is required by\n+\t// duplicating the first 8 bytes of the 16-byte key.\n+\tede2Key := []byte(\"example key 1234\")\n+\n+\tvar tripleDESKey []byte\n+\ttripleDESKey = append(tripleDESKey, ede2Key[:16]...)\n+\ttripleDESKey = append(tripleDESKey, ede2Key[:8]...)\n+\n+\t_, err := NewTripleDESCipher(tripleDESKey)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// See crypto/cipher for how to use a cipher.Block for encryption and\n+\t// decryption.\n+}"}, {"sha": "50e5b162bdd615901e750b6c4133593ea44e8dff", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -10,6 +10,21 @@ import (\n \t\"math/big\"\n )\n \n+// smallPrimes is a list of small, prime numbers that allows us to rapidly\n+// exclude some fraction of composite candidates when searching for a random\n+// prime. This list is truncated at the point where smallPrimesProduct exceeds\n+// a uint64. It does not include two because we ensure that the candidates are\n+// odd by construction.\n+var smallPrimes = []uint8{\n+\t3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\n+}\n+\n+// smallPrimesProduct is the product of the values in smallPrimes and allows us\n+// to reduce a candidate prime by this number and then determine whether it's\n+// coprime to all the elements of smallPrimes without further big.Int\n+// operations.\n+var smallPrimesProduct = new(big.Int).SetUint64(16294579238595022365)\n+\n // Prime returns a number, p, of the given size, such that p is prime\n // with high probability.\n func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n@@ -25,6 +40,8 @@ func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \tbytes := make([]byte, (bits+7)/8)\n \tp = new(big.Int)\n \n+\tbigMod := new(big.Int)\n+\n \tfor {\n \t\t_, err = io.ReadFull(rand, bytes)\n \t\tif err != nil {\n@@ -33,13 +50,51 @@ func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \n \t\t// Clear bits in the first byte to make sure the candidate has a size <= bits.\n \t\tbytes[0] &= uint8(int(1<<b) - 1)\n-\t\t// Don't let the value be too small, i.e, set the most significant bit.\n-\t\tbytes[0] |= 1 << (b - 1)\n+\t\t// Don't let the value be too small, i.e, set the most significant two bits.\n+\t\t// Setting the top two bits, rather than just the top bit,\n+\t\t// means that when two of these values are multiplied together,\n+\t\t// the result isn't ever one bit short.\n+\t\tif b >= 2 {\n+\t\t\tbytes[0] |= 3 << (b - 2)\n+\t\t} else {\n+\t\t\t// Here b==1, because b cannot be zero.\n+\t\t\tbytes[0] |= 1\n+\t\t\tif len(bytes) > 1 {\n+\t\t\t\tbytes[1] |= 0x80\n+\t\t\t}\n+\t\t}\n \t\t// Make the value odd since an even number this large certainly isn't prime.\n \t\tbytes[len(bytes)-1] |= 1\n \n \t\tp.SetBytes(bytes)\n-\t\tif p.ProbablyPrime(20) {\n+\n+\t\t// Calculate the value mod the product of smallPrimes.  If it's\n+\t\t// a multiple of any of these primes we add two until it isn't.\n+\t\t// The probability of overflowing is minimal and can be ignored\n+\t\t// because we still perform Miller-Rabin tests on the result.\n+\t\tbigMod.Mod(p, smallPrimesProduct)\n+\t\tmod := bigMod.Uint64()\n+\n+\tNextDelta:\n+\t\tfor delta := uint64(0); delta < 1<<20; delta += 2 {\n+\t\t\tm := mod + delta\n+\t\t\tfor _, prime := range smallPrimes {\n+\t\t\t\tif m%uint64(prime) == 0 {\n+\t\t\t\t\tcontinue NextDelta\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif delta > 0 {\n+\t\t\t\tbigMod.SetUint64(delta)\n+\t\t\t\tp.Add(p, bigMod)\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// There is a tiny possibility that, by adding delta, we caused\n+\t\t// the number to be one bit too long. Thus we check BitLen\n+\t\t// here.\n+\t\tif p.ProbablyPrime(20) && p.BitLen() == bits {\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "bf9219bae1b47c36158c58eeb3f8f1c51de10d65", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -57,7 +57,7 @@ func TestDecryptPKCS1v15(t *testing.T) {\n \t\t\tt.Errorf(\"#%d error decrypting\", i)\n \t\t}\n \t\twant := []byte(test.out)\n-\t\tif bytes.Compare(out, want) != 0 {\n+\t\tif !bytes.Equal(out, want) {\n \t\t\tt.Errorf(\"#%d got:%#v want:%#v\", i, out, want)\n \t\t}\n \t}\n@@ -90,7 +90,7 @@ func TestEncryptPKCS1v15(t *testing.T) {\n \t\t\treturn false\n \t\t}\n \n-\t\tif bytes.Compare(plaintext, in) != 0 {\n+\t\tif !bytes.Equal(plaintext, in) {\n \t\t\tt.Errorf(\"output mismatch: %#v %#v\", plaintext, in)\n \t\t\treturn false\n \t\t}\n@@ -132,7 +132,7 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {\n \t\t\tt.Errorf(\"#%d error decrypting\", i)\n \t\t}\n \t\twant := []byte(test.out)\n-\t\tif bytes.Compare(key, want) != 0 {\n+\t\tif !bytes.Equal(key, want) {\n \t\t\tt.Errorf(\"#%d got:%#v want:%#v\", i, key, want)\n \t\t}\n \t}\n@@ -176,7 +176,7 @@ func TestSignPKCS1v15(t *testing.T) {\n \t\t}\n \n \t\texpected, _ := hex.DecodeString(test.out)\n-\t\tif bytes.Compare(s, expected) != 0 {\n+\t\tif !bytes.Equal(s, expected) {\n \t\t\tt.Errorf(\"#%d got: %x want: %x\", i, s, expected)\n \t\t}\n \t}"}, {"sha": "543070f90fbe4d412bf2e431617fa37cf5e78ef9", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -175,6 +175,11 @@ NextSetOfPrimes:\n \t\t\tpminus1.Sub(prime, bigOne)\n \t\t\ttotient.Mul(totient, pminus1)\n \t\t}\n+\t\tif n.BitLen() != bits {\n+\t\t\t// This should never happen because crypto/rand should\n+\t\t\t// set the top two bits in each prime.\n+\t\t\tcontinue NextSetOfPrimes\n+\t\t}\n \n \t\tg := new(big.Int)\n \t\tpriv.D = new(big.Int)"}, {"sha": "9be22a8f0bfb395c8429472bd3aebb65441bdbb2", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -21,6 +21,9 @@ func TestKeyGeneration(t *testing.T) {\n \tif err != nil {\n \t\tt.Errorf(\"failed to generate key\")\n \t}\n+\tif bits := priv.N.BitLen(); bits != size {\n+\t\tt.Errorf(\"key too short (%d vs %d)\", bits, size)\n+\t}\n \ttestKeyBasics(t, priv)\n }\n \n@@ -176,7 +179,7 @@ func TestEncryptOAEP(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"#%d,%d error: %s\", i, j, err)\n \t\t\t}\n-\t\t\tif bytes.Compare(out, message.out) != 0 {\n+\t\t\tif !bytes.Equal(out, message.out) {\n \t\t\t\tt.Errorf(\"#%d,%d bad result: %x (want %x)\", i, j, out, message.out)\n \t\t\t}\n \t\t}\n@@ -200,15 +203,15 @@ func TestDecryptOAEP(t *testing.T) {\n \t\t\tout, err := DecryptOAEP(sha1, nil, private, message.out, nil)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"#%d,%d error: %s\", i, j, err)\n-\t\t\t} else if bytes.Compare(out, message.in) != 0 {\n+\t\t\t} else if !bytes.Equal(out, message.in) {\n \t\t\t\tt.Errorf(\"#%d,%d bad result: %#v (want %#v)\", i, j, out, message.in)\n \t\t\t}\n \n \t\t\t// Decrypt with blinding.\n \t\t\tout, err = DecryptOAEP(sha1, random, private, message.out, nil)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"#%d,%d (blind) error: %s\", i, j, err)\n-\t\t\t} else if bytes.Compare(out, message.in) != 0 {\n+\t\t\t} else if !bytes.Equal(out, message.in) {\n \t\t\t\tt.Errorf(\"#%d,%d (blind) bad result: %#v (want %#v)\", i, j, out, message.in)\n \t\t\t}\n \t\t}"}, {"sha": "a888df762db389ba0100189192d4ed70a4caafeb", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -184,6 +184,12 @@ type Config struct {\n \t// is nil, TLS uses a list of suites supported by the implementation.\n \tCipherSuites []uint16\n \n+\t// PreferServerCipherSuites controls whether the server selects the\n+\t// client's most preferred ciphersuite, or the server's most preferred\n+\t// ciphersuite. If true then the server's preference, as expressed in\n+\t// the order of elements in CipherSuites, is used.\n+\tPreferServerCipherSuites bool\n+\n \t// SessionTicketsDisabled may be set to true to disable session ticket\n \t// (resumption) support.\n \tSessionTicketsDisabled bool"}, {"sha": "730991016aaed5399365ec23ef8aee7701c2a486", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -180,8 +180,17 @@ Curves:\n \t\treturn true, nil\n \t}\n \n-\tfor _, id := range hs.clientHello.cipherSuites {\n-\t\tif hs.suite = c.tryCipherSuite(id, hs.ellipticOk); hs.suite != nil {\n+\tvar preferenceList, supportedList []uint16\n+\tif c.config.PreferServerCipherSuites {\n+\t\tpreferenceList = c.config.cipherSuites()\n+\t\tsupportedList = hs.clientHello.cipherSuites\n+\t} else {\n+\t\tpreferenceList = hs.clientHello.cipherSuites\n+\t\tsupportedList = c.config.cipherSuites()\n+\t}\n+\n+\tfor _, id := range preferenceList {\n+\t\tif hs.suite = c.tryCipherSuite(id, supportedList, hs.ellipticOk); hs.suite != nil {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -222,7 +231,7 @@ func (hs *serverHandshakeState) checkForResumption() bool {\n \t}\n \n \t// Check that we also support the ciphersuite from the session.\n-\ths.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, hs.ellipticOk)\n+\ths.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.ellipticOk)\n \tif hs.suite == nil {\n \t\treturn false\n \t}\n@@ -568,8 +577,8 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (*\n \n // tryCipherSuite returns a cipherSuite with the given id if that cipher suite\n // is acceptable to use.\n-func (c *Conn) tryCipherSuite(id uint16, ellipticOk bool) *cipherSuite {\n-\tfor _, supported := range c.config.cipherSuites() {\n+func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, ellipticOk bool) *cipherSuite {\n+\tfor _, supported := range supportedCipherSuites {\n \t\tif id == supported {\n \t\t\tvar candidate *cipherSuite\n "}, {"sha": "bf8cbe3ae6b91e97e898f966a1fc3e6e21a25fa4", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -125,6 +125,50 @@ func TestClose(t *testing.T) {\n \t}\n }\n \n+func testHandshake(clientConfig, serverConfig *Config) (state ConnectionState, err error) {\n+\tc, s := net.Pipe()\n+\tgo func() {\n+\t\tcli := Client(c, clientConfig)\n+\t\tcli.Handshake()\n+\t\tc.Close()\n+\t}()\n+\tserver := Server(s, serverConfig)\n+\terr = server.Handshake()\n+\tif err == nil {\n+\t\tstate = server.ConnectionState()\n+\t}\n+\ts.Close()\n+\treturn\n+}\n+\n+func TestCipherSuitePreference(t *testing.T) {\n+\tserverConfig := &Config{\n+\t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n+\t\tCertificates: testConfig.Certificates,\n+\t}\n+\tclientConfig := &Config{\n+\t\tCipherSuites:       []uint16{TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_RC4_128_SHA},\n+\t\tInsecureSkipVerify: true,\n+\t}\n+\tstate, err := testHandshake(clientConfig, serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshake failed: %s\", err)\n+\t}\n+\tif state.CipherSuite != TLS_RSA_WITH_AES_128_CBC_SHA {\n+\t\t// By default the server should use the client's preference.\n+\t\tt.Fatalf(\"Client's preference was not used, got %x\", state.CipherSuite)\n+\t}\n+\n+\tserverConfig.PreferServerCipherSuites = true\n+\tstate, err = testHandshake(clientConfig, serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshake failed: %s\", err)\n+\t}\n+\tif state.CipherSuite != TLS_RSA_WITH_RC4_128_SHA {\n+\t\tt.Fatalf(\"Server's preference was not used, got %x\", state.CipherSuite)\n+\t}\n+}\n+\n func testServerScript(t *testing.T, name string, serverScript [][]byte, config *Config, peers []*x509.Certificate) {\n \tc, s := net.Pipe()\n \tsrv := Server(s, config)"}, {"sha": "ad3bfb4b432c9ff527f7f7f4cffff1c72c4e6521", "filename": "libgo/go/crypto/x509/root_darwin.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -70,11 +70,12 @@ func initSystemRoots() {\n \n \tvar data C.CFDataRef = nil\n \terr := C.FetchPEMRoots(&data)\n-\tif err != -1 {\n-\t\tdefer C.CFRelease(C.CFTypeRef(data))\n-\t\tbuf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))\n-\t\troots.AppendCertsFromPEM(buf)\n+\tif err == -1 {\n+\t\treturn\n \t}\n \n+\tdefer C.CFRelease(C.CFTypeRef(data))\n+\tbuf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))\n+\troots.AppendCertsFromPEM(buf)\n \tsystemRoots = roots\n }"}, {"sha": "9965caadee3a887dd744f30051deacb51692cb57", "filename": "libgo/go/crypto/x509/root_plan9.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -23,9 +23,11 @@ func initSystemRoots() {\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tif err == nil {\n \t\t\troots.AppendCertsFromPEM(data)\n-\t\t\tbreak\n+\t\t\tsystemRoots = roots\n+\t\t\treturn\n \t\t}\n \t}\n \n-\tsystemRoots = roots\n+\t// All of the files failed to load. systemRoots will be nil which will\n+\t// trigger a specific error at verification time.\n }"}, {"sha": "4c742ccc3715eb8475c776aeab973fbdda5ac722", "filename": "libgo/go/crypto/x509/root_stub.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -11,5 +11,4 @@ func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate\n }\n \n func initSystemRoots() {\n-\tsystemRoots = NewCertPool()\n }"}, {"sha": "1b25a94d08d6c1e85ba665473e74cfcdeb92e3fb", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -27,9 +27,11 @@ func initSystemRoots() {\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tif err == nil {\n \t\t\troots.AppendCertsFromPEM(data)\n-\t\t\tbreak\n+\t\t\tsystemRoots = roots\n+\t\t\treturn\n \t\t}\n \t}\n \n-\tsystemRoots = roots\n+\t// All of the files failed to load. systemRoots will be nil which will\n+\t// trigger a specific error at verification time.\n }"}, {"sha": "e8f70a49da87c63a4cfcc4717f0d98922e79701a", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -226,5 +226,4 @@ func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate\n }\n \n func initSystemRoots() {\n-\tsystemRoots = NewCertPool()\n }"}, {"sha": "51be5feb063615f98bf069bc482ffa30f03f68e3", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -82,6 +82,14 @@ func (e UnknownAuthorityError) Error() string {\n \treturn \"x509: certificate signed by unknown authority\"\n }\n \n+// SystemRootsError results when we fail to load the system root certificates.\n+type SystemRootsError struct {\n+}\n+\n+func (e SystemRootsError) Error() string {\n+\treturn \"x509: failed to load system roots and no roots provided\"\n+}\n+\n // VerifyOptions contains parameters for Certificate.Verify. It's a structure\n // because other PKIX verification APIs have ended up needing many options.\n type VerifyOptions struct {\n@@ -170,6 +178,9 @@ func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e\n \n \tif opts.Roots == nil {\n \t\topts.Roots = systemRootsPool()\n+\t\tif opts.Roots == nil {\n+\t\t\treturn nil, SystemRootsError{}\n+\t\t}\n \t}\n \n \terr = c.isValid(leafCertificate, nil, &opts)"}, {"sha": "631a0f849810966e4e74642ed459448617f08440", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,19 +15,31 @@ import (\n )\n \n type verifyTest struct {\n-\tleaf          string\n-\tintermediates []string\n-\troots         []string\n-\tcurrentTime   int64\n-\tdnsName       string\n-\tsystemSkip    bool\n-\tkeyUsages     []ExtKeyUsage\n+\tleaf                 string\n+\tintermediates        []string\n+\troots                []string\n+\tcurrentTime          int64\n+\tdnsName              string\n+\tsystemSkip           bool\n+\tkeyUsages            []ExtKeyUsage\n+\ttestSystemRootsError bool\n \n \terrorCallback  func(*testing.T, int, error) bool\n \texpectedChains [][]string\n }\n \n var verifyTests = []verifyTest{\n+\t{\n+\t\tleaf:                 googleLeaf,\n+\t\tintermediates:        []string{thawteIntermediate},\n+\t\tcurrentTime:          1302726541,\n+\t\tdnsName:              \"www.google.com\",\n+\t\ttestSystemRootsError: true,\n+\n+\t\t// Without any roots specified we should get a system roots\n+\t\t// error.\n+\t\terrorCallback: expectSystemRootsError,\n+\t},\n \t{\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{thawteIntermediate},\n@@ -180,6 +192,14 @@ func expectAuthorityUnknown(t *testing.T, i int, err error) (ok bool) {\n \treturn true\n }\n \n+func expectSystemRootsError(t *testing.T, i int, err error) bool {\n+\tif _, ok := err.(SystemRootsError); !ok {\n+\t\tt.Errorf(\"#%d: error was not SystemRootsError: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \tblock, _ := pem.Decode([]byte(pemBytes))\n \tif block == nil {\n@@ -193,6 +213,9 @@ func testVerify(t *testing.T, useSystemRoots bool) {\n \t\tif useSystemRoots && test.systemSkip {\n \t\t\tcontinue\n \t\t}\n+\t\tif runtime.GOOS == \"windows\" && test.testSystemRootsError {\n+\t\t\tcontinue\n+\t\t}\n \n \t\topts := VerifyOptions{\n \t\t\tIntermediates: NewCertPool(),\n@@ -226,8 +249,19 @@ func testVerify(t *testing.T, useSystemRoots bool) {\n \t\t\treturn\n \t\t}\n \n+\t\tvar oldSystemRoots *CertPool\n+\t\tif test.testSystemRootsError {\n+\t\t\toldSystemRoots = systemRootsPool()\n+\t\t\tsystemRoots = nil\n+\t\t\topts.Roots = nil\n+\t\t}\n+\n \t\tchains, err := leaf.Verify(opts)\n \n+\t\tif test.testSystemRootsError {\n+\t\t\tsystemRoots = oldSystemRoots\n+\t\t}\n+\n \t\tif test.errorCallback == nil && err != nil {\n \t\t\tt.Errorf(\"#%d: unexpected error: %s\", i, err)\n \t\t}\n@@ -275,8 +309,7 @@ func TestGoVerify(t *testing.T) {\n \n func TestSystemVerify(t *testing.T) {\n \tif runtime.GOOS != \"windows\" {\n-\t\tt.Logf(\"skipping verify test using system APIs on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping verify test using system APIs on %q\", runtime.GOOS)\n \t}\n \n \ttestVerify(t, true)"}, {"sha": "29aef78b2407e373ac2af62fe9cf80232c629f03", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -369,19 +369,11 @@ func (db *DB) exec(query string, args []interface{}) (res Result, err error) {\n \t}\n \tdefer sti.Close()\n \n-\tdargs, err := driverArgs(sti, args)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tresi, err := sti.Exec(dargs)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn result{resi}, nil\n+\treturn resultFromStatement(sti, args...)\n }\n \n // Query executes a query that returns rows, typically a SELECT.\n+// The args are for any placeholder parameters in the query.\n func (db *DB) Query(query string, args ...interface{}) (*Rows, error) {\n \tstmt, err := db.Prepare(query)\n \tif err != nil {\n@@ -608,16 +600,7 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t}\n \tdefer sti.Close()\n \n-\tdargs, err := driverArgs(sti, args)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tresi, err := sti.Exec(dargs)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn result{resi}, nil\n+\treturn resultFromStatement(sti, args...)\n }\n \n // Query executes a query that returns rows, typically a SELECT.\n@@ -682,6 +665,10 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t}\n \tdefer releaseConn(nil)\n \n+\treturn resultFromStatement(si, args...)\n+}\n+\n+func resultFromStatement(si driver.Stmt, args ...interface{}) (Result, error) {\n \t// -1 means the driver doesn't know how to count the number of\n \t// placeholders, so we won't sanity check input here and instead let the\n \t// driver deal with errors."}, {"sha": "20acba612f2f015dd23a4aec081b1cf92dc47d2c", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -52,6 +52,14 @@ func dotest() bool {\n \treturn true\n }\n \n+func endtest() {\n+\tif pclineTempDir != \"\" {\n+\t\tos.RemoveAll(pclineTempDir)\n+\t\tpclineTempDir = \"\"\n+\t\tpclinetestBinary = \"\"\n+\t}\n+}\n+\n func getTable(t *testing.T) *Table {\n \tf, tab := crack(os.Args[0], t)\n \tf.Close()\n@@ -95,6 +103,7 @@ func TestLineFromAline(t *testing.T) {\n \tif !dotest() {\n \t\treturn\n \t}\n+\tdefer endtest()\n \n \ttab := getTable(t)\n \n@@ -129,7 +138,7 @@ func TestLineFromAline(t *testing.T) {\n \t\tif !ok {\n \t\t\tt.Errorf(\"file %s starts on line %d\", path, line)\n \t\t} else if line != ll+1 {\n-\t\t\tt.Errorf(\"expected next line of file %s to be %d, got %d\", path, ll+1, line)\n+\t\t\tt.Fatalf(\"expected next line of file %s to be %d, got %d\", path, ll+1, line)\n \t\t}\n \t\tlastline[path] = line\n \t}\n@@ -142,6 +151,7 @@ func TestLineAline(t *testing.T) {\n \tif !dotest() {\n \t\treturn\n \t}\n+\tdefer endtest()\n \n \ttab := getTable(t)\n \n@@ -183,7 +193,7 @@ func TestPCLine(t *testing.T) {\n \tif !dotest() {\n \t\treturn\n \t}\n-\tdefer os.RemoveAll(pclineTempDir)\n+\tdefer endtest()\n \n \tf, tab := crack(pclinetestBinary, t)\n \ttext := f.Section(\".text\")"}, {"sha": "cc01e0b9d695d2c2b1c0a34248f795bfeb1782fb", "filename": "libgo/go/debug/gosym/symtab.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -13,6 +13,7 @@ package gosym\n // and the Go format is the runtime source, specifically ../../runtime/symtab.c.\n \n import (\n+\t\"bytes\"\n \t\"encoding/binary\"\n \t\"fmt\"\n \t\"strconv\"\n@@ -104,11 +105,18 @@ type sym struct {\n \tname   []byte\n }\n \n+var littleEndianSymtab = []byte{0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00}\n+\n func walksymtab(data []byte, fn func(sym) error) error {\n+\tvar order binary.ByteOrder = binary.BigEndian\n+\tif bytes.HasPrefix(data, littleEndianSymtab) {\n+\t\tdata = data[6:]\n+\t\torder = binary.LittleEndian\n+\t}\n \tvar s sym\n \tp := data\n \tfor len(p) >= 6 {\n-\t\ts.value = binary.BigEndian.Uint32(p[0:4])\n+\t\ts.value = order.Uint32(p[0:4])\n \t\ttyp := p[4]\n \t\tif typ&0x80 == 0 {\n \t\t\treturn &DecodingError{len(data) - len(p) + 4, \"bad symbol type\", typ}\n@@ -139,7 +147,7 @@ func walksymtab(data []byte, fn func(sym) error) error {\n \t\t}\n \t\ts.name = p[0:i]\n \t\ti += nnul\n-\t\ts.gotype = binary.BigEndian.Uint32(p[i : i+4])\n+\t\ts.gotype = order.Uint32(p[i : i+4])\n \t\tp = p[i+4:]\n \t\tfn(s)\n \t}"}, {"sha": "6e98dcf0b990f7fd6b6628009bf634ae9ac60e62", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -124,7 +124,7 @@ func TestBitString(t *testing.T) {\n \t\t\tt.Errorf(\"#%d: Incorrect error result (did fail? %v, expected: %v)\", i, err == nil, test.ok)\n \t\t}\n \t\tif err == nil {\n-\t\t\tif test.bitLength != ret.BitLength || bytes.Compare(ret.Bytes, test.out) != 0 {\n+\t\t\tif test.bitLength != ret.BitLength || !bytes.Equal(ret.Bytes, test.out) {\n \t\t\t\tt.Errorf(\"#%d: Bad result: %v (expected %v %v)\", i, ret, test.out, test.bitLength)\n \t\t\t}\n \t\t}\n@@ -166,7 +166,7 @@ func TestBitStringRightAlign(t *testing.T) {\n \tfor i, test := range bitStringRightAlignTests {\n \t\tbs := BitString{test.in, test.inlen}\n \t\tout := bs.RightAlign()\n-\t\tif bytes.Compare(out, test.out) != 0 {\n+\t\tif !bytes.Equal(out, test.out) {\n \t\t\tt.Errorf(\"#%d got: %x want: %x\", i, out, test.out)\n \t\t}\n \t}\n@@ -477,7 +477,7 @@ func TestRawStructs(t *testing.T) {\n \tif s.A != 0x50 {\n \t\tt.Errorf(\"bad value for A: got %d want %d\", s.A, 0x50)\n \t}\n-\tif bytes.Compare([]byte(s.Raw), input) != 0 {\n+\tif !bytes.Equal([]byte(s.Raw), input) {\n \t\tt.Errorf(\"bad value for Raw: got %x want %x\", s.Raw, input)\n \t}\n }"}, {"sha": "b4dbe71ef3c7fe6403757395f8571124ed0ef6d1", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -132,7 +132,7 @@ func TestMarshal(t *testing.T) {\n \t\t\tt.Errorf(\"#%d failed: %s\", i, err)\n \t\t}\n \t\tout, _ := hex.DecodeString(test.out)\n-\t\tif bytes.Compare(out, data) != 0 {\n+\t\tif !bytes.Equal(out, data) {\n \t\t\tt.Errorf(\"#%d got: %x want %x\\n\\t%q\\n\\t%q\", i, data, out, data, out)\n \n \t\t}"}, {"sha": "5bd61b12eb1dd284b8ba5c660e88f0452ab94307", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -67,11 +67,13 @@ point values may be received into any floating point variable.  However,\n the destination variable must be able to represent the value or the decode\n operation will fail.\n \n-Structs, arrays and slices are also supported.  Strings and arrays of bytes are\n-supported with a special, efficient representation (see below).  When a slice is\n-decoded, if the existing slice has capacity the slice will be extended in place;\n-if not, a new array is allocated.  Regardless, the length of the resulting slice\n-reports the number of elements decoded.\n+Structs, arrays and slices are also supported.  Structs encode and\n+decode only exported fields. Strings and arrays of bytes are supported\n+with a special, efficient representation (see below).  When a slice\n+is decoded, if the existing slice has capacity the slice will be\n+extended in place; if not, a new array is allocated.  Regardless,\n+the length of the resulting slice reports the number of elements\n+decoded.\n \n Functions and channels cannot be sent in a gob.  Attempting\n to encode a value that contains one will fail."}, {"sha": "f669c3d5b24a0dfe982f2a491f61d924deea3b80", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -137,8 +137,8 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n \tut := userType(origt)\n \tif ut.isGobEncoder {\n \t\t// The rules are different: regardless of the underlying type's representation,\n-\t\t// we need to tell the other side that this exact type is a GobEncoder.\n-\t\treturn enc.sendActualType(w, state, ut, ut.user)\n+\t\t// we need to tell the other side that the base type is a GobEncoder.\n+\t\treturn enc.sendActualType(w, state, ut, ut.base)\n \t}\n \n \t// It's a concrete value, so drill down to the base type."}, {"sha": "18f4450da6d4051a322cceabc2c98edda4941ecc", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -142,6 +142,18 @@ type GobTest5 struct {\n \tV *ValueGobber\n }\n \n+type GobTest6 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tV ValueGobber\n+\tW *ValueGobber\n+}\n+\n+type GobTest7 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tV *ValueGobber\n+\tW ValueGobber\n+}\n+\n type GobTestIgnoreEncoder struct {\n \tX int // guarantee we have  something in common with GobTest*\n }\n@@ -360,6 +372,61 @@ func TestGobEncoderValueEncoder(t *testing.T) {\n \t}\n }\n \n+// Test that we can use a value then a pointer type of a GobEncoder\n+// in the same encoded value.  Bug 4647.\n+func TestGobEncoderValueThenPointer(t *testing.T) {\n+\tv := ValueGobber(\"forty-two\")\n+\tw := ValueGobber(\"six-by-nine\")\n+\n+\t// this was a bug: encoding a GobEncoder by value before a GobEncoder\n+\t// pointer would cause duplicate type definitions to be sent.\n+\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\tif err := enc.Encode(GobTest6{42, v, &w}); err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTest6)\n+\tif err := dec.Decode(x); err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif got, want := x.V, v; got != want {\n+\t\tt.Errorf(\"v = %q, want %q\", got, want)\n+\t}\n+\tif got, want := x.W, w; got == nil {\n+\t\tt.Errorf(\"w = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"w = %q, want %q\", *got, want)\n+\t}\n+}\n+\n+// Test that we can use a pointer then a value type of a GobEncoder\n+// in the same encoded value.\n+func TestGobEncoderPointerThenValue(t *testing.T) {\n+\tv := ValueGobber(\"forty-two\")\n+\tw := ValueGobber(\"six-by-nine\")\n+\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\tif err := enc.Encode(GobTest7{42, &v, w}); err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTest7)\n+\tif err := dec.Decode(x); err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif got, want := x.V, v; got == nil {\n+\t\tt.Errorf(\"v = nil, want %q\", want)\n+\t} else if *got != want {\n+\t\tt.Errorf(\"v = %q, want %q\", got, want)\n+\t}\n+\tif got, want := x.W, w; got != want {\n+\t\tt.Errorf(\"w = %q, want %q\", got, want)\n+\t}\n+}\n+\n func TestGobEncoderFieldTypeError(t *testing.T) {\n \t// GobEncoder to non-decoder: error\n \tb := new(bytes.Buffer)"}, {"sha": "356f590f0278e546a83db2ef62bb4331ab479cf8", "filename": "libgo/go/encoding/hex/hex_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -65,7 +65,7 @@ func TestDecodeString(t *testing.T) {\n \t\t\tt.Errorf(\"#%d: unexpected err value: %s\", i, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif bytes.Compare(dst, test.dec) != 0 {\n+\t\tif !bytes.Equal(dst, test.dec) {\n \t\t\tt.Errorf(\"#%d: got: %#v want: #%v\", i, dst, test.dec)\n \t\t}\n \t}"}, {"sha": "6e6815ff13185c7ea1f40ba4173be32d56e2c4ee", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -52,6 +52,25 @@ import (\n // an UnmarshalTypeError describing the earliest such error.\n //\n func Unmarshal(data []byte, v interface{}) error {\n+\n+\t// skip heavy processing for primitive values\n+\tvar first byte\n+\tvar i int\n+\tfor i, first = range data {\n+\t\tif !isSpace(rune(first)) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif first != '{' && first != '[' {\n+\t\trv := reflect.ValueOf(v)\n+\t\tif rv.Kind() != reflect.Ptr || rv.IsNil() {\n+\t\t\treturn &InvalidUnmarshalError{reflect.TypeOf(v)}\n+\t\t}\n+\t\tvar d decodeState\n+\t\td.literalStore(data[i:], rv.Elem(), false)\n+\t\treturn d.savedError\n+\t}\n+\n \td := new(decodeState).init(data)\n \n \t// Quick check for well-formedness.\n@@ -87,6 +106,7 @@ func (e *UnmarshalTypeError) Error() string {\n \n // An UnmarshalFieldError describes a JSON object key that\n // led to an unexported (and therefore unwritable) struct field.\n+// (No longer used; kept for compatibility.)\n type UnmarshalFieldError struct {\n \tKey   string\n \tType  reflect.Type\n@@ -328,15 +348,19 @@ func (d *decodeState) array(v reflect.Value) {\n \n \t// Check type of target.\n \tswitch v.Kind() {\n+\tcase reflect.Interface:\n+\t\tif v.NumMethod() == 0 {\n+\t\t\t// Decoding into nil interface?  Switch to non-reflect code.\n+\t\t\tv.Set(reflect.ValueOf(d.arrayInterface()))\n+\t\t\treturn\n+\t\t}\n+\t\t// Otherwise it's invalid.\n+\t\tfallthrough\n \tdefault:\n \t\td.saveError(&UnmarshalTypeError{\"array\", v.Type()})\n \t\td.off--\n \t\td.next()\n \t\treturn\n-\tcase reflect.Interface:\n-\t\t// Decoding into nil interface?  Switch to non-reflect code.\n-\t\tv.Set(reflect.ValueOf(d.arrayInterface()))\n-\t\treturn\n \tcase reflect.Array:\n \tcase reflect.Slice:\n \t\tbreak\n@@ -422,29 +446,27 @@ func (d *decodeState) object(v reflect.Value) {\n \tv = pv\n \n \t// Decoding into nil interface?  Switch to non-reflect code.\n-\tif v.Kind() == reflect.Interface {\n+\tif v.Kind() == reflect.Interface && v.NumMethod() == 0 {\n \t\tv.Set(reflect.ValueOf(d.objectInterface()))\n \t\treturn\n \t}\n \n \t// Check type of target: struct or map[string]T\n \tswitch v.Kind() {\n \tcase reflect.Map:\n-\t\t// map must have string type\n+\t\t// map must have string kind\n \t\tt := v.Type()\n-\t\tif t.Key() != reflect.TypeOf(\"\") {\n+\t\tif t.Key().Kind() != reflect.String {\n \t\t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n \t\t\tbreak\n \t\t}\n \t\tif v.IsNil() {\n \t\t\tv.Set(reflect.MakeMap(t))\n \t\t}\n \tcase reflect.Struct:\n+\n \tdefault:\n \t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n-\t}\n-\n-\tif !v.IsValid() {\n \t\td.off--\n \t\td.next() // skip over { } in input\n \t\treturn\n@@ -509,15 +531,6 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\t\t\t}\n \t\t\t\t\tsubv = subv.Field(i)\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// To give a good error, a quick scan for unexported fields in top level.\n-\t\t\t\tst := v.Type()\n-\t\t\t\tfor i := 0; i < st.NumField(); i++ {\n-\t\t\t\t\tf := st.Field(i)\n-\t\t\t\t\tif f.PkgPath != \"\" && strings.EqualFold(f.Name, key) {\n-\t\t\t\t\t\td.saveError(&UnmarshalFieldError{key, st, f})\n-\t\t\t\t\t}\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -536,10 +549,12 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t} else {\n \t\t\td.value(subv)\n \t\t}\n+\n \t\t// Write value back to map;\n \t\t// if using struct, subv points into struct already.\n \t\tif v.Kind() == reflect.Map {\n-\t\t\tv.SetMapIndex(reflect.ValueOf(key), subv)\n+\t\t\tkv := reflect.ValueOf(key).Convert(v.Type().Key())\n+\t\t\tv.SetMapIndex(kv, subv)\n \t\t}\n \n \t\t// Next token must be , or }.\n@@ -625,7 +640,11 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\tcase reflect.Bool:\n \t\t\tv.SetBool(value)\n \t\tcase reflect.Interface:\n-\t\t\tv.Set(reflect.ValueOf(value))\n+\t\t\tif v.NumMethod() == 0 {\n+\t\t\t\tv.Set(reflect.ValueOf(value))\n+\t\t\t} else {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"bool\", v.Type()})\n+\t\t\t}\n \t\t}\n \n \tcase '\"': // string\n@@ -655,7 +674,11 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\tcase reflect.String:\n \t\t\tv.SetString(string(s))\n \t\tcase reflect.Interface:\n-\t\t\tv.Set(reflect.ValueOf(string(s)))\n+\t\t\tif v.NumMethod() == 0 {\n+\t\t\t\tv.Set(reflect.ValueOf(string(s)))\n+\t\t\t} else {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"string\", v.Type()})\n+\t\t\t}\n \t\t}\n \n \tdefault: // number\n@@ -684,6 +707,10 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t\t\td.saveError(err)\n \t\t\t\tbreak\n \t\t\t}\n+\t\t\tif v.NumMethod() != 0 {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"number\", v.Type()})\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\tv.Set(reflect.ValueOf(n))\n \n \t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:"}, {"sha": "97f2a41eb767db439705134f0ad5fa53c1086c3f", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -199,12 +199,19 @@ var unmarshalTests = []unmarshalTest{\n \t{in: `\"invalid: \\uD834x\\uDD1E\"`, ptr: new(string), out: \"invalid: \\uFFFDx\\uFFFD\"},\n \t{in: \"null\", ptr: new(interface{}), out: nil},\n \t{in: `{\"X\": [1,2,3], \"Y\": 4}`, ptr: new(T), out: T{Y: 4}, err: &UnmarshalTypeError{\"array\", reflect.TypeOf(\"\")}},\n-\t{in: `{\"x\": 1}`, ptr: new(tx), out: tx{}, err: &UnmarshalFieldError{\"x\", txType, txType.Field(0)}},\n+\t{in: `{\"x\": 1}`, ptr: new(tx), out: tx{}},\n \t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: float64(1), F2: int32(2), F3: Number(\"3\")}},\n \t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: Number(\"1\"), F2: int32(2), F3: Number(\"3\")}, useNumber: true},\n \t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsFloat64},\n \t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsNumber, useNumber: true},\n \n+\t// raw values with whitespace\n+\t{in: \"\\n true \", ptr: new(bool), out: true},\n+\t{in: \"\\t 1 \", ptr: new(int), out: 1},\n+\t{in: \"\\r 1.2 \", ptr: new(float64), out: 1.2},\n+\t{in: \"\\t -5 \\n\", ptr: new(int16), out: int16(-5)},\n+\t{in: \"\\t \\\"a\\\\u1234\\\" \\n\", ptr: new(string), out: \"a\\u1234\"},\n+\n \t// Z has a \"-\" tag.\n \t{in: `{\"Y\": 1, \"Z\": 2}`, ptr: new(T), out: T{Y: 1}},\n \n@@ -217,6 +224,16 @@ var unmarshalTests = []unmarshalTest{\n \t{in: `[1, 2, 3+]`, err: &SyntaxError{\"invalid character '+' after array element\", 9}},\n \t{in: `{\"X\":12x}`, err: &SyntaxError{\"invalid character 'x' after object key:value pair\", 8}, useNumber: true},\n \n+\t// raw value errors\n+\t{in: \"\\x01 42\", err: &SyntaxError{\"invalid character '\\\\x01' looking for beginning of value\", 1}},\n+\t{in: \" 42 \\x01\", err: &SyntaxError{\"invalid character '\\\\x01' after top-level value\", 5}},\n+\t{in: \"\\x01 true\", err: &SyntaxError{\"invalid character '\\\\x01' looking for beginning of value\", 1}},\n+\t{in: \" false \\x01\", err: &SyntaxError{\"invalid character '\\\\x01' after top-level value\", 8}},\n+\t{in: \"\\x01 1.2\", err: &SyntaxError{\"invalid character '\\\\x01' looking for beginning of value\", 1}},\n+\t{in: \" 3.4 \\x01\", err: &SyntaxError{\"invalid character '\\\\x01' after top-level value\", 6}},\n+\t{in: \"\\x01 \\\"string\\\"\", err: &SyntaxError{\"invalid character '\\\\x01' looking for beginning of value\", 1}},\n+\t{in: \" \\\"string\\\" \\x01\", err: &SyntaxError{\"invalid character '\\\\x01' after top-level value\", 11}},\n+\n \t// array tests\n \t{in: `[1, 2, 3]`, ptr: new([3]int), out: [3]int{1, 2, 3}},\n \t{in: `[1, 2, 3]`, ptr: new([1]int), out: [1]int{1}},\n@@ -422,7 +439,7 @@ func TestUnmarshalMarshal(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Marshal: %v\", err)\n \t}\n-\tif bytes.Compare(jsonBig, b) != 0 {\n+\tif !bytes.Equal(jsonBig, b) {\n \t\tt.Errorf(\"Marshal jsonBig\")\n \t\tdiff(t, b, jsonBig)\n \t\treturn\n@@ -474,7 +491,7 @@ func TestLargeByteSlice(t *testing.T) {\n \tif err := Unmarshal(b, &s1); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %v\", err)\n \t}\n-\tif bytes.Compare(s0, s1) != 0 {\n+\tif !bytes.Equal(s0, s1) {\n \t\tt.Errorf(\"Marshal large byte slice\")\n \t\tdiff(t, s0, s1)\n \t}\n@@ -1000,3 +1017,72 @@ func TestUnmarshalNulls(t *testing.T) {\n \t\tt.Errorf(\"Unmarshal of null values affected primitives\")\n \t}\n }\n+\n+func TestStringKind(t *testing.T) {\n+\ttype stringKind string\n+\ttype aMap map[stringKind]int\n+\n+\tvar m1, m2 map[stringKind]int\n+\tm1 = map[stringKind]int{\n+\t\t\"foo\": 42,\n+\t}\n+\n+\tdata, err := Marshal(m1)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unexpected error marshalling: %v\", err)\n+\t}\n+\n+\terr = Unmarshal(data, &m2)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unexpected error unmarshalling: %v\", err)\n+\t}\n+\n+\tif !reflect.DeepEqual(m1, m2) {\n+\t\tt.Error(\"Items should be equal after encoding and then decoding\")\n+\t}\n+\n+}\n+\n+var decodeTypeErrorTests = []struct {\n+\tdest interface{}\n+\tsrc  string\n+}{\n+\t{new(string), `{\"user\": \"name\"}`}, // issue 4628.\n+\t{new(error), `{}`},                // issue 4222\n+\t{new(error), `[]`},\n+\t{new(error), `\"\"`},\n+\t{new(error), `123`},\n+\t{new(error), `true`},\n+}\n+\n+func TestUnmarshalTypeError(t *testing.T) {\n+\tfor _, item := range decodeTypeErrorTests {\n+\t\terr := Unmarshal([]byte(item.src), item.dest)\n+\t\tif _, ok := err.(*UnmarshalTypeError); !ok {\n+\t\t\tt.Errorf(\"expected type error for Unmarshal(%q, type %T): got %v instead\",\n+\t\t\t\titem.src, item.dest, err)\n+\t\t}\n+\t}\n+}\n+\n+// Test handling of unexported fields that should be ignored.\n+// Issue 4660\n+type unexportedFields struct {\n+\tName string\n+\tm    map[string]interface{} `json:\"-\"`\n+\tm2   map[string]interface{} `json:\"abcd\"`\n+}\n+\n+func TestUnmarshalUnexported(t *testing.T) {\n+\tinput := `{\"Name\": \"Bob\", \"m\": {\"x\": 123}, \"m2\": {\"y\": 456}, \"abcd\": {\"z\": 789}}`\n+\twant := &unexportedFields{Name: \"Bob\"}\n+\n+\tout := &unexportedFields{}\n+\terr := Unmarshal([]byte(input), out)\n+\tif err != nil {\n+\t\tt.Errorf(\"got error %v, expected nil\", err)\n+\t}\n+\tif !reflect.DeepEqual(out, want) {\n+\t\tt.Errorf(\"got %q, want %q\", out, want)\n+\t}\n+}"}, {"sha": "fb57f1d51b2ccf155d736d44cd6e0caa14e6c936", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -75,8 +75,9 @@ import (\n //   Field int `json:\",omitempty\"`\n //\n // The \"string\" option signals that a field is stored as JSON inside a\n-// JSON-encoded string.  This extra level of encoding is sometimes\n-// used when communicating with JavaScript programs:\n+// JSON-encoded string. It applies only to fields of string, floating point,\n+// or integer types. This extra level of encoding is sometimes used when\n+// communicating with JavaScript programs:\n //\n //    Int64String int64 `json:\",string\"`\n //\n@@ -437,7 +438,7 @@ func isValidTag(s string) bool {\n \t}\n \tfor _, c := range s {\n \t\tswitch {\n-\t\tcase strings.ContainsRune(\"!#$%&()*+-./:<=>?@[]^_{|}~\", c):\n+\t\tcase strings.ContainsRune(\"!#$%&()*+-./:<=>?@[]^_{|}~ \", c):\n \t\t\t// Backslash and quote chars are reserved, but\n \t\t\t// otherwise any punctuation chars are allowed\n \t\t\t// in a tag name.\n@@ -617,13 +618,20 @@ func typeFields(t reflect.Type) []field {\n \t\t\t\tindex := make([]int, len(f.index)+1)\n \t\t\t\tcopy(index, f.index)\n \t\t\t\tindex[len(f.index)] = i\n+\n+\t\t\t\tft := sf.Type\n+\t\t\t\tif ft.Name() == \"\" && ft.Kind() == reflect.Ptr {\n+\t\t\t\t\t// Follow pointer.\n+\t\t\t\t\tft = ft.Elem()\n+\t\t\t\t}\n+\n \t\t\t\t// Record found field and index sequence.\n-\t\t\t\tif name != \"\" || !sf.Anonymous {\n+\t\t\t\tif name != \"\" || !sf.Anonymous || ft.Kind() != reflect.Struct {\n \t\t\t\t\ttagged := name != \"\"\n \t\t\t\t\tif name == \"\" {\n \t\t\t\t\t\tname = sf.Name\n \t\t\t\t\t}\n-\t\t\t\t\tfields = append(fields, field{name, tagged, index, sf.Type,\n+\t\t\t\t\tfields = append(fields, field{name, tagged, index, ft,\n \t\t\t\t\t\topts.Contains(\"omitempty\"), opts.Contains(\"string\")})\n \t\t\t\t\tif count[f.typ] > 1 {\n \t\t\t\t\t\t// If there were multiple instances, add a second,\n@@ -636,11 +644,6 @@ func typeFields(t reflect.Type) []field {\n \t\t\t\t}\n \n \t\t\t\t// Record new anonymous struct to explore in next round.\n-\t\t\t\tft := sf.Type\n-\t\t\t\tif ft.Name() == \"\" {\n-\t\t\t\t\t// Must be pointer.\n-\t\t\t\t\tft = ft.Elem()\n-\t\t\t\t}\n \t\t\t\tnextCount[ft]++\n \t\t\t\tif nextCount[ft] == 1 {\n \t\t\t\t\tnext = append(next, field{name: ft.Name(), index: index, typ: ft})"}, {"sha": "be74c997cf82dda7f905e5606290b600d62aa905", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -186,3 +186,23 @@ func TestMarshalerEscaping(t *testing.T) {\n \t\tt.Errorf(\"got %q, want %q\", got, want)\n \t}\n }\n+\n+type IntType int\n+\n+type MyStruct struct {\n+\tIntType\n+}\n+\n+func TestAnonymousNonstruct(t *testing.T) {\n+\tvar i IntType = 11\n+\ta := MyStruct{i}\n+\tconst want = `{\"IntType\":11}`\n+\n+\tb, err := Marshal(a)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\tif got := string(b); got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+}"}, {"sha": "adb35715b9670ec65ea69261f06315204a1c1d8b", "filename": "libgo/go/encoding/json/scanner_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -92,7 +92,7 @@ func TestCompactBig(t *testing.T) {\n \t\tt.Fatalf(\"Compact: %v\", err)\n \t}\n \tb := buf.Bytes()\n-\tif bytes.Compare(b, jsonBig) != 0 {\n+\tif !bytes.Equal(b, jsonBig) {\n \t\tt.Error(\"Compact(jsonBig) != jsonBig\")\n \t\tdiff(t, b, jsonBig)\n \t\treturn\n@@ -118,7 +118,7 @@ func TestIndentBig(t *testing.T) {\n \t\tt.Fatalf(\"Indent2: %v\", err)\n \t}\n \tb1 := buf1.Bytes()\n-\tif bytes.Compare(b1, b) != 0 {\n+\tif !bytes.Equal(b1, b) {\n \t\tt.Error(\"Indent(Indent(jsonBig)) != Indent(jsonBig)\")\n \t\tdiff(t, b1, b)\n \t\treturn\n@@ -130,7 +130,7 @@ func TestIndentBig(t *testing.T) {\n \t\tt.Fatalf(\"Compact: %v\", err)\n \t}\n \tb1 = buf1.Bytes()\n-\tif bytes.Compare(b1, jsonBig) != 0 {\n+\tif !bytes.Equal(b1, jsonBig) {\n \t\tt.Error(\"Compact(Indent(jsonBig)) != jsonBig\")\n \t\tdiff(t, b1, jsonBig)\n \t\treturn"}, {"sha": "23e71c7525a5c3b6dfef9536d4ccd880340a3270", "filename": "libgo/go/encoding/json/tagkey_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -60,6 +60,14 @@ type badCodeTag struct {\n \tZ string `json:\" !\\\"#&'()*+,.\"`\n }\n \n+type spaceTag struct {\n+\tQ string `json:\"With space\"`\n+}\n+\n+type unicodeTag struct {\n+\tW string `json:\"\u0395\u03bb\u03bb\u03ac\u03b4\u03b1\"`\n+}\n+\n var structTagObjectKeyTests = []struct {\n \traw   interface{}\n \tvalue string\n@@ -78,6 +86,8 @@ var structTagObjectKeyTests = []struct {\n \t{badCodeTag{\"Reliable Man\"}, \"Reliable Man\", \"Z\"},\n \t{percentSlashTag{\"brut\"}, \"brut\", \"text/html%\"},\n \t{punctuationTag{\"Union Rags\"}, \"Union Rags\", \"!#$%&()*+-./:<=>?@[]^_{|}~\"},\n+\t{spaceTag{\"Perreddu\"}, \"Perreddu\", \"With space\"},\n+\t{unicodeTag{\"Loukanikos\"}, \"Loukanikos\", \"\u0395\u03bb\u03bb\u03ac\u03b4\u03b1\"},\n }\n \n func TestStructTagObjectKey(t *testing.T) {"}, {"sha": "aacb50c9cfcb3eefb3c38c7f13378b86e3bb9661", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -241,7 +241,7 @@ func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\tp.WriteString(strconv.FormatUint(val.Uint(), 10))\n \tcase reflect.Float32, reflect.Float64:\n-\t\tp.WriteString(strconv.FormatFloat(val.Float(), 'g', -1, 64))\n+\t\tp.WriteString(strconv.FormatFloat(val.Float(), 'g', -1, val.Type().Bits()))\n \tcase reflect.String:\n \t\t// TODO: Add EscapeString.\n \t\tEscape(p, []byte(val.String()))\n@@ -273,19 +273,32 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \ts := parentStack{printer: p}\n \tfor i := range tinfo.fields {\n \t\tfinfo := &tinfo.fields[i]\n-\t\tif finfo.flags&(fAttr|fAny) != 0 {\n+\t\tif finfo.flags&(fAttr) != 0 {\n \t\t\tcontinue\n \t\t}\n \t\tvf := finfo.value(val)\n \t\tswitch finfo.flags & fMode {\n \t\tcase fCharData:\n+\t\t\tvar scratch [64]byte\n \t\t\tswitch vf.Kind() {\n+\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\t\t\tEscape(p, strconv.AppendInt(scratch[:0], vf.Int(), 10))\n+\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\t\t\tEscape(p, strconv.AppendUint(scratch[:0], vf.Uint(), 10))\n+\t\t\tcase reflect.Float32, reflect.Float64:\n+\t\t\t\tEscape(p, strconv.AppendFloat(scratch[:0], vf.Float(), 'g', -1, vf.Type().Bits()))\n+\t\t\tcase reflect.Bool:\n+\t\t\t\tEscape(p, strconv.AppendBool(scratch[:0], vf.Bool()))\n \t\t\tcase reflect.String:\n \t\t\t\tEscape(p, []byte(vf.String()))\n \t\t\tcase reflect.Slice:\n \t\t\t\tif elem, ok := vf.Interface().([]byte); ok {\n \t\t\t\t\tEscape(p, elem)\n \t\t\t\t}\n+\t\t\tcase reflect.Struct:\n+\t\t\t\tif vf.Type() == timeType {\n+\t\t\t\t\tEscape(p, []byte(vf.Interface().(time.Time).Format(time.RFC3339Nano)))\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcontinue\n \n@@ -340,7 +353,7 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\tcase fElement:\n+\t\tcase fElement, fElement | fAny:\n \t\t\ts.trim(finfo.parents)\n \t\t\tif len(finfo.parents) > len(s.stack) {\n \t\t\t\tif vf.Kind() != reflect.Ptr && vf.Kind() != reflect.Interface || !vf.IsNil() {"}, {"sha": "67fcfd9ed565b6534247ae191565045bc2fb7473", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -59,6 +59,36 @@ type Book struct {\n \tTitle   string   `xml:\",chardata\"`\n }\n \n+type Event struct {\n+\tXMLName struct{} `xml:\"event\"`\n+\tYear    int      `xml:\",chardata\"`\n+}\n+\n+type Movie struct {\n+\tXMLName struct{} `xml:\"movie\"`\n+\tLength  uint     `xml:\",chardata\"`\n+}\n+\n+type Pi struct {\n+\tXMLName       struct{} `xml:\"pi\"`\n+\tApproximation float32  `xml:\",chardata\"`\n+}\n+\n+type Universe struct {\n+\tXMLName struct{} `xml:\"universe\"`\n+\tVisible float64  `xml:\",chardata\"`\n+}\n+\n+type Particle struct {\n+\tXMLName struct{} `xml:\"particle\"`\n+\tHasMass bool     `xml:\",chardata\"`\n+}\n+\n+type Departure struct {\n+\tXMLName struct{}  `xml:\"departure\"`\n+\tWhen    time.Time `xml:\",chardata\"`\n+}\n+\n type SecretAgent struct {\n \tXMLName   struct{} `xml:\"agent\"`\n \tHandle    string   `xml:\"handle,attr\"`\n@@ -188,6 +218,18 @@ type AnyTest struct {\n \tAnyField AnyHolder `xml:\",any\"`\n }\n \n+type AnyOmitTest struct {\n+\tXMLName  struct{}   `xml:\"a\"`\n+\tNested   string     `xml:\"nested>value\"`\n+\tAnyField *AnyHolder `xml:\",any,omitempty\"`\n+}\n+\n+type AnySliceTest struct {\n+\tXMLName  struct{}    `xml:\"a\"`\n+\tNested   string      `xml:\"nested>value\"`\n+\tAnyField []AnyHolder `xml:\",any\"`\n+}\n+\n type AnyHolder struct {\n \tXMLName Name\n \tXML     string `xml:\",innerxml\"`\n@@ -333,6 +375,12 @@ var marshalTests = []struct {\n \t{Value: &Domain{Name: []byte(\"google.com&friends\")}, ExpectXML: `<domain>google.com&amp;friends</domain>`},\n \t{Value: &Domain{Name: []byte(\"google.com\"), Comment: []byte(\" &friends \")}, ExpectXML: `<domain>google.com<!-- &friends --></domain>`},\n \t{Value: &Book{Title: \"Pride & Prejudice\"}, ExpectXML: `<book>Pride &amp; Prejudice</book>`},\n+\t{Value: &Event{Year: -3114}, ExpectXML: `<event>-3114</event>`},\n+\t{Value: &Movie{Length: 13440}, ExpectXML: `<movie>13440</movie>`},\n+\t{Value: &Pi{Approximation: 3.14159265}, ExpectXML: `<pi>3.1415927</pi>`},\n+\t{Value: &Universe{Visible: 9.3e13}, ExpectXML: `<universe>9.3e+13</universe>`},\n+\t{Value: &Particle{HasMass: true}, ExpectXML: `<particle>true</particle>`},\n+\t{Value: &Departure{When: ParseTime(\"2013-01-09T00:15:00-09:00\")}, ExpectXML: `<departure>2013-01-09T00:15:00-09:00</departure>`},\n \t{Value: atomValue, ExpectXML: atomXml},\n \t{\n \t\tValue: &Ship{\n@@ -652,12 +700,43 @@ var marshalTests = []struct {\n \t\t\t\tXML:     \"<sub>unknown</sub>\",\n \t\t\t},\n \t\t},\n-\t\tUnmarshalOnly: true,\n \t},\n \t{\n-\t\tValue:       &AnyTest{Nested: \"known\", AnyField: AnyHolder{XML: \"<unknown/>\"}},\n-\t\tExpectXML:   `<a><nested><value>known</value></nested></a>`,\n-\t\tMarshalOnly: true,\n+\t\tValue: &AnyTest{Nested: \"known\",\n+\t\t\tAnyField: AnyHolder{\n+\t\t\t\tXML:     \"<unknown/>\",\n+\t\t\t\tXMLName: Name{Local: \"AnyField\"},\n+\t\t\t},\n+\t\t},\n+\t\tExpectXML: `<a><nested><value>known</value></nested><AnyField><unknown/></AnyField></a>`,\n+\t},\n+\t{\n+\t\tExpectXML: `<a><nested><value>b</value></nested></a>`,\n+\t\tValue: &AnyOmitTest{\n+\t\t\tNested: \"b\",\n+\t\t},\n+\t},\n+\t{\n+\t\tExpectXML: `<a><nested><value>b</value></nested><c><d>e</d></c><g xmlns=\"f\"><h>i</h></g></a>`,\n+\t\tValue: &AnySliceTest{\n+\t\t\tNested: \"b\",\n+\t\t\tAnyField: []AnyHolder{\n+\t\t\t\t{\n+\t\t\t\t\tXMLName: Name{Local: \"c\"},\n+\t\t\t\t\tXML:     \"<d>e</d>\",\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tXMLName: Name{Space: \"f\", Local: \"g\"},\n+\t\t\t\t\tXML:     \"<h>i</h>\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tExpectXML: `<a><nested><value>b</value></nested></a>`,\n+\t\tValue: &AnySliceTest{\n+\t\t\tNested: \"b\",\n+\t\t},\n \t},\n \n \t// Test recursive types.\n@@ -690,15 +769,17 @@ var marshalTests = []struct {\n \n \t// Test escaping.\n \t{\n-\t\tExpectXML: `<a><nested><value>dquote: &#34;; squote: &#39;; ampersand: &amp;; less: &lt;; greater: &gt;;</value></nested></a>`,\n+\t\tExpectXML: `<a><nested><value>dquote: &#34;; squote: &#39;; ampersand: &amp;; less: &lt;; greater: &gt;;</value></nested><empty></empty></a>`,\n \t\tValue: &AnyTest{\n-\t\t\tNested: `dquote: \"; squote: '; ampersand: &; less: <; greater: >;`,\n+\t\t\tNested:   `dquote: \"; squote: '; ampersand: &; less: <; greater: >;`,\n+\t\t\tAnyField: AnyHolder{XMLName: Name{Local: \"empty\"}},\n \t\t},\n \t},\n \t{\n-\t\tExpectXML: `<a><nested><value>newline: &#xA;; cr: &#xD;; tab: &#x9;;</value></nested></a>`,\n+\t\tExpectXML: `<a><nested><value>newline: &#xA;; cr: &#xD;; tab: &#x9;;</value></nested><AnyField></AnyField></a>`,\n \t\tValue: &AnyTest{\n-\t\t\tNested: \"newline: \\n; cr: \\r; tab: \\t;\",\n+\t\t\tNested:   \"newline: \\n; cr: \\r; tab: \\t;\",\n+\t\t\tAnyField: AnyHolder{XMLName: Name{Local: \"AnyField\"}},\n \t\t},\n \t},\n \t{"}, {"sha": "344ab514e378bee139b29ba3f90fbc9cfac0bb40", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -279,7 +279,7 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\t\t\tsaveComment = finfo.value(sv)\n \t\t\t\t}\n \n-\t\t\tcase fAny:\n+\t\t\tcase fAny, fAny | fElement:\n \t\t\t\tif !saveAny.IsValid() {\n \t\t\t\t\tsaveAny = finfo.value(sv)\n \t\t\t\t}\n@@ -374,68 +374,58 @@ Loop:\n }\n \n func copyValue(dst reflect.Value, src []byte) (err error) {\n-\t// Helper functions for integer and unsigned integer conversions\n-\tvar itmp int64\n-\tgetInt64 := func() bool {\n-\t\titmp, err = strconv.ParseInt(string(src), 10, 64)\n-\t\t// TODO: should check sizes\n-\t\treturn err == nil\n-\t}\n-\tvar utmp uint64\n-\tgetUint64 := func() bool {\n-\t\tutmp, err = strconv.ParseUint(string(src), 10, 64)\n-\t\t// TODO: check for overflow?\n-\t\treturn err == nil\n-\t}\n-\tvar ftmp float64\n-\tgetFloat64 := func() bool {\n-\t\tftmp, err = strconv.ParseFloat(string(src), 64)\n-\t\t// TODO: check for overflow?\n-\t\treturn err == nil\n+\tif dst.Kind() == reflect.Ptr {\n+\t\tif dst.IsNil() {\n+\t\t\tdst.Set(reflect.New(dst.Type().Elem()))\n+\t\t}\n+\t\tdst = dst.Elem()\n \t}\n \n \t// Save accumulated data.\n-\tswitch t := dst; t.Kind() {\n+\tswitch dst.Kind() {\n \tcase reflect.Invalid:\n-\t\t// Probably a comment.\n+\t\t// Probably a commendst.\n \tdefault:\n-\t\treturn errors.New(\"cannot happen: unknown type \" + t.Type().String())\n+\t\treturn errors.New(\"cannot happen: unknown type \" + dst.Type().String())\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tif !getInt64() {\n+\t\titmp, err := strconv.ParseInt(string(src), 10, dst.Type().Bits())\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tt.SetInt(itmp)\n+\t\tdst.SetInt(itmp)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tif !getUint64() {\n+\t\tutmp, err := strconv.ParseUint(string(src), 10, dst.Type().Bits())\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tt.SetUint(utmp)\n+\t\tdst.SetUint(utmp)\n \tcase reflect.Float32, reflect.Float64:\n-\t\tif !getFloat64() {\n+\t\tftmp, err := strconv.ParseFloat(string(src), dst.Type().Bits())\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tt.SetFloat(ftmp)\n+\t\tdst.SetFloat(ftmp)\n \tcase reflect.Bool:\n \t\tvalue, err := strconv.ParseBool(strings.TrimSpace(string(src)))\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tt.SetBool(value)\n+\t\tdst.SetBool(value)\n \tcase reflect.String:\n-\t\tt.SetString(string(src))\n+\t\tdst.SetString(string(src))\n \tcase reflect.Slice:\n \t\tif len(src) == 0 {\n \t\t\t// non-nil to flag presence\n \t\t\tsrc = []byte{}\n \t\t}\n-\t\tt.SetBytes(src)\n+\t\tdst.SetBytes(src)\n \tcase reflect.Struct:\n-\t\tif t.Type() == timeType {\n+\t\tif dst.Type() == timeType {\n \t\t\ttv, err := time.Parse(time.RFC3339, string(src))\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tt.Set(reflect.ValueOf(tv))\n+\t\t\tdst.Set(reflect.ValueOf(tv))\n \t\t}\n \t}\n \treturn nil"}, {"sha": "b45e2f0e61e3c87f8dc01c8a500ab6b786c8e7b5", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -355,3 +355,47 @@ func TestUnmarshalWithoutNameType(t *testing.T) {\n \t\tt.Fatalf(\"have %v\\nwant %v\", x.Attr, OK)\n \t}\n }\n+\n+func TestUnmarshalAttr(t *testing.T) {\n+\ttype ParamVal struct {\n+\t\tInt int `xml:\"int,attr\"`\n+\t}\n+\n+\ttype ParamPtr struct {\n+\t\tInt *int `xml:\"int,attr\"`\n+\t}\n+\n+\ttype ParamStringPtr struct {\n+\t\tInt *string `xml:\"int,attr\"`\n+\t}\n+\n+\tx := []byte(`<Param int=\"1\" />`)\n+\n+\tp1 := &ParamPtr{}\n+\tif err := Unmarshal(x, p1); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %s\", err)\n+\t}\n+\tif p1.Int == nil {\n+\t\tt.Fatalf(\"Unmarshal failed in to *int field\")\n+\t} else if *p1.Int != 1 {\n+\t\tt.Fatalf(\"Unmarshal with %s failed:\\nhave %#v,\\n want %#v\", x, p1.Int, 1)\n+\t}\n+\n+\tp2 := &ParamVal{}\n+\tif err := Unmarshal(x, p2); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %s\", err)\n+\t}\n+\tif p2.Int != 1 {\n+\t\tt.Fatalf(\"Unmarshal with %s failed:\\nhave %#v,\\n want %#v\", x, p2.Int, 1)\n+\t}\n+\n+\tp3 := &ParamStringPtr{}\n+\tif err := Unmarshal(x, p3); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %s\", err)\n+\t}\n+\tif p3.Int == nil {\n+\t\tt.Fatalf(\"Unmarshal failed in to *string field\")\n+\t} else if *p3.Int != \"1\" {\n+\t\tt.Fatalf(\"Unmarshal with %s failed:\\nhave %#v,\\n want %#v\", x, p3.Int, 1)\n+\t}\n+}"}, {"sha": "bbeb28d87eaa35239687fa8a170332606614b519", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -154,6 +154,9 @@ func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, erro\n \t\t\t// This will also catch multiple modes in a single field.\n \t\t\tvalid = false\n \t\t}\n+\t\tif finfo.flags&fMode == fAny {\n+\t\t\tfinfo.flags |= fElement\n+\t\t}\n \t\tif finfo.flags&fOmitEmpty != 0 && finfo.flags&(fElement|fAttr) == 0 {\n \t\t\tvalid = false\n \t\t}"}, {"sha": "bb3237c37cb63252a0d1a4704cb9c74a932df52d", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -5,14 +5,13 @@\n package main\n \n import (\n-\t\"errors\"\n-\t\"exp/types\"\n \t\"flag\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"go/types\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -92,34 +91,28 @@ func parse(fset *token.FileSet, filename string, src []byte) *ast.File {\n \treturn file\n }\n \n-func parseStdin(fset *token.FileSet) (files map[string]*ast.File) {\n-\tfiles = make(map[string]*ast.File)\n+func parseStdin(fset *token.FileSet) (files []*ast.File) {\n \tsrc, err := ioutil.ReadAll(os.Stdin)\n \tif err != nil {\n \t\treport(err)\n \t\treturn\n \t}\n \tconst filename = \"<standard input>\"\n \tif file := parse(fset, filename, src); file != nil {\n-\t\tfiles[filename] = file\n+\t\tfiles = []*ast.File{file}\n \t}\n \treturn\n }\n \n-func parseFiles(fset *token.FileSet, filenames []string) (files map[string]*ast.File) {\n-\tfiles = make(map[string]*ast.File)\n+func parseFiles(fset *token.FileSet, filenames []string) (files []*ast.File) {\n \tfor _, filename := range filenames {\n \t\tsrc, err := ioutil.ReadFile(filename)\n \t\tif err != nil {\n \t\t\treport(err)\n \t\t\tcontinue\n \t\t}\n \t\tif file := parse(fset, filename, src); file != nil {\n-\t\t\tif files[filename] != nil {\n-\t\t\t\treport(errors.New(fmt.Sprintf(\"%q: duplicate file\", filename)))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfiles[filename] = file\n+\t\t\tfiles = append(files, file)\n \t\t}\n \t}\n \treturn\n@@ -169,15 +162,10 @@ func processFiles(filenames []string, allFiles bool) {\n \tprocessPackage(fset, parseFiles(fset, filenames[0:i]))\n }\n \n-func processPackage(fset *token.FileSet, files map[string]*ast.File) {\n-\t// make a package (resolve all identifiers)\n-\tpkg, err := ast.NewPackage(fset, files, types.GcImport, types.Universe)\n+func processPackage(fset *token.FileSet, files []*ast.File) {\n+\t_, err := types.Check(fset, files)\n \tif err != nil {\n \t\treport(err)\n-\t\treturn\n-\t}\n-\tif err = types.Check(fset, pkg, nil, nil); err != nil {\n-\t\treport(err)\n \t}\n }\n "}, {"sha": "67ab7cfa74a51dceb5d9095704d92cd5c195f208", "filename": "libgo/go/exp/gotype/gotype_test.go", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -51,17 +51,20 @@ var tests = []string{\n \t\"exp/gotype/testdata/test1.go\",\n \n \t// directories\n-\t// Note: packages that don't typecheck yet are commented out\n+\t// Note: Packages that don't typecheck yet are commented out.\n+\t// Unless there is a comment next to the commented out packages,\n+\t// the package doesn't typecheck due to errors in the shift\n+\t// expression checker.\n \t\"archive/tar\",\n \t\"archive/zip\",\n \n \t\"bufio\",\n \t\"bytes\",\n \n-\t\"compress/bzip2\",\n+\t// \"compress/bzip2\",\n \t\"compress/flate\",\n \t\"compress/gzip\",\n-\t\"compress/lzw\",\n+\t// \"compress/lzw\",\n \t\"compress/zlib\",\n \n \t\"container/heap\",\n@@ -77,7 +80,7 @@ var tests = []string{\n \t\"crypto/elliptic\",\n \t\"crypto/hmac\",\n \t\"crypto/md5\",\n-\t\"crypto/rand\",\n+\t// \"crypto/rand\",\n \t\"crypto/rc4\",\n \t// \"crypto/rsa\", // intermittent failure: /home/gri/go2/src/pkg/crypto/rsa/pkcs1v15.go:21:27: undeclared name: io\n \t\"crypto/sha1\",\n@@ -91,14 +94,14 @@ var tests = []string{\n \t\"database/sql\",\n \t\"database/sql/driver\",\n \n-\t\"debug/dwarf\",\n+\t// \"debug/dwarf\",\n \t\"debug/elf\",\n \t\"debug/gosym\",\n \t\"debug/macho\",\n \t\"debug/pe\",\n \n \t\"encoding/ascii85\",\n-\t\"encoding/asn1\",\n+\t// \"encoding/asn1\",\n \t\"encoding/base32\",\n \t\"encoding/base64\",\n \t\"encoding/binary\",\n@@ -114,7 +117,6 @@ var tests = []string{\n \t\"flag\",\n \t\"fmt\",\n \n-\t\"exp/types\",\n \t\"exp/gotype\",\n \n \t\"go/ast\",\n@@ -124,7 +126,8 @@ var tests = []string{\n \t\"go/parser\",\n \t\"go/printer\",\n \t\"go/scanner\",\n-\t\"go/token\",\n+\t// \"go/token\",\n+\t\"go/types\",\n \n \t\"hash/adler32\",\n \t\"hash/crc32\",\n@@ -135,7 +138,7 @@ var tests = []string{\n \t\"image/color\",\n \t\"image/draw\",\n \t\"image/gif\",\n-\t\"image/jpeg\",\n+\t// \"image/jpeg\",\n \t\"image/png\",\n \n \t\"index/suffixarray\",\n@@ -146,15 +149,15 @@ var tests = []string{\n \t\"log\",\n \t\"log/syslog\",\n \n-\t\"math\",\n-\t\"math/big\",\n+\t// \"math\",\n+\t//\"math/big\",\n \t\"math/cmplx\",\n \t\"math/rand\",\n \n \t\"mime\",\n \t\"mime/multipart\",\n \n-\t// \"net\", // c:\\go\\root\\src\\pkg\\net\\interface_windows.go:54:13: invalid operation: division by zero\n+\t// \"net\",\n \t\"net/http\",\n \t\"net/http/cgi\",\n \t\"net/http/fcgi\",\n@@ -165,41 +168,41 @@ var tests = []string{\n \t\"net/rpc\",\n \t\"net/rpc/jsonrpc\",\n \t\"net/smtp\",\n-\t\"net/textproto\",\n+\t// \"net/textproto\",\n \t\"net/url\",\n \n \t\"path\",\n \t\"path/filepath\",\n \n-\t// \"reflect\", // unsafe.Sizeof must return size > 0 for pointer types\n+\t\"reflect\",\n \n \t\"regexp\",\n \t\"regexp/syntax\",\n \n-\t\"runtime\",\n+\t// \"runtime\",\n \t\"runtime/cgo\",\n \t\"runtime/debug\",\n \t\"runtime/pprof\",\n \n \t\"sort\",\n-\t// \"strconv\", // bug in switch case duplicate detection\n+\t// \"strconv\",\n \t\"strings\",\n \n \t\"sync\",\n \t\"sync/atomic\",\n \n-\t// \"syscall\", c:\\go\\root\\src\\pkg\\syscall\\syscall_windows.go:35:16: cannot convert EINVAL (constant 536870951) to error\n+\t// \"syscall\",\n \n \t\"testing\",\n \t\"testing/iotest\",\n \t\"testing/quick\",\n \n-\t\"text/scanner\",\n+\t// \"text/scanner\",\n \t\"text/tabwriter\",\n \t\"text/template\",\n \t\"text/template/parse\",\n \n-\t// \"time\", // local const decls without initialization expressions\n+\t\"time\",\n \t\"unicode\",\n \t\"unicode/utf16\",\n \t\"unicode/utf8\","}, {"sha": "fac0f54e78adcdd7e74e4ab983ff6d6425c4dcea", "filename": "libgo/go/exp/html/doc.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -4,7 +4,6 @@\n \n /*\n Package html implements an HTML5-compliant tokenizer and parser.\n-INCOMPLETE.\n \n Tokenization is done by creating a Tokenizer for an io.Reader r. It is the\n caller's responsibility to ensure that r provides UTF-8 encoded HTML."}, {"sha": "4896dfb7a0f558695d6954087997978bb77ceeba", "filename": "libgo/go/exp/html/parse_test.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -382,15 +382,9 @@ func BenchmarkParser(b *testing.B) {\n \t}\n \tb.SetBytes(int64(len(buf)))\n \truntime.GC()\n-\tvar ms runtime.MemStats\n-\truntime.ReadMemStats(&ms)\n-\tmallocs := ms.Mallocs\n+\tb.ReportAllocs()\n \tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tParse(bytes.NewBuffer(buf))\n \t}\n-\tb.StopTimer()\n-\truntime.ReadMemStats(&ms)\n-\tmallocs = ms.Mallocs - mallocs\n-\tb.Logf(\"%d iterations, %d mallocs per iteration\\n\", b.N, int(mallocs)/b.N)\n }"}, {"sha": "d34564f49dd1e65a0a38f0bc3718c586e6ec6c9b", "filename": "libgo/go/exp/html/render.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -14,7 +14,7 @@ import (\n \n type writer interface {\n \tio.Writer\n-\tWriteByte(byte) error\n+\tio.ByteWriter\n \tWriteString(string) (int, error)\n }\n "}, {"sha": "14e23467f49e9b152fe74bc6941cb1caedd0c478", "filename": "libgo/go/exp/html/token_test.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -634,9 +634,7 @@ func benchmarkTokenizer(b *testing.B, level int) {\n \t}\n \tb.SetBytes(int64(len(buf)))\n \truntime.GC()\n-\tvar ms runtime.MemStats\n-\truntime.ReadMemStats(&ms)\n-\tmallocs := ms.Mallocs\n+\tb.ReportAllocs()\n \tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tz := NewTokenizer(bytes.NewBuffer(buf))\n@@ -674,10 +672,6 @@ func benchmarkTokenizer(b *testing.B, level int) {\n \t\t\t}\n \t\t}\n \t}\n-\tb.StopTimer()\n-\truntime.ReadMemStats(&ms)\n-\tmallocs = ms.Mallocs - mallocs\n-\tb.Logf(\"%d iterations, %d mallocs per iteration\\n\", b.N, int(mallocs)/b.N)\n }\n \n func BenchmarkRawLevelTokenizer(b *testing.B)  { benchmarkTokenizer(b, rawLevel) }"}, {"sha": "4c28bd6b8672d5b47e02f5f678131eb21e1ac82c", "filename": "libgo/go/exp/locale/collate/build/builder.go", "status": "modified", "additions": 112, "deletions": 47, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -98,60 +98,86 @@ func (b *Builder) Tailoring(locale string) *Tailoring {\n // a value for each colelem that is a variable. (See the reference above.)\n func (b *Builder) Add(runes []rune, colelems [][]int, variables []int) error {\n \tstr := string(runes)\n-\telems := make([][]int, len(colelems))\n+\telems := make([]rawCE, len(colelems))\n \tfor i, ce := range colelems {\n-\t\telems[i] = append(elems[i], ce...)\n \t\tif len(ce) == 0 {\n-\t\t\telems[i] = append(elems[i], []int{0, 0, 0, 0}...)\n \t\t\tbreak\n \t\t}\n+\t\telems[i] = makeRawCE(ce, 0)\n \t\tif len(ce) == 1 {\n-\t\t\telems[i] = append(elems[i], defaultSecondary)\n+\t\t\telems[i].w[1] = defaultSecondary\n \t\t}\n \t\tif len(ce) <= 2 {\n-\t\t\telems[i] = append(elems[i], defaultTertiary)\n+\t\t\telems[i].w[2] = defaultTertiary\n \t\t}\n \t\tif len(ce) <= 3 {\n-\t\t\telems[i] = append(elems[i], ce[0])\n+\t\t\telems[i].w[3] = ce[0]\n \t\t}\n \t}\n \tfor i, ce := range elems {\n+\t\tp := ce.w[0]\n \t\tisvar := false\n \t\tfor _, j := range variables {\n \t\t\tif i == j {\n \t\t\t\tisvar = true\n \t\t\t}\n \t\t}\n \t\tif isvar {\n-\t\t\tif ce[0] >= b.minNonVar && b.minNonVar > 0 {\n-\t\t\t\treturn fmt.Errorf(\"primary value %X of variable is larger than the smallest non-variable %X\", ce[0], b.minNonVar)\n+\t\t\tif p >= b.minNonVar && b.minNonVar > 0 {\n+\t\t\t\treturn fmt.Errorf(\"primary value %X of variable is larger than the smallest non-variable %X\", p, b.minNonVar)\n \t\t\t}\n-\t\t\tif ce[0] > b.varTop {\n-\t\t\t\tb.varTop = ce[0]\n+\t\t\tif p > b.varTop {\n+\t\t\t\tb.varTop = p\n \t\t\t}\n-\t\t} else if ce[0] > 1 { // 1 is a special primary value reserved for FFFE\n-\t\t\tif ce[0] <= b.varTop {\n-\t\t\t\treturn fmt.Errorf(\"primary value %X of non-variable is smaller than the highest variable %X\", ce[0], b.varTop)\n+\t\t} else if p > 1 { // 1 is a special primary value reserved for FFFE\n+\t\t\tif p <= b.varTop {\n+\t\t\t\treturn fmt.Errorf(\"primary value %X of non-variable is smaller than the highest variable %X\", p, b.varTop)\n \t\t\t}\n-\t\t\tif b.minNonVar == 0 || ce[0] < b.minNonVar {\n-\t\t\t\tb.minNonVar = ce[0]\n+\t\t\tif b.minNonVar == 0 || p < b.minNonVar {\n+\t\t\t\tb.minNonVar = p\n \t\t\t}\n \t\t}\n \t}\n \telems, err := convertLargeWeights(elems)\n \tif err != nil {\n \t\treturn err\n \t}\n+\tcccs := []uint8{}\n+\tnfd := norm.NFD.String(str)\n+\tfor i := range nfd {\n+\t\tcccs = append(cccs, norm.NFD.PropertiesString(nfd[i:]).CCC())\n+\t}\n+\tif len(cccs) < len(elems) {\n+\t\tif len(cccs) > 2 {\n+\t\t\treturn fmt.Errorf(\"number of decomposed characters should be greater or equal to the number of collation elements for len(colelems) > 3 (%d < %d)\", len(cccs), len(elems))\n+\t\t}\n+\t\tp := len(elems) - 1\n+\t\tfor ; p > 0 && elems[p].w[0] == 0; p-- {\n+\t\t\telems[p].ccc = cccs[len(cccs)-1]\n+\t\t}\n+\t\tfor ; p >= 0; p-- {\n+\t\t\telems[p].ccc = cccs[0]\n+\t\t}\n+\t} else {\n+\t\tfor i := range elems {\n+\t\t\telems[i].ccc = cccs[i]\n+\t\t}\n+\t}\n+\t// doNorm in collate.go assumes that the following conditions hold.\n+\tif len(elems) > 1 && len(cccs) > 1 && cccs[0] != 0 && cccs[0] != cccs[len(cccs)-1] {\n+\t\treturn fmt.Errorf(\"incompatible CCC values for expansion %X (%d)\", runes, cccs)\n+\t}\n \tb.root.newEntry(str, elems)\n \treturn nil\n }\n \n func (t *Tailoring) setAnchor(anchor string) error {\n-\tanchor = norm.NFD.String(anchor)\n+\tanchor = norm.NFC.String(anchor)\n \ta := t.index.find(anchor)\n \tif a == nil {\n \t\ta = t.index.newEntry(anchor, nil)\n \t\ta.implicit = true\n+\t\ta.modified = true\n \t\tfor _, r := range []rune(anchor) {\n \t\t\te := t.index.find(string(r))\n \t\t\te.lock = true\n@@ -221,7 +247,7 @@ func (t *Tailoring) Insert(level collate.Level, str, extend string) error {\n \tif t.anchor == nil {\n \t\treturn fmt.Errorf(\"%s:Insert: no anchor point set for tailoring of %s\", t.id, str)\n \t}\n-\tstr = norm.NFD.String(str)\n+\tstr = norm.NFC.String(str)\n \te := t.index.find(str)\n \tif e == nil {\n \t\te = t.index.newEntry(str, nil)\n@@ -262,12 +288,13 @@ func (t *Tailoring) Insert(level collate.Level, str, extend string) error {\n \t}\n \te.extend = norm.NFD.String(extend)\n \te.exclude = false\n+\te.modified = true\n \te.elems = nil\n \tt.anchor = e\n \treturn nil\n }\n \n-func (o *ordering) getWeight(e *entry) [][]int {\n+func (o *ordering) getWeight(e *entry) []rawCE {\n \tif len(e.elems) == 0 && e.logical == noAnchor {\n \t\tif e.implicit {\n \t\t\tfor _, r := range e.runes {\n@@ -279,11 +306,10 @@ func (o *ordering) getWeight(e *entry) [][]int {\n \t\t\tfor ; a.elems == nil && !a.implicit; a = a.next {\n \t\t\t\tcount[a.level]++\n \t\t\t}\n-\t\t\te.elems = append([][]int(nil), make([]int, len(a.elems[0])))\n-\t\t\tcopy(e.elems[0], a.elems[0])\n+\t\t\te.elems = []rawCE{makeRawCE(a.elems[0].w, a.elems[0].ccc)}\n \t\t\tfor i := collate.Primary; i < collate.Quaternary; i++ {\n \t\t\t\tif count[i] != 0 {\n-\t\t\t\t\te.elems[0][i] -= count[i]\n+\t\t\t\t\te.elems[0].w[i] -= count[i]\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n@@ -315,11 +341,11 @@ func (o *ordering) verifyWeights(a, b *entry, level collate.Level) error {\n \t\treturn nil\n \t}\n \tfor i := collate.Primary; i < level; i++ {\n-\t\tif a.elems[0][i] < b.elems[0][i] {\n+\t\tif a.elems[0].w[i] < b.elems[0].w[i] {\n \t\t\treturn nil\n \t\t}\n \t}\n-\tif a.elems[0][level] >= b.elems[0][level] {\n+\tif a.elems[0].w[level] >= b.elems[0].w[level] {\n \t\terr := fmt.Errorf(\"%s:overflow: collation elements of %q (%X) overflows those of %q (%X) at level %d (%X >= %X)\", o.id, a.str, a.runes, b.str, b.runes, level, a.elems, b.elems)\n \t\tlog.Println(err)\n \t\t// TODO: return the error instead, or better, fix the conflicting entry by making room.\n@@ -339,13 +365,62 @@ func (b *Builder) errorID(locale string, e error) {\n \t}\n }\n \n+// patchNorm ensures that NFC and NFD counterparts are consistent.\n+func (o *ordering) patchNorm() {\n+\t// Insert the NFD counterparts, if necessary.\n+\tfor _, e := range o.ordered {\n+\t\tnfd := norm.NFD.String(e.str)\n+\t\tif nfd != e.str {\n+\t\t\tif e0 := o.find(nfd); e0 != nil && !e0.modified {\n+\t\t\t\te0.elems = e.elems\n+\t\t\t} else if e.modified && !equalCEArrays(o.genColElems(nfd), e.elems) {\n+\t\t\t\te := o.newEntry(nfd, e.elems)\n+\t\t\t\te.modified = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// Update unchanged composed forms if one of their parts changed.\n+\tfor _, e := range o.ordered {\n+\t\tnfd := norm.NFD.String(e.str)\n+\t\tif e.modified || nfd == e.str {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif e0 := o.find(nfd); e0 != nil {\n+\t\t\te.elems = e0.elems\n+\t\t} else {\n+\t\t\te.elems = o.genColElems(nfd)\n+\t\t\tif norm.NFD.LastBoundary([]byte(nfd)) == 0 {\n+\t\t\t\tr := []rune(nfd)\n+\t\t\t\thead := string(r[0])\n+\t\t\t\ttail := \"\"\n+\t\t\t\tfor i := 1; i < len(r); i++ {\n+\t\t\t\t\ts := norm.NFC.String(head + string(r[i]))\n+\t\t\t\t\tif e0 := o.find(s); e0 != nil && e0.modified {\n+\t\t\t\t\t\thead = s\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttail += string(r[i])\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\te.elems = append(o.genColElems(head), o.genColElems(tail)...)\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// Exclude entries for which the individual runes generate the same collation elements.\n+\tfor _, e := range o.ordered {\n+\t\tif len(e.runes) > 1 && equalCEArrays(o.genColElems(e.str), e.elems) {\n+\t\t\te.exclude = true\n+\t\t}\n+\t}\n+}\n+\n func (b *Builder) buildOrdering(o *ordering) {\n \tfor _, e := range o.ordered {\n \t\to.getWeight(e)\n \t}\n \tfor _, e := range o.ordered {\n \t\to.addExtension(e)\n \t}\n+\to.patchNorm()\n \to.sort()\n \tsimplify(o)\n \tb.processExpansions(o)   // requires simplify\n@@ -392,11 +467,11 @@ func (b *Builder) Build() (*collate.Collator, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tc := collate.Init(t)\n-\tif c == nil {\n+\ttable := collate.Init(t)\n+\tif table == nil {\n \t\tpanic(\"generated table of incompatible type\")\n \t}\n-\treturn c, nil\n+\treturn collate.NewFromTable(table), nil\n }\n \n // Build builds a Collator for Tailoring t.\n@@ -436,20 +511,20 @@ func (b *Builder) Print(w io.Writer) (n int, err error) {\n \n // reproducibleFromNFKD checks whether the given expansion could be generated\n // from an NFKD expansion.\n-func reproducibleFromNFKD(e *entry, exp, nfkd [][]int) bool {\n+func reproducibleFromNFKD(e *entry, exp, nfkd []rawCE) bool {\n \t// Length must be equal.\n \tif len(exp) != len(nfkd) {\n \t\treturn false\n \t}\n \tfor i, ce := range exp {\n \t\t// Primary and secondary values should be equal.\n-\t\tif ce[0] != nfkd[i][0] || ce[1] != nfkd[i][1] {\n+\t\tif ce.w[0] != nfkd[i].w[0] || ce.w[1] != nfkd[i].w[1] {\n \t\t\treturn false\n \t\t}\n \t\t// Tertiary values should be equal to maxTertiary for third element onwards.\n \t\t// TODO: there seem to be a lot of cases in CLDR (e.g. \u33ed in zh.xml) that can\n \t\t// simply be dropped.  Try this out by dropping the following code.\n-\t\tif i >= 2 && ce[2] != maxTertiary {\n+\t\tif i >= 2 && ce.w[2] != maxTertiary {\n \t\t\treturn false\n \t\t}\n \t\tif _, err := makeCE(ce); err != nil {\n@@ -469,22 +544,12 @@ func simplify(o *ordering) {\n \t\t\tkeep[e.runes[0]] = true\n \t\t}\n \t}\n-\t// Remove entries for which the runes normalize (using NFD) to identical values.\n-\tfor e := o.front(); e != nil; e, _ = e.nextIndexed() {\n-\t\ts := e.str\n-\t\tnfd := norm.NFD.String(s)\n-\t\tif len(e.runes) > 1 || keep[e.runes[0]] || nfd == s {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif equalCEArrays(o.genColElems(nfd), e.elems) {\n-\t\t\te.remove()\n-\t\t}\n-\t}\n \t// Tag entries for which the runes NFKD decompose to identical values.\n \tfor e := o.front(); e != nil; e, _ = e.nextIndexed() {\n \t\ts := e.str\n \t\tnfkd := norm.NFKD.String(s)\n-\t\tif e.decompose || len(e.runes) > 1 || len(e.elems) == 1 || keep[e.runes[0]] || nfkd == s {\n+\t\tnfd := norm.NFD.String(s)\n+\t\tif e.decompose || len(e.runes) > 1 || len(e.elems) == 1 || keep[e.runes[0]] || nfkd == nfd {\n \t\t\tcontinue\n \t\t}\n \t\tif reproducibleFromNFKD(e, e.elems, o.genColElems(nfkd)) {\n@@ -589,18 +654,18 @@ func (b *Builder) processContractions(o *ordering) {\n \t\t// Bucket sort entries in index order.\n \t\tes := make([]*entry, len(l))\n \t\tfor _, e := range l {\n-\t\t\tvar o, sn int\n+\t\t\tvar p, sn int\n \t\t\tif len(e.runes) > 1 {\n \t\t\t\tstr := []byte(string(e.runes[1:]))\n-\t\t\t\to, sn = t.contractTries.lookup(handle, str)\n+\t\t\t\tp, sn = t.contractTries.lookup(handle, str)\n \t\t\t\tif sn != len(str) {\n-\t\t\t\t\tlog.Fatalf(\"processContractions: unexpected length for '%X'; len=%d; want %d\", e.runes, sn, len(str))\n+\t\t\t\t\tlog.Fatalf(\"%s: processContractions: unexpected length for '%X'; len=%d; want %d\", o.id, e.runes, sn, len(str))\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif es[o] != nil {\n-\t\t\t\tlog.Fatalf(\"Multiple contractions for position %d for rune %U\", o, e.runes[0])\n+\t\t\tif es[p] != nil {\n+\t\t\t\tlog.Fatalf(\"%s: multiple contractions for position %d for rune %U\", o.id, p, e.runes[0])\n \t\t\t}\n-\t\t\tes[o] = e\n+\t\t\tes[p] = e\n \t\t}\n \t\t// Create collation elements for contractions.\n \t\telems := []uint32{}"}, {"sha": "568309798e5c4f21e793b683bd842c762528ed7e", "filename": "libgo/go/exp/locale/collate/build/builder_test.go", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -7,48 +7,64 @@ package build\n import \"testing\"\n \n // cjk returns an implicit collation element for a CJK rune.\n-func cjk(r rune) [][]int {\n+func cjk(r rune) []rawCE {\n \t// A CJK character C is represented in the DUCET as\n \t//   [.AAAA.0020.0002.C][.BBBB.0000.0000.C]\n \t// Where AAAA is the most significant 15 bits plus a base value.\n \t// Any base value will work for the test, so we pick the common value of FB40.\n \tconst base = 0xFB40\n-\treturn [][]int{\n-\t\t{base + int(r>>15), defaultSecondary, defaultTertiary, int(r)},\n-\t\t{int(r&0x7FFF) | 0x8000, 0, 0, int(r)},\n+\treturn []rawCE{\n+\t\t{w: []int{base + int(r>>15), defaultSecondary, defaultTertiary, int(r)}},\n+\t\t{w: []int{int(r&0x7FFF) | 0x8000, 0, 0, int(r)}},\n \t}\n }\n \n-func pCE(p int) [][]int {\n-\treturn [][]int{{p, defaultSecondary, defaultTertiary, 0}}\n+func pCE(p int) []rawCE {\n+\treturn mkCE([]int{p, defaultSecondary, defaultTertiary, 0}, 0)\n }\n \n-func pqCE(p, q int) [][]int {\n-\treturn [][]int{{p, defaultSecondary, defaultTertiary, q}}\n+func pqCE(p, q int) []rawCE {\n+\treturn mkCE([]int{p, defaultSecondary, defaultTertiary, q}, 0)\n }\n \n-func ptCE(p, t int) [][]int {\n-\treturn [][]int{{p, defaultSecondary, t, 0}}\n+func ptCE(p, t int) []rawCE {\n+\treturn mkCE([]int{p, defaultSecondary, t, 0}, 0)\n }\n \n-func sCE(s int) [][]int {\n-\treturn [][]int{{0, s, defaultTertiary, 0}}\n+func ptcCE(p, t int, ccc uint8) []rawCE {\n+\treturn mkCE([]int{p, defaultSecondary, t, 0}, ccc)\n }\n \n-func stCE(s, t int) [][]int {\n-\treturn [][]int{{0, s, t, 0}}\n+func sCE(s int) []rawCE {\n+\treturn mkCE([]int{0, s, defaultTertiary, 0}, 0)\n+}\n+\n+func stCE(s, t int) []rawCE {\n+\treturn mkCE([]int{0, s, t, 0}, 0)\n+}\n+\n+func scCE(s int, ccc uint8) []rawCE {\n+\treturn mkCE([]int{0, s, defaultTertiary, 0}, ccc)\n+}\n+\n+func mkCE(w []int, ccc uint8) []rawCE {\n+\treturn []rawCE{rawCE{w, ccc}}\n }\n \n // ducetElem is used to define test data that is used to generate a table.\n type ducetElem struct {\n \tstr string\n-\tces [][]int\n+\tces []rawCE\n }\n \n func newBuilder(t *testing.T, ducet []ducetElem) *Builder {\n \tb := NewBuilder()\n \tfor _, e := range ducet {\n-\t\tif err := b.Add([]rune(e.str), e.ces, nil); err != nil {\n+\t\tces := [][]int{}\n+\t\tfor _, ce := range e.ces {\n+\t\t\tces = append(ces, ce.w)\n+\t\t}\n+\t\tif err := b.Add([]rune(e.str), ces, nil); err != nil {\n \t\t\tt.Errorf(err.Error())\n \t\t}\n \t}\n@@ -58,7 +74,7 @@ func newBuilder(t *testing.T, ducet []ducetElem) *Builder {\n }\n \n type convertTest struct {\n-\tin, out [][]int\n+\tin, out []rawCE\n \terr     bool\n }\n \n@@ -73,7 +89,10 @@ var convLargeTests = []convertTest{\n \n func TestConvertLarge(t *testing.T) {\n \tfor i, tt := range convLargeTests {\n-\t\te := &entry{elems: tt.in}\n+\t\te := new(entry)\n+\t\tfor _, ce := range tt.in {\n+\t\t\te.elems = append(e.elems, makeRawCE(ce.w, ce.ccc))\n+\t\t}\n \t\telems, err := convertLargeWeights(e.elems)\n \t\tif tt.err {\n \t\t\tif err == nil {\n@@ -173,16 +192,18 @@ func TestSimplify(t *testing.T) {\n }\n \n var expandTest = []ducetElem{\n-\t{\"\\u00C0\", append(ptCE(100, 8), sCE(30)...)},\n-\t{\"\\u00C8\", append(ptCE(105, 8), sCE(30)...)},\n-\t{\"\\u00C9\", append(ptCE(105, 8), sCE(30)...)}, // identical expansion\n+\t{\"\\u0300\", append(scCE(29, 230), scCE(30, 230)...)},\n+\t{\"\\u00C0\", append(ptCE(100, 8), scCE(30, 230)...)},\n+\t{\"\\u00C8\", append(ptCE(105, 8), scCE(30, 230)...)},\n+\t{\"\\u00C9\", append(ptCE(105, 8), scCE(30, 230)...)}, // identical expansion\n \t{\"\\u05F2\", append(ptCE(200, 4), ptCE(200, 4)[0], ptCE(200, 4)[0])},\n+\t{\"\\u01FF\", append(ptCE(200, 4), ptcCE(201, 4, 0)[0], scCE(30, 230)[0])},\n }\n \n func TestExpand(t *testing.T) {\n \tconst (\n-\t\ttotalExpansions = 3\n-\t\ttotalElements   = 2 + 2 + 3 + totalExpansions\n+\t\ttotalExpansions = 5\n+\t\ttotalElements   = 2 + 2 + 2 + 3 + 3 + totalExpansions\n \t)\n \tb := newBuilder(t, expandTest)\n \to := &b.root"}, {"sha": "1a8356d72bcd38eb439bf4e51f20c92653b2de68", "filename": "libgo/go/exp/locale/collate/build/colelem.go", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -16,6 +16,17 @@ const (\n \tmaxTertiary      = 0x1F\n )\n \n+type rawCE struct {\n+\tw   []int\n+\tccc uint8\n+}\n+\n+func makeRawCE(w []int, ccc uint8) rawCE {\n+\tce := rawCE{w: make([]int, 4), ccc: ccc}\n+\tcopy(ce.w, w)\n+\treturn ce\n+}\n+\n // A collation element is represented as an uint32.\n // In the typical case, a rune maps to a single collation element. If a rune\n // can be the start of a contraction or expands into multiple collation elements,\n@@ -29,29 +40,36 @@ const (\n // 01pppppp pppppppp ppppppp0 ssssssss\n //   - p* is primary collation value\n //   - s* is the secondary collation value\n-// or\n // 00pppppp pppppppp ppppppps sssttttt, where\n //   - p* is primary collation value\n //   - s* offset of secondary from default value.\n //   - t* is the tertiary collation value\n+// 100ttttt cccccccc pppppppp pppppppp\n+//   - t* is the tertiar collation value\n+//   - c* is the cannonical combining class\n+//   - p* is the primary collation value\n // Collation elements with a secondary value are of the form\n-// 10000000 0000ssss ssssssss tttttttt, where\n-//   - 16 BMP implicit -> weight\n-//   - 8 bit s\n-//   - default tertiary\n+// 1010cccc ccccssss ssssssss tttttttt, where\n+//   - c* is the canonical combining class\n+//   - s* is the secondary collation value\n+//   - t* is the tertiary collation value\n const (\n \tmaxPrimaryBits          = 21\n+\tmaxPrimaryCompactBits   = 16\n \tmaxSecondaryBits        = 12\n \tmaxSecondaryCompactBits = 8\n+\tmaxCCCBits              = 8\n \tmaxSecondaryDiffBits    = 4\n \tmaxTertiaryBits         = 8\n \tmaxTertiaryCompactBits  = 5\n \n-\tisSecondary = 0x80000000\n-\tisPrimary   = 0x40000000\n+\tisPrimary    = 0x40000000\n+\tisPrimaryCCC = 0x80000000\n+\tisSecondary  = 0xA0000000\n )\n \n-func makeCE(weights []int) (uint32, error) {\n+func makeCE(rce rawCE) (uint32, error) {\n+\tweights := rce.w\n \tif w := weights[0]; w >= 1<<maxPrimaryBits || w < 0 {\n \t\treturn 0, fmt.Errorf(\"makeCE: primary weight out of bounds: %x >= %x\", w, 1<<maxPrimaryBits)\n \t}\n@@ -63,14 +81,25 @@ func makeCE(weights []int) (uint32, error) {\n \t}\n \tce := uint32(0)\n \tif weights[0] != 0 {\n-\t\tif weights[2] == defaultTertiary {\n+\t\tif rce.ccc != 0 {\n+\t\t\tif weights[0] >= 1<<maxPrimaryCompactBits {\n+\t\t\t\treturn 0, fmt.Errorf(\"makeCE: primary weight with non-zero CCC out of bounds: %x >= %x\", weights[0], 1<<maxPrimaryCompactBits)\n+\t\t\t}\n+\t\t\tif weights[1] != defaultSecondary {\n+\t\t\t\treturn 0, fmt.Errorf(\"makeCE: cannot combine non-default secondary value (%x) with non-zero CCC (%x)\", weights[1], rce.ccc)\n+\t\t\t}\n+\t\t\tce = uint32(weights[2] << (maxPrimaryCompactBits + maxCCCBits))\n+\t\t\tce |= uint32(rce.ccc) << maxPrimaryCompactBits\n+\t\t\tce |= uint32(weights[0])\n+\t\t\tce |= isPrimaryCCC\n+\t\t} else if weights[2] == defaultTertiary {\n \t\t\tif weights[1] >= 1<<maxSecondaryCompactBits {\n \t\t\t\treturn 0, fmt.Errorf(\"makeCE: secondary weight with non-zero primary out of bounds: %x >= %x\", weights[1], 1<<maxSecondaryCompactBits)\n \t\t\t}\n \t\t\tce = uint32(weights[0]<<(maxSecondaryCompactBits+1) + weights[1])\n \t\t\tce |= isPrimary\n \t\t} else {\n-\t\t\td := weights[1] - defaultSecondary + 4\n+\t\t\td := weights[1] - defaultSecondary + maxSecondaryDiffBits\n \t\t\tif d >= 1<<maxSecondaryDiffBits || d < 0 {\n \t\t\t\treturn 0, fmt.Errorf(\"makeCE: secondary weight diff out of bounds: %x < 0 || %x > %x\", d, d, 1<<maxSecondaryDiffBits)\n \t\t\t}\n@@ -82,6 +111,7 @@ func makeCE(weights []int) (uint32, error) {\n \t\t}\n \t} else {\n \t\tce = uint32(weights[1]<<maxTertiaryBits + weights[2])\n+\t\tce += uint32(rce.ccc) << (maxSecondaryBits + maxTertiaryBits)\n \t\tce |= isSecondary\n \t}\n \treturn ce, nil\n@@ -207,7 +237,7 @@ func implicitPrimary(r rune) int {\n // We will rewrite these characters to a single CE.\n // We assume the CJK values start at 0x8000.\n // See http://unicode.org/reports/tr10/#Implicit_Weights\n-func convertLargeWeights(elems [][]int) (res [][]int, err error) {\n+func convertLargeWeights(elems []rawCE) (res []rawCE, err error) {\n \tconst (\n \t\tcjkPrimaryStart   = 0xFB40\n \t\trarePrimaryStart  = 0xFB80\n@@ -219,7 +249,7 @@ func convertLargeWeights(elems [][]int) (res [][]int, err error) {\n \t\tshiftBits         = 15\n \t)\n \tfor i := 0; i < len(elems); i++ {\n-\t\tce := elems[i]\n+\t\tce := elems[i].w\n \t\tp := ce[0]\n \t\tif p < cjkPrimaryStart {\n \t\t\tcontinue\n@@ -233,10 +263,10 @@ func convertLargeWeights(elems [][]int) (res [][]int, err error) {\n \t\t\tif i+1 >= len(elems) {\n \t\t\t\treturn elems, fmt.Errorf(\"second part of double primary weight missing: %v\", elems)\n \t\t\t}\n-\t\t\tif elems[i+1][0]&lowBitsFlag == 0 {\n+\t\t\tif elems[i+1].w[0]&lowBitsFlag == 0 {\n \t\t\t\treturn elems, fmt.Errorf(\"malformed second part of double primary weight: %v\", elems)\n \t\t\t}\n-\t\t\tnp := ((p & highBitsMask) << shiftBits) + elems[i+1][0]&lowBitsMask\n+\t\t\tnp := ((p & highBitsMask) << shiftBits) + elems[i+1].w[0]&lowBitsMask\n \t\t\tswitch {\n \t\t\tcase p < rarePrimaryStart:\n \t\t\t\tnp += commonUnifiedOffset\n@@ -257,26 +287,25 @@ func convertLargeWeights(elems [][]int) (res [][]int, err error) {\n \n // nextWeight computes the first possible collation weights following elems\n // for the given level.\n-func nextWeight(level collate.Level, elems [][]int) [][]int {\n+func nextWeight(level collate.Level, elems []rawCE) []rawCE {\n \tif level == collate.Identity {\n-\t\tnext := make([][]int, len(elems))\n+\t\tnext := make([]rawCE, len(elems))\n \t\tcopy(next, elems)\n \t\treturn next\n \t}\n-\tnext := [][]int{make([]int, len(elems[0]))}\n-\tcopy(next[0], elems[0])\n-\tnext[0][level]++\n+\tnext := []rawCE{makeRawCE(elems[0].w, elems[0].ccc)}\n+\tnext[0].w[level]++\n \tif level < collate.Secondary {\n-\t\tnext[0][collate.Secondary] = defaultSecondary\n+\t\tnext[0].w[collate.Secondary] = defaultSecondary\n \t}\n \tif level < collate.Tertiary {\n-\t\tnext[0][collate.Tertiary] = defaultTertiary\n+\t\tnext[0].w[collate.Tertiary] = defaultTertiary\n \t}\n \t// Filter entries that cannot influence ordering.\n \tfor _, ce := range elems[1:] {\n \t\tskip := true\n \t\tfor i := collate.Primary; i < level; i++ {\n-\t\t\tskip = skip && ce[i] == 0\n+\t\t\tskip = skip && ce.w[i] == 0\n \t\t}\n \t\tif !skip {\n \t\t\tnext = append(next, ce)\n@@ -285,18 +314,18 @@ func nextWeight(level collate.Level, elems [][]int) [][]int {\n \treturn next\n }\n \n-func nextVal(elems [][]int, i int, level collate.Level) (index, value int) {\n-\tfor ; i < len(elems) && elems[i][level] == 0; i++ {\n+func nextVal(elems []rawCE, i int, level collate.Level) (index, value int) {\n+\tfor ; i < len(elems) && elems[i].w[level] == 0; i++ {\n \t}\n \tif i < len(elems) {\n-\t\treturn i, elems[i][level]\n+\t\treturn i, elems[i].w[level]\n \t}\n \treturn i, 0\n }\n \n // compareWeights returns -1 if a < b, 1 if a > b, or 0 otherwise.\n // It also returns the collation level at which the difference is found.\n-func compareWeights(a, b [][]int) (result int, level collate.Level) {\n+func compareWeights(a, b []rawCE) (result int, level collate.Level) {\n \tfor level := collate.Primary; level < collate.Identity; level++ {\n \t\tvar va, vb int\n \t\tfor ia, ib := 0, 0; ia < len(a) || ib < len(b); ia, ib = ia+1, ib+1 {\n@@ -314,19 +343,16 @@ func compareWeights(a, b [][]int) (result int, level collate.Level) {\n \treturn 0, collate.Identity\n }\n \n-func equalCE(a, b []int) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n+func equalCE(a, b rawCE) bool {\n \tfor i := 0; i < 3; i++ {\n-\t\tif b[i] != a[i] {\n+\t\tif b.w[i] != a.w[i] {\n \t\t\treturn false\n \t\t}\n \t}\n \treturn true\n }\n \n-func equalCEArrays(a, b [][]int) bool {\n+func equalCEArrays(a, b []rawCE) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n \t}"}, {"sha": "b3be0336d21221102416b58bacbf70d31714c23c", "filename": "libgo/go/exp/locale/collate/build/colelem_test.go", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -16,7 +16,7 @@ type ceTest struct {\n }\n \n func normalCE(in []int) (ce uint32, err error) {\n-\treturn makeCE(in)\n+\treturn makeCE(rawCE{w: in[:3], ccc: uint8(in[3])})\n }\n \n func expandCE(in []int) (ce uint32, err error) {\n@@ -32,17 +32,20 @@ func decompCE(in []int) (ce uint32, err error) {\n }\n \n var ceTests = []ceTest{\n-\t{normalCE, []int{0, 0, 0}, 0x80000000},\n-\t{normalCE, []int{0, 0x28, 3}, 0x80002803},\n-\t{normalCE, []int{100, defaultSecondary, 3}, 0x0000C883},\n+\t{normalCE, []int{0, 0, 0, 0}, 0xA0000000},\n+\t{normalCE, []int{0, 0x28, 3, 0}, 0xA0002803},\n+\t{normalCE, []int{0, 0x28, 3, 0xFF}, 0xAFF02803},\n+\t{normalCE, []int{100, defaultSecondary, 3, 0}, 0x0000C883},\n \t// non-ignorable primary with non-default secondary\n-\t{normalCE, []int{100, 0x28, defaultTertiary}, 0x4000C828},\n-\t{normalCE, []int{100, defaultSecondary + 8, 3}, 0x0000C983},\n-\t{normalCE, []int{100, 0, 3}, 0xFFFF}, // non-ignorable primary with non-supported secondary\n-\t{normalCE, []int{100, 1, 3}, 0xFFFF},\n-\t{normalCE, []int{1 << maxPrimaryBits, defaultSecondary, 0}, 0xFFFF},\n-\t{normalCE, []int{0, 1 << maxSecondaryBits, 0}, 0xFFFF},\n-\t{normalCE, []int{100, defaultSecondary, 1 << maxTertiaryBits}, 0xFFFF},\n+\t{normalCE, []int{100, 0x28, defaultTertiary, 0}, 0x4000C828},\n+\t{normalCE, []int{100, defaultSecondary + 8, 3, 0}, 0x0000C983},\n+\t{normalCE, []int{100, 0, 3, 0}, 0xFFFF}, // non-ignorable primary with non-supported secondary\n+\t{normalCE, []int{100, 1, 3, 0}, 0xFFFF},\n+\t{normalCE, []int{1 << maxPrimaryBits, defaultSecondary, 0, 0}, 0xFFFF},\n+\t{normalCE, []int{0, 1 << maxSecondaryBits, 0, 0}, 0xFFFF},\n+\t{normalCE, []int{100, defaultSecondary, 1 << maxTertiaryBits, 0}, 0xFFFF},\n+\t{normalCE, []int{0x123, defaultSecondary, 8, 0xFF}, 0x88FF0123},\n+\t{normalCE, []int{0x123, defaultSecondary + 1, 8, 0xFF}, 0xFFFF},\n \n \t{contractCE, []int{0, 0, 0}, 0xC0000000},\n \t{contractCE, []int{1, 1, 1}, 0xC0010011},\n@@ -85,6 +88,14 @@ func TestColElem(t *testing.T) {\n \t}\n }\n \n+func mkRawCES(in [][]int) []rawCE {\n+\tout := []rawCE{}\n+\tfor _, w := range in {\n+\t\tout = append(out, rawCE{w: w})\n+\t}\n+\treturn out\n+}\n+\n type weightsTest struct {\n \ta, b   [][]int\n \tlevel  collate.Level\n@@ -119,8 +130,8 @@ var extra = [][]int{{200, 32, 8, 0}, {0, 32, 8, 0}, {0, 0, 8, 0}, {0, 0, 0, 0}}\n func TestNextWeight(t *testing.T) {\n \tfor i, tt := range nextWeightTests {\n \t\ttest := func(l collate.Level, tt weightsTest, a, gold [][]int) {\n-\t\t\tres := nextWeight(tt.level, a)\n-\t\t\tif !equalCEArrays(gold, res) {\n+\t\t\tres := nextWeight(tt.level, mkRawCES(a))\n+\t\t\tif !equalCEArrays(mkRawCES(gold), res) {\n \t\t\t\tt.Errorf(\"%d:%d: expected weights %d; found %d\", i, l, gold, res)\n \t\t\t}\n \t\t}\n@@ -189,7 +200,7 @@ var compareTests = []weightsTest{\n func TestCompareWeights(t *testing.T) {\n \tfor i, tt := range compareTests {\n \t\ttest := func(tt weightsTest, a, b [][]int) {\n-\t\t\tres, level := compareWeights(a, b)\n+\t\t\tres, level := compareWeights(mkRawCES(a), mkRawCES(b))\n \t\t\tif res != tt.result {\n \t\t\t\tt.Errorf(\"%d: expected comparisson result %d; found %d\", i, tt.result, res)\n \t\t\t}"}, {"sha": "b22a382e94b4e7ea2ad1f15fdbc9fbe9e0929821", "filename": "libgo/go/exp/locale/collate/build/order.go", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -6,6 +6,7 @@ package build\n \n import (\n \t\"exp/locale/collate\"\n+\t\"exp/norm\"\n \t\"fmt\"\n \t\"log\"\n \t\"sort\"\n@@ -28,7 +29,7 @@ const (\n type entry struct {\n \tstr    string // same as string(runes)\n \trunes  []rune\n-\telems  [][]int // the collation elements\n+\telems  []rawCE // the collation elements\n \textend string  // weights of extend to be appended to elems\n \tbefore bool    // weights relative to next instead of previous.\n \tlock   bool    // entry is used in extension and can no longer be moved.\n@@ -41,6 +42,7 @@ type entry struct {\n \tdecompose bool // can use NFKD decomposition to generate elems\n \texclude   bool // do not include in table\n \timplicit  bool // derived, is not included in the list\n+\tmodified  bool // entry was modified in tailoring\n \tlogical   logicalAnchor\n \n \texpansionIndex    int // used to store index into expansion table\n@@ -162,10 +164,10 @@ func (e *entry) encode() (ce uint32, err error) {\n \t}\n \tswitch {\n \tcase e.decompose:\n-\t\tt1 := e.elems[0][2]\n+\t\tt1 := e.elems[0].w[2]\n \t\tt2 := 0\n \t\tif len(e.elems) > 1 {\n-\t\t\tt2 = e.elems[1][2]\n+\t\t\tt2 = e.elems[1].w[2]\n \t\t}\n \t\tce, err = makeDecompose(t1, t2)\n \tcase e.contractionStarter():\n@@ -231,7 +233,7 @@ func (o *ordering) insert(e *entry) {\n \n // newEntry creates a new entry for the given info and inserts it into\n // the index.\n-func (o *ordering) newEntry(s string, ces [][]int) *entry {\n+func (o *ordering) newEntry(s string, ces []rawCE) *entry {\n \te := &entry{\n \t\trunes: []rune(s),\n \t\telems: ces,\n@@ -249,14 +251,29 @@ func (o *ordering) find(str string) *entry {\n \tif e == nil {\n \t\tr := []rune(str)\n \t\tif len(r) == 1 {\n-\t\t\te = o.newEntry(string(r[0]), [][]int{\n-\t\t\t\t{\n-\t\t\t\t\timplicitPrimary(r[0]),\n-\t\t\t\t\tdefaultSecondary,\n-\t\t\t\t\tdefaultTertiary,\n-\t\t\t\t\tint(r[0]),\n-\t\t\t\t},\n-\t\t\t})\n+\t\t\tconst (\n+\t\t\t\tfirstHangul = 0xAC00\n+\t\t\t\tlastHangul  = 0xD7A3\n+\t\t\t)\n+\t\t\tif r[0] >= firstHangul && r[0] <= lastHangul {\n+\t\t\t\tce := []rawCE{}\n+\t\t\t\tnfd := norm.NFD.String(str)\n+\t\t\t\tfor _, r := range nfd {\n+\t\t\t\t\tce = append(ce, o.find(string(r)).elems...)\n+\t\t\t\t}\n+\t\t\t\te = o.newEntry(nfd, ce)\n+\t\t\t} else {\n+\t\t\t\te = o.newEntry(string(r[0]), []rawCE{\n+\t\t\t\t\t{w: []int{\n+\t\t\t\t\t\timplicitPrimary(r[0]),\n+\t\t\t\t\t\tdefaultSecondary,\n+\t\t\t\t\t\tdefaultTertiary,\n+\t\t\t\t\t\tint(r[0]),\n+\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t})\n+\t\t\t\te.modified = true\n+\t\t\t}\n \t\t\te.exclude = true // do not index implicits\n \t\t}\n \t}\n@@ -275,7 +292,7 @@ func makeRootOrdering() ordering {\n \t}\n \tinsert := func(typ logicalAnchor, s string, ce []int) {\n \t\te := &entry{\n-\t\t\telems:   [][]int{ce},\n+\t\t\telems:   []rawCE{{w: ce}},\n \t\t\tstr:     s,\n \t\t\texclude: true,\n \t\t\tlogical: typ,\n@@ -362,10 +379,14 @@ func (o *ordering) sort() {\n \n // genColElems generates a collation element array from the runes in str. This\n // assumes that all collation elements have already been added to the Builder.\n-func (o *ordering) genColElems(str string) [][]int {\n-\telems := [][]int{}\n+func (o *ordering) genColElems(str string) []rawCE {\n+\telems := []rawCE{}\n \tfor _, r := range []rune(str) {\n-\t\telems = append(elems, o.find(string(r)).elems...)\n+\t\tfor _, ce := range o.find(string(r)).elems {\n+\t\t\tif ce.w[0] != 0 || ce.w[1] != 0 || ce.w[2] != 0 {\n+\t\t\t\telems = append(elems, ce)\n+\t\t\t}\n+\t\t}\n \t}\n \treturn elems\n }"}, {"sha": "9577d918cf2785d616b3f66ab7d8c1dab217ed0b", "filename": "libgo/go/exp/locale/collate/build/order_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -20,7 +20,7 @@ type entryTest struct {\n // entries plus a leading and trailing anchor.\n func makeList(n int) []*entry {\n \tes := make([]*entry, n+2)\n-\tweights := [][]int{{100, 20, 5, 0}}\n+\tweights := []rawCE{{w: []int{100, 20, 5, 0}}}\n \tfor i := range es {\n \t\trunes := []rune{rune(i)}\n \t\tes[i] = &entry{\n@@ -176,8 +176,8 @@ type entryLessTest struct {\n }\n \n var (\n-\tw1 = [][]int{{100, 20, 5, 5}}\n-\tw2 = [][]int{{101, 20, 5, 5}}\n+\tw1 = []rawCE{{w: []int{100, 20, 5, 5}}}\n+\tw2 = []rawCE{{w: []int{101, 20, 5, 5}}}\n )\n \n var entryLessTests = []entryLessTest{"}, {"sha": "1b6c3da4c0bb079dcd60b599fbadf4d6dae85c3f", "filename": "libgo/go/exp/locale/collate/build/table.go", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -69,30 +69,14 @@ func (t *table) fprint(w io.Writer, name string) (n, size int, err error) {\n \t\t}\n \t\tsize += sz\n \t}\n-\tp := func(f string, a ...interface{}) {\n-\t\tnn, e := fmt.Fprintf(w, f, a...)\n-\t\tupdate(nn, 0, e)\n-\t}\n-\t// Write main table.\n-\tsize += int(reflect.TypeOf(*t).Size())\n-\tp(\"var %sTable = table{\\n\", name)\n-\tupdate(t.index.printStruct(w, t.root, name))\n-\tp(\",\\n\")\n-\tp(\"%sExpandElem[:],\\n\", name)\n-\tupdate(t.contractTries.printStruct(w, name))\n-\tp(\",\\n\")\n-\tp(\"%sContractElem[:],\\n\", name)\n-\tp(\"%d,\\n\", t.maxContractLen)\n-\tp(\"0x%X,\\n\", t.variableTop)\n-\tp(\"}\\n\\n\")\n-\n \t// Write arrays needed for the structure.\n \tupdate(printColElems(w, t.expandElem, name+\"ExpandElem\"))\n \tupdate(printColElems(w, t.contractElem, name+\"ContractElem\"))\n \tupdate(t.index.printArrays(w, name))\n \tupdate(t.contractTries.printArray(w, name))\n \n-\tp(\"// Total size of %sTable is %d bytes\\n\", name, size)\n+\tnn, e := fmt.Fprintf(w, \"// Total size of %sTable is %d bytes\\n\", name, size)\n+\tupdate(nn, 0, e)\n \treturn\n }\n "}, {"sha": "7633ddc0e7f6256474850efaf3bb9abffb82bacc", "filename": "libgo/go/exp/locale/collate/colelem.go", "status": "modified", "additions": 128, "deletions": 46, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -8,27 +8,43 @@ import (\n \t\"unicode\"\n )\n \n+// Level identifies the collation comparison level.\n+// The primary level corresponds to the basic sorting of text.\n+// The secondary level corresponds to accents and related linguistic elements.\n+// The tertiary level corresponds to casing and related concepts.\n+// The quaternary level is derived from the other levels by the\n+// various algorithms for handling variable elements.\n+type Level int\n+\n+const (\n+\tPrimary Level = iota\n+\tSecondary\n+\tTertiary\n+\tQuaternary\n+\tIdentity\n+)\n+\n const (\n \tdefaultSecondary = 0x20\n \tdefaultTertiary  = 0x2\n \tmaxTertiary      = 0x1F\n-\tmaxQuaternary    = 0x1FFFFF // 21 bits.\n+\tMaxQuaternary    = 0x1FFFFF // 21 bits.\n )\n \n-// colElem is a representation of a collation element.\n-// In the typical case, a rune maps to a single collation element. If a rune\n-// can be the start of a contraction or expands into multiple collation elements,\n-// then the colElem that is associated with a rune will have a special form to represent\n-// such m to n mappings.  Such special colElems have a value >= 0x80000000.\n-type colElem uint32\n+// Elem is a representation of a collation element. This API provides ways to encode\n+// and decode Elems. Implementations of collation tables may use values greater\n+// or equal to PrivateUse for their own purposes.  However, these should never be\n+// returned by AppendNext.\n+type Elem uint32\n \n const (\n-\tmaxCE       colElem = 0x80FFFFFF\n-\tminContract         = 0xC0000000\n-\tmaxContract         = 0xDFFFFFFF\n-\tminExpand           = 0xE0000000\n-\tmaxExpand           = 0xEFFFFFFF\n-\tminDecomp           = 0xF0000000\n+\tmaxCE       Elem = 0xAFFFFFFF\n+\tPrivateUse       = minContract\n+\tminContract      = 0xC0000000\n+\tmaxContract      = 0xDFFFFFFF\n+\tminExpand        = 0xE0000000\n+\tmaxExpand        = 0xEFFFFFFF\n+\tminDecomp        = 0xF0000000\n )\n \n type ceType int\n@@ -40,7 +56,7 @@ const (\n \tceDecompose                      // rune expands using NFKC decomposition\n )\n \n-func (ce colElem) ctype() ceType {\n+func (ce Elem) ctype() ceType {\n \tif ce <= maxCE {\n \t\treturn ceNormal\n \t}\n@@ -62,97 +78,163 @@ func (ce colElem) ctype() ceType {\n // 01pppppp pppppppp ppppppp0 ssssssss\n //   - p* is primary collation value\n //   - s* is the secondary collation value\n-// or\n // 00pppppp pppppppp ppppppps sssttttt, where\n //   - p* is primary collation value\n //   - s* offset of secondary from default value.\n //   - t* is the tertiary collation value\n+// 100ttttt cccccccc pppppppp pppppppp\n+//   - t* is the tertiar collation value\n+//   - c* is the cannonical combining class\n+//   - p* is the primary collation value\n // Collation elements with a secondary value are of the form\n-// 10000000 0000ssss ssssssss tttttttt, where\n-//   - 16 BMP implicit -> weight\n-//   - 8 bit s\n-//   - default tertiary\n+// 1010cccc ccccssss ssssssss tttttttt, where\n+//   - c* is the canonical combining class\n+//   - s* is the secondary collation value\n+//   - t* is the tertiary collation value\n // 11qqqqqq qqqqqqqq qqqqqqq0 00000000\n //   - q* quaternary value\n const (\n \tceTypeMask            = 0xC0000000\n+\tceTypeMaskExt         = 0xE0000000\n \tceType1               = 0x40000000\n \tceType2               = 0x00000000\n-\tceType3               = 0x80000000\n+\tceType3or4            = 0x80000000\n+\tceType4               = 0xA0000000\n \tceTypeQ               = 0xC0000000\n-\tceIgnore              = ceType3\n+\tceIgnore              = ceType4\n \tfirstNonPrimary       = 0x80000000\n+\tlastSpecialPrimary    = 0xA0000000\n \tsecondaryMask         = 0x80000000\n \thasTertiaryMask       = 0x40000000\n \tprimaryValueMask      = 0x3FFFFE00\n \tprimaryShift          = 9\n+\tcompactPrimaryBits    = 16\n \tcompactSecondaryShift = 5\n \tminCompactSecondary   = defaultSecondary - 4\n )\n \n-func makeImplicitCE(primary int) colElem {\n-\treturn ceType1 | colElem(primary<<primaryShift) | defaultSecondary\n+func makeImplicitCE(primary int) Elem {\n+\treturn ceType1 | Elem(primary<<primaryShift) | defaultSecondary\n }\n \n-func makeQuaternary(primary int) colElem {\n-\treturn ceTypeQ | colElem(primary<<primaryShift)\n+// MakeElem returns an Elem for the given values.  It will return an error\n+// if the given combination of values is invalid.\n+func MakeElem(primary, secondary, tertiary int, ccc uint8) (Elem, error) {\n+\t// TODO: implement\n+\treturn 0, nil\n }\n \n-func (ce colElem) primary() int {\n+// MakeQuaternary returns an Elem with the given quaternary value.\n+func MakeQuaternary(v int) Elem {\n+\treturn ceTypeQ | Elem(v<<primaryShift)\n+}\n+\n+// Mask sets weights for any level smaller than l to 0.\n+// The resulting Elem can be used to test for equality with\n+// other Elems to which the same mask has been applied.\n+func (ce Elem) Mask(l Level) uint32 {\n+\treturn 0\n+}\n+\n+// CCC returns the canoncial combining class associated with the underlying character,\n+// if applicable, or 0 otherwise.\n+func (ce Elem) CCC() uint8 {\n+\tif ce&ceType3or4 != 0 {\n+\t\tif ce&ceType4 == ceType3or4 {\n+\t\t\treturn uint8(ce >> 16)\n+\t\t}\n+\t\treturn uint8(ce >> 20)\n+\t}\n+\treturn 0\n+}\n+\n+// Primary returns the primary collation weight for ce.\n+func (ce Elem) Primary() int {\n \tif ce >= firstNonPrimary {\n-\t\treturn 0\n+\t\tif ce > lastSpecialPrimary {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn int(uint16(ce))\n \t}\n \treturn int(ce&primaryValueMask) >> primaryShift\n }\n \n-func (ce colElem) secondary() int {\n+// Secondary returns the secondary collation weight for ce.\n+func (ce Elem) Secondary() int {\n \tswitch ce & ceTypeMask {\n \tcase ceType1:\n \t\treturn int(uint8(ce))\n \tcase ceType2:\n \t\treturn minCompactSecondary + int((ce>>compactSecondaryShift)&0xF)\n-\tcase ceType3:\n-\t\treturn int(uint16(ce >> 8))\n+\tcase ceType3or4:\n+\t\tif ce < ceType4 {\n+\t\t\treturn defaultSecondary\n+\t\t}\n+\t\treturn int(ce>>8) & 0xFFF\n \tcase ceTypeQ:\n \t\treturn 0\n \t}\n \tpanic(\"should not reach here\")\n }\n \n-func (ce colElem) tertiary() uint8 {\n+// Tertiary returns the tertiary collation weight for ce.\n+func (ce Elem) Tertiary() uint8 {\n \tif ce&hasTertiaryMask == 0 {\n-\t\tif ce&ceType3 == 0 {\n+\t\tif ce&ceType3or4 == 0 {\n \t\t\treturn uint8(ce & 0x1F)\n \t\t}\n-\t\treturn uint8(ce)\n+\t\tif ce&ceType4 == ceType4 {\n+\t\t\treturn uint8(ce)\n+\t\t}\n+\t\treturn uint8(ce>>24) & 0x1F // type 2\n \t} else if ce&ceTypeMask == ceType1 {\n \t\treturn defaultTertiary\n \t}\n \t// ce is a quaternary value.\n \treturn 0\n }\n \n-func (ce colElem) updateTertiary(t uint8) colElem {\n+func (ce Elem) updateTertiary(t uint8) Elem {\n \tif ce&ceTypeMask == ceType1 {\n+\t\t// convert to type 4\n \t\tnce := ce & primaryValueMask\n-\t\tnce |= colElem(uint8(ce)-minCompactSecondary) << compactSecondaryShift\n+\t\tnce |= Elem(uint8(ce)-minCompactSecondary) << compactSecondaryShift\n \t\tce = nce\n+\t} else if ce&ceTypeMaskExt == ceType3or4 {\n+\t\tce &= ^Elem(maxTertiary << 24)\n+\t\treturn ce | (Elem(t) << 24)\n \t} else {\n-\t\tce &= ^colElem(maxTertiary)\n+\t\t// type 2 or 4\n+\t\tce &= ^Elem(maxTertiary)\n \t}\n-\treturn ce | colElem(t)\n+\treturn ce | Elem(t)\n }\n \n-// quaternary returns the quaternary value if explicitly specified,\n-// 0 if ce == ceIgnore, or maxQuaternary otherwise.\n+// Quaternary returns the quaternary value if explicitly specified,\n+// 0 if ce == ceIgnore, or MaxQuaternary otherwise.\n // Quaternary values are used only for shifted variants.\n-func (ce colElem) quaternary() int {\n+func (ce Elem) Quaternary() int {\n \tif ce&ceTypeMask == ceTypeQ {\n \t\treturn int(ce&primaryValueMask) >> primaryShift\n \t} else if ce == ceIgnore {\n \t\treturn 0\n \t}\n-\treturn maxQuaternary\n+\treturn MaxQuaternary\n+}\n+\n+// Weight returns the collation weight for the given level.\n+func (ce Elem) Weight(l Level) int {\n+\tswitch l {\n+\tcase Primary:\n+\t\treturn ce.Primary()\n+\tcase Secondary:\n+\t\treturn ce.Secondary()\n+\tcase Tertiary:\n+\t\treturn int(ce.Tertiary())\n+\tcase Quaternary:\n+\t\treturn ce.Quaternary()\n+\t}\n+\treturn 0 // return 0 (ignore) for undefined levels.\n }\n \n // For contractions, collation elements are of the form\n@@ -167,7 +249,7 @@ const (\n \tmaxContractOffsetBits = 13\n )\n \n-func splitContractIndex(ce colElem) (index, n, offset int) {\n+func splitContractIndex(ce Elem) (index, n, offset int) {\n \tn = int(ce & (1<<maxNBits - 1))\n \tce >>= maxNBits\n \tindex = int(ce & (1<<maxTrieIndexBits - 1))\n@@ -176,23 +258,23 @@ func splitContractIndex(ce colElem) (index, n, offset int) {\n \treturn\n }\n \n-// For expansions, colElems are of the form 11100000 00000000 bbbbbbbb bbbbbbbb,\n+// For expansions, Elems are of the form 11100000 00000000 bbbbbbbb bbbbbbbb,\n // where b* is the index into the expansion sequence table.\n const maxExpandIndexBits = 16\n \n-func splitExpandIndex(ce colElem) (index int) {\n+func splitExpandIndex(ce Elem) (index int) {\n \treturn int(uint16(ce))\n }\n \n // Some runes can be expanded using NFKD decomposition. Instead of storing the full\n // sequence of collation elements, we decompose the rune and lookup the collation\n // elements for each rune in the decomposition and modify the tertiary weights.\n-// The colElem, in this case, is of the form 11110000 00000000 wwwwwwww vvvvvvvv, where\n+// The Elem, in this case, is of the form 11110000 00000000 wwwwwwww vvvvvvvv, where\n //   - v* is the replacement tertiary weight for the first rune,\n //   - w* is the replacement tertiary weight for the second rune,\n // Tertiary weights of subsequent runes should be replaced with maxTertiary.\n // See http://www.unicode.org/reports/tr10/#Compatibility_Decompositions for more details.\n-func splitDecompose(ce colElem) (t1, t2 uint8) {\n+func splitDecompose(ce Elem) (t1, t2 uint8) {\n \treturn uint8(ce), uint8(ce >> 8)\n }\n "}, {"sha": "374c4487976a188081cd1ac7f2f56fd9b18edc7e", "filename": "libgo/go/exp/locale/collate/colelem_test.go", "status": "modified", "additions": 121, "deletions": 33, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -10,85 +10,94 @@ import (\n )\n \n type ceTest struct {\n-\tf   func(inout []int) (colElem, ceType)\n+\tf   func(inout []int) (Elem, ceType)\n \targ []int\n }\n \n // The make* funcs are simplified versions of the functions in build/colelem.go\n-func makeCE(weights []int) colElem {\n+func makeCE(weights []int) Elem {\n \tconst (\n \t\tmaxPrimaryBits          = 21\n \t\tmaxSecondaryBits        = 12\n \t\tmaxSecondaryCompactBits = 8\n \t\tmaxSecondaryDiffBits    = 4\n \t\tmaxTertiaryBits         = 8\n \t\tmaxTertiaryCompactBits  = 5\n-\t\tisSecondary             = 0x80000000\n \t\tisPrimary               = 0x40000000\n+\t\tisPrimaryCCC            = 0x80000000\n+\t\tisSecondary             = 0xA0000000\n \t)\n-\tvar ce colElem\n+\tvar ce Elem\n+\tccc := weights[3]\n \tif weights[0] != 0 {\n-\t\tif weights[2] == defaultTertiary {\n-\t\t\tce = colElem(weights[0]<<(maxSecondaryCompactBits+1) + weights[1])\n+\t\tif ccc != 0 {\n+\t\t\tce = Elem(weights[2] << 24)\n+\t\t\tce |= Elem(ccc) << 16\n+\t\t\tce |= Elem(weights[0])\n+\t\t\tce |= isPrimaryCCC\n+\t\t} else if weights[2] == defaultTertiary {\n+\t\t\tce = Elem(weights[0]<<(maxSecondaryCompactBits+1) + weights[1])\n \t\t\tce |= isPrimary\n \t\t} else {\n \t\t\td := weights[1] - defaultSecondary + 4\n-\t\t\tce = colElem(weights[0]<<maxSecondaryDiffBits + d)\n-\t\t\tce = ce<<maxTertiaryCompactBits + colElem(weights[2])\n+\t\t\tce = Elem(weights[0]<<maxSecondaryDiffBits + d)\n+\t\t\tce = ce<<maxTertiaryCompactBits + Elem(weights[2])\n \t\t}\n \t} else {\n-\t\tce = colElem(weights[1]<<maxTertiaryBits + weights[2])\n+\t\tce = Elem(weights[1]<<maxTertiaryBits + weights[2])\n+\t\tce += Elem(ccc) << 20\n \t\tce |= isSecondary\n \t}\n \treturn ce\n }\n \n-func makeContractIndex(index, n, offset int) colElem {\n+func makeContractIndex(index, n, offset int) Elem {\n \tconst (\n \t\tcontractID            = 0xC0000000\n \t\tmaxNBits              = 4\n \t\tmaxTrieIndexBits      = 12\n \t\tmaxContractOffsetBits = 13\n \t)\n-\tce := colElem(contractID)\n-\tce += colElem(offset << (maxNBits + maxTrieIndexBits))\n-\tce += colElem(index << maxNBits)\n-\tce += colElem(n)\n+\tce := Elem(contractID)\n+\tce += Elem(offset << (maxNBits + maxTrieIndexBits))\n+\tce += Elem(index << maxNBits)\n+\tce += Elem(n)\n \treturn ce\n }\n \n-func makeExpandIndex(index int) colElem {\n+func makeExpandIndex(index int) Elem {\n \tconst expandID = 0xE0000000\n-\treturn expandID + colElem(index)\n+\treturn expandID + Elem(index)\n }\n \n-func makeDecompose(t1, t2 int) colElem {\n+func makeDecompose(t1, t2 int) Elem {\n \tconst decompID = 0xF0000000\n-\treturn colElem(t2<<8+t1) + decompID\n+\treturn Elem(t2<<8+t1) + decompID\n }\n \n-func normalCE(inout []int) (ce colElem, t ceType) {\n-\tw := makeCE(inout)\n-\tinout[0] = w.primary()\n-\tinout[1] = w.secondary()\n-\tinout[2] = int(w.tertiary())\n+func normalCE(inout []int) (ce Elem, t ceType) {\n+\tce = makeCE(inout)\n+\tinout[0] = ce.Primary()\n+\tinout[1] = ce.Secondary()\n+\tinout[2] = int(ce.Tertiary())\n+\tinout[3] = int(ce.CCC())\n \treturn ce, ceNormal\n }\n \n-func expandCE(inout []int) (ce colElem, t ceType) {\n+func expandCE(inout []int) (ce Elem, t ceType) {\n \tce = makeExpandIndex(inout[0])\n \tinout[0] = splitExpandIndex(ce)\n \treturn ce, ceExpansionIndex\n }\n \n-func contractCE(inout []int) (ce colElem, t ceType) {\n+func contractCE(inout []int) (ce Elem, t ceType) {\n \tce = makeContractIndex(inout[0], inout[1], inout[2])\n \ti, n, o := splitContractIndex(ce)\n \tinout[0], inout[1], inout[2] = i, n, o\n \treturn ce, ceContractionIndex\n }\n \n-func decompCE(inout []int) (ce colElem, t ceType) {\n+func decompCE(inout []int) (ce Elem, t ceType) {\n \tce = makeDecompose(inout[0], inout[1])\n \tt1, t2 := splitDecompose(ce)\n \tinout[0], inout[1] = int(t1), int(t2)\n@@ -102,9 +111,13 @@ const (\n )\n \n var ceTests = []ceTest{\n-\t{normalCE, []int{0, 0, 0}},\n-\t{normalCE, []int{0, 30, 3}},\n-\t{normalCE, []int{100, defaultSecondary, 3}},\n+\t{normalCE, []int{0, 0, 0, 0}},\n+\t{normalCE, []int{0, 30, 3, 0}},\n+\t{normalCE, []int{0, 30, 3, 0xFF}},\n+\t{normalCE, []int{100, defaultSecondary, defaultTertiary, 0}},\n+\t{normalCE, []int{100, defaultSecondary, defaultTertiary, 0xFF}},\n+\t{normalCE, []int{100, defaultSecondary, 3, 0}},\n+\t{normalCE, []int{0x123, defaultSecondary, 8, 0xFF}},\n \n \t{contractCE, []int{0, 0, 0}},\n \t{contractCE, []int{1, 1, 1}},\n@@ -127,11 +140,11 @@ func TestColElem(t *testing.T) {\n \t\tcopy(inout, tt.arg)\n \t\tce, typ := tt.f(inout)\n \t\tif ce.ctype() != typ {\n-\t\t\tt.Errorf(\"%d: type is %d; want %d\", i, ce.ctype(), typ)\n+\t\t\tt.Errorf(\"%d: type is %d; want %d (ColElem: %X)\", i, ce.ctype(), typ, ce)\n \t\t}\n \t\tfor j, a := range tt.arg {\n \t\t\tif inout[j] != a {\n-\t\t\t\tt.Errorf(\"%d: argument %d is %X; want %X\", i, j, inout[j], a)\n+\t\t\t\tt.Errorf(\"%d: argument %d is %X; want %X (ColElem: %X)\", i, j, inout[j], a, ce)\n \t\t\t}\n \t\t}\n \t}\n@@ -170,17 +183,92 @@ func TestImplicit(t *testing.T) {\n \n func TestUpdateTertiary(t *testing.T) {\n \ttests := []struct {\n-\t\tin, out colElem\n+\t\tin, out Elem\n \t\tt       uint8\n \t}{\n \t\t{0x4000FE20, 0x0000FE8A, 0x0A},\n \t\t{0x4000FE21, 0x0000FEAA, 0x0A},\n \t\t{0x0000FE8B, 0x0000FE83, 0x03},\n-\t\t{0x8000CC02, 0x8000CC1B, 0x1B},\n+\t\t{0x82FF0188, 0x9BFF0188, 0x1B},\n+\t\t{0xAFF0CC02, 0xAFF0CC1B, 0x1B},\n \t}\n \tfor i, tt := range tests {\n \t\tif out := tt.in.updateTertiary(tt.t); out != tt.out {\n \t\t\tt.Errorf(\"%d: was %X; want %X\", i, out, tt.out)\n \t\t}\n \t}\n }\n+\n+func TestDoNorm(t *testing.T) {\n+\tconst div = -1 // The insertion point of the next block.\n+\ttests := []struct {\n+\t\tin, out []int\n+\t}{\n+\t\t{in: []int{4, div, 3},\n+\t\t\tout: []int{3, 4},\n+\t\t},\n+\t\t{in: []int{4, div, 3, 3, 3},\n+\t\t\tout: []int{3, 3, 3, 4},\n+\t\t},\n+\t\t{in: []int{0, 4, div, 3},\n+\t\t\tout: []int{0, 3, 4},\n+\t\t},\n+\t\t{in: []int{0, 0, 4, 5, div, 3, 3},\n+\t\t\tout: []int{0, 0, 3, 3, 4, 5},\n+\t\t},\n+\t\t{in: []int{0, 0, 1, 4, 5, div, 3, 3},\n+\t\t\tout: []int{0, 0, 1, 3, 3, 4, 5},\n+\t\t},\n+\t\t{in: []int{0, 0, 1, 4, 5, div, 4, 4},\n+\t\t\tout: []int{0, 0, 1, 4, 4, 4, 5},\n+\t\t},\n+\t}\n+\tfor j, tt := range tests {\n+\t\ti := iter{}\n+\t\tvar w, p, s int\n+\t\tfor k, cc := range tt.in {\n+\t\t\tif cc == 0 {\n+\t\t\t\ts = 0\n+\t\t\t}\n+\t\t\tif cc == div {\n+\t\t\t\tw = 100\n+\t\t\t\tp = k\n+\t\t\t\ti.pStarter = s\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ti.ce = append(i.ce, makeCE([]int{w, 20, 2, cc}))\n+\t\t}\n+\t\ti.prevCCC = i.ce[p-1].CCC()\n+\t\ti.doNorm(p, i.ce[p].CCC())\n+\t\tif len(i.ce) != len(tt.out) {\n+\t\t\tt.Errorf(\"%d: length was %d; want %d\", j, len(i.ce), len(tt.out))\n+\t\t}\n+\t\tprevCCC := uint8(0)\n+\t\tfor k, ce := range i.ce {\n+\t\t\tif int(ce.CCC()) != tt.out[k] {\n+\t\t\t\tt.Errorf(\"%d:%d: unexpected CCC. Was %d; want %d\", j, k, ce.CCC(), tt.out[k])\n+\t\t\t}\n+\t\t\tif k > 0 && ce.CCC() == prevCCC && i.ce[k-1].Primary() > ce.Primary() {\n+\t\t\t\tt.Errorf(\"%d:%d: normalization crossed across CCC boundary.\", j, k)\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// test cutoff of large sequence of combining characters.\n+\tresult := []uint8{8, 8, 8, 5, 5}\n+\tfor o := -2; o <= 2; o++ {\n+\t\ti := iter{pStarter: 2, prevCCC: 8}\n+\t\tn := maxCombiningCharacters + 1 + o\n+\t\tfor j := 1; j < n+i.pStarter; j++ {\n+\t\t\ti.ce = append(i.ce, makeCE([]int{100, 20, 2, 8}))\n+\t\t}\n+\t\tp := len(i.ce)\n+\t\ti.ce = append(i.ce, makeCE([]int{0, 20, 2, 5}))\n+\t\ti.doNorm(p, 5)\n+\t\tif i.prevCCC != result[o+2] {\n+\t\t\tt.Errorf(\"%d: i.prevCCC was %d; want %d\", n, i.prevCCC, result[o+2])\n+\t\t}\n+\t\tif result[o+2] == 5 && i.pStarter != p {\n+\t\t\tt.Errorf(\"%d: i.pStarter was %d; want %d\", n, i.pStarter, p)\n+\t\t}\n+\t}\n+}"}, {"sha": "2cb29f24b740901dc33274c65b31d3c1d9af7a15", "filename": "libgo/go/exp/locale/collate/collate.go", "status": "modified", "additions": 178, "deletions": 101, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -12,22 +12,6 @@ import (\n \t\"exp/norm\"\n )\n \n-// Level identifies the collation comparison level.\n-// The primary level corresponds to the basic sorting of text.\n-// The secondary level corresponds to accents and related linguistic elements.\n-// The tertiary level corresponds to casing and related concepts.\n-// The quaternary level is derived from the other levels by the\n-// various algorithms for handling variable elements.\n-type Level int\n-\n-const (\n-\tPrimary Level = iota\n-\tSecondary\n-\tTertiary\n-\tQuaternary\n-\tIdentity\n-)\n-\n // AlternateHandling identifies the various ways in which variables are handled.\n // A rune with a primary weight lower than the variable top is considered a\n // variable.\n@@ -55,6 +39,12 @@ const (\n // Collator provides functionality for comparing strings for a given\n // collation order.\n type Collator struct {\n+\t// TODO: hide most of these options. Low-level options are set through the locale\n+\t// identifier (as defined by LDML) while high-level options are set through SetOptions.\n+\t// Using high-level options allows us to be more flexible (such as not ignoring\n+\t// Thai vowels for IgnoreDiacriticals) and more user-friendly (such as allowing\n+\t// diacritical marks to be ignored but not case without having to fiddle with levels).\n+\n \t// Strength sets the maximum level to use in comparison.\n \tStrength Level\n \n@@ -80,13 +70,39 @@ type Collator struct {\n \t// at a primary level with its numeric value.  For example, \"A-21\" < \"A-123\".\n \tNumeric bool\n \n+\t// The largest primary value that is considered to be variable.\n+\tvariableTop uint32\n+\n \tf norm.Form\n \n-\tt *table\n+\tt Weigher\n+\n+\tsorter sorter\n \n \t_iter [2]iter\n }\n \n+// An Option is used to change the behavior of Collator.  They override the\n+// settings passed through the locale identifier.\n+type Option int\n+\n+const (\n+\tNumeric          Option = 1 << iota // Sort numbers numerically (\"2\" < \"12\").\n+\tIgnoreCase                          // Case-insensitive search.\n+\tIgnoreDiacritics                    // Ignore diacritical marks. (\"o\" == \"\u00f6\").\n+\tIgnoreWidth                         // Ignore full versus normal width.\n+\tUpperFirst                          // Sort upper case before lower case.\n+\tLowerFirst                          // Sort lower case before upper case.\n+\tForce                               // Force ordering if strings are equivalent but not equal.\n+\n+\tLoose = IgnoreDiacritics | IgnoreWidth | IgnoreCase\n+)\n+\n+// SetOptions accepts a Options or-ed together.  All previous calls to SetOptions are ignored.\n+func (c *Collator) SetOptions(o Option) {\n+\t// TODO: implement\n+}\n+\n func (c *Collator) iter(i int) *iter {\n \t// TODO: evaluate performance for making the second iterator optional.\n \treturn &c._iter[i]\n@@ -101,18 +117,20 @@ func Locales() []string {\n // New returns a new Collator initialized for the given locale.\n func New(loc string) *Collator {\n \t// TODO: handle locale selection according to spec.\n-\tt := &mainTable\n+\tvar t tableIndex\n \tif loc != \"\" {\n \t\tif idx, ok := locales[loc]; ok {\n-\t\t\tt = mainTable.indexedTable(idx)\n+\t\t\tt = idx\n+\t\t} else {\n+\t\t\tt = locales[\"root\"]\n \t\t}\n \t}\n-\treturn newCollator(t)\n+\treturn NewFromTable(Init(t))\n }\n \n-func newCollator(t *table) *Collator {\n+func NewFromTable(t Weigher) *Collator {\n \tc := &Collator{\n-\t\tStrength: Quaternary,\n+\t\tStrength: Tertiary,\n \t\tf:        norm.NFD,\n \t\tt:        t,\n \t}\n@@ -121,12 +139,6 @@ func newCollator(t *table) *Collator {\n \treturn c\n }\n \n-// SetVariableTop sets all runes with primary strength less than the primary\n-// strength of r to be variable and thus affected by alternate handling.\n-func (c *Collator) SetVariableTop(r rune) {\n-\t// TODO: implement\n-}\n-\n // Buffer holds keys generated by Key and KeyString.\n type Buffer struct {\n \tbuf [4096]byte\n@@ -149,8 +161,8 @@ func (b *Buffer) Reset() {\n func (c *Collator) Compare(a, b []byte) int {\n \t// TODO: skip identical prefixes once we have a fast way to detect if a rune is\n \t// part of a contraction. This would lead to roughly a 10% speedup for the colcmp regtest.\n-\tc.iter(0).setInput(c, a)\n-\tc.iter(1).setInput(c, b)\n+\tc.iter(0).setInput(a)\n+\tc.iter(1).setInput(b)\n \tif res := c.compare(); res != 0 {\n \t\treturn res\n \t}\n@@ -165,8 +177,8 @@ func (c *Collator) Compare(a, b []byte) int {\n func (c *Collator) CompareString(a, b string) int {\n \t// TODO: skip identical prefixes once we have a fast way to detect if a rune is\n \t// part of a contraction. This would lead to roughly a 10% speedup for the colcmp regtest.\n-\tc.iter(0).setInputString(c, a)\n-\tc.iter(1).setInputString(c, b)\n+\tc.iter(0).setInputString(a)\n+\tc.iter(1).setInputString(b)\n \tif res := c.compare(); res != 0 {\n \t\treturn res\n \t}\n@@ -234,11 +246,6 @@ func (c *Collator) compare() int {\n \treturn 0\n }\n \n-func (c *Collator) Prefix(s, prefix []byte) int {\n-\t// iterate over s, track bytes consumed.\n-\treturn 0\n-}\n-\n // Key returns the collation key for str.\n // Passing the buffer buf may avoid memory allocations.\n // The returned slice will point to an allocation in Buffer and will remain\n@@ -259,114 +266,184 @@ func (c *Collator) KeyFromString(buf *Buffer, str string) []byte {\n \treturn c.key(buf, c.getColElemsString(str))\n }\n \n-func (c *Collator) key(buf *Buffer, w []colElem) []byte {\n-\tprocessWeights(c.Alternate, c.t.variableTop, w)\n+func (c *Collator) key(buf *Buffer, w []Elem) []byte {\n+\tprocessWeights(c.Alternate, c.variableTop, w)\n \tkn := len(buf.key)\n \tc.keyFromElems(buf, w)\n \treturn buf.key[kn:]\n }\n \n-func (c *Collator) getColElems(str []byte) []colElem {\n+func (c *Collator) getColElems(str []byte) []Elem {\n \ti := c.iter(0)\n-\ti.setInput(c, str)\n-\tfor !i.done() {\n-\t\ti.next()\n+\ti.setInput(str)\n+\tfor i.next() {\n \t}\n \treturn i.ce\n }\n \n-func (c *Collator) getColElemsString(str string) []colElem {\n+func (c *Collator) getColElemsString(str string) []Elem {\n \ti := c.iter(0)\n-\ti.setInputString(c, str)\n-\tfor !i.done() {\n-\t\ti.next()\n+\ti.setInputString(str)\n+\tfor i.next() {\n \t}\n \treturn i.ce\n }\n \n type iter struct {\n-\tsrc        norm.Iter\n-\tnorm       [1024]byte\n-\tbuf        []byte\n-\tp          int\n-\tminBufSize int\n-\n-\twa  [512]colElem\n-\tce  []colElem\n+\tbytes []byte\n+\tstr   string\n+\n+\twa  [512]Elem\n+\tce  []Elem\n \tpce int\n+\tnce int // nce <= len(nce)\n \n-\tt          *table\n-\t_done, eof bool\n+\tprevCCC  uint8\n+\tpStarter int\n+\n+\tt Weigher\n }\n \n func (i *iter) init(c *Collator) {\n \ti.t = c.t\n-\ti.minBufSize = c.t.maxContractLen\n \ti.ce = i.wa[:0]\n-\ti.buf = i.norm[:0]\n }\n \n func (i *iter) reset() {\n \ti.ce = i.ce[:0]\n-\ti.buf = i.buf[:0]\n-\ti.p = 0\n-\ti.eof = i.src.Done()\n-\ti._done = i.eof\n+\ti.nce = 0\n+\ti.prevCCC = 0\n+\ti.pStarter = 0\n }\n \n-func (i *iter) setInput(c *Collator, s []byte) *iter {\n-\ti.src.SetInput(c.f, s)\n+func (i *iter) setInput(s []byte) *iter {\n+\ti.bytes = s\n+\ti.str = \"\"\n \ti.reset()\n \treturn i\n }\n \n-func (i *iter) setInputString(c *Collator, s string) *iter {\n-\ti.src.SetInputString(c.f, s)\n+func (i *iter) setInputString(s string) *iter {\n+\ti.str = s\n+\ti.bytes = nil\n \ti.reset()\n \treturn i\n }\n \n func (i *iter) done() bool {\n-\treturn i._done\n+\treturn len(i.str) == 0 && len(i.bytes) == 0\n }\n \n-func (i *iter) next() {\n-\tif !i.eof && len(i.buf)-i.p < i.minBufSize {\n-\t\t// replenish buffer\n-\t\tn := copy(i.buf, i.buf[i.p:])\n-\t\tn += i.src.Next(i.buf[n:cap(i.buf)])\n-\t\ti.buf = i.buf[:n]\n-\t\ti.p = 0\n-\t\ti.eof = i.src.Done()\n+func (i *iter) tail(n int) {\n+\tif i.bytes == nil {\n+\t\ti.str = i.str[n:]\n+\t} else {\n+\t\ti.bytes = i.bytes[n:]\n \t}\n-\tif i.p == len(i.buf) {\n-\t\ti._done = true\n+}\n+\n+func (i *iter) appendNext() int {\n+\tvar sz int\n+\tif i.bytes == nil {\n+\t\ti.ce, sz = i.t.AppendNextString(i.ce, i.str)\n+\t} else {\n+\t\ti.ce, sz = i.t.AppendNext(i.ce, i.bytes)\n+\t}\n+\treturn sz\n+}\n+\n+// next appends Elems to the internal array until it adds an element with CCC=0.\n+// In the majority of cases, a Elem with a primary value > 0 will have\n+// a CCC of 0. The CCC values of colation elements are also used to detect if the\n+// input string was not normalized and to adjust the result accordingly.\n+func (i *iter) next() bool {\n+\tfor !i.done() {\n+\t\tp0 := len(i.ce)\n+\t\tsz := i.appendNext()\n+\t\ti.tail(sz)\n+\t\tlast := len(i.ce) - 1\n+\t\tif ccc := i.ce[last].CCC(); ccc == 0 {\n+\t\t\ti.nce = len(i.ce)\n+\t\t\ti.pStarter = last\n+\t\t\ti.prevCCC = 0\n+\t\t\treturn true\n+\t\t} else if p0 < last && i.ce[p0].CCC() == 0 {\n+\t\t\t// set i.nce to only cover part of i.ce for which ccc == 0 and\n+\t\t\t// use rest the next call to next.\n+\t\t\tfor p0++; p0 < last && i.ce[p0].CCC() == 0; p0++ {\n+\t\t\t}\n+\t\t\ti.nce = p0\n+\t\t\ti.pStarter = p0 - 1\n+\t\t\ti.prevCCC = ccc\n+\t\t\treturn true\n+\t\t} else if ccc < i.prevCCC {\n+\t\t\ti.doNorm(p0, ccc) // should be rare for most common cases\n+\t\t} else {\n+\t\t\ti.prevCCC = ccc\n+\t\t}\n+\t}\n+\tif len(i.ce) != i.nce {\n+\t\ti.nce = len(i.ce)\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// nextPlain is the same as next, but does not \"normalize\" the collation\n+// elements.\n+// TODO: remove this function. Using this instead of next does not seem\n+// to improve performance in any significant way. We retain this until\n+// later for evaluation purposes.\n+func (i *iter) nextPlain() bool {\n+\tif i.done() {\n+\t\treturn false\n+\t}\n+\tsz := i.appendNext()\n+\ti.tail(sz)\n+\ti.nce = len(i.ce)\n+\treturn true\n+}\n+\n+const maxCombiningCharacters = 30\n+\n+// doNorm reorders the collation elements in i.ce.\n+// It assumes that blocks of collation elements added with appendNext\n+// either start and end with the same CCC or start with CCC == 0.\n+// This allows for a single insertion point for the entire block.\n+// The correctness of this assumption is verified in builder.go.\n+func (i *iter) doNorm(p int, ccc uint8) {\n+\tif p-i.pStarter > maxCombiningCharacters {\n+\t\ti.prevCCC = i.ce[len(i.ce)-1].CCC()\n+\t\ti.pStarter = len(i.ce) - 1\n \t\treturn\n \t}\n-\tsz := 0\n-\ti.ce, sz = i.t.appendNext(i.ce, i.buf[i.p:])\n-\ti.p += sz\n+\tn := len(i.ce)\n+\tk := p\n+\tfor p--; p > i.pStarter && ccc < i.ce[p-1].CCC(); p-- {\n+\t}\n+\ti.ce = append(i.ce, i.ce[p:k]...)\n+\tcopy(i.ce[p:], i.ce[k:])\n+\ti.ce = i.ce[:n]\n }\n \n func (i *iter) nextPrimary() int {\n \tfor {\n-\t\tfor ; i.pce < len(i.ce); i.pce++ {\n-\t\t\tif v := i.ce[i.pce].primary(); v != 0 {\n+\t\tfor ; i.pce < i.nce; i.pce++ {\n+\t\t\tif v := i.ce[i.pce].Primary(); v != 0 {\n \t\t\t\ti.pce++\n \t\t\t\treturn v\n \t\t\t}\n \t\t}\n-\t\tif i.done() {\n+\t\tif !i.next() {\n \t\t\treturn 0\n \t\t}\n-\t\ti.next()\n \t}\n \tpanic(\"should not reach here\")\n }\n \n func (i *iter) nextSecondary() int {\n \tfor ; i.pce < len(i.ce); i.pce++ {\n-\t\tif v := i.ce[i.pce].secondary(); v != 0 {\n+\t\tif v := i.ce[i.pce].Secondary(); v != 0 {\n \t\t\ti.pce++\n \t\t\treturn v\n \t\t}\n@@ -376,7 +453,7 @@ func (i *iter) nextSecondary() int {\n \n func (i *iter) prevSecondary() int {\n \tfor ; i.pce < len(i.ce); i.pce++ {\n-\t\tif v := i.ce[len(i.ce)-i.pce-1].secondary(); v != 0 {\n+\t\tif v := i.ce[len(i.ce)-i.pce-1].Secondary(); v != 0 {\n \t\t\ti.pce++\n \t\t\treturn v\n \t\t}\n@@ -386,7 +463,7 @@ func (i *iter) prevSecondary() int {\n \n func (i *iter) nextTertiary() int {\n \tfor ; i.pce < len(i.ce); i.pce++ {\n-\t\tif v := i.ce[i.pce].tertiary(); v != 0 {\n+\t\tif v := i.ce[i.pce].Tertiary(); v != 0 {\n \t\t\ti.pce++\n \t\t\treturn int(v)\n \t\t}\n@@ -396,7 +473,7 @@ func (i *iter) nextTertiary() int {\n \n func (i *iter) nextQuaternary() int {\n \tfor ; i.pce < len(i.ce); i.pce++ {\n-\t\tif v := i.ce[i.pce].quaternary(); v != 0 {\n+\t\tif v := i.ce[i.pce].Quaternary(); v != 0 {\n \t\t\ti.pce++\n \t\t\treturn v\n \t\t}\n@@ -416,9 +493,9 @@ func appendPrimary(key []byte, p int) []byte {\n \n // keyFromElems converts the weights ws to a compact sequence of bytes.\n // The result will be appended to the byte buffer in buf.\n-func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n+func (c *Collator) keyFromElems(buf *Buffer, ws []Elem) {\n \tfor _, v := range ws {\n-\t\tif w := v.primary(); w > 0 {\n+\t\tif w := v.Primary(); w > 0 {\n \t\t\tbuf.key = appendPrimary(buf.key, w)\n \t\t}\n \t}\n@@ -427,13 +504,13 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \t\t// TODO: we can use one 0 if we can guarantee that all non-zero weights are > 0xFF.\n \t\tif !c.Backwards {\n \t\t\tfor _, v := range ws {\n-\t\t\t\tif w := v.secondary(); w > 0 {\n+\t\t\t\tif w := v.Secondary(); w > 0 {\n \t\t\t\t\tbuf.key = append(buf.key, uint8(w>>8), uint8(w))\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor i := len(ws) - 1; i >= 0; i-- {\n-\t\t\t\tif w := ws[i].secondary(); w > 0 {\n+\t\t\t\tif w := ws[i].Secondary(); w > 0 {\n \t\t\t\t\tbuf.key = append(buf.key, uint8(w>>8), uint8(w))\n \t\t\t\t}\n \t\t\t}\n@@ -444,20 +521,20 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \tif Tertiary <= c.Strength || c.CaseLevel {\n \t\tbuf.key = append(buf.key, 0, 0)\n \t\tfor _, v := range ws {\n-\t\t\tif w := v.tertiary(); w > 0 {\n+\t\t\tif w := v.Tertiary(); w > 0 {\n \t\t\t\tbuf.key = append(buf.key, uint8(w))\n \t\t\t}\n \t\t}\n \t\t// Derive the quaternary weights from the options and other levels.\n-\t\t// Note that we represent maxQuaternary as 0xFF. The first byte of the\n+\t\t// Note that we represent MaxQuaternary as 0xFF. The first byte of the\n \t\t// representation of a primary weight is always smaller than 0xFF,\n \t\t// so using this single byte value will compare correctly.\n \t\tif Quaternary <= c.Strength && c.Alternate >= AltShifted {\n \t\t\tif c.Alternate == AltShiftTrimmed {\n \t\t\t\tlastNonFFFF := len(buf.key)\n \t\t\t\tbuf.key = append(buf.key, 0)\n \t\t\t\tfor _, v := range ws {\n-\t\t\t\t\tif w := v.quaternary(); w == maxQuaternary {\n+\t\t\t\t\tif w := v.Quaternary(); w == MaxQuaternary {\n \t\t\t\t\t\tbuf.key = append(buf.key, 0xFF)\n \t\t\t\t\t} else if w > 0 {\n \t\t\t\t\t\tbuf.key = appendPrimary(buf.key, w)\n@@ -468,7 +545,7 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \t\t\t} else {\n \t\t\t\tbuf.key = append(buf.key, 0)\n \t\t\t\tfor _, v := range ws {\n-\t\t\t\t\tif w := v.quaternary(); w == maxQuaternary {\n+\t\t\t\t\tif w := v.Quaternary(); w == MaxQuaternary {\n \t\t\t\t\t\tbuf.key = append(buf.key, 0xFF)\n \t\t\t\t\t} else if w > 0 {\n \t\t\t\t\t\tbuf.key = appendPrimary(buf.key, w)\n@@ -479,14 +556,14 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \t}\n }\n \n-func processWeights(vw AlternateHandling, top uint32, wa []colElem) {\n+func processWeights(vw AlternateHandling, top uint32, wa []Elem) {\n \tignore := false\n \tvtop := int(top)\n \tswitch vw {\n \tcase AltShifted, AltShiftTrimmed:\n \t\tfor i := range wa {\n-\t\t\tif p := wa[i].primary(); p <= vtop && p != 0 {\n-\t\t\t\twa[i] = makeQuaternary(p)\n+\t\t\tif p := wa[i].Primary(); p <= vtop && p != 0 {\n+\t\t\t\twa[i] = MakeQuaternary(p)\n \t\t\t\tignore = true\n \t\t\t} else if p == 0 {\n \t\t\t\tif ignore {\n@@ -498,7 +575,7 @@ func processWeights(vw AlternateHandling, top uint32, wa []colElem) {\n \t\t}\n \tcase AltBlanked:\n \t\tfor i := range wa {\n-\t\t\tif p := wa[i].primary(); p <= vtop && (ignore || p != 0) {\n+\t\t\tif p := wa[i].Primary(); p <= vtop && (ignore || p != 0) {\n \t\t\t\twa[i] = ceIgnore\n \t\t\t\tignore = true\n \t\t\t} else {"}, {"sha": "cdb213ffe4d8f34078c9c4930f1b0c50e3148e37", "filename": "libgo/go/exp/locale/collate/colltab.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolltab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolltab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolltab.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package collate\n+\n+// A Weigher can be used as a source for Collator and Searcher.\n+type Weigher interface {\n+\t// Start finds the start of the segment that includes position p.\n+\tStart(p int, b []byte) int\n+\n+\t// StartString finds the start of the segment that includes position p.\n+\tStartString(p int, s string) int\n+\n+\t// AppendNext appends Elems to buf corresponding to the longest match\n+\t// of a single character or contraction from the start of s.\n+\t// It returns the new buf and the number of bytes consumed.\n+\tAppendNext(buf []Elem, s []byte) (ce []Elem, n int)\n+\n+\t// AppendNextString appends Elems to buf corresponding to the longest match\n+\t// of a single character or contraction from the start of s.\n+\t// It returns the new buf and the number of bytes consumed.\n+\tAppendNextString(buf []Elem, s string) (ce []Elem, n int)\n+\n+\t// Domain returns a slice of all single characters and contractions for which\n+\t// collation elements are defined in this table.\n+\tDomain() []string\n+}"}, {"sha": "7ce6b1f20ea665540e5bf0ff124f4821a32ad01e", "filename": "libgo/go/exp/locale/collate/contract.go", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -27,8 +27,21 @@ type ctScanner struct {\n \tdone   bool\n }\n \n+type ctScannerString struct {\n+\tstates contractTrieSet\n+\ts      string\n+\tn      int\n+\tindex  int\n+\tpindex int\n+\tdone   bool\n+}\n+\n func (t contractTrieSet) scanner(index, n int, b []byte) ctScanner {\n-\treturn ctScanner{states: t[index:], s: b, n: n}\n+\treturn ctScanner{s: b, states: t[index:], n: n}\n+}\n+\n+func (t contractTrieSet) scannerString(index, n int, str string) ctScannerString {\n+\treturn ctScannerString{s: str, states: t[index:], n: n}\n }\n \n // result returns the offset i and bytes consumed p so far.  If no suffix\n@@ -37,6 +50,10 @@ func (s *ctScanner) result() (i, p int) {\n \treturn s.index, s.pindex\n }\n \n+func (s *ctScannerString) result() (i, p int) {\n+\treturn s.index, s.pindex\n+}\n+\n const (\n \tfinal   = 0\n \tnoIndex = 0xFF\n@@ -84,3 +101,45 @@ func (s *ctScanner) scan(p int) int {\n \t}\n \treturn pr\n }\n+\n+// scan is a verbatim copy of ctScanner.scan.\n+func (s *ctScannerString) scan(p int) int {\n+\tpr := p // the p at the rune start\n+\tstr := s.s\n+\tstates, n := s.states, s.n\n+\tfor i := 0; i < n && p < len(str); {\n+\t\te := states[i]\n+\t\tc := str[p]\n+\t\t// TODO: a significant number of contractions are of a form that\n+\t\t// cannot match discontiguous UTF-8 in a normalized string. We could let\n+\t\t// a negative value of e.n mean that we can set s.done = true and avoid\n+\t\t// the need for additional matches.\n+\t\tif c >= e.l {\n+\t\t\tif e.l == c {\n+\t\t\t\tp++\n+\t\t\t\tif e.i != noIndex {\n+\t\t\t\t\ts.index = int(e.i)\n+\t\t\t\t\ts.pindex = p\n+\t\t\t\t}\n+\t\t\t\tif e.n != final {\n+\t\t\t\t\ti, states, n = 0, states[int(e.h)+n:], int(e.n)\n+\t\t\t\t\tif p >= len(str) || utf8.RuneStart(str[p]) {\n+\t\t\t\t\t\ts.states, s.n, pr = states, n, p\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\ts.done = true\n+\t\t\t\t\treturn p\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t} else if e.n == final && c <= e.h {\n+\t\t\t\tp++\n+\t\t\t\ts.done = true\n+\t\t\t\ts.index = int(c-e.l) + int(e.i)\n+\t\t\t\ts.pindex = p\n+\t\t\t\treturn p\n+\t\t\t}\n+\t\t}\n+\t\ti++\n+\t}\n+\treturn pr\n+}"}, {"sha": "8145dee25a9066187f1517f40faad13a44cc31e0", "filename": "libgo/go/exp/locale/collate/export.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -4,25 +4,24 @@\n \n package collate\n \n-// Init is used by type Builder in exp/locale/collate/build/\n-// to create Collator instances.  It is for internal use only.\n-func Init(data interface{}) *Collator {\n+// Init is for internal use only.\n+func Init(data interface{}) Weigher {\n \tinit, ok := data.(tableInitializer)\n \tif !ok {\n \t\treturn nil\n \t}\n \tt := &table{}\n \tloff, voff := init.FirstBlockOffsets()\n \tt.index.index = init.TrieIndex()\n-\tt.index.index0 = t.index.index[blockSize*loff:]\n+\tt.index.index0 = t.index.index[blockSize*int(loff):]\n \tt.index.values = init.TrieValues()\n-\tt.index.values0 = t.index.values[blockSize*voff:]\n+\tt.index.values0 = t.index.values[blockSize*int(voff):]\n \tt.expandElem = init.ExpandElems()\n \tt.contractTries = init.ContractTries()\n \tt.contractElem = init.ContractElems()\n \tt.maxContractLen = init.MaxContractLen()\n \tt.variableTop = init.VariableTop()\n-\treturn newCollator(t)\n+\treturn t\n }\n \n type tableInitializer interface {"}, {"sha": "3782144d83164c650dce8414dc51cec98ab15988", "filename": "libgo/go/exp/locale/collate/export_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -25,51 +25,51 @@ func W(ce ...int) Weights {\n \tif len(ce) > 3 {\n \t\tw.Quaternary = ce[3]\n \t} else if w.Tertiary != 0 {\n-\t\tw.Quaternary = maxQuaternary\n+\t\tw.Quaternary = MaxQuaternary\n \t}\n \treturn w\n }\n func (w Weights) String() string {\n-\treturn fmt.Sprintf(\"[%d.%d.%d.%d]\", w.Primary, w.Secondary, w.Tertiary, w.Quaternary)\n+\treturn fmt.Sprintf(\"[%X.%X.%X.%X]\", w.Primary, w.Secondary, w.Tertiary, w.Quaternary)\n }\n \n type Table struct {\n-\tt *table\n+\tt Weigher\n }\n \n func GetTable(c *Collator) *Table {\n \treturn &Table{c.t}\n }\n \n-func convertToWeights(ws []colElem) []Weights {\n+func convertToWeights(ws []Elem) []Weights {\n \tout := make([]Weights, len(ws))\n \tfor i, w := range ws {\n-\t\tout[i] = Weights{int(w.primary()), int(w.secondary()), int(w.tertiary()), int(w.quaternary())}\n+\t\tout[i] = Weights{int(w.Primary()), int(w.Secondary()), int(w.Tertiary()), int(w.Quaternary())}\n \t}\n \treturn out\n }\n \n-func convertFromWeights(ws []Weights) []colElem {\n-\tout := make([]colElem, len(ws))\n+func convertFromWeights(ws []Weights) []Elem {\n+\tout := make([]Elem, len(ws))\n \tfor i, w := range ws {\n-\t\tout[i] = makeCE([]int{w.Primary, w.Secondary, w.Tertiary})\n+\t\tout[i] = makeCE([]int{w.Primary, w.Secondary, w.Tertiary, 0})\n \t\tif out[i] == ceIgnore && w.Quaternary > 0 {\n-\t\t\tout[i] = makeQuaternary(w.Quaternary)\n+\t\t\tout[i] = MakeQuaternary(w.Quaternary)\n \t\t}\n \t}\n \treturn out\n }\n \n func (t *Table) AppendNext(s []byte) ([]Weights, int) {\n-\tw, n := t.t.appendNext(nil, s)\n+\tw, n := t.t.AppendNext(nil, s)\n \treturn convertToWeights(w), n\n }\n \n func SetTop(c *Collator, top int) {\n \tif c.t == nil {\n \t\tc.t = &table{}\n \t}\n-\tc.t.variableTop = uint32(top)\n+\tc.variableTop = uint32(top)\n }\n \n func GetColElems(c *Collator, str []byte) []Weights {"}, {"sha": "42df613e60f65a7aac62a7e16831898e8f89c328", "filename": "libgo/go/exp/locale/collate/maketables.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -674,7 +674,7 @@ func testCollator(c *collate.Collator) {\n \tfor _, str := range testInput.values() {\n \t\tk0 := c0.KeyFromString(&buf, str)\n \t\tk := c.KeyFromString(&buf, str)\n-\t\tif bytes.Compare(k0, k) != 0 {\n+\t\tif !bytes.Equal(k0, k) {\n \t\t\tfailOnError(fmt.Errorf(\"test:%U: keys differ (%x vs %x)\", []rune(str), k0, k))\n \t\t}\n \t\tbuf.Reset()"}, {"sha": "57b2efdfc258bc2a8d44d80eec337f5e99b1a2aa", "filename": "libgo/go/exp/locale/collate/sort.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package collate\n+\n+import (\n+\t\"bytes\"\n+\t\"sort\"\n+)\n+\n+const (\n+\tmaxSortBuffer  = 40960\n+\tmaxSortEntries = 4096\n+)\n+\n+type swapper interface {\n+\tSwap(i, j int)\n+}\n+\n+type sorter struct {\n+\tbuf  *Buffer\n+\tkeys [][]byte\n+\tsrc  swapper\n+}\n+\n+func (s *sorter) init(n int) {\n+\tif s.buf == nil {\n+\t\ts.buf = &Buffer{}\n+\t\ts.buf.init()\n+\t}\n+\tif cap(s.keys) < n {\n+\t\ts.keys = make([][]byte, n)\n+\t}\n+\ts.keys = s.keys[0:n]\n+}\n+\n+func (s *sorter) clean() {\n+\tif len(s.buf.key) > maxSortBuffer {\n+\t\ts.buf.key = s.buf.buf[:0]\n+\t}\n+\tif len(s.keys) > maxSortEntries {\n+\t\ts.keys = nil\n+\t}\n+}\n+\n+func (s *sorter) sort(src swapper) {\n+\ts.src = src\n+\tsort.Sort(s)\n+}\n+\n+func (s sorter) Len() int {\n+\treturn len(s.keys)\n+}\n+\n+func (s sorter) Less(i, j int) bool {\n+\treturn bytes.Compare(s.keys[i], s.keys[j]) == -1\n+}\n+\n+func (s sorter) Swap(i, j int) {\n+\ts.keys[i], s.keys[j] = s.keys[j], s.keys[i]\n+\ts.src.Swap(i, j)\n+}\n+\n+// A Lister can be sorted by Collator's Sort method.\n+type Lister interface {\n+\tLen() int\n+\tSwap(i, j int)\n+\t// Bytes returns the bytes of the text at index i.\n+\tBytes(i int) []byte\n+}\n+\n+// Sort uses sort.Sort to sort the strings represented by x using the rules of c.\n+func (c *Collator) Sort(x Lister) {\n+\tn := x.Len()\n+\tc.sorter.init(n)\n+\tfor i := 0; i < n; i++ {\n+\t\tc.sorter.keys[i] = c.Key(c.sorter.buf, x.Bytes(i))\n+\t}\n+\tc.sorter.sort(x)\n+}\n+\n+// Strings sorts x using the rules of c.\n+func (c *Collator) Strings(x []string) {\n+\tc.sorter.init(len(x))\n+\tfor i, s := range x {\n+\t\tc.sorter.keys[i] = c.KeyFromString(c.sorter.buf, s)\n+\t}\n+\tc.sorter.sort(sort.StringSlice(x))\n+}"}, {"sha": "d0682f48e6fb8f70f1b891b5a791b518543eb777", "filename": "libgo/go/exp/locale/collate/sort_test.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fsort_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package collate_test\n+\n+import (\n+\t\"exp/locale/collate\"\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func ExampleCollator_Strings() {\n+\tc := collate.New(\"root\")\n+\tstrings := []string{\n+\t\t\"ad\",\n+\t\t\"\u00e4b\",\n+\t\t\"ac\",\n+\t}\n+\tc.Strings(strings)\n+\tfmt.Println(strings)\n+\t// Output: [\u00e4b ac ad]\n+}\n+\n+type sorter []string\n+\n+func (s sorter) Len() int {\n+\treturn len(s)\n+}\n+\n+func (s sorter) Swap(i, j int) {\n+\ts[j], s[i] = s[i], s[j]\n+}\n+\n+func (s sorter) Bytes(i int) []byte {\n+\treturn []byte(s[i])\n+}\n+\n+func TestSort(t *testing.T) {\n+\tc := collate.New(\"en\")\n+\tstrings := []string{\n+\t\t\"bcd\",\n+\t\t\"abc\",\n+\t\t\"ddd\",\n+\t}\n+\tc.Sort(sorter(strings))\n+\tres := fmt.Sprint(strings)\n+\twant := \"[abc bcd ddd]\"\n+\tif res != want {\n+\t\tt.Errorf(\"found %s; want %s\", res, want)\n+\t}\n+}"}, {"sha": "a03e9e21585abcbdd530eae82c507ab9d0e0a120", "filename": "libgo/go/exp/locale/collate/table.go", "status": "modified", "additions": 192, "deletions": 17, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -37,34 +37,117 @@ func (t *table) indexedTable(idx tableIndex) *table {\n \treturn &nt\n }\n \n+func (t *table) AppendNext(w []Elem, b []byte) (res []Elem, n int) {\n+\treturn t.appendNext(w, source{bytes: b})\n+}\n+\n+func (t *table) AppendNextString(w []Elem, s string) (res []Elem, n int) {\n+\treturn t.appendNext(w, source{str: s})\n+}\n+\n+func (t *table) Start(p int, b []byte) int {\n+\t// TODO: implement\n+\tpanic(\"not implemented\")\n+}\n+\n+func (t *table) StartString(p int, s string) int {\n+\t// TODO: implement\n+\tpanic(\"not implemented\")\n+}\n+\n+func (t *table) Domain() []string {\n+\t// TODO: implement\n+\tpanic(\"not implemented\")\n+}\n+\n+type source struct {\n+\tstr   string\n+\tbytes []byte\n+}\n+\n+func (src *source) lookup(t *table) (ce Elem, sz int) {\n+\tif src.bytes == nil {\n+\t\treturn t.index.lookupString(src.str)\n+\t}\n+\treturn t.index.lookup(src.bytes)\n+}\n+\n+func (src *source) tail(sz int) {\n+\tif src.bytes == nil {\n+\t\tsrc.str = src.str[sz:]\n+\t} else {\n+\t\tsrc.bytes = src.bytes[sz:]\n+\t}\n+}\n+\n+func (src *source) nfd(buf []byte, end int) []byte {\n+\tif src.bytes == nil {\n+\t\treturn norm.NFD.AppendString(buf[:0], src.str[:end])\n+\t}\n+\treturn norm.NFD.Append(buf[:0], src.bytes[:end]...)\n+}\n+\n+func (src *source) rune() (r rune, sz int) {\n+\tif src.bytes == nil {\n+\t\treturn utf8.DecodeRuneInString(src.str)\n+\t}\n+\treturn utf8.DecodeRune(src.bytes)\n+}\n+\n+func (src *source) properties(f norm.Form) norm.Properties {\n+\tif src.bytes == nil {\n+\t\treturn f.PropertiesString(src.str)\n+\t}\n+\treturn f.Properties(src.bytes)\n+}\n+\n // appendNext appends the weights corresponding to the next rune or\n // contraction in s.  If a contraction is matched to a discontinuous\n // sequence of runes, the weights for the interstitial runes are\n // appended as well.  It returns a new slice that includes the appended\n // weights and the number of bytes consumed from s.\n-func (t *table) appendNext(w []colElem, s []byte) ([]colElem, int) {\n-\tv, sz := t.index.lookup(s)\n-\tce := colElem(v)\n+func (t *table) appendNext(w []Elem, src source) (res []Elem, n int) {\n+\tce, sz := src.lookup(t)\n \ttp := ce.ctype()\n \tif tp == ceNormal {\n \t\tif ce == 0 {\n-\t\t\tr, _ := utf8.DecodeRune(s)\n+\t\t\tr, _ := src.rune()\n+\t\t\tconst (\n+\t\t\t\thangulSize  = 3\n+\t\t\t\tfirstHangul = 0xAC00\n+\t\t\t\tlastHangul  = 0xD7A3\n+\t\t\t)\n+\t\t\tif r >= firstHangul && r <= lastHangul {\n+\t\t\t\t// TODO: performance can be considerably improved here.\n+\t\t\t\tn = sz\n+\t\t\t\tvar buf [16]byte // Used for decomposing Hangul.\n+\t\t\t\tfor b := src.nfd(buf[:0], hangulSize); len(b) > 0; b = b[sz:] {\n+\t\t\t\t\tce, sz = t.index.lookup(b)\n+\t\t\t\t\tw = append(w, ce)\n+\t\t\t\t}\n+\t\t\t\treturn w, n\n+\t\t\t}\n \t\t\tce = makeImplicitCE(implicitPrimary(r))\n \t\t}\n \t\tw = append(w, ce)\n \t} else if tp == ceExpansionIndex {\n \t\tw = t.appendExpansion(w, ce)\n \t} else if tp == ceContractionIndex {\n \t\tn := 0\n-\t\tw, n = t.matchContraction(w, ce, s[sz:])\n+\t\tsrc.tail(sz)\n+\t\tif src.bytes == nil {\n+\t\t\tw, n = t.matchContractionString(w, ce, src.str)\n+\t\t} else {\n+\t\t\tw, n = t.matchContraction(w, ce, src.bytes)\n+\t\t}\n \t\tsz += n\n \t} else if tp == ceDecompose {\n-\t\t// Decompose using NFCK and replace tertiary weights.\n+\t\t// Decompose using NFKD and replace tertiary weights.\n \t\tt1, t2 := splitDecompose(ce)\n \t\ti := len(w)\n-\t\tnfkd := norm.NFKD.Properties(s).Decomposition()\n+\t\tnfkd := src.properties(norm.NFKD).Decomposition()\n \t\tfor p := 0; len(nfkd) > 0; nfkd = nfkd[p:] {\n-\t\t\tw, p = t.appendNext(w, nfkd)\n+\t\t\tw, p = t.appendNext(w, source{bytes: nfkd})\n \t\t}\n \t\tw[i] = w[i].updateTertiary(t1)\n \t\tif i++; i < len(w) {\n@@ -77,17 +160,17 @@ func (t *table) appendNext(w []colElem, s []byte) ([]colElem, int) {\n \treturn w, sz\n }\n \n-func (t *table) appendExpansion(w []colElem, ce colElem) []colElem {\n+func (t *table) appendExpansion(w []Elem, ce Elem) []Elem {\n \ti := splitExpandIndex(ce)\n \tn := int(t.expandElem[i])\n \ti++\n \tfor _, ce := range t.expandElem[i : i+n] {\n-\t\tw = append(w, colElem(ce))\n+\t\tw = append(w, Elem(ce))\n \t}\n \treturn w\n }\n \n-func (t *table) matchContraction(w []colElem, ce colElem, suffix []byte) ([]colElem, int) {\n+func (t *table) matchContraction(w []Elem, ce Elem, suffix []byte) ([]Elem, int) {\n \tindex, n, offset := splitContractIndex(ce)\n \n \tscan := t.contractTries.scanner(index, n, suffix)\n@@ -99,16 +182,17 @@ func (t *table) matchContraction(w []colElem, ce colElem, suffix []byte) ([]colE\n \t\t// By now we should have filtered most cases.\n \t\tp0 := p\n \t\tbufn := 0\n-\t\trune := norm.NFC.Properties(suffix[p:])\n+\t\trune := norm.NFD.Properties(suffix[p:])\n \t\tp += rune.Size()\n-\t\tif prevCC := rune.TrailCCC(); prevCC != 0 {\n+\t\tif rune.LeadCCC() != 0 {\n+\t\t\tprevCC := rune.TrailCCC()\n \t\t\t// A gap may only occur in the last normalization segment.\n \t\t\t// This also ensures that len(scan.s) < norm.MaxSegmentSize.\n-\t\t\tif end := norm.NFC.FirstBoundary(suffix[p:]); end != -1 {\n+\t\t\tif end := norm.NFD.FirstBoundary(suffix[p:]); end != -1 {\n \t\t\t\tscan.s = suffix[:p+end]\n \t\t\t}\n \t\t\tfor p < len(suffix) && !scan.done && suffix[p] >= utf8.RuneSelf {\n-\t\t\t\trune = norm.NFC.Properties(suffix[p:])\n+\t\t\t\trune = norm.NFD.Properties(suffix[p:])\n \t\t\t\tif ccc := rune.LeadCCC(); ccc == 0 || prevCC >= ccc {\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -128,15 +212,106 @@ func (t *table) matchContraction(w []colElem, ce colElem, suffix []byte) ([]colE\n \t}\n \t// Append weights for the matched contraction, which may be an expansion.\n \ti, n := scan.result()\n-\tce = colElem(t.contractElem[i+offset])\n+\tce = Elem(t.contractElem[i+offset])\n \tif ce.ctype() == ceNormal {\n \t\tw = append(w, ce)\n \t} else {\n \t\tw = t.appendExpansion(w, ce)\n \t}\n \t// Append weights for the runes in the segment not part of the contraction.\n \tfor b, p := buf[:bufp], 0; len(b) > 0; b = b[p:] {\n-\t\tw, p = t.appendNext(w, b)\n+\t\tw, p = t.appendNext(w, source{bytes: b})\n \t}\n \treturn w, n\n }\n+\n+// TODO: unify the two implementations. This is best done after first simplifying\n+// the algorithm taking into account the inclusion of both NFC and NFD forms\n+// in the table.\n+func (t *table) matchContractionString(w []Elem, ce Elem, suffix string) ([]Elem, int) {\n+\tindex, n, offset := splitContractIndex(ce)\n+\n+\tscan := t.contractTries.scannerString(index, n, suffix)\n+\tbuf := [norm.MaxSegmentSize]byte{}\n+\tbufp := 0\n+\tp := scan.scan(0)\n+\n+\tif !scan.done && p < len(suffix) && suffix[p] >= utf8.RuneSelf {\n+\t\t// By now we should have filtered most cases.\n+\t\tp0 := p\n+\t\tbufn := 0\n+\t\trune := norm.NFD.PropertiesString(suffix[p:])\n+\t\tp += rune.Size()\n+\t\tif rune.LeadCCC() != 0 {\n+\t\t\tprevCC := rune.TrailCCC()\n+\t\t\t// A gap may only occur in the last normalization segment.\n+\t\t\t// This also ensures that len(scan.s) < norm.MaxSegmentSize.\n+\t\t\tif end := norm.NFD.FirstBoundaryInString(suffix[p:]); end != -1 {\n+\t\t\t\tscan.s = suffix[:p+end]\n+\t\t\t}\n+\t\t\tfor p < len(suffix) && !scan.done && suffix[p] >= utf8.RuneSelf {\n+\t\t\t\trune = norm.NFD.PropertiesString(suffix[p:])\n+\t\t\t\tif ccc := rune.LeadCCC(); ccc == 0 || prevCC >= ccc {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tprevCC = rune.TrailCCC()\n+\t\t\t\tif pp := scan.scan(p); pp != p {\n+\t\t\t\t\t// Copy the interstitial runes for later processing.\n+\t\t\t\t\tbufn += copy(buf[bufn:], suffix[p0:p])\n+\t\t\t\t\tif scan.pindex == pp {\n+\t\t\t\t\t\tbufp = bufn\n+\t\t\t\t\t}\n+\t\t\t\t\tp, p0 = pp, pp\n+\t\t\t\t} else {\n+\t\t\t\t\tp += rune.Size()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// Append weights for the matched contraction, which may be an expansion.\n+\ti, n := scan.result()\n+\tce = Elem(t.contractElem[i+offset])\n+\tif ce.ctype() == ceNormal {\n+\t\tw = append(w, ce)\n+\t} else {\n+\t\tw = t.appendExpansion(w, ce)\n+\t}\n+\t// Append weights for the runes in the segment not part of the contraction.\n+\tfor b, p := buf[:bufp], 0; len(b) > 0; b = b[p:] {\n+\t\tw, p = t.appendNext(w, source{bytes: b})\n+\t}\n+\treturn w, n\n+}\n+\n+// TODO: this should stay after the rest of this file is moved to colltab\n+func (t tableIndex) TrieIndex() []uint16 {\n+\treturn mainLookup[:]\n+}\n+\n+func (t tableIndex) TrieValues() []uint32 {\n+\treturn mainValues[:]\n+}\n+\n+func (t tableIndex) FirstBlockOffsets() (lookup, value uint16) {\n+\treturn uint16(t.lookupOffset), uint16(t.valuesOffset)\n+}\n+\n+func (t tableIndex) ExpandElems() []uint32 {\n+\treturn mainExpandElem[:]\n+}\n+\n+func (t tableIndex) ContractTries() []struct{ l, h, n, i uint8 } {\n+\treturn mainCTEntries[:]\n+}\n+\n+func (t tableIndex) ContractElems() []uint32 {\n+\treturn mainContractElem[:]\n+}\n+\n+func (t tableIndex) MaxContractLen() int {\n+\treturn 18\n+}\n+\n+func (t tableIndex) VariableTop() uint32 {\n+\treturn 0x30E\n+}"}, {"sha": "464514cf4b26f029256a9dc4a2767301abf84051", "filename": "libgo/go/exp/locale/collate/tables.go", "status": "modified", "additions": 45950, "deletions": 42016, "changes": 87966, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "616dc09236fec2627b6e294253f0d854e37e2a2d", "filename": "libgo/go/exp/locale/collate/trie.go", "status": "modified", "additions": 65, "deletions": 4, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -31,18 +31,79 @@ const (\n \tte = 0xFE // 1111 1110\n )\n \n-func (t *trie) lookupValue(n uint16, b byte) colElem {\n-\treturn colElem(t.values[int(n)<<6+int(b)])\n+func (t *trie) lookupValue(n uint16, b byte) Elem {\n+\treturn Elem(t.values[int(n)<<6+int(b)])\n }\n \n // lookup returns the trie value for the first UTF-8 encoding in s and\n // the width in bytes of this encoding. The size will be 0 if s does not\n // hold enough bytes to complete the encoding. len(s) must be greater than 0.\n-func (t *trie) lookup(s []byte) (v colElem, sz int) {\n+func (t *trie) lookup(s []byte) (v Elem, sz int) {\n \tc0 := s[0]\n \tswitch {\n \tcase c0 < tx:\n-\t\treturn colElem(t.values0[c0]), 1\n+\t\treturn Elem(t.values0[c0]), 1\n+\tcase c0 < t2:\n+\t\treturn 0, 1\n+\tcase c0 < t3:\n+\t\tif len(s) < 2 {\n+\t\t\treturn 0, 0\n+\t\t}\n+\t\ti := t.index0[c0]\n+\t\tc1 := s[1]\n+\t\tif c1 < tx || t2 <= c1 {\n+\t\t\treturn 0, 1\n+\t\t}\n+\t\treturn t.lookupValue(i, c1), 2\n+\tcase c0 < t4:\n+\t\tif len(s) < 3 {\n+\t\t\treturn 0, 0\n+\t\t}\n+\t\ti := t.index0[c0]\n+\t\tc1 := s[1]\n+\t\tif c1 < tx || t2 <= c1 {\n+\t\t\treturn 0, 1\n+\t\t}\n+\t\to := int(i)<<6 + int(c1)\n+\t\ti = t.index[o]\n+\t\tc2 := s[2]\n+\t\tif c2 < tx || t2 <= c2 {\n+\t\t\treturn 0, 2\n+\t\t}\n+\t\treturn t.lookupValue(i, c2), 3\n+\tcase c0 < t5:\n+\t\tif len(s) < 4 {\n+\t\t\treturn 0, 0\n+\t\t}\n+\t\ti := t.index0[c0]\n+\t\tc1 := s[1]\n+\t\tif c1 < tx || t2 <= c1 {\n+\t\t\treturn 0, 1\n+\t\t}\n+\t\to := int(i)<<6 + int(c1)\n+\t\ti = t.index[o]\n+\t\tc2 := s[2]\n+\t\tif c2 < tx || t2 <= c2 {\n+\t\t\treturn 0, 2\n+\t\t}\n+\t\to = int(i)<<6 + int(c2)\n+\t\ti = t.index[o]\n+\t\tc3 := s[3]\n+\t\tif c3 < tx || t2 <= c3 {\n+\t\t\treturn 0, 3\n+\t\t}\n+\t\treturn t.lookupValue(i, c3), 4\n+\t}\n+\t// Illegal rune\n+\treturn 0, 1\n+}\n+\n+// The body of lookupString is a verbatim copy of that of lookup.\n+func (t *trie) lookupString(s string) (v Elem, sz int) {\n+\tc0 := s[0]\n+\tswitch {\n+\tcase c0 < tx:\n+\t\treturn Elem(t.values0[c0]), 1\n \tcase c0 < t2:\n \t\treturn 0, 1\n \tcase c0 < t3:"}, {"sha": "2d52f99dc01581eee8e7369b2572d4a7e1c17f64", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -28,24 +28,20 @@ type reorderBuffer struct {\n \tnbyte uint8                     // Number or bytes.\n \tf     formInfo\n \n-\tsrc       input\n-\tnsrc      int\n-\tsrcBytes  inputBytes\n-\tsrcString inputString\n-\ttmpBytes  inputBytes\n+\tsrc      input\n+\tnsrc     int\n+\ttmpBytes input\n }\n \n func (rb *reorderBuffer) init(f Form, src []byte) {\n \trb.f = *formTable[f]\n-\trb.srcBytes = inputBytes(src)\n-\trb.src = &rb.srcBytes\n+\trb.src.setBytes(src)\n \trb.nsrc = len(src)\n }\n \n func (rb *reorderBuffer) initString(f Form, src string) {\n \trb.f = *formTable[f]\n-\trb.srcString = inputString(src)\n-\trb.src = &rb.srcString\n+\trb.src.setString(src)\n \trb.nsrc = len(src)\n }\n \n@@ -121,9 +117,9 @@ func (rb *reorderBuffer) insert(src input, i int, info Properties) bool {\n // in dcomp.  dcomp must be a sequence of decomposed UTF-8-encoded runes.\n func (rb *reorderBuffer) insertDecomposed(dcomp []byte) bool {\n \tsaveNrune, saveNbyte := rb.nrune, rb.nbyte\n-\trb.tmpBytes = inputBytes(dcomp)\n+\trb.tmpBytes.setBytes(dcomp)\n \tfor i := 0; i < len(dcomp); {\n-\t\tinfo := rb.f.info(&rb.tmpBytes, i)\n+\t\tinfo := rb.f.info(rb.tmpBytes, i)\n \t\tpos := rb.nbyte\n \t\tif !rb.insertOrdered(info) {\n \t\t\trb.nrune, rb.nbyte = saveNrune, saveNbyte"}, {"sha": "976aa21ed00f557f0333f66a4c74762dd82d6ba2", "filename": "libgo/go/exp/norm/composition_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -81,7 +81,7 @@ func flushF(rb *reorderBuffer) []byte {\n }\n \n func flushCopyF(rb *reorderBuffer) []byte {\n-\tout := make([]byte, MaxSegmentSize)\n+\tout := make([]byte, maxByteBufferSize)\n \tn := rb.flushCopy(out)\n \treturn out[:n]\n }"}, {"sha": "edb9fcf55b87fc2804debb4d249302b1b4dd302b", "filename": "libgo/go/exp/norm/example_iter_test.go", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fexample_iter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fexample_iter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fexample_iter_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm_test\n+\n+import (\n+\t\"bytes\"\n+\t\"exp/norm\"\n+\t\"fmt\"\n+\t\"unicode/utf8\"\n+)\n+\n+// EqualSimple uses a norm.Iter to compare two non-normalized\n+// strings for equivalence.\n+func EqualSimple(a, b string) bool {\n+\tvar ia, ib norm.Iter\n+\tia.InitString(norm.NFKD, a)\n+\tib.InitString(norm.NFKD, b)\n+\tfor !ia.Done() && !ib.Done() {\n+\t\tif !bytes.Equal(ia.Next(), ib.Next()) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn ia.Done() && ib.Done()\n+}\n+\n+// FindPrefix finds the longest common prefix of ASCII characters\n+// of a and b.\n+func FindPrefix(a, b string) int {\n+\ti := 0\n+\tfor ; i < len(a) && i < len(b) && a[i] < utf8.RuneSelf && a[i] == b[i]; i++ {\n+\t}\n+\treturn i\n+}\n+\n+// EqualOpt is like EqualSimple, but optimizes the special\n+// case for ASCII characters.\n+func EqualOpt(a, b string) bool {\n+\tn := FindPrefix(a, b)\n+\ta, b = a[n:], b[n:]\n+\tvar ia, ib norm.Iter\n+\tia.InitString(norm.NFKD, a)\n+\tib.InitString(norm.NFKD, b)\n+\tfor !ia.Done() && !ib.Done() {\n+\t\tif !bytes.Equal(ia.Next(), ib.Next()) {\n+\t\t\treturn false\n+\t\t}\n+\t\tif n := int64(FindPrefix(a[ia.Pos():], b[ib.Pos():])); n != 0 {\n+\t\t\tia.Seek(n, 1)\n+\t\t\tib.Seek(n, 1)\n+\t\t}\n+\t}\n+\treturn ia.Done() && ib.Done()\n+}\n+\n+var compareTests = []struct{ a, b string }{\n+\t{\"aaa\", \"aaa\"},\n+\t{\"aaa\", \"aab\"},\n+\t{\"a\\u0300a\", \"\\u00E0a\"},\n+\t{\"a\\u0300\\u0320b\", \"a\\u0320\\u0300b\"},\n+\t{\"\\u1E0A\\u0323\", \"\\x44\\u0323\\u0307\"},\n+\t// A character that decomposes into multiple segments\n+\t// spans several iterations.\n+\t{\"\\u3304\", \"\\u30A4\\u30CB\\u30F3\\u30AF\\u3099\"},\n+}\n+\n+func ExampleIter() {\n+\tfor i, t := range compareTests {\n+\t\tr0 := EqualSimple(t.a, t.b)\n+\t\tr1 := EqualOpt(t.a, t.b)\n+\t\tfmt.Printf(\"%d: %v %v\\n\", i, r0, r1)\n+\t}\n+\t// Output:\n+\t// 0: true true\n+\t// 1: false false\n+\t// 2: true true\n+\t// 3: true true\n+\t// 4: true true\n+\t// 5: true true\n+}"}, {"sha": "7f7ee72e8adc2a83727c3d6a5c6dac148a8f2c2b", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -50,6 +50,7 @@ type formInfo struct {\n \tform                     Form\n \tcomposing, compatibility bool // form type\n \tinfo                     lookupFunc\n+\tnextMain                 iterFunc\n }\n \n var formTable []*formInfo\n@@ -67,7 +68,9 @@ func init() {\n \t\t} else {\n \t\t\tf.info = lookupInfoNFC\n \t\t}\n+\t\tf.nextMain = nextDecomposed\n \t\tif Form(i) == NFC || Form(i) == NFKC {\n+\t\t\tf.nextMain = nextComposed\n \t\t\tf.composing = true\n \t\t}\n \t}\n@@ -117,6 +120,10 @@ func (p Properties) isInert() bool {\n \treturn p.flags&0xf == 0 && p.ccc == 0\n }\n \n+func (p Properties) multiSegment() bool {\n+\treturn p.index >= firstMulti && p.index < endMulti\n+}\n+\n // Decomposition returns the decomposition for the underlying rune\n // or nil if there is none.\n func (p Properties) Decomposition() []byte {"}, {"sha": "d0177a14a4ec3e8084f2b97de6ce3be17ad82e44", "filename": "libgo/go/exp/norm/input.go", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -6,91 +6,100 @@ package norm\n \n import \"unicode/utf8\"\n \n-type input interface {\n-\tskipASCII(p, max int) int\n-\tskipNonStarter(p int) int\n-\tappendSlice(buf []byte, s, e int) []byte\n-\tcopySlice(buf []byte, s, e int)\n-\tcharinfoNFC(p int) (uint16, int)\n-\tcharinfoNFKC(p int) (uint16, int)\n-\thangul(p int) rune\n+type input struct {\n+\tstr   string\n+\tbytes []byte\n }\n \n-type inputString string\n-\n-func (s inputString) skipASCII(p, max int) int {\n-\tfor ; p < max && s[p] < utf8.RuneSelf; p++ {\n-\t}\n-\treturn p\n-}\n-\n-func (s inputString) skipNonStarter(p int) int {\n-\tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n-\t}\n-\treturn p\n-}\n-\n-func (s inputString) appendSlice(buf []byte, b, e int) []byte {\n-\tfor i := b; i < e; i++ {\n-\t\tbuf = append(buf, s[i])\n-\t}\n-\treturn buf\n+func inputBytes(str []byte) input {\n+\treturn input{bytes: str}\n }\n \n-func (s inputString) copySlice(buf []byte, b, e int) {\n-\tcopy(buf, s[b:e])\n+func inputString(str string) input {\n+\treturn input{str: str}\n }\n \n-func (s inputString) charinfoNFC(p int) (uint16, int) {\n-\treturn nfcTrie.lookupString(string(s[p:]))\n+func (in *input) setBytes(str []byte) {\n+\tin.str = \"\"\n+\tin.bytes = str\n }\n \n-func (s inputString) charinfoNFKC(p int) (uint16, int) {\n-\treturn nfkcTrie.lookupString(string(s[p:]))\n+func (in *input) setString(str string) {\n+\tin.str = str\n+\tin.bytes = nil\n }\n \n-func (s inputString) hangul(p int) rune {\n-\tif !isHangulString(string(s[p:])) {\n-\t\treturn 0\n+func (in *input) _byte(p int) byte {\n+\tif in.bytes == nil {\n+\t\treturn in.str[p]\n \t}\n-\trune, _ := utf8.DecodeRuneInString(string(s[p:]))\n-\treturn rune\n+\treturn in.bytes[p]\n }\n \n-type inputBytes []byte\n-\n-func (s inputBytes) skipASCII(p, max int) int {\n-\tfor ; p < max && s[p] < utf8.RuneSelf; p++ {\n+func (in *input) skipASCII(p, max int) int {\n+\tif in.bytes == nil {\n+\t\tfor ; p < max && in.str[p] < utf8.RuneSelf; p++ {\n+\t\t}\n+\t} else {\n+\t\tfor ; p < max && in.bytes[p] < utf8.RuneSelf; p++ {\n+\t\t}\n \t}\n \treturn p\n }\n \n-func (s inputBytes) skipNonStarter(p int) int {\n-\tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n+func (in *input) skipNonStarter(p int) int {\n+\tif in.bytes == nil {\n+\t\tfor ; p < len(in.str) && !utf8.RuneStart(in.str[p]); p++ {\n+\t\t}\n+\t} else {\n+\t\tfor ; p < len(in.bytes) && !utf8.RuneStart(in.bytes[p]); p++ {\n+\t\t}\n \t}\n \treturn p\n }\n \n-func (s inputBytes) appendSlice(buf []byte, b, e int) []byte {\n-\treturn append(buf, s[b:e]...)\n+func (in *input) appendSlice(buf []byte, b, e int) []byte {\n+\tif in.bytes != nil {\n+\t\treturn append(buf, in.bytes[b:e]...)\n+\t}\n+\tfor i := b; i < e; i++ {\n+\t\tbuf = append(buf, in.str[i])\n+\t}\n+\treturn buf\n }\n \n-func (s inputBytes) copySlice(buf []byte, b, e int) {\n-\tcopy(buf, s[b:e])\n+func (in *input) copySlice(buf []byte, b, e int) int {\n+\tif in.bytes == nil {\n+\t\treturn copy(buf, in.str[b:e])\n+\t}\n+\treturn copy(buf, in.bytes[b:e])\n }\n \n-func (s inputBytes) charinfoNFC(p int) (uint16, int) {\n-\treturn nfcTrie.lookup(s[p:])\n+func (in *input) charinfoNFC(p int) (uint16, int) {\n+\tif in.bytes == nil {\n+\t\treturn nfcTrie.lookupString(in.str[p:])\n+\t}\n+\treturn nfcTrie.lookup(in.bytes[p:])\n }\n \n-func (s inputBytes) charinfoNFKC(p int) (uint16, int) {\n-\treturn nfkcTrie.lookup(s[p:])\n+func (in *input) charinfoNFKC(p int) (uint16, int) {\n+\tif in.bytes == nil {\n+\t\treturn nfkcTrie.lookupString(in.str[p:])\n+\t}\n+\treturn nfkcTrie.lookup(in.bytes[p:])\n }\n \n-func (s inputBytes) hangul(p int) rune {\n-\tif !isHangul(s[p:]) {\n-\t\treturn 0\n+func (in *input) hangul(p int) (r rune) {\n+\tif in.bytes == nil {\n+\t\tif !isHangulString(in.str[p:]) {\n+\t\t\treturn 0\n+\t\t}\n+\t\tr, _ = utf8.DecodeRuneInString(in.str[p:])\n+\t} else {\n+\t\tif !isHangul(in.bytes[p:]) {\n+\t\t\treturn 0\n+\t\t}\n+\t\tr, _ = utf8.DecodeRune(in.bytes[p:])\n \t}\n-\trune, _ := utf8.DecodeRune(s[p:])\n-\treturn rune\n+\treturn r\n }"}, {"sha": "a9546247c3b4954a8c422119f1da05ef2c559a49", "filename": "libgo/go/exp/norm/iter.go", "status": "modified", "additions": 269, "deletions": 154, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -4,222 +4,349 @@\n \n package norm\n \n+import (\n+\t\"fmt\"\n+\t\"unicode/utf8\"\n+)\n+\n const MaxSegmentSize = maxByteBufferSize\n \n // An Iter iterates over a string or byte slice, while normalizing it\n // to a given Form.\n type Iter struct {\n-\trb   reorderBuffer\n-\tinfo Properties // first character saved from previous iteration\n-\tnext iterFunc   // implementation of next depends on form\n-\n-\tp        int // current position in input source\n-\toutStart int // start of current segment in output buffer\n-\tinStart  int // start of current segment in input source\n-\tmaxp     int // position in output buffer after which not to start a new segment\n-\tmaxseg   int // for tracking an excess of combining characters\n+\trb     reorderBuffer\n+\tbuf    [maxByteBufferSize]byte\n+\tinfo   Properties // first character saved from previous iteration\n+\tnext   iterFunc   // implementation of next depends on form\n+\tasciiF iterFunc\n \n-\ttccc uint8\n-\tdone bool\n+\tp        int    // current position in input source\n+\tmultiSeg []byte // remainder of multi-segment decomposition\n }\n \n-type iterFunc func(*Iter, []byte) int\n+type iterFunc func(*Iter) []byte\n \n-// SetInput initializes i to iterate over src after normalizing it to Form f.\n-func (i *Iter) SetInput(f Form, src []byte) {\n-\ti.rb.init(f, src)\n-\tif i.rb.f.composing {\n-\t\ti.next = nextComposed\n-\t} else {\n-\t\ti.next = nextDecomposed\n-\t}\n+// Init initializes i to iterate over src after normalizing it to Form f.\n+func (i *Iter) Init(f Form, src []byte) {\n \ti.p = 0\n-\tif i.done = len(src) == 0; !i.done {\n-\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\tif len(src) == 0 {\n+\t\ti.setDone()\n+\t\ti.rb.nsrc = 0\n+\t\treturn\n \t}\n+\ti.multiSeg = nil\n+\ti.rb.init(f, src)\n+\ti.next = i.rb.f.nextMain\n+\ti.asciiF = nextASCIIBytes\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n }\n \n-// SetInputString initializes i to iterate over src after normalizing it to Form f.\n-func (i *Iter) SetInputString(f Form, src string) {\n+// InitString initializes i to iterate over src after normalizing it to Form f.\n+func (i *Iter) InitString(f Form, src string) {\n+\ti.p = 0\n+\tif len(src) == 0 {\n+\t\ti.setDone()\n+\t\ti.rb.nsrc = 0\n+\t\treturn\n+\t}\n+\ti.multiSeg = nil\n \ti.rb.initString(f, src)\n-\tif i.rb.f.composing {\n-\t\ti.next = nextComposed\n-\t} else {\n-\t\ti.next = nextDecomposed\n+\ti.next = i.rb.f.nextMain\n+\ti.asciiF = nextASCIIString\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+}\n+\n+// Seek sets the segment to be returned by the next call to Next to start\n+// at position p.  It is the responsibility of the caller to set p to the\n+// start of a UTF8 rune.\n+func (i *Iter) Seek(offset int64, whence int) (int64, error) {\n+\tvar abs int64\n+\tswitch whence {\n+\tcase 0:\n+\t\tabs = offset\n+\tcase 1:\n+\t\tabs = int64(i.p) + offset\n+\tcase 2:\n+\t\tabs = int64(i.rb.nsrc) + offset\n+\tdefault:\n+\t\treturn 0, fmt.Errorf(\"norm: invalid whence\")\n \t}\n-\ti.p = 0\n-\tif i.done = len(src) == 0; !i.done {\n-\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\tif abs < 0 {\n+\t\treturn 0, fmt.Errorf(\"norm: negative position\")\n+\t}\n+\tif int(abs) >= i.rb.nsrc {\n+\t\ti.setDone()\n+\t\treturn int64(i.p), nil\n+\t}\n+\ti.p = int(abs)\n+\ti.multiSeg = nil\n+\ti.next = i.rb.f.nextMain\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\treturn abs, nil\n+}\n+\n+// returnSlice returns a slice of the underlying input type as a byte slice.\n+// If the underlying is of type []byte, it will simply return a slice.\n+// If the underlying is of type string, it will copy the slice to the buffer\n+// and return that.\n+func (i *Iter) returnSlice(a, b int) []byte {\n+\tif i.rb.src.bytes == nil {\n+\t\treturn i.buf[:copy(i.buf[:], i.rb.src.str[a:b])]\n \t}\n+\treturn i.rb.src.bytes[a:b]\n }\n \n // Pos returns the byte position at which the next call to Next will commence processing.\n func (i *Iter) Pos() int {\n \treturn i.p\n }\n \n+func (i *Iter) setDone() {\n+\ti.next = nextDone\n+\ti.p = i.rb.nsrc\n+}\n+\n // Done returns true if there is no more input to process.\n func (i *Iter) Done() bool {\n-\treturn i.done\n+\treturn i.p >= i.rb.nsrc\n }\n \n-// Next writes f(i.input[i.Pos():n]...) to buffer buf, where n is the\n-// largest boundary of i.input such that the result fits in buf.\n-// It returns the number of bytes written to buf.\n-// len(buf) should be at least MaxSegmentSize.\n-// Done must be false before calling Next.\n-func (i *Iter) Next(buf []byte) int {\n-\treturn i.next(i, buf)\n+// Next returns f(i.input[i.Pos():n]), where n is a boundary of i.input.\n+// For any input a and b for which f(a) == f(b), subsequent calls\n+// to Next will return the same segments.\n+// Modifying runes are grouped together with the preceding starter, if such a starter exists.\n+// Although not guaranteed, n will typically be the smallest possible n.\n+func (i *Iter) Next() []byte {\n+\treturn i.next(i)\n }\n \n-func (i *Iter) initNext(outn, inStart int) {\n-\ti.outStart = 0\n-\ti.inStart = inStart\n-\ti.maxp = outn - MaxSegmentSize\n-\ti.maxseg = MaxSegmentSize\n+func nextASCIIBytes(i *Iter) []byte {\n+\tp := i.p + 1\n+\tif p >= i.rb.nsrc {\n+\t\ti.setDone()\n+\t\treturn i.rb.src.bytes[i.p:p]\n+\t}\n+\tif i.rb.src.bytes[p] < utf8.RuneSelf {\n+\t\tp0 := i.p\n+\t\ti.p = p\n+\t\treturn i.rb.src.bytes[p0:p]\n+\t}\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\ti.next = i.rb.f.nextMain\n+\treturn i.next(i)\n }\n \n-// setStart resets the start of the new segment to the given position.\n-// It returns true if there is not enough room for the new segment.\n-func (i *Iter) setStart(outp, inp int) bool {\n-\tif outp > i.maxp {\n-\t\treturn true\n+func nextASCIIString(i *Iter) []byte {\n+\tp := i.p + 1\n+\tif p >= i.rb.nsrc {\n+\t\ti.buf[0] = i.rb.src.str[i.p]\n+\t\ti.setDone()\n+\t\treturn i.buf[:1]\n \t}\n-\ti.outStart = outp\n-\ti.inStart = inp\n-\ti.maxseg = outp + MaxSegmentSize\n-\treturn false\n+\tif i.rb.src.str[p] < utf8.RuneSelf {\n+\t\ti.buf[0] = i.rb.src.str[i.p]\n+\t\ti.p = p\n+\t\treturn i.buf[:1]\n+\t}\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\ti.next = i.rb.f.nextMain\n+\treturn i.next(i)\n }\n \n-func min(a, b int) int {\n-\tif a < b {\n-\t\treturn a\n+func nextHangul(i *Iter) []byte {\n+\tif r := i.rb.src.hangul(i.p); r != 0 {\n+\t\ti.p += hangulUTF8Size\n+\t\tif i.p >= i.rb.nsrc {\n+\t\t\ti.setDone()\n+\t\t}\n+\t\treturn i.buf[:decomposeHangul(i.buf[:], r)]\n \t}\n-\treturn b\n+\ti.info = i.rb.f.info(i.rb.src, i.p)\n+\ti.next = i.rb.f.nextMain\n+\treturn i.next(i)\n+}\n+\n+func nextDone(i *Iter) []byte {\n+\treturn nil\n+}\n+\n+// nextMulti is used for iterating over multi-segment decompositions\n+// for decomposing normal forms.\n+func nextMulti(i *Iter) []byte {\n+\tj := 0\n+\td := i.multiSeg\n+\t// skip first rune\n+\tfor j = 1; j < len(d) && !utf8.RuneStart(d[j]); j++ {\n+\t}\n+\tfor j < len(d) {\n+\t\tinfo := i.rb.f.info(input{bytes: d}, j)\n+\t\tif info.ccc == 0 {\n+\t\t\ti.multiSeg = d[j:]\n+\t\t\treturn d[:j]\n+\t\t}\n+\t\tj += int(info.size)\n+\t}\n+\t// treat last segment as normal decomposition\n+\ti.next = i.rb.f.nextMain\n+\treturn i.next(i)\n+}\n+\n+// nextMultiNorm is used for iterating over multi-segment decompositions\n+// for composing normal forms.\n+func nextMultiNorm(i *Iter) []byte {\n+\tj := 0\n+\td := i.multiSeg\n+\t// skip first rune\n+\tfor j = 1; j < len(d) && !utf8.RuneStart(d[j]); j++ {\n+\t}\n+\tfor j < len(d) {\n+\t\tinfo := i.rb.f.info(input{bytes: d}, j)\n+\t\tif info.ccc == 0 {\n+\t\t\ti.multiSeg = d[j:]\n+\t\t\treturn d[:j]\n+\t\t}\n+\t\tj += int(info.size)\n+\t}\n+\ti.multiSeg = nil\n+\ti.next = nextComposed\n+\ti.p++ // restore old valud of i.p. See nextComposed.\n+\tif i.p >= i.rb.nsrc {\n+\t\ti.setDone()\n+\t}\n+\treturn d\n }\n \n // nextDecomposed is the implementation of Next for forms NFD and NFKD.\n-func nextDecomposed(i *Iter, out []byte) int {\n-\tvar outp int\n-\ti.initNext(len(out), i.p)\n-doFast:\n-\tinCopyStart, outCopyStart := i.p, outp // invariant xCopyStart <= i.xStart\n+func nextDecomposed(i *Iter) (next []byte) {\n+\tstartp, outp := i.p, 0\n+\tinCopyStart, outCopyStart := i.p, 0\n \tfor {\n \t\tif sz := int(i.info.size); sz <= 1 {\n-\t\t\t// ASCII or illegal byte.  Either way, advance by 1.\n-\t\t\ti.p++\n+\t\t\tp := i.p\n+\t\t\ti.p++ // ASCII or illegal byte.  Either way, advance by 1.\n+\t\t\tif i.p >= i.rb.nsrc {\n+\t\t\t\ti.setDone()\n+\t\t\t\treturn i.returnSlice(p, i.p)\n+\t\t\t} else if i.rb.src._byte(i.p) < utf8.RuneSelf {\n+\t\t\t\ti.next = i.asciiF\n+\t\t\t\treturn i.returnSlice(p, i.p)\n+\t\t\t}\n \t\t\toutp++\n-\t\t\tmax := min(i.rb.nsrc, len(out)-outp+i.p)\n-\t\t\tif np := i.rb.src.skipASCII(i.p, max); np > i.p {\n-\t\t\t\toutp += np - i.p\n-\t\t\t\ti.p = np\n-\t\t\t\tif i.p >= i.rb.nsrc {\n-\t\t\t\t\tbreak\n+\t\t} else if d := i.info.Decomposition(); d != nil {\n+\t\t\t// Note: If leading CCC != 0, then len(d) == 2 and last is also non-zero.\n+\t\t\t// Case 1: there is a leftover to copy.  In this case the decomposition\n+\t\t\t// must begin with a modifier and should always be appended.\n+\t\t\t// Case 2: no leftover. Simply return d if followed by a ccc == 0 value.\n+\t\t\tp := outp + len(d)\n+\t\t\tif outp > 0 {\n+\t\t\t\ti.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)\n+\t\t\t\tif p > len(i.buf) {\n+\t\t\t\t\treturn i.buf[:outp]\n \t\t\t\t}\n-\t\t\t\t// ASCII may combine with consecutive runes.\n-\t\t\t\tif i.setStart(outp-1, i.p-1) {\n-\t\t\t\t\ti.p--\n-\t\t\t\t\toutp--\n-\t\t\t\t\ti.info.size = 1\n-\t\t\t\t\tbreak\n+\t\t\t} else if i.info.multiSegment() {\n+\t\t\t\t// outp must be 0 as multi-segment decompositions always\n+\t\t\t\t// start a new segment.\n+\t\t\t\tif i.multiSeg == nil {\n+\t\t\t\t\ti.multiSeg = d\n+\t\t\t\t\ti.next = nextMulti\n+\t\t\t\t\treturn nextMulti(i)\n \t\t\t\t}\n+\t\t\t\t// We are in the last segment.  Treat as normal decomposition.\n+\t\t\t\td = i.multiSeg\n+\t\t\t\ti.multiSeg = nil\n+\t\t\t\tp = len(d)\n \t\t\t}\n-\t\t} else if d := i.info.Decomposition(); d != nil {\n-\t\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n-\t\t\tp := outp + len(d)\n-\t\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n-\t\t\t\treturn outp\n+\t\t\tprevCC := i.info.tccc\n+\t\t\tif i.p += sz; i.p >= i.rb.nsrc {\n+\t\t\t\ti.setDone()\n+\t\t\t\ti.info = Properties{} // Force BoundaryBefore to succeed.\n+\t\t\t} else {\n+\t\t\t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t\t\t}\n-\t\t\tcopy(out[outp:], d)\n+\t\t\tif i.info.BoundaryBefore() {\n+\t\t\t\tif outp > 0 {\n+\t\t\t\t\tcopy(i.buf[outp:], d)\n+\t\t\t\t\treturn i.buf[:p]\n+\t\t\t\t}\n+\t\t\t\treturn d\n+\t\t\t}\n+\t\t\tcopy(i.buf[outp:], d)\n \t\t\toutp = p\n-\t\t\ti.p += sz\n \t\t\tinCopyStart, outCopyStart = i.p, outp\n+\t\t\tif i.info.ccc < prevCC {\n+\t\t\t\tgoto doNorm\n+\t\t\t}\n+\t\t\tcontinue\n \t\t} else if r := i.rb.src.hangul(i.p); r != 0 {\n-\t\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n-\t\t\tfor {\n-\t\t\t\toutp += decomposeHangul(out[outp:], r)\n-\t\t\t\ti.p += hangulUTF8Size\n-\t\t\t\tif r = i.rb.src.hangul(i.p); r == 0 {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif i.setStart(outp, i.p) {\n-\t\t\t\t\treturn outp\n-\t\t\t\t}\n+\t\t\ti.next = nextHangul\n+\t\t\ti.p += hangulUTF8Size\n+\t\t\tif i.p >= i.rb.nsrc {\n+\t\t\t\ti.setDone()\n \t\t\t}\n-\t\t\tinCopyStart, outCopyStart = i.p, outp\n+\t\t\treturn i.buf[:decomposeHangul(i.buf[:], r)]\n \t\t} else {\n \t\t\tp := outp + sz\n-\t\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n+\t\t\tif p > len(i.buf) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\toutp = p\n \t\t\ti.p += sz\n \t\t}\n \t\tif i.p >= i.rb.nsrc {\n+\t\t\ti.setDone()\n \t\t\tbreak\n \t\t}\n \t\tprevCC := i.info.tccc\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n-\t\tif cc := i.info.ccc; cc == 0 {\n-\t\t\tif i.setStart(outp, i.p) {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t} else if cc < prevCC {\n+\t\tif i.info.BoundaryBefore() {\n+\t\t\tbreak\n+\t\t} else if i.info.ccc < prevCC {\n \t\t\tgoto doNorm\n \t\t}\n \t}\n-\tif inCopyStart != i.p {\n-\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n+\tif outCopyStart == 0 {\n+\t\treturn i.returnSlice(inCopyStart, i.p)\n+\t} else if inCopyStart < i.p {\n+\t\ti.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)\n \t}\n-\ti.done = i.p >= i.rb.nsrc\n-\treturn outp\n+\treturn i.buf[:outp]\n doNorm:\n \t// Insert what we have decomposed so far in the reorderBuffer.\n \t// As we will only reorder, there will always be enough room.\n-\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n-\tif !i.rb.insertDecomposed(out[i.outStart:outp]) {\n+\ti.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)\n+\tif !i.rb.insertDecomposed(i.buf[0:outp]) {\n \t\t// Start over to prevent decompositions from crossing segment boundaries.\n \t\t// This is a rare occurrence.\n-\t\ti.p = i.inStart\n+\t\ti.p = startp\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t}\n-\toutp = i.outStart\n \tfor {\n \t\tif !i.rb.insert(i.rb.src, i.p, i.info) {\n \t\t\tbreak\n \t\t}\n \t\tif i.p += int(i.info.size); i.p >= i.rb.nsrc {\n-\t\t\toutp += i.rb.flushCopy(out[outp:])\n-\t\t\ti.done = true\n-\t\t\treturn outp\n+\t\t\ti.setDone()\n+\t\t\tbreak\n \t\t}\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t\tif i.info.ccc == 0 {\n \t\t\tbreak\n \t\t}\n \t}\n \t// new segment or too many combining characters: exit normalization\n-\tif outp += i.rb.flushCopy(out[outp:]); i.setStart(outp, i.p) {\n-\t\treturn outp\n-\t}\n-\tgoto doFast\n+\treturn i.buf[:i.rb.flushCopy(i.buf[:])]\n }\n \n // nextComposed is the implementation of Next for forms NFC and NFKC.\n-func nextComposed(i *Iter, out []byte) int {\n-\tvar outp int\n-\ti.initNext(len(out), i.p)\n-doFast:\n-\tinCopyStart, outCopyStart := i.p, outp // invariant xCopyStart <= i.xStart\n+func nextComposed(i *Iter) []byte {\n+\toutp, startp := 0, i.p\n \tvar prevCC uint8\n \tfor {\n \t\tif !i.info.isYesC() {\n \t\t\tgoto doNorm\n \t\t}\n-\t\tif cc := i.info.ccc; cc == 0 {\n-\t\t\tif i.setStart(outp, i.p) {\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tif cc := i.info.ccc; cc == 0 && outp > 0 {\n+\t\t\tbreak\n \t\t} else if cc < prevCC {\n \t\t\tgoto doNorm\n \t\t}\n@@ -229,58 +356,46 @@ doFast:\n \t\t\tsz = 1 // illegal rune: copy byte-by-byte\n \t\t}\n \t\tp := outp + sz\n-\t\tif p > i.maxseg && i.setStart(outp, i.p) {\n+\t\tif p > len(i.buf) {\n \t\t\tbreak\n \t\t}\n \t\toutp = p\n \t\ti.p += sz\n-\t\tmax := min(i.rb.nsrc, len(out)-outp+i.p)\n-\t\tif np := i.rb.src.skipASCII(i.p, max); np > i.p {\n-\t\t\toutp += np - i.p\n-\t\t\ti.p = np\n-\t\t\tif i.p >= i.rb.nsrc {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\t// ASCII may combine with consecutive runes.\n-\t\t\tif i.setStart(outp-1, i.p-1) {\n-\t\t\t\ti.p--\n-\t\t\t\toutp--\n-\t\t\t\ti.info = Properties{size: 1}\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n \t\tif i.p >= i.rb.nsrc {\n+\t\t\ti.setDone()\n+\t\t\tbreak\n+\t\t} else if i.rb.src._byte(i.p) < utf8.RuneSelf {\n+\t\t\ti.next = i.asciiF\n \t\t\tbreak\n \t\t}\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t}\n-\tif inCopyStart != i.p {\n-\t\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n-\t}\n-\ti.done = i.p >= i.rb.nsrc\n-\treturn outp\n+\treturn i.returnSlice(startp, i.p)\n doNorm:\n-\ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.inStart)\n-\toutp, i.p = i.outStart, i.inStart\n+\tmulti := false\n+\ti.p = startp\n \ti.info = i.rb.f.info(i.rb.src, i.p)\n \tfor {\n \t\tif !i.rb.insert(i.rb.src, i.p, i.info) {\n \t\t\tbreak\n \t\t}\n+\t\tmulti = multi || i.info.multiSegment()\n \t\tif i.p += int(i.info.size); i.p >= i.rb.nsrc {\n-\t\t\ti.rb.compose()\n-\t\t\toutp += i.rb.flushCopy(out[outp:])\n-\t\t\ti.done = true\n-\t\t\treturn outp\n+\t\t\ti.setDone()\n+\t\t\tbreak\n \t\t}\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t\tif i.info.BoundaryBefore() {\n \t\t\tbreak\n \t\t}\n \t}\n \ti.rb.compose()\n-\tif outp += i.rb.flushCopy(out[outp:]); i.setStart(outp, i.p) {\n-\t\treturn outp\n+\tseg := i.buf[:i.rb.flushCopy(i.buf[:])]\n+\tif multi {\n+\t\ti.p-- // fake not being done yet\n+\t\ti.multiSeg = seg\n+\t\ti.next = nextMultiNorm\n+\t\treturn nextMultiNorm(i)\n \t}\n-\tgoto doFast\n+\treturn seg\n }"}, {"sha": "82611936268dd4ba544ee4825db10f56450decd4", "filename": "libgo/go/exp/norm/iter_test.go", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -9,21 +9,12 @@ import (\n \t\"testing\"\n )\n \n-var iterBufSizes = []int{\n-\tMaxSegmentSize,\n-\t1.5 * MaxSegmentSize,\n-\t2 * MaxSegmentSize,\n-\t3 * MaxSegmentSize,\n-\t100 * MaxSegmentSize,\n-}\n-\n-func doIterNorm(f Form, buf []byte, s string) []byte {\n+func doIterNorm(f Form, s string) []byte {\n \tacc := []byte{}\n \ti := Iter{}\n-\ti.SetInputString(f, s)\n+\ti.InitString(f, s)\n \tfor !i.Done() {\n-\t\tn := i.Next(buf)\n-\t\tacc = append(acc, buf[:n]...)\n+\t\tacc = append(acc, i.Next()...)\n \t}\n \treturn acc\n }\n@@ -35,30 +26,28 @@ func runIterTests(t *testing.T, name string, f Form, tests []AppendTest, norm bo\n \t\tif norm {\n \t\t\tgold = string(f.AppendString(nil, test.out))\n \t\t}\n-\t\tfor _, sz := range iterBufSizes {\n-\t\t\tbuf := make([]byte, sz)\n-\t\t\tout := string(doIterNorm(f, buf, in))\n-\t\t\tif len(out) != len(gold) {\n-\t\t\t\tconst msg = \"%s:%d:%d: length is %d; want %d\"\n-\t\t\t\tt.Errorf(msg, name, i, sz, len(out), len(gold))\n-\t\t\t}\n-\t\t\tif out != gold {\n-\t\t\t\t// Find first rune that differs and show context.\n-\t\t\t\tir := []rune(out)\n-\t\t\t\tig := []rune(gold)\n-\t\t\t\tfor j := 0; j < len(ir) && j < len(ig); j++ {\n-\t\t\t\t\tif ir[j] == ig[j] {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tif j -= 3; j < 0 {\n-\t\t\t\t\t\tj = 0\n-\t\t\t\t\t}\n-\t\t\t\t\tfor e := j + 7; j < e && j < len(ir) && j < len(ig); j++ {\n-\t\t\t\t\t\tconst msg = \"%s:%d:%d: runeAt(%d) = %U; want %U\"\n-\t\t\t\t\t\tt.Errorf(msg, name, i, sz, j, ir[j], ig[j])\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak\n+\t\tout := string(doIterNorm(f, in))\n+\t\tif len(out) != len(gold) {\n+\t\t\tconst msg = \"%s:%d: length is %d; want %d\"\n+\t\t\tt.Errorf(msg, name, i, len(out), len(gold))\n+\t\t}\n+\t\tif out != gold {\n+\t\t\t// Find first rune that differs and show context.\n+\t\t\tir := []rune(out)\n+\t\t\tig := []rune(gold)\n+\t\t\tt.Errorf(\"\\n%X != \\n%X\", ir, ig)\n+\t\t\tfor j := 0; j < len(ir) && j < len(ig); j++ {\n+\t\t\t\tif ir[j] == ig[j] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif j -= 3; j < 0 {\n+\t\t\t\t\tj = 0\n \t\t\t\t}\n+\t\t\t\tfor e := j + 7; j < e && j < len(ir) && j < len(ig); j++ {\n+\t\t\t\t\tconst msg = \"%s:%d: runeAt(%d) = %U; want %U\"\n+\t\t\t\t\tt.Errorf(msg, name, i, j, ir[j], ig[j])\n+\t\t\t\t}\n+\t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n@@ -68,42 +57,44 @@ func rep(r rune, n int) string {\n \treturn strings.Repeat(string(r), n)\n }\n \n+const segSize = maxByteBufferSize\n+\n var iterTests = []AppendTest{\n \t{\"\", ascii, ascii},\n \t{\"\", txt_all, txt_all},\n-\t{\"\", \"a\" + rep(0x0300, MaxSegmentSize/2), \"a\" + rep(0x0300, MaxSegmentSize/2)},\n+\t{\"\", \"a\" + rep(0x0300, segSize/2), \"a\" + rep(0x0300, segSize/2)},\n }\n \n var iterTestsD = []AppendTest{\n \t{ // segment overflow on unchanged character\n \t\t\"\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2) + \"\\u0316\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0316\\u0300\",\n+\t\t\"a\" + rep(0x0300, segSize/2) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0300, segSize/2-1) + \"\\u0316\\u0300\",\n \t},\n \t{ // segment overflow on unchanged character + start value\n \t\t\"\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2+maxCombiningChars+4) + \"\\u0316\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2+maxCombiningChars) + \"\\u0316\" + rep(0x300, 4),\n+\t\t\"a\" + rep(0x0300, segSize/2+maxCombiningChars+4) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0300, segSize/2+maxCombiningChars) + \"\\u0316\" + rep(0x300, 4),\n \t},\n \t{ // segment overflow on decomposition\n \t\t\"\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0340\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2),\n+\t\t\"a\" + rep(0x0300, segSize/2-1) + \"\\u0340\",\n+\t\t\"a\" + rep(0x0300, segSize/2),\n \t},\n \t{ // segment overflow on decomposition + start value\n \t\t\"\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + \"\\u0340\" + rep(0x300, maxCombiningChars+4) + \"\\u0320\",\n-\t\t\"a\" + rep(0x0300, MaxSegmentSize/2-1) + rep(0x300, maxCombiningChars+1) + \"\\u0320\" + rep(0x300, 4),\n+\t\t\"a\" + rep(0x0300, segSize/2-1) + \"\\u0340\" + rep(0x300, maxCombiningChars+4) + \"\\u0320\",\n+\t\t\"a\" + rep(0x0300, segSize/2-1) + rep(0x300, maxCombiningChars+1) + \"\\u0320\" + rep(0x300, 4),\n \t},\n \t{ // start value after ASCII overflow\n \t\t\"\",\n-\t\trep('a', MaxSegmentSize) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n-\t\trep('a', MaxSegmentSize) + rep(0x300, maxCombiningChars) + \"\\u0320\\u0300\\u0300\",\n+\t\trep('a', segSize) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n+\t\trep('a', segSize) + rep(0x300, maxCombiningChars) + \"\\u0320\\u0300\\u0300\",\n \t},\n \t{ // start value after Hangul overflow\n \t\t\"\",\n-\t\trep(0xAC00, MaxSegmentSize/6) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n-\t\tstrings.Repeat(\"\\u1100\\u1161\", MaxSegmentSize/6) + rep(0x300, maxCombiningChars-1) + \"\\u0320\" + rep(0x300, 3),\n+\t\trep(0xAC00, segSize/6) + rep(0x300, maxCombiningChars+2) + \"\\u0320\",\n+\t\tstrings.Repeat(\"\\u1100\\u1161\", segSize/6) + rep(0x300, maxCombiningChars+1) + \"\\u0320\" + rep(0x300, 1),\n \t},\n \t{ // start value after cc=0\n \t\t\"\",\n@@ -125,8 +116,8 @@ var iterTestsC = []AppendTest{\n \t},\n \t{ // segment overflow\n \t\t\"\",\n-\t\t\"a\" + rep(0x0305, MaxSegmentSize/2+4) + \"\\u0316\",\n-\t\t\"a\" + rep(0x0305, MaxSegmentSize/2-1) + \"\\u0316\" + rep(0x305, 5),\n+\t\t\"a\" + rep(0x0305, segSize/2+4) + \"\\u0316\",\n+\t\t\"a\" + rep(0x0305, segSize/2-1) + \"\\u0316\" + rep(0x305, 5),\n \t},\n }\n \n@@ -148,38 +139,49 @@ type SegmentTest struct {\n }\n \n var segmentTests = []SegmentTest{\n-\t{rep('a', MaxSegmentSize), []string{rep('a', MaxSegmentSize), \"\"}},\n-\t{rep('a', MaxSegmentSize+2), []string{rep('a', MaxSegmentSize-1), \"aaa\", \"\"}},\n-\t{rep('a', MaxSegmentSize) + \"\\u0300aa\", []string{rep('a', MaxSegmentSize-1), \"a\\u0300\", \"aa\", \"\"}},\n+\t{\"\\u1E0A\\u0323a\", []string{\"\\x44\\u0323\\u0307\", \"a\", \"\"}},\n+\t{rep('a', segSize), append(strings.Split(rep('a', segSize), \"\"), \"\")},\n+\t{rep('a', segSize+2), append(strings.Split(rep('a', segSize+2), \"\"), \"\")},\n+\t{rep('a', segSize) + \"\\u0300aa\",\n+\t\tappend(strings.Split(rep('a', segSize-1), \"\"), \"a\\u0300\", \"a\", \"a\", \"\")},\n+}\n+\n+var segmentTestsK = []SegmentTest{\n+\t{\"\\u3332\", []string{\"\\u30D5\", \"\\u30A1\", \"\\u30E9\", \"\\u30C3\", \"\\u30C8\\u3099\", \"\"}},\n+\t// last segment of multi-segment decomposition needs normalization\n+\t{\"\\u3332\\u093C\", []string{\"\\u30D5\", \"\\u30A1\", \"\\u30E9\", \"\\u30C3\", \"\\u30C8\\u093C\\u3099\", \"\"}},\n+\t// Hangul and Jamo are grouped togeter.\n+\t{\"\\uAC00\", []string{\"\\u1100\\u1161\", \"\"}},\n+\t{\"\\uAC01\", []string{\"\\u1100\\u1161\\u11A8\", \"\"}},\n+\t{\"\\u1100\\u1161\", []string{\"\\u1100\\u1161\", \"\"}},\n }\n \n // Note that, by design, segmentation is equal for composing and decomposing forms.\n func TestIterSegmentation(t *testing.T) {\n \tsegmentTest(t, \"SegmentTestD\", NFD, segmentTests)\n \tsegmentTest(t, \"SegmentTestC\", NFC, segmentTests)\n+\tsegmentTest(t, \"SegmentTestD\", NFKD, segmentTestsK)\n+\tsegmentTest(t, \"SegmentTestC\", NFKC, segmentTestsK)\n }\n \n func segmentTest(t *testing.T, name string, f Form, tests []SegmentTest) {\n \titer := Iter{}\n-\tfor i, tt := range segmentTests {\n-\t\tbuf := make([]byte, MaxSegmentSize)\n-\t\titer.SetInputString(f, tt.in)\n+\tfor i, tt := range tests {\n+\t\titer.InitString(f, tt.in)\n \t\tfor j, seg := range tt.out {\n \t\t\tif seg == \"\" {\n \t\t\t\tif !iter.Done() {\n-\t\t\t\t\tn := iter.Next(buf)\n-\t\t\t\t\tres := string(buf[:n])\n+\t\t\t\t\tres := string(iter.Next())\n \t\t\t\t\tt.Errorf(`%s:%d:%d: expected Done()==true, found segment \"%s\"`, name, i, j, res)\n \t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif iter.Done() {\n \t\t\t\tt.Errorf(\"%s:%d:%d: Done()==true, want false\", name, i, j)\n \t\t\t}\n-\t\t\tn := iter.Next(buf)\n \t\t\tseg = f.String(seg)\n-\t\t\tif res := string(buf[:n]); res != seg {\n-\t\t\t\tt.Errorf(`%s:%d:%d\" segment was \"%s\" (%d); want \"%s\" (%d)`, name, i, j, res, len(res), seg, len(seg))\n+\t\t\tif res := string(iter.Next()); res != seg {\n+\t\t\t\tt.Errorf(`%s:%d:%d\" segment was \"%s\" (%d); want \"%s\" (%d) %X %X`, name, i, j, res, len(res), seg, len(seg), []rune(res), []rune(seg))\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "03e1e2e33fa61744c5a5e026ea59d6dc1a026028", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -574,7 +574,19 @@ func makeEntry(f *FormInfo) uint16 {\n \n // decompSet keeps track of unique decompositions, grouped by whether\n // the decomposition is followed by a trailing and/or leading CCC.\n-type decompSet [4]map[string]bool\n+type decompSet [6]map[string]bool\n+\n+const (\n+\tnormalDecomp = iota\n+\tfirstMulti\n+\tfirstCCC\n+\tendMulti\n+\tfirstLeadingCCC\n+\tfirstCCCZeroExcept\n+\tlastDecomp\n+)\n+\n+var cname = []string{\"firstMulti\", \"firstCCC\", \"endMulti\", \"firstLeadingCCC\", \"firstCCCZeroExcept\", \"lastDecomp\"}\n \n func makeDecompSet() decompSet {\n \tm := decompSet{}\n@@ -614,20 +626,30 @@ func printCharInfoTables() int {\n \t\t\tconst msg = \"%U: lccc (%d) must be <= tcc (%d)\"\n \t\t\tlogger.Fatalf(msg, r, lccc, tccc)\n \t\t}\n-\t\tindex := 0\n+\t\tindex := normalDecomp\n \t\tif tccc > 0 || lccc > 0 {\n \t\t\ts += string([]byte{tccc})\n-\t\t\tindex = 1\n+\t\t\tindex = endMulti\n+\t\t\tfor _, r := range d[1:] {\n+\t\t\t\tif ccc(r) == 0 {\n+\t\t\t\t\tindex = firstCCC\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif lccc > 0 {\n \t\t\t\ts += string([]byte{lccc})\n-\t\t\t\tindex = 2\n+\t\t\t\tif index == firstCCC {\n+\t\t\t\t\tlogger.Fatalf(\"%U: multi-segment decomposition not supported for decompositions with leading CCC != 0\", r)\n+\t\t\t\t}\n+\t\t\t\tindex = firstLeadingCCC\n \t\t\t}\n \t\t\tif cc != lccc {\n \t\t\t\tif cc != 0 {\n \t\t\t\t\tlogger.Fatalf(\"%U: for lccc != ccc, expected ccc to be 0; was %d\", r, cc)\n \t\t\t\t}\n-\t\t\t\tindex = 3\n+\t\t\t\tindex = firstCCCZeroExcept\n \t\t\t}\n+\t\t} else if len(d) > 1 {\n+\t\t\tindex = firstMulti\n \t\t}\n \t\treturn index, s\n \t}\n@@ -653,7 +675,6 @@ func printCharInfoTables() int {\n \tsize := 0\n \tpositionMap := make(map[string]uint16)\n \tdecompositions.WriteString(\"\\000\")\n-\tcname := []string{\"firstCCC\", \"firstLeadingCCC\", \"firstCCCZeroExcept\", \"lastDecomp\"}\n \tfmt.Println(\"const (\")\n \tfor i, m := range decompSet {\n \t\tsa := []string{}"}, {"sha": "9a6b46e41bc52fb5450516d3c8da0ce044498df8", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -6,6 +6,7 @@ package norm\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -504,19 +505,44 @@ func appendBench(f Form, in []byte) func() {\n }\n \n func iterBench(f Form, in []byte) func() {\n-\tbuf := make([]byte, 4*len(in))\n \titer := Iter{}\n \treturn func() {\n-\t\titer.SetInput(f, in)\n+\t\titer.Init(f, in)\n \t\tfor !iter.Done() {\n-\t\t\titer.Next(buf)\n+\t\t\titer.Next()\n+\t\t}\n+\t}\n+}\n+\n+func readerBench(f Form, in []byte) func() {\n+\tbuf := make([]byte, 4*len(in))\n+\treturn func() {\n+\t\tr := f.Reader(bytes.NewReader(in))\n+\t\tvar err error\n+\t\tfor err == nil {\n+\t\t\t_, err = r.Read(buf)\n+\t\t}\n+\t\tif err != io.EOF {\n+\t\t\tpanic(\"\")\n+\t\t}\n+\t}\n+}\n+\n+func writerBench(f Form, in []byte) func() {\n+\tbuf := make([]byte, 0, 4*len(in))\n+\treturn func() {\n+\t\tr := f.Writer(bytes.NewBuffer(buf))\n+\t\tif _, err := r.Write(in); err != nil {\n+\t\t\tpanic(\"\")\n \t\t}\n \t}\n }\n \n func appendBenchmarks(bm []func(), f Form, in []byte) []func() {\n \t//bm = append(bm, appendBench(f, in))\n \tbm = append(bm, iterBench(f, in))\n+\t//bm = append(bm, readerBench(f, in))\n+\t//bm = append(bm, writerBench(f, in))\n \treturn bm\n }\n "}, {"sha": "d7ef9ba3ec76a0de0ac18bd5dd17ce2c9151112e", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -223,13 +223,11 @@ func doTest(t *Test, f norm.Form, gold, test string) {\n \tcmpResult(t, \"Bytes\", f, gold, test, string(result))\n \tsresult := f.String(test)\n \tcmpResult(t, \"String\", f, gold, test, sresult)\n-\tbuf := make([]byte, norm.MaxSegmentSize)\n \tacc := []byte{}\n \ti := norm.Iter{}\n-\ti.SetInputString(f, test)\n+\ti.InitString(f, test)\n \tfor !i.Done() {\n-\t\tn := i.Next(buf)\n-\t\tacc = append(acc, buf[:n]...)\n+\t\tacc = append(acc, i.Next()...)\n \t}\n \tcmpResult(t, \"Iter.Next\", f, gold, test, string(acc))\n \tfor i := range test {"}, {"sha": "fa33a34a16448b7987e6357ee64d202235a161ce", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 3389, "deletions": 3387, "changes": 6776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "77a98b3e011f50cd77a593a581f24950b6b469e2", "filename": "libgo/go/exp/ssa/blockopt.go", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,190 @@\n+package ssa\n+\n+// Simple block optimisations to simplify the control flow graph.\n+\n+// TODO(adonovan): instead of creating several \"unreachable\" blocks\n+// per function in the Builder, reuse a single one (e.g. at Blocks[1])\n+// to reduce garbage.\n+//\n+// TODO(adonovan): in the absence of multiway branch instructions,\n+// each BasicBlock has 0, 1, or 2 successors.  We should preallocate\n+// the backing array for the Succs slice inline in BasicBlock.\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+// If true, perform sanity checking and show progress at each\n+// successive iteration of optimizeBlocks.  Very verbose.\n+const debugBlockOpt = false\n+\n+func hasPhi(b *BasicBlock) bool {\n+\t_, ok := b.Instrs[0].(*Phi)\n+\treturn ok\n+}\n+\n+// prune attempts to prune block b if it is unreachable (i.e. has no\n+// predecessors other than itself), disconnecting it from the CFG.\n+// The result is true if the optimisation was applied.  i is the block\n+// index within the function.\n+//\n+func prune(f *Function, i int, b *BasicBlock) bool {\n+\tif i == 0 {\n+\t\treturn false // don't prune entry block\n+\t}\n+\tif len(b.Preds) == 0 || len(b.Preds) == 1 && b.Preds[0] == b {\n+\t\t// Disconnect it from its successors.\n+\t\tfor _, c := range b.Succs {\n+\t\t\tc.removePred(b)\n+\t\t}\n+\t\tif debugBlockOpt {\n+\t\t\tfmt.Fprintln(os.Stderr, \"prune\", b.Name)\n+\t\t}\n+\n+\t\t// Delete b.\n+\t\tf.Blocks[i] = nil\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// jumpThreading attempts to apply simple jump-threading to block b,\n+// in which a->b->c become a->c if b is just a Jump.\n+// The result is true if the optimisation was applied.\n+// i is the block index within the function.\n+//\n+func jumpThreading(f *Function, i int, b *BasicBlock) bool {\n+\tif i == 0 {\n+\t\treturn false // don't apply to entry block\n+\t}\n+\tif b.Instrs == nil {\n+\t\tfmt.Println(\"empty block \", b.Name)\n+\t\treturn false\n+\t}\n+\tif _, ok := b.Instrs[0].(*Jump); !ok {\n+\t\treturn false // not just a jump\n+\t}\n+\tc := b.Succs[0]\n+\tif c == b {\n+\t\treturn false // don't apply to degenerate jump-to-self.\n+\t}\n+\tif hasPhi(c) {\n+\t\treturn false // not sound without more effort\n+\t}\n+\tfor j, a := range b.Preds {\n+\t\ta.replaceSucc(b, c)\n+\n+\t\t// If a now has two edges to c, replace its degenerate If by Jump.\n+\t\tif len(a.Succs) == 2 && a.Succs[0] == c && a.Succs[1] == c {\n+\t\t\tjump := new(Jump)\n+\t\t\tjump.SetBlock(a)\n+\t\t\ta.Instrs[len(a.Instrs)-1] = jump\n+\t\t\ta.Succs = a.Succs[:1]\n+\t\t\tc.removePred(b)\n+\t\t} else {\n+\t\t\tif j == 0 {\n+\t\t\t\tc.replacePred(b, a)\n+\t\t\t} else {\n+\t\t\t\tc.Preds = append(c.Preds, a)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif debugBlockOpt {\n+\t\t\tfmt.Fprintln(os.Stderr, \"jumpThreading\", a.Name, b.Name, c.Name)\n+\t\t}\n+\t}\n+\tf.Blocks[i] = nil\n+\treturn true\n+}\n+\n+// fuseBlocks attempts to apply the block fusion optimisation to block\n+// a, in which a->b becomes ab if len(a.Succs)==len(b.Preds)==1.\n+// The result is true if the optimisation was applied.\n+//\n+func fuseBlocks(f *Function, a *BasicBlock) bool {\n+\tif len(a.Succs) != 1 {\n+\t\treturn false\n+\t}\n+\tb := a.Succs[0]\n+\tif len(b.Preds) != 1 {\n+\t\treturn false\n+\t}\n+\t// Eliminate jump at end of A, then copy all of B across.\n+\ta.Instrs = append(a.Instrs[:len(a.Instrs)-1], b.Instrs...)\n+\tfor _, instr := range b.Instrs {\n+\t\tinstr.SetBlock(a)\n+\t}\n+\n+\t// A inherits B's successors\n+\ta.Succs = b.Succs\n+\n+\t// Fix up Preds links of all successors of B.\n+\tfor _, c := range b.Succs {\n+\t\tc.replacePred(b, a)\n+\t}\n+\n+\tif debugBlockOpt {\n+\t\tfmt.Fprintln(os.Stderr, \"fuseBlocks\", a.Name, b.Name)\n+\t}\n+\n+\t// Make b unreachable.  Subsequent pruning will reclaim it.\n+\tb.Preds = nil\n+\treturn true\n+}\n+\n+// optimizeBlocks() performs some simple block optimizations on a\n+// completed function: dead block elimination, block fusion, jump\n+// threading.\n+//\n+func optimizeBlocks(f *Function) {\n+\t// Loop until no further progress.\n+\tchanged := true\n+\tfor changed {\n+\t\tchanged = false\n+\n+\t\tif debugBlockOpt {\n+\t\t\tf.DumpTo(os.Stderr)\n+\t\t\tMustSanityCheck(f, nil)\n+\t\t}\n+\n+\t\tfor i, b := range f.Blocks {\n+\t\t\t// f.Blocks will temporarily contain nils to indicate\n+\t\t\t// deleted blocks; we remove them at the end.\n+\t\t\tif b == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Prune unreachable blocks (including all empty blocks).\n+\t\t\tif prune(f, i, b) {\n+\t\t\t\tchanged = true\n+\t\t\t\tcontinue // (b was pruned)\n+\t\t\t}\n+\n+\t\t\t// Fuse blocks.  b->c becomes bc.\n+\t\t\tif fuseBlocks(f, b) {\n+\t\t\t\tchanged = true\n+\t\t\t}\n+\n+\t\t\t// a->b->c becomes a->c if b contains only a Jump.\n+\t\t\tif jumpThreading(f, i, b) {\n+\t\t\t\tchanged = true\n+\t\t\t\tcontinue // (b was disconnected)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Eliminate nils from Blocks.\n+\tj := 0\n+\tfor _, b := range f.Blocks {\n+\t\tif b != nil {\n+\t\t\tf.Blocks[j] = b\n+\t\t\tj++\n+\t\t}\n+\t}\n+\t// Nil out b.Blocks[j:] to aid GC.\n+\tfor i := j; i < len(f.Blocks); i++ {\n+\t\tf.Blocks[i] = nil\n+\t}\n+\tf.Blocks = f.Blocks[:j]\n+}"}, {"sha": "a489c312956a71467ab0bde42e11ae33c54d5a0e", "filename": "libgo/go/exp/ssa/doc.go", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,113 @@\n+// Package ssa defines a representation of the elements of Go programs\n+// (packages, types, functions, variables and constants) using a\n+// static single-assignment (SSA) form intermediate representation\n+// (IR) for the the bodies of functions.\n+//\n+// THIS INTERFACE IS EXPERIMENTAL AND IS LIKELY TO CHANGE.\n+//\n+// For an introduction to SSA form, see\n+// http://en.wikipedia.org/wiki/Static_single_assignment_form.\n+// This page provides a broader reading list:\n+// http://www.dcs.gla.ac.uk/~jsinger/ssa.html.\n+//\n+// The level of abstraction of the SSA form is intentionally close to\n+// the source language to facilitate construction of source analysis\n+// tools.  It is not primarily intended for machine code generation.\n+//\n+// All looping, branching and switching constructs are replaced with\n+// unstructured control flow.  We may add higher-level control flow\n+// primitives in the future to facilitate constant-time dispatch of\n+// switch statements, for example.\n+//\n+// Builder encapsulates the tasks of type-checking (using go/types)\n+// abstract syntax trees (as defined by go/ast) for the source files\n+// comprising a Go program, and the conversion of each function from\n+// Go ASTs to the SSA representation.\n+//\n+// By supplying an instance of the SourceLocator function prototype,\n+// clients may control how the builder locates, loads and parses Go\n+// sources files for imported packages.  This package provides\n+// GorootLoader, which uses go/build to locate packages in the Go\n+// source distribution, and go/parser to parse them.\n+//\n+// The builder initially builds a naive SSA form in which all local\n+// variables are addresses of stack locations with explicit loads and\n+// stores.  If desired, registerisation and \u03c6-node insertion using\n+// dominance and dataflow can be performed as a later pass to improve\n+// the accuracy and performance of subsequent analyses; this pass is\n+// not yet implemented.\n+//\n+// The program representation constructed by this package is fully\n+// resolved internally, i.e. it does not rely on the names of Values,\n+// Packages, Functions, Types or BasicBlocks for the correct\n+// interpretation of the program.  Only the identities of objects and\n+// the topology of the SSA and type graphs are semantically\n+// significant.  (There is one exception: Ids, used to identify field\n+// and method names, contain strings.)  Avoidance of name-based\n+// operations simplifies the implementation of subsequent passes and\n+// can make them very efficient.  Many objects are nonetheless named\n+// to aid in debugging, but it is not essential that the names be\n+// either accurate or unambiguous.  The public API exposes a number of\n+// name-based maps for client convenience.\n+//\n+// Given a Go source package such as this:\n+//\n+//      package main\n+//\n+//      import \"fmt\"\n+//\n+//      const message = \"Hello, World!\"\n+//\n+//      func hello() {\n+//              fmt.Println(message)\n+//      }\n+//\n+// The SSA Builder creates a *Program containing a main *Package such\n+// as this:\n+//\n+//      Package(Name: \"main\")\n+//        Members:\n+//          \"message\":          *Literal (Type: untyped string, Value: \"Hello, World!\")\n+//          \"init\u00b7guard\":       *Global (Type: *bool)\n+//          \"hello\":            *Function (Type: func())\n+//        Init:                 *Function (Type: func())\n+//\n+// The printed representation of the function main.hello is shown\n+// below.  Within the function listing, the name of each BasicBlock\n+// such as \".0.entry\" is printed left-aligned, followed by the block's\n+// instructions, i.e. implementations of Instruction.\n+// For each instruction that defines an SSA virtual register\n+// (i.e. implements Value), the type of that value is shown in the\n+// right column.\n+//\n+//      # Name: main.hello\n+//      # Declared at hello.go:7:6\n+//      # Type: func()\n+//      func hello():\n+//      .0.entry:\n+//              t0 = new [1]interface{}                                                 *[1]interface{}\n+//              t1 = &t0[0:untyped integer]                                             *interface{}\n+//              t2 = make interface interface{} <- string (\"Hello, World!\":string)      interface{}\n+//              *t1 = t2\n+//              t3 = slice t0[:]                                                        []interface{}\n+//              t4 = fmt.Println(t3)                                                    (n int, err error)\n+//              ret\n+//\n+// TODO(adonovan): demonstrate more features in the example:\n+// parameters and control flow at the least.\n+//\n+// TODO(adonovan): Consider how token.Pos source location information\n+// should be made available generally.  Currently it is only present in\n+// Package, Function and CallCommon.\n+//\n+// TODO(adonovan): Provide an example skeleton application that loads\n+// and dumps the SSA form of a program.  Accommodate package-at-a-time\n+// vs. whole-program operation.\n+//\n+// TODO(adonovan): Consider the exceptional control-flow implications\n+// of defer and recover().\n+//\n+// TODO(adonovan): build tables/functions that relate source variables\n+// to SSA variables to assist user interfaces that make queries about\n+// specific source entities.\n+package ssa"}, {"sha": "3751839b287a9cfaeecb56601f5249e1b7f8e1db", "filename": "libgo/go/exp/ssa/func.go", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,416 @@\n+package ssa\n+\n+// This file implements the Function and BasicBlock types.\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/types\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Mode bits for additional diagnostics and checking.\n+// TODO(adonovan): move these to builder.go once submitted.\n+type BuilderMode uint\n+\n+const (\n+\tLogPackages          BuilderMode = 1 << iota // Dump package inventory to stderr\n+\tLogFunctions                                 // Dump function SSA code to stderr\n+\tLogSource                                    // Show source locations as SSA builder progresses\n+\tSanityCheckFunctions                         // Perform sanity checking of function bodies\n+\tUseGCImporter                                // Ignore SourceLoader; use gc-compiled object code for all imports\n+)\n+\n+// addEdge adds a control-flow graph edge from from to to.\n+func addEdge(from, to *BasicBlock) {\n+\tfrom.Succs = append(from.Succs, to)\n+\tto.Preds = append(to.Preds, from)\n+}\n+\n+// emit appends an instruction to the current basic block.\n+// If the instruction defines a Value, it is returned.\n+//\n+func (b *BasicBlock) emit(i Instruction) Value {\n+\ti.SetBlock(b)\n+\tb.Instrs = append(b.Instrs, i)\n+\tv, _ := i.(Value)\n+\treturn v\n+}\n+\n+// phis returns the prefix of b.Instrs containing all the block's \u03c6-nodes.\n+func (b *BasicBlock) phis() []Instruction {\n+\tfor i, instr := range b.Instrs {\n+\t\tif _, ok := instr.(*Phi); !ok {\n+\t\t\treturn b.Instrs[:i]\n+\t\t}\n+\t}\n+\treturn nil // unreachable in well-formed blocks\n+}\n+\n+// replacePred replaces all occurrences of p in b's predecessor list with q.\n+// Ordinarily there should be at most one.\n+//\n+func (b *BasicBlock) replacePred(p, q *BasicBlock) {\n+\tfor i, pred := range b.Preds {\n+\t\tif pred == p {\n+\t\t\tb.Preds[i] = q\n+\t\t}\n+\t}\n+}\n+\n+// replaceSucc replaces all occurrences of p in b's successor list with q.\n+// Ordinarily there should be at most one.\n+//\n+func (b *BasicBlock) replaceSucc(p, q *BasicBlock) {\n+\tfor i, succ := range b.Succs {\n+\t\tif succ == p {\n+\t\t\tb.Succs[i] = q\n+\t\t}\n+\t}\n+}\n+\n+// removePred removes all occurrences of p in b's\n+// predecessor list and \u03c6-nodes.\n+// Ordinarily there should be at most one.\n+//\n+func (b *BasicBlock) removePred(p *BasicBlock) {\n+\tphis := b.phis()\n+\n+\t// We must preserve edge order for \u03c6-nodes.\n+\tj := 0\n+\tfor i, pred := range b.Preds {\n+\t\tif pred != p {\n+\t\t\tb.Preds[j] = b.Preds[i]\n+\t\t\t// Strike out \u03c6-edge too.\n+\t\t\tfor _, instr := range phis {\n+\t\t\t\tphi := instr.(*Phi)\n+\t\t\t\tphi.Edges[j] = phi.Edges[i]\n+\t\t\t}\n+\t\t\tj++\n+\t\t}\n+\t}\n+\t// Nil out b.Preds[j:] and \u03c6-edges[j:] to aid GC.\n+\tfor i := j; i < len(b.Preds); i++ {\n+\t\tb.Preds[i] = nil\n+\t\tfor _, instr := range phis {\n+\t\t\tinstr.(*Phi).Edges[i] = nil\n+\t\t}\n+\t}\n+\tb.Preds = b.Preds[:j]\n+\tfor _, instr := range phis {\n+\t\tphi := instr.(*Phi)\n+\t\tphi.Edges = phi.Edges[:j]\n+\t}\n+}\n+\n+// Destinations associated with unlabelled for/switch/select stmts.\n+// We push/pop one of these as we enter/leave each construct and for\n+// each BranchStmt we scan for the innermost target of the right type.\n+//\n+type targets struct {\n+\ttail         *targets // rest of stack\n+\t_break       *BasicBlock\n+\t_continue    *BasicBlock\n+\t_fallthrough *BasicBlock\n+}\n+\n+// Destinations associated with a labelled block.\n+// We populate these as labels are encountered in forward gotos or\n+// labelled statements.\n+//\n+type lblock struct {\n+\t_goto     *BasicBlock\n+\t_break    *BasicBlock\n+\t_continue *BasicBlock\n+}\n+\n+// funcSyntax holds the syntax tree for the function declaration and body.\n+type funcSyntax struct {\n+\trecvField    *ast.FieldList\n+\tparamFields  *ast.FieldList\n+\tresultFields *ast.FieldList\n+\tbody         *ast.BlockStmt\n+}\n+\n+// labelledBlock returns the branch target associated with the\n+// specified label, creating it if needed.\n+//\n+func (f *Function) labelledBlock(label *ast.Ident) *lblock {\n+\tlb := f.lblocks[label.Obj]\n+\tif lb == nil {\n+\t\tlb = &lblock{_goto: f.newBasicBlock(\"label.\" + label.Name)}\n+\t\tf.lblocks[label.Obj] = lb\n+\t}\n+\treturn lb\n+}\n+\n+// addParam adds a (non-escaping) parameter to f.Params of the\n+// specified name and type.\n+//\n+func (f *Function) addParam(name string, typ types.Type) *Parameter {\n+\tv := &Parameter{\n+\t\tName_: name,\n+\t\tType_: pointer(typ), // address of param\n+\t}\n+\tf.Params = append(f.Params, v)\n+\treturn v\n+}\n+\n+func (f *Function) addObjParam(obj types.Object) *Parameter {\n+\tp := f.addParam(obj.GetName(), obj.GetType())\n+\tf.objects[obj] = p\n+\treturn p\n+}\n+\n+// start initializes the function prior to generating SSA code for its body.\n+// Precondition: f.Type() already set.\n+//\n+// If f.syntax != nil, f is a Go source function and idents must be a\n+// mapping from syntactic identifiers to their canonical type objects;\n+// Otherwise, idents is ignored and the usual set-up for Go source\n+// functions is skipped.\n+//\n+func (f *Function) start(mode BuilderMode, idents map[*ast.Ident]types.Object) {\n+\tif mode&LogSource != 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"build function %s @ %s\\n\", f.FullName(), f.Prog.Files.Position(f.Pos))\n+\t}\n+\tf.currentBlock = f.newBasicBlock(\"entry\")\n+\tf.objects = make(map[types.Object]Value) // needed for some synthetics, e.g. init\n+\tif f.syntax == nil {\n+\t\treturn // synthetic function; no syntax tree\n+\t}\n+\tf.lblocks = make(map[*ast.Object]*lblock)\n+\n+\t// Receiver (at most one inner iteration).\n+\tif f.syntax.recvField != nil {\n+\t\tfor _, field := range f.syntax.recvField.List {\n+\t\t\tfor _, n := range field.Names {\n+\t\t\t\tf.addObjParam(idents[n])\n+\t\t\t}\n+\t\t\tif field.Names == nil {\n+\t\t\t\tf.addParam(f.Signature.Recv.Name, f.Signature.Recv.Type)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Parameters.\n+\tif f.syntax.paramFields != nil {\n+\t\tfor _, field := range f.syntax.paramFields.List {\n+\t\t\tfor _, n := range field.Names {\n+\t\t\t\tf.addObjParam(idents[n])\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Results.\n+\tif f.syntax.resultFields != nil {\n+\t\tfor _, field := range f.syntax.resultFields.List {\n+\t\t\t// Implicit \"var\" decl of locals for named results.\n+\t\t\tfor _, n := range field.Names {\n+\t\t\t\tf.results = append(f.results, f.addNamedLocal(idents[n]))\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// finish() finalizes the function after SSA code generation of its body.\n+func (f *Function) finish(mode BuilderMode) {\n+\tf.objects = nil\n+\tf.results = nil\n+\tf.currentBlock = nil\n+\tf.lblocks = nil\n+\tf.syntax = nil\n+\n+\t// Remove any f.Locals that are now heap-allocated.\n+\tj := 0\n+\tfor _, l := range f.Locals {\n+\t\tif !l.Heap {\n+\t\t\tf.Locals[j] = l\n+\t\t\tj++\n+\t\t}\n+\t}\n+\t// Nil out f.Locals[j:] to aid GC.\n+\tfor i := j; i < len(f.Locals); i++ {\n+\t\tf.Locals[i] = nil\n+\t}\n+\tf.Locals = f.Locals[:j]\n+\n+\t// Ensure all value-defining Instructions have register names.\n+\t// (Non-Instruction Values are named at construction.)\n+\ttmp := 0\n+\tfor _, b := range f.Blocks {\n+\t\tfor _, instr := range b.Instrs {\n+\t\t\tswitch instr := instr.(type) {\n+\t\t\tcase *Alloc:\n+\t\t\t\t// Local Allocs may already be named.\n+\t\t\t\tif instr.Name_ == \"\" {\n+\t\t\t\t\tinstr.Name_ = fmt.Sprintf(\"t%d\", tmp)\n+\t\t\t\t\ttmp++\n+\t\t\t\t}\n+\t\t\tcase Value:\n+\t\t\t\tinstr.(interface {\n+\t\t\t\t\tsetNum(int)\n+\t\t\t\t}).setNum(tmp)\n+\t\t\t\ttmp++\n+\t\t\t}\n+\t\t}\n+\t}\n+\toptimizeBlocks(f)\n+\n+\tif mode&LogFunctions != 0 {\n+\t\tf.DumpTo(os.Stderr)\n+\t}\n+\tif mode&SanityCheckFunctions != 0 {\n+\t\tMustSanityCheck(f, nil)\n+\t}\n+\tif mode&LogSource != 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"build function %s done\\n\", f.FullName())\n+\t}\n+}\n+\n+// addNamedLocal creates a local variable, adds it to function f and\n+// returns it.  Its name and type are taken from obj.  Subsequent\n+// calls to f.lookup(obj) will return the same local.\n+//\n+// Precondition: f.syntax != nil (i.e. a Go source function).\n+//\n+func (f *Function) addNamedLocal(obj types.Object) *Alloc {\n+\tl := f.addLocal(obj.GetType())\n+\tl.Name_ = obj.GetName()\n+\tf.objects[obj] = l\n+\treturn l\n+}\n+\n+// addLocal creates an anonymous local variable of type typ, adds it\n+// to function f and returns it.\n+//\n+func (f *Function) addLocal(typ types.Type) *Alloc {\n+\tv := &Alloc{Type_: pointer(typ)}\n+\tf.Locals = append(f.Locals, v)\n+\tf.emit(v)\n+\treturn v\n+}\n+\n+// lookup returns the address of the named variable identified by obj\n+// that is local to function f or one of its enclosing functions.\n+// If escaping, the reference comes from a potentially escaping pointer\n+// expression and the referent must be heap-allocated.\n+//\n+func (f *Function) lookup(obj types.Object, escaping bool) Value {\n+\tif v, ok := f.objects[obj]; ok {\n+\t\tif escaping {\n+\t\t\tswitch v := v.(type) {\n+\t\t\tcase *Capture:\n+\t\t\t\t// TODO(adonovan): fix: we must support this case.\n+\t\t\t\t// Requires copying to a 'new' Alloc.\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"Error: escaping reference to Capture\")\n+\t\t\tcase *Parameter:\n+\t\t\t\tv.Heap = true\n+\t\t\tcase *Alloc:\n+\t\t\t\tv.Heap = true\n+\t\t\tdefault:\n+\t\t\t\tpanic(fmt.Sprintf(\"Unexpected Function.objects kind: %T\", v))\n+\t\t\t}\n+\t\t}\n+\t\treturn v // function-local var (address)\n+\t}\n+\n+\t// Definition must be in an enclosing function;\n+\t// plumb it through intervening closures.\n+\tif f.Enclosing == nil {\n+\t\tpanic(\"no Value for type.Object \" + obj.GetName())\n+\t}\n+\tv := &Capture{f.Enclosing.lookup(obj, true)} // escaping\n+\tf.objects[obj] = v\n+\tf.FreeVars = append(f.FreeVars, v)\n+\treturn v\n+}\n+\n+// emit emits the specified instruction to function f, updating the\n+// control-flow graph if required.\n+//\n+func (f *Function) emit(instr Instruction) Value {\n+\treturn f.currentBlock.emit(instr)\n+}\n+\n+// DumpTo prints to w a human readable \"disassembly\" of the SSA code of\n+// all basic blocks of function f.\n+//\n+func (f *Function) DumpTo(w io.Writer) {\n+\tfmt.Fprintf(w, \"# Name: %s\\n\", f.FullName())\n+\tfmt.Fprintf(w, \"# Declared at %s\\n\", f.Prog.Files.Position(f.Pos))\n+\tfmt.Fprintf(w, \"# Type: %s\\n\", f.Type())\n+\n+\tif f.Enclosing != nil {\n+\t\tfmt.Fprintf(w, \"# Parent: %s\\n\", f.Enclosing.Name())\n+\t}\n+\n+\tif f.FreeVars != nil {\n+\t\tio.WriteString(w, \"# Free variables:\\n\")\n+\t\tfor i, fv := range f.FreeVars {\n+\t\t\tfmt.Fprintf(w, \"# % 3d:\\t%s %s\\n\", i, fv.Name(), fv.Type())\n+\t\t}\n+\t}\n+\n+\tparams := f.Params\n+\tif f.Signature.Recv != nil {\n+\t\tfmt.Fprintf(w, \"func (%s) %s(\", params[0].Name(), f.Name())\n+\t\tparams = params[1:]\n+\t} else {\n+\t\tfmt.Fprintf(w, \"func %s(\", f.Name())\n+\t}\n+\tfor i, v := range params {\n+\t\tif i > 0 {\n+\t\t\tio.WriteString(w, \", \")\n+\t\t}\n+\t\tio.WriteString(w, v.Name())\n+\t}\n+\tio.WriteString(w, \"):\\n\")\n+\n+\tfor _, b := range f.Blocks {\n+\t\tif b == nil {\n+\t\t\t// Corrupt CFG.\n+\t\t\tfmt.Fprintf(w, \".nil:\\n\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tfmt.Fprintf(w, \".%s:\\t\\t\\t\\t\\t\\t\\t       P:%d S:%d\\n\", b.Name, len(b.Preds), len(b.Succs))\n+\t\tif false { // CFG debugging\n+\t\t\tfmt.Fprintf(w, \"\\t# CFG: %s --> %s --> %s\\n\", blockNames(b.Preds), b.Name, blockNames(b.Succs))\n+\t\t}\n+\t\tfor _, instr := range b.Instrs {\n+\t\t\tio.WriteString(w, \"\\t\")\n+\t\t\tif v, ok := instr.(Value); ok {\n+\t\t\t\tl := 80 // for old time's sake.\n+\t\t\t\t// Left-align the instruction.\n+\t\t\t\tif name := v.Name(); name != \"\" {\n+\t\t\t\t\tn, _ := fmt.Fprintf(w, \"%s = \", name)\n+\t\t\t\t\tl -= n\n+\t\t\t\t}\n+\t\t\t\tn, _ := io.WriteString(w, instr.String())\n+\t\t\t\tl -= n\n+\t\t\t\t// Right-align the type.\n+\t\t\t\tif t := v.Type(); t != nil {\n+\t\t\t\t\tfmt.Fprintf(w, \"%*s\", l-9, t)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tio.WriteString(w, instr.String())\n+\t\t\t}\n+\t\t\tio.WriteString(w, \"\\n\")\n+\t\t}\n+\t}\n+\tfmt.Fprintf(w, \"\\n\")\n+}\n+\n+// newBasicBlock adds to f a new basic block with a unique name and\n+// returns it.  It does not automatically become the current block for\n+// subsequent calls to emit.\n+//\n+func (f *Function) newBasicBlock(name string) *BasicBlock {\n+\tb := &BasicBlock{\n+\t\tName: fmt.Sprintf(\"%d.%s\", len(f.Blocks), name),\n+\t\tFunc: f,\n+\t}\n+\tf.Blocks = append(f.Blocks, b)\n+\treturn b\n+}"}, {"sha": "fa26c47e927197efab8f9305e6a46336da542c0e", "filename": "libgo/go/exp/ssa/literal.go", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fliteral.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,137 @@\n+package ssa\n+\n+// This file defines the Literal SSA value type.\n+\n+import (\n+\t\"fmt\"\n+\t\"go/types\"\n+\t\"math/big\"\n+\t\"strconv\"\n+)\n+\n+// newLiteral returns a new literal of the specified value and type.\n+// val must be valid according to the specification of Literal.Value.\n+//\n+func newLiteral(val interface{}, typ types.Type) *Literal {\n+\t// This constructor exists to provide a single place to\n+\t// insert logging/assertions during debugging.\n+\treturn &Literal{typ, val}\n+}\n+\n+// intLiteral returns an untyped integer literal that evaluates to i.\n+func intLiteral(i int64) *Literal {\n+\treturn newLiteral(i, types.Typ[types.UntypedInt])\n+}\n+\n+// nilLiteral returns a nil literal of the specified (reference) type.\n+func nilLiteral(typ types.Type) *Literal {\n+\treturn newLiteral(types.NilType{}, typ)\n+}\n+\n+func (l *Literal) Name() string {\n+\tvar s string\n+\tswitch x := l.Value.(type) {\n+\tcase bool:\n+\t\ts = fmt.Sprintf(\"%v\", l.Value)\n+\tcase int64:\n+\t\ts = fmt.Sprintf(\"%d\", l.Value)\n+\tcase *big.Int:\n+\t\ts = x.String()\n+\tcase *big.Rat:\n+\t\ts = x.FloatString(20)\n+\tcase string:\n+\t\tif len(x) > 20 {\n+\t\t\tx = x[:17] + \"...\" // abbreviate\n+\t\t}\n+\t\ts = strconv.Quote(x)\n+\tcase types.Complex:\n+\t\tr := x.Re.FloatString(20)\n+\t\ti := x.Im.FloatString(20)\n+\t\ts = fmt.Sprintf(\"%s+%si\", r, i)\n+\tcase types.NilType:\n+\t\ts = \"nil\"\n+\tdefault:\n+\t\tpanic(fmt.Sprintf(\"unexpected literal value: %T\", x))\n+\t}\n+\treturn s + \":\" + l.Type_.String()\n+}\n+\n+func (l *Literal) Type() types.Type {\n+\treturn l.Type_\n+}\n+\n+// IsNil returns true if this literal represents a typed or untyped nil value.\n+func (l *Literal) IsNil() bool {\n+\t_, ok := l.Value.(types.NilType)\n+\treturn ok\n+}\n+\n+// Int64 returns the numeric value of this literal truncated to fit\n+// a signed 64-bit integer.\n+//\n+func (l *Literal) Int64() int64 {\n+\tswitch x := l.Value.(type) {\n+\tcase int64:\n+\t\treturn x\n+\tcase *big.Int:\n+\t\treturn x.Int64()\n+\tcase *big.Rat:\n+\t\t// TODO(adonovan): fix: is this the right rounding mode?\n+\t\tvar q big.Int\n+\t\treturn q.Quo(x.Num(), x.Denom()).Int64()\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected literal value: %T\", l.Value))\n+}\n+\n+// Uint64 returns the numeric value of this literal truncated to fit\n+// an unsigned 64-bit integer.\n+//\n+func (l *Literal) Uint64() uint64 {\n+\tswitch x := l.Value.(type) {\n+\tcase int64:\n+\t\tif x < 0 {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn uint64(x)\n+\tcase *big.Int:\n+\t\treturn x.Uint64()\n+\tcase *big.Rat:\n+\t\t// TODO(adonovan): fix: is this right?\n+\t\tvar q big.Int\n+\t\treturn q.Quo(x.Num(), x.Denom()).Uint64()\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected literal value: %T\", l.Value))\n+}\n+\n+// Float64 returns the numeric value of this literal truncated to fit\n+// a float64.\n+//\n+func (l *Literal) Float64() float64 {\n+\tswitch x := l.Value.(type) {\n+\tcase int64:\n+\t\treturn float64(x)\n+\tcase *big.Int:\n+\t\tvar r big.Rat\n+\t\tf, _ := r.SetInt(x).Float64()\n+\t\treturn f\n+\tcase *big.Rat:\n+\t\tf, _ := x.Float64()\n+\t\treturn f\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected literal value: %T\", l.Value))\n+}\n+\n+// Complex128 returns the complex value of this literal truncated to\n+// fit a complex128.\n+//\n+func (l *Literal) Complex128() complex128 {\n+\tswitch x := l.Value.(type) {\n+\tcase int64, *big.Int, *big.Rat:\n+\t\treturn complex(l.Float64(), 0)\n+\tcase types.Complex:\n+\t\tre64, _ := x.Re.Float64()\n+\t\tim64, _ := x.Im.Float64()\n+\t\treturn complex(re64, im64)\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected literal value: %T\", l.Value))\n+}"}, {"sha": "b8708b6ede46a2bf7e0d9238135acb9d50df43d3", "filename": "libgo/go/exp/ssa/print.go", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fprint.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,383 @@\n+package ssa\n+\n+// This file implements the String() methods for all Value and\n+// Instruction types.\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/types\"\n+)\n+\n+func (id Id) String() string {\n+\tif id.Pkg == nil {\n+\t\treturn id.Name\n+\t}\n+\treturn fmt.Sprintf(\"%s/%s\", id.Pkg.Path, id.Name)\n+}\n+\n+// relName returns the name of v relative to i.\n+// In most cases, this is identical to v.Name(), but for cross-package\n+// references to Functions (including methods) and Globals, the\n+// package-qualified FullName is used instead.\n+//\n+func relName(v Value, i Instruction) string {\n+\tswitch v := v.(type) {\n+\tcase *Global:\n+\t\tif v.Pkg == i.Block().Func.Pkg {\n+\t\t\treturn v.Name()\n+\t\t}\n+\t\treturn v.FullName()\n+\tcase *Function:\n+\t\tif v.Pkg == nil || v.Pkg == i.Block().Func.Pkg {\n+\t\t\treturn v.Name()\n+\t\t}\n+\t\treturn v.FullName()\n+\t}\n+\treturn v.Name()\n+}\n+\n+// Value.String()\n+//\n+// This method is provided only for debugging.\n+// It never appears in disassembly, which uses Value.Name().\n+\n+func (v *Literal) String() string {\n+\treturn fmt.Sprintf(\"literal %s rep=%T\", v.Name(), v.Value)\n+}\n+\n+func (v *Parameter) String() string {\n+\treturn fmt.Sprintf(\"parameter %s : %s\", v.Name(), v.Type())\n+}\n+\n+func (v *Capture) String() string {\n+\treturn fmt.Sprintf(\"capture %s : %s\", v.Name(), v.Type())\n+}\n+\n+func (v *Global) String() string {\n+\treturn fmt.Sprintf(\"global %s : %s\", v.Name(), v.Type())\n+}\n+\n+func (v *Builtin) String() string {\n+\treturn fmt.Sprintf(\"builtin %s : %s\", v.Name(), v.Type())\n+}\n+\n+func (r *Function) String() string {\n+\treturn fmt.Sprintf(\"function %s : %s\", r.Name(), r.Type())\n+}\n+\n+// FullName returns the name of this function qualified by the\n+// package name, unless it is anonymous or synthetic.\n+//\n+// TODO(adonovan): move to func.go when it's submitted.\n+//\n+func (f *Function) FullName() string {\n+\tif f.Enclosing != nil || f.Pkg == nil {\n+\t\treturn f.Name_ // anonymous or synthetic\n+\t}\n+\treturn fmt.Sprintf(\"%s.%s\", f.Pkg.ImportPath, f.Name_)\n+}\n+\n+// FullName returns g's package-qualified name.\n+func (g *Global) FullName() string {\n+\treturn fmt.Sprintf(\"%s.%s\", g.Pkg.ImportPath, g.Name_)\n+}\n+\n+// Instruction.String()\n+\n+func (v *Alloc) String() string {\n+\top := \"local\"\n+\tif v.Heap {\n+\t\top = \"new\"\n+\t}\n+\treturn fmt.Sprintf(\"%s %s\", op, indirectType(v.Type()))\n+}\n+\n+func (v *Phi) String() string {\n+\tvar b bytes.Buffer\n+\tb.WriteString(\"phi [\")\n+\tfor i, edge := range v.Edges {\n+\t\tif i > 0 {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\t// Be robust against malformed CFG.\n+\t\tblockname := \"?\"\n+\t\tif v.Block_ != nil && i < len(v.Block_.Preds) {\n+\t\t\tblockname = v.Block_.Preds[i].Name\n+\t\t}\n+\t\tb.WriteString(blockname)\n+\t\tb.WriteString(\": \")\n+\t\tb.WriteString(relName(edge, v))\n+\t}\n+\tb.WriteString(\"]\")\n+\treturn b.String()\n+}\n+\n+func printCall(v *CallCommon, prefix string, instr Instruction) string {\n+\tvar b bytes.Buffer\n+\tb.WriteString(prefix)\n+\tif v.Func != nil {\n+\t\tb.WriteString(relName(v.Func, instr))\n+\t} else {\n+\t\tname := underlyingType(v.Recv.Type()).(*types.Interface).Methods[v.Method].Name\n+\t\tfmt.Fprintf(&b, \"invoke %s.%s [#%d]\", relName(v.Recv, instr), name, v.Method)\n+\t}\n+\tb.WriteString(\"(\")\n+\tfor i, arg := range v.Args {\n+\t\tif i > 0 {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\tb.WriteString(relName(arg, instr))\n+\t}\n+\tif v.HasEllipsis {\n+\t\tb.WriteString(\"...\")\n+\t}\n+\tb.WriteString(\")\")\n+\treturn b.String()\n+}\n+\n+func (v *Call) String() string {\n+\treturn printCall(&v.CallCommon, \"\", v)\n+}\n+\n+func (v *BinOp) String() string {\n+\treturn fmt.Sprintf(\"%s %s %s\", relName(v.X, v), v.Op.String(), relName(v.Y, v))\n+}\n+\n+func (v *UnOp) String() string {\n+\treturn fmt.Sprintf(\"%s%s%s\", v.Op, relName(v.X, v), commaOk(v.CommaOk))\n+}\n+\n+func (v *Conv) String() string {\n+\treturn fmt.Sprintf(\"convert %s <- %s (%s)\", v.Type(), v.X.Type(), relName(v.X, v))\n+}\n+\n+func (v *ChangeInterface) String() string {\n+\treturn fmt.Sprintf(\"change interface %s <- %s (%s)\", v.Type(), v.X.Type(), relName(v.X, v))\n+}\n+\n+func (v *MakeInterface) String() string {\n+\treturn fmt.Sprintf(\"make interface %s <- %s (%s)\", v.Type(), v.X.Type(), relName(v.X, v))\n+}\n+\n+func (v *MakeClosure) String() string {\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"make closure %s\", relName(v.Fn, v))\n+\tif v.Bindings != nil {\n+\t\tb.WriteString(\" [\")\n+\t\tfor i, c := range v.Bindings {\n+\t\t\tif i > 0 {\n+\t\t\t\tb.WriteString(\", \")\n+\t\t\t}\n+\t\t\tb.WriteString(relName(c, v))\n+\t\t}\n+\t\tb.WriteString(\"]\")\n+\t}\n+\treturn b.String()\n+}\n+\n+func (v *MakeSlice) String() string {\n+\tvar b bytes.Buffer\n+\tb.WriteString(\"make slice \")\n+\tb.WriteString(v.Type().String())\n+\tb.WriteString(\" \")\n+\tb.WriteString(relName(v.Len, v))\n+\tb.WriteString(\" \")\n+\tb.WriteString(relName(v.Cap, v))\n+\treturn b.String()\n+}\n+\n+func (v *Slice) String() string {\n+\tvar b bytes.Buffer\n+\tb.WriteString(\"slice \")\n+\tb.WriteString(relName(v.X, v))\n+\tb.WriteString(\"[\")\n+\tif v.Low != nil {\n+\t\tb.WriteString(relName(v.Low, v))\n+\t}\n+\tb.WriteString(\":\")\n+\tif v.High != nil {\n+\t\tb.WriteString(relName(v.High, v))\n+\t}\n+\tb.WriteString(\"]\")\n+\treturn b.String()\n+}\n+\n+func (v *MakeMap) String() string {\n+\tres := \"\"\n+\tif v.Reserve != nil {\n+\t\tres = relName(v.Reserve, v)\n+\t}\n+\treturn fmt.Sprintf(\"make %s %s\", v.Type(), res)\n+}\n+\n+func (v *MakeChan) String() string {\n+\treturn fmt.Sprintf(\"make %s %s\", v.Type(), relName(v.Size, v))\n+}\n+\n+func (v *FieldAddr) String() string {\n+\tfields := underlyingType(indirectType(v.X.Type())).(*types.Struct).Fields\n+\t// Be robust against a bad index.\n+\tname := \"?\"\n+\tif v.Field >= 0 && v.Field < len(fields) {\n+\t\tname = fields[v.Field].Name\n+\t}\n+\treturn fmt.Sprintf(\"&%s.%s [#%d]\", relName(v.X, v), name, v.Field)\n+}\n+\n+func (v *Field) String() string {\n+\tfields := underlyingType(v.X.Type()).(*types.Struct).Fields\n+\t// Be robust against a bad index.\n+\tname := \"?\"\n+\tif v.Field >= 0 && v.Field < len(fields) {\n+\t\tname = fields[v.Field].Name\n+\t}\n+\treturn fmt.Sprintf(\"%s.%s [#%d]\", relName(v.X, v), name, v.Field)\n+}\n+\n+func (v *IndexAddr) String() string {\n+\treturn fmt.Sprintf(\"&%s[%s]\", relName(v.X, v), relName(v.Index, v))\n+}\n+\n+func (v *Index) String() string {\n+\treturn fmt.Sprintf(\"%s[%s]\", relName(v.X, v), relName(v.Index, v))\n+}\n+\n+func (v *Lookup) String() string {\n+\treturn fmt.Sprintf(\"%s[%s]%s\", relName(v.X, v), relName(v.Index, v), commaOk(v.CommaOk))\n+}\n+\n+func (v *Range) String() string {\n+\treturn \"range \" + relName(v.X, v)\n+}\n+\n+func (v *Next) String() string {\n+\treturn \"next \" + relName(v.Iter, v)\n+}\n+\n+func (v *TypeAssert) String() string {\n+\treturn fmt.Sprintf(\"typeassert%s %s.(%s)\", commaOk(v.CommaOk), relName(v.X, v), v.AssertedType)\n+}\n+\n+func (v *Extract) String() string {\n+\treturn fmt.Sprintf(\"extract %s #%d\", relName(v.Tuple, v), v.Index)\n+}\n+\n+func (s *Jump) String() string {\n+\t// Be robust against malformed CFG.\n+\tblockname := \"?\"\n+\tif s.Block_ != nil && len(s.Block_.Succs) == 1 {\n+\t\tblockname = s.Block_.Succs[0].Name\n+\t}\n+\treturn fmt.Sprintf(\"jump %s\", blockname)\n+}\n+\n+func (s *If) String() string {\n+\t// Be robust against malformed CFG.\n+\ttblockname, fblockname := \"?\", \"?\"\n+\tif s.Block_ != nil && len(s.Block_.Succs) == 2 {\n+\t\ttblockname = s.Block_.Succs[0].Name\n+\t\tfblockname = s.Block_.Succs[1].Name\n+\t}\n+\treturn fmt.Sprintf(\"if %s goto %s else %s\", relName(s.Cond, s), tblockname, fblockname)\n+}\n+\n+func (s *Go) String() string {\n+\treturn printCall(&s.CallCommon, \"go \", s)\n+}\n+\n+func (s *Ret) String() string {\n+\tvar b bytes.Buffer\n+\tb.WriteString(\"ret\")\n+\tfor i, r := range s.Results {\n+\t\tif i == 0 {\n+\t\t\tb.WriteString(\" \")\n+\t\t} else {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\tb.WriteString(relName(r, s))\n+\t}\n+\treturn b.String()\n+}\n+\n+func (s *Send) String() string {\n+\treturn fmt.Sprintf(\"send %s <- %s\", relName(s.Chan, s), relName(s.X, s))\n+}\n+\n+func (s *Defer) String() string {\n+\treturn printCall(&s.CallCommon, \"defer \", s)\n+}\n+\n+func (s *Select) String() string {\n+\tvar b bytes.Buffer\n+\tfor i, st := range s.States {\n+\t\tif i > 0 {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\tif st.Dir == ast.RECV {\n+\t\t\tb.WriteString(\"<-\")\n+\t\t\tb.WriteString(relName(st.Chan, s))\n+\t\t} else {\n+\t\t\tb.WriteString(relName(st.Chan, s))\n+\t\t\tb.WriteString(\"<-\")\n+\t\t\tb.WriteString(relName(st.Send, s))\n+\t\t}\n+\t}\n+\tnon := \"\"\n+\tif !s.Blocking {\n+\t\tnon = \"non\"\n+\t}\n+\treturn fmt.Sprintf(\"select %sblocking [%s]\", non, b.String())\n+}\n+\n+func (s *Store) String() string {\n+\treturn fmt.Sprintf(\"*%s = %s\", relName(s.Addr, s), relName(s.Val, s))\n+}\n+\n+func (s *MapUpdate) String() string {\n+\treturn fmt.Sprintf(\"%s[%s] = %s\", relName(s.Map, s), relName(s.Key, s), relName(s.Value, s))\n+}\n+\n+func (p *Package) String() string {\n+\t// TODO(adonovan): prettify output.\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"Package %s at %s:\\n\", p.ImportPath, p.Prog.Files.File(p.Pos).Name())\n+\n+\t// TODO(adonovan): make order deterministic.\n+\tmaxname := 0\n+\tfor name := range p.Members {\n+\t\tif l := len(name); l > maxname {\n+\t\t\tmaxname = l\n+\t\t}\n+\t}\n+\n+\tfor name, mem := range p.Members {\n+\t\tswitch mem := mem.(type) {\n+\t\tcase *Literal:\n+\t\t\tfmt.Fprintf(&b, \" const %-*s %s\\n\", maxname, name, mem.Name())\n+\n+\t\tcase *Function:\n+\t\t\tfmt.Fprintf(&b, \" func  %-*s %s\\n\", maxname, name, mem.Type())\n+\n+\t\tcase *Type:\n+\t\t\tfmt.Fprintf(&b, \" type  %-*s %s\\n\", maxname, name, mem.NamedType.Underlying)\n+\t\t\t// TODO(adonovan): make order deterministic.\n+\t\t\tfor name, method := range mem.Methods {\n+\t\t\t\tfmt.Fprintf(&b, \"       method %s %s\\n\", name, method.Signature)\n+\t\t\t}\n+\n+\t\tcase *Global:\n+\t\t\tfmt.Fprintf(&b, \" var   %-*s %s\\n\", maxname, name, mem.Type())\n+\n+\t\t}\n+\t}\n+\treturn b.String()\n+}\n+\n+func commaOk(x bool) string {\n+\tif x {\n+\t\treturn \",ok\"\n+\t}\n+\treturn \"\"\n+}"}, {"sha": "bbb30cfcf46bf93d51ed3669ac41728113b930f5", "filename": "libgo/go/exp/ssa/sanity.go", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fsanity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fsanity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fsanity.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,263 @@\n+package ssa\n+\n+// An optional pass for sanity checking invariants of the SSA representation.\n+// Currently it checks CFG invariants but little at the instruction level.\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+type sanity struct {\n+\treporter io.Writer\n+\tfn       *Function\n+\tblock    *BasicBlock\n+\tinsane   bool\n+}\n+\n+// SanityCheck performs integrity checking of the SSA representation\n+// of the function fn and returns true if it was valid.  Diagnostics\n+// are written to reporter if non-nil, os.Stderr otherwise.  Some\n+// diagnostics are only warnings and do not imply a negative result.\n+//\n+// Sanity checking is intended to facilitate the debugging of code\n+// transformation passes.\n+//\n+func SanityCheck(fn *Function, reporter io.Writer) bool {\n+\tif reporter == nil {\n+\t\treporter = os.Stderr\n+\t}\n+\treturn (&sanity{reporter: reporter}).checkFunction(fn)\n+}\n+\n+// MustSanityCheck is like SanityCheck but panics instead of returning\n+// a negative result.\n+//\n+func MustSanityCheck(fn *Function, reporter io.Writer) {\n+\tif !SanityCheck(fn, reporter) {\n+\t\tpanic(\"SanityCheck failed\")\n+\t}\n+}\n+\n+// blockNames returns the names of the specified blocks as a\n+// human-readable string.\n+//\n+func blockNames(blocks []*BasicBlock) string {\n+\tvar buf bytes.Buffer\n+\tfor i, b := range blocks {\n+\t\tif i > 0 {\n+\t\t\tio.WriteString(&buf, \", \")\n+\t\t}\n+\t\tio.WriteString(&buf, b.Name)\n+\t}\n+\treturn buf.String()\n+}\n+\n+func (s *sanity) diagnostic(prefix, format string, args ...interface{}) {\n+\tfmt.Fprintf(s.reporter, \"%s: function %s\", prefix, s.fn.FullName())\n+\tif s.block != nil {\n+\t\tfmt.Fprintf(s.reporter, \", block %s\", s.block.Name)\n+\t}\n+\tio.WriteString(s.reporter, \": \")\n+\tfmt.Fprintf(s.reporter, format, args...)\n+\tio.WriteString(s.reporter, \"\\n\")\n+}\n+\n+func (s *sanity) errorf(format string, args ...interface{}) {\n+\ts.insane = true\n+\ts.diagnostic(\"Error\", format, args...)\n+}\n+\n+func (s *sanity) warnf(format string, args ...interface{}) {\n+\ts.diagnostic(\"Warning\", format, args...)\n+}\n+\n+// findDuplicate returns an arbitrary basic block that appeared more\n+// than once in blocks, or nil if all were unique.\n+func findDuplicate(blocks []*BasicBlock) *BasicBlock {\n+\tif len(blocks) < 2 {\n+\t\treturn nil\n+\t}\n+\tif blocks[0] == blocks[1] {\n+\t\treturn blocks[0]\n+\t}\n+\t// Slow path:\n+\tm := make(map[*BasicBlock]bool)\n+\tfor _, b := range blocks {\n+\t\tif m[b] {\n+\t\t\treturn b\n+\t\t}\n+\t\tm[b] = true\n+\t}\n+\treturn nil\n+}\n+\n+func (s *sanity) checkInstr(idx int, instr Instruction) {\n+\tswitch instr := instr.(type) {\n+\tcase *If, *Jump, *Ret:\n+\t\ts.errorf(\"control flow instruction not at end of block\")\n+\tcase *Phi:\n+\t\tif idx == 0 {\n+\t\t\t// It suffices to apply this check to just the first phi node.\n+\t\t\tif dup := findDuplicate(s.block.Preds); dup != nil {\n+\t\t\t\ts.errorf(\"phi node in block with duplicate predecessor %s\", dup.Name)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tprev := s.block.Instrs[idx-1]\n+\t\t\tif _, ok := prev.(*Phi); !ok {\n+\t\t\t\ts.errorf(\"Phi instruction follows a non-Phi: %T\", prev)\n+\t\t\t}\n+\t\t}\n+\t\tif ne, np := len(instr.Edges), len(s.block.Preds); ne != np {\n+\t\t\ts.errorf(\"phi node has %d edges but %d predecessors\", ne, np)\n+\t\t}\n+\n+\tcase *Alloc:\n+\tcase *Call:\n+\tcase *BinOp:\n+\tcase *UnOp:\n+\tcase *MakeClosure:\n+\tcase *MakeChan:\n+\tcase *MakeMap:\n+\tcase *MakeSlice:\n+\tcase *Slice:\n+\tcase *Field:\n+\tcase *FieldAddr:\n+\tcase *IndexAddr:\n+\tcase *Index:\n+\tcase *Select:\n+\tcase *Range:\n+\tcase *TypeAssert:\n+\tcase *Extract:\n+\tcase *Go:\n+\tcase *Defer:\n+\tcase *Send:\n+\tcase *Store:\n+\tcase *MapUpdate:\n+\tcase *Next:\n+\tcase *Lookup:\n+\tcase *Conv:\n+\tcase *ChangeInterface:\n+\tcase *MakeInterface:\n+\t\t// TODO(adonovan): implement checks.\n+\tdefault:\n+\t\tpanic(fmt.Sprintf(\"Unknown instruction type: %T\", instr))\n+\t}\n+}\n+\n+func (s *sanity) checkFinalInstr(idx int, instr Instruction) {\n+\tswitch instr.(type) {\n+\tcase *If:\n+\t\tif nsuccs := len(s.block.Succs); nsuccs != 2 {\n+\t\t\ts.errorf(\"If-terminated block has %d successors; expected 2\", nsuccs)\n+\t\t\treturn\n+\t\t}\n+\t\tif s.block.Succs[0] == s.block.Succs[1] {\n+\t\t\ts.errorf(\"If-instruction has same True, False target blocks: %s\", s.block.Succs[0].Name)\n+\t\t\treturn\n+\t\t}\n+\n+\tcase *Jump:\n+\t\tif nsuccs := len(s.block.Succs); nsuccs != 1 {\n+\t\t\ts.errorf(\"Jump-terminated block has %d successors; expected 1\", nsuccs)\n+\t\t\treturn\n+\t\t}\n+\n+\tcase *Ret:\n+\t\tif nsuccs := len(s.block.Succs); nsuccs != 0 {\n+\t\t\ts.errorf(\"Ret-terminated block has %d successors; expected none\", nsuccs)\n+\t\t\treturn\n+\t\t}\n+\t\t// TODO(adonovan): check number and types of results\n+\n+\tdefault:\n+\t\ts.errorf(\"non-control flow instruction at end of block\")\n+\t}\n+}\n+\n+func (s *sanity) checkBlock(b *BasicBlock, isEntry bool) {\n+\ts.block = b\n+\n+\t// Check all blocks are reachable.\n+\t// (The entry block is always implicitly reachable.)\n+\tif !isEntry && len(b.Preds) == 0 {\n+\t\ts.warnf(\"unreachable block\")\n+\t\tif b.Instrs == nil {\n+\t\t\t// Since this block is about to be pruned,\n+\t\t\t// tolerating transient problems in it\n+\t\t\t// simplifies other optimisations.\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// Check predecessor and successor relations are dual.\n+\tfor _, a := range b.Preds {\n+\t\tfound := false\n+\t\tfor _, bb := range a.Succs {\n+\t\t\tif bb == b {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\ts.errorf(\"expected successor edge in predecessor %s; found only: %s\", a.Name, blockNames(a.Succs))\n+\t\t}\n+\t}\n+\tfor _, c := range b.Succs {\n+\t\tfound := false\n+\t\tfor _, bb := range c.Preds {\n+\t\t\tif bb == b {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\ts.errorf(\"expected predecessor edge in successor %s; found only: %s\", c.Name, blockNames(c.Preds))\n+\t\t}\n+\t}\n+\n+\t// Check each instruction is sane.\n+\tn := len(b.Instrs)\n+\tif n == 0 {\n+\t\ts.errorf(\"basic block contains no instructions\")\n+\t}\n+\tfor j, instr := range b.Instrs {\n+\t\tif b2 := instr.Block(); b2 == nil {\n+\t\t\ts.errorf(\"nil Block() for instruction at index %d\", j)\n+\t\t\tcontinue\n+\t\t} else if b2 != b {\n+\t\t\ts.errorf(\"wrong Block() (%s) for instruction at index %d \", b2.Name, j)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif j < n-1 {\n+\t\t\ts.checkInstr(j, instr)\n+\t\t} else {\n+\t\t\ts.checkFinalInstr(j, instr)\n+\t\t}\n+\t}\n+}\n+\n+func (s *sanity) checkFunction(fn *Function) bool {\n+\t// TODO(adonovan): check Function invariants:\n+\t// - check owning Package (if any) contains this function.\n+\t// - check params match signature\n+\t// - check locals are all !Heap\n+\t// - check transient fields are nil\n+\t// - check block labels are unique (warning)\n+\ts.fn = fn\n+\tif fn.Prog == nil {\n+\t\ts.errorf(\"nil Prog\")\n+\t}\n+\tfor i, b := range fn.Blocks {\n+\t\tif b == nil {\n+\t\t\ts.warnf(\"nil *BasicBlock at f.Blocks[%d]\", i)\n+\t\t\tcontinue\n+\t\t}\n+\t\ts.checkBlock(b, i == 0)\n+\t}\n+\ts.block = nil\n+\ts.fn = nil\n+\treturn !s.insane\n+}"}, {"sha": "8e503dc35b8ea7782f1018e7e2fa8dea5b9aca4c", "filename": "libgo/go/exp/ssa/ssa.go", "status": "added", "additions": 1112, "deletions": 0, "changes": 1112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,1112 @@\n+package ssa\n+\n+// This package defines a high-level intermediate representation for\n+// Go programs using static single-assignment (SSA) form.\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/token\"\n+\t\"go/types\"\n+)\n+\n+// A Program is a partial or complete Go program converted to SSA form.\n+// Each Builder creates and populates a single Program during its\n+// lifetime.\n+//\n+// TODO(adonovan): synthetic methods for promoted methods and for\n+// standalone interface methods do not belong to any package.  Make\n+// them enumerable here.\n+//\n+// TODO(adonovan): MethodSets of types other than named types\n+// (i.e. anon structs) are not currently accessible, nor are they\n+// memoized.  Add a method: MethodSetForType() which looks in the\n+// appropriate Package (for methods of named types) or in\n+// Program.AnonStructMethods (for methods of anon structs).\n+//\n+type Program struct {\n+\tFiles    *token.FileSet            // position information for the files of this Program\n+\tPackages map[string]*Package       // all loaded Packages, keyed by import path\n+\tBuiltins map[types.Object]*Builtin // all built-in functions, keyed by typechecker objects.\n+}\n+\n+// A Package is a single analyzed Go package, containing Members for\n+// all package-level functions, variables, constants and types it\n+// declares.  These may be accessed directly via Members, or via the\n+// type-specific accessor methods Func, Type, Var and Const.\n+//\n+type Package struct {\n+\tProg       *Program          // the owning program\n+\tTypes      *types.Package    // the type checker's package object for this package.\n+\tImportPath string            // e.g. \"sync/atomic\"\n+\tPos        token.Pos         // position of an arbitrary file in the package\n+\tMembers    map[string]Member // all exported and unexported members of the package\n+\tAnonFuncs  []*Function       // all anonymous functions in this package\n+\tInit       *Function         // the package's (concatenated) init function\n+\n+\t// The following fields are set transiently during building,\n+\t// then cleared.\n+\tfiles []*ast.File // the abstract syntax tree for the files of the package\n+}\n+\n+// A Member is a member of a Go package, implemented by *Literal,\n+// *Global, *Function, or *Type; they are created by package-level\n+// const, var, func and type declarations respectively.\n+//\n+type Member interface {\n+\tName() string      // the declared name of the package member\n+\tString() string    // human-readable information about the value\n+\tType() types.Type  // the type of the package member\n+\tImplementsMember() // dummy method to indicate the \"implements\" relation.\n+}\n+\n+// An Id identifies the name of a field of a struct type, or the name\n+// of a method of an interface or a named type.\n+//\n+// For exported names, i.e. those beginning with a Unicode upper-case\n+// letter, a simple string is unambiguous.\n+//\n+// However, a method set or struct may contain multiple unexported\n+// names with identical spelling that are logically distinct because\n+// they originate in different packages.  Unexported names must\n+// therefore be disambiguated by their package too.\n+//\n+// The Pkg field of an Id is therefore nil iff the name is exported.\n+//\n+// This type is suitable for use as a map key because the equivalence\n+// relation == is consistent with identifier equality.\n+type Id struct {\n+\tPkg  *types.Package\n+\tName string\n+}\n+\n+// A MethodSet contains all the methods whose receiver is either T or\n+// *T, for some named or struct type T.\n+//\n+// TODO(adonovan): the client is required to adapt T<=>*T, e.g. when\n+// invoking an interface method.  (This could be simplified for the\n+// client by having distinct method sets for T and *T, with the SSA\n+// Builder generating wrappers as needed, but probably the client is\n+// able to do a better job.)  Document the precise rules the client\n+// must follow.\n+//\n+type MethodSet map[Id]*Function\n+\n+// A Type is a Member of a Package representing the name, underlying\n+// type and method set of a named type declared at package scope.\n+//\n+// The method set contains only concrete methods; it is empty for\n+// interface types.\n+//\n+type Type struct {\n+\tNamedType *types.NamedType\n+\tMethods   MethodSet\n+}\n+\n+// An SSA value that can be referenced by an instruction.\n+//\n+// TODO(adonovan): add methods:\n+// - Referrers() []*Instruction // all instructions that refer to this value.\n+//\n+type Value interface {\n+\t// Name returns the name of this value, and determines how\n+\t// this Value appears when used as an operand of an\n+\t// Instruction.\n+\t//\n+\t// This is the same as the source name for Parameters,\n+\t// Builtins, Functions, Captures, Globals and some Allocs.\n+\t// For literals, it is a representation of the literal's value\n+\t// and type.  For all other Values this is the name of the\n+\t// virtual register defined by the instruction.\n+\t//\n+\t// The name of an SSA Value is not semantically significant,\n+\t// and may not even be unique within a function.\n+\tName() string\n+\n+\t// If this value is an Instruction, String returns its\n+\t// disassembled form; otherwise it returns unspecified\n+\t// human-readable information about the Value, such as its\n+\t// kind, name and type.\n+\tString() string\n+\n+\t// Type returns the type of this value.  Many instructions\n+\t// (e.g. IndexAddr) change the behaviour depending on the\n+\t// types of their operands.\n+\t//\n+\t// Documented type invariants below (e.g. \"Alloc.Type()\n+\t// returns a *types.Pointer\") refer to the underlying type in\n+\t// the case of NamedTypes.\n+\tType() types.Type\n+\n+\t// Dummy method to indicate the \"implements\" relation.\n+\tImplementsValue()\n+}\n+\n+// An Instruction is an SSA instruction that computes a new Value or\n+// has some effect.\n+//\n+// An Instruction that defines a value (e.g. BinOp) also implements\n+// the Value interface; an Instruction that only has an effect (e.g. Store)\n+// does not.\n+//\n+// TODO(adonovan): add method:\n+// - Operands() []Value  // all Values referenced by this instruction.\n+//\n+type Instruction interface {\n+\t// String returns the disassembled form of this value.  e.g.\n+\t//\n+\t// Examples of Instructions that define a Value:\n+\t// e.g.  \"x + y\"     (BinOp)\n+\t//       \"len([])\"   (Call)\n+\t// Note that the name of the Value is not printed.\n+\t//\n+\t// Examples of Instructions that do define (are) Values:\n+\t// e.g.  \"ret x\"     (Ret)\n+\t//       \"*y = x\"    (Store)\n+\t//\n+\t// (This separation is useful for some analyses which\n+\t// distinguish the operation from the value it\n+\t// defines. e.g. 'y = local int' is both an allocation of\n+\t// memory 'local int' and a definition of a pointer y.)\n+\tString() string\n+\n+\t// Block returns the basic block to which this instruction\n+\t// belongs.\n+\tBlock() *BasicBlock\n+\n+\t// SetBlock sets the basic block to which this instruction\n+\t// belongs.\n+\tSetBlock(*BasicBlock)\n+\n+\t// Dummy method to indicate the \"implements\" relation.\n+\tImplementsInstruction()\n+}\n+\n+// Function represents the parameters, results and code of a function\n+// or method.\n+//\n+// If Blocks is nil, this indicates an external function for which no\n+// Go source code is available.  In this case, Captures and Locals\n+// will be nil too.  Clients performing whole-program analysis must\n+// handle external functions specially.\n+//\n+// Functions are immutable values; they do not have addresses.\n+//\n+// Blocks[0] is the function entry point; block order is not otherwise\n+// semantically significant, though it may affect the readability of\n+// the disassembly.\n+//\n+// A nested function that refers to one or more lexically enclosing\n+// local variables (\"free variables\") has Capture parameters.  Such\n+// functions cannot be called directly but require a value created by\n+// MakeClosure which, via its Bindings, supplies values for these\n+// parameters.  Captures are always addresses.\n+//\n+// If the function is a method (Signature.Recv != nil) then the first\n+// element of Params is the receiver parameter.\n+//\n+// Type() returns the function's Signature.\n+//\n+type Function struct {\n+\tName_     string\n+\tSignature *types.Signature\n+\n+\tPos       token.Pos // location of the definition\n+\tEnclosing *Function // enclosing function if anon; nil if global\n+\tPkg       *Package  // enclosing package; nil for some synthetic methods\n+\tProg      *Program  // enclosing program\n+\tParams    []*Parameter\n+\tFreeVars  []*Capture // free variables whose values must be supplied by closure\n+\tLocals    []*Alloc\n+\tBlocks    []*BasicBlock // basic blocks of the function; nil => external\n+\n+\t// The following fields are set transiently during building,\n+\t// then cleared.\n+\tcurrentBlock *BasicBlock             // where to emit code\n+\tobjects      map[types.Object]Value  // addresses of local variables\n+\tresults      []*Alloc                // tuple of named results\n+\tsyntax       *funcSyntax             // abstract syntax trees for Go source functions\n+\ttargets      *targets                // linked stack of branch targets\n+\tlblocks      map[*ast.Object]*lblock // labelled blocks\n+}\n+\n+// An SSA basic block.\n+//\n+// The final element of Instrs is always an explicit transfer of\n+// control (If, Jump or Ret).\n+//\n+// A block may contain no Instructions only if it is unreachable,\n+// i.e. Preds is nil.  Empty blocks are typically pruned.\n+//\n+// BasicBlocks and their Preds/Succs relation form a (possibly cyclic)\n+// graph independent of the SSA Value graph.  It is illegal for\n+// multiple edges to exist between the same pair of blocks.\n+//\n+// The order of Preds and Succs are significant (to Phi and If\n+// instructions, respectively).\n+//\n+type BasicBlock struct {\n+\tName         string        // label; no semantic significance\n+\tFunc         *Function     // containing function\n+\tInstrs       []Instruction // instructions in order\n+\tPreds, Succs []*BasicBlock // predecessors and successors\n+}\n+\n+// Pure values ----------------------------------------\n+\n+// A Capture is a pointer to a lexically enclosing local variable.\n+//\n+// The referent of a capture is a Parameter, Alloc or another Capture\n+// and is always considered potentially escaping, so Captures are\n+// always addresses in the heap, and have pointer types.\n+//\n+type Capture struct {\n+\tOuter Value // the Value captured from the enclosing context.\n+}\n+\n+// A Parameter represents an input parameter of a function.\n+//\n+// Parameters are addresses and thus have pointer types.\n+// TODO(adonovan): this will change.  We should just spill parameters\n+// to ordinary Alloc-style locals if they are ever used in an\n+// addressable context.  Then we can lose the Heap flag.\n+//\n+// In the common case where Heap=false, Parameters are pointers into\n+// the function's stack frame.  If the case where Heap=true because a\n+// parameter's address may escape from its function, Parameters are\n+// pointers into a space in the heap implicitly allocated during the\n+// function call.  (See also Alloc, which uses the Heap flag in a\n+// similar manner.)\n+//\n+type Parameter struct {\n+\tName_ string\n+\tType_ *types.Pointer\n+\tHeap  bool\n+}\n+\n+// A Literal represents a literal nil, boolean, string or numeric\n+// (integer, fraction or complex) value.\n+//\n+// A literal's underlying Type() can be a basic type, possibly one of\n+// the \"untyped\" types.  A nil literal can have any reference type:\n+// interface, map, channel, pointer, slice, or function---but not\n+// \"untyped nil\".\n+//\n+// All source-level constant expressions are represented by a Literal\n+// of equal type and value.\n+//\n+// Value holds the exact value of the literal, independent of its\n+// Type(), using the same representation as package go/types uses for\n+// constants.\n+//\n+// Example printed form:\n+// \t42:int\n+//\t\"hello\":untyped string\n+//\t3+4i:MyComplex\n+//\n+type Literal struct {\n+\tType_ types.Type\n+\tValue interface{}\n+}\n+\n+// A Global is a named Value holding the address of a package-level\n+// variable.\n+//\n+type Global struct {\n+\tName_ string\n+\tType_ types.Type\n+\tPkg   *Package\n+\n+\t// The following fields are set transiently during building,\n+\t// then cleared.\n+\tspec *ast.ValueSpec // explained at buildGlobal\n+}\n+\n+// A built-in function, e.g. len.\n+//\n+// Builtins are immutable values; they do not have addresses.\n+//\n+// Type() returns an inscrutable *types.builtin.  Built-in functions\n+// may have polymorphic or variadic types that are not expressible in\n+// Go's type system.\n+//\n+type Builtin struct {\n+\tObject *types.Func // canonical types.Universe object for this built-in\n+}\n+\n+// Value-defining instructions  ----------------------------------------\n+\n+// The Alloc instruction reserves space for a value of the given type,\n+// zero-initializes it, and yields its address.\n+//\n+// Alloc values are always addresses, and have pointer types, so the\n+// type of the allocated space is actually indirect(Type()).\n+//\n+// If Heap is false, Alloc allocates space in the function's\n+// activation record (frame); we refer to an Alloc(Heap=false) as a\n+// \"local\" alloc.  Each local Alloc returns the same address each time\n+// it is executed within the same activation; the space is\n+// re-initialized to zero.\n+//\n+// If Heap is true, Alloc allocates space in the heap, and returns; we\n+// refer to an Alloc(Heap=true) as a \"new\" alloc.  Each new Alloc\n+// returns a different address each time it is executed.\n+//\n+// When Alloc is applied to a channel, map or slice type, it returns\n+// the address of an uninitialized (nil) reference of that kind; store\n+// the result of MakeSlice, MakeMap or MakeChan in that location to\n+// instantiate these types.\n+//\n+// Example printed form:\n+// \tt0 = local int\n+// \tt1 = new int\n+//\n+type Alloc struct {\n+\tanInstruction\n+\tName_ string\n+\tType_ types.Type\n+\tHeap  bool\n+}\n+\n+// Phi represents an SSA \u03c6-node, which combines values that differ\n+// across incoming control-flow edges and yields a new value.  Within\n+// a block, all \u03c6-nodes must appear before all non-\u03c6 nodes.\n+//\n+// Example printed form:\n+// \tt2 = phi [0.start: t0, 1.if.then: t1, ...]\n+//\n+type Phi struct {\n+\tRegister\n+\tEdges []Value // Edges[i] is value for Block().Preds[i]\n+}\n+\n+// Call represents a function or method call.\n+//\n+// The Call instruction yields the function result, if there is\n+// exactly one, or a tuple (empty or len>1) whose components are\n+// accessed via Extract.\n+//\n+// See CallCommon for generic function call documentation.\n+//\n+// Example printed form:\n+// \tt2 = println(t0, t1)\n+// \tt4 = t3()\n+// \tt7 = invoke t5.Println(...t6)\n+//\n+type Call struct {\n+\tRegister\n+\tCallCommon\n+}\n+\n+// BinOp yields the result of binary operation X Op Y.\n+//\n+// Example printed form:\n+// \tt1 = t0 + 1:int\n+//\n+type BinOp struct {\n+\tRegister\n+\t// One of:\n+\t// ADD SUB MUL QUO REM          + - * / %\n+\t// AND OR XOR SHL SHR AND_NOT   & | ^ << >> &~\n+\t// EQL LSS GTR NEQ LEQ GEQ      == != < <= < >=\n+\tOp   token.Token\n+\tX, Y Value\n+}\n+\n+// UnOp yields the result of Op X.\n+// ARROW is channel receive.\n+// MUL is pointer indirection (load).\n+//\n+// If CommaOk and Op=ARROW, the result is a 2-tuple of the value above\n+// and a boolean indicating the success of the receive.  The\n+// components of the tuple are accessed using Extract.\n+//\n+// Example printed form:\n+// \tt0 = *x\n+// \tt2 = <-t1,ok\n+//\n+type UnOp struct {\n+\tRegister\n+\tOp      token.Token // One of: NOT SUB ARROW MUL XOR ! - <- * ^\n+\tX       Value\n+\tCommaOk bool\n+}\n+\n+// Conv yields the conversion of X to type Type().\n+//\n+// A conversion is one of the following kinds.  The behaviour of the\n+// conversion operator may depend on both Type() and X.Type(), as well\n+// as the dynamic value.\n+//\n+// A '+' indicates that a dynamic representation change may occur.\n+// A '-' indicates that the conversion is a value-preserving change\n+// to types only.\n+//\n+// 1. implicit conversions (arising from assignability rules):\n+//    - adding/removing a name, same underlying types.\n+//    - channel type restriction, possibly adding/removing a name.\n+// 2. explicit conversions (in addition to the above):\n+//    - changing a name, same underlying types.\n+//    - between pointers to identical base types.\n+//    + conversions between real numeric types.\n+//    + conversions between complex numeric types.\n+//    + integer/[]byte/[]rune -> string.\n+//    + string -> []byte/[]rune.\n+//\n+// TODO(adonovan): split into two cases:\n+// - rename value (ChangeType)\n+// + value to type with different representation (Conv)\n+//\n+// Conversions of untyped string/number/bool constants to a specific\n+// representation are eliminated during SSA construction.\n+//\n+// Example printed form:\n+// \tt1 = convert interface{} <- int (t0)\n+//\n+type Conv struct {\n+\tRegister\n+\tX Value\n+}\n+\n+// ChangeInterface constructs a value of one interface type from a\n+// value of another interface type known to be assignable to it.\n+//\n+// Example printed form:\n+// \tt1 = change interface interface{} <- I (t0)\n+//\n+type ChangeInterface struct {\n+\tRegister\n+\tX Value\n+}\n+\n+// MakeInterface constructs an instance of an interface type from a\n+// value and its method-set.\n+//\n+// To construct the zero value of an interface type T, use:\n+// \t&Literal{types.nilType{}, T}\n+//\n+// Example printed form:\n+// \tt1 = make interface interface{} <- int (42:int)\n+//\n+type MakeInterface struct {\n+\tRegister\n+\tX       Value\n+\tMethods MethodSet // method set of (non-interface) X iff converting to interface\n+}\n+\n+// A MakeClosure instruction yields an anonymous function value whose\n+// code is Fn and whose lexical capture slots are populated by Bindings.\n+//\n+// By construction, all captured variables are addresses of variables\n+// allocated with 'new', i.e. Alloc(Heap=true).\n+//\n+// Type() returns a *types.Signature.\n+//\n+// Example printed form:\n+// \tt0 = make closure anon@1.2 [x y z]\n+//\n+type MakeClosure struct {\n+\tRegister\n+\tFn       *Function\n+\tBindings []Value // values for each free variable in Fn.FreeVars\n+}\n+\n+// The MakeMap instruction creates a new hash-table-based map object\n+// and yields a value of kind map.\n+//\n+// Type() returns a *types.Map.\n+//\n+// Example printed form:\n+// \tt1 = make map[string]int t0\n+//\n+type MakeMap struct {\n+\tRegister\n+\tReserve Value // initial space reservation; nil => default\n+}\n+\n+// The MakeChan instruction creates a new channel object and yields a\n+// value of kind chan.\n+//\n+// Type() returns a *types.Chan.\n+//\n+// Example printed form:\n+// \tt0 = make chan int 0\n+//\n+type MakeChan struct {\n+\tRegister\n+\tSize Value // int; size of buffer; zero => synchronous.\n+}\n+\n+// MakeSlice yields a slice of length Len backed by a newly allocated\n+// array of length Cap.\n+//\n+// Both Len and Cap must be non-nil Values of integer type.\n+//\n+// (Alloc(types.Array) followed by Slice will not suffice because\n+// Alloc can only create arrays of statically known length.)\n+//\n+// Type() returns a *types.Slice.\n+//\n+// Example printed form:\n+// \tt1 = make slice []string 1:int t0\n+//\n+type MakeSlice struct {\n+\tRegister\n+\tLen Value\n+\tCap Value\n+}\n+\n+// Slice yields a slice of an existing string, slice or *array X\n+// between optional integer bounds Low and High.\n+//\n+// Type() returns string if the type of X was string, otherwise a\n+// *types.Slice with the same element type as X.\n+//\n+// Example printed form:\n+// \tt1 = slice t0[1:]\n+//\n+type Slice struct {\n+\tRegister\n+\tX         Value // slice, string, or *array\n+\tLow, High Value // either may be nil\n+}\n+\n+// FieldAddr yields the address of Field of *struct  X.\n+//\n+// The field is identified by its index within the field list of the\n+// struct type of X.\n+//\n+// Type() returns a *types.Pointer.\n+//\n+// Example printed form:\n+// \tt1 = &t0.name [#1]\n+//\n+type FieldAddr struct {\n+\tRegister\n+\tX     Value // *struct\n+\tField int   // index into X.Type().(*types.Struct).Fields\n+}\n+\n+// Field yields the Field of struct X.\n+//\n+// The field is identified by its index within the field list of the\n+// struct type of X; by using numeric indices we avoid ambiguity of\n+// package-local identifiers and permit compact representations.\n+//\n+// Example printed form:\n+// \tt1 = t0.name [#1]\n+//\n+type Field struct {\n+\tRegister\n+\tX     Value // struct\n+\tField int   // index into X.Type().(*types.Struct).Fields\n+}\n+\n+// IndexAddr yields the address of the element at index Index of\n+// collection X.  Index is an integer expression.\n+//\n+// The elements of maps and strings are not addressable; use Lookup or\n+// MapUpdate instead.\n+//\n+// Type() returns a *types.Pointer.\n+//\n+// Example printed form:\n+// \tt2 = &t0[t1]\n+//\n+type IndexAddr struct {\n+\tRegister\n+\tX     Value // slice or *array,\n+\tIndex Value // numeric index\n+}\n+\n+// Index yields element Index of array X.\n+//\n+// TODO(adonovan): permit X to have type slice.\n+// Currently this requires IndexAddr followed by Load.\n+//\n+// Example printed form:\n+// \tt2 = t0[t1]\n+//\n+type Index struct {\n+\tRegister\n+\tX     Value // array\n+\tIndex Value // integer index\n+}\n+\n+// Lookup yields element Index of collection X, a map or string.\n+// Index is an integer expression if X is a string or the appropriate\n+// key type if X is a map.\n+//\n+// If CommaOk, the result is a 2-tuple of the value above and a\n+// boolean indicating the result of a map membership test for the key.\n+// The components of the tuple are accessed using Extract.\n+//\n+// Example printed form:\n+// \tt2 = t0[t1]\n+// \tt5 = t3[t4],ok\n+//\n+type Lookup struct {\n+\tRegister\n+\tX       Value // string or map\n+\tIndex   Value // numeric or key-typed index\n+\tCommaOk bool  // return a value,ok pair\n+}\n+\n+// SelectState is a helper for Select.\n+// It represents one goal state and its corresponding communication.\n+//\n+type SelectState struct {\n+\tDir  ast.ChanDir // direction of case\n+\tChan Value       // channel to use (for send or receive)\n+\tSend Value       // value to send (for send)\n+}\n+\n+// Select tests whether (or blocks until) one or more of the specified\n+// sent or received states is entered.\n+//\n+// It returns a triple (index int, recv ?, recvOk bool) whose\n+// components, described below, must be accessed via the Extract\n+// instruction.\n+//\n+// If Blocking, select waits until exactly one state holds, i.e. a\n+// channel becomes ready for the designated operation of sending or\n+// receiving; select chooses one among the ready states\n+// pseudorandomly, performs the send or receive operation, and sets\n+// 'index' to the index of the chosen channel.\n+//\n+// If !Blocking, select doesn't block if no states hold; instead it\n+// returns immediately with index equal to -1.\n+//\n+// If the chosen channel was used for a receive, 'recv' is set to the\n+// received value; Otherwise it is unspecified.  recv has no useful\n+// type since it is conceptually the union of all possible received\n+// values.\n+//\n+// The third component of the triple, recvOk, is a boolean whose value\n+// is true iff the selected operation was a receive and the receive\n+// successfully yielded a value.\n+//\n+// Example printed form:\n+// \tt3 = select nonblocking [<-t0, t1<-t2, ...]\n+// \tt4 = select blocking []\n+//\n+type Select struct {\n+\tRegister\n+\tStates   []SelectState\n+\tBlocking bool\n+}\n+\n+// Range yields an iterator over the domain and range of X.\n+// Elements are accessed via Next.\n+//\n+// Type() returns a *types.Result (tuple type).\n+//\n+// Example printed form:\n+// \tt0 = range \"hello\":string\n+//\n+type Range struct {\n+\tRegister\n+\tX Value // array, *array, slice, string, map or chan\n+}\n+\n+// Next reads and advances the iterator Iter and returns a 3-tuple\n+// value (ok, k, v).  If the iterator is not exhausted, ok is true and\n+// k and v are the next elements of the domain and range,\n+// respectively.  Otherwise ok is false and k and v are undefined.\n+//\n+// For channel iterators, k is the received value and v is always\n+// undefined.\n+//\n+// Components of the tuple are accessed using Extract.\n+//\n+// Type() returns a *types.Result (tuple type).\n+//\n+// Example printed form:\n+// \tt1 = next t0\n+//\n+type Next struct {\n+\tRegister\n+\tIter Value\n+}\n+\n+// TypeAssert tests whether interface value X has type\n+// AssertedType.\n+//\n+// If CommaOk: on success it returns a pair (v, true) where v is a\n+// copy of value X; on failure it returns (z, false) where z is the\n+// zero value of that type.  The components of the pair must be\n+// accessed using the Extract instruction.\n+//\n+// If !CommaOk, on success it returns just the single value v; on\n+// failure it panics.\n+//\n+// Type() reflects the actual type of the result, possibly a pair\n+// (types.Result); AssertedType is the asserted type.\n+//\n+// Example printed form:\n+// \tt1 = typeassert t0.(int)\n+// \tt3 = typeassert,ok t2.(T)\n+//\n+type TypeAssert struct {\n+\tRegister\n+\tX            Value\n+\tAssertedType types.Type\n+\tCommaOk      bool\n+}\n+\n+// Extract yields component Index of Tuple.\n+//\n+// This is used to access the results of instructions with multiple\n+// return values, such as Call, TypeAssert, Next, UnOp(ARROW) and\n+// IndexExpr(Map).\n+//\n+// Example printed form:\n+// \tt1 = extract t0 #1\n+//\n+type Extract struct {\n+\tRegister\n+\tTuple Value\n+\tIndex int\n+}\n+\n+// Instructions executed for effect.  They do not yield a value. --------------------\n+\n+// Jump transfers control to the sole successor of its owning block.\n+//\n+// A Jump instruction must be the last instruction of its containing\n+// BasicBlock.\n+//\n+// Example printed form:\n+// \tjump done\n+//\n+type Jump struct {\n+\tanInstruction\n+}\n+\n+// The If instruction transfers control to one of the two successors\n+// of its owning block, depending on the boolean Cond: the first if\n+// true, the second if false.\n+//\n+// An If instruction must be the last instruction of its containing\n+// BasicBlock.\n+//\n+// Example printed form:\n+// \tif t0 goto done else body\n+//\n+type If struct {\n+\tanInstruction\n+\tCond Value\n+}\n+\n+// Ret returns values and control back to the calling function.\n+//\n+// len(Results) is always equal to the number of results in the\n+// function's signature.  A source-level 'return' statement with no\n+// operands in a multiple-return value function is desugared to make\n+// the results explicit.\n+//\n+// If len(Results) > 1, Ret returns a tuple value with the specified\n+// components which the caller must access using Extract instructions.\n+//\n+// There is no instruction to return a ready-made tuple like those\n+// returned by a \"value,ok\"-mode TypeAssert, Lookup or UnOp(ARROW) or\n+// a tail-call to a function with multiple result parameters.\n+// TODO(adonovan): consider defining one; but: dis- and re-assembling\n+// the tuple is unavoidable if assignability conversions are required\n+// on the components.\n+//\n+// Ret must be the last instruction of its containing BasicBlock.\n+// Such a block has no successors.\n+//\n+// Example printed form:\n+// \tret\n+// \tret nil:I, 2:int\n+//\n+type Ret struct {\n+\tanInstruction\n+\tResults []Value\n+}\n+\n+// Go creates a new goroutine and calls the specified function\n+// within it.\n+//\n+// See CallCommon for generic function call documentation.\n+//\n+// Example printed form:\n+// \tgo println(t0, t1)\n+// \tgo t3()\n+// \tgo invoke t5.Println(...t6)\n+//\n+type Go struct {\n+\tanInstruction\n+\tCallCommon\n+}\n+\n+// Defer pushes the specified call onto a stack of functions\n+// to be called immediately prior to returning from the\n+// current function.\n+//\n+// See CallCommon for generic function call documentation.\n+//\n+// Example printed form:\n+// \tdefer println(t0, t1)\n+// \tdefer t3()\n+// \tdefer invoke t5.Println(...t6)\n+//\n+type Defer struct {\n+\tanInstruction\n+\tCallCommon\n+}\n+\n+// Send sends X on channel Chan.\n+//\n+// Example printed form:\n+// \tsend t0 <- t1\n+//\n+type Send struct {\n+\tanInstruction\n+\tChan, X Value\n+}\n+\n+// Store stores Val at address Addr.\n+// Stores can be of arbitrary types.\n+//\n+// Example printed form:\n+// \t*x = y\n+//\n+type Store struct {\n+\tanInstruction\n+\tAddr Value\n+\tVal  Value\n+}\n+\n+// MapUpdate updates the association of Map[Key] to Value.\n+//\n+// Example printed form:\n+//\tt0[t1] = t2\n+//\n+type MapUpdate struct {\n+\tanInstruction\n+\tMap   Value\n+\tKey   Value\n+\tValue Value\n+}\n+\n+// Embeddable mix-ins used for common parts of other structs. --------------------\n+\n+// Register is a mix-in embedded by all SSA values that are also\n+// instructions, i.e. virtual registers, and provides implementations\n+// of the Value interface's Name() and Type() methods: the name is\n+// simply a numbered register (e.g. \"t0\") and the type is the Type_\n+// field.\n+//\n+// Temporary names are automatically assigned to each Register on\n+// completion of building a function in SSA form.\n+//\n+// Clients must not assume that the 'id' value (and the Name() derived\n+// from it) is unique within a function.  As always in this API,\n+// semantics are determined only by identity; names exist only to\n+// facilitate debugging.\n+//\n+type Register struct {\n+\tanInstruction\n+\tnum   int        // \"name\" of virtual register, e.g. \"t0\".  Not guaranteed unique.\n+\tType_ types.Type // type of virtual register\n+}\n+\n+// AnInstruction is a mix-in embedded by all Instructions.\n+// It provides the implementations of the Block and SetBlock methods.\n+type anInstruction struct {\n+\tBlock_ *BasicBlock // the basic block of this instruction\n+}\n+\n+// CallCommon is a mix-in embedded by Go, Defer and Call to hold the\n+// common parts of a function or method call.\n+//\n+// Each CallCommon exists in one of two modes, function call and\n+// interface method invocation, or \"call\" and \"invoke\" for short.\n+//\n+// 1. \"call\" mode: when Recv is nil, a CallCommon represents an\n+// ordinary function call of the value in Func.\n+//\n+// In the common case in which Func is a *Function, this indicates a\n+// statically dispatched call to a package-level function, an\n+// anonymous function, or a method of a named type.  Also statically\n+// dispatched, but less common, Func may be a *MakeClosure, indicating\n+// an immediately applied function literal with free variables.  Any\n+// other Value of Func indicates a dynamically dispatched function\n+// call.\n+//\n+// Args contains the arguments to the call.  If Func is a method,\n+// Args[0] contains the receiver parameter.  Recv and Method are not\n+// used in this mode.\n+//\n+// Example printed form:\n+// \tt2 = println(t0, t1)\n+// \tgo t3()\n+//\tdefer t5(...t6)\n+//\n+// 2. \"invoke\" mode: when Recv is non-nil, a CallCommon represents a\n+// dynamically dispatched call to an interface method.  In this\n+// mode, Recv is the interface value and Method is the index of the\n+// method within the interface type of the receiver.\n+//\n+// Recv is implicitly supplied to the concrete method implementation\n+// as the receiver parameter; in other words, Args[0] holds not the\n+// receiver but the first true argument.  Func is not used in this\n+// mode.\n+//\n+// Example printed form:\n+// \tt1 = invoke t0.String()\n+// \tgo invoke t3.Run(t2)\n+// \tdefer invoke t4.Handle(...t5)\n+//\n+// In both modes, HasEllipsis is true iff the last element of Args is\n+// a slice value containing zero or more arguments to a variadic\n+// function.  (This is not semantically significant since the type of\n+// the called function is sufficient to determine this, but it aids\n+// readability of the printed form.)\n+//\n+type CallCommon struct {\n+\tRecv        Value     // receiver, iff interface method invocation\n+\tMethod      int       // index of interface method within Recv.Type().(*types.Interface).Methods\n+\tFunc        Value     // target of call, iff function call\n+\tArgs        []Value   // actual parameters, including receiver in invoke mode\n+\tHasEllipsis bool      // true iff last Args is a slice  (needed?)\n+\tPos         token.Pos // position of call expression\n+}\n+\n+func (v *Builtin) Type() types.Type { return v.Object.GetType() }\n+func (v *Builtin) Name() string     { return v.Object.GetName() }\n+\n+func (v *Capture) Type() types.Type { return v.Outer.Type() }\n+func (v *Capture) Name() string     { return v.Outer.Name() }\n+\n+func (v *Global) Type() types.Type { return v.Type_ }\n+func (v *Global) Name() string     { return v.Name_ }\n+\n+func (v *Function) Name() string     { return v.Name_ }\n+func (v *Function) Type() types.Type { return v.Signature }\n+\n+func (v *Parameter) Type() types.Type { return v.Type_ }\n+func (v *Parameter) Name() string     { return v.Name_ }\n+\n+func (v *Alloc) Type() types.Type { return v.Type_ }\n+func (v *Alloc) Name() string     { return v.Name_ }\n+\n+func (v *Register) Type() types.Type       { return v.Type_ }\n+func (v *Register) setType(typ types.Type) { v.Type_ = typ }\n+func (v *Register) Name() string           { return fmt.Sprintf(\"t%d\", v.num) }\n+func (v *Register) setNum(num int)         { v.num = num }\n+\n+func (v *anInstruction) Block() *BasicBlock         { return v.Block_ }\n+func (v *anInstruction) SetBlock(block *BasicBlock) { v.Block_ = block }\n+\n+func (ms *Type) Type() types.Type { return ms.NamedType }\n+func (ms *Type) String() string   { return ms.Name() }\n+func (ms *Type) Name() string     { return ms.NamedType.Obj.Name }\n+\n+func (p *Package) Name() string { return p.Types.Name }\n+\n+// Func returns the package-level function of the specified name,\n+// or nil if not found.\n+//\n+func (p *Package) Func(name string) (f *Function) {\n+\tf, _ = p.Members[name].(*Function)\n+\treturn\n+}\n+\n+// Var returns the package-level variable of the specified name,\n+// or nil if not found.\n+//\n+func (p *Package) Var(name string) (g *Global) {\n+\tg, _ = p.Members[name].(*Global)\n+\treturn\n+}\n+\n+// Const returns the package-level constant of the specified name,\n+// or nil if not found.\n+//\n+func (p *Package) Const(name string) (l *Literal) {\n+\tl, _ = p.Members[name].(*Literal)\n+\treturn\n+}\n+\n+// Type returns the package-level type of the specified name,\n+// or nil if not found.\n+//\n+func (p *Package) Type(name string) (t *Type) {\n+\tt, _ = p.Members[name].(*Type)\n+\treturn\n+}\n+\n+// \"Implements\" relation boilerplate.\n+// Don't try to factor this using promotion and mix-ins: the long-hand\n+// form serves as better documentation, including in godoc.\n+\n+func (*Alloc) ImplementsValue()           {}\n+func (*BinOp) ImplementsValue()           {}\n+func (*Builtin) ImplementsValue()         {}\n+func (*Call) ImplementsValue()            {}\n+func (*Capture) ImplementsValue()         {}\n+func (*ChangeInterface) ImplementsValue() {}\n+func (*Conv) ImplementsValue()            {}\n+func (*Extract) ImplementsValue()         {}\n+func (*Field) ImplementsValue()           {}\n+func (*FieldAddr) ImplementsValue()       {}\n+func (*Function) ImplementsValue()        {}\n+func (*Global) ImplementsValue()          {}\n+func (*Index) ImplementsValue()           {}\n+func (*IndexAddr) ImplementsValue()       {}\n+func (*Literal) ImplementsValue()         {}\n+func (*Lookup) ImplementsValue()          {}\n+func (*MakeChan) ImplementsValue()        {}\n+func (*MakeClosure) ImplementsValue()     {}\n+func (*MakeInterface) ImplementsValue()   {}\n+func (*MakeMap) ImplementsValue()         {}\n+func (*MakeSlice) ImplementsValue()       {}\n+func (*Next) ImplementsValue()            {}\n+func (*Parameter) ImplementsValue()       {}\n+func (*Phi) ImplementsValue()             {}\n+func (*Range) ImplementsValue()           {}\n+func (*Select) ImplementsValue()          {}\n+func (*Slice) ImplementsValue()           {}\n+func (*TypeAssert) ImplementsValue()      {}\n+func (*UnOp) ImplementsValue()            {}\n+\n+func (*Function) ImplementsMember() {}\n+func (*Global) ImplementsMember()   {}\n+func (*Literal) ImplementsMember()  {}\n+func (*Type) ImplementsMember()     {}\n+\n+func (*Alloc) ImplementsInstruction()           {}\n+func (*BinOp) ImplementsInstruction()           {}\n+func (*Call) ImplementsInstruction()            {}\n+func (*ChangeInterface) ImplementsInstruction() {}\n+func (*Conv) ImplementsInstruction()            {}\n+func (*Defer) ImplementsInstruction()           {}\n+func (*Extract) ImplementsInstruction()         {}\n+func (*Field) ImplementsInstruction()           {}\n+func (*FieldAddr) ImplementsInstruction()       {}\n+func (*Go) ImplementsInstruction()              {}\n+func (*If) ImplementsInstruction()              {}\n+func (*Index) ImplementsInstruction()           {}\n+func (*IndexAddr) ImplementsInstruction()       {}\n+func (*Jump) ImplementsInstruction()            {}\n+func (*Lookup) ImplementsInstruction()          {}\n+func (*MakeChan) ImplementsInstruction()        {}\n+func (*MakeClosure) ImplementsInstruction()     {}\n+func (*MakeInterface) ImplementsInstruction()   {}\n+func (*MakeMap) ImplementsInstruction()         {}\n+func (*MakeSlice) ImplementsInstruction()       {}\n+func (*MapUpdate) ImplementsInstruction()       {}\n+func (*Next) ImplementsInstruction()            {}\n+func (*Phi) ImplementsInstruction()             {}\n+func (*Range) ImplementsInstruction()           {}\n+func (*Ret) ImplementsInstruction()             {}\n+func (*Select) ImplementsInstruction()          {}\n+func (*Send) ImplementsInstruction()            {}\n+func (*Slice) ImplementsInstruction()           {}\n+func (*Store) ImplementsInstruction()           {}\n+func (*TypeAssert) ImplementsInstruction()      {}\n+func (*UnOp) ImplementsInstruction()            {}"}, {"sha": "0d2ebde268a3bfdb3b51bea7f2754e520269da87", "filename": "libgo/go/exp/ssa/util.go", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexp%2Fssa%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Futil.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,172 @@\n+package ssa\n+\n+// This file defines a number of miscellaneous utility functions.\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/types\"\n+)\n+\n+func unreachable() {\n+\tpanic(\"unreachable\")\n+}\n+\n+//// AST utilities\n+\n+// noparens returns e with any enclosing parentheses stripped.\n+func noparens(e ast.Expr) ast.Expr {\n+\tfor {\n+\t\tp, ok := e.(*ast.ParenExpr)\n+\t\tif !ok {\n+\t\t\tbreak\n+\t\t}\n+\t\te = p.X\n+\t}\n+\treturn e\n+}\n+\n+// isBlankIdent returns true iff e is an Ident with name \"_\".\n+// They have no associated types.Object, and thus no type.\n+//\n+// TODO(gri): consider making typechecker not treat them differently.\n+// It's one less thing for clients like us to worry about.\n+//\n+func isBlankIdent(e ast.Expr) bool {\n+\tid, ok := e.(*ast.Ident)\n+\treturn ok && id.Name == \"_\"\n+}\n+\n+//// Type utilities.  Some of these belong in go/types.\n+\n+// underlyingType returns the underlying type of typ.\n+// TODO(gri): this is a copy of go/types.underlying; export that function.\n+//\n+func underlyingType(typ types.Type) types.Type {\n+\tif typ, ok := typ.(*types.NamedType); ok {\n+\t\treturn typ.Underlying // underlying types are never NamedTypes\n+\t}\n+\tif typ == nil {\n+\t\tpanic(\"underlyingType(nil)\")\n+\t}\n+\treturn typ\n+}\n+\n+// isPointer returns true for types whose underlying type is a pointer.\n+func isPointer(typ types.Type) bool {\n+\tif nt, ok := typ.(*types.NamedType); ok {\n+\t\ttyp = nt.Underlying\n+\t}\n+\t_, ok := typ.(*types.Pointer)\n+\treturn ok\n+}\n+\n+// pointer(typ) returns the type that is a pointer to typ.\n+func pointer(typ types.Type) *types.Pointer {\n+\treturn &types.Pointer{Base: typ}\n+}\n+\n+// indirect(typ) assumes that typ is a pointer type,\n+// or named alias thereof, and returns its base type.\n+// Panic ensures if it is not a pointer.\n+//\n+func indirectType(ptr types.Type) types.Type {\n+\tif v, ok := underlyingType(ptr).(*types.Pointer); ok {\n+\t\treturn v.Base\n+\t}\n+\t// When debugging it is convenient to comment out this line\n+\t// and let it continue to print the (illegal) SSA form.\n+\tpanic(\"indirect() of non-pointer type: \" + ptr.String())\n+\treturn nil\n+}\n+\n+// deref returns a pointer's base type; otherwise it returns typ.\n+func deref(typ types.Type) types.Type {\n+\tif typ, ok := underlyingType(typ).(*types.Pointer); ok {\n+\t\treturn typ.Base\n+\t}\n+\treturn typ\n+}\n+\n+// methodIndex returns the method (and its index) named id within the\n+// method table methods of named or interface type typ.  If not found,\n+// panic ensues.\n+//\n+func methodIndex(typ types.Type, methods []*types.Method, id Id) (i int, m *types.Method) {\n+\tfor i, m = range methods {\n+\t\tif IdFromQualifiedName(m.QualifiedName) == id {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tpanic(fmt.Sprint(\"method not found: \", id, \" in interface \", typ))\n+}\n+\n+// objKind returns the syntactic category of the named entity denoted by obj.\n+func objKind(obj types.Object) ast.ObjKind {\n+\tswitch obj.(type) {\n+\tcase *types.Package:\n+\t\treturn ast.Pkg\n+\tcase *types.TypeName:\n+\t\treturn ast.Typ\n+\tcase *types.Const:\n+\t\treturn ast.Con\n+\tcase *types.Var:\n+\t\treturn ast.Var\n+\tcase *types.Func:\n+\t\treturn ast.Fun\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected Object type: %T\", obj))\n+}\n+\n+// DefaultType returns the default \"typed\" type for an \"untyped\" type;\n+// it returns the incoming type for all other types. If there is no\n+// corresponding untyped type, the result is types.Typ[types.Invalid].\n+//\n+// Exported to exp/ssa/interp.\n+//\n+// TODO(gri): this is a copy of go/types.defaultType; export that function.\n+//\n+func DefaultType(typ types.Type) types.Type {\n+\tif t, ok := typ.(*types.Basic); ok {\n+\t\tk := types.Invalid\n+\t\tswitch t.Kind {\n+\t\t// case UntypedNil:\n+\t\t//      There is no default type for nil. For a good error message,\n+\t\t//      catch this case before calling this function.\n+\t\tcase types.UntypedBool:\n+\t\t\tk = types.Bool\n+\t\tcase types.UntypedInt:\n+\t\t\tk = types.Int\n+\t\tcase types.UntypedRune:\n+\t\t\tk = types.Rune\n+\t\tcase types.UntypedFloat:\n+\t\t\tk = types.Float64\n+\t\tcase types.UntypedComplex:\n+\t\t\tk = types.Complex128\n+\t\tcase types.UntypedString:\n+\t\t\tk = types.String\n+\t\t}\n+\t\ttyp = types.Typ[k]\n+\t}\n+\treturn typ\n+}\n+\n+// makeId returns the Id (name, pkg) if the name is exported or\n+// (name, nil) otherwise.\n+//\n+func makeId(name string, pkg *types.Package) (id Id) {\n+\tid.Name = name\n+\tif !ast.IsExported(name) {\n+\t\tid.Pkg = pkg\n+\t}\n+\treturn\n+}\n+\n+// IdFromQualifiedName returns the Id (qn.Name, qn.Pkg) if qn is an\n+// exported name or (qn.Name, nil) otherwise.\n+//\n+// Exported to exp/ssa/interp.\n+//\n+func IdFromQualifiedName(qn types.QualifiedName) Id {\n+\treturn makeId(qn.Name, qn.Pkg)\n+}"}, {"sha": "af2d0c64d1113326671e1ba004095d9f4e4e46a1", "filename": "libgo/go/exp/types/check.go", "status": "removed", "additions": 0, "deletions": 380, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,380 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements the Check function, which typechecks a package.\n-\n-package types\n-\n-import (\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"sort\"\n-)\n-\n-// enable for debugging\n-const trace = false\n-\n-type checker struct {\n-\tfset *token.FileSet\n-\tpkg  *ast.Package\n-\terrh func(token.Pos, string)\n-\tmapf func(ast.Expr, Type)\n-\n-\t// lazily initialized\n-\tfirsterr  error\n-\tfilenames []string                      // sorted list of package file names for reproducible iteration order\n-\tinitexprs map[*ast.ValueSpec][]ast.Expr // \"inherited\" initialization expressions for constant declarations\n-\tfunctypes []*Signature                  // stack of function signatures; actively typechecked function on top\n-\tpos       []token.Pos                   // stack of expr positions; debugging support, used if trace is set\n-}\n-\n-// declare declares an object of the given kind and name (ident) in scope;\n-// decl is the corresponding declaration in the AST. An error is reported\n-// if the object was declared before.\n-//\n-// TODO(gri) This is very similar to the declare function in go/parser; it\n-// is only used to associate methods with their respective receiver base types.\n-// In a future version, it might be simpler and cleaner to do all the resolution\n-// in the type-checking phase. It would simplify the parser, AST, and also\n-// reduce some amount of code duplication.\n-//\n-func (check *checker) declare(scope *ast.Scope, kind ast.ObjKind, ident *ast.Ident, decl ast.Decl) {\n-\tassert(ident.Obj == nil) // identifier already declared or resolved\n-\tobj := ast.NewObj(kind, ident.Name)\n-\tobj.Decl = decl\n-\tident.Obj = obj\n-\tif ident.Name != \"_\" {\n-\t\tif alt := scope.Insert(obj); alt != nil {\n-\t\t\tprevDecl := \"\"\n-\t\t\tif pos := alt.Pos(); pos.IsValid() {\n-\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", check.fset.Position(pos))\n-\t\t\t}\n-\t\t\tcheck.errorf(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n-\t\t}\n-\t}\n-}\n-\n-func (check *checker) valueSpec(pos token.Pos, obj *ast.Object, lhs []*ast.Ident, typ ast.Expr, rhs []ast.Expr, iota int) {\n-\tif len(lhs) == 0 {\n-\t\tcheck.invalidAST(pos, \"missing lhs in declaration\")\n-\t\treturn\n-\t}\n-\n-\t// determine type for all of lhs, if any\n-\t// (but only set it for the object we typecheck!)\n-\tvar t Type\n-\tif typ != nil {\n-\t\tt = check.typ(typ, false)\n-\t}\n-\n-\t// len(lhs) > 0\n-\tif len(lhs) == len(rhs) {\n-\t\t// check only lhs and rhs corresponding to obj\n-\t\tvar l, r ast.Expr\n-\t\tfor i, name := range lhs {\n-\t\t\tif name.Obj == obj {\n-\t\t\t\tl = lhs[i]\n-\t\t\t\tr = rhs[i]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tassert(l != nil)\n-\t\tobj.Type = t\n-\t\tcheck.assign1to1(l, r, nil, true, iota)\n-\t\treturn\n-\t}\n-\n-\t// there must be a type or initialization expressions\n-\tif t == nil && len(rhs) == 0 {\n-\t\tcheck.invalidAST(pos, \"missing type or initialization expression\")\n-\t\tt = Typ[Invalid]\n-\t}\n-\n-\t// if we have a type, mark all of lhs\n-\tif t != nil {\n-\t\tfor _, name := range lhs {\n-\t\t\tname.Obj.Type = t\n-\t\t}\n-\t}\n-\n-\t// check initial values, if any\n-\tif len(rhs) > 0 {\n-\t\t// TODO(gri) should try to avoid this conversion\n-\t\tlhx := make([]ast.Expr, len(lhs))\n-\t\tfor i, e := range lhs {\n-\t\t\tlhx[i] = e\n-\t\t}\n-\t\tcheck.assignNtoM(lhx, rhs, true, iota)\n-\t}\n-}\n-\n-func (check *checker) function(typ *Signature, body *ast.BlockStmt) {\n-\tcheck.functypes = append(check.functypes, typ)\n-\tcheck.stmt(body)\n-\tcheck.functypes = check.functypes[0 : len(check.functypes)-1]\n-}\n-\n-// object typechecks an object by assigning it a type; obj.Type must be nil.\n-// Callers must check obj.Type before calling object; this eliminates a call\n-// for each identifier that has been typechecked already, a common scenario.\n-//\n-func (check *checker) object(obj *ast.Object, cycleOk bool) {\n-\tassert(obj.Type == nil)\n-\n-\tswitch obj.Kind {\n-\tcase ast.Bad, ast.Pkg:\n-\t\t// nothing to do\n-\n-\tcase ast.Con, ast.Var:\n-\t\t// The obj.Data field for constants and variables is initialized\n-\t\t// to the respective (hypothetical, for variables) iota value by\n-\t\t// the parser. The object's fields can be in one of the following\n-\t\t// states:\n-\t\t// Type != nil  =>  the constant value is Data\n-\t\t// Type == nil  =>  the object is not typechecked yet, and Data can be:\n-\t\t// Data is int  =>  Data is the value of iota for this declaration\n-\t\t// Data == nil  =>  the object's expression is being evaluated\n-\t\tif obj.Data == nil {\n-\t\t\tcheck.errorf(obj.Pos(), \"illegal cycle in initialization of %s\", obj.Name)\n-\t\t\tobj.Type = Typ[Invalid]\n-\t\t\treturn\n-\t\t}\n-\t\tspec := obj.Decl.(*ast.ValueSpec)\n-\t\tiota := obj.Data.(int)\n-\t\tobj.Data = nil\n-\t\t// determine initialization expressions\n-\t\tvalues := spec.Values\n-\t\tif len(values) == 0 && obj.Kind == ast.Con {\n-\t\t\tvalues = check.initexprs[spec]\n-\t\t}\n-\t\tcheck.valueSpec(spec.Pos(), obj, spec.Names, spec.Type, values, iota)\n-\n-\tcase ast.Typ:\n-\t\ttyp := &NamedType{Obj: obj}\n-\t\tobj.Type = typ // \"mark\" object so recursion terminates\n-\t\ttyp.Underlying = underlying(check.typ(obj.Decl.(*ast.TypeSpec).Type, cycleOk))\n-\t\t// typecheck associated method signatures\n-\t\tif obj.Data != nil {\n-\t\t\tscope := obj.Data.(*ast.Scope)\n-\t\t\tswitch t := typ.Underlying.(type) {\n-\t\t\tcase *Struct:\n-\t\t\t\t// struct fields must not conflict with methods\n-\t\t\t\tfor _, f := range t.Fields {\n-\t\t\t\t\tif m := scope.Lookup(f.Name); m != nil {\n-\t\t\t\t\t\tcheck.errorf(m.Pos(), \"type %s has both field and method named %s\", obj.Name, f.Name)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// ok to continue\n-\t\t\tcase *Interface:\n-\t\t\t\t// methods cannot be associated with an interface type\n-\t\t\t\tfor _, m := range scope.Objects {\n-\t\t\t\t\trecv := m.Decl.(*ast.FuncDecl).Recv.List[0].Type\n-\t\t\t\t\tcheck.errorf(recv.Pos(), \"invalid receiver type %s (%s is an interface type)\", obj.Name, obj.Name)\n-\t\t\t\t}\n-\t\t\t\t// ok to continue\n-\t\t\t}\n-\t\t\t// typecheck method signatures\n-\t\t\tfor _, m := range scope.Objects {\n-\t\t\t\tmdecl := m.Decl.(*ast.FuncDecl)\n-\t\t\t\t// TODO(gri) At the moment, the receiver is type-checked when checking\n-\t\t\t\t// the method body. Also, we don't properly track if the receiver is\n-\t\t\t\t// a pointer (i.e., currently, method sets are too large). FIX THIS.\n-\t\t\t\tmtyp := check.typ(mdecl.Type, cycleOk).(*Signature)\n-\t\t\t\tm.Type = mtyp\n-\t\t\t}\n-\t\t}\n-\n-\tcase ast.Fun:\n-\t\tfdecl := obj.Decl.(*ast.FuncDecl)\n-\t\tcheck.collectParams(fdecl.Recv, false) // ensure method base is type-checked\n-\t\tftyp := check.typ(fdecl.Type, cycleOk).(*Signature)\n-\t\tobj.Type = ftyp\n-\t\t// functions implemented elsewhere (say in assembly) have no body\n-\t\tif fdecl.Body != nil {\n-\t\t\tcheck.function(ftyp, fdecl.Body)\n-\t\t}\n-\n-\tdefault:\n-\t\tpanic(\"unreachable\")\n-\t}\n-}\n-\n-// assocInitvals associates \"inherited\" initialization expressions\n-// with the corresponding *ast.ValueSpec in the check.initexprs map\n-// for constant declarations without explicit initialization expressions.\n-//\n-func (check *checker) assocInitvals(decl *ast.GenDecl) {\n-\tvar values []ast.Expr\n-\tfor _, s := range decl.Specs {\n-\t\tif s, ok := s.(*ast.ValueSpec); ok {\n-\t\t\tif len(s.Values) > 0 {\n-\t\t\t\tvalues = s.Values\n-\t\t\t} else {\n-\t\t\t\tcheck.initexprs[s] = values\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif len(values) == 0 {\n-\t\tcheck.invalidAST(decl.Pos(), \"no initialization values provided\")\n-\t}\n-}\n-\n-// assocMethod associates a method declaration with the respective\n-// receiver base type. meth.Recv must exist.\n-//\n-func (check *checker) assocMethod(meth *ast.FuncDecl) {\n-\t// The receiver type is one of the following (enforced by parser):\n-\t// - *ast.Ident\n-\t// - *ast.StarExpr{*ast.Ident}\n-\t// - *ast.BadExpr (parser error)\n-\ttyp := meth.Recv.List[0].Type\n-\tif ptr, ok := typ.(*ast.StarExpr); ok {\n-\t\ttyp = ptr.X\n-\t}\n-\t// determine receiver base type object (or nil if error)\n-\tvar obj *ast.Object\n-\tif ident, ok := typ.(*ast.Ident); ok && ident.Obj != nil {\n-\t\tobj = ident.Obj\n-\t\tif obj.Kind != ast.Typ {\n-\t\t\tcheck.errorf(ident.Pos(), \"%s is not a type\", ident.Name)\n-\t\t\tobj = nil\n-\t\t}\n-\t\t// TODO(gri) determine if obj was defined in this package\n-\t\t/*\n-\t\t\tif check.notLocal(obj) {\n-\t\t\t\tcheck.errorf(ident.Pos(), \"cannot define methods on non-local type %s\", ident.Name)\n-\t\t\t\tobj = nil\n-\t\t\t}\n-\t\t*/\n-\t} else {\n-\t\t// If it's not an identifier or the identifier wasn't declared/resolved,\n-\t\t// the parser/resolver already reported an error. Nothing to do here.\n-\t}\n-\t// determine base type scope (or nil if error)\n-\tvar scope *ast.Scope\n-\tif obj != nil {\n-\t\tif obj.Data != nil {\n-\t\t\tscope = obj.Data.(*ast.Scope)\n-\t\t} else {\n-\t\t\tscope = ast.NewScope(nil)\n-\t\t\tobj.Data = scope\n-\t\t}\n-\t} else {\n-\t\t// use a dummy scope so that meth can be declared in\n-\t\t// presence of an error and get an associated object\n-\t\t// (always use a new scope so that we don't get double\n-\t\t// declaration errors)\n-\t\tscope = ast.NewScope(nil)\n-\t}\n-\tcheck.declare(scope, ast.Fun, meth.Name, meth)\n-}\n-\n-func (check *checker) assocInitvalsOrMethod(decl ast.Decl) {\n-\tswitch d := decl.(type) {\n-\tcase *ast.GenDecl:\n-\t\tif d.Tok == token.CONST {\n-\t\t\tcheck.assocInitvals(d)\n-\t\t}\n-\tcase *ast.FuncDecl:\n-\t\tif d.Recv != nil {\n-\t\t\tcheck.assocMethod(d)\n-\t\t}\n-\t}\n-}\n-\n-func (check *checker) decl(decl ast.Decl) {\n-\tswitch d := decl.(type) {\n-\tcase *ast.BadDecl:\n-\t\t// ignore\n-\tcase *ast.GenDecl:\n-\t\tfor _, spec := range d.Specs {\n-\t\t\tswitch s := spec.(type) {\n-\t\t\tcase *ast.ImportSpec:\n-\t\t\t\t// nothing to do (handled by ast.NewPackage)\n-\t\t\tcase *ast.ValueSpec:\n-\t\t\t\tfor _, name := range s.Names {\n-\t\t\t\t\tif obj := name.Obj; obj.Type == nil {\n-\t\t\t\t\t\tcheck.object(obj, false)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\tcase *ast.TypeSpec:\n-\t\t\t\tif obj := s.Name.Obj; obj.Type == nil {\n-\t\t\t\t\tcheck.object(obj, false)\n-\t\t\t\t}\n-\t\t\tdefault:\n-\t\t\t\tcheck.invalidAST(s.Pos(), \"unknown ast.Spec node %T\", s)\n-\t\t\t}\n-\t\t}\n-\tcase *ast.FuncDecl:\n-\t\tif d.Name.Name == \"init\" {\n-\t\t\t// initialization function\n-\t\t\t// TODO(gri) ignore for now (has no object associated with it)\n-\t\t\t// (should probably collect in a first phase and properly initialize)\n-\t\t\treturn\n-\t\t}\n-\t\tif obj := d.Name.Obj; obj.Type == nil {\n-\t\t\tcheck.object(obj, false)\n-\t\t}\n-\tdefault:\n-\t\tcheck.invalidAST(d.Pos(), \"unknown ast.Decl node %T\", d)\n-\t}\n-}\n-\n-// iterate calls f for each package-level declaration.\n-func (check *checker) iterate(f func(*checker, ast.Decl)) {\n-\tlist := check.filenames\n-\n-\tif list == nil {\n-\t\t// initialize lazily\n-\t\tfor filename := range check.pkg.Files {\n-\t\t\tlist = append(list, filename)\n-\t\t}\n-\t\tsort.Strings(list)\n-\t\tcheck.filenames = list\n-\t}\n-\n-\tfor _, filename := range list {\n-\t\tfor _, decl := range check.pkg.Files[filename].Decls {\n-\t\t\tf(check, decl)\n-\t\t}\n-\t}\n-}\n-\n-// A bailout panic is raised to indicate early termination.\n-type bailout struct{}\n-\n-func check(fset *token.FileSet, pkg *ast.Package, errh func(token.Pos, string), f func(ast.Expr, Type)) (err error) {\n-\t// initialize checker\n-\tvar check checker\n-\tcheck.fset = fset\n-\tcheck.pkg = pkg\n-\tcheck.errh = errh\n-\tcheck.mapf = f\n-\tcheck.initexprs = make(map[*ast.ValueSpec][]ast.Expr)\n-\n-\t// handle panics\n-\tdefer func() {\n-\t\tswitch p := recover().(type) {\n-\t\tcase nil:\n-\t\t\t// normal return - nothing to do\n-\t\tcase bailout:\n-\t\t\t// early exit\n-\t\t\terr = check.firsterr\n-\t\tdefault:\n-\t\t\t// unexpected panic: don't crash clients\n-\t\t\t// panic(p) // enable for debugging\n-\t\t\terr = fmt.Errorf(\"types.check internal error: %v\", p)\n-\t\t}\n-\t}()\n-\n-\t// determine missing constant initialization expressions\n-\t// and associate methods with types\n-\tcheck.iterate((*checker).assocInitvalsOrMethod)\n-\n-\t// typecheck all declarations\n-\tcheck.iterate((*checker).decl)\n-\n-\treturn\n-}"}, {"sha": "cbaef8aa9ae5fbaa6bad177edcd638758f662ed8", "filename": "libgo/go/exp/types/conversions.go", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements typechecking of conversions.\n-\n-package types\n-\n-import (\n-\t\"go/ast\"\n-)\n-\n-// conversion typechecks the type conversion conv to type typ. iota is the current\n-// value of iota or -1 if iota doesn't have a value in the current context. The result\n-// of the conversion is returned via x. If the conversion has type errors, the returned\n-// x is marked as invalid (x.mode == invalid).\n-//\n-func (check *checker) conversion(x *operand, conv *ast.CallExpr, typ Type, iota int) {\n-\t// all conversions have one argument\n-\tif len(conv.Args) != 1 {\n-\t\tcheck.invalidOp(conv.Pos(), \"%s conversion requires exactly one argument\", conv)\n-\t\tgoto Error\n-\t}\n-\n-\t// evaluate argument\n-\tcheck.expr(x, conv.Args[0], nil, iota)\n-\tif x.mode == invalid {\n-\t\tgoto Error\n-\t}\n-\n-\t// TODO(gri) fix this - implement all checks and constant evaluation\n-\tif x.mode != constant {\n-\t\tx.mode = value\n-\t}\n-\tx.expr = conv\n-\tx.typ = typ\n-\treturn\n-\n-Error:\n-\tx.mode = invalid\n-}"}, {"sha": "15b01419327cc0b0761681925de735747e376de1", "filename": "libgo/go/exp/types/resolver_test.go", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package types\n-\n-import (\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t// \"go/parser\"\n-\t\"go/scanner\"\n-\t\"go/token\"\n-\t// \"testing\"\n-)\n-\n-var sources = []string{\n-\t`package p\n-\timport \"fmt\"\n-\timport \"math\"\n-\tconst pi = math.Pi\n-\tfunc sin(x float64) float64 {\n-\t\treturn math.Sin(x)\n-\t}\n-\tvar Println = fmt.Println\n-\t`,\n-\t`package p\n-\timport \"fmt\"\n-\tfunc f() string {\n-\t\treturn fmt.Sprintf(\"%d\", g())\n-\t}\n-\t`,\n-\t`package p\n-\timport . \"go/parser\"\n-\tfunc g() Mode { return ImportsOnly }`,\n-}\n-\n-var pkgnames = []string{\n-\t\"fmt\",\n-\t\"go/parser\",\n-\t\"math\",\n-}\n-\n-// ResolveQualifiedIdents resolves the selectors of qualified\n-// identifiers by associating the correct ast.Object with them.\n-// TODO(gri): Eventually, this functionality should be subsumed\n-//            by Check.\n-//\n-func ResolveQualifiedIdents(fset *token.FileSet, pkg *ast.Package) error {\n-\tvar errors scanner.ErrorList\n-\n-\tfindObj := func(pkg *ast.Object, name *ast.Ident) *ast.Object {\n-\t\tscope := pkg.Data.(*ast.Scope)\n-\t\tobj := scope.Lookup(name.Name)\n-\t\tif obj == nil {\n-\t\t\terrors.Add(fset.Position(name.Pos()), fmt.Sprintf(\"no %s in package %s\", name.Name, pkg.Name))\n-\t\t}\n-\t\treturn obj\n-\t}\n-\n-\tast.Inspect(pkg, func(n ast.Node) bool {\n-\t\tif s, ok := n.(*ast.SelectorExpr); ok {\n-\t\t\tif x, ok := s.X.(*ast.Ident); ok && x.Obj != nil && x.Obj.Kind == ast.Pkg {\n-\t\t\t\t// find selector in respective package\n-\t\t\t\ts.Sel.Obj = findObj(x.Obj, s.Sel)\n-\t\t\t}\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\t})\n-\n-\treturn errors.Err()\n-}\n-\n-/*\n-\n-Does not work with gccgo.\n-\n-func TestResolveQualifiedIdents(t *testing.T) {\n-\t// parse package files\n-\tfset := token.NewFileSet()\n-\tfiles := make(map[string]*ast.File)\n-\tfor i, src := range sources {\n-\t\tfilename := fmt.Sprintf(\"file%d\", i)\n-\t\tf, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tfiles[filename] = f\n-\t}\n-\n-\t// resolve package AST\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// check that all packages were imported\n-\tfor _, name := range pkgnames {\n-\t\tif pkg.Imports[name] == nil {\n-\t\t\tt.Errorf(\"package %s not imported\", name)\n-\t\t}\n-\t}\n-\n-\t// check that there are no top-level unresolved identifiers\n-\tfor _, f := range pkg.Files {\n-\t\tfor _, x := range f.Unresolved {\n-\t\t\tt.Errorf(\"%s: unresolved global identifier %s\", fset.Position(x.Pos()), x.Name)\n-\t\t}\n-\t}\n-\n-\t// resolve qualified identifiers\n-\tif err := ResolveQualifiedIdents(fset, pkg); err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\t// check that qualified identifiers are resolved\n-\tast.Inspect(pkg, func(n ast.Node) bool {\n-\t\tif s, ok := n.(*ast.SelectorExpr); ok {\n-\t\t\tif x, ok := s.X.(*ast.Ident); ok {\n-\t\t\t\tif x.Obj == nil {\n-\t\t\t\t\tt.Errorf(\"%s: unresolved qualified identifier %s\", fset.Position(x.Pos()), x.Name)\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tif x.Obj.Kind == ast.Pkg && s.Sel != nil && s.Sel.Obj == nil {\n-\t\t\t\t\tt.Errorf(\"%s: unresolved selector %s\", fset.Position(s.Sel.Pos()), s.Sel.Name)\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\t})\n-}\n-\n-*/"}, {"sha": "0fbaa3329d44c8175787857573f50a2275436747", "filename": "libgo/go/exp/types/universe.go", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,161 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements the universe and unsafe package scopes.\n-\n-package types\n-\n-import (\n-\t\"go/ast\"\n-\t\"strings\"\n-)\n-\n-var (\n-\taType            implementsType\n-\tUniverse, unsafe *ast.Scope\n-\tUnsafe           *ast.Object // package unsafe\n-)\n-\n-// Predeclared types, indexed by BasicKind.\n-var Typ = [...]*Basic{\n-\tInvalid: {aType, Invalid, 0, 0, \"invalid type\"},\n-\n-\tBool:          {aType, Bool, IsBoolean, 1, \"bool\"},\n-\tInt:           {aType, Int, IsInteger, 0, \"int\"},\n-\tInt8:          {aType, Int8, IsInteger, 1, \"int8\"},\n-\tInt16:         {aType, Int16, IsInteger, 2, \"int16\"},\n-\tInt32:         {aType, Int32, IsInteger, 4, \"int32\"},\n-\tInt64:         {aType, Int64, IsInteger, 8, \"int64\"},\n-\tUint:          {aType, Uint, IsInteger | IsUnsigned, 0, \"uint\"},\n-\tUint8:         {aType, Uint8, IsInteger | IsUnsigned, 1, \"uint8\"},\n-\tUint16:        {aType, Uint16, IsInteger | IsUnsigned, 2, \"uint16\"},\n-\tUint32:        {aType, Uint32, IsInteger | IsUnsigned, 4, \"uint32\"},\n-\tUint64:        {aType, Uint64, IsInteger | IsUnsigned, 8, \"uint64\"},\n-\tUintptr:       {aType, Uintptr, IsInteger | IsUnsigned, 0, \"uintptr\"},\n-\tFloat32:       {aType, Float32, IsFloat, 4, \"float32\"},\n-\tFloat64:       {aType, Float64, IsFloat, 8, \"float64\"},\n-\tComplex64:     {aType, Complex64, IsComplex, 8, \"complex64\"},\n-\tComplex128:    {aType, Complex128, IsComplex, 16, \"complex128\"},\n-\tString:        {aType, String, IsString, 0, \"string\"},\n-\tUnsafePointer: {aType, UnsafePointer, 0, 0, \"Pointer\"},\n-\n-\tUntypedBool:    {aType, UntypedBool, IsBoolean | IsUntyped, 0, \"untyped boolean\"},\n-\tUntypedInt:     {aType, UntypedInt, IsInteger | IsUntyped, 0, \"untyped integer\"},\n-\tUntypedRune:    {aType, UntypedRune, IsInteger | IsUntyped, 0, \"untyped rune\"},\n-\tUntypedFloat:   {aType, UntypedFloat, IsFloat | IsUntyped, 0, \"untyped float\"},\n-\tUntypedComplex: {aType, UntypedComplex, IsComplex | IsUntyped, 0, \"untyped complex\"},\n-\tUntypedString:  {aType, UntypedString, IsString | IsUntyped, 0, \"untyped string\"},\n-\tUntypedNil:     {aType, UntypedNil, IsUntyped, 0, \"untyped nil\"},\n-}\n-\n-var aliases = [...]*Basic{\n-\t{aType, Byte, IsInteger | IsUnsigned, 1, \"byte\"},\n-\t{aType, Rune, IsInteger, 4, \"rune\"},\n-}\n-\n-var predeclaredConstants = [...]*struct {\n-\tkind BasicKind\n-\tname string\n-\tval  interface{}\n-}{\n-\t{UntypedBool, \"true\", true},\n-\t{UntypedBool, \"false\", false},\n-\t{UntypedInt, \"iota\", zeroConst},\n-\t{UntypedNil, \"nil\", nilConst},\n-}\n-\n-var predeclaredFunctions = [...]*builtin{\n-\t{aType, _Append, \"append\", 1, true, false},\n-\t{aType, _Cap, \"cap\", 1, false, false},\n-\t{aType, _Close, \"close\", 1, false, true},\n-\t{aType, _Complex, \"complex\", 2, false, false},\n-\t{aType, _Copy, \"copy\", 2, false, true},\n-\t{aType, _Delete, \"delete\", 2, false, true},\n-\t{aType, _Imag, \"imag\", 1, false, false},\n-\t{aType, _Len, \"len\", 1, false, false},\n-\t{aType, _Make, \"make\", 1, true, false},\n-\t{aType, _New, \"new\", 1, false, false},\n-\t{aType, _Panic, \"panic\", 1, false, true},\n-\t{aType, _Print, \"print\", 1, true, true},\n-\t{aType, _Println, \"println\", 1, true, true},\n-\t{aType, _Real, \"real\", 1, false, false},\n-\t{aType, _Recover, \"recover\", 0, false, true},\n-\n-\t{aType, _Alignof, \"Alignof\", 1, false, false},\n-\t{aType, _Offsetof, \"Offsetof\", 1, false, false},\n-\t{aType, _Sizeof, \"Sizeof\", 1, false, false},\n-}\n-\n-// commonly used types\n-var (\n-\temptyInterface = new(Interface)\n-)\n-\n-// commonly used constants\n-var (\n-\tuniverseIota *ast.Object\n-)\n-\n-func init() {\n-\t// Universe scope\n-\tUniverse = ast.NewScope(nil)\n-\n-\t// unsafe package and its scope\n-\tunsafe = ast.NewScope(nil)\n-\tUnsafe = ast.NewObj(ast.Pkg, \"unsafe\")\n-\tUnsafe.Data = unsafe\n-\n-\t// predeclared types\n-\tfor _, t := range Typ {\n-\t\tdef(ast.Typ, t.Name).Type = t\n-\t}\n-\tfor _, t := range aliases {\n-\t\tdef(ast.Typ, t.Name).Type = t\n-\t}\n-\n-\t// error type\n-\t{\n-\t\tres := ast.NewObj(ast.Var, \"\")\n-\t\tres.Type = Typ[String]\n-\t\terr := ast.NewObj(ast.Fun, \"Error\")\n-\t\terr.Type = &Signature{Results: ObjList{res}}\n-\t\tobj := def(ast.Typ, \"error\")\n-\t\tobj.Type = &NamedType{Underlying: &Interface{Methods: ObjList{err}}, Obj: obj}\n-\t}\n-\n-\t// predeclared constants\n-\tfor _, t := range predeclaredConstants {\n-\t\tobj := def(ast.Con, t.name)\n-\t\tobj.Type = Typ[t.kind]\n-\t\tobj.Data = t.val\n-\t}\n-\n-\t// predeclared functions\n-\tfor _, f := range predeclaredFunctions {\n-\t\tdef(ast.Fun, f.name).Type = f\n-\t}\n-\n-\tuniverseIota = Universe.Lookup(\"iota\")\n-}\n-\n-// Objects with names containing blanks are internal and not entered into\n-// a scope. Objects with exported names are inserted in the unsafe package\n-// scope; other objects are inserted in the universe scope.\n-//\n-func def(kind ast.ObjKind, name string) *ast.Object {\n-\tobj := ast.NewObj(kind, name)\n-\t// insert non-internal objects into respective scope\n-\tif strings.Index(name, \" \") < 0 {\n-\t\tscope := Universe\n-\t\t// exported identifiers go into package unsafe\n-\t\tif ast.IsExported(name) {\n-\t\t\tscope = unsafe\n-\t\t}\n-\t\tif scope.Insert(obj) != nil {\n-\t\t\tpanic(\"internal error: double declaration\")\n-\t\t}\n-\t\tobj.Decl = scope\n-\t}\n-\treturn obj\n-}"}, {"sha": "572c62beed56cb3eb434ff8ebc124e3512c7822b", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -18,6 +18,7 @@ func RemoveAll() {\n }\n \n func TestInt(t *testing.T) {\n+\tRemoveAll()\n \treqs := NewInt(\"requests\")\n \tif reqs.i != 0 {\n \t\tt.Errorf(\"reqs.i = %v, want 0\", reqs.i)\n@@ -43,6 +44,7 @@ func TestInt(t *testing.T) {\n }\n \n func TestFloat(t *testing.T) {\n+\tRemoveAll()\n \treqs := NewFloat(\"requests-float\")\n \tif reqs.f != 0.0 {\n \t\tt.Errorf(\"reqs.f = %v, want 0\", reqs.f)\n@@ -68,6 +70,7 @@ func TestFloat(t *testing.T) {\n }\n \n func TestString(t *testing.T) {\n+\tRemoveAll()\n \tname := NewString(\"my-name\")\n \tif name.s != \"\" {\n \t\tt.Errorf(\"name.s = %q, want \\\"\\\"\", name.s)\n@@ -84,6 +87,7 @@ func TestString(t *testing.T) {\n }\n \n func TestMapCounter(t *testing.T) {\n+\tRemoveAll()\n \tcolors := NewMap(\"bike-shed-colors\")\n \n \tcolors.Add(\"red\", 1)\n@@ -123,6 +127,7 @@ func TestMapCounter(t *testing.T) {\n }\n \n func TestFunc(t *testing.T) {\n+\tRemoveAll()\n \tvar x interface{} = []string{\"a\", \"b\"}\n \tf := Func(func() interface{} { return x })\n \tif s, exp := f.String(), `[\"a\",\"b\"]`; s != exp {"}, {"sha": "85dd8c3b37ac06e5c2eac2a1aca2bff617990557", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -91,6 +91,15 @@ func (b *boolValue) Set(s string) error {\n \n func (b *boolValue) String() string { return fmt.Sprintf(\"%v\", *b) }\n \n+func (b *boolValue) IsBoolFlag() bool { return true }\n+\n+// optional interface to indicate boolean flags that can be\n+// supplied without \"=value\" text\n+type boolFlag interface {\n+\tValue\n+\tIsBoolFlag() bool\n+}\n+\n // -- int Value\n type intValue int\n \n@@ -204,6 +213,10 @@ func (d *durationValue) String() string { return (*time.Duration)(d).String() }\n \n // Value is the interface to the dynamic value stored in a flag.\n // (The default value is represented as a string.)\n+//\n+// If a Value has an IsBoolFlag() bool method returning true,\n+// the command-line parser makes -name equivalent to -name=true\n+// rather than using the next command-line argument.\n type Value interface {\n \tString() string\n \tSet(string) error\n@@ -704,7 +717,7 @@ func (f *FlagSet) parseOne() (bool, error) {\n \t\t}\n \t\treturn false, f.failf(\"flag provided but not defined: -%s\", name)\n \t}\n-\tif fv, ok := flag.Value.(*boolValue); ok { // special case: doesn't need an arg\n+\tif fv, ok := flag.Value.(boolFlag); ok && fv.IsBoolFlag() { // special case: doesn't need an arg\n \t\tif has_value {\n \t\t\tif err := fv.Set(value); err != nil {\n \t\t\t\treturn false, f.failf(\"invalid boolean value %q for  -%s: %v\", value, name, err)"}, {"sha": "ddd54b2777fe6fd2374bf048db282c3cd463bdc5", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,17 +15,6 @@ import (\n \t\"time\"\n )\n \n-var (\n-\ttest_bool     = Bool(\"test_bool\", false, \"bool value\")\n-\ttest_int      = Int(\"test_int\", 0, \"int value\")\n-\ttest_int64    = Int64(\"test_int64\", 0, \"int64 value\")\n-\ttest_uint     = Uint(\"test_uint\", 0, \"uint value\")\n-\ttest_uint64   = Uint64(\"test_uint64\", 0, \"uint64 value\")\n-\ttest_string   = String(\"test_string\", \"0\", \"string value\")\n-\ttest_float64  = Float64(\"test_float64\", 0, \"float64 value\")\n-\ttest_duration = Duration(\"test_duration\", 0, \"time.Duration value\")\n-)\n-\n func boolString(s string) string {\n \tif s == \"0\" {\n \t\treturn \"false\"\n@@ -34,6 +23,16 @@ func boolString(s string) string {\n }\n \n func TestEverything(t *testing.T) {\n+\tResetForTesting(nil)\n+\tBool(\"test_bool\", false, \"bool value\")\n+\tInt(\"test_int\", 0, \"int value\")\n+\tInt64(\"test_int64\", 0, \"int64 value\")\n+\tUint(\"test_uint\", 0, \"uint value\")\n+\tUint64(\"test_uint64\", 0, \"uint64 value\")\n+\tString(\"test_string\", \"0\", \"string value\")\n+\tFloat64(\"test_float64\", 0, \"float64 value\")\n+\tDuration(\"test_duration\", 0, \"time.Duration value\")\n+\n \tm := make(map[string]*Flag)\n \tdesired := \"0\"\n \tvisitor := func(f *Flag) {\n@@ -208,6 +207,47 @@ func TestUserDefined(t *testing.T) {\n \t}\n }\n \n+// Declare a user-defined boolean flag type.\n+type boolFlagVar struct {\n+\tcount int\n+}\n+\n+func (b *boolFlagVar) String() string {\n+\treturn fmt.Sprintf(\"%d\", b.count)\n+}\n+\n+func (b *boolFlagVar) Set(value string) error {\n+\tif value == \"true\" {\n+\t\tb.count++\n+\t}\n+\treturn nil\n+}\n+\n+func (b *boolFlagVar) IsBoolFlag() bool {\n+\treturn b.count < 4\n+}\n+\n+func TestUserDefinedBool(t *testing.T) {\n+\tvar flags FlagSet\n+\tflags.Init(\"test\", ContinueOnError)\n+\tvar b boolFlagVar\n+\tvar err error\n+\tflags.Var(&b, \"b\", \"usage\")\n+\tif err = flags.Parse([]string{\"-b\", \"-b\", \"-b\", \"-b=true\", \"-b=false\", \"-b\", \"barg\", \"-b\"}); err != nil {\n+\t\tif b.count < 4 {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t}\n+\n+\tif b.count != 4 {\n+\t\tt.Errorf(\"want: %d; got: %d\", 4, b.count)\n+\t}\n+\n+\tif err == nil {\n+\t\tt.Error(\"expected error; got none\")\n+\t}\n+}\n+\n func TestSetOutput(t *testing.T) {\n \tvar flags FlagSet\n \tvar buf bytes.Buffer"}, {"sha": "2c925a4228308df466a9c096b24143935fa4c511", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -63,9 +63,10 @@\n \tThe default precision for %e and %f is 6; for %g it is the smallest\n \tnumber of digits necessary to identify the value uniquely.\n \n-\tFor strings, width is the minimum number of characters to output,\n-\tpadding with spaces if necessary, and precision is the maximum\n-\tnumber of characters to output, truncating if necessary.\n+\tFor most values, width is the minimum number of characters to output,\n+\tpadding the formatted form with spaces if necessary.\n+\tFor strings, precision is the maximum number of characters to output,\n+\ttruncating if necessary.\n \n \tOther flags:\n \t\t+\talways print a sign for numeric values;\n@@ -77,7 +78,12 @@\n \t\t\twrite e.g. U+0078 'x' if the character is printable for %U (%#U).\n \t\t' '\t(space) leave a space for elided sign in numbers (% d);\n \t\t\tput spaces between bytes printing strings or slices in hex (% x, % X)\n-\t\t0\tpad with leading zeros rather than spaces\n+\t\t0\tpad with leading zeros rather than spaces;\n+\t\t\tfor numbers, this moves the padding after the sign\n+\n+\tFlags are ignored by verbs that do not expect them.\n+\tFor example there is no alternate decimal format, so %#d and %d\n+\tbehave identically.\n \n \tFor each Printf-like function, there is also a Print function\n \tthat takes no format and is equivalent to saying %v for every"}, {"sha": "dd5e5542523874464180c83f07db8c16c7e8ee4c", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -96,7 +96,7 @@ type SI struct {\n \tI interface{}\n }\n \n-// A type with a String method with pointer receiver for testing %p\n+// P is a type with a String method with pointer receiver for testing %p.\n type P int\n \n var pValue P\n@@ -676,7 +676,8 @@ func TestStructPrinter(t *testing.T) {\n \t}\n }\n \n-// Check map printing using substrings so we don't depend on the print order.\n+// presentInMap checks map printing using substrings so we don't depend on the\n+// print order.\n func presentInMap(s string, a []string, t *testing.T) {\n \tfor i := 0; i < len(a); i++ {\n \t\tloc := strings.Index(s, a[i])\n@@ -717,8 +718,8 @@ func TestEmptyMap(t *testing.T) {\n \t}\n }\n \n-// Check that Sprint (and hence Print, Fprint) puts spaces in the right places,\n-// that is, between arg pairs in which neither is a string.\n+// TestBlank checks that Sprint (and hence Print, Fprint) puts spaces in the\n+// right places, that is, between arg pairs in which neither is a string.\n func TestBlank(t *testing.T) {\n \tgot := Sprint(\"<\", 1, \">:\", 1, 2, 3, \"!\")\n \texpect := \"<1>:1 2 3!\"\n@@ -727,8 +728,8 @@ func TestBlank(t *testing.T) {\n \t}\n }\n \n-// Check that Sprintln (and hence Println, Fprintln) puts spaces in the right places,\n-// that is, between all arg pairs.\n+// TestBlankln checks that Sprintln (and hence Println, Fprintln) puts spaces in\n+// the right places, that is, between all arg pairs.\n func TestBlankln(t *testing.T) {\n \tgot := Sprintln(\"<\", 1, \">:\", 1, 2, 3, \"!\")\n \texpect := \"< 1 >: 1 2 3 !\\n\"\n@@ -737,7 +738,7 @@ func TestBlankln(t *testing.T) {\n \t}\n }\n \n-// Check Formatter with Sprint, Sprintln, Sprintf\n+// TestFormatterPrintln checks Formatter with Sprint, Sprintln, Sprintf.\n func TestFormatterPrintln(t *testing.T) {\n \tf := F(1)\n \texpect := \"<v=F(1)>\\n\"\n@@ -786,7 +787,7 @@ func TestWidthAndPrecision(t *testing.T) {\n \t}\n }\n \n-// A type that panics in String.\n+// Panic is a type that panics in String.\n type Panic struct {\n \tmessage interface{}\n }\n@@ -801,7 +802,7 @@ func (p Panic) String() string {\n \tpanic(p.message)\n }\n \n-// A type that panics in Format.\n+// PanicF is a type that panics in Format.\n type PanicF struct {\n \tmessage interface{}\n }\n@@ -839,7 +840,7 @@ func TestPanics(t *testing.T) {\n \t}\n }\n \n-// Test that erroneous String routine doesn't cause fatal recursion.\n+// recurCount tests that erroneous String routine doesn't cause fatal recursion.\n var recurCount = 0\n \n type Recur struct {"}, {"sha": "5665db12c5d7146040de0a2bd0778cd5bcc493fc", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -72,7 +72,7 @@ func (f *fmt) init(buf *buffer) {\n \tf.clearflags()\n }\n \n-// Compute left and right padding widths (only one will be non-zero).\n+// computePadding computes left and right padding widths (only one will be non-zero).\n func (f *fmt) computePadding(width int) (padding []byte, leftWidth, rightWidth int) {\n \tleft := !f.minus\n \tw := f.wid\n@@ -95,7 +95,7 @@ func (f *fmt) computePadding(width int) (padding []byte, leftWidth, rightWidth i\n \treturn\n }\n \n-// Generate n bytes of padding.\n+// writePadding generates n bytes of padding.\n func (f *fmt) writePadding(n int, padding []byte) {\n \tfor n > 0 {\n \t\tm := n\n@@ -107,8 +107,7 @@ func (f *fmt) writePadding(n int, padding []byte) {\n \t}\n }\n \n-// Append b to f.buf, padded on left (w > 0) or right (w < 0 or f.minus)\n-// clear flags afterwards.\n+// pad appends b to f.buf, padded on left (w > 0) or right (w < 0 or f.minus).\n func (f *fmt) pad(b []byte) {\n \tif !f.widPresent || f.wid == 0 {\n \t\tf.buf.Write(b)\n@@ -124,8 +123,7 @@ func (f *fmt) pad(b []byte) {\n \t}\n }\n \n-// append s to buf, padded on left (w > 0) or right (w < 0 or f.minus).\n-// clear flags afterwards.\n+// padString appends s to buf, padded on left (w > 0) or right (w < 0 or f.minus).\n func (f *fmt) padString(s string) {\n \tif !f.widPresent || f.wid == 0 {\n \t\tf.buf.WriteString(s)\n@@ -141,17 +139,6 @@ func (f *fmt) padString(s string) {\n \t}\n }\n \n-func putint(buf []byte, base, val uint64, digits string) int {\n-\ti := len(buf) - 1\n-\tfor val >= base {\n-\t\tbuf[i] = digits[val%base]\n-\t\ti--\n-\t\tval /= base\n-\t}\n-\tbuf[i] = digits[val]\n-\treturn i - 1\n-}\n-\n var (\n \ttrueBytes  = []byte(\"true\")\n \tfalseBytes = []byte(\"false\")"}, {"sha": "4078f4a910b9fbd679b1b7031f55192091779bc5", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -26,8 +26,8 @@ var (\n \textraBytes      = []byte(\"%!(EXTRA \")\n \tirparenBytes    = []byte(\"i)\")\n \tbytesBytes      = []byte(\"[]byte{\")\n-\twidthBytes      = []byte(\"%!(BADWIDTH)\")\n-\tprecBytes       = []byte(\"%!(BADPREC)\")\n+\tbadWidthBytes   = []byte(\"%!(BADWIDTH)\")\n+\tbadPrecBytes    = []byte(\"%!(BADPREC)\")\n \tnoVerbBytes     = []byte(\"%!(NOVERB)\")\n )\n \n@@ -153,7 +153,7 @@ func newCache(f func() interface{}) *cache {\n \n var ppFree = newCache(func() interface{} { return new(pp) })\n \n-// Allocate a new pp struct or grab a cached one.\n+// newPrinter allocates a new pp struct or grab a cached one.\n func newPrinter() *pp {\n \tp := ppFree.get().(*pp)\n \tp.panicking = false\n@@ -162,7 +162,7 @@ func newPrinter() *pp {\n \treturn p\n }\n \n-// Save used pp structs in ppFree; avoids an allocation per invocation.\n+// free saves used pp structs in ppFree; avoids an allocation per invocation.\n func (p *pp) free() {\n \t// Don't hold on to pp structs with large buffers.\n \tif cap(p.buf) > 1024 {\n@@ -299,7 +299,7 @@ func Sprintln(a ...interface{}) string {\n \treturn s\n }\n \n-// Get the i'th arg of the struct value.\n+// getField gets the i'th arg of the struct value.\n // If the arg itself is an interface, return a value for\n // the thing inside the interface, not the interface itself.\n func getField(v reflect.Value, i int) reflect.Value {\n@@ -310,7 +310,7 @@ func getField(v reflect.Value, i int) reflect.Value {\n \treturn val\n }\n \n-// Convert ASCII to integer.  n is 0 (and got is false) if no number present.\n+// parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.\n func parsenum(s string, start, end int) (num int, isnum bool, newi int) {\n \tif start >= end {\n \t\treturn 0, false, end\n@@ -1057,7 +1057,7 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\tif i < end && format[i] == '*' {\n \t\t\tp.fmt.wid, p.fmt.widPresent, i, fieldnum = intFromArg(a, end, i, fieldnum)\n \t\t\tif !p.fmt.widPresent {\n-\t\t\t\tp.buf.Write(widthBytes)\n+\t\t\t\tp.buf.Write(badWidthBytes)\n \t\t\t}\n \t\t} else {\n \t\t\tp.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)\n@@ -1067,7 +1067,7 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\t\tif format[i+1] == '*' {\n \t\t\t\tp.fmt.prec, p.fmt.precPresent, i, fieldnum = intFromArg(a, end, i+1, fieldnum)\n \t\t\t\tif !p.fmt.precPresent {\n-\t\t\t\t\tp.buf.Write(precBytes)\n+\t\t\t\t\tp.buf.Write(badPrecBytes)\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tp.fmt.prec, p.fmt.precPresent, i = parsenum(format, i+1, end)\n@@ -1123,7 +1123,7 @@ func (p *pp) doPrint(a []interface{}, addspace, addnewline bool) {\n \tprevString := false\n \tfor fieldnum := 0; fieldnum < len(a); fieldnum++ {\n \t\tp.fmt.clearflags()\n-\t\t// always add spaces if we're doing println\n+\t\t// always add spaces if we're doing Println\n \t\tfield := a[fieldnum]\n \t\tif fieldnum > 0 {\n \t\t\tisString := field != nil && reflect.TypeOf(field).Kind() == reflect.String"}, {"sha": "bf888c4d88c5edd72e9fbfd6d8b2b38095c599d4", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -312,8 +312,9 @@ func notSpace(r rune) bool {\n \treturn !isSpace(r)\n }\n \n-// skipSpace provides Scan() methods the ability to skip space and newline characters\n-// in keeping with the current scanning mode set by format strings and Scan()/Scanln().\n+// SkipSpace provides Scan methods the ability to skip space and newline\n+// characters in keeping with the current scanning mode set by format strings\n+// and Scan/Scanln.\n func (s *ss) SkipSpace() {\n \ts.skipSpace(false)\n }\n@@ -381,7 +382,7 @@ func (r *readRune) ReadRune() (rr rune, size int, err error) {\n \n var ssFree = newCache(func() interface{} { return new(ss) })\n \n-// Allocate a new ss struct or grab a cached one.\n+// newScanState allocates a new ss struct or grab a cached one.\n func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) {\n \t// If the reader is a *ss, then we've got a recursive\n \t// call to Scan, so re-use the scan state.\n@@ -413,7 +414,7 @@ func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) {\n \treturn\n }\n \n-// Save used ss structs in ssFree; avoid an allocation per invocation.\n+// free saves used ss structs in ssFree; avoid an allocation per invocation.\n func (s *ss) free(old ssave) {\n \t// If it was used recursively, just restore the old state.\n \tif old.validSave {"}, {"sha": "4e2c0feb2cbb65d9a07e43250a3d5eee2d25d2c1", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -626,7 +626,7 @@ func TestScanlnWithMiddleNewline(t *testing.T) {\n \t}\n }\n \n-// Special Reader that counts reads at end of file.\n+// eofCounter is a special Reader that counts reads at end of file.\n type eofCounter struct {\n \treader   *strings.Reader\n \teofCount int\n@@ -640,8 +640,8 @@ func (ec *eofCounter) Read(b []byte) (n int, err error) {\n \treturn\n }\n \n-// Verify that when we scan, we see at most EOF once per call to a Scan function,\n-// and then only when it's really an EOF\n+// TestEOF verifies that when we scan, we see at most EOF once per call to a\n+// Scan function, and then only when it's really an EOF.\n func TestEOF(t *testing.T) {\n \tec := &eofCounter{strings.NewReader(\"123\\n\"), 0}\n \tvar a int\n@@ -668,7 +668,7 @@ func TestEOF(t *testing.T) {\n \t}\n }\n \n-// Verify that we see an EOF error if we run out of input.\n+// TestEOFAtEndOfInput verifies that we see an EOF error if we run out of input.\n // This was a buglet: we used to get \"expected integer\".\n func TestEOFAtEndOfInput(t *testing.T) {\n \tvar i, j int\n@@ -730,7 +730,8 @@ func TestEOFAllTypes(t *testing.T) {\n \t}\n }\n \n-// Verify that, at least when using bufio, successive calls to Fscan do not lose runes.\n+// TestUnreadRuneWithBufio verifies that, at least when using bufio, successive\n+// calls to Fscan do not lose runes.\n func TestUnreadRuneWithBufio(t *testing.T) {\n \tr := bufio.NewReader(strings.NewReader(\"123\u03b1b\"))\n \tvar i int\n@@ -753,7 +754,7 @@ func TestUnreadRuneWithBufio(t *testing.T) {\n \n type TwoLines string\n \n-// Attempt to read two lines into the object.  Scanln should prevent this\n+// Scan attempts to read two lines into the object.  Scanln should prevent this\n // because it stops at newline; Scan and Scanf should be fine.\n func (t *TwoLines) Scan(state ScanState, verb rune) error {\n \tchars := make([]rune, 0, 100)\n@@ -820,7 +821,8 @@ func (s *simpleReader) Read(b []byte) (n int, err error) {\n \treturn s.sr.Read(b)\n }\n \n-// Test that Fscanf does not read past newline. Issue 3481.\n+// TestLineByLineFscanf tests that Fscanf does not read past newline. Issue\n+// 3481.\n func TestLineByLineFscanf(t *testing.T) {\n \tr := &simpleReader{strings.NewReader(\"1\\n2\\n\")}\n \tvar i, j int\n@@ -862,7 +864,7 @@ func (r *RecursiveInt) Scan(state ScanState, verb rune) (err error) {\n \treturn\n }\n \n-// Perform the same scanning task as RecursiveInt.Scan\n+// scanInts performs the same scanning task as RecursiveInt.Scan\n // but without recurring through scanner, so we can compare\n // performance more directly.\n func scanInts(r *RecursiveInt, b *bytes.Buffer) (err error) {"}, {"sha": "8df5b2c6565bad9cc000fa18545d9fa1a8d3ac42", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -64,19 +64,16 @@ func (s *Scope) String() string {\n // ----------------------------------------------------------------------------\n // Objects\n \n-// TODO(gri) Consider replacing the Object struct with an interface\n-//           and a corresponding set of object implementations.\n-\n // An Object describes a named language entity such as a package,\n // constant, type, variable, function (incl. methods), or label.\n //\n // The Data fields contains object-specific data:\n //\n-//\tKind    Data type    Data value\n-//\tPkg\t*Scope       package scope\n-//\tCon     int          iota for the respective declaration\n-//\tCon     != nil       constant value\n-//\tTyp     *Scope       method scope; nil if no methods\n+//\tKind    Data type         Data value\n+//\tPkg\t*types.Package    package scope\n+//\tCon     int               iota for the respective declaration\n+//\tCon     != nil            constant value\n+//\tTyp     *Scope            (used as method scope during type checking - transient)\n //\n type Object struct {\n \tKind ObjKind\n@@ -138,7 +135,7 @@ func (obj *Object) Pos() token.Pos {\n \treturn token.NoPos\n }\n \n-// ObKind describes what an object represents.\n+// ObjKind describes what an object represents.\n type ObjKind int\n \n // The list of possible Object kinds."}, {"sha": "f11582ac685584b4bdeccaaf047670b98b3737c8", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -216,7 +216,6 @@ var cgoEnabled = map[string]bool{\n \t\"darwin/amd64\":  true,\n \t\"freebsd/386\":   true,\n \t\"freebsd/amd64\": true,\n-\t\"freebsd/arm\":   true,\n \t\"linux/386\":     true,\n \t\"linux/amd64\":   true,\n \t\"linux/arm\":     true,\n@@ -322,7 +321,13 @@ func (p *Package) IsCommand() bool {\n // ImportDir is like Import but processes the Go package found in\n // the named directory.\n func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error) {\n-\treturn ctxt.Import(\".\", dir, mode)\n+\tp, err := ctxt.Import(\".\", dir, mode)\n+\t// TODO(rsc,adg): breaks godoc net/http. Not sure why.\n+\t// See CL 7232047 and issue 4696.\n+\tif false && err == nil && !ctxt.isDir(p.Dir) {\n+\t\terr = fmt.Errorf(\"%q is not a directory\", p.Dir)\n+\t}\n+\treturn p, err\n }\n \n // NoGoError is the error used by Import to describe a directory"}, {"sha": "4684d9baf804eb0d45312389f01aee218e48d588", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -5,6 +5,7 @@\n package build\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -89,6 +90,17 @@ func TestLocalDirectory(t *testing.T) {\n \t}\n }\n \n+// golang.org/issue/3248\n+func TestBogusDirectory(t *testing.T) {\n+\treturn // See issue 4696.\n+\tconst dir = \"/foo/bar/baz/gopher\"\n+\t_, err := ImportDir(dir, FindOnly)\n+\twant := fmt.Sprintf(\"%q is not a directory\", filepath.FromSlash(dir))\n+\tif err == nil || err.Error() != want {\n+\t\tt.Errorf(\"got error %q, want %q\", err, want)\n+\t}\n+}\n+\n func TestShouldBuild(t *testing.T) {\n \tconst file1 = \"// +build tag1\\n\\n\" +\n \t\t\"package main\\n\""}, {"sha": "c562d05d00fba8417d2c8ce733c60d260cb0ade2", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -63,6 +63,9 @@\n // they must appear near the top of the file, preceded\n // only by blank lines and other line comments.\n //\n+// To distinguish build constraints from package documentation, a series of\n+// build constraints must be followed by a blank line.\n+//\n // A build constraint is evaluated as the OR of space-separated options;\n // each option evaluates as the AND of its comma-separated terms;\n // and each term is an alphanumeric word or, preceded by !, its negation."}, {"sha": "8043038b4aefdb37efdc8b1d10bdeb1a225e920c", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -123,7 +123,7 @@ func test(t *testing.T, mode Mode) {\n \t\t}\n \n \t\t// compare\n-\t\tif bytes.Compare(got, want) != 0 {\n+\t\tif !bytes.Equal(got, want) {\n \t\t\tt.Errorf(\"package %s\\n\\tgot:\\n%s\\n\\twant:\\n%s\", pkg.Name, got, want)\n \t\t}\n \t}"}, {"sha": "f634e16770a3f63095eb8dc9fb9c18e0ffa8e21e", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -19,12 +19,13 @@ import (\n )\n \n type Example struct {\n-\tName     string // name of the item being exemplified\n-\tDoc      string // example function doc string\n-\tCode     ast.Node\n-\tPlay     *ast.File // a whole program version of the example\n-\tComments []*ast.CommentGroup\n-\tOutput   string // expected output\n+\tName        string // name of the item being exemplified\n+\tDoc         string // example function doc string\n+\tCode        ast.Node\n+\tPlay        *ast.File // a whole program version of the example\n+\tComments    []*ast.CommentGroup\n+\tOutput      string // expected output\n+\tEmptyOutput bool   // expect empty output\n }\n \n func Examples(files ...*ast.File) []*Example {\n@@ -55,13 +56,15 @@ func Examples(files ...*ast.File) []*Example {\n \t\t\tif f.Doc != nil {\n \t\t\t\tdoc = f.Doc.Text()\n \t\t\t}\n+\t\t\toutput, hasOutput := exampleOutput(f.Body, file.Comments)\n \t\t\tflist = append(flist, &Example{\n-\t\t\t\tName:     name[len(\"Example\"):],\n-\t\t\t\tDoc:      doc,\n-\t\t\t\tCode:     f.Body,\n-\t\t\t\tPlay:     playExample(file, f.Body),\n-\t\t\t\tComments: file.Comments,\n-\t\t\t\tOutput:   exampleOutput(f.Body, file.Comments),\n+\t\t\t\tName:        name[len(\"Example\"):],\n+\t\t\t\tDoc:         doc,\n+\t\t\t\tCode:        f.Body,\n+\t\t\t\tPlay:        playExample(file, f.Body),\n+\t\t\t\tComments:    file.Comments,\n+\t\t\t\tOutput:      output,\n+\t\t\t\tEmptyOutput: output == \"\" && hasOutput,\n \t\t\t})\n \t\t}\n \t\tif !hasTests && numDecl > 1 && len(flist) == 1 {\n@@ -79,15 +82,22 @@ func Examples(files ...*ast.File) []*Example {\n \n var outputPrefix = regexp.MustCompile(`(?i)^[[:space:]]*output:`)\n \n-func exampleOutput(b *ast.BlockStmt, comments []*ast.CommentGroup) string {\n+// Extracts the expected output and whether there was a valid output comment\n+func exampleOutput(b *ast.BlockStmt, comments []*ast.CommentGroup) (output string, ok bool) {\n \tif _, last := lastComment(b, comments); last != nil {\n \t\t// test that it begins with the correct prefix\n \t\ttext := last.Text()\n \t\tif loc := outputPrefix.FindStringIndex(text); loc != nil {\n-\t\t\treturn strings.TrimSpace(text[loc[1]:])\n+\t\t\ttext = text[loc[1]:]\n+\t\t\t// Strip zero or more spaces followed by \\n or a single space.\n+\t\t\ttext = strings.TrimLeft(text, \" \")\n+\t\t\tif len(text) > 0 && text[0] == '\\n' {\n+\t\t\t\ttext = text[1:]\n+\t\t\t}\n+\t\t\treturn text, true\n \t\t}\n \t}\n-\treturn \"\" // no suitable comment found\n+\treturn \"\", false // no suitable comment found\n }\n \n // isTest tells whether name looks like a test, example, or benchmark.\n@@ -142,13 +152,13 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t// Find unresolved identifiers and uses of top-level declarations.\n \tunresolved := make(map[string]bool)\n \tusesTopDecl := false\n-\tast.Inspect(body, func(n ast.Node) bool {\n-\t\t// For an expression like fmt.Println, only add \"fmt\" to the\n-\t\t// set of unresolved names.\n+\tvar inspectFunc func(ast.Node) bool\n+\tinspectFunc = func(n ast.Node) bool {\n+\t\t// For selector expressions, only inspect the left hand side.\n+\t\t// (For an expression like fmt.Println, only add \"fmt\" to the\n+\t\t// set of unresolved names, not \"Println\".)\n \t\tif e, ok := n.(*ast.SelectorExpr); ok {\n-\t\t\tif id, ok := e.X.(*ast.Ident); ok && id.Obj == nil {\n-\t\t\t\tunresolved[id.Name] = true\n-\t\t\t}\n+\t\t\tast.Inspect(e.X, inspectFunc)\n \t\t\treturn false\n \t\t}\n \t\tif id, ok := n.(*ast.Ident); ok {\n@@ -159,7 +169,8 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\t\t}\n \t\t}\n \t\treturn true\n-\t})\n+\t}\n+\tast.Inspect(body, inspectFunc)\n \tif usesTopDecl {\n \t\t// We don't support examples that are not self-contained (yet).\n \t\treturn nil"}, {"sha": "b70efd93d4319aa72248328ec4b8b16318670b7f", "filename": "libgo/go/go/doc/example_test.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc_test\n+\n+import (\n+\t\"bytes\"\n+\t\"go/doc\"\n+\t\"go/format\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+const exampleTestFile = `\n+package foo_test\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os/exec\"\n+)\n+\n+func ExampleHello() {\n+\tfmt.Println(\"Hello, world!\")\n+\t// Output: Hello, world!\n+}\n+\n+func ExampleImport() {\n+\tout, err := exec.Command(\"date\").Output()\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tfmt.Printf(\"The date is %s\\n\", out)\n+}\n+`\n+\n+var exampleTestCases = []struct {\n+\tName, Play, Output string\n+}{\n+\t{\n+\t\tName:   \"Hello\",\n+\t\tPlay:   exampleHelloPlay,\n+\t\tOutput: \"Hello, world!\\n\",\n+\t},\n+\t{\n+\t\tName: \"Import\",\n+\t\tPlay: exampleImportPlay,\n+\t},\n+}\n+\n+const exampleHelloPlay = `package main\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func main() {\n+\tfmt.Println(\"Hello, world!\")\n+}\n+`\n+const exampleImportPlay = `package main\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os/exec\"\n+)\n+\n+func main() {\n+\tout, err := exec.Command(\"date\").Output()\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tfmt.Printf(\"The date is %s\\n\", out)\n+}\n+`\n+\n+func TestExamples(t *testing.T) {\n+\tfs := token.NewFileSet()\n+\tfile, err := parser.ParseFile(fs, \"test.go\", strings.NewReader(exampleTestFile), parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, e := range doc.Examples(file) {\n+\t\tc := exampleTestCases[i]\n+\t\tif e.Name != c.Name {\n+\t\t\tt.Errorf(\"got Name == %q, want %q\", e.Name, c.Name)\n+\t\t}\n+\t\tif w := c.Play; w != \"\" {\n+\t\t\tvar g string // hah\n+\t\t\tif e.Play == nil {\n+\t\t\t\tg = \"<nil>\"\n+\t\t\t} else {\n+\t\t\t\tb := new(bytes.Buffer)\n+\t\t\t\tif err := format.Node(b, fs, e.Play); err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tg = b.String()\n+\t\t\t}\n+\t\t\tif g != w {\n+\t\t\t\tt.Errorf(\"%s: got Play == %q, want %q\", c.Name, g, w)\n+\t\t\t}\n+\t\t}\n+\t\tif g, w := e.Output, c.Output; g != w {\n+\t\t\tt.Errorf(\"%s: got Output == %q, want %q\", c.Name, g, w)\n+\t\t}\n+\t}\n+}"}, {"sha": "8d06d1c843ad747c44629e26d4dc26151d16b19a", "filename": "libgo/go/go/parser/error_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -34,9 +34,11 @@ import (\n \n const testdata = \"testdata\"\n \n+var fsetErrs *token.FileSet\n+\n // getFile assumes that each filename occurs at most once\n func getFile(filename string) (file *token.File) {\n-\tfset.Iterate(func(f *token.File) bool {\n+\tfsetErrs.Iterate(func(f *token.File) bool {\n \t\tif f.Name() == filename {\n \t\t\tif file != nil {\n \t\t\t\tpanic(filename + \" used multiple times\")\n@@ -125,7 +127,7 @@ func compareErrors(t *testing.T, expected map[token.Pos]string, found scanner.Er\n \tif len(expected) > 0 {\n \t\tt.Errorf(\"%d errors not reported:\", len(expected))\n \t\tfor pos, msg := range expected {\n-\t\t\tt.Errorf(\"%s: %s\\n\", fset.Position(pos), msg)\n+\t\t\tt.Errorf(\"%s: %s\\n\", fsetErrs.Position(pos), msg)\n \t\t}\n \t}\n }\n@@ -137,7 +139,7 @@ func checkErrors(t *testing.T, filename string, input interface{}) {\n \t\treturn\n \t}\n \n-\t_, err = ParseFile(fset, filename, src, DeclarationErrors)\n+\t_, err = ParseFile(fsetErrs, filename, src, DeclarationErrors)\n \tfound, ok := err.(scanner.ErrorList)\n \tif err != nil && !ok {\n \t\tt.Error(err)\n@@ -153,6 +155,7 @@ func checkErrors(t *testing.T, filename string, input interface{}) {\n }\n \n func TestErrors(t *testing.T) {\n+\tfsetErrs = token.NewFileSet()\n \tlist, err := ioutil.ReadDir(testdata)\n \tif err != nil {\n \t\tt.Fatal(err)"}, {"sha": "959af387200912d801a0e41f3bc07993b83d7716", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -149,7 +149,7 @@ func (p *parser) shortVarDecl(decl *ast.AssignStmt, list []ast.Expr) {\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tp.errorExpected(x.Pos(), \"identifier\")\n+\t\t\tp.errorExpected(x.Pos(), \"identifier on left side of :=\")\n \t\t}\n \t}\n \tif n == 0 && p.mode&DeclarationErrors != 0 {\n@@ -162,7 +162,12 @@ func (p *parser) shortVarDecl(decl *ast.AssignStmt, list []ast.Expr) {\n // internal consistency.\n var unresolved = new(ast.Object)\n \n-func (p *parser) resolve(x ast.Expr) {\n+// If x is an identifier, tryResolve attempts to resolve x by looking up\n+// the object it denotes. If no object is found and collectUnresolved is\n+// set, x is marked as unresolved and collected in the list of unresolved\n+// identifiers.\n+//\n+func (p *parser) tryResolve(x ast.Expr, collectUnresolved bool) {\n \t// nothing to do if x is not an identifier or the blank identifier\n \tident, _ := x.(*ast.Ident)\n \tif ident == nil {\n@@ -183,8 +188,14 @@ func (p *parser) resolve(x ast.Expr) {\n \t// must be found either in the file scope, package scope\n \t// (perhaps in another file), or universe scope --- collect\n \t// them so that they can be resolved later\n-\tident.Obj = unresolved\n-\tp.unresolved = append(p.unresolved, ident)\n+\tif collectUnresolved {\n+\t\tident.Obj = unresolved\n+\t\tp.unresolved = append(p.unresolved, ident)\n+\t}\n+}\n+\n+func (p *parser) resolve(x ast.Expr) {\n+\tp.tryResolve(x, true)\n }\n \n // ----------------------------------------------------------------------------\n@@ -1189,14 +1200,35 @@ func (p *parser) parseElement(keyOk bool) ast.Expr {\n \t\treturn p.parseLiteralValue(nil)\n \t}\n \n-\tx := p.checkExpr(p.parseExpr(keyOk)) // don't resolve if map key\n+\t// Because the parser doesn't know the composite literal type, it cannot\n+\t// know if a key that's an identifier is a struct field name or a name\n+\t// denoting a value. The former is not resolved by the parser or the\n+\t// resolver.\n+\t//\n+\t// Instead, _try_ to resolve such a key if possible. If it resolves,\n+\t// it a) has correctly resolved, or b) incorrectly resolved because\n+\t// the key is a struct field with a name matching another identifier.\n+\t// In the former case we are done, and in the latter case we don't\n+\t// care because the type checker will do a separate field lookup.\n+\t//\n+\t// If the key does not resolve, it must a) be defined at the top-\n+\t// level in another file of the same package or be undeclared, or\n+\t// b) it is a struct field. In the former case, the type checker\n+\t// can do a top-level lookup, and in the latter case it will do a\n+\t// separate field lookup.\n+\tx := p.checkExpr(p.parseExpr(keyOk))\n \tif keyOk {\n \t\tif p.tok == token.COLON {\n \t\t\tcolon := p.pos\n \t\t\tp.next()\n+\t\t\t// Try to resolve the key but don't collect it\n+\t\t\t// as unresolved identifier if it fails so that\n+\t\t\t// we don't get (possibly false) errors about\n+\t\t\t// undeclared names.\n+\t\t\tp.tryResolve(x, false)\n \t\t\treturn &ast.KeyValueExpr{Key: x, Colon: colon, Value: p.parseElement(false)}\n \t\t}\n-\t\tp.resolve(x) // not a map key\n+\t\tp.resolve(x) // not a key\n \t}\n \n \treturn x"}, {"sha": "c62f7e050649303f19f77b35f44f0dedc66d721f", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -70,6 +70,7 @@ var invalids = []string{\n \t`package p; func f() { select { case _ <- chan /* ERROR \"expected expression\" */ int: } };`,\n \t`package p; func f() { _ = (<-<- /* ERROR \"expected 'chan'\" */ chan int)(nil) };`,\n \t`package p; func f() { _ = (<-chan<-chan<-chan<-chan<-chan<- /* ERROR \"expected channel type\" */ int)(nil) };`,\n+\t`package p; func f() { var t []int; t /* ERROR \"expected identifier on left side of :=\" */ [0] := 0 };`,\n }\n \n func TestInvalid(t *testing.T) {"}, {"sha": "ee0bbf1eda9aba40d6c12cf30afda3ca02638d1e", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -307,7 +307,7 @@ func (p *printer) parameters(fields *ast.FieldList) {\n \t\t\t\tp.print(blank)\n \t\t\t}\n \t\t\t// parameter type\n-\t\t\tp.expr(par.Type)\n+\t\t\tp.expr(stripParensAlways(par.Type))\n \t\t\tprevLine = parLineEnd\n \t\t}\n \t\t// if the closing \")\" is on a separate line from the last parameter,\n@@ -336,7 +336,7 @@ func (p *printer) signature(params, result *ast.FieldList) {\n \t\tp.print(blank)\n \t\tif n == 1 && result.List[0].Names == nil {\n \t\t\t// single anonymous result; no ()'s\n-\t\t\tp.expr(result.List[0].Type)\n+\t\t\tp.expr(stripParensAlways(result.List[0].Type))\n \t\t\treturn\n \t\t}\n \t\tp.parameters(result)\n@@ -959,6 +959,13 @@ func stripParens(x ast.Expr) ast.Expr {\n \treturn x\n }\n \n+func stripParensAlways(x ast.Expr) ast.Expr {\n+\tif x, ok := x.(*ast.ParenExpr); ok {\n+\t\treturn stripParensAlways(x.X)\n+\t}\n+\treturn x\n+}\n+\n func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, post ast.Stmt) {\n \tp.print(blank)\n \tneedsBlank := false"}, {"sha": "f1c07bd3be2d6c993bc624ab017419c365f8be97", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -1230,7 +1230,7 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n \t}\n \n \t// flush tabwriter, if any\n-\tif tw, _ := (output).(*tabwriter.Writer); tw != nil {\n+\tif tw, _ := output.(*tabwriter.Writer); tw != nil {\n \t\terr = tw.Flush()\n \t}\n "}, {"sha": "0ad72d349ee440bcb1aa2753929054328350c2fa", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -887,3 +887,28 @@ type _ interface {\n \t\tr string,\n \t\tx ...int)\n }\n+\n+// omit superfluous parentheses in parameter lists\n+func _(int)\n+func _(int)\n+func _(x int)\n+func _(x int)\n+func _(x, y int)\n+func _(x, y int)\n+\n+func _() int\n+func _() int\n+func _() int\n+\n+func _() (x int)\n+func _() (x int)\n+func _() (x int)\n+\n+// special cases: some channel types require parentheses\n+func _(x chan (<-chan int))\n+func _(x chan (<-chan int))\n+func _(x chan (<-chan int))\n+\n+func _(x chan<- (chan int))\n+func _(x chan<- (chan int))\n+func _(x chan<- (chan int))"}, {"sha": "455c0c6c19f1e84f5d5ac8db580537fd5276a6e0", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -896,3 +896,28 @@ p, q,\n r string,\n \t\tx ...int)\n }\n+\n+// omit superfluous parentheses in parameter lists\n+func _((int))\n+func _((((((int))))))\n+func _(x (int))\n+func _(x (((((int))))))\n+func _(x, y (int))\n+func _(x, y (((((int))))))\n+\n+func _() (int)\n+func _() ((int))\n+func _() ((((((int))))))\n+\n+func _() (x int)\n+func _() (x (int))\n+func _() (x (((((int))))))\n+\n+// special cases: some channel types require parentheses\n+func _(x chan(<-chan int))\n+func _(x (chan(<-chan int)))\n+func _(x ((((chan(<-chan int))))))\n+\n+func _(x chan<-(chan int))\n+func _(x (chan<-(chan int)))\n+func _(x ((((chan<-(chan int))))))"}, {"sha": "e5b6aa12c011d3028ada393a46cf0e3cf75e35dc", "filename": "libgo/go/go/types/api.go", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package types declares the data structures for representing\n+// Go types and implements typechecking of package files.\n+//\n+// WARNING: THE TYPES API IS SUBJECT TO CHANGE.\n+//\n+package types\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+)\n+\n+// A Context specifies the supporting context for type checking.\n+type Context struct {\n+\tIntSize int64 // size in bytes of int and uint values\n+\tPtrSize int64 // size in bytes of pointers\n+\n+\t// If Error is not nil, it is called with each error found\n+\t// during type checking. Most error messages have accurate\n+\t// position information; those error strings are formatted\n+\t// filename:line:column: message.\n+\tError func(err error)\n+\n+\t// If Ident is not nil, it is called for each identifier id\n+\t// denoting an Object in the files provided to Check, and\n+\t// obj is the denoted object.\n+\t// Ident is not called for fields and methods in struct or\n+\t// interface types or composite literals, or for blank (_)\n+\t// or dot (.) identifiers in dot-imports.\n+\t// TODO(gri) Consider making Fields and Methods ordinary\n+\t// Objects - than we could lift this restriction.\n+\tIdent func(id *ast.Ident, obj Object)\n+\n+\t// If Expr is not nil, it is called for each expression x that is\n+\t// type-checked: typ is the expression type, and val is the value\n+\t// if x is constant, val is nil otherwise.\n+\t//\n+\t// Constants are represented as follows:\n+\t//\n+\t//\tbool     ->  bool\n+\t//\tnumeric  ->  int64, *big.Int, *big.Rat, Complex\n+\t//\tstring   ->  string\n+\t//\tnil      ->  NilType\n+\t//\n+\t// Constant values are normalized, that is, they are represented\n+\t// using the \"smallest\" possible type that can represent the value.\n+\t// For instance, 1.0 is represented as an int64 because it can be\n+\t// represented accurately as an int64.\n+\tExpr func(x ast.Expr, typ Type, val interface{})\n+\n+\t// If Import is not nil, it is used instead of GcImport.\n+\tImport Importer\n+}\n+\n+// An Importer resolves import paths to Package objects.\n+// The imports map records the packages already imported,\n+// indexed by package id (canonical import path).\n+// An Importer must determine the canonical import path and\n+// check the map to see if it is already present in the imports map.\n+// If so, the Importer can return the map entry.  Otherwise, the\n+// Importer should load the package data for the given path into\n+// a new *Package, record pkg in the imports map, and then\n+// return pkg.\n+type Importer func(imports map[string]*Package, path string) (pkg *Package, err error)\n+\n+// Default is the default context for type checking.\n+var Default = Context{\n+\t// TODO(gri) Perhaps this should depend on GOARCH?\n+\tIntSize: 8,\n+\tPtrSize: 8,\n+}\n+\n+// Check resolves and typechecks a set of package files within the given\n+// context. The package files' ASTs are augmented by assigning types to\n+// ast.Objects. If there are no errors, Check returns the package, otherwise\n+// it returns the first error. If the context's Error handler is nil,\n+// Check terminates as soon as the first error is encountered.\n+//\n+// CAUTION: At the moment, the returned *ast.Package only contains the package\n+//          name and scope - the other fields are not set up. The returned\n+//          *Package contains the name and imports (but no scope yet). Once\n+//          we have the scope moved from *ast.Scope to *Scope, only *Package\n+//          will be returned.\n+//\n+func (ctxt *Context) Check(fset *token.FileSet, files []*ast.File) (*Package, error) {\n+\treturn check(ctxt, fset, files)\n+}\n+\n+// Check is shorthand for Default.Check.\n+func Check(fset *token.FileSet, files []*ast.File) (*Package, error) {\n+\treturn Default.Check(fset, files)\n+}"}, {"sha": "867f1e9c6de0545f581dd81830c2cb1974db5907", "filename": "libgo/go/go/types/builtins.go", "status": "renamed", "additions": 84, "deletions": 37, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -21,8 +21,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \tid := bin.id\n \n \t// declare before goto's\n-\tvar arg0 ast.Expr\n-\tvar typ0 Type\n+\tvar arg0 ast.Expr // first argument, if present\n \n \t// check argument count\n \tn := len(args)\n@@ -33,7 +32,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tmsg = \"too many\"\n \t}\n \tif msg != \"\" {\n-\t\tcheck.invalidOp(call.Pos(), msg+\"arguments for %s (expected %d, found %d)\", call, bin.nargs, n)\n+\t\tcheck.invalidOp(call.Pos(), msg+\" arguments for %s (expected %d, found %d)\", call, bin.nargs, n)\n \t\tgoto Error\n \t}\n \n@@ -42,31 +41,24 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \tif n > 0 {\n \t\targ0 = args[0]\n \t\tswitch id {\n-\t\tcase _Make, _New:\n-\t\t\t// argument must be a type\n-\t\t\ttyp0 = check.typ(arg0, false)\n-\t\t\tif typ0 == Typ[Invalid] {\n-\t\t\t\tgoto Error\n-\t\t\t}\n-\t\tcase _Trace:\n-\t\t\t// _Trace implementation does the work\n+\t\tcase _Make, _New, _Trace:\n+\t\t\t// respective cases below do the work\n \t\tdefault:\n \t\t\t// argument must be an expression\n \t\t\tcheck.expr(x, arg0, nil, iota)\n \t\t\tif x.mode == invalid {\n \t\t\t\tgoto Error\n \t\t\t}\n-\t\t\ttyp0 = underlying(x.typ)\n \t\t}\n \t}\n \n \tswitch id {\n \tcase _Append:\n-\t\ts, ok := typ0.(*Slice)\n-\t\tif !ok {\n+\t\tif _, ok := underlying(x.typ).(*Slice); !ok {\n \t\t\tcheck.invalidArg(x.pos(), \"%s is not a typed slice\", x)\n \t\t\tgoto Error\n \t\t}\n+\t\tresultTyp := x.typ\n \t\tfor _, arg := range args[1:] {\n \t\t\tcheck.expr(x, arg, nil, iota)\n \t\t\tif x.mode == invalid {\n@@ -75,12 +67,12 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\t\t// TODO(gri) check assignability\n \t\t}\n \t\tx.mode = value\n-\t\tx.typ = s\n+\t\tx.typ = resultTyp\n \n \tcase _Cap, _Len:\n \t\tmode := invalid\n \t\tvar val interface{}\n-\t\tswitch typ := implicitDeref(typ0).(type) {\n+\t\tswitch typ := implicitDeref(underlying(x.typ)).(type) {\n \t\tcase *Basic:\n \t\t\tif isString(typ) && id == _Len {\n \t\t\t\tif x.mode == constant {\n@@ -116,7 +108,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tx.val = val\n \n \tcase _Close:\n-\t\tch, ok := typ0.(*Chan)\n+\t\tch, ok := underlying(x.typ).(*Chan)\n \t\tif !ok {\n \t\t\tcheck.invalidArg(x.pos(), \"%s is not a channel\", x)\n \t\t\tgoto Error\n@@ -150,7 +142,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\t\tgoto Error\n \t\t}\n \n-\t\tif !isIdentical(x.typ, y.typ) {\n+\t\tif !IsIdentical(x.typ, y.typ) {\n \t\t\tcheck.invalidArg(x.pos(), \"mismatched types %s and %s\", x.typ, y.typ)\n \t\t\tgoto Error\n \t\t}\n@@ -175,13 +167,40 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\t}\n \n \tcase _Copy:\n-\t\t// TODO(gri) implements checks\n-\t\tunimplemented()\n+\t\tvar y operand\n+\t\tcheck.expr(&y, args[1], nil, iota)\n+\t\tif y.mode == invalid {\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\tvar dst, src Type\n+\t\tif t, ok := underlying(x.typ).(*Slice); ok {\n+\t\t\tdst = t.Elt\n+\t\t}\n+\t\tswitch t := underlying(y.typ).(type) {\n+\t\tcase *Basic:\n+\t\t\tif isString(y.typ) {\n+\t\t\t\tsrc = Typ[Byte]\n+\t\t\t}\n+\t\tcase *Slice:\n+\t\t\tsrc = t.Elt\n+\t\t}\n+\n+\t\tif dst == nil || src == nil {\n+\t\t\tcheck.invalidArg(x.pos(), \"copy expects slice arguments; found %s and %s\", x, &y)\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\tif !IsIdentical(dst, src) {\n+\t\t\tcheck.invalidArg(x.pos(), \"arguments to copy %s and %s have different element types %s and %s\", x, &y, dst, src)\n+\t\t\tgoto Error\n+\t\t}\n+\n \t\tx.mode = value\n \t\tx.typ = Typ[Int]\n \n \tcase _Delete:\n-\t\tm, ok := typ0.(*Map)\n+\t\tm, ok := underlying(x.typ).(*Map)\n \t\tif !ok {\n \t\t\tcheck.invalidArg(x.pos(), \"%s is not a map\", x)\n \t\t\tgoto Error\n@@ -197,25 +216,25 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tx.mode = novalue\n \n \tcase _Imag, _Real:\n-\t\tif !isComplex(typ0) {\n+\t\tif !isComplex(x.typ) {\n \t\t\tcheck.invalidArg(x.pos(), \"%s must be a complex number\", x)\n \t\t\tgoto Error\n \t\t}\n \t\tif x.mode == constant {\n \t\t\t// nothing to do for x.val == 0\n \t\t\tif !isZeroConst(x.val) {\n-\t\t\t\tc := x.val.(complex)\n+\t\t\t\tc := x.val.(Complex)\n \t\t\t\tif id == _Real {\n-\t\t\t\t\tx.val = c.re\n+\t\t\t\t\tx.val = c.Re\n \t\t\t\t} else {\n-\t\t\t\t\tx.val = c.im\n+\t\t\t\t\tx.val = c.Im\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tx.mode = value\n \t\t}\n \t\tk := Invalid\n-\t\tswitch typ0.(*Basic).Kind {\n+\t\tswitch underlying(x.typ).(*Basic).Kind {\n \t\tcase Complex64:\n \t\t\tk = Float32\n \t\tcase Complex128:\n@@ -228,8 +247,12 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tx.typ = Typ[k]\n \n \tcase _Make:\n+\t\tresultTyp := check.typ(arg0, false)\n+\t\tif resultTyp == Typ[Invalid] {\n+\t\t\tgoto Error\n+\t\t}\n \t\tvar min int // minimum number of arguments\n-\t\tswitch underlying(typ0).(type) {\n+\t\tswitch underlying(resultTyp).(type) {\n \t\tcase *Slice:\n \t\t\tmin = 2\n \t\tcase *Map, *Chan:\n@@ -264,18 +287,25 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\t\t// safe to continue\n \t\t}\n \t\tx.mode = variable\n-\t\tx.typ = typ0\n+\t\tx.typ = resultTyp\n \n \tcase _New:\n+\t\tresultTyp := check.typ(arg0, false)\n+\t\tif resultTyp == Typ[Invalid] {\n+\t\t\tgoto Error\n+\t\t}\n \t\tx.mode = variable\n-\t\tx.typ = &Pointer{Base: typ0}\n+\t\tx.typ = &Pointer{Base: resultTyp}\n \n \tcase _Panic, _Print, _Println:\n+\t\tfor _, arg := range args[1:] {\n+\t\t\tcheck.expr(x, arg, nil, -1)\n+\t\t}\n \t\tx.mode = novalue\n \n \tcase _Recover:\n \t\tx.mode = value\n-\t\tx.typ = emptyInterface\n+\t\tx.typ = new(Interface)\n \n \tcase _Alignof:\n \t\tx.mode = constant\n@@ -298,20 +328,15 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tx.val = int64(0)\n \n \tcase _Sizeof:\n-\t\t// basic types with specified sizes have size guarantees; for all others we use 0\n-\t\tvar size int64\n-\t\tif typ, ok := typ0.(*Basic); ok {\n-\t\t\tsize = typ.Size\n-\t\t}\n \t\tx.mode = constant\n+\t\tx.val = sizeof(check.ctxt, x.typ)\n \t\tx.typ = Typ[Uintptr]\n-\t\tx.val = size\n \n \tcase _Assert:\n \t\t// assert(pred) causes a typechecker error if pred is false.\n \t\t// The result of assert is the value of pred if there is no error.\n \t\t// Note: assert is only available in self-test mode.\n-\t\tif x.mode != constant || !isBoolean(typ0) {\n+\t\tif x.mode != constant || !isBoolean(x.typ) {\n \t\t\tcheck.invalidArg(x.pos(), \"%s is not a boolean constant\", x)\n \t\t\tgoto Error\n \t\t}\n@@ -408,3 +433,25 @@ func (check *checker) complexArg(x *operand) bool {\n \tcheck.invalidArg(x.pos(), \"%s must be a float32, float64, or an untyped non-complex numeric constant\", x)\n \treturn false\n }\n+\n+func sizeof(ctxt *Context, typ Type) int64 {\n+\tswitch typ := underlying(typ).(type) {\n+\tcase *Basic:\n+\t\tswitch typ.Kind {\n+\t\tcase Int, Uint:\n+\t\t\treturn ctxt.IntSize\n+\t\tcase Uintptr:\n+\t\t\treturn ctxt.PtrSize\n+\t\t}\n+\t\treturn typ.Size\n+\tcase *Array:\n+\t\treturn sizeof(ctxt, typ.Elt) * typ.Len\n+\tcase *Struct:\n+\t\tvar size int64\n+\t\tfor _, f := range typ.Fields {\n+\t\t\tsize += sizeof(ctxt, f.Type)\n+\t\t}\n+\t\treturn size\n+\t}\n+\treturn ctxt.PtrSize // good enough\n+}", "previous_filename": "libgo/go/exp/types/builtins.go"}, {"sha": "fb9d7573d5792147e1a47bf959fe26277e6b8936", "filename": "libgo/go/go/types/check.go", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,454 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements the Check function, which typechecks a package.\n+\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/token\"\n+)\n+\n+// enable for debugging\n+const trace = false\n+\n+type checker struct {\n+\tctxt  *Context\n+\tfset  *token.FileSet\n+\tfiles []*ast.File\n+\n+\t// lazily initialized\n+\tpkg       *Package                          // current package\n+\tfirsterr  error                             // first error encountered\n+\tidents    map[*ast.Ident]Object             // maps identifiers to their unique object\n+\tobjects   map[*ast.Object]Object            // maps *ast.Objects to their unique object\n+\tinitspecs map[*ast.ValueSpec]*ast.ValueSpec // \"inherited\" type and initialization expressions for constant declarations\n+\tmethods   map[*TypeName]*Scope              // maps type names to associated methods\n+\tfunclist  []function                        // list of functions/methods with correct signatures and non-empty bodies\n+\tfuncsig   *Signature                        // signature of currently typechecked function\n+\tpos       []token.Pos                       // stack of expr positions; debugging support, used if trace is set\n+}\n+\n+func (check *checker) register(id *ast.Ident, obj Object) {\n+\t// When an expression is evaluated more than once (happens\n+\t// in rare cases, e.g. for statement expressions, see\n+\t// comment in stmt.go), the object has been registered\n+\t// before. Don't do anything in that case.\n+\tif alt := check.idents[id]; alt != nil {\n+\t\tassert(alt == obj)\n+\t\treturn\n+\t}\n+\tcheck.idents[id] = obj\n+\tif f := check.ctxt.Ident; f != nil {\n+\t\tf(id, obj)\n+\t}\n+}\n+\n+// lookup returns the unique Object denoted by the identifier.\n+// For identifiers without assigned *ast.Object, it uses the\n+// checker.idents map; for identifiers with an *ast.Object it\n+// uses the checker.objects map.\n+//\n+// TODO(gri) Once identifier resolution is done entirely by\n+//           the typechecker, only the idents map is needed.\n+//\n+func (check *checker) lookup(ident *ast.Ident) Object {\n+\tobj := check.idents[ident]\n+\tastObj := ident.Obj\n+\n+\tif obj != nil {\n+\t\tassert(astObj == nil || check.objects[astObj] == nil || check.objects[astObj] == obj)\n+\t\treturn obj\n+\t}\n+\n+\tif astObj == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif obj = check.objects[astObj]; obj == nil {\n+\t\tobj = newObj(astObj)\n+\t\tcheck.objects[astObj] = obj\n+\t}\n+\tcheck.register(ident, obj)\n+\n+\treturn obj\n+}\n+\n+type function struct {\n+\tobj  *Func // for debugging/tracing only\n+\tsig  *Signature\n+\tbody *ast.BlockStmt\n+}\n+\n+// later adds a function with non-empty body to the list of functions\n+// that need to be processed after all package-level declarations\n+// are typechecked.\n+//\n+func (check *checker) later(f *Func, sig *Signature, body *ast.BlockStmt) {\n+\t// functions implemented elsewhere (say in assembly) have no body\n+\tif body != nil {\n+\t\tcheck.funclist = append(check.funclist, function{f, sig, body})\n+\t}\n+}\n+\n+func (check *checker) declareIdent(scope *Scope, ident *ast.Ident, obj Object) {\n+\tassert(check.lookup(ident) == nil) // identifier already declared or resolved\n+\tcheck.register(ident, obj)\n+\tif ident.Name != \"_\" {\n+\t\tif alt := scope.Insert(obj); alt != nil {\n+\t\t\tprevDecl := \"\"\n+\t\t\tif pos := alt.GetPos(); pos.IsValid() {\n+\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", check.fset.Position(pos))\n+\t\t\t}\n+\t\t\tcheck.errorf(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n+\t\t}\n+\t}\n+}\n+\n+func (check *checker) valueSpec(pos token.Pos, obj Object, lhs []*ast.Ident, spec *ast.ValueSpec, iota int) {\n+\tif len(lhs) == 0 {\n+\t\tcheck.invalidAST(pos, \"missing lhs in declaration\")\n+\t\treturn\n+\t}\n+\n+\t// determine type for all of lhs, if any\n+\t// (but only set it for the object we typecheck!)\n+\tvar typ Type\n+\tif spec.Type != nil {\n+\t\ttyp = check.typ(spec.Type, false)\n+\t}\n+\n+\t// len(lhs) > 0\n+\trhs := spec.Values\n+\tif len(lhs) == len(rhs) {\n+\t\t// check only lhs and rhs corresponding to obj\n+\t\tvar l, r ast.Expr\n+\t\tfor i, name := range lhs {\n+\t\t\tif check.lookup(name) == obj {\n+\t\t\t\tl = lhs[i]\n+\t\t\t\tr = rhs[i]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tassert(l != nil)\n+\t\tswitch obj := obj.(type) {\n+\t\tcase *Const:\n+\t\t\tobj.Type = typ\n+\t\tcase *Var:\n+\t\t\tobj.Type = typ\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\tcheck.assign1to1(l, r, nil, true, iota)\n+\t\treturn\n+\t}\n+\n+\t// there must be a type or initialization expressions\n+\tif typ == nil && len(rhs) == 0 {\n+\t\tcheck.invalidAST(pos, \"missing type or initialization expression\")\n+\t\ttyp = Typ[Invalid]\n+\t}\n+\n+\t// if we have a type, mark all of lhs\n+\tif typ != nil {\n+\t\tfor _, name := range lhs {\n+\t\t\tswitch obj := check.lookup(name).(type) {\n+\t\t\tcase *Const:\n+\t\t\t\tobj.Type = typ\n+\t\t\tcase *Var:\n+\t\t\t\tobj.Type = typ\n+\t\t\tdefault:\n+\t\t\t\tunreachable()\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// check initial values, if any\n+\tif len(rhs) > 0 {\n+\t\t// TODO(gri) should try to avoid this conversion\n+\t\tlhx := make([]ast.Expr, len(lhs))\n+\t\tfor i, e := range lhs {\n+\t\t\tlhx[i] = e\n+\t\t}\n+\t\tcheck.assignNtoM(lhx, rhs, true, iota)\n+\t}\n+}\n+\n+// object typechecks an object by assigning it a type.\n+//\n+func (check *checker) object(obj Object, cycleOk bool) {\n+\tswitch obj := obj.(type) {\n+\tcase *Package:\n+\t\t// nothing to do\n+\tcase *Const:\n+\t\tif obj.Type != nil {\n+\t\t\treturn // already checked\n+\t\t}\n+\t\t// The obj.Val field for constants is initialized to its respective\n+\t\t// iota value by the parser.\n+\t\t// The object's fields can be in one of the following states:\n+\t\t// Type != nil  =>  the constant value is Val\n+\t\t// Type == nil  =>  the constant is not typechecked yet, and Val can be:\n+\t\t// Val  is int  =>  Val is the value of iota for this declaration\n+\t\t// Val  == nil  =>  the object's expression is being evaluated\n+\t\tif obj.Val == nil {\n+\t\t\tcheck.errorf(obj.GetPos(), \"illegal cycle in initialization of %s\", obj.Name)\n+\t\t\tobj.Type = Typ[Invalid]\n+\t\t\treturn\n+\t\t}\n+\t\tspec := obj.spec\n+\t\tiota := obj.Val.(int)\n+\t\tobj.Val = nil // mark obj as \"visited\" for cycle detection\n+\t\t// determine spec for type and initialization expressions\n+\t\tinit := spec\n+\t\tif len(init.Values) == 0 {\n+\t\t\tinit = check.initspecs[spec]\n+\t\t}\n+\t\tcheck.valueSpec(spec.Pos(), obj, spec.Names, init, iota)\n+\n+\tcase *Var:\n+\t\tif obj.Type != nil {\n+\t\t\treturn // already checked\n+\t\t}\n+\t\tif obj.visited {\n+\t\t\tcheck.errorf(obj.GetPos(), \"illegal cycle in initialization of %s\", obj.Name)\n+\t\t\tobj.Type = Typ[Invalid]\n+\t\t\treturn\n+\t\t}\n+\t\tspec := obj.decl.(*ast.ValueSpec)\n+\t\tobj.visited = true\n+\t\tcheck.valueSpec(spec.Pos(), obj, spec.Names, spec, 0)\n+\n+\tcase *TypeName:\n+\t\tif obj.Type != nil {\n+\t\t\treturn // already checked\n+\t\t}\n+\t\ttyp := &NamedType{Obj: obj}\n+\t\tobj.Type = typ // \"mark\" object so recursion terminates\n+\t\ttyp.Underlying = underlying(check.typ(obj.spec.Type, cycleOk))\n+\t\t// typecheck associated method signatures\n+\t\tif scope := check.methods[obj]; scope != nil {\n+\t\t\tswitch t := typ.Underlying.(type) {\n+\t\t\tcase *Struct:\n+\t\t\t\t// struct fields must not conflict with methods\n+\t\t\t\tfor _, f := range t.Fields {\n+\t\t\t\t\tif m := scope.Lookup(f.Name); m != nil {\n+\t\t\t\t\t\tcheck.errorf(m.GetPos(), \"type %s has both field and method named %s\", obj.Name, f.Name)\n+\t\t\t\t\t\t// ok to continue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase *Interface:\n+\t\t\t\t// methods cannot be associated with an interface type\n+\t\t\t\tfor _, m := range scope.Entries {\n+\t\t\t\t\trecv := m.(*Func).decl.Recv.List[0].Type\n+\t\t\t\t\tcheck.errorf(recv.Pos(), \"invalid receiver type %s (%s is an interface type)\", obj.Name, obj.Name)\n+\t\t\t\t\t// ok to continue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// typecheck method signatures\n+\t\t\tvar methods []*Method\n+\t\t\tfor _, obj := range scope.Entries {\n+\t\t\t\tm := obj.(*Func)\n+\t\t\t\tsig := check.typ(m.decl.Type, cycleOk).(*Signature)\n+\t\t\t\tparams, _ := check.collectParams(m.decl.Recv, false)\n+\t\t\t\tsig.Recv = params[0] // the parser/assocMethod ensure there is exactly one parameter\n+\t\t\t\tm.Type = sig\n+\t\t\t\tmethods = append(methods, &Method{QualifiedName{check.pkg, m.Name}, sig})\n+\t\t\t\tcheck.later(m, sig, m.decl.Body)\n+\t\t\t}\n+\t\t\ttyp.Methods = methods\n+\t\t\tdelete(check.methods, obj) // we don't need this scope anymore\n+\t\t}\n+\n+\tcase *Func:\n+\t\tif obj.Type != nil {\n+\t\t\treturn // already checked\n+\t\t}\n+\t\tfdecl := obj.decl\n+\t\t// methods are typechecked when their receivers are typechecked\n+\t\tif fdecl.Recv == nil {\n+\t\t\tsig := check.typ(fdecl.Type, cycleOk).(*Signature)\n+\t\t\tif obj.Name == \"init\" && (len(sig.Params) != 0 || len(sig.Results) != 0) {\n+\t\t\t\tcheck.errorf(fdecl.Pos(), \"func init must have no arguments and no return values\")\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\t\t\tobj.Type = sig\n+\t\t\tcheck.later(obj, sig, fdecl.Body)\n+\t\t}\n+\n+\tdefault:\n+\t\tunreachable()\n+\t}\n+}\n+\n+// assocInitvals associates \"inherited\" initialization expressions\n+// with the corresponding *ast.ValueSpec in the check.initspecs map\n+// for constant declarations without explicit initialization expressions.\n+//\n+func (check *checker) assocInitvals(decl *ast.GenDecl) {\n+\tvar last *ast.ValueSpec\n+\tfor _, s := range decl.Specs {\n+\t\tif s, ok := s.(*ast.ValueSpec); ok {\n+\t\t\tif len(s.Values) > 0 {\n+\t\t\t\tlast = s\n+\t\t\t} else {\n+\t\t\t\tcheck.initspecs[s] = last\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif last == nil {\n+\t\tcheck.invalidAST(decl.Pos(), \"no initialization values provided\")\n+\t}\n+}\n+\n+// assocMethod associates a method declaration with the respective\n+// receiver base type. meth.Recv must exist.\n+//\n+func (check *checker) assocMethod(meth *ast.FuncDecl) {\n+\t// The receiver type is one of the following (enforced by parser):\n+\t// - *ast.Ident\n+\t// - *ast.StarExpr{*ast.Ident}\n+\t// - *ast.BadExpr (parser error)\n+\ttyp := meth.Recv.List[0].Type\n+\tif ptr, ok := typ.(*ast.StarExpr); ok {\n+\t\ttyp = ptr.X\n+\t}\n+\t// determine receiver base type name\n+\tident, ok := typ.(*ast.Ident)\n+\tif !ok {\n+\t\t// not an identifier - parser reported error already\n+\t\treturn // ignore this method\n+\t}\n+\t// determine receiver base type object\n+\tvar tname *TypeName\n+\tif obj := check.lookup(ident); obj != nil {\n+\t\tobj, ok := obj.(*TypeName)\n+\t\tif !ok {\n+\t\t\tcheck.errorf(ident.Pos(), \"%s is not a type\", ident.Name)\n+\t\t\treturn // ignore this method\n+\t\t}\n+\t\tif obj.spec == nil {\n+\t\t\tcheck.errorf(ident.Pos(), \"cannot define method on non-local type %s\", ident.Name)\n+\t\t\treturn // ignore this method\n+\t\t}\n+\t\ttname = obj\n+\t} else {\n+\t\t// identifier not declared/resolved - parser reported error already\n+\t\treturn // ignore this method\n+\t}\n+\t// declare method in receiver base type scope\n+\tscope := check.methods[tname]\n+\tif scope == nil {\n+\t\tscope = new(Scope)\n+\t\tcheck.methods[tname] = scope\n+\t}\n+\tcheck.declareIdent(scope, meth.Name, &Func{Name: meth.Name.Name, decl: meth})\n+}\n+\n+func (check *checker) decl(decl ast.Decl) {\n+\tswitch d := decl.(type) {\n+\tcase *ast.BadDecl:\n+\t\t// ignore\n+\tcase *ast.GenDecl:\n+\t\tfor _, spec := range d.Specs {\n+\t\t\tswitch s := spec.(type) {\n+\t\t\tcase *ast.ImportSpec:\n+\t\t\t\t// nothing to do (handled by check.resolve)\n+\t\t\tcase *ast.ValueSpec:\n+\t\t\t\tfor _, name := range s.Names {\n+\t\t\t\t\tcheck.object(check.lookup(name), false)\n+\t\t\t\t}\n+\t\t\tcase *ast.TypeSpec:\n+\t\t\t\tcheck.object(check.lookup(s.Name), false)\n+\t\t\tdefault:\n+\t\t\t\tcheck.invalidAST(s.Pos(), \"unknown ast.Spec node %T\", s)\n+\t\t\t}\n+\t\t}\n+\tcase *ast.FuncDecl:\n+\t\t// methods are checked when their respective base types are checked\n+\t\tif d.Recv != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tobj := check.lookup(d.Name)\n+\t\t// Initialization functions don't have an object associated with them\n+\t\t// since they are not in any scope. Create a dummy object for them.\n+\t\tif d.Name.Name == \"init\" {\n+\t\t\tassert(obj == nil) // all other functions should have an object\n+\t\t\tobj = &Func{Name: d.Name.Name, decl: d}\n+\t\t\tcheck.register(d.Name, obj)\n+\t\t}\n+\t\tcheck.object(obj, false)\n+\tdefault:\n+\t\tcheck.invalidAST(d.Pos(), \"unknown ast.Decl node %T\", d)\n+\t}\n+}\n+\n+// A bailout panic is raised to indicate early termination.\n+type bailout struct{}\n+\n+func check(ctxt *Context, fset *token.FileSet, files []*ast.File) (pkg *Package, err error) {\n+\t// initialize checker\n+\tcheck := checker{\n+\t\tctxt:      ctxt,\n+\t\tfset:      fset,\n+\t\tfiles:     files,\n+\t\tidents:    make(map[*ast.Ident]Object),\n+\t\tobjects:   make(map[*ast.Object]Object),\n+\t\tinitspecs: make(map[*ast.ValueSpec]*ast.ValueSpec),\n+\t\tmethods:   make(map[*TypeName]*Scope),\n+\t}\n+\n+\t// handle panics\n+\tdefer func() {\n+\t\tswitch p := recover().(type) {\n+\t\tcase nil, bailout:\n+\t\t\t// normal return or early exit\n+\t\t\terr = check.firsterr\n+\t\tdefault:\n+\t\t\t// unexpected panic: don't crash clients\n+\t\t\tpanic(p) // enable for debugging\n+\t\t\t// TODO(gri) add a test case for this scenario\n+\t\t\terr = fmt.Errorf(\"types internal error: %v\", p)\n+\t\t}\n+\t}()\n+\n+\t// resolve identifiers\n+\timp := ctxt.Import\n+\tif imp == nil {\n+\t\timp = GcImport\n+\t}\n+\tpkg, methods := check.resolve(imp)\n+\tcheck.pkg = pkg\n+\n+\t// associate methods with types\n+\tfor _, m := range methods {\n+\t\tcheck.assocMethod(m)\n+\t}\n+\n+\t// typecheck all declarations\n+\tfor _, f := range check.files {\n+\t\tfor _, d := range f.Decls {\n+\t\t\tcheck.decl(d)\n+\t\t}\n+\t}\n+\n+\t// typecheck all function/method bodies\n+\t// (funclist may grow when checking statements - do not use range clause!)\n+\tfor i := 0; i < len(check.funclist); i++ {\n+\t\tf := check.funclist[i]\n+\t\tif trace {\n+\t\t\ts := \"<function literal>\"\n+\t\t\tif f.obj != nil {\n+\t\t\t\ts = f.obj.Name\n+\t\t\t}\n+\t\t\tfmt.Println(\"---\", s)\n+\t\t}\n+\t\tcheck.funcsig = f.sig\n+\t\tcheck.stmtList(f.body.List)\n+\t}\n+\n+\treturn\n+}"}, {"sha": "375ae67246c45ab574858d3f52beafd5b2b6e598", "filename": "libgo/go/go/types/check_test.go", "status": "renamed", "additions": 79, "deletions": 81, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -32,7 +32,6 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"regexp\"\n-\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -73,48 +72,57 @@ func getFile(filename string) (file *token.File) {\n \treturn file\n }\n \n-func getPos(filename string, offset int) token.Pos {\n-\tif f := getFile(filename); f != nil {\n-\t\treturn f.Pos(offset)\n+// Positioned errors are of the form filename:line:column: message .\n+var posMsgRx = regexp.MustCompile(`^(.*:[0-9]+:[0-9]+): *(.*)`)\n+\n+// splitError splits an error's error message into a position string\n+// and the actual error message. If there's no position information,\n+// pos is the empty string, and msg is the entire error message.\n+//\n+func splitError(err error) (pos, msg string) {\n+\tmsg = err.Error()\n+\tif m := posMsgRx.FindStringSubmatch(msg); len(m) == 3 {\n+\t\tpos = m[1]\n+\t\tmsg = m[2]\n \t}\n-\treturn token.NoPos\n+\treturn\n }\n \n-func parseFiles(t *testing.T, testname string, filenames []string) (map[string]*ast.File, error) {\n-\tfiles := make(map[string]*ast.File)\n-\tvar errors scanner.ErrorList\n+func parseFiles(t *testing.T, testname string, filenames []string) ([]*ast.File, []error) {\n+\tvar files []*ast.File\n+\tvar errlist []error\n \tfor _, filename := range filenames {\n-\t\tif _, exists := files[filename]; exists {\n-\t\t\tt.Fatalf(\"%s: duplicate file %s\", testname, filename)\n-\t\t}\n \t\tfile, err := parser.ParseFile(fset, filename, nil, parser.DeclarationErrors)\n \t\tif file == nil {\n \t\t\tt.Fatalf(\"%s: could not parse file %s\", testname, filename)\n \t\t}\n-\t\tfiles[filename] = file\n+\t\tfiles = append(files, file)\n \t\tif err != nil {\n-\t\t\t// if the parser returns a non-scanner.ErrorList error\n-\t\t\t// the file couldn't be read in the first place and\n-\t\t\t// file == nil; in that case we shouldn't reach here\n-\t\t\terrors = append(errors, err.(scanner.ErrorList)...)\n+\t\t\tif list, _ := err.(scanner.ErrorList); len(list) > 0 {\n+\t\t\t\tfor _, err := range list {\n+\t\t\t\t\terrlist = append(errlist, err)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\terrlist = append(errlist, err)\n+\t\t\t}\n \t\t}\n-\n \t}\n-\treturn files, errors\n+\treturn files, errlist\n }\n \n // ERROR comments must be of the form /* ERROR \"rx\" */ and rx is\n // a regular expression that matches the expected error message.\n //\n var errRx = regexp.MustCompile(`^/\\* *ERROR *\"([^\"]*)\" *\\*/$`)\n \n-// expectedErrors collects the regular expressions of ERROR comments found\n+// errMap collects the regular expressions of ERROR comments found\n // in files and returns them as a map of error positions to error messages.\n //\n-func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) map[token.Pos][]string {\n-\terrors := make(map[token.Pos][]string)\n+func errMap(t *testing.T, testname string, files []*ast.File) map[string][]string {\n+\terrmap := make(map[string][]string)\n \n-\tfor filename := range files {\n+\tfor _, file := range files {\n+\t\tfilename := fset.Position(file.Package).Filename\n \t\tsrc, err := ioutil.ReadFile(filename)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"%s: could not read %s\", testname, filename)\n@@ -125,7 +133,7 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t// set otherwise the position information returned here will\n \t\t// not match the position information collected by the parser\n \t\ts.Init(getFile(filename), src, nil, scanner.ScanComments)\n-\t\tvar prev token.Pos // position of last non-comment, non-semicolon token\n+\t\tvar prev string // position string of last non-comment, non-semicolon token\n \n \tscanFile:\n \t\tfor {\n@@ -136,117 +144,107 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t\tcase token.COMMENT:\n \t\t\t\ts := errRx.FindStringSubmatch(lit)\n \t\t\t\tif len(s) == 2 {\n-\t\t\t\t\tlist := errors[prev]\n-\t\t\t\t\terrors[prev] = append(list, string(s[1]))\n+\t\t\t\t\terrmap[prev] = append(errmap[prev], string(s[1]))\n \t\t\t\t}\n \t\t\tcase token.SEMICOLON:\n \t\t\t\t// ignore automatically inserted semicolon\n \t\t\t\tif lit == \"\\n\" {\n-\t\t\t\t\tbreak\n+\t\t\t\t\tcontinue scanFile\n \t\t\t\t}\n \t\t\t\tfallthrough\n \t\t\tdefault:\n-\t\t\t\tprev = pos\n+\t\t\t\tprev = fset.Position(pos).String()\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn errors\n+\treturn errmap\n }\n \n-func eliminate(t *testing.T, expected map[token.Pos][]string, errors error) {\n-\tif *listErrors || errors == nil {\n-\t\treturn\n-\t}\n-\tfor _, error := range errors.(scanner.ErrorList) {\n-\t\t// error.Pos is a token.Position, but we want\n-\t\t// a token.Pos so we can do a map lookup\n-\t\tpos := getPos(error.Pos.Filename, error.Pos.Offset)\n-\t\tlist := expected[pos]\n+func eliminate(t *testing.T, errmap map[string][]string, errlist []error) {\n+\tfor _, err := range errlist {\n+\t\tpos, msg := splitError(err)\n+\t\tlist := errmap[pos]\n \t\tindex := -1 // list index of matching message, if any\n \t\t// we expect one of the messages in list to match the error at pos\n \t\tfor i, msg := range list {\n \t\t\trx, err := regexp.Compile(msg)\n \t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"%s: %v\", error.Pos, err)\n+\t\t\t\tt.Errorf(\"%s: %v\", pos, err)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif match := rx.MatchString(error.Msg); match {\n+\t\t\tif rx.MatchString(msg) {\n \t\t\t\tindex = i\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t\tif index >= 0 {\n \t\t\t// eliminate from list\n-\t\t\tn := len(list) - 1\n-\t\t\tif n > 0 {\n+\t\t\tif n := len(list) - 1; n > 0 {\n \t\t\t\t// not the last entry - swap in last element and shorten list by 1\n \t\t\t\tlist[index] = list[n]\n-\t\t\t\texpected[pos] = list[:n]\n+\t\t\t\terrmap[pos] = list[:n]\n \t\t\t} else {\n \t\t\t\t// last entry - remove list from map\n-\t\t\t\tdelete(expected, pos)\n+\t\t\t\tdelete(errmap, pos)\n \t\t\t}\n \t\t} else {\n-\t\t\tt.Errorf(\"%s: no error expected: %q\", error.Pos, error.Msg)\n-\t\t\tcontinue\n+\t\t\tt.Errorf(\"%s: no error expected: %q\", pos, msg)\n \t\t}\n+\n \t}\n }\n \n func checkFiles(t *testing.T, testname string, testfiles []string) {\n-\t// TODO(gri) Eventually all these different phases should be\n-\t//           subsumed into a single function call that takes\n-\t//           a set of files and creates a fully resolved and\n-\t//           type-checked AST.\n-\n-\tfiles, err := parseFiles(t, testname, testfiles)\n-\n-\t// we are expecting the following errors\n-\t// (collect these after parsing the files so that\n-\t// they are found in the file set)\n-\terrors := expectedErrors(t, testname, files)\n-\n-\t// verify errors returned by the parser\n-\teliminate(t, errors, err)\n+\t// parse files and collect parser errors\n+\tfiles, errlist := parseFiles(t, testname, testfiles)\n \n-\t// verify errors returned after resolving identifiers\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\teliminate(t, errors, err)\n-\n-\t// verify errors returned by the typechecker\n-\tvar list scanner.ErrorList\n-\terrh := func(pos token.Pos, msg string) {\n-\t\tlist.Add(fset.Position(pos), msg)\n-\t}\n-\terr = Check(fset, pkg, errh, nil)\n-\teliminate(t, errors, list)\n+\t// typecheck and collect typechecker errors\n+\tctxt := Default\n+\tctxt.Error = func(err error) { errlist = append(errlist, err) }\n+\tctxt.Check(fset, files)\n \n \tif *listErrors {\n-\t\tscanner.PrintError(os.Stdout, err)\n+\t\tt.Errorf(\"--- %s: %d errors found:\", testname, len(errlist))\n+\t\tfor _, err := range errlist {\n+\t\t\tt.Error(err)\n+\t\t}\n \t\treturn\n \t}\n \n+\t// match and eliminate errors\n+\t// we are expecting the following errors\n+\t// (collect these after parsing the files so that\n+\t// they are found in the file set)\n+\terrmap := errMap(t, testname, files)\n+\teliminate(t, errmap, errlist)\n+\n \t// there should be no expected errors left\n-\tif len(errors) > 0 {\n-\t\tt.Errorf(\"%s: %d errors not reported:\", testname, len(errors))\n-\t\tfor pos, msg := range errors {\n-\t\t\tt.Errorf(\"%s: %s\\n\", fset.Position(pos), msg)\n+\tif len(errmap) > 0 {\n+\t\tt.Errorf(\"--- %s: %d source positions with expected (but not reported) errors:\", testname, len(errmap))\n+\t\tfor pos, list := range errmap {\n+\t\t\tfor _, rx := range list {\n+\t\t\t\tt.Errorf(\"%s: %q\", pos, rx)\n+\t\t\t}\n \t\t}\n \t}\n }\n \n+var testBuiltinsDeclared = false\n+\n func TestCheck(t *testing.T) {\n-\t// This package does not yet know how to read gccgo export data.\n-\tif runtime.Compiler == \"gccgo\" {\n-\t\treturn\n-\t}\n+\t// Does not work with gccgo, because it requires reading gc\n+\t// import files.\n+\treturn\n \n \t// Declare builtins for testing.\n \t// Not done in an init func to avoid an init race with\n \t// the construction of the Universe var.\n-\tdef(ast.Fun, \"assert\").Type = &builtin{aType, _Assert, \"assert\", 1, false, true}\n-\tdef(ast.Fun, \"trace\").Type = &builtin{aType, _Trace, \"trace\", 0, true, true}\n+\tif !testBuiltinsDeclared {\n+\t\ttestBuiltinsDeclared = true\n+\t\tdef(&Func{Name: \"assert\", Type: &builtin{_Assert, \"assert\", 1, false, true}})\n+\t\tdef(&Func{Name: \"trace\", Type: &builtin{_Trace, \"trace\", 0, true, true}})\n+\t}\n \n \t// For easy debugging w/o changing the testing code,\n \t// if there is a local test file, only test that file.", "previous_filename": "libgo/go/exp/types/check_test.go"}, {"sha": "a6c807c432736ee202a133d9fdc62fea27f42054", "filename": "libgo/go/go/types/const.go", "status": "renamed", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -20,32 +20,32 @@ import (\n // Representation of constant values.\n //\n // bool     ->  bool (true, false)\n-// numeric  ->  int64, *big.Int, *big.Rat, complex (ordered by increasing data structure \"size\")\n+// numeric  ->  int64, *big.Int, *big.Rat, Complex (ordered by increasing data structure \"size\")\n // string   ->  string\n-// nil      ->  nilType (nilConst)\n+// nil      ->  NilType (nilConst)\n //\n // Numeric constants are normalized after each operation such\n // that they are represented by the \"smallest\" data structure\n // required to represent the constant, independent of actual\n // type. Non-numeric constants are always normalized.\n \n // Representation of complex numbers.\n-type complex struct {\n-\tre, im *big.Rat\n+type Complex struct {\n+\tRe, Im *big.Rat\n }\n \n-func (c complex) String() string {\n-\tif c.re.Sign() == 0 {\n-\t\treturn fmt.Sprintf(\"%si\", c.im)\n+func (c Complex) String() string {\n+\tif c.Re.Sign() == 0 {\n+\t\treturn fmt.Sprintf(\"%si\", c.Im)\n \t}\n \t// normalized complex values always have an imaginary part\n-\treturn fmt.Sprintf(\"(%s + %si)\", c.re, c.im)\n+\treturn fmt.Sprintf(\"(%s + %si)\", c.Re, c.Im)\n }\n \n // Representation of nil.\n-type nilType struct{}\n+type NilType struct{}\n \n-func (nilType) String() string {\n+func (NilType) String() string {\n \treturn \"nil\"\n }\n \n@@ -58,7 +58,7 @@ const (\n \n // Frequently used values.\n var (\n-\tnilConst  = nilType{}\n+\tnilConst  = NilType{}\n \tzeroConst = int64(0)\n )\n \n@@ -97,7 +97,7 @@ func newComplex(re, im *big.Rat) interface{} {\n \tif im.Sign() == 0 {\n \t\treturn normalizeRatConst(re)\n \t}\n-\treturn complex{re, im}\n+\treturn Complex{re, im}\n }\n \n // makeRuneConst returns the int64 code point for the rune literal\n@@ -137,7 +137,7 @@ func makeFloatConst(lit string) interface{} {\n \treturn nil\n }\n \n-// makeComplexConst returns the complex constant representation (complex) for\n+// makeComplexConst returns the complex constant representation (Complex) for\n // the imaginary literal lit. The result is nil if lit is not a correct imaginary\n // literal.\n //\n@@ -162,7 +162,7 @@ func makeStringConst(lit string) interface{} {\n \treturn nil\n }\n \n-// toImagConst returns the constant complex(0, x) for a non-complex x.\n+// toImagConst returns the constant Complex(0, x) for a non-complex x.\n func toImagConst(x interface{}) interface{} {\n \tvar im *big.Rat\n \tswitch x := x.(type) {\n@@ -175,7 +175,7 @@ func toImagConst(x interface{}) interface{} {\n \tdefault:\n \t\tunreachable()\n \t}\n-\treturn complex{rat0, im}\n+\treturn Complex{rat0, im}\n }\n \n // isZeroConst reports whether the value of constant x is 0.\n@@ -282,7 +282,7 @@ func isRepresentableConst(x interface{}, as BasicKind) bool {\n \t\t\treturn true\n \t\t}\n \n-\tcase complex:\n+\tcase Complex:\n \t\tswitch as {\n \t\tcase Complex64:\n \t\t\treturn true // TODO(gri) fix this\n@@ -295,7 +295,7 @@ func isRepresentableConst(x interface{}, as BasicKind) bool {\n \tcase string:\n \t\treturn as == String || as == UntypedString\n \n-\tcase nilType:\n+\tcase NilType:\n \t\treturn as == UntypedNil || as == UnsafePointer\n \n \tdefault:\n@@ -313,15 +313,15 @@ var (\n // complexity returns a measure of representation complexity for constant x.\n func complexity(x interface{}) int {\n \tswitch x.(type) {\n-\tcase bool, string, nilType:\n+\tcase bool, string, NilType:\n \t\treturn 1\n \tcase int64:\n \t\treturn 2\n \tcase *big.Int:\n \t\treturn 3\n \tcase *big.Rat:\n \t\treturn 4\n-\tcase complex:\n+\tcase Complex:\n \t\treturn 5\n \t}\n \tunreachable()\n@@ -330,7 +330,7 @@ func complexity(x interface{}) int {\n \n // matchConst returns the matching representation (same type) with the\n // smallest complexity for two constant values x and y. They must be\n-// of the same \"kind\" (boolean, numeric, string, or nilType).\n+// of the same \"kind\" (boolean, numeric, string, or NilType).\n //\n func matchConst(x, y interface{}) (_, _ interface{}) {\n \tif complexity(x) > complexity(y) {\n@@ -340,7 +340,7 @@ func matchConst(x, y interface{}) (_, _ interface{}) {\n \t// complexity(x) <= complexity(y)\n \n \tswitch x := x.(type) {\n-\tcase bool, complex, string, nilType:\n+\tcase bool, Complex, string, NilType:\n \t\treturn x, y\n \n \tcase int64:\n@@ -351,8 +351,8 @@ func matchConst(x, y interface{}) (_, _ interface{}) {\n \t\t\treturn big.NewInt(x), y\n \t\tcase *big.Rat:\n \t\t\treturn big.NewRat(x, 1), y\n-\t\tcase complex:\n-\t\t\treturn complex{big.NewRat(x, 1), rat0}, y\n+\t\tcase Complex:\n+\t\t\treturn Complex{big.NewRat(x, 1), rat0}, y\n \t\t}\n \n \tcase *big.Int:\n@@ -361,16 +361,16 @@ func matchConst(x, y interface{}) (_, _ interface{}) {\n \t\t\treturn x, y\n \t\tcase *big.Rat:\n \t\t\treturn new(big.Rat).SetFrac(x, int1), y\n-\t\tcase complex:\n-\t\t\treturn complex{new(big.Rat).SetFrac(x, int1), rat0}, y\n+\t\tcase Complex:\n+\t\t\treturn Complex{new(big.Rat).SetFrac(x, int1), rat0}, y\n \t\t}\n \n \tcase *big.Rat:\n \t\tswitch y := y.(type) {\n \t\tcase *big.Rat:\n \t\t\treturn x, y\n-\t\tcase complex:\n-\t\t\treturn complex{x, rat0}, y\n+\t\tcase Complex:\n+\t\t\treturn Complex{x, rat0}, y\n \t\t}\n \t}\n \n@@ -405,8 +405,8 @@ func unaryOpConst(x interface{}, op token.Token, typ *Basic) interface{} {\n \t\t\treturn normalizeIntConst(new(big.Int).Neg(x))\n \t\tcase *big.Rat:\n \t\t\treturn normalizeRatConst(new(big.Rat).Neg(x))\n-\t\tcase complex:\n-\t\t\treturn newComplex(new(big.Rat).Neg(x.re), new(big.Rat).Neg(x.im))\n+\t\tcase Complex:\n+\t\t\treturn newComplex(new(big.Rat).Neg(x.Re), new(big.Rat).Neg(x.Im))\n \t\t}\n \tcase token.XOR:\n \t\tvar z big.Int\n@@ -551,10 +551,10 @@ func binaryOpConst(x, y interface{}, op token.Token, typ *Basic) interface{} {\n \t\t}\n \t\treturn normalizeRatConst(&z)\n \n-\tcase complex:\n-\t\ty := y.(complex)\n-\t\ta, b := x.re, x.im\n-\t\tc, d := y.re, y.im\n+\tcase Complex:\n+\t\ty := y.(Complex)\n+\t\ta, b := x.Re, x.Im\n+\t\tc, d := y.Re, y.Im\n \t\tvar re, im big.Rat\n \t\tswitch op {\n \t\tcase token.ADD:\n@@ -632,7 +632,7 @@ func shiftConst(x interface{}, s uint, op token.Token) interface{} {\n \n // compareConst returns the result of the constant comparison x op y;\n // both operands must be of the same \"kind\" (boolean, numeric, string,\n-// or nilType).\n+// or NilType).\n //\n func compareConst(x, y interface{}, op token.Token) (z bool) {\n \tx, y = matchConst(x, y)\n@@ -707,10 +707,10 @@ func compareConst(x, y interface{}, op token.Token) (z bool) {\n \t\t\treturn s < 0\n \t\t}\n \n-\tcase complex:\n-\t\ty := y.(complex)\n+\tcase Complex:\n+\t\ty := y.(Complex)\n \t\tif op == token.EQL {\n-\t\t\treturn x.re.Cmp(y.re) == 0 && x.im.Cmp(y.im) == 0\n+\t\t\treturn x.Re.Cmp(y.Re) == 0 && x.Im.Cmp(y.Im) == 0\n \t\t}\n \n \tcase string:\n@@ -722,9 +722,9 @@ func compareConst(x, y interface{}, op token.Token) (z bool) {\n \t\t\treturn x < y\n \t\t}\n \n-\tcase nilType:\n+\tcase NilType:\n \t\tif op == token.EQL {\n-\t\t\treturn x == y.(nilType)\n+\t\t\treturn x == y.(NilType)\n \t\t}\n \t}\n ", "previous_filename": "libgo/go/exp/types/const.go"}, {"sha": "65359f319d1ed9edf6944e8b48dd830659518313", "filename": "libgo/go/go/types/conversions.go", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements typechecking of conversions.\n+\n+package types\n+\n+import (\n+\t\"go/ast\"\n+)\n+\n+// conversion typechecks the type conversion conv to type typ. iota is the current\n+// value of iota or -1 if iota doesn't have a value in the current context. The result\n+// of the conversion is returned via x. If the conversion has type errors, the returned\n+// x is marked as invalid (x.mode == invalid).\n+//\n+func (check *checker) conversion(x *operand, conv *ast.CallExpr, typ Type, iota int) {\n+\t// all conversions have one argument\n+\tif len(conv.Args) != 1 {\n+\t\tcheck.invalidOp(conv.Pos(), \"%s conversion requires exactly one argument\", conv)\n+\t\tgoto Error\n+\t}\n+\n+\t// evaluate argument\n+\tcheck.expr(x, conv.Args[0], nil, iota)\n+\tif x.mode == invalid {\n+\t\tgoto Error\n+\t}\n+\n+\tif x.mode == constant && isConstType(typ) {\n+\t\t// constant conversion\n+\t\t// TODO(gri) implement this\n+\t} else {\n+\t\t// non-constant conversion\n+\t\tif !x.isConvertible(typ) {\n+\t\t\tcheck.invalidOp(conv.Pos(), \"cannot convert %s to %s\", x, typ)\n+\t\t\tgoto Error\n+\t\t}\n+\t\tx.mode = value\n+\t}\n+\n+\tx.expr = conv\n+\tx.typ = typ\n+\treturn\n+\n+Error:\n+\tx.mode = invalid\n+}\n+\n+func (x *operand) isConvertible(T Type) bool {\n+\t// \"x is assignable to T\"\n+\tif x.isAssignable(T) {\n+\t\treturn true\n+\t}\n+\n+\t// \"x's type and T have identical underlying types\"\n+\tV := x.typ\n+\tVu := underlying(V)\n+\tTu := underlying(T)\n+\tif IsIdentical(Vu, Tu) {\n+\t\treturn true\n+\t}\n+\n+\t// \"x's type and T are unnamed pointer types and their pointer base types have identical underlying types\"\n+\tif V, ok := V.(*Pointer); ok {\n+\t\tif T, ok := T.(*Pointer); ok {\n+\t\t\tif IsIdentical(underlying(V.Base), underlying(T.Base)) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// \"x's type and T are both integer or floating point types\"\n+\tif (isInteger(V) || isFloat(V)) && (isInteger(T) || isFloat(T)) {\n+\t\treturn true\n+\t}\n+\n+\t// \"x's type and T are both complex types\"\n+\tif isComplex(V) && isComplex(T) {\n+\t\treturn true\n+\t}\n+\n+\t// \"x is an integer or a slice of bytes or runes and T is a string type\"\n+\tif (isInteger(V) || isBytesOrRunes(Vu)) && isString(T) {\n+\t\treturn true\n+\t}\n+\n+\t// \"x is a string and T is a slice of bytes or runes\"\n+\tif isString(V) && isBytesOrRunes(Tu) {\n+\t\treturn true\n+\t}\n+\n+\t// package unsafe:\n+\t// \"any pointer or value of underlying type uintptr can be converted into a unsafe.Pointer\"\n+\tif (isPointer(Vu) || isUintptr(Vu)) && isUnsafePointer(T) {\n+\t\treturn true\n+\t}\n+\t// \"and vice versa\"\n+\tif isUnsafePointer(V) && (isPointer(Tu) || isUintptr(Tu)) {\n+\t\treturn true\n+\t}\n+\n+\treturn false\n+}\n+\n+func isUintptr(typ Type) bool {\n+\tt, ok := typ.(*Basic)\n+\treturn ok && t.Kind == Uintptr\n+}\n+\n+func isUnsafePointer(typ Type) bool {\n+\tt, ok := typ.(*Basic)\n+\treturn ok && t.Kind == UnsafePointer\n+}\n+\n+func isPointer(typ Type) bool {\n+\t_, ok := typ.(*Pointer)\n+\treturn ok\n+}\n+\n+func isBytesOrRunes(typ Type) bool {\n+\tif s, ok := typ.(*Slice); ok {\n+\t\tt, ok := underlying(s.Elt).(*Basic)\n+\t\treturn ok && (t.Kind == Byte || t.Kind == Rune)\n+\t}\n+\treturn false\n+}"}, {"sha": "c8b420b4db6939b2b546446371e1e8caacc40ef7", "filename": "libgo/go/go/types/errors.go", "status": "renamed", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ferrors.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -20,25 +20,20 @@ func assert(p bool) {\n \t}\n }\n \n-func unimplemented() {\n-\t// enable for debugging\n-\t// panic(\"unimplemented\")\n-}\n-\n func unreachable() {\n \tpanic(\"unreachable\")\n }\n \n func (check *checker) printTrace(format string, args []interface{}) {\n-\tconst dots = \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n+\tconst dots = \".  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  \"\n \tn := len(check.pos) - 1\n-\ti := 2 * n\n+\ti := 3 * n\n \tfor i > len(dots) {\n \t\tfmt.Print(dots)\n \t\ti -= len(dots)\n \t}\n \t// i <= len(dots)\n-\tfmt.Printf(\"%s: \", check.fset.Position(check.pos[n]))\n+\tfmt.Printf(\"%s:\\t\", check.fset.Position(check.pos[n]))\n \tfmt.Print(dots[0:i])\n \tfmt.Println(check.formatMsg(format, args))\n }\n@@ -76,15 +71,19 @@ func (check *checker) dump(format string, args ...interface{}) {\n \tfmt.Println(check.formatMsg(format, args))\n }\n \n-func (check *checker) errorf(pos token.Pos, format string, args ...interface{}) {\n-\tmsg := check.formatMsg(format, args)\n+func (check *checker) err(err error) {\n \tif check.firsterr == nil {\n-\t\tcheck.firsterr = fmt.Errorf(\"%s: %s\", check.fset.Position(pos), msg)\n+\t\tcheck.firsterr = err\n \t}\n-\tif check.errh == nil {\n+\tf := check.ctxt.Error\n+\tif f == nil {\n \t\tpanic(bailout{}) // report only first error\n \t}\n-\tcheck.errh(pos, msg)\n+\tf(err)\n+}\n+\n+func (check *checker) errorf(pos token.Pos, format string, args ...interface{}) {\n+\tcheck.err(fmt.Errorf(\"%s: %s\", check.fset.Position(pos), check.formatMsg(format, args)))\n }\n \n func (check *checker) invalidAST(pos token.Pos, format string, args ...interface{}) {\n@@ -193,7 +192,7 @@ func typeString(typ Type) string {\n \treturn buf.String()\n }\n \n-func writeParams(buf *bytes.Buffer, params ObjList, isVariadic bool) {\n+func writeParams(buf *bytes.Buffer, params []*Var, isVariadic bool) {\n \tbuf.WriteByte('(')\n \tfor i, par := range params {\n \t\tif i > 0 {\n@@ -206,7 +205,7 @@ func writeParams(buf *bytes.Buffer, params ObjList, isVariadic bool) {\n \t\tif isVariadic && i == len(params)-1 {\n \t\t\tbuf.WriteString(\"...\")\n \t\t}\n-\t\twriteType(buf, par.Type.(Type))\n+\t\twriteType(buf, par.Type)\n \t}\n \tbuf.WriteByte(')')\n }\n@@ -283,7 +282,7 @@ func writeType(buf *bytes.Buffer, typ Type) {\n \t\t\t\tbuf.WriteString(\"; \")\n \t\t\t}\n \t\t\tbuf.WriteString(m.Name)\n-\t\t\twriteSignature(buf, m.Type.(*Signature))\n+\t\t\twriteSignature(buf, m.Type)\n \t\t}\n \t\tbuf.WriteByte('}')\n \n@@ -307,9 +306,26 @@ func writeType(buf *bytes.Buffer, typ Type) {\n \t\twriteType(buf, t.Elt)\n \n \tcase *NamedType:\n-\t\tbuf.WriteString(t.Obj.Name)\n+\t\ts := \"<NamedType w/o object>\"\n+\t\tif t.Obj != nil {\n+\t\t\ts = t.Obj.GetName()\n+\t\t}\n+\t\tbuf.WriteString(s)\n \n \tdefault:\n \t\tfmt.Fprintf(buf, \"<type %T>\", t)\n \t}\n }\n+\n+func (t *Array) String() string     { return typeString(t) }\n+func (t *Basic) String() string     { return typeString(t) }\n+func (t *Chan) String() string      { return typeString(t) }\n+func (t *Interface) String() string { return typeString(t) }\n+func (t *Map) String() string       { return typeString(t) }\n+func (t *NamedType) String() string { return typeString(t) }\n+func (t *Pointer) String() string   { return typeString(t) }\n+func (t *Result) String() string    { return typeString(t) }\n+func (t *Signature) String() string { return typeString(t) }\n+func (t *Slice) String() string     { return typeString(t) }\n+func (t *Struct) String() string    { return typeString(t) }\n+func (t *builtin) String() string   { return typeString(t) }", "previous_filename": "libgo/go/exp/types/errors.go"}, {"sha": "1f6a3c72526989c16e460c19f2882b897549195f", "filename": "libgo/go/go/types/exportdata.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/exportdata.go"}, {"sha": "696a0cae684e6c70cb035a8b103dfa8f3a96724a", "filename": "libgo/go/go/types/expr.go", "status": "renamed", "additions": 149, "deletions": 113, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -17,20 +17,17 @@ import (\n // - simplify invalid handling: maybe just use Typ[Invalid] as marker, get rid of invalid Mode for values?\n // - rethink error handling: should all callers check if x.mode == valid after making a call?\n // - at the moment, iota is passed around almost everywhere - in many places we know it cannot be used\n+// - use \"\" or \"_\" consistently for anonymous identifiers? (e.g. reeceivers that have no name)\n \n // TODO(gri) API issues\n-// - clients need access to constant values\n-// - clients need access to built-in type information\n+// - clients need access to builtins type information\n+// - API tests are missing (e.g., identifiers should be handled as expressions in callbacks)\n \n-// TODO(gri) Bugs\n-// - expression hints are (correctly) used untyped for composite literal components, but also\n-//   in possibly overlapping use as hints for shift expressions - investigate\n-\n-func (check *checker) collectParams(list *ast.FieldList, variadicOk bool) (params ObjList, isVariadic bool) {\n+func (check *checker) collectParams(list *ast.FieldList, variadicOk bool) (params []*Var, isVariadic bool) {\n \tif list == nil {\n \t\treturn\n \t}\n-\tvar last *ast.Object\n+\tvar last *Var\n \tfor i, field := range list.List {\n \t\tftype := field.Type\n \t\tif t, _ := ftype.(*ast.Ellipsis); t != nil {\n@@ -48,33 +45,29 @@ func (check *checker) collectParams(list *ast.FieldList, variadicOk bool) (param\n \t\tif len(field.Names) > 0 {\n \t\t\t// named parameter\n \t\t\tfor _, name := range field.Names {\n-\t\t\t\tobj := name.Obj\n-\t\t\t\tobj.Type = typ\n-\t\t\t\tparams = append(params, obj)\n-\t\t\t\tlast = obj\n+\t\t\t\tpar := check.lookup(name).(*Var)\n+\t\t\t\tpar.Type = typ\n+\t\t\t\tlast = par\n+\t\t\t\tcopy := *par\n+\t\t\t\tparams = append(params, &copy)\n \t\t\t}\n \t\t} else {\n \t\t\t// anonymous parameter\n-\t\t\tobj := ast.NewObj(ast.Var, \"\")\n-\t\t\tobj.Type = typ\n-\t\t\tparams = append(params, obj)\n-\t\t\tlast = obj\n+\t\t\tpar := &Var{Type: typ}\n+\t\t\tlast = nil // not accessible inside function\n+\t\t\tparams = append(params, par)\n \t\t}\n \t}\n \t// For a variadic function, change the last parameter's object type\n \t// from T to []T (this is the type used inside the function), but\n-\t// keep a copy of the object with the original type T in the params\n-\t// list (this is the externally visible type).\n-\tif isVariadic {\n-\t\t// if isVariadic is set, last must exist and len(params) > 0\n-\t\tcopy := *last\n-\t\tlast.Type = &Slice{Elt: last.Type.(Type)}\n-\t\tparams[len(params)-1] = &copy\n+\t// keep the params list unchanged (this is the externally visible type).\n+\tif isVariadic && last != nil {\n+\t\tlast.Type = &Slice{Elt: last.Type}\n \t}\n \treturn\n }\n \n-func (check *checker) collectMethods(list *ast.FieldList) (methods ObjList) {\n+func (check *checker) collectMethods(list *ast.FieldList) (methods []*Method) {\n \tif list == nil {\n \t\treturn\n \t}\n@@ -85,14 +78,13 @@ func (check *checker) collectMethods(list *ast.FieldList) (methods ObjList) {\n \t\tif len(f.Names) > 0 {\n \t\t\t// methods (the parser ensures that there's only one\n \t\t\t// and we don't care if a constructed AST has more)\n-\t\t\tif _, ok := typ.(*Signature); !ok {\n+\t\t\tsig, ok := typ.(*Signature)\n+\t\t\tif !ok {\n \t\t\t\tcheck.invalidAST(f.Type.Pos(), \"%s is not a method signature\", typ)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tfor _, name := range f.Names {\n-\t\t\t\tobj := name.Obj\n-\t\t\t\tobj.Type = typ\n-\t\t\t\tmethods = append(methods, obj)\n+\t\t\t\tmethods = append(methods, &Method{QualifiedName{check.pkg, name.Name}, sig})\n \t\t\t}\n \t\t} else {\n \t\t\t// embedded interface\n@@ -105,14 +97,20 @@ func (check *checker) collectMethods(list *ast.FieldList) (methods ObjList) {\n \t\t\t}\n \t\t}\n \t}\n-\t// check for double declarations\n-\tmethods.Sort()\n-\tprev := \"\"\n-\tfor _, obj := range methods {\n-\t\tif obj.Name == prev {\n-\t\t\tcheck.errorf(list.Pos(), \"multiple methods named %s\", prev)\n+\t// Check for double declarations.\n+\t// The parser inserts methods into an interface-local scope, so local\n+\t// double declarations are reported by the parser already. We need to\n+\t// check again for conflicts due to embedded interfaces. This will lead\n+\t// to a 2nd error message if the double declaration was reported before\n+\t// by the parser.\n+\t// TODO(gri) clean this up a bit\n+\tseen := make(map[string]bool)\n+\tfor _, m := range methods {\n+\t\tif seen[m.Name] {\n+\t\t\tcheck.errorf(list.Pos(), \"multiple methods named %s\", m.Name)\n \t\t\treturn // keep multiple entries, lookup will only return the first entry\n \t\t}\n+\t\tseen[m.Name] = true\n \t}\n \treturn\n }\n@@ -129,7 +127,7 @@ func (check *checker) tag(t *ast.BasicLit) string {\n \treturn \"\"\n }\n \n-func (check *checker) collectFields(list *ast.FieldList, cycleOk bool) (fields []*StructField) {\n+func (check *checker) collectFields(list *ast.FieldList, cycleOk bool) (fields []*Field) {\n \tif list == nil {\n \t\treturn\n \t}\n@@ -139,15 +137,15 @@ func (check *checker) collectFields(list *ast.FieldList, cycleOk bool) (fields [\n \t\tif len(f.Names) > 0 {\n \t\t\t// named fields\n \t\t\tfor _, name := range f.Names {\n-\t\t\t\tfields = append(fields, &StructField{name.Name, typ, tag, false})\n+\t\t\t\tfields = append(fields, &Field{QualifiedName{check.pkg, name.Name}, typ, tag, false})\n \t\t\t}\n \t\t} else {\n \t\t\t// anonymous field\n \t\t\tswitch t := deref(typ).(type) {\n \t\t\tcase *Basic:\n-\t\t\t\tfields = append(fields, &StructField{t.Name, typ, tag, true})\n+\t\t\t\tfields = append(fields, &Field{QualifiedName{check.pkg, t.Name}, typ, tag, true})\n \t\t\tcase *NamedType:\n-\t\t\t\tfields = append(fields, &StructField{t.Obj.Name, typ, tag, true})\n+\t\t\t\tfields = append(fields, &Field{QualifiedName{check.pkg, t.Obj.GetName()}, typ, tag, true})\n \t\t\tdefault:\n \t\t\t\tif typ != Typ[Invalid] {\n \t\t\t\t\tcheck.invalidAST(f.Type.Pos(), \"anonymous field type %s must be named\", typ)\n@@ -183,7 +181,11 @@ func (check *checker) op(m opPredicates, x *operand, op token.Token) bool {\n func (check *checker) unary(x *operand, op token.Token) {\n \tswitch op {\n \tcase token.AND:\n-\t\t// TODO(gri) need to check for composite literals, somehow (they are not variables, in general)\n+\t\t// spec: \"As an exception to the addressability\n+\t\t// requirement x may also be a composite literal.\"\n+\t\tif _, ok := unparen(x.expr).(*ast.CompositeLit); ok {\n+\t\t\tx.mode = variable\n+\t\t}\n \t\tif x.mode != variable {\n \t\t\tcheck.invalidOp(x.pos(), \"cannot take address of %s\", x)\n \t\t\tgoto Error\n@@ -338,41 +340,45 @@ func (check *checker) comparison(x, y *operand, op token.Token) {\n }\n \n // untyped lhs shift operands convert to the hint type\n-// TODO(gri) shift hinting is not correct\n func (check *checker) shift(x, y *operand, op token.Token, hint Type) {\n-\t// The right operand in a shift expression must have unsigned integer type\n-\t// or be an untyped constant that can be converted to unsigned integer type.\n-\tif y.mode == constant && isUntyped(y.typ) {\n-\t\tif isRepresentableConst(y.val, UntypedInt) {\n-\t\t\ty.typ = Typ[UntypedInt]\n-\t\t}\n-\t}\n-\tif !isInteger(y.typ) || !isUnsigned(y.typ) && !isUntyped(y.typ) {\n+\t// spec: \"The right operand in a shift expression must have unsigned\n+\t// integer type or be an untyped constant that can be converted to\n+\t// unsigned integer type.\"\n+\tswitch {\n+\tcase isInteger(y.typ) && isUnsigned(y.typ):\n+\t\t// nothing to do\n+\tcase y.mode == constant && isUntyped(y.typ) && isRepresentableConst(y.val, UntypedInt):\n+\t\ty.typ = Typ[UntypedInt]\n+\tdefault:\n \t\tcheck.invalidOp(y.pos(), \"shift count %s must be unsigned integer\", y)\n \t\tx.mode = invalid\n \t\treturn\n \t}\n \n-\t// If the left operand of a non-constant shift expression is an untyped\n-\t// constant, the type of the constant is what it would be if the shift\n-\t// expression were replaced by its left operand alone; the type is int\n-\t// if it cannot be determined from the context (for instance, if the\n-\t// shift expression is an operand in a comparison against an untyped\n-\t// constant)\n+\t// spec: \"If the left operand of a non-constant shift expression is\n+\t// an untyped constant, the type of the constant is what it would be\n+\t// if the shift expression were replaced by its left operand alone;\n+\t// the type is int if it cannot be determined from the context (for\n+\t// instance, if the shift expression is an operand in a comparison\n+\t// against an untyped constant)\".\n \tif x.mode == constant && isUntyped(x.typ) {\n \t\tif y.mode == constant {\n \t\t\t// constant shift - accept values of any (untyped) type\n \t\t\t// as long as the value is representable as an integer\n-\t\t\tif isRepresentableConst(x.val, UntypedInt) {\n-\t\t\t\tx.typ = Typ[UntypedInt]\n+\t\t\tif x.mode == constant && isUntyped(x.typ) {\n+\t\t\t\tif isRepresentableConst(x.val, UntypedInt) {\n+\t\t\t\t\tx.typ = Typ[UntypedInt]\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\t// non-constant shift\n-\t\t\tif hint != nil {\n-\t\t\t\tcheck.convertUntyped(x, hint)\n-\t\t\t\tif x.mode == invalid {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\t\t\tif hint == nil {\n+\t\t\t\t// TODO(gri) need to check for x.isNil (see other uses of defaultType)\n+\t\t\t\thint = defaultType(x.typ)\n+\t\t\t}\n+\t\t\tcheck.convertUntyped(x, hint)\n+\t\t\tif x.mode == invalid {\n+\t\t\t\treturn\n \t\t\t}\n \t\t}\n \t}\n@@ -395,10 +401,10 @@ func (check *checker) shift(x, y *operand, op token.Token, hint Type) {\n \t\t\tx.val = shiftConst(x.val, uint(s), op)\n \t\t\treturn\n \t\t}\n-\t\tx.mode = value\n \t}\n \n-\t// x.mode, x.Typ are unchanged\n+\tx.mode = value\n+\t// x.typ is already set\n }\n \n var binaryOpPredicates = opPredicates{\n@@ -438,7 +444,7 @@ func (check *checker) binary(x, y *operand, op token.Token, hint Type) {\n \t\treturn\n \t}\n \n-\tif !isIdentical(x.typ, y.typ) {\n+\tif !IsIdentical(x.typ, y.typ) {\n \t\tcheck.invalidOp(x.pos(), \"mismatched types %s and %s\", x.typ, y.typ)\n \t\tx.mode = invalid\n \t\treturn\n@@ -500,8 +506,20 @@ func (check *checker) index(index ast.Expr, length int64, iota int) int64 {\n \treturn i\n }\n \n+// compositeLitKey resolves unresolved composite literal keys.\n+// For details, see comment in go/parser/parser.go, method parseElement.\n+func (check *checker) compositeLitKey(key ast.Expr) {\n+\tif ident, ok := key.(*ast.Ident); ok && ident.Obj == nil {\n+\t\tif obj := check.pkg.Scope.Lookup(ident.Name); obj != nil {\n+\t\t\tcheck.register(ident, obj)\n+\t\t} else {\n+\t\t\tcheck.errorf(ident.Pos(), \"undeclared name: %s\", ident.Name)\n+\t\t}\n+\t}\n+}\n+\n // indexElts checks the elements (elts) of an array or slice composite literal\n-// against the literals element type (typ), and the element indices against\n+// against the literal's element type (typ), and the element indices against\n // the literal length if known (length >= 0). It returns the length of the\n // literal (maximum index value + 1).\n //\n@@ -513,6 +531,7 @@ func (check *checker) indexedElts(elts []ast.Expr, typ Type, length int64, iota\n \t\tvalidIndex := false\n \t\teval := e\n \t\tif kv, _ := e.(*ast.KeyValueExpr); kv != nil {\n+\t\t\tcheck.compositeLitKey(kv.Key)\n \t\t\tif i := check.index(kv.Key, length, iota); i >= 0 {\n \t\t\t\tindex = i\n \t\t\t\tvalidIndex = true\n@@ -552,7 +571,7 @@ func (check *checker) indexedElts(elts []ast.Expr, typ Type, length int64, iota\n //\n func (check *checker) argument(sig *Signature, i int, arg ast.Expr, x *operand, passSlice bool) {\n \t// determine parameter\n-\tvar par *ast.Object\n+\tvar par *Var\n \tn := len(sig.Params)\n \tif i < n {\n \t\tpar = sig.Params[i]\n@@ -567,7 +586,7 @@ func (check *checker) argument(sig *Signature, i int, arg ast.Expr, x *operand,\n \tvar z operand\n \tz.mode = variable\n \tz.expr = nil // TODO(gri) can we do better here? (for good error messages)\n-\tz.typ = par.Type.(Type)\n+\tz.typ = par.Type\n \n \tif arg != nil {\n \t\tcheck.expr(x, arg, z.typ, -1)\n@@ -591,10 +610,23 @@ func (check *checker) argument(sig *Signature, i int, arg ast.Expr, x *operand,\n \tcheck.assignOperand(&z, x)\n }\n \n-func (check *checker) recordType(x *operand) {\n-\tif x.mode != invalid {\n-\t\tcheck.mapf(x.expr, x.typ)\n+var emptyResult Result\n+\n+func (check *checker) callExpr(x *operand) {\n+\tvar typ Type\n+\tvar val interface{}\n+\tswitch x.mode {\n+\tcase invalid:\n+\t\treturn // nothing to do\n+\tcase novalue:\n+\t\ttyp = &emptyResult\n+\tcase constant:\n+\t\ttyp = x.typ\n+\t\tval = x.val\n+\tdefault:\n+\t\ttyp = x.typ\n \t}\n+\tcheck.ctxt.Expr(x.expr, typ, val)\n }\n \n // rawExpr typechecks expression e and initializes x with the expression\n@@ -605,12 +637,16 @@ func (check *checker) recordType(x *operand) {\n //\n func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycleOk bool) {\n \tif trace {\n-\t\tcheck.trace(e.Pos(), \"expr(%s, iota = %d, cycleOk = %v)\", e, iota, cycleOk)\n+\t\tc := \"\"\n+\t\tif cycleOk {\n+\t\t\tc = \" \u2a01\"\n+\t\t}\n+\t\tcheck.trace(e.Pos(), \"%s (%s, %d%s)\", e, typeString(hint), iota, c)\n \t\tdefer check.untrace(\"=> %s\", x)\n \t}\n \n-\tif check.mapf != nil {\n-\t\tdefer check.recordType(x)\n+\tif check.ctxt.Expr != nil {\n+\t\tdefer check.callExpr(x)\n \t}\n \n \tswitch e := e.(type) {\n@@ -622,21 +658,17 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\tcheck.invalidOp(e.Pos(), \"cannot use _ as value or type\")\n \t\t\tgoto Error\n \t\t}\n-\t\tobj := e.Obj\n+\t\tobj := check.lookup(e)\n \t\tif obj == nil {\n \t\t\tgoto Error // error was reported before\n \t\t}\n-\t\tif obj.Type == nil {\n-\t\t\tcheck.object(obj, cycleOk)\n-\t\t}\n-\t\tswitch obj.Kind {\n-\t\tcase ast.Bad:\n-\t\t\tgoto Error // error was reported before\n-\t\tcase ast.Pkg:\n+\t\tcheck.object(obj, cycleOk)\n+\t\tswitch obj := obj.(type) {\n+\t\tcase *Package:\n \t\t\tcheck.errorf(e.Pos(), \"use of package %s not in selector\", obj.Name)\n \t\t\tgoto Error\n-\t\tcase ast.Con:\n-\t\t\tif obj.Data == nil {\n+\t\tcase *Const:\n+\t\t\tif obj.Val == nil {\n \t\t\t\tgoto Error // cycle detected\n \t\t\t}\n \t\t\tx.mode = constant\n@@ -647,24 +679,24 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\t}\n \t\t\t\tx.val = int64(iota)\n \t\t\t} else {\n-\t\t\t\tx.val = obj.Data\n+\t\t\t\tx.val = obj.Val\n \t\t\t}\n-\t\tcase ast.Typ:\n+\t\tcase *TypeName:\n \t\t\tx.mode = typexpr\n-\t\t\tif !cycleOk && underlying(obj.Type.(Type)) == nil {\n-\t\t\t\tcheck.errorf(obj.Pos(), \"illegal cycle in declaration of %s\", obj.Name)\n+\t\t\tif !cycleOk && underlying(obj.Type) == nil {\n+\t\t\t\tcheck.errorf(obj.spec.Pos(), \"illegal cycle in declaration of %s\", obj.Name)\n \t\t\t\tx.expr = e\n \t\t\t\tx.typ = Typ[Invalid]\n \t\t\t\treturn // don't goto Error - need x.mode == typexpr\n \t\t\t}\n-\t\tcase ast.Var:\n+\t\tcase *Var:\n \t\t\tx.mode = variable\n-\t\tcase ast.Fun:\n+\t\tcase *Func:\n \t\t\tx.mode = value\n \t\tdefault:\n \t\t\tunreachable()\n \t\t}\n-\t\tx.typ = obj.Type.(Type)\n+\t\tx.typ = obj.GetType()\n \n \tcase *ast.Ellipsis:\n \t\t// ellipses are handled explicitly where they are legal\n@@ -680,10 +712,10 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t}\n \n \tcase *ast.FuncLit:\n-\t\tif typ, ok := check.typ(e.Type, false).(*Signature); ok {\n+\t\tif sig, ok := check.typ(e.Type, false).(*Signature); ok {\n \t\t\tx.mode = value\n-\t\t\tx.typ = typ\n-\t\t\tcheck.function(typ, e.Body)\n+\t\t\tx.typ = sig\n+\t\t\tcheck.later(nil, sig, e.Body)\n \t\t} else {\n \t\t\tcheck.invalidAST(e.Pos(), \"invalid function literal %s\", e)\n \t\t\tgoto Error\n@@ -767,7 +799,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\t\t// i < len(fields)\n \t\t\t\t\tetyp := fields[i].Type\n \t\t\t\t\tif !x.isAssignable(etyp) {\n-\t\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as an element of type %s in struct literal\", x, etyp)\n+\t\t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s value in struct literal\", x, etyp)\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -795,6 +827,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\t\tcheck.errorf(e.Pos(), \"missing key in map literal\")\n \t\t\t\t\tcontinue\n \t\t\t\t}\n+\t\t\t\tcheck.compositeLitKey(kv.Key)\n \t\t\t\tcheck.expr(x, kv.Key, nil, iota)\n \t\t\t\tif !x.isAssignable(utyp.Key) {\n \t\t\t\t\tcheck.errorf(x.pos(), \"cannot use %s as %s key in map literal\", x, utyp.Key)\n@@ -819,7 +852,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\tgoto Error\n \t\t}\n \n-\t\tx.mode = variable // TODO(gri) mode is really a value - keep for now to get going\n+\t\tx.mode = value\n \t\tx.typ = typ\n \n \tcase *ast.ParenExpr:\n@@ -832,30 +865,35 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t// can only appear in qualified identifiers which are mapped to\n \t\t// selector expressions.\n \t\tif ident, ok := e.X.(*ast.Ident); ok {\n-\t\t\tif obj := ident.Obj; obj != nil && obj.Kind == ast.Pkg {\n-\t\t\t\texp := obj.Data.(*ast.Scope).Lookup(sel)\n+\t\t\tif pkg, ok := check.lookup(ident).(*Package); ok {\n+\t\t\t\texp := pkg.Scope.Lookup(sel)\n \t\t\t\tif exp == nil {\n \t\t\t\t\tcheck.errorf(e.Sel.Pos(), \"cannot refer to unexported %s\", sel)\n \t\t\t\t\tgoto Error\n \t\t\t\t}\n-\t\t\t\t// simplified version of the code for *ast.Idents:\n-\t\t\t\t// imported objects are always fully initialized\n-\t\t\t\tswitch exp.Kind {\n-\t\t\t\tcase ast.Con:\n-\t\t\t\t\tassert(exp.Data != nil)\n+\t\t\t\tcheck.register(e.Sel, exp)\n+\t\t\t\t// Simplified version of the code for *ast.Idents:\n+\t\t\t\t// - imported packages use types.Scope and types.Objects\n+\t\t\t\t// - imported objects are always fully initialized\n+\t\t\t\tswitch exp := exp.(type) {\n+\t\t\t\tcase *Const:\n+\t\t\t\t\tassert(exp.Val != nil)\n \t\t\t\t\tx.mode = constant\n-\t\t\t\t\tx.val = exp.Data\n-\t\t\t\tcase ast.Typ:\n+\t\t\t\t\tx.typ = exp.Type\n+\t\t\t\t\tx.val = exp.Val\n+\t\t\t\tcase *TypeName:\n \t\t\t\t\tx.mode = typexpr\n-\t\t\t\tcase ast.Var:\n+\t\t\t\t\tx.typ = exp.Type\n+\t\t\t\tcase *Var:\n \t\t\t\t\tx.mode = variable\n-\t\t\t\tcase ast.Fun:\n+\t\t\t\t\tx.typ = exp.Type\n+\t\t\t\tcase *Func:\n \t\t\t\t\tx.mode = value\n+\t\t\t\t\tx.typ = exp.Type\n \t\t\t\tdefault:\n \t\t\t\t\tunreachable()\n \t\t\t\t}\n \t\t\t\tx.expr = e\n-\t\t\t\tx.typ = exp.Type.(Type)\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n@@ -864,7 +902,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\tif x.mode == invalid {\n \t\t\tgoto Error\n \t\t}\n-\t\tmode, typ := lookupField(x.typ, sel)\n+\t\tmode, typ := lookupField(x.typ, QualifiedName{check.pkg, sel})\n \t\tif mode == invalid {\n \t\t\tcheck.invalidOp(e.Pos(), \"%s has no single field or method %s\", x, sel)\n \t\t\tgoto Error\n@@ -880,11 +918,9 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t// argument of the method expression's function type\n \t\t\t// TODO(gri) at the moment, method sets don't correctly track\n \t\t\t// pointer vs non-pointer receivers => typechecker is too lenient\n-\t\t\targ := ast.NewObj(ast.Var, \"\")\n-\t\t\targ.Type = x.typ\n \t\t\tx.mode = value\n \t\t\tx.typ = &Signature{\n-\t\t\t\tParams:     append(ObjList{arg}, sig.Params...),\n+\t\t\t\tParams:     append([]*Var{{Type: x.typ}}, sig.Params...),\n \t\t\t\tResults:    sig.Results,\n \t\t\t\tIsVariadic: sig.IsVariadic,\n \t\t\t}\n@@ -1101,7 +1137,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\t\tfor i, obj := range t.Values {\n \t\t\t\t\t\tx.mode = value\n \t\t\t\t\t\tx.expr = nil // TODO(gri) can we do better here? (for good error messages)\n-\t\t\t\t\t\tx.typ = obj.Type.(Type)\n+\t\t\t\t\t\tx.typ = obj.Type\n \t\t\t\t\t\tcheck.argument(sig, i, nil, x, passSlice && i+1 == n)\n \t\t\t\t\t}\n \t\t\t\t} else {\n@@ -1135,7 +1171,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\t\tx.mode = novalue\n \t\t\tcase 1:\n \t\t\t\tx.mode = value\n-\t\t\t\tx.typ = sig.Results[0].Type.(Type)\n+\t\t\t\tx.typ = sig.Results[0].Type\n \t\t\tdefault:\n \t\t\t\tx.mode = value\n \t\t\t\tx.typ = &Result{Values: sig.Results}", "previous_filename": "libgo/go/exp/types/expr.go"}, {"sha": "edd3e4dec7d595440e0bc5548bb1bddbe17a1594", "filename": "libgo/go/go/types/gcimporter.go", "status": "renamed", "additions": 118, "deletions": 114, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -2,8 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements an ast.Importer for gc-generated object files.\n-// TODO(gri) Eventually move this into a separate package outside types.\n+// This file implements an Importer for gc-generated object files.\n \n package types\n \n@@ -78,12 +77,15 @@ func FindPkg(path, srcDir string) (filename, id string) {\n // adds the corresponding package object to the imports map indexed by id,\n // and returns the object.\n //\n-// The imports map must contains all packages already imported, and no map\n-// entry with id as the key must be present. The data reader position must\n-// be the beginning of the export data section. The filename is only used\n-// in error messages.\n+// The imports map must contains all packages already imported. The data\n+// reader position must be the beginning of the export data section. The\n+// filename is only used in error messages.\n //\n-func GcImportData(imports map[string]*ast.Object, filename, id string, data *bufio.Reader) (pkg *ast.Object, err error) {\n+// If imports[id] contains the completely imported package, that package\n+// can be used directly, and there is no need to call this function (but\n+// there is also no harm but for extra time used).\n+//\n+func GcImportData(imports map[string]*Package, filename, id string, data *bufio.Reader) (pkg *Package, err error) {\n \t// support for gcParser error handling\n \tdefer func() {\n \t\tif r := recover(); r != nil {\n@@ -104,7 +106,7 @@ func GcImportData(imports map[string]*ast.Object, filename, id string, data *buf\n // The imports map must contains all packages already imported.\n // GcImport satisfies the ast.Importer signature.\n //\n-func GcImport(imports map[string]*ast.Object, path string) (pkg *ast.Object, err error) {\n+func GcImport(imports map[string]*Package, path string) (pkg *Package, err error) {\n \tif path == \"unsafe\" {\n \t\treturn Unsafe, nil\n \t}\n@@ -119,12 +121,10 @@ func GcImport(imports map[string]*ast.Object, path string) (pkg *ast.Object, err\n \t\treturn\n \t}\n \n-\t// Note: imports[id] may already contain a partially imported package.\n-\t//       We must continue doing the full import here since we don't\n-\t//       know if something is missing.\n-\t// TODO: There's no need to re-import a package if we know that we\n-\t//       have done a full import before. At the moment we cannot\n-\t//       tell from the available information in this function alone.\n+\t// no need to re-import if the package was imported completely before\n+\tif pkg = imports[id]; pkg != nil && pkg.Complete {\n+\t\treturn\n+\t}\n \n \t// open file\n \tf, err := os.Open(filename)\n@@ -156,13 +156,13 @@ func GcImport(imports map[string]*ast.Object, path string) (pkg *ast.Object, err\n // object/archive file and populates its scope with the results.\n type gcParser struct {\n \tscanner scanner.Scanner\n-\ttok     rune                   // current token\n-\tlit     string                 // literal string; only valid for Ident, Int, String tokens\n-\tid      string                 // package id of imported package\n-\timports map[string]*ast.Object // package id -> package object\n+\ttok     rune                // current token\n+\tlit     string              // literal string; only valid for Ident, Int, String tokens\n+\tid      string              // package id of imported package\n+\timports map[string]*Package // package id -> package object\n }\n \n-func (p *gcParser) init(filename, id string, src io.Reader, imports map[string]*ast.Object) {\n+func (p *gcParser) init(filename, id string, src io.Reader, imports map[string]*Package) {\n \tp.scanner.Init(src)\n \tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }\n \tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanChars | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n@@ -187,27 +187,45 @@ func (p *gcParser) next() {\n \t}\n }\n \n-// Declare inserts a named object of the given kind in scope.\n-func (p *gcParser) declare(scope *ast.Scope, kind ast.ObjKind, name string) *ast.Object {\n-\t// the object may have been imported before - if it exists\n-\t// already in the respective package scope, return that object\n+func declConst(scope *Scope, name string) *Const {\n+\t// the constant may have been imported before - if it exists\n+\t// already in the respective scope, return that constant\n \tif obj := scope.Lookup(name); obj != nil {\n-\t\tassert(obj.Kind == kind)\n-\t\treturn obj\n+\t\treturn obj.(*Const)\n \t}\n+\t// otherwise create a new constant and insert it into the scope\n+\tobj := &Const{Name: name}\n+\tscope.Insert(obj)\n+\treturn obj\n+}\n \n-\t// otherwise create a new object and insert it into the package scope\n-\tobj := ast.NewObj(kind, name)\n-\tif scope.Insert(obj) != nil {\n-\t\tunreachable() // Lookup should have found it\n+func declTypeName(scope *Scope, name string) *TypeName {\n+\tif obj := scope.Lookup(name); obj != nil {\n+\t\treturn obj.(*TypeName)\n \t}\n+\tobj := &TypeName{Name: name}\n+\t// a named type may be referred to before the underlying type\n+\t// is known - set it up\n+\tobj.Type = &NamedType{Obj: obj}\n+\tscope.Insert(obj)\n+\treturn obj\n+}\n \n-\t// if the new type object is a named type it may be referred\n-\t// to before the underlying type is known - set it up\n-\tif kind == ast.Typ {\n-\t\tobj.Type = &NamedType{Obj: obj}\n+func declVar(scope *Scope, name string) *Var {\n+\tif obj := scope.Lookup(name); obj != nil {\n+\t\treturn obj.(*Var)\n \t}\n+\tobj := &Var{Name: name}\n+\tscope.Insert(obj)\n+\treturn obj\n+}\n \n+func declFunc(scope *Scope, name string) *Func {\n+\tif obj := scope.Lookup(name); obj != nil {\n+\t\treturn obj.(*Func)\n+\t}\n+\tobj := &Func{Name: name}\n+\tscope.Insert(obj)\n \treturn obj\n }\n \n@@ -270,7 +288,7 @@ func (p *gcParser) expectKeyword(keyword string) {\n \n // ImportPath = string_lit .\n //\n-func (p *gcParser) parsePkgId() *ast.Object {\n+func (p *gcParser) parsePkgId() *Package {\n \tid, err := strconv.Unquote(p.expect(scanner.String))\n \tif err != nil {\n \t\tp.error(err)\n@@ -288,8 +306,7 @@ func (p *gcParser) parsePkgId() *ast.Object {\n \n \tpkg := p.imports[id]\n \tif pkg == nil {\n-\t\tpkg = ast.NewObj(ast.Pkg, \"\")\n-\t\tpkg.Data = ast.NewScope(nil)\n+\t\tpkg = &Package{Scope: new(Scope)}\n \t\tp.imports[id] = pkg\n \t}\n \n@@ -315,7 +332,7 @@ func (p *gcParser) parseDotIdent() string {\n \n // ExportedName = \"@\" ImportPath \".\" dotIdentifier .\n //\n-func (p *gcParser) parseExportedName() (*ast.Object, string) {\n+func (p *gcParser) parseExportedName() (*Package, string) {\n \tp.expect('@')\n \tpkg := p.parsePkgId()\n \tp.expect('.')\n@@ -331,10 +348,11 @@ func (p *gcParser) parseExportedName() (*ast.Object, string) {\n func (p *gcParser) parseBasicType() Type {\n \tid := p.expect(scanner.Ident)\n \tobj := Universe.Lookup(id)\n-\tif obj == nil || obj.Kind != ast.Typ {\n-\t\tp.errorf(\"not a basic type: %s\", id)\n+\tif obj, ok := obj.(*TypeName); ok {\n+\t\treturn obj.Type\n \t}\n-\treturn obj.Type.(Type)\n+\tp.errorf(\"not a basic type: %s\", id)\n+\treturn nil\n }\n \n // ArrayType = \"[\" int_lit \"]\" Type .\n@@ -364,7 +382,7 @@ func (p *gcParser) parseMapType() Type {\n \n // Name = identifier | \"?\" | ExportedName  .\n //\n-func (p *gcParser) parseName() (name string) {\n+func (p *gcParser) parseName() (pkg *Package, name string) {\n \tswitch p.tok {\n \tcase scanner.Ident:\n \t\tname = p.lit\n@@ -374,7 +392,7 @@ func (p *gcParser) parseName() (name string) {\n \t\tp.next()\n \tcase '@':\n \t\t// exported name prefixed with package path\n-\t\t_, name = p.parseExportedName()\n+\t\tpkg, name = p.parseExportedName()\n \tdefault:\n \t\tp.error(\"name expected\")\n \t}\n@@ -383,17 +401,17 @@ func (p *gcParser) parseName() (name string) {\n \n // Field = Name Type [ string_lit ] .\n //\n-func (p *gcParser) parseField() *StructField {\n-\tvar f StructField\n-\tf.Name = p.parseName()\n+func (p *gcParser) parseField() *Field {\n+\tvar f Field\n+\tf.Pkg, f.Name = p.parseName()\n \tf.Type = p.parseType()\n \tif p.tok == scanner.String {\n \t\tf.Tag = p.expect(scanner.String)\n \t}\n \tif f.Name == \"\" {\n \t\t// anonymous field - typ must be T or *T and T must be a type name\n \t\tif typ, ok := deref(f.Type).(*NamedType); ok && typ.Obj != nil {\n-\t\t\tf.Name = typ.Obj.Name\n+\t\t\tf.Name = typ.Obj.GetName()\n \t\t\tf.IsAnonymous = true\n \t\t} else {\n \t\t\tp.errorf(\"anonymous field expected\")\n@@ -406,20 +424,15 @@ func (p *gcParser) parseField() *StructField {\n // FieldList  = Field { \";\" Field } .\n //\n func (p *gcParser) parseStructType() Type {\n-\tvar fields []*StructField\n-\n-\tparseField := func() {\n-\t\tfields = append(fields, p.parseField())\n-\t}\n+\tvar fields []*Field\n \n \tp.expectKeyword(\"struct\")\n \tp.expect('{')\n-\tif p.tok != '}' {\n-\t\tparseField()\n-\t\tfor p.tok == ';' {\n-\t\t\tp.next()\n-\t\t\tparseField()\n+\tfor p.tok != '}' {\n+\t\tif len(fields) > 0 {\n+\t\t\tp.expect(';')\n \t\t}\n+\t\tfields = append(fields, p.parseField())\n \t}\n \tp.expect('}')\n \n@@ -428,30 +441,33 @@ func (p *gcParser) parseStructType() Type {\n \n // Parameter = ( identifier | \"?\" ) [ \"...\" ] Type [ string_lit ] .\n //\n-func (p *gcParser) parseParameter() (par *ast.Object, isVariadic bool) {\n-\tname := p.parseName()\n+func (p *gcParser) parseParameter() (par *Var, isVariadic bool) {\n+\t_, name := p.parseName()\n \tif name == \"\" {\n \t\tname = \"_\" // cannot access unnamed identifiers\n \t}\n \tif p.tok == '.' {\n \t\tp.expectSpecial(\"...\")\n \t\tisVariadic = true\n \t}\n-\tptyp := p.parseType()\n+\ttyp := p.parseType()\n \t// ignore argument tag (e.g. \"noescape\")\n \tif p.tok == scanner.String {\n \t\tp.next()\n \t}\n-\tpar = ast.NewObj(ast.Var, name)\n-\tpar.Type = ptyp\n+\tpar = &Var{Name: name, Type: typ}\n \treturn\n }\n \n // Parameters    = \"(\" [ ParameterList ] \")\" .\n // ParameterList = { Parameter \",\" } Parameter .\n //\n-func (p *gcParser) parseParameters() (list []*ast.Object, isVariadic bool) {\n-\tparseParameter := func() {\n+func (p *gcParser) parseParameters() (list []*Var, isVariadic bool) {\n+\tp.expect('(')\n+\tfor p.tok != ')' {\n+\t\tif len(list) > 0 {\n+\t\t\tp.expect(',')\n+\t\t}\n \t\tpar, variadic := p.parseParameter()\n \t\tlist = append(list, par)\n \t\tif variadic {\n@@ -461,15 +477,6 @@ func (p *gcParser) parseParameters() (list []*ast.Object, isVariadic bool) {\n \t\t\tisVariadic = true\n \t\t}\n \t}\n-\n-\tp.expect('(')\n-\tif p.tok != ')' {\n-\t\tparseParameter()\n-\t\tfor p.tok == ',' {\n-\t\t\tp.next()\n-\t\t\tparseParameter()\n-\t\t}\n-\t}\n \tp.expect(')')\n \n \treturn\n@@ -482,13 +489,11 @@ func (p *gcParser) parseSignature() *Signature {\n \tparams, isVariadic := p.parseParameters()\n \n \t// optional result type\n-\tvar results []*ast.Object\n+\tvar results []*Var\n \tswitch p.tok {\n \tcase scanner.Ident, '[', '*', '<', '@':\n \t\t// single, unnamed result\n-\t\tresult := ast.NewObj(ast.Var, \"_\")\n-\t\tresult.Type = p.parseType()\n-\t\tresults = []*ast.Object{result}\n+\t\tresults = []*Var{{Type: p.parseType()}}\n \tcase '(':\n \t\t// named or multiple result(s)\n \t\tvar variadic bool\n@@ -510,26 +515,20 @@ func (p *gcParser) parseSignature() *Signature {\n // visible in the export data.\n //\n func (p *gcParser) parseInterfaceType() Type {\n-\tvar methods ObjList\n-\n-\tparseMethod := func() {\n-\t\tobj := ast.NewObj(ast.Fun, p.parseName())\n-\t\tobj.Type = p.parseSignature()\n-\t\tmethods = append(methods, obj)\n-\t}\n+\tvar methods []*Method\n \n \tp.expectKeyword(\"interface\")\n \tp.expect('{')\n-\tif p.tok != '}' {\n-\t\tparseMethod()\n-\t\tfor p.tok == ';' {\n-\t\t\tp.next()\n-\t\t\tparseMethod()\n+\tfor p.tok != '}' {\n+\t\tif len(methods) > 0 {\n+\t\t\tp.expect(';')\n \t\t}\n+\t\tpkg, name := p.parseName()\n+\t\ttyp := p.parseSignature()\n+\t\tmethods = append(methods, &Method{QualifiedName{pkg, name}, typ})\n \t}\n \tp.expect('}')\n \n-\tmethods.Sort()\n \treturn &Interface{Methods: methods}\n }\n \n@@ -585,7 +584,7 @@ func (p *gcParser) parseType() Type {\n \tcase '@':\n \t\t// TypeName\n \t\tpkg, name := p.parseExportedName()\n-\t\treturn p.declare(pkg.Data.(*ast.Scope), ast.Typ, name).Type.(Type)\n+\t\treturn declTypeName(pkg.Scope, name).Type\n \tcase '[':\n \t\tp.next() // look ahead\n \t\tif p.tok == ']' {\n@@ -693,7 +692,7 @@ func (p *gcParser) parseNumber() (x operand) {\n func (p *gcParser) parseConstDecl() {\n \tp.expectKeyword(\"const\")\n \tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Con, name)\n+\tobj := declConst(pkg.Scope, name)\n \tvar x operand\n \tif p.tok != '=' {\n \t\tobj.Type = p.parseType()\n@@ -751,15 +750,15 @@ func (p *gcParser) parseConstDecl() {\n \t\tobj.Type = x.typ\n \t}\n \tassert(x.val != nil)\n-\tobj.Data = x.val\n+\tobj.Val = x.val\n }\n \n // TypeDecl = \"type\" ExportedName Type .\n //\n func (p *gcParser) parseTypeDecl() {\n \tp.expectKeyword(\"type\")\n \tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Typ, name)\n+\tobj := declTypeName(pkg.Scope, name)\n \n \t// The type object may have been imported before and thus already\n \t// have a type associated with it. We still need to parse the type\n@@ -778,16 +777,15 @@ func (p *gcParser) parseTypeDecl() {\n func (p *gcParser) parseVarDecl() {\n \tp.expectKeyword(\"var\")\n \tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Var, name)\n+\tobj := declVar(pkg.Scope, name)\n \tobj.Type = p.parseType()\n }\n \n // Func = Signature [ Body ] .\n // Body = \"{\" ... \"}\" .\n //\n-func (p *gcParser) parseFunc(scope *ast.Scope, name string) {\n-\tobj := p.declare(scope, ast.Fun, name)\n-\tobj.Type = p.parseSignature()\n+func (p *gcParser) parseFunc() *Signature {\n+\tsig := p.parseSignature()\n \tif p.tok == '{' {\n \t\tp.next()\n \t\tfor i := 1; i > 0; p.next() {\n@@ -799,6 +797,7 @@ func (p *gcParser) parseFunc(scope *ast.Scope, name string) {\n \t\t\t}\n \t\t}\n \t}\n+\treturn sig\n }\n \n // MethodDecl = \"func\" Receiver Name Func .\n@@ -811,32 +810,35 @@ func (p *gcParser) parseMethodDecl() {\n \tp.expect(')')\n \n \t// determine receiver base type object\n-\ttyp := recv.Type.(Type)\n+\ttyp := recv.Type\n \tif ptr, ok := typ.(*Pointer); ok {\n \t\ttyp = ptr.Base\n \t}\n-\tobj := typ.(*NamedType).Obj\n+\tbase := typ.(*NamedType)\n \n-\t// determine base type scope\n-\tvar scope *ast.Scope\n-\tif obj.Data != nil {\n-\t\tscope = obj.Data.(*ast.Scope)\n-\t} else {\n-\t\tscope = ast.NewScope(nil)\n-\t\tobj.Data = scope\n-\t}\n+\t// parse method name, signature, and possibly inlined body\n+\tpkg, name := p.parseName() // unexported method names in imports are qualified with their package.\n+\tsig := p.parseFunc()\n+\tsig.Recv = recv\n \n-\t// declare method in base type scope\n-\tname := p.parseName() // unexported method names in imports are qualified with their package.\n-\tp.parseFunc(scope, name)\n+\t// add method to type unless type was imported before\n+\t// and method exists already\n+\t// TODO(gri) investigate if this can be avoided\n+\tfor _, m := range base.Methods {\n+\t\tif m.Name == name {\n+\t\t\treturn // method was added before\n+\t\t}\n+\t}\n+\tbase.Methods = append(base.Methods, &Method{QualifiedName{pkg, name}, sig})\n }\n \n // FuncDecl = \"func\" ExportedName Func .\n //\n func (p *gcParser) parseFuncDecl() {\n \t// \"func\" already consumed\n \tpkg, name := p.parseExportedName()\n-\tp.parseFunc(pkg.Data.(*ast.Scope), name)\n+\ttyp := p.parseFunc()\n+\tdeclFunc(pkg.Scope, name).Type = typ\n }\n \n // Decl = [ ImportDecl | ConstDecl | TypeDecl | VarDecl | FuncDecl | MethodDecl ] \"\\n\" .\n@@ -868,7 +870,7 @@ func (p *gcParser) parseDecl() {\n // Export        = \"PackageClause { Decl } \"$$\" .\n // PackageClause = \"package\" identifier [ \"safe\" ] \"\\n\" .\n //\n-func (p *gcParser) parseExport() *ast.Object {\n+func (p *gcParser) parseExport() *Package {\n \tp.expectKeyword(\"package\")\n \tname := p.expect(scanner.Ident)\n \tif p.tok != '\\n' {\n@@ -881,8 +883,7 @@ func (p *gcParser) parseExport() *ast.Object {\n \n \tpkg := p.imports[p.id]\n \tif pkg == nil {\n-\t\tpkg = ast.NewObj(ast.Pkg, name)\n-\t\tpkg.Data = ast.NewScope(nil)\n+\t\tpkg = &Package{Name: name, Scope: new(Scope)}\n \t\tp.imports[p.id] = pkg\n \t}\n \n@@ -900,5 +901,8 @@ func (p *gcParser) parseExport() *ast.Object {\n \t\tp.errorf(\"expected no scanner errors, got %d\", n)\n \t}\n \n+\t// package was imported completely and without errors\n+\tpkg.Complete = true\n+\n \treturn pkg\n }", "previous_filename": "libgo/go/exp/types/gcimporter.go"}, {"sha": "b793eb4cb33ae09a752041cbbf96d020a8dd425d", "filename": "libgo/go/go/types/gcimporter_test.go", "status": "renamed", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -51,24 +51,26 @@ func compile(t *testing.T, dirname, filename string) string {\n \n // Use the same global imports map for all tests. The effect is\n // as if all tested packages were imported into a single package.\n-var imports = make(map[string]*ast.Object)\n+var imports = make(map[string]*Package)\n \n func testPath(t *testing.T, path string) bool {\n+\tt0 := time.Now()\n \t_, err := GcImport(imports, path)\n \tif err != nil {\n \t\tt.Errorf(\"testPath(%s): %s\", path, err)\n \t\treturn false\n \t}\n+\tt.Logf(\"testPath(%s): %v\", path, time.Since(t0))\n \treturn true\n }\n \n-const maxTime = 3 * time.Second\n+const maxTime = 30 * time.Second\n \n func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {\n \tdirname := filepath.Join(runtime.GOROOT(), \"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH, dir)\n \tlist, err := ioutil.ReadDir(dirname)\n \tif err != nil {\n-\t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n+\t\tt.Fatalf(\"testDir(%s): %s\", dirname, err)\n \t}\n \tfor _, f := range list {\n \t\tif time.Now().After(endTime) {\n@@ -97,8 +99,7 @@ func TestGcImport(t *testing.T) {\n \t// On cross-compile builds, the path will not exist.\n \t// Need to use GOHOSTOS, which is not available.\n \tif _, err := os.Stat(gcPath); err != nil {\n-\t\tt.Logf(\"skipping test: %v\", err)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test: %v\", err)\n \t}\n \n \tif outFn := compile(t, \"testdata\", \"exports.go\"); outFn != \"\" {\n@@ -145,12 +146,34 @@ func TestGcImportedTypes(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tobj := pkg.Data.(*ast.Scope).Lookup(objName)\n-\t\tif obj.Kind != test.kind {\n-\t\t\tt.Errorf(\"%s: got kind = %q; want %q\", test.name, obj.Kind, test.kind)\n+\t\tobj := pkg.Scope.Lookup(objName)\n+\n+\t\t// TODO(gri) should define an accessor on Object\n+\t\tvar kind ast.ObjKind\n+\t\tvar typ Type\n+\t\tswitch obj := obj.(type) {\n+\t\tcase *Const:\n+\t\t\tkind = ast.Con\n+\t\t\ttyp = obj.Type\n+\t\tcase *TypeName:\n+\t\t\tkind = ast.Typ\n+\t\t\ttyp = obj.Type\n+\t\tcase *Var:\n+\t\t\tkind = ast.Var\n+\t\t\ttyp = obj.Type\n+\t\tcase *Func:\n+\t\t\tkind = ast.Fun\n+\t\t\ttyp = obj.Type\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\n+\t\tif kind != test.kind {\n+\t\t\tt.Errorf(\"%s: got kind = %q; want %q\", test.name, kind, test.kind)\n \t\t}\n-\t\ttyp := typeString(underlying(obj.Type.(Type)))\n-\t\tif typ != test.typ {\n+\n+\t\tstr := typeString(underlying(typ))\n+\t\tif str != test.typ {\n \t\t\tt.Errorf(\"%s: got type = %q; want %q\", test.name, typ, test.typ)\n \t\t}\n \t}", "previous_filename": "libgo/go/exp/types/gcimporter_test.go"}, {"sha": "dcd905b4138d65f807ba327e01c4095c2c474bce", "filename": "libgo/go/go/types/objects.go", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fobjects.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fobjects.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fobjects.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package types\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+)\n+\n+// An Object describes a named language entity such as a package,\n+// constant, type, variable, function (incl. methods), or label.\n+// All objects implement the Object interface.\n+//\n+type Object interface {\n+\tGetName() string\n+\tGetType() Type\n+\tGetPos() token.Pos\n+\n+\tanObject()\n+}\n+\n+// A Package represents the contents (objects) of a Go package.\n+type Package struct {\n+\tName     string\n+\tPath     string              // import path, \"\" for current (non-imported) package\n+\tScope    *Scope              // package-level scope\n+\tImports  map[string]*Package // map of import paths to imported packages\n+\tComplete bool                // if set, this package was imported completely\n+\n+\tspec *ast.ImportSpec\n+}\n+\n+// A Const represents a declared constant.\n+type Const struct {\n+\tName string\n+\tType Type\n+\tVal  interface{}\n+\n+\tspec *ast.ValueSpec\n+}\n+\n+// A TypeName represents a declared type.\n+type TypeName struct {\n+\tName string\n+\tType Type // *NamedType or *Basic\n+\n+\tspec *ast.TypeSpec\n+}\n+\n+// A Variable represents a declared variable (including function parameters and results).\n+type Var struct {\n+\tName string\n+\tType Type\n+\n+\tvisited bool // for initialization cycle detection\n+\tdecl    interface{}\n+}\n+\n+// A Func represents a declared function.\n+type Func struct {\n+\tName string\n+\tType Type // *Signature or *Builtin\n+\n+\tdecl *ast.FuncDecl\n+}\n+\n+func (obj *Package) GetName() string  { return obj.Name }\n+func (obj *Const) GetName() string    { return obj.Name }\n+func (obj *TypeName) GetName() string { return obj.Name }\n+func (obj *Var) GetName() string      { return obj.Name }\n+func (obj *Func) GetName() string     { return obj.Name }\n+\n+func (obj *Package) GetType() Type  { return Typ[Invalid] }\n+func (obj *Const) GetType() Type    { return obj.Type }\n+func (obj *TypeName) GetType() Type { return obj.Type }\n+func (obj *Var) GetType() Type      { return obj.Type }\n+func (obj *Func) GetType() Type     { return obj.Type }\n+\n+func (obj *Package) GetPos() token.Pos { return obj.spec.Pos() }\n+func (obj *Const) GetPos() token.Pos {\n+\tfor _, n := range obj.spec.Names {\n+\t\tif n.Name == obj.Name {\n+\t\t\treturn n.Pos()\n+\t\t}\n+\t}\n+\treturn token.NoPos\n+}\n+func (obj *TypeName) GetPos() token.Pos { return obj.spec.Pos() }\n+func (obj *Var) GetPos() token.Pos {\n+\tswitch d := obj.decl.(type) {\n+\tcase *ast.Field:\n+\t\tfor _, n := range d.Names {\n+\t\t\tif n.Name == obj.Name {\n+\t\t\t\treturn n.Pos()\n+\t\t\t}\n+\t\t}\n+\tcase *ast.ValueSpec:\n+\t\tfor _, n := range d.Names {\n+\t\t\tif n.Name == obj.Name {\n+\t\t\t\treturn n.Pos()\n+\t\t\t}\n+\t\t}\n+\tcase *ast.AssignStmt:\n+\t\tfor _, x := range d.Lhs {\n+\t\t\tif ident, isIdent := x.(*ast.Ident); isIdent && ident.Name == obj.Name {\n+\t\t\t\treturn ident.Pos()\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn token.NoPos\n+}\n+func (obj *Func) GetPos() token.Pos { return obj.decl.Name.Pos() }\n+\n+func (*Package) anObject()  {}\n+func (*Const) anObject()    {}\n+func (*TypeName) anObject() {}\n+func (*Var) anObject()      {}\n+func (*Func) anObject()     {}\n+\n+// newObj returns a new Object for a given *ast.Object.\n+// It does not canonicalize them (it always returns a new one).\n+// For canonicalization, see check.lookup.\n+//\n+// TODO(gri) Once we do identifier resolution completely in\n+//           in the typechecker, this functionality can go.\n+//\n+func newObj(astObj *ast.Object) Object {\n+\tname := astObj.Name\n+\ttyp, _ := astObj.Type.(Type)\n+\tswitch astObj.Kind {\n+\tcase ast.Bad:\n+\t\t// ignore\n+\tcase ast.Pkg:\n+\t\tunreachable()\n+\tcase ast.Con:\n+\t\treturn &Const{Name: name, Type: typ, Val: astObj.Data, spec: astObj.Decl.(*ast.ValueSpec)}\n+\tcase ast.Typ:\n+\t\treturn &TypeName{Name: name, Type: typ, spec: astObj.Decl.(*ast.TypeSpec)}\n+\tcase ast.Var:\n+\t\tswitch astObj.Decl.(type) {\n+\t\tcase *ast.Field, *ast.ValueSpec, *ast.AssignStmt: // these are ok\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\treturn &Var{Name: name, Type: typ, decl: astObj.Decl}\n+\tcase ast.Fun:\n+\t\treturn &Func{Name: name, Type: typ, decl: astObj.Decl.(*ast.FuncDecl)}\n+\tcase ast.Lbl:\n+\t\tunreachable() // for now\n+\t}\n+\tunreachable()\n+\treturn nil\n+}"}, {"sha": "6c2281027c3aaed0853500d49f37d3584dc0faac", "filename": "libgo/go/go/types/operand.go", "status": "renamed", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -137,7 +137,7 @@ func (x *operand) isAssignable(T Type) bool {\n \tV := x.typ\n \n \t// x's type is identical to T\n-\tif isIdentical(V, T) {\n+\tif IsIdentical(V, T) {\n \t\treturn true\n \t}\n \n@@ -146,7 +146,7 @@ func (x *operand) isAssignable(T Type) bool {\n \n \t// x's type V and T have identical underlying types\n \t// and at least one of V or T is not a named type\n-\tif isIdentical(Vu, Tu) {\n+\tif IsIdentical(Vu, Tu) {\n \t\treturn !isNamed(V) || !isNamed(T)\n \t}\n \n@@ -161,15 +161,19 @@ func (x *operand) isAssignable(T Type) bool {\n \t// type, x's type V and T have identical element types,\n \t// and at least one of V or T is not a named type\n \tif Vc, ok := Vu.(*Chan); ok && Vc.Dir == ast.SEND|ast.RECV {\n-\t\tif Tc, ok := Tu.(*Chan); ok && isIdentical(Vc.Elt, Tc.Elt) {\n+\t\tif Tc, ok := Tu.(*Chan); ok && IsIdentical(Vc.Elt, Tc.Elt) {\n \t\t\treturn !isNamed(V) || !isNamed(T)\n \t\t}\n \t}\n \n \t// x is the predeclared identifier nil and T is a pointer,\n \t// function, slice, map, channel, or interface type\n \tif x.isNil() {\n-\t\tswitch Tu.(type) {\n+\t\tswitch t := Tu.(type) {\n+\t\tcase *Basic:\n+\t\t\tif t.Kind == UnsafePointer {\n+\t\t\t\treturn true\n+\t\t\t}\n \t\tcase *Pointer, *Signature, *Slice, *Map, *Chan, *Interface:\n \t\t\treturn true\n \t\t}\n@@ -218,11 +222,11 @@ type embeddedType struct {\n }\n \n // lookupFieldBreadthFirst searches all types in list for a single entry (field\n-// or method) of the given name. If such a field is found, the result describes\n-// the field mode and type; otherwise the result mode is invalid.\n+// or method) of the given name from the given package. If such a field is found,\n+// the result describes the field mode and type; otherwise the result mode is invalid.\n // (This function is similar in structure to FieldByNameFunc in reflect/type.go)\n //\n-func lookupFieldBreadthFirst(list []embeddedType, name string) (res lookupResult) {\n+func lookupFieldBreadthFirst(list []embeddedType, name QualifiedName) (res lookupResult) {\n \t// visited records the types that have been searched already.\n \tvisited := make(map[*NamedType]bool)\n \n@@ -261,20 +265,20 @@ func lookupFieldBreadthFirst(list []embeddedType, name string) (res lookupResult\n \t\t\tvisited[typ] = true\n \n \t\t\t// look for a matching attached method\n-\t\t\tif data := typ.Obj.Data; data != nil {\n-\t\t\t\tif obj := data.(*ast.Scope).Lookup(name); obj != nil {\n-\t\t\t\t\tassert(obj.Type != nil)\n-\t\t\t\t\tif !potentialMatch(e.multiples, value, obj.Type.(Type)) {\n+\t\t\tfor _, m := range typ.Methods {\n+\t\t\t\tif name.IsSame(m.QualifiedName) {\n+\t\t\t\t\tassert(m.Type != nil)\n+\t\t\t\t\tif !potentialMatch(e.multiples, value, m.Type) {\n \t\t\t\t\t\treturn // name collision\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tswitch typ := underlying(typ).(type) {\n+\t\t\tswitch t := typ.Underlying.(type) {\n \t\t\tcase *Struct:\n \t\t\t\t// look for a matching field and collect embedded types\n-\t\t\t\tfor _, f := range typ.Fields {\n-\t\t\t\t\tif f.Name == name {\n+\t\t\t\tfor _, f := range t.Fields {\n+\t\t\t\t\tif name.IsSame(f.QualifiedName) {\n \t\t\t\t\t\tassert(f.Type != nil)\n \t\t\t\t\t\tif !potentialMatch(e.multiples, variable, f.Type) {\n \t\t\t\t\t\t\treturn // name collision\n@@ -297,10 +301,10 @@ func lookupFieldBreadthFirst(list []embeddedType, name string) (res lookupResult\n \n \t\t\tcase *Interface:\n \t\t\t\t// look for a matching method\n-\t\t\t\tfor _, obj := range typ.Methods {\n-\t\t\t\t\tif obj.Name == name {\n-\t\t\t\t\t\tassert(obj.Type != nil)\n-\t\t\t\t\t\tif !potentialMatch(e.multiples, value, obj.Type.(Type)) {\n+\t\t\t\tfor _, m := range t.Methods {\n+\t\t\t\t\tif name.IsSame(m.QualifiedName) {\n+\t\t\t\t\t\tassert(m.Type != nil)\n+\t\t\t\t\t\tif !potentialMatch(e.multiples, value, m.Type) {\n \t\t\t\t\t\t\treturn // name collision\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n@@ -344,23 +348,24 @@ func findType(list []embeddedType, typ *NamedType) *embeddedType {\n \treturn nil\n }\n \n-func lookupField(typ Type, name string) (operandMode, Type) {\n+func lookupField(typ Type, name QualifiedName) (operandMode, Type) {\n \ttyp = deref(typ)\n \n-\tif typ, ok := typ.(*NamedType); ok {\n-\t\tif data := typ.Obj.Data; data != nil {\n-\t\t\tif obj := data.(*ast.Scope).Lookup(name); obj != nil {\n-\t\t\t\tassert(obj.Type != nil)\n-\t\t\t\treturn value, obj.Type.(Type)\n+\tif t, ok := typ.(*NamedType); ok {\n+\t\tfor _, m := range t.Methods {\n+\t\t\tif name.IsSame(m.QualifiedName) {\n+\t\t\t\tassert(m.Type != nil)\n+\t\t\t\treturn value, m.Type\n \t\t\t}\n \t\t}\n+\t\ttyp = t.Underlying\n \t}\n \n-\tswitch typ := underlying(typ).(type) {\n+\tswitch t := typ.(type) {\n \tcase *Struct:\n \t\tvar next []embeddedType\n-\t\tfor _, f := range typ.Fields {\n-\t\t\tif f.Name == name {\n+\t\tfor _, f := range t.Fields {\n+\t\t\tif name.IsSame(f.QualifiedName) {\n \t\t\t\treturn variable, f.Type\n \t\t\t}\n \t\t\tif f.IsAnonymous {\n@@ -376,9 +381,9 @@ func lookupField(typ Type, name string) (operandMode, Type) {\n \t\t}\n \n \tcase *Interface:\n-\t\tfor _, obj := range typ.Methods {\n-\t\t\tif obj.Name == name {\n-\t\t\t\treturn value, obj.Type.(Type)\n+\t\tfor _, m := range t.Methods {\n+\t\t\tif name.IsSame(m.QualifiedName) {\n+\t\t\t\treturn value, m.Type\n \t\t\t}\n \t\t}\n \t}", "previous_filename": "libgo/go/exp/types/operand.go"}, {"sha": "3468da5a5761fc7e6426030956f7b051cf397229", "filename": "libgo/go/go/types/predicates.go", "status": "renamed", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -6,8 +6,6 @@\n \n package types\n \n-import \"go/ast\"\n-\n func isNamed(typ Type) bool {\n \tif _, ok := typ.(*Basic); ok {\n \t\treturn ok\n@@ -94,8 +92,8 @@ func hasNil(typ Type) bool {\n \treturn false\n }\n \n-// identical returns true if x and y are identical.\n-func isIdentical(x, y Type) bool {\n+// IsIdentical returns true if x and y are identical.\n+func IsIdentical(x, y Type) bool {\n \tif x == y {\n \t\treturn true\n \t}\n@@ -113,13 +111,13 @@ func isIdentical(x, y Type) bool {\n \t\t// Two array types are identical if they have identical element types\n \t\t// and the same array length.\n \t\tif y, ok := y.(*Array); ok {\n-\t\t\treturn x.Len == y.Len && isIdentical(x.Elt, y.Elt)\n+\t\t\treturn x.Len == y.Len && IsIdentical(x.Elt, y.Elt)\n \t\t}\n \n \tcase *Slice:\n \t\t// Two slice types are identical if they have identical element types.\n \t\tif y, ok := y.(*Slice); ok {\n-\t\t\treturn isIdentical(x.Elt, y.Elt)\n+\t\t\treturn IsIdentical(x.Elt, y.Elt)\n \t\t}\n \n \tcase *Struct:\n@@ -128,12 +126,11 @@ func isIdentical(x, y Type) bool {\n \t\t// and identical tags. Two anonymous fields are considered to have the same\n \t\t// name. Lower-case field names from different packages are always different.\n \t\tif y, ok := y.(*Struct); ok {\n-\t\t\t// TODO(gri) handle structs from different packages\n \t\t\tif len(x.Fields) == len(y.Fields) {\n \t\t\t\tfor i, f := range x.Fields {\n \t\t\t\t\tg := y.Fields[i]\n-\t\t\t\t\tif f.Name != g.Name ||\n-\t\t\t\t\t\t!isIdentical(f.Type, g.Type) ||\n+\t\t\t\t\tif !f.QualifiedName.IsSame(g.QualifiedName) ||\n+\t\t\t\t\t\t!IsIdentical(f.Type, g.Type) ||\n \t\t\t\t\t\tf.Tag != g.Tag ||\n \t\t\t\t\t\tf.IsAnonymous != g.IsAnonymous {\n \t\t\t\t\t\treturn false\n@@ -146,7 +143,7 @@ func isIdentical(x, y Type) bool {\n \tcase *Pointer:\n \t\t// Two pointer types are identical if they have identical base types.\n \t\tif y, ok := y.(*Pointer); ok {\n-\t\t\treturn isIdentical(x.Base, y.Base)\n+\t\t\treturn IsIdentical(x.Base, y.Base)\n \t\t}\n \n \tcase *Signature:\n@@ -165,20 +162,20 @@ func isIdentical(x, y Type) bool {\n \t\t// the same names and identical function types. Lower-case method names from\n \t\t// different packages are always different. The order of the methods is irrelevant.\n \t\tif y, ok := y.(*Interface); ok {\n-\t\t\treturn identicalTypes(x.Methods, y.Methods) // methods are sorted\n+\t\t\treturn identicalMethods(x.Methods, y.Methods) // methods are sorted\n \t\t}\n \n \tcase *Map:\n \t\t// Two map types are identical if they have identical key and value types.\n \t\tif y, ok := y.(*Map); ok {\n-\t\t\treturn isIdentical(x.Key, y.Key) && isIdentical(x.Elt, y.Elt)\n+\t\t\treturn IsIdentical(x.Key, y.Key) && IsIdentical(x.Elt, y.Elt)\n \t\t}\n \n \tcase *Chan:\n \t\t// Two channel types are identical if they have identical value types\n \t\t// and the same direction.\n \t\tif y, ok := y.(*Chan); ok {\n-\t\t\treturn x.Dir == y.Dir && isIdentical(x.Elt, y.Elt)\n+\t\t\treturn x.Dir == y.Dir && IsIdentical(x.Elt, y.Elt)\n \t\t}\n \n \tcase *NamedType:\n@@ -194,17 +191,37 @@ func isIdentical(x, y Type) bool {\n \n // identicalTypes returns true if both lists a and b have the\n // same length and corresponding objects have identical types.\n-func identicalTypes(a, b ObjList) bool {\n-\tif len(a) == len(b) {\n-\t\tfor i, x := range a {\n-\t\t\ty := b[i]\n-\t\t\tif !isIdentical(x.Type.(Type), y.Type.(Type)) {\n-\t\t\t\treturn false\n-\t\t\t}\n+func identicalTypes(a, b []*Var) bool {\n+\tif len(a) != len(b) {\n+\t\treturn false\n+\t}\n+\tfor i, x := range a {\n+\t\ty := b[i]\n+\t\tif !IsIdentical(x.Type, y.Type) {\n+\t\t\treturn false\n \t\t}\n-\t\treturn true\n \t}\n-\treturn false\n+\treturn true\n+}\n+\n+// identicalMethods returns true if both lists a and b have the\n+// same length and corresponding methods have identical types.\n+// TODO(gri) make this more efficient\n+func identicalMethods(a, b []*Method) bool {\n+\tif len(a) != len(b) {\n+\t\treturn false\n+\t}\n+\tm := make(map[QualifiedName]*Method)\n+\tfor _, x := range a {\n+\t\tassert(m[x.QualifiedName] == nil) // method list must not have duplicate entries\n+\t\tm[x.QualifiedName] = x\n+\t}\n+\tfor _, y := range b {\n+\t\tif x := m[y.QualifiedName]; x == nil || !IsIdentical(x.Type, y.Type) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n }\n \n // underlying returns the underlying type of typ.\n@@ -257,14 +274,15 @@ func defaultType(typ Type) Type {\n // it returns the first missing method required by T and whether it\n // is missing or simply has the wrong type.\n //\n-func missingMethod(typ Type, T *Interface) (method *ast.Object, wrongType bool) {\n+func missingMethod(typ Type, T *Interface) (method *Method, wrongType bool) {\n+\t// TODO(gri): this needs to correctly compare method names (taking package into account)\n \t// TODO(gri): distinguish pointer and non-pointer receivers\n \t// an interface type implements T if it has no methods with conflicting signatures\n \t// Note: This is stronger than the current spec. Should the spec require this?\n \tif ityp, _ := underlying(typ).(*Interface); ityp != nil {\n \t\tfor _, m := range T.Methods {\n-\t\t\tmode, sig := lookupField(ityp, m.Name) // TODO(gri) no need to go via lookupField\n-\t\t\tif mode != invalid && !isIdentical(sig, m.Type.(Type)) {\n+\t\t\tmode, sig := lookupField(ityp, m.QualifiedName) // TODO(gri) no need to go via lookupField\n+\t\t\tif mode != invalid && !IsIdentical(sig, m.Type) {\n \t\t\t\treturn m, true\n \t\t\t}\n \t\t}\n@@ -273,11 +291,11 @@ func missingMethod(typ Type, T *Interface) (method *ast.Object, wrongType bool)\n \n \t// a concrete type implements T if it implements all methods of T.\n \tfor _, m := range T.Methods {\n-\t\tmode, sig := lookupField(typ, m.Name)\n+\t\tmode, sig := lookupField(typ, m.QualifiedName)\n \t\tif mode == invalid {\n \t\t\treturn m, false\n \t\t}\n-\t\tif !isIdentical(sig, m.Type.(Type)) {\n+\t\tif !IsIdentical(sig, m.Type) {\n \t\t\treturn m, true\n \t\t}\n \t}", "previous_filename": "libgo/go/exp/types/predicates.go"}, {"sha": "112818f79047c2c99e792df8d88a94a0a4535e5c", "filename": "libgo/go/go/types/resolve.go", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolve.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/token\"\n+\t\"strconv\"\n+)\n+\n+func (check *checker) declareObj(scope, altScope *Scope, obj Object) {\n+\talt := scope.Insert(obj)\n+\tif alt == nil && altScope != nil {\n+\t\t// see if there is a conflicting declaration in altScope\n+\t\talt = altScope.Lookup(obj.GetName())\n+\t}\n+\tif alt != nil {\n+\t\tprevDecl := \"\"\n+\t\tif pos := alt.GetPos(); pos.IsValid() {\n+\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", check.fset.Position(pos))\n+\t\t}\n+\t\tcheck.errorf(obj.GetPos(), fmt.Sprintf(\"%s redeclared in this block%s\", obj.GetName(), prevDecl))\n+\t}\n+}\n+\n+func (check *checker) resolveIdent(scope *Scope, ident *ast.Ident) bool {\n+\tfor ; scope != nil; scope = scope.Outer {\n+\t\tif obj := scope.Lookup(ident.Name); obj != nil {\n+\t\t\tcheck.register(ident, obj)\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func (check *checker) resolve(importer Importer) (pkg *Package, methods []*ast.FuncDecl) {\n+\tpkg = &Package{Scope: &Scope{Outer: Universe}, Imports: make(map[string]*Package)}\n+\n+\t// complete package scope\n+\ti := 0\n+\tfor _, file := range check.files {\n+\t\t// package names must match\n+\t\tswitch name := file.Name.Name; {\n+\t\tcase pkg.Name == \"\":\n+\t\t\tpkg.Name = name\n+\t\tcase name != pkg.Name:\n+\t\t\tcheck.errorf(file.Package, \"package %s; expected %s\", name, pkg.Name)\n+\t\t\tcontinue // ignore this file\n+\t\t}\n+\n+\t\t// keep this file\n+\t\tcheck.files[i] = file\n+\t\ti++\n+\n+\t\t// the package identifier denotes the current package\n+\t\tcheck.register(file.Name, pkg)\n+\n+\t\t// insert top-level file objects in package scope\n+\t\t// (the parser took care of declaration errors)\n+\t\tfor _, decl := range file.Decls {\n+\t\t\tswitch d := decl.(type) {\n+\t\t\tcase *ast.BadDecl:\n+\t\t\t\t// ignore\n+\t\t\tcase *ast.GenDecl:\n+\t\t\t\tif d.Tok == token.CONST {\n+\t\t\t\t\tcheck.assocInitvals(d)\n+\t\t\t\t}\n+\t\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\t\tswitch s := spec.(type) {\n+\t\t\t\t\tcase *ast.ImportSpec:\n+\t\t\t\t\t\t// handled separately below\n+\t\t\t\t\tcase *ast.ValueSpec:\n+\t\t\t\t\t\tfor _, name := range s.Names {\n+\t\t\t\t\t\t\tif name.Name == \"_\" {\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpkg.Scope.Insert(check.lookup(name))\n+\t\t\t\t\t\t}\n+\t\t\t\t\tcase *ast.TypeSpec:\n+\t\t\t\t\t\tif s.Name.Name == \"_\" {\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tpkg.Scope.Insert(check.lookup(s.Name))\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tcheck.invalidAST(s.Pos(), \"unknown ast.Spec node %T\", s)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase *ast.FuncDecl:\n+\t\t\t\tif d.Recv != nil {\n+\t\t\t\t\t// collect method\n+\t\t\t\t\tmethods = append(methods, d)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif d.Name.Name == \"_\" || d.Name.Name == \"init\" {\n+\t\t\t\t\tcontinue // blank (_) and init functions are inaccessible\n+\t\t\t\t}\n+\t\t\t\tpkg.Scope.Insert(check.lookup(d.Name))\n+\t\t\tdefault:\n+\t\t\t\tcheck.invalidAST(d.Pos(), \"unknown ast.Decl node %T\", d)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tcheck.files = check.files[0:i]\n+\n+\t// complete file scopes with imports and resolve identifiers\n+\tfor _, file := range check.files {\n+\t\t// build file scope by processing all imports\n+\t\timportErrors := false\n+\t\tfileScope := &Scope{Outer: pkg.Scope}\n+\t\tfor _, spec := range file.Imports {\n+\t\t\tif importer == nil {\n+\t\t\t\timportErrors = true\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpath, _ := strconv.Unquote(spec.Path.Value)\n+\t\t\timp, err := importer(pkg.Imports, path)\n+\t\t\tif err != nil {\n+\t\t\t\tcheck.errorf(spec.Path.Pos(), \"could not import %s (%s)\", path, err)\n+\t\t\t\timportErrors = true\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// TODO(gri) If a local package name != \".\" is provided,\n+\t\t\t// global identifier resolution could proceed even if the\n+\t\t\t// import failed. Consider adjusting the logic here a bit.\n+\n+\t\t\t// local name overrides imported package name\n+\t\t\tname := imp.Name\n+\t\t\tif spec.Name != nil {\n+\t\t\t\tname = spec.Name.Name\n+\t\t\t}\n+\n+\t\t\t// add import to file scope\n+\t\t\tif name == \".\" {\n+\t\t\t\t// merge imported scope with file scope\n+\t\t\t\tfor _, obj := range imp.Scope.Entries {\n+\t\t\t\t\tcheck.declareObj(fileScope, pkg.Scope, obj)\n+\t\t\t\t}\n+\t\t\t\t// TODO(gri) consider registering the \".\" identifier\n+\t\t\t\t// if we have Context.Ident callbacks for say blank\n+\t\t\t\t// (_) identifiers\n+\t\t\t\t// check.register(spec.Name, pkg)\n+\t\t\t} else if name != \"_\" {\n+\t\t\t\t// declare imported package object in file scope\n+\t\t\t\t// (do not re-use imp in the file scope but create\n+\t\t\t\t// a new object instead; the Decl field is different\n+\t\t\t\t// for different files)\n+\t\t\t\tobj := &Package{Name: name, Scope: imp.Scope, spec: spec}\n+\t\t\t\tcheck.declareObj(fileScope, pkg.Scope, obj)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// resolve identifiers\n+\t\tif importErrors {\n+\t\t\t// don't use the universe scope without correct imports\n+\t\t\t// (objects in the universe may be shadowed by imports;\n+\t\t\t// with missing imports, identifiers might get resolved\n+\t\t\t// incorrectly to universe objects)\n+\t\t\tpkg.Scope.Outer = nil\n+\t\t}\n+\t\ti := 0\n+\t\tfor _, ident := range file.Unresolved {\n+\t\t\tif !check.resolveIdent(fileScope, ident) {\n+\t\t\t\tcheck.errorf(ident.Pos(), \"undeclared name: %s\", ident.Name)\n+\t\t\t\tfile.Unresolved[i] = ident\n+\t\t\t\ti++\n+\t\t\t}\n+\n+\t\t}\n+\t\tfile.Unresolved = file.Unresolved[0:i]\n+\t\tpkg.Scope.Outer = Universe // reset outer scope (is nil if there were importErrors)\n+\t}\n+\n+\treturn\n+}"}, {"sha": "b3b50a67d506c8b3ddc57ed739a97e4a49286e41", "filename": "libgo/go/go/types/resolver_test.go", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package types\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"testing\"\n+)\n+\n+var sources = []string{\n+\t`\n+\tpackage p\n+\timport \"fmt\"\n+\timport \"math\"\n+\tconst pi = math.Pi\n+\tfunc sin(x float64) float64 {\n+\t\treturn math.Sin(x)\n+\t}\n+\tvar Println = fmt.Println\n+\t`,\n+\t`\n+\tpackage p\n+\timport \"fmt\"\n+\tfunc f() string {\n+\t\t_ = \"foo\"\n+\t\treturn fmt.Sprintf(\"%d\", g())\n+\t}\n+\tfunc g() (x int) { return }\n+\t`,\n+\t`\n+\tpackage p\n+\timport . \"go/parser\"\n+\timport \"sync\"\n+\tfunc g() Mode { return ImportsOnly }\n+\tvar _, x int = 1, 2\n+\tfunc init() {}\n+\ttype T struct{ sync.Mutex; a, b, c int}\n+\ttype I interface{ m() }\n+\tvar _ = T{a: 1, b: 2, c: 3}\n+\tfunc (_ T) m() {}\n+\t`,\n+}\n+\n+var pkgnames = []string{\n+\t\"fmt\",\n+\t\"math\",\n+}\n+\n+func TestResolveQualifiedIdents(t *testing.T) {\n+\t// Does not work with gccgo, because it requires reading gc\n+\t// import files.\n+\treturn\n+\n+\t// parse package files\n+\tfset := token.NewFileSet()\n+\tvar files []*ast.File\n+\tfor _, src := range sources {\n+\t\tf, err := parser.ParseFile(fset, \"\", src, parser.DeclarationErrors)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tfiles = append(files, f)\n+\t}\n+\n+\t// resolve and type-check package AST\n+\tidents := make(map[*ast.Ident]Object)\n+\tctxt := Default\n+\tctxt.Ident = func(id *ast.Ident, obj Object) { idents[id] = obj }\n+\tpkg, err := ctxt.Check(fset, files)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// check that all packages were imported\n+\tfor _, name := range pkgnames {\n+\t\tif pkg.Imports[name] == nil {\n+\t\t\tt.Errorf(\"package %s not imported\", name)\n+\t\t}\n+\t}\n+\n+\t// check that there are no top-level unresolved identifiers\n+\tfor _, f := range files {\n+\t\tfor _, x := range f.Unresolved {\n+\t\t\tt.Errorf(\"%s: unresolved global identifier %s\", fset.Position(x.Pos()), x.Name)\n+\t\t}\n+\t}\n+\n+\t// check that qualified identifiers are resolved\n+\tfor _, f := range files {\n+\t\tast.Inspect(f, func(n ast.Node) bool {\n+\t\t\tif s, ok := n.(*ast.SelectorExpr); ok {\n+\t\t\t\tif x, ok := s.X.(*ast.Ident); ok {\n+\t\t\t\t\tobj := idents[x]\n+\t\t\t\t\tif obj == nil {\n+\t\t\t\t\t\tt.Errorf(\"%s: unresolved qualified identifier %s\", fset.Position(x.Pos()), x.Name)\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t\tif _, ok := obj.(*Package); ok && idents[s.Sel] == nil {\n+\t\t\t\t\t\tt.Errorf(\"%s: unresolved selector %s\", fset.Position(s.Sel.Pos()), s.Sel.Name)\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn true\n+\t\t})\n+\t}\n+\n+\t// Currently, the Check API doesn't call Ident for fields, methods, and composite literal keys.\n+\t// Introduce them artifically so that we can run the check below.\n+\tfor _, f := range files {\n+\t\tast.Inspect(f, func(n ast.Node) bool {\n+\t\t\tswitch x := n.(type) {\n+\t\t\tcase *ast.StructType:\n+\t\t\t\tfor _, list := range x.Fields.List {\n+\t\t\t\t\tfor _, f := range list.Names {\n+\t\t\t\t\t\tassert(idents[f] == nil)\n+\t\t\t\t\t\tidents[f] = &Var{Name: f.Name}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase *ast.InterfaceType:\n+\t\t\t\tfor _, list := range x.Methods.List {\n+\t\t\t\t\tfor _, f := range list.Names {\n+\t\t\t\t\t\tassert(idents[f] == nil)\n+\t\t\t\t\t\tidents[f] = &Func{Name: f.Name}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase *ast.CompositeLit:\n+\t\t\t\tfor _, e := range x.Elts {\n+\t\t\t\t\tif kv, ok := e.(*ast.KeyValueExpr); ok {\n+\t\t\t\t\t\tif k, ok := kv.Key.(*ast.Ident); ok {\n+\t\t\t\t\t\t\tassert(idents[k] == nil)\n+\t\t\t\t\t\t\tidents[k] = &Var{Name: k.Name}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t})\n+\t}\n+\n+\t// check that each identifier in the source is enumerated by the Context.Ident callback\n+\tfor _, f := range files {\n+\t\tast.Inspect(f, func(n ast.Node) bool {\n+\t\t\tif x, ok := n.(*ast.Ident); ok && x.Name != \"_\" && x.Name != \".\" {\n+\t\t\t\tobj := idents[x]\n+\t\t\t\tif obj == nil {\n+\t\t\t\t\tt.Errorf(\"%s: unresolved identifier %s\", fset.Position(x.Pos()), x.Name)\n+\t\t\t\t} else {\n+\t\t\t\t\tdelete(idents, x)\n+\t\t\t\t}\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn true\n+\t\t})\n+\t}\n+\n+\t// TODO(gri) enable code below\n+\t// At the moment, the type checker introduces artifical identifiers which are not\n+\t// present in the source. Once it doesn't do that anymore, enable the checks below.\n+\t/*\n+\t\tfor x := range idents {\n+\t\t\tt.Errorf(\"%s: identifier %s not present in source\", fset.Position(x.Pos()), x.Name)\n+\t\t}\n+\t*/\n+}"}, {"sha": "b8d6d0bb267289ee497b2d3be254a1bbb4978e5b", "filename": "libgo/go/go/types/scope.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package types\n+\n+// A Scope maintains the set of named language entities declared\n+// in the scope and a link to the immediately surrounding (outer)\n+// scope.\n+//\n+type Scope struct {\n+\tOuter   *Scope\n+\tEntries []Object          // scope entries in insertion order\n+\tlarge   map[string]Object // for fast lookup - only used for larger scopes\n+}\n+\n+// Lookup returns the object with the given name if it is\n+// found in scope s, otherwise it returns nil. Outer scopes\n+// are ignored.\n+//\n+func (s *Scope) Lookup(name string) Object {\n+\tif s.large != nil {\n+\t\treturn s.large[name]\n+\t}\n+\tfor _, obj := range s.Entries {\n+\t\tif obj.GetName() == name {\n+\t\t\treturn obj\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Insert attempts to insert an object obj into scope s.\n+// If s already contains an object with the same name,\n+// Insert leaves s unchanged and returns that object.\n+// Otherwise it inserts obj and returns nil.\n+//\n+func (s *Scope) Insert(obj Object) Object {\n+\tname := obj.GetName()\n+\tif alt := s.Lookup(name); alt != nil {\n+\t\treturn alt\n+\t}\n+\ts.Entries = append(s.Entries, obj)\n+\n+\t// If the scope size reaches a threshold, use a map for faster lookups.\n+\tconst threshold = 20\n+\tif len(s.Entries) > threshold {\n+\t\tif s.large == nil {\n+\t\t\tm := make(map[string]Object, len(s.Entries))\n+\t\t\tfor _, obj := range s.Entries {\n+\t\t\t\tm[obj.GetName()] = obj\n+\t\t\t}\n+\t\t\ts.large = m\n+\t\t}\n+\t\ts.large[name] = obj\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "11a2e7196dc5dae73aaeb8f2c0a540161e44f972", "filename": "libgo/go/go/types/stmt.go", "status": "renamed", "additions": 73, "deletions": 36, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -76,10 +76,10 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n \t}\n \n \t// lhs may or may not be typed yet\n-\tobj := ident.Obj\n+\tobj := check.lookup(ident)\n \tvar typ Type\n-\tif obj.Type != nil {\n-\t\ttyp = obj.Type.(Type)\n+\tif t := obj.GetType(); t != nil {\n+\t\ttyp = t\n \t}\n \n \tif rhs != nil {\n@@ -94,7 +94,7 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n \t\ttyp = Typ[Invalid]\n \t\tif x.mode != invalid {\n \t\t\ttyp = x.typ\n-\t\t\tif obj.Kind == ast.Var && isUntyped(typ) {\n+\t\t\tif _, ok := obj.(*Var); ok && isUntyped(typ) {\n \t\t\t\tif x.isNil() {\n \t\t\t\t\tcheck.errorf(x.pos(), \"use of untyped nil\")\n \t\t\t\t\tx.mode = invalid\n@@ -103,15 +103,22 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tobj.Type = typ\n+\t\tswitch obj := obj.(type) {\n+\t\tcase *Const:\n+\t\t\tobj.Type = typ\n+\t\tcase *Var:\n+\t\t\tobj.Type = typ\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n \t}\n \n \tif x.mode != invalid {\n \t\tvar z operand\n-\t\tswitch obj.Kind {\n-\t\tcase ast.Con:\n+\t\tswitch obj.(type) {\n+\t\tcase *Const:\n \t\t\tz.mode = constant\n-\t\tcase ast.Var:\n+\t\tcase *Var:\n \t\t\tz.mode = variable\n \t\tdefault:\n \t\t\tunreachable()\n@@ -122,35 +129,36 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n \t}\n \n \t// for constants, set their value\n-\tif obj.Kind == ast.Con {\n-\t\tassert(obj.Data == nil)\n+\tif obj, ok := obj.(*Const); ok {\n+\t\tassert(obj.Val == nil)\n \t\tif x.mode != invalid {\n \t\t\tif x.mode == constant {\n \t\t\t\tif isConstType(x.typ) {\n-\t\t\t\t\tobj.Data = x.val\n+\t\t\t\t\tobj.Val = x.val\n \t\t\t\t} else {\n \t\t\t\t\tcheck.errorf(x.pos(), \"%s has invalid constant type\", x)\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tcheck.errorf(x.pos(), \"%s is not constant\", x)\n \t\t\t}\n \t\t}\n-\t\tif obj.Data == nil {\n+\t\tif obj.Val == nil {\n \t\t\t// set the constant to its type's zero value to reduce spurious errors\n-\t\t\tswitch typ := underlying(obj.Type.(Type)); {\n+\t\t\tswitch typ := underlying(obj.Type); {\n \t\t\tcase typ == Typ[Invalid]:\n \t\t\t\t// ignore\n \t\t\tcase isBoolean(typ):\n-\t\t\t\tobj.Data = false\n+\t\t\t\tobj.Val = false\n \t\t\tcase isNumeric(typ):\n-\t\t\t\tobj.Data = int64(0)\n+\t\t\t\tobj.Val = int64(0)\n \t\t\tcase isString(typ):\n-\t\t\t\tobj.Data = \"\"\n+\t\t\t\tobj.Val = \"\"\n \t\t\tcase hasNil(typ):\n-\t\t\t\tobj.Data = nilConst\n+\t\t\t\tobj.Val = nilConst\n \t\t\tdefault:\n \t\t\t\t// in all other cases just prevent use of the constant\n-\t\t\t\tobj.Kind = ast.Bad\n+\t\t\t\t// TODO(gri) re-evaluate this code\n+\t\t\t\tobj.Val = nilConst\n \t\t\t}\n \t\t}\n \t}\n@@ -159,7 +167,7 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n // assignNtoM typechecks a general assignment. If decl is set, the lhs operands\n // must be identifiers. If their types are not set, they are deduced from the\n // types of the corresponding rhs expressions. iota >= 0 indicates that the\n-// \"assignment\" is part of a constant declaration.\n+// \"assignment\" is part of a constant/variable declaration.\n // Precondition: len(lhs) > 0 .\n //\n func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n@@ -187,7 +195,7 @@ func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n \t\t\tx.mode = value\n \t\t\tfor i, obj := range t.Values {\n \t\t\t\tx.expr = nil // TODO(gri) should do better here\n-\t\t\t\tx.typ = obj.Type.(Type)\n+\t\t\t\tx.typ = obj.Type\n \t\t\t\tcheck.assign1to1(lhs[i], nil, &x, decl, iota)\n \t\t\t}\n \t\t\treturn\n@@ -212,8 +220,15 @@ func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n \tif iota >= 0 {\n \t\t// declaration\n \t\tfor _, e := range lhs {\n-\t\t\tif ident, ok := e.(*ast.Ident); ok {\n-\t\t\t\tident.Obj.Type = Typ[Invalid]\n+\t\t\tif name, ok := e.(*ast.Ident); ok {\n+\t\t\t\tswitch obj := check.lookup(name).(type) {\n+\t\t\t\tcase *Const:\n+\t\t\t\t\tobj.Type = Typ[Invalid]\n+\t\t\t\tcase *Var:\n+\t\t\t\t\tobj.Type = Typ[Invalid]\n+\t\t\t\tdefault:\n+\t\t\t\t\tunreachable()\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -270,7 +285,15 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t// ignore\n \n \tcase *ast.DeclStmt:\n-\t\tcheck.decl(s.Decl)\n+\t\td, _ := s.Decl.(*ast.GenDecl)\n+\t\tif d == nil || (d.Tok != token.CONST && d.Tok != token.TYPE && d.Tok != token.VAR) {\n+\t\t\tcheck.invalidAST(token.NoPos, \"const, type, or var declaration expected\")\n+\t\t\treturn\n+\t\t}\n+\t\tif d.Tok == token.CONST {\n+\t\t\tcheck.assocInitvals(d)\n+\t\t}\n+\t\tcheck.decl(d)\n \n \tcase *ast.LabeledStmt:\n \t\t// TODO(gri) anything to do with label itself?\n@@ -284,6 +307,9 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t// function calls are permitted\n \t\t\tused = true\n \t\t\t// but some builtins are excluded\n+\t\t\t// (Caution: This evaluates e.Fun twice, once here and once\n+\t\t\t//           below as part of s.X. This has consequences for\n+\t\t\t//           check.register. Perhaps this can be avoided.)\n \t\t\tcheck.expr(&x, e.Fun, nil, -1)\n \t\t\tif x.mode != invalid {\n \t\t\t\tif b, ok := x.typ.(*builtin); ok && !b.isStatement {\n@@ -378,8 +404,14 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t}\n \t\t\tvar x, y operand\n \t\t\tcheck.expr(&x, s.Lhs[0], nil, -1)\n+\t\t\tif x.mode == invalid {\n+\t\t\t\treturn\n+\t\t\t}\n \t\t\tcheck.expr(&y, s.Rhs[0], nil, -1)\n-\t\t\tcheck.binary(&x, &y, op, nil)\n+\t\t\tif y.mode == invalid {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcheck.binary(&x, &y, op, x.typ)\n \t\t\tcheck.assign1to1(s.Lhs[0], nil, &x, false, -1)\n \t\t}\n \n@@ -390,19 +422,19 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\tcheck.call(s.Call)\n \n \tcase *ast.ReturnStmt:\n-\t\tsig := check.functypes[len(check.functypes)-1]\n+\t\tsig := check.funcsig\n \t\tif n := len(sig.Results); n > 0 {\n \t\t\t// TODO(gri) should not have to compute lhs, named every single time - clean this up\n \t\t\tlhs := make([]ast.Expr, n)\n \t\t\tnamed := false // if set, function has named results\n \t\t\tfor i, res := range sig.Results {\n \t\t\t\tif len(res.Name) > 0 {\n-\t\t\t\t\t// a blank (_) result parameter is a named result parameter!\n+\t\t\t\t\t// a blank (_) result parameter is a named result\n \t\t\t\t\tnamed = true\n \t\t\t\t}\n \t\t\t\tname := ast.NewIdent(res.Name)\n \t\t\t\tname.NamePos = s.Pos()\n-\t\t\t\tname.Obj = res\n+\t\t\t\tcheck.register(name, &Var{Name: res.Name, Type: res.Type})\n \t\t\t\tlhs[i] = name\n \t\t\t}\n \t\t\tif len(s.Results) > 0 || !named {\n@@ -414,7 +446,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t}\n \n \tcase *ast.BranchStmt:\n-\t\tunimplemented()\n+\t\t// TODO(gri) implement this\n \n \tcase *ast.BlockStmt:\n \t\tcheck.stmtList(s.List)\n@@ -435,7 +467,9 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\ttag := s.Tag\n \t\tif tag == nil {\n \t\t\t// use fake true tag value and position it at the opening { of the switch\n-\t\t\ttag = &ast.Ident{NamePos: s.Body.Lbrace, Name: \"true\", Obj: Universe.Lookup(\"true\")}\n+\t\t\tident := &ast.Ident{NamePos: s.Body.Lbrace, Name: \"true\"}\n+\t\t\tcheck.register(ident, Universe.Lookup(\"true\"))\n+\t\t\ttag = ident\n \t\t}\n \t\tcheck.expr(&x, tag, nil, -1)\n \n@@ -459,6 +493,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t\t\t// duplicate entry, but only report an error if there are\n \t\t\t\t\t// no other errors.\n \t\t\t\t\tvar dupl token.Pos\n+\t\t\t\t\tvar yy operand\n \t\t\t\t\tif y.mode == constant {\n \t\t\t\t\t\t// TODO(gri) This code doesn't work correctly for\n \t\t\t\t\t\t//           large integer, floating point, or\n@@ -467,6 +502,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t\t\t\t//           hash function to index the map.\n \t\t\t\t\t\tdupl = seen[y.val]\n \t\t\t\t\t\tseen[y.val] = y.pos()\n+\t\t\t\t\t\tyy = y // remember y\n \t\t\t\t\t}\n \t\t\t\t\t// TODO(gri) The convertUntyped call pair below appears in other places. Factor!\n \t\t\t\t\t// Order matters: By comparing y against x, error positions are at the case values.\n@@ -480,8 +516,8 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t\t\t}\n \t\t\t\t\tcheck.comparison(&y, &x, token.EQL)\n \t\t\t\t\tif y.mode != invalid && dupl.IsValid() {\n-\t\t\t\t\t\tcheck.errorf(y.pos(), \"%s is duplicate case (previous at %s)\",\n-\t\t\t\t\t\t\t&y, check.fset.Position(dupl))\n+\t\t\t\t\t\tcheck.errorf(yy.pos(), \"%s is duplicate case (previous at %s)\",\n+\t\t\t\t\t\t\t&yy, check.fset.Position(dupl))\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -499,7 +535,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t// remaining syntactic errors are considered AST errors here.\n \t\t// TODO(gri) better factoring of error handling (invalid ASTs)\n \t\t//\n-\t\tvar lhs *ast.Object // lhs identifier object or nil\n+\t\tvar lhs *Var // lhs variable or nil\n \t\tvar rhs ast.Expr\n \t\tswitch guard := s.Assign.(type) {\n \t\tcase *ast.ExprStmt:\n@@ -514,7 +550,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tlhs = ident.Obj\n+\t\t\tlhs = check.lookup(ident).(*Var)\n \t\t\trhs = guard.Rhs[0]\n \t\tdefault:\n \t\t\tcheck.invalidAST(s.Pos(), \"incorrect form of type switch guard\")\n@@ -574,10 +610,10 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t}\n \n \t\t// There is only one object (lhs) associated with a lhs identifier, but that object\n-\t\t// assumes different types for different clauses. Set it to nil when we are done so\n-\t\t// that the type cannot be used by mistake.\n+\t\t// assumes different types for different clauses. Set it back to the type of the\n+\t\t// TypeSwitchGuard expression so that that variable always has a valid type.\n \t\tif lhs != nil {\n-\t\t\tlhs.Type = nil\n+\t\t\tlhs.Type = x.typ\n \t\t}\n \n \tcase *ast.SelectStmt:\n@@ -664,6 +700,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t//           they refer to the expression in the range clause.\n \t\t//           Should give better messages w/o too much code\n \t\t//           duplication (assignment checking).\n+\t\tx.mode = value\n \t\tif s.Key != nil {\n \t\t\tx.typ = key\n \t\t\tcheck.assign1to1(s.Key, nil, &x, decl, -1)", "previous_filename": "libgo/go/exp/types/stmt.go"}, {"sha": "6c848fc27766f7cc889cce186657d3006b3fc9dc", "filename": "libgo/go/go/types/testdata/builtins.src", "status": "renamed", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fbuiltins.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fbuiltins.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fbuiltins.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -76,6 +76,22 @@ func _complex() {\n \tcomplex /* ERROR \"not used\" */ (1, 2)\n }\n \n+func _copy() {\n+\tcopy /* ERROR \"not enough arguments\" */ ()\n+\tcopy /* ERROR \"not enough arguments\" */ (\"foo\")\n+\tcopy([ /* ERROR \"copy expects slice arguments\" */ ...]int{}, []int{})\n+\tcopy([ /* ERROR \"copy expects slice arguments\" */ ]int{}, [...]int{})\n+\tcopy([ /* ERROR \"different element types\" */ ]int8{}, \"foo\")\n+\n+\t// spec examples\n+\tvar a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}\n+\tvar s = make([]int, 6)\n+\tvar b = make([]byte, 5)\n+\tn1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}\n+\tn2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}\n+\tn3 := copy(b, \"Hello, World!\")  // n3 == 5, b == []byte(\"Hello\")\n+}\n+\n func _delete() {\n \tvar m map[string]int\n \tvar s string", "previous_filename": "libgo/go/exp/types/testdata/builtins.src"}, {"sha": "a2ca344c788e6c0eb98090d6f62e68bbfa3caea5", "filename": "libgo/go/go/types/testdata/const0.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconst0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconst0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconst0.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/const0.src"}, {"sha": "1b1518366f34d09ce6a90f8093ba21c05923aa29", "filename": "libgo/go/go/types/testdata/conversions.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconversions.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconversions.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fconversions.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/conversions.src"}, {"sha": "33d4b3801490b3eeab9061d7301482de33e5ea8f", "filename": "libgo/go/go/types/testdata/decls0.src", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls0.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -127,7 +127,7 @@ type (\n \tI2 interface {\n \t\tm1()\n \t}\n-\tI3 interface {\n+\tI3 interface { /* ERROR \"multiple methods named m1\" */\n \t\tm1()\n \t\tm1 /* ERROR \"redeclared\" */ ()\n \t}", "previous_filename": "libgo/go/exp/types/testdata/decls0.src"}, {"sha": "dd63ba98091306a4deb00d2c388e1b032a319467", "filename": "libgo/go/go/types/testdata/decls1.src", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls1.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -122,3 +122,11 @@ func (T) m0() {}\n func (*T) m1() {}\n func (x T) m2() {}\n func (x *T) m3() {}\n+\n+\n+// Initialization functions\n+func init() {}\n+func /* ERROR \"no arguments and no return values\" */ init(int) {}\n+func /* ERROR \"no arguments and no return values\" */ init() int { return 0 }\n+func /* ERROR \"no arguments and no return values\" */ init(int) int {}\n+func (T) init(int) int { return 0 }", "previous_filename": "libgo/go/exp/types/testdata/decls1.src"}, {"sha": "3867be737653d80c4f59ed9de8e6a9552e05cc88", "filename": "libgo/go/go/types/testdata/decls2a.src", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2a.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2a.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2a.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -29,9 +29,9 @@ func (undeclared /* ERROR \"undeclared\" */) m() {}\n func (x *undeclared /* ERROR \"undeclared\" */) m() {}\n \n // TODO(gri) try to get rid of double error reporting here\n-func (pi /* ERROR \"not a type\" */ /* ERROR \"not a type\" */) m1() {}\n-func (x pi /* ERROR \"not a type\" */ /* ERROR \"not a type\" */) m2() {}\n-func (x *pi /* ERROR \"not a type\" */ /* ERROR \"cannot indirect\" */) m3() {} // TODO(gri) not closing the last /* comment crashes the system\n+func (pi /* ERROR \"not a type\" */) m1() {}\n+func (x pi /* ERROR \"not a type\" */) m2() {}\n+func (x *pi /* ERROR \"not a type\" */ ) m3() {} // TODO(gri) not closing the last /* comment crashes the system\n \n // Blank types.\n type _ struct { m int }\n@@ -61,7 +61,7 @@ func (T5 /* ERROR \"invalid receiver\" */) m1() {}\n func (T5 /* ERROR \"invalid receiver\" */) m2() {}\n \n // Methods associated with non-local or unnamed types.\n-// func (int) m() {} TODO(gri) check for methods associated with external (not package-local) types\n+func (int /* ERROR \"non-local type\" */ ) m() {}\n func ([ /* ERROR \"expected\" */ ]int) m() {}\n func (time /* ERROR \"expected\" */ .Time) m() {}\n func (x interface /* ERROR \"expected\" */ {}) m() {}", "previous_filename": "libgo/go/exp/types/testdata/decls2a.src"}, {"sha": "c7f9ddf01add6c2702a60743f24a914b46f889a6", "filename": "libgo/go/go/types/testdata/decls2b.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls2b.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/decls2b.src"}, {"sha": "4bc7d414941058876678207faab9ead0166b06c3", "filename": "libgo/go/go/types/testdata/decls3.src", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fdecls3.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// embedded types\n+\n+package decls3\n+\n+// fields with the same name at the same level cancel each other out\n+\n+func _() {\n+\ttype (\n+\t\tT1 struct { X int }\n+\t\tT2 struct { X int }\n+\t\tT3 struct { T1; T2 } // X is embedded twice at the same level via T1->X, T2->X\n+\t)\n+\n+\tvar t T3\n+\t_ = t /* ERROR \"no single field or method\" */ .X\n+}\n+\n+func _() {\n+\ttype (\n+\t\tT1 struct { X int }\n+\t\tT2 struct { T1 }\n+\t\tT3 struct { T1 }\n+\t\tT4 struct { T2; T3 } // X is embedded twice at the same level via T2->T1->X, T3->T1->X\n+\t)\n+\n+\tvar t T4\n+\t_ = t /* ERROR \"no single field or method\" */ .X\n+}\n+\n+func issue4355() {\n+\ttype (\n+\t    T1 struct {X int}\n+\t    T2 struct {T1}\n+\t    T3 struct {T2}\n+\t    T4 struct {T2}\n+\t    T5 struct {T3; T4} // X is embedded twice at the same level via T3->T2->T1->X, T4->T2->T1->X\n+\t)\t\n+\n+\tvar t T5\n+\t_ = t /* ERROR \"no single field or method\" */ .X\n+}\n+\n+// Borrowed from the FieldByName test cases in reflect/all_test.go.\n+\n+type D1 struct {\n+\td int\n+}\n+type D2 struct {\n+\td int\n+}\n+\n+type S0 struct {\n+\tA, B, C int\n+\tD1\n+\tD2\n+}\n+\n+type S1 struct {\n+\tB int\n+\tS0\n+}\n+\n+type S2 struct {\n+\tA int\n+\t*S1\n+}\n+\n+type S1x struct {\n+\tS1\n+}\n+\n+type S1y struct {\n+\tS1\n+}\n+\n+type S3 struct {\n+\tS1x\n+\tS2\n+\tD, E int\n+\t*S1y\n+}\n+\n+type S4 struct {\n+\t*S4\n+\tA int\n+}\n+\n+// The X in S6 and S7 annihilate, but they also block the X in S8.S9.\n+type S5 struct {\n+\tS6\n+\tS7\n+\tS8\n+}\n+\n+type S6 struct {\n+\tX int\n+}\n+\n+type S7 S6\n+\n+type S8 struct {\n+\tS9\n+}\n+\n+type S9 struct {\n+\tX int\n+\tY int\n+}\n+\n+// The X in S11.S6 and S12.S6 annihilate, but they also block the X in S13.S8.S9.\n+type S10 struct {\n+\tS11\n+\tS12\n+\tS13\n+}\n+\n+type S11 struct {\n+\tS6\n+}\n+\n+type S12 struct {\n+\tS6\n+}\n+\n+type S13 struct {\n+\tS8\n+}\n+\n+func _() {\n+\t_ = struct /* ERROR \"no single field or method\" */ {}{}.Foo\n+\t_ = S0{}.A\n+\t_ = S0 /* ERROR \"no single field or method\" */ {}.D\n+\t_ = S1{}.A\n+\t_ = S1{}.B\n+\t_ = S1{}.S0\n+\t_ = S1{}.C\n+\t_ = S2{}.A\n+\t_ = S2{}.S1\n+\t_ = S2{}.B\n+\t_ = S2{}.C\n+\t_ = S2 /* ERROR \"no single field or method\" */ {}.D\n+\t_ = S3 /* ERROR \"no single field or method\" */ {}.S1\n+\t_ = S3{}.A\n+\t_ = S3 /* ERROR \"no single field or method\" */ {}.B\n+\t_ = S3{}.D\n+\t_ = S3{}.E\n+\t_ = S4{}.A\n+\t_ = S4 /* ERROR \"no single field or method\" */ {}.B\n+\t_ = S5 /* ERROR \"no single field or method\" */ {}.X\n+\t_ = S5{}.Y\n+\t_ = S10 /* ERROR \"no single field or method\" */ {}.X\n+\t_ = S10{}.Y\n+}\n+\n+// Borrowed from the FieldByName benchmark in reflect/all_test.go.\n+\n+type R0 struct {\n+\t*R1\n+\t*R2\n+\t*R3\n+\t*R4\n+}\n+\n+type R1 struct {\n+\t*R5\n+\t*R6\n+\t*R7\n+\t*R8\n+}\n+\n+type R2 R1\n+type R3 R1\n+type R4 R1\n+\n+type R5 struct {\n+\t*R9\n+\t*R10\n+\t*R11\n+\t*R12\n+}\n+\n+type R6 R5\n+type R7 R5\n+type R8 R5\n+\n+type R9 struct {\n+\t*R13\n+\t*R14\n+\t*R15\n+\t*R16\n+}\n+\n+type R10 R9\n+type R11 R9\n+type R12 R9\n+\n+type R13 struct {\n+\t*R17\n+\t*R18\n+\t*R19\n+\t*R20\n+}\n+\n+type R14 R13\n+type R15 R13\n+type R16 R13\n+\n+type R17 struct {\n+\t*R21\n+\t*R22\n+\t*R23\n+\t*R24\n+}\n+\n+type R18 R17\n+type R19 R17\n+type R20 R17\n+\n+type R21 struct {\n+\tX int\n+}\n+\n+type R22 R21\n+type R23 R21\n+type R24 R21\n+\n+var _ = R0 /* ERROR \"no single field or method\" */ {}.X\n\\ No newline at end of file"}, {"sha": "8ee28b0942b69cab01baef4e6203a6ce12c63c26", "filename": "libgo/go/go/types/testdata/exports.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/exports.go"}, {"sha": "c3233d36fe1b560efdc47715195c922b934fff97", "filename": "libgo/go/go/types/testdata/expr0.src", "status": "renamed", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr0.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -133,3 +133,19 @@ var (\n \tch8 = <-rc\n \tch9 = <-sc /* ERROR \"cannot receive\" */\n )\n+\n+// address of composite literals\n+type T struct{x, y int}\n+\n+func f() T { return T{} }\n+\n+var (\n+\t_ = &T{1, 2}\n+\t_ = &[...]int{}\n+\t_ = &[]int{}\n+\t_ = &[]int{}\n+\t_ = &map[string]T{}\n+\t_ = &(T{1, 2})\n+\t_ = &((((T{1, 2}))))\n+\t_ = &f /* ERROR \"cannot take address\" */ ()\n+)", "previous_filename": "libgo/go/exp/types/testdata/expr0.src"}, {"sha": "8ef0aed6d2ea16ed8d811338a04c1f68fab08751", "filename": "libgo/go/go/types/testdata/expr1.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr1.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/expr1.src"}, {"sha": "674be4005dd5c0a34c394a003d33f0de17a77c9b", "filename": "libgo/go/go/types/testdata/expr2.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr2.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr2.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr2.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "previous_filename": "libgo/go/exp/types/testdata/expr2.src"}, {"sha": "519e3f567ac48f6f6ce9478013778c5db8d7146e", "filename": "libgo/go/go/types/testdata/expr3.src", "status": "renamed", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexpr3.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -246,8 +246,17 @@ func slice_literals() {\n \t_ = S0{2.0}\n \t_ = S0{2.1 /* ERROR \"cannot use\" */ }\n \t_ = S0{\"foo\" /* ERROR \"cannot use\" */ }\n+\n+\t// indices must be resolved correctly\n+\t// (for details, see comment in go/parser/parser.go, method parseElement)\n+\tindex1 := 1\n+\t_ = S0{index1: 1}\n+\t_ = S0{index2: 2}\n+\t_ = S0{index3 /* ERROR \"undeclared name\" */ : 3}\n }\n \n+var index2 int = 2\n+\n func map_literals() {\n \ttype M0 map[string]int\n \n@@ -256,8 +265,17 @@ func map_literals() {\n \t_ = M0{1 /* ERROR \"cannot use .* as string key\" */ : 2}\n \t_ = M0{\"foo\": \"bar\" /* ERROR \"cannot use .* as int value\" */ }\n \t_ = M0{\"foo\": 1, \"bar\": 2, \"foo\" /* ERROR \"duplicate key\" */ : 3 }\n+\n+\t// map keys must be resolved correctly\n+\t// (for detials, see comment in go/parser/parser.go, method parseElement)\n+\tkey1 := \"foo\"\n+\t_ = M0{key1: 1}\n+\t_ = M0{key2: 2}\n+\t_ = M0{key3 /* ERROR \"undeclared name\" */ : 2}\n }\n \n+var key2 string = \"bar\"\n+\n type I interface {\n \tm()\n }", "previous_filename": "libgo/go/exp/types/testdata/expr3.src"}, {"sha": "ca36834fde6d508368b5c75052a3907c9487a01d", "filename": "libgo/go/go/types/testdata/stmt0.src", "status": "renamed", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fstmt0.src?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -261,4 +261,14 @@ func _rangeloops() {\n \t}\n \tfor _ = range sc /* ERROR \"cannot range over send-only channel\" */ {}\n \tfor _ = range rc {}\n+\n+\t// constant strings\n+\tconst cs = \"foo\"\n+\tfor i, x := range cs {}\n+\tfor i, x := range \"\" {\n+\t\tvar ii int\n+\t\tii = i\n+\t\tvar xx rune\n+\t\txx = x\n+\t}\n }\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/testdata/stmt0.src"}, {"sha": "2107a20d16fc48ea53e82ce50fff61b9ce0b5021", "filename": "libgo/go/go/types/types.go", "status": "renamed", "additions": 55, "deletions": 67, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -2,34 +2,13 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package types declares the data structures for representing\n-// Go types and implements typechecking of an *ast.Package.\n-//\n-// PACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n-//\n package types\n \n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"sort\"\n-)\n-\n-// Check typechecks a package pkg. It returns the first error, or nil.\n-//\n-// Check augments the AST by assigning types to ast.Objects. It\n-// calls err with the error position and message for each error.\n-// It calls f with each valid AST expression and corresponding\n-// type. If err == nil, Check terminates as soon as the first error\n-// is found. If f is nil, it is not invoked.\n-//\n-func Check(fset *token.FileSet, pkg *ast.Package, err func(token.Pos, string), f func(ast.Expr, Type)) error {\n-\treturn check(fset, pkg, err, f)\n-}\n+import \"go/ast\"\n \n // All types implement the Type interface.\n-// TODO(gri) Eventually determine what common Type functionality should be exported.\n type Type interface {\n+\tString() string\n \taType()\n }\n \n@@ -93,37 +72,53 @@ const (\n \n // A Basic represents a basic type.\n type Basic struct {\n-\timplementsType\n \tKind BasicKind\n \tInfo BasicInfo\n-\tSize int64 // > 0 if valid\n+\tSize int64\n \tName string\n }\n \n // An Array represents an array type [Len]Elt.\n type Array struct {\n-\timplementsType\n \tLen int64\n \tElt Type\n }\n \n // A Slice represents a slice type []Elt.\n type Slice struct {\n-\timplementsType\n \tElt Type\n }\n \n-type StructField struct {\n-\tName        string // unqualified type name for anonymous fields\n+// A QualifiedName is a name qualified with the package that declared the name.\n+type QualifiedName struct {\n+\tPkg  *Package // nil only for predeclared error.Error\n+\tName string   // unqualified type name for anonymous fields\n+}\n+\n+// IsSame reports whether p and q are the same.\n+func (p QualifiedName) IsSame(q QualifiedName) bool {\n+\t// spec:\n+\t// \"Two identifiers are different if they are spelled differently,\n+\t// or if they appear in different packages and are not exported.\n+\t// Otherwise, they are the same.\"\n+\tif p.Name != q.Name {\n+\t\treturn false\n+\t}\n+\t// p.Name == q.Name\n+\treturn ast.IsExported(p.Name) || p.Pkg == q.Pkg\n+}\n+\n+// A Field represents a field of a struct.\n+type Field struct {\n+\tQualifiedName\n \tType        Type\n \tTag         string\n \tIsAnonymous bool\n }\n \n // A Struct represents a struct type struct{...}.\n type Struct struct {\n-\timplementsType\n-\tFields []*StructField\n+\tFields []*Field\n }\n \n func (typ *Struct) fieldIndex(name string) int {\n@@ -137,25 +132,20 @@ func (typ *Struct) fieldIndex(name string) int {\n \n // A Pointer represents a pointer type *Base.\n type Pointer struct {\n-\timplementsType\n \tBase Type\n }\n \n // A Result represents a (multi-value) function call result.\n-// TODO(gri) consider using an empty Result (Values == nil)\n-//           as representation for the novalue operand mode.\n type Result struct {\n-\timplementsType\n-\tValues ObjList // Signature.Results of the function called\n+\tValues []*Var // Signature.Results of the function called\n }\n \n // A Signature represents a user-defined function type func(...) (...).\n type Signature struct {\n-\timplementsType\n-\tRecv       *ast.Object // nil if not a method\n-\tParams     ObjList     // (incoming) parameters from left to right; or nil\n-\tResults    ObjList     // (outgoing) results from left to right; or nil\n-\tIsVariadic bool        // true if the last parameter's type is of the form ...T\n+\tRecv       *Var   // nil if not a method\n+\tParams     []*Var // (incoming) parameters from left to right; or nil\n+\tResults    []*Var // (outgoing) results from left to right; or nil\n+\tIsVariadic bool   // true if the last parameter's type is of the form ...T\n }\n \n // builtinId is an id of a builtin function.\n@@ -192,53 +182,51 @@ const (\n \n // A builtin represents the type of a built-in function.\n type builtin struct {\n-\timplementsType\n \tid          builtinId\n \tname        string\n \tnargs       int // number of arguments (minimum if variadic)\n \tisVariadic  bool\n \tisStatement bool // true if the built-in is valid as an expression statement\n }\n \n+// A Method represents a method.\n+type Method struct {\n+\tQualifiedName\n+\tType *Signature\n+}\n+\n // An Interface represents an interface type interface{...}.\n type Interface struct {\n-\timplementsType\n-\tMethods ObjList // interface methods sorted by name; or nil\n+\tMethods []*Method // TODO(gri) consider keeping them in sorted order\n }\n \n // A Map represents a map type map[Key]Elt.\n type Map struct {\n-\timplementsType\n \tKey, Elt Type\n }\n \n // A Chan represents a channel type chan Elt, <-chan Elt, or chan<-Elt.\n type Chan struct {\n-\timplementsType\n \tDir ast.ChanDir\n \tElt Type\n }\n \n // A NamedType represents a named type as declared in a type declaration.\n type NamedType struct {\n-\timplementsType\n-\tObj        *ast.Object // corresponding declared object; Obj.Data.(*ast.Scope) contains methods, if any\n-\tUnderlying Type        // nil if not fully declared yet; never a *NamedType\n-}\n-\n-// An ObjList represents an ordered (in some fashion) list of objects.\n-type ObjList []*ast.Object\n-\n-// ObjList implements sort.Interface.\n-func (list ObjList) Len() int           { return len(list) }\n-func (list ObjList) Less(i, j int) bool { return list[i].Name < list[j].Name }\n-func (list ObjList) Swap(i, j int)      { list[i], list[j] = list[j], list[i] }\n-\n-// Sort sorts an object list by object name.\n-func (list ObjList) Sort() { sort.Sort(list) }\n-\n-// All concrete types embed implementsType which\n-// ensures that all types implement the Type interface.\n-type implementsType struct{}\n-\n-func (*implementsType) aType() {}\n+\tObj        *TypeName // corresponding declared object\n+\tUnderlying Type      // nil if not fully declared yet; never a *NamedType\n+\tMethods    []*Method // TODO(gri) consider keeping them in sorted order\n+}\n+\n+func (*Basic) aType()     {}\n+func (*Array) aType()     {}\n+func (*Slice) aType()     {}\n+func (*Struct) aType()    {}\n+func (*Pointer) aType()   {}\n+func (*Result) aType()    {}\n+func (*Signature) aType() {}\n+func (*builtin) aType()   {}\n+func (*Interface) aType() {}\n+func (*Map) aType()       {}\n+func (*Chan) aType()      {}\n+func (*NamedType) aType() {}", "previous_filename": "libgo/go/exp/types/types.go"}, {"sha": "8e228fa677e9dcae97b538a6bf34afb6a77ef7e8", "filename": "libgo/go/go/types/types_test.go", "status": "renamed", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,20 +15,13 @@ import (\n \n const filename = \"<src>\"\n \n-func makePkg(t *testing.T, src string) (*ast.Package, error) {\n+func makePkg(t *testing.T, src string) (*Package, error) {\n \tfile, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tfiles := map[string]*ast.File{filename: file}\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif err := Check(fset, pkg, nil, nil); err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn pkg, nil\n+\tpkg, err := Check(fset, []*ast.File{file})\n+\treturn pkg, err\n }\n \n type testEntry struct {\n@@ -96,10 +89,7 @@ var testTypes = []testEntry{\n \t// interfaces\n \tdup(\"interface{}\"),\n \tdup(\"interface{m()}\"),\n-\t{`interface{\n-\t\tm(int) float32\n-\t\tString() string\n-\t}`, `interface{String() string; m(int) float32}`}, // methods are sorted\n+\tdup(`interface{m(int) float32; String() string}`),\n \t// TODO(gri) add test for interface w/ anonymous field\n \n \t// maps\n@@ -120,7 +110,7 @@ func TestTypes(t *testing.T) {\n \t\t\tt.Errorf(\"%s: %s\", src, err)\n \t\t\tcontinue\n \t\t}\n-\t\ttyp := underlying(pkg.Scope.Lookup(\"T\").Type.(Type))\n+\t\ttyp := underlying(pkg.Scope.Lookup(\"T\").GetType())\n \t\tstr := typeString(typ)\n \t\tif str != test.str {\n \t\t\tt.Errorf(\"%s: got %s, want %s\", test.src, str, test.str)\n@@ -164,14 +154,14 @@ var testExprs = []testEntry{\n func TestExprs(t *testing.T) {\n \tfor _, test := range testExprs {\n \t\tsrc := \"package p; var _ = \" + test.src + \"; var (x, y int; s []string; f func(int, float32) int; i interface{}; t interface { foo() })\"\n-\t\tpkg, err := makePkg(t, src)\n+\t\tfile, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s: %s\", src, err)\n \t\t\tcontinue\n \t\t}\n \t\t// TODO(gri) writing the code below w/o the decl variable will\n \t\t//           cause a 386 compiler error (out of fixed registers)\n-\t\tdecl := pkg.Files[filename].Decls[0].(*ast.GenDecl)\n+\t\tdecl := file.Decls[0].(*ast.GenDecl)\n \t\texpr := decl.Specs[0].(*ast.ValueSpec).Values[0]\n \t\tstr := exprString(expr)\n \t\tif str != test.str {", "previous_filename": "libgo/go/exp/types/types_test.go"}, {"sha": "8e9f6aaa09f4ddca3d88aecaac374df684886348", "filename": "libgo/go/go/types/universe.go", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements the universe and unsafe package scopes.\n+\n+package types\n+\n+import (\n+\t\"go/ast\"\n+\t\"strings\"\n+)\n+\n+var (\n+\tUniverse     *Scope\n+\tUnsafe       *Package\n+\tuniverseIota *Const\n+)\n+\n+// Predeclared types, indexed by BasicKind.\n+var Typ = [...]*Basic{\n+\tInvalid: {Invalid, 0, 0, \"invalid type\"},\n+\n+\tBool:          {Bool, IsBoolean, 1, \"bool\"},\n+\tInt:           {Int, IsInteger, 0, \"int\"},\n+\tInt8:          {Int8, IsInteger, 1, \"int8\"},\n+\tInt16:         {Int16, IsInteger, 2, \"int16\"},\n+\tInt32:         {Int32, IsInteger, 4, \"int32\"},\n+\tInt64:         {Int64, IsInteger, 8, \"int64\"},\n+\tUint:          {Uint, IsInteger | IsUnsigned, 0, \"uint\"},\n+\tUint8:         {Uint8, IsInteger | IsUnsigned, 1, \"uint8\"},\n+\tUint16:        {Uint16, IsInteger | IsUnsigned, 2, \"uint16\"},\n+\tUint32:        {Uint32, IsInteger | IsUnsigned, 4, \"uint32\"},\n+\tUint64:        {Uint64, IsInteger | IsUnsigned, 8, \"uint64\"},\n+\tUintptr:       {Uintptr, IsInteger | IsUnsigned, 0, \"uintptr\"},\n+\tFloat32:       {Float32, IsFloat, 4, \"float32\"},\n+\tFloat64:       {Float64, IsFloat, 8, \"float64\"},\n+\tComplex64:     {Complex64, IsComplex, 8, \"complex64\"},\n+\tComplex128:    {Complex128, IsComplex, 16, \"complex128\"},\n+\tString:        {String, IsString, 0, \"string\"},\n+\tUnsafePointer: {UnsafePointer, 0, 0, \"Pointer\"},\n+\n+\tUntypedBool:    {UntypedBool, IsBoolean | IsUntyped, 0, \"untyped boolean\"},\n+\tUntypedInt:     {UntypedInt, IsInteger | IsUntyped, 0, \"untyped integer\"},\n+\tUntypedRune:    {UntypedRune, IsInteger | IsUntyped, 0, \"untyped rune\"},\n+\tUntypedFloat:   {UntypedFloat, IsFloat | IsUntyped, 0, \"untyped float\"},\n+\tUntypedComplex: {UntypedComplex, IsComplex | IsUntyped, 0, \"untyped complex\"},\n+\tUntypedString:  {UntypedString, IsString | IsUntyped, 0, \"untyped string\"},\n+\tUntypedNil:     {UntypedNil, IsUntyped, 0, \"untyped nil\"},\n+}\n+\n+var aliases = [...]*Basic{\n+\t{Byte, IsInteger | IsUnsigned, 1, \"byte\"},\n+\t{Rune, IsInteger, 4, \"rune\"},\n+}\n+\n+var predeclaredConstants = [...]*Const{\n+\t{\"true\", Typ[UntypedBool], true, nil},\n+\t{\"false\", Typ[UntypedBool], false, nil},\n+\t{\"iota\", Typ[UntypedInt], zeroConst, nil},\n+\t{\"nil\", Typ[UntypedNil], nilConst, nil},\n+}\n+\n+var predeclaredFunctions = [...]*builtin{\n+\t{_Append, \"append\", 1, true, false},\n+\t{_Cap, \"cap\", 1, false, false},\n+\t{_Close, \"close\", 1, false, true},\n+\t{_Complex, \"complex\", 2, false, false},\n+\t{_Copy, \"copy\", 2, false, true},\n+\t{_Delete, \"delete\", 2, false, true},\n+\t{_Imag, \"imag\", 1, false, false},\n+\t{_Len, \"len\", 1, false, false},\n+\t{_Make, \"make\", 1, true, false},\n+\t{_New, \"new\", 1, false, false},\n+\t{_Panic, \"panic\", 1, false, true},\n+\t{_Print, \"print\", 1, true, true},\n+\t{_Println, \"println\", 1, true, true},\n+\t{_Real, \"real\", 1, false, false},\n+\t{_Recover, \"recover\", 0, false, true},\n+\n+\t{_Alignof, \"Alignof\", 1, false, false},\n+\t{_Offsetof, \"Offsetof\", 1, false, false},\n+\t{_Sizeof, \"Sizeof\", 1, false, false},\n+}\n+\n+func init() {\n+\tUniverse = new(Scope)\n+\tUnsafe = &Package{Name: \"unsafe\", Scope: new(Scope)}\n+\n+\t// predeclared types\n+\tfor _, t := range Typ {\n+\t\tdef(&TypeName{Name: t.Name, Type: t})\n+\t}\n+\tfor _, t := range aliases {\n+\t\tdef(&TypeName{Name: t.Name, Type: t})\n+\t}\n+\n+\t// error type\n+\t{\n+\t\t// Error has a nil package in its qualified name since it is in no package\n+\t\terr := &Method{QualifiedName{nil, \"Error\"}, &Signature{Results: []*Var{{Name: \"\", Type: Typ[String]}}}}\n+\t\tdef(&TypeName{Name: \"error\", Type: &NamedType{Underlying: &Interface{Methods: []*Method{err}}}})\n+\t}\n+\n+\tfor _, c := range predeclaredConstants {\n+\t\tdef(c)\n+\t}\n+\n+\tfor _, f := range predeclaredFunctions {\n+\t\tdef(&Func{Name: f.name, Type: f})\n+\t}\n+\n+\tuniverseIota = Universe.Lookup(\"iota\").(*Const)\n+}\n+\n+// Objects with names containing blanks are internal and not entered into\n+// a scope. Objects with exported names are inserted in the unsafe package\n+// scope; other objects are inserted in the universe scope.\n+//\n+func def(obj Object) {\n+\tname := obj.GetName()\n+\tif strings.Index(name, \" \") >= 0 {\n+\t\treturn // nothing to do\n+\t}\n+\t// fix Obj link for named types\n+\tif typ, ok := obj.GetType().(*NamedType); ok {\n+\t\ttyp.Obj = obj.(*TypeName)\n+\t}\n+\t// exported identifiers go into package unsafe\n+\tscope := Universe\n+\tif ast.IsExported(name) {\n+\t\tscope = Unsafe.Scope\n+\t}\n+\tif scope.Insert(obj) != nil {\n+\t\tpanic(\"internal error: double declaration\")\n+\t}\n+}"}, {"sha": "4829bfcc438b106148a6a7b16baf6eb0153872e7", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -220,10 +220,7 @@ func ensurePipelineContains(p *parse.PipeNode, s []string) {\n \tidents := p.Cmds\n \tfor i := n - 1; i >= 0; i-- {\n \t\tif cmd := p.Cmds[i]; len(cmd.Args) != 0 {\n-\t\t\tif id, ok := cmd.Args[0].(*parse.IdentifierNode); ok {\n-\t\t\t\tif id.Ident == \"noescape\" {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\t\t\tif _, ok := cmd.Args[0].(*parse.IdentifierNode); ok {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}"}, {"sha": "de3659ba8fefaa885414b0bca0abdefa9dcfb2bc", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -550,11 +550,6 @@ func TestEscape(t *testing.T) {\n \t\t\t\"<textarea>{{range .A}}{{.}}{{end}}</textarea>\",\n \t\t\t\"<textarea>&lt;a&gt;&lt;b&gt;</textarea>\",\n \t\t},\n-\t\t{\n-\t\t\t\"auditable exemption from escaping\",\n-\t\t\t\"{{range .A}}{{. | noescape}}{{end}}\",\n-\t\t\t\"<a><b>\",\n-\t\t},\n \t\t{\n \t\t\t\"No tag injection\",\n \t\t\t`{{\"10$\"}}<{{\"script src,evil.org/pwnd.js\"}}...`,\n@@ -659,12 +654,6 @@ func TestEscape(t *testing.T) {\n \n \tfor _, test := range tests {\n \t\ttmpl := New(test.name)\n-\t\t// TODO: Move noescape into template/func.go\n-\t\ttmpl.Funcs(FuncMap{\n-\t\t\t\"noescape\": func(a ...interface{}) string {\n-\t\t\t\treturn fmt.Sprint(a...)\n-\t\t\t},\n-\t\t})\n \t\ttmpl = Must(tmpl.Parse(test.input))\n \t\tb := new(bytes.Buffer)\n \t\tif err := tmpl.Execute(b, data); err != nil {"}, {"sha": "768cee7d5fd220acfb22f66a017408eab7b0044c", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -14,8 +14,8 @@ import (\n \t\"text/template/parse\"\n )\n \n-// Template is a specialized template.Template that produces a safe HTML\n-// document fragment.\n+// Template is a specialized Template from \"text/template\" that produces a safe\n+// HTML document fragment.\n type Template struct {\n \tescaped bool\n \t// We could embed the text/template field, but it's safer not to because\n@@ -238,7 +238,8 @@ func (t *Template) Name() string {\n // return values of which the second has type error. In that case, if the\n // second (error) argument evaluates to non-nil during execution, execution\n // terminates and Execute returns that error. FuncMap has the same base type\n-// as template.FuncMap, copied here so clients need not import \"text/template\".\n+// as FuncMap in \"text/template\", copied here so clients need not import\n+// \"text/template\".\n type FuncMap map[string]interface{}\n \n // Funcs adds the elements of the argument map to the template's function map.\n@@ -268,7 +269,10 @@ func (t *Template) Lookup(name string) *Template {\n \treturn t.set[name]\n }\n \n-// Must panics if err is non-nil in the same way as template.Must.\n+// Must is a helper that wraps a call to a function returning (*Template, error)\n+// and panics if the error is non-nil. It is intended for use in variable initializations\n+// such as\n+//\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n func Must(t *Template, err error) *Template {\n \tif err != nil {\n \t\tpanic(err)"}, {"sha": "36635bcc538fed6bbbe1a8d102194016fb3a5c5d", "filename": "libgo/go/image/format.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fformat.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -39,7 +39,7 @@ type reader interface {\n \tPeek(int) ([]byte, error)\n }\n \n-// AsReader converts an io.Reader to a reader.\n+// asReader converts an io.Reader to a reader.\n func asReader(r io.Reader) reader {\n \tif rr, ok := r.(reader); ok {\n \t\treturn rr"}, {"sha": "1ee6bbcd1acc04055c9bb5161ad56687f90f7584", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -147,14 +147,27 @@ func (d *decoder) processSOF(n int) error {\n \t\treturn UnsupportedError(\"SOF has wrong number of image components\")\n \t}\n \tfor i := 0; i < d.nComp; i++ {\n-\t\thv := d.tmp[7+3*i]\n-\t\td.comp[i].h = int(hv >> 4)\n-\t\td.comp[i].v = int(hv & 0x0f)\n \t\td.comp[i].c = d.tmp[6+3*i]\n \t\td.comp[i].tq = d.tmp[8+3*i]\n \t\tif d.nComp == nGrayComponent {\n+\t\t\t// If a JPEG image has only one component, section A.2 says \"this data\n+\t\t\t// is non-interleaved by definition\" and section A.2.2 says \"[in this\n+\t\t\t// case...] the order of data units within a scan shall be left-to-right\n+\t\t\t// and top-to-bottom... regardless of the values of H_1 and V_1\". Section\n+\t\t\t// 4.8.2 also says \"[for non-interleaved data], the MCU is defined to be\n+\t\t\t// one data unit\". Similarly, section A.1.1 explains that it is the ratio\n+\t\t\t// of H_i to max_j(H_j) that matters, and similarly for V. For grayscale\n+\t\t\t// images, H_1 is the maximum H_j for all components j, so that ratio is\n+\t\t\t// always 1. The component's (h, v) is effectively always (1, 1): even if\n+\t\t\t// the nominal (h, v) is (2, 1), a 20x5 image is encoded in three 8x8\n+\t\t\t// MCUs, not two 16x8 MCUs.\n+\t\t\td.comp[i].h = 1\n+\t\t\td.comp[i].v = 1\n \t\t\tcontinue\n \t\t}\n+\t\thv := d.tmp[7+3*i]\n+\t\td.comp[i].h = int(hv >> 4)\n+\t\td.comp[i].v = int(hv & 0x0f)\n \t\t// For color images, we only support 4:4:4, 4:4:0, 4:2:2 or 4:2:0 chroma\n \t\t// downsampling ratios. This implies that the (h, v) values for the Y\n \t\t// component are either (1, 1), (1, 2), (2, 1) or (2, 2), and the (h, v)"}, {"sha": "b520a8ab18c684044bd9f66ca80c3396b61159a8", "filename": "libgo/go/image/jpeg/reader_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -24,6 +24,7 @@ func TestDecodeProgressive(t *testing.T) {\n \t\t\"../testdata/video-001.q50.440\",\n \t\t\"../testdata/video-001.q50.444\",\n \t\t\"../testdata/video-005.gray.q50\",\n+\t\t\"../testdata/video-005.gray.q50.2x2\",\n \t}\n \tfor _, tc := range testCases {\n \t\tm0, err := decodeFile(tc + \".jpeg\")"}, {"sha": "c58fbf305553e58134c9b8a5899d9a49adccc7f3", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -210,8 +210,8 @@ func init() {\n // writer is a buffered writer.\n type writer interface {\n \tFlush() error\n-\tWrite([]byte) (int, error)\n-\tWriteByte(byte) error\n+\tio.Writer\n+\tio.ByteWriter\n }\n \n // encoder encodes an image to the JPEG format."}, {"sha": "630b615f73ad3ef5590f572340cbc9070efc2088", "filename": "libgo/go/image/testdata/video-005.gray.q50.2x2.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.jpeg?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "c6b93608cb7a28a2a79653496057063fdfd179a4", "filename": "libgo/go/image/testdata/video-005.gray.q50.2x2.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.2x2.progressive.jpeg?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "101d2c12153e6538bd33c3dea8fd65497d6a502c", "filename": "libgo/go/io/ioutil/blackhole.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -2,12 +2,22 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !race\n-\n package ioutil\n \n-var blackHoleBuf = make([]byte, 8192)\n+var blackHoleBuf = make(chan []byte, 1)\n \n func blackHole() []byte {\n-\treturn blackHoleBuf\n+\tselect {\n+\tcase b := <-blackHoleBuf:\n+\t\treturn b\n+\tdefault:\n+\t}\n+\treturn make([]byte, 8192)\n+}\n+\n+func blackHolePut(p []byte) {\n+\tselect {\n+\tcase blackHoleBuf <- p:\n+\tdefault:\n+\t}\n }"}, {"sha": "eb640e05cfba8a0a134ed0ad2ad286d553f994d6", "filename": "libgo/go/io/ioutil/blackhole_race.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole_race.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole_race.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fblackhole_race.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build race\n-\n-package ioutil\n-\n-// Replaces the normal fast implementation with slower but formally correct one.\n-\n-func blackHole() []byte {\n-\treturn make([]byte, 8192)\n-}"}, {"sha": "0eb146c0ab75598d082aeb4d247d0bd48629874a", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -132,6 +132,7 @@ func (devNull) Write(p []byte) (int, error) {\n \n func (devNull) ReadFrom(r io.Reader) (n int64, err error) {\n \tbuf := blackHole()\n+\tdefer blackHolePut(buf)\n \treadSize := 0\n \tfor {\n \t\treadSize, err = r.Read(buf)"}, {"sha": "98b9c5f6e8773d799febe617f8584fc642803618", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -202,14 +202,14 @@ func (w *Writer) writeString(p Priority, s string) (int, error) {\n }\n \n // writeString: generates and writes a syslog formatted string. The\n-// format is as follows: <PRI>1 TIMESTAMP HOSTNAME TAG[PID]: MSG\n+// format is as follows: <PRI>TIMESTAMP HOSTNAME TAG[PID]: MSG\n func (n netConn) writeString(p Priority, hostname, tag, msg string) (int, error) {\n \tnl := \"\"\n \tif len(msg) == 0 || msg[len(msg)-1] != '\\n' {\n \t\tnl = \"\\n\"\n \t}\n \ttimestamp := time.Now().Format(time.RFC3339)\n-\tif _, err := fmt.Fprintf(n.conn, \"<%d>1 %s %s %s[%d]: %s%s\", p, timestamp, hostname,\n+\tif _, err := fmt.Fprintf(n.conn, \"<%d>%s %s %s[%d]: %s%s\", p, timestamp, hostname,\n \t\ttag, os.Getpid(), msg, nl); err != nil {\n \t\treturn 0, err\n \t}"}, {"sha": "0c05f6f83c0cd7886f87000b54b34f6610dda291", "filename": "libgo/go/log/syslog/syslog_plan9.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_plan9.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package syslog provides a simple interface to the system log service.\n+package syslog\n+\n+// BUG(akumar): This package is not implemented on Plan 9 yet."}, {"sha": "3770b34d41c89dea4b1a7674d54cf3a63e1d8c96", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -41,23 +41,14 @@ func startServer(done chan<- string) {\n \tgo runSyslog(c, done)\n }\n \n-func skipNetTest(t *testing.T) bool {\n-\tif testing.Short() {\n-\t\t// Depends on syslog daemon running, and sometimes it's not.\n-\t\tt.Logf(\"skipping syslog test during -short\")\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func TestNew(t *testing.T) {\n \tif LOG_LOCAL7 != 23<<3 {\n \t\tt.Fatalf(\"LOG_LOCAL7 has wrong value\")\n \t}\n-\tif skipNetTest(t) {\n-\t\treturn\n+\tif testing.Short() {\n+\t\t// Depends on syslog daemon running, and sometimes it's not.\n+\t\tt.Skip(\"skipping syslog test during -short\")\n \t}\n-\n \ts, err := New(LOG_INFO|LOG_USER, \"\")\n \tif err != nil {\n \t\tt.Fatalf(\"New() failed: %s\", err)\n@@ -67,8 +58,8 @@ func TestNew(t *testing.T) {\n }\n \n func TestNewLogger(t *testing.T) {\n-\tif skipNetTest(t) {\n-\t\treturn\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping syslog test during -short\")\n \t}\n \tf, err := NewLogger(LOG_USER|LOG_INFO, 0)\n \tif f == nil {\n@@ -77,8 +68,8 @@ func TestNewLogger(t *testing.T) {\n }\n \n func TestDial(t *testing.T) {\n-\tif skipNetTest(t) {\n-\t\treturn\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping syslog test during -short\")\n \t}\n \tf, err := Dial(\"\", \"\", (LOG_LOCAL7|LOG_DEBUG)+1, \"syslog_test\")\n \tif f != nil {\n@@ -104,16 +95,15 @@ func TestUDPDial(t *testing.T) {\n \t}\n \tmsg := \"udp test\"\n \tl.Info(msg)\n-\texpected := fmt.Sprintf(\"<%d>1 \", LOG_USER+LOG_INFO) + \"%s %s syslog_test[%d]: udp test\\n\"\n+\texpected := fmt.Sprintf(\"<%d>\", LOG_USER+LOG_INFO) + \"%s %s syslog_test[%d]: udp test\\n\"\n \trcvd := <-done\n \tvar parsedHostname, timestamp string\n \tvar pid int\n \tif hostname, err := os.Hostname(); err != nil {\n \t\tt.Fatalf(\"Error retrieving hostname\")\n \t} else {\n-\t\tif n, err := fmt.Sscanf(rcvd, expected, &timestamp, &parsedHostname, &pid); n != 3 ||\n-\t\t\terr != nil || hostname != parsedHostname {\n-\t\t\tt.Fatalf(\"s.Info() = '%q', didn't match '%q'\", rcvd, expected)\n+\t\tif n, err := fmt.Sscanf(rcvd, expected, &timestamp, &parsedHostname, &pid); n != 3 || err != nil || hostname != parsedHostname {\n+\t\t\tt.Fatalf(\"'%q', didn't match '%q' (%d, %s)\", rcvd, expected, n, err)\n \t\t}\n \t}\n }\n@@ -146,12 +136,13 @@ func TestWrite(t *testing.T) {\n \t\t\t\tt.Fatalf(\"WriteString() failed: %s\", err)\n \t\t\t}\n \t\t\trcvd := <-done\n-\t\t\ttest.exp = fmt.Sprintf(\"<%d>1 \", test.pri) + test.exp\n+\t\t\ttest.exp = fmt.Sprintf(\"<%d>\", test.pri) + test.exp\n \t\t\tvar parsedHostname, timestamp string\n \t\t\tvar pid int\n-\t\t\tif n, err := fmt.Sscanf(rcvd, test.exp, &timestamp, &parsedHostname, &pid); n != 3 ||\n-\t\t\t\terr != nil || hostname != parsedHostname {\n-\t\t\t\tt.Fatalf(\"s.Info() = '%q', didn't match '%q'\", rcvd, test.exp)\n+\t\t\tif n, err := fmt.Sscanf(rcvd, test.exp, &timestamp, &parsedHostname,\n+\t\t\t\t&pid); n != 3 || err != nil || hostname != parsedHostname {\n+\t\t\t\tt.Fatalf(\"'%q', didn't match '%q' (%d %s)\", rcvd, test.exp,\n+\t\t\t\t\tn, err)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "bf2fd200926d2efb680b5d69b642c743125cb697", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -526,7 +526,7 @@ func (x *Int) Int64() int64 {\n \treturn v\n }\n \n-// Uint64 returns the int64 representation of x.\n+// Uint64 returns the uint64 representation of x.\n // If x cannot be represented in an uint64, the result is undefined.\n func (x *Int) Uint64() uint64 {\n \tif len(x.abs) == 0 {"}, {"sha": "6c981e7752e462fc82ecffa167912eec25310737", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -643,7 +643,7 @@ func TestSetBytes(t *testing.T) {\n \n func checkBytes(b []byte) bool {\n \tb2 := new(Int).SetBytes(b).Bytes()\n-\treturn bytes.Compare(b, b2) == 0\n+\treturn bytes.Equal(b, b2)\n }\n \n func TestBytes(t *testing.T) {"}, {"sha": "3e6473d92243a1fc42eab8b29a801fb3c60c0207", "filename": "libgo/go/math/big/rat.go", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"encoding/binary\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"math\"\n \t\"strings\"\n )\n \n@@ -27,6 +28,156 @@ func NewRat(a, b int64) *Rat {\n \treturn new(Rat).SetFrac64(a, b)\n }\n \n+// SetFloat64 sets z to exactly f and returns z.\n+// If f is not finite, SetFloat returns nil.\n+func (z *Rat) SetFloat64(f float64) *Rat {\n+\tconst expMask = 1<<11 - 1\n+\tbits := math.Float64bits(f)\n+\tmantissa := bits & (1<<52 - 1)\n+\texp := int((bits >> 52) & expMask)\n+\tswitch exp {\n+\tcase expMask: // non-finite\n+\t\treturn nil\n+\tcase 0: // denormal\n+\t\texp -= 1022\n+\tdefault: // normal\n+\t\tmantissa |= 1 << 52\n+\t\texp -= 1023\n+\t}\n+\n+\tshift := 52 - exp\n+\n+\t// Optimisation (?): partially pre-normalise.\n+\tfor mantissa&1 == 0 && shift > 0 {\n+\t\tmantissa >>= 1\n+\t\tshift--\n+\t}\n+\n+\tz.a.SetUint64(mantissa)\n+\tz.a.neg = f < 0\n+\tz.b.Set(intOne)\n+\tif shift > 0 {\n+\t\tz.b.Lsh(&z.b, uint(shift))\n+\t} else {\n+\t\tz.a.Lsh(&z.a, uint(-shift))\n+\t}\n+\treturn z.norm()\n+}\n+\n+// isFinite reports whether f represents a finite rational value.\n+// It is equivalent to !math.IsNan(f) && !math.IsInf(f, 0).\n+func isFinite(f float64) bool {\n+\treturn math.Abs(f) <= math.MaxFloat64\n+}\n+\n+// low64 returns the least significant 64 bits of natural number z.\n+func low64(z nat) uint64 {\n+\tif len(z) == 0 {\n+\t\treturn 0\n+\t}\n+\tif _W == 32 && len(z) > 1 {\n+\t\treturn uint64(z[1])<<32 | uint64(z[0])\n+\t}\n+\treturn uint64(z[0])\n+}\n+\n+// quotToFloat returns the non-negative IEEE 754 double-precision\n+// value nearest to the quotient a/b, using round-to-even in halfway\n+// cases.  It does not mutate its arguments.\n+// Preconditions: b is non-zero; a and b have no common factors.\n+func quotToFloat(a, b nat) (f float64, exact bool) {\n+\t// TODO(adonovan): specialize common degenerate cases: 1.0, integers.\n+\talen := a.bitLen()\n+\tif alen == 0 {\n+\t\treturn 0, true\n+\t}\n+\tblen := b.bitLen()\n+\tif blen == 0 {\n+\t\tpanic(\"division by zero\")\n+\t}\n+\n+\t// 1. Left-shift A or B such that quotient A/B is in [1<<53, 1<<55).\n+\t// (54 bits if A<B when they are left-aligned, 55 bits if A>=B.)\n+\t// This is 2 or 3 more than the float64 mantissa field width of 52:\n+\t// - the optional extra bit is shifted away in step 3 below.\n+\t// - the high-order 1 is omitted in float64 \"normal\" representation;\n+\t// - the low-order 1 will be used during rounding then discarded.\n+\texp := alen - blen\n+\tvar a2, b2 nat\n+\ta2 = a2.set(a)\n+\tb2 = b2.set(b)\n+\tif shift := 54 - exp; shift > 0 {\n+\t\ta2 = a2.shl(a2, uint(shift))\n+\t} else if shift < 0 {\n+\t\tb2 = b2.shl(b2, uint(-shift))\n+\t}\n+\n+\t// 2. Compute quotient and remainder (q, r).  NB: due to the\n+\t// extra shift, the low-order bit of q is logically the\n+\t// high-order bit of r.\n+\tvar q nat\n+\tq, r := q.div(a2, a2, b2) // (recycle a2)\n+\tmantissa := low64(q)\n+\thaveRem := len(r) > 0 // mantissa&1 && !haveRem => remainder is exactly half\n+\n+\t// 3. If quotient didn't fit in 54 bits, re-do division by b2<<1\n+\t// (in effect---we accomplish this incrementally).\n+\tif mantissa>>54 == 1 {\n+\t\tif mantissa&1 == 1 {\n+\t\t\thaveRem = true\n+\t\t}\n+\t\tmantissa >>= 1\n+\t\texp++\n+\t}\n+\tif mantissa>>53 != 1 {\n+\t\tpanic(\"expected exactly 54 bits of result\")\n+\t}\n+\n+\t// 4. Rounding.\n+\tif -1022-52 <= exp && exp <= -1022 {\n+\t\t// Denormal case; lose 'shift' bits of precision.\n+\t\tshift := uint64(-1022 - (exp - 1)) // [1..53)\n+\t\tlostbits := mantissa & (1<<shift - 1)\n+\t\thaveRem = haveRem || lostbits != 0\n+\t\tmantissa >>= shift\n+\t\texp = -1023 + 2\n+\t}\n+\t// Round q using round-half-to-even.\n+\texact = !haveRem\n+\tif mantissa&1 != 0 {\n+\t\texact = false\n+\t\tif haveRem || mantissa&2 != 0 {\n+\t\t\tif mantissa++; mantissa >= 1<<54 {\n+\t\t\t\t// Complete rollover 11...1 => 100...0, so shift is safe\n+\t\t\t\tmantissa >>= 1\n+\t\t\t\texp++\n+\t\t\t}\n+\t\t}\n+\t}\n+\tmantissa >>= 1 // discard rounding bit.  Mantissa now scaled by 2^53.\n+\n+\tf = math.Ldexp(float64(mantissa), exp-53)\n+\tif math.IsInf(f, 0) {\n+\t\texact = false\n+\t}\n+\treturn\n+}\n+\n+// Float64 returns the nearest float64 value to z.\n+// If z is exactly representable as a float64, Float64 returns exact=true.\n+// If z is negative, so too is f, even if f==0.\n+func (z *Rat) Float64() (f float64, exact bool) {\n+\tb := z.b.abs\n+\tif len(b) == 0 {\n+\t\tb = b.set(natOne) // materialize denominator\n+\t}\n+\tf, exact = quotToFloat(z.a.abs, b)\n+\tif z.a.neg {\n+\t\tf = -f\n+\t}\n+\treturn\n+}\n+\n // SetFrac sets z to a/b and returns z.\n func (z *Rat) SetFrac(a, b *Int) *Rat {\n \tz.a.neg = a.neg != b.neg"}, {"sha": "4b4134b410f7c7042d81523a797e27545aa59256", "filename": "libgo/go/math/big/rat_test.go", "status": "modified", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -8,6 +8,9 @@ import (\n \t\"bytes\"\n \t\"encoding/gob\"\n \t\"fmt\"\n+\t\"math\"\n+\t\"strconv\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -496,3 +499,404 @@ func TestIssue3521(t *testing.T) {\n \t\tt.Errorf(\"3) got %s want %s\", x, q53)\n \t}\n }\n+\n+// Test inputs to Rat.SetString.  The optional prefix \"slow:\" skips\n+// checks found to be slow for certain large rationals.\n+var float64inputs = []string{\n+\t//\n+\t// Constants plundered from strconv/testfp.txt.\n+\t//\n+\n+\t// Table 1: Stress Inputs for Conversion to 53-bit Binary, < 1/2 ULP\n+\t\"5e+125\",\n+\t\"69e+267\",\n+\t\"999e-026\",\n+\t\"7861e-034\",\n+\t\"75569e-254\",\n+\t\"928609e-261\",\n+\t\"9210917e+080\",\n+\t\"84863171e+114\",\n+\t\"653777767e+273\",\n+\t\"5232604057e-298\",\n+\t\"27235667517e-109\",\n+\t\"653532977297e-123\",\n+\t\"3142213164987e-294\",\n+\t\"46202199371337e-072\",\n+\t\"231010996856685e-073\",\n+\t\"9324754620109615e+212\",\n+\t\"78459735791271921e+049\",\n+\t\"272104041512242479e+200\",\n+\t\"6802601037806061975e+198\",\n+\t\"20505426358836677347e-221\",\n+\t\"836168422905420598437e-234\",\n+\t\"4891559871276714924261e+222\",\n+\n+\t// Table 2: Stress Inputs for Conversion to 53-bit Binary, > 1/2 ULP\n+\t\"9e-265\",\n+\t\"85e-037\",\n+\t\"623e+100\",\n+\t\"3571e+263\",\n+\t\"81661e+153\",\n+\t\"920657e-023\",\n+\t\"4603285e-024\",\n+\t\"87575437e-309\",\n+\t\"245540327e+122\",\n+\t\"6138508175e+120\",\n+\t\"83356057653e+193\",\n+\t\"619534293513e+124\",\n+\t\"2335141086879e+218\",\n+\t\"36167929443327e-159\",\n+\t\"609610927149051e-255\",\n+\t\"3743626360493413e-165\",\n+\t\"94080055902682397e-242\",\n+\t\"899810892172646163e+283\",\n+\t\"7120190517612959703e+120\",\n+\t\"25188282901709339043e-252\",\n+\t\"308984926168550152811e-052\",\n+\t\"6372891218502368041059e+064\",\n+\n+\t// Table 14: Stress Inputs for Conversion to 24-bit Binary, <1/2 ULP\n+\t\"5e-20\",\n+\t\"67e+14\",\n+\t\"985e+15\",\n+\t\"7693e-42\",\n+\t\"55895e-16\",\n+\t\"996622e-44\",\n+\t\"7038531e-32\",\n+\t\"60419369e-46\",\n+\t\"702990899e-20\",\n+\t\"6930161142e-48\",\n+\t\"25933168707e+13\",\n+\t\"596428896559e+20\",\n+\n+\t// Table 15: Stress Inputs for Conversion to 24-bit Binary, >1/2 ULP\n+\t\"3e-23\",\n+\t\"57e+18\",\n+\t\"789e-35\",\n+\t\"2539e-18\",\n+\t\"76173e+28\",\n+\t\"887745e-11\",\n+\t\"5382571e-37\",\n+\t\"82381273e-35\",\n+\t\"750486563e-38\",\n+\t\"3752432815e-39\",\n+\t\"75224575729e-45\",\n+\t\"459926601011e+15\",\n+\n+\t//\n+\t// Constants plundered from strconv/atof_test.go.\n+\t//\n+\n+\t\"0\",\n+\t\"1\",\n+\t\"+1\",\n+\t\"1e23\",\n+\t\"1E23\",\n+\t\"100000000000000000000000\",\n+\t\"1e-100\",\n+\t\"123456700\",\n+\t\"99999999999999974834176\",\n+\t\"100000000000000000000001\",\n+\t\"100000000000000008388608\",\n+\t\"100000000000000016777215\",\n+\t\"100000000000000016777216\",\n+\t\"-1\",\n+\t\"-0.1\",\n+\t\"-0\", // NB: exception made for this input\n+\t\"1e-20\",\n+\t\"625e-3\",\n+\n+\t// largest float64\n+\t\"1.7976931348623157e308\",\n+\t\"-1.7976931348623157e308\",\n+\t// next float64 - too large\n+\t\"1.7976931348623159e308\",\n+\t\"-1.7976931348623159e308\",\n+\t// the border is ...158079\n+\t// borderline - okay\n+\t\"1.7976931348623158e308\",\n+\t\"-1.7976931348623158e308\",\n+\t// borderline - too large\n+\t\"1.797693134862315808e308\",\n+\t\"-1.797693134862315808e308\",\n+\n+\t// a little too large\n+\t\"1e308\",\n+\t\"2e308\",\n+\t\"1e309\",\n+\n+\t// way too large\n+\t\"1e310\",\n+\t\"-1e310\",\n+\t\"1e400\",\n+\t\"-1e400\",\n+\t\"1e400000\",\n+\t\"-1e400000\",\n+\n+\t// denormalized\n+\t\"1e-305\",\n+\t\"1e-306\",\n+\t\"1e-307\",\n+\t\"1e-308\",\n+\t\"1e-309\",\n+\t\"1e-310\",\n+\t\"1e-322\",\n+\t// smallest denormal\n+\t\"5e-324\",\n+\t\"4e-324\",\n+\t\"3e-324\",\n+\t// too small\n+\t\"2e-324\",\n+\t// way too small\n+\t\"1e-350\",\n+\t\"slow:1e-400000\",\n+\t// way too small, negative\n+\t\"-1e-350\",\n+\t\"slow:-1e-400000\",\n+\n+\t// try to overflow exponent\n+\t// [Disabled: too slow and memory-hungry with rationals.]\n+\t// \"1e-4294967296\",\n+\t// \"1e+4294967296\",\n+\t// \"1e-18446744073709551616\",\n+\t// \"1e+18446744073709551616\",\n+\n+\t// http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n+\t\"2.2250738585072012e-308\",\n+\t// http://www.exploringbinary.com/php-hangs-on-numeric-value-2-2250738585072011e-308/\n+\n+\t\"2.2250738585072011e-308\",\n+\n+\t// A very large number (initially wrongly parsed by the fast algorithm).\n+\t\"4.630813248087435e+307\",\n+\n+\t// A different kind of very large number.\n+\t\"22.222222222222222\",\n+\t\"2.\" + strings.Repeat(\"2\", 4000) + \"e+1\",\n+\n+\t// Exactly halfway between 1 and math.Nextafter(1, 2).\n+\t// Round to even (down).\n+\t\"1.00000000000000011102230246251565404236316680908203125\",\n+\t// Slightly lower; still round down.\n+\t\"1.00000000000000011102230246251565404236316680908203124\",\n+\t// Slightly higher; round up.\n+\t\"1.00000000000000011102230246251565404236316680908203126\",\n+\t// Slightly higher, but you have to read all the way to the end.\n+\t\"slow:1.00000000000000011102230246251565404236316680908203125\" + strings.Repeat(\"0\", 10000) + \"1\",\n+\n+\t// Smallest denormal, 2^(-1022-52)\n+\t\"4.940656458412465441765687928682213723651e-324\",\n+\t// Half of smallest denormal, 2^(-1022-53)\n+\t\"2.470328229206232720882843964341106861825e-324\",\n+\t// A little more than the exact half of smallest denormal\n+\t// 2^-1075 + 2^-1100.  (Rounds to 1p-1074.)\n+\t\"2.470328302827751011111470718709768633275e-324\",\n+\t// The exact halfway between smallest normal and largest denormal:\n+\t// 2^-1022 - 2^-1075.  (Rounds to 2^-1022.)\n+\t\"2.225073858507201136057409796709131975935e-308\",\n+\n+\t\"1152921504606846975\",  //   1<<60 - 1\n+\t\"-1152921504606846975\", // -(1<<60 - 1)\n+\t\"1152921504606846977\",  //   1<<60 + 1\n+\t\"-1152921504606846977\", // -(1<<60 + 1)\n+\n+\t\"1/3\",\n+}\n+\n+func TestFloat64SpecialCases(t *testing.T) {\n+\tfor _, input := range float64inputs {\n+\t\tslow := strings.HasPrefix(input, \"slow:\")\n+\t\tif slow {\n+\t\t\tinput = input[len(\"slow:\"):]\n+\t\t}\n+\n+\t\tr, ok := new(Rat).SetString(input)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"Rat.SetString(%q) failed\", input)\n+\t\t\tcontinue\n+\t\t}\n+\t\tf, exact := r.Float64()\n+\n+\t\t// 1. Check string -> Rat -> float64 conversions are\n+\t\t// consistent with strconv.ParseFloat.\n+\t\t// Skip this check if the input uses \"a/b\" rational syntax.\n+\t\tif !strings.Contains(input, \"/\") {\n+\t\t\te, _ := strconv.ParseFloat(input, 64)\n+\n+\t\t\t// Careful: negative Rats too small for\n+\t\t\t// float64 become -0, but Rat obviously cannot\n+\t\t\t// preserve the sign from SetString(\"-0\").\n+\t\t\tswitch {\n+\t\t\tcase math.Float64bits(e) == math.Float64bits(f):\n+\t\t\t\t// Ok: bitwise equal.\n+\t\t\tcase f == 0 && r.Num().BitLen() == 0:\n+\t\t\t\t// Ok: Rat(0) is equivalent to both +/- float64(0).\n+\t\t\tdefault:\n+\t\t\t\tt.Errorf(\"strconv.ParseFloat(%q) = %g (%b), want %g (%b); delta=%g\", input, e, e, f, f, f-e)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !isFinite(f) || slow {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// 2. Check f is best approximation to r.\n+\t\tif !checkIsBestApprox(t, f, r) {\n+\t\t\t// Append context information.\n+\t\t\tt.Errorf(\"(input was %q)\", input)\n+\t\t}\n+\n+\t\t// 3. Check f->R->f roundtrip is non-lossy.\n+\t\tcheckNonLossyRoundtrip(t, f)\n+\n+\t\t// 4. Check exactness using slow algorithm.\n+\t\tif wasExact := new(Rat).SetFloat64(f).Cmp(r) == 0; wasExact != exact {\n+\t\t\tt.Errorf(\"Rat.SetString(%q).Float64().exact = %b, want %b\", input, exact, wasExact)\n+\t\t}\n+\t}\n+}\n+\n+func TestFloat64Distribution(t *testing.T) {\n+\t// Generate a distribution of (sign, mantissa, exp) values\n+\t// broader than the float64 range, and check Rat.Float64()\n+\t// always picks the closest float64 approximation.\n+\tvar add = []int64{\n+\t\t0,\n+\t\t1,\n+\t\t3,\n+\t\t5,\n+\t\t7,\n+\t\t9,\n+\t\t11,\n+\t}\n+\tconst winc, einc = 5, 100 // quick test (<1s)\n+\t//const winc, einc = 1, 1 // soak test (~75s)\n+\tfor _, sign := range \"+-\" {\n+\t\tfor _, a := range add {\n+\t\t\tfor wid := uint64(0); wid < 60; wid += winc {\n+\t\t\t\tb := int64(1<<wid + a)\n+\t\t\t\tif sign == '-' {\n+\t\t\t\t\tb = -b\n+\t\t\t\t}\n+\t\t\t\tfor exp := -1100; exp < 1100; exp += einc {\n+\t\t\t\t\tnum, den := NewInt(b), NewInt(1)\n+\t\t\t\t\tif exp > 0 {\n+\t\t\t\t\t\tnum.Lsh(num, uint(exp))\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tden.Lsh(den, uint(-exp))\n+\t\t\t\t\t}\n+\t\t\t\t\tr := new(Rat).SetFrac(num, den)\n+\t\t\t\t\tf, _ := r.Float64()\n+\n+\t\t\t\t\tif !checkIsBestApprox(t, f, r) {\n+\t\t\t\t\t\t// Append context information.\n+\t\t\t\t\t\tt.Errorf(\"(input was mantissa %#x, exp %d; f=%g (%b); f~%g; r=%v)\",\n+\t\t\t\t\t\t\tb, exp, f, f, math.Ldexp(float64(b), exp), r)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcheckNonLossyRoundtrip(t, f)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// TestFloat64NonFinite checks that SetFloat64 of a non-finite value\n+// returns nil.\n+func TestSetFloat64NonFinite(t *testing.T) {\n+\tfor _, f := range []float64{math.NaN(), math.Inf(+1), math.Inf(-1)} {\n+\t\tvar r Rat\n+\t\tif r2 := r.SetFloat64(f); r2 != nil {\n+\t\t\tt.Errorf(\"SetFloat64(%g) was %v, want nil\", f, r2)\n+\t\t}\n+\t}\n+}\n+\n+// checkNonLossyRoundtrip checks that a float->Rat->float roundtrip is\n+// non-lossy for finite f.\n+func checkNonLossyRoundtrip(t *testing.T, f float64) {\n+\tif !isFinite(f) {\n+\t\treturn\n+\t}\n+\tr := new(Rat).SetFloat64(f)\n+\tif r == nil {\n+\t\tt.Errorf(\"Rat.SetFloat64(%g (%b)) == nil\", f, f)\n+\t\treturn\n+\t}\n+\tf2, exact := r.Float64()\n+\tif f != f2 || !exact {\n+\t\tt.Errorf(\"Rat.SetFloat64(%g).Float64() = %g (%b), %v, want %g (%b), %v; delta=%b\",\n+\t\t\tf, f2, f2, exact, f, f, true, f2-f)\n+\t}\n+}\n+\n+// delta returns the absolute difference between r and f.\n+func delta(r *Rat, f float64) *Rat {\n+\td := new(Rat).Sub(r, new(Rat).SetFloat64(f))\n+\treturn d.Abs(d)\n+}\n+\n+// checkIsBestApprox checks that f is the best possible float64\n+// approximation of r.\n+// Returns true on success.\n+func checkIsBestApprox(t *testing.T, f float64, r *Rat) bool {\n+\tif math.Abs(f) >= math.MaxFloat64 {\n+\t\t// Cannot check +Inf, -Inf, nor the float next to them (MaxFloat64).\n+\t\t// But we have tests for these special cases.\n+\t\treturn true\n+\t}\n+\n+\t// r must be strictly between f0 and f1, the floats bracketing f.\n+\tf0 := math.Nextafter(f, math.Inf(-1))\n+\tf1 := math.Nextafter(f, math.Inf(+1))\n+\n+\t// For f to be correct, r must be closer to f than to f0 or f1.\n+\tdf := delta(r, f)\n+\tdf0 := delta(r, f0)\n+\tdf1 := delta(r, f1)\n+\tif df.Cmp(df0) > 0 {\n+\t\tt.Errorf(\"Rat(%v).Float64() = %g (%b), but previous float64 %g (%b) is closer\", r, f, f, f0, f0)\n+\t\treturn false\n+\t}\n+\tif df.Cmp(df1) > 0 {\n+\t\tt.Errorf(\"Rat(%v).Float64() = %g (%b), but next float64 %g (%b) is closer\", r, f, f, f1, f1)\n+\t\treturn false\n+\t}\n+\tif df.Cmp(df0) == 0 && !isEven(f) {\n+\t\tt.Errorf(\"Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead\", r, f, f, f0, f0)\n+\t\treturn false\n+\t}\n+\tif df.Cmp(df1) == 0 && !isEven(f) {\n+\t\tt.Errorf(\"Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead\", r, f, f, f1, f1)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func isEven(f float64) bool { return math.Float64bits(f)&1 == 0 }\n+\n+func TestIsFinite(t *testing.T) {\n+\tfinites := []float64{\n+\t\t1.0 / 3,\n+\t\t4891559871276714924261e+222,\n+\t\tmath.MaxFloat64,\n+\t\tmath.SmallestNonzeroFloat64,\n+\t\t-math.MaxFloat64,\n+\t\t-math.SmallestNonzeroFloat64,\n+\t}\n+\tfor _, f := range finites {\n+\t\tif !isFinite(f) {\n+\t\t\tt.Errorf(\"!IsFinite(%g (%b))\", f, f)\n+\t\t}\n+\t}\n+\tnonfinites := []float64{\n+\t\tmath.NaN(),\n+\t\tmath.Inf(-1),\n+\t\tmath.Inf(+1),\n+\t}\n+\tfor _, f := range nonfinites {\n+\t\tif isFinite(f) {\n+\t\t\tt.Errorf(\"IsFinite(%g, (%b))\", f, f)\n+\t\t}\n+\t}\n+}"}, {"sha": "9b040edd7ba921aa6945cc68cae67f4b5c7c52e9", "filename": "libgo/go/mime/testdata/test.types", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmime%2Ftestdata%2Ftest.types", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmime%2Ftestdata%2Ftest.types", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftestdata%2Ftest.types?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,8 @@\n+# Copyright 2010 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+\n+ # mime package test\n+application/test\tt1\t# Simple test\n+text/test\t\tt2\t# Text test"}, {"sha": "88eb83a735d167b34b157c220cfe22bd00208403", "filename": "libgo/go/mime/type_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmime%2Ftype_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fmime%2Ftype_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -52,7 +52,7 @@ func initMime() {\n }\n \n func initMimeForTests() map[string]string {\n-\ttypeFiles = []string{\"test.types\"}\n+\ttypeFiles = []string{\"testdata/test.types\"}\n \treturn map[string]string{\n \t\t\".t1\":  \"application/test\",\n \t\t\".t2\":  \"text/test; charset=utf-8\","}, {"sha": "354028a157ab4154b61cc4a672359719d525bd2a", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -5,7 +5,6 @@\n package net\n \n import (\n-\t\"runtime\"\n \t\"time\"\n )\n \n@@ -113,30 +112,16 @@ func dialAddr(net, addr string, addri Addr, deadline time.Time) (c Conn, err err\n \treturn\n }\n \n-const useDialTimeoutRace = runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\"\n-\n // DialTimeout acts like Dial but takes a timeout.\n // The timeout includes name resolution, if required.\n func DialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n-\tif useDialTimeoutRace {\n-\t\t// On windows and plan9, use the relatively inefficient\n-\t\t// goroutine-racing implementation of DialTimeout that\n-\t\t// doesn't push down deadlines to the pollster.\n-\t\t// TODO: remove this once those are implemented.\n-\t\treturn dialTimeoutRace(net, addr, timeout)\n-\t}\n-\tdeadline := time.Now().Add(timeout)\n-\t_, addri, err := resolveNetAddr(\"dial\", net, addr, deadline)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn dialAddr(net, addr, addri, deadline)\n+\treturn dialTimeout(net, addr, timeout)\n }\n \n // dialTimeoutRace is the old implementation of DialTimeout, still used\n // on operating systems where the deadline hasn't been pushed down\n // into the pollserver.\n-// TODO: fix this on Windows and plan9.\n+// TODO: fix this on plan9.\n func dialTimeoutRace(net, addr string, timeout time.Duration) (Conn, error) {\n \tt := time.NewTimer(timeout)\n \tdefer t.Stop()"}, {"sha": "aa53b667ded36e15e7814ad4aaeda01d2683b533", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -74,8 +74,7 @@ func TestDialTimeout(t *testing.T) {\n \t\t// by default. FreeBSD likely works, but is untested.\n \t\t// TODO(rsc):\n \t\t// The timeout never happens on Windows.  Why?  Issue 3016.\n-\t\tt.Logf(\"skipping test on %q; untested.\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q; untested.\", runtime.GOOS)\n \t}\n \n \tconnected := 0\n@@ -107,8 +106,7 @@ func TestDialTimeout(t *testing.T) {\n func TestSelfConnect(t *testing.T) {\n \tif runtime.GOOS == \"windows\" {\n \t\t// TODO(brainman): do not know why it hangs.\n-\t\tt.Logf(\"skipping known-broken test on windows\")\n-\t\treturn\n+\t\tt.Skip(\"skipping known-broken test on windows\")\n \t}\n \t// Test that Dial does not honor self-connects.\n \t// See the comment in DialTCP.\n@@ -228,8 +226,7 @@ func TestDialError(t *testing.T) {\n func TestDialTimeoutFDLeak(t *testing.T) {\n \tif runtime.GOOS != \"linux\" {\n \t\t// TODO(bradfitz): test on other platforms\n-\t\tt.Logf(\"skipping test on %s\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \n \tln := newLocalListener(t)"}, {"sha": "73a94f5bf1c1fe0d961fcd2aa7b9c67b4bd65836", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -56,8 +56,7 @@ var googleaddrsipv4 = []string{\n \n func TestDialGoogleIPv4(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \n \t// Insert an actual IPv4 address for google.com\n@@ -112,17 +111,14 @@ var googleaddrsipv6 = []string{\n \n func TestDialGoogleIPv6(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \t// Only run tcp6 if the kernel will take it.\n \tif !supportsIPv6 {\n-\t\tt.Logf(\"skipping test; ipv6 is not supported\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test; ipv6 is not supported\")\n \t}\n \tif !*testIPv6 {\n-\t\tt.Logf(\"test disabled; use -ipv6 to enable\")\n-\t\treturn\n+\t\tt.Skip(\"test disabled; use -ipv6 to enable\")\n \t}\n \n \t// Insert an actual IPv6 address for ipv6.google.com"}, {"sha": "4f5dd6e524af8b0606e2372eee2bab657e027d6b", "filename": "libgo/go/net/fd_bsd.go", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_bsd.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build freebsd netbsd openbsd\n+\n // Waiting for FDs via kqueue/kevent.\n \n package net", "previous_filename": "libgo/go/net/fd_netbsd.go"}, {"sha": "35d84c30ef61122bffed2a81882a15d12a99f531", "filename": "libgo/go/net/fd_openbsd.go", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfca59095b1cca9d4364996866848eaaf76c26/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_openbsd.go?ref=91bfca59095b1cca9d4364996866848eaaf76c26", "patch": "@@ -1,116 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Waiting for FDs via kqueue/kevent.\n-\n-package net\n-\n-import (\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-type pollster struct {\n-\tkq       int\n-\teventbuf [10]syscall.Kevent_t\n-\tevents   []syscall.Kevent_t\n-\n-\t// An event buffer for AddFD/DelFD.\n-\t// Must hold pollServer lock.\n-\tkbuf [1]syscall.Kevent_t\n-}\n-\n-func newpollster() (p *pollster, err error) {\n-\tp = new(pollster)\n-\tif p.kq, err = syscall.Kqueue(); err != nil {\n-\t\treturn nil, os.NewSyscallError(\"kqueue\", err)\n-\t}\n-\tsyscall.CloseOnExec(p.kq)\n-\tp.events = p.eventbuf[0:0]\n-\treturn p, nil\n-}\n-\n-func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n-\t// pollServer is locked.\n-\n-\tvar kmode int\n-\tif mode == 'r' {\n-\t\tkmode = syscall.EVFILT_READ\n-\t} else {\n-\t\tkmode = syscall.EVFILT_WRITE\n-\t}\n-\tev := &p.kbuf[0]\n-\t// EV_ADD - add event to kqueue list\n-\t// EV_ONESHOT - delete the event the first time it triggers\n-\tflags := syscall.EV_ADD\n-\tif !repeat {\n-\t\tflags |= syscall.EV_ONESHOT\n-\t}\n-\tsyscall.SetKevent(ev, fd, kmode, flags)\n-\n-\tn, err := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n-\tif err != nil {\n-\t\treturn false, os.NewSyscallError(\"kevent\", err)\n-\t}\n-\tif n != 1 || (ev.Flags&syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {\n-\t\treturn false, os.NewSyscallError(\"kqueue phase error\", err)\n-\t}\n-\tif ev.Data != 0 {\n-\t\treturn false, syscall.Errno(int(ev.Data))\n-\t}\n-\treturn false, nil\n-}\n-\n-func (p *pollster) DelFD(fd int, mode int) {\n-\t// pollServer is locked.\n-\n-\tvar kmode int\n-\tif mode == 'r' {\n-\t\tkmode = syscall.EVFILT_READ\n-\t} else {\n-\t\tkmode = syscall.EVFILT_WRITE\n-\t}\n-\tev := &p.kbuf[0]\n-\t// EV_DELETE - delete event from kqueue list\n-\tsyscall.SetKevent(ev, fd, kmode, syscall.EV_DELETE)\n-\tsyscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n-}\n-\n-func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err error) {\n-\tvar t *syscall.Timespec\n-\tfor len(p.events) == 0 {\n-\t\tif nsec > 0 {\n-\t\t\tif t == nil {\n-\t\t\t\tt = new(syscall.Timespec)\n-\t\t\t}\n-\t\t\t*t = syscall.NsecToTimespec(nsec)\n-\t\t}\n-\n-\t\ts.Unlock()\n-\t\tn, err := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n-\t\ts.Lock()\n-\n-\t\tif err != nil {\n-\t\t\tif err == syscall.EINTR {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", err)\n-\t\t}\n-\t\tif n == 0 {\n-\t\t\treturn -1, 0, nil\n-\t\t}\n-\t\tp.events = p.eventbuf[:n]\n-\t}\n-\tev := &p.events[0]\n-\tp.events = p.events[1:]\n-\tfd = int(ev.Ident)\n-\tif ev.Filter == syscall.EVFILT_READ {\n-\t\tmode = 'r'\n-\t} else {\n-\t\tmode = 'w'\n-\t}\n-\treturn fd, mode, nil\n-}\n-\n-func (p *pollster) Close() error { return os.NewSyscallError(\"close\", syscall.Close(p.kq)) }"}, {"sha": "3462792816e5f4d2e9952b4ae69075051825658e", "filename": "libgo/go/net/fd_plan9.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_plan9.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -23,6 +23,12 @@ var canCancelIO = true // used for testing current package\n func sysInit() {\n }\n \n+func dialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n+\t// On plan9, use the relatively inefficient\n+\t// goroutine-racing implementation.\n+\treturn dialTimeoutRace(net, addr, timeout)\n+}\n+\n func newFD(proto, name string, ctl *os.File, laddr, raddr Addr) *netFD {\n \treturn &netFD{proto, name, \"/net/\" + proto + \"/\" + name, ctl, nil, laddr, raddr}\n }"}, {"sha": "e9d2e4165f135ebaf11dc36382283c48d136b355", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -288,10 +288,16 @@ func server(fd int) *pollServer {\n \treturn pollservers[k]\n }\n \n-func newFD(fd, family, sotype int, net string) (*netFD, error) {\n-\tif err := syscall.SetNonblock(fd, true); err != nil {\n+func dialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n+\tdeadline := time.Now().Add(timeout)\n+\t_, addri, err := resolveNetAddr(\"dial\", net, addr, deadline)\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n+\treturn dialAddr(net, addr, addri, deadline)\n+}\n+\n+func newFD(fd, family, sotype int, net string) (*netFD, error) {\n \tnetfd := &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n@@ -606,16 +612,11 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n \t}\n \tdefer fd.decref()\n \n-\t// See ../syscall/exec_unix.go for description of ForkLock.\n-\t// It is okay to hold the lock across syscall.Accept\n-\t// because we have put fd.sysfd into non-blocking mode.\n \tvar s int\n \tvar rsa syscall.Sockaddr\n \tfor {\n-\t\tsyscall.ForkLock.RLock()\n-\t\ts, rsa, err = syscall.Accept(fd.sysfd)\n+\t\ts, rsa, err = accept(fd.sysfd)\n \t\tif err != nil {\n-\t\t\tsyscall.ForkLock.RUnlock()\n \t\t\tif err == syscall.EAGAIN {\n \t\t\t\tif err = fd.pollServer.WaitRead(fd); err == nil {\n \t\t\t\t\tcontinue\n@@ -629,8 +630,6 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n \t\t}\n \t\tbreak\n \t}\n-\tsyscall.CloseOnExec(s)\n-\tsyscall.ForkLock.RUnlock()\n \n \tif netfd, err = newFD(s, fd.family, fd.sotype, fd.net); err != nil {\n \t\tclosesocket(s)"}, {"sha": "ea6ef10ec1a950976108c8e89c6103bfaacbfdee", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -45,6 +45,28 @@ func closesocket(s syscall.Handle) error {\n \treturn syscall.Closesocket(s)\n }\n \n+func canUseConnectEx(net string) bool {\n+\tif net == \"udp\" || net == \"udp4\" || net == \"udp6\" {\n+\t\t// ConnectEx windows API does not support connectionless sockets.\n+\t\treturn false\n+\t}\n+\treturn syscall.LoadConnectEx() == nil\n+}\n+\n+func dialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n+\tif !canUseConnectEx(net) {\n+\t\t// Use the relatively inefficient goroutine-racing\n+\t\t// implementation of DialTimeout.\n+\t\treturn dialTimeoutRace(net, addr, timeout)\n+\t}\n+\tdeadline := time.Now().Add(timeout)\n+\t_, addri, err := resolveNetAddr(\"dial\", net, addr, deadline)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn dialAddr(net, addr, addri, deadline)\n+}\n+\n // Interface for all IO operations.\n type anOpIface interface {\n \tOp() *anOp\n@@ -321,8 +343,48 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n \truntime.SetFinalizer(fd, (*netFD).closesocket)\n }\n \n+// Make new connection.\n+\n+type connectOp struct {\n+\tanOp\n+\tra syscall.Sockaddr\n+}\n+\n+func (o *connectOp) Submit() error {\n+\treturn syscall.ConnectEx(o.fd.sysfd, o.ra, nil, 0, nil, &o.o)\n+}\n+\n+func (o *connectOp) Name() string {\n+\treturn \"ConnectEx\"\n+}\n+\n func (fd *netFD) connect(ra syscall.Sockaddr) error {\n-\treturn syscall.Connect(fd.sysfd, ra)\n+\tif !canUseConnectEx(fd.net) {\n+\t\treturn syscall.Connect(fd.sysfd, ra)\n+\t}\n+\t// ConnectEx windows API requires an unconnected, previously bound socket.\n+\tvar la syscall.Sockaddr\n+\tswitch ra.(type) {\n+\tcase *syscall.SockaddrInet4:\n+\t\tla = &syscall.SockaddrInet4{}\n+\tcase *syscall.SockaddrInet6:\n+\t\tla = &syscall.SockaddrInet6{}\n+\tdefault:\n+\t\tpanic(\"unexpected type in connect\")\n+\t}\n+\tif err := syscall.Bind(fd.sysfd, la); err != nil {\n+\t\treturn err\n+\t}\n+\t// Call ConnectEx API.\n+\tvar o connectOp\n+\to.Init(fd, 'w')\n+\to.ra = ra\n+\t_, err := iosrv.ExecIO(&o, fd.wdeadline.value())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// Refresh socket properties.\n+\treturn syscall.Setsockopt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_UPDATE_CONNECT_CONTEXT, (*byte)(unsafe.Pointer(&fd.sysfd)), int32(unsafe.Sizeof(fd.sysfd)))\n }\n \n // Add a reference to this fd."}, {"sha": "78c62221dae12d38fca00f1239cf4c1fe71ad09a", "filename": "libgo/go/net/file_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -90,8 +90,7 @@ var fileListenerTests = []struct {\n func TestFileListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \n \tfor _, tt := range fileListenerTests {\n@@ -181,8 +180,7 @@ var filePacketConnTests = []struct {\n func TestFilePacketConn(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \n \tfor _, tt := range filePacketConnTests {"}, {"sha": "4c8403e40631ad89750b0c27361d877ffd958451", "filename": "libgo/go/net/file_unix.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -20,6 +20,10 @@ func newFileFD(f *os.File) (*netFD, error) {\n \t}\n \tsyscall.CloseOnExec(fd)\n \tsyscall.ForkLock.RUnlock()\n+\tif err = syscall.SetNonblock(fd, true); err != nil {\n+\t\tclosesocket(fd)\n+\t\treturn nil, err\n+\t}\n \n \tsotype, err := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n \tif err != nil {"}, {"sha": "100b8b77760e7db692a9d3026538824333d882db", "filename": "libgo/go/net/http/cgi/child.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -91,10 +91,19 @@ func RequestFromMap(params map[string]string) (*http.Request, error) {\n \n \t// TODO: cookies.  parsing them isn't exported, though.\n \n+\turiStr := params[\"REQUEST_URI\"]\n+\tif uriStr == \"\" {\n+\t\t// Fallback to SCRIPT_NAME, PATH_INFO and QUERY_STRING.\n+\t\turiStr = params[\"SCRIPT_NAME\"] + params[\"PATH_INFO\"]\n+\t\ts := params[\"QUERY_STRING\"]\n+\t\tif s != \"\" {\n+\t\t\turiStr += \"?\" + s\n+\t\t}\n+\t}\n \tif r.Host != \"\" {\n \t\t// Hostname is provided, so we can reasonably construct a URL,\n \t\t// even if we have to assume 'http' for the scheme.\n-\t\trawurl := \"http://\" + r.Host + params[\"REQUEST_URI\"]\n+\t\trawurl := \"http://\" + r.Host + uriStr\n \t\turl, err := url.Parse(rawurl)\n \t\tif err != nil {\n \t\t\treturn nil, errors.New(\"cgi: failed to parse host and REQUEST_URI into a URL: \" + rawurl)\n@@ -104,7 +113,6 @@ func RequestFromMap(params map[string]string) (*http.Request, error) {\n \t// Fallback logic if we don't have a Host header or the URL\n \t// failed to parse\n \tif r.URL == nil {\n-\t\turiStr := params[\"REQUEST_URI\"]\n \t\turl, err := url.Parse(uriStr)\n \t\tif err != nil {\n \t\t\treturn nil, errors.New(\"cgi: failed to parse REQUEST_URI into a URL: \" + uriStr)"}, {"sha": "74e068014bb1d0ab5765654ae4fd2649b99b2224", "filename": "libgo/go/net/http/cgi/child_test.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -82,6 +82,28 @@ func TestRequestWithoutHost(t *testing.T) {\n \t\tt.Fatalf(\"unexpected nil URL\")\n \t}\n \tif g, e := req.URL.String(), \"/path?a=b\"; e != g {\n-\t\tt.Errorf(\"expected URL %q; got %q\", e, g)\n+\t\tt.Errorf(\"URL = %q; want %q\", g, e)\n+\t}\n+}\n+\n+func TestRequestWithoutRequestURI(t *testing.T) {\n+\tenv := map[string]string{\n+\t\t\"SERVER_PROTOCOL\": \"HTTP/1.1\",\n+\t\t\"HTTP_HOST\":       \"example.com\",\n+\t\t\"REQUEST_METHOD\":  \"GET\",\n+\t\t\"SCRIPT_NAME\":     \"/dir/scriptname\",\n+\t\t\"PATH_INFO\":       \"/p1/p2\",\n+\t\t\"QUERY_STRING\":    \"a=1&b=2\",\n+\t\t\"CONTENT_LENGTH\":  \"123\",\n+\t}\n+\treq, err := RequestFromMap(env)\n+\tif err != nil {\n+\t\tt.Fatalf(\"RequestFromMap: %v\", err)\n+\t}\n+\tif req.URL == nil {\n+\t\tt.Fatalf(\"unexpected nil URL\")\n+\t}\n+\tif g, e := req.URL.String(), \"http://example.com/dir/scriptname/p1/p2?a=1&b=2\"; e != g {\n+\t\tt.Errorf(\"URL = %q; want %q\", g, e)\n \t}\n }"}, {"sha": "cb6f1df1f45517a52cd6831e73035bc31b6231a7", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 32, "deletions": 48, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -63,34 +63,38 @@ readlines:\n \t}\n \n \tfor key, expected := range expectedMap {\n-\t\tif got := m[key]; got != expected {\n+\t\tgot := m[key]\n+\t\tif key == \"cwd\" {\n+\t\t\t// For Windows. golang.org/issue/4645.\n+\t\t\tfi1, _ := os.Stat(got)\n+\t\t\tfi2, _ := os.Stat(expected)\n+\t\t\tif os.SameFile(fi1, fi2) {\n+\t\t\t\tgot = expected\n+\t\t\t}\n+\t\t}\n+\t\tif got != expected {\n \t\t\tt.Errorf(\"for key %q got %q; expected %q\", key, got, expected)\n \t\t}\n \t}\n \treturn rw\n }\n \n-var cgiTested = false\n-var cgiWorks bool\n+var cgiTested, cgiWorks bool\n \n-func skipTest(t *testing.T) bool {\n+func check(t *testing.T) {\n \tif !cgiTested {\n \t\tcgiTested = true\n \t\tcgiWorks = exec.Command(\"./testdata/test.cgi\").Run() == nil\n \t}\n \tif !cgiWorks {\n \t\t// No Perl on Windows, needed by test.cgi\n \t\t// TODO: make the child process be Go, not Perl.\n-\t\tt.Logf(\"Skipping test: test.cgi failed.\")\n-\t\treturn true\n+\t\tt.Skip(\"Skipping test: test.cgi failed.\")\n \t}\n-\treturn false\n }\n \n func TestCGIBasicGet(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t\tRoot: \"/test.cgi\",\n@@ -124,9 +128,7 @@ func TestCGIBasicGet(t *testing.T) {\n }\n \n func TestCGIBasicGetAbsPath(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \tpwd, err := os.Getwd()\n \tif err != nil {\n \t\tt.Fatalf(\"getwd error: %v\", err)\n@@ -144,9 +146,7 @@ func TestCGIBasicGetAbsPath(t *testing.T) {\n }\n \n func TestPathInfo(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t\tRoot: \"/test.cgi\",\n@@ -163,9 +163,7 @@ func TestPathInfo(t *testing.T) {\n }\n \n func TestPathInfoDirRoot(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t\tRoot: \"/myscript/\",\n@@ -181,9 +179,7 @@ func TestPathInfoDirRoot(t *testing.T) {\n }\n \n func TestDupHeaders(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t}\n@@ -203,9 +199,7 @@ func TestDupHeaders(t *testing.T) {\n }\n \n func TestPathInfoNoRoot(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t\tRoot: \"\",\n@@ -221,9 +215,7 @@ func TestPathInfoNoRoot(t *testing.T) {\n }\n \n func TestCGIBasicPost(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \tpostReq := `POST /test.cgi?a=b HTTP/1.0\n Host: example.com\n Content-Type: application/x-www-form-urlencoded\n@@ -250,9 +242,7 @@ func chunk(s string) string {\n \n // The CGI spec doesn't allow chunked requests.\n func TestCGIPostChunked(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \tpostReq := `POST /test.cgi?a=b HTTP/1.1\n Host: example.com\n Content-Type: application/x-www-form-urlencoded\n@@ -273,9 +263,7 @@ Transfer-Encoding: chunked\n }\n \n func TestRedirect(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n \t\tRoot: \"/test.cgi\",\n@@ -290,9 +278,7 @@ func TestRedirect(t *testing.T) {\n }\n \n func TestInternalRedirect(t *testing.T) {\n-\tif skipTest(t) {\n-\t\treturn\n-\t}\n+\tcheck(t)\n \tbaseHandler := http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n \t\tfmt.Fprintf(rw, \"basepath=%s\\n\", req.URL.Path)\n \t\tfmt.Fprintf(rw, \"remoteaddr=%s\\n\", req.RemoteAddr)\n@@ -312,8 +298,9 @@ func TestInternalRedirect(t *testing.T) {\n // TestCopyError tests that we kill the process if there's an error copying\n // its output. (for example, from the client having gone away)\n func TestCopyError(t *testing.T) {\n-\tif skipTest(t) || runtime.GOOS == \"windows\" {\n-\t\treturn\n+\tcheck(t)\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n@@ -376,10 +363,10 @@ func TestCopyError(t *testing.T) {\n }\n \n func TestDirUnix(t *testing.T) {\n-\tif skipTest(t) || runtime.GOOS == \"windows\" {\n-\t\treturn\n+\tcheck(t)\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n-\n \tcwd, _ := os.Getwd()\n \th := &Handler{\n \t\tPath: \"testdata/test.cgi\",\n@@ -406,8 +393,7 @@ func TestDirUnix(t *testing.T) {\n \n func TestDirWindows(t *testing.T) {\n \tif runtime.GOOS != \"windows\" {\n-\t\tt.Logf(\"Skipping windows specific test.\")\n-\t\treturn\n+\t\tt.Skip(\"Skipping windows specific test.\")\n \t}\n \n \tcgifile, _ := filepath.Abs(\"testdata/test.cgi\")\n@@ -416,8 +402,7 @@ func TestDirWindows(t *testing.T) {\n \tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n-\t\tt.Logf(\"Skipping test: perl not found.\")\n-\t\treturn\n+\t\tt.Skip(\"Skipping test: perl not found.\")\n \t}\n \tperl, _ = filepath.Abs(perl)\n \n@@ -459,8 +444,7 @@ func TestEnvOverride(t *testing.T) {\n \tvar err error\n \tperl, err = exec.LookPath(\"perl\")\n \tif err != nil {\n-\t\tt.Logf(\"Skipping test: perl not found.\")\n-\t\treturn\n+\t\tt.Skipf(\"Skipping test: perl not found.\")\n \t}\n \tperl, _ = filepath.Abs(perl)\n "}, {"sha": "d42014c265b3c56eb7275028baed46c00dfa740c", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -257,8 +257,7 @@ func TestFileServerImplicitLeadingSlash(t *testing.T) {\n func TestDirJoin(t *testing.T) {\n \twfi, err := os.Stat(\"/etc/hosts\")\n \tif err != nil {\n-\t\tt.Logf(\"skipping test; no /etc/hosts file\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test; no /etc/hosts file\")\n \t}\n \ttest := func(d Dir, name string) {\n \t\tf, err := d.Open(name)\n@@ -665,13 +664,10 @@ func TestServeContent(t *testing.T) {\n // verifies that sendfile is being used on Linux\n func TestLinuxSendfile(t *testing.T) {\n \tif runtime.GOOS != \"linux\" {\n-\t\tt.Logf(\"skipping; linux-only test\")\n-\t\treturn\n+\t\tt.Skip(\"skipping; linux-only test\")\n \t}\n-\t_, err := exec.LookPath(\"strace\")\n-\tif err != nil {\n-\t\tt.Logf(\"skipping; strace not found in path\")\n-\t\treturn\n+\tif _, err := exec.LookPath(\"strace\"); err != nil {\n+\t\tt.Skip(\"skipping; strace not found in path\")\n \t}\n \n \tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n@@ -690,10 +686,8 @@ func TestLinuxSendfile(t *testing.T) {\n \tchild.Env = append([]string{\"GO_WANT_HELPER_PROCESS=1\"}, os.Environ()...)\n \tchild.Stdout = &buf\n \tchild.Stderr = &buf\n-\terr = child.Start()\n-\tif err != nil {\n-\t\tt.Logf(\"skipping; failed to start straced child: %v\", err)\n-\t\treturn\n+\tif err := child.Start(); err != nil {\n+\t\tt.Skipf(\"skipping; failed to start straced child: %v\", err)\n \t}\n \n \tres, err := Get(fmt.Sprintf(\"http://%s/\", ln.Addr()))"}, {"sha": "f479b7b4eb901d35a9a827488cccdf61560ff32a", "filename": "libgo/go/net/http/header.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -54,6 +54,16 @@ func (h Header) Write(w io.Writer) error {\n \treturn h.WriteSubset(w, nil)\n }\n \n+func (h Header) clone() Header {\n+\th2 := make(Header, len(h))\n+\tfor k, vv := range h {\n+\t\tvv2 := make([]string, len(vv))\n+\t\tcopy(vv2, vv)\n+\t\th2[k] = vv2\n+\t}\n+\treturn h2\n+}\n+\n var timeFormats = []string{\n \tTimeFormat,\n \ttime.RFC850,"}, {"sha": "449ccaeea760a4cb7266028258f65b8ca725b18e", "filename": "libgo/go/net/http/proxy_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -31,7 +31,7 @@ var UseProxyTests = []struct {\n \t{\"localhost.net\", true},   // not match as suffix of address\n \t{\"local.localhost\", true}, // not match as prefix as address\n \t{\"barbarbaz.net\", true},   // not match because NO_PROXY have a '.'\n-\t{\"www.foobar.com\", true},  // not match because NO_PROXY is not .foobar.com\n+\t{\"www.foobar.com\", false}, // match because NO_PROXY includes \"foobar.com\"\n }\n \n func TestUseProxy(t *testing.T) {"}, {"sha": "217f35b48331ee8bf06c3885ad58ec74e37bf550", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -71,7 +71,13 @@ var reqWriteExcludeHeader = map[string]bool{\n // or to be sent by a client.\n type Request struct {\n \tMethod string // GET, POST, PUT, etc.\n-\tURL    *url.URL\n+\n+\t// URL is created from the URI supplied on the Request-Line\n+\t// as stored in RequestURI.\n+\t//\n+\t// For most requests, fields other than Path and RawQuery\n+\t// will be empty. (See RFC 2616, Section 5.1.2)\n+\tURL *url.URL\n \n \t// The protocol version for incoming requests.\n \t// Outgoing requests always use HTTP/1.1.\n@@ -325,11 +331,20 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) err\n \t}\n \t// TODO(bradfitz): escape at least newlines in ruri?\n \n-\tbw := bufio.NewWriter(w)\n-\tfmt.Fprintf(bw, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), ruri)\n+\t// Wrap the writer in a bufio Writer if it's not already buffered.\n+\t// Don't always call NewWriter, as that forces a bytes.Buffer\n+\t// and other small bufio Writers to have a minimum 4k buffer\n+\t// size.\n+\tvar bw *bufio.Writer\n+\tif _, ok := w.(io.ByteWriter); !ok {\n+\t\tbw = bufio.NewWriter(w)\n+\t\tw = bw\n+\t}\n+\n+\tfmt.Fprintf(w, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), ruri)\n \n \t// Header lines\n-\tfmt.Fprintf(bw, \"Host: %s\\r\\n\", host)\n+\tfmt.Fprintf(w, \"Host: %s\\r\\n\", host)\n \n \t// Use the defaultUserAgent unless the Header contains one, which\n \t// may be blank to not send the header.\n@@ -340,41 +355,44 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) err\n \t\t}\n \t}\n \tif userAgent != \"\" {\n-\t\tfmt.Fprintf(bw, \"User-Agent: %s\\r\\n\", userAgent)\n+\t\tfmt.Fprintf(w, \"User-Agent: %s\\r\\n\", userAgent)\n \t}\n \n \t// Process Body,ContentLength,Close,Trailer\n \ttw, err := newTransferWriter(req)\n \tif err != nil {\n \t\treturn err\n \t}\n-\terr = tw.WriteHeader(bw)\n+\terr = tw.WriteHeader(w)\n \tif err != nil {\n \t\treturn err\n \t}\n \n \t// TODO: split long values?  (If so, should share code with Conn.Write)\n-\terr = req.Header.WriteSubset(bw, reqWriteExcludeHeader)\n+\terr = req.Header.WriteSubset(w, reqWriteExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}\n \n \tif extraHeaders != nil {\n-\t\terr = extraHeaders.Write(bw)\n+\t\terr = extraHeaders.Write(w)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n \n-\tio.WriteString(bw, \"\\r\\n\")\n+\tio.WriteString(w, \"\\r\\n\")\n \n \t// Write body and trailer\n-\terr = tw.WriteBody(bw)\n+\terr = tw.WriteBody(w)\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\treturn bw.Flush()\n+\tif bw != nil {\n+\t\treturn bw.Flush()\n+\t}\n+\treturn nil\n }\n \n // ParseHTTPVersion parses a HTTP version string.\n@@ -427,10 +445,12 @@ func NewRequest(method, urlStr string, body io.Reader) (*Request, error) {\n \t}\n \tif body != nil {\n \t\tswitch v := body.(type) {\n-\t\tcase *strings.Reader:\n-\t\t\treq.ContentLength = int64(v.Len())\n \t\tcase *bytes.Buffer:\n \t\t\treq.ContentLength = int64(v.Len())\n+\t\tcase *bytes.Reader:\n+\t\t\treq.ContentLength = int64(v.Len())\n+\t\tcase *strings.Reader:\n+\t\t\treq.ContentLength = int64(v.Len())\n \t\t}\n \t}\n "}, {"sha": "bd757920b7808fc96b24923afe18d7730ad819cb", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -238,6 +238,65 @@ func TestNewRequestHost(t *testing.T) {\n \t}\n }\n \n+func TestNewRequestContentLength(t *testing.T) {\n+\treadByte := func(r io.Reader) io.Reader {\n+\t\tvar b [1]byte\n+\t\tr.Read(b[:])\n+\t\treturn r\n+\t}\n+\ttests := []struct {\n+\t\tr    io.Reader\n+\t\twant int64\n+\t}{\n+\t\t{bytes.NewReader([]byte(\"123\")), 3},\n+\t\t{bytes.NewBuffer([]byte(\"1234\")), 4},\n+\t\t{strings.NewReader(\"12345\"), 5},\n+\t\t// Not detected:\n+\t\t{struct{ io.Reader }{strings.NewReader(\"xyz\")}, 0},\n+\t\t{io.NewSectionReader(strings.NewReader(\"x\"), 0, 6), 0},\n+\t\t{readByte(io.NewSectionReader(strings.NewReader(\"xy\"), 0, 6)), 0},\n+\t}\n+\tfor _, tt := range tests {\n+\t\treq, err := NewRequest(\"POST\", \"http://localhost/\", tt.r)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif req.ContentLength != tt.want {\n+\t\t\tt.Errorf(\"ContentLength(%#T) = %d; want %d\", tt.r, req.ContentLength, tt.want)\n+\t\t}\n+\t}\n+}\n+\n+type logWrites struct {\n+\tt   *testing.T\n+\tdst *[]string\n+}\n+\n+func (l logWrites) WriteByte(c byte) error {\n+\tl.t.Fatalf(\"unexpected WriteByte call\")\n+\treturn nil\n+}\n+\n+func (l logWrites) Write(p []byte) (n int, err error) {\n+\t*l.dst = append(*l.dst, string(p))\n+\treturn len(p), nil\n+}\n+\n+func TestRequestWriteBufferedWriter(t *testing.T) {\n+\tgot := []string{}\n+\treq, _ := NewRequest(\"GET\", \"http://foo.com/\", nil)\n+\treq.Write(logWrites{t, &got})\n+\twant := []string{\n+\t\t\"GET / HTTP/1.1\\r\\n\",\n+\t\t\"Host: foo.com\\r\\n\",\n+\t\t\"User-Agent: Go http package\\r\\n\",\n+\t\t\"\\r\\n\",\n+\t}\n+\tif !reflect.DeepEqual(got, want) {\n+\t\tt.Errorf(\"Writes = %q\\n  Want = %q\", got, want)\n+\t}\n+}\n+\n func testMissingFile(t *testing.T, req *Request) {\n \tf, fh, err := req.FormFile(\"missing\")\n \tif f != nil {"}, {"sha": "a00a4ae0a9b246aba4e0aa185735a4e57065e03a", "filename": "libgo/go/net/http/response_test.go", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -124,7 +124,7 @@ var respTests = []respTest{\n \n \t// Chunked response without Content-Length.\n \t{\n-\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\" +\n \t\t\t\"\\r\\n\" +\n \t\t\t\"0a\\r\\n\" +\n@@ -137,12 +137,12 @@ var respTests = []respTest{\n \t\tResponse{\n \t\t\tStatus:           \"200 OK\",\n \t\t\tStatusCode:       200,\n-\t\t\tProto:            \"HTTP/1.0\",\n+\t\t\tProto:            \"HTTP/1.1\",\n \t\t\tProtoMajor:       1,\n-\t\t\tProtoMinor:       0,\n+\t\t\tProtoMinor:       1,\n \t\t\tRequest:          dummyReq(\"GET\"),\n \t\t\tHeader:           Header{},\n-\t\t\tClose:            true,\n+\t\t\tClose:            false,\n \t\t\tContentLength:    -1,\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n@@ -152,7 +152,7 @@ var respTests = []respTest{\n \n \t// Chunked response with Content-Length.\n \t{\n-\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\" +\n \t\t\t\"Content-Length: 10\\r\\n\" +\n \t\t\t\"\\r\\n\" +\n@@ -164,36 +164,101 @@ var respTests = []respTest{\n \t\tResponse{\n \t\t\tStatus:           \"200 OK\",\n \t\t\tStatusCode:       200,\n-\t\t\tProto:            \"HTTP/1.0\",\n+\t\t\tProto:            \"HTTP/1.1\",\n \t\t\tProtoMajor:       1,\n-\t\t\tProtoMinor:       0,\n+\t\t\tProtoMinor:       1,\n \t\t\tRequest:          dummyReq(\"GET\"),\n \t\t\tHeader:           Header{},\n-\t\t\tClose:            true,\n+\t\t\tClose:            false,\n \t\t\tContentLength:    -1, // TODO(rsc): Fix?\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n \n \t\t\"Body here\\n\",\n \t},\n \n-\t// Chunked response in response to a HEAD request (the \"chunked\" should\n-\t// be ignored, as HEAD responses never have bodies)\n+\t// Chunked response in response to a HEAD request\n \t{\n-\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\" +\n \t\t\t\"\\r\\n\",\n \n \t\tResponse{\n-\t\t\tStatus:        \"200 OK\",\n-\t\t\tStatusCode:    200,\n-\t\t\tProto:         \"HTTP/1.0\",\n-\t\t\tProtoMajor:    1,\n-\t\t\tProtoMinor:    0,\n-\t\t\tRequest:       dummyReq(\"HEAD\"),\n-\t\t\tHeader:        Header{},\n-\t\t\tClose:         true,\n-\t\t\tContentLength: -1,\n+\t\t\tStatus:           \"200 OK\",\n+\t\t\tStatusCode:       200,\n+\t\t\tProto:            \"HTTP/1.1\",\n+\t\t\tProtoMajor:       1,\n+\t\t\tProtoMinor:       1,\n+\t\t\tRequest:          dummyReq(\"HEAD\"),\n+\t\t\tHeader:           Header{},\n+\t\t\tTransferEncoding: []string{\"chunked\"},\n+\t\t\tClose:            false,\n+\t\t\tContentLength:    -1,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n+\t// Content-Length in response to a HEAD request\n+\t{\n+\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\t\"Content-Length: 256\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:           \"200 OK\",\n+\t\t\tStatusCode:       200,\n+\t\t\tProto:            \"HTTP/1.0\",\n+\t\t\tProtoMajor:       1,\n+\t\t\tProtoMinor:       0,\n+\t\t\tRequest:          dummyReq(\"HEAD\"),\n+\t\t\tHeader:           Header{\"Content-Length\": {\"256\"}},\n+\t\t\tTransferEncoding: nil,\n+\t\t\tClose:            true,\n+\t\t\tContentLength:    256,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n+\t// Content-Length in response to a HEAD request with HTTP/1.1\n+\t{\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n+\t\t\t\"Content-Length: 256\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:           \"200 OK\",\n+\t\t\tStatusCode:       200,\n+\t\t\tProto:            \"HTTP/1.1\",\n+\t\t\tProtoMajor:       1,\n+\t\t\tProtoMinor:       1,\n+\t\t\tRequest:          dummyReq(\"HEAD\"),\n+\t\t\tHeader:           Header{\"Content-Length\": {\"256\"}},\n+\t\t\tTransferEncoding: nil,\n+\t\t\tClose:            false,\n+\t\t\tContentLength:    256,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n+\t// No Content-Length or Chunked in response to a HEAD request\n+\t{\n+\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:           \"200 OK\",\n+\t\t\tStatusCode:       200,\n+\t\t\tProto:            \"HTTP/1.0\",\n+\t\t\tProtoMajor:       1,\n+\t\t\tProtoMinor:       0,\n+\t\t\tRequest:          dummyReq(\"HEAD\"),\n+\t\t\tHeader:           Header{},\n+\t\t\tTransferEncoding: nil,\n+\t\t\tClose:            true,\n+\t\t\tContentLength:    -1,\n \t\t},\n \n \t\t\"\","}, {"sha": "5c10e2161cfd6efa8681f42947aad9aa2bc84918", "filename": "libgo/go/net/http/responsewrite_test.go", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fresponsewrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fresponsewrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponsewrite_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,83 +15,83 @@ type respWriteTest struct {\n \tRaw  string\n }\n \n-var respWriteTests = []respWriteTest{\n-\t// HTTP/1.0, identity coding; no trailer\n-\t{\n-\t\tResponse{\n-\t\t\tStatusCode:    503,\n-\t\t\tProtoMajor:    1,\n-\t\t\tProtoMinor:    0,\n-\t\t\tRequest:       dummyReq(\"GET\"),\n-\t\t\tHeader:        Header{},\n-\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n-\t\t\tContentLength: 6,\n-\t\t},\n+func TestResponseWrite(t *testing.T) {\n+\trespWriteTests := []respWriteTest{\n+\t\t// HTTP/1.0, identity coding; no trailer\n+\t\t{\n+\t\t\tResponse{\n+\t\t\t\tStatusCode:    503,\n+\t\t\t\tProtoMajor:    1,\n+\t\t\t\tProtoMinor:    0,\n+\t\t\t\tRequest:       dummyReq(\"GET\"),\n+\t\t\t\tHeader:        Header{},\n+\t\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n+\t\t\t\tContentLength: 6,\n+\t\t\t},\n \n-\t\t\"HTTP/1.0 503 Service Unavailable\\r\\n\" +\n-\t\t\t\"Content-Length: 6\\r\\n\\r\\n\" +\n-\t\t\t\"abcdef\",\n-\t},\n-\t// Unchunked response without Content-Length.\n-\t{\n-\t\tResponse{\n-\t\t\tStatusCode:    200,\n-\t\t\tProtoMajor:    1,\n-\t\t\tProtoMinor:    0,\n-\t\t\tRequest:       dummyReq(\"GET\"),\n-\t\t\tHeader:        Header{},\n-\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n-\t\t\tContentLength: -1,\n+\t\t\t\"HTTP/1.0 503 Service Unavailable\\r\\n\" +\n+\t\t\t\t\"Content-Length: 6\\r\\n\\r\\n\" +\n+\t\t\t\t\"abcdef\",\n \t\t},\n-\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n-\t\t\t\"\\r\\n\" +\n-\t\t\t\"abcdef\",\n-\t},\n-\t// HTTP/1.1, chunked coding; empty trailer; close\n-\t{\n-\t\tResponse{\n-\t\t\tStatusCode:       200,\n-\t\t\tProtoMajor:       1,\n-\t\t\tProtoMinor:       1,\n-\t\t\tRequest:          dummyReq(\"GET\"),\n-\t\t\tHeader:           Header{},\n-\t\t\tBody:             ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n-\t\t\tContentLength:    6,\n-\t\t\tTransferEncoding: []string{\"chunked\"},\n-\t\t\tClose:            true,\n+\t\t// Unchunked response without Content-Length.\n+\t\t{\n+\t\t\tResponse{\n+\t\t\t\tStatusCode:    200,\n+\t\t\t\tProtoMajor:    1,\n+\t\t\t\tProtoMinor:    0,\n+\t\t\t\tRequest:       dummyReq(\"GET\"),\n+\t\t\t\tHeader:        Header{},\n+\t\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n+\t\t\t\tContentLength: -1,\n+\t\t\t},\n+\t\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\t\t\"\\r\\n\" +\n+\t\t\t\t\"abcdef\",\n \t\t},\n+\t\t// HTTP/1.1, chunked coding; empty trailer; close\n+\t\t{\n+\t\t\tResponse{\n+\t\t\t\tStatusCode:       200,\n+\t\t\t\tProtoMajor:       1,\n+\t\t\t\tProtoMinor:       1,\n+\t\t\t\tRequest:          dummyReq(\"GET\"),\n+\t\t\t\tHeader:           Header{},\n+\t\t\t\tBody:             ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n+\t\t\t\tContentLength:    6,\n+\t\t\t\tTransferEncoding: []string{\"chunked\"},\n+\t\t\t\tClose:            true,\n+\t\t\t},\n \n-\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n-\t\t\t\"Connection: close\\r\\n\" +\n-\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n-\t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n-\t},\n+\t\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n+\t\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n+\t\t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n+\t\t},\n \n-\t// Header value with a newline character (Issue 914).\n-\t// Also tests removal of leading and trailing whitespace.\n-\t{\n-\t\tResponse{\n-\t\t\tStatusCode: 204,\n-\t\t\tProtoMajor: 1,\n-\t\t\tProtoMinor: 1,\n-\t\t\tRequest:    dummyReq(\"GET\"),\n-\t\t\tHeader: Header{\n-\t\t\t\t\"Foo\": []string{\" Bar\\nBaz \"},\n+\t\t// Header value with a newline character (Issue 914).\n+\t\t// Also tests removal of leading and trailing whitespace.\n+\t\t{\n+\t\t\tResponse{\n+\t\t\t\tStatusCode: 204,\n+\t\t\t\tProtoMajor: 1,\n+\t\t\t\tProtoMinor: 1,\n+\t\t\t\tRequest:    dummyReq(\"GET\"),\n+\t\t\t\tHeader: Header{\n+\t\t\t\t\t\"Foo\": []string{\" Bar\\nBaz \"},\n+\t\t\t\t},\n+\t\t\t\tBody:             nil,\n+\t\t\t\tContentLength:    0,\n+\t\t\t\tTransferEncoding: []string{\"chunked\"},\n+\t\t\t\tClose:            true,\n \t\t\t},\n-\t\t\tBody:             nil,\n-\t\t\tContentLength:    0,\n-\t\t\tTransferEncoding: []string{\"chunked\"},\n-\t\t\tClose:            true,\n-\t\t},\n \n-\t\t\"HTTP/1.1 204 No Content\\r\\n\" +\n-\t\t\t\"Connection: close\\r\\n\" +\n-\t\t\t\"Foo: Bar Baz\\r\\n\" +\n-\t\t\t\"\\r\\n\",\n-\t},\n-}\n+\t\t\t\"HTTP/1.1 204 No Content\\r\\n\" +\n+\t\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\t\"Foo: Bar Baz\\r\\n\" +\n+\t\t\t\t\"\\r\\n\",\n+\t\t},\n+\t}\n \n-func TestResponseWrite(t *testing.T) {\n \tfor i := range respWriteTests {\n \t\ttt := &respWriteTests[i]\n \t\tvar braw bytes.Buffer"}, {"sha": "886ed4e8f7413e2d2504550ea5f5e999a29f9344", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -67,6 +67,7 @@ func (a dummyAddr) String() string {\n type testConn struct {\n \treadBuf  bytes.Buffer\n \twriteBuf bytes.Buffer\n+\tclosec   chan bool // if non-nil, send value to it on close\n }\n \n func (c *testConn) Read(b []byte) (int, error) {\n@@ -78,6 +79,10 @@ func (c *testConn) Write(b []byte) (int, error) {\n }\n \n func (c *testConn) Close() error {\n+\tselect {\n+\tcase c.closec <- true:\n+\tdefault:\n+\t}\n \treturn nil\n }\n \n@@ -179,10 +184,11 @@ var vtests = []struct {\n }\n \n func TestHostHandlers(t *testing.T) {\n+\tmux := NewServeMux()\n \tfor _, h := range handlers {\n-\t\tHandle(h.pattern, stringHandler(h.msg))\n+\t\tmux.Handle(h.pattern, stringHandler(h.msg))\n \t}\n-\tts := httptest.NewServer(nil)\n+\tts := httptest.NewServer(mux)\n \tdefer ts.Close()\n \n \tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n@@ -484,6 +490,7 @@ func TestChunkedResponseHeaders(t *testing.T) {\n \n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tw.Header().Set(\"Content-Length\", \"intentional gibberish\") // we check that this is deleted\n+\t\tw.(Flusher).Flush()\n \t\tfmt.Fprintf(w, \"I am a chunked response.\")\n \t}))\n \tdefer ts.Close()\n@@ -764,6 +771,7 @@ func TestServerUnreadRequestBodyLittle(t *testing.T) {\n \t\t\tt.Errorf(\"on request, read buffer length is %d; expected about 100 KB\", conn.readBuf.Len())\n \t\t}\n \t\trw.WriteHeader(200)\n+\t\trw.(Flusher).Flush()\n \t\tif g, e := conn.readBuf.Len(), 0; g != e {\n \t\t\tt.Errorf(\"after WriteHeader, read buffer length is %d; want %d\", g, e)\n \t\t}\n@@ -786,24 +794,24 @@ func TestServerUnreadRequestBodyLarge(t *testing.T) {\n \t\t\t\"Content-Length: %d\\r\\n\"+\n \t\t\t\"\\r\\n\", len(body))))\n \tconn.readBuf.Write([]byte(body))\n-\n-\tdone := make(chan bool)\n+\tconn.closec = make(chan bool, 1)\n \n \tls := &oneConnListener{conn}\n \tgo Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {\n-\t\tdefer close(done)\n \t\tif conn.readBuf.Len() < len(body)/2 {\n \t\t\tt.Errorf(\"on request, read buffer length is %d; expected about 1MB\", conn.readBuf.Len())\n \t\t}\n \t\trw.WriteHeader(200)\n+\t\trw.(Flusher).Flush()\n \t\tif conn.readBuf.Len() < len(body)/2 {\n \t\t\tt.Errorf(\"post-WriteHeader, read buffer length is %d; expected about 1MB\", conn.readBuf.Len())\n \t\t}\n-\t\tif c := rw.Header().Get(\"Connection\"); c != \"close\" {\n-\t\t\tt.Errorf(`Connection header = %q; want \"close\"`, c)\n-\t\t}\n \t}))\n-\t<-done\n+\t<-conn.closec\n+\n+\tif res := conn.writeBuf.String(); !strings.Contains(res, \"Connection: close\") {\n+\t\tt.Errorf(\"Expected a Connection: close header; got response: %s\", res)\n+\t}\n }\n \n func TestTimeoutHandler(t *testing.T) {\n@@ -1144,22 +1152,17 @@ func TestClientWriteShutdown(t *testing.T) {\n // Tests that chunked server responses that write 1 byte at a time are\n // buffered before chunk headers are added, not after chunk headers.\n func TestServerBufferedChunking(t *testing.T) {\n-\tif true {\n-\t\tt.Logf(\"Skipping known broken test; see Issue 2357\")\n-\t\treturn\n-\t}\n \tconn := new(testConn)\n \tconn.readBuf.Write([]byte(\"GET / HTTP/1.1\\r\\n\\r\\n\"))\n-\tdone := make(chan bool)\n+\tconn.closec = make(chan bool, 1)\n \tls := &oneConnListener{conn}\n \tgo Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {\n-\t\tdefer close(done)\n-\t\trw.Header().Set(\"Content-Type\", \"text/plain\") // prevent sniffing, which buffers\n+\t\trw.(Flusher).Flush() // force the Header to be sent, in chunking mode, not counting the length\n \t\trw.Write([]byte{'x'})\n \t\trw.Write([]byte{'y'})\n \t\trw.Write([]byte{'z'})\n \t}))\n-\t<-done\n+\t<-conn.closec\n \tif !bytes.HasSuffix(conn.writeBuf.Bytes(), []byte(\"\\r\\n\\r\\n3\\r\\nxyz\\r\\n0\\r\\n\\r\\n\")) {\n \t\tt.Errorf(\"response didn't end with a single 3 byte 'xyz' chunk; got:\\n%q\",\n \t\t\tconn.writeBuf.Bytes())"}, {"sha": "434943d49a389087a2368fb1266294ee880d0f22", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 234, "deletions": 166, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -113,7 +113,6 @@ type conn struct {\n \tlr         *io.LimitedReader    // io.LimitReader(sr)\n \tbuf        *bufio.ReadWriter    // buffered(lr,rwc), reading from bufio->limitReader->sr->rwc\n \ttlsState   *tls.ConnectionState // or nil when not using TLS\n-\tbody       []byte\n \n \tmu           sync.Mutex // guards the following\n \tclientGone   bool       // if client has disconnected mid-request\n@@ -193,18 +192,85 @@ func (sr *switchReader) Read(p []byte) (n int, err error) {\n \treturn r.Read(p)\n }\n \n+// This should be >= 512 bytes for DetectContentType,\n+// but otherwise it's somewhat arbitrary.\n+const bufferBeforeChunkingSize = 2048\n+\n+// chunkWriter writes to a response's conn buffer, and is the writer\n+// wrapped by the response.bufw buffered writer.\n+//\n+// chunkWriter also is responsible for finalizing the Header, including\n+// conditionally setting the Content-Type and setting a Content-Length\n+// in cases where the handler's final output is smaller than the buffer\n+// size. It also conditionally adds chunk headers, when in chunking mode.\n+//\n+// See the comment above (*response).Write for the entire write flow.\n+type chunkWriter struct {\n+\tres         *response\n+\theader      Header // a deep copy of r.Header, once WriteHeader is called\n+\twroteHeader bool   // whether the header's been sent\n+\n+\t// set by the writeHeader method:\n+\tchunking bool // using chunked transfer encoding for reply body\n+}\n+\n+var crlf = []byte(\"\\r\\n\")\n+\n+func (cw *chunkWriter) Write(p []byte) (n int, err error) {\n+\tif !cw.wroteHeader {\n+\t\tcw.writeHeader(p)\n+\t}\n+\tif cw.chunking {\n+\t\t_, err = fmt.Fprintf(cw.res.conn.buf, \"%x\\r\\n\", len(p))\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tn, err = cw.res.conn.buf.Write(p)\n+\tif cw.chunking && err == nil {\n+\t\t_, err = cw.res.conn.buf.Write(crlf)\n+\t}\n+\treturn\n+}\n+\n+func (cw *chunkWriter) flush() {\n+\tif !cw.wroteHeader {\n+\t\tcw.writeHeader(nil)\n+\t}\n+\tcw.res.conn.buf.Flush()\n+}\n+\n+func (cw *chunkWriter) close() {\n+\tif !cw.wroteHeader {\n+\t\tcw.writeHeader(nil)\n+\t}\n+\tif cw.chunking {\n+\t\t// zero EOF chunk, trailer key/value pairs (currently\n+\t\t// unsupported in Go's server), followed by a blank\n+\t\t// line.\n+\t\tio.WriteString(cw.res.conn.buf, \"0\\r\\n\\r\\n\")\n+\t}\n+}\n+\n // A response represents the server side of an HTTP response.\n type response struct {\n \tconn          *conn\n \treq           *Request // request for this response\n-\tchunking      bool     // using chunked transfer encoding for reply body\n-\twroteHeader   bool     // reply header has been written\n+\twroteHeader   bool     // reply header has been (logically) written\n \twroteContinue bool     // 100 Continue response was written\n-\theader        Header   // reply header parameters\n-\twritten       int64    // number of bytes written in body\n-\tcontentLength int64    // explicitly-declared Content-Length; or -1\n-\tstatus        int      // status code passed to WriteHeader\n-\tneedSniff     bool     // need to sniff to find Content-Type\n+\n+\tw  *bufio.Writer // buffers output in chunks to chunkWriter\n+\tcw *chunkWriter\n+\n+\t// handlerHeader is the Header that Handlers get access to,\n+\t// which may be retained and mutated even after WriteHeader.\n+\t// handlerHeader is copied into cw.header at WriteHeader\n+\t// time, and privately mutated thereafter.\n+\thandlerHeader Header\n+\n+\twritten       int64 // number of bytes written in body\n+\tcontentLength int64 // explicitly-declared Content-Length; or -1\n+\tstatus        int   // status code passed to WriteHeader\n \n \t// close connection after this reply.  set on request and\n \t// updated after response from handler if there's a\n@@ -220,6 +286,8 @@ type response struct {\n \t// subsequent requests on this connection and stop reading\n \t// input from it.\n \trequestBodyLimitHit bool\n+\n+\thandlerDone bool // set true when the handler exits\n }\n \n // requestTooLarge is called by maxBytesReader when too much input has\n@@ -232,27 +300,46 @@ func (w *response) requestTooLarge() {\n \t}\n }\n \n+// needsSniff returns whether a Content-Type still needs to be sniffed.\n+func (w *response) needsSniff() bool {\n+\treturn !w.cw.wroteHeader && w.handlerHeader.Get(\"Content-Type\") == \"\" && w.written < sniffLen\n+}\n+\n type writerOnly struct {\n \tio.Writer\n }\n \n func (w *response) ReadFrom(src io.Reader) (n int64, err error) {\n-\t// Call WriteHeader before checking w.chunking if it hasn't\n-\t// been called yet, since WriteHeader is what sets w.chunking.\n \tif !w.wroteHeader {\n \t\tw.WriteHeader(StatusOK)\n \t}\n-\tif !w.chunking && w.bodyAllowed() && !w.needSniff {\n-\t\tw.Flush()\n+\n+\tif w.needsSniff() {\n+\t\tn0, err := io.Copy(writerOnly{w}, io.LimitReader(src, sniffLen))\n+\t\tn += n0\n+\t\tif err != nil {\n+\t\t\treturn n, err\n+\t\t}\n+\t}\n+\n+\tw.w.Flush()  // get rid of any previous writes\n+\tw.cw.flush() // make sure Header is written; flush data to rwc\n+\n+\t// Now that cw has been flushed, its chunking field is guaranteed initialized.\n+\tif !w.cw.chunking && w.bodyAllowed() {\n \t\tif rf, ok := w.conn.rwc.(io.ReaderFrom); ok {\n-\t\t\tn, err = rf.ReadFrom(src)\n-\t\t\tw.written += n\n-\t\t\treturn\n+\t\t\tn0, err := rf.ReadFrom(src)\n+\t\t\tn += n0\n+\t\t\tw.written += n0\n+\t\t\treturn n, err\n \t\t}\n \t}\n+\n \t// Fall back to default io.Copy implementation.\n \t// Use wrapper to hide w.ReadFrom from io.Copy.\n-\treturn io.Copy(writerOnly{w}, src)\n+\tn0, err := io.Copy(writerOnly{w}, src)\n+\tn += n0\n+\treturn n, err\n }\n \n // noLimit is an effective infinite upper bound for io.LimitedReader\n@@ -272,7 +359,6 @@ func (srv *Server) newConn(rwc net.Conn) (c *conn, err error) {\n \t\tc.rwc = newLoggingConn(\"server\", c.rwc)\n \t}\n \tc.sr = switchReader{r: c.rwc}\n-\tc.body = make([]byte, sniffLen)\n \tc.lr = io.LimitReader(&c.sr, noLimit).(*io.LimitedReader)\n \tbr := bufio.NewReader(c.lr)\n \tbw := bufio.NewWriter(c.rwc)\n@@ -343,17 +429,20 @@ func (c *conn) readRequest() (w *response, err error) {\n \treq.RemoteAddr = c.remoteAddr\n \treq.TLS = c.tlsState\n \n-\tw = new(response)\n-\tw.conn = c\n-\tw.req = req\n-\tw.header = make(Header)\n-\tw.contentLength = -1\n-\tc.body = c.body[:0]\n+\tw = &response{\n+\t\tconn:          c,\n+\t\treq:           req,\n+\t\thandlerHeader: make(Header),\n+\t\tcontentLength: -1,\n+\t\tcw:            new(chunkWriter),\n+\t}\n+\tw.cw.res = w\n+\tw.w = bufio.NewWriterSize(w.cw, bufferBeforeChunkingSize)\n \treturn w, nil\n }\n \n func (w *response) Header() Header {\n-\treturn w.header\n+\treturn w.handlerHeader\n }\n \n // maxPostHandlerReadBytes is the max number of Request.Body bytes not\n@@ -379,30 +468,68 @@ func (w *response) WriteHeader(code int) {\n \tw.wroteHeader = true\n \tw.status = code\n \n-\t// Check for a explicit (and valid) Content-Length header.\n-\tvar hasCL bool\n-\tvar contentLength int64\n-\tif clenStr := w.header.get(\"Content-Length\"); clenStr != \"\" {\n-\t\tvar err error\n-\t\tcontentLength, err = strconv.ParseInt(clenStr, 10, 64)\n-\t\tif err == nil {\n-\t\t\thasCL = true\n+\tw.cw.header = w.handlerHeader.clone()\n+\n+\tif cl := w.cw.header.get(\"Content-Length\"); cl != \"\" {\n+\t\tv, err := strconv.ParseInt(cl, 10, 64)\n+\t\tif err == nil && v >= 0 {\n+\t\t\tw.contentLength = v\n \t\t} else {\n-\t\t\tlog.Printf(\"http: invalid Content-Length of %q sent\", clenStr)\n-\t\t\tw.header.Del(\"Content-Length\")\n+\t\t\tlog.Printf(\"http: invalid Content-Length of %q\", cl)\n+\t\t\tw.cw.header.Del(\"Content-Length\")\n+\t\t}\n+\t}\n+}\n+\n+// writeHeader finalizes the header sent to the client and writes it\n+// to cw.res.conn.buf.\n+//\n+// p is not written by writeHeader, but is the first chunk of the body\n+// that will be written.  It is sniffed for a Content-Type if none is\n+// set explicitly.  It's also used to set the Content-Length, if the\n+// total body size was small and the handler has already finished\n+// running.\n+func (cw *chunkWriter) writeHeader(p []byte) {\n+\tif cw.wroteHeader {\n+\t\treturn\n+\t}\n+\tcw.wroteHeader = true\n+\n+\tw := cw.res\n+\tcode := w.status\n+\tdone := w.handlerDone\n+\n+\t// If the handler is done but never sent a Content-Length\n+\t// response header and this is our first (and last) write, set\n+\t// it, even to zero. This helps HTTP/1.0 clients keep their\n+\t// \"keep-alive\" connections alive.\n+\tif done && cw.header.get(\"Content-Length\") == \"\" && w.req.Method != \"HEAD\" {\n+\t\tw.contentLength = int64(len(p))\n+\t\tcw.header.Set(\"Content-Length\", strconv.Itoa(len(p)))\n+\t}\n+\n+\t// If this was an HTTP/1.0 request with keep-alive and we sent a\n+\t// Content-Length back, we can make this a keep-alive response ...\n+\tif w.req.wantsHttp10KeepAlive() {\n+\t\tsentLength := cw.header.get(\"Content-Length\") != \"\"\n+\t\tif sentLength && cw.header.get(\"Connection\") == \"keep-alive\" {\n+\t\t\tw.closeAfterReply = false\n \t\t}\n \t}\n \n+\t// Check for a explicit (and valid) Content-Length header.\n+\thasCL := w.contentLength != -1\n+\n \tif w.req.wantsHttp10KeepAlive() && (w.req.Method == \"HEAD\" || hasCL) {\n-\t\t_, connectionHeaderSet := w.header[\"Connection\"]\n+\t\t_, connectionHeaderSet := cw.header[\"Connection\"]\n \t\tif !connectionHeaderSet {\n-\t\t\tw.header.Set(\"Connection\", \"keep-alive\")\n+\t\t\tcw.header.Set(\"Connection\", \"keep-alive\")\n \t\t}\n \t} else if !w.req.ProtoAtLeast(1, 1) || w.req.wantsClose() {\n \t\tw.closeAfterReply = true\n \t}\n \n-\tif w.header.get(\"Connection\") == \"close\" {\n+\tif cw.header.get(\"Connection\") == \"close\" {\n \t\tw.closeAfterReply = true\n \t}\n \n@@ -416,7 +543,7 @@ func (w *response) WriteHeader(code int) {\n \t\t\tn, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)\n \t\t\tif n >= maxPostHandlerReadBytes {\n \t\t\t\tw.requestTooLarge()\n-\t\t\t\tw.header.Set(\"Connection\", \"close\")\n+\t\t\t\tcw.header.Set(\"Connection\", \"close\")\n \t\t\t} else {\n \t\t\t\tw.req.Body.Close()\n \t\t\t}\n@@ -426,69 +553,65 @@ func (w *response) WriteHeader(code int) {\n \tif code == StatusNotModified {\n \t\t// Must not have body.\n \t\tfor _, header := range []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"} {\n-\t\t\tif w.header.get(header) != \"\" {\n-\t\t\t\t// TODO: return an error if WriteHeader gets a return parameter\n-\t\t\t\t// or set a flag on w to make future Writes() write an error page?\n-\t\t\t\t// for now just log and drop the header.\n-\t\t\t\tlog.Printf(\"http: StatusNotModified response with header %q defined\", header)\n-\t\t\t\tw.header.Del(header)\n+\t\t\t// RFC 2616 section 10.3.5: \"the response MUST NOT include other entity-headers\"\n+\t\t\tif cw.header.get(header) != \"\" {\n+\t\t\t\tcw.header.Del(header)\n \t\t\t}\n \t\t}\n \t} else {\n \t\t// If no content type, apply sniffing algorithm to body.\n-\t\tif w.header.get(\"Content-Type\") == \"\" && w.req.Method != \"HEAD\" {\n-\t\t\tw.needSniff = true\n+\t\tif cw.header.get(\"Content-Type\") == \"\" && w.req.Method != \"HEAD\" {\n+\t\t\tcw.header.Set(\"Content-Type\", DetectContentType(p))\n \t\t}\n \t}\n \n-\tif _, ok := w.header[\"Date\"]; !ok {\n-\t\tw.Header().Set(\"Date\", time.Now().UTC().Format(TimeFormat))\n+\tif _, ok := cw.header[\"Date\"]; !ok {\n+\t\tcw.header.Set(\"Date\", time.Now().UTC().Format(TimeFormat))\n \t}\n \n-\tte := w.header.get(\"Transfer-Encoding\")\n+\tte := cw.header.get(\"Transfer-Encoding\")\n \thasTE := te != \"\"\n \tif hasCL && hasTE && te != \"identity\" {\n \t\t// TODO: return an error if WriteHeader gets a return parameter\n \t\t// For now just ignore the Content-Length.\n \t\tlog.Printf(\"http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d\",\n-\t\t\tte, contentLength)\n-\t\tw.header.Del(\"Content-Length\")\n+\t\t\tte, w.contentLength)\n+\t\tcw.header.Del(\"Content-Length\")\n \t\thasCL = false\n \t}\n \n \tif w.req.Method == \"HEAD\" || code == StatusNotModified {\n \t\t// do nothing\n \t} else if code == StatusNoContent {\n-\t\tw.header.Del(\"Transfer-Encoding\")\n+\t\tcw.header.Del(\"Transfer-Encoding\")\n \t} else if hasCL {\n-\t\tw.contentLength = contentLength\n-\t\tw.header.Del(\"Transfer-Encoding\")\n+\t\tcw.header.Del(\"Transfer-Encoding\")\n \t} else if w.req.ProtoAtLeast(1, 1) {\n \t\t// HTTP/1.1 or greater: use chunked transfer encoding\n \t\t// to avoid closing the connection at EOF.\n \t\t// TODO: this blows away any custom or stacked Transfer-Encoding they\n \t\t// might have set.  Deal with that as need arises once we have a valid\n \t\t// use case.\n-\t\tw.chunking = true\n-\t\tw.header.Set(\"Transfer-Encoding\", \"chunked\")\n+\t\tcw.chunking = true\n+\t\tcw.header.Set(\"Transfer-Encoding\", \"chunked\")\n \t} else {\n \t\t// HTTP version < 1.1: cannot do chunked transfer\n \t\t// encoding and we don't know the Content-Length so\n \t\t// signal EOF by closing connection.\n \t\tw.closeAfterReply = true\n-\t\tw.header.Del(\"Transfer-Encoding\") // in case already set\n+\t\tcw.header.Del(\"Transfer-Encoding\") // in case already set\n \t}\n \n \t// Cannot use Content-Length with non-identity Transfer-Encoding.\n-\tif w.chunking {\n-\t\tw.header.Del(\"Content-Length\")\n+\tif cw.chunking {\n+\t\tcw.header.Del(\"Content-Length\")\n \t}\n \tif !w.req.ProtoAtLeast(1, 0) {\n \t\treturn\n \t}\n \n-\tif w.closeAfterReply && !hasToken(w.header.get(\"Connection\"), \"close\") {\n-\t\tw.header.Set(\"Connection\", \"close\")\n+\tif w.closeAfterReply && !hasToken(cw.header.get(\"Connection\"), \"close\") {\n+\t\tcw.header.Set(\"Connection\", \"close\")\n \t}\n \n \tproto := \"HTTP/1.0\"\n@@ -501,37 +624,8 @@ func (w *response) WriteHeader(code int) {\n \t\ttext = \"status code \" + codestring\n \t}\n \tio.WriteString(w.conn.buf, proto+\" \"+codestring+\" \"+text+\"\\r\\n\")\n-\tw.header.Write(w.conn.buf)\n-\n-\t// If we need to sniff the body, leave the header open.\n-\t// Otherwise, end it here.\n-\tif !w.needSniff {\n-\t\tio.WriteString(w.conn.buf, \"\\r\\n\")\n-\t}\n-}\n-\n-// sniff uses the first block of written data,\n-// stored in w.conn.body, to decide the Content-Type\n-// for the HTTP body.\n-func (w *response) sniff() {\n-\tif !w.needSniff {\n-\t\treturn\n-\t}\n-\tw.needSniff = false\n-\n-\tdata := w.conn.body\n-\tfmt.Fprintf(w.conn.buf, \"Content-Type: %s\\r\\n\\r\\n\", DetectContentType(data))\n-\n-\tif len(data) == 0 {\n-\t\treturn\n-\t}\n-\tif w.chunking {\n-\t\tfmt.Fprintf(w.conn.buf, \"%x\\r\\n\", len(data))\n-\t}\n-\t_, err := w.conn.buf.Write(data)\n-\tif w.chunking && err == nil {\n-\t\tio.WriteString(w.conn.buf, \"\\r\\n\")\n-\t}\n+\tcw.header.Write(w.conn.buf)\n+\tw.conn.buf.Write(crlf)\n }\n \n // bodyAllowed returns true if a Write is allowed for this response type.\n@@ -543,6 +637,38 @@ func (w *response) bodyAllowed() bool {\n \treturn w.status != StatusNotModified && w.req.Method != \"HEAD\"\n }\n \n+// The Life Of A Write is like this:\n+//\n+// Handler starts. No header has been sent. The handler can either\n+// write a header, or just start writing.  Writing before sending a header\n+// sends an implicity empty 200 OK header.\n+//\n+// If the handler didn't declare a Content-Length up front, we either\n+// go into chunking mode or, if the handler finishes running before\n+// the chunking buffer size, we compute a Content-Length and send that\n+// in the header instead.\n+//\n+// Likewise, if the handler didn't set a Content-Type, we sniff that\n+// from the initial chunk of output.\n+//\n+// The Writers are wired together like:\n+//\n+// 1. *response (the ResponseWriter) ->\n+// 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes\n+// 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)\n+//    and which writes the chunk headers, if needed.\n+// 4. conn.buf, a bufio.Writer of default (4kB) bytes\n+// 5. the rwc, the net.Conn.\n+//\n+// TODO(bradfitz): short-circuit some of the buffering when the\n+// initial header contains both a Content-Type and Content-Length.\n+// Also short-circuit in (1) when the header's been sent and not in\n+// chunking mode, writing directly to (4) instead, if (2) has no\n+// buffered data.  More generally, we could short-circuit from (1) to\n+// (3) even in chunking mode if the write size from (1) is over some\n+// threshold and nothing is in (2).  The answer might be mostly making\n+// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal\n+// with this instead.\n func (w *response) Write(data []byte) (n int, err error) {\n \tif w.conn.hijacked() {\n \t\tlog.Print(\"http: response.Write on hijacked connection\")\n@@ -562,81 +688,20 @@ func (w *response) Write(data []byte) (n int, err error) {\n \tif w.contentLength != -1 && w.written > w.contentLength {\n \t\treturn 0, ErrContentLength\n \t}\n-\n-\tvar m int\n-\tif w.needSniff {\n-\t\t// We need to sniff the beginning of the output to\n-\t\t// determine the content type.  Accumulate the\n-\t\t// initial writes in w.conn.body.\n-\t\t// Cap m so that append won't allocate.\n-\t\tm = cap(w.conn.body) - len(w.conn.body)\n-\t\tif m > len(data) {\n-\t\t\tm = len(data)\n-\t\t}\n-\t\tw.conn.body = append(w.conn.body, data[:m]...)\n-\t\tdata = data[m:]\n-\t\tif len(data) == 0 {\n-\t\t\t// Copied everything into the buffer.\n-\t\t\t// Wait for next write.\n-\t\t\treturn m, nil\n-\t\t}\n-\n-\t\t// Filled the buffer; more data remains.\n-\t\t// Sniff the content (flushes the buffer)\n-\t\t// and then proceed with the remainder\n-\t\t// of the data as a normal Write.\n-\t\t// Calling sniff clears needSniff.\n-\t\tw.sniff()\n-\t}\n-\n-\t// TODO(rsc): if chunking happened after the buffering,\n-\t// then there would be fewer chunk headers.\n-\t// On the other hand, it would make hijacking more difficult.\n-\tif w.chunking {\n-\t\tfmt.Fprintf(w.conn.buf, \"%x\\r\\n\", len(data))\n-\t}\n-\tn, err = w.conn.buf.Write(data)\n-\tif err == nil && w.chunking {\n-\t\tif n != len(data) {\n-\t\t\terr = io.ErrShortWrite\n-\t\t}\n-\t\tif err == nil {\n-\t\t\tio.WriteString(w.conn.buf, \"\\r\\n\")\n-\t\t}\n-\t}\n-\n-\treturn m + n, err\n+\treturn w.w.Write(data)\n }\n \n func (w *response) finishRequest() {\n-\t// If the handler never wrote any bytes and never sent a Content-Length\n-\t// response header, set the length explicitly to zero. This helps\n-\t// HTTP/1.0 clients keep their \"keep-alive\" connections alive, and for\n-\t// HTTP/1.1 clients is just as good as the alternative: sending a\n-\t// chunked response and immediately sending the zero-length EOF chunk.\n-\tif w.written == 0 && w.header.get(\"Content-Length\") == \"\" && w.req.Method != \"HEAD\" {\n-\t\tw.header.Set(\"Content-Length\", \"0\")\n-\t}\n-\t// If this was an HTTP/1.0 request with keep-alive and we sent a\n-\t// Content-Length back, we can make this a keep-alive response ...\n-\tif w.req.wantsHttp10KeepAlive() {\n-\t\tsentLength := w.header.get(\"Content-Length\") != \"\"\n-\t\tif sentLength && w.header.get(\"Connection\") == \"keep-alive\" {\n-\t\t\tw.closeAfterReply = false\n-\t\t}\n-\t}\n+\tw.handlerDone = true\n+\n \tif !w.wroteHeader {\n \t\tw.WriteHeader(StatusOK)\n \t}\n-\tif w.needSniff {\n-\t\tw.sniff()\n-\t}\n-\tif w.chunking {\n-\t\tio.WriteString(w.conn.buf, \"0\\r\\n\")\n-\t\t// trailer key/value pairs, followed by blank line\n-\t\tio.WriteString(w.conn.buf, \"\\r\\n\")\n-\t}\n+\n+\tw.w.Flush()\n+\tw.cw.close()\n \tw.conn.buf.Flush()\n+\n \t// Close the body, unless we're about to close the whole TCP connection\n \t// anyway.\n \tif !w.closeAfterReply {\n@@ -646,7 +711,7 @@ func (w *response) finishRequest() {\n \t\tw.req.MultipartForm.RemoveAll()\n \t}\n \n-\tif w.contentLength != -1 && w.contentLength != w.written {\n+\tif w.contentLength != -1 && w.bodyAllowed() && w.contentLength != w.written {\n \t\t// Did not write enough. Avoid getting out of sync.\n \t\tw.closeAfterReply = true\n \t}\n@@ -656,8 +721,8 @@ func (w *response) Flush() {\n \tif !w.wroteHeader {\n \t\tw.WriteHeader(StatusOK)\n \t}\n-\tw.sniff()\n-\tw.conn.buf.Flush()\n+\tw.w.Flush()\n+\tw.cw.flush()\n }\n \n func (c *conn) finalFlush() {\n@@ -809,6 +874,9 @@ func (w *response) sendExpectationFailed() {\n // Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter\n // and a Hijacker.\n func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {\n+\tif w.wroteHeader {\n+\t\tw.cw.flush()\n+\t}\n \treturn w.conn.hijack()\n }\n \n@@ -1148,7 +1216,7 @@ func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n }\n \n // Serve accepts incoming HTTP connections on the listener l,\n-// creating a new service thread for each.  The service threads\n+// creating a new service goroutine for each.  The service goroutines\n // read requests and then call handler to reply to them.\n // Handler is typically nil, in which case the DefaultServeMux is used.\n func Serve(l net.Listener, handler Handler) error {\n@@ -1182,7 +1250,7 @@ func (srv *Server) ListenAndServe() error {\n }\n \n // Serve accepts incoming connections on the Listener l, creating a\n-// new service thread for each.  The service threads read requests and\n+// new service goroutine for each.  The service goroutines read requests and\n // then call srv.Handler to reply to them.\n func (srv *Server) Serve(l net.Listener) error {\n \tdefer l.Close()\n@@ -1327,7 +1395,7 @@ func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n // TimeoutHandler returns a Handler that runs h with the given time limit.\n //\n // The new Handler calls h.ServeHTTP to handle each request, but if a\n-// call runs for more than ns nanoseconds, the handler responds with\n+// call runs for longer than its time limit, the handler responds with\n // a 503 Service Unavailable error and the given message in its body.\n // (If msg is empty, a suitable default message will be sent.)\n // After such a timeout, writes by h to its ResponseWriter will return"}, {"sha": "25b34addec77fe9b57af79cc22bafe134653af67", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -87,10 +87,8 @@ func newTransferWriter(r interface{}) (t *transferWriter, err error) {\n \t// Sanitize Body,ContentLength,TransferEncoding\n \tif t.ResponseToHEAD {\n \t\tt.Body = nil\n-\t\tt.TransferEncoding = nil\n-\t\t// ContentLength is expected to hold Content-Length\n-\t\tif t.ContentLength < 0 {\n-\t\t\treturn nil, ErrMissingContentLength\n+\t\tif chunked(t.TransferEncoding) {\n+\t\t\tt.ContentLength = -1\n \t\t}\n \t} else {\n \t\tif !atLeastHTTP11 || t.Body == nil {\n@@ -122,9 +120,6 @@ func (t *transferWriter) shouldSendContentLength() bool {\n \tif t.ContentLength > 0 {\n \t\treturn true\n \t}\n-\tif t.ResponseToHEAD {\n-\t\treturn true\n-\t}\n \t// Many servers expect a Content-Length for these methods\n \tif t.Method == \"POST\" || t.Method == \"PUT\" {\n \t\treturn true\n@@ -380,12 +375,6 @@ func fixTransferEncoding(requestMethod string, header Header) ([]string, error)\n \n \tdelete(header, \"Transfer-Encoding\")\n \n-\t// Head responses have no bodies, so the transfer encoding\n-\t// should be ignored.\n-\tif requestMethod == \"HEAD\" {\n-\t\treturn nil, nil\n-\t}\n-\n \tencodings := strings.Split(raw[0], \",\")\n \tte := make([]string, 0, len(encodings))\n \t// TODO: Even though we only support \"identity\" and \"chunked\""}, {"sha": "98e198e78af71bf4983c770a88c8ec10bd5cc20f", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -450,7 +450,15 @@ func useProxy(addr string) bool {\n \t\tif hasPort(p) {\n \t\t\tp = p[:strings.LastIndex(p, \":\")]\n \t\t}\n-\t\tif addr == p || (p[0] == '.' && (strings.HasSuffix(addr, p) || addr == p[1:])) {\n+\t\tif addr == p {\n+\t\t\treturn false\n+\t\t}\n+\t\tif p[0] == '.' && (strings.HasSuffix(addr, p) || addr == p[1:]) {\n+\t\t\t// no_proxy \".foo.com\" matches \"bar.foo.com\" or \"foo.com\"\n+\t\t\treturn false\n+\t\t}\n+\t\tif p[0] != '.' && strings.HasSuffix(addr, p) && addr[len(addr)-len(p)-1] == '.' {\n+\t\t\t// no_proxy \"foo.com\" matches \"bar.foo.com\"\n \t\t\treturn false\n \t\t}\n \t}"}, {"sha": "daaecae341bb406bfbee431a376c35c8e10c09f7", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -390,8 +390,7 @@ func TestTransportServerClosingUnexpectedly(t *testing.T) {\n // This fails pretty reliably with GOMAXPROCS=100 or something high.\n func TestStressSurpriseServerCloses(t *testing.T) {\n \tif testing.Short() {\n-\t\tt.Logf(\"skipping test in short mode\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test in short mode\")\n \t}\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tw.Header().Set(\"Content-Length\", \"5\")\n@@ -1115,35 +1114,65 @@ func TestTransportNoHost(t *testing.T) {\n \t}\n }\n \n-var proxyFromEnvTests = []struct {\n+type proxyFromEnvTest struct {\n+\treq     string // URL to fetch; blank means \"http://example.com\"\n \tenv     string\n-\twanturl string\n+\tnoenv   string\n+\twant    string\n \twanterr error\n-}{\n-\t{\"127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n-\t{\"cache.corp.example.com:1234\", \"http://cache.corp.example.com:1234\", nil},\n-\t{\"cache.corp.example.com\", \"http://cache.corp.example.com\", nil},\n-\t{\"https://cache.corp.example.com\", \"https://cache.corp.example.com\", nil},\n-\t{\"http://127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n-\t{\"https://127.0.0.1:8080\", \"https://127.0.0.1:8080\", nil},\n-\t{\"\", \"<nil>\", nil},\n+}\n+\n+func (t proxyFromEnvTest) String() string {\n+\tvar buf bytes.Buffer\n+\tif t.env != \"\" {\n+\t\tfmt.Fprintf(&buf, \"http_proxy=%q\", t.env)\n+\t}\n+\tif t.noenv != \"\" {\n+\t\tfmt.Fprintf(&buf, \" no_proxy=%q\", t.noenv)\n+\t}\n+\treq := \"http://example.com\"\n+\tif t.req != \"\" {\n+\t\treq = t.req\n+\t}\n+\tfmt.Fprintf(&buf, \" req=%q\", req)\n+\treturn strings.TrimSpace(buf.String())\n+}\n+\n+var proxyFromEnvTests = []proxyFromEnvTest{\n+\t{env: \"127.0.0.1:8080\", want: \"http://127.0.0.1:8080\"},\n+\t{env: \"cache.corp.example.com:1234\", want: \"http://cache.corp.example.com:1234\"},\n+\t{env: \"cache.corp.example.com\", want: \"http://cache.corp.example.com\"},\n+\t{env: \"https://cache.corp.example.com\", want: \"https://cache.corp.example.com\"},\n+\t{env: \"http://127.0.0.1:8080\", want: \"http://127.0.0.1:8080\"},\n+\t{env: \"https://127.0.0.1:8080\", want: \"https://127.0.0.1:8080\"},\n+\t{want: \"<nil>\"},\n+\t{noenv: \"example.com\", req: \"http://example.com/\", env: \"proxy\", want: \"<nil>\"},\n+\t{noenv: \".example.com\", req: \"http://example.com/\", env: \"proxy\", want: \"<nil>\"},\n+\t{noenv: \"ample.com\", req: \"http://example.com/\", env: \"proxy\", want: \"http://proxy\"},\n+\t{noenv: \"example.com\", req: \"http://foo.example.com/\", env: \"proxy\", want: \"<nil>\"},\n+\t{noenv: \".foo.com\", req: \"http://example.com/\", env: \"proxy\", want: \"http://proxy\"},\n }\n \n func TestProxyFromEnvironment(t *testing.T) {\n \tos.Setenv(\"HTTP_PROXY\", \"\")\n \tos.Setenv(\"http_proxy\", \"\")\n \tos.Setenv(\"NO_PROXY\", \"\")\n \tos.Setenv(\"no_proxy\", \"\")\n-\tfor i, tt := range proxyFromEnvTests {\n+\tfor _, tt := range proxyFromEnvTests {\n \t\tos.Setenv(\"HTTP_PROXY\", tt.env)\n-\t\treq, _ := NewRequest(\"GET\", \"http://example.com\", nil)\n+\t\tos.Setenv(\"NO_PROXY\", tt.noenv)\n+\t\treqURL := tt.req\n+\t\tif reqURL == \"\" {\n+\t\t\treqURL = \"http://example.com\"\n+\t\t}\n+\t\treq, _ := NewRequest(\"GET\", reqURL, nil)\n \t\turl, err := ProxyFromEnvironment(req)\n \t\tif g, e := fmt.Sprintf(\"%v\", err), fmt.Sprintf(\"%v\", tt.wanterr); g != e {\n-\t\t\tt.Errorf(\"%d. got error = %q, want %q\", i, g, e)\n+\t\t\tt.Errorf(\"%v: got error = %q, want %q\", tt, g, e)\n \t\t\tcontinue\n \t\t}\n-\t\tif got := fmt.Sprintf(\"%s\", url); got != tt.wanturl {\n-\t\t\tt.Errorf(\"%d. got URL = %q, want %q\", i, url, tt.wanturl)\n+\t\tif got := fmt.Sprintf(\"%s\", url); got != tt.want {\n+\t\t\tt.Errorf(\"%v: got URL = %q, want %q\", tt, url, tt.want)\n \t\t}\n \t}\n }"}, {"sha": "df9b3a2f279a4759e07f61c51a741c6019462b67", "filename": "libgo/go/net/interface_bsd.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_bsd.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -118,7 +118,9 @@ func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n-\t\t\t\tifat = append(ifat, ifa)\n+\t\t\t\tif ifa != nil {\n+\t\t\t\t\tifat = append(ifat, ifa)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -157,6 +159,8 @@ func newAddr(m *syscall.InterfaceAddrMessage) (Addr, error) {\n \t\t\t\t\tifa.IP[2], ifa.IP[3] = 0, 0\n \t\t\t\t}\n \t\t\t}\n+\t\tdefault: // Sockaddrs contain syscall.SockaddrDatalink on NetBSD\n+\t\t\treturn nil, nil\n \t\t}\n \t}\n \treturn ifa, nil"}, {"sha": "803c1f4495ca1bb7481a5c8fb344ded58ff98eef", "filename": "libgo/go/net/interface_test.go", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Finterface_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Finterface_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -75,9 +75,13 @@ func testInterfaceMulticastAddrs(t *testing.T, ifi *Interface) {\n \n func testAddrs(t *testing.T, ifat []Addr) {\n \tfor _, ifa := range ifat {\n-\t\tswitch ifa.(type) {\n+\t\tswitch v := ifa.(type) {\n \t\tcase *IPAddr, *IPNet:\n-\t\t\tt.Logf(\"\\tinterface address %q\", ifa.String())\n+\t\t\tif v == nil {\n+\t\t\t\tt.Errorf(\"\\tunexpected value: %v\", ifa)\n+\t\t\t} else {\n+\t\t\t\tt.Logf(\"\\tinterface address %q\", ifa.String())\n+\t\t\t}\n \t\tdefault:\n \t\t\tt.Errorf(\"\\tunexpected type: %T\", ifa)\n \t\t}\n@@ -86,9 +90,13 @@ func testAddrs(t *testing.T, ifat []Addr) {\n \n func testMulticastAddrs(t *testing.T, ifmat []Addr) {\n \tfor _, ifma := range ifmat {\n-\t\tswitch ifma.(type) {\n+\t\tswitch v := ifma.(type) {\n \t\tcase *IPAddr:\n-\t\t\tt.Logf(\"\\tjoined group address %q\", ifma.String())\n+\t\t\tif v == nil {\n+\t\t\t\tt.Errorf(\"\\tunexpected value: %v\", ifma)\n+\t\t\t} else {\n+\t\t\t\tt.Logf(\"\\tjoined group address %q\", ifma.String())\n+\t\t\t}\n \t\tdefault:\n \t\t\tt.Errorf(\"\\tunexpected type: %T\", ifma)\n \t\t}"}, {"sha": "d588e3a42946c6c2771598e646363e1725e53c74", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -7,7 +7,7 @@\n // IPv4 addresses are 4 bytes; IPv6 addresses are 16 bytes.\n // An IPv4 address can be converted to an IPv6 address by\n // adding a canonical prefix (10 zeros, 2 0xFFs).\n-// This library accepts either size of byte array but always\n+// This library accepts either size of byte slice but always\n // returns 16-byte addresses.\n \n package net\n@@ -18,14 +18,14 @@ const (\n \tIPv6len = 16\n )\n \n-// An IP is a single IP address, an array of bytes.\n+// An IP is a single IP address, a slice of bytes.\n // Functions in this package accept either 4-byte (IPv4)\n-// or 16-byte (IPv6) arrays as input.\n+// or 16-byte (IPv6) slices as input.\n //\n // Note that in this documentation, referring to an\n // IP address as an IPv4 address or an IPv6 address\n // is a semantic property of the address, not just the\n-// length of the byte array: a 16-byte array can still\n+// length of the byte slice: a 16-byte slice can still\n // be an IPv4 address.\n type IP []byte\n "}, {"sha": "db1c7694bb099e1013ba57fc38892a24825c6de1", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -61,8 +61,7 @@ var icmpTests = []struct {\n \n func TestICMP(t *testing.T) {\n \tif os.Getuid() != 0 {\n-\t\tt.Logf(\"skipping test; must be root\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test; must be root\")\n \t}\n \n \tseqnum := 61455\n@@ -253,8 +252,7 @@ var ipConnLocalNameTests = []struct {\n \n func TestIPConnLocalName(t *testing.T) {\n \tif os.Getuid() != 0 {\n-\t\tt.Logf(\"skipping test; must be root\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test; must be root\")\n \t}\n \n \tfor _, tt := range ipConnLocalNameTests {"}, {"sha": "3355e4694894974fc1d23a3ffb407c4adcb31027", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -17,8 +17,7 @@ var testExternal = flag.Bool(\"external\", true, \"allow use of external networks d\n \n func TestGoogleSRV(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \t_, addrs, err := LookupSRV(\"xmpp-server\", \"tcp\", \"google.com\")\n \tif err != nil {\n@@ -40,8 +39,7 @@ func TestGoogleSRV(t *testing.T) {\n \n func TestGmailMX(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \tmx, err := LookupMX(\"gmail.com\")\n \tif err != nil {\n@@ -54,8 +52,7 @@ func TestGmailMX(t *testing.T) {\n \n func TestGmailNS(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \tns, err := LookupNS(\"gmail.com\")\n \tif err != nil {\n@@ -68,8 +65,7 @@ func TestGmailNS(t *testing.T) {\n \n func TestGmailTXT(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \ttxt, err := LookupTXT(\"gmail.com\")\n \tif err != nil {\n@@ -82,8 +78,7 @@ func TestGmailTXT(t *testing.T) {\n \n func TestGoogleDNSAddr(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \tnames, err := LookupAddr(\"8.8.8.8\")\n \tif err != nil {\n@@ -96,8 +91,7 @@ func TestGoogleDNSAddr(t *testing.T) {\n \n func TestLookupIANACNAME(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \tcname, err := LookupCNAME(\"www.iana.org\")\n \tif !strings.HasSuffix(cname, \".icann.org.\") || err != nil {"}, {"sha": "5850a6be0f71e7d5ac4d5d65bffa8e47d663114b", "filename": "libgo/go/net/multicast_posix_test.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -48,12 +48,10 @@ var multicastListenerTests = []struct {\n func TestMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"netbsd\", \"openbsd\", \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \tcase \"linux\":\n \t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"alpha\" {\n-\t\t\tt.Logf(\"skipping test on %q/%q\", runtime.GOOS, runtime.GOARCH)\n-\t\t\treturn\n+\t\t\tt.Skipf(\"skipping test on %q/%q\", runtime.GOOS, runtime.GOARCH)\n \t\t}\n \t}\n \n@@ -83,12 +81,10 @@ func TestMulticastListener(t *testing.T) {\n func TestSimpleMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \tcase \"windows\":\n \t\tif testing.Short() || !*testExternal {\n-\t\t\tt.Logf(\"skipping test on windows to avoid firewall\")\n-\t\t\treturn\n+\t\t\tt.Skip(\"skipping test on windows to avoid firewall\")\n \t\t}\n \t}\n "}, {"sha": "8a560b521943a5ea7dab540ff8864520c4b73453", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,8 +15,7 @@ import (\n \n func TestShutdown(t *testing.T) {\n \tif runtime.GOOS == \"plan9\" {\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \tln, err := Listen(\"tcp\", \"127.0.0.1:0\")\n \tif err != nil {\n@@ -63,8 +62,7 @@ func TestShutdown(t *testing.T) {\n func TestShutdownUnix(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"windows\", \"plan9\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \tf, err := ioutil.TempFile(\"\", \"go_net_unixtest\")\n \tif err != nil {\n@@ -145,8 +143,7 @@ func TestTCPListenClose(t *testing.T) {\n func TestUDPListenClose(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \tln, err := ListenPacket(\"udp\", \"127.0.0.1:0\")\n \tif err != nil {"}, {"sha": "9df0c534b33be1d075a7a0ba7a222ae6ba02d818", "filename": "libgo/go/net/parse_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -15,8 +15,7 @@ func TestReadLine(t *testing.T) {\n \t// /etc/services file does not exist on windows and Plan 9.\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \tfilename := \"/etc/services\" // a nice big file\n "}, {"sha": "1344fba8a064ecfbac60020608dc097a94b02b95", "filename": "libgo/go/net/protoconn_test.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fprotoconn_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -156,12 +156,10 @@ func TestUDPConnSpecificMethods(t *testing.T) {\n func TestIPConnSpecificMethods(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":\n-\t\tt.Logf(\"skipping read test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping read test on %q\", runtime.GOOS)\n \t}\n \tif os.Getuid() != 0 {\n-\t\tt.Logf(\"skipping test; must be root\")\n-\t\treturn\n+\t\tt.Skipf(\"skipping test; must be root\")\n \t}\n \n \tla, err := net.ResolveIPAddr(\"ip4\", \"127.0.0.1\")\n@@ -212,8 +210,7 @@ func TestIPConnSpecificMethods(t *testing.T) {\n func TestUnixListenerSpecificMethods(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping read test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping read test on %q\", runtime.GOOS)\n \t}\n \n \tp := \"/tmp/gotest.net\"\n@@ -259,8 +256,7 @@ func TestUnixListenerSpecificMethods(t *testing.T) {\n func TestUnixConnSpecificMethods(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \n \tp1, p2, p3 := \"/tmp/gotest.net1\", \"/tmp/gotest.net2\", \"/tmp/gotest.net3\""}, {"sha": "eba1e7d96915fc80ae3f5d3eb5ee375aba78515f", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -142,8 +142,7 @@ var seqpacketConnServerTests = []struct {\n \n func TestSeqpacketConnServer(t *testing.T) {\n \tif runtime.GOOS != \"linux\" {\n-\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n-\t\treturn\n+\t\tt.Skipf(\"skipping test on %q\", runtime.GOOS)\n \t}\n \n \tfor _, tt := range seqpacketConnServerTests {"}, {"sha": "e2a5ef7160a9243a78c43a1ec2a1db92cf954b24", "filename": "libgo/go/net/sock_cloexec.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_cloexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_cloexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_cloexec.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements sysSocket and accept for platforms that\n+// provide a fast path for setting SetNonblock and CloseOnExec.\n+\n+// +build linux\n+\n+package net\n+\n+import \"syscall\"\n+\n+// Wrapper around the socket system call that marks the returned file\n+// descriptor as nonblocking and close-on-exec.\n+func sysSocket(f, t, p int) (int, error) {\n+\ts, err := syscall.Socket(f, t|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, p)\n+\t// The SOCK_NONBLOCK and SOCK_CLOEXEC flags were introduced in\n+\t// Linux 2.6.27.  If we get an EINVAL error, fall back to\n+\t// using socket without them.\n+\tif err == nil || err != syscall.EINVAL {\n+\t\treturn s, err\n+\t}\n+\n+\t// See ../syscall/exec_unix.go for description of ForkLock.\n+\tsyscall.ForkLock.RLock()\n+\ts, err = syscall.Socket(f, t, p)\n+\tif err == nil {\n+\t\tsyscall.CloseOnExec(s)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\tif err = syscall.SetNonblock(s, true); err != nil {\n+\t\tsyscall.Close(s)\n+\t\treturn -1, err\n+\t}\n+\treturn s, nil\n+}\n+\n+// Wrapper around the accept system call that marks the returned file\n+// descriptor as nonblocking and close-on-exec.\n+func accept(fd int) (int, syscall.Sockaddr, error) {\n+\tnfd, sa, err := syscall.Accept4(fd, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)\n+\t// The accept4 system call was introduced in Linux 2.6.28.  If\n+\t// we get an ENOSYS error, fall back to using accept.\n+\tif err == nil || err != syscall.ENOSYS {\n+\t\treturn nfd, sa, err\n+\t}\n+\n+\t// See ../syscall/exec_unix.go for description of ForkLock.\n+\t// It is okay to hold the lock across syscall.Accept\n+\t// because we have put fd.sysfd into non-blocking mode.\n+\tsyscall.ForkLock.RLock()\n+\tnfd, sa, err = syscall.Accept(fd)\n+\tif err == nil {\n+\t\tsyscall.CloseOnExec(nfd)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\tif err != nil {\n+\t\treturn -1, nil, err\n+\t}\n+\tif err = syscall.SetNonblock(nfd, true); err != nil {\n+\t\tsyscall.Close(nfd)\n+\t\treturn -1, nil, err\n+\t}\n+\treturn nfd, sa, nil\n+}"}, {"sha": "9cd149e466b381237ff75af45a152f01ab45e25d", "filename": "libgo/go/net/sock_posix.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_posix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -17,15 +17,10 @@ var listenerBacklog = maxListenerBacklog()\n \n // Generic socket creation.\n func socket(net string, f, t, p int, ipv6only bool, ulsa, ursa syscall.Sockaddr, deadline time.Time, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n-\t// See ../syscall/exec_unix.go for description of ForkLock.\n-\tsyscall.ForkLock.RLock()\n-\ts, err := syscall.Socket(f, t, p)\n+\ts, err := sysSocket(f, t, p)\n \tif err != nil {\n-\t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, err\n \t}\n-\tsyscall.CloseOnExec(s)\n-\tsyscall.ForkLock.RUnlock()\n \n \tif err = setDefaultSockopts(s, f, t, ipv6only); err != nil {\n \t\tclosesocket(s)"}, {"sha": "fc5d9e5de21e9edf3f14c209787904a2a0cd59d6", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -41,3 +41,14 @@ func listenerSockaddr(s syscall.Handle, f int, la syscall.Sockaddr, toAddr func(\n \t}\n \treturn la, nil\n }\n+\n+func sysSocket(f, t, p int) (syscall.Handle, error) {\n+\t// See ../syscall/exec_unix.go for description of ForkLock.\n+\tsyscall.ForkLock.RLock()\n+\ts, err := syscall.Socket(f, t, p)\n+\tif err == nil {\n+\t\tsyscall.CloseOnExec(s)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\treturn s, err\n+}"}, {"sha": "75d5688a163af10333d79f7385efe4115fcf6911", "filename": "libgo/go/net/sys_cloexec.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsys_cloexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fsys_cloexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsys_cloexec.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements sysSocket and accept for platforms that do not\n+// provide a fast path for setting SetNonblock and CloseOnExec.\n+\n+// +build darwin freebsd netbsd openbsd\n+\n+package net\n+\n+import \"syscall\"\n+\n+// Wrapper around the socket system call that marks the returned file\n+// descriptor as nonblocking and close-on-exec.\n+func sysSocket(f, t, p int) (int, error) {\n+\t// See ../syscall/exec_unix.go for description of ForkLock.\n+\tsyscall.ForkLock.RLock()\n+\ts, err := syscall.Socket(f, t, p)\n+\tif err == nil {\n+\t\tsyscall.CloseOnExec(s)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\tif err = syscall.SetNonblock(s, true); err != nil {\n+\t\tsyscall.Close(s)\n+\t\treturn -1, err\n+\t}\n+\treturn s, nil\n+}\n+\n+// Wrapper around the accept system call that marks the returned file\n+// descriptor as nonblocking and close-on-exec.\n+func accept(fd int) (int, syscall.Sockaddr, error) {\n+\t// See ../syscall/exec_unix.go for description of ForkLock.\n+\t// It is okay to hold the lock across syscall.Accept\n+\t// because we have put fd.sysfd into non-blocking mode.\n+\tsyscall.ForkLock.RLock()\n+\tnfd, sa, err := syscall.Accept(fd)\n+\tif err == nil {\n+\t\tsyscall.CloseOnExec(nfd)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\tif err != nil {\n+\t\treturn -1, nil, err\n+\t}\n+\tif err = syscall.SetNonblock(nfd, true); err != nil {\n+\t\tsyscall.Close(nfd)\n+\t\treturn -1, nil, err\n+\t}\n+\treturn nfd, sa, nil\n+}"}, {"sha": "1d54b3adcc759c2af45ad93997aaf515e127cb32", "filename": "libgo/go/net/tcp_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftcp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftcp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcp_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -159,8 +159,7 @@ var tcpListenerNameTests = []struct {\n \n func TestTCPListenerName(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n-\t\tt.Logf(\"skipping test to avoid external network\")\n-\t\treturn\n+\t\tt.Skip(\"skipping test to avoid external network\")\n \t}\n \n \tfor _, tt := range tcpListenerNameTests {"}, {"sha": "bd5a2a287754d8d6624583039cd040f71e570eec", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "patch": "@@ -26,11 +26,6 @@ func sockaddrToTCP(sa syscall.Sockaddr) Addr {\n \t\treturn &TCPAddr{IP: sa.Addr[0:], Port: sa.Port}\n \tcase *syscall.SockaddrInet6:\n \t\treturn &TCPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}\n-\tdefault:\n-\t\tif sa != nil {\n-\t\t\t// Diagnose when we will turn a non-nil sockaddr into a nil.\n-\t\t\tpanic(\"unexpected type in sockaddrToTCP\")\n-\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "7cf45ca0a09269e09afdfd9dc67916a8e75395ba", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "220422e132e1563907d494911cbb0fd1b4c8a31a", "filename": "libgo/go/net/udp_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "385cd902eb800f8358b55c47e93db05beca08e66", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a8855cab7da7441f9087b17d2a846430ccd81719", "filename": "libgo/go/net/unicast_posix_test.go", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Funicast_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Funicast_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_posix_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "68f2c2f6e7e176d19f4671dffb7ed5b7be534f2d", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "cd3b0b9e8c7a734200dc941687bcc38b68b20020", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "ff8954fd020f2d23ed42e3f2d4de601dc0e64358", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "2bd5b6888d98b07a0ec2acef6336e9c9ab638fa8", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "38adcf95c7931bb6f20b35e7944cf61ee7df7519", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "560f7a0c32480f74861c97b7d4a53fbd9ad7ac66", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "16c4120dc6c93d6fb316bf8fd71fd6200e52b752", "filename": "libgo/go/os/path_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a2ce9a39f56882ad528495229ff601f8f7c67ade", "filename": "libgo/go/os/pipe_bsd.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpipe_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpipe_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpipe_bsd.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "9bafad84f9fd2d1f0781fd0c110969e546e1a6b7", "filename": "libgo/go/os/pipe_linux.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpipe_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fpipe_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpipe_linux.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "38c436ec54d2450e6125be36d4ae243d602d1153", "filename": "libgo/go/os/proc.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fproc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "509b273aa2ff866e63189104f49a6b1af3c10a34", "filename": "libgo/go/os/signal/signal_test.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "444a9aacd47cdc557b2aef1c612903c377ea249c", "filename": "libgo/go/os/user/user_test.go", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "15f571509b9fe86942de21f7b671575193e1f658", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "dd1fe9d181d740b63c58c43e8af1dc5e2bca63cd", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "b4cdea342ad93a81c8b1917e18a2f74a522c2c3f", "filename": "libgo/go/regexp/exec_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "c516a1566f7e04e3d226e9bd15bfefe12bc503b6", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "2896b21417afad5ece2836198dfe2b4fc758cd3d", "filename": "libgo/go/runtime/debug/stack.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "b15054662225636e1aeb3b1bc11a155d0e15b4f2", "filename": "libgo/go/runtime/mgc0.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fmgc0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fmgc0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc0.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "5762e17d36db1f280fce5de4fabf7b3ac20d5128", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "bf97fb148dde187cca41edaf45b153e7a0bed116", "filename": "libgo/go/runtime/proc_test.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fproc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fproc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "e458793491db8be19c4f0de6be2fe57f4e8f1189", "filename": "libgo/go/runtime/runtime_test.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "294b7a9bfbb50e2b9cd199fb1111a3dfcfb5d133", "filename": "libgo/go/strconv/fp_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ffp_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "08d3c4ef0981f332322ac51c4a893476591b0404", "filename": "libgo/go/strconv/testdata/testfp.txt", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fstrconv%2Ftestdata%2Ftestfp.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fstrconv%2Ftestdata%2Ftestfp.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ftestdata%2Ftestfp.txt?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "25be63b5a37156f9342603a7a22b0023a4e15e6a", "filename": "libgo/go/sync/atomic/atomic_test.go", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "27a12c984884199b8ebaf927c528bd1140870fd0", "filename": "libgo/go/sync/atomic/doc.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "c8eed532db76503a84dafa4cd080009d904f0661", "filename": "libgo/go/syscall/exec_bsd.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "e29878acbd290583845786736cf32deb8f026c0f", "filename": "libgo/go/syscall/exec_linux.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "d4aa959c1e053e31974f7d8b1be3eabea1696a0b", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "7d780e6ef718fb9817024ad273be28cc3214d25b", "filename": "libgo/go/syscall/libcall_linux.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "49550ea2f021b5171718e8fe61a674fc74c0ad23", "filename": "libgo/go/syscall/netlink_linux.go", "status": "modified", "additions": 66, "deletions": 104, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a2e26a1f4711bfd17f4ce700c3c70f8ce593fb8f", "filename": "libgo/go/syscall/sockcmsg_linux.go", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "fc83df123dbac9420383afa31e4bbb545e55ef71", "filename": "libgo/go/syscall/sockcmsg_unix.go", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "25fb2d61918dbfc37d7d9290438ccafb756fc70f", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "828c2d3eda809e1fc940e36e35c5944857592fb6", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "c1917f8fe03c492250a1b507d48643b8e3fcb519", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "2da339ce8351d9b5a8be237b0b699bbf8a250d5c", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "c0fb9274a3d584e2697defca82186f1b01a1ab21", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "cda565ff3ee59feab9f41d3652366e0bac857ed8", "filename": "libgo/go/time/example_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexample_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "130ca8f7ebeff4dcc275edeb89e5a4a999d25b7f", "filename": "libgo/go/time/export_test.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexport_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "8d21040bf9afe86f1c8c3c1be4aafd1d7a61d370", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "918a9f33be6f8629088337e9099876be2263aa70", "filename": "libgo/go/time/internal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Finternal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Finternal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Finternal_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "1e6b4f2e44250794ea82c4adb76948c5df6ba533", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "e5a9fdf5408c29d0a4b3ef6b017e78e77a9f297b", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "d291672af10a42a05fc47433d2b4a40884944083", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a8953aefd33c666d2d222e66ab73243db8044fde", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "93d0be5e0c180ea9aba29ef4f3f3f4b7210c6b80", "filename": "libgo/go/unicode/utf8/utf8.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "32538de1c7f31e980fe4afea514253e4997cb5f8", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "3ab5ea235f23bba5f6067f784af95897a42bb8c0", "filename": "libgo/runtime/go-nosys.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fgo-nosys.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fgo-nosys.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-nosys.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "6c7378c9ecf3477c0bff152999533660285d3b00", "filename": "libgo/runtime/go-setenv.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fgo-setenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fgo-setenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-setenv.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "5374aff6d9ce94a496aabdd77eef5124d2479e28", "filename": "libgo/runtime/lock_futex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Flock_futex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Flock_futex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_futex.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a484642073f7f347b2493aab29f593680318f06e", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a82077420315e765d0fe179ec1261889fbab069f", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "b405438f9f996ece0eecfc98beb5ee902efb22fb", "filename": "libgo/runtime/mcentral.c", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmcentral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmcentral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmcentral.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "e70694cf0ed5b00fd80be250423bcb1af13cb751", "filename": "libgo/runtime/mem.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "ffbe2cefb2d7152202c0d20977374c00d5d33c15", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 297, "deletions": 63, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "1b478f9ae83719eed1f698f0695ea109f002cfb0", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "23a56f3dc64f5ee932f93336b2f6a6483b7fb4a4", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "e805c90800038771e13ee725d925229b63732c54", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "a937503a09a700eafe14e8b016bf5f7e92fe04d8", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}, {"sha": "82b0400d6498c8a237076c741256bada490be3ea", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}]}