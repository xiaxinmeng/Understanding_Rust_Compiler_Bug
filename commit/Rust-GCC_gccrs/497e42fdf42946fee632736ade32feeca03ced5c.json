{"sha": "497e42fdf42946fee632736ade32feeca03ced5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3ZTQyZmRmNDI5NDZmZWU2MzI3MzZhZGUzMmZlZWNhMDNjZWQ1Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-06-08T15:14:56Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-06-08T15:14:56Z"}, "message": "[multiple changes]\n\n\n2002-06-08  Paolo Carlini  <pcarlini@unitus.it>\n\n\t* testsuite/backwards/strstream_members.cc: New.\n\n2002-06-08  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/backwards/strstream: Format.\n\t* src/strstream.cc: Format.\n\n2002-06-08  Andreas Schwab  <schwab@suse.de>\n\n\t* src/strstream.cc (strstreambuf::overflow): Set _M_buf,\n\t_M_buf_size and _M_buf_size_opt to the new buffer and size.\n\nFrom-SVN: r54375", "tree": {"sha": "f215051312d00fb874e345398d9bd5bb0965023b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f215051312d00fb874e345398d9bd5bb0965023b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/497e42fdf42946fee632736ade32feeca03ced5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497e42fdf42946fee632736ade32feeca03ced5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497e42fdf42946fee632736ade32feeca03ced5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497e42fdf42946fee632736ade32feeca03ced5c/comments", "author": null, "committer": null, "parents": [{"sha": "e36231584063923f764e9702451205dc4371d97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36231584063923f764e9702451205dc4371d97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36231584063923f764e9702451205dc4371d97d"}], "stats": {"total": 967, "additions": 483, "deletions": 484}, "files": [{"sha": "3fc972c46027b345ecbc19d386b1932cbe6d1a4d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=497e42fdf42946fee632736ade32feeca03ced5c", "patch": "@@ -1,3 +1,17 @@\n+2002-06-08  Paolo Carlini  <pcarlini@unitus.it>\n+\n+\t* testsuite/backwards/strstream_members.cc: New.\n+\n+2002-06-08  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/backwards/strstream: Format.\n+\t* src/strstream.cc: Format.\n+\t\n+2002-06-08  Andreas Schwab  <schwab@suse.de>\n+\n+\t* src/strstream.cc (strstreambuf::overflow): Set _M_buf,\n+\t_M_buf_size and _M_buf_size_opt to the new buffer and size.\n+\n 2002-06-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* config/os/generic/bits/ctype_noninline.h: Tweak format."}, {"sha": "165c6e70dd4a1316f3b55dc578c8cca7ebd73735", "filename": "libstdc++-v3/include/backward/strstream", "status": "modified", "additions": 115, "deletions": 129, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream?ref=497e42fdf42946fee632736ade32feeca03ced5c", "patch": "@@ -1,6 +1,6 @@\n // Backward-compat support -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -57,132 +57,118 @@\n \n namespace std\n {\n-\n-//----------------------------------------------------------------------\n-// Class strstreambuf, a streambuf class that manages an array of char.\n-// Note that this class is not a template.\n-\n-class strstreambuf : public basic_streambuf<char, char_traits<char> >\n-{\n-public:                         // Types.\n-  typedef char_traits<char>              _Traits;\n-  typedef basic_streambuf<char, _Traits> _Base;\n-\n-public:                         // Constructor, destructor\n-  explicit strstreambuf(streamsize __initial_capacity = 0);\n-  strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n-\n-  strstreambuf(char* __get, streamsize __n, char* __put = 0);\n-  strstreambuf(signed char* __get, streamsize __n, signed char* __put = 0);\n-  strstreambuf(unsigned char* __get, streamsize __n, unsigned char* __put=0);\n-\n-  strstreambuf(const char* __get, streamsize __n);\n-  strstreambuf(const signed char* __get, streamsize __n);\n-  strstreambuf(const unsigned char* __get, streamsize __n);\n-\n-  virtual ~strstreambuf();\n-\n-public:                         // strstreambuf operations.\n-  void freeze(bool = true);\n-  char* str();\n-  int pcount() const;\n-\n-protected:                      // Overridden virtual member functions.\n-  virtual int_type overflow(int_type __c  = _Traits::eof());\n-  virtual int_type pbackfail(int_type __c = _Traits::eof());\n-  virtual int_type underflow();\n-  virtual _Base* setbuf(char* __buf, streamsize __n);\n-  virtual pos_type seekoff(off_type __off, ios_base::seekdir __dir,\n-                           ios_base::openmode __mode\n-                                      = ios_base::in | ios_base::out);\n-  virtual pos_type seekpos(pos_type __pos, ios_base::openmode __mode\n-                                      = ios_base::in | ios_base::out);\n-\n-private:                        // Helper functions.\n-  // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n-  char* _M_alloc(size_t);\n-  void  _M_free(char*);\n-\n-  // Helper function used in constructors.\n-  void _M_setup(char* __get, char* __put, streamsize __n);\n-\n-private:                        // Data members.\n-  void* (*_M_alloc_fun)(size_t);\n-  void  (*_M_free_fun)(void*);\n-\n-  bool _M_dynamic  : 1;\n-  bool _M_frozen   : 1;\n-  bool _M_constant : 1;\n-};\n-\n-//----------------------------------------------------------------------\n-// Class istrstream, an istream that manages a strstreambuf.\n-\n-class istrstream : public basic_istream<char>\n-{\n-public:\n-  explicit istrstream(char*);\n-  explicit istrstream(const char*);\n-  istrstream(char* , streamsize);\n-  istrstream(const char*, streamsize);\n-  virtual ~istrstream();\n-\n-  strstreambuf* rdbuf() const;\n-  char* str();\n-\n-private:\n-  strstreambuf _M_buf;\n-};\n-\n-//----------------------------------------------------------------------\n-// Class ostrstream\n-\n-class ostrstream : public basic_ostream<char>\n-{\n-public:\n-  ostrstream();\n-  ostrstream(char*, int, ios_base::openmode = ios_base::out);\n-  virtual ~ostrstream();\n-\n-  strstreambuf* rdbuf() const;\n-  void freeze(bool = true);\n-  char* str();\n-  int pcount() const;\n-\n-private:\n-  strstreambuf _M_buf;\n-};\n-\n-//----------------------------------------------------------------------\n-// Class strstream\n-\n-class strstream : public basic_iostream<char>\n-{\n-public:\n-  typedef char                        char_type;\n-  typedef char_traits<char>::int_type int_type;\n-  typedef char_traits<char>::pos_type pos_type;\n-  typedef char_traits<char>::off_type off_type;\n-\n-  strstream();\n-  strstream(char*, int, ios_base::openmode = ios_base::in | ios_base::out);\n-  virtual ~strstream();\n-\n-  strstreambuf* rdbuf() const;\n-  void freeze(bool = true);\n-  int pcount() const;\n-  char* str();\n-\n-private:\n-  strstreambuf _M_buf;\n-};\n-\n+  // Class strstreambuf, a streambuf class that manages an array of char.\n+  // Note that this class is not a template.\n+  class strstreambuf : public basic_streambuf<char, char_traits<char> >\n+  {\n+  public:                         \n+    // Types.\n+    typedef char_traits<char>              _Traits;\n+    typedef basic_streambuf<char, _Traits> _Base;\n+\n+  public:  \n+    // Constructor, destructor\n+    explicit strstreambuf(streamsize __initial_capacity = 0);\n+    strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n+\n+    strstreambuf(char* __get, streamsize __n, char* __put = 0);\n+    strstreambuf(signed char* __get, streamsize __n, signed char* __put = 0);\n+    strstreambuf(unsigned char* __get, streamsize __n, unsigned char* __put=0);\n+\n+    strstreambuf(const char* __get, streamsize __n);\n+    strstreambuf(const signed char* __get, streamsize __n);\n+    strstreambuf(const unsigned char* __get, streamsize __n);\n+\n+    virtual ~strstreambuf();\n+\n+  public:\n+    void freeze(bool = true);\n+    char* str();\n+    int pcount() const;\n+\n+  protected:\n+    virtual int_type overflow(int_type __c  = _Traits::eof());\n+    virtual int_type pbackfail(int_type __c = _Traits::eof());\n+    virtual int_type underflow();\n+    virtual _Base* setbuf(char* __buf, streamsize __n);\n+    virtual pos_type seekoff(off_type __off, ios_base::seekdir __dir,\n+\t\t\t     ios_base::openmode __mode\n+\t\t\t     = ios_base::in | ios_base::out);\n+    virtual pos_type seekpos(pos_type __pos, ios_base::openmode __mode\n+\t\t\t     = ios_base::in | ios_base::out);\n+\n+  private:  \n+    // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n+    char* _M_alloc(size_t);\n+    void  _M_free(char*);\n+\n+    // Helper function used in constructors.\n+    void _M_setup(char* __get, char* __put, streamsize __n);\n+\n+  private:  \n+    // Data members.\n+    void* (*_M_alloc_fun)(size_t);\n+    void  (*_M_free_fun)(void*);\n+\n+    bool _M_dynamic  : 1;\n+    bool _M_frozen   : 1;\n+    bool _M_constant : 1;\n+  };\n+\n+  // Class istrstream, an istream that manages a strstreambuf.\n+  class istrstream : public basic_istream<char>\n+  {\n+  public:\n+    explicit istrstream(char*);\n+    explicit istrstream(const char*);\n+    istrstream(char* , streamsize);\n+    istrstream(const char*, streamsize);\n+    virtual ~istrstream();\n+\n+    strstreambuf* rdbuf() const;\n+    char* str();\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n+\n+  // Class ostrstream\n+  class ostrstream : public basic_ostream<char>\n+  {\n+  public:\n+    ostrstream();\n+    ostrstream(char*, int, ios_base::openmode = ios_base::out);\n+    virtual ~ostrstream();\n+\n+    strstreambuf* rdbuf() const;\n+    void freeze(bool = true);\n+    char* str();\n+    int pcount() const;\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n+\n+  // Class strstream\n+  class strstream : public basic_iostream<char>\n+  {\n+  public:\n+    typedef char                        char_type;\n+    typedef char_traits<char>::int_type int_type;\n+    typedef char_traits<char>::pos_type pos_type;\n+    typedef char_traits<char>::off_type off_type;\n+\n+    strstream();\n+    strstream(char*, int, ios_base::openmode = ios_base::in | ios_base::out);\n+    virtual ~strstream();\n+\n+    strstreambuf* rdbuf() const;\n+    void freeze(bool = true);\n+    int pcount() const;\n+    char* str();\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n } // namespace std\n-\n-#endif /* __SGI_STL_STRSTREAM */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-\n-\n+#endif "}, {"sha": "961ff03944787e1d879e9cb6f3e6a4f70e194f28", "filename": "libstdc++-v3/src/strstream.cc", "status": "modified", "additions": 314, "deletions": 355, "changes": 669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc?ref=497e42fdf42946fee632736ade32feeca03ced5c", "patch": "@@ -1,6 +1,6 @@\n // strstream definitions -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation\n+// Copyright (C) 2001, 2002 Free Software Foundation\n //\n // This file is part of GNU CC.\n //\n@@ -56,410 +56,369 @@\n \n namespace std\n {\n-\n-// strstreambuf constructor, destructor.\n-\n-strstreambuf::strstreambuf(streamsize initial_capacity)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(true), _M_frozen(false), _M_constant(false)\n-{\n-  _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n-  _M_buf = _M_alloc(_M_buf_size);\n-  if (_M_buf) \n-    {\n-      setp(_M_buf, _M_buf + _M_buf_size);\n-      setg(_M_buf, _M_buf, _M_buf);\n-    }\n-}\n-\n-strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n-  : _Base(),\n-    _M_alloc_fun(alloc_f), _M_free_fun(free_f),\n-    _M_dynamic(true), _M_frozen(false), _M_constant(false)\n-{\n-  _M_buf_size = _M_buf_size_opt = 16;\n-  _M_buf = _M_alloc(_M_buf_size);\n-  if (_M_buf) \n-    {\n-      setp(_M_buf, _M_buf + _M_buf_size);\n-      setg(_M_buf, _M_buf, _M_buf);\n+  strstreambuf::strstreambuf(streamsize initial_capacity)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(true), \n+    _M_frozen(false), _M_constant(false)\n+  {\n+    _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n+    _M_buf = _M_alloc(_M_buf_size);\n+    if (_M_buf) \n+      {\n+\tsetp(_M_buf, _M_buf + _M_buf_size);\n+\tsetg(_M_buf, _M_buf, _M_buf);\n+      }\n   }\n-}\n-\n-strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(false)\n-{\n-  _M_setup(get, put, n);\n-}\n-\n-strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(false)\n-{\n-  _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n);\n-}\n-\n-strstreambuf::strstreambuf(unsigned char* get, streamsize n,\n-                           unsigned char* put)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(false)\n-{\n-  _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n);\n-}\n-\n-strstreambuf::strstreambuf(const char* get, streamsize n)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(true)\n-{\n-  _M_setup(const_cast<char*>(get), 0, n);\n-}\n \n-strstreambuf::strstreambuf(const signed char* get, streamsize n)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(true)\n-{\n-  _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n);\n-}\n-\n-strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n-  : _Base(),\n-    _M_alloc_fun(0), _M_free_fun(0),\n-    _M_dynamic(false), _M_frozen(false), _M_constant(true)\n-{\n-  _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n);\n-}\n-\n-strstreambuf::~strstreambuf()\n-{\n-  if (_M_dynamic && !_M_frozen)\n-    {\n-      char* p = this->eback();\n-      _M_free(p);\n-      if (p == _M_buf)\n-\t_M_buf = 0;\n-    }\n-  if (_M_buf)\n-    _M_free(_M_buf);\n-}\n-\n-void strstreambuf::freeze(bool frozenflag)\n-{\n-  if (_M_dynamic)\n-    _M_frozen = frozenflag;\n-}\n-\n-char* strstreambuf::str()\n-{\n-  freeze(true);\n-  return eback();\n-}\n-\n-int strstreambuf::pcount() const\n-{\n-  return pptr() ? pptr() - pbase() : 0;\n-}\n-\n-strstreambuf::int_type strstreambuf::overflow(int_type c) {\n-  if (c == traits_type::eof())\n-    return traits_type::not_eof(c);\n-\n-  // Try to expand the buffer.\n-  if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) {\n-    ptrdiff_t old_size = epptr() - pbase();\n-    ptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n-\n-    char* buf = _M_alloc(new_size);\n-    if (buf) {\n-      memcpy(buf, pbase(), old_size);\n-\n-      char* old_buffer = pbase();\n-      bool reposition_get = false;\n-      ptrdiff_t old_get_offset;\n-      if (gptr() != 0) {\n-        reposition_get = true;\n-        old_get_offset = gptr() - eback();\n+  strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n+  : _Base(), _M_alloc_fun(alloc_f), _M_free_fun(free_f), _M_dynamic(true), \n+    _M_frozen(false), _M_constant(false)\n+  {\n+    _M_buf_size = _M_buf_size_opt = 16;\n+    _M_buf = _M_alloc(_M_buf_size);\n+    if (_M_buf) \n+      {\n+\tsetp(_M_buf, _M_buf + _M_buf_size);\n+\tsetg(_M_buf, _M_buf, _M_buf);\n       }\n-\n-      setp(buf, buf + new_size);\n-      pbump(old_size);\n-\n-      if (reposition_get)\n-        setg(buf, buf + old_get_offset, buf + max(old_get_offset, old_size));\n-\n-      _M_free(old_buffer);\n-    }\n   }\n \n-  if (pptr() != epptr()) {\n-    *pptr() = c;\n-    pbump(1);\n-    return c;\n+  strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(false)\n+  { _M_setup(get, put, n); }\n+\n+  strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(false)\n+  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+  strstreambuf::strstreambuf(unsigned char* get, streamsize n, \n+\t\t\t     unsigned char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(false)\n+  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+  strstreambuf::strstreambuf(const char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(const_cast<char*>(get), 0, n); }\n+\n+  strstreambuf::strstreambuf(const signed char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n); }\n+\n+  strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n); }\n+\n+  strstreambuf::~strstreambuf()\n+  {\n+    if (_M_dynamic && !_M_frozen)\n+      {\n+\tchar* p = this->eback();\n+\t_M_free(p);\n+\tif (p == _M_buf)\n+\t  _M_buf = 0;\n+      }\n+    if (_M_buf)\n+      _M_free(_M_buf);\n   }\n-  else\n-    return traits_type::eof();\n-}\n \n-strstreambuf::int_type strstreambuf::pbackfail(int_type c)\n-{\n-  if (gptr() != eback()) {\n-    if (c == _Traits::eof()) {\n-      gbump(-1);\n-      return _Traits::not_eof(c);\n-    }\n-    else if (c == static_cast<int_type>(gptr()[-1])) {  // KLUDGE\n-      gbump(-1);\n-      return c;\n-    }\n-    else if (!_M_constant) {\n-      gbump(-1);\n-      *gptr() = c;\n-      return c;\n-    }\n+  void \n+  strstreambuf::freeze(bool frozenflag)\n+  {\n+    if (_M_dynamic)\n+      _M_frozen = frozenflag;\n   }\n \n-  return _Traits::eof();\n-}\n-\n-strstreambuf::int_type strstreambuf::underflow()\n-{\n-  if (gptr() == egptr() && pptr() && pptr() > egptr())\n-    setg(eback(), gptr(), pptr());\n-\n-  if (gptr() != egptr())\n-    return (unsigned char) *gptr();\n-  else\n-    return _Traits::eof();\n-}\n-\n-basic_streambuf<char, char_traits<char> >*\n-strstreambuf::setbuf(char*, streamsize)\n-{\n-  return this;\n-}\n-\n-strstreambuf::pos_type\n-strstreambuf::seekoff(off_type off,\n-                      ios_base::seekdir dir, ios_base::openmode mode)\n-{\n-  bool do_get = false;\n-  bool do_put = false;\n-\n-  if ((mode & (ios_base::in | ios_base::out)) ==\n-          (ios_base::in | ios_base::out) &&\n-      (dir == ios_base::beg || dir == ios_base::end))\n-    do_get = do_put = true;\n-  else if (mode & ios_base::in)\n-    do_get = true;\n-  else if (mode & ios_base::out)\n-    do_put = true;\n-\n-  // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n-  // area is undefined if there is no get area.\n-  if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n-    return pos_type(off_type(-1));\n-\n-  char* seeklow  = eback();\n-  char* seekhigh = epptr() ? epptr() : egptr();\n-\n-  off_type newoff;\n-  switch(dir) {\n-  case ios_base::beg:\n-    newoff = 0;\n-    break;\n-  case ios_base::end:\n-    newoff = seekhigh - seeklow;\n-    break;\n-  case ios_base::cur:\n-    newoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n-    break;\n-  default:\n-    return pos_type(off_type(-1));\n+  char* \n+  strstreambuf::str()\n+  {\n+    freeze(true);\n+    return eback();\n   }\n \n-  off += newoff;\n-  if (off < 0 || off > seekhigh - seeklow)\n-    return pos_type(off_type(-1));\n+  int \n+  strstreambuf::pcount() const\n+  { return pptr() ? pptr() - pbase() : 0; }\n+\n+  strstreambuf::int_type \n+  strstreambuf::overflow(int_type c) \n+  {\n+    if (c == traits_type::eof())\n+      return traits_type::not_eof(c);\n+    \n+    // Try to expand the buffer.\n+    if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) \n+      {\n+\tptrdiff_t old_size = epptr() - pbase();\n+\tptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n+\t\n+\tchar* buf = _M_alloc(new_size);\n+\tif (buf) \n+\t  {\n+\t    memcpy(buf, pbase(), old_size);\n+\t    char* old_buffer = pbase();\n+\t    bool reposition_get = false;\n+\t    ptrdiff_t old_get_offset;\n+\t    if (gptr() != 0) \n+\t      {\n+\t\treposition_get = true;\n+\t\told_get_offset = gptr() - eback();\n+\t      }\n+\t    \n+\t    _M_buf = buf;\n+\t    _M_buf_size = _M_buf_size_opt = new_size;\n+\t    setp(buf, buf + new_size);\n+\t    pbump(old_size);\n+\n+\t    if (reposition_get)\n+\t      setg(buf, buf + old_get_offset, buf + \n+\t\t   max(old_get_offset, old_size));\n+\n+\t    _M_free(old_buffer);\n+\t  }\n+      }\n+    \n+    if (pptr() != epptr()) \n+      {\n+\t*pptr() = c;\n+\tpbump(1);\n+\treturn c;\n+      }\n+    else\n+      return traits_type::eof();\n+  }\n \n-  if (do_put) {\n-    if (seeklow + off < pbase()) {\n-      setp(seeklow, epptr());\n-      pbump(off);\n-    }\n-    else {\n-      setp(pbase(), epptr());\n-      pbump(off - (pbase() - seeklow));\n+  strstreambuf::int_type \n+  strstreambuf::pbackfail(int_type c)\n+  {\n+    if (gptr() != eback()) \n+      {\n+      if (c == _Traits::eof()) \n+\t{\n+\t  gbump(-1);\n+\t  return _Traits::not_eof(c);\n+\t}\n+      else if (c == static_cast<int_type>(gptr()[-1])) \n+\t{  // KLUDGE\n+\t  gbump(-1);\n+\t  return c;\n+\t}\n+      else if (!_M_constant) \n+\t{\n+\t  gbump(-1);\n+\t  *gptr() = c;\n+\t  return c;\n+\t}\n     }\n+    return _Traits::eof();\n   }\n-  if (do_get) {\n-    if (off <= egptr() - seeklow)\n-      setg(seeklow, seeklow + off, egptr());\n-    else if (off <= pptr() - seeklow)\n-      setg(seeklow, seeklow + off, pptr());\n+\n+  strstreambuf::int_type \n+  strstreambuf::underflow()\n+  {\n+    if (gptr() == egptr() && pptr() && pptr() > egptr())\n+      setg(eback(), gptr(), pptr());\n+    \n+    if (gptr() != egptr())\n+      return (unsigned char) *gptr();\n     else\n-      setg(seeklow, seeklow + off, epptr());\n+      return _Traits::eof();\n   }\n \n-  return pos_type(newoff);\n-}\n-\n-strstreambuf::pos_type\n-strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n-{\n-  return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode);\n-}\n+  basic_streambuf<char, char_traits<char> >*\n+  strstreambuf::setbuf(char*, streamsize)\n+  { return this; }\n+\n+  strstreambuf::pos_type\n+  strstreambuf::seekoff(off_type off, ios_base::seekdir dir, \n+\t\t\tios_base::openmode mode)\n+  {\n+    bool do_get = false;\n+    bool do_put = false;\n+\n+    if ((mode & (ios_base::in | ios_base::out)) \n+\t== (ios_base::in | ios_base::out) &&\n+\t(dir == ios_base::beg || dir == ios_base::end))\n+      do_get = do_put = true;\n+    else if (mode & ios_base::in)\n+      do_get = true;\n+    else if (mode & ios_base::out)\n+      do_put = true;\n+\n+    // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n+    // area is undefined if there is no get area.\n+    if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n+      return pos_type(off_type(-1));\n+\n+    char* seeklow  = eback();\n+    char* seekhigh = epptr() ? epptr() : egptr();\n+\n+    off_type newoff;\n+    switch (dir) \n+      {\n+      case ios_base::beg:\n+\tnewoff = 0;\n+\tbreak;\n+      case ios_base::end:\n+\tnewoff = seekhigh - seeklow;\n+\tbreak;\n+      case ios_base::cur:\n+\tnewoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n+\tbreak;\n+      default:\n+\treturn pos_type(off_type(-1));\n+      }\n+    \n+    off += newoff;\n+    if (off < 0 || off > seekhigh - seeklow)\n+      return pos_type(off_type(-1));\n+\n+    if (do_put) \n+      {\n+\tif (seeklow + off < pbase()) \n+\t  {\n+\t    setp(seeklow, epptr());\n+\t    pbump(off);\n+\t  }\n+\telse \n+\t  {\n+\t    setp(pbase(), epptr());\n+\t    pbump(off - (pbase() - seeklow));\n+\t  }\n+      }\n+    if (do_get) \n+      {\n+\tif (off <= egptr() - seeklow)\n+\t  setg(seeklow, seeklow + off, egptr());\n+\telse if (off <= pptr() - seeklow)\n+\t  setg(seeklow, seeklow + off, pptr());\n+\telse\n+\t  setg(seeklow, seeklow + off, epptr());\n+      }\n+    return pos_type(newoff);\n+  }\n \n-char* strstreambuf::_M_alloc(size_t n)\n-{\n-  if (_M_alloc_fun)\n-    return static_cast<char*>(_M_alloc_fun(n));\n-  else\n-    return new char[n];\n-}\n+  strstreambuf::pos_type\n+  strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n+  { return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode); }\n \n-void strstreambuf::_M_free(char* p)\n-{\n-  if (p)\n-    if (_M_free_fun)\n-      _M_free_fun(p);\n+  char* \n+  strstreambuf::_M_alloc(size_t n)\n+  {\n+    if (_M_alloc_fun)\n+      return static_cast<char*>(_M_alloc_fun(n));\n     else\n-      delete[] p;\n-}\n-\n-void strstreambuf::_M_setup(char* get, char* put, streamsize n)\n-{\n-  if (get) {\n-    size_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n+      return new char[n];\n+  }\n \n-    if (put) {\n-      setg(get, get, put);\n-      setp(put, put + N);\n-    }\n-    else {\n-      setg(get, get, get + N);\n-    }\n+  void \n+  strstreambuf::_M_free(char* p)\n+  {\n+    if (p)\n+      if (_M_free_fun)\n+\t_M_free_fun(p);\n+      else\n+\tdelete[] p;\n   }\n-}\n \n-//----------------------------------------------------------------------\n-// Class istrstream\n+  void \n+  strstreambuf::_M_setup(char* get, char* put, streamsize n)\n+  {\n+    if (get) \n+      {\n+\tsize_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n+\t\n+\tif (put) \n+\t  {\n+\t    setg(get, get, put);\n+\t    setp(put, put + N);\n+\t  }\n+\telse \n+\t  setg(get, get, get + N);\n+      }\n+  }\n \n-istrstream::istrstream(char* s)\n+  istrstream::istrstream(char* s)\n   : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-istrstream::istrstream(const char* s)\n+  istrstream::istrstream(const char* s)\n   : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-istrstream::istrstream(char* s, streamsize n)\n+  istrstream::istrstream(char* s, streamsize n)\n   : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-istrstream::istrstream(const char* s, streamsize n)\n+  istrstream::istrstream(const char* s, streamsize n)\n   : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n-\n-istrstream::~istrstream() {}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-strstreambuf* istrstream::rdbuf() const {\n-  return const_cast<strstreambuf*>(&_M_buf);\n-}\n+  istrstream::~istrstream() { }\n \n-char* istrstream::str() { return _M_buf.str(); }\n+  strstreambuf* \n+  istrstream::rdbuf() const \n+  { return const_cast<strstreambuf*>(&_M_buf); }\n \n-//----------------------------------------------------------------------\n-// Class ostrstream\n+  char* \n+  istrstream::str() \n+  { return _M_buf.str(); }\n \n-ostrstream::ostrstream()\n+  ostrstream::ostrstream()\n   : basic_ios<char>(), basic_ostream<char>(0), _M_buf()\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n-  : basic_ios<char>(), basic_ostream<char>(0),\n+  ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n+  : basic_ios<char>(), basic_ostream<char>(0), \n     _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-ostrstream::~ostrstream() {}\n+  ostrstream::~ostrstream() {}\n \n-strstreambuf* ostrstream::rdbuf() const\n-{\n-  return const_cast<strstreambuf*>(&_M_buf);\n-}\n+  strstreambuf* \n+  ostrstream::rdbuf() const\n+  { return const_cast<strstreambuf*>(&_M_buf); }\n \n-void ostrstream::freeze(bool freezeflag)\n-{\n-  _M_buf.freeze(freezeflag);\n-}\n+  void \n+  ostrstream::freeze(bool freezeflag)\n+  { _M_buf.freeze(freezeflag); }\n \n-char* ostrstream::str()\n-{\n-  return _M_buf.str();\n-}\n+  char* \n+  ostrstream::str()\n+  { return _M_buf.str(); }\n \n-int ostrstream::pcount() const\n-{\n-  return _M_buf.pcount();\n-}\n-\n-//----------------------------------------------------------------------\n-// Class strstream\n+  int \n+  ostrstream::pcount() const\n+  { return _M_buf.pcount(); }\n \n-strstream::strstream()\n+  strstream::strstream()\n   : basic_ios<char>(), basic_iostream<char>(0), _M_buf()\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-strstream::strstream(char* s, int n, ios_base::openmode mode)\n-  : basic_ios<char>(), basic_iostream<char>(0),\n+  strstream::strstream(char* s, int n, ios_base::openmode mode)\n+  : basic_ios<char>(), basic_iostream<char>(0), \n     _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-{\n-  basic_ios<char>::init(&_M_buf);\n-}\n-\n-strstream::~strstream() {}\n+  { basic_ios<char>::init(&_M_buf); }\n \n-strstreambuf* strstream::rdbuf() const\n-{\n-  return const_cast<strstreambuf*>(&_M_buf);\n-}\n+  strstream::~strstream() { }\n \n-void strstream::freeze(bool freezeflag)\n-{\n-  _M_buf.freeze(freezeflag);\n-}\n+  strstreambuf* \n+  strstream::rdbuf() const\n+  { return const_cast<strstreambuf*>(&_M_buf); }\n \n-int strstream::pcount() const\n-{\n-  return _M_buf.pcount();\n-}\n+  void \n+  strstream::freeze(bool freezeflag)\n+  { _M_buf.freeze(freezeflag); }\n \n-char* strstream::str()\n-{\n-  return _M_buf.str();\n-}\n+  int \n+  strstream::pcount() const\n+  { return _M_buf.pcount(); }\n \n+  char* \n+  strstream::str()\n+  { return _M_buf.str(); }\n } // namespace std\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "494008e4c2b7ff7a71a3ad7d31870edf341f50cd", "filename": "libstdc++-v3/testsuite/backward/strstream_members.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497e42fdf42946fee632736ade32feeca03ced5c/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc?ref=497e42fdf42946fee632736ade32feeca03ced5c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// backward strstream members\n+\n+#include <strstream.h>\n+#include <testsuite_hooks.h>\n+\n+// { dg-options \"-Wno-deprecated\" }\n+\n+int test01()\n+{\n+   strstream s;\n+   for (unsigned i=0 ; i!= 1000 ; ++i)\n+      s << i << std::endl;\n+   s << std::ends;\n+\n+   return 0;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}