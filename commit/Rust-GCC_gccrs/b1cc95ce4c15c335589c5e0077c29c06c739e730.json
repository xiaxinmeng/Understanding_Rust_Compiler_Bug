{"sha": "b1cc95ce4c15c335589c5e0077c29c06c739e730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjYzk1Y2U0YzE1YzMzNTU4OWM1ZTAwNzdjMjljMDZjNzM5ZTczMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-02T06:25:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-02T06:25:36Z"}, "message": "re PR c++/16224 (internal compiler error: in write_unscoped_name (template/namespace))\n\n\tPR c++/16224\n\t* name-lookup.c (decl_namespace): Remove.\n\t(current_decl_namespace): Use decl_namespace_context instead of\n\tdecl_namespace.\n\t(push_decl_namespace): Likewise.\n\t(arg_assoc_class): Likewise.\n\t(arg_assoc_type): Likewise.\n\t* pt.c (check_specialization_namespace): New function.\n\t(maybe_process_partial_specialization): Use it.\n\t(register_specialization): Likewise.\n\n\tPR c++/16224\n\t* g++.dg/template/spec17.C: New test.\n\t* g++.old-deja/g++.ns/template13.C: Remove XFAIL.\n\t* g++.old-deja/g++.pt/lookup10.C: Add dg-error marker.\n\nFrom-SVN: r85431", "tree": {"sha": "c3d8dbd637ffc5e31556926ff4cb38f427e0d90a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d8dbd637ffc5e31556926ff4cb38f427e0d90a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1cc95ce4c15c335589c5e0077c29c06c739e730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cc95ce4c15c335589c5e0077c29c06c739e730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1cc95ce4c15c335589c5e0077c29c06c739e730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cc95ce4c15c335589c5e0077c29c06c739e730/comments", "author": null, "committer": null, "parents": [{"sha": "e9475fa369a6f1491864fc3f768a08573a4a5456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9475fa369a6f1491864fc3f768a08573a4a5456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9475fa369a6f1491864fc3f768a08573a4a5456"}], "stats": {"total": 209, "additions": 122, "deletions": 87}, "files": [{"sha": "81a819a793167575e1b90f0894c7518ab69b00fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -1,5 +1,16 @@\n 2004-08-01  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/16224\n+\t* name-lookup.c (decl_namespace): Remove.\n+\t(current_decl_namespace): Use decl_namespace_context instead of\n+\tdecl_namespace.\n+\t(push_decl_namespace): Likewise.\n+\t(arg_assoc_class): Likewise.\n+\t(arg_assoc_type): Likewise.\n+\t* pt.c (check_specialization_namespace): New function.\n+\t(maybe_process_partial_specialization): Use it.\n+\t(register_specialization): Likewise.\n+\n \tPR c++/16489\n \t* cp-tree.h (DECL_INTEGRAL_CONSTANT_VAR_P): New macro.\n \t* call.c (null_ptr_cst_p): Handle variables with constant"}, {"sha": "c44541285fb73ef850f2419225ddf816f05b3098", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -2991,27 +2991,6 @@ set_namespace_binding (tree name, tree scope, tree val)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n-/* Compute the namespace where a declaration is defined.  */\n-\n-static tree\n-decl_namespace (tree decl)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (TYPE_P (decl))\n-    decl = TYPE_STUB_DECL (decl);\n-  while (DECL_CONTEXT (decl))\n-    {\n-      decl = DECL_CONTEXT (decl);\n-      if (TREE_CODE (decl) == NAMESPACE_DECL)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-      if (TYPE_P (decl))\n-\tdecl = TYPE_STUB_DECL (decl);\n-      my_friendly_assert (DECL_P (decl), 390);\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, global_namespace);\n-}\n-\n /* Set the context of a declaration to scope. Complain if we are not\n    outside scope.  */\n \n@@ -3080,9 +3059,9 @@ current_decl_namespace (void)\n     return TREE_PURPOSE (decl_namespace_list);\n \n   if (current_class_type)\n-    result = decl_namespace (TYPE_STUB_DECL (current_class_type));\n+    result = decl_namespace_context (current_class_type);\n   else if (current_function_decl)\n-    result = decl_namespace (current_function_decl);\n+    result = decl_namespace_context (current_function_decl);\n   else \n     result = current_namespace;\n   return result;\n@@ -3210,7 +3189,7 @@ void\n push_decl_namespace (tree decl)\n {\n   if (TREE_CODE (decl) != NAMESPACE_DECL)\n-    decl = decl_namespace (decl);\n+    decl = decl_namespace_context (decl);\n   decl_namespace_list = tree_cons (ORIGINAL_NAMESPACE (decl),\n                                    NULL_TREE, decl_namespace_list);\n }\n@@ -4394,7 +4373,7 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n     return false;\n   k->classes = tree_cons (type, NULL_TREE, k->classes);\n   \n-  context = decl_namespace (TYPE_MAIN_DECL (type));\n+  context = decl_namespace_context (type);\n   if (arg_assoc_namespace (k, context))\n     return true;\n \n@@ -4483,7 +4462,7 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n+      return arg_assoc_namespace (k, decl_namespace_context (type));\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n \t fall through.  */"}, {"sha": "1e9bbb131227989f6fa93ca5c9c0d69c301e40a2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 83, "deletions": 57, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -708,6 +708,36 @@ end_explicit_instantiation (void)\n   processing_explicit_instantiation = false;\n }\n \n+/* A explicit specialization or partial specialization TMPL is being\n+   declared.  Check that the namespace in which the specialization is\n+   occurring is permissible.  Returns false iff it is invalid to\n+   specialize TMPL in the current namespace.  */\n+   \n+static bool\n+check_specialization_namespace (tree tmpl)\n+{\n+  tree tpl_ns = decl_namespace_context (tmpl);\n+\n+  /* [tmpl.expl.spec]\n+     \n+     An explicit specialization shall be declared in the namespace of\n+     which the template is a member, or, for member templates, in the\n+     namespace of which the enclosing class or enclosing class\n+     template is a member.  An explicit specialization of a member\n+     function, member class or static data member of a class template\n+     shall be declared in the namespace of which the class template is\n+     a member.  */\n+  if (is_associated_namespace (current_namespace, tpl_ns))\n+    /* Same or super-using namespace.  */\n+    return true;\n+  else\n+    {\n+      pedwarn (\"specialization of `%D' in different namespace\", tmpl);\n+      cp_pedwarn_at (\"  from definition of `%#D'\", tmpl);\n+      return false;\n+    }\n+}\n+\n /* The TYPE is being declared.  If it is a template type, that means it\n    is a partial specialization.  Do appropriate error-checking.  */\n \n@@ -733,15 +763,7 @@ maybe_process_partial_specialization (tree type)\n       if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n \t  && !COMPLETE_TYPE_P (type))\n \t{\n-\t  tree tpl_ns = decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type));\n-\t  if (is_associated_namespace (current_namespace, tpl_ns))\n-\t    /* Same or super-using namespace.  */;\n-\t  else\n-\t    {\n-\t      pedwarn (\"specializing `%#T' in different namespace\", type);\n-\t      cp_pedwarn_at (\"  from definition of `%#D'\",\n-\t\t\t     CLASSTYPE_TI_TEMPLATE (type));\n-\t    }\n+\t  check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (type));\n \t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (type);\n \t  if (processing_template_decl)\n \t    push_template_decl (TYPE_MAIN_DECL (type));\n@@ -1057,64 +1079,68 @@ register_specialization (tree spec, tree tmpl, tree args)\n \t more convenient to simply allow this than to try to prevent it.  */\n       if (fn == spec)\n \treturn spec;\n-      else if (comp_template_args (TREE_PURPOSE (s), args))\n+      else if (comp_template_args (TREE_PURPOSE (s), args)\n+\t       && DECL_TEMPLATE_SPECIALIZATION (spec))\n \t{\n-\t  if (DECL_TEMPLATE_SPECIALIZATION (spec))\n+\t  if (DECL_TEMPLATE_INSTANTIATION (fn))\n \t    {\n-\t      if (DECL_TEMPLATE_INSTANTIATION (fn))\n+\t      if (TREE_USED (fn) \n+\t\t  || DECL_EXPLICIT_INSTANTIATION (fn))\n \t\t{\n-\t\t  if (TREE_USED (fn) \n-\t\t      || DECL_EXPLICIT_INSTANTIATION (fn))\n-\t\t    {\n-\t\t      error (\"specialization of %D after instantiation\",\n-\t\t\t\tfn);\n-\t\t      return spec;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* This situation should occur only if the first\n-\t\t\t specialization is an implicit instantiation,\n-\t\t\t the second is an explicit specialization, and\n-\t\t\t the implicit instantiation has not yet been\n-\t\t\t used.  That situation can occur if we have\n-\t\t\t implicitly instantiated a member function and\n-\t\t\t then specialized it later.\n-\n-\t\t\t We can also wind up here if a friend\n-\t\t\t declaration that looked like an instantiation\n-\t\t\t turns out to be a specialization:\n-\n-\t\t\t   template <class T> void foo(T);\n-\t\t\t   class S { friend void foo<>(int) };\n-\t\t\t   template <> void foo(int);  \n-\n-\t\t\t We transform the existing DECL in place so that\n-\t\t\t any pointers to it become pointers to the\n-\t\t\t updated declaration.  \n-\n-\t\t\t If there was a definition for the template, but\n-\t\t\t not for the specialization, we want this to\n-\t\t\t look as if there were no definition, and vice\n-\t\t\t versa.  */\n-\t\t      DECL_INITIAL (fn) = NULL_TREE;\n-\t\t      duplicate_decls (spec, fn);\n-\n-\t\t      return fn;\n-\t\t    }\n+\t\t  error (\"specialization of %D after instantiation\",\n+\t\t\t fn);\n+\t\t  return spec;\n \t\t}\n-\t      else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t      else\n \t\t{\n-\t\t  if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n-\t\t    /* Dup decl failed, but this is a new\n-\t\t       definition. Set the line number so any errors\n-\t\t       match this new definition.  */\n-\t\t    DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (spec);\n+\t\t  /* This situation should occur only if the first\n+\t\t     specialization is an implicit instantiation, the\n+\t\t     second is an explicit specialization, and the\n+\t\t     implicit instantiation has not yet been used.\n+\t\t     That situation can occur if we have implicitly\n+\t\t     instantiated a member function and then\n+\t\t     specialized it later.\n+\n+\t\t     We can also wind up here if a friend declaration\n+\t\t     that looked like an instantiation turns out to be\n+\t\t     a specialization:\n+\n+\t\t       template <class T> void foo(T);\n+\t\t       class S { friend void foo<>(int) };\n+\t\t       template <> void foo(int);  \n+\n+\t\t     We transform the existing DECL in place so that\n+\t\t     any pointers to it become pointers to the updated\n+\t\t     declaration.\n+\n+\t\t     If there was a definition for the template, but\n+\t\t     not for the specialization, we want this to look\n+\t\t     as if there were no definition, and vice\n+\t\t     versa.  */\n+\t\t  DECL_INITIAL (fn) = NULL_TREE;\n+\t\t  duplicate_decls (spec, fn);\n \t\t  \n \t\t  return fn;\n \t\t}\n \t    }\n+\t  else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t    {\n+\t      if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n+\t\t/* Dup decl failed, but this is a new definition. Set\n+\t\t   the line number so any errors match this new\n+\t\t   definition.  */\n+\t\tDECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (spec);\n+\t      \n+\t      return fn;\n+\t    }\n \t}\n-      }\n+    }\n+\n+  /* A specialization must be declared in the same namespace as the\n+     template it is specializing.  */\n+  if (DECL_TEMPLATE_SPECIALIZATION (spec)\n+      && !check_specialization_namespace (tmpl))\n+    DECL_CONTEXT (spec) = decl_namespace_context (tmpl);\n \n   DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n      = tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));"}, {"sha": "eb04ff1fd019d06602cf5b4f6183ccb64aac373a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -1,3 +1,10 @@\n+2004-08-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16224\n+\t* g++.dg/template/spec17.C: New test.\n+\t* g++.old-deja/g++.ns/template13.C: Remove XFAIL.\n+\t* g++.old-deja/g++.pt/lookup10.C: Add dg-error marker.\n+\n 2004-08-02  David Billinghurst\n \n \tPR fortran/16292"}, {"sha": "237557684238f7270be6235fef873c7d32973f0b", "filename": "gcc/testsuite/g++.dg/template/spec17.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec17.C?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/16224\n+\n+namespace io { \n+  template <typename> int foo(); // { dg-error \"\" }\n+} \n+ \n+using namespace io; \n+ \n+template<> int foo<int>(); // { dg-error \"\" }\n+ \n+int a = foo<int>(); "}, {"sha": "058d7b9ec88e07492c9c5005cd8234e05b7e645f", "filename": "gcc/testsuite/g++.old-deja/g++.ns/template13.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate13.C?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -2,8 +2,9 @@\n // Templates defined outside must be declared inside\n namespace bar\n {\n+  // trick it to provide some prior declaration\n   template<class T>\n-  void foo(); // trick it to provide some prior declaration\n+  void foo(); // { dg-error \"definition\" }\n   template<class T>class X; // { dg-error \"\" } previous declaration\n }\n \n@@ -15,7 +16,7 @@ bar::foo(T const &a)\n }\n \n template<> void bar::foo<int>()\n-{                        // { dg-error \"\" \"\" { xfail *-*-* } } not declared in bar - \n+{                        // { dg-error \"\" }\n }\n \n template<class T,class U>"}, {"sha": "1c04250fc3c0c59ece91d363d87e524c2f9874ef", "filename": "gcc/testsuite/g++.old-deja/g++.pt/lookup10.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cc95ce4c15c335589c5e0077c29c06c739e730/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup10.C?ref=b1cc95ce4c15c335589c5e0077c29c06c739e730", "patch": "@@ -13,8 +13,8 @@ namespace Outer {\n   namespace Core = Core_Real;\n \n   namespace Core_Real {\n-    template<class T> void Foo (T *) {}\n+    template<class T> void Foo (T *) {} // { dg-error \"definition\" }\n   }\n \n-  template<> void Core::Foo<> (Render_Real::Type *) {}\n+  template<> void Core::Foo<> (Render_Real::Type *) {} // { dg-error \"\" }\n }  "}]}