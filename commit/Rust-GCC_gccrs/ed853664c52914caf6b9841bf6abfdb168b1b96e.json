{"sha": "ed853664c52914caf6b9841bf6abfdb168b1b96e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ4NTM2NjRjNTI5MTRjYWY2Yjk4NDFiZjZhYmZkYjE2OGIxYjk2ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-03-31T15:15:04Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-03-31T15:15:04Z"}, "message": "loop-iv.c (suitable_set_for_replacement): Renamed from simplify_using_assignment...\n\n\t* loop-iv.c (suitable_set_for_replacement): Renamed from\n\tsimplify_using_assignment; changed to return bool and to accept new\n\targs DEST and SRC.  Return true iff we find a source/destination pair\n\tthat can be used to make a replacement, and fill SRC and DEST if so.\n\tRemove arg ALTERED.  Don't deal with altered regs here.  All callers\n\tchanged.\n\t(simplify_using_initial_values): Deal with altered regs here and track\n\tmore precisely the effect they have on the validity of our expression.\n\nFrom-SVN: r145351", "tree": {"sha": "bf6fa20b19a417e860e35f143a681c1cc93575fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf6fa20b19a417e860e35f143a681c1cc93575fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed853664c52914caf6b9841bf6abfdb168b1b96e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed853664c52914caf6b9841bf6abfdb168b1b96e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed853664c52914caf6b9841bf6abfdb168b1b96e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed853664c52914caf6b9841bf6abfdb168b1b96e/comments", "author": null, "committer": null, "parents": [{"sha": "bebc6e07b129cd3e159a6a82fb283e8d13c7a1ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebc6e07b129cd3e159a6a82fb283e8d13c7a1ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebc6e07b129cd3e159a6a82fb283e8d13c7a1ff"}], "stats": {"total": 117, "additions": 71, "deletions": 46}, "files": [{"sha": "007b00e8c024adc0d1192239388f324e00d6d75f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed853664c52914caf6b9841bf6abfdb168b1b96e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed853664c52914caf6b9841bf6abfdb168b1b96e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed853664c52914caf6b9841bf6abfdb168b1b96e", "patch": "@@ -1,3 +1,14 @@\n+2009-03-31  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* loop-iv.c (suitable_set_for_replacement): Renamed from\n+\tsimplify_using_assignment; changed to return bool and to accept new\n+\targs DEST and SRC.  Return true iff we find a source/destination pair\n+\tthat can be used to make a replacement, and fill SRC and DEST if so.\n+\tRemove arg ALTERED.  Don't deal with altered regs here.  All callers\n+\tchanged.\n+\t(simplify_using_initial_values): Deal with altered regs here and track\n+\tmore precisely the effect they have on the validity of our expression.\n+\n 2009-03-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n         PR target/27237"}, {"sha": "483a868859dfb8c83f08ea4a2a3b09598aca2792", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed853664c52914caf6b9841bf6abfdb168b1b96e/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed853664c52914caf6b9841bf6abfdb168b1b96e/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=ed853664c52914caf6b9841bf6abfdb168b1b96e", "patch": "@@ -1364,39 +1364,23 @@ simple_rhs_p (rtx rhs)\n     }\n }\n \n-/* Simplifies *EXPR using assignment in INSN.  ALTERED is the set of registers\n-   altered so far.  */\n+/* A subroutine of simplify_using_initial_values, this function examines INSN\n+   to see if it contains a suitable set that we can use to make a replacement.\n+   If it is suitable, return true and set DEST and SRC to the lhs and rhs of\n+   the set; return false otherwise.  */\n \n-static void\n-simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n+static bool\n+suitable_set_for_replacement (rtx insn, rtx *dest, rtx *src)\n {\n   rtx set = single_set (insn);\n   rtx lhs = NULL_RTX, rhs;\n-  bool ret = false;\n \n-  if (set)\n-    {\n-      lhs = SET_DEST (set);\n-      if (!REG_P (lhs)\n-\t  || altered_reg_used (&lhs, altered))\n-\tret = true;\n-    }\n-  else\n-    ret = true;\n-\n-  note_stores (PATTERN (insn), mark_altered, altered);\n-  if (CALL_P (insn))\n-    {\n-      int i;\n-\n-      /* Kill all call clobbered registers.  */\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t  SET_REGNO_REG_SET (altered, i);\n-    }\n+  if (!set)\n+    return false;\n \n-  if (ret)\n-    return;\n+  lhs = SET_DEST (set);\n+  if (!REG_P (lhs))\n+    return false;\n \n   rhs = find_reg_equal_equiv_note (insn);\n   if (rhs)\n@@ -1405,12 +1389,11 @@ simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n     rhs = SET_SRC (set);\n \n   if (!simple_rhs_p (rhs))\n-    return;\n-\n-  if (for_each_rtx (&rhs, altered_reg_used, altered))\n-    return;\n+    return false;\n \n-  *expr = simplify_replace_rtx (*expr, lhs, rhs);\n+  *dest = lhs;\n+  *src = rhs;\n+  return true;\n }\n \n /* Checks whether A implies B.  */\n@@ -1762,9 +1745,10 @@ eliminate_implied_conditions (enum rtx_code op, rtx *head, rtx tail)\n static void\n simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n {\n-  rtx head, tail, insn;\n+  bool expression_valid;\n+  rtx head, tail, insn, last_valid_expr;\n   rtx neutral, aggr;\n-  regset altered;\n+  regset altered, this_altered;\n   edge e;\n \n   if (!*expr)\n@@ -1829,7 +1813,10 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n     return;\n \n   altered = ALLOC_REG_SET (&reg_obstack);\n+  this_altered = ALLOC_REG_SET (&reg_obstack);\n \n+  expression_valid = true;\n+  last_valid_expr = *expr;\n   while (1)\n     {\n       insn = BB_END (e->src);\n@@ -1843,29 +1830,52 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t    {\n \t      simplify_using_condition (cond, expr, altered);\n \t      if (CONSTANT_P (*expr))\n-\t\t{\n-\t\t  FREE_REG_SET (altered);\n-\t\t  return;\n-\t\t}\n+\t\tgoto out;\n \t    }\n \t}\n \n       FOR_BB_INSNS_REVERSE (e->src, insn)\n \t{\n+\t  rtx src, dest;\n+\n \t  if (!INSN_P (insn))\n \t    continue;\n-\t    \n-\t  simplify_using_assignment (insn, expr, altered);\n-\t  if (CONSTANT_P (*expr))\n+\n+\t  CLEAR_REG_SET (this_altered);\n+\t  note_stores (PATTERN (insn), mark_altered, this_altered);\n+\t  if (CALL_P (insn))\n \t    {\n-\t      FREE_REG_SET (altered);\n-\t      return;\n+\t      int i;\n+\t\t  \n+\t      /* Kill all call clobbered registers.  */\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+\t\t  SET_REGNO_REG_SET (this_altered, i);\n \t    }\n-\t  if (for_each_rtx (expr, altered_reg_used, altered))\n+\n+\t  if (suitable_set_for_replacement (insn, &dest, &src))\n \t    {\n-\t      FREE_REG_SET (altered);\n-\t      return;\n+\t      *expr = simplify_replace_rtx (*expr, dest, src);\n+\t      if (CONSTANT_P (*expr))\n+\t\tgoto out;\n \t    }\n+\t  else\n+\t    /* If we did not use this insn to make a replacement, any overlap\n+\t       between stores in this insn and our expression will cause the\n+\t       expression to become invalid.  */\n+\t    if (for_each_rtx (expr, altered_reg_used, this_altered))\n+\t      goto out;\n+\n+\t  IOR_REG_SET (altered, this_altered);\n+\n+\t  /* If the expression now contains regs that have been altered, we\n+\t     can't return it to the caller.  However, it is still valid for\n+\t     further simplification, so keep searching to see if we can\n+\t     eventually turn it into a constant.  */\n+\t  if (for_each_rtx (expr, altered_reg_used, altered))\n+\t    expression_valid = false;\n+\t  if (expression_valid)\n+\t    last_valid_expr = *expr;\n \t}\n \n       if (!single_pred_p (e->src)\n@@ -1874,7 +1884,11 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       e = single_pred_edge (e->src);\n     }\n \n+ out:\n+  if (!CONSTANT_P (*expr))\n+    *expr = last_valid_expr;\n   FREE_REG_SET (altered);\n+  FREE_REG_SET (this_altered);\n }\n \n /* Transforms invariant IV into MODE.  Adds assumptions based on the fact"}]}