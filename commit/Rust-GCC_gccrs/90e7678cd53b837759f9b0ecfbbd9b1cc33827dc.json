{"sha": "90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlNzY3OGNkNTNiODM3NzU5ZjliMGVjZmJiZDliMWNjMzM4MjdkYw==", "commit": {"author": {"name": "Denis Chertykov", "email": "denisc@overta.ru", "date": "2000-02-11T22:31:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-02-11T22:31:46Z"}, "message": "Denis Chertykov  <denisc@overta.ru>\n\n        * README.AVR: New file with information about the avr ports.\n        * config/avr: New directory with avr port files.\n\nFrom-SVN: r31935", "tree": {"sha": "b53a0316047aa8eaa515ccfa2834204e22979e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b53a0316047aa8eaa515ccfa2834204e22979e50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/comments", "author": null, "committer": null, "parents": [{"sha": "ed3b04804dac56496d08938d8a9fec74bf6b3961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3b04804dac56496d08938d8a9fec74bf6b3961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3b04804dac56496d08938d8a9fec74bf6b3961"}], "stats": {"total": 9772, "additions": 9763, "deletions": 9}, "files": [{"sha": "1632ef2bb20a79624fa772f785c4aaa37195d3c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -1,3 +1,8 @@\n+2000-02-11  Denis Chertykov  <denisc@overta.ru>\n+\n+\t* README.AVR: New file with information about the avr ports.\n+\t* config/avr: New directory with avr port files.\n+\n 2000-02-11  Andreas Jaeger  <aj@suse.de>\n \n \t* fixinc/Makefile.in (FIXINC_DEFS): Remove unneeded @fixinc_defs@.\n@@ -335,17 +340,17 @@ Thu Feb 10 18:28:59 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n 2000-02-09  Scott Bambrough  <scottb@netwinder.org>\n \n-        * config/arm/arm.md (movsi): In PIC mode, make sure that a\n-        constant source address is legitimate.\n+\t* config/arm/arm.md (movsi): In PIC mode, make sure that a\n+\tconstant source address is legitimate.\n \n 2000-02-09  Philip Blundell  <pb@futuretv.com>\n \n-        * config/arm/arm.c (legitimize_pic_address): Handle LABEL_REF\n-        correctly.\n+\t* config/arm/arm.c (legitimize_pic_address): Handle LABEL_REF\n+\tcorrectly.\n \n-        * config/arm/arm.h (LEGITIMATE_CONSTANT_P): Allow anything when\n-        generating PIC.\n-        (LEGITIMATE_PIC_OPERAND): Disallow references to labels.\n+\t* config/arm/arm.h (LEGITIMATE_CONSTANT_P): Allow anything when\n+\tgenerating PIC.\n+\t(LEGITIMATE_PIC_OPERAND): Disallow references to labels.\n \n 2000-02-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n@@ -396,8 +401,8 @@ Tue Feb  8 15:51:50 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2000-02-08  Clinton Popetz  <cpopetz@cygnus.com>\n \n-        * function.c (thread_prologue_and_epilogue_insns): Don't replace\n-        jumps with returns unless they are jumps to the fallthru block.\n+\t* function.c (thread_prologue_and_epilogue_insns): Don't replace\n+\tjumps with returns unless they are jumps to the fallthru block.\n \n Tue Feb  8 07:53:55 2000  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "0971cecb14ee1b68ec9f9bb77876db89bdaceeed", "filename": "gcc/README.AVR", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2FREADME.AVR", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2FREADME.AVR", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.AVR?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1,23 @@\n+This file describes the implementation notes of the GNU C Compiler for\n+the ATMEL AVR micro controllers family.\n+\n+The generated assembly code requires the GNU assembler (GAS).  This is\n+not currently included as part of the binutils package.\n+Patches against binutils-2.9.5.0.13 can be obtained from\n+http://medo.fov.uni-mb.si/mapp/uTools.  This site also has patches for\n+the GNU debugger (GDB).\n+\n+\n+GCC can be configured as a cross compiler for the AVR architectures\n+on the same system.  Use `configure --target=avr' to configure GCC.\n+\n+\n+Further installation notes and other useful information about AVR tools\n+can also be obtained from http://medo.fov.uni-mb.si/mapp/uTools.\n+\n+\n+Mailing list, avr@fov.uni-mb.si, exists to discuss related issues and\n+suggestions for further optimizations and improvements.\n+\n+\n+Denis Chertykov <denisc@overta.ru>,  30 Jan 2000\n\\ No newline at end of file"}, {"sha": "fc525c285dce2faa2a6a8fe4f25fbb10502df71e", "filename": "gcc/config/avr/avr-protos.h", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1,152 @@\n+/* Prototypes for exported functions defined in avr.c\n+   \n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Denis Chertykov (denisc@overta.ru)\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+\n+extern void   avr_output_ascii                  PARAMS ((FILE *file,\n+\t\t\t\t\t\t\tconst char *p,\n+\t\t\t\t\t\t\tint size));\n+extern int    function_arg_regno_p              PARAMS ((int r));\n+extern void   asm_file_start                    PARAMS ((FILE *file));\n+extern void   asm_file_end                      PARAMS ((FILE *file));\n+extern void   avr_init_once                     PARAMS ((void));\n+extern void   avr_override_options              PARAMS ((void));\n+extern char * avr_change_section                PARAMS ((char *sect_name));\n+extern int    avr_ret_register                  PARAMS((void));\n+extern enum reg_class class_likely_spilled_p    PARAMS ((int c));\n+extern enum reg_class avr_regno_reg_class       PARAMS ((int r));\n+extern enum reg_class avr_reg_class_from_letter PARAMS ((int c));\n+extern int    frame_pointer_required_p          PARAMS ((void));\n+extern void   asm_globalize_label               PARAMS ((FILE *file,\n+\t\t\t\t\t\t\tconst char *name));\n+extern void   order_regs_for_local_alloc        PARAMS ((void));\n+extern int    initial_elimination_offset        PARAMS ((int from, int to));\n+extern void   function_prologue                 PARAMS ((FILE *file, int size));\n+extern void   function_epilogue                 PARAMS ((FILE *file, int size));\n+extern void   progmem_section                   PARAMS ((void));\n+extern int    mask_one_bit_p                    PARAMS ((HOST_WIDE_INT mask));\n+\n+#ifdef TREE_CODE\n+extern void   asm_output_external          PARAMS ((FILE *file, tree decl,\n+\t\t\t\t\t\t   char *name));\n+extern void   unique_section               PARAMS ((tree decl, int reloc));\n+extern void   encode_section_info          PARAMS ((tree decl));\n+extern void   asm_output_section_name      PARAMS ((FILE *file, tree decl,\n+\t\t\t\t\t\t   const char *name,\n+\t\t\t\t\t\t   int reloc));\n+extern int    valid_machine_type_attribute PARAMS ((tree type, tree attributes,\n+\t\t\t\t\t\t   tree identifier,\n+\t\t\t\t\t\t   tree args));\n+extern int    valid_machine_decl_attribute PARAMS ((tree decl, tree attributes,\n+\t\t\t\t\t\t   tree attr, tree args));\n+\n+#ifdef RTX_CODE /* inside TREE_CODE */\n+extern rtx    avr_function_value           PARAMS ((tree type, tree func));\n+extern void   init_cumulative_args         PARAMS ((CUMULATIVE_ARGS *cum,\n+\t\t\t\t\t\t   tree fntype, rtx libname,\n+\t\t\t\t\t\t   int indirect));\n+extern rtx    function_arg         PARAMS ((CUMULATIVE_ARGS *cum,\n+\t\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t\t   tree type, int named));\n+\n+\n+#endif /* RTX_CODE inside TREE_CODE */\n+\n+#ifdef HAVE_MACHINE_MODES /* inside TREE_CODE */\n+extern void   function_arg_advance PARAMS ((CUMULATIVE_ARGS *cum,\n+\t\t\t\t\t   enum machine_mode mode, tree type,\n+\t\t\t\t\t   int named));\n+#endif /* HAVE_MACHINE_MODES inside TREE_CODE*/\n+#endif /* TREE_CODE */\n+\n+#ifdef RTX_CODE\n+extern void   asm_output_external_libcall PARAMS ((FILE *file, rtx symref));\n+extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,\n+\t\t\t\t\tint strict));\n+extern void   machine_dependent_reorg PARAMS ((rtx first_insn));\n+extern int    compare_diff_p  PARAMS ((rtx insn));\n+extern char * out_movqi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * out_movqi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * out_movhi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * out_movhi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * out_movsi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * out_movsi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n+extern char * output_movsisf  PARAMS ((rtx insn, rtx operands[],\n+\t\t\t      \t      int which_alternative));\n+extern char * out_tstsi       PARAMS ((rtx insn, int *l));\n+extern char * out_tsthi       PARAMS ((rtx insn, int *l));\n+extern char * ret_cond_branch PARAMS ((RTX_CODE cond, int len));\n+\n+extern char * ashlqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * ashlhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * ashlsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+\n+extern char * ashrqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * ashrhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * ashrsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+\n+extern char * lshrqi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * lshrhi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+extern char * lshrsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n+\n+extern int    avr_address_cost       PARAMS ((rtx x));\n+extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n+\t\t\t\t\t\t     enum reg_class class));\n+extern int    extra_constraint       PARAMS ((rtx x, char c));\n+extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,\n+\t\t\t\t\t     enum machine_mode mode));\n+extern int    adjust_insn_length     PARAMS ((rtx insn, int len));\n+extern rtx    avr_libcall_value      PARAMS ((enum machine_mode mode));\n+extern char * output_reload_inhi     PARAMS ((rtx insn, rtx *operands,\n+\t\t\t\t\t     int which_alternative));\n+extern char * output_reload_insisf   PARAMS ((rtx insn, rtx *operands,\n+\t\t\t\t\t     int which_alternative));\n+extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n+\t\t\t\t\t     RTX_CODE outer_code));\n+extern void   asm_output_char        PARAMS ((FILE *file, rtx value));\n+extern void   asm_output_short       PARAMS ((FILE *file, rtx value));\n+extern void   asm_output_byte        PARAMS ((FILE *file, char value));\n+extern enum reg_class secondary_input_reload_class PARAMS ((enum reg_class,\n+\t\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t\t   rtx));\n+extern void   notice_update_cc       PARAMS ((rtx body, rtx insn));\n+extern void   print_operand          PARAMS ((FILE *file, rtx x, int code));\n+extern void   print_operand_address  PARAMS ((FILE *file, rtx addr));\n+extern int    reg_unused_after       PARAMS ((rtx insn, rtx reg));\n+extern int    _reg_unused_after      PARAMS ((rtx insn, rtx reg));\n+extern int    avr_jump_mode          PARAMS ((rtx x, rtx insn));\n+extern int    byte_immediate_operand PARAMS ((register rtx op,\n+\t\t\t\t\t     enum machine_mode mode));\n+\n+#endif /* RTX_CODE */\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern int    class_max_nregs        PARAMS ((enum reg_class class,\n+\t\t\t\t\t     enum machine_mode mode));\n+#endif /* HAVE_MACHINE_MODES */\n+\n+#ifdef REAL_VALUE_TYPE\n+\n+extern void   asm_output_float       PARAMS ((FILE *file, REAL_VALUE_TYPE n));\n+\n+#endif \n+\n+"}, {"sha": "21c87dc8846ed8b24f4e5534b431e0b7b52db63e", "filename": "gcc/config/avr/avr.c", "status": "added", "additions": 3750, "deletions": 0, "changes": 3750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc"}, {"sha": "270ae1f389e3e4757e593f86fcbdde961abca271", "filename": "gcc/config/avr/avr.h", "status": "added", "additions": 3206, "deletions": 0, "changes": 3206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc"}, {"sha": "f90db47272750f0b7ebd98d6b312e20925aa3f88", "filename": "gcc/config/avr/avr.md", "status": "added", "additions": 1903, "deletions": 0, "changes": 1903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1,1903 @@\n+;; -*- Mode: Scheme -*-\n+;;   Machine description for GNU compiler,\n+;;   for ATMEL AVR micro controllers.\n+;;   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+;;   Contributed by Denis Chertykov (denisc@overta.ru)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Condition code settings.\n+(define_attr \"cc\" \"none,set_czn,set_zn,set_n,compare,clobber\"\n+  (const_string \"none\"))\n+\n+(define_attr \"type\" \"branch,branch1,arith\"\n+  (const_string \"arith\"))\n+\n+;; The size of instructions in bytes.\n+;; XXX may depend from \"cc\"\n+\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"branch\")\n+         (if_then_else (and (ge (minus (pc) (match_dup 0))\n+                                (const_int -63))\n+                            (le (minus (pc) (match_dup 0))\n+                                (const_int 62)))\n+                       (const_int 1)\n+                       (if_then_else (and (ge (minus (pc) (match_dup 0))\n+                                              (const_int -2045))\n+                                          (le (minus (pc) (match_dup 0))\n+                                              (const_int 2045)))\n+                                     (const_int 2)\n+                                     (const_int 2)))\n+         (eq_attr \"type\" \"branch1\")\n+         (if_then_else (and (ge (minus (pc) (match_dup 0))\n+                                (const_int -62))\n+                            (le (minus (pc) (match_dup 0))\n+                                (const_int 61)))\n+                       (const_int 2)\n+                       (if_then_else (and (ge (minus (pc) (match_dup 0))\n+                                              (const_int -2044))\n+                                          (le (minus (pc) (match_dup 0))\n+                                              (const_int 2043)))\n+                                     (const_int 3)\n+                                     (const_int 3)))]\n+        (const_int 2)))\n+\n+(define_insn \"*pop1\"\n+  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 1)))]\n+  \"\"\n+  \"pop __tmp_reg__\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"*pop2\"\n+  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 2)))]\n+  \"\"\n+  \"pop __tmp_reg__\n+\tpop __tmp_reg__\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*pop3\"\n+  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 3)))]\n+  \"\"\n+  \"pop __tmp_reg__\n+\tpop __tmp_reg__\n+ \tpop __tmp_reg__\"\n+  [(set_attr \"length\" \"3\")])\n+\n+(define_insn \"*pop4\"\n+  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 4)))]\n+  \"\"\n+  \"pop __tmp_reg__\n+\tpop __tmp_reg__\n+\tpop __tmp_reg__\n+\tpop __tmp_reg__\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*pop5\"\n+  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 5)))]\n+  \"\"\n+  \"pop __tmp_reg__\n+\tpop __tmp_reg__\n+\tpop __tmp_reg__\n+\tpop __tmp_reg__\n+\tpop __tmp_reg__\"\n+  [(set_attr \"length\" \"5\")])\n+\n+(define_insn \"*pushqi\"\n+  [(set (mem:QI (post_dec (reg:HI 32)))\n+        (match_operand:QI 0 \"nonmemory_operand\" \"r,L\"))]\n+  \"(operands[0] == const0_rtx || register_operand (operands[0], QImode))\"\n+  \"@\n+\tpush %0\n+\tpush __zero_reg__\"\n+  [(set_attr \"length\" \"1,1\")])\n+\n+\n+(define_insn \"*pushhi\"\n+  [(set (mem:HI (post_dec (reg:HI 32)))\n+        (match_operand:HI 0 \"nonmemory_operand\" \"r,L\"))]\n+  \"(operands[0] == const0_rtx || register_operand (operands[0], HImode))\"\n+  \"@\n+\tpush %B0\\;push %A0\n+\tpush __zero_reg__\\;push __zero_reg__\"\n+  [(set_attr \"length\" \"2,2\")])\n+\n+(define_insn \"*pushsi\"\n+  [(set (mem:SI (post_dec (reg:HI 32)))\n+        (match_operand:SI 0 \"nonmemory_operand\" \"r,L\"))]\n+  \"(operands[0] == const0_rtx || register_operand (operands[0], SImode))\"\n+  \"@\n+\tpush %D0\\;push %C0\\;push %B0\\;push %A0\n+\tpush __zero_reg__\\;push __zero_reg__\\;push __zero_reg__\\;push __zero_reg__\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"*pushsf\"\n+  [(set (mem:SF (post_dec (reg:HI 32)))\n+        (match_operand:SF 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"push %D0\n+\tpush %C0\n+\tpush %B0\n+\tpush %A0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*mov_r_sp\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (reg:HI 32))]\n+  \"\"\n+  \"in %A0,__SP_L__\n+\tin %B0,__SP_H__\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*mov_sp_r\"\n+  [(set (reg:HI 32)\n+        (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"!TARGET_NO_INTERRUPTS\"\n+  \"in __tmp_reg__,__SREG__\n+\tcli\n+\tout __SP_L__,%A0\n+\tout __SREG__,__tmp_reg__\n+\tout __SP_H__,%B0\"\n+  [(set_attr \"length\" \"5\")])\n+\n+(define_insn \"*mov_sp_r_no_interrupts\"\n+  [(set (reg:HI 32)\n+        (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"TARGET_NO_INTERRUPTS\"\n+  \"out __SP_L__,%A0\n+\tout __SP_H__,%B0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;;========================================================================\n+;; move byte\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand(operand0, QImode)\n+      && ! (register_operand(operand1, QImode) || const0_rtx == operand1))\n+    {\n+      operands[1] = copy_to_mode_reg(QImode, operand1);\n+    }\n+ }\"); \n+\n+(define_insn \"*movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,d,Qm,r,q\")\n+\t(match_operand:QI 1 \"general_operand\"      \"r,L,i,rL,Qm,r\"))]\n+  \"(register_operand (operands[0],QImode)\n+    || register_operand (operands[1], QImode) || const0_rtx == operands[1])\"\n+  \"*{\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\treturn AS2 (mov, %0,%1);\n+      case 1:\n+\treturn AS1 (clr, %0);\n+      case 2:\n+\treturn AS2 (ldi, %0,lo8(%1));\n+      case 3:\n+        {\n+          rtx save1=NULL;\n+          if (operands[1] == const0_rtx)\n+            {\n+              save1 = operands[1];\n+              operands[1] = zero_reg_rtx;\n+            }\n+          output_asm_insn (out_movqi_mr_r (insn,operands,NULL), operands);\n+          if (save1)\n+            operands[1] = save1;\n+        }\n+        return \\\"\\\";\n+      case 4:\n+        return out_movqi_r_mr (insn,operands,NULL);\n+      case 5:\n+        return (AS2 (in,__tmp_reg__,__SREG__) CR_TAB\n+\t        \\\"cli\\\"                       CR_TAB\n+\t        AS2 (out,__SREG__,__tmp_reg__)CR_TAB\n+\t        AS2 (out,%0,%1));\n+      }\n+}\"\n+  [(set_attr \"length\" \"1,1,1,5,5,4\")\n+   (set_attr \"cc\" \"none,clobber,none,clobber,clobber,none\")])\n+\n+;;============================================================================\n+;; move word (16 bit)\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\"       \"\"))]\n+  \"\"\n+  \"\n+{\n+   /* One of the ops has to be in a register */\n+  if (!register_operand(operand0, HImode)\n+      && !(register_operand(operand1, HImode)  || const0_rtx == operands[1]))\n+    {\n+      operands[1] = copy_to_mode_reg(HImode, operand1);\n+    }\n+}\")\n+\n+(define_insn \"*movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,d,r,m\")\n+        (match_operand:HI 1 \"general_operand\"       \"r,L,i,m,rL\"))]\n+  \"(register_operand (operands[0],HImode)\n+    || register_operand (operands[1],HImode) || const0_rtx == operands[1])\"\n+  \"*{\n+  rtx link;\n+  switch (which_alternative)\n+    {\n+    case 0: /* mov r,r */\n+      if (true_regnum (operands[0]) > true_regnum (operands[1]))\n+        return (AS2 (mov,%B0,%B1) CR_TAB\n+\t        AS2 (mov,%A0,%A1));\n+      else\n+        return (AS2 (mov,%A0,%A1) CR_TAB\n+\t        AS2 (mov,%B0,%B1));\n+    case 1:  /* mov r,L */\n+      return (AS1 (clr,%A0) CR_TAB\n+\t      AS1 (clr,%B0));\n+    case 2: /* mov r,d */\n+      if (operands[1] == const1_rtx\n+          && (link = find_reg_note (insn, REG_WAS_0, 0))\n+\t  /* Make sure the insn that stored the 0 is still present.  */\n+\t  && ! INSN_DELETED_P (XEXP (link, 0))\n+\t  && GET_CODE (XEXP (link, 0)) != NOTE\n+\t  /* Make sure cross jumping didn't happen here.  */\n+\t  && no_labels_between_p (XEXP (link, 0), insn)\n+\t  /* Make sure the reg hasn't been clobbered.  */\n+\t  && ! reg_set_between_p (operands[0], XEXP (link, 0), insn))\n+      /* Fastest way to change a 0 to a 1.  */\n+        return AS1 (inc,%A0 ; reg_was_0);\n+      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n+\t      AS2 (ldi,%B0,hi8(%1)));\n+    case 3: /* mov r,m*/\n+      return out_movhi_r_mr (insn, operands, NULL);\n+    case 4: /* mov m,r*/\n+        {\n+          rtx save1=NULL;\n+          if (operands[1] == const0_rtx)\n+            {\n+              save1 = operands[1];\n+              operands[1] = zero_reg_rtx;\n+            }\n+          output_asm_insn (out_movhi_mr_r (insn,operands,NULL), operands);\n+          if (save1)\n+            operands[1] = save1;\n+        }\n+        return \\\"\\\";\n+    }\n+}\"\n+  [(set_attr \"length\" \"2,2,2,4,4\")\n+   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+\n+;;==========================================================================\n+;; move double word (32 bit)\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:SI 1 \"general_operand\"  \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register.  */\n+  if (!register_operand (operand0, SImode)\n+      && !(register_operand (operand1, SImode) || const0_rtx == operand1))\n+    {\n+      operands[1] = copy_to_mode_reg (SImode, operand1);\n+    }\n+}\")\n+\n+(define_insn \"*movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,d,r,Qm\")\n+        (match_operand:SI 1 \"general_operand\"      \"r,L,i,Qm,rL\"))]\n+  \"(register_operand (operands[0],SImode)\n+    || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n+  \"* return output_movsisf (insn, operands, which_alternative);\"\n+  [(set_attr \"length\" \"4,4,4,8,8\")\n+   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+\n+;; fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n+;; move floating point numbers (32 bit)\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:SF 1 \"general_operand\"  \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register.  */\n+  if (!register_operand (operand1, SFmode)\n+      && !register_operand (operand0, SFmode))\n+    {\n+      operands[1] = copy_to_mode_reg (SFmode, operand1);\n+    }\n+}\")\n+\n+(define_insn \"*movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,d,r,Qm\")\n+        (match_operand:SF 1 \"general_operand\"      \"r,G,F,Qm,r\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"* return output_movsisf (insn, operands, which_alternative);\"\n+  [(set_attr \"length\" \"4,4,4,8,8\")\n+   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+\n+;;=========================================================================\n+;; move string (like memcpy)\n+\n+(define_expand \"movstrhi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n+\t      (use (match_operand:HI 2 \"const_int_operand\" \"\"))\n+\t      (use (match_operand:HI 3 \"const_int_operand\" \"\"))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (match_dup 6))])]\n+  \"\"\n+  \"{\n+  rtx addr0, addr1;\n+  int cnt8;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+  cnt8 = byte_immediate_operand (operands[2], GET_MODE (operands[2]));\n+  operands[2] = copy_to_mode_reg (cnt8 ? QImode : HImode, operands[2]);\n+  operands[4] = operands[2];\n+\n+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+\n+  operands[5] = addr0;\n+  operands[6] = addr1;\n+\n+  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+  operands[1] = gen_rtx (MEM, BLKmode, addr1);\n+}\")\n+\n+(define_insn \"*movstrqi_insn\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e\"))\n+\t(mem:BLK (match_operand:HI 1 \"register_operand\" \"e\")))\n+   (use (match_operand:QI 2 \"register_operand\" \"r\"))\n+   (use (match_operand:QI 3 \"const_int_operand\" \"i\"))\n+   (clobber (match_dup 2))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"\n+\tld __tmp_reg__,%a1+\n+\tst %a0+,__tmp_reg__\n+\tdec %2\n+\tbrne _PC_-8\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*movstrhi\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e,e\"))\n+\t(mem:BLK (match_operand:HI 1 \"register_operand\" \"e,e\")))\n+   (use (match_operand:HI 2 \"register_operand\" \"!w,d\"))\n+   (use (match_operand:HI 3 \"const_int_operand\" \"\"))\n+   (clobber (match_dup 2))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"*{\n+     if (which_alternative==0)\n+       return (AS2 (ld,__tmp_reg__,%a1+) CR_TAB\n+\t       AS2 (st,%a0+,__tmp_reg__)  CR_TAB\n+\t       AS2 (sbiw,%A2,1) CR_TAB\n+\t       AS1 (brne,_PC_-8));\n+     else\n+       return (AS2 (ld,__tmp_reg__,%a1+) CR_TAB\n+\t       AS2 (st,%a0+,__tmp_reg__)  CR_TAB\n+\t       AS2 (subi,%A2,1) CR_TAB\n+\t       AS2 (sbci,%B2,0) CR_TAB\n+\t       AS1 (brne,_PC_-10));\n+}\"\n+  [(set_attr \"length\" \"4,5\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n+;; =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0\n+;; memset (%0, 0, %1)\n+\n+(define_expand \"clrstrhi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (const_int 0))\n+\t      (use (match_operand:HI 1 \"const_int_operand\" \"\"))\n+\t      (use (match_operand:HI 2 \"const_int_operand\" \"n\"))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+  \"{\n+  rtx addr0;\n+  int cnt8;\n+\n+  if (GET_CODE (operands[1]) != CONST_INT)\n+    FAIL;\n+\n+  cnt8 = byte_immediate_operand (operands[1], GET_MODE (operands[1]));\n+  operands[1] = copy_to_mode_reg (cnt8 ? QImode : HImode, operands[1]);\n+  operands[3] = operands[1];\n+\n+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  operands[4] = addr0;\n+  \n+  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+}\")\n+\n+(define_insn \"*clrstrqi\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e\"))\n+\t(const_int 0))\n+   (use (match_operand:QI 1 \"register_operand\" \"r\"))\n+   (use (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 0))]\n+  \"\"\n+  \"\n+\tst %a0+,__zero_reg__\n+        dec %1\n+\tbrne _PC_-6\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*clrstrhi\"\n+  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"e,e\"))\n+\t(const_int 0))\n+   (use (match_operand:HI 1 \"register_operand\" \"!w,d\"))\n+   (use (match_operand:HI 2 \"const_int_operand\" \"n,n\"))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 0))]\n+  \"\"\n+  \"*{\n+     if (which_alternative==0)\n+       return (AS2 (st,%a0+,__zero_reg__) CR_TAB\n+\t       AS2 (sbiw,%A1,1) CR_TAB\n+\t       AS1 (brne,_PC_-6));\n+     else\n+       return (AS2 (st,%a0+,__zero_reg__) CR_TAB\n+\t       AS2 (subi,%A1,1) CR_TAB\n+\t       AS2 (sbci,%B1,0) CR_TAB\n+\t       AS1 (brne,_PC_-8));\n+}\"\n+  [(set_attr \"length\" \"3,4\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n+(define_expand \"strlenhi\"\n+    [(parallel\n+      [(set (match_dup 4)\n+\t    (unspec:HI [(match_operand:BLK 1 \"memory_operand\" \"\")\n+\t\t\t(match_operand:QI 2 \"const_int_operand\" \"\")\n+\t\t\t(match_operand:HI 3 \"immediate_operand\" \"\")] 0))\n+       (clobber (match_dup 6))])\n+     (set (match_dup 4) (plus:HI (match_dup 4)\n+\t\t\t\t (const_int -1)))\n+     (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t  (minus:HI (match_dup 4)\n+\t\t    (match_dup 5)))]\n+   \"\"\n+   \"{\n+  if (! (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0))\n+    FAIL;\n+  operands[6] = copy_to_mode_reg (Pmode, XEXP (operands[1],0));\n+  operands[1] = gen_rtx (MEM, BLKmode, operands[6]); \n+  operands[5] = operands[6];\n+  operands[4] = gen_reg_rtx (HImode);\n+}\")\n+\n+(define_insn \"*strlenhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=e\")\n+\t(unspec:HI [(mem:BLK (match_operand:HI 1 \"register_operand\" \"%0\"))\n+\t\t    (const_int 0)\n+\t\t    (match_operand:HI 2 \"immediate_operand\" \"i\")] 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"ld __tmp_reg__,%a0+\n+\ttst __tmp_reg__\n+\tbrne _PC_-6\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+; add bytes\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,d,r,r\")\n+        (plus:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0\")\n+                 (match_operand:QI 2 \"nonmemory_operand\" \"r,i,P,N\")))]\n+  \"\"\n+  \"@\n+\tadd %0,%2\n+\tsubi %0,lo8(-(%2))\n+\tinc %0\n+\tdec %0\"\n+  [(set_attr \"length\" \"1,1,1,1\")\n+   (set_attr \"cc\" \"set_czn,set_czn,set_zn,set_zn\")])\n+\n+\n+(define_expand \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      short tmp = INTVAL (operands[2]);\n+      operands[2] = GEN_INT(tmp);\n+    }\n+ if (! (reload_completed | reload_in_progress))\n+   {\n+     if (REGNO (operands[0]) != REGNO (operands[1])\n+\t && REGNO (operands[0]) != REGNO (operands[2])&&0)\n+       {\n+\t emit_move_insn (operands[0], operands[1]);\n+\t operands[1] = operands[0];\n+       }\n+   }\n+}\")\n+\n+\n+(define_insn \"*addhi3_zero_extend\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (zero_extend:HI\n+\t\t  (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:HI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"add %A0,%1\n+\tadc %B0,__zero_reg__\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addhi3_zero_extend1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t (zero_extend:HI\n+\t\t  (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"add %A0,%2\n+\tadc %B0,__zero_reg__\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addhi3_zero_extend2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI\n+\t (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"add %0,%2\n+\tmov %B0,__zero_reg__\n+\tadc %B0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,!w,!w,d,r,r\")\n+ \t(plus:HI\n+ \t (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+ \t (match_operand:HI 2 \"nonmemory_operand\" \"r,I,J,i,P,N\")))]\n+  \"\"\n+  \"@\n+ \tadd %A0,%A2\\;adc %B0,%B2\n+ \tadiw %A0,%2\n+ \tsbiw %A0,%n2\n+ \tsubi %A0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\n+ \tsec\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\n+ \tsec\\;sbc %A0,__zero_reg__\\;sbc %B0,__zero_reg__\"\n+  [(set_attr \"length\" \"2,1,1,2,3,3\")\n+   (set_attr \"cc\" \"set_n,set_czn,set_czn,set_czn,set_n,set_n\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,!w,!w,d,r,r,&*!w,&*!w\")\n+\t  (plus:SI\n+\t   (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,r,r\")\n+\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,I,J,i,P,N,#I,#J\")))]\n+  \"\"\n+  \"@\n+\tadd %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\\;adc %D0,%D2\n+\tadiw %0,%2\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\n+\tsbiw %0,%n2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\n+\tsubi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\\;sbci %D0,hhi8(-(%2))\n+\tsec\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\n+\tsec\\;sbc %A0,__zero_reg__\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\n+\tmov %A0,%A1\\;mov %B0,%B1\\;mov %C0,%C1\\;mov %D0,%D1\\;adiw %0,%2\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\n+\tmov %A0,%A1\\;mov %B0,%B1\\;mov %C0,%C1\\;mov %D0,%D1\\;sbiw %0,%n2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n+  [(set_attr \"length\" \"4,3,3,4,5,5,7,7\")\n+   (set_attr \"cc\" \"set_n,set_n,set_czn,set_czn,set_n,set_n,set_n,set_czn\")])\n+\n+;-----------------------------------------------------------------------------\n+; sub bytes\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,d\")\n+        (minus:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                  (match_operand:QI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tsub %0,%2\n+\tsubi %0,lo8(%2)\"\n+  [(set_attr \"length\" \"1,1\")\n+   (set_attr \"cc\" \"set_czn,set_czn\")])\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,d\")\n+        (minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tsub %A0,%A2\\;sbc %B0,%B2\n+\tsubi %A0,lo8(%2)\\;sbci %B0,hi8(%2)\"\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"set_czn,set_czn\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+                 (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tsub %0,%2\\;sbc %B0,%B2\\;sbc %C0,%C2\\;sbc %D0,%D2\n+\tsubi %A0,lo8(%2)\\;sbci %B0,hi8(%2)\\;sbci %C0,hlo8(%2)\\;sbci %D0,hhi8(%2)\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"cc\" \"set_czn,set_czn\")])\n+\n+;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n+; and\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,d\")\n+        (and:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+                (match_operand:QI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tand %0,%2\n+\tandi %0,lo8(%2)\"\n+  [(set_attr \"length\" \"1,1\")\n+   (set_attr \"cc\" \"set_zn,set_zn\")])\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,d,r\")\n+\t  (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,i,M\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n+  \"\"\n+  \"*{\n+  if (which_alternative==0)\n+    return (AS2 (and,%A0,%A2) CR_TAB\n+\t    AS2 (and,%B0,%B2));\n+  else if (which_alternative==1)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+        {\n+\t  int mask = INTVAL (operands[2]);\n+\t  if ((mask & 0xff) != 0xff)\n+\t    output_asm_insn (AS2 (andi,%A0,lo8(%2)), operands);\n+\t  if ((mask & 0xff00) != 0xff00)\n+\t    output_asm_insn (AS2 (andi,%B0,hi8(%2)), operands);\n+\t  return \\\"\\\";\n+        }\n+        return (AS2 (andi,%A0,lo8(%2)) CR_TAB\n+\t        AS2 (andi,%B0,hi8(%2)));\n+     }\n+  return (AS2 (ldi,%3,lo8(%2)) CR_TAB\n+          AS2 (and,%A0,%3)     CR_TAB\n+          AS1 (clr,%B0));\n+}\"\n+  [(set_attr \"length\" \"2,2,3\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"*{\n+  if (which_alternative==0)\n+    return (AS2 (and, %0,%2)   CR_TAB\n+\t    AS2 (and, %B0,%B2) CR_TAB\n+\t    AS2 (and, %C0,%C2) CR_TAB\n+\t    AS2 (and, %D0,%D2));\n+  else if (which_alternative==1)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+        {\n+\t  HOST_WIDE_INT mask = INTVAL (operands[2]);\n+\t  if ((mask & 0xff) != 0xff)\n+\t    output_asm_insn (AS2 (andi,%A0,lo8(%2)), operands);\n+\t  if ((mask & 0xff00) != 0xff00)\n+\t    output_asm_insn (AS2 (andi,%B0,hi8(%2)), operands);\n+\t  if ((mask & 0xff0000UL) != 0xff0000UL)\n+\t    output_asm_insn (AS2 (andi,%C0,hlo8(%2)), operands);\n+\t  if ((mask & 0xff000000UL) != 0xff000000UL)\n+\t    output_asm_insn (AS2 (andi,%D0,hhi8(%2)), operands);\n+\t  return \\\"\\\";\n+        }\n+      return (AS2 (andi, %A0,lo8(%2))  CR_TAB\n+              AS2 (andi, %B0,hi8(%2)) CR_TAB\n+\t      AS2 (andi, %C0,hlo8(%2)) CR_TAB\n+\t      AS2 (andi, %D0,hhi8(%2)));\n+      }\n+}\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n+;;|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n+;; ior\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,d\")\n+        (ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+                (match_operand:QI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tor %0,%2\n+\tori %0,lo8(%2)\"\n+  [(set_attr \"length\" \"1,1\")\n+   (set_attr \"cc\" \"set_zn,set_zn\")])\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,d\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"*{\n+  if (which_alternative==0)\n+    return (AS2 (or,%A0,%A2) CR_TAB\n+\t    AS2 (or,%B0,%B2));\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+     {\n+\tint mask = INTVAL (operands[2]);\n+\tif (mask & 0xff)\n+\t  output_asm_insn (AS2 (ori,%A0,lo8(%2)), operands);\n+\tif (mask & 0xff00)\n+\t  output_asm_insn (AS2 (ori,%B0,hi8(%2)), operands);\n+\treturn \\\"\\\";\n+      }\n+   return (AS2 (ori,%0,lo8(%2)) CR_TAB\n+\t   AS2 (ori,%B0,hi8(%2)));\n+}\"  \n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"set_n,clobber\")])\n+\n+(define_insn \"*iorhi3_clobber\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"immediate_operand\" \"M,i\")))\n+   (clobber (match_scratch:QI 3 \"=&d,&d\"))]\n+  \"\"\n+  \"@\n+\tldi %3,lo8(%2)\\;or %A0,%3\n+\tldi %3,lo8(%2)\\;or %A0,%3\\;ldi %3,lo8(%2)\\;or %B0,%3\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"clobber,set_n\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"        \"=r,d\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"*{\n+  if (which_alternative==0)\n+    return (AS2 (or, %0,%2)   CR_TAB\n+\t    AS2 (or, %B0,%B2) CR_TAB\n+\t    AS2 (or, %C0,%C2) CR_TAB\n+\t    AS2 (or, %D0,%D2));\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+     {\n+\tHOST_WIDE_INT mask = INTVAL (operands[2]);\n+\tif (mask & 0xff)\n+\t  output_asm_insn (AS2 (ori,%A0,lo8(%2)), operands);\n+\tif (mask & 0xff00)\n+\t  output_asm_insn (AS2 (ori,%B0,hi8(%2)), operands);\n+\tif (mask & 0xff0000UL)\n+\t  output_asm_insn (AS2 (ori,%C0,hlo8(%2)), operands);\n+\tif (mask & 0xff000000UL)\n+\t  output_asm_insn (AS2 (ori,%D0,hhi8(%2)), operands);\n+\treturn \\\"\\\";\n+      }\n+  return (AS2 (ori, %A0,lo8(%2))  CR_TAB\n+\t  AS2 (ori, %B0,hi8(%2)) CR_TAB\n+\t  AS2 (ori, %C0,hlo8(%2)) CR_TAB\n+\t  AS2 (ori, %D0,hhi8(%2)));\n+}\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"cc\" \"set_n,clobber\")])\n+\n+(define_insn \"*iorsi3_clobber\"\n+  [(set (match_operand:SI 0 \"register_operand\"        \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"immediate_operand\" \"M,i\")))\n+   (clobber (match_scratch:QI 3 \"=&d,&d\"))]\n+  \"\"\n+  \"@\n+\tldi %3,lo8(%2)\\;or %A0,%3\n+\tldi %3,lo8(%2)\\;or %A0,%3\\;ldi %3,hi8(%2)\\;or %B0,%3\\;ldi %3,hlo8(%2)\\;or %C0,%3\\;ldi %3,hhi8(%2)\\;or %D0,%3\"\n+  [(set_attr \"length\" \"2,8\")\n+   (set_attr \"cc\" \"clobber,set_n\")])\n+\n+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+;; xor\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (xor:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+                (match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"eor %0,%2\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (xor:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+                (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"eor %0,%2\\;eor %B0,%B2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+                (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"eor %0,%2\n+\teor %B0,%B2\n+\teor %C0,%C2\n+\teor %D0,%D2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+;;<< << << << << << << << << << << << << << << << << << << << << << << << << <<\n+;; arithmetic shift left\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,!d,r,r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"r,i,i,Qm\")))]\n+  \"\"\n+  \"* return ashlqi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"6,4,6,7\")\n+   (set_attr \"cc\" \"clobber,set_czn,set_czn,clobber\")])\n+\n+(define_expand \"ashlhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ashlhi3_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\"           \"=r,r,r,r,r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0,r,0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return ashlhi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"7,2,4,2,5,8\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n+\n+(define_expand \"ashlsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ashlsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r,r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return ashlsi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"9,4,4,7,10\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n+\n+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>\n+;; arithmetic shift right\n+\n+(define_expand \"ashrqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ashrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"r,P,K,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return ashrqi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"6,1,2,4,7\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n+\n+\n+(define_expand \"ashrhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ashrhi3_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,K,O,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return ashrhi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"7,2,4,2,5,8\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n+\n+(define_expand \"ashrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*ashrsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return ashrsi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"9,4,6,7,10\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n+\n+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>\n+;; logical shift right\n+\n+(define_insn \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,d,r,r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"r,i,i,Qm\")))]\n+  \"\"\n+  \"* return lshrqi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"6,4,6,7\")\n+   (set_attr \"cc\" \"clobber,set_czn,set_czn,clobber\")])\n+\n+(define_expand \"lshrhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*lshrhi3_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,K,O,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return lshrhi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"7,2,4,2,5,8\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n+\n+\n+\n+(define_expand \"lshrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*lshrsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,i,Qm\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d,X\"))]\n+  \"\"\n+  \"* return lshrsi3_out (insn,operands, NULL);\"\n+  [(set_attr \"length\" \"9,4,4,7,10\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n+\n+;; abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x)\n+;; abs\n+\n+(define_insn \"absqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (abs:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"sbrc %0,7\\;neg %0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d,r\")\n+        (abs:SF (match_operand:SF 1 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+\tandi %D0,0x7f\n+\tclt\\;bld %D0,7\"\n+  [(set_attr \"length\" \"1,2\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n+;; 0 - x  0 - x  0 - x  0 - x  0 - x  0 - x  0 - x  0 - x  0 - x  0 - x  0 - x\n+;; neg\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (neg:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"neg %0\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=!d,r\")\n+\t(neg:HI (match_operand:HI 1 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+\tcom %B0\\;neg %A0\\;sbci %B0,lo8(-1)\n+\tcom %B0\\;neg %A0\\;sbc %B0,__zero_reg__\\;inc %B0\"\n+  [(set_attr \"length\" \"3,4\")\n+   (set_attr \"cc\" \"set_czn,set_n\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=!d,r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+\tcom %D0\\;com %C0\\;com %B0\\;neg %A0\\;sbci %B0,lo8(-1)\\;sbci %C0,lo8(-1)\\;sbci %D0,lo8(-1)\n+\tcom %D0\\;com %C0\\;com %B0\\;neg %A0\\;brcs _PC_+8\\;sec\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\"\n+  [(set_attr \"length\" \"7,9\")\n+   (set_attr \"cc\" \"set_czn,clobber\")])\n+\n+;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+;; not\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (not:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"com %0\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"com %0\\;com %B0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"com %0\\;com %B0\\;com %C0\\;com %D0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x\n+;; sign extend\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %B0\\;sbrc %0,7\\;com %B0\n+\tmov %A0,%A1\\;clr %B0\\;sbrc %A0,7\\;com %B0\"\n+  [(set_attr \"length\" \"3,4\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %B0\\;sbrc %A0,7\\;com %B0\\;mov %C0,%B0\\;mov %D0,%B0\n+\tmov %A0,%A1\\;clr %B0\\;sbrc %A0,7\\;com %B0\\;mov %C0,%B0\\;mov %D0,%B0\"\n+  [(set_attr \"length\" \"5,6\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"               \"=r,&r\")\n+        (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %C0\\;sbrc %B0,7\\;com %C0\\;mov %D0,%C0\n+\tmov %A0,%A1\\;mov %B0,%B1\\;clr %C0\\;sbrc %B0,7\\;com %C0\\;mov %D0,%C0\"\n+  [(set_attr \"length\" \"4,6\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x\n+;; zero extend\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %B0\n+\tmov %A0,%A1\\;clr %B0\"\n+  [(set_attr \"length\" \"1,2\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %B0\\;clr %C0\\;clr %D0\n+\tmov %A0,%A1\\;clr %B0\\;clr %C0\\;clr %D0\"\n+  [(set_attr \"length\" \"3,4\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,&r\")\n+        (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %C0\\;clr %D0\n+\tmov %A0,%A1\\;mov %B0,%B1\\;clr %C0\\;clr %D0\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n+;;<=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=>\n+;; compare\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+        (match_operand:QI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"tst %0\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*negated_tstqi\"\n+  [(set (cc0)\n+        (neg:QI (match_operand:QI 0 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cp __zero_reg__,%0\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+        (match_operand:HI 0 \"register_operand\" \"!w,r\"))]\n+  \"\"\n+  \"* return out_tsthi (insn,NULL);\"\n+[(set_attr \"cc\" \"compare,compare\")\n+ (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*negated_tsthi\"\n+  [(set (cc0)\n+        (neg:HI (match_operand:HI 0 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cp __zero_reg__,%A0\n+\tcpc __zero_reg__,%B0\"\n+[(set_attr \"cc\" \"compare\")\n+ (set_attr \"length\" \"2\")])\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"* return out_tstsi (insn,NULL);\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*negated_tstsi\"\n+  [(set (cc0)\n+        (neg:SI (match_operand:SI 0 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cp __zero_reg__,%A0\n+\tcpc __zero_reg__,%B0\n+\tcpc __zero_reg__,%C0\n+\tcpc __zero_reg__,%D0\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"4\")])\n+\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+        (compare (match_operand:QI 0 \"register_operand\"  \"r,d\")\n+\t\t (match_operand:QI 1 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+\tcp %0,%1\n+\tcpi %0,lo8(%1)\"\n+  [(set_attr \"cc\" \"compare,compare\")\n+   (set_attr \"length\" \"1,1\")])\n+\n+(define_insn \"*cmpqi_sign_extend\"\n+  [(set (cc0)\n+        (compare (sign_extend:HI\n+\t\t  (match_operand:QI 0 \"register_operand\"  \"d\"))\n+\t\t (match_operand:HI 1 \"immediate_operand\" \"M\")))]\n+  \"\"\n+  \"cpi %0,lo8(%1)\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\"  \"r,d,d,r,r\")\n+\t\t (match_operand:HI 1 \"nonmemory_operand\" \"r,M,i,M,i\")))\n+   (clobber (match_scratch:QI 2 \"=X,X,&d,&d,&d\"))]\n+  \"\"\n+  \"*{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (AS2 (cp,%A0,%A1) CR_TAB\n+              AS2 (cpc,%B0,%B1));\n+    case 1:\n+      if (reg_unused_after (insn, operands[0])\n+          && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n+          && TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+        return AS2 (sbiw,%0,%1);\n+       else\n+        return (AS2 (cpi,%0,%1) CR_TAB\n+                AS2 (cpc,%B0,__zero_reg__));\n+    case 2:\n+      if (reg_unused_after (insn, operands[0]))\n+        return (AS2 (subi,%0,lo8(%1))  CR_TAB\n+                AS2 (sbci,%B0,hi8(%1)));\n+      else\n+        return (AS2 (ldi, %2,hi8(%1))  CR_TAB\n+\t        AS2 (cpi, %A0,lo8(%1)) CR_TAB\n+\t        AS2 (cpc, %B0,%2));\n+   case 3:\n+      return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n+\t      AS2 (cp, %A0,%2) CR_TAB\n+\t      AS2 (cpc, %B0,__zero_reg__));\n+\n+   case 4:\n+      return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n+              AS2 (cp, %A0,%2)       CR_TAB\n+              AS2 (ldi, %2,hi8(%1)) CR_TAB\n+\t      AS2 (cpc, %B0,%2));\n+    }\n+}\" \n+  [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"2,2,3,3,4\")])\n+\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\"  \"r,d,d,r,r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,M,i,M,i\")))\n+   (clobber (match_scratch:QI 2 \"=X,X,&d,&d,&d\"))]\n+  \"\"\n+  \"*{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return (AS2 (cp,%A0,%A1) CR_TAB\n+              AS2 (cpc,%B0,%B1) CR_TAB\n+\t      AS2 (cpc,%C0,%C1) CR_TAB\n+\t      AS2 (cpc,%D0,%D1));\n+    case 1:\n+      if (reg_unused_after (insn, operands[0])\n+          && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n+          && TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+        return (AS2 (sbiw,%0,%1) CR_TAB\n+                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n+                AS2 (cpc,%D0,__zero_reg__));\n+      else\n+        return (AS2 (cpi,%A0,lo8(%1))  CR_TAB\n+                AS2 (cpc,%B0,__zero_reg__) CR_TAB\n+                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n+                AS2 (cpc,%D0,__zero_reg__));\n+    case 2:\n+      if (reg_unused_after (insn, operands[0]))\n+        return (AS2 (subi,%A0,lo8(%1))  CR_TAB\n+                AS2 (sbci,%B0,hi8(%1))  CR_TAB\n+                AS2 (sbci,%C0,hlo8(%1))  CR_TAB\n+                AS2 (sbci,%D0,hhi8(%1)));\n+      else\n+       return (AS2 (cpi, %A0,lo8(%1))   CR_TAB\n+\t       AS2 (ldi, %2,hi8(%1))  CR_TAB\n+\t       AS2 (cpc, %B0,%2)       CR_TAB\n+\t       AS2 (ldi, %2,hlo8(%1))  CR_TAB\n+\t       AS2 (cpc, %C0,%2)       CR_TAB\n+\t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n+\t       AS2 (cpc, %D0,%2));\n+    case 3:\n+        return (AS2 (ldi,%2,lo8(%1))        CR_TAB\n+                AS2 (cp,%A0,%2)            CR_TAB\n+                AS2 (cpc,%B0,__zero_reg__) CR_TAB\n+                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n+                AS2 (cpc,%D0,__zero_reg__));\n+    case 4:\n+       return (AS2 (ldi, %2,lo8(%1))   CR_TAB\n+               AS2 (cp, %A0,%2)        CR_TAB\n+\t       AS2 (ldi, %2,hi8(%1))  CR_TAB\n+\t       AS2 (cpc, %B0,%2)       CR_TAB\n+\t       AS2 (ldi, %2,hlo8(%1))  CR_TAB\n+\t       AS2 (cpc, %C0,%2)       CR_TAB\n+\t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n+\t       AS2 (cpc, %D0,%2));\n+   }\n+}\"\n+  [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,7,5,8\")])\n+\n+;; ----------------------------------------------------------------------\n+;; JUMP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+;; Conditional jump instructions\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+        (if_then_else (eq (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+        (if_then_else (ne (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+        (if_then_else (ge (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+        (if_then_else (geu (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+        (if_then_else (lt (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+        (if_then_else (ltu (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+\n+\n+/****************************************************************\n+ AVR not have following conditional jumps: LE,LEU,GT,GTU.\n+ Convert them all to proper jumps.\n+*****************************************************************/\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+        (if_then_else (le (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+        (if_then_else (leu (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+        (if_then_else (gt (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+        (if_then_else (gtu (cc0) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sbrx_branch\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(zero_extract\n+\t\t\t   (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\"\n+  \"* {\n+       int comp = ((get_attr_length (insn) == 4)\n+                   ? reverse_condition (GET_CODE (operands[0]))\n+                   : GET_CODE (operands[0]));\n+       if (comp == EQ)\n+         output_asm_insn (AS2 (sbrs,%1,%2), operands);\n+       else\n+         output_asm_insn (AS2 (sbrc,%1,%2), operands);\n+       if (get_attr_length (insn) != 4)\n+         return AS1 (rjmp,%3);\n+       return (AS1 (rjmp,_PC_+4) CR_TAB\n+               AS1 (jmp,%3));\n+     }\"\n+  [(set (attr \"length\") (if_then_else (and (ge (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int -2046))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int 2046)))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (if_then_else (eq (symbol_ref \"AVR_MEGA\")\n+\t\t\t\t\t\t\t(const_int 0))\n+\t\t\t\t\t\t    (const_int 2)\n+\t\t\t\t\t\t    (const_int 4))))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*sbrx_and_branchsi\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(and:SI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n+   && mask_one_bit_p(INTVAL (operands[2]))\"\n+  \"* {\n+       int comp = ((get_attr_length (insn) == 4)\n+                   ? reverse_condition (GET_CODE (operands[0]))\n+                   : GET_CODE (operands[0]));\n+       int bit = mask_one_bit_p(INTVAL (operands[2])) - 1;\n+       static char buf[] = \\\"sbrc %A1,0\\\";\n+       buf[3] = (comp == EQ ? 's' : 'c');\n+       buf[6] = bit / 8 + 'A';\n+       buf[9] = bit % 8 + '0';\n+       output_asm_insn (buf, operands);\n+\n+       if (get_attr_length (insn) != 4)\n+         return AS1 (rjmp,%3);\n+       return (AS1 (rjmp,_PC_+4) CR_TAB\n+               AS1 (jmp,%3));\n+     }\"\n+  [(set (attr \"length\") (if_then_else (and (ge (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int -2046))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int 2046)))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (if_then_else (eq (symbol_ref \"AVR_MEGA\")\n+\t\t\t\t\t\t\t(const_int 0))\n+\t\t\t\t\t\t    (const_int 2)\n+\t\t\t\t\t\t    (const_int 4))))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*sbrx_and_branchhi\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(and:HI\n+\t\t\t   (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:HI 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n+   && mask_one_bit_p(INTVAL (operands[2]))\"\n+  \"* {\n+       int comp = ((get_attr_length (insn) == 4)\n+                   ? reverse_condition (GET_CODE (operands[0]))\n+                   : GET_CODE (operands[0]));\n+       int bit = mask_one_bit_p(INTVAL (operands[2])) - 1;\n+       static char buf[] = \\\"sbrc %A1,0\\\";\n+       buf[3] = (comp == EQ ? 's' : 'c');\n+       buf[6] = bit / 8 + 'A';\n+       buf[9] = bit % 8 + '0';\n+       output_asm_insn (buf, operands);\n+\n+       if (get_attr_length (insn) != 4)\n+         return AS1 (rjmp,%3);\n+       return (AS1 (rjmp,_PC_+4) CR_TAB\n+               AS1 (jmp,%3));\n+     }\"\n+  [(set (attr \"length\") (if_then_else (and (ge (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int -2046))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 3))\n+\t\t\t\t\t       (const_int 2046)))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (if_then_else (eq (symbol_ref \"AVR_MEGA\")\n+\t\t\t\t\t\t\t(const_int 0))\n+\t\t\t\t\t\t    (const_int 2)\n+\t\t\t\t\t\t    (const_int 4))))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; ************************************************************************\n+;; Implementation of conditional jumps here.\n+;;  Compare with 0 (test) jumps\n+;; ************************************************************************\n+\n+(define_insn \"branch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"comparison_operator\"\n+                        [(cc0)\n+                         (const_int 0)])\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"! (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n+      || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"*\n+   return ret_cond_branch (GET_CODE (operands[1]),\n+                           avr_jump_mode (operands[0],insn));\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"difficult_branch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"comparison_operator\"\n+                        [(cc0)\n+                         (const_int 0)])\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"(GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n+    || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"*\n+   return ret_cond_branch (GET_CODE (operands[1]),\n+                           avr_jump_mode (operands[0],insn));\"\n+  [(set_attr \"type\" \"branch1\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; revers branch\n+\n+(define_insn \"rvbranch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"! (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n+      || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"*\n+   return ret_cond_branch (reverse_condition (GET_CODE (operands[1])),\n+                           avr_jump_mode (operands[0],insn));\"\n+  [(set_attr \"type\" \"branch1\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"difficult_rvbranch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"(GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n+    || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"*\n+   return ret_cond_branch (reverse_condition (GET_CODE (operands[1])),\n+                           avr_jump_mode (operands[0],insn));\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; **************************************************************************\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*{\n+  if (AVR_MEGA && get_attr_length (insn) != 1)\n+    return \\\"jmp %0\\\";\n+  return \\\"rjmp %0\\\";\n+}\"\n+  [(set (attr \"length\") (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int -2047))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int 2047)))\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"none\")])\n+\n+;; call\n+\n+(define_expand \"call\"\n+  [(call (match_operand:HI 0 \"call_insn_operand\" \"\")\n+         (match_operand:HI 1 \"general_operand\" \"\"))]\n+  ;; Operand 1 not used on the AVR.\n+  \"\"\n+  \"\")\n+\n+;; call value\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+        (call (match_operand:HI 1 \"call_insn_operand\" \"\")\n+              (match_operand:HI 2 \"general_operand\" \"\")))]\n+  ;; Operand 2 not used on the AVR.\n+  \"\"\n+  \"\")\n+\n+(define_insn \"call_insn\"\n+  [(call (mem:HI (match_operand:HI 0 \"nonmemory_operand\" \"!z,*r,i\"))\n+         (match_operand:HI 1 \"general_operand\" \"X,X,X\"))]\n+;; We don't need in saving Z register because r30,r31 is a call used registers\n+  ;; Operand 1 not used on the AVR.\n+  \"(register_operand (operands[0], HImode) || CONSTANT_P (operands[0]))\"\n+  \"*\n+{\n+  if (which_alternative==0)\n+     return \\\"icall\\\";\n+  else if (which_alternative==1)\n+     return (AS2 (mov, r30,%A0) CR_TAB\n+\t     AS2 (mov, r31,%B0) CR_TAB\n+\t     \\\"icall\\\");\n+  else if (!AVR_MEGA)\n+     return AS1(rcall,%c0);   \n+  return AS1(call,%c0);\n+}\"\n+  [(set_attr \"cc\" \"clobber,clobber,clobber\")\n+   (set (attr \"length\")\n+\t(cond [(eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (const_int 1)\n+\t       (eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (const_int 3)\n+\t       (eq (symbol_ref \"!AVR_MEGA\")\n+\t\t   (const_int 0))\n+\t       (const_int 2)]\n+\t(const_int 1)))])\n+\n+(define_insn \"call_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=r,r,r\")\n+        (call (mem:HI (match_operand:HI 1 \"nonmemory_operand\" \"!z,*r,i\"))\n+;; We don't need in saving Z register because r30,r31 is a call used registers\n+              (match_operand:HI 2 \"general_operand\" \"X,X,X\")))]\n+  ;; Operand 2 not used on the AVR.\n+  \"(register_operand (operands[0], VOIDmode) || CONSTANT_P (operands[0]))\"\n+  \"*\n+{\n+  if (which_alternative==0)\n+     return \\\"icall\\\";\n+  else if (which_alternative==1)\n+     return (AS2 (mov, r30,%A1) CR_TAB\n+\t     AS2 (mov, r31,%B1) CR_TAB\n+\t     \\\"icall\\\");\n+  else if (!AVR_MEGA)\n+     return AS1(rcall,%c1);   \n+  return AS1(call,%c1);\n+}\"\n+  [(set_attr \"cc\" \"clobber,clobber,clobber\")\n+   (set (attr \"length\")\n+\t(cond [(eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (const_int 1)\n+\t       (eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (const_int 3)\n+\t       (eq (symbol_ref \"!AVR_MEGA\")\n+\t\t   (const_int 0))\n+\t       (const_int 2)]\n+\t      (const_int 1)))])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"1\")])\n+\n+; indirect jump\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:HI 0 \"register_operand\" \"!z,*r\"))]\n+  \"\"\n+  \"@\n+\tijmp\n+\tpush %A0\\;push %B0\\;ret\"\n+  [(set_attr \"length\" \"1,3\")\n+   (set_attr \"cc\" \"none,none\")])\n+\n+;; table jump\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand:HI 0 \"register_operand\" \"\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"optimize\"\n+  \"\")\n+\n+(define_insn \"*tablejump\"\n+   [(set (pc) (mem:HI\n+\t       (plus:HI (match_operand:HI 0 \"register_operand\" \"=&z\")\n+\t\t\t(label_ref (match_operand 2 \"\" \"\")))))\n+    (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"subi r30,lo8(-(%2))\n+\tsbci r31,hi8(-(%2))\n+\tlpm\n+\tpush r0\n+        adiw r30,1\n+\tlpm\n+\tpush r0\n+        ret\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"casesi\"\n+  [(set (match_dup 6)\n+\t(minus:HI (subreg:HI (match_operand:SI 0 \"register_operand\" \"\") 0)\n+\t\t  (match_operand:HI 1 \"register_operand\" \"\")))\n+   (parallel [(set (cc0)\n+\t\t   (compare (match_dup 6)\n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 9 \"\"))])\n+   \n+   (set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 6)\n+\t(plus:HI (match_dup 6)\n+\t\t (match_dup 6)))\n+;;   (set (match_dup 6)\n+;;\t(plus:HI (match_dup 6) (label_ref (match_operand:HI 3 \"\" \"\"))))\n+\t\t \n+   (parallel [(set (pc) (mem:HI\n+\t\t\t (plus:HI (match_dup 6)\n+\t\t\t\t  (label_ref (match_operand:HI 3 \"\" \"\")))))\n+\t      (use (label_ref (match_dup 3)))])]\n+  \"!optimize\"\n+  \"\n+{\n+  operands[6] = gen_reg_rtx (HImode);\n+}\")\n+\n+\n+;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+;; This instructin sets Z flag\n+\n+(define_insn \"sez\"\n+  [(set (cc0) (const_int 0))]\n+  \"\"\n+  \"sez\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+\n+;; ************************* Peepholes ********************************\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (plus:SI (match_dup 0)\n+                 (const_int -1)))\n+   (parallel\n+    [(set (cc0)\n+          (compare (match_dup 0)\n+\t\t   (const_int -1)))\n+     (clobber (match_operand:QI 1 \"register_operand\" \"\"))])\n+   (set (pc)\n+\t(if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(true_regnum (operands[0]) >= LD_REGS\n+    && true_regnum (operands[1]) >= LD_REGS)\"\n+  \"*\n+{\n+  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+    output_asm_insn (AS2 (sbiw,%0,1) CR_TAB\n+\t\t     AS2 (sbc,%C0,__zero_reg__) CR_TAB\n+\t\t     AS2 (sbc,%D0,__zero_reg__) \\\"\\\\n\\\", operands);\n+  else\n+    output_asm_insn (AS2 (subi,%A0,1) CR_TAB\n+\t\t     AS2 (sbc,%B0,__zero_reg__) CR_TAB\n+\t\t     AS2 (sbc,%C0,__zero_reg__) CR_TAB\n+\t\t     AS2 (sbc,%D0,__zero_reg__) \\\"\\\\n\\\", operands);\n+  switch (avr_jump_mode (operands[2],insn))\n+  {\n+    case 1:\n+      return AS1 (brcc,%2);\n+    case 2:\n+      return (AS1 (brcs,_PC_+2) CR_TAB\n+              AS1 (rjmp,%2));\n+  }\n+  return (AS1 (brcs,_PC_+4) CR_TAB\n+          AS1 (jmp,%2));\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (plus:HI (match_dup 0)\n+                 (const_int -1)))\n+   (parallel\n+    [(set (cc0)\n+          (compare (match_dup 0)\n+\t\t   (const_int 65535)))\n+     (clobber (match_operand:QI 1 \"register_operand\" \"\"))])\n+   (set (pc)\n+\t(if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(true_regnum (operands[0]) >= LD_REGS\n+    && true_regnum (operands[1]) >= LD_REGS)\"\n+  \"*\n+{\n+  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (operands[0])))\n+    output_asm_insn (AS2 (sbiw,%0,1), operands);\n+  else\n+    output_asm_insn (AS2 (subi,%A0,1) CR_TAB\n+\t\t     AS2 (sbc,%B0,__zero_reg__) \\\"\\\\n\\\", operands);\n+  switch (avr_jump_mode (operands[2],insn))\n+  {\n+    case 1:\n+      return AS1 (brcc,%2);\n+    case 2:\n+      return (AS1 (brcs,_PC_+2) CR_TAB\n+              AS1 (rjmp,%2));\n+  }\n+  return (AS1 (brcs,_PC_+4) CR_TAB\n+          AS1 (jmp,%2));\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (plus:QI (match_dup 0)\n+                 (const_int -1)))\n+   (set (cc0)\n+\t(compare (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (pc)\n+\t(if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(true_regnum (operands[0]) >= LD_REGS)\"\n+  \"*\n+{\n+  output_asm_insn (AS2 (subi,%A0,1), operands);\n+  switch (avr_jump_mode (operands[1],insn))\n+  {\n+    case 1:\n+      return AS1 (brcc,%1);\n+    case 2:\n+      return (AS1 (brcs,_PC_+2) CR_TAB\n+              AS1 (rjmp,%1));\n+  }\n+  return (AS1 (brcs,_PC_+4) CR_TAB\n+          AS1 (jmp,%1));\n+}\")\n+\t\t\t\t\t"}, {"sha": "b0e91cc39fc27c0d1ac248c07ecc85a87e402a9a", "filename": "gcc/config/avr/libgcc.S", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1,666 @@\n+/*  -*- Mode: Asm -*-  */\n+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Denis Chertykov <denisc@overta.ru>\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#define TEXT_SEG(x) .section .text.libgcc ; x\n+#define GLOBAL(x) .global _##x\n+#define FUNCTION(x) .func _##x\n+#define LABEL(x) _##x##:\n+#define ENDFUNC .endfunc\n+\n+#define __zero_reg__ r1\n+#define __tmp_reg__ r0\n+#define __SREG__ 0x3f\n+#define __SP_H__ 0x3e\n+#define __SP_L__ 0x3d\n+\n+/*******************************************************\n+               Multiplication  8 x 8\n+*******************************************************/\n+#if defined (Lmulqi3)\n+\n+#define\tr_arg2\tr25\t\t/* multiplicand */\n+#define\tr_arg1 \tr24\t\t/* multiplier */\n+#define r_res\t__tmp_reg__\t/* result */\n+\n+TEXT_SEG(mulqi3)\n+GLOBAL (mulqi3)\n+FUNCTION (mulqi3)\n+LABEL(mulqi3)\n+\n+GLOBAL (umulqi3)\n+LABEL(umulqi3)\n+\tclr\tr_res\t\t; clear result\n+__mulqi3_loop:\n+\tsbrc\tr_arg1,0\n+\tadd\tr_res,r_arg2\n+\tadd\tr_arg2,r_arg2\t; shift multiplicand\n+\tbreq\t__mulqi3_exit\t; while multiplicand != 0\n+\tlsr\tr_arg1\t\t; \n+\tbrne\t__mulqi3_loop\t; exit if multiplier = 0\n+__mulqi3_exit:\t\n+\tmov\tr_arg1,r_res\t; result to return register\n+\tret\n+\n+#undef r_arg2  \n+#undef r_arg1  \n+#undef r_res   \n+\t\n+ENDFUNC\n+#endif \t/* defined (Lmulqi3) */\n+\n+\n+/*******************************************************\n+               Multiplication  16 x 16\n+*******************************************************/\n+#if defined (Lmulhi3)\n+#define\tr_arg1L\tr24\t\t/* multiplier Low */\n+#define\tr_arg1H\tr25\t\t/* multiplier High */\n+#define\tr_arg2L\tr22\t\t/* multiplicand Low */\n+#define\tr_arg2H\tr23\t\t/* multiplicand High */\n+#define r_resL\tr20\t\t/* result Low */\n+#define r_resH  r21\t\t/* result High */\n+\n+TEXT_SEG(mulhi3)\n+GLOBAL (mulhi3)\n+FUNCTION (mulhi3)\n+LABEL(mulhi3)\n+\n+GLOBAL (umulhi3)\n+LABEL(umulhi3)\n+\t\n+\tclr\tr_resH\t\t; clear result\n+\tclr\tr_resL\t\t; clear result\n+__mulhi3_loop:\n+\tsbrs\tr_arg1L,0\n+\trjmp\t__mulhi3_skip1\n+\tadd\tr_resL,r_arg2L\t; result + multiplicand\n+\tadc\tr_resH,r_arg2H\n+__mulhi3_skip1:\t\n+\tadd\tr_arg2L,r_arg2L\t; shift multiplicand\n+\tadc\tr_arg2H,r_arg2H\n+\n+\tcpc\tr_arg2L,__zero_reg__\n+\tbreq\t__mulhi3_exit\t; while multiplicand != 0\n+\n+\tlsr\tr_arg1H\t\t; gets LSB of multiplier\n+\tror\tr_arg1L\n+\tcpc\tr_arg1H,__zero_reg__\n+\tbrne\t__mulhi3_loop\t; exit if multiplier = 0\n+__mulhi3_exit:\n+\tmov\tr_arg1H,r_resH\t; result to return register\n+\tmov\tr_arg1L,r_resL\n+\tret\n+\n+#undef r_arg1L\n+#undef r_arg1H\n+#undef r_arg2L\n+#undef r_arg2H\n+#undef r_resL \t\n+#undef r_resH \n+\n+ENDFUNC\n+#endif /* defined (Lmulhi3) */\n+\n+#if defined (Lmulsi3)\n+/*******************************************************\n+               Multiplication  32 x 32\n+*******************************************************/\n+#define r_arg1L  r22\t\t/* multiplier Low */\n+#define r_arg1H  r23\n+#define\tr_arg1HL r24\n+#define\tr_arg1HH r25\t\t/* multiplier High */\n+\n+\n+#define\tr_arg2L  r18\t\t/* multiplicand Low */\n+#define\tr_arg2H  r19\t\n+#define\tr_arg2HL r20\n+#define\tr_arg2HH r21\t\t/* multiplicand High */\n+\t\n+#define r_resL\t r26\t\t/* result Low */\n+#define r_resH   r27\n+#define r_resHL\t r30\n+#define r_resHH  r31\t\t/* result High */\n+\n+\t\n+TEXT_SEG(mulsi3)\n+GLOBAL (mulsi3)\n+FUNCTION (mulsi3)\n+LABEL(mulsi3)\n+\n+GLOBAL (umulsi3)\n+LABEL(umulsi3)\n+\tclr\tr_resHH\t\t; clear result\n+\tclr\tr_resHL\t\t; clear result\n+\tclr\tr_resH\t\t; clear result\n+\tclr\tr_resL\t\t; clear result\n+__mulsi3_loop:\n+\tsbrs\tr_arg1L,0\n+\trjmp\t__mulsi3_skip1\n+\tadd\tr_resL,r_arg2L\t\t; result + multiplicand\n+\tadc\tr_resH,r_arg2H\n+\tadc\tr_resHL,r_arg2HL\n+\tadc\tr_resHH,r_arg2HH\n+__mulsi3_skip1:\n+\tadd\tr_arg2L,r_arg2L\t\t; shift multiplicand\n+\tadc\tr_arg2H,r_arg2H\n+\tadc\tr_arg2HL,r_arg2HL\n+\tadc\tr_arg2HH,r_arg2HH\n+\t\n+\tlsr\tr_arg1HH\t; gets LSB of multiplier\n+\tror\tr_arg1HL\n+\tror\tr_arg1H\n+\tror\tr_arg1L\n+\tbrne\t__mulsi3_loop\n+\tsbiw\tr_arg1HL,0\n+\tcpc\tr_arg1H,r_arg1L\n+\tbrne\t__mulsi3_loop\t\t; exit if multiplier = 0\n+__mulsi3_exit:\n+\tmov\tr_arg1HH,r_resHH\t; result to return register\n+\tmov\tr_arg1HL,r_resHL\n+\tmov\tr_arg1H,r_resH\n+\tmov\tr_arg1L,r_resL\n+\tret\n+#undef r_arg1L \n+#undef r_arg1H \n+#undef r_arg1HL\n+#undef r_arg1HH\n+             \n+             \n+#undef r_arg2L \n+#undef r_arg2H \n+#undef r_arg2HL\n+#undef r_arg2HH\n+             \n+#undef r_resL  \n+#undef r_resH  \n+#undef r_resHL \n+#undef r_resHH \n+\n+ENDFUNC\n+#endif /* defined (Lmulsi3) */\n+\t\n+/*******************************************************\n+       Division 8 / 8 => (result + remainder)\n+*******************************************************/\n+#define\tr_rem\tr26\t/* remainder */\n+#define\tr_arg1\tr25\t/* dividend */\n+#define\tr_arg2\tr24\t/* divisor */\n+#define\tr_cnt\tr27\t/* loop count */\n+\n+#if defined (Lumodqi3)\n+\n+TEXT_SEG(divqi3)\n+GLOBAL (umodqi3)\n+FUNCTION (umodqi3)\n+LABEL(umodqi3)\n+\tclt\n+\trcall\t_udivqi3\n+\tmov\tr24,r_rem\n+\tret\n+ENDFUNC\n+#endif /* defined (Lumodqi3) */\n+\t\n+#if defined (Ludivqi3)\n+\n+TEXT_SEG(divqi3)\n+GLOBAL (udivqi3)\n+FUNCTION (udivqi3)\n+LABEL(udivqi3)\n+\tclr\t__tmp_reg__\n+\trjmp\t_divqi_raw\n+ENDFUNC\n+#endif /* defined (Ludivqi3) */\n+\n+#if defined (Lmodqi3)\n+\t\n+TEXT_SEG (divqi3)\n+GLOBAL (moqhi3)\n+FUNCTION (moqhi3)\n+LABEL (modqi3)\n+\trcall\t_divqi3\n+\tmov\tr24,r_rem\n+\tret\n+ENDFUNC\n+#endif /* defined (Lmodqi3) */\n+\n+#if defined (Ldivqi3)\n+\n+TEXT_SEG(divqi3)\n+GLOBAL (divqi3)\n+FUNCTION (divqi3)\n+LABEL(divqi3)\n+        bst     r_arg1,7\t; store sign of divident\n+        mov     __tmp_reg__,r_arg1\n+        eor     __tmp_reg__,r_arg2; r0.7 is sign of result\n+        sbrc\tr_arg1,7\n+        neg     r_arg1\t\t; divident negative : negate\n+        sbrc\tr_arg2,7\n+        neg     r_arg2\t\t; divisor negative : negate\n+GLOBAL (divqi_raw)\n+LABEL (divqi_raw)\t\n+\tsub\tr_rem,r_rem\t; clear remainder and carry\n+\tldi\tr_cnt,9\t\t; init loop counter\n+\trjmp\t__divqi3_ep\t; jump to entry point\n+__divqi3_loop:\n+        rol\tr_rem\t\t; shift dividend into remainder\n+        cp\tr_rem,r_arg2\t; compare remainder & divisor\n+        brcs\t__divqi3_ep\t; remainder <= divisor\n+        sub\tr_rem,r_arg2\t; restore remainder\n+__divqi3_ep:\n+        rol\tr_arg1\t\t; shift dividend (with CARRY)\n+        dec\tr_cnt\t\t; decrement loop counter\n+        brne\t__divqi3_loop\t; loop\n+\tcom\tr_arg1\t\t; complement result \n+\t\t\t\t; because C flag was complemented in loop\n+\tbrtc\t__divqi3_1\n+\tneg\tr_rem\t\t; correct remainder sign\n+__divqi3_1:\n+\tsbrc\t__tmp_reg__,7\n+\tneg\tr_arg1\t\t; correct result sign\n+__divqi3_exit:\n+\tmov\tr24,r_arg1\t; put result to return register\n+\tret\n+ENDFUNC\n+#endif /* defined (Ldivqi3) */\n+\n+#undef r_rem\n+#undef r_arg1\n+#undef r_arg2\n+#undef r_cnt\n+\t\n+\t\t\n+/*******************************************************\n+       Division 16 / 16 => (result + remainder)\n+*******************************************************/\n+#define\tr_remL\tr26\t/* remainder Low */\n+#define\tr_remH\tr27\t/* remainder High */\n+\t\n+#define\tr_arg1L\tr24\t/* dividend Low */\n+#define\tr_arg1H\tr25\t/* dividend High */\n+\t\n+#define\tr_arg2L\tr22\t/* divisor Low */\n+#define\tr_arg2H\tr23\t/* divisor High */\n+\t\n+#define\tr_cnt\tr21\t/* loop count */\n+#if defined (Lumodhi3)\n+\t\n+TEXT_SEG (divhi3)\n+GLOBAL (umodhi3)\n+FUNCTION (umodhi3)\n+LABEL (umodhi3)\n+\tclt\n+\trcall\t_udivhi3\n+GLOBAL (umodhi3_ret)\n+LABEL (umodhi3_ret)\n+\tmov\tr24,r_remL\n+\tmov\tr25,r_remH\n+\tret\n+ENDFUNC\n+#endif /* defined (Lumodhi3) */\n+\t\n+#if defined (Ludivhi3)\n+\t\n+TEXT_SEG (divhi3)\n+GLOBAL (udivhi3)\n+FUNCTION (udivhi3)\n+LABEL (udivhi3)\n+\tclr\t__tmp_reg__\n+\trjmp\t_divhi_raw\n+ENDFUNC\n+#endif /* defined (Ludivhi3) */\n+\n+#if defined (Lmodhi3)\n+\t\n+TEXT_SEG (divhi3)\n+GLOBAL (modhi3)\n+FUNCTION (modhi3)\n+LABEL (modhi3)\n+GLOBAL (div)\n+LABEL (div)\n+\trcall\t_divhi3\n+\tmov\tr22,r24\t\t; needed for div () function\n+\tmov\tr23,r25\n+\trjmp\t_umodhi3_ret\n+ENDFUNC\n+#endif /* defined (Lmodhi3) */\n+\t\n+\t\n+#if defined (Ldivhi3)\n+\t\n+TEXT_SEG (divhi3)\n+GLOBAL (divhi3)\n+FUNCTION (divhi3)\n+LABEL (divhi3)\n+        bst     r_arg1H,7\t; store sign of divident\n+        mov     __tmp_reg__,r_arg1H\n+        eor     __tmp_reg__,r_arg2H   ; r0.7 is sign of result\n+\tbrtc\t__divhi3_skip1\n+\tcom\tr_arg1H\n+        neg     r_arg1L\t\t; divident negative : negate\n+\tsbci\tr_arg1H,0xff\n+__divhi3_skip1:\n+        tst\tr_arg2H\n+\tbrpl\t__divhi3_skip2\n+\tcom\tr_arg2H\n+        neg     r_arg2L\t\t; divisor negative : negate\n+\tsbci\tr_arg2H,0xff\n+__divhi3_skip2:\n+GLOBAL (divhi_raw)\n+LABEL (divhi_raw)\n+\tsub\tr_remL,r_remL\n+\tsub\tr_remH,r_remH\t\t; clear remainder and carry\n+\tldi\tr_cnt,17\t; init loop counter\n+\trjmp\t__divhi3_ep\t; jump to entry point\n+__divhi3_loop:\n+        rol\tr_remL\t\t; shift dividend into remainder\n+\trol\tr_remH\n+        cp\tr_remL,r_arg2L\t; compare remainder & divisor\n+\tcpc\tr_remH,r_arg2H\n+        brcs\t__divhi3_ep\t; remainder < divisor\n+        sub\tr_remL,r_arg2L\t; restore remainder\n+        sbc\tr_remH,r_arg2H\n+__divhi3_ep:\n+        rol\tr_arg1L\t\t; shift dividend (with CARRY)\n+        rol\tr_arg1H\n+        dec\tr_cnt\t\t; decrement loop counter\n+        brne\t__divhi3_loop\t; loop\n+\tbrtc\t__divhi3_1\n+\tcom\tr_remH\n+\tneg\tr_remL\t\t; correct remainder sign\n+\tsbci\tr_remH,0xff\n+__divhi3_1:\n+\ttst\t__tmp_reg__\n+\tbrpl\t__divhi3_exit\n+\tadiw\tr_arg1L,1\t; correct result sign\n+\tret\n+__divhi3_exit:\n+\tcom\tr_arg1L\n+\tcom\tr_arg1H\n+\tret\n+ENDFUNC\n+#endif /* defined (Ldivhi3) */\n+\t\n+#undef r_remH  \n+#undef r_remL  \n+             \n+#undef r_arg1H \n+#undef r_arg1L \n+             \n+#undef r_arg2H \n+#undef r_arg2L \n+             \t\n+#undef r_cnt   \t\n+\t\n+/*******************************************************\n+       Division 32 / 32 => (result + remainder)\n+*******************************************************/\n+#define\tr_remHH\tr31\t/* remainder High */\n+#define\tr_remHL\tr30\n+#define\tr_remH\tr27\n+#define\tr_remL\tr26\t/* remainder Low */\n+\t\n+#define\tr_arg1HH r25\t/* dividend High */\n+#define\tr_arg1HL r24\n+#define\tr_arg1H  r23\n+#define\tr_arg1L  r22\t/* dividend Low */\n+\t\n+#define\tr_arg2HH r21\t/* divisor High */\n+#define\tr_arg2HL r20\n+#define\tr_arg2H  r19\n+#define\tr_arg2L  r18\t/* divisor Low */\n+\t\n+#define\tr_cnt\tr17\t/* loop count */\n+\n+#if defined (Lumodsi3)\n+\n+TEXT_SEG(divsi3)\n+GLOBAL (umodsi3)\n+FUNCTION (umodsi3)\n+LABEL(umodsi3)\n+\tclt\n+\trcall\t_udivsi3\n+GLOBAL (umodsi3_ret)\n+LABEL (umodsi3_ret)\n+\tmov\tr25,r_remHH\n+\tmov\tr24,r_remHL\n+\tmov\tr23,r_remH\n+\tmov\tr22,r_remL\n+GLOBAL (cleanup)\n+LABEL (cleanup)\n+\tret\n+ENDFUNC\n+#endif /* defined (Lumodsi3) */\n+\t\n+#if defined (Ludivsi3)\n+\n+TEXT_SEG(divsi3)\n+GLOBAL (udivsi3)\n+FUNCTION (udivsi3)\n+LABEL(udivsi3)\n+\tclr\t__tmp_reg__\n+\trjmp\t_divsi_raw\n+ENDFUNC\n+#endif /* defined (Ludivsi3) */\n+\n+#if defined (Lmodsi3)\n+\t\n+TEXT_SEG (divsi3)\n+GLOBAL (modsi3)\n+FUNCTION (modsi3)\n+LABEL (modsi3)\n+GLOBAL (ldiv)\n+LABEL (ldiv)\n+\trcall\t_divsi3\n+\tmov\tr18,r22\t\t/* Needed for ldiv */\n+\tmov\tr19,r23\n+\tmov\tr20,r24\n+\tmov\tr21,r25\n+\trjmp\t_umodsi3_ret\n+ENDFUNC\n+#endif /* defined (Lmodsi3) */\n+\n+#if defined (Ldivsi3)\n+\n+TEXT_SEG(divsi3)\n+GLOBAL (divsi3)\n+FUNCTION (divsi3)\n+LABEL(divsi3)\n+        bst     r_arg1HH,7\t; store sign of divident\n+        mov     __tmp_reg__,r_arg1HH\n+        eor     __tmp_reg__,r_arg2HH   ; r0.7 is sign of result\n+\tbrtc\t__divsi3_skip1\n+\tcom\tr_arg1HH\n+\tcom\tr_arg1HL\n+\tcom\tr_arg1H\n+        neg     r_arg1L\t\t; divident negative : negate\n+\tsbci\tr_arg1H, 0xff\n+\tsbci\tr_arg1HL,0xff\n+\tsbci\tr_arg1HH,0xff\n+__divsi3_skip1:\n+        tst\tr_arg2HH\n+\tbrpl\t__divsi3_skip2\n+\tcom\tr_arg2HH\n+\tcom\tr_arg2HL\n+\tcom\tr_arg2H\n+        neg     r_arg2L\t\t; divisor negative : negate\n+\tsbci\tr_arg2H, 0xff\n+\tsbci\tr_arg2HL,0xff\n+\tsbci\tr_arg2HH,0xff\n+__divsi3_skip2:\n+GLOBAL (divsi_raw)\n+LABEL (divsi_raw)\n+\tpush\tr_cnt\n+\tsub\tr_remL,r_remL\n+\tsub\tr_remH,r_remH\n+\tsub\tr_remHL,r_remHL\n+\tsub\tr_remHH,r_remHH\t; clear remainder and carry\n+\tldi\tr_cnt,33\t; init loop counter\n+\trjmp\t__divsi3_ep\t; jump to entry point\n+__divsi3_loop:\n+        rol\tr_remL\t\t; shift dividend into remainder\n+\trol\tr_remH\n+\trol\tr_remHL\n+\trol\tr_remHH\n+        cp\tr_remL,r_arg2L\t; compare remainder & divisor\n+\tcpc\tr_remH,r_arg2H\n+\tcpc\tr_remHL,r_arg2HL\n+\tcpc\tr_remHH,r_arg2HH\n+        brcs\t__divsi3_ep\t; remainder <= divisor\n+        sub\tr_remL,r_arg2L\t; restore remainder\n+        sbc\tr_remH,r_arg2H\n+        sbc\tr_remHL,r_arg2HL\n+        sbc\tr_remHH,r_arg2HH\n+__divsi3_ep:\n+        rol\tr_arg1L\t\t; shift dividend (with CARRY)\n+        rol\tr_arg1H\n+        rol\tr_arg1HL\n+        rol\tr_arg1HH\n+        dec\tr_cnt\t\t; decrement loop counter\n+        brne\t__divsi3_loop\t; loop\n+\tpop\tr_cnt\n+\tbrtc\t__divsi3_1\n+\tcom\tr_remHH\n+\tcom\tr_remHL\n+\tcom\tr_remH\n+\tneg\tr_remL\t\t; correct remainder sign\n+\tsbci\tr_remH, 0xff\n+\tsbci\tr_remHL,0xff\n+\tsbci\tr_remHH,0xff\n+__divsi3_1:\n+\trol\t__tmp_reg__\n+\tbrcc\t__divsi3_exit\n+\tadc\tr_arg1L,__zero_reg__; correct result sign\n+\tadc\tr_arg1H,__zero_reg__\n+\tadc\tr_arg1HL,__zero_reg__\n+\tadc\tr_arg1HH,__zero_reg__\n+\tret\n+__divsi3_exit:\n+\tcom\tr_arg1L\n+\tcom\tr_arg1H\n+\tcom\tr_arg1HL\n+\tcom\tr_arg1HH\n+\tret\n+ENDFUNC\n+#endif /* defined (Ldivsi3) */\n+\n+/**********************************\n+ * This is a prologue subroutine\n+ **********************************/\n+#if defined (Lprologue)\n+\n+TEXT_SEG (_prologue_saves)\n+GLOBAL (_prologue_saves__)\n+FUNCTION (_prologue_saves__)\n+LABEL (_prologue_saves__)\n+\tpush r2\n+\tpush r3\n+\tpush r4\n+\tpush r5\n+\tpush r6\n+\tpush r7\n+\tpush r8\n+\tpush r9\n+\tpush r10\n+\tpush r11\n+\tpush r12\n+\tpush r13\n+\tpush r14\n+\tpush r15\n+\tpush r16\n+\tpush r17\n+\tpush r28\n+\tpush r29\n+\tin\tr28,__SP_L__\n+\tin\tr29,__SP_H__\n+\tsbiw r26,0\n+\tbreq _prologue_end\n+\tsub\tr28,r26\n+\tsbc\tr29,r27\n+\tin\t__tmp_reg__,__SREG__\n+\tcli\n+\tout\t__SP_L__,r28\n+\tout\t__SREG__,__tmp_reg__\n+\tout\t__SP_H__,r29\n+_prologue_end:\n+\tijmp\n+ENDFUNC\n+#endif /* defined (Lprologue) */\n+\n+/*\n+ * This is a epilogue subroutine\n+ */\n+#if defined (Lepilogue)\n+\n+TEXT_SEG (_epilogue_restores)\n+GLOBAL (_epilogue_restores__)\n+FUNCTION (_epilogue_restores__)\n+LABEL (_epilogue_restores__)\n+\tldd\tr2,Y+18\n+\tldd\tr3,Y+17\n+\tldd\tr4,Y+16\n+\tldd\tr5,Y+15\n+\tldd\tr6,Y+14\n+\tldd\tr7,Y+13\n+\tldd\tr8,Y+12\n+\tldd\tr9,Y+11\n+\tldd\tr10,Y+10\n+\tldd\tr11,Y+9\n+\tldd\tr12,Y+8\n+\tldd\tr13,Y+7\n+\tldd\tr14,Y+6\n+\tldd\tr15,Y+5\n+\tldd\tr16,Y+4\n+\tldd\tr17,Y+3\n+\tldd\tr26,Y+2\n+\tldd\tr27,Y+1\n+\tadd\tr28,r30\n+\tadc\tr29,__zero_reg__\n+\tin\t__tmp_reg__,__SREG__\n+\tcli\n+\tout\t__SP_L__,r28\n+\tout\t__SREG__,__tmp_reg__\n+\tout\t__SP_H__,r29\n+\tmov\tr28,r26\n+\tmov\tr29,r27\n+\tret\n+#endif /* defined (Lepilogue) */\n+\n+#ifdef L__exit\n+TEXT_SEG(exit)\n+GLOBAL (exit)\n+FUNCTION (exit)\n+LABEL(exit)\n+\trjmp\t_exit\n+ENDFUNC\n+#endif\n\\ No newline at end of file"}, {"sha": "9f549f459cd79be5966d463c79d9620696801d83", "filename": "gcc/config/avr/t-avr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1,48 @@\n+# Specific names for AVR tools\n+AR_FOR_TARGET = avr-ar\n+RANLIB_FOR_TARGET = avr-ranlib\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = avr/libgcc.S\n+LIB1ASMFUNCS = \\\n+\tmulqi3 \\\n+\tmulhi3 \\\n+\tmulsi3 \\\n+\tumodqi3 \\\n+\tudivqi3 \\\n+\tmodqi3 \\\n+\tdivqi3 \\\n+\tumodhi3 \\\n+\tudivhi3 \\\n+\tmodhi3 \\\n+\tdivhi3 \\\n+\tumodsi3 \\\n+\tudivsi3 \\\n+\tmodsi3 \\\n+\tdivsi3 \\\n+\tprologue \\\n+\tepilogue \\\n+\t__exit\n+\n+# libgcc...\n+LIBGCC1_TEST =\n+\n+# We do not have DF type\n+TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc\n+#LIBGCC2 = $(LIBGCC1)\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/avr/t-avr\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#define FLOAT_ONLY' >> fp-bit.c\n+\techo '#define CMPtype QItype' >> fp-bit.c\n+\techo '#define DF SF' >> fp-bit.c\n+\techo '#define DI SI' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#define SMALL_MACHINE' >> fp-bit.c\n+\techo 'typedef int QItype __attribute__ ((mode (QI)));' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+FPBIT = fp-bit.c\n+\n+\n+"}, {"sha": "af51cd3e6e83749f2951238fe5f598b2ff17efe7", "filename": "gcc/config/avr/xm-avr.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Fxm-avr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e7678cd53b837759f9b0ecfbbd9b1cc33827dc/gcc%2Fconfig%2Favr%2Fxm-avr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fxm-avr.h?ref=90e7678cd53b837759f9b0ecfbbd9b1cc33827dc", "patch": "@@ -0,0 +1 @@\n+#include \"tm.h\""}]}