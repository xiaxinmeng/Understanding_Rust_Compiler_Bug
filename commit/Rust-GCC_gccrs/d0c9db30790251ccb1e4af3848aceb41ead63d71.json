{"sha": "d0c9db30790251ccb1e4af3848aceb41ead63d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjOWRiMzA3OTAyNTFjY2IxZTRhZjM4NDhhY2ViNDFlYWQ2M2Q3MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-01-22T23:42:07Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-01-22T23:42:07Z"}, "message": "combine.c (simplify_and_const_int): Don't trunc_int_for_mode \"nonzero\" as that might add \"1\" bits.\n\n\t* combine.c (simplify_and_const_int): Don't trunc_int_for_mode\n\t\"nonzero\" as that might add \"1\" bits.  Ensure \"constop\" is\n\tproperly sign extened.\n\t(force_to_mode): Tweak for sign extended constop.\n\nFrom-SVN: r49112", "tree": {"sha": "f8312a49809cfe096c794e2e9c08fe11a35c9aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8312a49809cfe096c794e2e9c08fe11a35c9aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c9db30790251ccb1e4af3848aceb41ead63d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9db30790251ccb1e4af3848aceb41ead63d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c9db30790251ccb1e4af3848aceb41ead63d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9db30790251ccb1e4af3848aceb41ead63d71/comments", "author": null, "committer": null, "parents": [{"sha": "1e7e480e5c37ab841a7ddcc48f5b8614a3b55096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7e480e5c37ab841a7ddcc48f5b8614a3b55096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7e480e5c37ab841a7ddcc48f5b8614a3b55096"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "30d007887137b0100c17e1041b1618818121774b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9db30790251ccb1e4af3848aceb41ead63d71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9db30790251ccb1e4af3848aceb41ead63d71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0c9db30790251ccb1e4af3848aceb41ead63d71", "patch": "@@ -1,3 +1,10 @@\n+2002-01-23  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* combine.c (simplify_and_const_int): Don't trunc_int_for_mode\n+\t\"nonzero\" as that might add \"1\" bits.  Ensure \"constop\" is\n+\tproperly sign extened.\n+\t(force_to_mode): Tweak for sign extended constop.\n+\n 2002-01-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (some_small_symbolic_mem_operand) Use"}, {"sha": "47ac3a8aa623ac8ec49988d158eff4dcb8bed337", "filename": "gcc/combine.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9db30790251ccb1e4af3848aceb41ead63d71/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9db30790251ccb1e4af3848aceb41ead63d71/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d0c9db30790251ccb1e4af3848aceb41ead63d71", "patch": "@@ -6701,7 +6701,8 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t     need it.  */\n \n \t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) == mask)\n+\t      && ((INTVAL (XEXP (x, 1)) & GET_MODE_MASK (GET_MODE (x)))\n+\t\t  == (HOST_WIDE_INT) mask))\n \t    x = XEXP (x, 0);\n \n \t  /* If it remains an AND, try making another AND with the bits\n@@ -7755,7 +7756,6 @@ simplify_and_const_int (x, mode, varop, constop)\n      MODE.  */\n \n   nonzero = nonzero_bits (varop, mode) & GET_MODE_MASK (mode);\n-  nonzero = trunc_int_for_mode (nonzero, mode);\n \n   /* Turn off all bits in the constant that are known to already be zero.\n      Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS\n@@ -7823,19 +7823,22 @@ simplify_and_const_int (x, mode, varop, constop)\n   /* If we are only masking insignificant bits, return VAROP.  */\n   if (constop == nonzero)\n     x = varop;\n-\n-  /* Otherwise, return an AND.  See how much, if any, of X we can use.  */\n-  else if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-    x = gen_binary (AND, mode, varop, GEN_INT (constop));\n-\n   else\n     {\n+      /* Otherwise, return an AND.  */\n       constop = trunc_int_for_mode (constop, mode);\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t  || (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) != constop)\n-\tSUBST (XEXP (x, 1), GEN_INT (constop));\n+      /* See how much, if any, of X we can use.  */\n+      if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n+\tx = gen_binary (AND, mode, varop, GEN_INT (constop));\n \n-      SUBST (XEXP (x, 0), varop);\n+      else\n+\t{\n+\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t      || (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) != constop)\n+\t    SUBST (XEXP (x, 1), GEN_INT (constop));\n+\n+\t  SUBST (XEXP (x, 0), varop);\n+\t}\n     }\n \n   return x;"}]}