{"sha": "088414c1224f0b20e3bc0c953bebb7273284f48c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4NDE0YzEyMjRmMGIyMGUzYmMwYzk1M2JlYmI3MjczMjg0ZjQ4Yw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-02-07T18:57:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-02-07T18:57:35Z"}, "message": "re PR middle-end/13696 (enum not useable as array index?)\n\n\n\tPR middle-end/13696\n\t* fold-const.c (fold_convert): New function to provide type\n\tconversion to the middle-end without using convert.\n\t(negate_expr, associate_trees, size_diffop, omit_one_operand,\n\toperand_equal_for_comparison_p, pedantic_omit_one_operand,\n\tinvert_truthvalue, optimize_bit_field_compare, range_binop,\n\tdecode_field_reference, make_range, build_range_check, unextend,\n\tfold_truthop, extract_muldiv_1, fold_mathfn_compare,\n\tfold_binary_op_with_conditional_arg, fold_inf_compare,\n\tfold_single_bit_test, fold, multiple_of_p): Replace all calls to\n\tconvert with calls to fold_convert.\n\n\t* g++.dg/opt/fold1.C: New test case.\n\nFrom-SVN: r77464", "tree": {"sha": "a332f087a54481cb0bc35e12d08f3362b5f43f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a332f087a54481cb0bc35e12d08f3362b5f43f69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/088414c1224f0b20e3bc0c953bebb7273284f48c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088414c1224f0b20e3bc0c953bebb7273284f48c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/088414c1224f0b20e3bc0c953bebb7273284f48c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088414c1224f0b20e3bc0c953bebb7273284f48c/comments", "author": null, "committer": null, "parents": [{"sha": "076963eb57db82bacc373d507b50459b40589c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076963eb57db82bacc373d507b50459b40589c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076963eb57db82bacc373d507b50459b40589c3e"}], "stats": {"total": 727, "additions": 450, "deletions": 277}, "files": [{"sha": "aa425183fdf81060143f9c6787dc01ef4e2659da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=088414c1224f0b20e3bc0c953bebb7273284f48c", "patch": "@@ -1,3 +1,17 @@\n+2004-02-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/13696\n+\t* fold-const.c (fold_convert): New function to provide type\n+\tconversion to the middle-end without using convert.\n+\t(negate_expr, associate_trees, size_diffop, omit_one_operand,\n+\toperand_equal_for_comparison_p, pedantic_omit_one_operand,\n+\tinvert_truthvalue, optimize_bit_field_compare, range_binop,\n+\tdecode_field_reference, make_range, build_range_check, unextend,\n+\tfold_truthop, extract_muldiv_1, fold_mathfn_compare,\n+\tfold_binary_op_with_conditional_arg, fold_inf_compare,\n+\tfold_single_bit_test, fold, multiple_of_p): Replace all calls to\n+\tconvert with calls to fold_convert.\n+\n 2004-02-07  Jan Hubicka  <jh@suse.cz>\n \n \t* genrecog.c (find_operand): add extra argument stop."}, {"sha": "b51a510f05c04c5b7012d1580e8becda3d8e19b2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 414, "deletions": 277, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=088414c1224f0b20e3bc0c953bebb7273284f48c", "patch": "@@ -70,6 +70,7 @@ static tree const_binop (enum tree_code, tree, tree, int);\n static hashval_t size_htab_hash (const void *);\n static int size_htab_eq (const void *, const void *);\n static tree fold_convert_const (enum tree_code, tree, tree);\n+static tree fold_convert (tree, tree);\n static enum tree_code invert_tree_comparison (enum tree_code);\n static enum tree_code swap_tree_comparison (enum tree_code);\n static int comparison_to_compcode (enum tree_code);\n@@ -971,7 +972,7 @@ negate_expr (tree t)\n       tem = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (t)));\n       /* Two's complement FP formats, such as c4x, may overflow.  */\n       if (! TREE_OVERFLOW (tem) || ! flag_trapping_math)\n-\treturn convert (type, tem);\n+\treturn fold_convert (type, tem);\n       break;\n \n     case COMPLEX_CST:\n@@ -988,7 +989,7 @@ negate_expr (tree t)\n       break;\n \n     case NEGATE_EXPR:\n-      return convert (type, TREE_OPERAND (t, 0));\n+      return fold_convert (type, TREE_OPERAND (t, 0));\n \n     case PLUS_EXPR:\n       if (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n@@ -997,27 +998,27 @@ negate_expr (tree t)\n \t  if (negate_expr_p (TREE_OPERAND (t, 1))\n \t      && reorder_operands_p (TREE_OPERAND (t, 0),\n \t\t\t\t     TREE_OPERAND (t, 1)))\n-\t    return convert (type,\n-\t\t\t    fold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t negate_expr (TREE_OPERAND (t, 1)),\n-\t\t\t\t\t TREE_OPERAND (t, 0))));\n+\t    return fold_convert (type,\n+\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t\t      negate_expr (TREE_OPERAND (t, 1)),\n+\t\t\t\t\t      TREE_OPERAND (t, 0))));\n \t  /* -(A + B) -> (-A) - B.  */\n \t  if (negate_expr_p (TREE_OPERAND (t, 0)))\n-\t    return convert (type,\n-\t\t\t    fold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t\t negate_expr (TREE_OPERAND (t, 0)),\n-\t\t\t\t\t TREE_OPERAND (t, 1))));\n+\t    return fold_convert (type,\n+\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t\t      negate_expr (TREE_OPERAND (t, 0)),\n+\t\t\t\t\t      TREE_OPERAND (t, 1))));\n \t}\n       break;\n \n     case MINUS_EXPR:\n       /* - (A - B) -> B - A  */\n       if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t  && reorder_operands_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1)))\n-\treturn convert (type,\n-\t\t\tfold (build (MINUS_EXPR, TREE_TYPE (t),\n-\t\t\t\t     TREE_OPERAND (t, 1),\n-\t\t\t\t     TREE_OPERAND (t, 0))));\n+\treturn fold_convert (type,\n+\t\t\t     fold (build (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t\t  TREE_OPERAND (t, 1),\n+\t\t\t\t\t  TREE_OPERAND (t, 0))));\n       break;\n \n     case MULT_EXPR:\n@@ -1031,16 +1032,16 @@ negate_expr (tree t)\n \t{\n \t  tem = TREE_OPERAND (t, 1);\n \t  if (negate_expr_p (tem))\n-\t    return convert (type,\n-\t\t\t    fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t TREE_OPERAND (t, 0),\n-\t\t\t\t\t negate_expr (tem))));\n+\t    return fold_convert (type,\n+\t\t\t\t fold (build (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t      TREE_OPERAND (t, 0),\n+\t\t\t\t\t      negate_expr (tem))));\n \t  tem = TREE_OPERAND (t, 0);\n \t  if (negate_expr_p (tem))\n-\t    return convert (type,\n-\t\t\t    fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t\t\t negate_expr (tem),\n-\t\t\t\t\t TREE_OPERAND (t, 1))));\n+\t    return fold_convert (type,\n+\t\t\t\t fold (build (TREE_CODE (t), TREE_TYPE (t),\n+\t\t\t\t\t      negate_expr (tem),\n+\t\t\t\t\t      TREE_OPERAND (t, 1))));\n \t}\n       break;\n \n@@ -1050,7 +1051,7 @@ negate_expr (tree t)\n \t{\n \t  tem = strip_float_extensions (t);\n \t  if (tem != t && negate_expr_p (tem))\n-\t    return convert (type, negate_expr (tem));\n+\t    return fold_convert (type, negate_expr (tem));\n \t}\n       break;\n \n@@ -1072,7 +1073,8 @@ negate_expr (tree t)\n       break;\n     }\n \n-  return convert (type, fold (build1 (NEGATE_EXPR, TREE_TYPE (t), t)));\n+  tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (t), t));\n+  return fold_convert (type, tem);\n }\n \f\n /* Split a tree IN into a constant, literal and variable parts that could be\n@@ -1191,16 +1193,18 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n       if (code == PLUS_EXPR)\n \t{\n \t  if (TREE_CODE (t1) == NEGATE_EXPR)\n-\t    return build (MINUS_EXPR, type, convert (type, t2),\n-\t\t\t  convert (type, TREE_OPERAND (t1, 0)));\n+\t    return build (MINUS_EXPR, type, fold_convert (type, t2),\n+\t\t\t  fold_convert (type, TREE_OPERAND (t1, 0)));\n \t  else if (TREE_CODE (t2) == NEGATE_EXPR)\n-\t    return build (MINUS_EXPR, type, convert (type, t1),\n-\t\t\t  convert (type, TREE_OPERAND (t2, 0)));\n+\t    return build (MINUS_EXPR, type, fold_convert (type, t1),\n+\t\t\t  fold_convert (type, TREE_OPERAND (t2, 0)));\n \t}\n-      return build (code, type, convert (type, t1), convert (type, t2));\n+      return build (code, type, fold_convert (type, t1),\n+\t\t    fold_convert (type, t2));\n     }\n \n-  return fold (build (code, type, convert (type, t1), convert (type, t2)));\n+  return fold (build (code, type, fold_convert (type, t1),\n+\t\t      fold_convert (type, t2)));\n }\n \f\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n@@ -1670,20 +1674,21 @@ size_diffop (tree arg0, tree arg1)\n      type and subtract.  The hardware will do the right thing with any\n      overflow in the subtraction.  */\n   if (TREE_CODE (arg0) != INTEGER_CST || TREE_CODE (arg1) != INTEGER_CST)\n-    return size_binop (MINUS_EXPR, convert (ctype, arg0),\n-\t\t       convert (ctype, arg1));\n+    return size_binop (MINUS_EXPR, fold_convert (ctype, arg0),\n+\t\t       fold_convert (ctype, arg1));\n \n   /* If ARG0 is larger than ARG1, subtract and return the result in CTYPE.\n      Otherwise, subtract the other way, convert to CTYPE (we know that can't\n      overflow) and negate (which can't either).  Special-case a result\n      of zero while we're here.  */\n   if (tree_int_cst_equal (arg0, arg1))\n-    return convert (ctype, integer_zero_node);\n+    return fold_convert (ctype, integer_zero_node);\n   else if (tree_int_cst_lt (arg1, arg0))\n-    return convert (ctype, size_binop (MINUS_EXPR, arg0, arg1));\n+    return fold_convert (ctype, size_binop (MINUS_EXPR, arg0, arg1));\n   else\n-    return size_binop (MINUS_EXPR, convert (ctype, integer_zero_node),\n-\t\t       convert (ctype, size_binop (MINUS_EXPR, arg1, arg0)));\n+    return size_binop (MINUS_EXPR, fold_convert (ctype, integer_zero_node),\n+\t\t       fold_convert (ctype, size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t\targ1, arg0)));\n }\n \f\n \n@@ -1848,6 +1853,115 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n     }\n   return NULL_TREE;\n }\n+\n+/* Convert expression ARG to type TYPE.  Used by the middle-end for\n+   simple conversions in preference to calling the front-end's convert.  */\n+\n+static tree\n+fold_convert (tree type, tree arg)\n+{\n+  tree orig = TREE_TYPE (arg);\n+  tree tem;\n+\n+  if (type == orig)\n+    return arg;\n+\n+  if (TREE_CODE (arg) == ERROR_MARK\n+      || TREE_CODE (type) == ERROR_MARK\n+      || TREE_CODE (orig) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig))\n+    return fold (build1 (NOP_EXPR, type, arg));\n+\n+  if (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n+    {\n+      if (TREE_CODE (arg) == INTEGER_CST)\n+\t{\n+\t  tem = fold_convert_const (NOP_EXPR, type, arg);\n+\t  if (tem != NULL_TREE)\n+\t    return tem;\n+\t}\n+      if (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n+        return fold (build1 (NOP_EXPR, type, arg));\n+      if (TREE_CODE (orig) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t  return fold_convert (type, tem);\n+\t}\n+      if (TREE_CODE (orig) == VECTOR_TYPE\n+\t  && GET_MODE_SIZE (TYPE_MODE (type))\n+\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\treturn fold (build1 (NOP_EXPR, type, arg));\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE)\n+    {\n+      if (TREE_CODE (arg) == INTEGER_CST)\n+\t{\n+\t  tem = fold_convert_const (FLOAT_EXPR, type, arg);\n+\t  if (tem != NULL_TREE)\n+\t    return tem;\n+\t}\n+      else if (TREE_CODE (arg) == REAL_CST)\n+\t{\n+\t  tem = fold_convert_const (NOP_EXPR, type, arg);\n+\t  if (tem != NULL_TREE)\n+\t    return tem;\n+\t}\n+\n+      if (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n+        return fold (build1 (FLOAT_EXPR, type, arg));\n+      if (TREE_CODE (orig) == REAL_TYPE)\n+\treturn fold (build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n+\t\t\t     type, arg));\n+      if (TREE_CODE (orig) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t  return fold_convert (type, tem);\n+\t}\n+    }\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      if (INTEGRAL_TYPE_P (orig)\n+\t  || POINTER_TYPE_P (orig)\n+\t  || TREE_CODE (orig) == REAL_TYPE)\n+\treturn build (COMPLEX_EXPR, type,\n+\t\t      fold_convert (TREE_TYPE (type), arg),\n+\t\t      fold_convert (TREE_TYPE (type), integer_zero_node));\n+      if (TREE_CODE (orig) == COMPLEX_TYPE)\n+\t{\n+\t  tree rpart, ipart;\n+\n+\t  if (TREE_CODE (arg) == COMPLEX_EXPR)\n+\t    {\n+\t      rpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n+\t      ipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n+\t      return fold (build (COMPLEX_EXPR, type, rpart, ipart));\n+\t    }\n+\n+\t  arg = save_expr (arg);\n+\t  rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t  ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n+\t  rpart = fold_convert (TREE_TYPE (type), rpart);\n+\t  ipart = fold_convert (TREE_TYPE (type), ipart);\n+\t  return fold (build (COMPLEX_EXPR, type, rpart, ipart));\n+\t}\n+    }\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      if ((INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n+\t  && GET_MODE_SIZE (TYPE_MODE (type))\n+\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\treturn fold (build1 (NOP_EXPR, type, arg));\n+      if (TREE_CODE (orig) == VECTOR_TYPE\n+\t  && GET_MODE_SIZE (TYPE_MODE (type))\n+\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\treturn fold (build1 (NOP_EXPR, type, arg));\n+    }\n+  else if (VOID_TYPE_P (type))\n+    return fold (build1 (CONVERT_EXPR, type, arg));\n+  abort ();\n+}\n \f\n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n@@ -2277,10 +2391,10 @@ operand_equal_for_comparison_p (tree arg0, tree arg1, tree other)\n \n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n-      primarg1 = convert ((*lang_hooks.types.signed_or_unsigned_type)\n-\t\t\t  (unsignedp1, TREE_TYPE (primarg1)), primarg1);\n+      primarg1 = fold_convert ((*lang_hooks.types.signed_or_unsigned_type)\n+\t\t\t       (unsignedp1, TREE_TYPE (primarg1)), primarg1);\n \n-      if (operand_equal_p (arg0, convert (type, primarg1), 0))\n+      if (operand_equal_p (arg0, fold_convert (type, primarg1), 0))\n \treturn 1;\n     }\n \n@@ -2476,7 +2590,7 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n tree\n omit_one_operand (tree type, tree result, tree omitted)\n {\n-  tree t = convert (type, result);\n+  tree t = fold_convert (type, result);\n \n   if (TREE_SIDE_EFFECTS (omitted))\n     return build (COMPOUND_EXPR, type, omitted, t);\n@@ -2489,7 +2603,7 @@ omit_one_operand (tree type, tree result, tree omitted)\n static tree\n pedantic_omit_one_operand (tree type, tree result, tree omitted)\n {\n-  tree t = convert (type, result);\n+  tree t = fold_convert (type, result);\n \n   if (TREE_SIDE_EFFECTS (omitted))\n     return build (COMPOUND_EXPR, type, omitted, t);\n@@ -2529,7 +2643,7 @@ invert_truthvalue (tree arg)\n   switch (code)\n     {\n     case INTEGER_CST:\n-      return convert (type, build_int_2 (integer_zerop (arg), 0));\n+      return fold_convert (type, build_int_2 (integer_zerop (arg), 0));\n \n     case TRUTH_AND_EXPR:\n       return build (TRUTH_OR_EXPR, type,\n@@ -2594,7 +2708,8 @@ invert_truthvalue (tree arg)\n     case BIT_AND_EXPR:\n       if (!integer_onep (TREE_OPERAND (arg, 1)))\n \tbreak;\n-      return build (EQ_EXPR, type, arg, convert (type, integer_zero_node));\n+      return build (EQ_EXPR, type, arg,\n+\t\t    fold_convert (type, integer_zero_node));\n \n     case SAVE_EXPR:\n       return build1 (TRUTH_NOT_EXPR, type, arg);\n@@ -2768,7 +2883,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n   mask = build_int_2 (~0, ~0);\n   TREE_TYPE (mask) = unsigned_type;\n   force_fit_type (mask, 0);\n-  mask = convert (unsigned_type, mask);\n+  mask = fold_convert (unsigned_type, mask);\n   mask = const_binop (LSHIFT_EXPR, mask, size_int (nbitsize - lbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask,\n \t\t      size_int (nbitsize - lbitsize - lbitpos), 0);\n@@ -2798,35 +2913,35 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n   if (lunsignedp)\n     {\n       if (! integer_zerop (const_binop (RSHIFT_EXPR,\n-\t\t\t\t\tconvert (unsigned_type, rhs),\n+\t\t\t\t\tfold_convert (unsigned_type, rhs),\n \t\t\t\t\tsize_int (lbitsize), 0)))\n \t{\n \t  warning (\"comparison is always %d due to width of bit-field\",\n \t\t   code == NE_EXPR);\n-\t  return convert (compare_type,\n-\t\t\t  (code == NE_EXPR\n-\t\t\t   ? integer_one_node : integer_zero_node));\n+\t  return fold_convert (compare_type,\n+\t\t\t       (code == NE_EXPR\n+\t\t\t\t? integer_one_node : integer_zero_node));\n \t}\n     }\n   else\n     {\n-      tree tem = const_binop (RSHIFT_EXPR, convert (signed_type, rhs),\n+      tree tem = const_binop (RSHIFT_EXPR, fold_convert (signed_type, rhs),\n \t\t\t      size_int (lbitsize - 1), 0);\n       if (! integer_zerop (tem) && ! integer_all_onesp (tem))\n \t{\n \t  warning (\"comparison is always %d due to width of bit-field\",\n \t\t   code == NE_EXPR);\n-\t  return convert (compare_type,\n-\t\t\t  (code == NE_EXPR\n-\t\t\t   ? integer_one_node : integer_zero_node));\n+\t  return fold_convert (compare_type,\n+\t\t\t       (code == NE_EXPR\n+\t\t\t\t? integer_one_node : integer_zero_node));\n \t}\n     }\n \n   /* Single-bit compares should always be against zero.  */\n   if (lbitsize == 1 && ! integer_zerop (rhs))\n     {\n       code = code == EQ_EXPR ? NE_EXPR : EQ_EXPR;\n-      rhs = convert (type, integer_zero_node);\n+      rhs = fold_convert (type, integer_zero_node);\n     }\n \n   /* Make a new bitfield reference, shift the constant over the\n@@ -2841,7 +2956,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n \n   rhs = fold (const_binop (BIT_AND_EXPR,\n \t\t\t   const_binop (LSHIFT_EXPR,\n-\t\t\t\t\tconvert (unsigned_type, rhs),\n+\t\t\t\t\tfold_convert (unsigned_type, rhs),\n \t\t\t\t\tsize_int (lbitpos), 0),\n \t\t\t   mask, 0));\n \n@@ -2935,7 +3050,7 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   /* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */\n   if (and_mask != 0)\n     mask = fold (build (BIT_AND_EXPR, unsigned_type,\n-\t\t\tconvert (unsigned_type, and_mask), mask));\n+\t\t\tfold_convert (unsigned_type, and_mask), mask));\n \n   *pmask = mask;\n   *pand_mask = and_mask;\n@@ -3101,7 +3216,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n   if (arg0 != 0 && arg1 != 0)\n     {\n       tem = fold (build (code, type != 0 ? type : TREE_TYPE (arg0),\n-\t\t\t arg0, convert (TREE_TYPE (arg0), arg1)));\n+\t\t\t arg0, fold_convert (TREE_TYPE (arg0), arg1)));\n       STRIP_NOPS (tem);\n       return TREE_CODE (tem) == INTEGER_CST ? tem : 0;\n     }\n@@ -3141,7 +3256,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n       abort ();\n     }\n \n-  return convert (type, result ? integer_one_node : integer_zero_node);\n+  return fold_convert (type, result ? integer_one_node : integer_zero_node);\n }\n \f\n /* Given EXP, a logical expression, set the range it is testing into\n@@ -3165,7 +3280,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n      the outer loop when we've changed something; otherwise we \"break\"\n      the switch, which will \"break\" the while.  */\n \n-  in_p = 0, low = high = convert (TREE_TYPE (exp), integer_zero_node);\n+  in_p = 0;\n+  low = high = fold_convert (TREE_TYPE (exp), integer_zero_node);\n \n   while (1)\n     {\n@@ -3242,7 +3358,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t  if (TREE_UNSIGNED (type) && (low == 0 || high == 0))\n \t    {\n \t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n-\t\t\t\t  1, convert (type, integer_zero_node),\n+\t\t\t\t  1, fold_convert (type, integer_zero_node),\n \t\t\t\t  NULL_TREE))\n \t\tbreak;\n \n@@ -3256,25 +3372,27 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t  in_p = ! in_p;\n \t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n \t\t\t\t      integer_one_node, 0);\n-\t\t  low = convert (type, integer_zero_node);\n+\t\t  low = fold_convert (type, integer_zero_node);\n \t\t}\n \t    }\n \t  continue;\n \n \tcase NEGATE_EXPR:\n \t  /* (-x) IN [a,b] -> x in [-b, -a]  */\n \t  n_low = range_binop (MINUS_EXPR, type,\n-\t\t\t       convert (type, integer_zero_node), 0, high, 1);\n+\t\t\t       fold_convert (type, integer_zero_node),\n+\t\t\t       0, high, 1);\n \t  n_high = range_binop (MINUS_EXPR, type,\n-\t\t\t\tconvert (type, integer_zero_node), 0, low, 0);\n+\t\t\t\tfold_convert (type, integer_zero_node),\n+\t\t\t\t0, low, 0);\n \t  low = n_low, high = n_high;\n \t  exp = arg0;\n \t  continue;\n \n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n \t  exp = build (MINUS_EXPR, type, negate_expr (arg0),\n-\t\t       convert (type, integer_one_node));\n+\t\t       fold_convert (type, integer_one_node));\n \t  continue;\n \n \tcase PLUS_EXPR:  case MINUS_EXPR:\n@@ -3330,10 +3448,10 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t  n_low = low, n_high = high;\n \n \t  if (n_low != 0)\n-\t    n_low = convert (type, n_low);\n+\t    n_low = fold_convert (type, n_low);\n \n \t  if (n_high != 0)\n-\t    n_high = convert (type, n_high);\n+\t    n_high = fold_convert (type, n_high);\n \n \t  /* If we're converting from an unsigned to a signed type,\n \t     we will be doing the comparison as unsigned.  The tests above\n@@ -3356,17 +3474,19 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \t      if (TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (exp)))\n \t        high_positive = fold (build (RSHIFT_EXPR, type,\n-\t\t\t\t\t     convert (type, high_positive),\n-\t\t\t\t\t     convert (type, integer_one_node)));\n+\t\t\t\t\t     fold_convert (type,\n+\t\t\t\t\t\t\t   high_positive),\n+\t\t\t\t\t     fold_convert (type,\n+\t\t\t\t\t\t\t   integer_one_node)));\n \n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n \t\t positive.  */\n \t      if (low != 0)\n \t\t{\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n-\t\t\t\t      1, n_low, n_high,\n-\t\t\t\t      1, convert (type, integer_zero_node),\n+\t\t\t\t      1, n_low, n_high, 1,\n+\t\t\t\t      fold_convert (type, integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -3377,8 +3497,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t  /* Otherwise, \"or\" the range with the range of the input\n \t\t     that will be interpreted as negative.  */\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n-\t\t\t\t      0, n_low, n_high,\n-\t\t\t\t      1, convert (type, integer_zero_node),\n+\t\t\t\t      0, n_low, n_high, 1,\n+\t\t\t\t      fold_convert (type, integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -3427,7 +3547,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     return invert_truthvalue (value);\n \n   if (low == 0 && high == 0)\n-    return convert (type, integer_one_node);\n+    return fold_convert (type, integer_one_node);\n \n   if (low == 0)\n     return fold (build (LE_EXPR, type, exp, high));\n@@ -3443,8 +3563,8 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n       if (! TREE_UNSIGNED (etype))\n \t{\n \t  etype = (*lang_hooks.types.unsigned_type) (etype);\n-\t  high = convert (etype, high);\n-\t  exp = convert (etype, exp);\n+\t  high = fold_convert (etype, high);\n+\t  exp = fold_convert (etype, exp);\n \t}\n       return build_range_check (type, exp, 1, 0, high);\n     }\n@@ -3473,18 +3593,19 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t  if (TREE_UNSIGNED (etype))\n \t    {\n \t      etype = (*lang_hooks.types.signed_type) (etype);\n-\t      exp = convert (etype, exp);\n+\t      exp = fold_convert (etype, exp);\n \t    }\n \t  return fold (build (GT_EXPR, type, exp,\n-\t\t\t      convert (etype, integer_zero_node)));\n+\t\t\t      fold_convert (etype, integer_zero_node)));\n \t}\n     }\n \n   if (0 != (value = const_binop (MINUS_EXPR, high, low, 0))\n       && ! TREE_OVERFLOW (value))\n     return build_range_check (type,\n \t\t\t      fold (build (MINUS_EXPR, etype, exp, low)),\n-\t\t\t      1, convert (etype, integer_zero_node), value);\n+\t\t\t      1, fold_convert (etype, integer_zero_node),\n+\t\t\t      value);\n \n   return 0;\n }\n@@ -3724,17 +3845,18 @@ unextend (tree c, int p, int unsignedp, tree mask)\n      zero or one, and the conversion to a signed type can never overflow.\n      We could get an overflow if this conversion is done anywhere else.  */\n   if (TREE_UNSIGNED (type))\n-    temp = convert ((*lang_hooks.types.signed_type) (type), temp);\n+    temp = fold_convert ((*lang_hooks.types.signed_type) (type), temp);\n \n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n   temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n   if (mask != 0)\n-    temp = const_binop (BIT_AND_EXPR, temp, convert (TREE_TYPE (c), mask), 0);\n+    temp = const_binop (BIT_AND_EXPR, temp,\n+\t\t\tfold_convert (TREE_TYPE (c), mask), 0);\n   /* If necessary, convert the type back to match the type of C.  */\n   if (TREE_UNSIGNED (type))\n-    temp = convert (type, temp);\n+    temp = fold_convert (type, temp);\n \n-  return convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n+  return fold_convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n }\n \f\n /* Find ways of folding logical expressions of LHS and RHS:\n@@ -3852,9 +3974,9 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \tcompcode = -1;\n \n       if (compcode == COMPCODE_TRUE)\n-\treturn convert (truth_type, integer_one_node);\n+\treturn fold_convert (truth_type, integer_one_node);\n       else if (compcode == COMPCODE_FALSE)\n-\treturn convert (truth_type, integer_zero_node);\n+\treturn fold_convert (truth_type, integer_zero_node);\n       else if (compcode != -1)\n \treturn build (compcode_to_comparison (compcode),\n \t\t      truth_type, ll_arg, lr_arg);\n@@ -3994,14 +4116,14 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       xrl_bitpos = lnbitsize - xrl_bitpos - rl_bitsize;\n     }\n \n-  ll_mask = const_binop (LSHIFT_EXPR, convert (lntype, ll_mask),\n+  ll_mask = const_binop (LSHIFT_EXPR, fold_convert (lntype, ll_mask),\n \t\t\t size_int (xll_bitpos), 0);\n-  rl_mask = const_binop (LSHIFT_EXPR, convert (lntype, rl_mask),\n+  rl_mask = const_binop (LSHIFT_EXPR, fold_convert (lntype, rl_mask),\n \t\t\t size_int (xrl_bitpos), 0);\n \n   if (l_const)\n     {\n-      l_const = convert (lntype, l_const);\n+      l_const = fold_convert (lntype, l_const);\n       l_const = unextend (l_const, ll_bitsize, ll_unsignedp, ll_and_mask);\n       l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n@@ -4011,14 +4133,14 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n \n-\t  return convert (truth_type,\n-\t\t\t  wanted_code == NE_EXPR\n-\t\t\t  ? integer_one_node : integer_zero_node);\n+\t  return fold_convert (truth_type,\n+\t\t\t       wanted_code == NE_EXPR\n+\t\t\t       ? integer_one_node : integer_zero_node);\n \t}\n     }\n   if (r_const)\n     {\n-      r_const = convert (lntype, r_const);\n+      r_const = fold_convert (lntype, r_const);\n       r_const = unextend (r_const, rl_bitsize, rl_unsignedp, rl_and_mask);\n       r_const = const_binop (LSHIFT_EXPR, r_const, size_int (xrl_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, r_const,\n@@ -4028,9 +4150,9 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n \n-\t  return convert (truth_type,\n-\t\t\t  wanted_code == NE_EXPR\n-\t\t\t  ? integer_one_node : integer_zero_node);\n+\t  return fold_convert (truth_type,\n+\t\t\t       wanted_code == NE_EXPR\n+\t\t\t       ? integer_one_node : integer_zero_node);\n \t}\n     }\n \n@@ -4065,9 +4187,9 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t  xrr_bitpos = rnbitsize - xrr_bitpos - rr_bitsize;\n \t}\n \n-      lr_mask = const_binop (LSHIFT_EXPR, convert (rntype, lr_mask),\n+      lr_mask = const_binop (LSHIFT_EXPR, fold_convert (rntype, lr_mask),\n \t\t\t     size_int (xlr_bitpos), 0);\n-      rr_mask = const_binop (LSHIFT_EXPR, convert (rntype, rr_mask),\n+      rr_mask = const_binop (LSHIFT_EXPR, fold_convert (rntype, rr_mask),\n \t\t\t     size_int (xrr_bitpos), 0);\n \n       /* Make a mask that corresponds to both fields being compared.\n@@ -4122,14 +4244,14 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t    {\n \t      if (lnbitsize > rnbitsize)\n \t\t{\n-\t\t  lhs = convert (rntype, lhs);\n-\t\t  ll_mask = convert (rntype, ll_mask);\n+\t\t  lhs = fold_convert (rntype, lhs);\n+\t\t  ll_mask = fold_convert (rntype, ll_mask);\n \t\t  type = rntype;\n \t\t}\n \t      else if (lnbitsize < rnbitsize)\n \t\t{\n-\t\t  rhs = convert (lntype, rhs);\n-\t\t  lr_mask = convert (lntype, lr_mask);\n+\t\t  rhs = fold_convert (lntype, rhs);\n+\t\t  lr_mask = fold_convert (lntype, lr_mask);\n \t\t  type = lntype;\n \t\t}\n \t    }\n@@ -4158,12 +4280,12 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       if (wanted_code == NE_EXPR)\n \t{\n \t  warning (\"`or' of unmatched not-equal tests is always 1\");\n-\t  return convert (truth_type, integer_one_node);\n+\t  return fold_convert (truth_type, integer_one_node);\n \t}\n       else\n \t{\n \t  warning (\"`and' of mutually exclusive equal-tests is always 0\");\n-\t  return convert (truth_type, integer_zero_node);\n+\t  return fold_convert (truth_type, integer_zero_node);\n \t}\n     }\n \n@@ -4348,7 +4470,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t or (for divide and modulus) if it is a multiple of our constant.  */\n       if (code == MULT_EXPR\n \t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, t, c, 0)))\n-\treturn const_binop (code, convert (ctype, t), convert (ctype, c), 0);\n+\treturn const_binop (code, fold_convert (ctype, t),\n+\t\t\t    fold_convert (ctype, c), 0);\n       break;\n \n     case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n@@ -4378,7 +4501,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       /* Pass the constant down and see if we can make a simplification.  If\n \t we can, replace this expression with the inner simplification for\n \t possible later conversion to our or some other type.  */\n-      if ((t2 = convert (TREE_TYPE (op0), c)) != 0\n+      if ((t2 = fold_convert (TREE_TYPE (op0), c)) != 0\n \t  && TREE_CODE (t2) == INTEGER_CST\n \t  && ! TREE_CONSTANT_OVERFLOW (t2)\n \t  && (0 != (t1 = extract_muldiv (op0, t2, code,\n@@ -4389,7 +4512,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \n     case NEGATE_EXPR:  case ABS_EXPR:\n       if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n-\treturn fold (build1 (tcode, ctype, convert (ctype, t1)));\n+\treturn fold (build1 (tcode, ctype, fold_convert (ctype, t1)));\n       break;\n \n     case MIN_EXPR:  case MAX_EXPR:\n@@ -4405,8 +4528,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  if (tree_int_cst_sgn (c) < 0)\n \t    tcode = (tcode == MIN_EXPR ? MAX_EXPR : MIN_EXPR);\n \n-\t  return fold (build (tcode, ctype, convert (ctype, t1),\n-\t\t\t      convert (ctype, t2)));\n+\t  return fold (build (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t      fold_convert (ctype, t2)));\n \t}\n       break;\n \n@@ -4425,13 +4548,14 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t     so check for it explicitly here.  */\n \t  && TYPE_PRECISION (TREE_TYPE (size_one_node)) > TREE_INT_CST_LOW (op1)\n \t  && TREE_INT_CST_HIGH (op1) == 0\n-\t  && 0 != (t1 = convert (ctype,\n-\t\t\t\t const_binop (LSHIFT_EXPR, size_one_node,\n-\t\t\t\t\t      op1, 0)))\n+\t  && 0 != (t1 = fold_convert (ctype,\n+\t\t\t\t      const_binop (LSHIFT_EXPR,\n+\t\t\t\t\t\t   size_one_node,\n+\t\t\t\t\t\t   op1, 0)))\n \t  && ! TREE_OVERFLOW (t1))\n \treturn extract_muldiv (build (tcode == LSHIFT_EXPR\n \t\t\t\t      ? MULT_EXPR : FLOOR_DIV_EXPR,\n-\t\t\t\t      ctype, convert (ctype, op0), t1),\n+\t\t\t\t      ctype, fold_convert (ctype, op0), t1),\n \t\t\t       c, code, wide_type);\n       break;\n \n@@ -4448,8 +4572,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t are divisible by c.  */\n \t      || (multiple_of_p (ctype, op0, c)\n \t          && multiple_of_p (ctype, op1, c))))\n-\treturn fold (build (tcode, ctype, convert (ctype, t1),\n-\t\t\t    convert (ctype, t2)));\n+\treturn fold (build (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t    fold_convert (ctype, t2)));\n \n       /* If this was a subtraction, negate OP1 and set it to be an addition.\n \t This simplifies the logic below.  */\n@@ -4478,8 +4602,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       if (code == MULT_EXPR\n \t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n \t{\n-\t  op1 = const_binop (code, convert (ctype, op1),\n-\t\t\t     convert (ctype, c), 0);\n+\t  op1 = const_binop (code, fold_convert (ctype, op1),\n+\t\t\t     fold_convert (ctype, c), 0);\n \t  /* We allow the constant to overflow with wrapping semantics.  */\n \t  if (op1 == 0\n \t      || (TREE_OVERFLOW (op1) && ! flag_wrapv))\n@@ -4499,15 +4623,16 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       /* If we were able to eliminate our operation from the first side,\n \t apply our operation to the second side and reform the PLUS.  */\n       if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR))\n-\treturn fold (build (tcode, ctype, convert (ctype, t1), op1));\n+\treturn fold (build (tcode, ctype, fold_convert (ctype, t1), op1));\n \n       /* The last case is if we are a multiply.  In that case, we can\n \t apply the distributive law to commute the multiply and addition\n \t if the multiplication of the constants doesn't overflow.  */\n       if (code == MULT_EXPR)\n-\treturn fold (build (tcode, ctype, fold (build (code, ctype,\n-\t\t\t\t\t\t       convert (ctype, op0),\n-\t\t\t\t\t\t       convert (ctype, c))),\n+\treturn fold (build (tcode, ctype,\n+\t\t\t    fold (build (code, ctype,\n+\t\t\t\t\t fold_convert (ctype, op0),\n+\t\t\t\t\t fold_convert (ctype, c))),\n \t\t\t    op1));\n \n       break;\n@@ -4530,22 +4655,22 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t do something only if the second operand is a constant.  */\n       if (same_p\n \t  && (t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n-\treturn fold (build (tcode, ctype, convert (ctype, t1),\n-\t\t\t    convert (ctype, op1)));\n+\treturn fold (build (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t    fold_convert (ctype, op1)));\n       else if (tcode == MULT_EXPR && code == MULT_EXPR\n \t       && (t1 = extract_muldiv (op1, c, code, wide_type)) != 0)\n-\treturn fold (build (tcode, ctype, convert (ctype, op0),\n-\t\t\t    convert (ctype, t1)));\n+\treturn fold (build (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t    fold_convert (ctype, t1)));\n       else if (TREE_CODE (op1) != INTEGER_CST)\n \treturn 0;\n \n       /* If these are the same operation types, we can associate them\n \t assuming no overflow.  */\n       if (tcode == code\n-\t  && 0 != (t1 = const_binop (MULT_EXPR, convert (ctype, op1),\n-\t\t\t\t     convert (ctype, c), 0))\n+\t  && 0 != (t1 = const_binop (MULT_EXPR, fold_convert (ctype, op1),\n+\t\t\t\t     fold_convert (ctype, c), 0))\n \t  && ! TREE_OVERFLOW (t1))\n-\treturn fold (build (tcode, ctype, convert (ctype, op0), t1));\n+\treturn fold (build (tcode, ctype, fold_convert (ctype, op0), t1));\n \n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n@@ -4564,15 +4689,15 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR)))\n \t{\n \t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n-\t    return fold (build (tcode, ctype, convert (ctype, op0),\n-\t\t\t\tconvert (ctype,\n-\t\t\t\t\t const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t      op1, c, 0))));\n+\t    return fold (build (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t\tfold_convert (ctype,\n+\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t   op1, c, 0))));\n \t  else if (integer_zerop (const_binop (TRUNC_MOD_EXPR, c, op1, 0)))\n-\t    return fold (build (code, ctype, convert (ctype, op0),\n-\t\t\t\tconvert (ctype,\n-\t\t\t\t\t const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t      c, op1, 0))));\n+\t    return fold (build (code, ctype, fold_convert (ctype, op0),\n+\t\t\t\tfold_convert (ctype,\n+\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t   c, op1, 0))));\n \t}\n       break;\n \n@@ -4739,8 +4864,8 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n     {\n       tree testtype = TREE_TYPE (cond);\n       test = cond;\n-      true_value = convert (testtype, integer_one_node);\n-      false_value = convert (testtype, integer_zero_node);\n+      true_value = fold_convert (testtype, integer_one_node);\n+      false_value = fold_convert (testtype, integer_zero_node);\n     }\n \n   /* If ARG is complex we want to make sure we only evaluate it once.  Though\n@@ -4793,10 +4918,10 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n      of ARG is not enough to decide here. \ufffd*/\n   if (save)\n     return build (COMPOUND_EXPR, type,\n-\t\t  convert (void_type_node, arg),\n+\t\t  fold_convert (void_type_node, arg),\n \t\t  strip_compound_expr (test, arg));\n   else\n-    return convert (type, test);\n+    return fold_convert (type, test);\n }\n \n \f\n@@ -4868,14 +4993,14 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t  /* sqrt(x) < y is always false, if y is negative.  */\n \t  if (code == EQ_EXPR || code == LT_EXPR || code == LE_EXPR)\n \t    return omit_one_operand (type,\n-\t\t\t\t     convert (type, integer_zero_node),\n+\t\t\t\t     fold_convert (type, integer_zero_node),\n \t\t\t\t     arg);\n \n \t  /* sqrt(x) > y is always true, if y is negative and we\n \t     don't care about NaNs, i.e. negative values of x.  */\n \t  if (code == NE_EXPR || !HONOR_NANS (mode))\n \t    return omit_one_operand (type,\n-\t\t\t\t     convert (type, integer_one_node),\n+\t\t\t\t     fold_convert (type, integer_one_node),\n \t\t\t\t     arg);\n \n \t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n@@ -4899,7 +5024,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t      /* sqrt(x) > y is always false, when y is very large\n \t\t and we don't care about infinities.  */\n \t      return omit_one_operand (type,\n-\t\t\t\t       convert (type, integer_zero_node),\n+\t\t\t\t       fold_convert (type, integer_zero_node),\n \t\t\t\t       arg);\n \t    }\n \n@@ -4920,7 +5045,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t\t value and we don't care about NaNs or Infinities.  */\n \t      if (! HONOR_NANS (mode) && ! HONOR_INFINITIES (mode))\n \t\treturn omit_one_operand (type,\n-\t\t\t\t\t convert (type, integer_one_node),\n+\t\t\t\t\t fold_convert (type, integer_one_node),\n \t\t\t\t\t arg);\n \n \t      /* sqrt(x) < y is x != +Inf when y is very large and we\n@@ -5006,14 +5131,14 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n       if (HONOR_SNANS (mode))\n         return NULL_TREE;\n       return omit_one_operand (type,\n-\t\t\t       convert (type, integer_zero_node),\n+\t\t\t       fold_convert (type, integer_zero_node),\n \t\t\t       arg0);\n \n     case LE_EXPR:\n       /* x <= +Inf is always true, if we don't case about NaNs.  */\n       if (! HONOR_NANS (mode))\n \treturn omit_one_operand (type,\n-\t\t\t\t convert (type, integer_one_node),\n+\t\t\t\t fold_convert (type, integer_one_node),\n \t\t\t\t arg0);\n \n       /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n@@ -5100,8 +5225,8 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t{\n \t  tree stype = (*lang_hooks.types.signed_type) (TREE_TYPE (arg00));\n \t  return fold (build (code == EQ_EXPR ? GE_EXPR : LT_EXPR, result_type,\n-\t\t\t      convert (stype, arg00),\n-\t\t\t      convert (stype, integer_zero_node)));\n+\t\t\t      fold_convert (stype, arg00),\n+\t\t\t      fold_convert (stype, integer_zero_node)));\n \t}\n \n       /* At this point, we know that arg0 is not testing the sign bit.  */\n@@ -5137,7 +5262,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       signed_type = (*lang_hooks.types.type_for_mode) (operand_mode, 0);\n       unsigned_type = (*lang_hooks.types.type_for_mode) (operand_mode, 1);\n       intermediate_type = ops_unsigned ? unsigned_type : signed_type;\n-      inner = convert (intermediate_type, inner);\n+      inner = fold_convert (intermediate_type, inner);\n \n       if (bitnum != 0)\n \tinner = build (RSHIFT_EXPR, intermediate_type,\n@@ -5152,7 +5277,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t     inner, integer_one_node);\n \n       /* Make sure to return the proper type.  */\n-      inner = convert (result_type, inner);\n+      inner = fold_convert (result_type, inner);\n \n       return inner;\n     }\n@@ -5516,7 +5641,8 @@ fold (tree expr)\n \t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (final_type)\n \t      && ((inter_int && final_int) || (inter_float && final_float))\n \t      && inter_prec >= final_prec)\n-\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t    return fold_convert (final_type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \n \t  /* Likewise, if the intermediate and final types are either both\n \t     float or both integer, we don't need the middle conversion if\n@@ -5531,14 +5657,16 @@ fold (tree expr)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (final_type))\n \t\t    && TYPE_MODE (final_type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t    return fold_convert (final_type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \n \t  /* If we have a sign-extension of a zero-extended value, we can\n \t     replace that by a single zero-extension.  */\n \t  if (inside_int && inter_int && final_int\n \t      && inside_prec < inter_prec && inter_prec < final_prec\n \t      && inside_unsignedp && !inter_unsignedp)\n-\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t    return fold_convert (final_type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \n \t  /* Two conversions in a row are not needed unless:\n \t     - some conversion is floating-point (overstrict for now), or\n@@ -5562,7 +5690,8 @@ fold (tree expr)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (final_type))\n \t\t    && TYPE_MODE (final_type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t    return fold_convert (final_type,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \t}\n \n       if (TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n@@ -5615,15 +5744,15 @@ fold (tree expr)\n \t\t      == ZERO_EXTEND))\n \t\t{\n \t\t  tree uns = (*lang_hooks.types.unsigned_type) (TREE_TYPE (and0));\n-\t\t  and0 = convert (uns, and0);\n-\t\t  and1 = convert (uns, and1);\n+\t\t  and0 = fold_convert (uns, and0);\n+\t\t  and1 = fold_convert (uns, and1);\n \t\t}\n #endif\n \t    }\n \t  if (change)\n \t    return fold (build (BIT_AND_EXPR, TREE_TYPE (t),\n-\t\t\t\tconvert (TREE_TYPE (t), and0),\n-\t\t\t\tconvert (TREE_TYPE (t), and1)));\n+\t\t\t\tfold_convert (TREE_TYPE (t), and0),\n+\t\t\t\tfold_convert (TREE_TYPE (t), and1)));\n \t}\n \n       tem = fold_convert_const (code, TREE_TYPE (t), arg0);\n@@ -5704,16 +5833,17 @@ fold (tree expr)\n \t{\n \t  tree targ0 = strip_float_extensions (arg0);\n \t  if (targ0 != arg0)\n-\t    return convert (type, fold (build1 (ABS_EXPR, TREE_TYPE (targ0),\n-\t\t\t\t\t\ttarg0)));\n+\t    return fold_convert (type, fold (build1 (ABS_EXPR,\n+\t\t\t\t\t\t     TREE_TYPE (targ0),\n+\t\t\t\t\t\t     targ0)));\n \t}\n       else if (tree_expr_nonnegative_p (arg0))\n \treturn arg0;\n       return t;\n \n     case CONJ_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn convert (type, arg0);\n+\treturn fold_convert (type, arg0);\n       else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n \treturn build (COMPLEX_EXPR, type,\n \t\t      TREE_OPERAND (arg0, 0),\n@@ -5755,7 +5885,7 @@ fold (tree expr)\n       else if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n-\t    return non_lvalue (convert (type, arg0));\n+\t    return non_lvalue (fold_convert (type, arg0));\n \n \t  /* If we are adding two BIT_AND_EXPR's, both of which are and'ing\n \t     with a constant, and the two constants have no bits in common,\n@@ -5796,16 +5926,16 @@ fold (tree expr)\n \t\t  && TREE_CODE (parg1) != MULT_EXPR)\n \t\treturn fold (build (PLUS_EXPR, type,\n \t\t\t\t    fold (build (PLUS_EXPR, type,\n-\t\t\t\t\t\t convert (type, parg0),\n-\t\t\t\t\t\t convert (type, marg))),\n-\t\t\t\t    convert (type, parg1)));\n+\t\t\t\t\t\t fold_convert (type, parg0),\n+\t\t\t\t\t\t fold_convert (type, marg))),\n+\t\t\t\t    fold_convert (type, parg1)));\n \t      if (TREE_CODE (parg0) != MULT_EXPR\n \t\t  && TREE_CODE (parg1) == MULT_EXPR)\n \t\treturn fold (build (PLUS_EXPR, type,\n \t\t\t\t    fold (build (PLUS_EXPR, type,\n-\t\t\t\t\t\t convert (type, parg1),\n-\t\t\t\t\t\t convert (type, marg))),\n-\t\t\t\t    convert (type, parg0)));\n+\t\t\t\t\t\t fold_convert (type, parg1),\n+\t\t\t\t\t\t fold_convert (type, marg))),\n+\t\t\t\t    fold_convert (type, parg0)));\n \t    }\n \n \t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n@@ -5873,11 +6003,11 @@ fold (tree expr)\n \t{\n \t  /* See if ARG1 is zero and X + ARG1 reduces to X.  */\n \t  if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 0))\n-\t    return non_lvalue (convert (type, arg0));\n+\t    return non_lvalue (fold_convert (type, arg0));\n \n \t  /* Likewise if the operands are reversed.  */\n \t  if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n-\t    return non_lvalue (convert (type, arg1));\n+\t    return non_lvalue (fold_convert (type, arg1));\n \n \t  /* Convert x+x into x*2.0.  */\n \t  if (operand_equal_p (arg0, arg1, 0)\n@@ -6070,19 +6200,22 @@ fold (tree expr)\n \t      if (minus_lit0)\n \t\t{\n \t\t  if (con0 == 0)\n-\t\t    return convert (type, associate_trees (var0, minus_lit0,\n-\t\t\t\t\t\t\t   MINUS_EXPR, type));\n+\t\t    return fold_convert (type,\n+\t\t\t\t\t associate_trees (var0, minus_lit0,\n+\t\t\t\t\t\t\t  MINUS_EXPR, type));\n \t\t  else\n \t\t    {\n \t\t      con0 = associate_trees (con0, minus_lit0,\n \t\t\t\t\t      MINUS_EXPR, type);\n-\t\t      return convert (type, associate_trees (var0, con0,\n-\t\t\t\t\t\t\t     PLUS_EXPR, type));\n+\t\t      return fold_convert (type,\n+\t\t\t\t\t   associate_trees (var0, con0,\n+\t\t\t\t\t\t\t    PLUS_EXPR, type));\n \t\t    }\n \t\t}\n \n \t      con0 = associate_trees (con0, lit0, code, type);\n-\t      return convert (type, associate_trees (var0, con0, code, type));\n+\t      return fold_convert (type, associate_trees (var0, con0,\n+\t\t\t\t\t\t\t  code, type));\n \t    }\n \t}\n \n@@ -6094,7 +6227,7 @@ fold (tree expr)\n \t  /* The return value should always have\n \t     the same type as the original expression.  */\n \t  if (TREE_TYPE (t1) != TREE_TYPE (t))\n-\t    t1 = convert (TREE_TYPE (t), t1);\n+\t    t1 = fold_convert (TREE_TYPE (t), t1);\n \n \t  return t1;\n \t}\n@@ -6116,9 +6249,9 @@ fold (tree expr)\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n-\t    return negate_expr (convert (type, arg1));\n+\t    return negate_expr (fold_convert (type, arg1));\n \t  if (integer_zerop (arg1))\n-\t    return non_lvalue (convert (type, arg0));\n+\t    return non_lvalue (fold_convert (type, arg0));\n \n \t  /* Fold A - (A & B) into ~B & A.  */\n \t  if (!TREE_SIDE_EFFECTS (arg0)\n@@ -6158,13 +6291,13 @@ fold (tree expr)\n \n       /* See if ARG1 is zero and X - ARG1 reduces to X.  */\n       else if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n \n       /* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether\n \t ARG0 is zero and X + ARG0 reduces to X, since that would mean\n \t (-ARG1 + ARG0) reduces to -ARG1.  */\n       else if (!wins && fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n-\treturn negate_expr (convert (type, arg1));\n+\treturn negate_expr (fold_convert (type, arg1));\n \n       /* Fold &x - &x.  This can happen from &x.foo - &x.\n \t This is unsafe for certain floats even in non-IEEE formats.\n@@ -6174,7 +6307,7 @@ fold (tree expr)\n \n       if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t  && operand_equal_p (arg0, arg1, 0))\n-\treturn convert (type, integer_zero_node);\n+\treturn fold_convert (type, integer_zero_node);\n \n       /* A - B -> A + (-B) if B is easily negatable.  */\n       if (!wins && negate_expr_p (arg1)\n@@ -6222,7 +6355,7 @@ fold (tree expr)\n \t  if (integer_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n \t  if (integer_onep (arg1))\n-\t    return non_lvalue (convert (type, arg0));\n+\t    return non_lvalue (fold_convert (type, arg0));\n \n \t  /* (a * (1 << b)) is (a << b)  */\n \t  if (TREE_CODE (arg1) == LSHIFT_EXPR\n@@ -6236,9 +6369,9 @@ fold (tree expr)\n \n \t  if (TREE_CODE (arg1) == INTEGER_CST\n \t      && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0),\n-\t\t\t\t\t     convert (type, arg1),\n+\t\t\t\t\t     fold_convert (type, arg1),\n \t\t\t\t\t     code, NULL_TREE)))\n-\t    return convert (type, tem);\n+\t    return fold_convert (type, tem);\n \n \t}\n       else\n@@ -6254,7 +6387,7 @@ fold (tree expr)\n \t  /* In IEEE floating point, x*1 is not equivalent to x for snans.  */\n \t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n \t      && real_onep (arg1))\n-\t    return non_lvalue (convert (type, arg0));\n+\t    return non_lvalue (fold_convert (type, arg0));\n \n \t  /* Transform x * -1.0 into -x.  */\n \t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n@@ -6475,7 +6608,7 @@ fold (tree expr)\n       if (integer_all_onesp (arg1))\n \treturn omit_one_operand (type, arg1, arg0);\n       if (integer_zerop (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       t1 = distribute_bit_expr (code, type, arg0, arg1);\n       if (t1 != NULL_TREE)\n \treturn t1;\n@@ -6501,7 +6634,7 @@ fold (tree expr)\n \n     case BIT_XOR_EXPR:\n       if (integer_zerop (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_all_onesp (arg1))\n \treturn fold (build1 (BIT_NOT_EXPR, type, arg0));\n \n@@ -6527,7 +6660,7 @@ fold (tree expr)\n \n     case BIT_AND_EXPR:\n       if (integer_all_onesp (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_zerop (arg1))\n \treturn omit_one_operand (type, arg1, arg0);\n       t1 = distribute_bit_expr (code, type, arg0, arg1);\n@@ -6543,7 +6676,7 @@ fold (tree expr)\n \t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_WIDE_INT\n \t      && (~TREE_INT_CST_LOW (arg1)\n \t\t  & (((HOST_WIDE_INT) 1 << prec) - 1)) == 0)\n-\t    return build1 (NOP_EXPR, type, TREE_OPERAND (arg0, 0));\n+\t    return fold_convert (type, TREE_OPERAND (arg0, 0));\n \t}\n \n       /* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).\n@@ -6584,12 +6717,12 @@ fold (tree expr)\n       /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n       if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n \t  && real_onep (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n \n       /* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */\n       if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n \t  && real_minus_onep (arg1))\n-\treturn non_lvalue (convert (type, negate_expr (arg0)));\n+\treturn non_lvalue (fold_convert (type, negate_expr (arg0)));\n \n       /* If ARG1 is a constant, we can convert this to a multiply by the\n \t reciprocal.  This does not have the same rounding properties,\n@@ -6771,7 +6904,7 @@ fold (tree expr)\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       if (integer_onep (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_zerop (arg1))\n \treturn t;\n \n@@ -6788,7 +6921,7 @@ fold (tree expr)\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n \t\t\t\t\t code, NULL_TREE)))\n-\treturn convert (type, tem);\n+\treturn fold_convert (type, tem);\n \n       goto binary;\n \n@@ -6804,7 +6937,7 @@ fold (tree expr)\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n \t\t\t\t\t code, NULL_TREE)))\n-\treturn convert (type, tem);\n+\treturn fold_convert (type, tem);\n \n       goto binary;\n \n@@ -6823,7 +6956,7 @@ fold (tree expr)\n     case LSHIFT_EXPR:\n     shift:\n       if (integer_zerop (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_zerop (arg0))\n \treturn omit_one_operand (type, arg0, arg1);\n \n@@ -6836,7 +6969,7 @@ fold (tree expr)\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n \t  tree tem = build_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0);\n-\t  tem = convert (TREE_TYPE (arg1), tem);\n+\t  tem = fold_convert (TREE_TYPE (arg1), tem);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n \t  return fold (build (RROTATE_EXPR, type, arg0, tem));\n \t}\n@@ -6900,23 +7033,23 @@ fold (tree expr)\n \t    return tem;\n \t  return t;\n \t}\n-      return convert (type, tem);\n+      return fold_convert (type, tem);\n \n     case TRUTH_ANDIF_EXPR:\n       /* Note that the operands of this must be ints\n \t and their values must be 0 or 1.\n \t (\"true\" is a fixed value perhaps depending on the language.)  */\n       /* If first arg is constant zero, return it.  */\n       if (integer_zerop (arg0))\n-\treturn convert (type, arg0);\n+\treturn fold_convert (type, arg0);\n     case TRUTH_AND_EXPR:\n       /* If either arg is constant true, drop it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n-\treturn non_lvalue (convert (type, arg1));\n+\treturn non_lvalue (fold_convert (type, arg1));\n       if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1)\n \t  /* Preserve sequence points.  */\n \t  && (code != TRUTH_ANDIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       /* If second arg is constant zero, result is zero, but first arg\n \t must be evaluated.  */\n       if (integer_zerop (arg1))\n@@ -6996,15 +7129,15 @@ fold (tree expr)\n \t (\"true\" is a fixed value perhaps depending on the language.)  */\n       /* If first arg is constant true, return it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n-\treturn convert (type, arg0);\n+\treturn fold_convert (type, arg0);\n     case TRUTH_OR_EXPR:\n       /* If either arg is constant zero, drop it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && integer_zerop (arg0))\n-\treturn non_lvalue (convert (type, arg1));\n+\treturn non_lvalue (fold_convert (type, arg1));\n       if (TREE_CODE (arg1) == INTEGER_CST && integer_zerop (arg1)\n \t  /* Preserve sequence points.  */\n \t  && (code != TRUTH_ORIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       /* If second arg is constant true, result is true, but we must\n \t evaluate first arg.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n@@ -7018,14 +7151,14 @@ fold (tree expr)\n     case TRUTH_XOR_EXPR:\n       /* If either arg is constant zero, drop it.  */\n       if (integer_zerop (arg0))\n-\treturn non_lvalue (convert (type, arg1));\n+\treturn non_lvalue (fold_convert (type, arg1));\n       if (integer_zerop (arg1))\n-\treturn non_lvalue (convert (type, arg0));\n+\treturn non_lvalue (fold_convert (type, arg0));\n       /* If either arg is constant true, this is a logical inversion.  */\n       if (integer_onep (arg0))\n-\treturn non_lvalue (convert (type, invert_truthvalue (arg1)));\n+\treturn non_lvalue (fold_convert (type, invert_truthvalue (arg1)));\n       if (integer_onep (arg1))\n-\treturn non_lvalue (convert (type, invert_truthvalue (arg0)));\n+\treturn non_lvalue (fold_convert (type, invert_truthvalue (arg0)));\n       return t;\n \n     case EQ_EXPR:\n@@ -7049,8 +7182,8 @@ fold (tree expr)\n \n \t  /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n \t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t    return fold (build (code, type, convert (newtype, targ0),\n-\t\t\t\tconvert (newtype, targ1)));\n+\t    return fold (build (code, type, fold_convert (newtype, targ0),\n+\t\t\t\tfold_convert (newtype, targ1)));\n \n \t  /* (-a) CMP (-b) -> b CMP a  */\n \t  if (TREE_CODE (arg0) == NEGATE_EXPR\n@@ -7082,7 +7215,7 @@ fold (tree expr)\n \t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t      {\n \t\tt = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t\treturn omit_one_operand (type, convert (type, t), arg0);\n+\t\treturn omit_one_operand (type, fold_convert (type, t), arg0);\n \t      }\n \n \t    /* Fold comparisons against infinity.  */\n@@ -7210,8 +7343,8 @@ fold (tree expr)\n \t\t\t\t\tsize_int (precision - size), 0);\n \t\t    newconst = fold (build (BIT_AND_EXPR,\n \t\t\t\t\t    TREE_TYPE (varop), newconst,\n-\t\t\t\t\t    convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t     mask)));\n+\t\t\t\t\t    fold_convert (TREE_TYPE (varop),\n+\t\t\t\t\t\t\t  mask)));\n \t\t  }\n \n \t\tt = build (code, type,\n@@ -7271,8 +7404,8 @@ fold (tree expr)\n \t\t\t\t\tsize_int (precision - size), 0);\n \t\t    newconst = fold (build (BIT_AND_EXPR,\n \t\t\t\t\t    TREE_TYPE (varop), newconst,\n-\t\t\t\t\t    convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t     mask)));\n+\t\t\t\t\t    fold_convert (TREE_TYPE (varop),\n+\t\t\t\t\t\t\t  mask)));\n \t\t  }\n \n \t\tt = build (code, type,\n@@ -7338,14 +7471,16 @@ fold (tree expr)\n \t\t{\n \t\tcase GT_EXPR:\n \t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   fold_convert (type,\n+\t\t\t\t\t\t\t integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase GE_EXPR:\n \t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase LE_EXPR:\n \t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   fold_convert (type,\n+\t\t\t\t\t\t\t integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase LT_EXPR:\n \t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n@@ -7375,14 +7510,16 @@ fold (tree expr)\n \t\t{\n \t\tcase LT_EXPR:\n \t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   fold_convert (type,\n+\t\t\t\t\t\t\t integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase LE_EXPR:\n \t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase GE_EXPR:\n \t\t  return omit_one_operand (type,\n-\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   fold_convert (type,\n+\t\t\t\t\t\t\t integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase GT_EXPR:\n \t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n@@ -7419,8 +7556,8 @@ fold (tree expr)\n \t\t    st1 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg1));\n \t\t    return fold\n \t\t      (build (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t      type, convert (st0, arg0),\n-\t\t\t      convert (st1, integer_zero_node)));\n+\t\t\t      type, fold_convert (st0, arg0),\n+\t\t\t      fold_convert (st1, integer_zero_node)));\n \t\t  }\n \t      }\n \t  }\n@@ -7466,7 +7603,8 @@ fold (tree expr)\n \t       && (TREE_TYPE (t1) == TREE_TYPE (tem)\n \t\t   || (TREE_CODE (t1) == INTEGER_CST\n \t\t       && int_fits_type_p (t1, TREE_TYPE (tem)))))\n-\treturn fold (build (code, type, tem, convert (TREE_TYPE (tem), t1)));\n+\treturn fold (build (code, type, tem,\n+\t\t\t    fold_convert (TREE_TYPE (tem), t1)));\n \n       /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n \t constant, we can simplify it.  */\n@@ -7509,8 +7647,8 @@ fold (tree expr)\n \t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg0, 0)),\n \t\t\t\t\t TREE_OPERAND (arg0, 1),\n \t\t\t\t\t TREE_OPERAND (TREE_OPERAND (arg0, 0), 1)),\n-\t\t\t\t  convert (TREE_TYPE (arg0),\n-\t\t\t\t\t   integer_one_node)),\n+\t\t\t\t  fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\tinteger_one_node)),\n \t\t\t   arg1));\n \t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n \t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n@@ -7521,8 +7659,8 @@ fold (tree expr)\n \t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg0, 1)),\n \t\t\t\t\t TREE_OPERAND (arg0, 0),\n \t\t\t\t\t TREE_OPERAND (TREE_OPERAND (arg0, 1), 1)),\n-\t\t\t\t  convert (TREE_TYPE (arg0),\n-\t\t\t\t\t   integer_one_node)),\n+\t\t\t\t  fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\tinteger_one_node)),\n \t\t\t   arg1));\n \t}\n \n@@ -7540,18 +7678,20 @@ fold (tree expr)\n \t{\n \t  tree newtype = (*lang_hooks.types.unsigned_type) (TREE_TYPE (arg0));\n \t  tree newmod = build (TREE_CODE (arg0), newtype,\n-\t\t\t       convert (newtype, TREE_OPERAND (arg0, 0)),\n-\t\t\t       convert (newtype, TREE_OPERAND (arg0, 1)));\n+\t\t\t       fold_convert (newtype,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 0)),\n+\t\t\t       fold_convert (newtype,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 1)));\n \n-\t  return build (code, type, newmod, convert (newtype, arg1));\n+\t  return build (code, type, newmod, fold_convert (newtype, arg1));\n \t}\n \n       /* If this is an NE comparison of zero with an AND of one, remove the\n \t comparison since the AND will give the correct value.  */\n       if (code == NE_EXPR && integer_zerop (arg1)\n \t  && TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && integer_onep (TREE_OPERAND (arg0, 1)))\n-\treturn convert (type, arg0);\n+\treturn fold_convert (type, arg0);\n \n       /* If we have (A & C) == C where C is a power of 2, convert this into\n \t (A & C) != 0.  Similarly for NE_EXPR.  */\n@@ -7610,7 +7750,7 @@ fold (tree expr)\n \treturn build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n \t\t      build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t     TREE_OPERAND (arg1, 1)),\n-\t\t      convert (TREE_TYPE (arg0), integer_zero_node));\n+\t\t      fold_convert (TREE_TYPE (arg0), integer_zero_node));\n \n       else if ((code == LT_EXPR || code == GE_EXPR)\n \t       && TREE_UNSIGNED (TREE_TYPE (arg0))\n@@ -7620,10 +7760,11 @@ fold (tree expr)\n \t       && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n \treturn\n \t  build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t convert (TREE_TYPE (arg0),\n-\t\t\t  build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (arg1, 0), 1))),\n-\t\t convert (TREE_TYPE (arg0), integer_zero_node));\n+\t\t fold_convert (TREE_TYPE (arg0),\n+\t\t\t       build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t\t      TREE_OPERAND (TREE_OPERAND (arg1, 0),\n+\t\t\t\t\t\t    1))),\n+\t\t fold_convert (TREE_TYPE (arg0), integer_zero_node));\n \n       /* Simplify comparison of something with itself.  (For IEEE\n \t floating-point, we can only do some of these simplifications.)  */\n@@ -7974,32 +8115,26 @@ fold (tree expr)\n \t    switch (comp_code)\n \t      {\n \t      case EQ_EXPR:\n-\t\treturn\n-\t\t  pedantic_non_lvalue\n-\t\t    (convert (type,\n-\t\t\t      negate_expr\n-\t\t\t      (convert (TREE_TYPE (TREE_OPERAND (t, 1)),\n-\t\t\t\t\targ1))));\n+\t\ttem = fold_convert (TREE_TYPE (TREE_OPERAND (t, 1)), arg1);\n+\t\ttem = fold_convert (type, negate_expr (tem));\n+\t\treturn pedantic_non_lvalue (tem);\n \t      case NE_EXPR:\n-\t\treturn pedantic_non_lvalue (convert (type, arg1));\n+\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      case GE_EXPR:\n \t      case GT_EXPR:\n \t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = convert ((*lang_hooks.types.signed_type)\n-\t\t\t\t  (TREE_TYPE (arg1)), arg1);\n-\t\treturn pedantic_non_lvalue\n-\t\t  (convert (type, fold (build1 (ABS_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (arg1), arg1))));\n+\t\t  arg1 = fold_convert ((*lang_hooks.types.signed_type)\n+\t\t\t\t       (TREE_TYPE (arg1)), arg1);\n+\t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n+\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      case LE_EXPR:\n \t      case LT_EXPR:\n \t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = convert ((lang_hooks.types.signed_type)\n-\t\t\t\t  (TREE_TYPE (arg1)), arg1);\n-\t\treturn pedantic_non_lvalue\n-\t\t  (negate_expr (convert (type,\n-\t\t\t\t\t fold (build1 (ABS_EXPR,\n-\t\t\t\t\t\t       TREE_TYPE (arg1),\n-\t\t\t\t\t\t       arg1)))));\n+\t\t  arg1 = fold_convert ((lang_hooks.types.signed_type)\n+\t\t\t\t       (TREE_TYPE (arg1)), arg1);\n+\t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n+\t\targ1 = negate_expr (fold_convert (type, arg1));\n+\t\treturn pedantic_non_lvalue (arg1);\n \t      default:\n \t\tabort ();\n \t      }\n@@ -8012,9 +8147,9 @@ fold (tree expr)\n \t  if (integer_zerop (TREE_OPERAND (arg0, 1)) && integer_zerop (arg2))\n \t    {\n \t      if (comp_code == NE_EXPR)\n-\t\treturn pedantic_non_lvalue (convert (type, arg1));\n+\t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      else if (comp_code == EQ_EXPR)\n-\t\treturn pedantic_non_lvalue (convert (type, integer_zero_node));\n+\t\treturn pedantic_non_lvalue (fold_convert (type, integer_zero_node));\n \t    }\n \n \t  /* Try some transformations of A op B ? A : B.\n@@ -8061,32 +8196,32 @@ fold (tree expr)\n \t      switch (comp_code)\n \t\t{\n \t\tcase EQ_EXPR:\n-\t\t  return pedantic_non_lvalue (convert (type, arg2));\n+\t\t  return pedantic_non_lvalue (fold_convert (type, arg2));\n \t\tcase NE_EXPR:\n-\t\t  return pedantic_non_lvalue (convert (type, arg1));\n+\t\t  return pedantic_non_lvalue (fold_convert (type, arg1));\n \t\tcase LE_EXPR:\n \t\tcase LT_EXPR:\n \t\t  /* In C++ a ?: expression can be an lvalue, so put the\n \t\t     operand which will be used if they are equal first\n \t\t     so that we can convert this back to the\n \t\t     corresponding COND_EXPR.  */\n \t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t\t    return pedantic_non_lvalue\n-\t\t      (convert (type, fold (build (MIN_EXPR, comp_type,\n-\t\t\t\t\t\t   (comp_code == LE_EXPR\n-\t\t\t\t\t\t    ? comp_op0 : comp_op1),\n-\t\t\t\t\t\t   (comp_code == LE_EXPR\n-\t\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n+\t\t    return pedantic_non_lvalue (fold_convert\n+\t\t      (type, fold (build (MIN_EXPR, comp_type,\n+\t\t\t\t\t  (comp_code == LE_EXPR\n+\t\t\t\t\t   ? comp_op0 : comp_op1),\n+\t\t\t\t\t  (comp_code == LE_EXPR\n+\t\t\t\t\t   ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tcase GE_EXPR:\n \t\tcase GT_EXPR:\n \t\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t\t    return pedantic_non_lvalue\n-\t\t      (convert (type, fold (build (MAX_EXPR, comp_type,\n-\t\t\t\t\t\t   (comp_code == GE_EXPR\n-\t\t\t\t\t\t    ? comp_op0 : comp_op1),\n-\t\t\t\t\t\t   (comp_code == GE_EXPR\n-\t\t\t\t\t\t    ? comp_op1 : comp_op0)))));\n+\t\t    return pedantic_non_lvalue (fold_convert\n+\t\t      (type, fold (build (MAX_EXPR, comp_type,\n+\t\t\t\t\t  (comp_code == GE_EXPR\n+\t\t\t\t\t   ? comp_op0 : comp_op1),\n+\t\t\t\t\t  (comp_code == GE_EXPR\n+\t\t\t\t\t   ? comp_op1 : comp_op0)))));\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();\n@@ -8106,7 +8241,7 @@ fold (tree expr)\n \t      {\n \t      case EQ_EXPR:\n \t\t/* We can replace A with C1 in this case.  */\n-\t\targ1 = convert (type, TREE_OPERAND (arg0, 1));\n+\t\targ1 = fold_convert (type, TREE_OPERAND (arg0, 1));\n \t\treturn fold (build (code, type, TREE_OPERAND (t, 0), arg1,\n \t\t\t\t    TREE_OPERAND (t, 2)));\n \n@@ -8186,8 +8321,8 @@ fold (tree expr)\n       if (integer_zerop (TREE_OPERAND (t, 1))\n \t  && integer_onep (TREE_OPERAND (t, 2))\n \t  && truth_value_p (TREE_CODE (arg0)))\n-\treturn pedantic_non_lvalue (convert (type,\n-\t\t\t\t\t     invert_truthvalue (arg0)));\n+\treturn pedantic_non_lvalue (fold_convert (type,\n+\t\t\t\t\t\t  invert_truthvalue (arg0)));\n \n       /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n \t operation is simply A & 2.  */\n@@ -8199,7 +8334,8 @@ fold (tree expr)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR\n \t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),\n \t\t\t      arg1, 1))\n-\treturn pedantic_non_lvalue (convert (type, TREE_OPERAND (arg0, 0)));\n+\treturn pedantic_non_lvalue (fold_convert (type,\n+\t\t\t\t\t\t  TREE_OPERAND (arg0, 0)));\n \n       /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n       if (integer_zerop (TREE_OPERAND (t, 2))\n@@ -8228,9 +8364,9 @@ fold (tree expr)\n       if (TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n \treturn t;\n       /* Don't let (0, 0) be null pointer constant.  */\n-      if (integer_zerop (arg1))\n-\treturn pedantic_non_lvalue (build1 (NOP_EXPR, type, arg1));\n-      return pedantic_non_lvalue (convert (type, arg1));\n+      tem = integer_zerop (arg1) ? build1 (NOP_EXPR, type, arg1)\n+\t\t\t\t : fold_convert (type, arg1);\n+      return pedantic_non_lvalue (tem);\n \n     case COMPLEX_EXPR:\n       if (wins)\n@@ -8255,7 +8391,7 @@ fold (tree expr)\n \n     case IMAGPART_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn convert (type, integer_zero_node);\n+\treturn fold_convert (type, integer_zero_node);\n       else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n \treturn omit_one_operand (type, TREE_OPERAND (arg0, 1),\n \t\t\t\t TREE_OPERAND (arg0, 0));\n@@ -8617,9 +8753,10 @@ multiple_of_p (tree type, tree top, tree bottom)\n \t  if (TYPE_PRECISION (TREE_TYPE (size_one_node))\n \t      > TREE_INT_CST_LOW (op1)\n \t      && TREE_INT_CST_HIGH (op1) == 0\n-\t      && 0 != (t1 = convert (type,\n-\t\t\t\t     const_binop (LSHIFT_EXPR, size_one_node,\n-\t\t\t\t\t\t  op1, 0)))\n+\t      && 0 != (t1 = fold_convert (type,\n+\t\t\t\t\t  const_binop (LSHIFT_EXPR,\n+\t\t\t\t\t\t       size_one_node,\n+\t\t\t\t\t\t       op1, 0)))\n \t      && ! TREE_OVERFLOW (t1))\n \t    return multiple_of_p (type, t1, bottom);\n \t}"}, {"sha": "20a9683a0f398e33f058d0bdd7bfeeeb1d92aa02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=088414c1224f0b20e3bc0c953bebb7273284f48c", "patch": "@@ -1,3 +1,8 @@\n+2004-02-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/13696\n+\t* g++.dg/opt/fold1.C: New test case.\n+\n 2003-02-06  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14033"}, {"sha": "98f1b519115debb24c034f7108b0bdf9163fa833", "filename": "gcc/testsuite/g++.dg/opt/fold1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ffold1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088414c1224f0b20e3bc0c953bebb7273284f48c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ffold1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ffold1.C?ref=088414c1224f0b20e3bc0c953bebb7273284f48c", "patch": "@@ -0,0 +1,17 @@\n+// PR middle-end/13696\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+extern void x(unsigned long*);\n+\n+enum e { red, blue, green };\n+\n+struct s {\n+  unsigned long l;\n+};\n+struct s map[1][256];\n+\n+void\n+f(int i,e j) {\n+     x(&(map[i][j].l));\n+}"}]}