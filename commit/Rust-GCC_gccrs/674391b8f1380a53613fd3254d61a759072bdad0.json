{"sha": "674391b8f1380a53613fd3254d61a759072bdad0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0MzkxYjhmMTM4MGE1MzYxM2ZkMzI1NGQ2MWE3NTkwNzJiZGFkMA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-06-30T00:51:17Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-30T00:51:17Z"}, "message": "re PR tree-optimization/22234 (verify_ssa failed with -fno-exceptions)\n\n\n\tPR 22234\n\t* tree-ssa-copy.c (fini_copy_prop): Do not overwrite copy_of\n\twhen following copy-of chains.\n\ntestsuite/ChangeLog\n\n\tPR 22234\n\t* gcc.dg/20050629-1.c: New test.\n\nFrom-SVN: r101450", "tree": {"sha": "dd909a5c023477ac7df3eee31bc872951a8da4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd909a5c023477ac7df3eee31bc872951a8da4f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/674391b8f1380a53613fd3254d61a759072bdad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674391b8f1380a53613fd3254d61a759072bdad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674391b8f1380a53613fd3254d61a759072bdad0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674391b8f1380a53613fd3254d61a759072bdad0/comments", "author": null, "committer": null, "parents": [{"sha": "acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1"}], "stats": {"total": 316, "additions": 314, "deletions": 2}, "files": [{"sha": "194c81477a2dd5eaf9c6f3c8831d5afc0e9d2c64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=674391b8f1380a53613fd3254d61a759072bdad0", "patch": "@@ -1,3 +1,9 @@\n+2005-06-29  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 22234\n+\t* tree-ssa-copy.c (fini_copy_prop): Do not overwrite copy_of\n+\twhen following copy-of chains.\n+\n 2005-06-30  Jan Hubicka  <jh@suse.cz>\n \n \t* function.h (struct function): Add saved blocks/unexpanded var list."}, {"sha": "a75c03ecfb2ed6f816f23f00fc86ebc4f459bcfa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=674391b8f1380a53613fd3254d61a759072bdad0", "patch": "@@ -1,3 +1,8 @@\n+2005-06-29  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 22234\n+\t* gcc.dg/20050629-1.c: New test.\n+\n 2005-06-29  Ziemowit Laski  <zlaski@apple.com>\n \n \t* obj-c++.dg/const-str-1[0-1].mm: New."}, {"sha": "67d73f0eb66b43b77c4d2fdbba6e9142809673e7", "filename": "gcc/testsuite/gcc.dg/20050629-1.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftestsuite%2Fgcc.dg%2F20050629-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftestsuite%2Fgcc.dg%2F20050629-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20050629-1.c?ref=674391b8f1380a53613fd3254d61a759072bdad0", "patch": "@@ -0,0 +1,297 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w\" } */\n+\n+/* This file was automatically reduced from tree-ssa-operands.c.  It\n+   contains many warnings, but it exposes a copy propagation bug that\n+   is somewhat difficult to reproduce otherwise.  */\n+\n+typedef long unsigned int size_t;\n+  extern void fancy_abort (const char *, int, const char *) __attribute__ ((__noreturn__));\n+  typedef union tree_node *tree;\n+  enum tree_code {\n+ TREE_LIST, ARRAY_TYPE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, STRING_CST, LT_EXPR, GE_EXPR, LABEL_EXPR, ASM_EXPR, SSA_NAME, };\n+  enum tree_code_class {\n+   tcc_type,   tcc_reference,   tcc_expression };\n+  extern const enum tree_code_class tree_code_type[];\n+  extern const unsigned char tree_code_length[];\n+  struct tree_common {\n+   union tree_ann_d *ann;\n+   __extension__ enum tree_code code : 8;\n+ };\n+  struct tree_string {\n+   char str[1];\n+ };\n+  struct tree_list {\n+   tree purpose;\n+   tree value;\n+ };\n+  struct tree_exp {\n+   tree     operands[1];\n+ };\n+  typedef struct ssa_use_operand_d {\n+   struct ssa_use_operand_d* prev;\n+   struct ssa_use_operand_d* next;\n+   tree stmt;\n+   tree * use;\n+ }\n+  ssa_use_operand_t;\n+  struct tree_ssa_name {\n+   struct ssa_use_operand_d imm_uses;\n+ };\n+  union tree_node {\n+   struct tree_common common;\n+   struct tree_string string;\n+   struct tree_list list;\n+   struct tree_exp exp;\n+   struct tree_ssa_name ssa_name;\n+ };\n+  typedef struct bitmap_head_def *bitmap;\n+  typedef union varray_data_tag {\n+   char c[1];\n+   int i[1];\n+   tree * tp[1];\n+ }\n+  varray_data;\n+  struct varray_head_tag {\n+   size_t num_elements;\n+   size_t elements_used;\n+   varray_data data;\n+ };\n+  typedef struct varray_head_tag *varray_type;\n+  extern void varray_check_failed (varray_type, size_t, const char *, int,      const char *) __attribute__ ((__noreturn__));\n+  typedef ssa_use_operand_t *use_operand_p;\n+  struct use_optype_d {\n+   struct use_optype_d *next;\n+   struct ssa_use_operand_d use_ptr;\n+ };\n+  typedef struct use_optype_d *use_optype_p;\n+  struct ssa_operand_memory_d {\n+   char mem[(2048 - sizeof (void *))];\n+ };\n+  struct stmt_operands_d {\n+   struct use_optype_d * use_ops;\n+ };\n+  struct ptr_info_def {\n+   tree name_mem_tag;\n+ };\n+  typedef struct subvar *subvar_t;\n+  struct var_ann_d {\n+   size_t uid;\n+ };\n+  struct stmt_ann_d {\n+   unsigned modified : 1;\n+   struct stmt_operands_d operands;\n+   bitmap addresses_taken;\n+ };\n+  typedef struct var_ann_d *var_ann_t;\n+  typedef struct stmt_ann_d *stmt_ann_t;\n+  static __inline__ var_ann_t var_ann (tree t) {\n+ }\n+  static __inline__ stmt_ann_t stmt_ann (tree t) {\n+   ((void)(!(is_gimple_stmt (t)) ? fancy_abort (\"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-flow-inline.h\", 55, __FUNCTION__), 0 : 0));\n+   return (stmt_ann_t) t->common.ann;\n+ }\n+  static __inline__ unsigned char stmt_modified_p (tree t) {\n+   stmt_ann_t ann = stmt_ann (t);\n+   return ann ? ann->modified : 1;\n+ }\n+  static __inline__ void delink_imm_use (ssa_use_operand_t *linknode) {\n+   if (linknode->prev == ((void *)0))     return;\n+   linknode->prev->next = linknode->next;\n+   linknode->next->prev = linknode->prev;\n+   linknode->prev = ((void *)0);\n+   linknode->next = ((void *)0);\n+ }\n+  static __inline__ void link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list) {\n+   linknode->prev = list;\n+   linknode->next = list->next;\n+   list->next = linknode;\n+ }\n+  static __inline__ void link_imm_use (ssa_use_operand_t *linknode, tree def) {\n+   ssa_use_operand_t *root;\n+   if (!def || ((enum tree_code) (def)->common.code) != SSA_NAME)     linknode->prev = ((void *)0);\n+   else     {\n+       root = &(__extension__ ({ const tree __t = (def); if (((enum tree_code) (__t)->common.code) != (SSA_NAME)) tree_check_failed (__t, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-flow-inline.h\", 222, __FUNCTION__, (SSA_NAME), 0); __t; }\n+)->ssa_name.imm_uses);\n+       link_imm_use_to_list (linknode, root);\n+     }\n+ }\n+  static __inline__ void link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, tree stmt) {\n+     link_imm_use (linknode, def);\n+ }\n+  struct ggc_root_tab {\n+ };\n+  struct opbuild_list_d {\n+   varray_type vars;\n+   varray_type uid;\n+   varray_type next;\n+   int first;\n+   unsigned num;\n+ };\n+  static struct opbuild_list_d build_uses;\n+  static struct opbuild_list_d build_v_may_defs;\n+  static struct ssa_operand_memory_d *operand_memory = ((void *)0);\n+  static unsigned operand_memory_index;\n+  static use_optype_p free_uses = ((void *)0);\n+  static __inline__ int opbuild_next (struct opbuild_list_d *list, int prev) {\n+   return __extension__ (*({\n+ varray_type const _va = (list->next);\n+ const size_t _n = (prev);\n+ if (_n >= _va->num_elements) varray_check_failed (_va, _n, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 323, __FUNCTION__);\n+ &_va->data.i[_n];\n+ }\n+));\n+ }\n+  static __inline__ tree * opbuild_elem_real (struct opbuild_list_d *list, int elem) {\n+   return __extension__ (*({\n+ varray_type const _va = (list->vars);\n+ const size_t _n = (elem);\n+ if (_n >= _va->num_elements) varray_check_failed (_va, _n, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 332, __FUNCTION__);\n+ &_va->data.tp[_n];\n+ }\n+));\n+ }\n+  static __inline__ void opbuild_clear (struct opbuild_list_d *list) {\n+   ((list->vars)->elements_used = 0);\n+   ((list->next)->elements_used = 0);\n+ }\n+  static __inline__ void * ssa_operand_alloc (unsigned size) {\n+   char *ptr;\n+   if (operand_memory_index + size >= (2048 - sizeof (void *)))     {\n+       ptr = ggc_alloc_stat (sizeof (struct ssa_operand_memory_d) );\n+     }\n+   ptr = &(operand_memory->mem[operand_memory_index]);\n+   return ptr;\n+ }\n+  static __inline__ void correct_use_link (use_operand_p ptr, tree stmt) {\n+   use_operand_p prev;\n+   tree root;\n+   prev = ptr->prev;\n+   if (prev)     {\n+       unsigned char stmt_mod = 1;\n+       while (stmt_mod)  {    while (prev->stmt == stmt || prev->stmt == ((void *)0))      prev = prev->prev;    if (prev->use == ((void *)0))      stmt_mod = 0;    else      if ((stmt_mod = stmt_modified_p (prev->stmt)))        prev = prev->prev;  }\n+       if (prev->use == ((void *)0))  root = prev->stmt;\n+       else  root = *(prev->use);\n+       if (root == *(ptr->use))  return;\n+     }\n+   delink_imm_use (ptr);\n+   link_imm_use (ptr, *(ptr->use));\n+ }\n+  static __inline__ struct use_optype_d * alloc_use (void) {\n+   struct use_optype_d *ret;\n+     {\n+       free_uses = free_uses->next;\n+     }\n+     ret = (struct use_optype_d *)ssa_operand_alloc (sizeof (struct use_optype_d));\n+   return ret;\n+ }\n+  static __inline__ void finalize_ssa_use_ops (tree stmt) {\n+   int new_i;\n+   struct use_optype_d *old_ops, *ptr, *last;\n+   tree * old_base;\n+   struct use_optype_d new_list;\n+   last = &new_list;\n+   if (old_ops)     old_base = ((old_ops)->use_ptr.use);\n+   while (old_ops && new_i != -1)     {\n+       tree * new_base = opbuild_elem_real (&build_uses, (new_i));\n+       if (old_base == new_base)         {    last->next = old_ops;    last = old_ops;    correct_use_link ((&((last)->use_ptr)), stmt);    old_ops = old_ops->next;    new_i = opbuild_next (&build_uses, new_i);  }\n+       else         if (old_base < new_base)    {      use_operand_p use_p = (&((old_ops)->use_ptr));      delink_imm_use (use_p);      old_ops = old_ops->next;      ptr->next = free_uses;    }\n+  else    {      ptr = alloc_use ();      (ptr)->use_ptr.use = (opbuild_elem_real (&build_uses, (new_i))); link_imm_use_stmt (&((ptr)->use_ptr), *(opbuild_elem_real (&build_uses, (new_i))), (stmt));      new_i = opbuild_next (&build_uses, new_i);    }\n+       if (old_ops)         old_base = ((old_ops)->use_ptr.use);\n+     }\n+   for ( ;\n+  new_i != -1;\n+  new_i = opbuild_next (&build_uses, new_i))     {\n+       ptr = alloc_use ();\n+       (ptr)->use_ptr.use = (opbuild_elem_real (&build_uses, (new_i)));\n+ link_imm_use_stmt (&((ptr)->use_ptr), *(opbuild_elem_real (&build_uses, (new_i))), (stmt));\n+     }\n+     {\n+  {    use_operand_p use_p = (&((ptr)->use_ptr));    delink_imm_use (use_p);  }\n+     }\n+   (stmt_ann (stmt)->operands.use_ops) = new_list.next;\n+   {\n+     unsigned x = 0;\n+     for (ptr = (stmt_ann (stmt)->operands.use_ops);\n+ ptr;\n+ ptr = ptr->next)       x++;\n+   }\n+ }\n+  finalize_ssa_uses (tree stmt) {\n+   {\n+     unsigned x;\n+       ((void)(!(*(opbuild_elem_real (&build_uses, x)) != stmt) ? fancy_abort (\"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 581, __FUNCTION__), 0 : 0));\n+   }\n+   finalize_ssa_use_ops (stmt);\n+   opbuild_clear (&build_uses);\n+ }\n+  finalize_ssa_v_may_def_ops (tree stmt) {\n+   int new_i;\n+     {\n+     }\n+   for ( ;\n+  new_i != -1;\n+  new_i = opbuild_next (&build_v_may_defs, new_i))     {\n+     }\n+   {\n+   }\n+ }\n+  get_expr_operands (tree stmt, tree *expr_p, int flags) {\n+   enum tree_code code;\n+   tree expr = *expr_p;\n+     {\n+       {  subvar_t svars;  if (var_can_have_subvars (expr)      && (svars = get_subvars_for_var (expr)))    {    }    {    }       }\n+       {    {      if (code == LT_EXPR   || code == GE_EXPR)        {   swap_tree_operands (stmt,         &__extension__ (*({const tree __t = __extension__ ({ const tree __t = (expr); char const __c = tree_code_type[(int) (((enum tree_code) (__t)->common.code))]; if (!((__c) >= tcc_reference && (__c) <= tcc_expression)) tree_class_check_failed (__t, tcc_expression, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1435, __FUNCTION__); __t; }); const int __i = (0); if (__i < 0 || __i >= tree_code_length[(int) (((enum tree_code) (__t)->common.code))]) tree_operand_check_failed (__i, ((enum tree_code) (__t)->common.code), \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1435, __FUNCTION__); &__t->exp.operands[__i]; })),         &__extension__ (*({const tree __t = __extension__ ({ const tree __t = (expr); char const __c = tree_code_type[(int) (((enum tree_code) (__t)->common.code))]; if (!((__c) >= tcc_reference && (__c) <= tcc_expression)) tree_class_check_failed (__t, tcc_expression, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1436, __FUNCTION__); __t; }); const int __i = (1); if (__i < 0 || __i >= tree_code_length[(int) (((enum tree_code) (__t)->common.code))]) tree_operand_check_failed (__i, ((enum tree_code) (__t)->common.code), \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1436, __FUNCTION__); &__t->exp.operands[__i]; })));        }        {        }    }       }\n+     }\n+ }\n+  get_asm_expr_operands (tree stmt) {\n+   int noutputs = list_length (__extension__ (*({\n+const tree __t = __extension__ ({ const tree __t = (__extension__ ({ const tree __t = (stmt); if (((enum tree_code) (__t)->common.code) != (ASM_EXPR)) tree_check_failed (__t, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1495, __FUNCTION__, (ASM_EXPR), 0); __t; })); char const __c = tree_code_type[(int) (((enum tree_code) (__t)->common.code))]; if (!((__c) >= tcc_reference && (__c) <= tcc_expression)) tree_class_check_failed (__t, tcc_expression, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1495, __FUNCTION__); __t; }\n+);\n+ const int __i = (1);\n+ if (__i < 0 || __i >= tree_code_length[(int) (((enum tree_code) (__t)->common.code))]) tree_operand_check_failed (__i, ((enum tree_code) (__t)->common.code), \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1495, __FUNCTION__);\n+ &__t->exp.operands[__i];\n+ }\n+)));\n+   const char **oconstraints     = (const char **) __builtin_alloca((noutputs) * sizeof (const char *));\n+   int i;\n+   tree link;\n+   const char *constraint;\n+   unsigned char allows_mem, allows_reg, is_inout;\n+     {\n+       oconstraints[i] = constraint  = ((const char *)(__extension__ ({ const tree __t = ((__extension__ ({ const tree __t = ((__extension__ ({ const tree __t = (link); if (((enum tree_code) (__t)->common.code) != (TREE_LIST)) tree_check_failed (__t, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1506, __FUNCTION__, (TREE_LIST), 0); __t; })->list.purpose)); if (((enum tree_code) (__t)->common.code) != (TREE_LIST)) tree_check_failed (__t, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1506, __FUNCTION__, (TREE_LIST), 0); __t; })->list.value)); if (((enum tree_code) (__t)->common.code) != (STRING_CST)) tree_check_failed (__t, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1506, __FUNCTION__, (STRING_CST), 0); __t; }\n+)->string.str));\n+       parse_output_constraint (&constraint, i, 0, 0,    &allows_mem, &allows_reg, &is_inout);\n+       }\n+ }\n+  get_indirect_ref_operands (tree stmt, tree expr, int flags) {\n+   tree *pptr = &__extension__ (*({\n+const tree __t = __extension__ ({ const tree __t = (expr); char const __c = tree_code_type[(int) (((enum tree_code) (__t)->common.code))]; if (!((__c) >= tcc_reference && (__c) <= tcc_expression)) tree_class_check_failed (__t, tcc_expression, \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1591, __FUNCTION__); __t; }\n+);\n+ const int __i = (0);\n+ if (__i < 0 || __i >= tree_code_length[(int) (((enum tree_code) (__t)->common.code))]) tree_operand_check_failed (__i, ((enum tree_code) (__t)->common.code), \"/home/cygnus/dnovillo/gcc/src.ppc64/gcc/tree-ssa-operands.c\", 1591, __FUNCTION__);\n+ &__t->exp.operands[__i];\n+ }\n+));\n+   tree ptr = *pptr;\n+     {\n+       struct ptr_info_def *pi = ((void *)0);\n+       if (((enum tree_code) (ptr)->common.code) == SSA_NAME    && pi->name_mem_tag)  {  }\n+     }\n+ }\n+  note_addressable (tree var, stmt_ann_t s_ann) {\n+   subvar_t svars;\n+     {\n+       if (var_can_have_subvars (var)    && (svars = get_subvars_for_var (var)))  bitmap_set_bit (s_ann->addresses_taken, var_ann (var)->uid);\n+     }\n+ }\n+  const struct ggc_root_tab gt_ggc_r_gt_tree_ssa_operands_h[] = {\n+   {\n+     &operand_memory,   }\n+,   {\n+   }\n+,   {\n+   }\n+,   {\n+   }\n+, };"}, {"sha": "7111960823732c0df42a7dfd2a9a4894d4ca5952", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674391b8f1380a53613fd3254d61a759072bdad0/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=674391b8f1380a53613fd3254d61a759072bdad0", "patch": "@@ -885,20 +885,24 @@ static void\n fini_copy_prop (void)\n {\n   size_t i;\n+  prop_value_t *tmp;\n   \n   /* Set the final copy-of value for each variable by traversing the\n      copy-of chains.  */\n+  tmp = xmalloc (num_ssa_names * sizeof (*tmp));\n+  memset (tmp, 0, num_ssa_names * sizeof (*tmp));\n   for (i = 1; i < num_ssa_names; i++)\n     {\n       tree var = ssa_name (i);\n       if (var && copy_of[i].value && copy_of[i].value != var)\n-\tcopy_of[i].value = get_last_copy_of (var);\n+\ttmp[i].value = get_last_copy_of (var);\n     }\n \n-  substitute_and_fold (copy_of, false);\n+  substitute_and_fold (tmp, false);\n \n   free (cached_last_copy_of);\n   free (copy_of);\n+  free (tmp);\n }\n \n "}]}