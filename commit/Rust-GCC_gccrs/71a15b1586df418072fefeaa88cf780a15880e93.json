{"sha": "71a15b1586df418072fefeaa88cf780a15880e93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhMTViMTU4NmRmNDE4MDcyZmVmZWFhODhjZjc4MGExNTg4MGU5Mw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-18T07:41:56Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-18T07:41:56Z"}, "message": "configure.in: Fixed links to platform dependant java.net files.\n\n2003-03-18  Michael Koch  <konqueror@gmx.de>\n\n\t* configure.in: Fixed links to platform dependant java.net files.\n\t* configure: Regenerated.\n\t* java/net/natInetAddress.cc,\n\tjava/net/natNetworkInterface.cc,\n\tjava/net/natPlainDatagramSocketImpl.cc,\n\tjava/net/natPlainSocketImpl.cc:\n\tRemoved.\n\nFrom-SVN: r64527", "tree": {"sha": "52483b00ecc43c38b98e7a1ad04252fed7563316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52483b00ecc43c38b98e7a1ad04252fed7563316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71a15b1586df418072fefeaa88cf780a15880e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a15b1586df418072fefeaa88cf780a15880e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a15b1586df418072fefeaa88cf780a15880e93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a15b1586df418072fefeaa88cf780a15880e93/comments", "author": null, "committer": null, "parents": [{"sha": "9b5f18b179d4fe726cc95a2658af0757eb66e41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b5f18b179d4fe726cc95a2658af0757eb66e41c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b5f18b179d4fe726cc95a2658af0757eb66e41c"}], "stats": {"total": 2412, "additions": 15, "deletions": 2397}, "files": [{"sha": "64f4388c5a98367ee18203f3019c466965e10ee2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=71a15b1586df418072fefeaa88cf780a15880e93", "patch": "@@ -1,3 +1,13 @@\n+2003-03-18  Michael Koch  <konqueror@gmx.de>\n+\n+\t* configure.in: Fixed links to platform dependant java.net files.\n+\t* configure: Regenerated.\n+\t* java/net/natInetAddress.cc,\n+\tjava/net/natNetworkInterface.cc,\n+\tjava/net/natPlainDatagramSocketImpl.cc,\n+\tjava/net/natPlainSocketImpl.cc:\n+\tRemoved.\n+\n 2003-03-18  Michael Koch  <konqueror@gmx.de>\n \n \t* configure.in: Create links to architecture dependent files,"}, {"sha": "45b49c5c830d8eedc48d0f986bf276c5a3e42b6b", "filename": "libjava/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=71a15b1586df418072fefeaa88cf780a15880e93", "patch": "@@ -9136,7 +9136,7 @@ EOF\n \n cat >> $CONFIG_STATUS <<EOF\n ac_sources=\"include/$PLATFORMH java/io/natFile${FILE-${PLATFORM}}.cc java/io/natFileDescriptor${FILE-${PLATFORM}}.cc java/lang/${PLATFORM}Process.java java/lang/nat${PLATFORM}Process.cc java/net/natInetAddress${PLATFORMNET}.cc java/net/natNetworkInterface${PLATFORMNET}.cc java/net/natPlainSocketImpl${PLATFORMNET}.cc java/net/natPlainDatagramSocketImpl${PLATFORMNET}.cc include/$GCHDR include/$THREADH sysdep/$sysdeps_dir/locks.h $SIGNAL_HANDLER\"\n-ac_dests=\"include/platform.h java/io/natFile.cc java/io/natFileDescriptor.cc java/lang/ConcreteProcess.java java/lang/natConcreteProcess.cc java/lang/natInetAddress.cc java/lang/natNetworkInterface.cc java/lang/natPlainSocketImpl.cc java/lang/natPlainDatagramSocketImpl.cc include/java-gc.h include/java-threads.h sysdep/locks.h include/java-signal.h\"\n+ac_dests=\"include/platform.h java/io/natFile.cc java/io/natFileDescriptor.cc java/lang/ConcreteProcess.java java/lang/natConcreteProcess.cc java/net/natInetAddress.cc java/net/natNetworkInterface.cc java/net/natPlainSocketImpl.cc java/net/natPlainDatagramSocketImpl.cc include/java-gc.h include/java-threads.h sysdep/locks.h include/java-signal.h\"\n EOF\n \n cat >> $CONFIG_STATUS <<\\EOF"}, {"sha": "5763c801c3d872880a1977e66a90ed9625855c5b", "filename": "libjava/configure.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71a15b1586df418072fefeaa88cf780a15880e93/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=71a15b1586df418072fefeaa88cf780a15880e93", "patch": "@@ -275,10 +275,10 @@ AC_LINK_FILES(java/lang/nat${PLATFORM}Process.cc, java/lang/natConcreteProcess.c\n dnl Likewise for natInetAddress.cc, natNetworkInterface.cc, natPlainSocketImpl.cc\n dnl and natPlainDatagramSocketImpl.cc\n test -d java/net || mkdir java/net\n-AC_LINK_FILES(java/net/natInetAddress${PLATFORMNET}.cc, java/lang/natInetAddress.cc)\n-AC_LINK_FILES(java/net/natNetworkInterface${PLATFORMNET}.cc, java/lang/natNetworkInterface.cc)\n-AC_LINK_FILES(java/net/natPlainSocketImpl${PLATFORMNET}.cc, java/lang/natPlainSocketImpl.cc)\n-AC_LINK_FILES(java/net/natPlainDatagramSocketImpl${PLATFORMNET}.cc, java/lang/natPlainDatagramSocketImpl.cc)\n+AC_LINK_FILES(java/net/natInetAddress${PLATFORMNET}.cc, java/net/natInetAddress.cc)\n+AC_LINK_FILES(java/net/natNetworkInterface${PLATFORMNET}.cc, java/net/natNetworkInterface.cc)\n+AC_LINK_FILES(java/net/natPlainSocketImpl${PLATFORMNET}.cc, java/net/natPlainSocketImpl.cc)\n+AC_LINK_FILES(java/net/natPlainDatagramSocketImpl${PLATFORMNET}.cc, java/net/natPlainDatagramSocketImpl.cc)\n \n case \"${host}\" in\n     *mingw*)"}, {"sha": "c0083714287b44ac30bff698ddd52109daf7e501", "filename": "libjava/java/net/natInetAddress.cc", "status": "removed", "additions": 0, "deletions": 357, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=9b5f18b179d4fe726cc95a2658af0757eb66e41c", "patch": "@@ -1,357 +0,0 @@\n-// natInetAddress.cc\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n-#undef STRICT\n-\n-#ifndef MAXHOSTNAMELEN\n-#define MAXHOSTNAMELEN\t64\n-#endif /* MAXHOSTNAMELEN */\n-\n-#else /* WIN32 */\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <string.h>\n-#include <errno.h>\n-\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-\n-#endif /* WIN32 */\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/net/InetAddress.h>\n-#include <java/net/UnknownHostException.h>\n-#include <java/lang/SecurityException.h>\n-\n-#if defined(HAVE_UNAME) && ! defined(HAVE_GETHOSTNAME)\n-#include <sys/utsname.h>\n-#endif\n-\n-#ifndef HAVE_GETHOSTNAME_DECL\n-extern \"C\" int gethostname (char *name, int namelen);\n-#endif\n-\n-#ifdef DISABLE_JAVA_NET\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring)\n-{\n-  return NULL;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  return 0;\n-}\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring, java::net::InetAddress *, jboolean)\n-{\n-  return NULL;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  return NULL;\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring host)\n-{\n-  char *hostname;\n-  char buf[100];\n-  int len = JvGetStringUTFLength(host);\n-  if (len < 100)\n-    hostname = buf;\n-  else\n-    hostname = (char*) _Jv_AllocBytes (len+1);\n-  JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-  buf[len] = '\\0';\n-  char* bytes = NULL;\n-  int blen = 0;\n-#ifdef HAVE_INET_ATON\n-  struct in_addr laddr;\n-  if (inet_aton (hostname, &laddr))\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-#elif defined(HAVE_INET_ADDR)\n-#if ! HAVE_IN_ADDR_T\n-  typedef jint in_addr_t;\n-#endif\n-  in_addr_t laddr = inet_addr (hostname);\n-  if (laddr != (in_addr_t)(-1))\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-#endif\n-#if defined (HAVE_INET_PTON) && defined (HAVE_INET6)\n-  char inet6_addr[16];\n-  if (len != 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n-    {\n-      bytes = inet6_addr;\n-      blen = 16;\n-    }\n-#endif\n-  if (blen == 0)\n-    return NULL;\n-  jbyteArray result = JvNewByteArray (blen);\n-  memcpy (elements (result), bytes, blen);\n-  return result;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  int len = bytes->length;\n-  if (len == 4)\n-    return AF_INET;\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    return AF_INET6;\n-#endif /* HAVE_INET6 */\n-  else\n-    JvFail (\"unrecognized size\");\n-}\n-\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n-\t\t\t\tjboolean all)\n-{\n-  struct hostent *hptr = NULL;\n-#if defined (HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR_R)\n-  struct hostent hent_r;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-  struct hostent_data fixed_buffer, *buffer_r = &fixed_buffer;\n-#else\n-#if defined (__GLIBC__) \n-  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n-  // ERANGE to errno if the buffer size is too small, rather than what is \n-  // expected here. We work around this by setting a bigger buffer size and \n-  // hoping that it is big enough.\n-  char fixed_buffer[1024];\n-#else\n-  char fixed_buffer[200];\n-#endif\n-  char *buffer_r = fixed_buffer;\n-  int size_r = sizeof (fixed_buffer);\n-#endif\n-#endif\n-\n-  if (host != NULL)\n-    {\n-      char *hostname;\n-      char buf[100];\n-      int len = JvGetStringUTFLength(host);\n-      if (len < 100)\n-\thostname = buf;\n-      else\n-\thostname = (char*) _Jv_AllocBytes (len+1);\n-      JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-      buf[len] = '\\0';\n-#ifdef HAVE_GETHOSTBYNAME_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYNAME_R_RETURNS_INT\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r, size_r,\n-\t\t\t\t  &hptr, &herr);\n-#else\n-\t  hptr = gethostbyname_r (hostname, &hent_r, buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTNAME_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else\n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyname.\n-      JvSynchronize sync (java::net::InetAddress::localhostAddress);\n-      hptr = gethostbyname (hostname);\n-#endif /* HAVE_GETHOSTBYNAME_R */\n-    }\n-  else\n-    {\n-      jbyteArray bytes = iaddr->addr;\n-      char *chars = (char*) elements (bytes);\n-      int len = bytes->length;\n-      int type;\n-      char *val;\n-      if (len == 4)\n-\t{\n-\t  val = chars;\n-\t  type = iaddr->family = AF_INET;\n-\t}\n-#ifdef HAVE_INET6\n-      else if (len == 16)\n-\t{\n-\t  val = (char *) &chars;\n-\t  type = iaddr->family = AF_INET6;\n-\t}\n-#endif /* HAVE_INET6 */\n-      else\n-\tJvFail (\"unrecognized size\");\n-\n-#ifdef HAVE_GETHOSTBYADDR_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYADDR_R_RETURNS_INT\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &hptr, &herr);\n-#else\n-\t  hptr = gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTBYADDR_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else \n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else /* HAVE_GETHOSTBYADDR_R */\n-      // FIXME: this is insufficient if some other piece of code calls\n-      // this gethostbyaddr.\n-      JvSynchronize sync (java::net::InetAddress::localhostAddress);\n-      hptr = gethostbyaddr (val, len, type);\n-#endif /* HAVE_GETHOSTBYADDR_R */\n-    }\n-  if (hptr != NULL)\n-    {\n-      if (!all)\n-        host = JvNewStringUTF (hptr->h_name);\n-      java::lang::SecurityException *ex = checkConnect (host);\n-      if (ex != NULL)\n-\t{\n-\t  if (iaddr == NULL || iaddr->addr == NULL)\n-\t    throw ex;\n-\t  hptr = NULL;\n-\t}\n-    }\n-  if (hptr == NULL)\n-    {\n-      if (iaddr != NULL && iaddr->addr != NULL)\n-\t{\n-\t  iaddr->hostName = iaddr->getHostAddress();\n-\t  return NULL;\n-\t}\n-      else\n-\tthrow new java::net::UnknownHostException(host);\n-    }\n-  int count;\n-  if (all)\n-    {\n-      char** ptr = hptr->h_addr_list;\n-      count = 0;\n-      while (*ptr++)  count++;\n-    }\n-  else\n-    count = 1;\n-  JArray<java::net::InetAddress*> *result;\n-  java::net::InetAddress** iaddrs;\n-  if (all)\n-    {\n-      result = java::net::InetAddress::allocArray (count);\n-      iaddrs = elements (result);\n-    }\n-  else\n-    {\n-      result = NULL;\n-      iaddrs = &iaddr;\n-    }\n-\n-  for (int i = 0;  i < count;  i++)\n-    {\n-      if (iaddrs[i] == NULL)\n-\tiaddrs[i] = new java::net::InetAddress (NULL, NULL);\n-      if (iaddrs[i]->hostName == NULL)\n-        iaddrs[i]->hostName = host;\n-      if (iaddrs[i]->addr == NULL)\n-\t{\n-\t  char *bytes = hptr->h_addr_list[i];\n-\t  iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n-\t  iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n-\t  memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n-\t}\n-    }\n-  return result;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  char *chars;\n-#ifdef HAVE_GETHOSTNAME\n-  char buffer[MAXHOSTNAMELEN];\n-  if (gethostname (buffer, MAXHOSTNAMELEN))\n-    return NULL;\n-  chars = buffer;\n-#elif HAVE_UNAME\n-  struct utsname stuff;\n-  if (uname (&stuff) != 0)\n-    return NULL;\n-  chars = stuff.nodename;\n-#else\n-  return NULL;\n-#endif\n-  // It is admittedly non-optimal to convert the hostname to Unicode\n-  // only to convert it back in getByName, but simplicity wins.  Note\n-  // that unless there is a SecurityManager, we only get called once\n-  // anyway, thanks to the InetAddress.localhost cache.\n-  return JvNewStringUTF (chars);\n-}\n-\n-#endif /* DISABLE_JAVA_NET */"}, {"sha": "65bcf16a2c5c811c94c3cb00fb11e18fb8df0ab6", "filename": "libjava/java/net/natNetworkInterface.cc", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatNetworkInterface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatNetworkInterface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatNetworkInterface.cc?ref=9b5f18b179d4fe726cc95a2658af0757eb66e41c", "patch": "@@ -1,144 +0,0 @@\n-// natNetworkInterface.cc\n-\n-/* Copyright (C) 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n-#undef STRICT\n-\n-#else /* WIN32 */\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <string.h>\n-#include <errno.h>\n-#include <stdlib.h>\n-\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-#ifdef HAVE_SYS_IOCTL_H\n-#define BSD_COMP /* Get FIONREAD on Solaris2. */\n-#include <sys/ioctl.h>\n-#endif\n-#ifdef HAVE_NET_IF_H\n-#include <net/if.h>\n-#endif\n-\n-#endif /* WIN32 */\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/net/NetworkInterface.h>\n-#include <java/net/Inet4Address.h>\n-#include <java/net/SocketException.h>\n-#include <java/util/Vector.h>\n-\n-#ifdef DISABLE_JAVA_NET\n-\n-::java::util::Vector*\n-java::net::NetworkInterface::getRealNetworkInterfaces ()\n-{\n-  ::java::util::Vector* ht = new ::java::util::Vector();\n-  return ht;\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n-::java::util::Vector*\n-java::net::NetworkInterface::getRealNetworkInterfaces ()\n-{\n-#ifdef WIN32\n-  throw new ::java::net::SocketException;\n-#else\n-  int fd;\n-  int num_interfaces = 0;\n-  struct ifconf if_data;\n-  struct ifreq* if_record;\n-  ::java::util::Vector* ht = new ::java::util::Vector ();\n-\n-  if_data.ifc_len = 0;\n-  if_data.ifc_buf = NULL;\n-\n-  // Open a (random) socket to have a file descriptor for the ioctl calls.\n-  fd = _Jv_socket (PF_INET, SOCK_DGRAM, htons (IPPROTO_IP));\n-\n-  if (fd < 0)\n-    throw new ::java::net::SocketException;\n-\n-  // Get all interfaces. If not enough buffers are available try it\n-  // with a bigger buffer size.\n-  do\n-    {\n-      num_interfaces += 16;\n-      \n-      if_data.ifc_len = sizeof (struct ifreq) * num_interfaces;\n-      if_data.ifc_buf =\n-        (char*) _Jv_Realloc (if_data.ifc_buf, if_data.ifc_len);\n-\n-      // Try to get all local interfaces.\n-      if (::ioctl (fd, SIOCGIFCONF, &if_data) < 0)\n-        throw new java::net::SocketException;\n-    }\n-  while (if_data.ifc_len >= (sizeof (struct ifreq) * num_interfaces));\n-\n-  // Get addresses of all interfaces.\n-  if_record = if_data.ifc_req;\n-\n-  for (int n = 0; n < if_data.ifc_len; n += sizeof (struct ifreq))\n-    {\n-      struct ifreq ifr;\n-      \n-      memset (&ifr, 0, sizeof (ifr));\n-      strcpy (ifr.ifr_name, if_record->ifr_name);\n-\n-      // Try to get the IPv4-address of the local interface\n-      if (::ioctl (fd, SIOCGIFADDR, &ifr) < 0)\n-        throw new java::net::SocketException;\n-\n-      int len = 4;\n-      struct sockaddr_in sa = *((sockaddr_in*) &(ifr.ifr_addr));\n-\n-      jbyteArray baddr = JvNewByteArray (len);\n-      memcpy (elements (baddr), &(sa.sin_addr), len);\n-      jstring if_name = JvNewStringLatin1 (if_record->ifr_name);\n-      Inet4Address* address =\n-        new java::net::Inet4Address (baddr, JvNewStringLatin1 (\"\"));\n-      ht->add (new NetworkInterface (if_name, address));\n-      if_record++;\n-    }\n-\n-#ifdef HAVE_INET6\n-      // FIXME: read /proc/net/if_inet6 (on Linux 2.4)\n-#endif\n-\n-  _Jv_Free (if_data.ifc_buf);\n-  \n-  if (fd >= 0)\n-    _Jv_close (fd);\n-  \n-  return ht;\n-#endif /* WIN32 */\n-}\n-\n-#endif // DISABLE_JAVA_NET //"}, {"sha": "5546061c503b121599d5cce349c1fcdb42bc59ef", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "removed", "additions": 0, "deletions": 872, "changes": 872, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=9b5f18b179d4fe726cc95a2658af0757eb66e41c", "patch": "@@ -1,872 +0,0 @@\n-/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#ifdef WIN32\n-\n-#include <errno.h>\n-#include <string.h>\n-\n-#else /* WIN32 */\n-\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#include <errno.h>\n-#include <string.h>\n-\n-#endif /* WIN32 */\n-\n-#if HAVE_BSTRING_H\n-// Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2 \n-#include <bstring.h>\n-#endif\n-\n-#include <gcj/cni.h>\n-#include <java/io/IOException.h>\n-#include <java/io/InterruptedIOException.h>\n-#include <java/net/BindException.h>\n-#include <java/net/SocketException.h>\n-#include <java/net/PlainDatagramSocketImpl.h>\n-#include <java/net/InetAddress.h>\n-#include <java/net/NetworkInterface.h>\n-#include <java/net/DatagramPacket.h>\n-#include <java/net/PortUnreachableException.h>\n-#include <java/lang/InternalError.h>\n-#include <java/lang/Object.h>\n-#include <java/lang/Boolean.h>\n-#include <java/lang/Integer.h>\n-\n-#ifdef DISABLE_JAVA_NET\n-\n-void\n-java::net::PlainDatagramSocketImpl::create ()\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.create: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::bind (jint, java::net::InetAddress *)\n-{\n-  throw new BindException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.bind: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::connect (java::net::InetAddress *, jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.connect: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::disconnect ()\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.disconnect: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.peek: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.peekData: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::close ()\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.close: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.send: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.receive: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setTimeToLive (jint)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.setTimeToLive: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::getTimeToLive ()\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.getTimeToLive: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *,\n-                                              java::net::NetworkInterface *,\n-\t\t\t\t\t      jboolean)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.mcastGrp: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setOption (jint, java::lang::Object *)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.setOption: unimplemented\"));\n-}\n-\n-java::lang::Object *\n-java::net::PlainDatagramSocketImpl::getOption (jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.getOption: unimplemented\"));\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n-\n-union SockAddr\n-{\n-  struct sockaddr_in address;\n-#ifdef HAVE_INET6\n-  struct sockaddr_in6 address6;\n-#endif\n-};\n-\n-union McastReq\n-{\n-#if HAVE_STRUCT_IP_MREQ\n-  struct ip_mreq mreq;\n-#endif\n-#if HAVE_STRUCT_IPV6_MREQ\n-  struct ipv6_mreq mreq6;\n-#endif\n-};\n-\n-union InAddr\n-{\n-  struct in_addr addr;\n-#ifdef HAVE_INET6\n-  struct in6_addr addr6;\n-#endif\n-};\n-\n-\n-// FIXME: routines here and/or in natPlainSocketImpl.cc could throw\n-// NoRouteToHostException; also consider UnknownHostException, ConnectException.\n-\n-void\n-java::net::PlainDatagramSocketImpl::create ()\n-{\n-  int sock = _Jv_socket (AF_INET, SOCK_DGRAM, 0);\n-\n-  if (sock < 0)\n-    {\n-      char* strerr = strerror (errno);\n-      throw new java::net::SocketException (JvNewStringUTF (strerr));\n-    }\n-\n-  _Jv_platform_close_on_exec (sock);\n-\n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n-  // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::bind (jint lport,\n-\t\t\t\t\t  java::net::InetAddress *host)\n-{\n-  union SockAddr u;\n-  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  // FIXME: Use getaddrinfo() to get actual protocol instead of assuming ipv4.\n-  jbyteArray haddress = host->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-\n-  if (len == 4)\n-    {\n-      u.address.sin_family = AF_INET;\n-\n-      if (host != NULL)\n-        memcpy (&u.address.sin_addr, bytes, len);\n-      else\n-        u.address.sin_addr.s_addr = htonl (INADDR_ANY);\n-\n-      len = sizeof (struct sockaddr_in);\n-      u.address.sin_port = htons (lport);\n-    }\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    {\n-      u.address6.sin6_family = AF_INET6;\n-      memcpy (&u.address6.sin6_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in6);\n-      u.address6.sin6_port = htons (lport);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-  if (_Jv_bind (fnum, ptr, len) == 0)\n-    {\n-      socklen_t addrlen = sizeof(u);\n-\n-      if (lport != 0)\n-        localPort = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n-        localPort = ntohs (u.address.sin_port);\n-      else\n-        goto error;\n-\n-      /* Allow broadcast by default. */\n-      int broadcast = 1;\n-      if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast, \n-                        sizeof (broadcast)) != 0)\n-        goto error;\n-\n-      return;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::BindException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::connect (java::net::InetAddress *, jint)\n-{ \n-  throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::connect: not implemented yet\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::disconnect ()\n-{\n-  throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::disconnect: not implemented yet\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n-{\n-  // FIXME: Deal with Multicast and if the socket is connected.\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  ssize_t retlen =\n-    ::recvfrom (fnum, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n-      &addrlen);\n-  if (retlen < 0)\n-    goto error;\n-  // FIXME: Deal with Multicast addressing and if the socket is connected.\n-  jbyteArray raddr;\n-  jint rport;\n-  if (u.address.sin_family == AF_INET)\n-    {\n-      raddr = JvNewByteArray (4);\n-      memcpy (elements (raddr), &u.address.sin_addr, 4);\n-      rport = ntohs (u.address.sin_port);\n-    }\n-#ifdef HAVE_INET6\n-  else if (u.address.sin_family == AF_INET6)\n-    {\n-      raddr = JvNewByteArray (16);\n-      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n-      rport = ntohs (u.address6.sin6_port);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n-\n-  i->addr = raddr;\n-  return rport;\n- error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *p)\n-{\n-  // FIXME: Deal with Multicast and if the socket is connected.\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  jbyte *dbytes = elements (p->getData());\n-  ssize_t retlen = 0;\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException ();\n-    }\n-#endif /* WIN32 */\n-\n-  retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n-      &addrlen);\n-  if (retlen < 0)\n-    goto error;\n-  // FIXME: Deal with Multicast addressing and if the socket is connected.\n-  jbyteArray raddr;\n-  jint rport;\n-  if (u.address.sin_family == AF_INET)\n-    {\n-      raddr = JvNewByteArray (4);\n-      memcpy (elements (raddr), &u.address.sin_addr, 4);\n-      rport = ntohs (u.address.sin_port);\n-    }\n-#ifdef HAVE_INET6\n-  else if (u.address.sin_family == AF_INET6)\n-    {\n-      raddr = JvNewByteArray (16);\n-      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n-      rport = ntohs (u.address6.sin6_port);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n-\n-  p->setAddress (new InetAddress (raddr, NULL));\n-  p->setPort (rport);\n-  p->setLength ((jint) retlen);\n-  return rport;\n-\n- error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-// Close(shutdown) the socket.\n-void\n-java::net::PlainDatagramSocketImpl::close ()\n-{\n-  // Avoid races from asynchronous finalization.\n-  JvSynchronize sync (this);\n-\n-  // The method isn't declared to throw anything, so we disregard\n-  // the return value.\n-  _Jv_close (fnum);\n-  fnum = -1;\n-  timeout = 0;\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *p)\n-{\n-  // FIXME: Deal with Multicast and if the socket is connected.\n-  jint rport = p->getPort();\n-  union SockAddr u;\n-  jbyteArray haddress = p->getAddress()->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  jbyte *dbytes = elements (p->getData());\n-  if (len == 4)\n-    {\n-      u.address.sin_family = AF_INET;\n-      memcpy (&u.address.sin_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in);\n-      u.address.sin_port = htons (rport);\n-    }\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    {\n-      u.address6.sin6_family = AF_INET6;\n-      memcpy (&u.address6.sin6_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in6);\n-      u.address6.sin6_port = htons (rport);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-  if (::sendto (fnum, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n-    return;\n-\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n-{\n-  // FIXME: Deal with Multicast and if the socket is connected.\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  jbyte *dbytes = elements (p->getData());\n-  ssize_t retlen = 0;\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException ();\n-    }\n-#endif /* WIN32 */\n-\n-  retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n-      &addrlen);\n-  if (retlen < 0)\n-    goto error;\n-  // FIXME: Deal with Multicast addressing and if the socket is connected.\n-  jbyteArray raddr;\n-  jint rport;\n-  if (u.address.sin_family == AF_INET)\n-    {\n-      raddr = JvNewByteArray (4);\n-      memcpy (elements (raddr), &u.address.sin_addr, 4);\n-      rport = ntohs (u.address.sin_port);\n-    }\n-#ifdef HAVE_INET6\n-  else if (u.address.sin_family == AF_INET6)\n-    {\n-      raddr = JvNewByteArray (16);\n-      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n-      rport = ntohs (u.address6.sin6_port);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n-\n-  p->setAddress (new InetAddress (raddr, NULL));\n-  p->setPort (rport);\n-  p->setLength ((jint) retlen);\n-  return;\n-\n- error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n-{\n-  // Assumes IPPROTO_IP rather than IPPROTO_IPV6 since socket created is IPv4.\n-  char val = (char) ttl;\n-  socklen_t val_len = sizeof(val);\n-\n-  if (::setsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n-    return;\n-\n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::getTimeToLive ()\n-{\n-  // Assumes IPPROTO_IP rather than IPPROTO_IPV6 since socket created is IPv4.\n-  char val;\n-  socklen_t val_len = sizeof(val);\n-\n-  if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n-    return ((int) val) & 0xFF;\n-\n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n-                                              java::net::NetworkInterface *,\n-\t\t\t\t\t      jboolean join)\n-{\n-  // FIXME: implement use of NetworkInterface\n-\n-  union McastReq u;\n-  jbyteArray haddress = inetaddr->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-  int level, opname;\n-  const char *ptr;\n-  if (0)\n-    ;\n-#if HAVE_STRUCT_IP_MREQ\n-  else if (len == 4)\n-    {\n-      level = IPPROTO_IP;\n-      opname = join ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;\n-      memcpy (&u.mreq.imr_multiaddr, bytes, len);\n-      // FIXME:  If a non-default interface is set, use it; see Stevens p. 501.\n-      // Maybe not, see note in last paragraph at bottom of Stevens p. 497.\n-      u.mreq.imr_interface.s_addr = htonl (INADDR_ANY); \n-      len = sizeof (struct ip_mreq);\n-      ptr = (const char *) &u.mreq;\n-    }\n-#endif\n-#if HAVE_STRUCT_IPV6_MREQ\n-  else if (len == 16)\n-    {\n-      level = IPPROTO_IPV6;\n-\n-      /* Prefer new RFC 2553 names.  */\n-#ifndef IPV6_JOIN_GROUP\n-#define IPV6_JOIN_GROUP IPV6_ADD_MEMBERSHIP\n-#endif\n-#ifndef IPV6_LEAVE_GROUP\n-#define IPV6_LEAVE_GROUP IPV6_DROP_MEMBERSHIP\n-#endif\n-\n-      opname = join ? IPV6_JOIN_GROUP : IPV6_LEAVE_GROUP;\n-      memcpy (&u.mreq6.ipv6mr_multiaddr, bytes, len);\n-      // FIXME:  If a non-default interface is set, use it; see Stevens p. 501.\n-      // Maybe not, see note in last paragraph at bottom of Stevens p. 497.\n-      u.mreq6.ipv6mr_interface = 0;\n-      len = sizeof (struct ipv6_mreq);\n-      ptr = (const char *) &u.mreq6;\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-  if (::setsockopt (fnum, level, opname, ptr, len) == 0)\n-    return;\n-\n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setOption (jint optID,\n-\t\t\t\t\t       java::lang::Object *value)\n-{\n-  int val;\n-  socklen_t val_len = sizeof (val);\n-\n-  if (fnum < 0)\n-    throw new java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n-\n-  if (_Jv_IsInstanceOf (value, &java::lang::Boolean::class$))\n-    {\n-      java::lang::Boolean *boolobj = \n-        static_cast<java::lang::Boolean *> (value);\n-      val = boolobj->booleanValue() ? 1 : 0;\n-    }\n-  else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n-    {\n-      java::lang::Integer *intobj = \n-        static_cast<java::lang::Integer *> (value);          \n-      val = (int) intobj->intValue();\n-    }\n-  // Else assume value to be an InetAddress for use with IP_MULTICAST_IF.\n-\n-  switch (optID) \n-    {\n-      case _Jv_TCP_NODELAY_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"TCP_NODELAY not valid for UDP\"));\n-        return;\n-      case _Jv_SO_LINGER_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_LINGER not valid for UDP\"));\n-        return;\n-      case _Jv_SO_KEEPALIVE_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n-        return;\n-\n-      case _Jv_SO_BROADCAST_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-                          val_len) != 0)\n-          goto error;\n-\tbreak;\n-\t\n-      case _Jv_SO_OOBINLINE_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_OOBINLINE: not valid for UDP\"));\n-        break;\n-\t\n-      case _Jv_SO_SNDBUF_ :\n-      case _Jv_SO_RCVBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n-        int opt;\n-        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n-\t  goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif \n-        return;\n-      case _Jv_SO_REUSEADDR_ :\n-#if defined(SO_REUSEADDR)\n-\tif (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n-\t    val_len) != 0)\n-\t  goto error;\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_REUSEADDR not supported\"));\n-#endif \n-\treturn;\n-      case _Jv_SO_BINDADDR_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_BINDADDR: read only option\"));\n-        return;\n-      case _Jv_IP_MULTICAST_IF_ :\n-\tunion InAddr u;\n-        jbyteArray haddress;\n-\tjbyte *bytes;\n-\tint len;\n-\tint level, opname;\n-\tconst char *ptr;\n-\n-\thaddress = ((java::net::InetAddress *) value)->addr;\n-\tbytes = elements (haddress);\n-\tlen = haddress->length;\n-\tif (len == 4)\n-\t  {\n-\t    level = IPPROTO_IP;\n-\t    opname = IP_MULTICAST_IF;\n-\t    memcpy (&u.addr, bytes, len);\n-\t    len = sizeof (struct in_addr);\n-\t    ptr = (const char *) &u.addr;\n-\t  }\n-// Tru64 UNIX V5.0 has struct sockaddr_in6, but no IPV6_MULTICAST_IF\n-#if defined (HAVE_INET6) && defined (IPV6_MULTICAST_IF)\n-\telse if (len == 16)\n-\t  {\n-\t    level = IPPROTO_IPV6;\n-\t    opname = IPV6_MULTICAST_IF;\n-\t    memcpy (&u.addr6, bytes, len);\n-\t    len = sizeof (struct in6_addr);\n-\t    ptr = (const char *) &u.addr6;\n-\t  }\n-#endif\n-\telse\n-\t  throw\n-\t    new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-\tif (::setsockopt (fnum, level, opname, ptr, len) != 0)\n-\t  goto error;\n-        return;\n-\t\n-      case _Jv_IP_MULTICAST_IF2_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n-        break;\n-\t\n-      case _Jv_IP_MULTICAST_LOOP_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_LOOP: not yet implemented\"));\n-        break;\n-\t\n-      case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-\t   val_len) != 0)\n-\t  goto error;    \n-\treturn;\n-\t\n-      case _Jv_SO_TIMEOUT_ :\n-\ttimeout = val;\n-        return;\n-      default :\n-        errno = ENOPROTOOPT;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n-}\n-\n-java::lang::Object *\n-java::net::PlainDatagramSocketImpl::getOption (jint optID)\n-{\n-  int val;\n-  socklen_t val_len = sizeof(val);\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-\n-  switch (optID)\n-    {\n-      case _Jv_TCP_NODELAY_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"TCP_NODELAY not valid for UDP\"));\n-        break;\n-      case _Jv_SO_LINGER_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_LINGER not valid for UDP\"));\n-        break;    \n-      case _Jv_SO_KEEPALIVE_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n-        break;\n-\t\n-      case _Jv_SO_BROADCAST_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-\t\n-      case _Jv_SO_OOBINLINE_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_OOBINLINE not valid for UDP\"));\n-        break;\n-      \n-      case _Jv_SO_RCVBUF_ :\n-      case _Jv_SO_SNDBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n-        int opt;\n-        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n-\t  goto error;    \n-        else\n-\t  return new java::lang::Integer (val);\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif    \n-\tbreak;\n-      case _Jv_SO_BINDADDR_:\n-\t// cache the local address\n-\tif (localAddress == NULL)\n-\t  {\t\n-\t    jbyteArray laddr;\n-\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-\t      goto error;\n-\t    if (u.address.sin_family == AF_INET)\n-\t      {\n-\t\tladdr = JvNewByteArray (4);\n-\t\tmemcpy (elements (laddr), &u.address.sin_addr, 4);\n-\t      }\n-#ifdef HAVE_INET6\n-            else if (u.address.sin_family == AF_INET6)\n-\t      {\n-\t\tladdr = JvNewByteArray (16);\n-\t\tmemcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-\t      }\n-#endif\n-\t    else\n-\t      throw new java::net::SocketException (\n-\t\t\t      JvNewStringUTF (\"invalid family\"));\n-\t    localAddress = new java::net::InetAddress (laddr, NULL);\n-\t  }\n-\treturn localAddress;  \n-\tbreak;\n-      case _Jv_SO_REUSEADDR_ :\n-#if defined(SO_REUSEADDR)\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_REUSEADDR not supported\"));\n-#endif \n-\tbreak;\n-      case _Jv_IP_MULTICAST_IF_ :\n-#ifdef HAVE_INET_NTOA\n-\tstruct in_addr inaddr;\n-  \tsocklen_t inaddr_len;\n-\tchar *bytes;\n-\n-  \tinaddr_len = sizeof(inaddr);\n-\tif (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n-\t    &inaddr_len) != 0)\n-\t  goto error;\n-\n-\tbytes = inet_ntoa (inaddr);\n-\n-\treturn java::net::InetAddress::getByName (JvNewStringLatin1 (bytes));\n-#else\n-\tthrow new java::net::SocketException (\n-\t  JvNewStringUTF (\"IP_MULTICAST_IF: not available - no inet_ntoa()\"));\n-#endif\n-\tbreak;\n-      case _Jv_SO_TIMEOUT_ :\n-\treturn new java::lang::Integer (timeout);\n-\tbreak;\n-\t\n-      case _Jv_IP_MULTICAST_IF2_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n-        break;\n-\t\n-      case _Jv_IP_MULTICAST_LOOP_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-\t\n-      case _Jv_IP_TOS_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-           &val_len) != 0)\n-          goto error;\n-        return new java::lang::Integer (val);\n-\t\n-      default :\n-\terrno = ENOPROTOOPT;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n-}\n-\n-#endif /* DISABLE_JAVA_NET */"}, {"sha": "114c2102ac54399f0a9359ed979892b29aef602c", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "removed", "additions": 0, "deletions": 1019, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5f18b179d4fe726cc95a2658af0757eb66e41c/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=9b5f18b179d4fe726cc95a2658af0757eb66e41c", "patch": "@@ -1,1019 +0,0 @@\n-/* Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#ifndef DISABLE_JAVA_NET\n-\n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n-#include <errno.h>\n-#include <string.h>\n-#undef STRICT\n-#undef MAX_PRIORITY\n-#undef MIN_PRIORITY\n-#undef FIONREAD\n-\n-// These functions make the Win32 socket API look more POSIXy\n-static inline int\n-write(int s, void *buf, int len)\n-{\n-  return send(s, (char*)buf, len, 0);\n-}\n-\n-static inline int\n-read(int s, void *buf, int len)\n-{\n-  return recv(s, (char*)buf, len, 0);\n-}\n-\n-// these errors cannot occur on Win32\n-#else /* WIN32 */\n-\n-#ifdef HAVE_SYS_IOCTL_H\n-#define BSD_COMP /* Get FIONREAD on Solaris2. */\n-#include <sys/ioctl.h>\n-#endif\n-\n-// Pick up FIONREAD on Solaris 2.5.\n-#ifdef HAVE_SYS_FILIO_H\n-#include <sys/filio.h>\n-#endif\n-\n-#include <netinet/in.h>\n-#include <netinet/tcp.h>\n-#include <errno.h>\n-#include <string.h>\n-\n-#endif /* WIN32 */\n-#endif /* DISABLE_JAVA_NET */\n-\n-#if HAVE_BSTRING_H\n-// Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2 \n-#include <bstring.h>\n-#endif\n-\n-\n-#include <gcj/cni.h>\n-#include <gcj/javaprims.h>\n-#include <java/io/IOException.h>\n-#include <java/io/InterruptedIOException.h>\n-#include <java/net/BindException.h>\n-#include <java/net/ConnectException.h>\n-#include <java/net/PlainSocketImpl.h>\n-#include <java/net/InetAddress.h>\n-#include <java/net/InetSocketAddress.h>\n-#include <java/net/SocketException.h>\n-#include <java/net/SocketTimeoutException.h>\n-#include <java/lang/InternalError.h>\n-#include <java/lang/Object.h>\n-#include <java/lang/Boolean.h>\n-#include <java/lang/Class.h>\n-#include <java/lang/Integer.h>\n-#include <java/lang/Thread.h>\n-#include <java/lang/NullPointerException.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-#include <java/lang/IllegalArgumentException.h>\n-\n-#ifdef DISABLE_JAVA_NET\n-\n-void\n-java::net::PlainSocketImpl::create (jboolean)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.create: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::bind (java::net::InetAddress *, jint)\n-{\n-  throw new BindException (\n-    JvNewStringLatin1 (\"SocketImpl.bind: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::connect (java::net::SocketAddress *, jint)\n-{\n-  throw new ConnectException (\n-    JvNewStringLatin1 (\"SocketImpl.connect: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::listen (jint)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.listen: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.accept: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::setOption (jint, java::lang::Object *)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.setOption: unimplemented\"));\n-}\n-\n-java::lang::Object *\n-java::net::PlainSocketImpl::getOption (jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.getOption: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::read(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::write(jint b)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::sendUrgentData(jint data)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.sendUrgentData: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::available(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.available: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::close(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.close: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownInput (void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.shutdownInput: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownOutput (void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.shutdownOutput: unimplemented\"));\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n-union SockAddr\n-{\n-  struct sockaddr_in address;\n-#ifdef HAVE_INET6\n-  struct sockaddr_in6 address6;\n-#endif\n-};\n-\n-void\n-java::net::PlainSocketImpl::create (jboolean stream)\n-{\n-  int sock = _Jv_socket (AF_INET, stream ? SOCK_STREAM : SOCK_DGRAM, 0);\n-\n-  if (sock < 0)\n-    {\n-      char* strerr = strerror (errno);\n-      throw new java::io::IOException (JvNewStringUTF (strerr));\n-    }\n-\n-  _Jv_platform_close_on_exec (sock);\n-\n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n-  // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n-}\n-\n-void\n-java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n-{\n-  union SockAddr u;\n-  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  jbyteArray haddress = host->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-  int i = 1;\n-\n-  if (len == 4)\n-    {\n-      u.address.sin_family = AF_INET;\n-\n-      if (host != NULL)\n-        memcpy (&u.address.sin_addr, bytes, len);\n-      else\n-        u.address.sin_addr.s_addr = htonl (INADDR_ANY);\n-\n-      len = sizeof (struct sockaddr_in);\n-      u.address.sin_port = htons (lport);\n-    }\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    {\n-      u.address6.sin6_family = AF_INET6;\n-      memcpy (&u.address6.sin6_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in6);\n-      u.address6.sin6_port = htons (lport);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-  // Enable SO_REUSEADDR, so that servers can reuse ports left in TIME_WAIT.\n-  ::setsockopt(fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n-  \n-  if (_Jv_bind (fnum, ptr, len) == 0)\n-    {\n-      address = host;\n-      socklen_t addrlen = sizeof(u);\n-\n-      if (lport != 0)\n-        localport = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n-        localport = ntohs (u.address.sin_port);\n-      else\n-        goto error;\n-\n-      return;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::BindException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n-                                     jint timeout)\n-{\n-  java::net::InetSocketAddress *tmp = (java::net::InetSocketAddress*) addr;\n-  java::net::InetAddress *host = tmp->getAddress();\n-  jint rport = tmp->getPort();\n-\t\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  jbyteArray haddress = host->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  if (len == 4)\n-    {\n-      u.address.sin_family = AF_INET;\n-      memcpy (&u.address.sin_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in);\n-      u.address.sin_port = htons (rport);\n-    }\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n-    {\n-      u.address6.sin6_family = AF_INET6;\n-      memcpy (&u.address6.sin6_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in6);\n-      u.address6.sin6_port = htons (rport);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  if (timeout > 0)\n-    {\n-      int flags = ::fcntl (fnum, F_GETFL);\n-      ::fcntl (fnum, F_SETFL, flags | O_NONBLOCK);\n-      \n-      if ((_Jv_connect (fnum, ptr, len) != 0) && (errno != EINPROGRESS))\n-        goto error;\n-\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      \n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::net::SocketTimeoutException\n-          (JvNewStringUTF (\"Connect timed out\"));\n-    }\n-  else\n-#endif\n-    {\n-      if (_Jv_connect (fnum, ptr, len) != 0)\n-        goto error;\n-    }\n-\n-  address = host;\n-  port = rport;\n-\n-  // A bind may not have been done on this socket; if so, set localport now.\n-  if (localport == 0)\n-    {\n-      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n-        localport = ntohs (u.address.sin_port);\n-      else\n-        goto error;\n-    }\n-\n-  return;  \n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::ConnectException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainSocketImpl::listen (jint backlog)\n-{\n-  if (::listen (fnum, backlog) != 0)\n-    {\n-      char* strerr = strerror (errno);\n-      throw new java::io::IOException (JvNewStringUTF (strerr));\n-    }\n-}\n-\n-void\n-java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n-{\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  int new_socket = 0; \n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException (\n-\t                                  JvNewStringUTF(\"Accept timed out\"));\n-    }\n-#endif /* WIN32 */\n-\n-  new_socket = _Jv_accept (fnum, (sockaddr*) &u, &addrlen);\n-\n-  if (new_socket < 0)\n-    goto error;\n-\n-  _Jv_platform_close_on_exec (new_socket);\n-\n-  jbyteArray raddr;\n-  jint rport;\n-  if (u.address.sin_family == AF_INET)\n-    {\n-      raddr = JvNewByteArray (4);\n-      memcpy (elements (raddr), &u.address.sin_addr, 4);\n-      rport = ntohs (u.address.sin_port);\n-    }\n-#ifdef HAVE_INET6\n-  else if (u.address.sin_family == AF_INET6)\n-    {\n-      raddr = JvNewByteArray (16);\n-      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n-      rport = ntohs (u.address6.sin6_port);\n-    }\n-#endif\n-  else\n-    throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n-\n-  s->fnum = new_socket;\n-  s->localport = localport;\n-  s->address = new InetAddress (raddr, NULL);\n-  s->port = rport;\n-  return;\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n-}\n-\n-// Close(shutdown) the socket.\n-void\n-java::net::PlainSocketImpl::close()\n-{\n-  // Avoid races from asynchronous finalization.\n-  JvSynchronize sync (this);\n-\n-  // should we use shutdown here? how would that effect so_linger?\n-  int res = _Jv_close (fnum);\n-\n-  if (res == -1)\n-    {\n-      // These three errors are not errors according to tests performed\n-      // on the reference implementation.\n-      if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-        throw new java::io::IOException  (JvNewStringUTF (strerror (errno)));\n-    }\n-  // Safe place to reset the file pointer.\n-  fnum = -1;\n-  timeout = 0;\n-}\n-\n-// Write a byte to the socket.\n-void\n-java::net::PlainSocketImpl::write(jint b)\n-{\n-  jbyte d =(jbyte) b;\n-  int r = 0;\n-\n-  while (r != 1)\n-    {\n-      r = _Jv_write (fnum, &d, 1);\n-      if (r == -1)\n-        {\n-          if (java::lang::Thread::interrupted())\n-            {\n-              java::io::InterruptedIOException *iioe\n-                = new java::io::InterruptedIOException \n-                (JvNewStringLatin1 (strerror (errno)));\n-              iioe->bytesTransferred = 0;\n-              throw iioe;\n-            }\n-          // Some errors should not cause exceptions.\n-          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-          break;\n-        }\n-    }\n-}\n-\n-// Write some bytes to the socket.\n-void\n-java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n-{\n-  if (! b)\n-    throw new java::lang::NullPointerException;\n-  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-\n-  jbyte *bytes = elements (b) + offset;\n-  int written = 0;\n-\n-  while (len > 0)\n-    {\n-      int r = _Jv_write (fnum, bytes, len);\n-\n-      if (r == -1)\n-        {\n-          if (java::lang::Thread::interrupted())\n-            {\n-              java::io::InterruptedIOException *iioe\n-                = new java::io::InterruptedIOException\n-                (JvNewStringLatin1 (strerror (errno)));\n-              iioe->bytesTransferred = written;\n-              throw iioe;\n-            }\n-          // Some errors should not cause exceptions.\n-          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-          break;\n-        }\n-\n-      written += r;\n-      len -= r;\n-      bytes += r;\n-    }\n-}\n-\n-void\n-java::net::PlainSocketImpl::sendUrgentData (jint)\n-{\n-  throw new SocketException (JvNewStringLatin1 (\n-    \"PlainSocketImpl: sending of urgent data not supported by this socket\"));\n-}\n-\n-// Read a single byte from the socket.\n-jint\n-java::net::PlainSocketImpl::read(void)\n-{\n-  jbyte b;\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      // Create the file descriptor set.\n-      fd_set read_fds;\n-      FD_ZERO (&read_fds);\n-      FD_SET (fnum,&read_fds);\n-      // Create the timeout struct based on our internal timeout value.\n-      struct timeval timeout_value;\n-      timeout_value.tv_sec = timeout / 1000;\n-      timeout_value.tv_usec = (timeout % 1000) * 1000;\n-      // Select on the fds.\n-      int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-      // If select returns 0 we've waited without getting data...\n-      // that means we've timed out.\n-      if (sel_retval == 0)\n-        throw new java::io::InterruptedIOException\n-          (JvNewStringUTF (\"read timed out\") );\n-      // If select returns ok we know we either got signalled or read some data...\n-      // either way we need to try to read.\n-    }\n-#endif /* WIN32 */\n-\n-  int r = _Jv_read (fnum, &b, 1);\n-\n-  if (r == 0)\n-    return -1;\n-\n-  if (java::lang::Thread::interrupted())\n-    {\n-      java::io::InterruptedIOException *iioe =\n-        new java::io::InterruptedIOException\n-        (JvNewStringUTF(\"read interrupted\"));\n-      iioe->bytesTransferred = r == -1 ? 0 : r;\n-      throw iioe;\n-    }\n-  else if (r == -1)\n-    {\n-      // Some errors cause us to return end of stream...\n-      if (errno == ENOTCONN)\n-        return -1;\n-\n-      // Other errors need to be signalled.\n-      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-    }\n-\n-  return b & 0xFF;\n-}\n-\n-// Read count bytes into the buffer, starting at offset.\n-jint\n-java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n-{\n-  if (! buffer)\n-    throw new java::lang::NullPointerException;\n-\n-  jsize bsize = JvGetArrayLength (buffer);\n-\n-  if (offset < 0 || count < 0 || offset + count > bsize)\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-\n-  jbyte *bytes = elements (buffer) + offset;\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      // Create the file descriptor set.\n-      fd_set read_fds;\n-      FD_ZERO (&read_fds);\n-      FD_SET (fnum, &read_fds);\n-      // Create the timeout struct based on our internal timeout value.\n-      struct timeval timeout_value;\n-      timeout_value.tv_sec = timeout / 1000;\n-      timeout_value.tv_usec =(timeout % 1000) * 1000;\n-      // Select on the fds.\n-      int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-      // We're only interested in the 0 return.\n-      // error returns still require us to try to read \n-      // the socket to see what happened.\n-      if (sel_retval == 0)\n-        {\n-          java::io::InterruptedIOException *iioe =\n-            new java::io::InterruptedIOException\n-            (JvNewStringUTF (\"read interrupted\"));\n-          iioe->bytesTransferred = 0;\n-          throw iioe;\n-        }\n-    }\n-#endif\n-\n-  // Read the socket.\n-  int r = ::recv (fnum, (char *) bytes, count, 0);\n-\n-  if (r == 0)\n-    return -1;\n-\n-  if (java::lang::Thread::interrupted())\n-    {\n-      java::io::InterruptedIOException *iioe =\n-        new java::io::InterruptedIOException\n-        (JvNewStringUTF (\"read interrupted\"));\n-      iioe->bytesTransferred = r == -1 ? 0 : r;\n-      throw iioe;\n-    }\n-  else if (r == -1)\n-    {\n-      // Some errors cause us to return end of stream...\n-      if (errno == ENOTCONN)\n-        return -1;\n-\n-      // Other errors need to be signalled.\n-      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-    }\n-\n-  return r;\n-}\n-\n-// How many bytes are available?\n-jint\n-java::net::PlainSocketImpl::available(void)\n-{\n-#if defined(FIONREAD) || defined(HAVE_SELECT)\n-  long num = 0;\n-  int r = 0;\n-  bool num_set = false;\n-\n-#if defined(FIONREAD)\n-  r = ::ioctl (fnum, FIONREAD, &num);\n-\n-  if (r == -1 && errno == ENOTTY)\n-    {\n-      // If the ioctl doesn't work, we don't care.\n-      r = 0;\n-      num = 0;\n-    }\n-  else\n-    num_set = true;\n-#elif defined(HAVE_SELECT)\n-  if (fnum < 0)\n-    {\n-      errno = EBADF;\n-      r = -1;\n-    }\n-#endif\n-\n-  if (r == -1)\n-    {\n-    posix_error:\n-      throw new java::io::IOException(JvNewStringUTF(strerror(errno)));\n-    }\n-\n-  // If we didn't get anything we can use select.\n-\n-#if defined(HAVE_SELECT)\n-  if (! num_set)\n-    if (! num_set && fnum >= 0 && fnum < FD_SETSIZE)\n-      {\n-        fd_set rd;\n-        FD_ZERO (&rd);\n-        FD_SET (fnum, &rd);\n-        struct timeval tv;\n-        tv.tv_sec = 0;\n-        tv.tv_usec = 0;\n-        r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n-        if(r == -1)\n-          goto posix_error;\n-        num = r == 0 ? 0 : 1;\n-      }\n-#endif /* HAVE_SELECT */\n-\n-  return (jint) num;\n-#else\n-  throw new java::io::IOException (JvNewStringUTF (\"unimplemented\"));\n-#endif\n-}\n-\n-void\n-java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n-{\n-  int val;\n-  socklen_t val_len = sizeof (val);\n-\n-  if (fnum < 0)\n-    throw new java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n-\n-  if (_Jv_IsInstanceOf (value, &java::lang::Boolean::class$))\n-    {\n-      java::lang::Boolean *boolobj = \n-        static_cast<java::lang::Boolean *> (value);\n-      if (boolobj->booleanValue())\n-        val = 1; \n-      else \n-        {\n-          if (optID == _Jv_SO_LINGER_)\n-            val = -1;\n-          else\n-            val = 0;\n-        }\n-    }\n-  else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n-    {\n-      java::lang::Integer *intobj = \n-        static_cast<java::lang::Integer *> (value);          \n-      val = (int) intobj->intValue();\n-    }\n-  else\n-    {\n-      throw new java::lang::IllegalArgumentException (\n-        JvNewStringLatin1 (\"`value' must be Boolean or Integer\"));\n-    }\n-\n-  switch (optID) \n-    {\n-      case _Jv_TCP_NODELAY_ :\n-#ifdef TCP_NODELAY\n-        if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-                          val_len) != 0)\n-          goto error;\n-#else\n-        throw new java::lang::InternalError\n-          (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n-#endif /* TCP_NODELAY */\n-        return;\n-\n-      case _Jv_SO_KEEPALIVE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-                          val_len) != 0)\n-          goto error;\n-        break;\n-      \n-      case _Jv_SO_BROADCAST_ :\n-        throw new java::net::SocketException\n-          (JvNewStringUTF (\"SO_BROADCAST not valid for TCP\"));\n-        break;\n-\t\n-      case _Jv_SO_OOBINLINE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-                          val_len) != 0)\n-          goto error;\n-        break;\n-\n-      case _Jv_SO_LINGER_ :\n-#ifdef SO_LINGER\n-        struct linger l_val;\n-        l_val.l_onoff = (val != -1);\n-        l_val.l_linger = val;\n-\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-                          sizeof(l_val)) != 0)\n-          goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_LINGER not supported\"));\n-#endif /* SO_LINGER */\n-        return;\n-\n-      case _Jv_SO_SNDBUF_ :\n-      case _Jv_SO_RCVBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n-        int opt;\n-        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n-          goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif \n-        return;\n-\n-      case _Jv_SO_BINDADDR_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_BINDADDR: read only option\"));\n-        return;\n-\n-      case _Jv_IP_MULTICAST_IF_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n-        return;\n-\t\n-      case _Jv_IP_MULTICAST_IF2_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n-        break;\n-\t\n-      case _Jv_IP_MULTICAST_LOOP_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n-        break;\n-\t\n-      case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-                          val_len) != 0)\n-          goto error;    \n-        break;\n-\t\n-      case _Jv_SO_REUSEADDR_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n-        return;\n-\n-      case _Jv_SO_TIMEOUT_ :\n-        timeout = val;\n-        return;\n-\n-      default :\n-        errno = ENOPROTOOPT;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n-}\n-\n-java::lang::Object *\n-java::net::PlainSocketImpl::getOption (jint optID)\n-{\n-  int val;\n-  socklen_t val_len = sizeof(val);\n-  union SockAddr u;\n-  socklen_t addrlen = sizeof(u);\n-  struct linger l_val;\n-  socklen_t l_val_len = sizeof(l_val);\n-\n-  switch (optID)\n-    {\n-#ifdef TCP_NODELAY\n-    case _Jv_TCP_NODELAY_ :\n-      if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;\n-      else\n-        return new java::lang::Boolean (val != 0);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n-#endif       \n-      break;\n-      \n-    case _Jv_SO_LINGER_ :\n-#ifdef SO_LINGER\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-                        &l_val_len) != 0)\n-        goto error;    \n- \n-      if (l_val.l_onoff)\n-        return new java::lang::Integer (l_val.l_linger);\n-      else\n-        return new java::lang::Boolean ((jboolean)false);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"SO_LINGER not supported\"));\n-#endif\n-      break;    \n-\n-    case _Jv_SO_KEEPALIVE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;\n-      else\n-        return new java::lang::Boolean (val != 0);\n-\n-    case _Jv_SO_BROADCAST_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;    \n-      return new java::lang::Boolean ((jboolean)val);\n-\t\n-    case _Jv_SO_OOBINLINE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;    \n-      return new java::lang::Boolean ((jboolean)val);\n-\t\n-    case _Jv_SO_RCVBUF_ :\n-    case _Jv_SO_SNDBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n-      int opt;\n-      optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n-        goto error;    \n-      else\n-        return new java::lang::Integer (val);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif    \n-      break;\n-    case _Jv_SO_BINDADDR_:\n-      // cache the local address \n-      if (localAddress == NULL)\n-        {\n-          jbyteArray laddr;\n-\n-          if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-            goto error;\n-\n-          if (u.address.sin_family == AF_INET)\n-            {\n-              laddr = JvNewByteArray (4);\n-              memcpy (elements (laddr), &u.address.sin_addr, 4);\n-            }\n-#ifdef HAVE_INET6\n-          else if (u.address.sin_family == AF_INET6)\n-            {\n-              laddr = JvNewByteArray (16);\n-              memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-            }\n-#endif\n-          else\n-            throw new java::net::SocketException\n-              (JvNewStringUTF (\"invalid family\"));\n-          localAddress = new java::net::InetAddress (laddr, NULL);\n-        }\n-\n-      return localAddress;\n-      break;\n-    case _Jv_IP_MULTICAST_IF_ :\n-      throw new java::net::SocketException\n-        (JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n-      break;\n-\t\n-    case _Jv_IP_MULTICAST_IF2_ :\n-      throw new java::net::SocketException\n-        (JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n-      break;\n-\t\n-    case _Jv_IP_MULTICAST_LOOP_ :\n-      throw new java::net::SocketException\n-        (JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n-      break;\n-\t\n-    case _Jv_IP_TOS_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;\n-      return new java::lang::Integer (val);\n-      break;\n-\t\n-    case _Jv_SO_REUSEADDR_ :\n-      throw new java::net::SocketException\n-        (JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n-      break;\n-\n-    case _Jv_SO_TIMEOUT_ :\n-      return new java::lang::Integer (timeout);\n-      break;\n-\n-    default :\n-      errno = ENOPROTOOPT;\n-    }\n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownInput (void)\n-{\n-  if (::shutdown (fnum, 0))\n-    throw new SocketException (JvNewStringUTF (strerror (errno)));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownOutput (void)\n-{\n-  if (::shutdown (fnum, 1))\n-    throw new SocketException (JvNewStringUTF (strerror (errno)));\n-}\n-\n-#endif /* DISABLE_JAVA_NET */"}]}