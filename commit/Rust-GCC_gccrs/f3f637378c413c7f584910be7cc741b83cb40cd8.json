{"sha": "f3f637378c413c7f584910be7cc741b83cb40cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNmNjM3Mzc4YzQxM2M3ZjU4NDkxMGJlN2NjNzQxYjgzY2I0MGNkOA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-10-29T08:53:47Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-10-29T08:53:47Z"}, "message": "invoke.texi: Document -mam34 and -mtune options.\n\n        * doc/invoke.texi: Document -mam34 and -mtune options.\n        * config/mn10300/mn10300.c (mn10300_tune_string): New variable.\n        (mn10300_tune_cpu): New variable.\n        (mn10300_handle_option): Handle -mam34 and -mtune options.\n        (mn10300_option_override): Convert tune string into tune cpu\n        variable.\n        (mn10300_legitimate_constant_p): Delete unused local variable.\n        (is_load_insn): New function.\n        (is_store_insn): New function.\n        (mn10300_adjust_schedule_cost): New function.\n        (TARGET_SCHED_ADJUST_COST): Define.\n        * config/mn10300/mn10300.opt (mam34): New option.\n        (mtune): New option.\n        * config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Add AM34\n        support.\n        (enum processor_type): Add AM34.\n        (TARGET_AM34): Define.\n        * config/mn10300/mn10300.md (attr cpu): Add am34.\n        Add pipeline description.\n        (movqi, movhi, movsi, movsf, movdf, movdi): Fix predicates. Remove unneeded\n        alternatives.  Add timing attribute.\n        (pop_pic_reg, am33_addsi3, mn10300_addsi3, am33_subsi3,\n        mn10300_subsi3, mulsidi3, umulsidi3, am33_mulsi3,\n        mn10300_mulsi3, udivmodsi4_am33, divmodsi4, am33_andsi3,\n        mn10300_andsi3, am33_iorsi3, mn10300_iorsi3, am33_xorsi3,\n        mn10300_xorsi3, byte_clear, byte_set, bit_clear1, bit_clear2,\n        bit_set, am33_iorqi3, mn10300_iorqi3, test_byte_bitfield,\n        bit_test, subreg_bit_test, cmpsi, am33_cmpsf, am33_subsi3,\n        float_conditional_branch, jump, indirect_jump, tablejump,\n        call_internal, call_value_internal, zero_extendqisi2_am33,\n        zero_extendqisi2_mn10300, zero_extendhisi2_am33,\n        zero_extendhisi2_mn10300, extendqisi2_am33, extendqisi2_mn10300,\n        extendhisi2_am33, extendhisi2_mn10300, am33_ashlsi3,\n        mn10300_ashlsi3, am33_lshrsi3, mn10300_lshrsi3, am33_ashrisi3,\n        mn10300_ashrsi3, abssf2_am33_2, negsf2_am33_2, rsqrtsf2,\n        addsf3_internal, subsf3_internal, mulsf3_internal, divsf3,\n        fmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4, return_internal,\n        return_internal_regs, store_movm, return, call_next_insn):\n        Add timing attribute.\n        (am33_subsi3): Add missing clobber of CC_REG.\n        (am33_andsi3, mn10300_andsi3): Fix compile time warnings.\n        (udivmodsi4, udivmodsi4_insn, divmodsi4, test_byte_bitfield,\n        subreg_bit_test, zero_extendqisi2, zero_extendhisi2,\n        extendqisi2): Fix predicates.\n        (call_internal, call_internal_value): Separate alternatives.\n        * config/mn10300/t-mn10300: Add AM34 multilib.\n\nFrom-SVN: r166058", "tree": {"sha": "e6ae4bf66634186860949005668690b4e9f2d6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6ae4bf66634186860949005668690b4e9f2d6e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3f637378c413c7f584910be7cc741b83cb40cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f637378c413c7f584910be7cc741b83cb40cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3f637378c413c7f584910be7cc741b83cb40cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f637378c413c7f584910be7cc741b83cb40cd8/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a575d5a19921067667378221af5ed250711a352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a575d5a19921067667378221af5ed250711a352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a575d5a19921067667378221af5ed250711a352"}], "stats": {"total": 1625, "additions": 1097, "deletions": 528}, "files": [{"sha": "0bd68104025af6c0dd77c3f4be945a552f887636", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -1,3 +1,52 @@\n+2010-10-29  Nick Clifton<nickc@redhat.com>\n+\n+\t* doc/invoke.texi: Document -mam34 and -mtune options.\n+\t* config/mn10300/mn10300.c (mn10300_tune_string): New variable.\n+\t(mn10300_tune_cpu): New variable.\n+\t(mn10300_handle_option): Handle -mam34 and -mtune options.\n+\t(mn10300_option_override): Convert tune string into tune cpu\n+\tvariable.\n+\t(mn10300_legitimate_constant_p): Delete unused local variable.\n+\t(is_load_insn): New function.\n+\t(is_store_insn): New function.\n+\t(mn10300_adjust_schedule_cost): New function.\n+\t(TARGET_SCHED_ADJUST_COST): Define.\n+\t* config/mn10300/mn10300.opt (mam34): New option.\n+\t(mtune): New option.\n+\t* config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Add AM34\n+\tsupport.\n+\t(enum processor_type): Add AM34.\n+\t(TARGET_AM34): Define.\n+\t* config/mn10300/mn10300.md (attr cpu): Add am34.\n+\tAdd pipeline description.\n+\t(movqi, movhi, movsi, movsf, movdf, movdi): Fix predicates. Remove unneeded\n+\talternatives.  Add timing attribute.\n+\t(pop_pic_reg, am33_addsi3, mn10300_addsi3, am33_subsi3,\n+\tmn10300_subsi3, mulsidi3, umulsidi3, am33_mulsi3,\n+\tmn10300_mulsi3, udivmodsi4_am33, divmodsi4, am33_andsi3,\n+\tmn10300_andsi3, am33_iorsi3, mn10300_iorsi3, am33_xorsi3,\n+\tmn10300_xorsi3, byte_clear, byte_set, bit_clear1, bit_clear2,\n+\tbit_set, am33_iorqi3, mn10300_iorqi3, test_byte_bitfield,\n+\tbit_test, subreg_bit_test, cmpsi, am33_cmpsf, am33_subsi3,\n+\tfloat_conditional_branch, jump, indirect_jump, tablejump,\n+\tcall_internal, call_value_internal, zero_extendqisi2_am33,\n+\tzero_extendqisi2_mn10300, zero_extendhisi2_am33,\n+\tzero_extendhisi2_mn10300, extendqisi2_am33, extendqisi2_mn10300,\n+\textendhisi2_am33, extendhisi2_mn10300, am33_ashlsi3,\n+\tmn10300_ashlsi3, am33_lshrsi3, mn10300_lshrsi3, am33_ashrisi3,\n+\tmn10300_ashrsi3, abssf2_am33_2, negsf2_am33_2, rsqrtsf2,\n+\taddsf3_internal, subsf3_internal, mulsf3_internal, divsf3,\n+\tfmaddsf4, fmsubsf4, fnmaddsf4, fnmsubsf4, return_internal,\n+\treturn_internal_regs, store_movm, return, call_next_insn):\n+\tAdd timing attribute.\n+\t(am33_subsi3): Add missing clobber of CC_REG.\n+\t(am33_andsi3, mn10300_andsi3): Fix compile time warnings.\n+\t(udivmodsi4, udivmodsi4_insn, divmodsi4, test_byte_bitfield,\n+\tsubreg_bit_test, zero_extendqisi2, zero_extendhisi2,\n+\textendqisi2): Fix predicates.\n+\t(call_internal, call_internal_value): Separate alternatives.\n+\t* config/mn10300/t-mn10300: Add AM34 multilib.\n+\n 2010-10-29  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/sh/sh.c (sh_promote_function_mode): Use"}, {"sha": "c0f11805117ac2d9c9639062010b7932bac1c021", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 144, "deletions": 10, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -58,6 +58,12 @@ int mn10300_protect_label;\n /* The selected processor.  */\n enum processor_type mn10300_processor = PROCESSOR_DEFAULT;\n \n+/* Processor type to select for tuning.  */\n+static const char * mn10300_tune_string = NULL;\n+\n+/* Selected processor type for tuning.  */\n+enum processor_type mn10300_tune_cpu = PROCESSOR_DEFAULT;\n+\n /* The size of the callee register save area.  Right now we save everything\n    on entry since it costs us nothing in code size.  It does cost us from a\n    speed standpoint, so we want to optimize this sooner or later.  */\n@@ -91,11 +97,21 @@ mn10300_handle_option (size_t code,\n     case OPT_mam33:\n       mn10300_processor = value ? PROCESSOR_AM33 : PROCESSOR_MN10300;\n       return true;\n+\n     case OPT_mam33_2:\n       mn10300_processor = (value\n \t\t\t   ? PROCESSOR_AM33_2\n \t\t\t   : MIN (PROCESSOR_AM33, PROCESSOR_DEFAULT));\n       return true;\n+\n+    case OPT_mam34:\n+      mn10300_processor = (value ? PROCESSOR_AM34 : PROCESSOR_DEFAULT);\n+      return true;\n+\n+    case OPT_mtune_:\n+      mn10300_tune_string = arg;\n+      return true;\n+\n     default:\n       return true;\n     }\n@@ -108,6 +124,27 @@ mn10300_option_override (void)\n {\n   if (TARGET_AM33)\n     target_flags &= ~MASK_MULT_BUG;\n+  else\n+    {\n+      /* Disable scheduling for the MN10300 as we do\n+\t not have timing information available for it.  */\n+      flag_schedule_insns = 0;\n+      flag_schedule_insns_after_reload = 0;\n+    }\n+  \n+  if (mn10300_tune_string)\n+    {\n+      if (strcasecmp (mn10300_tune_string, \"mn10300\") == 0)\n+\tmn10300_tune_cpu = PROCESSOR_MN10300;\n+      else if (strcasecmp (mn10300_tune_string, \"am33\") == 0)\n+\tmn10300_tune_cpu = PROCESSOR_AM33;\n+      else if (strcasecmp (mn10300_tune_string, \"am33-2\") == 0)\n+\tmn10300_tune_cpu = PROCESSOR_AM33_2;\n+      else if (strcasecmp (mn10300_tune_string, \"am34\") == 0)\n+\tmn10300_tune_cpu = PROCESSOR_AM34;\n+      else\n+\terror (\"-mtune= expects mn10300, am33, am33-2, or am34\");\n+    }\n }\n \n static void\n@@ -370,7 +407,7 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n \n       case 'A':\n \tfputc ('(', file);\n-\tif (REG_P ((XEXP (x, 0))))\n+\tif (REG_P (XEXP (x, 0)))\n \t  output_address (gen_rtx_PLUS (SImode, XEXP (x, 0), const0_rtx));\n \telse\n \t  output_address (XEXP (x, 0));\n@@ -392,7 +429,7 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n \t shift count as an error.  So we mask off the high bits\n \t of the immediate here.  */\n       case 'S':\n-\tif (CONST_INT_P ((x)))\n+\tif (CONST_INT_P (x))\n \t  {\n \t    fprintf (file, \"%d\", (int)(INTVAL (x) & 0x1f));\n \t    break;\n@@ -1250,8 +1287,8 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n   /* Memory loads less than a full word wide can't have an\n      address or stack pointer destination.  They must use\n      a data register as an intermediate register.  */\n-  if ((MEM_P ((in))\n-       || (REG_P ((inner))\n+  if ((MEM_P (in)\n+       || (REG_P (inner)\n \t   && REGNO (inner) >= FIRST_PSEUDO_REGISTER))\n       && (mode == QImode || mode == HImode)\n       && (rclass == ADDRESS_REGS || rclass == SP_REGS\n@@ -1281,13 +1318,13 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n     {\n       /* We can't load directly into an FP register from a\t\n \t constant address.  */\n-      if (MEM_P ((in))\n+      if (MEM_P (in)\n \t  && CONSTANT_ADDRESS_P (XEXP (in, 0)))\n \treturn DATA_OR_EXTENDED_REGS;\n \n       /* Handle case were a pseudo may not get a hard register\n \t but has an equivalent memory location defined.  */\n-      if (REG_P ((inner))\n+      if (REG_P (inner)\n \t  && REGNO (inner) >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem [REGNO (inner)]\n \t  && CONSTANT_ADDRESS_P (XEXP (reg_equiv_mem [REGNO (inner)], 0)))\n@@ -1696,7 +1733,7 @@ mn10300_symbolic_operand (rtx op,\n       op = XEXP (op, 0);\n       return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n                || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-              && CONST_INT_P ((XEXP (op, 1))));\n+              && CONST_INT_P (XEXP (op, 1)));\n     default:\n       return 0;\n     }\n@@ -1870,7 +1907,7 @@ mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n       if (base != 0 && index != 0)\n \t{\n-\t  if (CONST_INT_P ((index)))\n+\t  if (CONST_INT_P (index))\n \t    return TRUE;\n \t  if (GET_CODE (index) == CONST\n \t      && GET_CODE (XEXP (index, 0)) != PLUS\n@@ -1907,7 +1944,6 @@ mn10300_legitimate_constant_p (rtx x)\n       /* Only some unspecs are valid as \"constants\".  */\n       if (GET_CODE (x) == UNSPEC)\n \t{\n-\t  rtx sym = XVECEXP (x, 0, 0);\n \t  switch (XINT (x, 1))\n \t    {\n \t    case UNSPEC_INT_LABEL:\n@@ -2070,7 +2106,7 @@ mn10300_wide_const_load_uses_clr (rtx operands[2])\n {\n   long val[2] = {0, 0};\n \n-  if (! REG_P (operands[0])\n+  if ((! REG_P (operands[0]))\n       || REGNO_REG_CLASS (REGNO (operands[0])) != DATA_REGS)\n     return false;\n \n@@ -2272,6 +2308,101 @@ mn10300_select_cc_mode (rtx x)\n {\n   return (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT) ? CC_FLOATmode : CCmode;\n }\n+\n+static inline bool\n+is_load_insn (rtx insn)\n+{\n+  if (GET_CODE (PATTERN (insn)) != SET)\n+    return false;\n+\n+  return MEM_P (SET_SRC (PATTERN (insn)));\n+}\n+\n+static inline bool\n+is_store_insn (rtx insn)\n+{\n+  if (GET_CODE (PATTERN (insn)) != SET)\n+    return false;\n+\n+  return MEM_P (SET_DEST (PATTERN (insn)));\n+}\n+\n+/* Update scheduling costs for situations that cannot be\n+   described using the attributes and DFA machinery.\n+   DEP is the insn being scheduled.\n+   INSN is the previous insn.\n+   COST is the current cycle cost for DEP.  */\n+\n+static int\n+mn10300_adjust_sched_cost (rtx insn, rtx link, rtx dep, int cost)\n+{\n+  int timings = get_attr_timings (insn);\n+\n+  if (!TARGET_AM33)\n+    return 1;\n+\n+  if (GET_CODE (insn) == PARALLEL)\n+    insn = XVECEXP (insn, 0, 0);\n+\n+  if (GET_CODE (dep) == PARALLEL)\n+    dep = XVECEXP (dep, 0, 0);\n+\n+  /* For the AM34 a load instruction that follows a\n+     store instruction incurs an extra cycle of delay.  */\n+  if (mn10300_tune_cpu == PROCESSOR_AM34\n+      && is_load_insn (dep)\n+      && is_store_insn (insn))\n+    cost += 1;\n+\n+  /* For the AM34 a non-store, non-branch FPU insn that follows\n+     another FPU insn incurs a one cycle throughput increase.  */\n+  else if (mn10300_tune_cpu == PROCESSOR_AM34\n+      && ! is_store_insn (insn)\n+      && ! JUMP_P (insn)\n+      && GET_CODE (PATTERN (dep)) == SET\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (dep)))) == MODE_FLOAT\n+      && GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (insn)))) == MODE_FLOAT)\n+    cost += 1;\n+\n+  /*  Resolve the conflict described in section 1-7-4 of\n+      Chapter 3 of the MN103E Series Instruction Manual\n+      where it says:\n+\n+        \"When the preceeding instruction is a CPU load or\n+\t store instruction, a following FPU instruction\n+\t cannot be executed until the CPU completes the\n+\t latency period even though there are no register\n+\t or flag dependencies between them.\"  */\n+\n+  /* Only the AM33-2 (and later) CPUs have FPU instructions.  */\n+  if (! TARGET_AM33_2)\n+    return cost;\n+\n+  /* If a data dependence already exists then the cost is correct.  */\n+  if (REG_NOTE_KIND (link) == 0)\n+    return cost;\n+\n+  /* Check that the instruction about to scheduled is an FPU instruction.  */\n+  if (GET_CODE (PATTERN (dep)) != SET)\n+    return cost;\n+\n+  if (GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (dep)))) != MODE_FLOAT)\n+    return cost;\n+\n+  /* Now check to see if the previous instruction is a load or store.  */\n+  if (! is_load_insn (insn) && ! is_store_insn (insn))\n+    return cost;\n+\n+  /* XXX: Verify: The text of 1-7-4 implies that the restriction\n+     only applies when an INTEGER load/store preceeds an FPU\n+     instruction, but is this true ?  For now we assume that it is.  */\n+  if (GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (insn)))) != MODE_INT)\n+    return cost;\n+\n+  /* Extract the latency value from the timings attribute.  */\n+  return timings < 100 ? (timings % 10) : (timings % 100);\n+}\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -2347,4 +2478,7 @@ mn10300_select_cc_mode (rtx x)\n #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK  mn10300_can_output_mi_thunk\n \n+#undef  TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST mn10300_adjust_sched_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "c9f76f87593ccb9aa240d8dd01daedc1d6b7e112", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -38,7 +38,12 @@\n       builtin_assert (\"cpu=mn10300\");\t\t\\\n       builtin_assert (\"machine=mn10300\");\t\\\n \t\t\t\t\t\t\\\n-      if (TARGET_AM33_2)\t\t\t\\\n+      if (TARGET_AM34)\t\t\t\t\\\n+        { \t\t\t\t\t\\\n+          builtin_define (\"__AM33__=4\");\t\\\n+          builtin_define (\"__AM34__\");\t\t\\\n+        }\t\t\t\t\t\\\n+      else if (TARGET_AM33_2)\t\t\t\\\n         { \t\t\t\t\t\\\n           builtin_define (\"__AM33__=2\");\t\\\n           builtin_define (\"__AM33_2__\");\t\\\n@@ -54,13 +59,16 @@ enum processor_type\n {\n   PROCESSOR_MN10300,\n   PROCESSOR_AM33,\n-  PROCESSOR_AM33_2\n+  PROCESSOR_AM33_2,\n+  PROCESSOR_AM34\n };\n \n extern enum processor_type mn10300_processor;\n+extern enum processor_type mn10300_tune_cpu;\n \n #define TARGET_AM33\t(mn10300_processor >= PROCESSOR_AM33)\n-#define TARGET_AM33_2\t(mn10300_processor == PROCESSOR_AM33_2)\n+#define TARGET_AM33_2\t(mn10300_processor >= PROCESSOR_AM33_2)\n+#define TARGET_AM34\t(mn10300_processor >= PROCESSOR_AM34)\n \n #ifndef PROCESSOR_DEFAULT\n #define PROCESSOR_DEFAULT PROCESSOR_MN10300\n@@ -274,7 +282,7 @@ enum reg_class\n \n /* Give names of register classes as strings for dump file.  */\n \n-#define REG_CLASS_NAMES\t\t\t\t\t\t\\\n+#define REG_CLASS_NAMES\t\t\t\t\t   \t\\\n { \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\",\t\t\t\\\n   \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\",\t\\\n   \"EXTENDED_REGS\",\t\t\t\t\t\t\\\n@@ -289,7 +297,7 @@ enum reg_class\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\\\n-{ { 0,\t        0 },\t  /* No regs      */\t\t\t\\\n+{ { 0,\t        0 },\t  /* No regs */\t\t\t\t\\\n   { 0x0000000f, 0 },\t  /* DATA_REGS */\t\t\t\\\n   { 0x000001f0, 0 },\t  /* ADDRESS_REGS */\t\t\t\\\n   { 0x00000200, 0 },\t  /* SP_REGS */\t\t\t\t\\\n@@ -304,7 +312,7 @@ enum reg_class\n   { 0x03fc0000, 0 },\t  /* FP_ACC_REGS */\t\t\t\\\n   { 0x00000000, 0x80000 },/* CC_REGS */\t\t\t\t\\\n   { 0x0003fdff, 0 }, \t  /* GENERAL_REGS */\t\t\t\\\n-  { 0xffffffff, 0xfffff } /* ALL_REGS \t*/\t\t\t\\\n+  { 0xffffffff, 0xfffff } /* ALL_REGS */\t\t\t\\\n }\n \n /* The following macro defines cover classes for Integrated Register"}, {"sha": "26126a7c0343be5d0954952b6266e894c8b6de32", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 862, "deletions": 507, "changes": 1369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -40,6 +40,114 @@\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n+\n+;; Processor type.  This attribute must exactly match the processor_type\n+;; enumeration in mn10300.h.\n+(define_attr \"cpu\" \"mn10300,am33,am33_2,am34\"\n+  (const (symbol_ref \"mn10300_tune_cpu\")))\n+\n+\f\n+;; Pipeline description.\n+\n+;; The AM33 only has a single pipeline.  It has five stages (fetch,\n+;; decode, execute, memory access, writeback) each of which normally\n+;; takes a single CPU clock cycle.\n+\n+;; The timings attribute consists of two numbers, the first is the\n+;; throughput, which is the number of cycles the instruction takes\n+;; to execute and generate a result.  The second is the latency\n+;; which is the effective number of cycles the instruction takes to\n+;; execute if its result is used by the following instruction.  The\n+;; latency is always greater than or equal to the throughput.\n+;; These values were taken from the Appendix of the \"MN103E Series\n+;; Instruction Manual\" and the timings for the AM34.\n+\n+;; Note - it would be nice to use strings rather than integers for\n+;; the possible values of this attribute, so that we can have the\n+;; gcc build mechanism check for values that are not supported by\n+;; the reservations below.  But this will not work because the code\n+;; in mn10300_adjust_sched_cost() needs integers not strings.\n+\n+(define_attr \"timings\" \"\" (const_int 11))\n+\n+(define_automaton \"pipelining\")\n+(define_cpu_unit \"throughput\" \"pipelining\")\n+\n+(define_insn_reservation \"throughput__1_latency__1\"  1\n+  (eq_attr \"timings\" \"11\") \"throughput\")\n+(define_insn_reservation \"throughput__1_latency__2\"  2\n+  (eq_attr \"timings\" \"12\") \"throughput,nothing\")\n+(define_insn_reservation \"throughput__1_latency__3\"  3\n+  (eq_attr \"timings\" \"13\") \"throughput,nothing*2\")\n+(define_insn_reservation \"throughput__1_latency__4\"  4\n+  (eq_attr \"timings\" \"14\") \"throughput,nothing*3\")\n+(define_insn_reservation \"throughput__2_latency__2\"  2\n+  (eq_attr \"timings\" \"22\") \"throughput*2\")\n+(define_insn_reservation \"throughput__2_latency__3\"  3\n+  (eq_attr \"timings\" \"23\") \"throughput*2,nothing\")\n+(define_insn_reservation \"throughput__2_latency__4\"  4\n+  (eq_attr \"timings\" \"24\") \"throughput*2,nothing*2\")\n+(define_insn_reservation \"throughput__2_latency__5\"  5\n+  (eq_attr \"timings\" \"25\") \"throughput*2,nothing*3\")\n+(define_insn_reservation \"throughput__3_latency__3\"  3\n+  (eq_attr \"timings\" \"33\") \"throughput*3\")\n+(define_insn_reservation \"throughput__3_latency__7\"  7\n+  (eq_attr \"timings\" \"37\") \"throughput*3,nothing*4\")\n+(define_insn_reservation \"throughput__4_latency__4\"  4\n+  (eq_attr \"timings\" \"44\") \"throughput*4\")\n+(define_insn_reservation \"throughput__4_latency__7\"  7\n+  (eq_attr \"timings\" \"47\") \"throughput*4,nothing*3\")\n+(define_insn_reservation \"throughput__4_latency__8\"  8\n+  (eq_attr \"timings\" \"48\") \"throughput*4,nothing*4\")\n+(define_insn_reservation \"throughput__5_latency__5\"  5\n+  (eq_attr \"timings\" \"55\") \"throughput*5\")\n+(define_insn_reservation \"throughput__6_latency__6\"  6\n+  (eq_attr \"timings\" \"66\") \"throughput*6\")\n+(define_insn_reservation \"throughput__7_latency__7\"  7\n+  (eq_attr \"timings\" \"77\") \"throughput*7\")\n+(define_insn_reservation \"throughput__7_latency__8\"  8\n+  (eq_attr \"timings\" \"78\") \"throughput*7,nothing\")\n+(define_insn_reservation \"throughput__8_latency__8\"  8\n+  (eq_attr \"timings\" \"88\") \"throughput*8\")\n+(define_insn_reservation \"throughput__9_latency__9\"  9\n+  (eq_attr \"timings\" \"99\") \"throughput*9\")\n+(define_insn_reservation \"throughput__8_latency_14\" 14\n+  (eq_attr \"timings\" \"814\") \"throughput*8,nothing*6\")\n+(define_insn_reservation \"throughput__9_latency_10\" 10\n+  (eq_attr \"timings\" \"910\") \"throughput*9,nothing\")\n+(define_insn_reservation \"throughput_10_latency_10\" 10\n+  (eq_attr \"timings\" \"1010\") \"throughput*10\")\n+(define_insn_reservation \"throughput_12_latency_16\" 16\n+  (eq_attr \"timings\" \"1216\") \"throughput*12,nothing*4\")\n+(define_insn_reservation \"throughput_13_latency_13\" 13\n+  (eq_attr \"timings\" \"1313\") \"throughput*13\")\n+(define_insn_reservation \"throughput_14_latency_14\" 14\n+  (eq_attr \"timings\" \"1414\") \"throughput*14\")\n+(define_insn_reservation \"throughput_13_latency_17\" 17\n+  (eq_attr \"timings\" \"1317\") \"throughput*13,nothing*4\")\n+(define_insn_reservation \"throughput_23_latency_27\" 27\n+  (eq_attr \"timings\" \"2327\") \"throughput*23,nothing*4\")\n+(define_insn_reservation \"throughput_25_latency_31\" 31\n+  (eq_attr \"timings\" \"2531\") \"throughput*25,nothing*6\")\n+(define_insn_reservation \"throughput_38_latency_39\" 39\n+  (eq_attr \"timings\" \"3839\") \"throughput*38,nothing\")\n+(define_insn_reservation \"throughput_39_latency_40\" 40\n+  (eq_attr \"timings\" \"3940\") \"throughput*39,nothing\")\n+(define_insn_reservation \"throughput_40_latency_40\" 40\n+  (eq_attr \"timings\" \"4040\") \"throughput*40\")\n+(define_insn_reservation \"throughput_41_latency_42\" 42\n+  (eq_attr \"timings\" \"4142\") \"throughput*41,nothing\")\n+(define_insn_reservation \"throughput_43_latency_44\" 44\n+  (eq_attr \"timings\" \"4344\") \"throughput*43,nothing\")\n+(define_insn_reservation \"throughput_45_latency_46\" 46\n+  (eq_attr \"timings\" \"4546\") \"throughput*45,nothing\")\n+(define_insn_reservation \"throughput_47_latency_53\" 53\n+  (eq_attr \"timings\" \"4753\") \"throughput*47,nothing*6\")\n+\n+;; Note - the conflict between memory load/store instructions\n+;; and floating point instructions described in section 1-7-4\n+;; of Chapter 3 of the MN103E Series Instruction Manual is\n+;; handled by the mn10300_adjust_sched_cost function.\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n@@ -48,7 +156,7 @@\n ;; movqi\n \n (define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\")\n \t(match_operand:QI 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -60,52 +168,62 @@\n }\")\n \n (define_insn \"*am33_movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x*a,d*x*a,m,*f,d*x*a\")\n-\t(match_operand:QI 1 \"general_operand\"      \"0,d*xai,m,d*xa,d*xa*f,*f\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\"\n+\t\t\t  ;; 0       1      2      3     4       5\n+\t\t\t  \"=d*x*a*f, d*x*a, d*x*a, m,   *f,      d*x*a\")\n+\t(match_operand:QI 1 \"general_operand\"\n+\t\t\t   \"0,       d*xai, m,     d*xa, d*xa*f, *f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n   \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \\\"nop\\\";\n-    case 1:\n-      if (CONST_DOUBLE_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        return \\\"nop\\\";\n+      case 1:\n+        gcc_assert (! CONST_DOUBLE_P (operands[1]));\n \n-      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && CONST_INT_P (operands[1]))\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+        if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t    && CONST_INT_P (operands[1]))\n+\t  {\n+\t    HOST_WIDE_INT val = INTVAL (operands[1]);\n \n-\t  if (((val & 0x80) && ! (val & 0xffffff00))\n-\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t    return \\\"movu %1,%0\\\";\n-\t}\n-      return \\\"mov %1,%0\\\";\n-    case 2:\n-    case 3:\n-      return \\\"movbu %1,%0\\\";\n-    case 4:\n-    case 5:\n-      return \\\"fmov %1,%0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n+\t    if (((val & 0x80) && ! (val & 0xffffff00))\n+\t        || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t      return \\\"movu %1,%0\\\";\n+\t  }\n+        return \\\"mov %1,%0\\\";\n+      case 2:\n+      case 3:\n+        return \\\"movbu %1,%0\\\";\n+      case 4:\n+      case 5:\n+        return \\\"fmov %1,%0\\\";\n+      default:\n+        gcc_unreachable ();\n+      }\n+  }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 47) (const_int 25))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 47) (const_int 25))\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*mn10300_movqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,I,i,i,da,m,d\"))]\n+\t(match_operand:QI 1 \"general_operand\"       \"0,  I,i,i,  da, m,d\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n   \"*\n@@ -118,15 +236,7 @@\n     case 2:\n     case 3:\n     case 4:\n-      if (CONST_DOUBLE_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n+      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n       return \\\"mov %1,%0\\\";\n     case 5:\n     case 6:\n@@ -135,12 +245,27 @@\n       gcc_unreachable ();\n     }\n }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n ;; movhi\n \n (define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n \t(match_operand:HI 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -152,8 +277,11 @@\n }\")\n \n (define_insn \"*am33_movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x*a,d*x*a,m,*f,d*x*a\")\n-\t(match_operand:HI 1 \"general_operand\"      \"0,d*x*ai,m,d*x*a,d*x*a*f,*f\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n+\t\t\t  ;; 0       1       2      3     4         5\n+\t\t\t  \"=d*x*a*f, d*x*a,  d*x*a, m,    *f,       d*x*a\")\n+\t(match_operand:HI 1 \"general_operand\"\n+\t\t\t  \"0,        d*x*ai, m,     d*x*a, d*x*a*f, *f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -164,14 +292,7 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      if (CONST_DOUBLE_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n+      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n \n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n \t  && CONST_INT_P (operands[1]))\n@@ -193,11 +314,25 @@\n       gcc_unreachable ();\n     }\n }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 47) (const_int 25))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 47) (const_int 25))\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*mn10300_movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,I,i,i,da,m,d\"))]\n+\t(match_operand:HI 1 \"general_operand\"       \"0,  I,i,i,  da, m,d\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\"\n   \"*\n@@ -210,14 +345,7 @@\n     case 2:\n     case 3:\n     case 4:\n-      if (CONST_DOUBLE_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n+      gcc_assert (! CONST_DOUBLE_P (operands[1]));\n       return \\\"mov %1,%0\\\";\n     case 5:\n     case 6:\n@@ -226,6 +354,21 @@\n       gcc_unreachable ();\n     }\n }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n ;; movsi and helpers\n@@ -276,10 +419,13 @@\n   [(set (reg:SI PIC_REG)\n \t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n   \"reload_completed\"\n-  \"movm (sp),[a2]\")\n+  \"movm (sp),[a2]\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 44) (const_int 33)))]\n+)\n \n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n \t(match_operand:SI 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -322,62 +468,49 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,axR,!*y,*f,*f,dxaQ\")\n+\t\t\t  \"=dax, dax,  m,   dax, axR, !*y\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dixm,aixm,dixm,aixm,!*y,axR,0,dxaQi*f,*f\"))]\n+\t\t\t  \"0,    Idax, dax, im,  !*y, axR\"))\n+  ]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n+  {\n+    if (which_alternative == 0)\n       return \\\"nop\\\";\n-    case 2:\n-    case 3:\n-    case 4:\n-    case 5:\n-    case 6:\n-    case 7:\n-    case 8:\n-    case 9:\n-    case 10:\n-    case 11:\n-    case 12:\n-    case 13:\n-      if (CONST_DOUBLE_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n \n-      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && CONST_INT_P (operands[1]))\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+    gcc_assert (! CONST_DOUBLE_P (operands[1]));\n \n-\t  if (((val & 0x80) && ! (val & 0xffffff00))\n-\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t    return \\\"movu %1,%0\\\";\n-\t}\n-      return \\\"mov %1,%0\\\";\n-    case 14:\n-      return \\\"nop\\\";\n-    case 15:\n-    case 16:\n-      return \\\"fmov %1,%0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n+    if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+        && CONST_INT_P (operands[1]))\n+      {\n+        HOST_WIDE_INT val = INTVAL (operands[1]);\n+\n+        if (((val & 0x80) && ! (val & 0xffffff00))\n+            || ((val & 0x800000) && ! (val & 0xff000000)))\n+          return \\\"movu %1, %0\\\";\n+      }\n+\n+    return \\\"mov %1, %0\\\";\n+  }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\")\n \t(match_operand:SF 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -389,44 +522,59 @@\n }\")\n \n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,dx,ax,dx,a,f,dxaQ,daxm,dax\")\n-\t(match_operand:SF 1 \"general_operand\"       \"0,0,0,G,G,fdxaQF,f,dax,daxFm\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n+\t\t\t  ;; 0    1    2       3     4     5\n+\t\t\t  \"=fdxa, dxa, f,      dxaQ, daxm, dax\")\n+\t(match_operand:SF 1 \"general_operand\"\n+\t\t\t  \" 0,    G,   fdxaQF, f,    dax,  daxFm\"))\n+  ]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 2:\n-      return \\\"nop\\\";\n-    /* Cases 3 & 4: below.  */\n-    case 5:\n-    case 6:\n-      return \\\"fmov %1, %0\\\";\n-    case 3:\n-    case 4:\n-    case 7:\n-    case 8:\n-      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && CONST_INT_P (operands[1]))\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        return \\\"nop\\\";\n+      /* case 1: below.  */\n+      case 2:\n+      case 3:\n+        return \\\"fmov %1, %0\\\";\n+      case 1:\n+      case 4:\n+      case 5:\n+        if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t    && CONST_INT_P (operands[1]))\n+\t  {\n+\t    HOST_WIDE_INT val = INTVAL (operands[1]);\n \n-\t  if (((val & 0x80) && ! (val & 0xffffff00))\n-\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n-\t    return \\\"movu %1,%0\\\";\n-\t}\n-      return \\\"mov %1,%0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n+\t    if (((val & 0x80) && ! (val & 0xffffff00))\n+\t        || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t      return \\\"movu %1, %0\\\";\n+\t  }\n+        return \\\"mov %1, %0\\\";\n+      default:\n+        gcc_unreachable ();\n+      }\n+  }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 47) (const_int 25))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 47) (const_int 25))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\")\n \t(match_operand:DI 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -437,11 +585,10 @@\n     operands[1] = copy_to_mode_reg (DImode, operand1);\n }\")\n \n-(define_insn \"*movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,*f,*f,*f,dxa,*f,Q\")\n-\t(match_operand:DI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dxim,axim,dxim,axim,0,*f,dxai,*f,Q,*f\"))]\n+\n+(define_insn \"*movdi_internal\"                   ;;   0 1  2  3 4   5   6  7 8  9\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=dx,ax,dx,a,dxm,dxm,a, a,dx,a\")\n+\t(match_operand:DI 1 \"general_operand\"        \"0,0, I, I,dx, a,  dx,a,im,im\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n   \"*\n@@ -469,8 +616,6 @@\n       case 7:\n       case 8:\n       case 9:\n-      case 10:\n-      case 11:\n \tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n@@ -568,34 +713,28 @@\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n-      case 12:\n-        return \\\"nop\\\";\n-      case 13:\n-      case 14:\n-      case 15:\n-        return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n-      case 16:\n-\tif (MEM_P (operands[1])\n-\t    && CONST_INT_P (XEXP (operands[1], 0))\n-\t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n-\t  return \\\"fmov %D1, %D0\\\";\n-\telse\n-          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n-      case 17:\n-\tif (MEM_P (operands[0])\n-\t    && CONST_INT_P (XEXP (operands[0], 0))\n-\t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n-\t  return \\\"fmov %D1, %D0\\\";\n-\telse\n-          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+  }\"\n+  ;; The timing of \"37\" is an approximation of the worst case sceanario.\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\")\n \t(match_operand:DF 1 \"general_operand\"))]\n   \"\"\n   \"\n@@ -608,63 +747,52 @@\n \n (define_insn \"*am33_2_movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t  ;;      0 1  2  3  4 5 6   7 8 9 10  11  12  13  14 15 16 17\n-\t\t\t\t\"=f,dx,ax,dx,f,f,dxa,f,Q,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n+\t\t\t  ;; 0   1   2    3    4 5 6   7   8  9 10 11\n+\t\t\t  \"=fdax,dax,fdxa,f,   f,Q,dxm,dxm,a, a,dx,a\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t  ;;     0 1 2 3 4 5    6 7 8 9 10 11 12 13 14   15   16   17\n-\t\t\t\t\"0,0,0,G,f,dxaF,f,Q,f,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n+\t\t\t  \" 0,   G,  f,   dxaF,Q,f,dx, a,  dx,a,Fm,Fm\"))]\n   \"TARGET_AM33_2\n-\t&& (register_operand (operands[0], DFmode)\n-   \t|| register_operand (operands[1], DFmode))\"\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n   \"*\n-{\n-  long val[2];\n-  REAL_VALUE_TYPE rv;\n+  {\n+    long val[2];\n+    REAL_VALUE_TYPE rv;\n \n-  switch (which_alternative)\n-    {\n+    switch (which_alternative)\n+      {\n       case 0:\n-      case 1:\n-      case 2:\n \treturn \\\"nop\\\";\n \n+      case 1:\n+\treturn \\\"mov 0, %L0\\; mov 0, %H0\\\";\n+\n+      case 2:\n       case 3:\n-\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n+        return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n \n       case 4:\n-      case 5:\n-      case 6:\n-        return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n-\n-      case 7:\n \tif (MEM_P (operands[1])\n \t    && CONST_INT_P (XEXP (operands[1], 0))\n \t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n-          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+          return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n \n-      case 8:\n+      case 5:\n \tif (MEM_P (operands[0])\n \t    && CONST_INT_P (XEXP (operands[0], 0))\n \t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n-          return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n+          return \\\"fmov %L1, %L0\\; fmov %H1, %H0\\\";\n \n+      case 6:\n+      case 7:\n+      case 8:\n       case 9:\n-\t if (rtx_equal_p (operands[0], operands[1]))\n-\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n-\t else\n-\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 10:\n       case 11:\n-      case 12:\n-      case 13:\n-      case 14:\n-      case 15:\n-      case 16:\n-      case 17:\n \tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n@@ -699,9 +827,9 @@\n \n \t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n-\t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n+\t      return \\\"mov %H1, %H0\\; mov %L1, %L0\\\";\n \t    else\n-\t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n+\t      return \\\"mov %L1, %L0\\; mov %H1, %H0\\\";\n \n \t  }\n \telse if (MEM_P (operands[1])\n@@ -713,7 +841,7 @@\n \t    xoperands[0] = operands[0];\n \t    xoperands[1] = XEXP (operands[1], 0);\n \n-\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n+\t    output_asm_insn (\\\"mov %1, %L0\\; mov (4, %L0), %H0\\; mov (%L0), %L0\\\",\n \t\t\t     xoperands);\n \t    return \\\"\\\";\n \t  }\n@@ -734,9 +862,9 @@\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n \t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %L1,%L0\\\", operands);\n+\t      output_asm_insn (\\\"movu %L1, %L0\\\", operands);\n \t    else\n-\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t      output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n \n \t    if ((CONST_INT_P (operands[1])\n \t\t || CONST_DOUBLE_P (operands[1]))\n@@ -745,7 +873,7 @@\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n-\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n \t      }\n \t    else if ((CONST_INT_P (operands[1])\n \t\t      || CONST_DOUBLE_P (operands[1]))\n@@ -757,60 +885,68 @@\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n \t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %H1,%H0\\\", operands);\n+\t      output_asm_insn (\\\"movu %H1, %H0\\\", operands);\n \t    else\n-\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t      output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+  }\"\n+  ;; The timing of \"37\" is an approximation of the worst case sceanario.\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*mn10300_movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t  ;;     0    1  2 3   4   5   6   7  8  9  10\n-\t\t\t\t\"=dxa,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n+\t\t\t  ;;0    1    2    3    4   5  6   7\n+\t\t\t  \"=dxa, dax, dxm, dxm, a,  a, dx, a\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t  ;;        0 1 2 3  4  5  6  7    8    9    10\n-\t\t\t\t   \"0,G,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n+\t\t\t  \" 0,   G,   dx,  a,   dx, a, Fm, Fm\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n-{\n-  long val[2];\n-  REAL_VALUE_TYPE rv;\n+  {\n+    long val[2];\n+    REAL_VALUE_TYPE rv;\n \n-  switch (which_alternative)\n-    {\n+    switch (which_alternative)\n+      {\n       case 0:\n \treturn \\\"nop\\\";\n \n       case 1:\n-\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n+\treturn \\\"mov 0, %L0\\; mov 0, %H0\\\";\n \n       case 2:\n-\t if (rtx_equal_p (operands[0], operands[1]))\n-\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n-\t else\n-\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n       case 3:\n       case 4:\n       case 5:\n       case 6:\n       case 7:\n-      case 8:\n-      case 9:\n-      case 10:\n \tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n \t    split_double (operands[1], &low, &high);\n \t    val[0] = INTVAL (low);\n \t    val[1] = INTVAL (high);\n \t  }\n-\tif (CONST_DOUBLE_P (operands[1]))\n+        if (CONST_DOUBLE_P (operands[1]))\n \t  {\n \t    if (GET_MODE (operands[1]) == DFmode)\n \t      {\n@@ -837,10 +973,9 @@\n \n \t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n-\t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n+\t      return \\\"mov %H1, %H0\\; mov %L1, %L0\\\";\n \t    else\n-\t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n-\n+\t      return \\\"mov %L1, %L0\\; mov %H1, %H0\\\";\n \t  }\n \telse if (MEM_P (operands[1])\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n@@ -851,7 +986,7 @@\n \t    xoperands[0] = operands[0];\n \t    xoperands[1] = XEXP (operands[1], 0);\n \n-\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n+\t    output_asm_insn (\\\"mov %1, %L0\\; mov (4, %L0), %H0\\; mov (%L0), %L0\\\",\n \t\t\t     xoperands);\n \t    return \\\"\\\";\n \t  }\n@@ -864,17 +999,17 @@\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n-\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n \t      }\n \t    else if ((CONST_INT_P (operands[1])\n \t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n \t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %L1,%L0\\\", operands);\n+\t      output_asm_insn (\\\"movu %L1, %L0\\\", operands);\n \t    else\n-\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t      output_asm_insn (\\\"mov %L1, %L0\\\", operands);\n \n \t    if ((CONST_INT_P (operands[1])\n \t\t || CONST_DOUBLE_P (operands[1]))\n@@ -883,29 +1018,40 @@\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n-\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n \t      }\n \t    else if ((CONST_INT_P (operands[1])\n \t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && val[0] == val[1])\n-\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n+\t      output_asm_insn (\\\"mov %L0, %H0\\\", operands);\n \t    else if ((CONST_INT_P (operands[1])\n \t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n \t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n-\t      output_asm_insn (\\\"movu %H1,%H0\\\", operands);\n+\t      output_asm_insn (\\\"movu %H1, %H0\\\", operands);\n \t    else\n-\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t      output_asm_insn (\\\"mov %H1, %H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+  }\"\n+  ;; Timings of \"37\" is approximation of the worst case sceanario.\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t  (const_int 37)\n+\t\t\t ])\n+  ]\n )\n-\t\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n@@ -1000,7 +1146,8 @@\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n+  }\"\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,22\")]\n )\n \n (define_insn \"*mn10300_addsi3\"\n@@ -1045,6 +1192,7 @@\n       gcc_unreachable ();\n     }\n }\"\n+  [(set_attr \"timings\" \"11,11,11,11,11,22\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -1062,33 +1210,36 @@\n   \"\")\n \n (define_insn \"*am33_subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dax,!dax\")\n+  [(set (match_operand:SI           0 \"register_operand\" \"=dax,!dax\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi,dax\")))]\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (true_regnum (operands[0]) == true_regnum (operands[1]))\n-    return \\\"sub %2,%0\\\";\n-  else\n-    {\n-      enum reg_class src1_class, src2_class, dst_class;\n-\n-      src1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n-      src2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n-      dst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n-\n-      /* If no extended registers are used, then the best way to handle\n-\t this is to copy the first source operand into the destination\n-\t and emit a two address subtraction.  */\n-      if (src1_class != EXTENDED_REGS\n-\t  && src2_class != EXTENDED_REGS\n-\t  && dst_class != EXTENDED_REGS\n-\t  && true_regnum (operands[0]) != true_regnum (operands[2]))\n-\treturn \\\"mov %1,%0\\;sub %2,%0\\\";\n-      return \\\"sub %2,%1,%0\\\";\n-    }\n-}\"\n+  {\n+    if (true_regnum (operands[0]) == true_regnum (operands[1]))\n+      return \\\"sub %2,%0\\\";\n+    else\n+      {\n+        enum reg_class src1_class, src2_class, dst_class;\n+\n+        src1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n+        src2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n+        dst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n+\n+        /* If no extended registers are used, then the best way to handle\n+\t   this is to copy the first source operand into the destination\n+\t   and emit a two address subtraction.  */\n+        if (src1_class != EXTENDED_REGS\n+\t    && src2_class != EXTENDED_REGS\n+\t    && dst_class != EXTENDED_REGS\n+\t    && true_regnum (operands[0]) != true_regnum (operands[2]))\n+\t  return \\\"mov %1,%0\\;sub %2,%0\\\";\n+        return \\\"sub %2,%1,%0\\\";\n+      }\n+  }\"\n+  [(set_attr \"timings\" \"11,22\")]\n )\n \n (define_insn \"*mn10300_subsi3\"\n@@ -1099,6 +1250,8 @@\n   ]\n   \"\"\n   \"sub %2,%0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 22)))]\n )\n \n (define_expand \"negsi2\"\n@@ -1127,16 +1280,20 @@\n   ]\n   \"TARGET_AM33\"\n   \"mul %1,%2,%H0,%L0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 24) (const_int 23)))]\n )\n \n (define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n+  [(set (match_operand:DI                          0 \"register_operand\" \"=dax\")\n         (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n                  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"TARGET_AM33\"\n   \"mulu %1,%2,%H0,%L0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 24) (const_int 23)))]\n )\n \n (define_expand \"mulsi3\"\n@@ -1163,6 +1320,7 @@\n   else\n     return \\\"mul %2,%0\\\";\n }\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 24) (const_int 23)))]\n )\n \n (define_insn \"*mn10300_mulsi3\"\n@@ -1179,13 +1337,15 @@\n   else\n     return \\\"mul %2,%0\\\";\n }\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+  \t      \t\t \t       (const_int 24) (const_int 23)))]\n )\n \n (define_expand \"udivmodsi4\"\n-  [(parallel [(set (match_operand:SI          0 \"nonimmediate_operand\")\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n \t\t   (udiv:SI (match_operand:SI 1 \"general_operand\")\n \t\t\t    (match_operand:SI 2 \"general_operand\")))\n-\t      (set (match_operand:SI          3 \"nonimmediate_operand\")\n+\t      (set (match_operand:SI          3 \"register_operand\")\n \t\t   (umod:SI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REG))\n \t     ])\n@@ -1199,11 +1359,11 @@\n    }\"\n )\n \n-(define_insn \"*udivmodsi4_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx\")\n+(define_insn \"*udivmodsi4\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"register_operand\" \"dx\")))\n-   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=&d\")\n+   (set (match_operand:SI          3 \"register_operand\" \"=&d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))\n    (clobber (reg:CC CC_REG))\n   ]\n@@ -1217,13 +1377,22 @@\n   else\n     return \\\"divu %2,%0\\;mov mdr,%3\\\";\n }\"\n+  ;; Timings:  AM33   AM34\n+  ;;  SUB       1/1    1/1\n+  ;;  MOV       1/1    1/1\n+  ;;  DIVU     38/39  42/43\n+  ;;  MOV       1/1    1/1\n+  ;;  --------------------\n+  ;;  total    41/42  45/46  (worst case sceanario)\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+  \t      \t\t \t       (const_int 4546) (const_int 4142)))]\n )\n \n (define_insn \"divmodsi4\"\n-  [(set (match_operand:SI          0 \"nonimmediate_operand\" \"=dx\")\n-\t(div:SI (match_operand:SI  1 \"general_operand\"       \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\"       \"dx\")))\n-   (set (match_operand:SI          3 \"nonimmediate_operand\" \"=d\")\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n+\t(div:SI (match_operand:SI  1 \"register_operand\"  \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\"  \"dx\")))\n+   (set (match_operand:SI          3 \"register_operand\" \"=d\")\n \t(mod:SI (match_dup 1) (match_dup 2)))\n    (clobber (reg:CC CC_REG))\n   ]\n@@ -1235,6 +1404,13 @@\n   else\n     return \\\"ext %0\\;div %2,%0\\;mov mdr,%3\\\";\n }\"\n+  ;; Timings:  AM33   AM34\n+  ;;  EXT       1/1    1/1\n+  ;;  DIV      38/39  42/43\n+  ;;  --------------------\n+  ;;  total    39/40  43/44  (worst case sceanario)\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+  \t      \t\t \t       (const_int 4344) (const_int 3940)))]\n )\n \n \f\n@@ -1259,44 +1435,40 @@\n    (clobber (reg:CC CC_REG))\n   ]\n   \"TARGET_AM33\"\n-  \"*\n-{\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xff)\n-    return \\\"extbu %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xffff)\n-    return \\\"exthu %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x7fffffff)\n-    return \\\"add %0,%0\\;lsr 1,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x3fffffff)\n-    return \\\"asl2 %0\\;lsr 2,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x1fffffff)\n-    return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x0fffffff)\n-    return \\\"asl2 %0\\;asl2 %0\\;lsr 4,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffe)\n-    return \\\"lsr 1,%0\\;add %0,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffc)\n-    return \\\"lsr 2,%0\\;asl2 %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff8)\n-    return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff0)\n-    return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2])\n-      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-    return \\\"mov %1,%0\\;and %2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"and %1,%2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[0])\n-      && true_regnum (operands[2]) == true_regnum (operands[0]))\n-    return \\\"and %1,%0\\\";\n-  return \\\"and %2,%0\\\";\n-}\"\n+  {\n+    if (CONST_INT_P (operands[2]))\n+      switch (INTVAL (operands[2]))\n+        {\n+        case 0xff:       return \"extbu %0\";\n+        case 0xffff:     return \"exthu %0\";\n+        case 0x7fffffff: return \"add  %0, %0; lsr 1, %0\";\n+        case 0x3fffffff: return \"asl2 %0; lsr 2, %0\";\n+        case 0x1fffffff: return \"add  %0, %0; asl2 %0; lsr 3, %0\";\n+        case 0x0fffffff: return \"asl2 %0; asl2 %0; lsr 4, %0\";\n+        case 0xfffffffe: return \"lsr 1, %0; add  %0, %0\";\n+        case 0xfffffffc: return \"lsr 2, %0; asl2 %0\";\n+        case 0xfffffff8: return \"lsr 3, %0; add  %0, %0; asl2 %0\";\n+        case 0xfffffff0: return \"lsr 4, %0; asl2 %0; asl2 %0\";\n+        }\n+      \n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2])\n+        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+      return \"mov %1, %0; and %2, %0\";\n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \"and %1, %2, %0\";\n+    if (REG_P (operands[2]) && REG_P (operands[0])\n+        && true_regnum (operands[2]) == true_regnum (operands[0]))\n+      return \"and %1, %0\";\n+\n+    return \"and %2, %0\";\n+  }\n+  [(set_attr \"timings\" \"33\")]\n )\n \n (define_insn \"*mn10300_andsi3\"\n@@ -1306,30 +1478,25 @@\n    (clobber (reg:CC CC_REG))\n   ]\n   \"\"\n-  \"*\n-{\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xff)\n-    return \\\"extbu %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xffff)\n-    return \\\"exthu %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x7fffffff)\n-    return \\\"add %0,%0\\;lsr 1,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x3fffffff)\n-    return \\\"asl2 %0\\;lsr 2,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x1fffffff)\n-    return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x0fffffff)\n-    return \\\"asl2 %0\\;asl2 %0\\;lsr 4,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffe)\n-    return \\\"lsr 1,%0\\;add %0,%0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffc)\n-    return \\\"lsr 2,%0\\;asl2 %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff8)\n-    return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff0)\n-    return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n-  return \\\"and %2,%0\\\";\n-}\"\n+  {\n+    if (CONST_INT_P (operands[2]))\n+      switch (INTVAL (operands[2]))\n+        {\n+        case 0xff:       return \"extbu %0\";\n+        case 0xffff:     return \"exthu %0\";\n+        case 0x7fffffff: return \"add  %0, %0; lsr 1, %0\";\n+        case 0x3fffffff: return \"asl2 %0; lsr 2, %0\";\n+        case 0x1fffffff: return \"add  %0, %0; asl2 %0; lsr 3, %0\";\n+        case 0x0fffffff: return \"asl2 %0; asl2 %0; lsr 4, %0\";\n+        case 0xfffffffe: return \"lsr 1, %0; add  %0, %0\";\n+        case 0xfffffffc: return \"lsr 2, %0; asl2 %0\";\n+        case 0xfffffff8: return \"lsr 3, %0; add  %0, %0; asl2 %0\";\n+        case 0xfffffff0: return \"lsr 4, %0; asl2 %0; asl2 %0\";\n+\t}\n+\n+    return \"and %2, %0\";\n+  }\n+  [(set_attr \"timings\" \"33\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -1354,33 +1521,35 @@\n   ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2])\n-      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-    return \\\"mov %1,%0\\;or %2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"or %1,%2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[0])\n-      && true_regnum (operands[2]) == true_regnum (operands[0]))\n-    return \\\"or %1,%0\\\";\n-  return \\\"or %2,%0\\\";\n-}\"\n+  {\n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2])\n+        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+      return \\\"mov %1,%0\\;or %2,%0\\\";\n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \\\"or %1,%2,%0\\\";\n+    if (REG_P (operands[2]) && REG_P (operands[0])\n+        && true_regnum (operands[2]) == true_regnum (operands[0]))\n+      return \\\"or %1,%0\\\";\n+    return \\\"or %2,%0\\\";\n+  }\"\n+  [(set_attr \"timings\" \"22\")]\n )\n \n (define_insn \"*mn10300_iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"\"\n   \"or %2,%0\"\n+  [(set_attr \"timings\" \"33\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -1398,40 +1567,42 @@\n   \"\")\n \n (define_insn \"*am33_xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx,!dax\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2])\n-      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-    return \\\"mov %1,%0\\;xor %2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[1])\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"xor %1,%2,%0\\\";\n-  if (REG_P (operands[2]) && REG_P (operands[0])\n-      && true_regnum (operands[2]) == true_regnum (operands[0]))\n-    return \\\"xor %1,%0\\\";\n-  return \\\"xor %2,%0\\\";\n-}\"\n+  {\n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2])\n+        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+      return \\\"mov %1,%0\\;xor %2,%0\\\";\n+    if (REG_P (operands[2]) && REG_P (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[1])\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \\\"xor %1,%2,%0\\\";\n+    if (REG_P (operands[2]) && REG_P (operands[0])\n+        && true_regnum (operands[2]) == true_regnum (operands[0]))\n+      return \\\"xor %1,%0\\\";\n+    return \\\"xor %2,%0\\\";\n+  }\"\n+  [(set_attr \"timings\" \"22\")]\n )\n \n (define_insn \"*mn10300_xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"\"\n   \"xor %2,%0\"\n+  [(set_attr \"timings\" \"11\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -1484,17 +1655,29 @@\n   \"@\n   bclr 255,%A0\n   clr %0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*byte_set\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int -1))\n    (clobber (reg:CC CC_REG))\n   ]\n-  \"( ! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n-                                && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n+  \"(! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n+                               && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n   \"@\n   bset 255,%A0\n   mov -1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*bit_clear1\"\n@@ -1508,6 +1691,12 @@\n   \"@\n   bclr %N1,%A0\n   and %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*bit_clear2\"\n@@ -1521,6 +1710,12 @@\n   \"@\n   bclr %U1,%A0\n   bclr %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 66)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*bit_set\"\n@@ -1534,6 +1729,12 @@\n   \"@\n   bset %U1,%A0\n   or %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"iorqi3\"\n@@ -1547,12 +1748,12 @@\n   \"\")\n \n (define_insn \"*am33_iorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,T,r\")\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\" \"=R,T,r\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n \t\t;; This constraint should really be nonmemory_operand,\n \t\t;; but making it general_operand, along with the\n-\t\t;; condition that not both input operands are MEMs, it\n-\t\t;; here helps combine do a better job.\n+\t\t;; condition that not both input operands are MEMs,\n+\t\t;; helps combine do a better job.\n \t\t(match_operand:QI 2 \"general_operand\" \"i,d,ir\")))\n    (clobber (reg:CC CC_REG))\n   ]\n@@ -1562,15 +1763,22 @@\n   bset %U2,%A0\n   bset %2,%0\n   or %2,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 66)\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*mn10300_iorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,T,d\")\n+  [(set (match_operand:QI         0 \"nonimmediate_operand\" \"=R,T,d\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n \t\t;; This constraint should really be nonmemory_operand,\n \t\t;; but making it general_operand, along with the\n-\t\t;; condition that not both input operands are MEMs, it\n-\t\t;; here helps combine do a better job.\n+\t\t;; condition that not both input operands are MEMs,\n+\t\t;; helps combine do a better job.\n \t\t(match_operand:QI 2 \"general_operand\" \"i,d,id\")))\n    (clobber (reg:CC CC_REG))\n   ]\n@@ -1579,6 +1787,13 @@\n   bset %U2,%A0\n   bset %2,%0\n   or %2,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 66) (const_int 77))\n+\t\t\t  (const_int 66)\n+\t\t\t  (const_int 11)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*test_int_bitfield\"\n@@ -1611,7 +1826,7 @@\n \n (define_insn \"*test_byte_bitfield\"\n   [(set (reg:CC CC_REG)\n-     (compare (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,dx\")\n+     (compare (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"R,dx\")\n \t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n \t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n \t      (const_int 0)))]\n@@ -1653,6 +1868,13 @@\n     output_asm_insn (\\\"btst %U1,%A0\\\", xoperands);\n   return \\\"\\\";\n }\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t \t\t(const_int 11) (const_int 22))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t  \t\t(const_int 44) (const_int 55))\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"*bit_test\"\n@@ -1663,18 +1885,27 @@\n   ]\n   \"\"\n   \"btst %1,%0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 22)))]\n )\n \n (define_insn \"*subreg_bit_test\"\n   [(set (reg:CC CC_REG)\n      (compare (and:SI\n-\t       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,dx\") 0)\n+\t       (subreg:SI (match_operand:QI 0 \"nonimmediate_operand\" \"R,dx\") 0)\n \t       (match_operand:SI 1 \"const_8bit_operand\" \"\"))\n \t      (const_int 0)))]\n   \"\"\n   \"@\n   btst %U1,%A0\n   btst %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 44) (const_int 55))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 11) (const_int 22))\n+\t\t\t ])\n+  ]\n )\n \n \f\n@@ -1750,11 +1981,19 @@\n       return mn10300_output_cmp (operands[0], insn);\n     return \\\"cmp %1,%0\\\";\n   }\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 11) (const_int 22))\n+\t\t\t  (const_int 22)\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"integer_conditional_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\" [(reg:CC CC_REG) (const_int 0)])\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC CC_REG) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -1805,6 +2044,8 @@\n \t\t\t  (match_operand:SF 1 \"nonmemory_operand\" \"fF\")))]\n   \"TARGET_AM33_2\"\n   \"fcmp %1, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 25)))]\n )\n \n (define_insn \"float_conditional_branch\"\n@@ -1815,6 +2056,8 @@\n \t\t      (pc)))]\n   \"TARGET_AM33_2\"\n   \"fb%b0 %1\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 44) (const_int 33)))]\n )\n \n ;; Unconditional and other jump instructions.\n@@ -1824,12 +2067,16 @@\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"jmp %l0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 44)))]\n )\n \n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))]\n   \"\"\n   \"jmp (%0)\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 33)))]\n )\n \n (define_expand \"builtin_setjmp_receiver\"\n@@ -1876,6 +2123,8 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"jmp (%0)\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 33)))]\n )\n \n ;; Call subroutine with no return value.\n@@ -1909,16 +2158,19 @@\n ;; NB: Mode on match_operand 0 deliberately omitted in\n ;;     order to be able to match UNSPECs in PIC mode.\n (define_insn \"call_internal\"\n-  [(call (mem:QI (match_operand 0 \"call_address_operand\" \"aS\"))\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  [(call (mem:QI (match_operand 0 \"call_address_operand\" \"a,S\"))\n+\t (match_operand:SI      1 \"general_operand\"      \"g,g\"))]\n   \"\"\n-  \"*\n-{\n-  if (REG_P (operands[0]))\n-    return \\\"calls %C0\\\";\n-  else\n-    return \\\"call %C0,[],0\\\";\n-}\"\n+  \"@\n+   calls %C0\n+   call %C0,[],0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 33) (const_int 44))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 55) (const_int 33))\n+\t\t\t ])\n+  ]\n )\n \n ;; Call subroutine, returning value in operand 0\n@@ -1956,17 +2208,20 @@\n ;; NB: Mode on match_operands 0 and 1 deliberately omitted\n ;;     in order to be able to match UNSPECs in PIC mode.\n (define_insn \"call_value_internal\"\n-  [(set (match_operand               0 \"register_operand\"    \"=dax\")\n-\t(call (mem:QI (match_operand 1 \"call_address_operand\" \"aS\"))\n-\t      (match_operand:SI      2 \"general_operand\"      \"g\")))]\n+  [(set (match_operand               0 \"register_operand\"    \"=dax,dax\")\n+\t(call (mem:QI (match_operand 1 \"call_address_operand\" \"a,S\"))\n+\t      (match_operand:SI      2 \"general_operand\"      \"g,g\")))]\n   \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"calls %C1\\\";\n-  else\n-    return \\\"call %C1,[],0\\\";\n-}\"\n+  \"@\n+   calls %C1\n+   call %C1,[],0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 33) (const_int 44))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 55) (const_int 33))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"untyped_call\"\n@@ -2000,16 +2255,16 @@\n ;; ----------------------------------------------------------------------\n \n (define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\")\n+  [(set (match_operand:SI 0 \"register_operand\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"general_operand\")))]\n+\t (match_operand:QI 1 \"nonimmediate_operand\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n+(define_insn \"*zero_extendqisi2_am33\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,dax,m,0,dax,m\")))]\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,dax,m,0,dax,m\")))]\n   \"TARGET_AM33\"\n   \"@\n   extbu %0\n@@ -2018,30 +2273,48 @@\n   extbu %0\n   mov %1,%0\\;extbu %0\n   movbu %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx\")\n+(define_insn \"*zero_extendqisi2_mn10300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,d,m\")))]\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,d,m\")))]\n   \"\"\n   \"@\n   extbu %0\n   mov %1,%0\\;extbu %0\n   movbu %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\")\n+  [(set (match_operand:SI 0 \"register_operand\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\")))]\n+\t (match_operand:HI 1 \"nonimmediate_operand\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n+(define_insn \"*zero_extendhisi2_am33\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,dax,m,0,dax,m\")))]\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,dax,m,0,dax,m\")))]\n   \"TARGET_AM33\"\n   \"@\n   exthu %0\n@@ -2050,77 +2323,99 @@\n   exthu %0\n   mov %1,%0\\;exthu %0\n   movhu %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t  (const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx\")\n+(define_insn \"*zero_extendhisi2_mn10300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,dx,m\")))]\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,dx,m\")))]\n   \"\"\n   \"@\n   exthu %0\n   mov %1,%0\\;exthu %0\n   movhu %1,%0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(const_int 11)\n+\t\t\t  (const_int 22)\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 13) (const_int 24))\n+\t\t\t ])\n+  ]\n )\n \n ;;- sign extension instructions\n \n (define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\")\n+  [(set (match_operand:SI 0 \"register_operand\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\")))]\n+\t (match_operand:QI 1 \"register_operand\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,!dax,!dax\")\n+(define_insn \"*extendqisi2_am33\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax,!dax\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,dx,0,dax\")))]\n+\t (match_operand:QI 1 \"register_operand\" \"0,dx,0,dax\")))]\n   \"TARGET_AM33\"\n   \"@\n   extb %0\n   mov %1,%0\\;extb %0\n   extb %0\n   mov %1,%0\\;extb %0\"\n+  [(set_attr \"timings\" \"11,22,11,22\")]\n )\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx\")\n+(define_insn \"*extendqisi2_mn10300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,dx\")))]\n+\t (match_operand:QI 1 \"register_operand\" \"0,dx\")))]\n   \"\"\n   \"@\n   extb %0\n   mov %1,%0\\;extb %0\"\n+  [(set_attr \"timings\" \"11,22\")]\n )\n \n (define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\")\n+  [(set (match_operand:SI 0 \"register_operand\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\")))]\n+\t (match_operand:HI 1 \"register_operand\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,!dax,!dax\")\n+(define_insn \"*extendhisi2_am33\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax,!dax\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,dax,0,dax\")))]\n+\t (match_operand:HI 1 \"register_operand\" \"0,dax,0,dax\")))]\n   \"TARGET_AM33\"\n   \"@\n   exth %0\n   mov %1,%0\\;exth %0\n   exth %0\n   mov %1,%0\\;exth %0\"\n+  [(set_attr \"timings\" \"11,22,11,22\")]\n )\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx\")\n+(define_insn \"*extendhisi2_mn10300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,dx\")))]\n+\t (match_operand:HI 1 \"register_operand\" \"0,dx\")))]\n   \"\"\n   \"@\n   exth %0\n   mov %1,%0\\;exth %0\"\n+  [(set_attr \"timings\" \"11,22\")]\n )\n \f\n ;; ----------------------------------------------------------------------\n@@ -2147,30 +2442,31 @@\n   ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n-    return \\\"add %0,%0\\\";\n+  {\n+    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n+      return \\\"add %0,%0\\\";\n \n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 2)\n-    return \\\"asl2 %0\\\";\n+    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 2)\n+      return \\\"asl2 %0\\\";\n \n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 3\n-      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n-    return \\\"asl2 %0\\;add %0,%0\\\";\n+    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 3\n+        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n+      return \\\"asl2 %0\\;add %0,%0\\\";\n \n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 4\n-      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n-    return \\\"asl2 %0\\;asl2 %0\\\";\n+    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 4\n+        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n+      return \\\"asl2 %0\\;asl2 %0\\\";\n \n-  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-    return \\\"asl %S2,%0\\\";\n+    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+      return \\\"asl %S2,%0\\\";\n \n-  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"mov %1,%0\\;asl %S2,%0\\\";\n-  return \\\"asl %2,%1,%0\\\";\n-}\"\n+    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \\\"mov %1,%0\\;asl %S2,%0\\\";\n+    return \\\"asl %2,%1,%0\\\";\n+  }\"\n+  [(set_attr \"timings\" \"22\")]\n )\n \n (define_insn \"*mn10300_ashlsi3\"\n@@ -2187,6 +2483,7 @@\n   asl2 %0\\;add %0,%0\n   asl2 %0\\;asl2 %0\n   asl %S2,%0\"\n+  [(set_attr \"timings\" \"11,11,22,22,11\")]\n )\n \n (define_expand \"lshrsi3\"\n@@ -2209,16 +2506,17 @@\n   ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-    return \\\"lsr %S2,%0\\\";\n-\n-  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"mov %1,%0\\;lsr %S2,%0\\\";\n-  return \\\"lsr %2,%1,%0\\\";\n-}\"\n+  {\n+    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+      return \\\"lsr %S2,%0\\\";\n+\n+    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \\\"mov %1,%0\\;lsr %S2,%0\\\";\n+    return \\\"lsr %2,%1,%0\\\";\n+  }\"\n+  [(set_attr \"timings\" \"22\")]\n )\n \n (define_insn \"*mn10300_lshrsi3\"\n@@ -2230,6 +2528,8 @@\n   ]\n   \"\"\n   \"lsr %S2,%0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 22)))]\n )\n \n (define_expand \"ashrsi3\"\n@@ -2252,16 +2552,17 @@\n   ]\n   \"TARGET_AM33\"\n   \"*\n-{\n-  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-    return \\\"asr %S2,%0\\\";\n-\n-  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-      && true_regnum (operands[0]) != true_regnum (operands[2]))\n-    return \\\"mov %1,%0\\;asr %S2,%0\\\";\n-  return \\\"asr %2,%1,%0\\\";\n-}\"\n+  {\n+    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+      return \\\"asr %S2,%0\\\";\n+\n+    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+        && true_regnum (operands[0]) != true_regnum (operands[2]))\n+      return \\\"mov %1,%0\\;asr %S2,%0\\\";\n+    return \\\"asr %2,%1,%0\\\";\n+  }\"\n+  [(set_attr \"timings\" \"22\")]\n )\n \n (define_insn \"*mn10300_ashrsi3\"\n@@ -2273,6 +2574,8 @@\n   ]\n   \"\"\n   \"asr %S2,%0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 11) (const_int 22)))]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -2352,6 +2655,8 @@\n   \"@\n    fabs %0\n    fabs %1, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 14)))]\n )\n \n (define_expand \"negdf2\"\n@@ -2421,6 +2726,8 @@\n   \"@\n    fneg %0\n    fneg %1, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 14)))]\n )\n \n (define_expand \"sqrtsf2\"\n@@ -2431,13 +2738,13 @@\n   ]\n   \"TARGET_AM33_2 && flag_unsafe_math_optimizations\"\n   \"\n-{\n-  rtx scratch = gen_reg_rtx (SFmode);\n-  emit_insn (gen_rsqrtsf2 (scratch, operands[1], CONST1_RTX (SFmode)));\n-  emit_insn (gen_divsf3 (operands[0], force_reg (SFmode, CONST1_RTX (SFmode)),\n-\t\t\t scratch));\n-  DONE;\n-}\")\n+  {\n+    rtx scratch = gen_reg_rtx (SFmode);\n+    emit_insn (gen_rsqrtsf2 (scratch, operands[1], CONST1_RTX (SFmode)));\n+    emit_insn (gen_divsf3 (operands[0], force_reg (SFmode, CONST1_RTX (SFmode)),\n+\t\t\t   scratch));\n+    DONE;\n+  }\")\n \n (define_insn \"rsqrtsf2\"\n   [(set (match_operand:SF                  0 \"register_operand\" \"=f,f\")\n@@ -2449,6 +2756,8 @@\n   \"@\n    frsqrt %0\n    frsqrt %1, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 4753) (const_int 2327)))]\n )\n \n (define_expand \"addsf3\"\n@@ -2471,6 +2780,13 @@\n   \"@\n    fadd %2, %0\n    fadd %2, %1, %0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 14))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 25))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"subsf3\"\n@@ -2493,6 +2809,13 @@\n   \"@\n    fsub %2, %0\n    fsub %2, %1, %0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 14))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 25))\n+\t\t\t ])\n+  ]\n )\n \n (define_expand \"mulsf3\"\n@@ -2515,6 +2838,13 @@\n   \"@\n    fmul %2, %0\n    fmul %2, %1, %0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 14))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 17) (const_int 25))\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"divsf3\"\n@@ -2527,6 +2857,13 @@\n   \"@\n    fdiv %2, %0\n    fdiv %2, %1, %0\"\n+  [(set_attr_alternative \"timings\"\n+\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 2531) (const_int 1216))\n+\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t\t(const_int 2531) (const_int 1317))\n+\t\t\t ])\n+  ]\n )\n \n (define_insn \"fmaddsf4\"\n@@ -2538,6 +2875,8 @@\n   ]\n   \"TARGET_AM33_2\"\n   \"fmadd %1, %2, %3, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 24)))]\n )\n \n (define_insn \"fmsubsf4\"\n@@ -2549,6 +2888,8 @@\n   ]\n   \"TARGET_AM33_2\"\n   \"fmsub %1, %2, %3, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 24)))]\n )\n \n (define_insn \"fnmaddsf4\"\n@@ -2560,6 +2901,8 @@\n   ]\n   \"TARGET_AM33_2\"\n   \"fnmadd %1, %2, %3, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 24)))]\n )\n \n (define_insn \"fnmsubsf4\"\n@@ -2571,6 +2914,8 @@\n   ]\n   \"TARGET_AM33_2\"\n   \"fnmsub %1, %2, %3, %0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 17) (const_int 24)))]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -2585,16 +2930,17 @@\n   [(return)]\n   \"\"\n   \"\n-{\n-  mn10300_expand_epilogue ();\n-  DONE;\n-}\")\n+  {\n+    mn10300_expand_epilogue ();\n+    DONE;\n+  }\")\n \n (define_insn \"return_internal\"\n   [(const_int 2)\n    (return)]\n   \"\"\n   \"rets\"\n+  [(set_attr \"timings\" \"66\")]\n )\n \n ;; This insn restores the callee saved registers and does a return, it\n@@ -2605,12 +2951,15 @@\n    (return)]\n   \"\"\n   \"*\n-{\n-  fputs (\\\"\\\\tret \\\", asm_out_file);\n-  mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n-  fprintf (asm_out_file, \\\",%d\\\\n\\\", (int) INTVAL (operands[0]));\n-  return \\\"\\\";\n-}\"\n+  {\n+    fputs (\\\"\\\\tret \\\", asm_out_file);\n+    mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n+    fprintf (asm_out_file, \\\",%d\\\\n\\\", (int) INTVAL (operands[0]));\n+    return \\\"\\\";\n+  }\"\n+  ;; Assumes that there will be no more than 8 regs to pop\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 1414) (const_int 1313)))]\n )\n \n ;; This instruction matches one generated by mn10300_gen_multiple_store()\n@@ -2619,14 +2968,17 @@\n     [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_operand 1 \"\" \"\")))])]\n   \"\"\n   \"*\n-{\n-  fputs (\\\"\\\\tmovm \\\", asm_out_file);\n-  mn10300_print_reg_list (asm_out_file,\n-                          mn10300_store_multiple_operation (operands[0],\n-\t\t\t\t\t\t            VOIDmode));\n-  fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n-  return \\\"\\\";\n-}\"\n+  {\n+    fputs (\\\"\\\\tmovm \\\", asm_out_file);\n+    mn10300_print_reg_list (asm_out_file,\n+                            mn10300_store_multiple_operation (operands[0],\n+\t\t\t\t\t\t              VOIDmode));\n+    fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n+    return \\\"\\\";\n+  }\"\n+  ;; Assume that no more than 8 registers will be pushed.\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t       (const_int 99) (const_int 88)))]\n )\n \n (define_insn \"return\"\n@@ -2643,6 +2995,7 @@\n   else\n     return \\\"rets\\\";\n }\"\n+  [(set_attr \"timings\" \"66\")]\n )\n \n ;; Try to combine consecutive updates of the stack pointer (or any\n@@ -2727,7 +3080,9 @@\n     [(set (mem:SI (reg:SI SP_REG)) (pc))\n      (use (match_operand 0 \"\" \"\"))])]\n   \"reload_completed\"\n-  \"calls %0\\;%0:\")\n+  \"calls %0\\;%0:\"\n+  [(set_attr \"timings\" \"44\")]\n+)\n \n (define_expand \"add_GOT_to_pic_reg\"\n   [(parallel [(set (reg:SI PIC_REG)"}, {"sha": "f2a434ef7382ca6cada97dc44c2b499084ce66e8", "filename": "gcc/config/mn10300/mn10300.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -1,6 +1,6 @@\n ; Options for the Matsushita MN10300 port of the compiler.\n \n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -26,6 +26,14 @@ mam33-2\n Target\n Target the AM33/2.0 processor\n \n+mam34\n+Target Report\n+Target the AM34 processor\n+\n+mtune=\n+Target RejectNegative Joined\n+Tune code for the given processor\n+\n mmult-bug\n Target Report Mask(MULT_BUG)\n Work around hardware multiply bug"}, {"sha": "93ed17d9572007fcbd50994f040de5c3c80ddc26", "filename": "gcc/config/mn10300/t-mn10300", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Ft-mn10300?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -29,8 +29,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT' > fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS = mam33/mam33-2\n-MULTILIB_DIRNAMES = am33 am33-2\n+MULTILIB_OPTIONS = mam33/mam33-2/mam34\n+MULTILIB_DIRNAMES = am33 am33-2 am34\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}, {"sha": "4a605e315c3dbea0ffbaaf54487494f767768de3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f637378c413c7f584910be7cc741b83cb40cd8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f3f637378c413c7f584910be7cc741b83cb40cd8", "patch": "@@ -734,8 +734,8 @@ Objective-C and Objective-C++ Dialects}.\n \n @emph{MN10300 Options}\n @gccoptlist{-mmult-bug  -mno-mult-bug @gol\n--mam33  -mno-am33 @gol\n--mam33-2  -mno-am33-2 @gol\n+-mno-am33 -mam33 -mam33-2 -mam34 @gol\n+-mtune=@var{cpu-type} @gol\n -mreturn-pointer-on-d0 @gol\n -mno-crt0  -mrelax}\n \n@@ -14915,6 +14915,21 @@ Generate code which uses features specific to the AM33 processor.\n Do not generate code which uses features specific to the AM33 processor.  This\n is the default.\n \n+@item -mam33-2\n+@opindex mam33-2\n+Generate code which uses features specific to the AM33/2.0 processor.\n+\n+@item -mam34\n+@opindex mam34\n+Generate code which uses features specific to the AM34 processor.\n+\n+@item -mtune=@var{cpu-type}\n+@opindex mtune\n+Use the timing characteristics of the indicated CPU type when\n+scheduling instructions.  This does not change the targeted processor\n+type.  The CPU type must be one of @samp{mn10300}, @samp{am33},\n+@samp{am33-2} or @samp{am34}.\n+\n @item -mreturn-pointer-on-d0\n @opindex mreturn-pointer-on-d0\n When generating a function which returns a pointer, return the pointer"}]}