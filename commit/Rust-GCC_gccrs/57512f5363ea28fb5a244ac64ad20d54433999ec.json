{"sha": "57512f5363ea28fb5a244ac64ad20d54433999ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1MTJmNTM2M2VhMjhmYjVhMjQ0YWM2NGFkMjBkNTQ0MzM5OTllYw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-10-11T23:39:21Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-10-11T23:39:21Z"}, "message": "re PR middle-end/37448 (cannot compile big function)\n\n2008-10-11  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/37448\n\t* df.h: (df_ref_class): New enum.\n\t(DF_REF_TYPE_NAMES, df_ref_extract): Removed.\n\t(struct df_ref): Replaced with union df_ref_d.\n\t(df_base_ref, df_artificial_ref, df_regular_ref, df_extract_ref):\n\tNew members of df_ref_d union.\n\t(DF_REF_REAL_REG, DF_REF_REGNO, DF_REF_REAL_LOC, DF_REF_REG,\n\tDF_REF_LOC, DF_REF_BB, DF_REF_INSN_INFO, DF_REF_INSN,\n\tDF_REF_CLASS, DF_REF_TYPE, DF_REF_CHAIN, DF_REF_ID, DF_REF_FLAGS,\n\tDF_REF_ORDER, DF_REF_IS_ARTIFICIAL, DF_REF_NEXT_REG,\n\tDF_REF_PREV_REG, DF_REF_EXTRACT_WIDTH, DF_REF_EXTRACT_OFFSET,\n\tDF_REF_EXTRACT_MODE): Replaced definition to access union\n\tdf_ref_d.\n       \t(DF_MWS_REG_DEF_P, DF_MWS_REG_USE_P, DF_MWS_TYPE): New macros.\n\t(df_scan_bb_info, df_bb_regno_first_def_find,\n\tdf_bb_regno_last_def_find, df_find_def, df_find_use,\n\tdf_refs_chain_dump, df_regs_chain_dump, df_ref_debug,\n\tdebug_df_ref, df_chain_create, df_chain_unlink, df_chain_copy,\n\tdf_ref_create, df_ref_remove, df_compute_accessed_bytes,\n\tdf_get_artificial_defs, df_get_artificial_uses, union_defs)\n\tReplaced struct df_ref * with df_ref.\n\t* df-scan.c (df_collection_rec, df_null_ref_rec,\n\tdf_ref_chain_delete_du_chain, df_ref_chain_delete, df_install_ref,\n\tdf_grow_ref_info, df_ref_create, df_reg_chain_unlink,\n\tdf_ref_compress_rec, df_ref_remove, df_ref_chain_delete_du_chain,\n\tdf_ref_chain_delete, df_free_collection_rec, df_insn_rescan,\n\tdf_reorganize_refs_by_reg_by_reg,\n\tdf_reorganize_refs_by_reg_by_insn, df_reorganize_refs_by_reg,\n\tdf_ref_change_reg_with_loc_1, df_notes_rescan, df_swap_refs,\n\tdf_sort_and_compress_refs, df_install_ref, df_install_refs,\n\tdf_ref_record, df_get_conditional_uses, df_get_call_refs,\n\tdf_bb_refs_record, df_exit_block_uses_collect,\n\tdf_record_exit_block_uses, df_reg_chain_mark,\n\tdf_reg_chain_verify_unmarked, df_refs_verify): Replaced struct\n\tdf_ref * with df_ref.\n\t(df_ref_record, df_uses_record, df_ref_create_structure): Added\n\tdf_ref_class parameter.\n\t(df_scan_problem_data): Added new pools for different types of\n\trefs.\n\t(df_scan_free_internal, df_scan_alloc, df_free_ref,\n\tdf_ref_create_structure): Processed new ref pools.\n\t(df_scan_start_dump): Added counts of refs and insns.\n\t(df_ref_create, df_notes_rescan, df_def_record_1, df_uses_record,\n\tdf_get_call_refs, df_insn_refs_collect, df_bb_refs_collect,\n\tdf_entry_block_defs_collect, df_exit_block_uses_collect): Added\n\tcode to pass df_ref_class down to ref creation functions.\n\t(df_reg_chain_unlink, df_ref_remove, df_ref_change_reg_with_loc_1,\n\tdf_reg_chain_mark): Use macros to hide references to df_refs.\n\t(df_ref_chain_change_bb): Removed.\n\t(df_insn_change_bb): Remove calls to df_ref_insn_change_bb.\n\t(df_ref_equal_p, df_ref_compare, df_ref_create_structure):\n\tEnhanced to understand df_ref union structure.\n\t* fwprop.c (local_ref_killed_between_p, use_killed_between,\n\tall_uses_available_at, update_df, try_fwprop_subst,\n\tforward_propagate_subreg, forward_propagate_and_simplify,\n\tforward_propagate_into, fwprop, fwprop_addr): Replaced struct\n\tdf_ref * with df_ref.\n\t(use_killed_between, all_uses_available_at): Use macros to hide\n\treferences to df_refs.\n\t* regstat.c (regstat_bb_compute_ri,\n\tregstat_bb_compute_calls_crossed): Replaced struct df_ref * with\n\tdf_ref.\n\t* see.c (see_handle_relevant_defs, see_handle_relevant_uses,\n\tsee_handle_relevant_refs, see_analyze_one_def,\n\tsee_update_relevancy, see_propagate_extensions_to_uses): Replaced\n\tstruct df_ref * with df_ref.\n\t* ra-conflict.c (record_one_conflict, clear_reg_in_live,\n\tglobal_conflicts): Replaced struct df_ref * with df_ref.\n\t* ddg.c (create_ddg_dep_from_intra_loop_link,\n\tadd_cross_iteration_register_deps, build_inter_loop_deps):\n\tReplaced struct df_ref * with df_ref.\n\t(create_ddg_dep_from_intra_loop_link,\n\tadd_cross_iteration_register_deps): Use macros to hide references\n\tto df_refs.\n\t* auto-inc-dec.c (find_inc, merge_in_block): Replaced struct\n\tdf_ref * with df_ref.\n\t* df-core.c (df_bb_regno_first_def_find,\n\tdf_bb_regno_last_def_find, df_find_def, df_find_use,\n\tdf_refs_chain_dump, df_regs_chain_dump, df_ref_debug,\n\tdebug_df_ref): Replaced struct df_ref * with df_ref.\n\t(df_mws_dump, df_ref_debug): Use macros to hide references to\n\tdf_refs.\n\t* cse.c (cse_extended_basic_block): Replaced struct df_ref * with\n\tdf_ref.\n\t* web.c (union_defs, entry_register, replace_ref, web_main):\n\tReplaced struct df_ref * with df_ref.\n\t(union_defs, replace_ref): Use macros to hide references to\n\tdf_refs.\n\t* global.c (compute_regs_asm_clobbered, build_insn_chain):\n\tReplaced struct df_ref * with df_ref.\n\t* ifcvt.c (dead_or_predicable): Replaced struct df_ref * with\n\tdf_ref.\n\t* sel-sched-ir.c (maybe_downgrade_id_to_use, setup_id_reg_sets, ):\n\tReplaced struct df_ref * with df_ref.\n\t* ira-lives.c (mark_ref_live, def_conflicts_with_inputs_p,\n\tmark_ref_dead, process_bb_node_lives): Replaced struct df_ref *\n\twith df_ref.\n\t* local-alloc.c (block_alloc): Replaced struct df_ref * with\n\tdf_ref.\n\t* df-byte-scan.c (df_compute_accessed_bytes_extract,\n\tdf_compute_accessed_bytes_strict_low_part,\n\tdf_compute_accessed_bytes_subreg, df_compute_accessed_bytes):\n\tReplaced struct df_ref * with df_ref.\n\t(df_compute_accessed_bytes): Use macros to hide references to\n\tdf_refs.\n\t* init-regs.c (initialize_uninitialized_regs): Replaced struct\n\tdf_ref * with df_ref.\n\t* loop-invariant.c (invariant_for_use, hash_invariant_expr_1,\n\tcheck_dependency, check_dependencies, record_uses): Replaced\n\tstruct df_ref * with df_ref.\n\t(invariant_for_use, check_dependency): Use macros to hide\n\treferences to df_refs.\n\t* loop-iv.c (iv_analysis_loop_init, iv_get_reaching_def,\n\tget_biv_step_1, get_biv_step, record_iv, iv_analyze_def,\n\tiv_analyze, biv_p): Replaced struct df_ref * with df_ref.\n\t(iv_analysis_loop_init, iv_get_reaching_def): Use macros to hide\n\treferences to df_refs.\n\t* ira.c (compute_regs_asm_clobbered): Replaced struct df_ref * with df_ref.\n\t* combine.c (create_log_links): Replaced struct df_ref * with df_ref.\n\t* df-problems.c (df_rd_bb_local_compute_process_def,\n\tdf_lr_bb_local_compute, df_live_bb_local_compute, df_chain_create,\n\tdf_chain_unlink_1, df_chain_unlink, df_chain_copy,\n\tdf_chain_remove_problem, df_chain_create_bb_process_use,\n\tdf_chain_create_bb, df_chain_top_dump, df_chain_bottom_dump,\n\tdf_byte_lr_check_regs, df_byte_lr_bb_local_compute,\n\tdf_byte_lr_simulate_defs, df_byte_lr_simulate_uses,\n\tdf_byte_lr_simulate_artificial_refs_at_top,\n\tdf_byte_lr_simulate_artificial_refs_at_end, df_create_unused_note,\n\tdf_note_bb_compute, df_note_add_problem, df_simulate_defs,\n\tdf_simulate_uses, df_simulate_artificial_refs_at_end,\n\tdf_simulate_artificial_refs_at_top): Replaced struct df_ref * with df_ref.\n\t(df_chain_dump): Use macros to hide\n\treferences to df_refs.\n\t* config/mips/mips.c (r10k_simplify_address): Replaced struct\n\tdf_ref * with df_ref.\n\t* dce.c (mark_nonreg_stores, delete_corresponding_reg_eq_notes,\n\tmark_artificial_uses, mark_reg_dependencies,\n\tbyte_dce_process_block): Replaced struct df_ref * with df_ref.\n\nFrom-SVN: r141067", "tree": {"sha": "1fd6fb73215a23b3f36551fffcc7f43df83fa870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd6fb73215a23b3f36551fffcc7f43df83fa870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57512f5363ea28fb5a244ac64ad20d54433999ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57512f5363ea28fb5a244ac64ad20d54433999ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57512f5363ea28fb5a244ac64ad20d54433999ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57512f5363ea28fb5a244ac64ad20d54433999ec/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4849e8364d789819c55b178c2e85a4b80d029bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4849e8364d789819c55b178c2e85a4b80d029bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4849e8364d789819c55b178c2e85a4b80d029bbf"}], "stats": {"total": 1540, "additions": 908, "deletions": 632}, "files": [{"sha": "64068cafc5875e898813282ac32c3e4e2a937e46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -1,3 +1,144 @@\n+2008-10-11  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/37448\n+\t* df.h: (df_ref_class): New enum.\n+\t(DF_REF_TYPE_NAMES, df_ref_extract): Removed.\n+\t(struct df_ref): Replaced with union df_ref_d.\n+\t(df_base_ref, df_artificial_ref, df_regular_ref, df_extract_ref):\n+\tNew members of df_ref_d union.\n+\t(DF_REF_REAL_REG, DF_REF_REGNO, DF_REF_REAL_LOC, DF_REF_REG,\n+\tDF_REF_LOC, DF_REF_BB, DF_REF_INSN_INFO, DF_REF_INSN,\n+\tDF_REF_CLASS, DF_REF_TYPE, DF_REF_CHAIN, DF_REF_ID, DF_REF_FLAGS,\n+\tDF_REF_ORDER, DF_REF_IS_ARTIFICIAL, DF_REF_NEXT_REG,\n+\tDF_REF_PREV_REG, DF_REF_EXTRACT_WIDTH, DF_REF_EXTRACT_OFFSET,\n+\tDF_REF_EXTRACT_MODE): Replaced definition to access union\n+\tdf_ref_d.\n+       \t(DF_MWS_REG_DEF_P, DF_MWS_REG_USE_P, DF_MWS_TYPE): New macros.\n+\t(df_scan_bb_info, df_bb_regno_first_def_find,\n+\tdf_bb_regno_last_def_find, df_find_def, df_find_use,\n+\tdf_refs_chain_dump, df_regs_chain_dump, df_ref_debug,\n+\tdebug_df_ref, df_chain_create, df_chain_unlink, df_chain_copy,\n+\tdf_ref_create, df_ref_remove, df_compute_accessed_bytes,\n+\tdf_get_artificial_defs, df_get_artificial_uses, union_defs)\n+\tReplaced struct df_ref * with df_ref.\n+\t* df-scan.c (df_collection_rec, df_null_ref_rec,\n+\tdf_ref_chain_delete_du_chain, df_ref_chain_delete, df_install_ref,\n+\tdf_grow_ref_info, df_ref_create, df_reg_chain_unlink,\n+\tdf_ref_compress_rec, df_ref_remove, df_ref_chain_delete_du_chain,\n+\tdf_ref_chain_delete, df_free_collection_rec, df_insn_rescan,\n+\tdf_reorganize_refs_by_reg_by_reg,\n+\tdf_reorganize_refs_by_reg_by_insn, df_reorganize_refs_by_reg,\n+\tdf_ref_change_reg_with_loc_1, df_notes_rescan, df_swap_refs,\n+\tdf_sort_and_compress_refs, df_install_ref, df_install_refs,\n+\tdf_ref_record, df_get_conditional_uses, df_get_call_refs,\n+\tdf_bb_refs_record, df_exit_block_uses_collect,\n+\tdf_record_exit_block_uses, df_reg_chain_mark,\n+\tdf_reg_chain_verify_unmarked, df_refs_verify): Replaced struct\n+\tdf_ref * with df_ref.\n+\t(df_ref_record, df_uses_record, df_ref_create_structure): Added\n+\tdf_ref_class parameter.\n+\t(df_scan_problem_data): Added new pools for different types of\n+\trefs.\n+\t(df_scan_free_internal, df_scan_alloc, df_free_ref,\n+\tdf_ref_create_structure): Processed new ref pools.\n+\t(df_scan_start_dump): Added counts of refs and insns.\n+\t(df_ref_create, df_notes_rescan, df_def_record_1, df_uses_record,\n+\tdf_get_call_refs, df_insn_refs_collect, df_bb_refs_collect,\n+\tdf_entry_block_defs_collect, df_exit_block_uses_collect): Added\n+\tcode to pass df_ref_class down to ref creation functions.\n+\t(df_reg_chain_unlink, df_ref_remove, df_ref_change_reg_with_loc_1,\n+\tdf_reg_chain_mark): Use macros to hide references to df_refs.\n+\t(df_ref_chain_change_bb): Removed.\n+\t(df_insn_change_bb): Remove calls to df_ref_insn_change_bb.\n+\t(df_ref_equal_p, df_ref_compare, df_ref_create_structure):\n+\tEnhanced to understand df_ref union structure.\n+\t* fwprop.c (local_ref_killed_between_p, use_killed_between,\n+\tall_uses_available_at, update_df, try_fwprop_subst,\n+\tforward_propagate_subreg, forward_propagate_and_simplify,\n+\tforward_propagate_into, fwprop, fwprop_addr): Replaced struct\n+\tdf_ref * with df_ref.\n+\t(use_killed_between, all_uses_available_at): Use macros to hide\n+\treferences to df_refs.\n+\t* regstat.c (regstat_bb_compute_ri,\n+\tregstat_bb_compute_calls_crossed): Replaced struct df_ref * with\n+\tdf_ref.\n+\t* see.c (see_handle_relevant_defs, see_handle_relevant_uses,\n+\tsee_handle_relevant_refs, see_analyze_one_def,\n+\tsee_update_relevancy, see_propagate_extensions_to_uses): Replaced\n+\tstruct df_ref * with df_ref.\n+\t* ra-conflict.c (record_one_conflict, clear_reg_in_live,\n+\tglobal_conflicts): Replaced struct df_ref * with df_ref.\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link,\n+\tadd_cross_iteration_register_deps, build_inter_loop_deps):\n+\tReplaced struct df_ref * with df_ref.\n+\t(create_ddg_dep_from_intra_loop_link,\n+\tadd_cross_iteration_register_deps): Use macros to hide references\n+\tto df_refs.\n+\t* auto-inc-dec.c (find_inc, merge_in_block): Replaced struct\n+\tdf_ref * with df_ref.\n+\t* df-core.c (df_bb_regno_first_def_find,\n+\tdf_bb_regno_last_def_find, df_find_def, df_find_use,\n+\tdf_refs_chain_dump, df_regs_chain_dump, df_ref_debug,\n+\tdebug_df_ref): Replaced struct df_ref * with df_ref.\n+\t(df_mws_dump, df_ref_debug): Use macros to hide references to\n+\tdf_refs.\n+\t* cse.c (cse_extended_basic_block): Replaced struct df_ref * with\n+\tdf_ref.\n+\t* web.c (union_defs, entry_register, replace_ref, web_main):\n+\tReplaced struct df_ref * with df_ref.\n+\t(union_defs, replace_ref): Use macros to hide references to\n+\tdf_refs.\n+\t* global.c (compute_regs_asm_clobbered, build_insn_chain):\n+\tReplaced struct df_ref * with df_ref.\n+\t* ifcvt.c (dead_or_predicable): Replaced struct df_ref * with\n+\tdf_ref.\n+\t* sel-sched-ir.c (maybe_downgrade_id_to_use, setup_id_reg_sets, ):\n+\tReplaced struct df_ref * with df_ref.\n+\t* ira-lives.c (mark_ref_live, def_conflicts_with_inputs_p,\n+\tmark_ref_dead, process_bb_node_lives): Replaced struct df_ref *\n+\twith df_ref.\n+\t* local-alloc.c (block_alloc): Replaced struct df_ref * with\n+\tdf_ref.\n+\t* df-byte-scan.c (df_compute_accessed_bytes_extract,\n+\tdf_compute_accessed_bytes_strict_low_part,\n+\tdf_compute_accessed_bytes_subreg, df_compute_accessed_bytes):\n+\tReplaced struct df_ref * with df_ref.\n+\t(df_compute_accessed_bytes): Use macros to hide references to\n+\tdf_refs.\n+\t* init-regs.c (initialize_uninitialized_regs): Replaced struct\n+\tdf_ref * with df_ref.\n+\t* loop-invariant.c (invariant_for_use, hash_invariant_expr_1,\n+\tcheck_dependency, check_dependencies, record_uses): Replaced\n+\tstruct df_ref * with df_ref.\n+\t(invariant_for_use, check_dependency): Use macros to hide\n+\treferences to df_refs.\n+\t* loop-iv.c (iv_analysis_loop_init, iv_get_reaching_def,\n+\tget_biv_step_1, get_biv_step, record_iv, iv_analyze_def,\n+\tiv_analyze, biv_p): Replaced struct df_ref * with df_ref.\n+\t(iv_analysis_loop_init, iv_get_reaching_def): Use macros to hide\n+\treferences to df_refs.\n+\t* ira.c (compute_regs_asm_clobbered): Replaced struct df_ref * with df_ref.\n+\t* combine.c (create_log_links): Replaced struct df_ref * with df_ref.\n+\t* df-problems.c (df_rd_bb_local_compute_process_def,\n+\tdf_lr_bb_local_compute, df_live_bb_local_compute, df_chain_create,\n+\tdf_chain_unlink_1, df_chain_unlink, df_chain_copy,\n+\tdf_chain_remove_problem, df_chain_create_bb_process_use,\n+\tdf_chain_create_bb, df_chain_top_dump, df_chain_bottom_dump,\n+\tdf_byte_lr_check_regs, df_byte_lr_bb_local_compute,\n+\tdf_byte_lr_simulate_defs, df_byte_lr_simulate_uses,\n+\tdf_byte_lr_simulate_artificial_refs_at_top,\n+\tdf_byte_lr_simulate_artificial_refs_at_end, df_create_unused_note,\n+\tdf_note_bb_compute, df_note_add_problem, df_simulate_defs,\n+\tdf_simulate_uses, df_simulate_artificial_refs_at_end,\n+\tdf_simulate_artificial_refs_at_top): Replaced struct df_ref * with df_ref.\n+\t(df_chain_dump): Use macros to hide\n+\treferences to df_refs.\n+\t* config/mips/mips.c (r10k_simplify_address): Replaced struct\n+\tdf_ref * with df_ref.\n+\t* dce.c (mark_nonreg_stores, delete_corresponding_reg_eq_notes,\n+\tmark_artificial_uses, mark_reg_dependencies,\n+\tbyte_dce_process_block): Replaced struct df_ref * with df_ref.\n+\n 2008-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.h (contains_packed_reference): Mention ARRAY_RANGE_REF in"}, {"sha": "16b708c925248691f7423164cd04360f61236eae", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -1007,7 +1007,7 @@ find_inc (bool first_try)\n   rtx insn;\n   basic_block bb = BASIC_BLOCK (BLOCK_NUM (mem_insn.insn));\n   rtx other_insn;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n \n   /* Make sure this reg appears only once in this insn.  */\n   if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg0, 1) != 1)\n@@ -1053,7 +1053,7 @@ find_inc (bool first_try)\n      assigned to by the mem insn.  */\n   for (def_rec = DF_INSN_DEFS (mem_insn.insn); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       unsigned int regno = DF_REF_REGNO (def);\n       if ((regno == REGNO (inc_insn.reg0)) \n \t  || (regno == REGNO (inc_insn.reg_res)))\n@@ -1454,20 +1454,20 @@ merge_in_block (int max_reg, basic_block bb)\n \t and there is noting to update.  */\n       if (DF_INSN_UID_GET(uid))\n \t{\n-\t  struct df_ref **def_rec;\n-\t  struct df_ref **use_rec;\n+\t  df_ref *def_rec;\n+\t  df_ref *use_rec;\n \t  /* Need to update next use.  */\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      reg_next_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_inc_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_def[DF_REF_REGNO (def)] = insn;\n \t    }\n \t  \n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      reg_next_use[DF_REF_REGNO (use)] = insn;\n \t      if (insn_is_add_or_inc)\n \t\treg_next_inc_use[DF_REF_REGNO (use)] = insn;"}, {"sha": "5821301d72cdf7753597a1fad86ff82e5080af4c", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -900,7 +900,7 @@ create_log_links (void)\n {\n   basic_block bb;\n   rtx *next_use, insn;\n-  struct df_ref **def_vec, **use_vec;\n+  df_ref *def_vec, *use_vec;\n \n   next_use = XCNEWVEC (rtx, max_reg_num ());\n \n@@ -925,7 +925,7 @@ create_log_links (void)\n \n           for (def_vec = DF_INSN_DEFS (insn); *def_vec; def_vec++)\n             {\n-\t      struct df_ref *def = *def_vec;\n+\t      df_ref def = *def_vec;\n               int regno = DF_REF_REGNO (def);\n               rtx use_insn;\n \n@@ -979,7 +979,7 @@ create_log_links (void)\n \n           for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n             {\n-\t      struct df_ref *use = *use_vec;\n+\t      df_ref use = *use_vec;\n \t      int regno = DF_REF_REGNO (use);\n \n               /* Do not consider the usage of the stack pointer"}, {"sha": "8508f61fe2cc3660c36ea861706a83403e196d4e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -12105,7 +12105,7 @@ static rtx\n r10k_simplify_address (rtx x, rtx insn)\n {\n   rtx newx, op0, op1, set, def_insn, note;\n-  struct df_ref *use, *def;\n+  df_ref use, def;\n   struct df_link *defs;\n \n   newx = NULL_RTX;"}, {"sha": "ed7d885643921b03cb5b30b88f1c92d28fa8ead6", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -6008,11 +6008,11 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t edge pointing to that bb.  */\n       if (bb_has_eh_pred (bb))\n \t{\n-\t  struct df_ref **def_rec;\n+\t  df_ref *def_rec;\n \n \t  for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t\tinvalidate (DF_REF_REG (def), GET_MODE (DF_REF_REG (def)));\n \t    }"}, {"sha": "63ea3806606aede778a8ee6ccb5ae262cfc86997", "filename": "gcc/dce.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -218,18 +218,18 @@ mark_nonreg_stores (rtx body, rtx insn, bool fast)\n static void\n delete_corresponding_reg_eq_notes (rtx insn)\n {\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       unsigned int regno = DF_REF_REGNO (def);\n       /* This loop is a little tricky.  We cannot just go down the\n \t chain because it is being modified by the actions in the\n \t loop.  So we just get the head.  We plan to drain the list\n \t anyway.  */\n       while (DF_REG_EQ_USE_CHAIN (regno))\n \t{\n-\t  struct df_ref *eq_use = DF_REG_EQ_USE_CHAIN (regno);\n+\t  df_ref eq_use = DF_REG_EQ_USE_CHAIN (regno);\n \t  rtx noted_insn = DF_REF_INSN (eq_use);\n \t  rtx note = find_reg_note (noted_insn, REG_EQUAL, NULL_RTX);\n \t  if (!note)\n@@ -330,7 +330,7 @@ mark_artificial_uses (void)\n {\n   basic_block bb;\n   struct df_link *defs;\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n \n   FOR_ALL_BB (bb)\n     {\n@@ -349,11 +349,11 @@ static void\n mark_reg_dependencies (rtx insn)\n {\n   struct df_link *defs;\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n \n   for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Processing use of \");\n@@ -480,7 +480,7 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n   rtx insn;\n   bool block_changed;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n \n   if (redo_out)\n     {\n@@ -511,7 +511,7 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t/* The insn is needed if there is someone who uses the output.  */\n \tfor (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n \t  {\n-\t    struct df_ref *def = *def_rec;\n+\t    df_ref def = *def_rec;\n \t    unsigned int last;\n \t    unsigned int dregno = DF_REF_REGNO (def);\n \t    unsigned int start = df_byte_lr_get_regno_start (dregno);\n@@ -584,7 +584,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n   rtx insn;\n   bool block_changed;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n \n   if (redo_out)\n     {"}, {"sha": "6ae2ae25b65c1fd1ac2bba01f98df81666852fd8", "filename": "gcc/ddg.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -183,13 +183,13 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n       if (set && REG_P (SET_DEST (set)))\n         {\n           int regno = REGNO (SET_DEST (set));\n-          struct df_ref *first_def;\n+          df_ref first_def;\n           struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n \n           first_def = df_bb_regno_first_def_find (g->bb, regno);\n           gcc_assert (first_def);\n \n-          if (bitmap_bit_p (bb_info->gen, first_def->id))\n+          if (bitmap_bit_p (bb_info->gen, DF_REF_ID (first_def)))\n             return;\n         }\n     }\n@@ -239,7 +239,7 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n    and anti-dependences from its uses in the current iteration to the\n    first definition in the next iteration.  */\n static void\n-add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n+add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n {\n   int regno = DF_REF_REGNO (last_def);\n   struct df_link *r_use;\n@@ -250,14 +250,14 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n #ifdef ENABLE_CHECKING\n   struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n #endif\n-  struct df_ref *first_def = df_bb_regno_first_def_find (g->bb, regno);\n+  df_ref first_def = df_bb_regno_first_def_find (g->bb, regno);\n \n   gcc_assert (last_def_node);\n   gcc_assert (first_def);\n \n #ifdef ENABLE_CHECKING\n-  if (last_def->id != first_def->id)\n-    gcc_assert (!bitmap_bit_p (bb_info->gen, first_def->id));\n+  if (DF_REF_ID (last_def) != DF_REF_ID (first_def))\n+    gcc_assert (!bitmap_bit_p (bb_info->gen, DF_REF_ID (first_def)));\n #endif\n \n   /* Create inter-loop true dependences and anti dependences.  */\n@@ -293,7 +293,7 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n \n \t  gcc_assert (first_def_node);\n \n-          if (last_def->id != first_def->id\n+          if (DF_REF_ID (last_def) != DF_REF_ID (first_def)\n               || !flag_modulo_sched_allow_regmoves)\n             create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n                                     REG_DEP, 1);\n@@ -311,7 +311,7 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n     {\n       ddg_node_ptr dest_node;\n \n-      if (last_def->id == first_def->id)\n+      if (DF_REF_ID (last_def) == DF_REF_ID (first_def))\n \treturn;\n \n       dest_node = get_node_of_insn (g, DF_REF_INSN (first_def));\n@@ -333,7 +333,7 @@ build_inter_loop_deps (ddg_ptr g)\n   /* Find inter-loop register output, true and anti deps.  */\n   EXECUTE_IF_SET_IN_BITMAP (rd_bb_info->gen, 0, rd_num, bi)\n   {\n-    struct df_ref *rd = DF_DEFS_GET (rd_num);\n+    df_ref rd = DF_DEFS_GET (rd_num);\n \n     add_cross_iteration_register_deps (g, rd);\n   }"}, {"sha": "7e4db4b35bc2c896192edc68ba902528170e8ce5", "filename": "gcc/df-byte-scan.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-byte-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-byte-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-byte-scan.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n    df_compute_accessed_bytes for a description of MM.  */ \n \n static bool \n-df_compute_accessed_bytes_extract (struct df_ref *ref,\n+df_compute_accessed_bytes_extract (df_ref ref,\n \t\t\t\t   enum df_mm mm ,\n \t\t\t\t   unsigned int *start_byte, \n \t\t\t\t   unsigned int *last_byte)\n@@ -148,7 +148,7 @@ df_compute_accessed_bytes_extract (struct df_ref *ref,\n    otherwise and set START_BYTE and LAST_BYTE.  */ \n \n static bool \n-df_compute_accessed_bytes_strict_low_part (struct df_ref *ref, \n+df_compute_accessed_bytes_strict_low_part (df_ref ref, \n \t\t\t\t\t   unsigned int *start_byte, \n \t\t\t\t\t   unsigned int *last_byte)\n {\n@@ -200,7 +200,7 @@ df_compute_accessed_bytes_strict_low_part (struct df_ref *ref,\n    otherwise and set START_BYTE and LAST_BYTE.  */ \n \n static bool \n-df_compute_accessed_bytes_subreg (struct df_ref *ref, unsigned int *start_byte, \n+df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte, \n \t\t\t\t  unsigned int *last_byte)\n \n {\n@@ -229,7 +229,7 @@ df_compute_accessed_bytes_subreg (struct df_ref *ref, unsigned int *start_byte,\n     return true;\n \n   /* Defs and uses are different in the amount of the reg that touch.  */\n-  if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n+  if (DF_REF_REG_DEF_P (ref))\n     {\n       /* This is an lvalue.  */ \n \n@@ -300,14 +300,14 @@ df_compute_accessed_bytes_subreg (struct df_ref *ref, unsigned int *start_byte,\n    This means that this use can be ignored.  */\n \n bool \n-df_compute_accessed_bytes (struct df_ref *ref, enum df_mm mm, \n+df_compute_accessed_bytes (df_ref ref, enum df_mm mm, \n \t\t\t   unsigned int *start_byte, \n \t\t\t   unsigned int *last_byte)\n {\n   if (!dbg_cnt (df_byte_scan))\n     return true;\n \n-  if (DF_REF_TYPE (ref) != DF_REF_REG_DEF \n+  if (!DF_REF_REG_DEF_P (ref) \n       && DF_REF_FLAGS_IS_SET (ref, DF_REF_READ_WRITE))\n     {\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_PRE_POST_MODIFY))"}, {"sha": "1ad7ab104643dea1bbe6e4a9c1bdeac6e6ad2b2b", "filename": "gcc/df-core.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -1725,11 +1725,11 @@ df_set_clean_cfg (void)\n \n /* Return first def of REGNO within BB.  */\n \n-struct df_ref *\n+df_ref \n df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   unsigned int uid;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -1740,7 +1740,7 @@ df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n       uid = INSN_UID (insn);\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  if (DF_REF_REGNO (def) == regno)\n \t    return def;\n \t}\n@@ -1751,11 +1751,11 @@ df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n \n /* Return last def of REGNO within BB.  */\n \n-struct df_ref *\n+df_ref \n df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   unsigned int uid;\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n@@ -1766,7 +1766,7 @@ df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n       uid = INSN_UID (insn);\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  if (DF_REF_REGNO (def) == regno)\n \t    return def;\n \t}\n@@ -1778,11 +1778,11 @@ df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n /* Finds the reference corresponding to the definition of REG in INSN.\n    DF is the dataflow object.  */\n \n-struct df_ref *\n+df_ref \n df_find_def (rtx insn, rtx reg)\n {\n   unsigned int uid;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -1791,7 +1791,7 @@ df_find_def (rtx insn, rtx reg)\n   uid = INSN_UID (insn);\n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (rtx_equal_p (DF_REF_REAL_REG (def), reg))\n \treturn def;\n     }\n@@ -1812,11 +1812,11 @@ df_reg_defined (rtx insn, rtx reg)\n /* Finds the reference corresponding to the use of REG in INSN.\n    DF is the dataflow object.  */\n   \n-struct df_ref *\n+df_ref \n df_find_use (rtx insn, rtx reg)\n {\n   unsigned int uid;\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -1825,14 +1825,14 @@ df_find_use (rtx insn, rtx reg)\n   uid = INSN_UID (insn);\n   for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n \treturn use;\n     } \n   if (df->changeable_flags & DF_EQ_NOTES)\n     for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n       {\n-\tstruct df_ref *use = *use_rec;\n+\tdf_ref use = *use_rec;\n \tif (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n \t  return use; \n       }\n@@ -2064,12 +2064,12 @@ df_dump_bottom (basic_block bb, FILE *file)\n \n \n void\n-df_refs_chain_dump (struct df_ref **ref_rec, bool follow_chain, FILE *file)\n+df_refs_chain_dump (df_ref *ref_rec, bool follow_chain, FILE *file)\n {\n   fprintf (file, \"{ \");\n   while (*ref_rec)\n     {\n-      struct df_ref *ref = *ref_rec;\n+      df_ref ref = *ref_rec;\n       fprintf (file, \"%c%d(%d)\",\n \t       DF_REF_REG_DEF_P (ref) ? 'd' : (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE) ? 'e' : 'u',\n \t       DF_REF_ID (ref),\n@@ -2085,7 +2085,7 @@ df_refs_chain_dump (struct df_ref **ref_rec, bool follow_chain, FILE *file)\n /* Dump either a ref-def or reg-use chain.  */\n \n void\n-df_regs_chain_dump (struct df_ref *ref,  FILE *file)\n+df_regs_chain_dump (df_ref ref,  FILE *file)\n {\n   fprintf (file, \"{ \");\n   while (ref)\n@@ -2094,7 +2094,7 @@ df_regs_chain_dump (struct df_ref *ref,  FILE *file)\n \t       DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n \t       DF_REF_ID (ref),\n \t       DF_REF_REGNO (ref));\n-      ref = ref->next_reg;\n+      ref = DF_REF_NEXT_REG (ref);\n     }\n   fprintf (file, \"}\");\n }\n@@ -2106,7 +2106,7 @@ df_mws_dump (struct df_mw_hardreg **mws, FILE *file)\n   while (*mws)\n     {\n       fprintf (file, \"mw %c r[%d..%d]\\n\", \n-\t       ((*mws)->type == DF_REF_REG_DEF) ? 'd' : 'u',\n+\t       (DF_MWS_REG_DEF_P (*mws)) ? 'd' : 'u',\n \t       (*mws)->start_regno, (*mws)->end_regno);\n       mws++;\n     }\n@@ -2185,15 +2185,15 @@ df_regno_debug (unsigned int regno, FILE *file)\n \n \n void\n-df_ref_debug (struct df_ref *ref, FILE *file)\n+df_ref_debug (df_ref ref, FILE *file)\n {\n   fprintf (file, \"%c%d \",\n \t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n \t   DF_REF_ID (ref));\n   fprintf (file, \"reg %d bb %d insn %d flag 0x%x type 0x%x \",\n \t   DF_REF_REGNO (ref),\n \t   DF_REF_BBNO (ref),\n-\t   DF_REF_INSN_INFO (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1,\n+\t   DF_REF_IS_ARTIFICIAL (ref) ? -1 : DF_REF_INSN_UID (ref),\n \t   DF_REF_FLAGS (ref),\n \t   DF_REF_TYPE (ref));\n   if (DF_REF_LOC (ref))\n@@ -2229,7 +2229,7 @@ debug_df_regno (unsigned int regno)\n \n \n void\n-debug_df_ref (struct df_ref *ref)\n+debug_df_ref (df_ref ref)\n {\n   df_ref_debug (ref, stderr);\n }"}, {"sha": "25dea30817b9440236d30510839157d1b7e122ff", "filename": "gcc/df-problems.c", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -128,7 +128,7 @@ df_chain_dump (struct df_link *link, FILE *file)\n \t       DF_REF_REG_DEF_P (link->ref) ? 'd' : 'u',\n \t       DF_REF_ID (link->ref),\n \t       DF_REF_BBNO (link->ref),\n-\t       DF_REF_INSN_INFO (link->ref) ? DF_REF_INSN_UID (link->ref) : -1);\n+\t       DF_REF_IS_ARTIFICIAL (link->ref) ? -1 : DF_REF_INSN_UID (link->ref));\n     }\n   fprintf (file, \"}\");\n }\n@@ -320,12 +320,12 @@ df_rd_alloc (bitmap all_blocks)\n \n static void\n df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n-\t\t\t\t    struct df_ref **def_rec,\n+\t\t\t\t    df_ref *def_rec,\n \t\t\t\t    enum df_ref_flags top_flag)\n {\n   while (*def_rec)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n \t  unsigned int regno = DF_REF_REGNO (def);\n@@ -795,13 +795,13 @@ df_lr_bb_local_compute (unsigned int bb_index)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n \n   /* Process the registers set in an exception handler.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -813,7 +813,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n   /* Process the hardware registers that are always live.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \tbitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n@@ -828,7 +828,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  /* If the def is to only part of the reg, it does\n \t     not kill the other defs that reach here.  */\n \t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n@@ -841,7 +841,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  /* Add use to set of uses in this BB.  */\n \t  bitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n \t}\n@@ -852,7 +852,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n      goto.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -865,7 +865,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n   /* Process the uses that are live into an exception handler.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n \tbitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n@@ -1415,7 +1415,7 @@ df_live_bb_local_compute (unsigned int bb_index)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   int luid = 0;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -1438,7 +1438,7 @@ df_live_bb_local_compute (unsigned int bb_index)\n       luid++;\n       for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  unsigned int regno = DF_REF_REGNO (def);\n \n \t  if (DF_REF_FLAGS_IS_SET (def,\n@@ -1457,7 +1457,7 @@ df_live_bb_local_compute (unsigned int bb_index)\n \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       bitmap_set_bit (bb_info->gen, DF_REF_REGNO (def));\n     }\n }\n@@ -1858,7 +1858,7 @@ df_live_verify_transfer_functions (void)\n /* Create a du or ud chain from SRC to DST and link it into SRC.   */\n \n struct df_link *\n-df_chain_create (struct df_ref *src, struct df_ref *dst)\n+df_chain_create (df_ref src, df_ref dst)\n {\n   struct df_link *head = DF_REF_CHAIN (src);\n   struct df_link *link = (struct df_link *) pool_alloc (df_chain->block_pool);\n@@ -1873,7 +1873,7 @@ df_chain_create (struct df_ref *src, struct df_ref *dst)\n /* Delete any du or ud chains that start at REF and point to\n    TARGET.  */ \n static void\n-df_chain_unlink_1 (struct df_ref *ref, struct df_ref *target)\n+df_chain_unlink_1 (df_ref ref, df_ref target)\n {\n   struct df_link *chain = DF_REF_CHAIN (ref);\n   struct df_link *prev = NULL;\n@@ -1898,7 +1898,7 @@ df_chain_unlink_1 (struct df_ref *ref, struct df_ref *target)\n /* Delete a du or ud chain that leave or point to REF.  */\n \n void\n-df_chain_unlink (struct df_ref *ref)\n+df_chain_unlink (df_ref ref)\n {\n   struct df_link *chain = DF_REF_CHAIN (ref);\n   while (chain)\n@@ -1917,7 +1917,7 @@ df_chain_unlink (struct df_ref *ref)\n    TO_REF.  */ \n \n void \n-df_chain_copy (struct df_ref *to_ref, \n+df_chain_copy (df_ref to_ref, \n \t       struct df_link *from_ref)\n {\n   while (from_ref)\n@@ -1943,8 +1943,8 @@ df_chain_remove_problem (void)\n   EXECUTE_IF_SET_IN_BITMAP (df_chain->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       rtx insn;\n-      struct df_ref **def_rec;\n-      struct df_ref **use_rec;\n+      df_ref *def_rec;\n+      df_ref *use_rec;\n       basic_block bb = BASIC_BLOCK (bb_index);\n \n       if (df_chain_problem_p (DF_DU_CHAIN))\n@@ -2015,15 +2015,15 @@ df_chain_reset (bitmap blocks_to_clear ATTRIBUTE_UNUSED)\n \n static void\n df_chain_create_bb_process_use (bitmap local_rd,\n-\t\t\t\tstruct df_ref **use_rec,\n+\t\t\t\tdf_ref *use_rec,\n \t\t\t\tenum df_ref_flags top_flag)\n {\n   bitmap_iterator bi;\n   unsigned int def_index;\n   \n   while (*use_rec)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       unsigned int uregno = DF_REF_REGNO (use);\n       if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n \t  || (uregno >= FIRST_PSEUDO_REGISTER))\n@@ -2039,7 +2039,7 @@ df_chain_create_bb_process_use (bitmap local_rd,\n \t\t  \n \t\t  EXECUTE_IF_SET_IN_BITMAP (local_rd, first_index, def_index, bi)\n \t\t    {\n-\t\t      struct df_ref *def;\n+\t\t      df_ref def;\n \t\t      if (def_index > last_index) \n \t\t\tbreak;\n \t\t      \n@@ -2067,7 +2067,7 @@ df_chain_create_bb (unsigned int bb_index)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx insn;\n   bitmap cpy = BITMAP_ALLOC (NULL);\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n \n   bitmap_copy (cpy, bb_info->in);\n   bitmap_set_bit (df_chain->out_of_date_transfer_functions, bb_index);\n@@ -2088,7 +2088,7 @@ df_chain_create_bb (unsigned int bb_index)\n \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -2103,7 +2103,7 @@ df_chain_create_bb (unsigned int bb_index)\n   /* Process the regular instructions next.  */\n   FOR_BB_INSNS (bb, insn)\n     {\n-      struct df_ref **def_rec;\n+      df_ref *def_rec;\n       unsigned int uid = INSN_UID (insn);\n \n       if (!INSN_P (insn))\n@@ -2122,7 +2122,7 @@ df_chain_create_bb (unsigned int bb_index)\n          pass only changes the bits in cpy.  */\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \t  if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n \t      || (dregno >= FIRST_PSEUDO_REGISTER))\n@@ -2183,14 +2183,14 @@ df_chain_top_dump (basic_block bb, FILE *file)\n   if (df_chain_problem_p (DF_DU_CHAIN))\n     {\n       rtx insn;\n-      struct df_ref **def_rec = df_get_artificial_defs (bb->index);\n+      df_ref *def_rec = df_get_artificial_defs (bb->index);\n       if (*def_rec)\n \t{\n \t  \n \t  fprintf (file, \";;  DU chains for artificial defs\\n\");\n \t  while (*def_rec)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      fprintf (file, \";;   reg %d \", DF_REF_REGNO (def));\n \t      df_chain_dump (DF_REF_CHAIN (def), file);\n \t      fprintf (file, \"\\n\");\n@@ -2211,9 +2211,9 @@ df_chain_top_dump (basic_block bb, FILE *file)\n \t\t  \n \t\t  while (*def_rec)\n \t\t    {\n-\t\t      struct df_ref *def = *def_rec;\n+\t\t      df_ref def = *def_rec;\n \t\t      fprintf (file, \";;      reg %d \", DF_REF_REGNO (def));\n-\t\t      if (def->flags & DF_REF_READ_WRITE)\n+\t\t      if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n \t\t\tfprintf (file, \"read/write \");\n \t\t      df_chain_dump (DF_REF_CHAIN (def), file);\n \t\t      fprintf (file, \"\\n\");\n@@ -2232,14 +2232,14 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n   if (df_chain_problem_p (DF_UD_CHAIN))\n     {\n       rtx insn;\n-      struct df_ref **use_rec = df_get_artificial_uses (bb->index);\n+      df_ref *use_rec = df_get_artificial_uses (bb->index);\n \n       if (*use_rec)\n \t{\n \t  fprintf (file, \";;  UD chains for artificial uses\\n\");\n \t  while (*use_rec)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      fprintf (file, \";;   reg %d \", DF_REF_REGNO (use));\n \t      df_chain_dump (DF_REF_CHAIN (use), file);\n \t      fprintf (file, \"\\n\");\n@@ -2252,7 +2252,7 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n \t  if (INSN_P (insn))\n \t    {\n \t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-\t      struct df_ref **eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n+\t      df_ref *eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n \t      use_rec = DF_INSN_INFO_USES (insn_info);\n \t      if (*use_rec || *eq_use_rec)\n \t\t{\n@@ -2261,17 +2261,17 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n \t\t  \n \t\t  while (*use_rec)\n \t\t    {\n-\t\t      struct df_ref *use = *use_rec;\n+\t\t      df_ref use = *use_rec;\n \t\t      fprintf (file, \";;      reg %d \", DF_REF_REGNO (use));\n-\t\t      if (use->flags & DF_REF_READ_WRITE)\n+\t\t      if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n \t\t\tfprintf (file, \"read/write \");\n \t\t      df_chain_dump (DF_REF_CHAIN (use), file);\n \t\t      fprintf (file, \"\\n\");\n \t\t      use_rec++;\n \t\t    }\n \t\t  while (*eq_use_rec)\n \t\t    {\n-\t\t      struct df_ref *use = *eq_use_rec;\n+\t\t      df_ref use = *eq_use_rec;\n \t\t      fprintf (file, \";;   eq_note reg %d \", DF_REF_REGNO (use));\n \t\t      df_chain_dump (DF_REF_CHAIN (use), file);\n \t\t      fprintf (file, \"\\n\");\n@@ -2432,14 +2432,14 @@ df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n    extracts, subregs or strict_low_parts.  */\n \n static void\n-df_byte_lr_check_regs (struct df_ref **ref_rec)\n+df_byte_lr_check_regs (df_ref *ref_rec)\n {\n   struct df_byte_lr_problem_data *problem_data \n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n \n   for (; *ref_rec; ref_rec++)\n     {\n-      struct df_ref *ref = *ref_rec;\n+      df_ref ref = *ref_rec;\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT \n \t\t\t       | DF_REF_ZERO_EXTRACT \n \t\t\t       | DF_REF_STRICT_LOW_PART)\n@@ -2595,13 +2595,13 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n \n   /* Process the registers set in an exception handler.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -2615,7 +2615,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n   /* Process the hardware registers that are always live.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \t{\n@@ -2635,7 +2635,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  /* If the def is to only part of the reg, it does\n \t     not kill the other defs that reach here.  */\n \t  if (!(DF_REF_FLAGS (def) & (DF_REF_CONDITIONAL)))\n@@ -2660,7 +2660,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \t  unsigned int start = problem_data->regno_start[uregno];\n \t  unsigned int len = problem_data->regno_len[uregno];\n@@ -2682,7 +2682,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n      goto.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -2697,7 +2697,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n   /* Process the uses that are live into an exception handler.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n \t{\n@@ -2911,12 +2911,12 @@ df_byte_lr_simulate_defs (rtx insn, bitmap live)\n {\n   struct df_byte_lr_problem_data *problem_data \n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n \n       /* If the def is to only part of the reg, it does\n \t not kill the other defs that reach here.  */\n@@ -2947,12 +2947,12 @@ df_byte_lr_simulate_uses (rtx insn, bitmap live)\n {\n   struct df_byte_lr_problem_data *problem_data \n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       unsigned int uregno = DF_REF_REGNO (use);\n       unsigned int start = problem_data->regno_start[uregno];\n       unsigned int len = problem_data->regno_len[uregno];\n@@ -2980,16 +2980,16 @@ df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n {\n   struct df_byte_lr_problem_data *problem_data \n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n #ifdef EH_USES\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n #endif\n   int bb_index = bb->index;\n   \n #ifdef EH_USES\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int uregno = DF_REF_REGNO (use);\n@@ -3002,7 +3002,7 @@ df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{      \n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -3022,13 +3022,13 @@ df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n {\n   struct df_byte_lr_problem_data *problem_data \n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n   int bb_index = bb->index;\n   \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n@@ -3040,7 +3040,7 @@ df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n \n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int uregno = DF_REF_REGNO (use);\n@@ -3351,7 +3351,7 @@ df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n    LIVE.  Do not generate notes for registers in ARTIFICIAL_USES.  */\n \n static rtx\n-df_create_unused_note (rtx insn, rtx old, struct df_ref *def, \n+df_create_unused_note (rtx insn, rtx old, df_ref def, \n \t\t       bitmap live, bitmap artificial_uses)\n {\n   unsigned int dregno = DF_REF_REGNO (def);\n@@ -3391,8 +3391,8 @@ df_note_bb_compute (unsigned int bb_index,\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n \n   bitmap_copy (live, df_get_live_out (bb));\n   bitmap_clear (artificial_uses);\n@@ -3409,7 +3409,7 @@ df_note_bb_compute (unsigned int bb_index,\n      to begin processing.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n #ifdef REG_DEAD_DEBUGGING\n       if (dump_file)\n \tfprintf (dump_file, \"artificial def %d\\n\", DF_REF_REGNO (def));\n@@ -3421,7 +3421,7 @@ df_note_bb_compute (unsigned int bb_index,\n \n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \t{\n \t  unsigned int regno = DF_REF_REGNO (use);\n@@ -3470,7 +3470,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t  while (*mws_rec)\n \t    {\n \t      struct df_mw_hardreg *mws = *mws_rec; \n-\t      if ((mws->type == DF_REF_REG_DEF) \n+\t      if ((DF_MWS_REG_DEF_P (mws)) \n \t\t  && !df_ignore_stack_reg (mws->start_regno))\n \t\told_unused_notes \n \t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes, \n@@ -3483,7 +3483,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t     clobber.  This code is for the return.  */\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n \t\t{\n@@ -3504,7 +3504,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t  while (*mws_rec)\n \t    {\n \t      struct df_mw_hardreg *mws = *mws_rec; \n-\t      if (mws->type == DF_REF_REG_DEF)\n+\t      if (DF_MWS_REG_DEF_P (mws))\n \t\told_unused_notes\n \t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes, \n \t\t\t\t\t\tmws, live, do_not_gen, \n@@ -3514,7 +3514,7 @@ df_note_bb_compute (unsigned int bb_index,\n \n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      old_unused_notes\n \t\t= df_create_unused_note (insn, old_unused_notes, \n@@ -3533,7 +3533,7 @@ df_note_bb_compute (unsigned int bb_index,\n       while (*mws_rec)\n \t{\n \t  struct df_mw_hardreg *mws = *mws_rec; \n-\t  if ((mws->type != DF_REF_REG_DEF)  \n+\t  if ((DF_MWS_REG_DEF_P (mws))  \n \t      && !df_ignore_stack_reg (mws->start_regno))\n \t    old_dead_notes\n \t      = df_set_dead_notes_for_mw (insn, old_dead_notes, \n@@ -3544,7 +3544,7 @@ df_note_bb_compute (unsigned int bb_index,\n \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n #ifdef REG_DEAD_DEBUGGING\n@@ -3689,12 +3689,12 @@ df_note_add_problem (void)\n void\n df_simulate_find_defs (rtx insn, bitmap defs)\n {\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       /* If the def is to only part of the reg, it does\n \t not kill the other defs that reach here.  */\n       if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n@@ -3708,12 +3708,12 @@ df_simulate_find_defs (rtx insn, bitmap defs)\n void\n df_simulate_defs (rtx insn, bitmap live)\n {\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       unsigned int dregno = DF_REF_REGNO (def);\n \n       /* If the def is to only part of the reg, it does\n@@ -3729,12 +3729,12 @@ df_simulate_defs (rtx insn, bitmap live)\n void \n df_simulate_uses (rtx insn, bitmap live)\n {\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       bitmap_set_bit (live, DF_REF_REGNO (use));\n     }\n@@ -3778,20 +3778,20 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n void \n df_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n {\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n   int bb_index = bb->index;\n   \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n \n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \tbitmap_set_bit (live, DF_REF_REGNO (use));\n     }\n@@ -3818,23 +3818,23 @@ df_simulate_one_insn (basic_block bb, rtx insn, bitmap live)\n void \n df_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n {\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n #ifdef EH_USES\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n #endif\n   int bb_index = bb->index;\n   \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n \n #ifdef EH_USES\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n \tbitmap_set_bit (live, DF_REF_REGNO (use));\n     }"}, {"sha": "ec0d12edc54061bc9fa8d0c3112643b50808299c", "filename": "gcc/df-scan.c", "status": "modified", "additions": 351, "deletions": 253, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -94,20 +94,20 @@ bitmap df_invalidated_by_call = NULL;\n \n struct df_collection_rec\n {\n-  struct df_ref ** def_vec;\n+  df_ref * def_vec;\n   unsigned int next_def;\n-  struct df_ref ** use_vec;\n+  df_ref * use_vec;\n   unsigned int next_use;\n-  struct df_ref ** eq_use_vec;\n+  df_ref * eq_use_vec;\n   unsigned int next_eq_use;\n   struct df_mw_hardreg **mw_vec;\n   unsigned int next_mw;\n };\n \n-static struct df_ref * df_null_ref_rec[1];\n+static df_ref df_null_ref_rec[1];\n static struct df_mw_hardreg * df_null_mw_rec[1];\n \n-static void df_ref_record (struct df_collection_rec *,\n+static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t   rtx, rtx *, \n \t\t\t   basic_block, struct df_insn_info *,\n \t\t\t   enum df_ref_type, enum df_ref_flags,\n@@ -118,16 +118,17 @@ static void df_def_record_1 (struct df_collection_rec *, rtx,\n static void df_defs_record (struct df_collection_rec *, rtx,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    enum df_ref_flags);\n-static void df_uses_record (struct df_collection_rec *,\n+static void df_uses_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    enum df_ref_flags, \n \t\t\t    int, int, enum machine_mode);\n \n-static struct df_ref *df_ref_create_structure (struct df_collection_rec *, rtx, rtx *, \n-\t\t\t\t\t       basic_block, struct df_insn_info *,\n-\t\t\t\t\t       enum df_ref_type, enum df_ref_flags,\n-\t\t\t\t\t       int, int, enum machine_mode);\n+static df_ref df_ref_create_structure (enum df_ref_class, \n+\t\t\t\t       struct df_collection_rec *, rtx, rtx *, \n+\t\t\t\t       basic_block, struct df_insn_info *,\n+\t\t\t\t       enum df_ref_type, enum df_ref_flags,\n+\t\t\t\t       int, int, enum machine_mode);\n \n static void df_insn_refs_collect (struct df_collection_rec*, \n \t\t\t\t  basic_block, struct df_insn_info *); \n@@ -141,16 +142,16 @@ static void df_record_exit_block_uses (bitmap);\n static void df_get_exit_block_use_set (bitmap);\n static void df_get_entry_block_def_set (bitmap);\n static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n-static void df_ref_chain_delete_du_chain (struct df_ref **);\n-static void df_ref_chain_delete (struct df_ref **);\n+static void df_ref_chain_delete_du_chain (df_ref *);\n+static void df_ref_chain_delete (df_ref *);\n \n static void df_refs_add_to_chains (struct df_collection_rec *, \n \t\t\t\t   basic_block, rtx);\n \n static bool df_insn_refs_verify (struct df_collection_rec *, basic_block, rtx, bool);\n static void df_entry_block_defs_collect (struct df_collection_rec *, bitmap);\n static void df_exit_block_uses_collect (struct df_collection_rec *, bitmap);\n-static void df_install_ref (struct df_ref *, struct df_reg_info *, \n+static void df_install_ref (df_ref, struct df_reg_info *, \n \t\t\t    struct df_ref_info *, bool);\n \n static int df_ref_compare (const void *, const void *);\n@@ -178,7 +179,9 @@ static bool regs_ever_live[FIRST_PSEUDO_REGISTER];\n /* Problem data for the scanning dataflow function.  */\n struct df_scan_problem_data\n {\n-  alloc_pool ref_pool;\n+  alloc_pool ref_base_pool;\n+  alloc_pool ref_artificial_pool;\n+  alloc_pool ref_regular_pool;\n   alloc_pool ref_extract_pool;\n   alloc_pool insn_pool;\n   alloc_pool reg_pool;\n@@ -264,7 +267,9 @@ df_scan_free_internal (void)\n   BITMAP_FREE (df->insns_to_notes_rescan);\n \n   free_alloc_pool (df_scan->block_pool);\n-  free_alloc_pool (problem_data->ref_pool);\n+  free_alloc_pool (problem_data->ref_base_pool);\n+  free_alloc_pool (problem_data->ref_artificial_pool);\n+  free_alloc_pool (problem_data->ref_regular_pool);\n   free_alloc_pool (problem_data->ref_extract_pool);\n   free_alloc_pool (problem_data->insn_pool);\n   free_alloc_pool (problem_data->reg_pool);\n@@ -344,20 +349,26 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_scan->problem_data = problem_data;\n   df_scan->computed = true;\n \n-  problem_data->ref_pool \n-    = create_alloc_pool (\"df_scan_ref pool\", \n-\t\t\t sizeof (struct df_ref), block_size);\n+  problem_data->ref_base_pool \n+    = create_alloc_pool (\"df_scan ref base\", \n+\t\t\t sizeof (struct df_base_ref), block_size);\n+  problem_data->ref_artificial_pool \n+    = create_alloc_pool (\"df_scan ref artificial\", \n+\t\t\t sizeof (struct df_artificial_ref), block_size);\n+  problem_data->ref_regular_pool \n+    = create_alloc_pool (\"df_scan ref regular\", \n+\t\t\t sizeof (struct df_regular_ref), block_size);\n   problem_data->ref_extract_pool \n-    = create_alloc_pool (\"df_scan_ref extract pool\", \n-\t\t\t sizeof (struct df_ref_extract), block_size);\n+    = create_alloc_pool (\"df_scan ref extract\", \n+\t\t\t sizeof (struct df_extract_ref), block_size);\n   problem_data->insn_pool \n-    = create_alloc_pool (\"df_scan_insn pool\", \n+    = create_alloc_pool (\"df_scan insn\", \n \t\t\t sizeof (struct df_insn_info), block_size);\n   problem_data->reg_pool \n-    = create_alloc_pool (\"df_scan_reg pool\", \n+    = create_alloc_pool (\"df_scan reg\", \n \t\t\t sizeof (struct df_reg_info), block_size);\n   problem_data->mw_reg_pool \n-    = create_alloc_pool (\"df_scan_mw_reg pool\", \n+    = create_alloc_pool (\"df_scan mw_reg\", \n \t\t\t sizeof (struct df_mw_hardreg), block_size);\n \n   bitmap_obstack_initialize (&problem_data->reg_bitmaps);\n@@ -416,6 +427,13 @@ static void\n df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n {\n   int i;\n+  int dcount = 0;\n+  int ucount = 0;\n+  int ecount = 0;\n+  int icount = 0;\n+  int ccount = 0;\n+  basic_block bb;\n+  rtx insn;\n \n   fprintf (file, \";;  invalidated by call \\t\");\n   df_print_regset (file, df_invalidated_by_call);\n@@ -433,8 +451,46 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (df_regs_ever_live_p (i))\n       fprintf (file, \" %d[%s]\", i, reg_names[i]);\n+  fprintf (file, \"\\n;;  ref usage \\t\");\n+  \n+  for (i = 0; i < (int)df->regs_inited; i++)\n+    if (DF_REG_DEF_COUNT (i) || DF_REG_USE_COUNT (i) || DF_REG_EQ_USE_COUNT (i))\n+      {\n+\tconst char * sep = \"\";\n+\n+\tfprintf (file, \"r%d={\", i);\n+\tif (DF_REG_DEF_COUNT (i))\n+\t  {\n+\t    fprintf (file, \"%dd\", DF_REG_DEF_COUNT (i));\n+\t    sep = \",\";\n+\t    dcount += DF_REG_DEF_COUNT (i);\n+\t  }\n+\tif (DF_REG_USE_COUNT (i))\n+\t  {\n+\t    fprintf (file, \"%s%du\", sep, DF_REG_USE_COUNT (i));\n+\t    sep = \",\";\n+\t    ucount += DF_REG_USE_COUNT (i);\n+\t  }\n+\tif (DF_REG_EQ_USE_COUNT (i))\n+\t  {\n+\t    fprintf (file, \"%s%dd\", sep, DF_REG_EQ_USE_COUNT (i));\n+\t    ecount += DF_REG_EQ_USE_COUNT (i);\n+\t  }\n+\tfprintf (file, \"} \");\n+      }\n \n-  fprintf (file, \"\\n\");\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      if (INSN_P (insn))\n+\t{\n+\t  if (CALL_P (insn))\n+\t    ccount++;\n+\t  else\n+\t    icount++;\n+\t}\n+\n+  fprintf (file, \"\\n;;    total ref usage %d{%dd,%du,%de} in %d{%d regular + %d call} insns.\\n\", \n+\t   dcount + ucount + ecount, dcount, ucount, ecount, icount + ccount, icount, ccount);\n }\n \n /* Dump the bb_info for a given basic block. */\n@@ -565,9 +621,9 @@ df_grow_ref_info (struct df_ref_info *ref_info, unsigned int new_size)\n {\n   if (ref_info->refs_size < new_size)\n     {\n-      ref_info->refs = XRESIZEVEC (struct df_ref *, ref_info->refs, new_size);\n+      ref_info->refs = XRESIZEVEC (df_ref, ref_info->refs, new_size);\n       memset (ref_info->refs + ref_info->refs_size, 0,\n-\t      (new_size - ref_info->refs_size) *sizeof (struct df_ref *));\n+\t      (new_size - ref_info->refs_size) *sizeof (df_ref));\n       ref_info->refs_size = new_size;\n     }\n }\n@@ -658,30 +714,38 @@ df_scan_blocks (void)\n    fields if they were constants.  Otherwise they should be -1 if\n    those flags were set.  */\n \n-struct df_ref *\n+df_ref \n df_ref_create (rtx reg, rtx *loc, rtx insn, \n \t       basic_block bb,\n \t       enum df_ref_type ref_type, \n \t       enum df_ref_flags ref_flags,\n \t       int width, int offset, enum machine_mode mode)\n {\n-  struct df_ref *ref;\n+  df_ref ref;\n   struct df_reg_info **reg_info;\n   struct df_ref_info *ref_info;\n-  struct df_ref **ref_rec;\n-  struct df_ref ***ref_rec_ptr;\n+  df_ref *ref_rec;\n+  df_ref **ref_rec_ptr;\n   unsigned int count = 0;\n   bool add_to_table;\n+  enum df_ref_class cl;\n \n   df_grow_reg_info ();\n \n   /* You cannot hack artificial refs.  */\n   gcc_assert (insn);\n-  ref = df_ref_create_structure (NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n+\n+  if (width != -1 || offset != -1)\n+    cl = DF_REF_EXTRACT;\n+  else if (loc)\n+    cl = DF_REF_REGULAR;\n+  else\n+    cl = DF_REF_BASE;\n+  ref = df_ref_create_structure (cl, NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n                                  ref_type, ref_flags, \n \t\t\t\t width, offset, mode);\n \n-  if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n+  if (DF_REF_REG_DEF_P (ref))\n     {\n       reg_info = df->def_regs;\n       ref_info = &df->def_info;\n@@ -742,15 +806,15 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   ref_rec = *ref_rec_ptr;\n   if (count)\n     {\n-      ref_rec = XRESIZEVEC (struct df_ref *, ref_rec, count+2);\n+      ref_rec = XRESIZEVEC (df_ref, ref_rec, count+2);\n       *ref_rec_ptr = ref_rec;\n       ref_rec[count] = ref;\n       ref_rec[count+1] = NULL;\n-      qsort (ref_rec, count + 1, sizeof (struct df_ref *), df_ref_compare);\n+      qsort (ref_rec, count + 1, sizeof (df_ref), df_ref_compare);\n     }\n   else\n     {\n-      struct df_ref **ref_rec = XNEWVEC (struct df_ref*, 2);\n+      df_ref *ref_rec = XNEWVEC (df_ref, 2);\n       ref_rec[0] = ref;\n       ref_rec[1] = NULL;\n       *ref_rec_ptr = ref_rec;\n@@ -778,33 +842,48 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n ----------------------------------------------------------------------------*/\n \n static void\n-df_free_ref (struct df_ref *ref)\n+df_free_ref (df_ref ref)\n {\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n \n-  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-    pool_free (problem_data->ref_extract_pool, (struct df_ref_extract *)ref);\n-  else\n-    pool_free (problem_data->ref_pool, ref);\n+  switch (DF_REF_CLASS (ref))\n+    {\n+    case DF_REF_BASE:\n+      pool_free (problem_data->ref_base_pool, ref);\n+      break;\n+\n+    case DF_REF_ARTIFICIAL:\n+      pool_free (problem_data->ref_artificial_pool, ref);\n+      break;\n+\n+    case DF_REF_REGULAR:\n+      pool_free (problem_data->ref_regular_pool, ref);\n+      break;\n+\n+    case DF_REF_EXTRACT:\n+      pool_free (problem_data->ref_extract_pool, ref);\n+      break;\n+    }\n }\n \n \n /* Unlink and delete REF at the reg_use, reg_eq_use or reg_def chain.\n    Also delete the def-use or use-def chain if it exists.  */\n \n static void\n-df_reg_chain_unlink (struct df_ref *ref) \n+df_reg_chain_unlink (df_ref ref) \n {\n-  struct df_ref *next = DF_REF_NEXT_REG (ref);  \n-  struct df_ref *prev = DF_REF_PREV_REG (ref);\n+  df_ref next = DF_REF_NEXT_REG (ref);  \n+  df_ref prev = DF_REF_PREV_REG (ref);\n   int id = DF_REF_ID (ref);\n   struct df_reg_info *reg_info;\n-  struct df_ref **refs = NULL;\n+  df_ref *refs = NULL;\n \n-  if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n+  if (DF_REF_REG_DEF_P (ref))\n     {\n-      reg_info = DF_REG_DEF_GET (DF_REF_REGNO (ref));\n+      int regno = DF_REF_REGNO (ref);\n+      reg_info = DF_REG_DEF_GET (regno);\n       refs = df->def_info.refs;\n     }\n   else \n@@ -834,7 +913,7 @@ df_reg_chain_unlink (struct df_ref *ref)\n     {\n       if (df->analyze_subset)\n \t{\n-\t  if (bitmap_bit_p (df->blocks_to_analyze, DF_REF_BB (ref)->index))\n+\t  if (bitmap_bit_p (df->blocks_to_analyze, DF_REF_BBNO (ref)))\n \t    refs[id] = NULL;\n \t}\n       else\n@@ -875,9 +954,9 @@ df_reg_chain_unlink (struct df_ref *ref)\n /* Remove REF from VEC.  */\n \n static void\n-df_ref_compress_rec (struct df_ref ***vec_ptr, struct df_ref *ref)\n+df_ref_compress_rec (df_ref **vec_ptr, df_ref ref)\n {\n-  struct df_ref **vec = *vec_ptr;\n+  df_ref *vec = *vec_ptr;\n \n   if (vec[1])\n     {\n@@ -901,7 +980,7 @@ df_ref_compress_rec (struct df_ref ***vec_ptr, struct df_ref *ref)\n /* Unlink REF from all def-use/use-def chains, etc.  */\n \n void\n-df_ref_remove (struct df_ref *ref)\n+df_ref_remove (df_ref ref)\n {\n #if 0\n   if (dump_file)\n@@ -916,7 +995,7 @@ df_ref_remove (struct df_ref *ref)\n       if (DF_REF_IS_ARTIFICIAL (ref))\n \t{\n \t  struct df_scan_bb_info *bb_info \n-\t    = df_scan_get_bb_info (DF_REF_BB (ref)->index);\n+\t    = df_scan_get_bb_info (DF_REF_BBNO (ref));\n \t  df_ref_compress_rec (&bb_info->artificial_defs, ref);\n \t}\n       else\n@@ -931,7 +1010,7 @@ df_ref_remove (struct df_ref *ref)\n       if (DF_REF_IS_ARTIFICIAL (ref))\n \t{\n \t  struct df_scan_bb_info *bb_info \n-\t    = df_scan_get_bb_info (DF_REF_BB (ref)->index);\n+\t    = df_scan_get_bb_info (DF_REF_BBNO (ref));\n \t  df_ref_compress_rec (&bb_info->artificial_uses, ref);\n \t}\n       else \n@@ -980,11 +1059,11 @@ df_insn_create_insn_record (rtx insn)\n /* Delete all du chain (DF_REF_CHAIN()) of all refs in the ref chain.  */\n \n static void\n-df_ref_chain_delete_du_chain (struct df_ref **ref_rec)\n+df_ref_chain_delete_du_chain (df_ref *ref_rec)\n {\n   while (*ref_rec)\n     {\n-      struct df_ref *ref = *ref_rec;\n+      df_ref ref = *ref_rec;\n       /* CHAIN is allocated by DF_CHAIN. So make sure to \n          pass df_scan instance for the problem.  */\n       if (DF_REF_CHAIN (ref))\n@@ -997,9 +1076,9 @@ df_ref_chain_delete_du_chain (struct df_ref **ref_rec)\n /* Delete all refs in the ref chain.  */\n \n static void\n-df_ref_chain_delete (struct df_ref **ref_rec)\n+df_ref_chain_delete (df_ref *ref_rec)\n {\n-  struct df_ref **start = ref_rec;\n+  df_ref *start = ref_rec;\n   while (*ref_rec)\n     {\n       df_reg_chain_unlink (*ref_rec);\n@@ -1113,7 +1192,7 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n {\n   struct df_scan_problem_data *problem_data \n     = (struct df_scan_problem_data *) df_scan->problem_data;\n-  struct df_ref **ref;\n+  df_ref *ref;\n   struct df_mw_hardreg **mw;\n \n   if (collection_rec->def_vec)\n@@ -1140,9 +1219,9 @@ df_insn_rescan (rtx insn)\n   struct df_insn_info *insn_info = NULL;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n   struct df_collection_rec collection_rec;\n-  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.def_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (df_ref, 1000);\n   collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   if ((!df) || (!INSN_P (insn)))\n@@ -1407,7 +1486,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n       ref_info->begin[regno] = offset;\n       if (include_defs)\n \t{\n-\t  struct df_ref *ref = DF_REG_DEF_CHAIN (regno);\n+\t  df_ref ref = DF_REG_DEF_CHAIN (regno);\n \t  while (ref) \n \t    {\n \t      ref_info->refs[offset] = ref;\n@@ -1419,7 +1498,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t}\n       if (include_uses)\n \t{\n-\t  struct df_ref *ref = DF_REG_USE_CHAIN (regno);\n+\t  df_ref ref = DF_REG_USE_CHAIN (regno);\n \t  while (ref) \n \t    {\n \t      ref_info->refs[offset] = ref;\n@@ -1431,7 +1510,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t}\n       if (include_eq_uses)\n \t{\n-\t  struct df_ref *ref = DF_REG_EQ_USE_CHAIN (regno);\n+\t  df_ref ref = DF_REG_EQ_USE_CHAIN (regno);\n \t  while (ref) \n \t    {\n \t      ref_info->refs[offset] = ref;\n@@ -1480,7 +1559,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n     {\n       basic_block bb = BASIC_BLOCK (bb_index);\n       rtx insn;\n-      struct df_ref **ref_rec;\n+      df_ref *ref_rec;\n \n       if (include_defs)\n \tfor (ref_rec = df_get_artificial_defs (bb_index); *ref_rec; ref_rec++)\n@@ -1534,12 +1613,12 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n     {\n       basic_block bb = BASIC_BLOCK (bb_index);\n       rtx insn;\n-      struct df_ref **ref_rec;\n+      df_ref *ref_rec;\n \n       if (include_defs)\n \tfor (ref_rec = df_get_artificial_defs (bb_index); *ref_rec; ref_rec++)\n \t  {\n-\t    struct df_ref *ref = *ref_rec;\n+\t    df_ref ref = *ref_rec;\n \t    unsigned int regno = DF_REF_REGNO (ref);\n \t    if (regno >= start)\n \t      {\n@@ -1552,7 +1631,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n       if (include_uses)\n \tfor (ref_rec = df_get_artificial_uses (bb_index); *ref_rec; ref_rec++)\n \t  {\n-\t    struct df_ref *ref = *ref_rec;\n+\t    df_ref ref = *ref_rec;\n \t    unsigned int regno = DF_REF_REGNO (ref);\n \t    if (regno >= start)\n \t      {\n@@ -1572,7 +1651,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t      if (include_defs)\n \t\tfor (ref_rec = DF_INSN_UID_DEFS (uid); *ref_rec; ref_rec++)\n \t\t  {\n-\t\t    struct df_ref *ref = *ref_rec;\n+\t\t    df_ref ref = *ref_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (ref);\n \t\t    if (regno >= start)\n \t\t      {\n@@ -1585,7 +1664,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t      if (include_uses)\n \t\tfor (ref_rec = DF_INSN_UID_USES (uid); *ref_rec; ref_rec++)\n \t\t  {\n-\t\t    struct df_ref *ref = *ref_rec;\n+\t\t    df_ref ref = *ref_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (ref);\n \t\t    if (regno >= start)\n \t\t      {\n@@ -1598,7 +1677,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t      if (include_eq_uses)\n \t\tfor (ref_rec = DF_INSN_UID_EQ_USES (uid); *ref_rec; ref_rec++)\n \t\t  {\n-\t\t    struct df_ref *ref = *ref_rec;\n+\t\t    df_ref ref = *ref_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (ref);\n \t\t    if (regno >= start)\n \t\t      {\n@@ -1641,11 +1720,11 @@ df_reorganize_refs_by_reg (struct df_ref_info *ref_info,\n static unsigned int \n df_add_refs_to_table (unsigned int offset, \n \t\t      struct df_ref_info *ref_info, \n-\t\t      struct df_ref **ref_vec)\n+\t\t      df_ref *ref_vec)\n {\n   while (*ref_vec)\n     {\n-      struct df_ref *ref = *ref_vec;\n+      df_ref ref = *ref_vec;\n       if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n \t  || (DF_REF_REGNO (ref) >= FIRST_PSEUDO_REGISTER))\n \t{\n@@ -1813,25 +1892,6 @@ df_maybe_reorganize_def_refs (enum df_ref_order order)\n }\n \n \n-/* Change the BB of all refs in the ref chain from OLD_BB to NEW_BB.\n-   Assumes that all refs in the chain have the same BB.  */\n-\n-static void\n-df_ref_chain_change_bb (struct df_ref **ref_rec, \n-                        basic_block old_bb,\n-                        basic_block new_bb)\n-{\n-  while (*ref_rec)\n-    {\n-      struct df_ref *ref = *ref_rec;\n-\n-      gcc_assert (DF_REF_BB (ref) == old_bb);\n-      DF_REF_BB (ref) = new_bb;\n-      ref_rec++;\n-    }\n-}\n-\n-\n /* Change all of the basic block references in INSN to use the insn's\n    current basic block.  This function is called from routines that move \n    instructions from one block to another.  */  \n@@ -1866,10 +1926,6 @@ df_insn_change_bb (rtx insn, basic_block new_bb)\n   if (!INSN_P (insn))\n     return;\n \n-  df_ref_chain_change_bb (insn_info->defs, old_bb, new_bb);\n-  df_ref_chain_change_bb (insn_info->uses, old_bb, new_bb);\n-  df_ref_chain_change_bb (insn_info->eq_uses, old_bb, new_bb);\n-\n   df_set_bb_dirty (new_bb);\n   if (old_bb)\n     {\n@@ -1887,83 +1943,78 @@ df_insn_change_bb (rtx insn, basic_block new_bb)\n /* Helper function for df_ref_change_reg_with_loc.  */\n \n static void\n-df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df, struct df_reg_info *new_df,\n+df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df, \n+\t\t\t      struct df_reg_info *new_df,\n \t\t\t      int new_regno, rtx loc)\n {\n-  struct df_ref *the_ref = old_df->reg_chain;\n+  df_ref the_ref = old_df->reg_chain;\n \n   while (the_ref)\n     {\n-      if (DF_REF_LOC(the_ref) && (*DF_REF_LOC(the_ref) == loc))\n+      if ((!DF_REF_IS_ARTIFICIAL (the_ref))\n+\t  && (DF_REF_LOC (the_ref))\n+\t  && (*DF_REF_LOC (the_ref) == loc))\n \t{\n-\t  struct df_ref *next_ref = the_ref->next_reg;\n-\t  struct df_ref *prev_ref = the_ref->prev_reg;\n-\t  struct df_ref **ref_vec, **ref_vec_t;\n+\t  df_ref next_ref = DF_REF_NEXT_REG (the_ref);\n+\t  df_ref prev_ref = DF_REF_PREV_REG (the_ref);\n+\t  df_ref *ref_vec, *ref_vec_t;\n+\t  struct df_insn_info *insn_info = DF_REF_INSN_INFO (the_ref);\n \t  unsigned int count = 0;\n \n \t  DF_REF_REGNO (the_ref) = new_regno;\n \t  DF_REF_REG (the_ref) = regno_reg_rtx[new_regno];\n \n \t  /* Pull the_ref out of the old regno chain.  */\n \t  if (prev_ref)\n-\t    prev_ref->next_reg = next_ref;\n+\t    DF_REF_NEXT_REG (prev_ref) = next_ref;\n \t  else\n \t    old_df->reg_chain = next_ref;\n \t  if (next_ref)\n-\t    next_ref->prev_reg = prev_ref;\n+\t    DF_REF_PREV_REG (next_ref) = prev_ref;\n \t  old_df->n_refs--;\n \n \t  /* Put the ref into the new regno chain.  */\n-\t  the_ref->prev_reg = NULL;\n-\t  the_ref->next_reg = new_df->reg_chain;\n+\t  DF_REF_PREV_REG (the_ref) = NULL;\n+\t  DF_REF_NEXT_REG (the_ref) = new_df->reg_chain;\n \t  if (new_df->reg_chain)\n-\t    new_df->reg_chain->prev_reg = the_ref;\n+\t    DF_REF_PREV_REG (new_df->reg_chain) = the_ref;\n \t  new_df->reg_chain = the_ref;\n \t  new_df->n_refs++;\n \t  df_set_bb_dirty (DF_REF_BB (the_ref));\n \n-\t  /* Need to resort the record that the ref was in because the\n-\t     regno is a sorting key.  First, find the right record.  */\n-\t  if (DF_REF_IS_ARTIFICIAL (the_ref))\n-\t    {\n-\t      unsigned int bb_index = DF_REF_BB (the_ref)->index;\n-\t      if (DF_REF_REG_DEF_P (the_ref))\n-\t\tref_vec = df_get_artificial_defs (bb_index);\n-\t      else\n-\t\tref_vec = df_get_artificial_uses (bb_index);\n-\t    }\n+\t  /* Need to sort the record again that the ref was in because\n+\t     the regno is a sorting key.  First, find the right\n+\t     record.  */\n+\t  if (DF_REF_FLAGS (the_ref) & DF_REF_IN_NOTE)\n+\t    ref_vec = insn_info->eq_uses;\n \t  else\n-\t    {\n-\t      struct df_insn_info *insn_info = DF_REF_INSN_INFO (the_ref);\n-\t      if (DF_REF_FLAGS (the_ref) & DF_REF_IN_NOTE)\n-\t\tref_vec = insn_info->eq_uses;\n-\t      else\n-\t\tref_vec = insn_info->uses;\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"changing reg in insn %d\\n\", \n-\t\t\t INSN_UID (DF_REF_INSN (the_ref))); \n-\t    }\n+\t    ref_vec = insn_info->uses;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"changing reg in insn %d\\n\", \n+\t\t     DF_REF_INSN_UID (the_ref)); \n+      \n \t  ref_vec_t = ref_vec;\n-\n+\t  \n \t  /* Find the length.  */\n \t  while (*ref_vec_t)\n \t    {\n \t      count++;\n \t      ref_vec_t++;\n \t    }\n-\t  qsort (ref_vec, count, sizeof (struct df_ref *), df_ref_compare);\n+\t  qsort (ref_vec, count, sizeof (df_ref ), df_ref_compare);\n \n \t  the_ref = next_ref;\n \t}\n       else\n-\tthe_ref = the_ref->next_reg;\n+\tthe_ref = DF_REF_NEXT_REG (the_ref);\n     }\n }\n \n \n /* Change the regno of all refs that contained LOC from OLD_REGNO to\n-   NEW_REGNO.  Refs that do not match LOC are not changed.  This call\n-   is to support the SET_REGNO macro. */\n+   NEW_REGNO.  Refs that do not match LOC are not changed which means\n+   that artificial refs are not changed since they have no loc.  This\n+   call is to support the SET_REGNO macro. */\n \n void\n df_ref_change_reg_with_loc (int old_regno, int new_regno, rtx loc)\n@@ -2087,7 +2138,7 @@ df_notes_rescan (rtx insn)\n       unsigned int num_deleted;\n \n       memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-      collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+      collection_rec.eq_use_vec = XALLOCAVEC (df_ref, 1000);\n       collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 1000);\n \n       num_deleted = df_mw_hardreg_chain_delete_eq_uses (insn_info);\n@@ -2102,7 +2153,7 @@ df_notes_rescan (rtx insn)\n \t    {\n \t    case REG_EQUIV:\n \t    case REG_EQUAL:\n-\t      df_uses_record (&collection_rec,\n+\t      df_uses_record (DF_REF_REGULAR, &collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n \t\t\t      bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n \t    default:\n@@ -2170,30 +2221,44 @@ df_notes_rescan (rtx insn)\n    It ignores DF_REF_MARKER.  */\n \n static bool\n-df_ref_equal_p (struct df_ref *ref1, struct df_ref *ref2)\n+df_ref_equal_p (df_ref ref1, df_ref ref2)\n {\n   if (!ref2)\n     return false;\n+  \n+  if (ref1 == ref2)\n+    return true;\n+\n+  if (DF_REF_CLASS (ref1) != DF_REF_CLASS (ref2)\n+      || DF_REF_REGNO (ref1) != DF_REF_REGNO (ref2)\n+      || DF_REF_REG (ref1) != DF_REF_REG (ref2)\n+      || DF_REF_TYPE (ref1) != DF_REF_TYPE (ref2)\n+      || ((DF_REF_FLAGS (ref1) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)) \n+\t  != (DF_REF_FLAGS (ref2) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)))\n+      || DF_REF_BB (ref1) != DF_REF_BB (ref2)\n+      || DF_REF_INSN_INFO (ref1) != DF_REF_INSN_INFO (ref2))\n+    return false;\n+  \n+  switch (DF_REF_CLASS (ref1))\n+    {\n+    case DF_REF_ARTIFICIAL:\n+    case DF_REF_BASE:\n+      return true;\n \n-  /* The two flag tests here are only to make sure we do not look at\n-     the offset and width if they are not there.  The flags are\n-     compared in the next set of tests.  */\n-  if ((DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-      && (DF_REF_FLAGS_IS_SET (ref2, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-      && ((DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n+    case DF_REF_EXTRACT:\n+      if ((DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n \t  || (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n-\t  || (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))))\n-    return false;\n+\t  || (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2)))\n+\treturn false;\n+      /* fallthru.  */\n+\n+    case DF_REF_REGULAR:\n+      return DF_REF_LOC (ref1) == DF_REF_LOC (ref2);\n \n-  return (ref1 == ref2) ||\n-    (DF_REF_REG (ref1) == DF_REF_REG (ref2)\n-     && DF_REF_REGNO (ref1) == DF_REF_REGNO (ref2)\n-     && DF_REF_LOC (ref1) == DF_REF_LOC (ref2)\n-     && DF_REF_INSN_INFO (ref1) == DF_REF_INSN_INFO (ref2)\n-     && DF_REF_TYPE (ref1) == DF_REF_TYPE (ref2)\n-     && ((DF_REF_FLAGS (ref1) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)) \n-\t == (DF_REF_FLAGS (ref2) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)))\n-     && DF_REF_BB (ref1) == DF_REF_BB (ref2));\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n }\n \n \n@@ -2204,20 +2269,27 @@ df_ref_equal_p (struct df_ref *ref1, struct df_ref *ref2)\n static int\n df_ref_compare (const void *r1, const void *r2)\n {\n-  const struct df_ref *const ref1 = *(const struct df_ref *const*)r1;\n-  const struct df_ref *const ref2 = *(const struct df_ref *const*)r2;\n+  const df_ref ref1 = *(const df_ref *)r1;\n+  const df_ref ref2 = *(const df_ref *)r2;\n \n   if (ref1 == ref2)\n     return 0;\n \n+  if (DF_REF_CLASS (ref1) != DF_REF_CLASS (ref2))\n+    return (int)DF_REF_CLASS (ref1) - (int)DF_REF_CLASS (ref2);\n+\n   if (DF_REF_REGNO (ref1) != DF_REF_REGNO (ref2))\n     return (int)DF_REF_REGNO (ref1) - (int)DF_REF_REGNO (ref2);\n   \n   if (DF_REF_TYPE (ref1) != DF_REF_TYPE (ref2))\n     return (int)DF_REF_TYPE (ref1) - (int)DF_REF_TYPE (ref2);\n \n-  if ((DF_REF_REG (ref1) != DF_REF_REG (ref2))\n-      || (DF_REF_LOC (ref1) != DF_REF_LOC (ref2)))\n+  if (DF_REF_REG (ref1) != DF_REF_REG (ref2))\n+    return (int)DF_REF_ORDER (ref1) - (int)DF_REF_ORDER (ref2);\n+\n+  /* Cannot look at the LOC field on artificial refs.  */\n+  if (DF_REF_CLASS (ref1) != DF_REF_ARTIFICIAL\n+      && DF_REF_LOC (ref1) != DF_REF_LOC (ref2))\n     return (int)DF_REF_ORDER (ref1) - (int)DF_REF_ORDER (ref2);\n \n   if (DF_REF_FLAGS (ref1) != DF_REF_FLAGS (ref2))\n@@ -2234,32 +2306,32 @@ df_ref_compare (const void *r1, const void *r2)\n \treturn 1;\n     }\n \n-  /* The flags are the same at this point so it is safe to only look\n+  /* The classes are the same at this point so it is safe to only look\n      at ref1.  */\n-  if (DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+  if (DF_REF_CLASS (ref1) == DF_REF_EXTRACT)\n     {\n-      if (DF_REF_EXTRACT_OFFSET_CONST (ref1) != DF_REF_EXTRACT_OFFSET_CONST (ref2))\n-\treturn DF_REF_EXTRACT_OFFSET_CONST (ref1) - DF_REF_EXTRACT_OFFSET_CONST (ref2);\n-      if (DF_REF_EXTRACT_WIDTH_CONST (ref1) != DF_REF_EXTRACT_WIDTH_CONST (ref2))\n-\treturn DF_REF_EXTRACT_WIDTH_CONST (ref1) - DF_REF_EXTRACT_WIDTH_CONST (ref2);\n-      if (DF_REF_EXTRACT_MODE_CONST (ref1) != DF_REF_EXTRACT_MODE_CONST (ref2))\n-\treturn DF_REF_EXTRACT_MODE_CONST (ref1) - DF_REF_EXTRACT_MODE_CONST (ref2);\n+      if (DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n+\treturn DF_REF_EXTRACT_OFFSET (ref1) - DF_REF_EXTRACT_OFFSET (ref2);\n+      if (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n+\treturn DF_REF_EXTRACT_WIDTH (ref1) - DF_REF_EXTRACT_WIDTH (ref2);\n+      if (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))\n+\treturn DF_REF_EXTRACT_MODE (ref1) - DF_REF_EXTRACT_MODE (ref2);\n     }\n   return 0;\n }\n \n static void\n-df_swap_refs (struct df_ref **ref_vec, int i, int j)\n+df_swap_refs (df_ref *ref_vec, int i, int j)\n {\n-  struct df_ref *tmp = ref_vec[i];\n+  df_ref tmp = ref_vec[i];\n   ref_vec[i] = ref_vec[j];\n   ref_vec[j] = tmp;\n }\n \n /* Sort and compress a set of refs.  */\n \n static unsigned int\n-df_sort_and_compress_refs (struct df_ref **ref_vec, unsigned int count)\n+df_sort_and_compress_refs (df_ref *ref_vec, unsigned int count)\n {\n   unsigned int i;\n   unsigned int dist = 0;\n@@ -2287,7 +2359,7 @@ df_sort_and_compress_refs (struct df_ref **ref_vec, unsigned int count)\n          of DF_REF_COMPARE.  */\n       if (i == count - 1)\n         return count;\n-      qsort (ref_vec, count, sizeof (struct df_ref *), df_ref_compare);\n+      qsort (ref_vec, count, sizeof (df_ref), df_ref_compare);\n     }\n \n   for (i=0; i<count-dist; i++)\n@@ -2427,14 +2499,14 @@ df_canonize_collection_rec (struct df_collection_rec *collection_rec)\n /* Add the new df_ref to appropriate reg_info/ref_info chains.  */\n \n static void\n-df_install_ref (struct df_ref *this_ref, \n+df_install_ref (df_ref this_ref, \n \t\tstruct df_reg_info *reg_info, \n \t\tstruct df_ref_info *ref_info,\n \t\tbool add_to_table)\n {\n   unsigned int regno = DF_REF_REGNO (this_ref);\n   /* Add the ref to the reg_{def,use,eq_use} chain.  */\n-  struct df_ref *head = reg_info->reg_chain;\n+  df_ref head = reg_info->reg_chain;\n \n   reg_info->reg_chain = this_ref;\n   reg_info->n_refs++;\n@@ -2476,17 +2548,17 @@ df_install_ref (struct df_ref *this_ref,\n    eq_uses) and installs the entire group into the insn.  It also adds\n    each of these refs into the appropriate chains.  */\n \n-static struct df_ref **\n+static df_ref *\n df_install_refs (basic_block bb,\n-\t\t struct df_ref **old_vec, unsigned int count, \n+\t\t df_ref *old_vec, unsigned int count, \n \t\t struct df_reg_info **reg_info, \n \t\t struct df_ref_info *ref_info,\n \t\t bool is_notes)\n {\n   if (count)\n     {\n       unsigned int i;\n-      struct df_ref **new_vec = XNEWVEC (struct df_ref*, count + 1);\n+      df_ref *new_vec = XNEWVEC (df_ref, count + 1);\n       bool add_to_table;\n \n       switch (ref_info->ref_order)\n@@ -2514,7 +2586,7 @@ df_install_refs (basic_block bb,\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  struct df_ref *this_ref = old_vec[i];\n+\t  df_ref this_ref = old_vec[i];\n \t  new_vec[i] = this_ref;\n \t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)], \n \t\t\t  ref_info, add_to_table);\n@@ -2622,37 +2694,57 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n    if they were constants.  Otherwise they should be -1 if those flags\n    were set.  */\n \n-static struct df_ref *\n-df_ref_create_structure (struct df_collection_rec *collection_rec,\n+static df_ref \n+df_ref_create_structure (enum df_ref_class cl, \n+\t\t\t struct df_collection_rec *collection_rec,\n \t\t\t rtx reg, rtx *loc, \n \t\t\t basic_block bb, struct df_insn_info *info,\n \t\t\t enum df_ref_type ref_type, \n \t\t\t enum df_ref_flags ref_flags,\n \t\t\t int width, int offset, enum machine_mode mode)\n {\n-  struct df_ref *this_ref;\n+  df_ref this_ref = NULL;\n   int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n \n-  if (ref_flags & (DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+  switch (cl)\n     {\n-      this_ref = (struct df_ref *) pool_alloc (problem_data->ref_extract_pool);\n+    case DF_REF_BASE:\n+      this_ref = (df_ref) pool_alloc (problem_data->ref_base_pool);\n+      gcc_assert (loc == NULL);\n+      break;\n+\n+    case DF_REF_ARTIFICIAL:\n+      this_ref = (df_ref) pool_alloc (problem_data->ref_artificial_pool);\n+      this_ref->artificial_ref.bb = bb;\n+      gcc_assert (loc == NULL);\n+      break;\n+\n+    case DF_REF_REGULAR:\n+      this_ref = (df_ref) pool_alloc (problem_data->ref_regular_pool);\n+      this_ref->regular_ref.loc = loc;\n+      gcc_assert (loc);\n+      break;\n+\n+    case DF_REF_EXTRACT:\n+      this_ref = (df_ref) pool_alloc (problem_data->ref_extract_pool);\n       DF_REF_EXTRACT_WIDTH (this_ref) = width;\n       DF_REF_EXTRACT_OFFSET (this_ref) = offset;\n       DF_REF_EXTRACT_MODE (this_ref) = mode;\n+      this_ref->regular_ref.loc = loc;\n+      gcc_assert (loc);\n+      break;\n     }\n-  else\n-    this_ref = (struct df_ref *) pool_alloc (problem_data->ref_pool);\n+\n+  DF_REF_CLASS (this_ref) = cl;\n   DF_REF_ID (this_ref) = -1;\n   DF_REF_REG (this_ref) = reg;\n   DF_REF_REGNO (this_ref) =  regno;\n-  DF_REF_LOC (this_ref) = loc;\n+  DF_REF_TYPE (this_ref) = ref_type;\n   DF_REF_INSN_INFO (this_ref) = info;\n   DF_REF_CHAIN (this_ref) = NULL;\n-  DF_REF_TYPE (this_ref) = ref_type;\n   DF_REF_FLAGS (this_ref) = ref_flags;\n-  DF_REF_BB (this_ref) = bb;\n   DF_REF_NEXT_REG (this_ref) = NULL;\n   DF_REF_PREV_REG (this_ref) = NULL;\n   DF_REF_ORDER (this_ref) = df->ref_order++;\n@@ -2666,7 +2758,7 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n   if ((regno < FIRST_PSEUDO_REGISTER) \n       && (!DF_REF_IS_ARTIFICIAL (this_ref)))\n     {\n-      if (DF_REF_TYPE (this_ref) == DF_REF_REG_DEF)\n+      if (DF_REF_REG_DEF_P (this_ref))\n \t{\n \t  if (!DF_REF_FLAGS_IS_SET (this_ref, DF_REF_MAY_CLOBBER))\n \t    DF_REF_FLAGS_SET (this_ref, DF_HARD_REG_LIVE);\n@@ -2679,7 +2771,7 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n \n   if (collection_rec)\n     {\n-      if (DF_REF_TYPE (this_ref) == DF_REF_REG_DEF)\n+      if (DF_REF_REG_DEF_P (this_ref))\n \tcollection_rec->def_vec[collection_rec->next_def++] = this_ref;\n       else if (DF_REF_FLAGS (this_ref) & DF_REF_IN_NOTE)\n \tcollection_rec->eq_use_vec[collection_rec->next_eq_use++] = this_ref;\n@@ -2701,7 +2793,8 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n \n \n static void\n-df_ref_record (struct df_collection_rec *collection_rec,\n+df_ref_record (enum df_ref_class cl, \n+\t       struct df_collection_rec *collection_rec,\n                rtx reg, rtx *loc, \n \t       basic_block bb, struct df_insn_info *insn_info,\n \t       enum df_ref_type ref_type, \n@@ -2720,7 +2813,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n         = (struct df_scan_problem_data *) df_scan->problem_data;\n       unsigned int i;\n       unsigned int endregno;\n-      struct df_ref *ref;\n+      df_ref ref;\n \n       if (GET_CODE (reg) == SUBREG)\n \t{\n@@ -2754,7 +2847,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n \n       for (i = regno; i < endregno; i++)\n \t{\n-\t  ref = df_ref_create_structure (collection_rec, regno_reg_rtx[i], loc, \n+\t  ref = df_ref_create_structure (cl, collection_rec, regno_reg_rtx[i], loc, \n \t\t\t\t\t bb, insn_info, ref_type, ref_flags, \n \t\t\t\t\t width, offset, mode);\n \n@@ -2763,9 +2856,8 @@ df_ref_record (struct df_collection_rec *collection_rec,\n     }\n   else\n     {\n-      struct df_ref *ref;\n-      ref = df_ref_create_structure (collection_rec, reg, loc, bb, insn_info, \n-                                     ref_type, ref_flags, width, offset, mode);\n+      df_ref_create_structure (cl, collection_rec, reg, loc, bb, insn_info, \n+\t\t\t       ref_type, ref_flags, width, offset, mode);\n     }\n }\n \n@@ -2802,6 +2894,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   int offset = -1;\n   int width = -1;\n   enum machine_mode mode = 0;\n+  enum df_ref_class cl = DF_REF_REGULAR;\n \n  /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n@@ -2847,6 +2940,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \t  width = INTVAL (XEXP (dst, 1));\n \t  offset = INTVAL (XEXP (dst, 2));\n \t  mode = GET_MODE (dst);\n+\t  cl = DF_REF_EXTRACT;\n \t}\n \n       loc = &XEXP (dst, 0);\n@@ -2856,14 +2950,14 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   /* At this point if we do not have a reg or a subreg, just return.  */\n   if (REG_P (dst))\n     {\n-      df_ref_record (collection_rec, \n+      df_ref_record (cl, collection_rec, \n \t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n \t\t     width, offset, mode);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n-\tdf_ref_record (collection_rec,\n+\tdf_ref_record (DF_REF_BASE, collection_rec,\n \t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags, \n \t\t       width, offset, mode);\n     }\n@@ -2874,7 +2968,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \n       flags |= DF_REF_SUBREG;\n \n-      df_ref_record (collection_rec, \n+      df_ref_record (cl, collection_rec, \n \t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n \t\t     width, offset, mode);\n     }\n@@ -2921,7 +3015,7 @@ df_defs_record (struct df_collection_rec *collection_rec,\n    those flags were set.  */\n \n static void\n-df_uses_record (struct df_collection_rec *collection_rec,\n+df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n \t\tbasic_block bb, struct df_insn_info *insn_info,\n \t\tenum df_ref_flags flags,\n@@ -2954,7 +3048,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (MEM_P (XEXP (x, 0)))\n-\tdf_uses_record (collection_rec,\n+\tdf_uses_record (cl, collection_rec,\n \t\t\t&XEXP (XEXP (x, 0), 0),\n \t\t\tDF_REF_REG_MEM_STORE,\n \t\t        bb, insn_info,\n@@ -2964,7 +3058,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       return;\n \n     case MEM:\n-      df_uses_record (collection_rec,\n+      df_uses_record (cl, collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD, \n \t\t      bb, insn_info, flags & DF_REF_IN_NOTE, \n \t\t      width, offset, mode);\n@@ -2977,14 +3071,14 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (collection_rec, loc, ref_type, bb, insn_info, flags, \n+\t  df_uses_record (cl, collection_rec, loc, ref_type, bb, insn_info, flags, \n \t\t\t  width, offset, mode);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n-      df_ref_record (collection_rec, \n+      df_ref_record (cl, collection_rec, \n \t\t     x, loc, bb, insn_info,\n \t\t     ref_type, flags, \n \t\t     width, offset, mode);\n@@ -3008,7 +3102,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t    else\n \t      flags |= DF_REF_SIGN_EXTRACT;\n \n-\t    df_uses_record (collection_rec,\n+\t    df_uses_record (DF_REF_EXTRACT, collection_rec,\n \t\t\t    &XEXP (x, 0), ref_type, bb, insn_info, flags, \n \t\t\t    width, offset, mode);\n \t    return;\n@@ -3020,7 +3114,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       {\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n-\tdf_uses_record (collection_rec,\n+\tdf_uses_record (cl, collection_rec,\n \t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\twidth, offset, mode);\n \n@@ -3029,7 +3123,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t    case SUBREG:\n \t      if (df_read_modify_subreg_p (dst))\n \t\t{\n-\t\t  df_uses_record (collection_rec, &SUBREG_REG (dst), \n+\t\t  df_uses_record (cl, collection_rec, &SUBREG_REG (dst), \n \t\t\t\t  DF_REF_REG_USE, bb, insn_info, \n \t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, \n \t\t\t\t  width, offset, mode);\n@@ -3043,7 +3137,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t    case CC0:\n \t\tbreak;\n \t    case MEM:\n-\t      df_uses_record (collection_rec, &XEXP (dst, 0),\n+\t      df_uses_record (cl, collection_rec, &XEXP (dst, 0),\n \t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n \t      break;\n@@ -3053,7 +3147,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\t/* A strict_low_part uses the whole REG and not just the\n \t\t SUBREG.  */\n \t\tdst = XEXP (dst, 0);\n-\t\tdf_uses_record (collection_rec, \n+\t\tdf_uses_record (cl, collection_rec, \n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n \t\t\t\tDF_REF_REG_USE, bb, insn_info,\n \t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, \n@@ -3068,21 +3162,25 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\t    width = INTVAL (XEXP (dst, 1));\n \t\t    offset = INTVAL (XEXP (dst, 2));\n \t\t    mode = GET_MODE (dst);\n+\t\t    df_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (dst, 0), \n+\t\t\t\tDF_REF_REG_USE, bb, insn_info, \n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n+\t\t\t\twidth, offset, mode);\n \t\t  }\n \t\telse \n \t\t  {\n-\t\t    df_uses_record (collection_rec, &XEXP (dst, 1), \n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 1), \n \t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t\t    width, offset, mode);\n-\t\t    df_uses_record (collection_rec, &XEXP (dst, 2), \n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 2), \n \t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t\t    width, offset, mode);\n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 0), \n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info, \n+\t\t\t\t    DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n+\t\t\t\t    width, offset, mode);\n \t\t  }\n \n-\t\tdf_uses_record (collection_rec, &XEXP (dst, 0), \n-\t\t\t\tDF_REF_REG_USE, bb, insn_info, \n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n-\t\t\t\twidth, offset, mode);\n \t      }\n \t      break;\n \n@@ -3131,7 +3229,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t    int j;\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n-\t      df_uses_record (collection_rec, &ASM_OPERANDS_INPUT (x, j),\n+\t      df_uses_record (cl, collection_rec, &ASM_OPERANDS_INPUT (x, j),\n \t\t\t      DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n \t    return;\n@@ -3146,7 +3244,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       /* Catch the def of the register being modified.  */\n-      df_ref_record (collection_rec, XEXP (x, 0), &XEXP (x, 0),\n+      df_ref_record (cl, collection_rec, XEXP (x, 0), &XEXP (x, 0),\n \t\t     bb, insn_info, \n \t\t     DF_REF_REG_DEF,\n                      flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, \n@@ -3173,15 +3271,15 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tloc = &XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    df_uses_record (collection_rec, &XEXP (x, i), ref_type, \n+\t    df_uses_record (cl, collection_rec, &XEXP (x, i), ref_type, \n \t\t\t    bb, insn_info, flags, \n \t\t\t    width, offset, mode);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      df_uses_record (collection_rec,\n+\t      df_uses_record (cl, collection_rec,\n \t\t\t      &XVECEXP (x, i, j), ref_type, \n \t\t\t      bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n@@ -3201,13 +3299,13 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n   unsigned int i;\n   for (i = 0; i < collection_rec->next_def; i++)\n     {\n-      struct df_ref *ref = collection_rec->def_vec[i];\n+      df_ref ref = collection_rec->def_vec[i];\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_CONDITIONAL))\n         {\n \t  int width = -1;\n \t  int offset = -1;\n \t  enum machine_mode mode = 0;\n-          struct df_ref *use;\n+          df_ref use;\n \n \t  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n \t    {\n@@ -3216,7 +3314,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n \t      mode = DF_REF_EXTRACT_MODE (ref);\n \t    }\n \n-          use = df_ref_create_structure (collection_rec, DF_REF_REG (ref),\n+          use = df_ref_create_structure (DF_REF_CLASS (ref), collection_rec, DF_REF_REG (ref),\n \t\t\t\t\t DF_REF_LOC (ref), DF_REF_BB (ref),\n \t\t\t\t\t DF_REF_INSN_INFO (ref), DF_REF_REG_USE,\n \t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL,\n@@ -3247,7 +3345,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n      depending on which def is seen first.  */\n   for (i=0; i<collection_rec->next_def; i++)\n     {\n-      struct df_ref *def = collection_rec->def_vec[i];\n+      df_ref def = collection_rec->def_vec[i];\n       bitmap_set_bit (defs_generated, DF_REF_REGNO (def));\n     }\n \n@@ -3257,7 +3355,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n        note = XEXP (note, 1))\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n-        df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n+        df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (XEXP (note, 0), 0),\n \t\t\tDF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n@@ -3269,13 +3367,13 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t\t\t\tinsn_info, flags);\n \t    }\n \t  else\n-\t    df_uses_record (collection_rec, &XEXP (note, 0),\n+\t    df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (note, 0),\n \t\t            DF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n-  df_ref_record (collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n+  df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n \t\t NULL, bb, insn_info, DF_REF_REG_USE,\n \t\t DF_REF_CALL_STACK_USAGE | flags, \n \t\t -1, -1, 0);\n@@ -3285,9 +3383,9 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n       {\n-\tdf_ref_record (collection_rec, regno_reg_rtx[i],\n+\tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n \t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags, -1, -1, 0);\n-\tdf_ref_record (collection_rec, regno_reg_rtx[i],\n+\tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n \t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags, -1, -1, 0);\n       }\n \n@@ -3300,7 +3398,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t      || !bitmap_bit_p (df->exit_block_uses, ui)\n \t      || refers_to_regno_p (ui, ui+1, \n \t\t\t\t    crtl->return_rtx, NULL)))\n-        df_ref_record (collection_rec, regno_reg_rtx[ui], \n+        df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui], \n \t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n \t\t       DF_REF_MAY_CLOBBER | flags, \n \t\t       -1, -1, 0);\n@@ -3339,18 +3437,18 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         {\n         case REG_EQUIV:\n         case REG_EQUAL:\n-          df_uses_record (collection_rec,\n+          df_uses_record (DF_REF_REGULAR, collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n                           bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n-          df_ref_record (collection_rec,\n+          df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n                          DF_REF_REG_USE, 0, -1, -1, 0);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-          df_ref_record (collection_rec,\n+          df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n                          DF_REF_REG_USE, 0, -1, -1, 0);\n@@ -3366,7 +3464,7 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n \t\t      (is_cond_exec) ? DF_REF_CONDITIONAL : 0);\n \n   /* Record the register uses.  */\n-  df_uses_record (collection_rec,\n+  df_uses_record (DF_REF_REGULAR, collection_rec,\n \t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0, \n \t\t  -1, -1, 0);\n \n@@ -3450,7 +3548,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t  unsigned regno = EH_RETURN_DATA_REGNO (i);\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n-\t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n+\t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n \t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n \t}\n     }\n@@ -3474,15 +3572,15 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n          eh-receiver for all of the edges at once. */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (EH_USES (i))\n-\t  df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n+\t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n \t\t\t bb, NULL, DF_REF_REG_USE, DF_REF_AT_TOP, -1, -1, 0);\n     }\n #endif\n \n   /* Add the hard_frame_pointer if this block is the target of a\n      non-local goto.  */\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n-    df_ref_record (collection_rec, hard_frame_pointer_rtx, NULL,\n+    df_ref_record (DF_REF_ARTIFICIAL, collection_rec, hard_frame_pointer_rtx, NULL,\n \t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n  \n   /* Add the artificial uses.  */\n@@ -3496,7 +3594,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n-\t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n+\t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n \t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n \t}\n     }\n@@ -3515,9 +3613,9 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n   int luid = 0;\n   struct df_scan_bb_info *bb_info;\n   struct df_collection_rec collection_rec;\n-  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.def_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (df_ref, 1000);\n   collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   if (!df)\n@@ -3789,7 +3887,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n \n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n-      df_ref_record (collection_rec, regno_reg_rtx[i], NULL, \n+      df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL, \n \t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1, 0);\n     }\n \n@@ -3805,7 +3903,7 @@ df_record_entry_block_defs (bitmap entry_block_defs)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, FIRST_PSEUDO_REGISTER);\n+  collection_rec.def_vec = XALLOCAVEC (df_ref, FIRST_PSEUDO_REGISTER);\n \n   df_entry_block_defs_collect (&collection_rec, entry_block_defs);\n \n@@ -3950,7 +4048,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n-    df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n+    df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n \t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n@@ -3960,7 +4058,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n       && !bitmap_bit_p (exit_block_uses, ARG_POINTER_REGNUM)\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n-    df_ref_record (collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n+    df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n \t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n #endif\n \n@@ -3976,7 +4074,7 @@ df_record_exit_block_uses (bitmap exit_block_uses)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, FIRST_PSEUDO_REGISTER);\n+  collection_rec.use_vec = XALLOCAVEC (df_ref, FIRST_PSEUDO_REGISTER);\n \n   df_exit_block_uses_collect (&collection_rec, exit_block_uses);\n \n@@ -4183,11 +4281,11 @@ df_compute_regs_ever_live (bool reset)\n are in the correct chain.  */ \n \n static unsigned int\n-df_reg_chain_mark (struct df_ref *refs, unsigned int regno, \n+df_reg_chain_mark (df_ref refs, unsigned int regno, \n \t\t   bool is_def, bool is_eq_use)\n {\n   unsigned int count = 0;\n-  struct df_ref *ref;\n+  df_ref ref;\n   for (ref = refs; ref; ref = DF_REF_NEXT_REG (ref))\n     {\n       gcc_assert (!DF_REF_IS_REG_MARKED (ref));\n@@ -4200,17 +4298,17 @@ df_reg_chain_mark (struct df_ref *refs, unsigned int regno,\n       /* Check to make sure the ref is in the correct chain.  */\n       gcc_assert (DF_REF_REGNO (ref) == regno);\n       if (is_def)\n-\tgcc_assert (DF_REF_TYPE(ref) == DF_REF_REG_DEF);\n+\tgcc_assert (DF_REF_REG_DEF_P (ref));\n       else\n-\tgcc_assert (DF_REF_TYPE(ref) != DF_REF_REG_DEF);\n+\tgcc_assert (!DF_REF_REG_DEF_P (ref));\n \n       if (is_eq_use)\n \tgcc_assert ((DF_REF_FLAGS (ref) & DF_REF_IN_NOTE));\n       else\n \tgcc_assert ((DF_REF_FLAGS (ref) & DF_REF_IN_NOTE) == 0);\n \n-      if (ref->next_reg)\n-\tgcc_assert (ref->next_reg->prev_reg == ref);\n+      if (DF_REF_NEXT_REG (ref))\n+\tgcc_assert (DF_REF_PREV_REG (DF_REF_NEXT_REG (ref)) == ref);\n       count++;\n       DF_REF_REG_MARK (ref);\n     }\n@@ -4221,9 +4319,9 @@ df_reg_chain_mark (struct df_ref *refs, unsigned int regno,\n /* Verify that all of the registers in the chain are unmarked.  */ \n \n static void\n-df_reg_chain_verify_unmarked (struct df_ref *refs)\n+df_reg_chain_verify_unmarked (df_ref refs)\n {\n-  struct df_ref *ref;\n+  df_ref ref;\n   for (ref = refs; ref; ref = DF_REF_NEXT_REG (ref))\n     gcc_assert (!DF_REF_IS_REG_MARKED (ref));\n }\n@@ -4232,7 +4330,7 @@ df_reg_chain_verify_unmarked (struct df_ref *refs)\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_refs_verify (struct df_ref **new_rec, struct df_ref **old_rec,\n+df_refs_verify (df_ref *new_rec, df_ref *old_rec,\n \t\tbool abort_if_fail)\n {\n   while ((*new_rec) && (*old_rec))\n@@ -4350,14 +4448,14 @@ df_bb_verify (basic_block bb)\n   struct df_collection_rec collection_rec;\n   \n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n-  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.def_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (df_ref, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (df_ref, 1000);\n   collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   gcc_assert (bb_info);\n \n-  /* Scan the block an insn at a time from beginning to end.  */\n+  /* Scan the block, one insn at a time, from beginning to end.  */\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       if (!INSN_P (insn))"}, {"sha": "979065aa269c24edbaf6be34d81d64b9214ce85f", "filename": "gcc/df.h", "status": "modified", "additions": 134, "deletions": 97, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -34,6 +34,8 @@ struct dataflow;\n struct df;\n struct df_problem;\n struct df_link;\n+struct df_insn_info;\n+union df_ref_d;\n \n /* Data flow problems.  All problems must have a unique id here.  */ \n \n@@ -68,13 +70,14 @@ enum df_mm\n     DF_MM_MUST\n   };\n \n-/* The first of these is a set of a register.  The remaining three are\n-   all uses of a register (the mem_load and mem_store relate to how\n-   the register as an addressing operand).  */\n-enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n-\t\t  DF_REF_REG_MEM_STORE};\n+/* Descriminator for the various df_ref types.  */\n+enum df_ref_class {DF_REF_BASE, DF_REF_ARTIFICIAL, DF_REF_REGULAR, DF_REF_EXTRACT};\n \n-#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n+/* The first of these us a set of a registers.  The remaining three\n+   are all uses of a register (the mem_load and mem_store relate to\n+   how the register as an addressing operand).  */\n+enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE,\n+\t\t  DF_REF_REG_MEM_LOAD, DF_REF_REG_MEM_STORE};\n \n enum df_ref_flags\n   {\n@@ -346,75 +349,106 @@ struct df_mw_hardreg\n };\n  \n \n-/* One of these structures is allocated for every insn.  */\n-struct df_insn_info\n-{\n-  rtx insn;                     /* The insn this info comes from.  */\n-  struct df_ref **defs;\t        /* Head of insn-def chain.  */\n-  struct df_ref **uses;\t        /* Head of insn-use chain.  */\n-  /* Head of insn-use chain for uses in REG_EQUAL/EQUIV notes.  */\n-  struct df_ref **eq_uses;       \n-  struct df_mw_hardreg **mw_hardregs;\n-  /* The logical uid of the insn in the basic block.  This is valid\n-     after any call to df_analyze but may rot after insns are added,\n-     deleted or moved. */\n-  int luid; \n-};\n-\n-\n /* Define a register reference structure.  One of these is allocated\n-   for every register reference (use or def).  Note some register\n-   references (e.g., post_inc, subreg) generate both a def and a use.  */\n-struct df_ref\n+    for every register reference (use or def).  Note some register\n+    references (e.g., post_inc, subreg) generate both a def and a use.  */\n+struct df_base_ref\n {\n-  rtx reg;\t\t\t/* The register referenced.  */\n-  basic_block bb;               /* Basic block containing the instruction. */\n-\n-  /* Insn info for the insn containing ref. This will be null if this is\n-     an artificial reference.  */\n-  struct df_insn_info *insn_info;\n+  /* These three bitfields are intentionally oversized, in the hope that\n+     accesses to 8 and 16-bit fields will usually be quicker.  */\n+  ENUM_BITFIELD(df_ref_class) cl : 8;\n \n-  rtx *loc;\t\t\t/* The location of the reg.  */\n+  ENUM_BITFIELD(df_ref_type) type : 8;\n+\t\t\t\t/* Type of ref.  */\n+  ENUM_BITFIELD(df_ref_flags) flags : 16;\n+\t\t\t\t/* Various flags.  */\n+  rtx reg;\t\t\t/* The register referenced.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n+  /* Pointer to the insn info of the containing instruction.  FIXME! \n+     Currently this is NULL for artificial refs but this will be used\n+     when FUDs are added.  */ \n+  struct df_insn_info *insn_info;\n+  /* For each regno, there are three chains of refs, one for the uses,\n+     the eq_uses and the defs.  These chains go thru the refs\n+     themselves rather than using an external structure.  */\n+  union df_ref_d *next_reg;     /* Next ref with same regno and type.  */\n+  union df_ref_d *prev_reg;     /* Prev ref with same regno and type.  */\n+  unsigned int regno;\t\t/* The register number referenced.  */\n   /* Location in the ref table.  This is only valid after a call to \n      df_maybe_reorganize_[use,def]_refs which is an expensive operation.  */\n   int id;\n   /* The index at which the operand was scanned in the insn.  This is\n      used to totally order the refs in an insn.  */\n   unsigned int ref_order;\n+};\n \n-  unsigned int regno;\t\t/* The register number referenced.  */\n-  /* These two bitfields are intentionally oversized, in the hope that\n-     accesses to 16-bit fields will usually be quicker.  */\n-  ENUM_BITFIELD(df_ref_type) type : 16;\n-\t\t\t\t/* Type of ref.  */\n-  ENUM_BITFIELD(df_ref_flags) flags : 16;\n-\t\t\t\t/* Various flags.  */\n \n-  /* For each regno, there are three chains of refs, one for the uses,\n-     the eq_uses and the defs.  These chains go thru the refs\n-     themselves rather than using an external structure.  */\n-  struct df_ref *next_reg;     /* Next ref with same regno and type.  */\n-  struct df_ref *prev_reg;     /* Prev ref with same regno and type.  */\n+/* The three types of df_refs.  Note that the df_ref_extract is an\n+   extension of the df_regular_ref, not the df_base_ref.  */  \n+struct df_artificial_ref\n+{\n+  struct df_base_ref base;\n+\n+  /* Artificial refs do not have an insn, so to get the basic block,\n+     it must be explicitly here.  */\n+  basic_block bb;\n+};\n+\n+\n+struct df_regular_ref\n+{\n+  struct df_base_ref base;\n+  /* The loc is the address in the insn of the reg.  This is not\n+     defined for special registers, such as clobbers and stack\n+     pointers that are also associated with call insns and so those\n+     just use the base.  */\n+  rtx *loc;\n };\n \n+\n /* A df_ref_extract is just a df_ref with a width and offset field at\n    the end of it.  It is used to hold this information if the ref was\n    wrapped by a SIGN_EXTRACT or a ZERO_EXTRACT and to pass this info\n    to passes that wish to process partial regs precisely.  */\n-struct df_ref_extract\n+struct df_extract_ref\n {\n-  struct df_ref ref;\n+  struct df_regular_ref base;\n   int width;\n   int offset;\n   enum machine_mode mode;\n };\n \n+/* Union of the different kinds of defs/uses placeholders.  */\n+union df_ref_d\n+{\n+  struct df_base_ref base;\n+  struct df_regular_ref regular_ref;\n+  struct df_artificial_ref artificial_ref;\n+  struct df_extract_ref extract_ref;\n+};\n+typedef union df_ref_d *df_ref;\n+\n+\n+/* One of these structures is allocated for every insn.  */\n+struct df_insn_info\n+{\n+  rtx insn;                     /* The insn this info comes from.  */\n+  df_ref *defs;\t                /* Head of insn-def chain.  */\n+  df_ref *uses;\t                /* Head of insn-use chain.  */\n+  /* Head of insn-use chain for uses in REG_EQUAL/EQUIV notes.  */\n+  df_ref *eq_uses;       \n+  struct df_mw_hardreg **mw_hardregs;\n+  /* The logical uid of the insn in the basic block.  This is valid\n+     after any call to df_analyze but may rot after insns are added,\n+     deleted or moved. */\n+  int luid; \n+};\n+ \n /* These links are used for ref-ref chains.  Currently only DEF-USE and\n    USE-DEF chains can be built by DF.  */\n struct df_link\n {\n-  struct df_ref *ref;\n+  df_ref ref;\n   struct df_link *next;\n };\n \n@@ -454,7 +488,7 @@ enum df_changeable_flags\n    boundary of the df_set_blocks if that has been defined.  */\n struct df_ref_info\n {\n-  struct df_ref **refs;         /* Ref table, indexed by id.  */\n+  df_ref *refs;                 /* Ref table, indexed by id.  */\n   unsigned int *begin;          /* First ref_index for this pseudo.  */\n   unsigned int *count;          /* Count of refs for this pseudo.  */\n   unsigned int refs_size;       /* Size of currently allocated refs table.  */\n@@ -476,7 +510,7 @@ struct df_ref_info\n struct df_reg_info\n {\n   /* Head of chain for refs of that type and regno.  */\n-  struct df_ref *reg_chain;\n+  df_ref reg_chain;\n   /* Number of refs in the chain.  */\n   unsigned int n_refs;\n };\n@@ -604,53 +638,56 @@ struct df\n /* Macros to access the elements within the ref structure.  */\n \n \n-#define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n-\t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n-#define DF_REF_REGNO(REF) ((REF)->regno)\n-#define DF_REF_REAL_LOC(REF) (GET_CODE (*((REF)->loc)) == SUBREG \\\n-                               ? &SUBREG_REG (*((REF)->loc)) : ((REF)->loc))\n-#define DF_REF_REG(REF) ((REF)->reg)\n-#define DF_REF_LOC(REF) ((REF)->loc)\n-#define DF_REF_BB(REF) ((REF)->bb)\n+#define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->base.reg) == SUBREG \\\n+\t\t\t\t? SUBREG_REG ((REF)->base.reg) : ((REF)->base.reg))\n+#define DF_REF_REGNO(REF) ((REF)->base.regno)\n+#define DF_REF_REAL_LOC(REF) (GET_CODE (*((REF)->regular_ref.loc)) == SUBREG \\\n+                               ? &SUBREG_REG (*((REF)->regular_ref.loc)) : ((REF)->regular_ref.loc))\n+#define DF_REF_REG(REF) ((REF)->base.reg)\n+#define DF_REF_LOC(REF) ((DF_REF_CLASS(REF) == DF_REF_REGULAR || DF_REF_CLASS(REF) == DF_REF_EXTRACT) ? \\\n+\t\t\t (REF)->regular_ref.loc : NULL)\n+#define DF_REF_BB(REF) (DF_REF_IS_ARTIFICIAL(REF) ? \\\n+                        (REF)->artificial_ref.bb : BLOCK_FOR_INSN (DF_REF_INSN(REF)))\n #define DF_REF_BBNO(REF) (DF_REF_BB (REF)->index)\n-#define DF_REF_INSN_INFO(REF) ((REF)->insn_info)\n-#define DF_REF_INSN(REF) ((REF)->insn_info->insn)\n+#define DF_REF_INSN_INFO(REF) ((REF)->base.insn_info)\n+#define DF_REF_INSN(REF) ((REF)->base.insn_info->insn)\n #define DF_REF_INSN_UID(REF) (INSN_UID (DF_REF_INSN(REF)))\n-#define DF_REF_TYPE(REF) ((REF)->type)\n-#define DF_REF_CHAIN(REF) ((REF)->chain)\n-#define DF_REF_ID(REF) ((REF)->id)\n-#define DF_REF_FLAGS(REF) ((REF)->flags)\n+#define DF_REF_CLASS(REF) ((REF)->base.cl)\n+#define DF_REF_TYPE(REF) ((REF)->base.type)\n+#define DF_REF_CHAIN(REF) ((REF)->base.chain)\n+#define DF_REF_ID(REF) ((REF)->base.id)\n+#define DF_REF_FLAGS(REF) ((REF)->base.flags)\n #define DF_REF_FLAGS_IS_SET(REF, v) ((DF_REF_FLAGS (REF) & (v)) != 0)\n #define DF_REF_FLAGS_SET(REF, v) (DF_REF_FLAGS (REF) |= (v))\n #define DF_REF_FLAGS_CLEAR(REF, v) (DF_REF_FLAGS (REF) &= ~(v))\n-#define DF_REF_ORDER(REF) ((REF)->ref_order)\n-/* If DF_REF_IS_ARTIFICIAL () is true, this is not a real definition/use, \n-   but an artificial one created to model \n-   always live registers, eh uses, etc.  \n-   ARTIFICIAL refs has NULL insn.  */\n-#define DF_REF_IS_ARTIFICIAL(REF) ((REF)->insn_info == NULL)\n+#define DF_REF_ORDER(REF) ((REF)->base.ref_order)\n+/* If DF_REF_IS_ARTIFICIAL () is true, this is not a real\n+   definition/use, but an artificial one created to model always live\n+   registers, eh uses, etc.  */\n+#define DF_REF_IS_ARTIFICIAL(REF) (DF_REF_CLASS(REF) == DF_REF_ARTIFICIAL)\n #define DF_REF_REG_MARK(REF) (DF_REF_FLAGS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_REG_UNMARK(REF) (DF_REF_FLAGS_CLEAR ((REF),DF_REF_REG_MARKER))\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n-#define DF_REF_NEXT_REG(REF) ((REF)->next_reg)\n-#define DF_REF_PREV_REG(REF) ((REF)->prev_reg)\n+#define DF_REF_NEXT_REG(REF) ((REF)->base.next_reg)\n+#define DF_REF_PREV_REG(REF) ((REF)->base.prev_reg)\n /* The following two macros may only be applied if one of \n    DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */ \n-#define DF_REF_EXTRACT_WIDTH(REF) (((struct df_ref_extract *)(REF))->width)\n-#define DF_REF_EXTRACT_WIDTH_CONST(REF) (((const struct df_ref_extract *)(REF))->width)\n-#define DF_REF_EXTRACT_OFFSET(REF) (((struct df_ref_extract *)(REF))->offset)\n-#define DF_REF_EXTRACT_OFFSET_CONST(REF) (((const struct df_ref_extract *)(REF))->offset)\n-#define DF_REF_EXTRACT_MODE(REF) (((struct df_ref_extract *)(REF))->mode)\n-#define DF_REF_EXTRACT_MODE_CONST(REF) (((const struct df_ref_extract *)(REF))->mode)\n-/* Macros to determine the reference type.  */\n+#define DF_REF_EXTRACT_WIDTH(REF) ((REF)->extract_ref.width)\n+#define DF_REF_EXTRACT_OFFSET(REF) ((REF)->extract_ref.offset)\n+#define DF_REF_EXTRACT_MODE(REF) ((REF)->extract_ref.mode)\n \n+/* Macros to determine the reference type.  */\n #define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n #define DF_REF_REG_USE_P(REF) ((REF) && !DF_REF_REG_DEF_P (REF))\n #define DF_REF_REG_MEM_STORE_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_STORE)\n #define DF_REF_REG_MEM_LOAD_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_LOAD)\n #define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n                                || DF_REF_REG_MEM_LOAD_P (REF))\n \n+#define DF_MWS_REG_DEF_P(MREF) (DF_MWS_TYPE (MREF) == DF_REF_REG_DEF)\n+#define DF_MWS_REG_USE_P(MREF) ((MREF) && !DF_MWS_REG_DEF_P (MREF))\n+#define DF_MWS_TYPE(MREF) ((MREF)->type)\n+\n /* Macros to get the refs out of def_info or use_info refs table.  If\n    the focus of the dataflow has been set to some subset of blocks\n    with df_set_blocks, these macros will only find the uses and defs\n@@ -743,13 +780,13 @@ struct df_scan_bb_info\n \n      Blocks that are the targets of non-local goto's have the hard\n      frame pointer defined at the top of the block.  */\n-  struct df_ref **artificial_defs;\n+  df_ref *artificial_defs;\n \n   /* Blocks that are targets of exception edges may have some\n      artificial uses.  These are logically at the top of the block.\n \n      Most blocks have artificial uses at the bottom of the block.  */\n-  struct df_ref **artificial_uses;\n+  df_ref *artificial_uses;\n };\n \n \n@@ -866,11 +903,11 @@ extern void df_verify (void);\n #ifdef DF_DEBUG_CFG\n extern void df_check_cfg_clean (void);\n #endif\n-extern struct df_ref *df_bb_regno_first_def_find (basic_block, unsigned int);\n-extern struct df_ref *df_bb_regno_last_def_find (basic_block, unsigned int);\n-extern struct df_ref *df_find_def (rtx, rtx);\n+extern df_ref df_bb_regno_first_def_find (basic_block, unsigned int);\n+extern df_ref df_bb_regno_last_def_find (basic_block, unsigned int);\n+extern df_ref df_find_def (rtx, rtx);\n extern bool df_reg_defined (rtx, rtx);\n-extern struct df_ref *df_find_use (rtx, rtx);\n+extern df_ref df_find_use (rtx, rtx);\n extern bool df_reg_used (rtx, rtx);\n extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);\n extern void df_print_regset (FILE *file, bitmap r);\n@@ -880,25 +917,25 @@ extern void df_dump_region (FILE *);\n extern void df_dump_start (FILE *);\n extern void df_dump_top (basic_block, FILE *);\n extern void df_dump_bottom (basic_block, FILE *);\n-extern void df_refs_chain_dump (struct df_ref **, bool, FILE *);\n-extern void df_regs_chain_dump (struct df_ref *,  FILE *);\n+extern void df_refs_chain_dump (df_ref *, bool, FILE *);\n+extern void df_regs_chain_dump (df_ref,  FILE *);\n extern void df_insn_debug (rtx, bool, FILE *);\n extern void df_insn_debug_regno (rtx, FILE *);\n extern void df_regno_debug (unsigned int, FILE *);\n-extern void df_ref_debug (struct df_ref *, FILE *);\n+extern void df_ref_debug (df_ref, FILE *);\n extern void debug_df_insn (rtx);\n extern void debug_df_regno (unsigned int);\n extern void debug_df_reg (rtx);\n extern void debug_df_defno (unsigned int);\n extern void debug_df_useno (unsigned int);\n-extern void debug_df_ref (struct df_ref *);\n+extern void debug_df_ref (df_ref);\n extern void debug_df_chain (struct df_link *);\n \n /* Functions defined in df-problems.c. */\n \n-extern struct df_link *df_chain_create (struct df_ref *, struct df_ref *);\n-extern void df_chain_unlink (struct df_ref *);\n-extern void df_chain_copy (struct df_ref *, struct df_link *);\n+extern struct df_link *df_chain_create (df_ref, df_ref);\n+extern void df_chain_unlink (df_ref);\n+extern void df_chain_copy (df_ref, struct df_link *);\n extern bitmap df_get_live_in (basic_block);\n extern bitmap df_get_live_out (basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n@@ -933,10 +970,10 @@ extern void df_scan_add_problem (void);\n extern void df_grow_reg_info (void);\n extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n-extern struct df_ref *df_ref_create (rtx, rtx *, rtx,basic_block, \n+extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block, \n \t\t\t\t     enum df_ref_type, enum df_ref_flags,\n \t\t\t\t     int, int, enum machine_mode);\n-extern void df_ref_remove (struct df_ref *);\n+extern void df_ref_remove (df_ref);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);\n extern void df_bb_refs_record (int, bool);\n@@ -962,7 +999,7 @@ extern bool df_read_modify_subreg_p (rtx);\n extern void df_scan_verify (void);\n \n /* Functions defined in df-byte-scan.c.  */\n-extern bool df_compute_accessed_bytes (struct df_ref *, enum df_mm, \n+extern bool df_compute_accessed_bytes (df_ref, enum df_mm, \n \t\t\t\t       unsigned int *, unsigned int *);\n \n \n@@ -1015,7 +1052,7 @@ df_byte_lr_get_bb_info (unsigned int index)\n \n /* Get the artificial defs for a basic block.  */\n \n-static inline struct df_ref **\n+static inline df_ref *\n df_get_artificial_defs (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_defs;\n@@ -1024,7 +1061,7 @@ df_get_artificial_defs (unsigned int bb_index)\n \n /* Get the artificial uses for a basic block.  */\n \n-static inline struct df_ref **\n+static inline df_ref *\n df_get_artificial_uses (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_uses;\n@@ -1045,7 +1082,7 @@ struct web_entry\n \n extern struct web_entry *unionfind_root (struct web_entry *);\n extern bool unionfind_union (struct web_entry *, struct web_entry *);\n-extern void union_defs (struct df_ref *,\n+extern void union_defs (df_ref,\n                         struct web_entry *, struct web_entry *,\n \t\t\tbool (*fun) (struct web_entry *, struct web_entry *));\n "}, {"sha": "88be943b20d0d605fdfb2e5a782ddb4211498a1d", "filename": "gcc/fwprop.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -487,19 +487,19 @@ propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx,\n    between FROM to (but not including) TO.  */\n \n static bool\n-local_ref_killed_between_p (struct df_ref * ref, rtx from, rtx to)\n+local_ref_killed_between_p (df_ref ref, rtx from, rtx to)\n {\n   rtx insn;\n \n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n     {\n-      struct df_ref **def_rec;\n+      df_ref *def_rec;\n       if (!INSN_P (insn))\n \tcontinue;\n \n       for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  if (DF_REF_REGNO (ref) == DF_REF_REGNO (def))\n \t    return true;\n \t}\n@@ -517,12 +517,12 @@ local_ref_killed_between_p (struct df_ref * ref, rtx from, rtx to)\n      we check if the definition is killed after DEF_INSN or before\n      TARGET_INSN insn, in their respective basic blocks.  */\n static bool\n-use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n+use_killed_between (df_ref use, rtx def_insn, rtx target_insn)\n {\n   basic_block def_bb = BLOCK_FOR_INSN (def_insn);\n   basic_block target_bb = BLOCK_FOR_INSN (target_insn);\n   int regno;\n-  struct df_ref * def;\n+  df_ref def;\n \n   /* In some obscure situations we can have a def reaching a use\n      that is _before_ the def.  In other words the def does not\n@@ -543,7 +543,7 @@ use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n   regno = DF_REF_REGNO (use);\n   def = DF_REG_DEF_CHAIN (regno);\n   if (def\n-      && def->next_reg == NULL\n+      && DF_REF_NEXT_REG (def) == NULL\n       && regno >= FIRST_PSEUDO_REGISTER)\n     return false;\n \n@@ -555,7 +555,7 @@ use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n   if (single_pred_p (target_bb)\n       && single_pred (target_bb) == def_bb)\n     {\n-      struct df_ref *x;\n+      df_ref x;\n \n       /* See if USE is killed between DEF_INSN and the last insn in the\n \t basic block containing DEF_INSN.  */\n@@ -583,7 +583,7 @@ use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n static bool\n all_uses_available_at (rtx def_insn, rtx target_insn)\n {\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n   rtx def_set = single_set (def_insn);\n \n@@ -600,14 +600,14 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n          invalid.  */\n       for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  if (rtx_equal_p (DF_REF_REG (use), def_reg))\n \t    return false;\n \t}\n       for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n-\t  if (rtx_equal_p (use->reg, def_reg))\n+\t  df_ref use = *use_rec;\n+\t  if (rtx_equal_p (DF_REF_REG (use), def_reg))\n \t    return false;\n \t}\n     }\n@@ -617,13 +617,13 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n \t killed between DEF_INSN and TARGET_INSN.  */\n       for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  if (use_killed_between (use, def_insn, target_insn))\n \t    return false;\n \t}\n       for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  if (use_killed_between (use, def_insn, target_insn))\n \t    return false;\n \t}\n@@ -682,16 +682,16 @@ find_occurrence (rtx *px, rtx find)\n    in the data flow object of the pass.  Mark any new uses as having the\n    given TYPE.  */\n static void\n-update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n+update_df (rtx insn, rtx *loc, df_ref *use_rec, enum df_ref_type type,\n \t   int new_flags)\n {\n   bool changed = false;\n \n   /* Add a use for the registers that were propagated.  */\n   while (*use_rec)\n     {\n-      struct df_ref *use = *use_rec;\n-      struct df_ref *orig_use = use, *new_use;\n+      df_ref use = *use_rec;\n+      df_ref orig_use = use, new_use;\n       int width = -1;\n       int offset = -1;\n       enum machine_mode mode = 0;\n@@ -731,7 +731,7 @@ update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n    performed.  */\n \n static bool\n-try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_equal)\n+try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_equal)\n {\n   rtx insn = DF_REF_INSN (use);\n   enum df_ref_type type = DF_REF_TYPE (use);\n@@ -821,7 +821,7 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new_rtx, rtx def_insn, bool\n /* If USE is a paradoxical subreg, see if it can be replaced by a pseudo.  */\n \n static bool\n-forward_propagate_subreg (struct df_ref *use, rtx def_insn, rtx def_set)\n+forward_propagate_subreg (df_ref use, rtx def_insn, rtx def_set)\n {\n   rtx use_reg = DF_REF_REG (use);\n   rtx use_insn, src;\n@@ -856,7 +856,7 @@ forward_propagate_subreg (struct df_ref *use, rtx def_insn, rtx def_set)\n    result.  */\n \n static bool\n-forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n+forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n {\n   rtx use_insn = DF_REF_INSN (use);\n   rtx use_set = single_set (use_insn);\n@@ -952,10 +952,10 @@ forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n    definition, try to forward propagate it into that insn.  */\n \n static void\n-forward_propagate_into (struct df_ref *use)\n+forward_propagate_into (df_ref use)\n {\n   struct df_link *defs;\n-  struct df_ref *def;\n+  df_ref def;\n   rtx def_insn, def_set, use_insn;\n   rtx parent;\n \n@@ -1064,7 +1064,7 @@ fwprop (void)\n \n   for (i = 0; i < DF_USES_TABLE_SIZE (); i++)\n     {\n-      struct df_ref *use = DF_USES_GET (i);\n+      df_ref use = DF_USES_GET (i);\n       if (use)\n \tif (DF_REF_TYPE (use) == DF_REF_REG_USE\n \t    || DF_REF_BB (use)->loop_father == NULL\n@@ -1109,7 +1109,7 @@ fwprop_addr (void)\n \n   for (i = 0; i < DF_USES_TABLE_SIZE (); i++)\n     {\n-      struct df_ref *use = DF_USES_GET (i);\n+      df_ref use = DF_USES_GET (i);\n       if (use)\n \tif (DF_REF_TYPE (use) != DF_REF_REG_USE\n \t    && DF_REF_BB (use)->loop_father != NULL"}, {"sha": "edc2a42c5902db0fe8cde584719bed9ef852c865", "filename": "gcc/global.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -165,11 +165,11 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n       rtx insn;\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  struct df_ref **def_rec;\n+\t  df_ref *def_rec;\n \t  if (insn_contains_asm (insn))\n \t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n \t      {\n-\t\tstruct df_ref *def = *def_rec;\n+\t\tdf_ref def = *def_rec;\n \t\tunsigned int dregno = DF_REF_REGNO (def);\n \t\tif (dregno < FIRST_PSEUDO_REGISTER)\n \t\t  {\n@@ -1448,8 +1448,8 @@ build_insn_chain (void)\n \t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n \t    {\n \t      unsigned int uid = INSN_UID (insn);\n-\t      struct df_ref **def_rec;\n-\t      struct df_ref **use_rec;\n+\t      df_ref *def_rec;\n+\t      df_ref *use_rec;\n \n \t      c = new_insn_chain ();\n \t      c->next = next;\n@@ -1463,7 +1463,7 @@ build_insn_chain (void)\n \t      if (INSN_P (insn))\n \t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t\t  {\n-\t\t    struct df_ref *def = *def_rec;\n+\t\t    df_ref def = *def_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (def);\n \t\t    \n \t\t    /* Ignore may clobbers because these are generated\n@@ -1555,7 +1555,7 @@ build_insn_chain (void)\n \t      if (INSN_P (insn))\n \t\tfor (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t  {\n-\t\t    struct df_ref *use = *use_rec;\n+\t\t    df_ref use = *use_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    rtx reg = DF_REF_REG (use);\n \t\t    "}, {"sha": "cd148abd7a906d13671cbbee445cbda78646e9c8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -3922,10 +3922,10 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t  if (INSN_P (insn))\n \t    {\n \t      unsigned int uid = INSN_UID (insn);\n-\t      struct df_ref **def_rec;\n+\t      df_ref *def_rec;\n \t      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t\t{\n-\t\t  struct df_ref *def = *def_rec;\n+\t\t  df_ref def = *def_rec;\n \t\t  bitmap_set_bit (merge_set, DF_REF_REGNO (def));\n \t\t}\n \t    }"}, {"sha": "843f8a38443d72245492eeedd8b724ec5489a695", "filename": "gcc/init-regs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -70,13 +70,13 @@ initialize_uninitialized_regs (void)\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  unsigned int uid = INSN_UID (insn);\n-\t  struct df_ref **use_rec;\n+\t  df_ref *use_rec;\n \t  if (!INSN_P (insn))\n \t    continue;\n \n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      unsigned int regno = DF_REF_REGNO (use);\n \n \t      /* Only do this for the pseudos.  */"}, {"sha": "89343fe30f363633a21bc4179faed6f8f4e741ca", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -266,7 +266,7 @@ mark_reg_live (rtx reg)\n \n /* Mark the register referenced by use or def REF as live.  */\n static void\n-mark_ref_live (struct df_ref *ref)\n+mark_ref_live (df_ref ref)\n {\n   rtx reg;\n \n@@ -335,7 +335,7 @@ mark_reg_dead (rtx reg)\n /* Mark the register referenced by definition DEF as dead, if the\n    definition is a total one.  */\n static void\n-mark_ref_dead (struct df_ref *def)\n+mark_ref_dead (df_ref def)\n {\n   rtx reg;\n \n@@ -356,7 +356,7 @@ mark_early_clobbers (rtx insn, bool live_p)\n {\n   int alt;\n   int def;\n-  struct df_ref **def_rec;\n+  df_ref *def_rec;\n   bool set_p = false;\n \n   for (def = 0; def < recog_data.n_operands; def++)\n@@ -702,7 +702,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t pessimistic, but it probably doesn't matter much in practice.  */\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  struct df_ref **def_rec, **use_rec;\n+\t  df_ref *def_rec, *use_rec;\n \t  bool call_p;\n \t  \n \t  if (! INSN_P (insn))"}, {"sha": "5fbd713ac75b46c11abf3f046e6bc9a63bcc779d", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -1216,12 +1216,12 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n       rtx insn;\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  struct df_ref **def_rec;\n+\t  df_ref *def_rec;\n \n \t  if (insn_contains_asm (insn))\n \t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n \t      {\n-\t\tstruct df_ref *def = *def_rec;\n+\t\tdf_ref def = *def_rec;\n \t\tunsigned int dregno = DF_REF_REGNO (def);\n \t\tif (dregno < FIRST_PSEUDO_REGISTER)\n \t\t  {"}, {"sha": "648f239a65df8878ec8d5bc8e004b7d8337b373d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -1279,7 +1279,7 @@ block_alloc (basic_block b)\n   int insn_count = 0;\n   int max_uid = get_max_uid ();\n   int *qty_order;\n-  struct df_ref ** def_rec;\n+  df_ref *def_rec;\n \n   /* Count the instructions in the basic block.  */\n "}, {"sha": "9c0be87bc87e11350eaf82962363cbdcd31f6e0a", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -243,13 +243,13 @@ check_maybe_invariant (rtx x)\n    invariant.  */\n \n static struct invariant *\n-invariant_for_use (struct df_ref *use)\n+invariant_for_use (df_ref use)\n {\n   struct df_link *defs;\n-  struct df_ref *def;\n+  df_ref def;\n   basic_block bb = DF_REF_BB (use), def_bb;\n \n-  if (use->flags & DF_REF_READ_WRITE)\n+  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n     return NULL;\n \n   defs = DF_REF_CHAIN (use);\n@@ -276,7 +276,7 @@ hash_invariant_expr_1 (rtx insn, rtx x)\n   const char *fmt;\n   hashval_t val = code;\n   int do_not_record_p;\n-  struct df_ref *use;\n+  df_ref use;\n   struct invariant *inv;\n \n   switch (code)\n@@ -330,7 +330,7 @@ invariant_expr_equal_p (rtx insn1, rtx e1, rtx insn2, rtx e2)\n   enum rtx_code code = GET_CODE (e1);\n   int i, j;\n   const char *fmt;\n-  struct df_ref *use1, *use2;\n+  df_ref use1, use2;\n   struct invariant *inv1 = NULL, *inv2 = NULL;\n   rtx sub1, sub2;\n \n@@ -724,15 +724,15 @@ record_use (struct def *def, rtx *use, rtx insn)\n    loop invariants, false otherwise.  */\n \n static bool\n-check_dependency (basic_block bb, struct df_ref *use, bitmap depends_on)\n+check_dependency (basic_block bb, df_ref use, bitmap depends_on)\n {\n-  struct df_ref *def;\n+  df_ref def;\n   basic_block def_bb;\n   struct df_link *defs;\n   struct def *def_data;\n   struct invariant *inv;\n   \n-  if (use->flags & DF_REF_READ_WRITE)\n+  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n     return false;\n   \n   defs = DF_REF_CHAIN (use);\n@@ -772,7 +772,7 @@ static bool\n check_dependencies (rtx insn, bitmap depends_on)\n {\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n   for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n@@ -792,7 +792,7 @@ check_dependencies (rtx insn, bitmap depends_on)\n static void\n find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n {\n-  struct df_ref *ref;\n+  df_ref ref;\n   struct def *def;\n   bitmap depends_on;\n   rtx set, dest;\n@@ -855,19 +855,19 @@ static void\n record_uses (rtx insn)\n {\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  struct df_ref **use_rec;\n+  df_ref *use_rec;\n   struct invariant *inv;\n \n   for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, DF_REF_REAL_LOC (use), DF_REF_INSN (use));\n     }\n   for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, DF_REF_REAL_LOC (use), DF_REF_INSN (use));"}, {"sha": "2523963f36d7c537d64ba83917e55ca903b1672f", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -293,15 +293,15 @@ iv_analysis_loop_init (struct loop *loop)\n    is set to NULL and true is returned.  */\n \n static bool\n-latch_dominating_def (rtx reg, struct df_ref **def)\n+latch_dominating_def (rtx reg, df_ref *def)\n {\n-  struct df_ref *single_rd = NULL, *adef;\n+  df_ref single_rd = NULL, adef;\n   unsigned regno = REGNO (reg);\n   struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (current_loop->latch);\n \n-  for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = adef->next_reg)\n+  for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = DF_REF_NEXT_REG (adef))\n     {\n-      if (!bitmap_bit_p (df->blocks_to_analyze, DF_REF_BB (adef)->index)\n+      if (!bitmap_bit_p (df->blocks_to_analyze, DF_REF_BBNO (adef))\n \t  || !bitmap_bit_p (bb_info->out, DF_REF_ID (adef)))\n \tcontinue;\n \n@@ -322,9 +322,9 @@ latch_dominating_def (rtx reg, struct df_ref **def)\n /* Gets definition of REG reaching its use in INSN and stores it to DEF.  */\n \n static enum iv_grd_result\n-iv_get_reaching_def (rtx insn, rtx reg, struct df_ref **def)\n+iv_get_reaching_def (rtx insn, rtx reg, df_ref *def)\n {\n-  struct df_ref *use, *adef;\n+  df_ref use, adef;\n   basic_block def_bb, use_bb;\n   rtx def_insn;\n   bool dom_p;\n@@ -349,7 +349,7 @@ iv_get_reaching_def (rtx insn, rtx reg, struct df_ref **def)\n   adef = DF_REF_CHAIN (use)->ref;\n \n   /* We do not handle setting only part of the register.  */\n-  if (adef->flags & DF_REF_READ_WRITE)\n+  if (DF_REF_FLAGS (adef) & DF_REF_READ_WRITE)\n     return GRD_INVALID;\n \n   def_insn = DF_REF_INSN (adef);\n@@ -616,7 +616,7 @@ iv_shift (struct rtx_iv *iv, rtx mby)\n    at get_biv_step.  */\n \n static bool\n-get_biv_step_1 (struct df_ref *def, rtx reg,\n+get_biv_step_1 (df_ref def, rtx reg,\n \t\trtx *inner_step, enum machine_mode *inner_mode,\n \t\tenum rtx_code *extend, enum machine_mode outer_mode,\n \t\trtx *outer_step)\n@@ -625,7 +625,7 @@ get_biv_step_1 (struct df_ref *def, rtx reg,\n   rtx next, nextr, tmp;\n   enum rtx_code code;\n   rtx insn = DF_REF_INSN (def);\n-  struct df_ref *next_def;\n+  df_ref next_def;\n   enum iv_grd_result res;\n \n   set = single_set (insn);\n@@ -783,7 +783,7 @@ get_biv_step_1 (struct df_ref *def, rtx reg,\n    LAST_DEF is the definition of REG that dominates loop latch.  */\n \n static bool\n-get_biv_step (struct df_ref *last_def, rtx reg, rtx *inner_step,\n+get_biv_step (df_ref last_def, rtx reg, rtx *inner_step,\n \t      enum machine_mode *inner_mode, enum rtx_code *extend,\n \t      enum machine_mode *outer_mode, rtx *outer_step)\n {\n@@ -803,7 +803,7 @@ get_biv_step (struct df_ref *last_def, rtx reg, rtx *inner_step,\n /* Records information that DEF is induction variable IV.  */\n \n static void\n-record_iv (struct df_ref *def, struct rtx_iv *iv)\n+record_iv (df_ref def, struct rtx_iv *iv)\n {\n   struct rtx_iv *recorded_iv = XNEW (struct rtx_iv);\n \n@@ -849,7 +849,7 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n   rtx inner_step, outer_step;\n   enum machine_mode inner_mode, outer_mode;\n   enum rtx_code extend;\n-  struct df_ref *last_def;\n+  df_ref last_def;\n \n   if (dump_file)\n     {\n@@ -1042,7 +1042,7 @@ iv_analyze_expr (rtx insn, rtx rhs, enum machine_mode mode, struct rtx_iv *iv)\n /* Analyzes iv DEF and stores the result to *IV.  */\n \n static bool\n-iv_analyze_def (struct df_ref *def, struct rtx_iv *iv)\n+iv_analyze_def (df_ref def, struct rtx_iv *iv)\n {\n   rtx insn = DF_REF_INSN (def);\n   rtx reg = DF_REF_REG (def);\n@@ -1107,7 +1107,7 @@ iv_analyze_def (struct df_ref *def, struct rtx_iv *iv)\n static bool\n iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n {\n-  struct df_ref *def = NULL;\n+  df_ref def = NULL;\n   enum iv_grd_result res;\n \n   if (dump_file)\n@@ -1190,7 +1190,7 @@ iv_analyze (rtx insn, rtx val, struct rtx_iv *iv)\n bool\n iv_analyze_result (rtx insn, rtx def, struct rtx_iv *iv)\n {\n-  struct df_ref *adef;\n+  df_ref adef;\n \n   adef = df_find_def (insn, def);\n   if (!adef)\n@@ -1207,7 +1207,7 @@ bool\n biv_p (rtx insn, rtx reg)\n {\n   struct rtx_iv iv;\n-  struct df_ref *def, *last_def;\n+  df_ref def, last_def;\n \n   if (!simple_reg_p (reg))\n     return false;"}, {"sha": "e0ffbbd4c3ff43a66e9e5ed44d2fb3dddcf1b68f", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -54,7 +54,7 @@ HOST_WIDE_INT max_bitnum;\n alloc_pool adjacency_pool;\n adjacency_t **adjacency;\n \n-typedef struct df_ref * df_ref_t;\n+typedef df_ref df_ref_t;\n DEF_VEC_P(df_ref_t);\n DEF_VEC_ALLOC_P(df_ref_t,heap);\n \n@@ -278,7 +278,7 @@ record_one_conflict (sparseset allocnos_live,\n static void\n mark_reg_store (sparseset allocnos_live, \n \t\tHARD_REG_SET *hard_regs_live, \n-\t\tstruct df_ref *ref)\n+\t\tdf_ref ref)\n {\n   rtx reg = DF_REF_REG (ref);\n   unsigned int regno = DF_REF_REGNO (ref);\n@@ -448,7 +448,7 @@ clear_reg_in_live (sparseset allocnos_live,\n \t\t   sbitmap *live_subregs, \n \t\t   int *live_subregs_used,\n \t\t   HARD_REG_SET *hard_regs_live, \n-\t\t   rtx reg, struct df_ref *def)\n+\t\t   rtx reg, df_ref def)\n {\n   unsigned int regno = (GET_CODE (reg) == SUBREG) \n     ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n@@ -813,8 +813,8 @@ global_conflicts (void)\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n \t  unsigned int uid = INSN_UID (insn);\n-\t  struct df_ref **def_rec;\n-\t  struct df_ref **use_rec;\n+\t  df_ref *def_rec;\n+\t  df_ref *use_rec;\n \n \t  if (!INSN_P (insn))\n \t    continue;\t\n@@ -849,7 +849,7 @@ global_conflicts (void)\n \t     later.  */\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \n \t      /* FIXME: Ignoring may clobbers is technically the wrong\n \t\t thing to do.  However the old version of the this\n@@ -880,7 +880,7 @@ global_conflicts (void)\n \t  /* Add the interferences for the defs.  */\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n \t\tmark_reg_store (allocnos_live, &renumbers_live, def);\n \t    }\n@@ -891,7 +891,7 @@ global_conflicts (void)\n \t  VEC_truncate (df_ref_t, clobbers, 0);\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n \t\t{\n@@ -931,7 +931,7 @@ global_conflicts (void)\n \t  VEC_truncate (df_ref_t, dying_regs, 0);\n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      unsigned int regno = DF_REF_REGNO (use);\n \t      bool added = false;\n \t      int renumber = reg_renumber[regno];\n@@ -1079,12 +1079,12 @@ global_conflicts (void)\n \t\tfprintf (dump_file, \"  clobber conflicts\\n\");\n \t      for (k = VEC_length (df_ref_t, clobbers) - 1; k >= 0; k--)\n \t\t{\n-\t\t  struct df_ref *def = VEC_index (df_ref_t, clobbers, k);\n+\t\t  df_ref def = VEC_index (df_ref_t, clobbers, k);\n \t\t  int j;\n \n \t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n \t\t    {\n-\t\t      struct df_ref *use = VEC_index (df_ref_t, dying_regs, j);\n+\t\t      df_ref use = VEC_index (df_ref_t, dying_regs, j);\n \t\t      record_one_conflict_between_regnos (GET_MODE (DF_REF_REG (def)),\n \t\t\t\t\t\t\t  DF_REF_REGNO (def),\n \t\t\t\t\t\t\t  GET_MODE (DF_REF_REG (use)),\n@@ -1143,7 +1143,7 @@ global_conflicts (void)\n \t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n \t\t    {\n \t\t      int used_in_output = 0;\n-\t\t      struct df_ref *use = VEC_index (df_ref_t, dying_regs, j);\n+\t\t      df_ref use = VEC_index (df_ref_t, dying_regs, j);\n \t\t      rtx reg = DF_REF_REG (use);\n \t\t      int uregno = DF_REF_REGNO (use);\n \t\t      enum machine_mode umode = GET_MODE (DF_REF_REG (use));"}, {"sha": "d6e398930b7f4bab7e471f14c72e9661e216df95", "filename": "gcc/regstat.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -108,8 +108,8 @@ regstat_bb_compute_ri (unsigned int bb_index,\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n   int luid = 0;\n   bitmap_iterator bi;\n   unsigned int regno;\n@@ -126,14 +126,14 @@ regstat_bb_compute_ri (unsigned int bb_index,\n      to begin processing.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n \n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \t{\n \t  regno = DF_REF_REGNO (use);\n@@ -205,7 +205,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n       for (mws_rec = DF_INSN_UID_MWS (uid); *mws_rec; mws_rec++)\n \t{\n \t  struct df_mw_hardreg *mws = *mws_rec; \n-\t  if (mws->type == DF_REF_REG_DEF) \n+\t  if (DF_MWS_REG_DEF_P (mws)) \n \t    {\n \t      bool all_dead = true;\n \t      unsigned int r;\n@@ -232,7 +232,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t clobber.  This code is for the return.  */\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  if ((!CALL_P (insn))\n \t      || (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n \t    {\n@@ -281,7 +281,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n       \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n \t  if (uregno >= FIRST_PSEUDO_REGISTER)\n@@ -412,23 +412,23 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n-  struct df_ref **def_rec;\n-  struct df_ref **use_rec;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n \n   bitmap_copy (live, df_get_live_out (bb));\n \n   /* Process the artificial defs and uses at the bottom of the block\n      to begin processing.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n-      struct df_ref *def = *def_rec;\n+      df_ref def = *def_rec;\n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n \n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n-      struct df_ref *use = *use_rec;\n+      df_ref use = *use_rec;\n       if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n \tbitmap_set_bit (live, DF_REF_REGNO (use));\n     }\n@@ -456,7 +456,7 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n \t clobber.  This code is for the return.  */\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  if ((!CALL_P (insn))\n \t      || (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n \t    {\n@@ -468,7 +468,7 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n       \n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  bitmap_set_bit (live, DF_REF_REGNO (use));\n \t}\n     }"}, {"sha": "27e70216f052fa1f6b2eab743bf9bad5a25368e7", "filename": "gcc/see.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -3242,7 +3242,7 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n    happened and the optimization should be aborted.  */\n \n static int\n-see_handle_relevant_defs (struct df_ref *ref, rtx insn)\n+see_handle_relevant_defs (df_ref ref, rtx insn)\n {\n   struct web_entry *root_entry = NULL;\n   rtx se_insn = NULL;\n@@ -3311,7 +3311,7 @@ see_handle_relevant_defs (struct df_ref *ref, rtx insn)\n    happened and the optimization should be aborted.  */\n \n static int\n-see_handle_relevant_uses (struct df_ref *ref, rtx insn)\n+see_handle_relevant_uses (df_ref ref, rtx insn)\n {\n   struct web_entry *root_entry = NULL;\n   rtx se_insn = NULL;\n@@ -3367,28 +3367,28 @@ see_handle_relevant_refs (void)\n \n \t  if (INSN_P (insn))\n \t    {\n-\t      struct df_ref **use_rec;\n-\t      struct df_ref **def_rec;\n+\t      df_ref *use_rec;\n+\t      df_ref *def_rec;\n \t      \n \t      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  int result = see_handle_relevant_uses (use, insn);\n \t\t  if (result == -1)\n \t\t    return -1;\n \t\t  num_relevant_refs += result;\n \t\t}\n \t      for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  int result = see_handle_relevant_uses (use, insn);\n \t\t  if (result == -1)\n \t\t    return -1;\n \t\t  num_relevant_refs += result;\n \t\t}\n \t      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t\t{\n-\t\t  struct df_ref *def = *def_rec;\n+\t\t  df_ref def = *def_rec;\n \t\t  int result = see_handle_relevant_defs (def, insn);\n \t\t  if (result == -1)\n \t\t    return -1;\n@@ -3404,7 +3404,7 @@ see_handle_relevant_refs (void)\n /* Initialized the use_entry field for REF in INSN at INDEX with ET.  */\n \n static void\n-see_update_uses_relevancy (rtx insn, struct df_ref *ref, \n+see_update_uses_relevancy (rtx insn, df_ref ref, \n \t\t\t   enum entry_type et, unsigned int index)\n {\n   struct see_entry_extra_info *curr_entry_extra_info;\n@@ -3585,7 +3585,7 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n /* Initialized the def_entry field for REF in INSN at INDEX with ET.  */\n \n static void\n-see_update_defs_relevancy (rtx insn, struct df_ref *ref,\n+see_update_defs_relevancy (rtx insn, df_ref ref,\n \t\t\t   enum entry_type et,\n \t\t\t   enum machine_mode source_mode,\n \t\t\t   enum machine_mode source_mode_unsigned,\n@@ -3685,8 +3685,8 @@ see_update_relevancy (void)\n \n   FOR_ALL_BB (bb)\n     {\n-      struct df_ref **use_rec;\n-      struct df_ref **def_rec;\n+      df_ref *use_rec;\n+      df_ref *def_rec;\n       rtx insn;\n       FOR_BB_INSNS (bb, insn)\n \t{\n@@ -3697,22 +3697,22 @@ see_update_relevancy (void)\n \n \t      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  see_update_uses_relevancy (insn, use, et, u);\n \t\t  u++;\n \t\t}\n \t      \n \t      for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  see_update_uses_relevancy (insn, use, et, u);\n \t\t  u++;\n \t\t}\n \n \t      et = see_analyze_one_def (insn, &source_mode, &source_mode_unsigned);\n \t      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t\t{\n-\t\t  struct df_ref *def = *def_rec;\n+\t\t  df_ref def = *def_rec;\n \t\t  see_update_defs_relevancy (insn, def, et, source_mode, \n \t\t\t\t\t       source_mode_unsigned, d);\n \t\t  d++;\n@@ -3722,14 +3722,14 @@ see_update_relevancy (void)\n       \n       for (use_rec = df_get_artificial_uses (bb->index); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  see_update_uses_relevancy (NULL, use, NOT_RELEVANT, u);\n \t  u++;\n \t}\n \n       for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n \t{\n-\t  struct df_ref *def = *def_rec;\n+\t  df_ref def = *def_rec;\n \t  see_update_defs_relevancy (NULL, def, NOT_RELEVANT, \n \t\t\t\t       MAX_MACHINE_MODE, MAX_MACHINE_MODE, d);\n \t  d++;\n@@ -3766,7 +3766,7 @@ see_propagate_extensions_to_uses (void)\n   FOR_ALL_BB (bb)\n     {\n       rtx insn;\n-      struct df_ref **use_rec;\n+      df_ref *use_rec;\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n@@ -3775,21 +3775,21 @@ see_propagate_extensions_to_uses (void)\n \t    {\n \t      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  union_defs (use, def_entry, use_entry, see_update_leader_extra_info);\n \t\t}\n \t      \n \t      for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t\t{\n-\t\t  struct df_ref *use = *use_rec;\n+\t\t  df_ref use = *use_rec;\n \t\t  union_defs (use, def_entry, use_entry, see_update_leader_extra_info);\n \t\t}\n \t    }\n \t}\n \n       for (use_rec = df_get_artificial_uses (bb->index); *use_rec; use_rec++)\n \t{\n-\t  struct df_ref *use = *use_rec;\n+\t  df_ref use = *use_rec;\n \t  union_defs (use, def_entry, use_entry, see_update_leader_extra_info);\n \t}\n     }"}, {"sha": "6f16d751bee9fc1249e652b3d4138839ba7de9fb", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -2552,7 +2552,7 @@ maybe_downgrade_id_to_use (idata_t id, insn_t insn)\n {\n   bool must_be_use = false;\n   unsigned uid = INSN_UID (insn);\n-  struct df_ref **rec;\n+  df_ref *rec;\n   rtx lhs = IDATA_LHS (id);\n   rtx rhs = IDATA_RHS (id);\n   \n@@ -2568,7 +2568,7 @@ maybe_downgrade_id_to_use (idata_t id, insn_t insn)\n   \n   for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n     {\n-      struct df_ref *def = *rec;\n+      df_ref def = *rec;\n       \n       if (DF_REF_INSN (def)\n           && DF_REF_FLAGS_IS_SET (def, DF_REF_PRE_POST_MODIFY)\n@@ -2598,12 +2598,12 @@ static void\n setup_id_reg_sets (idata_t id, insn_t insn)\n {\n   unsigned uid = INSN_UID (insn);\n-  struct df_ref **rec;\n+  df_ref *rec;\n   regset tmp = get_clear_regset_from_pool ();\n   \n   for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n     {\n-      struct df_ref *def = *rec;\n+      df_ref def = *rec;\n       unsigned int regno = DF_REF_REGNO (def);\n       \n       /* Post modifies are treated like clobbers by sched-deps.c.  */\n@@ -2629,7 +2629,7 @@ setup_id_reg_sets (idata_t id, insn_t insn)\n       \n   for (rec = DF_INSN_UID_USES (uid); *rec; rec++)\n     {\n-      struct df_ref *use = *rec;\n+      df_ref use = *rec;\n       unsigned int regno = DF_REF_REGNO (use);\n \n       /* When these refs are met for the first time, skip them, as"}, {"sha": "1f7169fe069e9275e1c5c0c437441e00b8f07dd6", "filename": "gcc/web.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57512f5363ea28fb5a244ac64ad20d54433999ec/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=57512f5363ea28fb5a244ac64ad20d54433999ec", "patch": "@@ -60,8 +60,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n \n \n-static rtx entry_register (struct web_entry *, struct df_ref *, char *);\n-static void replace_ref (struct df_ref *, rtx);\n+static rtx entry_register (struct web_entry *, df_ref, char *);\n+static void replace_ref (df_ref, rtx);\n \n /* Find the root of unionfind tree (the representative of set).  */\n \n@@ -101,15 +101,15 @@ unionfind_union (struct web_entry *first, struct web_entry *second)\n    FUN is the function that does the union.  */\n \n void\n-union_defs (struct df_ref *use, struct web_entry *def_entry,\n+union_defs (df_ref use, struct web_entry *def_entry,\n  \t    struct web_entry *use_entry,\n  \t    bool (*fun) (struct web_entry *, struct web_entry *))\n {\n   struct df_insn_info *insn_info = DF_REF_INSN_INFO (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n-  struct df_ref **use_link;\n-  struct df_ref **eq_use_link;\n-  struct df_ref **def_link;\n+  df_ref *use_link;\n+  df_ref *eq_use_link;\n+  df_ref *def_link;\n   rtx set;\n \n   if (insn_info)\n@@ -178,9 +178,9 @@ union_defs (struct df_ref *use, struct web_entry *def_entry,\n \n   /* A READ_WRITE use requires the corresponding def to be in the same\n      register.  Find it and union.  */\n-  if (use->flags & DF_REF_READ_WRITE)\n+  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n     {\n-      struct df_ref **link;\n+      df_ref *link;\n \n       if (insn_info)\n \tlink = DF_INSN_INFO_DEFS (insn_info);\n@@ -201,7 +201,7 @@ union_defs (struct df_ref *use, struct web_entry *def_entry,\n /* Find the corresponding register for the given entry.  */\n \n static rtx\n-entry_register (struct web_entry *entry, struct df_ref *ref, char *used)\n+entry_register (struct web_entry *entry, df_ref ref, char *used)\n {\n   struct web_entry *root;\n   rtx reg, newreg;\n@@ -243,11 +243,11 @@ entry_register (struct web_entry *entry, struct df_ref *ref, char *used)\n /* Replace the reference by REG.  */\n \n static void\n-replace_ref (struct df_ref *ref, rtx reg)\n+replace_ref (df_ref ref, rtx reg)\n {\n   rtx oldreg = DF_REF_REAL_REG (ref);\n   rtx *loc = DF_REF_REAL_LOC (ref);\n-  unsigned int uid = INSN_UID (DF_REF_INSN (ref));\n+  unsigned int uid = DF_REF_INSN_UID (ref);\n \n   if (oldreg == reg)\n     return;\n@@ -290,16 +290,16 @@ web_main (void)\n       unsigned int uid = INSN_UID (insn);\n       if (INSN_P (insn))\n \t{\n-\t  struct df_ref **use_rec;\n+\t  df_ref *use_rec;\n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\tDF_REF_ID (use) = uses_num++;\n \t    }\n \t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\tDF_REF_ID (use) = uses_num++;\n \t    }\n@@ -318,16 +318,16 @@ web_main (void)\n       unsigned int uid = INSN_UID (insn);\n       if (INSN_P (insn))\n \t{\n-\t  struct df_ref **use_rec;\n+\t  df_ref *use_rec;\n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\tunion_defs (use, def_entry, use_entry, unionfind_union);\n \t    }\n \t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\tunion_defs (use, def_entry, use_entry, unionfind_union);\n \t    }\n@@ -342,23 +342,23 @@ web_main (void)\n       unsigned int uid = INSN_UID (insn);\n       if (INSN_P (insn))\n \t{\n-\t  struct df_ref **use_rec;\n-\t  struct df_ref **def_rec;\n+\t  df_ref *use_rec;\n+\t  df_ref *def_rec;\n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\treplace_ref (use, entry_register (use_entry + DF_REF_ID (use), use, used));\n \t    }\n \t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n \t    {\n-\t      struct df_ref *use = *use_rec;\n+\t      df_ref use = *use_rec;\n \t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n \t\treplace_ref (use, entry_register (use_entry + DF_REF_ID (use), use, used));\n \t    }\n \t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t    {\n-\t      struct df_ref *def = *def_rec;\n+\t      df_ref def = *def_rec;\n \t      if (DF_REF_REGNO (def) >= FIRST_PSEUDO_REGISTER)\n \t\treplace_ref (def, entry_register (def_entry + DF_REF_ID (def), def, used));\n \t    }"}]}