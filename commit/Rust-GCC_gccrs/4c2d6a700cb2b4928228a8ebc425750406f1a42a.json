{"sha": "4c2d6a700cb2b4928228a8ebc425750406f1a42a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyZDZhNzAwY2IyYjQ5MjgyMjhhOGViYzQyNTc1MDQwNmYxYTQyYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2005-02-09T11:14:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-09T11:14:42Z"}, "message": "a-rbtgso.adb, [...]: New files.\n\n\t* a-rbtgso.adb, a-crbtgo.ads, a-crbtgo.adb, a-crbtgk.ads,\n\ta-crbtgk.adb, a-crbltr.ads, a-coprnu.ads, a-coprnu.adb,\n\ta-coorse.ads, a-coorse.adb, a-convec.ads, a-convec.adb,\n\ta-contai.ads, a-coinve.ads, a-coinve.adb, a-cohata.ads,\n\ta-cohama.ads, a-cohama.adb, a-ciorse.ads, a-ciorse.adb,\n\ta-cihama.ads, a-cihama.adb, a-cidlli.ads, a-cidlli.adb,\n\ta-chtgop.ads, a-chtgop.adb, a-cgcaso.ads, a-cgcaso.adb,\n\ta-cgarso.ads, a-cgarso.adb, a-cdlili.ads, a-cdlili.adb,\n\ta-cgaaso.adb, a-coormu.adb, a-ciormu.adb, a-cihase.adb,\n\ta-cihase.ads, a-cohase.adb, a-cohase.ads, a-ciorma.ads,\n\ta-coorma.ads, a-swunha.ads, a-stunha.ads, a-ciormu.ads,\n\ta-coormu.ads, a-rbtgso.ads, a-swunha.adb, a-stunha.adb,\n\ta-cgaaso.ads, a-ciorma.adb, a-coorma.adb, a-secain.adb,\n\ta-secain.ads, a-slcain.ads, a-slcain.adb, a-shcain.ads,\n\ta-shcain.adb, a-chtgke.ads, a-chtgke.adb, a-stwiha.ads,\n\ta-stwiha.adb, a-strhas.ads, a-strhas.adb, a-chzla1.ads,\n\ta-chzla9.ads, a-lfztio.ads, a-liztio.ads, a-llfzti.ads,\n\ta-llizti.ads, a-sfztio.ads, a-siztio.ads, a-ssizti.ads,\n\ta-stzbou.adb, a-stzbou.ads, a-stzfix.adb, a-stzfix.ads,\n\ta-stzhas.adb, a-stzhas.ads, a-stzmap.adb, a-stzmap.ads,\n\ta-stzsea.adb, a-stzsea.ads, a-stzsup.adb, a-stzsup.ads,\n\ta-stzunb.adb, a-stzunb.ads, a-swunau.adb, a-swunau.ads,\n\ta-szmzco.ads, a-szunau.adb, a-szunau.ads, a-szunha.adb,\n\ta-szunha.ads, a-szuzti.adb, a-szuzti.ads, a-tiunio.ads,\n\ta-wwunio.ads, a-ztcoau.adb, a-ztcoau.ads, a-ztcoio.adb,\n\ta-ztcoio.ads, a-ztcstr.adb, a-ztcstr.ads, a-ztdeau.adb,\n\ta-ztdeau.ads, a-ztdeio.adb, a-ztdeio.ads, a-ztedit.adb,\n\ta-ztedit.ads, a-ztenau.adb, a-ztenau.ads, a-ztenio.adb,\n\ta-ztenio.ads, a-ztexio.adb, a-ztexio.ads, a-ztfiio.adb,\n\ta-ztfiio.ads, a-ztflau.adb, a-ztflau.ads, a-ztflio.adb,\n\ta-ztflio.ads, a-ztgeau.adb, a-ztgeau.ads, a-ztinau.adb,\n\ta-ztinau.ads, a-ztinio.adb, a-ztinio.ads, a-ztmoau.adb,\n\ta-ztmoau.ads, a-ztmoio.adb, a-ztmoio.ads, a-zttest.adb,\n\ta-zttest.ads, a-zzunio.ads: New files. Part of new Ada 2005\n\tlibrary.\n\nFrom-SVN: r94764", "tree": {"sha": "fc2c56125c477bf3312555b0de2bc5a1860ba895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc2c56125c477bf3312555b0de2bc5a1860ba895"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2d6a700cb2b4928228a8ebc425750406f1a42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2d6a700cb2b4928228a8ebc425750406f1a42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2d6a700cb2b4928228a8ebc425750406f1a42a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2d6a700cb2b4928228a8ebc425750406f1a42a/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e99e6d711d080daa5c3d25b2dc184bbbdeaba47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e99e6d711d080daa5c3d25b2dc184bbbdeaba47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e99e6d711d080daa5c3d25b2dc184bbbdeaba47f"}], "stats": {"total": 47004, "additions": 47004, "deletions": 0}, "files": [{"sha": "a4adba5fda62c5a32e508f988dcc363ee1582a20", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -1,3 +1,41 @@\n+2005-02-09  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-rbtgso.adb, a-crbtgo.ads, a-crbtgo.adb, a-crbtgk.ads,\n+\ta-crbtgk.adb, a-crbltr.ads, a-coprnu.ads, a-coprnu.adb,\n+\ta-coorse.ads, a-coorse.adb, a-convec.ads, a-convec.adb,\n+\ta-contai.ads, a-coinve.ads, a-coinve.adb, a-cohata.ads,\n+\ta-cohama.ads, a-cohama.adb, a-ciorse.ads, a-ciorse.adb,\n+\ta-cihama.ads, a-cihama.adb, a-cidlli.ads, a-cidlli.adb,\n+\ta-chtgop.ads, a-chtgop.adb, a-cgcaso.ads, a-cgcaso.adb,\n+\ta-cgarso.ads, a-cgarso.adb, a-cdlili.ads, a-cdlili.adb,\n+\ta-cgaaso.adb, a-coormu.adb, a-ciormu.adb, a-cihase.adb,\n+\ta-cihase.ads, a-cohase.adb, a-cohase.ads, a-ciorma.ads,\n+\ta-coorma.ads, a-swunha.ads, a-stunha.ads, a-ciormu.ads,\n+\ta-coormu.ads, a-rbtgso.ads, a-swunha.adb, a-stunha.adb,\n+\ta-cgaaso.ads, a-ciorma.adb, a-coorma.adb, a-secain.adb,\n+\ta-secain.ads, a-slcain.ads, a-slcain.adb, a-shcain.ads,\n+\ta-shcain.adb, a-chtgke.ads, a-chtgke.adb, a-stwiha.ads,\n+\ta-stwiha.adb, a-strhas.ads, a-strhas.adb, a-chzla1.ads,\n+\ta-chzla9.ads, a-lfztio.ads, a-liztio.ads, a-llfzti.ads,\n+\ta-llizti.ads, a-sfztio.ads, a-siztio.ads, a-ssizti.ads,\n+\ta-stzbou.adb, a-stzbou.ads, a-stzfix.adb, a-stzfix.ads,\n+\ta-stzhas.adb, a-stzhas.ads, a-stzmap.adb, a-stzmap.ads,\n+\ta-stzsea.adb, a-stzsea.ads, a-stzsup.adb, a-stzsup.ads,\n+\ta-stzunb.adb, a-stzunb.ads, a-swunau.adb, a-swunau.ads,\n+\ta-szmzco.ads, a-szunau.adb, a-szunau.ads, a-szunha.adb,\n+\ta-szunha.ads, a-szuzti.adb, a-szuzti.ads, a-tiunio.ads,\n+\ta-wwunio.ads, a-ztcoau.adb, a-ztcoau.ads, a-ztcoio.adb,\n+\ta-ztcoio.ads, a-ztcstr.adb, a-ztcstr.ads, a-ztdeau.adb,\n+\ta-ztdeau.ads, a-ztdeio.adb, a-ztdeio.ads, a-ztedit.adb,\n+\ta-ztedit.ads, a-ztenau.adb, a-ztenau.ads, a-ztenio.adb,\n+\ta-ztenio.ads, a-ztexio.adb, a-ztexio.ads, a-ztfiio.adb,\n+\ta-ztfiio.ads, a-ztflau.adb, a-ztflau.ads, a-ztflio.adb,\n+\ta-ztflio.ads, a-ztgeau.adb, a-ztgeau.ads, a-ztinau.adb,\n+\ta-ztinau.ads, a-ztinio.adb, a-ztinio.ads, a-ztmoau.adb,\n+\ta-ztmoau.ads, a-ztmoio.adb, a-ztmoio.ads, a-zttest.adb,\n+\ta-zttest.ads, a-zzunio.ads: New files. Part of new Ada 2005\n+\tlibrary.\n+\n 2005-01-27  Laurent GUERBY <laurent@guerby.net>\n \n \t* Makefile.in: Fix a-intnam.ads from previous commit,"}, {"sha": "435679d313deaa01386c3aca79bea4f7ab1315dc", "filename": "gcc/ada/a-cdlili.adb", "status": "added", "additions": 1282, "deletions": 0, "changes": 1282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1282 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.DOUBLY_LINKED_LISTS                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Containers.Doubly_Linked_Lists is\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Delete_Node\n+     (Container : in out List;\n+      Node      : in out Node_Access);\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Node_Access;\n+      New_Node  : Node_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : List) return Boolean is\n+      L : Node_Access := Left.First;\n+      R : Node_Access := Right.First;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      for J in 1 .. Left.Length loop\n+         if L.Element /= R.Element then\n+            return False;\n+         end if;\n+\n+         L := L.Next;\n+         R := R.Next;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out List) is\n+      Src    : Node_Access := Container.First;\n+      Length : constant Count_Type := Container.Length;\n+\n+   begin\n+      if Src = null then\n+         pragma Assert (Container.Last = null);\n+         pragma Assert (Length = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+      pragma Assert (Length > 0);\n+\n+      Container.First := null;\n+      Container.Last := null;\n+      Container.Length := 0;\n+\n+      Container.First := new Node_Type'(Src.Element, null, null);\n+\n+      Container.Last := Container.First;\n+      loop\n+         Container.Length := Container.Length + 1;\n+         Src := Src.Next;\n+         exit when Src = null;\n+         Container.Last.Next := new Node_Type'(Element => Src.Element,\n+                                               Prev    => Container.Last,\n+                                               Next    => null);\n+         Container.Last := Container.Last.Next;\n+      end loop;\n+\n+      pragma Assert (Container.Length = Length);\n+   end Adjust;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+   begin\n+      Delete_Last (Container, Count => Container.Length);\n+   end Clear;\n+\n+   --------------\n+   -- Continue --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      for Index in 1 .. Count loop\n+         Delete_Node (Container, Position.Node);\n+\n+         if Position.Node = null then\n+            Position.Container := null;\n+            return;\n+         end if;\n+      end loop;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      Node : Node_Access := Container.First;\n+   begin\n+      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n+         Delete_Node (Container, Node);\n+      end loop;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      Node : Node_Access;\n+   begin\n+      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n+         Node := Container.Last;\n+         Delete_Node (Container, Node);\n+      end loop;\n+   end Delete_Last;\n+\n+   -----------------\n+   -- Delete_Node --\n+   -----------------\n+\n+   procedure Delete_Node\n+     (Container : in out List;\n+      Node      : in out Node_Access)\n+   is\n+      X : Node_Access := Node;\n+\n+   begin\n+      Node := X.Next;\n+      Container.Length := Container.Length - 1;\n+\n+      if X = Container.First then\n+         Container.First := X.Next;\n+\n+         if X = Container.Last then\n+            pragma Assert (Container.First = null);\n+            pragma Assert (Container.Length = 0);\n+            Container.Last := null;\n+         else\n+            pragma Assert (Container.Length > 0);\n+            Container.First.Prev := null;\n+         end if;\n+\n+      elsif X = Container.Last then\n+         pragma Assert (Container.Length > 0);\n+\n+         Container.Last := X.Prev;\n+         Container.Last.Next := null;\n+\n+      else\n+         pragma Assert (Container.Length > 0);\n+\n+         X.Next.Prev := X.Prev;\n+         X.Prev.Next := X.Next;\n+      end if;\n+\n+      Free (X);\n+   end Delete_Node;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element;\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.First;\n+      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element = Item then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+   begin\n+      return Container.First.Element;\n+   end First_Element;\n+\n+   -------------------\n+   -- Generic_Merge --\n+   -------------------\n+\n+   procedure Generic_Merge\n+     (Target : in out List;\n+      Source : in out List)\n+   is\n+      LI : Cursor := First (Target);\n+      RI : Cursor := First (Source);\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      while RI.Node /= null loop\n+         if LI.Node = null then\n+            Splice (Target, No_Element, Source);\n+            return;\n+         end if;\n+\n+         if RI.Node.Element < LI.Node.Element then\n+            declare\n+               RJ : constant Cursor := RI;\n+            begin\n+               RI.Node := RI.Node.Next;\n+               Splice (Target, LI, Source, RJ);\n+            end;\n+\n+         else\n+            LI.Node := LI.Node.Next;\n+         end if;\n+      end loop;\n+   end Generic_Merge;\n+\n+   ------------------\n+   -- Generic_Sort --\n+   ------------------\n+\n+   procedure Generic_Sort (Container : in out List) is\n+\n+      procedure Partition\n+        (Pivot : in Node_Access;\n+         Back  : in Node_Access);\n+\n+      procedure Sort (Front, Back : Node_Access);\n+\n+      ---------------\n+      -- Partition --\n+      ---------------\n+\n+      procedure Partition\n+        (Pivot : Node_Access;\n+         Back  : Node_Access)\n+      is\n+         Node : Node_Access := Pivot.Next;\n+\n+      begin\n+         while Node /= Back loop\n+            if Node.Element < Pivot.Element then\n+               declare\n+                  Prev : constant Node_Access := Node.Prev;\n+                  Next : constant Node_Access := Node.Next;\n+\n+               begin\n+                  Prev.Next := Next;\n+\n+                  if Next = null then\n+                     Container.Last := Prev;\n+                  else\n+                     Next.Prev := Prev;\n+                  end if;\n+\n+                  Node.Next := Pivot;\n+                  Node.Prev := Pivot.Prev;\n+\n+                  Pivot.Prev := Node;\n+\n+                  if Node.Prev = null then\n+                     Container.First := Node;\n+                  else\n+                     Node.Prev.Next := Node;\n+                  end if;\n+\n+                  Node := Next;\n+               end;\n+\n+            else\n+               Node := Node.Next;\n+            end if;\n+         end loop;\n+      end Partition;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Front, Back : Node_Access) is\n+         Pivot : Node_Access;\n+\n+      begin\n+         if Front = null then\n+            Pivot := Container.First;\n+         else\n+            Pivot := Front.Next;\n+         end if;\n+\n+         if Pivot /= Back then\n+            Partition (Pivot, Back);\n+            Sort (Front, Pivot);\n+            Sort (Pivot, Back);\n+         end if;\n+      end Sort;\n+\n+   --  Start of processing for Generic_Sort\n+\n+   begin\n+      Sort (Front => null, Back => null);\n+\n+      pragma Assert (Container.Length = 0\n+                       or else\n+                         (Container.First.Prev = null\n+                            and then Container.Last.Next = null));\n+   end Generic_Sort;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position.Container /= null and then Position.Node /= null;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Node : Node_Access;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      New_Node := new Node_Type'(New_Item, null, null);\n+      Insert_Internal (Container, Before.Node, New_Node);\n+\n+      Position := Cursor'(Before.Container, New_Node);\n+\n+      for J in Count_Type'(2) .. Count loop\n+         New_Node := new Node_Type'(New_Item, null, null);\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Node : Node_Access;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      New_Node := new Node_Type;\n+      Insert_Internal (Container, Before.Node, New_Node);\n+\n+      Position := Cursor'(Before.Container, New_Node);\n+\n+      for J in Count_Type'(2) .. Count loop\n+         New_Node := new Node_Type;\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Node_Access;\n+      New_Node  : Node_Access)\n+   is\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = null);\n+         pragma Assert (Container.First = null);\n+         pragma Assert (Container.Last = null);\n+\n+         Container.First := New_Node;\n+         Container.Last := New_Node;\n+\n+      elsif Before = null then\n+         pragma Assert (Container.Last.Next = null);\n+\n+         Container.Last.Next := New_Node;\n+         New_Node.Prev := Container.Last;\n+\n+         Container.Last := New_Node;\n+\n+      elsif Before = Container.First then\n+         pragma Assert (Container.First.Prev = null);\n+\n+         Container.First.Prev := New_Node;\n+         New_Node.Next := Container.First;\n+\n+         Container.First := New_Node;\n+\n+      else\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         New_Node.Next := Before;\n+         New_Node.Prev := Before.Prev;\n+\n+         Before.Prev.Next := New_Node;\n+         Before.Prev := New_Node;\n+      end if;\n+\n+      Container.Length := Container.Length + 1;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      Node : Node_Access := Container.First;\n+   begin\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Node := Node.Next;\n+      end loop;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+   begin\n+      return Container.Last.Element;\n+   end Last_Element;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List)\n+   is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Length > 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Target.First := Source.First;\n+      Source.First := null;\n+\n+      Target.Last := Source.Last;\n+      Source.Last := null;\n+\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      if Position.Node = null then\n+         return;\n+      end if;\n+\n+      Position.Node := Position.Node.Next;\n+\n+      if Position.Node = null then\n+         Position.Container := null;\n+      end if;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Next_Node : constant Node_Access := Position.Node.Next;\n+      begin\n+         if Next_Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Next_Node);\n+      end;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      if Position.Node = null then\n+         return;\n+      end if;\n+\n+      Position.Node := Position.Node.Prev;\n+\n+      if Position.Node = null then\n+         Position.Container := null;\n+      end if;\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Prev_Node : constant Node_Access := Position.Node.Prev;\n+      begin\n+         if Prev_Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Prev_Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Element);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out List)\n+   is\n+      N : Count_Type'Base;\n+      X : Node_Access;\n+\n+   begin\n+      Clear (Item);  --  ???\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      X := new Node_Type;\n+\n+      begin\n+         Element_Type'Read (Stream, X.Element);\n+      exception\n+         when others =>\n+            Free (X);\n+            raise;\n+      end;\n+\n+      Item.First := X;\n+      Item.Last := X;\n+\n+      loop\n+         Item.Length := Item.Length + 1;\n+         exit when Item.Length = N;\n+\n+         X := new Node_Type;\n+\n+         begin\n+            Element_Type'Read (Stream, X.Element);\n+         exception\n+            when others =>\n+               Free (X);\n+               raise;\n+         end;\n+\n+         X.Prev := Item.Last;\n+         Item.Last.Next := X;\n+         Item.Last := X;\n+      end loop;\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type)\n+   is\n+   begin\n+      Position.Node.Element := By;\n+   end Replace_Element;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.Last;\n+      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element = Item then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      Node : Node_Access := Container.Last;\n+   begin\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Node := Node.Prev;\n+      end loop;\n+   end Reverse_Iterate;\n+\n+   ------------------\n+   -- Reverse_List --\n+   ------------------\n+\n+   procedure Reverse_List (Container : in out List) is\n+      I : Node_Access := Container.First;\n+      J : Node_Access := Container.Last;\n+\n+      procedure Swap (L, R : Node_Access);\n+\n+      ----------\n+      -- Swap --\n+      ----------\n+\n+      procedure Swap (L, R : Node_Access) is\n+         LN : constant Node_Access := L.Next;\n+         LP : constant Node_Access := L.Prev;\n+\n+         RN : constant Node_Access := R.Next;\n+         RP : constant Node_Access := R.Prev;\n+\n+      begin\n+         if LP /= null then\n+            LP.Next := R;\n+         end if;\n+\n+         if RN /= null then\n+            RN.Prev := L;\n+         end if;\n+\n+         L.Next := RN;\n+         R.Prev := LP;\n+\n+         if LN = R then\n+            pragma Assert (RP = L);\n+\n+            L.Prev := R;\n+            R.Next := L;\n+\n+         else\n+            L.Prev := RP;\n+            RP.Next := L;\n+\n+            R.Next := LN;\n+            LN.Prev := R;\n+         end if;\n+      end Swap;\n+\n+   --  Start of processing for Reverse_List\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      Container.First := J;\n+      Container.Last := I;\n+      loop\n+         Swap (L => I, R => J);\n+\n+         J := J.Next;\n+         exit when I = J;\n+\n+         I := I.Prev;\n+         exit when I = J;\n+\n+         Swap (L => J, R => I);\n+\n+         I := I.Next;\n+         exit when I = J;\n+\n+         J := J.Prev;\n+         exit when I = J;\n+      end loop;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+   end Reverse_List;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   is\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Target'Address = Source'Address\n+        or else Source.Length = 0\n+      then\n+         return;\n+      end if;\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Before = No_Element);\n+\n+         Target.First := Source.First;\n+         Target.Last := Source.Last;\n+\n+      elsif Before.Node = null then\n+         pragma Assert (Target.Last.Next = null);\n+\n+         Target.Last.Next := Source.First;\n+         Source.First.Prev := Target.Last;\n+\n+         Target.Last := Source.Last;\n+\n+      elsif Before.Node = Target.First then\n+         pragma Assert (Target.First.Prev = null);\n+\n+         Source.Last.Next := Target.First;\n+         Target.First.Prev := Source.Last;\n+\n+         Target.First := Source.First;\n+\n+      else\n+         Before.Node.Prev.Next := Source.First;\n+         Source.First.Prev := Before.Node.Prev;\n+\n+         Before.Node.Prev := Source.Last;\n+         Source.Last.Next := Before.Node;\n+      end if;\n+\n+      Source.First := null;\n+      Source.Last := null;\n+\n+      Target.Length := Target.Length + Source.Length;\n+      Source.Length := 0;\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Position : Cursor)\n+   is\n+      X : Node_Access := Position.Node;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= null\n+        and then Position.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if X = null\n+        or else X = Before.Node\n+        or else X.Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Target.Length > 0);\n+\n+      if Before.Node = null then\n+         pragma Assert (X /= Target.Last);\n+\n+         if X = Target.First then\n+            Target.First := X.Next;\n+            Target.First.Prev := null;\n+         else\n+            X.Prev.Next := X.Next;\n+            X.Next.Prev := X.Prev;\n+         end if;\n+\n+         Target.Last.Next := X;\n+         X.Prev := Target.Last;\n+\n+         Target.Last := X;\n+         Target.Last.Next := null;\n+\n+         return;\n+      end if;\n+\n+      if Before.Node = Target.First then\n+         pragma Assert (X /= Target.First);\n+\n+         if X = Target.Last then\n+            Target.Last := X.Prev;\n+            Target.Last.Next := null;\n+         else\n+            X.Prev.Next := X.Next;\n+            X.Next.Prev := X.Prev;\n+         end if;\n+\n+         Target.First.Prev := X;\n+         X.Next := Target.First;\n+\n+         Target.First := X;\n+         Target.First.Prev := null;\n+\n+         return;\n+      end if;\n+\n+      if X = Target.First then\n+         Target.First := X.Next;\n+         Target.First.Prev := null;\n+\n+      elsif X = Target.Last then\n+         Target.Last := X.Prev;\n+         Target.Last.Next := null;\n+\n+      else\n+         X.Prev.Next := X.Next;\n+         X.Next.Prev := X.Prev;\n+      end if;\n+\n+      Before.Node.Prev.Next := X;\n+      X.Prev := Before.Node.Prev;\n+\n+      Before.Node.Prev := X;\n+      X.Next := Before.Node;\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : Cursor)\n+   is\n+      X : Node_Access := Position.Node;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         Splice (Target, Before, Position);\n+         return;\n+      end if;\n+\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= null\n+        and then Position.Container /= List_Access'(Source'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if X = null then\n+         return;\n+      end if;\n+\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last.Next = null);\n+\n+      if X = Source.First then\n+         Source.First := X.Next;\n+         Source.First.Prev := null;\n+\n+         if X = Source.Last then\n+            pragma Assert (Source.First = null);\n+            pragma Assert (Source.Length = 1);\n+            Source.Last := null;\n+         end if;\n+\n+      elsif X = Source.Last then\n+         Source.Last := X.Prev;\n+         Source.Last.Next := null;\n+\n+      else\n+         X.Prev.Next := X.Next;\n+         X.Next.Prev := X.Prev;\n+      end if;\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Before = No_Element);\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n+\n+         Target.First := X;\n+         Target.Last := X;\n+\n+      elsif Before.Node = null then\n+         Target.Last.Next := X;\n+         X.Next := Target.Last;\n+\n+         Target.Last := X;\n+         Target.Last.Next := null;\n+\n+      elsif Before.Node = Target.First then\n+         Target.First.Prev := X;\n+         X.Next := Target.First;\n+\n+         Target.First := X;\n+         Target.First.Prev := null;\n+\n+      else\n+         Before.Node.Prev.Next := X;\n+         X.Prev := Before.Node.Prev;\n+\n+         Before.Node.Prev := X;\n+         X.Next := Before.Node;\n+      end if;\n+\n+      Target.Length := Target.Length + 1;\n+      Source.Length := Source.Length - 1;\n+   end Splice;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   --  Is this defined when I and J designate elements in different containers,\n+   --  or should it raise an exception (Program_Error)???\n+\n+   procedure Swap (I, J : in Cursor) is\n+      EI : constant Element_Type := I.Node.Element;\n+   begin\n+      I.Node.Element := J.Node.Element;\n+      J.Node.Element := EI;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I = No_Element\n+        or else J = No_Element\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if I.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      if J.Container /= I.Container then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 1);\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 2);\n+\n+      declare\n+         I_Next : constant Cursor := Next (I);\n+\n+      begin\n+         if I_Next = J then\n+            Splice (Container, Before => I, Position => J);\n+\n+         else\n+            declare\n+               J_Next : constant Cursor := Next (J);\n+\n+            begin\n+               if J_Next = I then\n+                  Splice (Container, Before => J, Position => I);\n+\n+               else\n+                  pragma Assert (Container.Length >= 3);\n+\n+                  Splice (Container, Before => I_Next, Position => J);\n+                  Splice (Container, Before => J_Next, Position => I);\n+               end if;\n+            end;\n+         end if;\n+      end;\n+   end Swap_Links;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type)) is\n+   begin\n+      Process (Position.Node.Element);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : List)\n+   is\n+      Node : Node_Access := Item.First;\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Item.Length);\n+\n+      while Node /= null loop\n+         Element_Type'Write (Stream, Node.Element);\n+         Node := Node.Next;\n+      end loop;\n+   end Write;\n+\n+end Ada.Containers.Doubly_Linked_Lists;\n+"}, {"sha": "f87479cabe649c109937fa5aefe5aeaeea1f2a8d", "filename": "gcc/ada/a-cdlili.ads", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,252 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.DOUBLY_LINKED_LISTS                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type)\n+      return Boolean is <>;\n+\n+package Ada.Containers.Doubly_Linked_Lists is\n+   pragma Preelaborate (Doubly_Linked_Lists);\n+\n+   type List is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_List : constant List;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : List) return Boolean;\n+\n+   function Length (Container : List) return Count_Type;\n+\n+   function Is_Empty (Container : List) return Boolean;\n+\n+   procedure Clear (Container : in out List);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type);\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type)\n+         return Boolean is <>;\n+   procedure Generic_Sort (Container : in out List);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type)\n+         return Boolean is <>;\n+   procedure Generic_Merge (Target : in out List; Source : in out List);\n+\n+   procedure Reverse_List (Container : in out List);\n+\n+   procedure Swap (I, J : in Cursor);\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Position : Cursor);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : Cursor);\n+\n+   function First (Container : List) return Cursor;\n+\n+   function First_Element (Container : List) return Element_Type;\n+\n+   function Last (Container : List) return Cursor;\n+\n+   function Last_Element (Container : List) return Element_Type;\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   type Node_Type is\n+      record\n+         Element : Element_Type;\n+         Next    : Node_Access;\n+         Prev    : Node_Access;\n+      end record;\n+\n+   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n+\n+   use Ada.Finalization;\n+\n+   type List is\n+     new Controlled with record\n+        First  : Node_Access;\n+        Last   : Node_Access;\n+        Length : Count_Type := 0;\n+     end record;\n+\n+   procedure Adjust (Container : in out List);\n+\n+   procedure Finalize (Container : in out List) renames Clear;\n+\n+   use Ada.Streams;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out List);\n+\n+   for List'Read use Read;\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : List);\n+\n+   for List'Write use Write;\n+\n+   Empty_List : constant List := List'(Controlled with null, null, 0);\n+\n+   type List_Access is access constant List;\n+   for List_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : List_Access;\n+         Node      : Node_Access;\n+      end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n+\n+end Ada.Containers.Doubly_Linked_Lists;\n+"}, {"sha": "1fc24fcf67259feb563bcd1049d6cba4e1f473f7", "filename": "gcc/ada/a-cgaaso.adb", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgaaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgaaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgaaso.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,125 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.GENERIC_ANONYMOUS_ARRAY_SORT                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+procedure Ada.Containers.Generic_Anonymous_Array_Sort\n+  (First, Last : Index_Type'Base)\n+is\n+   Pivot, Lo, Mid, Hi : Index_Type;\n+\n+begin\n+   if Last <= First then\n+      return;\n+   end if;\n+\n+   Lo := First;\n+   Hi := Last;\n+\n+   if Last = Index_Type'Succ (First) then\n+      if not Less (Lo, Hi) then\n+         Swap (Lo, Hi);\n+      end if;\n+\n+      return;\n+   end if;\n+\n+   Mid := Index_Type'Val\n+     (Index_Type'Pos (Lo) +\n+      (Index_Type'Pos (Hi) - Index_Type'Pos (Lo)) / 2);\n+\n+   --  We need to figure out which case we have:\n+   --  x < y < z\n+   --  x < z < y\n+   --  z < x < y\n+   --  y < x < z\n+   --  y < z < x\n+   --  z < y < x\n+\n+   if Less (Lo, Mid) then\n+      if Less (Lo, Hi) then\n+         if Less (Mid, Hi) then\n+            Swap (Lo, Mid);\n+\n+         else\n+            Swap (Lo, Hi);\n+\n+         end if;\n+\n+      else\n+         null;  --  lo is median\n+      end if;\n+\n+   elsif Less (Lo, Hi) then\n+      null; --  lo is median\n+\n+   elsif Less (Mid, Hi) then\n+      Swap (Lo, Hi);\n+\n+   else\n+      Swap (Lo, Mid);\n+   end if;\n+\n+   Pivot := Lo;\n+   Outer : loop\n+      loop\n+         exit Outer when not (Pivot < Hi);\n+\n+         if Less (Hi, Pivot) then\n+            Swap (Hi, Pivot);\n+            Pivot := Hi;\n+            Lo := Index_Type'Succ (Lo);\n+            exit;\n+         else\n+            Hi := Index_Type'Pred (Hi);\n+         end if;\n+      end loop;\n+\n+      loop\n+         exit Outer when not (Lo < Pivot);\n+\n+         if Less (Lo, Pivot) then\n+            Lo := Index_Type'Succ (Lo);\n+         else\n+            Swap (Lo, Pivot);\n+            Pivot := Lo;\n+            Hi := Index_Type'Pred (Hi);\n+            exit;\n+         end if;\n+      end loop;\n+   end loop Outer;\n+\n+   Generic_Anonymous_Array_Sort (First, Index_Type'Pred (Pivot));\n+   Generic_Anonymous_Array_Sort (Index_Type'Succ (Pivot), Last);\n+\n+end Ada.Containers.Generic_Anonymous_Array_Sort;"}, {"sha": "fddc1d4ade1a96f73184439969ae87e5f647e11a", "filename": "gcc/ada/a-cgaaso.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgaaso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgaaso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgaaso.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.GENERIC_ANONYMOUS_ARRAY_SORT                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Index_Type is (<>);\n+   with function Less (Left, Right : Index_Type) return Boolean is <>;\n+   with procedure Swap (Left, Right : Index_Type) is <>;\n+\n+procedure Ada.Containers.Generic_Anonymous_Array_Sort\n+  (First, Last : in Index_Type'Base);\n+\n+pragma Pure (Ada.Containers.Generic_Anonymous_Array_Sort);"}, {"sha": "5594caaabe63815a9cf17f831645ae00988eb3d1", "filename": "gcc/ada/a-cgarso.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgarso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgarso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgarso.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.GENERIC_ARRAY_SORT                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Generic_Constrained_Array_Sort;\n+\n+procedure Ada.Containers.Generic_Array_Sort\n+  (Container : in out Array_Type)\n+is\n+   subtype Index_Subtype is\n+     Index_Type range Container'First .. Container'Last;\n+\n+   subtype Array_Subtype is\n+     Array_Type (Index_Subtype);\n+\n+   procedure Sort is\n+      new Generic_Constrained_Array_Sort\n+       (Index_Type   => Index_Subtype,\n+        Element_Type => Element_Type,\n+        Array_Type   => Array_Subtype,\n+        \"<\"          => \"<\");\n+\n+begin\n+   Sort (Container);\n+end Ada.Containers.Generic_Array_Sort;"}, {"sha": "a22cde76bb2bf97a375e78a510680dcbdc416eb6", "filename": "gcc/ada/a-cgarso.ads", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgarso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgarso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgarso.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,28 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.GENERIC_ARRAY_SORT                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Index_Type is (<>);\n+   type Element_Type is private;\n+   type Array_Type is array (Index_Type range <>) of Element_Type;\n+\n+   with function \"<\" (Left, Right : Element_Type)\n+      return Boolean is <>;\n+\n+procedure Ada.Containers.Generic_Array_Sort (Container : in out Array_Type);\n+\n+pragma Pure (Ada.Containers.Generic_Array_Sort);\n+\n+"}, {"sha": "7f640836775667b16b7db29ef9a23392d785623c", "filename": "gcc/ada/a-cgcaso.adb", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgcaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgcaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgcaso.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,162 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.GENERIC_CONSTRAINED_ARRAY_SORT               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit has originally being developed by Matthew J Heaney.            --\n+------------------------------------------------------------------------------\n+\n+procedure Ada.Containers.Generic_Constrained_Array_Sort\n+  (Container : in out Array_Type)\n+is\n+   function Is_Less (I, J : Index_Type) return Boolean;\n+   pragma Inline (Is_Less);\n+\n+   procedure Swap (I, J : Index_Type);\n+   pragma Inline (Swap);\n+\n+   procedure Sort (First, Last : Index_Type'Base);\n+\n+   -------------\n+   -- Is_Less --\n+   -------------\n+\n+   function Is_Less (I, J : Index_Type) return Boolean is\n+   begin\n+      return Container (I) < Container (J);\n+   end Is_Less;\n+\n+   ----------\n+   -- Sort --\n+   ----------\n+\n+   procedure Sort (First, Last : Index_Type'Base) is\n+      Pivot, Lo, Mid, Hi : Index_Type;\n+\n+   begin\n+      if Last <= First then\n+         return;\n+      end if;\n+\n+      Lo := First;\n+      Hi := Last;\n+\n+      if Last = Index_Type'Succ (First) then\n+         if not Is_Less (Lo, Hi) then\n+            Swap (Lo, Hi);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      Mid := Index_Type'Val\n+               (Index_Type'Pos (Lo) +\n+                (Index_Type'Pos (Hi) - Index_Type'Pos (Lo)) / 2);\n+\n+      --  We need to figure out which case we have:\n+      --  x < y < z\n+      --  x < z < y\n+      --  z < x < y\n+      --  y < x < z\n+      --  y < z < x\n+      --  z < y < x\n+\n+      if Is_Less (Lo, Mid) then\n+         if Is_Less (Lo, Hi) then\n+            if Is_Less (Mid, Hi) then\n+               Swap (Lo, Mid);\n+            else\n+               Swap (Lo, Hi);\n+            end if;\n+\n+         else\n+            null;  --  lo is median\n+         end if;\n+\n+      elsif Is_Less (Lo, Hi) then\n+         null; --  lo is median\n+\n+      elsif Is_Less (Mid, Hi) then\n+         Swap (Lo, Hi);\n+\n+      else\n+         Swap (Lo, Mid);\n+      end if;\n+\n+      Pivot := Lo;\n+\n+      Outer : loop\n+         loop\n+            exit Outer when not (Pivot < Hi);\n+\n+            if Is_Less (Hi, Pivot) then\n+               Swap (Hi, Pivot);\n+               Pivot := Hi;\n+               Lo := Index_Type'Succ (Lo);\n+               exit;\n+            else\n+               Hi := Index_Type'Pred (Hi);\n+            end if;\n+         end loop;\n+\n+         loop\n+            exit Outer when not (Lo < Pivot);\n+\n+            if Is_Less (Lo, Pivot) then\n+               Lo := Index_Type'Succ (Lo);\n+            else\n+               Swap (Lo, Pivot);\n+               Pivot := Lo;\n+               Hi := Index_Type'Pred (Hi);\n+               exit;\n+            end if;\n+         end loop;\n+      end loop Outer;\n+\n+      Sort (First, Index_Type'Pred (Pivot));\n+      Sort (Index_Type'Succ (Pivot), Last);\n+   end Sort;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (I, J : Index_Type) is\n+      EI : constant Element_Type := Container (I);\n+   begin\n+      Container (I) := Container (J);\n+      Container (J) := EI;\n+   end Swap;\n+\n+--  Start of processing for Generic_Constrained_Array_Sort\n+\n+begin\n+   Sort (Container'First, Container'Last);\n+end Ada.Containers.Generic_Constrained_Array_Sort;"}, {"sha": "b247e2be3b8bc15c6f8468dd03beeaa7d1275771", "filename": "gcc/ada/a-cgcaso.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgcaso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cgcaso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgcaso.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,27 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.GENERIC_CONSTRAINED_ARRAY_SORT               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Index_Type is (<>);\n+   type Element_Type is private;\n+   type Array_Type is array (Index_Type) of Element_Type;\n+\n+   with function \"<\" (Left, Right : Element_Type)\n+     return Boolean is <>;\n+\n+procedure Ada.Containers.Generic_Constrained_Array_Sort\n+  (Container : in out Array_Type);\n+\n+pragma Pure (Ada.Containers.Generic_Constrained_Array_Sort);"}, {"sha": "9a21ad0c9eb73fad209081d6e731a19fb818cd85", "filename": "gcc/ada/a-chtgke.adb", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,178 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.CONTAINERS.HASH_TABLES.GENERIC_KEYS                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Hash_Tables.Generic_Keys is\n+\n+   --------------------------\n+   -- Delete_Key_Sans_Free --\n+   --------------------------\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT   : in out HT_Type;\n+      Key  : Key_Type;\n+      X    : out Node_Access)\n+   is\n+      Indx : Hash_Type;\n+      Prev : Node_Access;\n+\n+   begin\n+      if HT.Length = 0 then\n+         X := Null_Node;\n+         return;\n+      end if;\n+\n+      Indx := Index (HT, Key);\n+      X := HT.Buckets (Indx);\n+\n+      if X = Null_Node then\n+         return;\n+      end if;\n+\n+      if Equivalent_Keys (Key, X) then\n+         HT.Buckets (Indx) := Next (X);\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      loop\n+         Prev := X;\n+         X := Next (Prev);\n+\n+         if X = Null_Node then\n+            return;\n+         end if;\n+\n+         if Equivalent_Keys (Key, X) then\n+            Set_Next (Node => Prev, Next => Next (X));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+      end loop;\n+   end Delete_Key_Sans_Free;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (HT  : HT_Type;\n+      Key : Key_Type) return Node_Access is\n+\n+      Indx : Hash_Type;\n+      Node : Node_Access;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return Null_Node;\n+      end if;\n+\n+      Indx := Index (HT, Key);\n+\n+      Node := HT.Buckets (Indx);\n+      while Node /= Null_Node loop\n+         if Equivalent_Keys (Key, Node) then\n+            return Node;\n+         end if;\n+         Node := Next (Node);\n+      end loop;\n+\n+      return Null_Node;\n+   end Find;\n+\n+   --------------------------------\n+   -- Generic_Conditional_Insert --\n+   --------------------------------\n+\n+   procedure Generic_Conditional_Insert\n+     (HT      : in out HT_Type;\n+      Key     : Key_Type;\n+      Node    : out Node_Access;\n+      Success : out Boolean)\n+   is\n+      Indx : constant Hash_Type := Index (HT, Key);\n+      B    : Node_Access renames HT.Buckets (Indx);\n+\n+      subtype Length_Subtype is Count_Type range 0 .. Count_Type'Last - 1;\n+\n+   begin\n+      if B = Null_Node then\n+         declare\n+            Length : constant Length_Subtype := HT.Length;\n+         begin\n+            Node := New_Node (Next => Null_Node);\n+            Success := True;\n+\n+            B := Node;\n+            HT.Length := Length + 1;\n+         end;\n+\n+         return;\n+      end if;\n+\n+      Node := B;\n+      loop\n+         if Equivalent_Keys (Key, Node) then\n+            Success := False;\n+            return;\n+         end if;\n+\n+         Node := Next (Node);\n+\n+         exit when Node = Null_Node;\n+      end loop;\n+\n+      declare\n+         Length : constant Length_Subtype := HT.Length;\n+      begin\n+         Node := New_Node (Next => B);\n+         Success := True;\n+\n+         B := Node;\n+         HT.Length := Length + 1;\n+      end;\n+   end Generic_Conditional_Insert;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (HT  : HT_Type;\n+      Key : Key_Type) return Hash_Type is\n+   begin\n+      return Hash (Key) mod HT.Buckets'Length;\n+   end Index;\n+\n+end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "704c653f730bc6244cf03c93def20ba460e8142c", "filename": "gcc/ada/a-chtgke.ads", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgke.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgke.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.CONTAINERS.HASH_TABLES.GENERIC_KEYS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   with package HT_Types is\n+     new Generic_Hash_Table_Types (<>);\n+\n+   type HT_Type is new HT_Types.Hash_Table_Type with private;\n+\n+   use HT_Types;\n+\n+   Null_Node : Node_Access;\n+\n+   with function Next (Node : Node_Access) return Node_Access;\n+\n+   with procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access);\n+\n+   type Key_Type (<>) is limited private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+\n+   with function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Access) return Boolean;\n+\n+package Ada.Containers.Hash_Tables.Generic_Keys is\n+   pragma Preelaborate;\n+\n+   function Index\n+     (HT  : HT_Type;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Index);\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT   : in out HT_Type;\n+      Key  : Key_Type;\n+      X    : out Node_Access);\n+\n+   function Find (HT  : HT_Type; Key : Key_Type) return Node_Access;\n+\n+   generic\n+      with function New_Node\n+        (Next : Node_Access) return Node_Access;\n+   procedure Generic_Conditional_Insert\n+     (HT      : in out HT_Type;\n+      Key     : Key_Type;\n+      Node    : out Node_Access;\n+      Success : out Boolean);\n+\n+end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "aa27f427c2e85e590dbf2d16c7dea3dd7a0731c3", "filename": "gcc/ada/a-chtgop.adb", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,701 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.HASH_TABLES.GENERIC_OPERATIONS               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  This body needs commenting ???\n+\n+with Ada.Containers.Prime_Numbers;\n+with Ada.Unchecked_Deallocation;\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Hash_Tables.Generic_Operations is\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Buckets_Type, Buckets_Access);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Rehash\n+     (HT   : in out Hash_Table_Type;\n+      Size : Hash_Type);\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (HT : in out Hash_Table_Type) is\n+      Src_Buckets : constant Buckets_Access := HT.Buckets;\n+      N           : constant Count_Type := HT.Length;\n+      Src_Node    : Node_Access;\n+      Dst_Prev    : Node_Access;\n+\n+   begin\n+      HT.Buckets := null;\n+      HT.Length := 0;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      HT.Buckets := new Buckets_Type (Src_Buckets'Range);\n+\n+      --  Probably we have to duplicate the Size (Src), too, in order\n+      --  to guarantee that\n+\n+      --    Dst := Src;\n+      --    Dst = Src is true\n+\n+      --  The only quirk is that we depend on the hash value of a dst key\n+      --  to be the same as the src key from which it was copied.\n+      --  If we relax the requirement that the hash value must be the\n+      --  same, then of course we can't guarantee that following\n+      --  assignment that Dst = Src is true ???\n+\n+      for Src_Index in Src_Buckets'Range loop\n+         Src_Node := Src_Buckets (Src_Index);\n+\n+         if Src_Node /= Null_Node then\n+            declare\n+               Dst_Node : constant Node_Access := Copy_Node (Src_Node);\n+\n+               --   See note above\n+\n+               pragma Assert (Index (HT, Dst_Node) = Src_Index);\n+\n+            begin\n+               HT.Buckets (Src_Index) := Dst_Node;\n+               HT.Length := HT.Length + 1;\n+\n+               Dst_Prev := Dst_Node;\n+            end;\n+\n+            Src_Node := Next (Src_Node);\n+            while Src_Node /= Null_Node loop\n+               declare\n+                  Dst_Node : constant Node_Access := Copy_Node (Src_Node);\n+\n+                  --  See note above\n+\n+                  pragma Assert (Index (HT, Dst_Node) = Src_Index);\n+\n+               begin\n+                  Set_Next (Node => Dst_Prev, Next => Dst_Node);\n+                  HT.Length := HT.Length + 1;\n+\n+                  Dst_Prev := Dst_Node;\n+               end;\n+\n+               Src_Node := Next (Src_Node);\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      pragma Assert (HT.Length = N);\n+   end Adjust;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (HT : Hash_Table_Type) return Count_Type is\n+   begin\n+      if HT.Buckets = null then\n+         return 0;\n+      end if;\n+\n+      return HT.Buckets'Length;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (HT : in out Hash_Table_Type) is\n+      Index : Hash_Type := 0;\n+      Node  : Node_Access;\n+\n+   begin\n+      while HT.Length > 0 loop\n+         while HT.Buckets (Index) = Null_Node loop\n+            Index := Index + 1;\n+         end loop;\n+\n+         declare\n+            Bucket : Node_Access renames HT.Buckets (Index);\n+         begin\n+            loop\n+               Node := Bucket;\n+               Bucket := Next (Bucket);\n+               HT.Length := HT.Length - 1;\n+               Free (Node);\n+               exit when Bucket = Null_Node;\n+            end loop;\n+         end;\n+      end loop;\n+   end Clear;\n+\n+   ---------------------------\n+   -- Delete_Node_Sans_Free --\n+   ---------------------------\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Node_Access)\n+   is\n+      pragma Assert (X /= Null_Node);\n+\n+      Indx : Hash_Type;\n+      Prev : Node_Access;\n+      Curr : Node_Access;\n+\n+   begin\n+      if HT.Length = 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      Indx := Index (HT, X);\n+      Prev := HT.Buckets (Indx);\n+\n+      if Prev = Null_Node then\n+         raise Program_Error;\n+      end if;\n+\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (Prev);\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      if HT.Length = 1 then\n+         raise Program_Error;\n+      end if;\n+\n+      loop\n+         Curr := Next (Prev);\n+\n+         if Curr = Null_Node then\n+            raise Program_Error;\n+         end if;\n+\n+         if Curr = X then\n+            Set_Next (Node => Prev, Next => Next (Curr));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+\n+         Prev := Curr;\n+      end loop;\n+   end Delete_Node_Sans_Free;\n+\n+   ---------------------\n+   -- Ensure_Capacity --\n+   ---------------------\n+\n+   procedure Ensure_Capacity\n+     (HT : in out Hash_Table_Type;\n+      N  : Count_Type)\n+   is\n+      NN : Hash_Type;\n+\n+   begin\n+      if N = 0 then\n+         if HT.Length = 0 then\n+            Free (HT.Buckets);\n+\n+         elsif HT.Length < HT.Buckets'Length then\n+            NN := Prime_Numbers.To_Prime (HT.Length);\n+\n+            --  ASSERT: NN >= HT.Length\n+\n+            if NN < HT.Buckets'Length then\n+               Rehash (HT, Size => NN);\n+            end if;\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if HT.Buckets = null then\n+         NN := Prime_Numbers.To_Prime (N);\n+\n+         --  ASSERT: NN >= N\n+\n+         Rehash (HT, Size => NN);\n+         return;\n+      end if;\n+\n+      if N <= HT.Length then\n+         if HT.Length >= HT.Buckets'Length then\n+            return;\n+         end if;\n+\n+         NN := Prime_Numbers.To_Prime (HT.Length);\n+\n+         --  ASSERT: NN >= HT.Length\n+\n+         if NN < HT.Buckets'Length then\n+            Rehash (HT, Size => NN);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  ASSERT: N > HT.Length\n+\n+      if N = HT.Buckets'Length then\n+         return;\n+      end if;\n+\n+      NN := Prime_Numbers.To_Prime (N);\n+\n+      --  ASSERT: NN >= N\n+      --  ASSERT: NN > HT.Length\n+\n+      if NN /= HT.Buckets'Length then\n+         Rehash (HT, Size => NN);\n+      end if;\n+   end Ensure_Capacity;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (HT : in out Hash_Table_Type) is\n+   begin\n+      Clear (HT);\n+      Free (HT.Buckets);\n+   end Finalize;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (HT : Hash_Table_Type) return Node_Access is\n+      Indx : Hash_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return Null_Node;\n+      end if;\n+\n+      Indx := HT.Buckets'First;\n+      loop\n+         if HT.Buckets (Indx) /= Null_Node then\n+            return HT.Buckets (Indx);\n+         end if;\n+\n+         Indx := Indx + 1;\n+      end loop;\n+   end First;\n+\n+   ---------------------\n+   -- Free_Hash_Table --\n+   ---------------------\n+\n+   procedure Free_Hash_Table (Buckets : in out Buckets_Access) is\n+      Node : Node_Access;\n+\n+   begin\n+      if Buckets = null then\n+         return;\n+      end if;\n+\n+      for J in Buckets'Range loop\n+         while Buckets (J) /= Null_Node loop\n+            Node := Buckets (J);\n+            Buckets (J) := Next (Node);\n+            Free (Node);\n+         end loop;\n+      end loop;\n+\n+      Free (Buckets);\n+   end Free_Hash_Table;\n+\n+   -------------------\n+   -- Generic_Equal --\n+   -------------------\n+\n+   function Generic_Equal\n+     (L, R : Hash_Table_Type) return Boolean is\n+\n+      L_Index : Hash_Type;\n+      L_Node  : Node_Access;\n+\n+      N : Count_Type;\n+\n+   begin\n+      if L'Address = R'Address then\n+         return True;\n+      end if;\n+\n+      if L.Length /= R.Length then\n+         return False;\n+      end if;\n+\n+      if L.Length = 0 then\n+         return True;\n+      end if;\n+\n+      L_Index := 0;\n+\n+      loop\n+         L_Node := L.Buckets (L_Index);\n+         exit when L_Node /= Null_Node;\n+         L_Index := L_Index + 1;\n+      end loop;\n+\n+      N := L.Length;\n+\n+      loop\n+         if not Find (HT => R, Key => L_Node) then\n+            return False;\n+         end if;\n+\n+         N := N - 1;\n+\n+         L_Node := Next (L_Node);\n+\n+         if L_Node = Null_Node then\n+            if N = 0 then\n+               return True;\n+            end if;\n+\n+            loop\n+               L_Index := L_Index + 1;\n+               L_Node := L.Buckets (L_Index);\n+               exit when L_Node /= Null_Node;\n+            end loop;\n+         end if;\n+      end loop;\n+   end Generic_Equal;\n+\n+   -----------------------\n+   -- Generic_Iteration --\n+   -----------------------\n+\n+   procedure Generic_Iteration (HT : Hash_Table_Type) is\n+      Node : Node_Access;\n+\n+   begin\n+      if HT.Buckets = null\n+        or else HT.Length = 0\n+      then\n+         return;\n+      end if;\n+\n+      for Indx in HT.Buckets'Range loop\n+         Node := HT.Buckets (Indx);\n+         while Node /= Null_Node loop\n+            Process (Node);\n+            Node := Next (Node);\n+         end loop;\n+      end loop;\n+   end Generic_Iteration;\n+\n+   ------------------\n+   -- Generic_Read --\n+   ------------------\n+\n+   procedure Generic_Read\n+     (Stream : access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type)\n+   is\n+      X, Y : Node_Access;\n+\n+      Last, I : Hash_Type;\n+      N, M    : Count_Type'Base;\n+\n+   begin\n+      --  As with the sorted set, it's not clear whether read is allowed to\n+      --  have side effect if it fails. For now, we assume side effects are\n+      --  allowed since it simplifies the algorithm ???\n+      --\n+      Clear (HT);\n+\n+      declare\n+         B : Buckets_Access := HT.Buckets;\n+      begin\n+         HT.Buckets := null;\n+         HT.Length := 0;\n+         Free (B); -- can this fail???\n+      end;\n+\n+      Hash_Type'Read (Stream, Last);\n+\n+      if Last /= 0 then\n+         HT.Buckets := new Buckets_Type (0 .. Last);\n+      end if;\n+\n+      Count_Type'Base'Read (Stream, N);\n+      pragma Assert (N >= 0);\n+      while N > 0 loop\n+         Hash_Type'Read (Stream, I);\n+         pragma Assert (I in HT.Buckets'Range);\n+         pragma Assert (HT.Buckets (I) = Null_Node);\n+\n+         Count_Type'Base'Read (Stream, M);\n+         pragma Assert (M >= 1);\n+         pragma Assert (M <= N);\n+\n+         HT.Buckets (I) := New_Node (Stream);\n+         pragma Assert (HT.Buckets (I) /= Null_Node);\n+         pragma Assert (Next (HT.Buckets (I)) = Null_Node);\n+\n+         Y := HT.Buckets (I);\n+\n+         HT.Length := HT.Length + 1;\n+\n+         for J in Count_Type range 2 .. M loop\n+            X := New_Node (Stream);\n+            pragma Assert (X /= Null_Node);\n+            pragma Assert (Next (X) = Null_Node);\n+\n+            Set_Next (Node => Y, Next => X);\n+            Y := X;\n+\n+            HT.Length := HT.Length + 1;\n+         end loop;\n+\n+         N := N - M;\n+      end loop;\n+   end Generic_Read;\n+\n+   -------------------\n+   -- Generic_Write --\n+   -------------------\n+\n+   procedure Generic_Write\n+     (Stream : access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type)\n+   is\n+      M : Count_Type'Base;\n+      X : Node_Access;\n+\n+   begin\n+      if HT.Buckets = null then\n+         Hash_Type'Write (Stream, 0);\n+      else\n+         Hash_Type'Write (Stream, HT.Buckets'Last);\n+      end if;\n+\n+      Count_Type'Base'Write (Stream, HT.Length);\n+\n+      if HT.Length = 0 then\n+         return;\n+      end if;\n+\n+      for Indx in HT.Buckets'Range loop\n+         X := HT.Buckets (Indx);\n+\n+         if X /= Null_Node then\n+            M := 1;\n+            loop\n+               X := Next (X);\n+               exit when X = Null_Node;\n+               M := M + 1;\n+            end loop;\n+\n+            Hash_Type'Write (Stream, Indx);\n+            Count_Type'Base'Write (Stream, M);\n+\n+            X := HT.Buckets (Indx);\n+            for J in Count_Type range 1 .. M loop\n+               Write (Stream, X);\n+               X := Next (X);\n+            end loop;\n+\n+            pragma Assert (X = Null_Node);\n+         end if;\n+      end loop;\n+   end Generic_Write;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Access) return Hash_Type is\n+   begin\n+      return Hash_Node (Node) mod Buckets'Length;\n+   end Index;\n+\n+   function Index\n+     (Hash_Table : Hash_Table_Type;\n+      Node       : Node_Access) return Hash_Type is\n+   begin\n+      return Index (Hash_Table.Buckets.all, Node);\n+   end Index;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target, Source : in out Hash_Table_Type) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Length > 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Free (Target.Buckets);\n+\n+      Target.Buckets := Source.Buckets;\n+      Source.Buckets := null;\n+\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (HT   : Hash_Table_Type;\n+      Node : Node_Access) return Node_Access\n+   is\n+      Result : Node_Access := Next (Node);\n+\n+   begin\n+      if Result /= Null_Node then\n+         return Result;\n+      end if;\n+\n+      for Indx in Index (HT, Node) + 1 .. HT.Buckets'Last loop\n+         Result := HT.Buckets (Indx);\n+\n+         if Result /= Null_Node then\n+            return Result;\n+         end if;\n+      end loop;\n+\n+      return Null_Node;\n+   end Next;\n+\n+   ------------\n+   -- Rehash --\n+   ------------\n+\n+   procedure Rehash\n+     (HT   : in out Hash_Table_Type;\n+      Size : Hash_Type)\n+   is\n+      subtype Buckets_Range is Hash_Type range 0 .. Size - 1;\n+\n+      Dst_Buckets : Buckets_Access := new Buckets_Type (Buckets_Range);\n+      Src_Buckets : Buckets_Access := HT.Buckets;\n+\n+      L  : Count_Type renames HT.Length;\n+      LL : constant Count_Type := L;\n+\n+   begin\n+      if Src_Buckets = null then\n+         pragma Assert (L = 0);\n+         HT.Buckets := Dst_Buckets;\n+         return;\n+      end if;\n+\n+      if L = 0 then\n+         HT.Buckets := Dst_Buckets;\n+         Free (Src_Buckets);\n+         return;\n+      end if;\n+\n+      --  We might want to change this to iter from 1 .. L instead ???\n+\n+      for Src_Index in Src_Buckets'Range loop\n+\n+         declare\n+            Src_Bucket : Node_Access renames Src_Buckets (Src_Index);\n+         begin\n+            while Src_Bucket /= Null_Node loop\n+               declare\n+                  Src_Node   : constant Node_Access := Src_Bucket;\n+                  Dst_Index  : constant Hash_Type :=\n+                                 Index (Dst_Buckets.all, Src_Node);\n+                  Dst_Bucket : Node_Access renames Dst_Buckets (Dst_Index);\n+               begin\n+                  Src_Bucket := Next (Src_Node);\n+                  Set_Next (Src_Node, Dst_Bucket);\n+                  Dst_Bucket := Src_Node;\n+               end;\n+\n+               pragma Assert (L > 0);\n+               L := L - 1;\n+\n+            end loop;\n+\n+         exception\n+            when others =>\n+\n+               --  Not clear that we can deallocate the nodes,\n+               --  because they may be designated by outstanding\n+               --  iterators.  Which means they're now lost... ???\n+\n+               --                 for J in NB'Range loop\n+               --                    declare\n+               --                       Dst : Node_Access renames NB (J);\n+               --                       X   : Node_Access;\n+               --                    begin\n+               --                       while Dst /= Null_Node loop\n+               --                          X := Dst;\n+               --                          Dst := Succ (Dst);\n+               --                          Free (X);\n+               --                       end loop;\n+               --                    end;\n+               --                 end loop;\n+\n+\n+               Free (Dst_Buckets);\n+               raise;\n+         end;\n+\n+         --  exit when L = 0;\n+         --  need to bother???\n+\n+      end loop;\n+\n+      pragma Assert (L = 0);\n+\n+      HT.Buckets := Dst_Buckets;\n+      HT.Length := LL;\n+\n+      Free (Src_Buckets);\n+   end Rehash;\n+\n+end Ada.Containers.Hash_Tables.Generic_Operations;\n+"}, {"sha": "232c719b04c69157b90685636dd592e09d2ad0aa", "filename": "gcc/ada/a-chtgop.ads", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,111 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.HASH_TABLES.GENERIC_OPERATIONS               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Streams;\n+\n+generic\n+\n+   with package HT_Types is\n+     new Generic_Hash_Table_Types (<>);\n+\n+   type Hash_Table_Type is new HT_Types.Hash_Table_Type with private;\n+\n+   use HT_Types;\n+\n+   Null_Node : in Node_Access;\n+\n+   with function Hash_Node (Node : Node_Access) return Hash_Type;\n+\n+   with function Next (Node : Node_Access) return Node_Access;\n+\n+   with procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access);\n+\n+    with function Copy_Node (Source : Node_Access) return Node_Access;\n+\n+   with procedure Free (X : in out Node_Access);\n+\n+package Ada.Containers.Hash_Tables.Generic_Operations is\n+   pragma Preelaborate;\n+\n+   procedure Free_Hash_Table (Buckets : in out Buckets_Access);\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Access) return Hash_Type;\n+   pragma Inline (Index);\n+\n+   function Index\n+     (Hash_Table : Hash_Table_Type;\n+      Node       : Node_Access) return Hash_Type;\n+   pragma Inline (Index);\n+\n+   procedure Adjust (HT : in out Hash_Table_Type);\n+\n+   procedure Finalize (HT : in out Hash_Table_Type);\n+\n+   generic\n+      with function Find\n+        (HT  : Hash_Table_Type;\n+         Key : Node_Access) return Boolean;\n+   function Generic_Equal\n+     (L, R : Hash_Table_Type) return Boolean;\n+\n+   procedure Clear (HT : in out Hash_Table_Type);\n+\n+   procedure Move (Target, Source : in out Hash_Table_Type);\n+\n+   function Capacity (HT : Hash_Table_Type) return Count_Type;\n+\n+   procedure Ensure_Capacity\n+     (HT : in out Hash_Table_Type;\n+      N  : Count_Type);\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Node_Access);\n+\n+   function First (HT : Hash_Table_Type) return Node_Access;\n+\n+   function Next\n+     (HT   : Hash_Table_Type;\n+      Node : Node_Access) return Node_Access;\n+\n+   generic\n+      with procedure Process (Node : Node_Access);\n+   procedure Generic_Iteration (HT : Hash_Table_Type);\n+\n+   generic\n+      use Ada.Streams;\n+      with procedure Write\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+   procedure Generic_Write\n+     (Stream : access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type);\n+\n+   generic\n+      use Ada.Streams;\n+      with function New_Node (Stream : access Root_Stream_Type'Class)\n+         return Node_Access;\n+   procedure Generic_Read\n+     (Stream : access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type);\n+\n+end Ada.Containers.Hash_Tables.Generic_Operations;\n+"}, {"sha": "230a8156d03b7f998a8478c35957d22f630ecf70", "filename": "gcc/ada/a-chzla1.ads", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chzla1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chzla1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chzla1.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,378 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--     A D A . C H A R A C T E R S . W I D E _ W I D E _ L A T I N _ 1      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides definitions analogous to those in the RM defined\n+--  package Ada.Characters.Latin_1 except that the type of the constants\n+--  is Wide_Wide_Character instead of Character. The provision of this package\n+--  is in accordance with the implementation permission in RM (A.3.3(27)).\n+\n+package Ada.Characters.Wide_Wide_Latin_1 is\n+pragma Pure (Wide_Wide_Latin_1);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (0);\n+   SOH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (1);\n+   STX  : constant Wide_Wide_Character := Wide_Wide_Character'Val (2);\n+   ETX  : constant Wide_Wide_Character := Wide_Wide_Character'Val (3);\n+   EOT  : constant Wide_Wide_Character := Wide_Wide_Character'Val (4);\n+   ENQ  : constant Wide_Wide_Character := Wide_Wide_Character'Val (5);\n+   ACK  : constant Wide_Wide_Character := Wide_Wide_Character'Val (6);\n+   BEL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (7);\n+   BS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (8);\n+   HT   : constant Wide_Wide_Character := Wide_Wide_Character'Val (9);\n+   LF   : constant Wide_Wide_Character := Wide_Wide_Character'Val (10);\n+   VT   : constant Wide_Wide_Character := Wide_Wide_Character'Val (11);\n+   FF   : constant Wide_Wide_Character := Wide_Wide_Character'Val (12);\n+   CR   : constant Wide_Wide_Character := Wide_Wide_Character'Val (13);\n+   SO   : constant Wide_Wide_Character := Wide_Wide_Character'Val (14);\n+   SI   : constant Wide_Wide_Character := Wide_Wide_Character'Val (15);\n+\n+   DLE  : constant Wide_Wide_Character := Wide_Wide_Character'Val (16);\n+   DC1  : constant Wide_Wide_Character := Wide_Wide_Character'Val (17);\n+   DC2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (18);\n+   DC3  : constant Wide_Wide_Character := Wide_Wide_Character'Val (19);\n+   DC4  : constant Wide_Wide_Character := Wide_Wide_Character'Val (20);\n+   NAK  : constant Wide_Wide_Character := Wide_Wide_Character'Val (21);\n+   SYN  : constant Wide_Wide_Character := Wide_Wide_Character'Val (22);\n+   ETB  : constant Wide_Wide_Character := Wide_Wide_Character'Val (23);\n+   CAN  : constant Wide_Wide_Character := Wide_Wide_Character'Val (24);\n+   EM   : constant Wide_Wide_Character := Wide_Wide_Character'Val (25);\n+   SUB  : constant Wide_Wide_Character := Wide_Wide_Character'Val (26);\n+   ESC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (27);\n+   FS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (28);\n+   GS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (29);\n+   RS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (30);\n+   US   : constant Wide_Wide_Character := Wide_Wide_Character'Val (31);\n+\n+   -------------------------------------\n+   -- ISO 646 Graphic Wide_Wide_Characters --\n+   -------------------------------------\n+\n+   Space                : constant Wide_Wide_Character := ' ';  -- WC'Val(32)\n+   Exclamation          : constant Wide_Wide_Character := '!';  -- WC'Val(33)\n+   Quotation            : constant Wide_Wide_Character := '\"';  -- WC'Val(34)\n+   Number_Sign          : constant Wide_Wide_Character := '#';  -- WC'Val(35)\n+   Dollar_Sign          : constant Wide_Wide_Character := '$';  -- WC'Val(36)\n+   Percent_Sign         : constant Wide_Wide_Character := '%';  -- WC'Val(37)\n+   Ampersand            : constant Wide_Wide_Character := '&';  -- WC'Val(38)\n+   Apostrophe           : constant Wide_Wide_Character := ''';  -- WC'Val(39)\n+   Left_Parenthesis     : constant Wide_Wide_Character := '(';  -- WC'Val(40)\n+   Right_Parenthesis    : constant Wide_Wide_Character := ')';  -- WC'Val(41)\n+   Asterisk             : constant Wide_Wide_Character := '*';  -- WC'Val(42)\n+   Plus_Sign            : constant Wide_Wide_Character := '+';  -- WC'Val(43)\n+   Comma                : constant Wide_Wide_Character := ',';  -- WC'Val(44)\n+   Hyphen               : constant Wide_Wide_Character := '-';  -- WC'Val(45)\n+   Minus_Sign           : Wide_Wide_Character renames Hyphen;\n+   Full_Stop            : constant Wide_Wide_Character := '.';  -- WC'Val(46)\n+   Solidus              : constant Wide_Wide_Character := '/';  -- WC'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Wide_Wide_Character := ':';  -- WC'Val(58)\n+   Semicolon            : constant Wide_Wide_Character := ';';  -- WC'Val(59)\n+   Less_Than_Sign       : constant Wide_Wide_Character := '<';  -- WC'Val(60)\n+   Equals_Sign          : constant Wide_Wide_Character := '=';  -- WC'Val(61)\n+   Greater_Than_Sign    : constant Wide_Wide_Character := '>';  -- WC'Val(62)\n+   Question             : constant Wide_Wide_Character := '?';  -- WC'Val(63)\n+\n+   Commercial_At        : constant Wide_Wide_Character := '@';  -- WC'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Wide_Wide_Character := '[';  -- WC'Val (91)\n+   Reverse_Solidus      : constant Wide_Wide_Character := '\\';  -- WC'Val (92)\n+   Right_Square_Bracket : constant Wide_Wide_Character := ']';  -- WC'Val (93)\n+   Circumflex           : constant Wide_Wide_Character := '^';  -- WC'Val (94)\n+   Low_Line             : constant Wide_Wide_Character := '_';  -- WC'Val (95)\n+\n+   Grave                : constant Wide_Wide_Character := '`';  -- WC'Val (96)\n+   LC_A                 : constant Wide_Wide_Character := 'a';  -- WC'Val (97)\n+   LC_B                 : constant Wide_Wide_Character := 'b';  -- WC'Val (98)\n+   LC_C                 : constant Wide_Wide_Character := 'c';  -- WC'Val (99)\n+   LC_D                 : constant Wide_Wide_Character := 'd';  -- WC'Val (100)\n+   LC_E                 : constant Wide_Wide_Character := 'e';  -- WC'Val (101)\n+   LC_F                 : constant Wide_Wide_Character := 'f';  -- WC'Val (102)\n+   LC_G                 : constant Wide_Wide_Character := 'g';  -- WC'Val (103)\n+   LC_H                 : constant Wide_Wide_Character := 'h';  -- WC'Val (104)\n+   LC_I                 : constant Wide_Wide_Character := 'i';  -- WC'Val (105)\n+   LC_J                 : constant Wide_Wide_Character := 'j';  -- WC'Val (106)\n+   LC_K                 : constant Wide_Wide_Character := 'k';  -- WC'Val (107)\n+   LC_L                 : constant Wide_Wide_Character := 'l';  -- WC'Val (108)\n+   LC_M                 : constant Wide_Wide_Character := 'm';  -- WC'Val (109)\n+   LC_N                 : constant Wide_Wide_Character := 'n';  -- WC'Val (110)\n+   LC_O                 : constant Wide_Wide_Character := 'o';  -- WC'Val (111)\n+   LC_P                 : constant Wide_Wide_Character := 'p';  -- WC'Val (112)\n+   LC_Q                 : constant Wide_Wide_Character := 'q';  -- WC'Val (113)\n+   LC_R                 : constant Wide_Wide_Character := 'r';  -- WC'Val (114)\n+   LC_S                 : constant Wide_Wide_Character := 's';  -- WC'Val (115)\n+   LC_T                 : constant Wide_Wide_Character := 't';  -- WC'Val (116)\n+   LC_U                 : constant Wide_Wide_Character := 'u';  -- WC'Val (117)\n+   LC_V                 : constant Wide_Wide_Character := 'v';  -- WC'Val (118)\n+   LC_W                 : constant Wide_Wide_Character := 'w';  -- WC'Val (119)\n+   LC_X                 : constant Wide_Wide_Character := 'x';  -- WC'Val (120)\n+   LC_Y                 : constant Wide_Wide_Character := 'y';  -- WC'Val (121)\n+   LC_Z                 : constant Wide_Wide_Character := 'z';  -- WC'Val (122)\n+   Left_Curly_Bracket   : constant Wide_Wide_Character := '{';  -- WC'Val (123)\n+   Vertical_Line        : constant Wide_Wide_Character := '|';  -- WC'Val (124)\n+   Right_Curly_Bracket  : constant Wide_Wide_Character := '}';  -- WC'Val (125)\n+   Tilde                : constant Wide_Wide_Character := '~';  -- WC'Val (126)\n+   DEL                  : constant Wide_Wide_Character :=\n+                            Wide_Wide_Character'Val (127);\n+\n+   --------------------------------------\n+   -- ISO 6429 Control Wide_Wide_Characters --\n+   --------------------------------------\n+\n+   IS4 : Wide_Wide_Character renames FS;\n+   IS3 : Wide_Wide_Character renames GS;\n+   IS2 : Wide_Wide_Character renames RS;\n+   IS1 : Wide_Wide_Character renames US;\n+\n+   Reserved_128\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (128);\n+   Reserved_129\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (129);\n+   BPH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (130);\n+   NBH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (131);\n+   Reserved_132\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (132);\n+   NEL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (133);\n+   SSA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (134);\n+   ESA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (135);\n+   HTS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (136);\n+   HTJ  : constant Wide_Wide_Character := Wide_Wide_Character'Val (137);\n+   VTS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (138);\n+   PLD  : constant Wide_Wide_Character := Wide_Wide_Character'Val (139);\n+   PLU  : constant Wide_Wide_Character := Wide_Wide_Character'Val (140);\n+   RI   : constant Wide_Wide_Character := Wide_Wide_Character'Val (141);\n+   SS2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (142);\n+   SS3  : constant Wide_Wide_Character := Wide_Wide_Character'Val (143);\n+\n+   DCS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (144);\n+   PU1  : constant Wide_Wide_Character := Wide_Wide_Character'Val (145);\n+   PU2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (146);\n+   STS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (147);\n+   CCH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (148);\n+   MW   : constant Wide_Wide_Character := Wide_Wide_Character'Val (149);\n+   SPA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (150);\n+   EPA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (151);\n+\n+   SOS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (152);\n+   Reserved_153\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (153);\n+   SCI  : constant Wide_Wide_Character := Wide_Wide_Character'Val (154);\n+   CSI  : constant Wide_Wide_Character := Wide_Wide_Character'Val (155);\n+   ST   : constant Wide_Wide_Character := Wide_Wide_Character'Val (156);\n+   OSC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (157);\n+   PM   : constant Wide_Wide_Character := Wide_Wide_Character'Val (158);\n+   APC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (159);\n+\n+   -----------------------------------\n+   -- Other Graphic Wide_Wide_Characters --\n+   -----------------------------------\n+\n+   --  Wide_Wide_Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (160);\n+   NBSP        : Wide_Wide_Character renames No_Break_Space;\n+   Inverted_Exclamation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (161);\n+   Cent_Sign   : constant Wide_Wide_Character := Wide_Wide_Character'Val (162);\n+   Pound_Sign  : constant Wide_Wide_Character := Wide_Wide_Character'Val (163);\n+   Currency_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (164);\n+   Yen_Sign    : constant Wide_Wide_Character := Wide_Wide_Character'Val (165);\n+   Broken_Bar  : constant Wide_Wide_Character := Wide_Wide_Character'Val (166);\n+   Section_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (167);\n+   Diaeresis   : constant Wide_Wide_Character := Wide_Wide_Character'Val (168);\n+   Copyright_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (169);\n+   Feminine_Ordinal_Indicator\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (170);\n+   Left_Angle_Quotation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (171);\n+   Not_Sign    : constant Wide_Wide_Character := Wide_Wide_Character'Val (172);\n+   Soft_Hyphen : constant Wide_Wide_Character := Wide_Wide_Character'Val (173);\n+   Registered_Trade_Mark_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (174);\n+   Macron      : constant Wide_Wide_Character := Wide_Wide_Character'Val (175);\n+\n+   --  Wide_Wide_Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign : constant Wide_Wide_Character := Wide_Wide_Character'Val (176);\n+   Ring_Above  : Wide_Wide_Character renames Degree_Sign;\n+   Plus_Minus_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (177);\n+   Superscript_Two\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (178);\n+   Superscript_Three\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (179);\n+   Acute       : constant Wide_Wide_Character := Wide_Wide_Character'Val (180);\n+   Micro_Sign  : constant Wide_Wide_Character := Wide_Wide_Character'Val (181);\n+   Pilcrow_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (182);\n+   Paragraph_Sign\n+               : Wide_Wide_Character renames Pilcrow_Sign;\n+   Middle_Dot  : constant Wide_Wide_Character := Wide_Wide_Character'Val (183);\n+   Cedilla     : constant Wide_Wide_Character := Wide_Wide_Character'Val (184);\n+   Superscript_One\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (185);\n+   Masculine_Ordinal_Indicator\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (186);\n+   Right_Angle_Quotation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (187);\n+   Fraction_One_Quarter\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (188);\n+   Fraction_One_Half\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (189);\n+   Fraction_Three_Quarters\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (190);\n+   Inverted_Question\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (191);\n+\n+   --  Wide_Wide_Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (192);\n+   UC_A_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (193);\n+   UC_A_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (194);\n+   UC_A_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (195);\n+   UC_A_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (196);\n+   UC_A_Ring   : constant Wide_Wide_Character := Wide_Wide_Character'Val (197);\n+   UC_AE_Diphthong\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (198);\n+   UC_C_Cedilla\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (199);\n+   UC_E_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (200);\n+   UC_E_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (201);\n+   UC_E_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (202);\n+   UC_E_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (203);\n+   UC_I_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (204);\n+   UC_I_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (205);\n+   UC_I_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (206);\n+   UC_I_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (207);\n+\n+   --  Wide_Wide_Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (208);\n+   UC_N_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (209);\n+   UC_O_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (210);\n+   UC_O_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (211);\n+   UC_O_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (212);\n+   UC_O_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (213);\n+   UC_O_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (214);\n+   Multiplication_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (215);\n+   UC_O_Oblique_Stroke\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (216);\n+   UC_U_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (217);\n+   UC_U_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (218);\n+   UC_U_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (219);\n+   UC_U_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (220);\n+   UC_Y_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (221);\n+   UC_Icelandic_Thorn\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (222);\n+   LC_German_Sharp_S\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (223);\n+\n+   --  Wide_Wide_Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (224);\n+   LC_A_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (225);\n+   LC_A_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (226);\n+   LC_A_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (227);\n+   LC_A_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (228);\n+   LC_A_Ring   : constant Wide_Wide_Character := Wide_Wide_Character'Val (229);\n+   LC_AE_Diphthong\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (230);\n+   LC_C_Cedilla\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (231);\n+   LC_E_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (232);\n+   LC_E_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (233);\n+   LC_E_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (234);\n+   LC_E_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (235);\n+   LC_I_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (236);\n+   LC_I_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (237);\n+   LC_I_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (238);\n+   LC_I_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (239);\n+\n+   --  Wide_Wide_Character positions 240 (16#F0#) .. 255 (16#FF)\n+\n+   LC_Icelandic_Eth\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (240);\n+   LC_N_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (241);\n+   LC_O_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (242);\n+   LC_O_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (243);\n+   LC_O_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (244);\n+   LC_O_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (245);\n+   LC_O_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (246);\n+   Division_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (247);\n+   LC_O_Oblique_Stroke\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (248);\n+   LC_U_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (249);\n+   LC_U_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (250);\n+   LC_U_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (251);\n+   LC_U_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (252);\n+   LC_Y_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (253);\n+   LC_Icelandic_Thorn\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (254);\n+   LC_Y_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (255);\n+\n+end Ada.Characters.Wide_Wide_Latin_1;"}, {"sha": "40691f2e6fdc5f5096aad30de0549e67755789c6", "filename": "gcc/ada/a-chzla9.ads", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chzla9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-chzla9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chzla9.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,390 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--     A D A . C H A R A C T E R S . W I D E _ W I D E _ L A T I N _ 9      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides definitions analogous to those in the GNAT package\n+--  Ada.Characters.Latin_9 except that the type of the various constants is\n+--  Wide_Wide_Character instead of Character. The provision of this package\n+--  is in accordance with the implementation permission in RM (A.3.3(27)).\n+\n+package Ada.Characters.Wide_Wide_Latin_9 is\n+pragma Pure (Wide_Wide_Latin_9);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (0);\n+   SOH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (1);\n+   STX  : constant Wide_Wide_Character := Wide_Wide_Character'Val (2);\n+   ETX  : constant Wide_Wide_Character := Wide_Wide_Character'Val (3);\n+   EOT  : constant Wide_Wide_Character := Wide_Wide_Character'Val (4);\n+   ENQ  : constant Wide_Wide_Character := Wide_Wide_Character'Val (5);\n+   ACK  : constant Wide_Wide_Character := Wide_Wide_Character'Val (6);\n+   BEL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (7);\n+   BS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (8);\n+   HT   : constant Wide_Wide_Character := Wide_Wide_Character'Val (9);\n+   LF   : constant Wide_Wide_Character := Wide_Wide_Character'Val (10);\n+   VT   : constant Wide_Wide_Character := Wide_Wide_Character'Val (11);\n+   FF   : constant Wide_Wide_Character := Wide_Wide_Character'Val (12);\n+   CR   : constant Wide_Wide_Character := Wide_Wide_Character'Val (13);\n+   SO   : constant Wide_Wide_Character := Wide_Wide_Character'Val (14);\n+   SI   : constant Wide_Wide_Character := Wide_Wide_Character'Val (15);\n+\n+   DLE  : constant Wide_Wide_Character := Wide_Wide_Character'Val (16);\n+   DC1  : constant Wide_Wide_Character := Wide_Wide_Character'Val (17);\n+   DC2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (18);\n+   DC3  : constant Wide_Wide_Character := Wide_Wide_Character'Val (19);\n+   DC4  : constant Wide_Wide_Character := Wide_Wide_Character'Val (20);\n+   NAK  : constant Wide_Wide_Character := Wide_Wide_Character'Val (21);\n+   SYN  : constant Wide_Wide_Character := Wide_Wide_Character'Val (22);\n+   ETB  : constant Wide_Wide_Character := Wide_Wide_Character'Val (23);\n+   CAN  : constant Wide_Wide_Character := Wide_Wide_Character'Val (24);\n+   EM   : constant Wide_Wide_Character := Wide_Wide_Character'Val (25);\n+   SUB  : constant Wide_Wide_Character := Wide_Wide_Character'Val (26);\n+   ESC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (27);\n+   FS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (28);\n+   GS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (29);\n+   RS   : constant Wide_Wide_Character := Wide_Wide_Character'Val (30);\n+   US   : constant Wide_Wide_Character := Wide_Wide_Character'Val (31);\n+\n+   -------------------------------------\n+   -- ISO 646 Graphic Wide_Wide_Characters --\n+   -------------------------------------\n+\n+   Space                : constant Wide_Wide_Character := ' ';  -- WC'Val(32)\n+   Exclamation          : constant Wide_Wide_Character := '!';  -- WC'Val(33)\n+   Quotation            : constant Wide_Wide_Character := '\"';  -- WC'Val(34)\n+   Number_Sign          : constant Wide_Wide_Character := '#';  -- WC'Val(35)\n+   Dollar_Sign          : constant Wide_Wide_Character := '$';  -- WC'Val(36)\n+   Percent_Sign         : constant Wide_Wide_Character := '%';  -- WC'Val(37)\n+   Ampersand            : constant Wide_Wide_Character := '&';  -- WC'Val(38)\n+   Apostrophe           : constant Wide_Wide_Character := ''';  -- WC'Val(39)\n+   Left_Parenthesis     : constant Wide_Wide_Character := '(';  -- WC'Val(40)\n+   Right_Parenthesis    : constant Wide_Wide_Character := ')';  -- WC'Val(41)\n+   Asterisk             : constant Wide_Wide_Character := '*';  -- WC'Val(42)\n+   Plus_Sign            : constant Wide_Wide_Character := '+';  -- WC'Val(43)\n+   Comma                : constant Wide_Wide_Character := ',';  -- WC'Val(44)\n+   Hyphen               : constant Wide_Wide_Character := '-';  -- WC'Val(45)\n+   Minus_Sign           : Wide_Wide_Character renames Hyphen;\n+   Full_Stop            : constant Wide_Wide_Character := '.';  -- WC'Val(46)\n+   Solidus              : constant Wide_Wide_Character := '/';  -- WC'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Wide_Wide_Character := ':';  -- WC'Val(58)\n+   Semicolon            : constant Wide_Wide_Character := ';';  -- WC'Val(59)\n+   Less_Than_Sign       : constant Wide_Wide_Character := '<';  -- WC'Val(60)\n+   Equals_Sign          : constant Wide_Wide_Character := '=';  -- WC'Val(61)\n+   Greater_Than_Sign    : constant Wide_Wide_Character := '>';  -- WC'Val(62)\n+   Question             : constant Wide_Wide_Character := '?';  -- WC'Val(63)\n+\n+   Commercial_At        : constant Wide_Wide_Character := '@';  -- WC'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Wide_Wide_Character := '[';  -- WC'Val (91)\n+   Reverse_Solidus      : constant Wide_Wide_Character := '\\';  -- WC'Val (92)\n+   Right_Square_Bracket : constant Wide_Wide_Character := ']';  -- WC'Val (93)\n+   Circumflex           : constant Wide_Wide_Character := '^';  -- WC'Val (94)\n+   Low_Line             : constant Wide_Wide_Character := '_';  -- WC'Val (95)\n+\n+   Grave                : constant Wide_Wide_Character := '`';  -- WC'Val (96)\n+   LC_A                 : constant Wide_Wide_Character := 'a';  -- WC'Val (97)\n+   LC_B                 : constant Wide_Wide_Character := 'b';  -- WC'Val (98)\n+   LC_C                 : constant Wide_Wide_Character := 'c';  -- WC'Val (99)\n+   LC_D                 : constant Wide_Wide_Character := 'd';  -- WC'Val (100)\n+   LC_E                 : constant Wide_Wide_Character := 'e';  -- WC'Val (101)\n+   LC_F                 : constant Wide_Wide_Character := 'f';  -- WC'Val (102)\n+   LC_G                 : constant Wide_Wide_Character := 'g';  -- WC'Val (103)\n+   LC_H                 : constant Wide_Wide_Character := 'h';  -- WC'Val (104)\n+   LC_I                 : constant Wide_Wide_Character := 'i';  -- WC'Val (105)\n+   LC_J                 : constant Wide_Wide_Character := 'j';  -- WC'Val (106)\n+   LC_K                 : constant Wide_Wide_Character := 'k';  -- WC'Val (107)\n+   LC_L                 : constant Wide_Wide_Character := 'l';  -- WC'Val (108)\n+   LC_M                 : constant Wide_Wide_Character := 'm';  -- WC'Val (109)\n+   LC_N                 : constant Wide_Wide_Character := 'n';  -- WC'Val (110)\n+   LC_O                 : constant Wide_Wide_Character := 'o';  -- WC'Val (111)\n+   LC_P                 : constant Wide_Wide_Character := 'p';  -- WC'Val (112)\n+   LC_Q                 : constant Wide_Wide_Character := 'q';  -- WC'Val (113)\n+   LC_R                 : constant Wide_Wide_Character := 'r';  -- WC'Val (114)\n+   LC_S                 : constant Wide_Wide_Character := 's';  -- WC'Val (115)\n+   LC_T                 : constant Wide_Wide_Character := 't';  -- WC'Val (116)\n+   LC_U                 : constant Wide_Wide_Character := 'u';  -- WC'Val (117)\n+   LC_V                 : constant Wide_Wide_Character := 'v';  -- WC'Val (118)\n+   LC_W                 : constant Wide_Wide_Character := 'w';  -- WC'Val (119)\n+   LC_X                 : constant Wide_Wide_Character := 'x';  -- WC'Val (120)\n+   LC_Y                 : constant Wide_Wide_Character := 'y';  -- WC'Val (121)\n+   LC_Z                 : constant Wide_Wide_Character := 'z';  -- WC'Val (122)\n+   Left_Curly_Bracket   : constant Wide_Wide_Character := '{';  -- WC'Val (123)\n+   Vertical_Line        : constant Wide_Wide_Character := '|';  -- WC'Val (124)\n+   Right_Curly_Bracket  : constant Wide_Wide_Character := '}';  -- WC'Val (125)\n+   Tilde                : constant Wide_Wide_Character := '~';  -- WC'Val (126)\n+   DEL                  : constant Wide_Wide_Character :=\n+                            Wide_Wide_Character'Val (127);\n+\n+   --------------------------------------\n+   -- ISO 6429 Control Wide_Wide_Characters --\n+   --------------------------------------\n+\n+   IS4 : Wide_Wide_Character renames FS;\n+   IS3 : Wide_Wide_Character renames GS;\n+   IS2 : Wide_Wide_Character renames RS;\n+   IS1 : Wide_Wide_Character renames US;\n+\n+   Reserved_128\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (128);\n+   Reserved_129\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (129);\n+   BPH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (130);\n+   NBH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (131);\n+   Reserved_132\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (132);\n+   NEL  : constant Wide_Wide_Character := Wide_Wide_Character'Val (133);\n+   SSA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (134);\n+   ESA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (135);\n+   HTS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (136);\n+   HTJ  : constant Wide_Wide_Character := Wide_Wide_Character'Val (137);\n+   VTS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (138);\n+   PLD  : constant Wide_Wide_Character := Wide_Wide_Character'Val (139);\n+   PLU  : constant Wide_Wide_Character := Wide_Wide_Character'Val (140);\n+   RI   : constant Wide_Wide_Character := Wide_Wide_Character'Val (141);\n+   SS2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (142);\n+   SS3  : constant Wide_Wide_Character := Wide_Wide_Character'Val (143);\n+\n+   DCS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (144);\n+   PU1  : constant Wide_Wide_Character := Wide_Wide_Character'Val (145);\n+   PU2  : constant Wide_Wide_Character := Wide_Wide_Character'Val (146);\n+   STS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (147);\n+   CCH  : constant Wide_Wide_Character := Wide_Wide_Character'Val (148);\n+   MW   : constant Wide_Wide_Character := Wide_Wide_Character'Val (149);\n+   SPA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (150);\n+   EPA  : constant Wide_Wide_Character := Wide_Wide_Character'Val (151);\n+\n+   SOS  : constant Wide_Wide_Character := Wide_Wide_Character'Val (152);\n+   Reserved_153\n+        : constant Wide_Wide_Character := Wide_Wide_Character'Val (153);\n+   SCI  : constant Wide_Wide_Character := Wide_Wide_Character'Val (154);\n+   CSI  : constant Wide_Wide_Character := Wide_Wide_Character'Val (155);\n+   ST   : constant Wide_Wide_Character := Wide_Wide_Character'Val (156);\n+   OSC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (157);\n+   PM   : constant Wide_Wide_Character := Wide_Wide_Character'Val (158);\n+   APC  : constant Wide_Wide_Character := Wide_Wide_Character'Val (159);\n+\n+   -----------------------------------\n+   -- Other Graphic Wide_Wide_Characters --\n+   -----------------------------------\n+\n+   --  Wide_Wide_Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (160);\n+   NBSP        : Wide_Wide_Character renames No_Break_Space;\n+   Inverted_Exclamation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (161);\n+   Cent_Sign   : constant Wide_Wide_Character := Wide_Wide_Character'Val (162);\n+   Pound_Sign  : constant Wide_Wide_Character := Wide_Wide_Character'Val (163);\n+   Euro_Sign   : constant Wide_Wide_Character := Wide_Wide_Character'Val (164);\n+   Yen_Sign    : constant Wide_Wide_Character := Wide_Wide_Character'Val (165);\n+   UC_S_Caron  : constant Wide_Wide_Character := Wide_Wide_Character'Val (166);\n+   Section_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (167);\n+   LC_S_Caron  : constant Wide_Wide_Character := Wide_Wide_Character'Val (168);\n+   Copyright_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (169);\n+   Feminine_Ordinal_Indicator\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (170);\n+   Left_Angle_Quotation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (171);\n+   Not_Sign    : constant Wide_Wide_Character := Wide_Wide_Character'Val (172);\n+   Soft_Hyphen : constant Wide_Wide_Character := Wide_Wide_Character'Val (173);\n+   Registered_Trade_Mark_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (174);\n+   Macron      : constant Wide_Wide_Character := Wide_Wide_Character'Val (175);\n+\n+   --  Wide_Wide_Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign : constant Wide_Wide_Character := Wide_Wide_Character'Val (176);\n+   Ring_Above  : Wide_Wide_Character renames Degree_Sign;\n+   Plus_Minus_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (177);\n+   Superscript_Two\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (178);\n+   Superscript_Three\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (179);\n+   UC_Z_Caron  : constant Wide_Wide_Character := Wide_Wide_Character'Val (180);\n+   Micro_Sign  : constant Wide_Wide_Character := Wide_Wide_Character'Val (181);\n+   Pilcrow_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (182);\n+   Paragraph_Sign\n+               : Wide_Wide_Character renames Pilcrow_Sign;\n+   Middle_Dot  : constant Wide_Wide_Character := Wide_Wide_Character'Val (183);\n+   LC_Z_Caron  : constant Wide_Wide_Character := Wide_Wide_Character'Val (184);\n+   Superscript_One\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (185);\n+   Masculine_Ordinal_Indicator\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (186);\n+   Right_Angle_Quotation\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (187);\n+   UC_Ligature_OE\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (188);\n+   LC_Ligature_OE\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (189);\n+   UC_Y_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (190);\n+   Inverted_Question\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (191);\n+\n+   --  Wide_Wide_Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (192);\n+   UC_A_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (193);\n+   UC_A_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (194);\n+   UC_A_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (195);\n+   UC_A_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (196);\n+   UC_A_Ring   : constant Wide_Wide_Character := Wide_Wide_Character'Val (197);\n+   UC_AE_Diphthong\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (198);\n+   UC_C_Cedilla\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (199);\n+   UC_E_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (200);\n+   UC_E_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (201);\n+   UC_E_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (202);\n+   UC_E_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (203);\n+   UC_I_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (204);\n+   UC_I_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (205);\n+   UC_I_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (206);\n+   UC_I_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (207);\n+\n+   --  Wide_Wide_Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (208);\n+   UC_N_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (209);\n+   UC_O_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (210);\n+   UC_O_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (211);\n+   UC_O_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (212);\n+   UC_O_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (213);\n+   UC_O_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (214);\n+   Multiplication_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (215);\n+   UC_O_Oblique_Stroke\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (216);\n+   UC_U_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (217);\n+   UC_U_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (218);\n+   UC_U_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (219);\n+   UC_U_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (220);\n+   UC_Y_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (221);\n+   UC_Icelandic_Thorn\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (222);\n+   LC_German_Sharp_S\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (223);\n+\n+   --  Wide_Wide_Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (224);\n+   LC_A_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (225);\n+   LC_A_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (226);\n+   LC_A_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (227);\n+   LC_A_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (228);\n+   LC_A_Ring   : constant Wide_Wide_Character := Wide_Wide_Character'Val (229);\n+   LC_AE_Diphthong\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (230);\n+   LC_C_Cedilla\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (231);\n+   LC_E_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (232);\n+   LC_E_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (233);\n+   LC_E_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (234);\n+   LC_E_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (235);\n+   LC_I_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (236);\n+   LC_I_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (237);\n+   LC_I_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (238);\n+   LC_I_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (239);\n+\n+   --  Wide_Wide_Character positions 240 (16#F0#) .. 255 (16#FF)\n+\n+   LC_Icelandic_Eth\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (240);\n+   LC_N_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (241);\n+   LC_O_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (242);\n+   LC_O_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (243);\n+   LC_O_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (244);\n+   LC_O_Tilde  : constant Wide_Wide_Character := Wide_Wide_Character'Val (245);\n+   LC_O_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (246);\n+   Division_Sign\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (247);\n+   LC_O_Oblique_Stroke\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (248);\n+   LC_U_Grave  : constant Wide_Wide_Character := Wide_Wide_Character'Val (249);\n+   LC_U_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (250);\n+   LC_U_Circumflex\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (251);\n+   LC_U_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (252);\n+   LC_Y_Acute  : constant Wide_Wide_Character := Wide_Wide_Character'Val (253);\n+   LC_Icelandic_Thorn\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (254);\n+   LC_Y_Diaeresis\n+               : constant Wide_Wide_Character := Wide_Wide_Character'Val (255);\n+\n+   ------------------------------------------------\n+   -- Summary of Changes from Latin-1 => Latin-9 --\n+   ------------------------------------------------\n+\n+   --   164     Currency                => Euro_Sign\n+   --   166     Broken_Bar              => UC_S_Caron\n+   --   168     Diaeresis               => LC_S_Caron\n+   --   180     Acute                   => UC_Z_Caron\n+   --   184     Cedilla                 => LC_Z_Caron\n+   --   188     Fraction_One_Quarter    => UC_Ligature_OE\n+   --   189     Fraction_One_Half       => LC_Ligature_OE\n+   --   190     Fraction_Three_Quarters => UC_Y_Diaeresis\n+\n+end Ada.Characters.Wide_Wide_Latin_9;"}, {"sha": "252b64f2a34d64353655d24cfab61e33ca80b821", "filename": "gcc/ada/a-cidlli.adb", "status": "added", "additions": 1314, "deletions": 0, "changes": 1314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1314 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.INDEFINITE_DOUBLY_LINKED_LISTS               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Delete_Node\n+     (Container : in out List;\n+      Node      : in out Node_Access);\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Node_Access;\n+      New_Node  : Node_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : List) return Boolean is\n+      L : Node_Access;\n+      R : Node_Access;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      L := Left.First;\n+      R := Right.First;\n+      for J in 1 .. Left.Length loop\n+         if L.Element = null then\n+            if R.Element /= null then\n+               return False;\n+            end if;\n+\n+         elsif R.Element = null then\n+            return False;\n+\n+         elsif L.Element.all /= R.Element.all then\n+            return False;\n+         end if;\n+\n+         L := L.Next;\n+         R := R.Next;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out List) is\n+      Src : Node_Access := Container.First;\n+      Dst : Node_Access;\n+\n+   begin\n+      if Src = null then\n+         pragma Assert (Container.Last = null);\n+         pragma Assert (Container.Length = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+      pragma Assert (Container.Length > 0);\n+\n+      Container.First := null;\n+      Container.Last := null;\n+      Container.Length := 0;\n+\n+      Dst := new Node_Type'(null, null, null);\n+\n+      if Src.Element /= null then\n+         begin\n+            Dst.Element := new Element_Type'(Src.Element.all);\n+         exception\n+            when others =>\n+               Free (Dst);\n+               raise;\n+         end;\n+      end if;\n+\n+      Container.First := Dst;\n+\n+      Container.Last := Dst;\n+      loop\n+         Container.Length := Container.Length + 1;\n+         Src := Src.Next;\n+         exit when Src = null;\n+\n+         Dst := new Node_Type'(null, Prev => Container.Last, Next => null);\n+\n+         if Src.Element /= null then\n+            begin\n+               Dst.Element := new Element_Type'(Src.Element.all);\n+            exception\n+               when others =>\n+                  Free (Dst);\n+                  raise;\n+            end;\n+         end if;\n+\n+         Container.Last.Next := Dst;\n+         Container.Last := Dst;\n+      end loop;\n+   end Adjust;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+   begin\n+      Delete_Last (Container, Count => Container.Length);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      for Index in 1 .. Count loop\n+         Delete_Node (Container, Position.Node);\n+\n+         if Position.Node = null then\n+            Position.Container := null;\n+            return;\n+         end if;\n+      end loop;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      Node : Node_Access := Container.First;\n+   begin\n+      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n+         Delete_Node (Container, Node);\n+      end loop;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      Node : Node_Access;\n+   begin\n+      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n+         Node := Container.Last;\n+         Delete_Node (Container, Node);\n+      end loop;\n+   end Delete_Last;\n+\n+   -----------------\n+   -- Delete_Node --\n+   -----------------\n+\n+   procedure Delete_Node\n+     (Container : in out List;\n+      Node      : in out Node_Access)\n+   is\n+      X : Node_Access := Node;\n+\n+   begin\n+      Node := X.Next;\n+      Container.Length := Container.Length - 1;\n+\n+      if X = Container.First then\n+         Container.First := X.Next;\n+\n+         if X = Container.Last then\n+            pragma Assert (Container.First = null);\n+            pragma Assert (Container.Length = 0);\n+            Container.Last := null;\n+         else\n+            pragma Assert (Container.Length > 0);\n+            Container.First.Prev := null;\n+         end if;\n+\n+      elsif X = Container.Last then\n+         pragma Assert (Container.Length > 0);\n+\n+         Container.Last := X.Prev;\n+         Container.Last.Next := null;\n+\n+      else\n+         pragma Assert (Container.Length > 0);\n+\n+         X.Next.Prev := X.Prev;\n+         X.Prev.Next := X.Next;\n+\n+      end if;\n+\n+      Free (X.Element);\n+      Free (X);\n+   end Delete_Node;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.First;\n+      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element /= null\n+           and then Node.Element.all = Item\n+         then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+   begin\n+      return Container.First.Element.all;\n+   end First_Element;\n+\n+   -------------------\n+   -- Generic_Merge --\n+   -------------------\n+\n+   procedure Generic_Merge\n+     (Target : in out List;\n+      Source : in out List)\n+   is\n+      LI : Cursor;\n+      RI : Cursor;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      LI := First (Target);\n+      RI := First (Source);\n+      while RI.Node /= null loop\n+         if LI.Node = null then\n+            Splice (Target, No_Element, Source);\n+            return;\n+         end if;\n+\n+         if LI.Node.Element = null then\n+            LI.Node := LI.Node.Next;\n+\n+         elsif RI.Node.Element = null\n+           or else RI.Node.Element.all < LI.Node.Element.all\n+         then\n+            declare\n+               RJ : constant Cursor := RI;\n+            begin\n+               RI.Node := RI.Node.Next;\n+               Splice (Target, LI, Source, RJ);\n+            end;\n+\n+         else\n+            LI.Node := LI.Node.Next;\n+         end if;\n+      end loop;\n+   end Generic_Merge;\n+\n+   ------------------\n+   -- Generic_Sort --\n+   ------------------\n+\n+   procedure Generic_Sort (Container : in out List) is\n+      procedure Partition (Pivot : Node_Access; Back  : Node_Access);\n+\n+      procedure Sort (Front, Back : Node_Access);\n+\n+      ---------------\n+      -- Partition --\n+      ---------------\n+\n+      procedure Partition (Pivot : Node_Access; Back  : Node_Access) is\n+         Node : Node_Access := Pivot.Next;\n+\n+      begin\n+         while Node /= Back loop\n+            if Pivot.Element = null then\n+               Node := Node.Next;\n+\n+            elsif Node.Element = null\n+              or else Node.Element.all < Pivot.Element.all\n+            then\n+               declare\n+                  Prev : constant Node_Access := Node.Prev;\n+                  Next : constant Node_Access := Node.Next;\n+               begin\n+                  Prev.Next := Next;\n+\n+                  if Next = null then\n+                     Container.Last := Prev;\n+                  else\n+                     Next.Prev := Prev;\n+                  end if;\n+\n+                  Node.Next := Pivot;\n+                  Node.Prev := Pivot.Prev;\n+\n+                  Pivot.Prev := Node;\n+\n+                  if Node.Prev = null then\n+                     Container.First := Node;\n+                  else\n+                     Node.Prev.Next := Node;\n+                  end if;\n+\n+                  Node := Next;\n+               end;\n+\n+            else\n+               Node := Node.Next;\n+            end if;\n+         end loop;\n+      end Partition;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Front, Back : Node_Access) is\n+         Pivot : Node_Access;\n+\n+      begin\n+         if Front = null then\n+            Pivot := Container.First;\n+         else\n+            Pivot := Front.Next;\n+         end if;\n+\n+         if Pivot /= Back then\n+            Partition (Pivot, Back);\n+            Sort (Front, Pivot);\n+            Sort (Pivot, Back);\n+         end if;\n+      end Sort;\n+\n+   --  Start of processing for Generic_Sort\n+\n+   begin\n+      Sort (Front => null, Back => null);\n+\n+      pragma Assert (Container.Length = 0\n+                       or else (Container.First.Prev = null\n+                                  and Container.Last.Next = null));\n+   end Generic_Sort;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position.Container /= null and then Position.Node /= null;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Node : Node_Access;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      declare\n+         Element : Element_Access := new Element_Type'(New_Item);\n+      begin\n+         New_Node := new Node_Type'(Element, null, null);\n+      exception\n+         when others =>\n+            Free (Element);\n+            raise;\n+      end;\n+\n+      Insert_Internal (Container, Before.Node, New_Node);\n+      Position := Cursor'(Before.Container, New_Node);\n+\n+      for J in Count_Type'(2) .. Count loop\n+\n+         declare\n+            Element : Element_Access := new Element_Type'(New_Item);\n+         begin\n+            New_Node := new Node_Type'(Element, null, null);\n+         exception\n+            when others =>\n+               Free (Element);\n+               raise;\n+         end;\n+\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Node_Access;\n+      New_Node  : Node_Access)\n+   is\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = null);\n+         pragma Assert (Container.First = null);\n+         pragma Assert (Container.Last = null);\n+\n+         Container.First := New_Node;\n+         Container.Last := New_Node;\n+\n+      elsif Before = null then\n+         pragma Assert (Container.Last.Next = null);\n+\n+         Container.Last.Next := New_Node;\n+         New_Node.Prev := Container.Last;\n+\n+         Container.Last := New_Node;\n+\n+      elsif Before = Container.First then\n+         pragma Assert (Container.First.Prev = null);\n+\n+         Container.First.Prev := New_Node;\n+         New_Node.Next := Container.First;\n+\n+         Container.First := New_Node;\n+\n+      else\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         New_Node.Next := Before;\n+         New_Node.Prev := Before.Prev;\n+\n+         Before.Prev.Next := New_Node;\n+         Before.Prev := New_Node;\n+      end if;\n+\n+      Container.Length := Container.Length + 1;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : in Cursor))\n+   is\n+      Node : Node_Access := Container.First;\n+   begin\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Node := Node.Next;\n+      end loop;\n+   end Iterate;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out List; Source : in out List) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Length > 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Target.First := Source.First;\n+      Source.First := null;\n+\n+      Target.Last := Source.Last;\n+      Source.Last := null;\n+\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n+   end Move;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+   begin\n+      return Container.Last.Element.all;\n+   end Last_Element;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      if Position.Node = null then\n+         return;\n+      end if;\n+\n+      Position.Node := Position.Node.Next;\n+\n+      if Position.Node = null then\n+         Position.Container := null;\n+      end if;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Next_Node : constant Node_Access := Position.Node.Next;\n+      begin\n+         if Next_Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Next_Node);\n+      end;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      if Position.Node = null then\n+         return;\n+      end if;\n+\n+      Position.Node := Position.Node.Prev;\n+\n+      if Position.Node = null then\n+         Position.Container := null;\n+      end if;\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Prev_Node : constant Node_Access := Position.Node.Prev;\n+      begin\n+         if Prev_Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Prev_Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Element.all);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out List)\n+   is\n+      N : Count_Type'Base;\n+      X : Node_Access;\n+\n+   begin\n+      Clear (Item);  --  ???\n+\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      X := new Node_Type;\n+\n+      begin\n+         X.Element := new Element_Type'(Element_Type'Input (Stream));\n+      exception\n+         when others =>\n+            Free (X);\n+            raise;\n+      end;\n+\n+      Item.First := X;\n+\n+      Item.Last := X;\n+      loop\n+         Item.Length := Item.Length + 1;\n+         exit when Item.Length = N;\n+\n+         X := new Node_Type;\n+\n+         begin\n+            X.Element := new Element_Type'(Element_Type'Input (Stream));\n+         exception\n+            when others =>\n+               Free (X);\n+               raise;\n+         end;\n+\n+         X.Prev := Item.Last;\n+         Item.Last.Next := X;\n+         Item.Last := X;\n+      end loop;\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type)\n+   is\n+      X : Element_Access := Position.Node.Element;\n+   begin\n+      Position.Node.Element := new Element_Type'(By);\n+      Free (X);\n+   end Replace_Element;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.Last;\n+      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element /= null\n+           and then Node.Element.all = Item\n+         then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : in Cursor))\n+   is\n+      Node : Node_Access := Container.Last;\n+\n+   begin\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Node := Node.Prev;\n+      end loop;\n+   end Reverse_Iterate;\n+\n+   ------------------\n+   -- Reverse_List --\n+   ------------------\n+\n+   procedure Reverse_List (Container : in out List) is\n+      I : Node_Access := Container.First;\n+      J : Node_Access := Container.Last;\n+\n+      procedure Swap (L, R : Node_Access);\n+\n+      ----------\n+      -- Swap --\n+      ----------\n+\n+      procedure Swap (L, R : Node_Access) is\n+         LN : constant Node_Access := L.Next;\n+         LP : constant Node_Access := L.Prev;\n+\n+         RN : constant Node_Access := R.Next;\n+         RP : constant Node_Access := R.Prev;\n+\n+      begin\n+         if LP /= null then\n+            LP.Next := R;\n+         end if;\n+\n+         if RN /= null then\n+            RN.Prev := L;\n+         end if;\n+\n+         L.Next := RN;\n+         R.Prev := LP;\n+\n+         if LN = R then\n+            pragma Assert (RP = L);\n+\n+            L.Prev := R;\n+            R.Next := L;\n+\n+         else\n+            L.Prev := RP;\n+            RP.Next := L;\n+\n+            R.Next := LN;\n+            LN.Prev := R;\n+         end if;\n+      end Swap;\n+\n+   --  Start of processing for Reverse_List\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      Container.First := J;\n+      Container.Last := I;\n+      loop\n+         Swap (L => I, R => J);\n+\n+         J := J.Next;\n+         exit when I = J;\n+\n+         I := I.Prev;\n+         exit when I = J;\n+\n+         Swap (L => J, R => I);\n+\n+         I := I.Next;\n+         exit when I = J;\n+\n+         J := J.Prev;\n+         exit when I = J;\n+      end loop;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+   end Reverse_List;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   is\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Target'Address = Source'Address\n+        or else Source.Length = 0\n+      then\n+         return;\n+      end if;\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Before = No_Element);\n+\n+         Target.First := Source.First;\n+         Target.Last := Source.Last;\n+\n+      elsif Before.Node = null then\n+         pragma Assert (Target.Last.Next = null);\n+\n+         Target.Last.Next := Source.First;\n+         Source.First.Prev := Target.Last;\n+\n+         Target.Last := Source.Last;\n+\n+      elsif Before.Node = Target.First then\n+         pragma Assert (Target.First.Prev = null);\n+\n+         Source.Last.Next := Target.First;\n+         Target.First.Prev := Source.Last;\n+\n+         Target.First := Source.First;\n+\n+      else\n+         Before.Node.Prev.Next := Source.First;\n+         Source.First.Prev := Before.Node.Prev;\n+\n+         Before.Node.Prev := Source.Last;\n+         Source.Last.Next := Before.Node;\n+      end if;\n+\n+      Source.First := null;\n+      Source.Last := null;\n+\n+      Target.Length := Target.Length + Source.Length;\n+      Source.Length := 0;\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Position : Cursor)\n+   is\n+      X : Node_Access := Position.Node;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= null\n+        and then Position.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if X = null\n+        or else X = Before.Node\n+        or else X.Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Target.Length > 0);\n+\n+      if Before.Node = null then\n+         pragma Assert (X /= Target.Last);\n+\n+         if X = Target.First then\n+            Target.First := X.Next;\n+            Target.First.Prev := null;\n+         else\n+            X.Prev.Next := X.Next;\n+            X.Next.Prev := X.Prev;\n+         end if;\n+\n+         Target.Last.Next := X;\n+         X.Prev := Target.Last;\n+\n+         Target.Last := X;\n+         Target.Last.Next := null;\n+\n+         return;\n+      end if;\n+\n+      if Before.Node = Target.First then\n+         pragma Assert (X /= Target.First);\n+\n+         if X = Target.Last then\n+            Target.Last := X.Prev;\n+            Target.Last.Next := null;\n+         else\n+            X.Prev.Next := X.Next;\n+            X.Next.Prev := X.Prev;\n+         end if;\n+\n+         Target.First.Prev := X;\n+         X.Next := Target.First;\n+\n+         Target.First := X;\n+         Target.First.Prev := null;\n+\n+         return;\n+      end if;\n+\n+      if X = Target.First then\n+         Target.First := X.Next;\n+         Target.First.Prev := null;\n+\n+      elsif X = Target.Last then\n+         Target.Last := X.Prev;\n+         Target.Last.Next := null;\n+\n+      else\n+         X.Prev.Next := X.Next;\n+         X.Next.Prev := X.Prev;\n+      end if;\n+\n+      Before.Node.Prev.Next := X;\n+      X.Prev := Before.Node.Prev;\n+\n+      Before.Node.Prev := X;\n+      X.Next := Before.Node;\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : Cursor)\n+   is\n+      X : Node_Access := Position.Node;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         Splice (Target, Before, Position);\n+         return;\n+      end if;\n+\n+      if Before.Container /= null\n+        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= null\n+        and then Position.Container /= List_Access'(Source'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if X = null then\n+         return;\n+      end if;\n+\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last.Next = null);\n+\n+      if X = Source.First then\n+         Source.First := X.Next;\n+         Source.First.Prev := null;\n+\n+         if X = Source.Last then\n+            pragma Assert (Source.First = null);\n+            pragma Assert (Source.Length = 1);\n+            Source.Last := null;\n+         end if;\n+\n+      elsif X = Source.Last then\n+         Source.Last := X.Prev;\n+         Source.Last.Next := null;\n+\n+      else\n+         X.Prev.Next := X.Next;\n+         X.Next.Prev := X.Prev;\n+      end if;\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Before = No_Element);\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n+\n+         Target.First := X;\n+         Target.Last := X;\n+\n+      elsif Before.Node = null then\n+         Target.Last.Next := X;\n+         X.Next := Target.Last;\n+\n+         Target.Last := X;\n+         Target.Last.Next := null;\n+\n+      elsif Before.Node = Target.First then\n+         Target.First.Prev := X;\n+         X.Next := Target.First;\n+\n+         Target.First := X;\n+         Target.First.Prev := null;\n+\n+      else\n+         Before.Node.Prev.Next := X;\n+         X.Prev := Before.Node.Prev;\n+\n+         Before.Node.Prev := X;\n+         X.Next := Before.Node;\n+      end if;\n+\n+      Target.Length := Target.Length + 1;\n+      Source.Length := Source.Length - 1;\n+   end Splice;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (I, J : Cursor) is\n+\n+      --  Is this op legal when I and J designate elements in different\n+      --  containers, or should it raise an exception (e.g. Program_Error).\n+\n+      EI : constant Element_Access := I.Node.Element;\n+\n+   begin\n+      I.Node.Element := J.Node.Element;\n+      J.Node.Element := EI;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I = No_Element\n+        or else J = No_Element\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if I.Container /= List_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      if J.Container /= I.Container then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 1);\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 2);\n+\n+      declare\n+         I_Next : constant Cursor := Next (I);\n+\n+      begin\n+         if I_Next = J then\n+            Splice (Container, Before => I, Position => J);\n+\n+         else\n+            declare\n+               J_Next : constant Cursor := Next (J);\n+            begin\n+               if J_Next = I then\n+                  Splice (Container, Before => J, Position => I);\n+\n+               else\n+                  pragma Assert (Container.Length >= 3);\n+\n+                  Splice (Container, Before => I_Next, Position => J);\n+                  Splice (Container, Before => J_Next, Position => I);\n+               end if;\n+            end;\n+         end if;\n+      end;\n+   end Swap_Links;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Element.all);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : List)\n+   is\n+      Node : Node_Access := Item.First;\n+   begin\n+      Count_Type'Base'Write (Stream, Item.Length);\n+      while Node /= null loop\n+         Element_Type'Output (Stream, Node.Element.all);  --  X.all\n+         Node := Node.Next;\n+      end loop;\n+   end Write;\n+\n+end Ada.Containers.Indefinite_Doubly_Linked_Lists;\n+\n+"}, {"sha": "2f4ebcb69f0f2d58ce77c25f0c81fa5c151992cb", "filename": "gcc/ada/a-cidlli.ads", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,251 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.INDEFINITE_DOUBLY_LINKED_LISTS               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+\n+   type Element_Type (<>) is private;\n+\n+   with function \"=\" (Left, Right : Element_Type)\n+      return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n+   pragma Preelaborate (Indefinite_Doubly_Linked_Lists);\n+\n+   type List is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_List : constant List;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : List) return Boolean;\n+\n+   function Length (Container : List) return Count_Type;\n+\n+   function Is_Empty (Container : List) return Boolean;\n+\n+   procedure Clear (Container : in out List);\n+\n+   function Element (Position : Cursor)\n+      return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type);\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type)\n+         return Boolean is <>;\n+   procedure Generic_Sort (Container : in out List);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type)\n+         return Boolean is <>;\n+   procedure Generic_Merge\n+     (Target : in out List;\n+      Source : in out List);\n+\n+   procedure Reverse_List (Container : in out List);\n+\n+   procedure Swap (I, J : Cursor);\n+\n+   procedure Swap_Links (Container : in out List; I, J : Cursor);\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Position : Cursor);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : Cursor);\n+\n+   function First (Container : List) return Cursor;\n+\n+   function First_Element (Container : List) return Element_Type;\n+\n+   function Last (Container : List) return Cursor;\n+\n+   function Last_Element (Container : List) return Element_Type;\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   type Element_Access is access Element_Type;\n+\n+   type Node_Type is\n+      record\n+         Element : Element_Access;\n+         Next    : Node_Access;\n+         Prev    : Node_Access;\n+      end record;\n+\n+   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n+\n+   use Ada.Finalization;\n+\n+   type List is\n+     new Controlled with record\n+        First  : Node_Access;\n+        Last   : Node_Access;\n+        Length : Count_Type := 0;\n+     end record;\n+\n+   procedure Adjust (Container : in out List);\n+\n+   procedure Finalize (Container : in out List) renames Clear;\n+\n+   use Ada.Streams;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out List);\n+\n+   for List'Read use Read;\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : List);\n+\n+   for List'Write use Write;\n+\n+   Empty_List : constant List := List'(Controlled with null, null, 0);\n+\n+   type List_Access is access constant List;\n+   for List_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : List_Access;\n+         Node      : Node_Access;\n+      end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n+\n+end Ada.Containers.Indefinite_Doubly_Linked_Lists;\n+\n+"}, {"sha": "c0bfaed874a551dfab0478483943ddad50e6a99a", "filename": "gcc/ada/a-cihama.adb", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,689 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_HASHED_MAPS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit has originally being developed by Matthew J Heaney.            --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Containers.Indefinite_Hashed_Maps is\n+\n+   type Key_Access is access Key_Type;\n+   type Element_Access is access Element_Type;\n+\n+   type Node_Type is limited record\n+      Key     : Key_Access;\n+      Element : Element_Access;\n+      Next    : Node_Access;\n+   end record;\n+\n+   procedure Free_Key is\n+      new Ada.Unchecked_Deallocation (Key_Type, Key_Access);\n+\n+   procedure Free_Element is\n+      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Copy_Node (Node : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Find_Equal_Key\n+     (R_Map  : Map;\n+      L_Node : Node_Access) return Boolean;\n+\n+   procedure Free (X : in out Node_Access);\n+   pragma Inline (Free);\n+\n+   function Hash_Node (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Next (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n+\n+   function Read_Node\n+     (Stream : access Root_Stream_Type'Class) return Node_Access;\n+\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access);\n+   pragma Inline (Set_Next);\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package HT_Ops is\n+      new Ada.Containers.Hash_Tables.Generic_Operations\n+        (HT_Types          => HT_Types,\n+         Hash_Table_Type   => Map,\n+         Null_Node         => null,\n+         Hash_Node         => Hash_Node,\n+         Next              => Next,\n+         Set_Next          => Set_Next,\n+         Copy_Node         => Copy_Node,\n+         Free              => Free);\n+\n+   package Key_Ops is\n+      new Hash_Tables.Generic_Keys\n+       (HT_Types  => HT_Types,\n+        HT_Type   => Map,\n+        Null_Node => null,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Key_Type  => Key_Type,\n+        Hash      => Hash,\n+        Equivalent_Keys => Equivalent_Keys);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function Is_Equal is new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+   function \"=\" (Left, Right : Map) return Boolean renames Is_Equal;\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Map) renames HT_Ops.Adjust;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Map)\n+     return Count_Type renames HT_Ops.Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) renames HT_Ops.Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n+\n+   function Copy_Node (Node : Node_Access) return Node_Access is\n+      K : Key_Access := new Key_Type'(Node.Key.all);\n+      E : Element_Access;\n+\n+   begin\n+      E := new Element_Type'(Node.Element.all);\n+      return new Node_Type'(K, E, null);\n+\n+   exception\n+      when others =>\n+         Free_Key (K);\n+         Free_Element (E);\n+         raise;\n+   end Copy_Node;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access;\n+\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Free (X);\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      C : constant Cursor := Find (Container, Key);\n+   begin\n+      return C.Node.Element.all;\n+   end Element;\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Access) return Boolean\n+   is\n+   begin\n+      return Equivalent_Keys (Key, Node.Key.all);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Key.all, Right.Node.Key.all);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys\n+     (Left  : Cursor;\n+      Right : Key_Type) return Boolean\n+   is\n+   begin\n+      return Equivalent_Keys (Left.Node.Key.all, Right);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys\n+     (Left  : Key_Type;\n+      Right : Cursor) return Boolean\n+   is\n+   begin\n+      return Equivalent_Keys (Left, Right.Node.Key.all);\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access;\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Free (X);\n+   end Exclude;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Container : in out Map) renames HT_Ops.Finalize;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Find;\n+\n+   --------------------\n+   -- Find_Equal_Key --\n+   --------------------\n+\n+   function Find_Equal_Key\n+     (R_Map  : Map;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type := Key_Ops.Index (R_Map, L_Node.Key.all);\n+      R_Node  : Node_Access := R_Map.Buckets (R_Index);\n+\n+   begin\n+      while R_Node /= null loop\n+         if Equivalent_Keys (L_Node.Key.all, R_Node.Key.all) then\n+            return L_Node.Element.all = R_Node.Element.all;\n+         end if;\n+\n+         R_Node := R_Node.Next;\n+      end loop;\n+\n+      return False;\n+   end Find_Equal_Key;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end First;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         Free_Key (X.Key);\n+         Free_Element (X.Element);\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Access) return Hash_Type is\n+   begin\n+      return Hash (Node.Key.all);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+      K : Key_Access;\n+      E : Element_Access;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         K := Position.Node.Key;\n+         E := Position.Node.Element;\n+\n+         Position.Node.Key := new Key_Type'(Key);\n+         Position.Node.Element := new Element_Type'(New_Item);\n+\n+         Free_Key (K);\n+         Free_Element (E);\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node (Next : Node_Access) return Node_Access;\n+\n+      procedure Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         K  : Key_Access := new Key_Type'(Key);\n+         E  : Element_Access;\n+      begin\n+         E := new Element_Type'(New_Item);\n+         return new Node_Type'(K, E, Next);\n+      exception\n+         when others =>\n+            Free_Key (K);\n+            Free_Element (E);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n+      Insert (Container, Key, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing Iterate\n+\n+   begin\n+      Iterate (Container);\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Cursor) return Key_Type is\n+   begin\n+      return Position.Node.Key.all;\n+   end Key;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Map;\n+      Source : in out Map) renames HT_Ops.Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         M    : Map renames Position.Container.all;\n+         Node : constant Node_Access := HT_Ops.Next (M, Position.Node);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key.all, Position.Node.Element.all);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read_Nodes is new HT_Ops.Generic_Read (Read_Node);\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map) renames Read_Nodes;\n+\n+   ---------------\n+   -- Read_Node --\n+   ---------------\n+\n+   function Read_Node\n+     (Stream : access Root_Stream_Type'Class) return Node_Access\n+   is\n+      Node : Node_Access := new Node_Type;\n+\n+   begin\n+      begin\n+         Node.Key := new Key_Type'(Key_Type'Input (Stream));\n+      exception\n+         when others =>\n+            Free (Node);\n+            raise;\n+      end;\n+\n+      begin\n+         Node.Element := new Element_Type'(Element_Type'Input (Stream));\n+      exception\n+         when others =>\n+            Free_Key (Node.Key);\n+            Free (Node);\n+            raise;\n+      end;\n+\n+      return Node;\n+   end Read_Node;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+\n+      K : Key_Access;\n+      E : Element_Access;\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      K := Node.Key;\n+      E := Node.Element;\n+\n+      Node.Key := new Key_Type'(Key);\n+      Node.Element := new Element_Type'(New_Item);\n+\n+      Free_Key (K);\n+      Free_Element (E);\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+      X : Element_Access := Position.Node.Element;\n+   begin\n+      Position.Node.Element := new Element_Type'(By);\n+      Free_Element (X);\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type) renames HT_Ops.Ensure_Capacity;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key.all, Position.Node.Element.all);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write_Nodes is new HT_Ops.Generic_Write (Write_Node);\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map) renames Write_Nodes;\n+\n+   ----------------\n+   -- Write_Node --\n+   ----------------\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access)\n+   is\n+   begin\n+      Key_Type'Output (Stream, Node.Key.all);\n+      Element_Type'Output (Stream, Node.Element.all);\n+   end Write_Node;\n+\n+end Ada.Containers.Indefinite_Hashed_Maps;\n+"}, {"sha": "7769cbb1a83c9009bd710c014184e01421c4c4fc", "filename": "gcc/ada/a-cihama.ads", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,206 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_HASHED_MAPS                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables;\n+with Ada.Streams;\n+\n+generic\n+   type Key_Type (<>) is private;\n+   type Element_Type (<>) is private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Hashed_Maps is\n+   pragma Preelaborate (Indefinite_Hashed_Maps);\n+\n+   type Map is tagged private;\n+   type Cursor is private;\n+\n+   Empty_Map  : constant Map;\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   procedure Clear (Container : in out Map);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type));\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type);\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n+   procedure Exclude\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n+   procedure Delete\n+     (Container : in out Map;\n+      Position  : in out Cursor);\n+\n+   function Contains\n+     (Container : Map;\n+      Key       : Key_Type) return Boolean;\n+\n+   function Find\n+     (Container : Map;\n+      Key       : Key_Type) return Cursor;\n+\n+   function Element\n+     (Container : Map;\n+      Key       : Key_Type) return Element_Type;\n+\n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type);\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Key (Position : Cursor) return Key_Type;\n+\n+   function Equivalent_Keys (Left, Right : Cursor)\n+     return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Cursor;\n+      Right : Key_Type) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Key_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package HT_Types is\n+      new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+\n+   use HT_Types;\n+\n+   type Map is new Hash_Table_Type with null record;\n+\n+   procedure Adjust (Container : in out Map);\n+\n+   procedure Finalize (Container : in out Map);\n+\n+   type Map_Access is access constant Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : Map_Access;\n+         Node      : Node_Access;\n+      end record;\n+\n+   No_Element : constant Cursor :=\n+     (Container => null,\n+      Node      => null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   Empty_Map : constant Map := (Hash_Table_Type with null record);\n+\n+end Ada.Containers.Indefinite_Hashed_Maps;\n+\n+\n+"}, {"sha": "cc5589f0c1cfc5479b2fbca044c7a0d558ce8cc7", "filename": "gcc/ada/a-cihase.adb", "status": "added", "additions": 1531, "deletions": 0, "changes": 1531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1531 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_HASHED_SETS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit has originally being developed by Matthew J Heaney.            --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Hash_Tables.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n+\n+with System;  use type System.Address;\n+\n+with Ada.Containers.Prime_Numbers;\n+\n+with Ada.Finalization;  use Ada.Finalization;\n+\n+package body Ada.Containers.Indefinite_Hashed_Sets is\n+\n+   type Element_Access is access Element_Type;\n+\n+   type Node_Type is\n+      limited record\n+         Element : Element_Access;\n+         Next    : Node_Access;\n+      end record;\n+\n+   function Hash_Node\n+     (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Hash_Node\n+     (Node : Node_Access) return Hash_Type is\n+   begin\n+      return Hash (Node.Element.all);\n+   end Hash_Node;\n+\n+   function Next\n+     (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n+\n+   function Next\n+     (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access);\n+   pragma Inline (Set_Next);\n+\n+   procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean is\n+   begin\n+      return Equivalent_Keys (Key, Node.Element.all);\n+   end Equivalent_Keys;\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access is\n+\n+      Target : constant Node_Access :=\n+        new Node_Type'(Element => Source.Element,\n+                       Next    => null);\n+   begin\n+      return Target;\n+   end Copy_Node;\n+\n+\n+   procedure Free_Element is\n+      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   procedure Free (X : in out Node_Access);\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         Free_Element (X.Element);\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   package HT_Ops is\n+      new Hash_Tables.Generic_Operations\n+       (HT_Types          => HT_Types,\n+        Hash_Table_Type   => Set,\n+        Null_Node         => null,\n+        Hash_Node         => Hash_Node,\n+        Next              => Next,\n+        Set_Next          => Set_Next,\n+        Copy_Node         => Copy_Node,\n+        Free              => Free);\n+\n+   package Element_Keys is\n+      new Hash_Tables.Generic_Keys\n+       (HT_Types  => HT_Types,\n+        HT_Type   => Set,\n+        Null_Node => null,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Key_Type  => Element_Type,\n+        Hash      => Hash,\n+        Equivalent_Keys => Equivalent_Keys);\n+\n+\n+   procedure Adjust (Container : in out Set) renames HT_Ops.Adjust;\n+\n+   procedure Finalize (Container : in out Set) renames HT_Ops.Finalize;\n+\n+\n+   function Find_Equal_Key\n+     (R_Set  : Set;\n+      L_Node : Node_Access) return Boolean;\n+\n+   function Find_Equal_Key\n+     (R_Set  : Set;\n+      L_Node : Node_Access) return Boolean is\n+\n+      R_Index : constant Hash_Type :=\n+        Element_Keys.Index (R_Set, L_Node.Element.all);\n+\n+      R_Node  : Node_Access := R_Set.Buckets (R_Index);\n+\n+   begin\n+\n+      loop\n+\n+         if R_Node = null then\n+            return False;\n+         end if;\n+\n+         if L_Node.Element.all = R_Node.Element.all then\n+            return True;\n+         end if;\n+\n+         R_Node := Next (R_Node);\n+\n+      end loop;\n+\n+   end Find_Equal_Key;\n+\n+   function Is_Equal is\n+      new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+   function \"=\" (Left, Right : Set) return Boolean renames Is_Equal;\n+\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+\n+   procedure Clear (Container : in out Set) renames HT_Ops.Clear;\n+\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+\n+   procedure Query_Element\n+     (Position : in Cursor;\n+      Process  : not null access procedure (Element : in Element_Type)) is\n+   begin\n+      Process (Position.Node.Element.all);\n+   end Query_Element;\n+\n+\n+--  TODO:\n+--     procedure Replace_Element (Container : in out Set;\n+--                                Position  : in     Node_Access;\n+--                                By        : in     Element_Type);\n+\n+--     procedure Replace_Element (Container : in out Set;\n+--                                Position  : in     Node_Access;\n+--                                By        : in     Element_Type) is\n+\n+--        Node : Node_Access := Position;\n+\n+--     begin\n+\n+--        if Equivalent_Keys (Node.Element.all, By) then\n+\n+--           declare\n+--              X : Element_Access := Node.Element;\n+--           begin\n+--              Node.Element := new Element_Type'(By);\n+--              --\n+--              --  NOTE: If there's an exception here, then just\n+--              --  let it propagate.  We haven't modified the\n+--              --  state of the container, so there's nothing else\n+--              --  we need to do.\n+\n+--              Free_Element (X);\n+--           end;\n+\n+--           return;\n+\n+--        end if;\n+\n+--        HT_Ops.Delete_Node_Sans_Free (Container, Node);\n+\n+--        begin\n+--           Free_Element (Node.Element);\n+--        exception\n+--           when others =>\n+--              Node.Element := null;  --  don't attempt to dealloc X.E again\n+--              Free (Node);\n+--              raise;\n+--        end;\n+\n+--        begin\n+--           Node.Element := new Element_Type'(By);\n+--        exception\n+--           when others =>\n+--              Free (Node);\n+--              raise;\n+--        end;\n+\n+--        declare\n+--           function New_Node (Next : Node_Access) return Node_Access;\n+--           pragma Inline (New_Node);\n+\n+--           function New_Node (Next : Node_Access) return Node_Access is\n+--           begin\n+--              Node.Next := Next;\n+--              return Node;\n+--           end New_Node;\n+\n+--           procedure Insert is\n+--              new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+--           Result  : Node_Access;\n+--           Success : Boolean;\n+--        begin\n+--           Insert\n+--             (HT      => Container,\n+--              Key     => Node.Element.all,\n+--              Node    => Result,\n+--              Success => Success);\n+\n+--           if not Success then\n+--              Free (Node);\n+--              raise Program_Error;\n+--           end if;\n+\n+--           pragma Assert (Result = Node);\n+--        end;\n+\n+--     end Replace_Element;\n+\n+\n+--     procedure Replace_Element (Container : in out Set;\n+--                                Position  : in     Cursor;\n+--                                By        : in     Element_Type) is\n+--     begin\n+\n+--        if Position.Container = null then\n+--           raise Constraint_Error;\n+--        end if;\n+\n+--        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+--           raise Program_Error;\n+--        end if;\n+\n+--        Replace_Element (Container, Position.Node, By);\n+\n+--     end Replace_Element;\n+\n+\n+   procedure Move (Target : in out Set;\n+                   Source : in out Set) renames HT_Ops.Move;\n+\n+\n+   procedure Insert (Container : in out Set;\n+                     New_Item  : in     Element_Type;\n+                     Position  :    out Cursor;\n+                     Inserted  :    out Boolean) is\n+\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Element : Element_Access := new Element_Type'(New_Item);\n+      begin\n+         return new Node_Type'(Element, Next);\n+      exception\n+         when others =>\n+            Free_Element (Element);\n+            raise;\n+      end New_Node;\n+\n+      procedure Insert is\n+        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+   begin\n+\n+      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n+      Insert (Container, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+\n+   end Insert;\n+\n+\n+   procedure Insert (Container : in out Set;\n+                     New_Item  : in     Element_Type) is\n+\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+\n+   end Insert;\n+\n+\n+   procedure Replace (Container : in out Set;\n+                      New_Item  : in     Element_Type) is\n+\n+      Node : constant Node_Access :=\n+        Element_Keys.Find (Container, New_Item);\n+\n+      X : Element_Access;\n+\n+   begin\n+\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      X := Node.Element;\n+\n+      Node.Element := new Element_Type'(New_Item);\n+\n+      Free_Element (X);\n+\n+   end Replace;\n+\n+\n+   procedure Include (Container : in out Set;\n+                      New_Item  : in     Element_Type) is\n+\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+      X : Element_Access;\n+\n+   begin\n+\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+\n+         X := Position.Node.Element;\n+\n+         Position.Node.Element := new Element_Type'(New_Item);\n+\n+         Free_Element (X);\n+\n+      end if;\n+\n+   end Include;\n+\n+\n+   procedure Delete (Container : in out Set;\n+                     Item      : in     Element_Type) is\n+\n+      X : Node_Access;\n+\n+   begin\n+\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Free (X);\n+\n+   end Delete;\n+\n+\n+   procedure Exclude (Container : in out Set;\n+                      Item      : in     Element_Type) is\n+\n+      X : Node_Access;\n+\n+   begin\n+\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      Free (X);\n+\n+   end Exclude;\n+\n+\n+   procedure Delete (Container : in out Set;\n+                     Position  : in out Cursor) is\n+   begin\n+\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+\n+   end Delete;\n+\n+\n+\n+   procedure Union (Target : in out Set;\n+                    Source : in     Set) is\n+\n+      procedure Process (Src_Node : in Node_Access);\n+\n+      procedure Process (Src_Node : in Node_Access) is\n+\n+         Src : Element_Type renames Src_Node.Element.all;\n+\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n+\n+         function New_Node (Next : Node_Access) return Node_Access is\n+            Tgt : Element_Access := new Element_Type'(Src);\n+         begin\n+            return new Node_Type'(Tgt, Next);\n+         exception\n+            when others =>\n+               Free_Element (Tgt);\n+               raise;\n+         end New_Node;\n+\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+         Tgt_Node : Node_Access;\n+         Success  : Boolean;\n+\n+      begin\n+\n+         Insert (Target, Src, Tgt_Node, Success);\n+\n+      end Process;\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+\n+      Iterate (Source);\n+\n+   end Union;\n+\n+\n+\n+   function Union (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type :=\n+           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+            I : constant Hash_Type :=\n+              Hash (L_Node.Element.all) mod Buckets'Length;\n+         begin\n+            Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      Length := Left.Length;\n+\n+      declare\n+         procedure Process (Src_Node : Node_Access);\n+\n+         procedure Process (Src_Node : Node_Access) is\n+\n+            Src : Element_Type renames Src_Node.Element.all;\n+\n+            I : constant Hash_Type :=\n+              Hash (Src) mod Buckets'Length;\n+\n+            Tgt_Node : Node_Access := Buckets (I);\n+\n+         begin\n+\n+            while Tgt_Node /= null loop\n+\n+               if Equivalent_Keys (Src, Tgt_Node.Element.all) then\n+                  return;\n+               end if;\n+\n+               Tgt_Node := Next (Tgt_Node);\n+\n+            end loop;\n+\n+            declare\n+               Tgt : Element_Access := new Element_Type'(Src);\n+            begin\n+               Buckets (I) := new Node_Type'(Tgt, Buckets (I));\n+            exception\n+               when others =>\n+                  Free_Element (Tgt);\n+                  raise;\n+            end;\n+\n+            Length := Length + 1;\n+\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Right);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Union;\n+\n+\n+   function Is_In\n+     (HT  : Set;\n+      Key : Node_Access) return Boolean;\n+   pragma Inline (Is_In);\n+\n+   function Is_In\n+     (HT  : Set;\n+      Key : Node_Access) return Boolean is\n+   begin\n+      return Element_Keys.Find (HT, Key.Element.all) /= null;\n+   end Is_In;\n+\n+\n+   procedure Intersection (Target : in out Set;\n+                           Source : in     Set) is\n+\n+      Tgt_Node : Node_Access;\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      --  TODO: optimize this to use an explicit\n+      --  loop instead of an active iterator\n+      --  (similar to how a passive iterator is\n+      --  implemented).\n+      --\n+      --  Another possibility is to test which\n+      --  set is smaller, and iterate over the\n+      --  smaller set.\n+\n+      Tgt_Node := HT_Ops.First (Target);\n+\n+      while Tgt_Node /= null loop\n+\n+         if Is_In (Source, Tgt_Node) then\n+\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+\n+         else\n+\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Free (X);\n+            end;\n+\n+         end if;\n+\n+      end loop;\n+\n+   end Intersection;\n+\n+\n+   function Intersection (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      Length := Count_Type'Min (Left.Length, Right.Length);\n+\n+      if Length = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if Is_In (Right, L_Node) then\n+\n+               declare\n+                  I : constant Hash_Type :=\n+                    Hash (L_Node.Element.all) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+               end;\n+\n+               Length := Length + 1;\n+\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Intersection;\n+\n+\n+   procedure Difference (Target : in out Set;\n+                         Source : in     Set) is\n+\n+\n+      Tgt_Node : Node_Access;\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      --  TODO: As I noted above, this can be\n+      --  written in terms of a loop instead as\n+      --  active-iterator style, sort of like a\n+      --  passive iterator.\n+\n+      Tgt_Node := HT_Ops.First (Target);\n+\n+      while Tgt_Node /= null loop\n+\n+         if Is_In (Source, Tgt_Node) then\n+\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Free (X);\n+            end;\n+\n+         else\n+\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+\n+         end if;\n+\n+      end loop;\n+\n+   end Difference;\n+\n+\n+\n+   function Difference (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right, L_Node) then\n+\n+               declare\n+                  I : constant Hash_Type :=\n+                    Hash (L_Node.Element.all) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+               end;\n+\n+               Length := Length + 1;\n+\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Difference;\n+\n+\n+\n+   procedure Symmetric_Difference (Target : in out Set;\n+                                   Source : in     Set) is\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+\n+      if Target.Length = 0 then\n+\n+         declare\n+            procedure Process (Src_Node : Node_Access);\n+\n+            procedure Process (Src_Node : Node_Access) is\n+               E : Element_Type renames Src_Node.Element.all;\n+               B : Buckets_Type renames Target.Buckets.all;\n+               I : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.Length;\n+            begin\n+               declare\n+                  X : Element_Access := new Element_Type'(E);\n+               begin\n+                  B (I) := new Node_Type'(X, B (I));\n+               exception\n+                  when others =>\n+                     Free_Element (X);\n+                     raise;\n+               end;\n+\n+               N := N + 1;\n+            end Process;\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+         begin\n+            Iterate (Source);\n+         end;\n+\n+      else\n+\n+         declare\n+            procedure Process (Src_Node : Node_Access);\n+\n+            procedure Process (Src_Node : Node_Access) is\n+               E : Element_Type renames Src_Node.Element.all;\n+               B : Buckets_Type renames Target.Buckets.all;\n+               I : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.Length;\n+            begin\n+               if B (I) = null then\n+\n+                  declare\n+                     X : Element_Access := new Element_Type'(E);\n+                  begin\n+                     B (I) := new Node_Type'(X, null);\n+                  exception\n+                     when others =>\n+                        Free_Element (X);\n+                        raise;\n+                  end;\n+\n+                  N := N + 1;\n+\n+               elsif Equivalent_Keys (E, B (I).Element.all) then\n+\n+                  declare\n+                     X : Node_Access := B (I);\n+                  begin\n+                     B (I) := B (I).Next;\n+                     N := N - 1;\n+                     Free (X);\n+                  end;\n+\n+               else\n+\n+                  declare\n+                     Prev : Node_Access := B (I);\n+                     Curr : Node_Access := Prev.Next;\n+                  begin\n+                     while Curr /= null loop\n+                        if Equivalent_Keys (E, Curr.Element.all) then\n+                           Prev.Next := Curr.Next;\n+                           N := N - 1;\n+                           Free (Curr);\n+                           return;\n+                        end if;\n+\n+                        Prev := Curr;\n+                        Curr := Prev.Next;\n+                     end loop;\n+\n+                     declare\n+                        X : Element_Access := new Element_Type'(E);\n+                     begin\n+                        B (I) := new Node_Type'(X, B (I));\n+                     exception\n+                        when others =>\n+                           Free_Element (X);\n+                           raise;\n+                     end;\n+\n+                     N := N + 1;\n+                  end;\n+\n+               end if;\n+            end Process;\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+         begin\n+            Iterate (Source);\n+         end;\n+\n+      end if;\n+\n+   end Symmetric_Difference;\n+\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type :=\n+           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right, L_Node) then\n+               declare\n+                  E : Element_Type renames L_Node.Element.all;\n+                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+               begin\n+\n+                  declare\n+                     X : Element_Access := new Element_Type'(E);\n+                  begin\n+                     Buckets (I) := new Node_Type'(X, Buckets (I));\n+                  exception\n+                     when others =>\n+                        Free_Element (X);\n+                        raise;\n+                  end;\n+\n+                  Length := Length + 1;\n+               end;\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      declare\n+         procedure Process (R_Node : Node_Access);\n+\n+         procedure Process (R_Node : Node_Access) is\n+         begin\n+            if not Is_In (Left, R_Node) then\n+               declare\n+                  E : Element_Type renames R_Node.Element.all;\n+                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+               begin\n+\n+                  declare\n+                     X : Element_Access := new Element_Type'(E);\n+                  begin\n+                     Buckets (I) := new Node_Type'(X, Buckets (I));\n+                  exception\n+                     when others =>\n+                        Free_Element (X);\n+                        raise;\n+                  end;\n+\n+                  Length := Length + 1;\n+\n+               end;\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Right);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Symmetric_Difference;\n+\n+\n+   function Is_Subset (Subset : Set;\n+                       Of_Set : Set) return Boolean is\n+\n+      Subset_Node : Node_Access;\n+\n+   begin\n+\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n+      end if;\n+\n+      --  TODO: rewrite this to loop in the\n+      --  style of a passive iterator.\n+\n+      Subset_Node := HT_Ops.First (Subset);\n+\n+      while Subset_Node /= null loop\n+         if not Is_In (Of_Set, Subset_Node) then\n+            return False;\n+         end if;\n+\n+         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n+      end loop;\n+\n+      return True;\n+\n+   end Is_Subset;\n+\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+\n+      Left_Node : Node_Access;\n+\n+   begin\n+\n+      if Right.Length = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := HT_Ops.First (Left);\n+\n+      while Left_Node /= null loop\n+         if Is_In (Right, Left_Node) then\n+            return True;\n+         end if;\n+\n+         Left_Node := HT_Ops.Next (Left, Left_Node);\n+      end loop;\n+\n+      return False;\n+\n+   end Overlap;\n+\n+\n+   function Find (Container : Set;\n+                  Item      : Element_Type) return Cursor is\n+\n+      Node : constant Node_Access := Element_Keys.Find (Container, Item);\n+\n+   begin\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+\n+   end Find;\n+\n+\n+   function Contains (Container : Set;\n+                      Item      : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+\n+\n+   function First (Container : Set) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end First;\n+\n+\n+--     function First_Element (Container : Set) return Element_Type is\n+--        Node : constant Node_Access := HT_Ops.First (Container);\n+--     begin\n+--        return Node.Element;\n+--     end First_Element;\n+\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null\n+        or else Position.Node = null\n+      then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+         Node : constant Node_Access := HT_Ops.Next (S, Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node = null then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Has_Element;\n+\n+\n+   function Equivalent_Keys (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Element.all, Right.Node.Element.all);\n+   end Equivalent_Keys;\n+\n+\n+   function Equivalent_Keys (Left  : Cursor;\n+                             Right : Element_Type)\n+    return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Element.all, Right);\n+   end Equivalent_Keys;\n+\n+\n+   function Equivalent_Keys (Left  : Element_Type;\n+                             Right : Cursor)\n+    return Boolean is\n+   begin\n+      return Equivalent_Keys (Left, Right.Node.Element.all);\n+   end Equivalent_Keys;\n+\n+\n+   procedure Iterate\n+     (Container : in Set;\n+      Process   : not null access procedure (Position : in Cursor)) is\n+\n+      procedure Process_Node (Node : in Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Process_Node (Node : in Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n+   begin\n+      Iterate (Container);\n+   end Iterate;\n+\n+\n+   function Capacity (Container : Set) return Count_Type\n+     renames HT_Ops.Capacity;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : in     Count_Type)\n+     renames HT_Ops.Ensure_Capacity;\n+\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : in     Node_Access);\n+   pragma Inline (Write_Node);\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : in     Node_Access) is\n+   begin\n+      Element_Type'Output (Stream, Node.Element.all);\n+   end Write_Node;\n+\n+   procedure Write_Nodes is\n+      new HT_Ops.Generic_Write (Write_Node);\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : in     Set) renames Write_Nodes;\n+\n+\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access;\n+   pragma Inline (Read_Node);\n+\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access is\n+\n+      X : Element_Access := new Element_Type'(Element_Type'Input (Stream));\n+   begin\n+      return new Node_Type'(X, null);\n+   exception\n+      when others =>\n+         Free_Element (X);\n+         raise;\n+   end Read_Node;\n+\n+   procedure Read_Nodes is\n+      new HT_Ops.Generic_Read (Read_Node);\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container :    out Set) renames Read_Nodes;\n+\n+\n+   package body Generic_Keys is\n+\n+      function Equivalent_Keys (Left  : Cursor;\n+                                Right : Key_Type)\n+        return Boolean is\n+      begin\n+         return Equivalent_Keys (Right, Left.Node.Element.all);\n+      end Equivalent_Keys;\n+\n+      function Equivalent_Keys (Left  : Key_Type;\n+                                Right : Cursor)\n+        return Boolean is\n+      begin\n+         return Equivalent_Keys (Left, Right.Node.Element.all);\n+      end Equivalent_Keys;\n+\n+      function Equivalent_Keys\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean;\n+      pragma Inline (Equivalent_Keys);\n+\n+      function Equivalent_Keys\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean is\n+      begin\n+         return Equivalent_Keys (Key, Node.Element.all);\n+      end Equivalent_Keys;\n+\n+      package Key_Keys is\n+         new Hash_Tables.Generic_Keys\n+          (HT_Types  => HT_Types,\n+           HT_Type   => Set,\n+           Null_Node => null,\n+           Next      => Next,\n+           Set_Next  => Set_Next,\n+           Key_Type  => Key_Type,\n+           Hash      => Hash,\n+           Equivalent_Keys => Equivalent_Keys);\n+\n+\n+      function Find (Container : Set;\n+                     Key       : Key_Type)\n+         return Cursor is\n+\n+         Node : constant Node_Access :=\n+           Key_Keys.Find (Container, Key);\n+\n+      begin\n+\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+\n+      end Find;\n+\n+\n+      function Contains (Container : Set;\n+                         Key       : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+\n+      function Element (Container : Set;\n+                        Key       : Key_Type)\n+        return Element_Type is\n+\n+         Node : constant Node_Access := Key_Keys.Find (Container, Key);\n+      begin\n+         return Node.Element.all;\n+      end Element;\n+\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element.all);\n+      end Key;\n+\n+\n+--  TODO:\n+--        procedure Replace (Container : in out Set;\n+--                           Key       : in     Key_Type;\n+--                           New_Item  : in     Element_Type) is\n+\n+--           Node : constant Node_Access :=\n+--             Key_Keys.Find (Container, Key);\n+\n+--        begin\n+\n+--           if Node = null then\n+--              raise Constraint_Error;\n+--           end if;\n+\n+--           Replace_Element (Container, Node, New_Item);\n+\n+--        end Replace;\n+\n+\n+      procedure Delete (Container : in out Set;\n+                        Key       : in     Key_Type) is\n+\n+         X : Node_Access;\n+\n+      begin\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+\n+         if X = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Free (X);\n+\n+      end Delete;\n+\n+\n+      procedure Exclude (Container : in out Set;\n+                         Key       : in     Key_Type) is\n+\n+         X : Node_Access;\n+\n+      begin\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Free (X);\n+\n+      end Exclude;\n+\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : in     Cursor;\n+         Process   : not null access\n+           procedure (Element : in out Element_Type)) is\n+\n+      begin\n+\n+         if Position.Container = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n+         begin\n+            Process (Position.Node.Element.all);\n+\n+            if Equivalent_Keys (Old_Key, Position.Node.Element.all) then\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            function New_Node (Next : Node_Access) return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            function New_Node (Next : Node_Access) return Node_Access is\n+            begin\n+               Position.Node.Next := Next;\n+               return Position.Node;\n+            end New_Node;\n+\n+            procedure Insert is\n+               new Key_Keys.Generic_Conditional_Insert (New_Node);\n+\n+            Result  : Node_Access;\n+            Success : Boolean;\n+         begin\n+            HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+\n+            Insert\n+              (HT      => Container,\n+               Key     => Key (Position.Node.Element.all),\n+               Node    => Result,\n+               Success => Success);\n+\n+            if not Success then\n+               declare\n+                  X : Node_Access := Position.Node;\n+               begin\n+                  Free (X);\n+               end;\n+\n+               raise Program_Error;\n+            end if;\n+\n+            pragma Assert (Result = Position.Node);\n+         end;\n+\n+      end Checked_Update_Element;\n+\n+   end Generic_Keys;\n+\n+end Ada.Containers.Indefinite_Hashed_Sets;\n+"}, {"sha": "53ec645be09565028a157d5793905a52b552e963", "filename": "gcc/ada/a-cihase.ads", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_HASHED_SETS                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables;\n+with Ada.Streams;\n+\n+generic\n+   type Element_Type (<>) is private;\n+\n+   with function Hash (Element : Element_Type) return Hash_Type;\n+\n+   --  TODO: get a ruling from ARG in Atlanta re the name and\n+   --  order of these declarations ???\n+\n+   with function Equivalent_Keys (Left, Right : Element_Type) return Boolean;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Hashed_Sets is\n+\n+   pragma Preelaborate (Indefinite_Hashed_Sets);\n+\n+   type Set is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+--  TODO: resolve in atlanta ???\n+--   procedure Replace_Element (Container : in out Set;\n+--                              Position  : Cursor;\n+--                              By        : Element_Type);\n+\n+   procedure Move\n+     (Target : in out Set;\n+      Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Delete  (Container : in out Set; Item : Element_Type);\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n+\n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set\n+     renames Symmetric_Difference;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Capacity (Container : Set) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type);\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      type Key_Type (<>) is limited private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function Hash (Key : Key_Type) return Hash_Type;\n+\n+      with function Equivalent_Keys\n+        (Key     : Key_Type;\n+         Element : Element_Type) return Boolean;\n+\n+   package Generic_Keys is\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+--  TODO: resolve in atlanta???\n+--      procedure Replace (Container : in out Set;\n+--                         Key       : Key_Type;\n+--                         New_Item  : Element_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+\n+      function Equivalent_Keys\n+        (Left  : Cursor;\n+         Right : Key_Type) return Boolean;\n+\n+      function Equivalent_Keys\n+        (Left  : Key_Type;\n+         Right : Cursor) return Boolean;\n+   end Generic_Keys;\n+\n+private\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package HT_Types is\n+      new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+\n+   use HT_Types;\n+\n+   type Set is new Hash_Table_Type with null record;\n+\n+   procedure Adjust (Container : in out Set);\n+\n+   procedure Finalize (Container : in out Set);\n+\n+   type Set_Access is access constant Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : Set_Access;\n+         Node      : Node_Access;\n+      end record;\n+\n+   No_Element : constant Cursor :=\n+                  (Container => null,\n+                   Node      => null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set := (Hash_Table_Type with null record);\n+\n+end Ada.Containers.Indefinite_Hashed_Sets;\n+"}, {"sha": "1886d3d7dec2f50bc168441c15855837288cf961", "filename": "gcc/ada/a-ciorma.adb", "status": "added", "additions": 1031, "deletions": 0, "changes": 1031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1031 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_ORDERED_MAPS                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Indefinite_Ordered_Maps is\n+\n+   use Red_Black_Trees;\n+\n+   type Key_Access is access Key_Type;\n+   type Element_Access is access Element_Type;\n+\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red;\n+      Key     : Key_Access;\n+      Element : Element_Access;\n+   end record;\n+\n+   -----------------------------\n+   -- Node Access Subprograms --\n+   -----------------------------\n+\n+   --  These subprograms provide a functional interface to access fields\n+   --  of a node, and a procedural interface for modifying these values.\n+\n+   function Color (Node : Node_Access) return Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left (Node : Node_Access) return Node_Access;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Access) return Node_Access;\n+   pragma Inline (Parent);\n+\n+   function Right (Node : Node_Access) return Node_Access;\n+   pragma Inline (Right);\n+\n+   procedure Set_Parent (Node : Node_Access; Parent : Node_Access);\n+   pragma Inline (Set_Parent);\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n+\n+   procedure Delete_Tree (X : in out Node_Access);\n+\n+   procedure Free (X : in out Node_Access);\n+\n+   function Is_Equal_Node_Node\n+     (L, R : Node_Access) return Boolean;\n+   pragma Inline (Is_Equal_Node_Node);\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Greater_Key_Node);\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Less_Key_Node);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+     new Red_Black_Trees.Generic_Operations\n+       (Tree_Types => Tree_Types,\n+        Null_Node  => Node_Access'(null));\n+\n+   use Tree_Operations;\n+\n+   package Key_Ops is\n+     new Red_Black_Trees.Generic_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Key_Type,\n+        Is_Less_Key_Node    => Is_Less_Key_Node,\n+        Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+   procedure Free_Key is\n+     new Ada.Unchecked_Deallocation (Key_Type, Key_Access);\n+\n+   procedure Free_Element is\n+     new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   function Is_Equal is\n+     new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      return Left.Node.Key.all < Right.Node.Key.all;\n+   end \"<\";\n+\n+   function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      return Left.Node.Key.all < Right;\n+   end \"<\";\n+\n+   function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Left < Right.Node.Key.all;\n+   end \"<\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      return Is_Equal (Left.Tree, Right.Tree);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      return Right.Node.Key.all < Left.Node.Key.all;\n+   end \">\";\n+\n+   function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      return Right < Left.Node.Key.all;\n+   end \">\";\n+\n+   function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Right.Node.Key.all < Left;\n+   end \">\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Map) is\n+      Tree : Tree_Type renames Container.Tree;\n+\n+      N : constant Count_Type := Tree.Length;\n+      X : constant Node_Access := Tree.Root;\n+\n+   begin\n+      if N = 0 then\n+         pragma Assert (X = null);\n+         return;\n+      end if;\n+\n+      Tree := (Length => 0, others => null);\n+\n+      Tree.Root := Copy_Tree (X);\n+      Tree.First := Min (Tree.Root);\n+      Tree.Last := Max (Tree.Root);\n+      Tree.Length := N;\n+   end Adjust;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Node_Access := Key_Ops.Ceiling (Container.Tree, Key);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end if;\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) is\n+      Tree : Tree_Type renames Container.Tree;\n+      Root : Node_Access := Tree.Root;\n+   begin\n+      Tree := (Length => 0, others => null);\n+      Delete_Tree (Root);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Access) return Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access is\n+      Target : constant Node_Access :=\n+         new Node_Type'(Parent  => null,\n+                        Left    => null,\n+                        Right   => null,\n+                        Color   => Source.Color,\n+                        Key     => Source.Key,\n+                        Element => Source.Element);\n+   begin\n+      return Target;\n+   end Copy_Node;\n+\n+   ---------------\n+   -- Copy_Tree --\n+   ---------------\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n+      Target_Root : Node_Access := Copy_Node (Source_Root);\n+\n+      P, X : Node_Access;\n+\n+   begin\n+      if Source_Root.Right /= null then\n+         Target_Root.Right := Copy_Tree (Source_Root.Right);\n+         Target_Root.Right.Parent := Target_Root;\n+      end if;\n+\n+      P := Target_Root;\n+      X := Source_Root.Left;\n+      while X /= null loop\n+         declare\n+            Y : Node_Access := Copy_Node (X);\n+\n+         begin\n+            P.Left := Y;\n+            Y.Parent := P;\n+\n+            if X.Right /= null then\n+               Y.Right := Copy_Tree (X.Right);\n+               Y.Right.Parent := Y;\n+            end if;\n+\n+            P := Y;\n+            X := X.Left;\n+         end;\n+      end loop;\n+\n+      return Target_Root;\n+\n+   exception\n+      when others =>\n+         Delete_Tree (Target_Root);\n+         raise;\n+   end Copy_Tree;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Map;\n+      Position  : in out Cursor)\n+   is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access := Key_Ops.Find (Container.Tree, Key);\n+   begin\n+      if X = null then\n+         raise Constraint_Error;\n+      else\n+         Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end if;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Map) is\n+      Position : Cursor := First (Container);\n+   begin\n+      Delete (Container, Position);\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Map) is\n+      Position : Cursor := Last (Container);\n+   begin\n+      Delete (Container, Position);\n+   end Delete_Last;\n+\n+   -----------------\n+   -- Delete_Tree --\n+   -----------------\n+\n+   procedure Delete_Tree (X : in out Node_Access) is\n+      Y : Node_Access;\n+   begin\n+      while X /= null loop\n+         Y := X.Right;\n+         Delete_Tree (Y);\n+         Y := X.Left;\n+         Free (X);\n+         X := Y;\n+      end loop;\n+   end Delete_Tree;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+   begin\n+      return Node.Element.all;\n+   end Element;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n+   begin\n+      if X /= null then\n+         Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end if;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+   begin\n+      if Container.Tree.First = null then\n+         return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+      end if;\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Map) return Element_Type is\n+   begin\n+      return Container.Tree.First.Element.all;\n+   end First_Element;\n+\n+   ---------------\n+   -- First_Key --\n+   ---------------\n+\n+   function First_Key (Container : Map) return Key_Type is\n+   begin\n+      return Container.Tree.First.Key.all;\n+   end First_Key;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Node_Access := Key_Ops.Floor (Container.Tree, Key);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end if;\n+   end Floor;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         Free_Key (X.Key);\n+         Free_Element (X.Element);\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+      K : Key_Access;\n+      E : Element_Access;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         K := Position.Node.Key;\n+         E := Position.Node.Element;\n+\n+         Position.Node.Key := new Key_Type'(Key);\n+         Position.Node.Element := new Element_Type'(New_Item);\n+\n+         Free_Key (K);\n+         Free_Element (E);\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Node : Node_Access := new Node_Type;\n+\n+      begin\n+         Node.Key := new Key_Type'(Key);\n+         Node.Element := new Element_Type'(New_Item);\n+         return Node;\n+\n+      exception\n+         when others =>\n+\n+            --  On exception, deallocate key and elem\n+\n+            Free (Node);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container.Tree,\n+         Key,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Container.Tree.Length = 0;\n+   end Is_Empty;\n+\n+   ------------------------\n+   -- Is_Equal_Node_Node --\n+   ------------------------\n+\n+   function Is_Equal_Node_Node\n+     (L, R : Node_Access) return Boolean is\n+   begin\n+      return L.Element.all = R.Element.all;\n+   end Is_Equal_Node_Node;\n+\n+   -------------------------\n+   -- Is_Greater_Key_Node --\n+   -------------------------\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Access) return Boolean\n+   is\n+   begin\n+      --  k > node same as node < k\n+\n+      return Right.Key.all < Left;\n+   end Is_Greater_Key_Node;\n+\n+   ----------------------\n+   -- Is_Less_Key_Node --\n+   ----------------------\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Access) return Boolean is\n+   begin\n+      return Left < Right.Key.all;\n+   end Is_Less_Key_Node;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      Local_Iterate (Container.Tree);\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Cursor) return Key_Type is\n+   begin\n+      return Position.Node.Key.all;\n+   end Key;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Map) return Cursor is\n+   begin\n+      if Container.Tree.Last = null then\n+         return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+      end if;\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Map) return Element_Type is\n+   begin\n+      return Container.Tree.Last.Element.all;\n+   end Last_Element;\n+\n+   --------------\n+   -- Last_Key --\n+   --------------\n+\n+   function Last_Key (Container : Map) return Key_Type is\n+   begin\n+      return Container.Tree.Last.Key.all;\n+   end Last_Key;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Left;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      return Container.Tree.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Map; Source : in out Map) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Move (Target => Target.Tree, Source => Source.Tree);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access := Tree_Operations.Next (Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         else\n+            return Cursor'(Position.Container, Node);\n+         end if;\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access :=\n+           Tree_Operations.Previous (Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key.all, Position.Node.Element.all);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map)\n+   is\n+      N : Count_Type'Base;\n+\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Node : Node_Access := new Node_Type;\n+\n+      begin\n+         Node.Key := new Key_Type'(Key_Type'Input (Stream));\n+         Node.Element := new Element_Type'(Element_Type'Input (Stream));\n+         return Node;\n+\n+      exception\n+         when others =>\n+\n+            --  Deallocate key and elem too on exception\n+\n+            Free (Node);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Clear (Container);\n+\n+      Count_Type'Base'Read (Stream, N);\n+      pragma Assert (N >= 0);\n+\n+      Local_Read (Container.Tree, N);\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Node_Access :=\n+               Key_Ops.Find (Container.Tree, Key);\n+\n+      K : Key_Access;\n+      E : Element_Access;\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      K := Node.Key;\n+      E := Node.Element;\n+\n+      Node.Key := new Key_Type'(Key);\n+      Node.Element := new Element_Type'(New_Item);\n+\n+      Free_Key (K);\n+      Free_Element (E);\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+      X : Element_Access := Position.Node.Element;\n+   begin\n+      Position.Node.Element := new Element_Type'(By);\n+      Free_Element (X);\n+   end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      Local_Reverse_Iterate (Container.Tree);\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Right;\n+   end Right;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type) is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : Node_Access; Parent : Node_Access) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key.all, Position.Node.Element.all);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map)\n+   is\n+      procedure Process (Node : Node_Access);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is\n+        new Tree_Operations.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Node : Node_Access) is\n+      begin\n+         Key_Type'Output (Stream, Node.Key.all);\n+         Element_Type'Output (Stream, Node.Element.all);\n+      end Process;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Container.Tree.Length);\n+      Iterate (Container.Tree);\n+   end Write;\n+\n+end Ada.Containers.Indefinite_Ordered_Maps;\n+"}, {"sha": "8bfe3270e2132778a96203766a78c9b6c0163285", "filename": "gcc/ada/a-ciorma.ads", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,234 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_ORDERED_MAPS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees;\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+\n+   type Key_Type (<>) is private;\n+\n+   type Element_Type (<>) is private;\n+\n+   with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Ordered_Maps is\n+pragma Preelaborate (Indefinite_Ordered_Maps);\n+\n+   type Map is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Map : constant Map;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   procedure Clear (Container : in out Map);\n+\n+   function Key (Position : Cursor) return Key_Type;\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type));\n+\n+   procedure Replace_Element (Position : Cursor; By : Element_Type);\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n+   procedure Exclude\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n+   procedure Delete\n+     (Container : in out Map;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Map);\n+\n+   procedure Delete_Last (Container : in out Map);\n+\n+   function Contains\n+     (Container : Map;\n+      Key       : Key_Type) return Boolean;\n+\n+   function Find\n+     (Container : Map;\n+      Key       : Key_Type) return Cursor;\n+\n+   function Element\n+     (Container : Map;\n+      Key       : Key_Type) return Element_Type;\n+\n+   function Floor\n+     (Container : Map;\n+      Key       : Key_Type) return Cursor;\n+\n+   function Ceiling\n+     (Container : Map;\n+      Key       : Key_Type) return Cursor;\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function First_Key (Container : Map) return Key_Type;\n+\n+   function First_Element (Container : Map) return Element_Type;\n+\n+   function Last (Container : Map) return Cursor;\n+\n+   function Last_Key (Container : Map) return Key_Type;\n+\n+   function Last_Element (Container : Map) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean;\n+\n+   function \">\" (Left, Right : Cursor) return Boolean;\n+\n+   function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+   function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+   function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+   function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package Tree_Types is\n+     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Map is new Controlled with record\n+      Tree : Tree_Type := (Length => 0, others => null);\n+   end record;\n+\n+   procedure Adjust (Container : in out Map);\n+\n+   procedure Finalize (Container : in out Map) renames Clear;\n+\n+   type Map_Access is access constant Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Map_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   Empty_Map : constant Map :=\n+     (Controlled with Tree => (Length => 0, others => null));\n+\n+end Ada.Containers.Indefinite_Ordered_Maps;\n+"}, {"sha": "1d608b0367215f532d49a18f5beef03072f0c191", "filename": "gcc/ada/a-ciormu.adb", "status": "added", "additions": 1659, "deletions": 0, "changes": 1659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1659 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.INDEFINITE_ORDERED_MULTISETS                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Set_Operations;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Indefinite_Ordered_Multisets is\n+\n+   use Red_Black_Trees;\n+\n+   type Element_Access is access Element_Type;\n+\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red;\n+      Element : Element_Access;\n+   end record;\n+\n+   -----------------------------\n+   -- Node Access Subprograms --\n+   -----------------------------\n+\n+   --  These subprograms provide a functional interface to access fields\n+   --  of a node, and a procedural interface for modifying these values.\n+\n+   function Color (Node : Node_Access) return Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left (Node : Node_Access) return Node_Access;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Access) return Node_Access;\n+   pragma Inline (Parent);\n+\n+   function Right (Node : Node_Access) return Node_Access;\n+   pragma Inline (Right);\n+\n+   procedure Set_Parent (Node : Node_Access; Parent : Node_Access);\n+   pragma Inline (Set_Parent);\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n+\n+   procedure Delete_Tree (X : in out Node_Access);\n+\n+   procedure Free (X : in out Node_Access);\n+\n+   procedure Insert_With_Hint\n+     (Dst_Tree : in out Tree_Type;\n+      Dst_Hint : Node_Access;\n+      Src_Node : Node_Access;\n+      Dst_Node : out Node_Access);\n+\n+   function Is_Equal_Node_Node (L, R : Node_Access) return Boolean;\n+   pragma Inline (Is_Equal_Node_Node);\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Greater_Element_Node);\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Less_Element_Node);\n+\n+   function Is_Less_Node_Node (L, R : Node_Access) return Boolean;\n+   pragma Inline (Is_Less_Node_Node);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+     new Red_Black_Trees.Generic_Operations\n+       (Tree_Types => Tree_Types,\n+        Null_Node  => Node_Access'(null));\n+\n+   use Tree_Operations;\n+\n+   procedure Free_Element is\n+     new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   function Is_Equal is\n+     new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n+\n+   package Set_Ops is\n+     new Generic_Set_Operations\n+       (Tree_Operations  => Tree_Operations,\n+        Insert_With_Hint => Insert_With_Hint,\n+        Copy_Tree        => Copy_Tree,\n+        Delete_Tree      => Delete_Tree,\n+        Is_Less          => Is_Less_Node_Node,\n+        Free             => Free);\n+\n+   package Element_Keys is\n+     new Red_Black_Trees.Generic_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Element_Type,\n+        Is_Less_Key_Node    => Is_Less_Element_Node,\n+        Is_Greater_Key_Node => Is_Greater_Element_Node);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      return Left.Node.Element.all < Right.Node.Element.all;\n+   end \"<\";\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      return Left.Node.Element.all < Right;\n+   end \"<\";\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Left < Right.Node.Element.all;\n+   end \"<\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      return Is_Equal (Left.Tree, Right.Tree);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      return Right < Left.Node.Element.all;\n+   end \">\";\n+\n+   function \">\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      --  L > R same as R < L\n+\n+      return Right.Node.Element.all < Left.Node.Element.all;\n+   end \">\";\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Right.Node.Element.all < Left;\n+   end \">\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+\n+      N : constant Count_Type := Tree.Length;\n+      X : constant Node_Access := Tree.Root;\n+\n+   begin\n+      if N = 0 then\n+         pragma Assert (X = null);\n+         return;\n+      end if;\n+\n+      Tree := (Length => 0, others => null);\n+\n+      Tree.Root := Copy_Tree (X);\n+      Tree.First := Min (Tree.Root);\n+      Tree.Last := Max (Tree.Root);\n+      Tree.Length := N;\n+   end Adjust;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Ceiling (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+      Root : Node_Access := Tree.Root;\n+   begin\n+      Tree := (Length => 0, others => null);\n+      Delete_Tree (Root);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Access) return Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access is\n+      X : Element_Access := new Element_Type'(Source.Element.all);\n+\n+   begin\n+      return new Node_Type'(Parent  => null,\n+                            Left    => null,\n+                            Right   => null,\n+                            Color   => Source.Color,\n+                            Element => X);\n+\n+   exception\n+      when others =>\n+         Free_Element (X);\n+         raise;\n+   end Copy_Node;\n+\n+   ---------------\n+   -- Copy_Tree --\n+   ---------------\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n+      Target_Root : Node_Access := Copy_Node (Source_Root);\n+\n+      P, X : Node_Access;\n+\n+   begin\n+      if Source_Root.Right /= null then\n+         Target_Root.Right := Copy_Tree (Source_Root.Right);\n+         Target_Root.Right.Parent := Target_Root;\n+      end if;\n+\n+      P := Target_Root;\n+      X := Source_Root.Left;\n+      while X /= null loop\n+         declare\n+            Y : Node_Access := Copy_Node (X);\n+\n+         begin\n+            P.Left := Y;\n+            Y.Parent := P;\n+\n+            if X.Right /= null then\n+               Y.Right := Copy_Tree (X.Right);\n+               Y.Right.Parent := Y;\n+            end if;\n+\n+            P := Y;\n+            X := X.Left;\n+         end;\n+      end loop;\n+\n+      return Target_Root;\n+\n+   exception\n+      when others =>\n+         Delete_Tree (Target_Root);\n+         raise;\n+   end Copy_Tree;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Set; Item : Element_Type) is\n+      Tree : Tree_Type renames Container.Tree;\n+      Node : Node_Access := Element_Keys.Ceiling (Tree, Item);\n+      Done : constant Node_Access := Element_Keys.Upper_Bound (Tree, Item);\n+      X    : Node_Access;\n+\n+   begin\n+      if Node = Done then\n+         raise Constraint_Error;\n+      end if;\n+\n+      loop\n+         X := Node;\n+         Node := Tree_Operations.Next (Node);\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+         Free (X);\n+\n+         exit when Node = Done;\n+      end loop;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+      X    : Node_Access := Tree.First;\n+\n+   begin\n+      if X = null then\n+         return;\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+      Free (X);\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+      X    : Node_Access := Tree.Last;\n+\n+   begin\n+      if X = null then\n+         return;\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+      Free (X);\n+   end Delete_Last;\n+\n+   -----------------\n+   -- Delete_Tree --\n+   -----------------\n+\n+   procedure Delete_Tree (X : in out Node_Access) is\n+      Y : Node_Access;\n+   begin\n+      while X /= null loop\n+         Y := X.Right;\n+         Delete_Tree (Y);\n+         Y := X.Left;\n+         Free (X);\n+         X := Y;\n+      end loop;\n+   end Delete_Tree;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      Set_Ops.Difference (Target.Tree, Source.Tree);\n+   end Difference;\n+\n+   function Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Difference (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type) is\n+      Tree : Tree_Type renames Container.Tree;\n+      Node : Node_Access := Element_Keys.Ceiling (Tree, Item);\n+      Done : constant Node_Access := Element_Keys.Upper_Bound (Tree, Item);\n+      X    : Node_Access;\n+   begin\n+      while Node /= Done loop\n+         X := Node;\n+         Node := Tree_Operations.Next (Node);\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+         Free (X);\n+      end loop;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Find (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+   begin\n+      if Container.Tree.First = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Set) return Element_Type is\n+   begin\n+      return Container.Tree.First.Element.all;\n+   end First_Element;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Floor (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Floor;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         Free_Element (X.Element);\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   ------------------\n+   -- Generic_Keys --\n+   ------------------\n+\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean;\n+      pragma Inline (Is_Less_Key_Node);\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean;\n+      pragma Inline (Is_Greater_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Red_Black_Trees.Generic_Keys\n+          (Tree_Operations     => Tree_Operations,\n+           Key_Type            => Key_Type,\n+           Is_Less_Key_Node    => Is_Less_Key_Node,\n+           Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+      ---------\n+      -- \"<\" --\n+      ---------\n+\n+      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n+      begin\n+         return Left < Right.Node.Element.all;\n+      end \"<\";\n+\n+      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n+      begin\n+         return Right > Left.Node.Element.all;\n+      end \"<\";\n+\n+      ---------\n+      -- \">\" --\n+      ---------\n+\n+      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n+      begin\n+         return Left > Right.Node.Element.all;\n+      end \">\";\n+\n+      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n+      begin\n+         return Right < Left.Node.Element.all;\n+      end \">\";\n+\n+      -------------\n+      -- Ceiling --\n+      -------------\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Ceiling (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Ceiling;\n+\n+      ----------------------------\n+      -- Checked_Update_Element --\n+      ----------------------------\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access procedure (Element : in out Element_Type))\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n+\n+         begin\n+            Process (Position.Node.Element.all);\n+\n+            if Old_Key < Position.Node.Element.all\n+              or else Old_Key > Position.Node.Element.all\n+            then\n+               null;\n+            else\n+               return;\n+            end if;\n+         end;\n+\n+         Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+\n+         Do_Insert : declare\n+            Result : Node_Access;\n+\n+            function New_Node return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            procedure Insert_Post is\n+              new Key_Keys.Generic_Insert_Post (New_Node);\n+\n+            procedure Insert is\n+              new Key_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+            --------------\n+            -- New_Node --\n+            --------------\n+\n+            function New_Node return Node_Access is\n+            begin\n+               return Position.Node;\n+            end New_Node;\n+\n+         --  Start of processing for Do_Insert\n+\n+         begin\n+            Insert\n+              (Tree    => Container.Tree,\n+               Key     => Key (Position.Node.Element.all),\n+               Node    => Result);\n+\n+            pragma Assert (Result = Position.Node);\n+         end Do_Insert;\n+      end Checked_Update_Element;\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type) is\n+         Tree : Tree_Type renames Container.Tree;\n+         Node : Node_Access := Key_Keys.Ceiling (Tree, Key);\n+         Done : constant Node_Access := Key_Keys.Upper_Bound (Tree, Key);\n+         X    : Node_Access;\n+\n+      begin\n+         if Node = Done then\n+            raise Constraint_Error;\n+         end if;\n+\n+         loop\n+            X := Node;\n+            Node := Tree_Operations.Next (Node);\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Free (X);\n+\n+            exit when Node = Done;\n+         end loop;\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type is\n+         Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n+      begin\n+         return Node.Element.all;\n+      end Element;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type) is\n+         Tree : Tree_Type renames Container.Tree;\n+         Node : Node_Access := Key_Keys.Ceiling (Tree, Key);\n+         Done : constant Node_Access := Key_Keys.Upper_Bound (Tree, Key);\n+         X    : Node_Access;\n+\n+      begin\n+         while Node /= Done loop\n+            X := Node;\n+            Node := Tree_Operations.Next (Node);\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Free (X);\n+         end loop;\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Find;\n+\n+      -----------\n+      -- Floor --\n+      -----------\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access := Key_Keys.Floor (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Floor;\n+\n+      -------------------------\n+      -- Is_Greater_Key_Node --\n+      -------------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean is\n+      begin\n+         return Left > Right.Element.all;\n+      end Is_Greater_Key_Node;\n+\n+      ----------------------\n+      -- Is_Less_Key_Node --\n+      ----------------------\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean is\n+      begin\n+         return Left < Right.Element.all;\n+      end Is_Less_Key_Node;\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate\n+        (Container : Set;\n+         Key       : Key_Type;\n+         Process   : not null access procedure (Position : Cursor))\n+      is\n+         procedure Process_Node (Node : Node_Access);\n+         pragma Inline (Process_Node);\n+\n+         procedure Local_Iterate is\n+           new Key_Keys.Generic_Iteration (Process_Node);\n+\n+         ------------------\n+         -- Process_Node --\n+         ------------------\n+\n+         procedure Process_Node (Node : Node_Access) is\n+         begin\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+         end Process_Node;\n+\n+      --  Start of processing for Iterate\n+\n+      begin\n+         Local_Iterate (Container.Tree, Key);\n+      end Iterate;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element.all);\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      --  In post-madision api: ???\n+\n+--     procedure Replace\n+--       (Container : in out Set;\n+--        Key       : Key_Type;\n+--        New_Item  : Element_Type)\n+--     is\n+--           Node : Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+--        begin\n+--           if Node = null then\n+--              raise Constraint_Error;\n+--           end if;\n+\n+--           Replace_Node (Container, Node, New_Item);\n+--        end Replace;\n+\n+      ---------------------\n+      -- Reverse_Iterate --\n+      ---------------------\n+\n+      procedure Reverse_Iterate\n+        (Container : Set;\n+         Key       : Key_Type;\n+         Process   : not null access procedure (Position : Cursor))\n+      is\n+         procedure Process_Node (Node : Node_Access);\n+         pragma Inline (Process_Node);\n+\n+         -------------\n+         -- Iterate --\n+         -------------\n+\n+         procedure Local_Reverse_Iterate is\n+            new Key_Keys.Generic_Reverse_Iteration (Process_Node);\n+\n+         ------------------\n+         -- Process_Node --\n+         ------------------\n+\n+         procedure Process_Node (Node : Node_Access) is\n+         begin\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+         end Process_Node;\n+\n+      --  Start of processing for Reverse_Iterate\n+\n+      begin\n+         Local_Reverse_Iterate (Container.Tree, Key);\n+      end Reverse_Iterate;\n+\n+   end Generic_Keys;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert (Container : in out Set; New_Item : Element_Type) is\n+      Position : Cursor;\n+   begin\n+      Insert (Container, New_Item, Position);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor)\n+   is\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Unconditional_Insert_Sans_Hint is\n+        new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         X : Element_Access := new Element_Type'(New_Item);\n+\n+      begin\n+         return new Node_Type'(Parent  => null,\n+                               Left    => null,\n+                               Right   => null,\n+                               Color   => Red,\n+                               Element => X);\n+\n+      exception\n+         when others =>\n+            Free_Element (X);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      Unconditional_Insert_Sans_Hint\n+        (Container.Tree,\n+         New_Item,\n+         Position.Node);\n+\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_With_Hint --\n+   ----------------------\n+\n+   procedure Insert_With_Hint\n+     (Dst_Tree : in out Tree_Type;\n+      Dst_Hint : Node_Access;\n+      Src_Node : Node_Access;\n+      Dst_Node : out Node_Access)\n+   is\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+        new Element_Keys.Generic_Unconditional_Insert_With_Hint\n+          (Insert_Post,\n+           Insert_Sans_Hint);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         X : Element_Access := new Element_Type'(Src_Node.Element.all);\n+\n+      begin\n+         return new Node_Type'(Parent  => null,\n+                               Left    => null,\n+                               Right   => null,\n+                               Color   => Red,\n+                               Element => X);\n+\n+      exception\n+         when others =>\n+            Free_Element (X);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert_With_Hint\n+\n+   begin\n+      Local_Insert_With_Hint\n+        (Dst_Tree,\n+         Dst_Hint,\n+         Src_Node.Element.all,\n+         Dst_Node);\n+   end Insert_With_Hint;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Set_Ops.Intersection (Target.Tree, Source.Tree);\n+   end Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Intersection (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Tree.Length = 0;\n+   end Is_Empty;\n+\n+   ------------------------\n+   -- Is_Equal_Node_Node --\n+   ------------------------\n+\n+   function Is_Equal_Node_Node (L, R : Node_Access) return Boolean is\n+   begin\n+      return L.Element.all = R.Element.all;\n+   end Is_Equal_Node_Node;\n+\n+   -----------------------------\n+   -- Is_Greater_Element_Node --\n+   -----------------------------\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean\n+   is\n+   begin\n+      --  e > node same as node < e\n+\n+      return Right.Element.all < Left;\n+   end Is_Greater_Element_Node;\n+\n+   --------------------------\n+   -- Is_Less_Element_Node --\n+   --------------------------\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean\n+   is\n+   begin\n+      return Left < Right.Element.all;\n+   end Is_Less_Element_Node;\n+\n+   -----------------------\n+   -- Is_Less_Node_Node --\n+   -----------------------\n+\n+   function Is_Less_Node_Node (L, R : Node_Access) return Boolean is\n+   begin\n+      return L.Element.all < R.Element.all;\n+   end Is_Less_Node_Node;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      return Set_Ops.Is_Subset (Subset => Subset.Tree, Of_Set => Of_Set.Tree);\n+   end Is_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Item      : Element_Type;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Element_Keys.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      Local_Iterate (Container.Tree, Item);\n+   end Iterate;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      Local_Iterate (Container.Tree);\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Set) return Cursor is\n+   begin\n+      if Container.Tree.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Set) return Element_Type is\n+   begin\n+      return Container.Tree.Last.Element.all;\n+   end Last_Element;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Left;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Tree.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Move (Target => Target.Tree, Source => Source.Tree);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access :=\n+                  Tree_Operations.Next (Position.Node);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Tree.Length /= 0;\n+      end if;\n+\n+      return Set_Ops.Overlap (Left.Tree, Right.Tree);\n+   end Overlap;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access :=\n+                  Tree_Operations.Previous (Position.Node);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Element.all);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      N : Count_Type'Base;\n+\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Node : Node_Access := new Node_Type;\n+\n+      begin\n+         begin\n+            Node.Element := new Element_Type'(Element_Type'Input (Stream));\n+         exception\n+            when others =>\n+               Free (Node);\n+               raise;\n+         end;\n+\n+         return Node;\n+      end New_Node;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Clear (Container);\n+\n+      Count_Type'Base'Read (Stream, N);\n+      pragma Assert (N >= 0);\n+\n+      Local_Read (Container.Tree, N);\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   --  NOTE: from post-madison api???\n+\n+--   procedure Replace\n+--     (Container : in out Set;\n+--      Position  : Cursor;\n+--      By        : Element_Type)\n+--   is\n+--   begin\n+--      if Position.Container = null then\n+--         raise Constraint_Error;\n+--      end if;\n+\n+--      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+--         raise Program_Error;\n+--      end if;\n+\n+--      Replace_Node (Container, Position.Node, By);\n+--   end Replace;\n+\n+   ------------------\n+   -- Replace_Node --\n+   ------------------\n+\n+   --  NOTE: from post-madison api???\n+\n+--   procedure Replace_Node\n+--     (Container : in out Set;\n+--      Position  : Node_Access;\n+--      By        : Element_Type);\n+--   is\n+--      Tree : Tree_Type renames Container.Tree;\n+--      Node : Node_Access := Position;\n+\n+--   begin\n+--      if By < Node.Element\n+--        or else Node.Element < By\n+--      then\n+--         null;\n+\n+--      else\n+--         begin\n+--            Node.Element := By;\n+\n+--         exception\n+--            when others =>\n+--               Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n+--               Free (Node);\n+--               raise;\n+--         end;\n+\n+--         return;\n+--      end if;\n+\n+--      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n+\n+--      begin\n+--         Node.Element := By;\n+\n+--      exception\n+--         when others =>\n+--            Free (Node);\n+--            raise;\n+--      end;\n+\n+--      declare\n+--         Result  : Node_Access;\n+--         Success : Boolean;\n+\n+--         function New_Node return Node_Access;\n+--         pragma Inline (New_Node);\n+\n+--         procedure Insert_Post is\n+--           new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+--         procedure Insert is\n+--           new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+--         --------------\n+--         -- New_Node --\n+--         --------------\n+--\n+--         function New_Node return Node_Access is\n+--         begin\n+--            return Node;\n+--         end New_Node;\n+\n+--      --  Start of processing for Replace_Node\n+\n+--      begin\n+--         Insert\n+--           (Tree    => Tree,\n+--            Key     => Node.Element,\n+--            Node    => Result,\n+--            Success => Success);\n+\n+--         if not Success then\n+--            Free (Node);\n+--            raise Program_Error;\n+--         end if;\n+\n+--         pragma Assert (Result = Node);\n+--      end;\n+--   end Replace_Node;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Item      : Element_Type;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+        new Element_Keys.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      Local_Reverse_Iterate (Container.Tree, Item);\n+   end Reverse_Iterate;\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      Local_Reverse_Iterate (Container.Tree);\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Right;\n+   end Right;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type) is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : Node_Access; Parent : Node_Access) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      Set_Ops.Symmetric_Difference (Target.Tree, Source.Tree);\n+   end Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Symmetric_Difference;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Set_Ops.Union (Target.Tree, Source.Tree);\n+   end Union;\n+\n+   function Union (Left, Right : Set) return Set is begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type := Set_Ops.Union (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Union;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Process (Node : Node_Access);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is new Tree_Operations.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Node : Node_Access) is\n+      begin\n+         Element_Type'Output (Stream, Node.Element.all);\n+      end Process;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Container.Tree.Length);\n+      Iterate (Container.Tree);\n+   end Write;\n+\n+end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "328d0dded9f3a02c34e0b82f45ea985db074ac76", "filename": "gcc/ada/a-ciormu.ads", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,290 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.INDEFINITE_ORDERED_MULTISETS                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees;\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+   type Element_Type (<>) is private;\n+\n+   with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Ordered_Multisets is\n+pragma Preelaborate (Indefinite_Ordered_Multisets);\n+\n+   type Set is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor);\n+\n+   procedure Insert (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Delete (Container : in out Set; Item : Element_Type);\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Set);\n+\n+   procedure Delete_Last (Container : in out Set);\n+\n+\n+   --  NOTE: The following operation is named Replace in the Madison API.\n+   --  However, it should be named Replace_Element ???\n+   --\n+   --   procedure Replace\n+   --     (Container : in out Set;\n+   --      Position  : Cursor;\n+   --      By        : Element_Type);\n+\n+   procedure Union (Target : in out Set;\n+                    Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function First_Element (Container : Set) return Element_Type;\n+\n+   function Last (Container : Set) return Cursor;\n+\n+   function Last_Element (Container : Set) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean;\n+\n+   function \">\" (Left, Right : Cursor) return Boolean;\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Item      : Element_Type;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Item      : Element_Type;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+\n+      type Key_Type (<>) is limited private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function \"<\" (Left : Key_Type; Right : Element_Type)\n+          return Boolean is <>;\n+\n+      with function \">\" (Left : Key_Type; Right : Element_Type)\n+          return Boolean is <>;\n+\n+   package Generic_Keys is\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      --  NOTE: in post-madison api ???\n+      --      procedure Replace\n+      --        (Container : in out Set;\n+      --         Key       : Key_Type;\n+      --         New_Item  : Element_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+\n+      procedure Iterate\n+        (Container : Set;\n+         Key       : Key_Type;\n+         Process   : not null access procedure (Position : Cursor));\n+\n+      procedure Reverse_Iterate\n+        (Container : Set;\n+         Key       : Key_Type;\n+         Process   : not null access procedure (Position : Cursor));\n+\n+   end Generic_Keys;\n+\n+private\n+\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package Tree_Types is\n+      new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Set is new Controlled with record\n+      Tree : Tree_Type := (Length => 0, others => null);\n+   end record;\n+\n+   procedure Adjust (Container : in out Set);\n+\n+   procedure Finalize (Container : in out Set) renames Clear;\n+\n+   type Set_Access is access constant Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Set_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write (Stream : access Root_Stream_Type'Class; Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set :=\n+                 (Controlled with Tree => (Length => 0, others => null));\n+\n+end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "9cd5e14db36508784f87a62ee9777b66ef36f842", "filename": "gcc/ada/a-ciorse.adb", "status": "added", "additions": 1557, "deletions": 0, "changes": 1557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1557 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_ORDERED_SETS                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Set_Operations;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Indefinite_Ordered_Sets is\n+\n+   type Element_Access is access Element_Type;\n+\n+   use Red_Black_Trees;\n+\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red;\n+      Element : Element_Access;\n+   end record;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Color (Node : Node_Access) return Color_Type;\n+   pragma Inline (Color);\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n+\n+   procedure Delete_Tree (X : in out Node_Access);\n+\n+   procedure Free (X : in out Node_Access);\n+\n+   procedure Insert_With_Hint\n+     (Dst_Tree : in out Tree_Type;\n+      Dst_Hint : Node_Access;\n+      Src_Node : Node_Access;\n+      Dst_Node : out Node_Access);\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Greater_Element_Node);\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean;\n+   pragma Inline (Is_Less_Element_Node);\n+\n+   function Is_Less_Node_Node (L, R : Node_Access) return Boolean;\n+   pragma Inline (Is_Less_Node_Node);\n+\n+   function Left (Node : Node_Access) return Node_Access;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Access) return Node_Access;\n+   pragma Inline (Parent);\n+\n+   function Right (Node : Node_Access) return Node_Access;\n+   pragma Inline (Right);\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Parent (Node   : Node_Access; Parent : Node_Access);\n+   pragma Inline (Set_Parent);\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access);\n+   pragma Inline (Set_Right);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   procedure Free_Element is\n+     new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   package Tree_Operations is\n+     new Red_Black_Trees.Generic_Operations\n+       (Tree_Types => Tree_Types,\n+        Null_Node  => Node_Access'(null));\n+\n+   use Tree_Operations;\n+\n+   package Element_Keys is\n+     new Red_Black_Trees.Generic_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Element_Type,\n+        Is_Less_Key_Node    => Is_Less_Element_Node,\n+        Is_Greater_Key_Node => Is_Greater_Element_Node);\n+\n+   package Set_Ops is\n+      new Generic_Set_Operations\n+        (Tree_Operations  => Tree_Operations,\n+         Insert_With_Hint => Insert_With_Hint,\n+         Copy_Tree        => Copy_Tree,\n+         Delete_Tree      => Delete_Tree,\n+         Is_Less          => Is_Less_Node_Node,\n+         Free             => Free);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      return Left.Node.Element.all < Right.Node.Element.all;\n+   end \"<\";\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      return Left.Node.Element.all < Right;\n+   end \"<\";\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Left < Right.Node.Element.all;\n+   end \"<\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is\n+\n+      function Is_Equal_Node_Node (L, R : Node_Access) return Boolean;\n+      pragma Inline (Is_Equal_Node_Node);\n+\n+      function Is_Equal is\n+        new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n+\n+      ------------------------\n+      -- Is_Equal_Node_Node --\n+      ------------------------\n+\n+      function Is_Equal_Node_Node (L, R : Node_Access) return Boolean is\n+      begin\n+         return L.Element.all = R.Element.all;\n+      end Is_Equal_Node_Node;\n+\n+   --  Start of processing for \"=\"\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      return Is_Equal (Left.Tree, Right.Tree);\n+   end \"=\";\n+\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      --  L > R same as R < L\n+\n+      return Right.Node.Element.all < Left.Node.Element.all;\n+   end \">\";\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      return Right < Left.Node.Element.all;\n+   end \">\";\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Right.Node.Element.all < Left;\n+   end \">\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+\n+   begin\n+      if Tree.Length = 0 then\n+         pragma Assert (Tree.Root = null);\n+         return;\n+      end if;\n+\n+      begin\n+         Tree.Root := Copy_Tree (Tree.Root);\n+      exception\n+         when others =>\n+            Tree := (Length => 0, others => null);\n+            raise;\n+      end;\n+\n+      Tree.First := Min (Tree.Root);\n+      Tree.Last := Max (Tree.Root);\n+   end Adjust;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Ceiling (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Set) is\n+      Tree : Tree_Type renames Container.Tree;\n+      Root : Node_Access := Tree.Root;\n+   begin\n+      Tree := (Length => 0, others => null);\n+      Delete_Tree (Root);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Access) return Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n+\n+   function Copy_Node (Source : Node_Access) return Node_Access is\n+      Element : Element_Access := new Element_Type'(Source.Element.all);\n+   begin\n+      return new Node_Type'(Parent  => null,\n+                            Left    => null,\n+                            Right   => null,\n+                            Color   => Source.Color,\n+                            Element => Element);\n+   exception\n+      when others =>\n+         Free_Element (Element);\n+         raise;\n+   end Copy_Node;\n+\n+   ---------------\n+   -- Copy_Tree --\n+   ---------------\n+\n+   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n+      Target_Root : Node_Access := Copy_Node (Source_Root);\n+      P, X        : Node_Access;\n+\n+   begin\n+      if Source_Root.Right /= null then\n+         Target_Root.Right := Copy_Tree (Source_Root.Right);\n+         Target_Root.Right.Parent := Target_Root;\n+      end if;\n+\n+      P := Target_Root;\n+      X := Source_Root.Left;\n+\n+      while X /= null loop\n+         declare\n+            Y : Node_Access := Copy_Node (X);\n+\n+         begin\n+            P.Left := Y;\n+            Y.Parent := P;\n+\n+            if X.Right /= null then\n+               Y.Right := Copy_Tree (X.Right);\n+               Y.Right.Parent := Y;\n+            end if;\n+\n+            P := Y;\n+            X := X.Left;\n+         end;\n+      end loop;\n+\n+      return Target_Root;\n+\n+   exception\n+      when others =>\n+         Delete_Tree (Target_Root);\n+         raise;\n+   end Copy_Tree;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Set; Position  : in out Cursor) is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Set; Item : Element_Type) is\n+      X : Node_Access :=\n+            Element_Keys.Find (Container.Tree, Item);\n+\n+   begin\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Delete_Node_Sans_Free (Container.Tree, X);\n+      Free (X);\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Set) is\n+      C : Cursor := First (Container);\n+   begin\n+      Delete (Container, C);\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Set) is\n+      C : Cursor := Last (Container);\n+   begin\n+      Delete (Container, C);\n+   end Delete_Last;\n+\n+   -----------------\n+   -- Delete_Tree --\n+   -----------------\n+\n+   procedure Delete_Tree (X : in out Node_Access) is\n+      Y : Node_Access;\n+   begin\n+      while X /= null loop\n+         Y := X.Right;\n+         Delete_Tree (Y);\n+         Y := X.Left;\n+         Free (X);\n+         X := Y;\n+      end loop;\n+   end Delete_Tree;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      Set_Ops.Difference (Target.Tree, Source.Tree);\n+   end Difference;\n+\n+   function Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+           Set_Ops.Difference (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type) is\n+      X : Node_Access :=\n+            Element_Keys.Find (Container.Tree, Item);\n+   begin\n+      if X /= null then\n+         Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Find (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+   begin\n+      if Container.Tree.First = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Set) return Element_Type is\n+   begin\n+      return Container.Tree.First.Element.all;\n+   end First_Element;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Node_Access :=\n+               Element_Keys.Floor (Container.Tree, Item);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Floor;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         Free_Element (X.Element);\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n+   ------------------\n+   -- Generic_Keys --\n+   ------------------\n+\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean;\n+      pragma Inline (Is_Greater_Key_Node);\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean;\n+      pragma Inline (Is_Less_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Red_Black_Trees.Generic_Keys\n+          (Tree_Operations     => Tree_Operations,\n+           Key_Type            => Key_Type,\n+           Is_Less_Key_Node    => Is_Less_Key_Node,\n+           Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+      ---------\n+      -- \"<\" --\n+      ---------\n+\n+      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n+      begin\n+         return Left < Right.Node.Element.all;\n+      end \"<\";\n+\n+      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n+      begin\n+         return Right > Left.Node.Element.all;\n+      end \"<\";\n+\n+      ---------\n+      -- \">\" --\n+      ---------\n+\n+      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n+      begin\n+         return Left > Right.Node.Element.all;\n+      end \">\";\n+\n+      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n+      begin\n+         return Right < Left.Node.Element.all;\n+      end \">\";\n+\n+      -------------\n+      -- Ceiling --\n+      -------------\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Ceiling (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Ceiling;\n+\n+      ----------------------------\n+      -- Checked_Update_Element --\n+      ----------------------------\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                        procedure (Element : in out Element_Type))\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n+\n+         begin\n+            Process (Position.Node.Element.all);\n+\n+            if Old_Key < Position.Node.Element.all\n+              or else Old_Key > Position.Node.Element.all\n+            then\n+               null;\n+            else\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            Result  : Node_Access;\n+            Success : Boolean;\n+\n+            function New_Node return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            procedure Insert_Post is\n+              new Key_Keys.Generic_Insert_Post (New_Node);\n+\n+            procedure Insert is\n+              new Key_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+            --------------\n+            -- New_Node --\n+            --------------\n+\n+            function New_Node return Node_Access is\n+            begin\n+               return Position.Node;\n+            end New_Node;\n+\n+         --  Start of processing for Checked_Update_Element\n+\n+         begin\n+            Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+\n+            Insert\n+              (Tree    => Container.Tree,\n+               Key     => Key (Position.Node.Element.all),\n+               Node    => Result,\n+               Success => Success);\n+\n+            if not Success then\n+               declare\n+                  X : Node_Access := Position.Node;\n+               begin\n+                  Free (X);\n+               end;\n+\n+               raise Program_Error;\n+            end if;\n+\n+            pragma Assert (Result = Position.Node);\n+         end;\n+      end Checked_Update_Element;\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type) is\n+         X : Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if X = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type is\n+         C : constant Cursor := Find (Container, Key);\n+      begin\n+         return C.Node.Element.all;\n+      end Element;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type) is\n+         X : Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if X /= null then\n+            Delete_Node_Sans_Free (Container.Tree, X);\n+            Free (X);\n+         end if;\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Find;\n+\n+      -----------\n+      -- Floor --\n+      -----------\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Floor (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+      end Floor;\n+\n+      -------------------------\n+      -- Is_Greater_Key_Node --\n+      -------------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean is\n+      begin\n+         return Left > Right.Element.all;\n+      end Is_Greater_Key_Node;\n+\n+      ----------------------\n+      -- Is_Less_Key_Node --\n+      ----------------------\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Access) return Boolean is\n+      begin\n+         return Left < Right.Element.all;\n+      end Is_Less_Key_Node;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element.all);\n+      end Key;\n+\n+   end Generic_Keys;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include (Container : in out Set; New_Item  : Element_Type) is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+      X : Element_Access;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         X := Position.Node.Element;\n+         Position.Node.Element := new Element_Type'(New_Item);\n+         Free_Element (X);\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Element : Element_Access := new Element_Type'(New_Item);\n+      begin\n+         return new Node_Type'(Parent  => null,\n+                               Left    => null,\n+                               Right   => null,\n+                               Color   => Red,\n+                               Element => Element);\n+      exception\n+         when others =>\n+            Free_Element (Element);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container.Tree,\n+         New_Item,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_With_Hint --\n+   ----------------------\n+\n+   procedure Insert_With_Hint\n+     (Dst_Tree : in out Tree_Type;\n+      Dst_Hint : Node_Access;\n+      Src_Node : Node_Access;\n+      Dst_Node : out Node_Access)\n+   is\n+      Success  : Boolean;\n+\n+      function New_Node return Node_Access;\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Insert_With_Hint is\n+         new Element_Keys.Generic_Conditional_Insert_With_Hint\n+            (Insert_Post,\n+             Insert_Sans_Hint);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Element : Element_Access :=\n+                     new Element_Type'(Src_Node.Element.all);\n+         Node    : Node_Access;\n+\n+      begin\n+         begin\n+            Node := new Node_Type;\n+         exception\n+            when others =>\n+               Free_Element (Element);\n+               raise;\n+         end;\n+\n+         Node.Element := Element;\n+         return Node;\n+      end New_Node;\n+\n+   --  Start of processing for Insert_With_Hint\n+\n+   begin\n+      Insert_With_Hint\n+        (Dst_Tree,\n+         Dst_Hint,\n+         Src_Node.Element.all,\n+         Dst_Node,\n+         Success);\n+   end Insert_With_Hint;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Set_Ops.Intersection (Target.Tree, Source.Tree);\n+   end Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Intersection (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -----------------------------\n+   -- Is_Greater_Element_Node --\n+   -----------------------------\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean is\n+   begin\n+      --  e > node same as node < e\n+\n+      return Right.Element.all < Left;\n+   end Is_Greater_Element_Node;\n+\n+\n+   --------------------------\n+   -- Is_Less_Element_Node --\n+   --------------------------\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Access) return Boolean is\n+   begin\n+      return Left < Right.Element.all;\n+   end Is_Less_Element_Node;\n+\n+   -----------------------\n+   -- Is_Less_Node_Node --\n+   -----------------------\n+\n+   function Is_Less_Node_Node (L, R : Node_Access) return Boolean is\n+   begin\n+      return L.Element.all < R.Element.all;\n+   end Is_Less_Node_Node;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      return Set_Ops.Is_Subset (Subset => Subset.Tree, Of_Set => Of_Set.Tree);\n+   end Is_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      Local_Iterate (Container.Tree);\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Set) return Cursor is\n+   begin\n+      if Container.Tree.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Set) return Element_Type is\n+   begin\n+      return Container.Tree.Last.Element.all;\n+   end Last_Element;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Left;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Tree.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Move (Target => Target.Tree, Source => Source.Tree);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access :=\n+           Tree_Operations.Next (Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Tree.Length /= 0;\n+      end if;\n+\n+      return Set_Ops.Overlap (Left.Tree, Right.Tree);\n+   end Overlap;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access :=\n+           Tree_Operations.Previous (Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Element.all);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : access Ada.Streams.Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      N : Count_Type'Base;\n+\n+      function New_Node return Node_Access;\n+\n+      procedure Read is\n+        new Tree_Operations.Generic_Read (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+         Node : Node_Access := new Node_Type;\n+\n+      begin\n+         Node.Element := new Element_Type'(Element_Type'Input (Stream));\n+         return Node;\n+\n+      exception\n+         when others =>\n+            Free (Node);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Clear (Container);\n+      Count_Type'Base'Read (Stream, N);\n+      pragma Assert (N >= 0);\n+      Read (Container.Tree, N);\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n+      Node : constant Node_Access :=\n+               Element_Keys.Find (Container.Tree, New_Item);\n+\n+      X : Element_Access;\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      X := Node.Element;\n+      Node.Element := new Element_Type'(New_Item);\n+      Free_Element (X);\n+   end Replace;\n+\n+--  TODO ???\n+--        procedure Replace\n+--          (Container : in out Set;\n+--           Key       : Key_Type;\n+--           New_Item  : Element_Type)\n+--        is\n+--           Node : Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+--        begin\n+--           if Node = null then\n+--              raise Constraint_Error;\n+--           end if;\n+\n+--           Replace_Element (Container, Node, New_Item);\n+--        end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+--  TODO: ???\n+--     procedure Replace_Element\n+--       (Container : in out Set;\n+--        Position  : Node_Access;\n+--        By        : Element_Type)\n+--   is\n+\n+--        Node : Node_Access := Position;\n+\n+--     begin\n+--        if By < Node.Element.all\n+--          or else Node.Element.all < By\n+--        then\n+--           null;\n+\n+--        else\n+--           declare\n+--              X : Element_Access := Node.Element;\n+\n+--           begin\n+--              Node.Element := new Element_Type'(By);\n+\n+--              --  NOTE: If there's an exception here, then just\n+--              --  let it propagate.  We haven't modified the\n+--              --  state of the container, so there's nothing else\n+--              --  we need to do.\n+\n+--              Free_Element (X);\n+--           end;\n+\n+--           return;\n+--        end if;\n+\n+--        Delete_Node_Sans_Free (Container.Tree, Node);\n+\n+--        begin\n+--           Free_Element (Node.Element);\n+--        exception\n+--           when others =>\n+--              Node.Element := null;  --  don't attempt to dealloc X.E again\n+--              Free (Node);\n+--              raise;\n+--        end;\n+\n+--        begin\n+--           Node.Element := new Element_Type'(By);\n+--        exception\n+--           when others =>\n+--              Free (Node);\n+--              raise;\n+--        end;\n+\n+--        declare\n+--           function New_Node return Node_Access;\n+--           pragma Inline (New_Node);\n+\n+--           function New_Node return Node_Access is\n+--           begin\n+--              return Node;\n+--           end New_Node;\n+\n+--           procedure Insert_Post is\n+--             new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+--           procedure Insert is\n+--             new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+--           Result  : Node_Access;\n+--           Success : Boolean;\n+\n+--        begin\n+--           Insert\n+--             (Tree    => Container.Tree,\n+--              Key     => Node.Element.all,\n+--              Node    => Result,\n+--              Success => Success);\n+\n+--           if not Success then\n+--              Free (Node);\n+--              raise Program_Error;\n+--           end if;\n+\n+--           pragma Assert (Result = Node);\n+--        end;\n+--     end Replace_Element;\n+\n+\n+--     procedure Replace_Element\n+--      (Container : in out Set;\n+--       Position  : Cursor;\n+--       By        : Element_Type)\n+--     is\n+--     begin\n+--        if Position.Container = null then\n+--           raise Constraint_Error;\n+--        end if;\n+\n+--        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+--           raise Program_Error;\n+--        end if;\n+\n+--        Replace_Element (Container, Position.Node, By);\n+--     end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+         new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      Local_Reverse_Iterate (Container.Tree);\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Right;\n+   end Right;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color (Node : Node_Access; Color : Color_Type) is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : Node_Access; Left : Node_Access) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : Node_Access; Parent : Node_Access) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : Node_Access; Right : Node_Access) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      Set_Ops.Symmetric_Difference (Target.Tree, Source.Tree);\n+   end Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Symmetric_Difference;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union (Target : in out Set; Source : Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Set_Ops.Union (Target.Tree, Source.Tree);\n+   end Union;\n+\n+   function Union (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Tree : constant Tree_Type :=\n+                  Set_Ops.Union (Left.Tree, Right.Tree);\n+      begin\n+         return (Controlled with Tree);\n+      end;\n+   end Union;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : access Ada.Streams.Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Process (Node : Node_Access);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is\n+        new Tree_Operations.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Node : Node_Access) is\n+      begin\n+         Element_Type'Output (Stream, Node.Element.all);\n+      end Process;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Container.Tree.Length);\n+      Iterate (Container.Tree);\n+   end Write;\n+\n+end Ada.Containers.Indefinite_Ordered_Sets;\n+\n+"}, {"sha": "e05dc1a6638882d2c7767c50188039257662a636", "filename": "gcc/ada/a-ciorse.ads", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,296 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                  ADA.CONTAINERS.INDEFINITE_ORDERED_SETS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees;\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+   type Element_Type (<>) is private;\n+\n+   with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Ordered_Sets is\n+pragma Preelaborate (Indefinite_Ordered_Sets);\n+\n+   type Set is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   --  TODO: resolve in Atlanta???\n+   --   procedure Replace_Element\n+   --     (Container : in out Set;\n+   --      Position  : Cursor;\n+   --      By        : Element_Type);\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Set);\n+\n+   procedure Delete_Last (Container : in out Set);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set;\n+                         Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function First_Element (Container : Set) return Element_Type;\n+\n+   function Last (Container : Set) return Cursor;\n+\n+   function Last_Element (Container : Set) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean;\n+\n+   function \">\" (Left, Right : Cursor) return Boolean;\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      type Key_Type (<>) is limited private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function \"<\" (Left : Key_Type; Right : Element_Type)\n+          return Boolean is <>;\n+\n+      with function \">\" (Left : Key_Type; Right : Element_Type)\n+          return Boolean is <>;\n+\n+   package Generic_Keys is\n+\n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean;\n+\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor;\n+\n+      function Floor\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor;\n+\n+      function Ceiling\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type;\n+\n+      --  TODO: resolve in Atlanta???\n+      --      procedure Replace\n+      --        (Container : in out Set;\n+      --         Key       : Key_Type;\n+      --         New_Item  : Element_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+      --  TODO: resolve name in Atlanta???\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+\n+   end Generic_Keys;\n+\n+private\n+\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package Tree_Types is\n+     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Set is new Controlled with record\n+      Tree : Tree_Type := (Length => 0, others => null);\n+   end record;\n+\n+   procedure Adjust (Container : in out Set);\n+\n+   procedure Finalize (Container : in out Set) renames Clear;\n+\n+   type Set_Access is access constant Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Set_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set :=\n+                 (Controlled with Tree => (Length => 0, others => null));\n+\n+end Ada.Containers.Indefinite_Ordered_Sets;"}, {"sha": "e1120c1b3577a19838b6e34629a10d4b5f7867b6", "filename": "gcc/ada/a-cohama.adb", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,663 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        ADA.CONTAINERS.HASHED_MAPS                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Hash_Tables.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n+\n+package body Ada.Containers.Hashed_Maps is\n+\n+   type Node_Type is limited record\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+      Next    : Node_Access;\n+   end record;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Find_Equal_Key\n+     (R_Map  : Map;\n+      L_Node : Node_Access) return Boolean;\n+\n+   function Hash_Node (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Next (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n+\n+   function Read_Node\n+     (Stream : access Root_Stream_Type'Class) return Node_Access;\n+   pragma Inline (Read_Node);\n+\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access);\n+   pragma Inline (Set_Next);\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access);\n+   pragma Inline (Write_Node);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   package HT_Ops is\n+      new Hash_Tables.Generic_Operations\n+       (HT_Types          => HT_Types,\n+        Hash_Table_Type   => Map,\n+        Null_Node         => null,\n+        Hash_Node         => Hash_Node,\n+        Next              => Next,\n+        Set_Next          => Set_Next,\n+        Copy_Node         => Copy_Node,\n+        Free              => Free);\n+\n+   package Key_Ops is\n+      new Hash_Tables.Generic_Keys\n+       (HT_Types  => HT_Types,\n+        HT_Type   => Map,\n+        Null_Node => null,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Key_Type  => Key_Type,\n+        Hash      => Hash,\n+        Equivalent_Keys => Equivalent_Keys);\n+\n+   function Is_Equal is new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+   procedure Read_Nodes  is new HT_Ops.Generic_Read (Read_Node);\n+   procedure Write_Nodes is new HT_Ops.Generic_Write (Write_Node);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean renames Is_Equal;\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Map) renames HT_Ops.Adjust;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Map) return Count_Type\n+     renames HT_Ops.Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) renames HT_Ops.Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access\n+   is\n+      Target : constant Node_Access :=\n+                 new Node_Type'(Key     => Source.Key,\n+                                Element => Source.Element,\n+                                Next    => null);\n+   begin\n+      return Target;\n+   end Copy_Node;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access;\n+\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Free (X);\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      C : constant Cursor := Find (Container, Key);\n+   begin\n+      return C.Node.Element;\n+   end Element;\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Access) return Boolean is\n+   begin\n+      return Equivalent_Keys (Key, Node.Key);\n+   end Equivalent_Keys;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Key, Right.Node.Key);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Key, Right);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      return Equivalent_Keys (Left, Right.Node.Key);\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : Node_Access;\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Free (X);\n+   end Exclude;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Container : in out Map) renames HT_Ops.Finalize;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end Find;\n+\n+   --------------------\n+   -- Find_Equal_Key --\n+   --------------------\n+\n+   function Find_Equal_Key\n+     (R_Map  : Map;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type := Key_Ops.Index (R_Map, L_Node.Key);\n+      R_Node  : Node_Access := R_Map.Buckets (R_Index);\n+\n+   begin\n+      while R_Node /= null loop\n+         if Equivalent_Keys (L_Node.Key, R_Node.Key) then\n+            return L_Node.Element = R_Node.Element;\n+         end if;\n+\n+         R_Node := R_Node.Next;\n+      end loop;\n+\n+      return False;\n+   end Find_Equal_Key;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container);\n+\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end First;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Access) return Hash_Type is\n+   begin\n+      return Hash (Node.Key);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         Position.Node.Key := Key;\n+         Position.Node.Element := New_Item;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Node : Node_Access := new Node_Type; --  Ada 2005 aggregate possible?\n+\n+      begin\n+         Node.Key := Key;\n+         Node.Next := Next;\n+\n+         return Node;\n+\n+      exception\n+         when others =>\n+            Free (Node);\n+            raise;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Node : constant Node_Access := new Node_Type'(Key, New_Item, Next);\n+      begin\n+         return Node;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      Local_Iterate (Container);\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Cursor) return Key_Type is\n+   begin\n+      return Position.Node.Key;\n+   end Key;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Map;\n+      Source : in out Map) renames HT_Ops.Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         M    : Map renames Position.Container.all;\n+         Node : constant Node_Access := HT_Ops.Next (M, Position.Node);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key, Position.Node.Element);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map) renames Read_Nodes;\n+\n+   ---------------\n+   -- Read_Node --\n+   ---------------\n+\n+   function Read_Node\n+     (Stream : access Root_Stream_Type'Class) return Node_Access\n+   is\n+      Node : Node_Access := new Node_Type;\n+\n+   begin\n+      Key_Type'Read (Stream, Node.Key);\n+      Element_Type'Read (Stream, Node.Element);\n+      return Node;\n+\n+   exception\n+      when others =>\n+         Free (Node);\n+         raise;\n+   end Read_Node;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Node.Key := Key;\n+      Node.Element := New_Item;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+   begin\n+      Position.Node.Element := By;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type) renames HT_Ops.Ensure_Capacity;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      Process (Position.Node.Key, Position.Node.Element);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map) renames Write_Nodes;\n+\n+   ----------------\n+   -- Write_Node --\n+   ----------------\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access)\n+   is\n+   begin\n+      Key_Type'Write (Stream, Node.Key);\n+      Element_Type'Write (Stream, Node.Element);\n+   end Write_Node;\n+\n+end Ada.Containers.Hashed_Maps;"}, {"sha": "72dd1c2b107785fe62a2c785a36a7d1bddae1308", "filename": "gcc/ada/a-cohama.ads", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,193 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        ADA.CONTAINERS.HASHED_MAPS                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables;\n+with Ada.Streams;\n+\n+generic\n+   type Key_Type is private;\n+\n+   type Element_Type is private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+\n+   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Hashed_Maps is\n+pragma Preelaborate (Hashed_Maps);\n+\n+   type Map is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Map : constant Map;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   procedure Clear (Container : in out Map);\n+\n+   function Element (Position : Cursor)\n+      return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : in out Element_Type));\n+\n+   procedure Replace_Element (Position : Cursor; By : Element_Type);\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity (Container : in out Map;\n+                               Capacity  : Count_Type);\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Key (Position : Cursor) return Key_Type;\n+\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+   function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package HT_Types is new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+\n+   use HT_Types;\n+\n+   type Map is new Hash_Table_Type with null record;\n+\n+   procedure Adjust (Container : in out Map);\n+\n+   procedure Finalize (Container : in out Map);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   Empty_Map : constant Map := (Hash_Table_Type with null record);\n+\n+   type Map_Access is access constant Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : Map_Access;\n+         Node      : Node_Access;\n+      end record;\n+\n+   No_Element : constant Cursor := (Container => null, Node => null);\n+\n+end Ada.Containers.Hashed_Maps;"}, {"sha": "58d04febfd1f3b9b700b3a39e6a7bc34362f7288", "filename": "gcc/ada/a-cohase.adb", "status": "added", "additions": 1418, "deletions": 0, "changes": 1418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,1418 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        ADA.CONTAINERS.HASHED_SETS                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit has originally being developed by Matthew J Heaney.            --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Containers.Hash_Tables.Generic_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n+\n+with System;  use type System.Address;\n+\n+with Ada.Containers.Prime_Numbers;\n+\n+with Ada.Finalization;  use Ada.Finalization;\n+\n+package body Ada.Containers.Hashed_Sets is\n+\n+   type Node_Type is\n+      limited record\n+         Element : Element_Type;\n+         Next    : Node_Access;\n+      end record;\n+\n+   function Hash_Node\n+     (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Hash_Node\n+     (Node : Node_Access) return Hash_Type is\n+   begin\n+      return Hash (Node.Element);\n+   end Hash_Node;\n+\n+   function Next\n+     (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n+\n+   function Next\n+     (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access);\n+   pragma Inline (Set_Next);\n+\n+   procedure Set_Next\n+     (Node : Node_Access;\n+      Next : Node_Access) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean is\n+   begin\n+      return Equivalent_Keys (Key, Node.Element);\n+   end Equivalent_Keys;\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n+\n+   function Copy_Node\n+     (Source : Node_Access) return Node_Access is\n+\n+      Target : constant Node_Access :=\n+        new Node_Type'(Element => Source.Element,\n+                       Next    => null);\n+   begin\n+      return Target;\n+   end Copy_Node;\n+\n+\n+   procedure Free is\n+      new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   package HT_Ops is\n+      new Hash_Tables.Generic_Operations\n+       (HT_Types          => HT_Types,\n+        Hash_Table_Type   => Set,\n+        Null_Node         => null,\n+        Hash_Node         => Hash_Node,\n+        Next              => Next,\n+        Set_Next          => Set_Next,\n+        Copy_Node         => Copy_Node,\n+        Free              => Free);\n+\n+   package Element_Keys is\n+      new Hash_Tables.Generic_Keys\n+       (HT_Types  => HT_Types,\n+        HT_Type   => Set,\n+        Null_Node => null,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Key_Type  => Element_Type,\n+        Hash      => Hash,\n+        Equivalent_Keys => Equivalent_Keys);\n+\n+\n+   procedure Adjust (Container : in out Set) renames HT_Ops.Adjust;\n+\n+   procedure Finalize (Container : in out Set) renames HT_Ops.Finalize;\n+\n+\n+   function Find_Equal_Key\n+     (R_Set  : Set;\n+      L_Node : Node_Access) return Boolean;\n+\n+   function Find_Equal_Key\n+     (R_Set  : Set;\n+      L_Node : Node_Access) return Boolean is\n+\n+      R_Index : constant Hash_Type :=\n+        Element_Keys.Index (R_Set, L_Node.Element);\n+\n+      R_Node  : Node_Access := R_Set.Buckets (R_Index);\n+\n+   begin\n+\n+      loop\n+\n+         if R_Node = null then\n+            return False;\n+         end if;\n+\n+         if L_Node.Element = R_Node.Element then\n+            --  pragma Assert (Is_Equal_Key (L_Node.Element, R_Node.Element));\n+            return True;\n+         end if;\n+\n+         R_Node := Next (R_Node);\n+\n+      end loop;\n+\n+   end Find_Equal_Key;\n+\n+   function Is_Equal is\n+      new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+   function \"=\" (Left, Right : Set) return Boolean renames Is_Equal;\n+\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+\n+   procedure Clear (Container : in out Set) renames HT_Ops.Clear;\n+\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element;\n+   end Element;\n+\n+\n+   procedure Query_Element\n+     (Position : in Cursor;\n+      Process  : not null access procedure (Element : in Element_Type)) is\n+   begin\n+      Process (Position.Node.Element);\n+   end Query_Element;\n+\n+\n+--  TODO:\n+--     procedure Replace_Element (Container : in out Set;\n+--                                Position  : in     Node_Access;\n+--                                By        : in     Element_Type) is\n+\n+--        Node : Node_Access := Position;\n+\n+--     begin\n+\n+--        if Equivalent_Keys (Node.Element, By) then\n+\n+--           begin\n+--              Node.Element := By;\n+--           exception\n+--              when others =>\n+--                 HT_Ops.Delete_Node_Sans_Free (Container, Node);\n+--                 Free (Node);\n+--                 raise;\n+--           end;\n+\n+--           return;\n+\n+--        end if;\n+\n+--        HT_Ops.Delete_Node_Sans_Free (Container, Node);\n+\n+--        begin\n+--           Node.Element := By;\n+--        exception\n+--           when others =>\n+--              Free (Node);\n+--              raise;\n+--        end;\n+\n+--        declare\n+--           function New_Node (Next : Node_Access) return Node_Access;\n+--           pragma Inline (New_Node);\n+\n+--           function New_Node (Next : Node_Access) return Node_Access is\n+--           begin\n+--              Node.Next := Next;\n+--              return Node;\n+--           end New_Node;\n+\n+--           procedure Insert is\n+--              new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+--           Result  : Node_Access;\n+--           Success : Boolean;\n+--        begin\n+--           Insert\n+--             (HT      => Container,\n+--              Key     => Node.Element,\n+--              Node    => Result,\n+--              Success => Success);\n+\n+--           if not Success then\n+--              Free (Node);\n+--              raise Program_Error;\n+--           end if;\n+\n+--           pragma Assert (Result = Node);\n+--        end;\n+\n+--     end Replace_Element;\n+\n+\n+--     procedure Replace_Element (Container : in out Set;\n+--                                Position  : in     Cursor;\n+--                                By        : in     Element_Type) is\n+--     begin\n+\n+--        if Position.Container = null then\n+--           raise Constraint_Error;\n+--        end if;\n+\n+--        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+--           raise Program_Error;\n+--        end if;\n+\n+--        Replace_Element (Container, Position.Node, By);\n+\n+--     end Replace_Element;\n+\n+\n+   procedure Move (Target : in out Set;\n+                   Source : in out Set) renames HT_Ops.Move;\n+\n+\n+   procedure Insert (Container : in out Set;\n+                     New_Item  : in     Element_Type;\n+                     Position  :    out Cursor;\n+                     Inserted  :    out Boolean) is\n+\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Node : constant Node_Access := new Node_Type'(New_Item, Next);\n+      begin\n+         return Node;\n+      end New_Node;\n+\n+      procedure Insert is\n+        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+   begin\n+\n+      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n+      Insert (Container, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+\n+   end Insert;\n+\n+\n+   procedure Insert (Container : in out Set;\n+                     New_Item  : in     Element_Type) is\n+\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+\n+   end Insert;\n+\n+\n+   procedure Replace (Container : in out Set;\n+                      New_Item  : in     Element_Type) is\n+\n+      X : Node_Access := Element_Keys.Find (Container, New_Item);\n+\n+   begin\n+\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      X.Element := New_Item;\n+\n+   end Replace;\n+\n+\n+   procedure Include (Container : in out Set;\n+                      New_Item  : in     Element_Type) is\n+\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         Position.Node.Element := New_Item;\n+      end if;\n+\n+   end Include;\n+\n+\n+   procedure Delete (Container : in out Set;\n+                     Item      : in     Element_Type) is\n+\n+      X : Node_Access;\n+\n+   begin\n+\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Free (X);\n+\n+   end Delete;\n+\n+\n+   procedure Exclude (Container : in out Set;\n+                      Item      : in     Element_Type) is\n+\n+      X : Node_Access;\n+\n+   begin\n+\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      Free (X);\n+\n+   end Exclude;\n+\n+\n+   procedure Delete (Container : in out Set;\n+                     Position  : in out Cursor) is\n+   begin\n+\n+      if Position = No_Element then\n+         return;\n+      end if;\n+\n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      Free (Position.Node);\n+\n+      Position.Container := null;\n+\n+   end Delete;\n+\n+\n+\n+   procedure Union (Target : in out Set;\n+                    Source : in     Set) is\n+\n+      procedure Process (Src_Node : in Node_Access);\n+\n+      procedure Process (Src_Node : in Node_Access) is\n+\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n+\n+         function New_Node (Next : Node_Access) return Node_Access is\n+            Node : constant Node_Access :=\n+              new Node_Type'(Src_Node.Element, Next);\n+         begin\n+            return Node;\n+         end New_Node;\n+\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+         Tgt_Node : Node_Access;\n+         Success  : Boolean;\n+\n+      begin\n+\n+         Insert (Target, Src_Node.Element, Tgt_Node, Success);\n+\n+      end Process;\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+\n+      Iterate (Source);\n+\n+   end Union;\n+\n+\n+\n+   function Union (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type :=\n+           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+            I : constant Hash_Type :=\n+              Hash (L_Node.Element) mod Buckets'Length;\n+         begin\n+            Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      Length := Left.Length;\n+\n+      declare\n+         procedure Process (Src_Node : Node_Access);\n+\n+         procedure Process (Src_Node : Node_Access) is\n+\n+            I : constant Hash_Type :=\n+              Hash (Src_Node.Element) mod Buckets'Length;\n+\n+            Tgt_Node : Node_Access := Buckets (I);\n+\n+         begin\n+\n+            while Tgt_Node /= null loop\n+\n+               if Equivalent_Keys (Src_Node.Element, Tgt_Node.Element) then\n+                  return;\n+               end if;\n+\n+               Tgt_Node := Next (Tgt_Node);\n+\n+            end loop;\n+\n+            Buckets (I) := new Node_Type'(Src_Node.Element, Buckets (I));\n+            Length := Length + 1;\n+\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Right);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Union;\n+\n+\n+   function Is_In\n+     (HT  : Set;\n+      Key : Node_Access) return Boolean;\n+   pragma Inline (Is_In);\n+\n+   function Is_In\n+     (HT  : Set;\n+      Key : Node_Access) return Boolean is\n+   begin\n+      return Element_Keys.Find (HT, Key.Element) /= null;\n+   end Is_In;\n+\n+\n+   procedure Intersection (Target : in out Set;\n+                           Source : in     Set) is\n+\n+      Tgt_Node : Node_Access;\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      --  TODO: optimize this to use an explicit\n+      --  loop instead of an active iterator\n+      --  (similar to how a passive iterator is\n+      --  implemented).\n+      --\n+      --  Another possibility is to test which\n+      --  set is smaller, and iterate over the\n+      --  smaller set.\n+\n+      Tgt_Node := HT_Ops.First (Target);\n+\n+      while Tgt_Node /= null loop\n+\n+         if Is_In (Source, Tgt_Node) then\n+\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+\n+         else\n+\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Free (X);\n+            end;\n+\n+         end if;\n+\n+      end loop;\n+\n+   end Intersection;\n+\n+\n+   function Intersection (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      Length := Count_Type'Min (Left.Length, Right.Length);\n+\n+      if Length = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if Is_In (Right, L_Node) then\n+\n+               declare\n+                  I : constant Hash_Type :=\n+                    Hash (L_Node.Element) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+               end;\n+\n+               Length := Length + 1;\n+\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Intersection;\n+\n+\n+   procedure Difference (Target : in out Set;\n+                         Source : in     Set) is\n+\n+\n+      Tgt_Node : Node_Access;\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      --  TODO: As I noted above, this can be\n+      --  written in terms of a loop instead as\n+      --  active-iterator style, sort of like a\n+      --  passive iterator.\n+\n+      Tgt_Node := HT_Ops.First (Target);\n+\n+      while Tgt_Node /= null loop\n+\n+         if Is_In (Source, Tgt_Node) then\n+\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Free (X);\n+            end;\n+\n+         else\n+\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+\n+         end if;\n+\n+      end loop;\n+\n+   end Difference;\n+\n+\n+\n+   function Difference (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right, L_Node) then\n+\n+               declare\n+                  I : constant Hash_Type :=\n+                    Hash (L_Node.Element) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+               end;\n+\n+               Length := Length + 1;\n+\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Difference;\n+\n+\n+\n+   procedure Symmetric_Difference (Target : in out Set;\n+                                   Source : in     Set) is\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+\n+      if Target.Length = 0 then\n+\n+         declare\n+            procedure Process (Src_Node : Node_Access);\n+\n+            procedure Process (Src_Node : Node_Access) is\n+               E : Element_Type renames Src_Node.Element;\n+               B : Buckets_Type renames Target.Buckets.all;\n+               I : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.Length;\n+            begin\n+               B (I) := new Node_Type'(E, B (I));\n+               N := N + 1;\n+            end Process;\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+         begin\n+            Iterate (Source);\n+         end;\n+\n+      else\n+\n+         declare\n+            procedure Process (Src_Node : Node_Access);\n+\n+            procedure Process (Src_Node : Node_Access) is\n+               E : Element_Type renames Src_Node.Element;\n+               B : Buckets_Type renames Target.Buckets.all;\n+               I : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.Length;\n+            begin\n+               if B (I) = null then\n+\n+                  B (I) := new Node_Type'(E, null);\n+                  N := N + 1;\n+\n+               elsif Equivalent_Keys (E, B (I).Element) then\n+\n+                  declare\n+                     X : Node_Access := B (I);\n+                  begin\n+                     B (I) := B (I).Next;\n+                     N := N - 1;\n+                     Free (X);\n+                  end;\n+\n+               else\n+\n+                  declare\n+                     Prev : Node_Access := B (I);\n+                     Curr : Node_Access := Prev.Next;\n+                  begin\n+                     while Curr /= null loop\n+                        if Equivalent_Keys (E, Curr.Element) then\n+                           Prev.Next := Curr.Next;\n+                           N := N - 1;\n+                           Free (Curr);\n+                           return;\n+                        end if;\n+\n+                        Prev := Curr;\n+                        Curr := Prev.Next;\n+                     end loop;\n+\n+                     B (I) := new Node_Type'(E, B (I));\n+                     N := N + 1;\n+                  end;\n+\n+               end if;\n+            end Process;\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+         begin\n+            Iterate (Source);\n+         end;\n+\n+      end if;\n+\n+   end Symmetric_Difference;\n+\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n+\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      declare\n+         Size : constant Hash_Type :=\n+           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n+\n+      Length := 0;\n+\n+      declare\n+         procedure Process (L_Node : Node_Access);\n+\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right, L_Node) then\n+               declare\n+                  E : Element_Type renames L_Node.Element;\n+                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(E, Buckets (I));\n+                  Length := Length + 1;\n+               end;\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Left);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      declare\n+         procedure Process (R_Node : Node_Access);\n+\n+         procedure Process (R_Node : Node_Access) is\n+         begin\n+            if not Is_In (Left, R_Node) then\n+               declare\n+                  E : Element_Type renames R_Node.Element;\n+                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+               begin\n+                  Buckets (I) := new Node_Type'(E, Buckets (I));\n+                  Length := Length + 1;\n+               end;\n+            end if;\n+         end Process;\n+\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+      begin\n+         Iterate (Right);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end;\n+\n+      return (Controlled with Buckets, Length);\n+\n+   end Symmetric_Difference;\n+\n+\n+   function Is_Subset (Subset : Set;\n+                       Of_Set : Set) return Boolean is\n+\n+      Subset_Node : Node_Access;\n+\n+   begin\n+\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n+      end if;\n+\n+      --  TODO: rewrite this to loop in the\n+      --  style of a passive iterator.\n+\n+      Subset_Node := HT_Ops.First (Subset);\n+\n+      while Subset_Node /= null loop\n+         if not Is_In (Of_Set, Subset_Node) then\n+            return False;\n+         end if;\n+\n+         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n+      end loop;\n+\n+      return True;\n+\n+   end Is_Subset;\n+\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+\n+      Left_Node : Node_Access;\n+\n+   begin\n+\n+      if Right.Length = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := HT_Ops.First (Left);\n+\n+      while Left_Node /= null loop\n+         if Is_In (Right, Left_Node) then\n+            return True;\n+         end if;\n+\n+         Left_Node := HT_Ops.Next (Left, Left_Node);\n+      end loop;\n+\n+      return False;\n+\n+   end Overlap;\n+\n+\n+   function Find (Container : Set;\n+                  Item      : Element_Type) return Cursor is\n+\n+      Node : constant Node_Access := Element_Keys.Find (Container, Item);\n+\n+   begin\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+\n+   end Find;\n+\n+\n+   function Contains (Container : Set;\n+                      Item      : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+\n+\n+   function First (Container : Set) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container);\n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Node);\n+   end First;\n+\n+\n+--     function First_Element (Container : Set) return Element_Type is\n+--        Node : constant Node_Access := HT_Ops.First (Container);\n+--     begin\n+--        return Node.Element;\n+--     end First_Element;\n+\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null\n+        or else Position.Node = null\n+      then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+         Node : constant Node_Access := HT_Ops.Next (S, Position.Node);\n+      begin\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node = null then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Has_Element;\n+\n+\n+   function Equivalent_Keys (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Element, Right.Node.Element);\n+   end Equivalent_Keys;\n+\n+\n+   function Equivalent_Keys (Left  : Cursor;\n+                             Right : Element_Type)\n+    return Boolean is\n+   begin\n+      return Equivalent_Keys (Left.Node.Element, Right);\n+   end Equivalent_Keys;\n+\n+\n+   function Equivalent_Keys (Left  : Element_Type;\n+                             Right : Cursor)\n+    return Boolean is\n+   begin\n+      return Equivalent_Keys (Left, Right.Node.Element);\n+   end Equivalent_Keys;\n+\n+\n+   procedure Iterate\n+     (Container : in Set;\n+      Process   : not null access procedure (Position : in Cursor)) is\n+\n+      procedure Process_Node (Node : in Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Process_Node (Node : in Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unchecked_Access, Node));\n+      end Process_Node;\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n+   begin\n+      Iterate (Container);\n+   end Iterate;\n+\n+\n+   function Capacity (Container : Set) return Count_Type\n+     renames HT_Ops.Capacity;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : in     Count_Type)\n+     renames HT_Ops.Ensure_Capacity;\n+\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : in     Node_Access);\n+   pragma Inline (Write_Node);\n+\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : in     Node_Access) is\n+   begin\n+      Element_Type'Write (Stream, Node.Element);\n+   end Write_Node;\n+\n+   procedure Write_Nodes is\n+      new HT_Ops.Generic_Write (Write_Node);\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : in     Set) renames Write_Nodes;\n+\n+\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access;\n+   pragma Inline (Read_Node);\n+\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access is\n+\n+      Node : Node_Access := new Node_Type;\n+   begin\n+      Element_Type'Read (Stream, Node.Element);\n+      return Node;\n+   exception\n+      when others =>\n+         Free (Node);\n+         raise;\n+   end Read_Node;\n+\n+   procedure Read_Nodes is\n+      new HT_Ops.Generic_Read (Read_Node);\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container :    out Set) renames Read_Nodes;\n+\n+\n+   package body Generic_Keys is\n+\n+      function Equivalent_Keys (Left  : Cursor;\n+                                Right : Key_Type)\n+        return Boolean is\n+      begin\n+         return Equivalent_Keys (Right, Left.Node.Element);\n+      end Equivalent_Keys;\n+\n+      function Equivalent_Keys (Left  : Key_Type;\n+                                Right : Cursor)\n+        return Boolean is\n+      begin\n+         return Equivalent_Keys (Left, Right.Node.Element);\n+      end Equivalent_Keys;\n+\n+      function Equivalent_Keys\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean;\n+      pragma Inline (Equivalent_Keys);\n+\n+      function Equivalent_Keys\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean is\n+      begin\n+         return Equivalent_Keys (Key, Node.Element);\n+      end Equivalent_Keys;\n+\n+      package Key_Keys is\n+         new Hash_Tables.Generic_Keys\n+          (HT_Types  => HT_Types,\n+           HT_Type   => Set,\n+           Null_Node => null,\n+           Next      => Next,\n+           Set_Next  => Set_Next,\n+           Key_Type  => Key_Type,\n+           Hash      => Hash,\n+           Equivalent_Keys => Equivalent_Keys);\n+\n+\n+      function Find (Container : Set;\n+                     Key       : Key_Type)\n+         return Cursor is\n+\n+         Node : constant Node_Access :=\n+           Key_Keys.Find (Container, Key);\n+\n+      begin\n+\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unchecked_Access, Node);\n+\n+      end Find;\n+\n+\n+      function Contains (Container : Set;\n+                         Key       : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+\n+      function Element (Container : Set;\n+                        Key       : Key_Type)\n+        return Element_Type is\n+\n+         Node : constant Node_Access := Key_Keys.Find (Container, Key);\n+      begin\n+         return Node.Element;\n+      end Element;\n+\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element);\n+      end Key;\n+\n+\n+--  TODO:\n+--        procedure Replace (Container : in out Set;\n+--                           Key       : in     Key_Type;\n+--                           New_Item  : in     Element_Type) is\n+\n+--           Node : constant Node_Access :=\n+--             Key_Keys.Find (Container, Key);\n+\n+--        begin\n+\n+--           if Node = null then\n+--              raise Constraint_Error;\n+--           end if;\n+\n+--           Replace_Element (Container, Node, New_Item);\n+\n+--        end Replace;\n+\n+\n+      procedure Delete (Container : in out Set;\n+                        Key       : in     Key_Type) is\n+\n+         X : Node_Access;\n+\n+      begin\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+\n+         if X = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Free (X);\n+\n+      end Delete;\n+\n+\n+      procedure Exclude (Container : in out Set;\n+                         Key       : in     Key_Type) is\n+\n+         X : Node_Access;\n+\n+      begin\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Free (X);\n+\n+      end Exclude;\n+\n+\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : in     Cursor;\n+         Process   : not null access\n+           procedure (Element : in out Element_Type)) is\n+\n+      begin\n+\n+         if Position.Container = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            Old_Key : Key_Type renames Key (Position.Node.Element);\n+         begin\n+            Process (Position.Node.Element);\n+\n+            if Equivalent_Keys (Old_Key, Position.Node.Element) then\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            function New_Node (Next : Node_Access) return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            function New_Node (Next : Node_Access) return Node_Access is\n+            begin\n+               Position.Node.Next := Next;\n+               return Position.Node;\n+            end New_Node;\n+\n+            procedure Insert is\n+               new Key_Keys.Generic_Conditional_Insert (New_Node);\n+\n+            Result  : Node_Access;\n+            Success : Boolean;\n+         begin\n+            HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+\n+            Insert\n+              (HT      => Container,\n+               Key     => Key (Position.Node.Element),\n+               Node    => Result,\n+               Success => Success);\n+\n+            if not Success then\n+               declare\n+                  X : Node_Access := Position.Node;\n+               begin\n+                  Free (X);\n+               end;\n+\n+               raise Program_Error;\n+            end if;\n+\n+            pragma Assert (Result = Position.Node);\n+         end;\n+\n+      end Checked_Update_Element;\n+\n+   end Generic_Keys;\n+\n+end Ada.Containers.Hashed_Sets;"}, {"sha": "9f0cdc387476cfc241db28f427c660ed7c3390b7", "filename": "gcc/ada/a-cohase.ads", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        ADA.CONTAINERS.HASHED_SETS                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables;\n+with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function Hash (Element : Element_Type) return Hash_Type;\n+\n+   --  TODO: get a ruling from ARG in Atlanta re the name and\n+   --  order of these declarations. ???\n+   --\n+   with function Equivalent_Keys (Left, Right : Element_Type) return Boolean;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Hashed_Sets is\n+pragma Preelaborate (Hashed_Sets);\n+\n+   type Set is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   --  TODO: resolve in atlanta\n+   --   procedure Replace_Element\n+   --     (Container : in out Set;\n+   --      Position  : Cursor;\n+   --      By        : Element_Type);\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Delete  (Container : in out Set; Item     : Element_Type);\n+\n+   procedure Exclude (Container : in out Set; Item     : Element_Type);\n+\n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set\n+     renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor;\n+\n+   function Capacity (Container : Set) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type);\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      type Key_Type (<>) is limited private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function Hash (Key : Key_Type) return Hash_Type;\n+\n+      with function Equivalent_Keys\n+        (Key     : Key_Type;\n+         Element : Element_Type) return Boolean;\n+\n+   package Generic_Keys is\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      --  TODO: resolve in atlanta\n+      --      procedure Replace\n+      --        (Container : in out Set;\n+      --         Key       : Key_Type;\n+      --         New_Item  : Element_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      --  TODO: resolve name in atlanta: ???\n+      procedure Checked_Update_Element\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+\n+      function Equivalent_Keys\n+        (Left  : Cursor;\n+         Right : Key_Type) return Boolean;\n+\n+      function Equivalent_Keys\n+        (Left  : Key_Type;\n+         Right : Cursor) return Boolean;\n+\n+   end Generic_Keys;\n+\n+private\n+\n+   type Node_Type;\n+   type Node_Access is access Node_Type;\n+\n+   package HT_Types is\n+     new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+\n+   use HT_Types;\n+\n+   type Set is new Hash_Table_Type with null record;\n+\n+   procedure Adjust (Container : in out Set);\n+\n+   procedure Finalize (Container : in out Set);\n+\n+   type Set_Access is access constant Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Set_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   No_Element : constant Cursor := (Container => null, Node => null);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set := (Hash_Table_Type with null record);\n+\n+end Ada.Containers.Hashed_Sets;"}, {"sha": "068efc6a2a87b3d5c722d9b4e473cf9d4806d380", "filename": "gcc/ada/a-cohata.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohata.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                        ADA.CONTAINERS.HASH_TABLES                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+\n+package Ada.Containers.Hash_Tables is\n+pragma Preelaborate;\n+\n+   generic\n+      type Node_Access is private;\n+\n+   package Generic_Hash_Table_Types is\n+      type Buckets_Type is array (Hash_Type range <>) of Node_Access;\n+\n+      type Buckets_Access is access Buckets_Type;\n+\n+      type Hash_Table_Type is new Ada.Finalization.Controlled with record\n+         Buckets : Buckets_Access;\n+         Length  : Count_Type := 0;\n+      end record;\n+   end Generic_Hash_Table_Types;\n+\n+end Ada.Containers.Hash_Tables;"}, {"sha": "c997430f6f0e9710e41076b66f0afb809448ee6b", "filename": "gcc/ada/a-coinve.adb", "status": "added", "additions": 2171, "deletions": 0, "changes": 2171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,2171 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.INDEFINITE_VECTORS                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit has originally being developed by Matthew J Heaney.            --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Generic_Array_Sort;\n+with Ada.Unchecked_Deallocation;\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Indefinite_Vectors is\n+\n+\n+   type Int is range System.Min_Int .. System.Max_Int;\n+\n+   procedure Free is\n+      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n+\n+   procedure Free is\n+      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+\n+   procedure Adjust (Container : in out Vector) is\n+   begin\n+\n+      if Container.Elements = null then\n+         return;\n+      end if;\n+\n+      if Container.Elements'Length = 0\n+        or else Container.Last < Index_Type'First\n+      then\n+         Container.Elements := null;\n+         return;\n+      end if;\n+\n+      declare\n+         E : Elements_Type renames Container.Elements.all;\n+         L : constant Index_Type := Container.Last;\n+      begin\n+\n+         Container.Elements := null;\n+         Container.Last := Index_Type'Pred (Index_Type'First);\n+\n+         Container.Elements := new Elements_Type (Index_Type'First .. L);\n+\n+         for I in Container.Elements'Range loop\n+\n+            if E (I) /= null then\n+               Container.Elements (I) := new Element_Type'(E (I).all);\n+            end if;\n+\n+            Container.Last := I;\n+\n+         end loop;\n+\n+      end;\n+\n+   end Adjust;\n+\n+\n+   procedure Finalize (Container : in out Vector) is\n+\n+      E : Elements_Access := Container.Elements;\n+      L : constant Index_Type'Base := Container.Last;\n+\n+   begin\n+\n+      Container.Elements := null;\n+      Container.Last := Index_Type'Pred (Index_Type'First);\n+\n+      for I in Index_Type'First .. L loop\n+         Free (E (I));\n+      end loop;\n+\n+      Free (E);\n+\n+   end Finalize;\n+\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : in     Vector) is\n+\n+      N : constant Count_Type := Length (Container);\n+\n+   begin\n+\n+      Count_Type'Base'Write (Stream, N);\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         E : Elements_Type renames Container.Elements.all;\n+      begin\n+         for I in Index_Type'First .. Container.Last loop\n+\n+            --  There's another way to do this.  Instead a separate\n+            --  Boolean for each element, you could write a Boolean\n+            --  followed by a count of how many nulls or non-nulls\n+            --  follow in the array.  Alternately you could use a\n+            --  signed integer, and use the sign as the indicator\n+            --  or null-ness.\n+\n+            if E (I) = null then\n+               Boolean'Write (Stream, False);\n+            else\n+               Boolean'Write (Stream, True);\n+               Element_Type'Output (Stream, E (I).all);\n+            end if;\n+\n+         end loop;\n+      end;\n+\n+   end Write;\n+\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container :    out Vector) is\n+\n+      Length : Count_Type'Base;\n+      Last   : Index_Type'Base := Index_Type'Pred (Index_Type'First);\n+\n+      B : Boolean;\n+\n+   begin\n+\n+      Clear (Container);\n+\n+      Count_Type'Base'Read (Stream, Length);\n+\n+      if Length > Capacity (Container) then\n+         Reserve_Capacity (Container, Capacity => Length);\n+      end if;\n+\n+      for I in Count_Type range 1 .. Length loop\n+\n+         Last := Index_Type'Succ (Last);\n+\n+         Boolean'Read (Stream, B);\n+\n+         if B then\n+            Container.Elements (Last) :=\n+              new Element_Type'(Element_Type'Input (Stream));\n+         end if;\n+\n+         Container.Last := Last;\n+\n+      end loop;\n+\n+   end Read;\n+\n+\n+   function To_Vector (Length : Count_Type) return Vector is\n+   begin\n+\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      declare\n+\n+         First : constant Int := Int (Index_Type'First);\n+\n+         Last_As_Int : constant Int'Base :=\n+           First + Int (Length) - 1;\n+\n+         Last : constant Index_Type :=\n+           Index_Type (Last_As_Int);\n+\n+         Elements : constant Elements_Access :=\n+           new Elements_Type (Index_Type'First .. Last);\n+\n+      begin\n+\n+         return (Controlled with Elements, Last);\n+\n+      end;\n+\n+   end To_Vector;\n+\n+\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Count_Type) return Vector is\n+\n+   begin\n+\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      declare\n+\n+         First : constant Int := Int (Index_Type'First);\n+\n+         Last_As_Int : constant Int'Base :=\n+           First + Int (Length) - 1;\n+\n+         Last : constant Index_Type :=\n+           Index_Type (Last_As_Int);\n+\n+         Elements : Elements_Access :=\n+           new Elements_Type (Index_Type'First .. Last);\n+\n+      begin\n+\n+         for I in Elements'Range loop\n+\n+            begin\n+               Elements (I) := new Element_Type'(New_Item);\n+            exception\n+               when others =>\n+                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     Free (Elements (J));\n+                  end loop;\n+\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         return (Controlled with Elements, Last);\n+\n+      end;\n+\n+   end To_Vector;\n+\n+\n+   function \"=\" (Left, Right : Vector) return Boolean is\n+   begin\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Last /= Right.Last then\n+         return False;\n+      end if;\n+\n+      for I in Index_Type'First .. Left.Last loop\n+\n+         --  NOTE:\n+         --  I think it's a bounded error to read or otherwise manipulate\n+         --  an \"empty\" element, which here means that it has the value\n+         --  null.  If it's a bounded error then an exception might\n+         --  propagate, or it might not.  We take advantage of that\n+         --  permission here to allow empty elements to be compared.\n+         --\n+         --  Whether this is the right decision I'm not really sure.  If\n+         --  you have a contrary argument then let me know.\n+         --  END NOTE.\n+\n+         if Left.Elements (I) = null then\n+\n+            if Right.Elements (I) /= null then\n+               return False;\n+            end if;\n+\n+         elsif Right.Elements (I) = null then\n+\n+            return False;\n+\n+         elsif Left.Elements (I).all /= Right.Elements (I).all then\n+\n+            return False;\n+\n+         end if;\n+\n+      end loop;\n+\n+      return True;\n+\n+   end \"=\";\n+\n+\n+   function Length (Container : Vector) return Count_Type is\n+\n+      L : constant Int := Int (Container.Last);\n+      F : constant Int := Int (Index_Type'First);\n+\n+      N : constant Int'Base := L - F + 1;\n+   begin\n+      return Count_Type (N);\n+   end Length;\n+\n+\n+   function Is_Empty (Container : Vector) return Boolean is\n+   begin\n+      return Container.Last < Index_Type'First;\n+   end Is_Empty;\n+\n+\n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : in     Count_Type) is\n+\n+      N : constant Count_Type := Indefinite_Vectors.Length (Container);\n+\n+   begin\n+\n+      if Length = N then\n+         return;\n+      end if;\n+\n+      if Length = 0 then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      declare\n+         Last_As_Int : constant Int'Base :=\n+           Int (Index_Type'First) + Int (Length) - 1;\n+\n+         Last : constant Index_Type :=\n+           Index_Type (Last_As_Int);\n+      begin\n+\n+         if Length > N then\n+\n+            if Length > Capacity (Container) then\n+               Reserve_Capacity (Container, Capacity => Length);\n+            end if;\n+\n+            Container.Last := Last;\n+\n+            return;\n+\n+         end if;\n+\n+         for I in reverse Index_Type'Succ (Last) .. Container.Last loop\n+\n+            declare\n+               X : Element_Access := Container.Elements (I);\n+            begin\n+               Container.Elements (I) := null;\n+               Container.Last := Index_Type'Pred (Container.Last);\n+               Free (X);\n+            end;\n+\n+         end loop;\n+\n+      end;\n+\n+   end Set_Length;\n+\n+\n+   procedure Clear (Container : in out Vector) is\n+   begin\n+\n+      for I in reverse Index_Type'First .. Container.Last loop\n+\n+         declare\n+            X : Element_Access := Container.Elements (I);\n+         begin\n+            Container.Elements (I) := null;\n+            Container.Last := Index_Type'Pred (I);\n+            Free (X);\n+         end;\n+\n+      end loop;\n+\n+   end Clear;\n+\n+\n+   procedure Append (Container : in out Vector;\n+                     New_Item  : in     Element_Type;\n+                     Count     : in     Count_Type := 1) is\n+   begin\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      Insert\n+        (Container,\n+         Index_Type'Succ (Container.Last),\n+         New_Item,\n+         Count);\n+   end Append;\n+\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : in     Extended_Index;\n+      New_Item  : in     Element_Type;\n+      Count     : in     Count_Type := 1) is\n+\n+      Old_Last_As_Int : constant Int := Int (Container.Last);\n+\n+      N : constant Int := Int (Count);\n+\n+      New_Last_As_Int : constant Int'Base := Old_Last_As_Int + N;\n+\n+      New_Last : constant Extended_Index := Extended_Index (New_Last_As_Int);\n+\n+      Index : Index_Type;\n+\n+      Dst_Last : Index_Type;\n+      Dst      : Elements_Access;\n+\n+   begin\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         subtype Before_Subtype is Index_Type'Base range\n+           Index_Type'First .. Index_Type'Succ (Container.Last);\n+\n+         Old_First : constant Before_Subtype := Before;\n+\n+         Old_First_As_Int : constant Int := Int (Old_First);\n+\n+         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n+      begin\n+         Index := Index_Type (New_First_As_Int);\n+      end;\n+\n+      if Container.Elements = null then\n+\n+         declare\n+            subtype Elements_Subtype is\n+              Elements_Type (Index_Type'First .. New_Last);\n+         begin\n+            Container.Elements := new Elements_Subtype;\n+            Container.Last := Index_Type'Pred (Index_Type'First);\n+\n+            for I in Container.Elements'Range loop\n+               Container.Elements (I) := new Element_Type'(New_Item);\n+               Container.Last := I;\n+            end loop;\n+         end;\n+\n+         return;\n+\n+      end if;\n+\n+      if New_Last <= Container.Elements'Last then\n+\n+         declare\n+            E : Elements_Type renames Container.Elements.all;\n+         begin\n+            E (Index .. New_Last) := E (Before .. Container.Last);\n+            Container.Last := New_Last;\n+\n+            --  NOTE:\n+            --  Now we do the allocation.  If it fails, we can propagate the\n+            --  exception and invariants are more or less satisfied.  The\n+            --  issue is that we have some slots still null, and the client\n+            --  has no way of detecting whether the slot is null (unless we\n+            --  give him a way).\n+            --\n+            --  Another way is to allocate a subarray on the stack, do the\n+            --  allocation into that array, and if that success then do\n+            --  the insertion proper.  The issue there is that you have to\n+            --  allocate the subarray on the stack, and that may fail if the\n+            --  subarray is long.\n+            --\n+            --  Or we could try to roll-back the changes: deallocate the\n+            --  elements we have successfully deallocated, and then copy\n+            --  the elements ptrs back to their original posns.\n+            --  END NOTE.\n+\n+            --  NOTE: I have written the loop manually here.  I could\n+            --  have done it this way too:\n+            --    E (Before .. Index_Type'Pred (Index)) :=\n+            --      (others => new Element_Type'New_Item);\n+            --  END NOTE.\n+\n+            for I in Before .. Index_Type'Pred (Index) loop\n+\n+               begin\n+                  E (I) := new Element_Type'(New_Item);\n+               exception\n+                  when others =>\n+                     E (I .. Index_Type'Pred (Index)) := (others => null);\n+                     raise;\n+               end;\n+\n+            end loop;\n+         end;\n+\n+         return;\n+\n+      end if;\n+\n+      declare\n+\n+         First : constant Int := Int (Index_Type'First);\n+\n+         New_Size : constant Int'Base :=\n+           New_Last_As_Int - First + 1;\n+\n+         Max_Size : constant Int'Base :=\n+           Int (Index_Type'Last) - First + 1;\n+\n+         Size, Dst_Last_As_Int : Int'Base;\n+\n+      begin\n+\n+         if New_Size >= Max_Size / 2 then\n+\n+            Dst_Last := Index_Type'Last;\n+\n+         else\n+\n+            Size := Container.Elements'Length;\n+\n+            if Size = 0 then\n+               Size := 1;\n+            end if;\n+\n+            while Size < New_Size loop\n+               Size := 2 * Size;\n+            end loop;\n+\n+            Dst_Last_As_Int := First + Size - 1;\n+            Dst_Last := Index_Type (Dst_Last_As_Int);\n+\n+         end if;\n+\n+      end;\n+\n+      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+\n+      declare\n+         Src : Elements_Type renames Container.Elements.all;\n+      begin\n+         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n+           Src (Index_Type'First .. Index_Type'Pred (Before));\n+\n+         Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+      end;\n+\n+      declare\n+         X : Elements_Access := Container.Elements;\n+      begin\n+         Container.Elements := Dst;\n+         Container.Last := New_Last;\n+\n+         Free (X);\n+      end;\n+\n+      --  NOTE:\n+      --  Now do the allocation.  If the allocation fails,\n+      --  then the worst thing is that we have a few null slots.\n+      --  Our invariants are otherwise satisfied.\n+      --  END NOTE.\n+\n+      for I in Before .. Index_Type'Pred (Index) loop\n+         Dst (I) := new Element_Type'(New_Item);\n+      end loop;\n+\n+   end Insert;\n+\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : in     Extended_Index;\n+      Count     : in     Count_Type := 1) is\n+\n+      Old_Last_As_Int : constant Int := Int (Container.Last);\n+\n+      N : constant Int := Int (Count);\n+\n+      New_Last_As_Int : constant Int'Base := Old_Last_As_Int + N;\n+\n+      New_Last : constant Extended_Index := Extended_Index (New_Last_As_Int);\n+\n+      Index : Index_Type;\n+\n+      Dst_Last : Index_Type;\n+      Dst      : Elements_Access;\n+\n+   begin\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         subtype Before_Subtype is Index_Type'Base range\n+           Index_Type'First .. Index_Type'Succ (Container.Last);\n+\n+         Old_First : constant Before_Subtype := Before;\n+\n+         Old_First_As_Int : constant Int := Int (Old_First);\n+\n+         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n+      begin\n+         Index := Index_Type (New_First_As_Int);\n+      end;\n+\n+      if Container.Elements = null then\n+\n+         declare\n+            subtype Elements_Subtype is\n+              Elements_Type (Index_Type'First .. New_Last);\n+         begin\n+            Container.Elements := new Elements_Subtype;\n+            Container.Last := New_Last;\n+         end;\n+\n+         return;\n+\n+      end if;\n+\n+      if New_Last <= Container.Elements'Last then\n+\n+         declare\n+            E : Elements_Type renames Container.Elements.all;\n+         begin\n+            E (Index .. New_Last) := E (Before .. Container.Last);\n+            E (Before .. Index_Type'Pred (Index)) := (others => null);\n+\n+            Container.Last := New_Last;\n+         end;\n+\n+         return;\n+\n+      end if;\n+\n+      declare\n+\n+         First : constant Int := Int (Index_Type'First);\n+\n+         New_Size : constant Int'Base :=\n+           Int (New_Last_As_Int) - First + 1;\n+\n+         Max_Size : constant Int'Base :=\n+           Int (Index_Type'Last) - First + 1;\n+\n+         Size, Dst_Last_As_Int : Int'Base;\n+\n+      begin\n+\n+         if New_Size >= Max_Size / 2 then\n+\n+            Dst_Last := Index_Type'Last;\n+\n+         else\n+\n+            Size := Container.Elements'Length;\n+\n+            if Size = 0 then\n+               Size := 1;\n+            end if;\n+\n+            while Size < New_Size loop\n+               Size := 2 * Size;\n+            end loop;\n+\n+            Dst_Last_As_Int := First + Size - 1;\n+            Dst_Last := Index_Type (Dst_Last_As_Int);\n+\n+         end if;\n+\n+      end;\n+\n+      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+\n+      declare\n+         Src : Elements_Type renames Container.Elements.all;\n+      begin\n+         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n+           Src (Index_Type'First .. Index_Type'Pred (Before));\n+\n+         Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+      end;\n+\n+      declare\n+         X : Elements_Access := Container.Elements;\n+      begin\n+         Container.Elements := Dst;\n+         Container.Last := New_Last;\n+\n+         Free (X);\n+      end;\n+\n+   end Insert_Space;\n+\n+\n+   procedure Delete_First (Container : in out Vector;\n+                           Count     : in     Count_Type := 1) is\n+   begin\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      Delete (Container, Index_Type'First, Count);\n+\n+   end Delete_First;\n+\n+\n+   procedure Delete_Last (Container : in out Vector;\n+                          Count     : in     Count_Type := 1) is\n+\n+      Index : Int'Base;\n+\n+   begin\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      Index := Int'Base (Container.Last) - Int'Base (Count) + 1;\n+\n+      Delete (Container, Index_Type'Base (Index), Count);\n+\n+   end Delete_Last;\n+\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : in     Extended_Index;  --  TODO: verify in Atlanta\n+      Count     : in     Count_Type := 1) is\n+\n+   begin\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+\n+         subtype I_Subtype is Index_Type'Base range\n+           Index_Type'First .. Container.Last;\n+\n+         I : constant I_Subtype := Index;\n+         I_As_Int : constant Int := Int (I);\n+\n+         Old_Last_As_Int : constant Int := Int (Container.Last);\n+\n+         Count1 : constant Int'Base := Int (Count);\n+         Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n+\n+         N : constant Int'Base := Int'Min (Count1, Count2);\n+\n+         J_As_Int : constant Int'Base := I_As_Int + N;\n+         J : constant Index_Type'Base := Index_Type'Base (J_As_Int);\n+\n+         E : Elements_Type renames Container.Elements.all;\n+\n+         New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+\n+         New_Last : constant Extended_Index :=\n+           Extended_Index (New_Last_As_Int);\n+\n+      begin\n+\n+         for K in I .. Index_Type'Pred (J) loop\n+\n+            begin\n+               Free (E (K));\n+            exception\n+               when others =>\n+                  E (K) := null;\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         E (I .. New_Last) := E (J .. Container.Last);\n+         Container.Last := New_Last;\n+\n+      end;\n+\n+   end Delete;\n+\n+\n+   function Capacity (Container : Vector) return Count_Type is\n+   begin\n+      if Container.Elements = null then\n+         return 0;\n+      end if;\n+\n+      return Container.Elements'Length;\n+   end Capacity;\n+\n+\n+   procedure Reserve_Capacity (Container : in out Vector;\n+                               Capacity  : in     Count_Type) is\n+\n+      N : constant Count_Type := Length (Container);\n+\n+   begin\n+\n+      if Capacity = 0 then\n+\n+         if N = 0 then\n+\n+            declare\n+               X : Elements_Access := Container.Elements;\n+            begin\n+               Container.Elements := null;\n+               Free (X);\n+            end;\n+\n+         elsif N < Container.Elements'Length then\n+\n+            declare\n+               subtype Array_Index_Subtype is Index_Type'Base range\n+                 Index_Type'First .. Container.Last;\n+\n+               Src : Elements_Type renames\n+                 Container.Elements (Array_Index_Subtype);\n+\n+               subtype Array_Subtype is\n+                 Elements_Type (Array_Index_Subtype);\n+\n+               X : Elements_Access := Container.Elements;\n+            begin\n+               Container.Elements := new Array_Subtype'(Src);\n+               Free (X);\n+            end;\n+\n+         end if;\n+\n+         return;\n+\n+      end if;\n+\n+      if Container.Elements = null then\n+\n+         declare\n+            Last_As_Int : constant Int'Base :=\n+              Int (Index_Type'First) + Int (Capacity) - 1;\n+\n+            Last : constant Index_Type :=\n+              Index_Type (Last_As_Int);\n+\n+            subtype Array_Subtype is\n+              Elements_Type (Index_Type'First .. Last);\n+         begin\n+            Container.Elements := new Array_Subtype;\n+         end;\n+\n+         return;\n+\n+      end if;\n+\n+      if Capacity <= N then\n+\n+         if N < Container.Elements'Length then\n+\n+            declare\n+               subtype Array_Index_Subtype is Index_Type'Base range\n+                 Index_Type'First .. Container.Last;\n+\n+               Src : Elements_Type renames\n+                 Container.Elements (Array_Index_Subtype);\n+\n+               subtype Array_Subtype is\n+                 Elements_Type (Array_Index_Subtype);\n+\n+               X : Elements_Access := Container.Elements;\n+            begin\n+               Container.Elements := new Array_Subtype'(Src);\n+               Free (X);\n+            end;\n+\n+         end if;\n+\n+         return;\n+\n+      end if;\n+\n+      if Capacity = Container.Elements'Length then\n+         return;\n+      end if;\n+\n+      declare\n+         Last_As_Int : constant Int'Base :=\n+           Int (Index_Type'First) + Int (Capacity) - 1;\n+\n+         Last : constant Index_Type :=\n+           Index_Type (Last_As_Int);\n+\n+         subtype Array_Subtype is\n+           Elements_Type (Index_Type'First .. Last);\n+\n+         X : Elements_Access := Container.Elements;\n+      begin\n+         Container.Elements := new Array_Subtype;\n+\n+         declare\n+            Src : Elements_Type renames\n+              X (Index_Type'First .. Container.Last);\n+\n+            Tgt : Elements_Type renames\n+              Container.Elements (Index_Type'First .. Container.Last);\n+         begin\n+            Tgt := Src;\n+         end;\n+\n+         Free (X);\n+      end;\n+\n+   end Reserve_Capacity;\n+\n+\n+   function First_Index (Container : Vector) return Index_Type is\n+      pragma Warnings (Off, Container);\n+   begin\n+      return Index_Type'First;\n+   end First_Index;\n+\n+\n+   function First_Element (Container : Vector) return Element_Type is\n+   begin\n+      return Element (Container, Index_Type'First);\n+   end First_Element;\n+\n+\n+   function Last_Index (Container : Vector) return Extended_Index is\n+   begin\n+      return Container.Last;\n+   end Last_Index;\n+\n+\n+   function Last_Element (Container : Vector) return Element_Type is\n+   begin\n+      return Element (Container, Container.Last);\n+   end Last_Element;\n+\n+\n+   function Element (Container : Vector;\n+                     Index     : Index_Type)\n+      return Element_Type is\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. Container.Last;\n+   begin\n+      return Container.Elements (T'(Index)).all;\n+   end Element;\n+\n+\n+   procedure Replace_Element (Container : in Vector;\n+                              Index     : in Index_Type;\n+                              By        : in Element_Type) is\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. Container.Last;\n+\n+      X : Element_Access := Container.Elements (T'(Index));\n+   begin\n+      Container.Elements (T'(Index)) := new Element_Type'(By);\n+      Free (X);\n+   end Replace_Element;\n+\n+\n+   procedure Generic_Sort (Container : in Vector) is\n+\n+      function Is_Less (L, R : Element_Access) return Boolean;\n+      pragma Inline (Is_Less);\n+\n+      function Is_Less (L, R : Element_Access) return Boolean is\n+      begin\n+         if L = null then\n+            return R /= null;\n+         elsif R = null then\n+            return False;\n+         else\n+            return L.all < R.all;\n+         end if;\n+      end Is_Less;\n+\n+      procedure Sort is\n+         new Generic_Array_Sort\n+          (Index_Type,\n+           Element_Access,\n+           Elements_Type,\n+           \"<\" => Is_Less);\n+\n+   begin\n+\n+      if Container.Elements = null then\n+         return;\n+      end if;\n+\n+      Sort (Container.Elements (Index_Type'First .. Container.Last));\n+\n+   end Generic_Sort;\n+\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First)\n+     return Extended_Index is\n+\n+   begin\n+\n+      for I in Index .. Container.Last loop\n+         if Container.Elements (I) /= null\n+           and then Container.Elements (I).all = Item\n+         then\n+            return I;\n+         end if;\n+      end loop;\n+\n+      return No_Index;\n+\n+   end Find_Index;\n+\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last)\n+     return Extended_Index is\n+\n+      Last : Index_Type'Base;\n+\n+   begin\n+\n+      if Index > Container.Last then\n+         Last := Container.Last;\n+      else\n+         Last := Index;\n+      end if;\n+\n+      for I in reverse Index_Type'First .. Last loop\n+         if Container.Elements (I) /= null\n+           and then Container.Elements (I).all = Item\n+         then\n+            return I;\n+         end if;\n+      end loop;\n+\n+      return No_Index;\n+\n+   end Reverse_Find_Index;\n+\n+\n+   function Contains (Container : Vector;\n+                      Item      : Element_Type) return Boolean is\n+   begin\n+      return Find_Index (Container, Item) /= No_Index;\n+   end Contains;\n+\n+\n+\n+   procedure Assign\n+     (Target : in out Vector;\n+      Source : in     Vector) is\n+\n+      N : constant Count_Type := Length (Source);\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Clear (Target);\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      if N > Capacity (Target) then\n+         Reserve_Capacity (Target, Capacity => N);\n+      end if;\n+\n+      for I in Index_Type'First .. Source.Last loop\n+\n+         declare\n+            EA : constant Element_Access := Source.Elements (I);\n+         begin\n+            if EA /= null then\n+               Target.Elements (I) := new Element_Type'(EA.all);\n+            end if;\n+         end;\n+\n+         Target.Last := I;\n+\n+      end loop;\n+\n+   end Assign;\n+\n+\n+   procedure Move\n+     (Target : in out Vector;\n+      Source : in out Vector) is\n+\n+      X : Elements_Access := Target.Elements;\n+\n+   begin\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Last >= Index_Type'First then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Target.Elements := null;\n+      Free (X);  --  shouldn't fail\n+\n+      Target.Elements := Source.Elements;\n+      Target.Last := Source.Last;\n+\n+      Source.Elements := null;\n+      Source.Last := Index_Type'Pred (Index_Type'First);\n+\n+   end Move;\n+\n+\n+   procedure Query_Element\n+     (Container : in Vector;\n+      Index     : in Index_Type;\n+      Process   : not null access procedure (Element : in Element_Type)) is\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. Container.Last;\n+   begin\n+      Process (Container.Elements (T'(Index)).all);\n+   end Query_Element;\n+\n+\n+   procedure Update_Element\n+     (Container : in Vector;\n+      Index     : in Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type)) is\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. Container.Last;\n+   begin\n+      Process (Container.Elements (T'(Index)).all);\n+   end Update_Element;\n+\n+\n+   procedure Prepend (Container : in out Vector;\n+                      New_Item  : in     Element_Type;\n+                      Count     : in     Count_Type := 1) is\n+   begin\n+      Insert (Container,\n+              Index_Type'First,\n+              New_Item,\n+              Count);\n+   end Prepend;\n+\n+\n+   procedure Swap\n+     (Container : in Vector;\n+      I, J      : in Index_Type) is\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. Container.Last;\n+\n+      EI : constant Element_Access := Container.Elements (T'(I));\n+\n+   begin\n+\n+      Container.Elements (T'(I)) := Container.Elements (T'(J));\n+      Container.Elements (T'(J)) := EI;\n+\n+   end Swap;\n+\n+\n+   function \"&\" (Left, Right : Vector) return Vector is\n+\n+      LN : constant Count_Type := Length (Left);\n+      RN : constant Count_Type := Length (Right);\n+\n+   begin\n+\n+      if LN = 0 then\n+\n+         if RN = 0 then\n+            return Empty_Vector;\n+         end if;\n+\n+         declare\n+            RE : Elements_Type renames\n+              Right.Elements (Index_Type'First .. Right.Last);\n+\n+            Elements : Elements_Access :=\n+              new Elements_Type (RE'Range);\n+         begin\n+            for I in Elements'Range loop\n+               begin\n+                  if RE (I) /= null then\n+                     Elements (I) := new Element_Type'(RE (I).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                        Free (Elements (J));\n+                     end loop;\n+\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n+\n+            return (Controlled with Elements, Right.Last);\n+         end;\n+\n+      end if;\n+\n+      if RN = 0 then\n+\n+         declare\n+            LE : Elements_Type renames\n+              Left.Elements (Index_Type'First .. Left.Last);\n+\n+            Elements : Elements_Access :=\n+              new Elements_Type (LE'Range);\n+         begin\n+            for I in Elements'Range loop\n+               begin\n+                  if LE (I) /= null then\n+                     Elements (I) := new Element_Type'(LE (I).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                        Free (Elements (J));\n+                     end loop;\n+\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n+\n+            return (Controlled with Elements, Left.Last);\n+         end;\n+\n+      end if;\n+\n+      declare\n+\n+         Last_As_Int : constant Int'Base :=\n+            Int (Index_Type'First) + Int (LN) + Int (RN) - 1;\n+\n+         Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+         LE : Elements_Type renames\n+           Left.Elements (Index_Type'First .. Left.Last);\n+\n+         RE : Elements_Type renames\n+           Right.Elements (Index_Type'First .. Right.Last);\n+\n+         Elements : Elements_Access :=\n+           new Elements_Type (Index_Type'First .. Last);\n+\n+         I : Index_Type'Base := Index_Type'Pred (Index_Type'First);\n+\n+      begin\n+\n+         for LI in LE'Range loop\n+\n+            I := Index_Type'Succ (I);\n+\n+            begin\n+               if LE (LI) /= null then\n+                  Elements (I) := new Element_Type'(LE (LI).all);\n+               end if;\n+            exception\n+               when others =>\n+                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     Free (Elements (J));\n+                  end loop;\n+\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         for RI in RE'Range loop\n+\n+            I := Index_Type'Succ (I);\n+\n+            begin\n+               if RE (RI) /= null then\n+                  Elements (I) := new Element_Type'(RE (RI).all);\n+               end if;\n+            exception\n+               when others =>\n+                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     Free (Elements (J));\n+                  end loop;\n+\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         return (Controlled with Elements, Last);\n+      end;\n+\n+   end \"&\";\n+\n+\n+   function \"&\" (Left  : Vector;\n+                 Right : Element_Type) return Vector is\n+\n+      LN : constant Count_Type := Length (Left);\n+\n+   begin\n+\n+      if LN = 0 then\n+\n+         declare\n+            Elements : Elements_Access :=\n+              new Elements_Type (Index_Type'First .. Index_Type'First);\n+         begin\n+\n+            begin\n+               Elements (Elements'First) := new Element_Type'(Right);\n+            exception\n+               when others =>\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+            return (Controlled with Elements, Index_Type'First);\n+\n+         end;\n+\n+      end if;\n+\n+      declare\n+\n+         Last_As_Int : constant Int'Base :=\n+            Int (Index_Type'First) + Int (LN);\n+\n+         Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+         LE : Elements_Type renames\n+           Left.Elements (Index_Type'First .. Left.Last);\n+\n+         Elements : Elements_Access :=\n+           new Elements_Type (Index_Type'First .. Last);\n+\n+      begin\n+\n+         for I in LE'Range loop\n+\n+            begin\n+               if LE (I) /= null then\n+                  Elements (I) := new Element_Type'(LE (I).all);\n+               end if;\n+            exception\n+               when others =>\n+                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     Free (Elements (J));\n+                  end loop;\n+\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         begin\n+            Elements (Elements'Last) := new Element_Type'(Right);\n+         exception\n+            when others =>\n+\n+               declare\n+                  subtype J_Subtype is Index_Type'Base range\n+                    Index_Type'First .. Index_Type'Pred (Elements'Last);\n+               begin\n+                  for J in J_Subtype loop\n+                     Free (Elements (J));\n+                  end loop;\n+               end;\n+\n+               Free (Elements);\n+               raise;\n+         end;\n+\n+         return (Controlled with Elements, Last);\n+      end;\n+\n+   end \"&\";\n+\n+\n+\n+   function \"&\" (Left  : Element_Type;\n+                 Right : Vector) return Vector is\n+\n+      RN : constant Count_Type := Length (Right);\n+\n+   begin\n+\n+      if RN = 0 then\n+\n+         declare\n+            Elements : Elements_Access :=\n+              new Elements_Type (Index_Type'First .. Index_Type'First);\n+         begin\n+\n+            begin\n+               Elements (Elements'First) := new Element_Type'(Left);\n+            exception\n+               when others =>\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+            return (Controlled with Elements, Index_Type'First);\n+\n+         end;\n+\n+      end if;\n+\n+      declare\n+\n+         Last_As_Int : constant Int'Base :=\n+            Int (Index_Type'First) + Int (RN);\n+\n+         Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+         RE : Elements_Type renames\n+           Right.Elements (Index_Type'First .. Right.Last);\n+\n+         Elements : Elements_Access :=\n+           new Elements_Type (Index_Type'First .. Last);\n+\n+         I : Index_Type'Base := Index_Type'First;\n+\n+      begin\n+\n+         begin\n+            Elements (I) := new Element_Type'(Left);\n+         exception\n+            when others =>\n+               Free (Elements);\n+               raise;\n+         end;\n+\n+         for RI in RE'Range loop\n+\n+            I := Index_Type'Succ (I);\n+\n+            begin\n+               if RE (RI) /= null then\n+                  Elements (I) := new Element_Type'(RE (RI).all);\n+               end if;\n+            exception\n+               when others =>\n+                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     Free (Elements (J));\n+                  end loop;\n+\n+                  Free (Elements);\n+                  raise;\n+            end;\n+\n+         end loop;\n+\n+         return (Controlled with Elements, Last);\n+      end;\n+\n+   end \"&\";\n+\n+\n+   function \"&\" (Left, Right  : Element_Type) return Vector is\n+\n+      subtype IT is Index_Type'Base range\n+        Index_Type'First .. Index_Type'Succ (Index_Type'First);\n+\n+      Elements : Elements_Access := new Elements_Type (IT);\n+\n+   begin\n+\n+      begin\n+         Elements (Elements'First) := new Element_Type'(Left);\n+      exception\n+         when others =>\n+            Free (Elements);\n+            raise;\n+      end;\n+\n+      begin\n+         Elements (Elements'Last) := new Element_Type'(Right);\n+      exception\n+         when others =>\n+            Free (Elements (Elements'First));\n+            Free (Elements);\n+            raise;\n+      end;\n+\n+      return (Controlled with Elements, Elements'Last);\n+\n+   end \"&\";\n+\n+\n+   function To_Cursor (Container : Vector;\n+                       Index     : Extended_Index)\n+      return Cursor is\n+   begin\n+      if Index not in Index_Type'First .. Container.Last then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unchecked_Access, Index);\n+   end To_Cursor;\n+\n+\n+   function To_Index (Position : Cursor) return Extended_Index is\n+   begin\n+      if Position.Container = null then\n+         return No_Index;\n+      end if;\n+\n+      if Position.Index <= Position.Container.Last then\n+         return Position.Index;\n+      end if;\n+\n+      return No_Index;\n+   end To_Index;\n+\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Element (Position.Container.all, Position.Index);\n+   end Element;\n+\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index < Position.Container.Last then\n+         return (Position.Container, Index_Type'Succ (Position.Index));\n+      end if;\n+\n+      return No_Element;\n+\n+   end Next;\n+\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index > Index_Type'First then\n+         return (Position.Container, Index_Type'Pred (Position.Index));\n+      end if;\n+\n+      return No_Element;\n+\n+   end Previous;\n+\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+\n+      if Position.Container = null then\n+         return;\n+      end if;\n+\n+      if Position.Index < Position.Container.Last then\n+         Position.Index := Index_Type'Succ (Position.Index);\n+      else\n+         Position := No_Element;\n+      end if;\n+\n+   end Next;\n+\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+\n+      if Position.Container = null then\n+         return;\n+      end if;\n+\n+      if Position.Index > Index_Type'First then\n+         Position.Index := Index_Type'Pred (Position.Index);\n+      else\n+         Position := No_Element;\n+      end if;\n+\n+   end Previous;\n+\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      return Position.Index <= Position.Container.Last;\n+\n+   end Has_Element;\n+\n+\n+   procedure Iterate\n+     (Container : in Vector;\n+      Process   : not null access procedure (Position : in Cursor)) is\n+   begin\n+\n+      for I in Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unchecked_Access, I));\n+      end loop;\n+\n+   end Iterate;\n+\n+\n+   procedure Reverse_Iterate\n+     (Container : in Vector;\n+      Process   : not null access procedure (Position : in Cursor)) is\n+   begin\n+\n+      for I in reverse Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unchecked_Access, I));\n+      end loop;\n+\n+   end Reverse_Iterate;\n+\n+\n+   procedure Query_Element\n+     (Position : in Cursor;\n+      Process  : not null access procedure (Element : in Element_Type)) is\n+\n+      C : Vector renames Position.Container.all;\n+      E : Elements_Type renames C.Elements.all;\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. C.Last;\n+   begin\n+      Process (E (T'(Position.Index)).all);\n+   end Query_Element;\n+\n+\n+   procedure Update_Element\n+     (Position : in Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type)) is\n+\n+      C : Vector renames Position.Container.all;\n+      E : Elements_Type renames C.Elements.all;\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. C.Last;\n+   begin\n+      Process (E (T'(Position.Index)).all);\n+   end Update_Element;\n+\n+\n+   procedure Replace_Element (Position : in Cursor;\n+                              By       : in Element_Type) is\n+\n+      C : Vector renames Position.Container.all;\n+      E : Elements_Type renames C.Elements.all;\n+\n+      subtype T is Index_Type'Base range\n+        Index_Type'First .. C.Last;\n+\n+      X : Element_Access := E (T'(Position.Index));\n+   begin\n+      E (T'(Position.Index)) := new Element_Type'(By);\n+      Free (X);\n+   end Replace_Element;\n+\n+\n+   procedure Insert (Container : in out Vector;\n+                     Before    : in     Extended_Index;\n+                     New_Item  : in     Vector) is\n+\n+      N : constant Count_Type := Length (New_Item);\n+\n+   begin\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      if Container'Address = New_Item'Address then\n+\n+         declare\n+            Dst_Last_As_Int : constant Int'Base :=\n+              Int'Base (Before) + Int'Base (N) - 1;\n+\n+            Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n+\n+            Dst_Index : Index_Type'Base := Index_Type'Pred (Before);\n+\n+            Dst : Elements_Type renames\n+              Container.Elements (Before .. Dst_Last);\n+         begin\n+\n+            declare\n+               subtype Src_Index_Subtype is Index_Type'Base range\n+                 Index_Type'First .. Index_Type'Pred (Before);\n+\n+               Src : Elements_Type renames\n+                 Container.Elements (Src_Index_Subtype);\n+            begin\n+               for Src_Index in Src'Range loop\n+                  Dst_Index := Index_Type'Succ (Dst_Index);\n+\n+                  if Src (Src_Index) /= null then\n+                     Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n+                  end if;\n+               end loop;\n+            end;\n+\n+            declare\n+               subtype Src_Index_Subtype is Index_Type'Base range\n+                 Index_Type'Succ (Dst_Last) .. Container.Last;\n+\n+               Src : Elements_Type renames\n+                 Container.Elements (Src_Index_Subtype);\n+            begin\n+               for Src_Index in Src'Range loop\n+                  Dst_Index := Index_Type'Succ (Dst_Index);\n+\n+                  if Src (Src_Index) /= null then\n+                     Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n+                  end if;\n+               end loop;\n+            end;\n+\n+         end;\n+\n+      else\n+\n+         declare\n+            Dst_Last_As_Int : constant Int'Base :=\n+              Int'Base (Before) + Int'Base (N) - 1;\n+\n+            Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n+\n+            Dst_Index : Index_Type'Base := Index_Type'Pred (Before);\n+\n+            Src : Elements_Type renames\n+              New_Item.Elements (Index_Type'First .. New_Item.Last);\n+\n+            Dst : Elements_Type renames\n+              Container.Elements (Before .. Dst_Last);\n+         begin\n+            for Src_Index in Src'Range loop\n+               Dst_Index := Index_Type'Succ (Dst_Index);\n+\n+               if Src (Src_Index) /= null then\n+                  Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n+               end if;\n+            end loop;\n+         end;\n+\n+      end if;\n+\n+   end Insert;\n+\n+\n+   procedure Insert (Container : in out Vector;\n+                     Before    : in     Cursor;\n+                     New_Item  : in     Vector) is\n+\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Before.Container /= null\n+        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         Index := Index_Type'Succ (Container.Last);\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+\n+   end Insert;\n+\n+\n+\n+   procedure Insert (Container : in out Vector;\n+                     Before    : in     Cursor;\n+                     New_Item  : in     Vector;\n+                     Position  :    out Cursor) is\n+\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Before.Container /= null\n+        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         Index := Index_Type'Succ (Container.Last);\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+\n+      Position := (Container'Unchecked_Access, Index);\n+\n+   end Insert;\n+\n+\n+   procedure Insert (Container : in out Vector;\n+                     Before    : in     Cursor;\n+                     New_Item  : in     Element_Type;\n+                     Count     : in     Count_Type := 1) is\n+\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Before.Container /= null\n+        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         Index := Index_Type'Succ (Container.Last);\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+\n+   end Insert;\n+\n+\n+   procedure Insert (Container : in out Vector;\n+                     Before    : in     Cursor;\n+                     New_Item  : in     Element_Type;\n+                     Position  :    out Cursor;\n+                     Count     : in     Count_Type := 1) is\n+\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Before.Container /= null\n+        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         Index := Index_Type'Succ (Container.Last);\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+\n+      Position := (Container'Unchecked_Access, Index);\n+\n+   end Insert;\n+\n+\n+\n+   procedure Prepend (Container : in out Vector;\n+                      New_Item  : in     Vector) is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item);\n+   end Prepend;\n+\n+\n+   procedure Append (Container : in out Vector;\n+                     New_Item  : in     Vector) is\n+   begin\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      Insert\n+        (Container,\n+         Index_Type'Succ (Container.Last),\n+         New_Item);\n+   end Append;\n+\n+\n+\n+   procedure Insert_Space (Container : in out Vector;\n+                           Before    : in     Cursor;\n+                           Position  :    out Cursor;\n+                           Count     : in     Count_Type := 1) is\n+\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Before.Container /= null\n+        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Count = 0 then\n+\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         Index := Index_Type'Succ (Container.Last);\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert_Space (Container, Index, Count);\n+\n+      Position := (Container'Unchecked_Access, Index);\n+\n+   end Insert_Space;\n+\n+\n+   procedure Delete (Container : in out Vector;\n+                     Position  : in out Cursor;\n+                     Count     : in     Count_Type := 1) is\n+   begin\n+\n+      if Position.Container /= null\n+        and then Position.Container /=\n+                   Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container = null\n+        or else Position.Index > Container.Last\n+      then\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      Delete (Container, Position.Index, Count);\n+\n+      if Position.Index <= Container.Last then\n+         Position := (Container'Unchecked_Access, Position.Index);\n+      else\n+         Position := No_Element;\n+      end if;\n+\n+   end Delete;\n+\n+\n+   function First (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (Container'Unchecked_Access, Index_Type'First);\n+   end First;\n+\n+\n+   function Last (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (Container'Unchecked_Access, Container.Last);\n+   end Last;\n+\n+\n+   procedure Swap (I, J : in Cursor) is\n+\n+      --  NOTE: I've liberalized the behavior here, to\n+      --  allow I and J to designate different containers.\n+      --  TODO: I think this is suppose to raise P_E.\n+\n+      subtype TI is Index_Type'Base range\n+        Index_Type'First .. I.Container.Last;\n+\n+      EI : Element_Access renames\n+        I.Container.Elements (TI'(I.Index));\n+\n+      EI_Copy : constant Element_Access := EI;\n+\n+      subtype TJ is Index_Type'Base range\n+        Index_Type'First .. J.Container.Last;\n+\n+      EJ : Element_Access renames\n+        J.Container.Elements (TJ'(J.Index));\n+\n+   begin\n+\n+      EI := EJ;\n+      EJ := EI_Copy;\n+\n+   end Swap;\n+\n+\n+   function Find (Container : Vector;\n+                  Item      : Element_Type;\n+                  Position  : Cursor := No_Element) return Cursor is\n+\n+   begin\n+\n+      if Position.Container /= null\n+        and then Position.Container /=\n+                   Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      for I in Position.Index .. Container.Last loop\n+         if Container.Elements (I) /= null\n+           and then Container.Elements (I).all = Item\n+         then\n+            return (Container'Unchecked_Access, I);\n+         end if;\n+      end loop;\n+\n+      return No_Element;\n+\n+   end Find;\n+\n+\n+   function Reverse_Find (Container : Vector;\n+                          Item      : Element_Type;\n+                          Position  : Cursor := No_Element) return Cursor is\n+\n+      Last : Index_Type'Base;\n+\n+   begin\n+\n+      if Position.Container /= null\n+        and then Position.Container /=\n+                   Vector_Access'(Container'Unchecked_Access)\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container = null\n+        or else Position.Index > Container.Last\n+      then\n+         Last := Container.Last;\n+      else\n+         Last := Position.Index;\n+      end if;\n+\n+      for I in reverse Index_Type'First .. Last loop\n+         if Container.Elements (I) /= null\n+           and then Container.Elements (I).all = Item\n+         then\n+            return (Container'Unchecked_Access, I);\n+         end if;\n+      end loop;\n+\n+      return No_Element;\n+\n+   end Reverse_Find;\n+\n+\n+end Ada.Containers.Indefinite_Vectors;\n+"}, {"sha": "6aa79a4fce4dff6e195b0d73d73784a1df1596e7", "filename": "gcc/ada/a-coinve.ads", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,343 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                    ADA.CONTAINERS.INDEFINITE_VECTORS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+with Ada.Streams;\n+\n+generic\n+   type Index_Type is range <>;\n+\n+   type Element_Type (<>) is private;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Vectors is\n+pragma Preelaborate (Indefinite_Vectors);\n+\n+   subtype Extended_Index is Index_Type'Base\n+     range Index_Type'First - 1 ..\n+            Index_Type'Last +\n+            Boolean'Pos (Index_Type'Base'Last > Index_Type'Last);\n+\n+   No_Index : constant Extended_Index := Extended_Index'First;\n+\n+   subtype Index_Subtype is Index_Type;\n+\n+   type Vector is tagged private;\n+\n+   type Cursor is private;\n+\n+   Empty_Vector : constant Vector;\n+\n+   No_Element : constant Cursor;\n+\n+   function To_Vector (Length : Count_Type) return Vector;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Count_Type) return Vector;\n+\n+   function \"&\" (Left, Right : Vector) return Vector;\n+\n+   function \"&\" (Left : Vector; Right : Element_Type) return Vector;\n+\n+   function \"&\" (Left : Element_Type; Right : Vector) return Vector;\n+\n+   function \"&\" (Left, Right : Element_Type) return Vector;\n+\n+   function \"=\" (Left, Right : Vector) return Boolean;\n+\n+   function Capacity (Container : Vector) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Count_Type);\n+\n+   function Length (Container : Vector) return Count_Type;\n+\n+   function Is_Empty (Container : Vector) return Boolean;\n+\n+   procedure Clear (Container : in out Vector);\n+\n+   function To_Cursor\n+     (Container : Vector;\n+      Index     : Extended_Index) return Cursor;\n+\n+   function To_Index (Position : Cursor) return Extended_Index;\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type;\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Update_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Replace_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      By        : Element_Type);\n+\n+   procedure Replace_Element\n+     (Position : Cursor;\n+      By       : Element_Type);\n+\n+   procedure Assign (Target : in out Vector; Source : Vector);\n+\n+   procedure Move (Target : in out Vector; Source : in out Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector;\n+      Position  : out Cursor);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Count_Type);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;  --  TODO: verify\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   function First_Index (Container : Vector) return Index_Type;\n+\n+   function First (Container : Vector) return Cursor;\n+\n+   function First_Element (Container : Vector) return Element_Type;\n+\n+   function Last_Index (Container : Vector) return Extended_Index;\n+\n+   function Last (Container : Vector) return Cursor;\n+\n+   function Last_Element (Container : Vector) return Element_Type;\n+\n+   procedure Swap (Container : Vector; I, J : Index_Type);\n+\n+   procedure Swap (I, J : Cursor);\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   procedure Generic_Sort (Container : Vector);\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index;\n+\n+   function Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+       Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index;\n+\n+   function Reverse_Find (Container : Vector;\n+                          Item      : Element_Type;\n+                          Position  : Cursor := No_Element)\n+      return Cursor;\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   pragma Inline (First_Index);\n+   pragma Inline (Last_Index);\n+   pragma Inline (Element);\n+   pragma Inline (First_Element);\n+   pragma Inline (Last_Element);\n+   pragma Inline (Query_Element);\n+   pragma Inline (Update_Element);\n+   pragma Inline (Replace_Element);\n+   pragma Inline (Contains);\n+\n+   type Element_Access is access Element_Type;\n+\n+   type Elements_Type is array (Index_Type range <>) of Element_Access;\n+\n+   function \"=\" (L, R : Elements_Type) return Boolean is abstract;\n+\n+   type Elements_Access is access Elements_Type;\n+\n+   use Ada.Finalization;\n+\n+   type Vector is new Controlled with record\n+      Elements : Elements_Access;\n+      Last     : Extended_Index := No_Index;\n+   end record;\n+\n+   procedure Adjust (Container : in out Vector);\n+\n+   procedure Finalize (Container : in out Vector);\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : Vector);\n+\n+   for Vector'Write use Write;\n+\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Vector);\n+\n+   for Vector'Read use Read;\n+\n+   Empty_Vector : constant Vector := Vector'(Controlled with null, No_Index);\n+\n+   type Vector_Access is access constant Vector;\n+   for Vector_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Vector_Access;\n+      Index     : Index_Type := Index_Type'First;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n+\n+end Ada.Containers.Indefinite_Vectors;\n+"}, {"sha": "e76f0765bfc692df49bafae57eaf52118a1de5e2", "filename": "gcc/ada/a-contai.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-contai.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-contai.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-contai.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a", "patch": "@@ -0,0 +1,22 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                              ADA.CONTAINERS                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Containers is\n+pragma Pure (Containers);\n+\n+   type Hash_Type is mod 2**32;\n+   type Count_Type is range 0 .. 2**31 - 1;\n+\n+end Ada.Containers;"}, {"sha": "c98c58a3b21896dd4057a4e3598c569487c0bd16", "filename": "gcc/ada/a-convec.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "ef877c0f7979bf3d3e662cf23a740adb72c767ca", "filename": "gcc/ada/a-convec.ads", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "2a706ab4d59e45f6b9b9756ada3636284c76fc85", "filename": "gcc/ada/a-coorma.adb", "status": "added", "additions": 1031, "deletions": 0, "changes": 1031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "7fa06e0e31b5a7ffcb4b9892943e2a85396ad227", "filename": "gcc/ada/a-coorma.ads", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "20712960bf955b9d60a574bc1bd9b63882db5de6", "filename": "gcc/ada/a-coormu.adb", "status": "added", "additions": 1635, "deletions": 0, "changes": 1635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "6d848a8215a59d2894cdf3ef0801440de0112215", "filename": "gcc/ada/a-coormu.ads", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "03cf0036ddb411ac1cf7c66118ce2990147443f6", "filename": "gcc/ada/a-coorse.adb", "status": "added", "additions": 1529, "deletions": 0, "changes": 1529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "1dca837ccb68e6bb6ea37cade1064cfb9fa8791d", "filename": "gcc/ada/a-coorse.ads", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "a27557afd96c1760c8979fea3836b47f073ca319", "filename": "gcc/ada/a-coprnu.adb", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coprnu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coprnu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coprnu.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "9960b9d480f6ea77e5c3114e495aa7df16f0f3c9", "filename": "gcc/ada/a-coprnu.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coprnu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-coprnu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coprnu.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "fe20d457c49f9951bf9015e985c16e17ad2ecf56", "filename": "gcc/ada/a-crbltr.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbltr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbltr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbltr.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "70c8f35278c6a92fdae74e27949a255f60da281f", "filename": "gcc/ada/a-crbtgk.adb", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "445c28b1c9df0d987285fd6b3d5877bcc748044f", "filename": "gcc/ada/a-crbtgk.ads", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "9f9b7125c6f700056c3edfd5035bbc0b2910f97f", "filename": "gcc/ada/a-crbtgo.adb", "status": "added", "additions": 879, "deletions": 0, "changes": 879, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "3e13ae58e855a74e5210bfdb741fa723e65e6ff6", "filename": "gcc/ada/a-crbtgo.ads", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-crbtgo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "d007464952c8e287323f9138c4552246ca987f65", "filename": "gcc/ada/a-lfztio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-lfztio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-lfztio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-lfztio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "1bb3ef50bdf03383777d01bede6a3bf8e052d6e9", "filename": "gcc/ada/a-liztio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-liztio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-liztio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-liztio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "9bda49b3a0e33410b3c3e5e62460cf172fb68398", "filename": "gcc/ada/a-llfzti.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-llfzti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-llfzti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-llfzti.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "75b05df28dc85eb05ee2282665a2649c1c14eaaf", "filename": "gcc/ada/a-llizti.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-llizti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-llizti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-llizti.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "d775234a9c333a1c31999232946a0d1d087bec5e", "filename": "gcc/ada/a-rbtgso.adb", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e22059c0af4843e25f1e0b9a5fd1b0c7e5179108", "filename": "gcc/ada/a-rbtgso.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-rbtgso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-rbtgso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "052632b322663300d2f39516caecb6d4f9fbfe22", "filename": "gcc/ada/a-secain.adb", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-secain.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-secain.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-secain.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "f56b62ac9ee60a66c19d08fb976815d444ea7eee", "filename": "gcc/ada/a-secain.ads", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-secain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-secain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-secain.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "9fea38c8ff02e3c397bc198f40b2250daa20f145", "filename": "gcc/ada/a-sfztio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-sfztio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-sfztio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sfztio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "1c6e78f7f682a20570746014db8bbdb8ce052000", "filename": "gcc/ada/a-shcain.adb", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-shcain.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-shcain.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-shcain.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "24bd62c597863188fc500a60b5c5c51a1c866d05", "filename": "gcc/ada/a-shcain.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-shcain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-shcain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-shcain.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "ea42cc323c552617d8e6a82fce628a3651fb7e3a", "filename": "gcc/ada/a-siztio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-siztio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-siztio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-siztio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "6d395afaab892feed6041fc3fb67a16fa84e5f03", "filename": "gcc/ada/a-slcain.adb", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-slcain.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-slcain.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-slcain.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "c54c6f24ec47fb716c3f1dff08b18543a603789e", "filename": "gcc/ada/a-slcain.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-slcain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-slcain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-slcain.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "a99211042cd96fe26a94f9d12bc2956d5e9ef3e8", "filename": "gcc/ada/a-ssizti.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ssizti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ssizti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ssizti.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "3dffb2006d92f3c7626a03c2e39969e69220bd0a", "filename": "gcc/ada/a-strhas.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-strhas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-strhas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strhas.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b3b71aecdeaca0f87247c3a15be430c12f364c91", "filename": "gcc/ada/a-strhas.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-strhas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-strhas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strhas.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "a6b6920514e6517f2475e012ef3b369afa956b94", "filename": "gcc/ada/a-stunha.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stunha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stunha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunha.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b838bcbdcdfc0f68d63ffbf7fa4211ca3b629823", "filename": "gcc/ada/a-stunha.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stunha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stunha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunha.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "f218b486cc3b287beb4ae4089cb5c7b00298f53f", "filename": "gcc/ada/a-stwiha.adb", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stwiha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stwiha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiha.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "349b8919f1635e8c1b6c2a53a6b6f10a132ec6f2", "filename": "gcc/ada/a-stwiha.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stwiha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stwiha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiha.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "baf4c537d2141f3622a863720eada40cb2aeaf28", "filename": "gcc/ada/a-stzbou.adb", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzbou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzbou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzbou.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "5ea7f7aa480d7159451dab8c4b65b970ddfbd90b", "filename": "gcc/ada/a-stzbou.ads", "status": "added", "additions": 920, "deletions": 0, "changes": 920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzbou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzbou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzbou.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "7ab6e4434c4a46486a8250b9300bf3c3ee16287f", "filename": "gcc/ada/a-stzfix.adb", "status": "added", "additions": 681, "deletions": 0, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzfix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzfix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzfix.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b7f3ae7719421df640566c5ebac9982f69f08c7a", "filename": "gcc/ada/a-stzfix.ads", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzfix.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b6fa3a9904e2504ff649234ef0771d01519ccec2", "filename": "gcc/ada/a-stzhas.adb", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzhas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzhas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzhas.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "f2059288d209a5970a06125847811115aab3ada9", "filename": "gcc/ada/a-stzhas.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzhas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzhas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzhas.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "065f0aca8b2b37720e6e60868d994b3659b2b4a2", "filename": "gcc/ada/a-stzmap.adb", "status": "added", "additions": 744, "deletions": 0, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzmap.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "8d563acffaaf546005c15f0084d0e0d28e840e92", "filename": "gcc/ada/a-stzmap.ads", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzmap.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "bb65fd97742a5cde63815194f20e1d694614d51c", "filename": "gcc/ada/a-stzsea.adb", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsea.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "52e42047ea174b81e85885f12dd46ed88c4684bf", "filename": "gcc/ada/a-stzsea.ads", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsea.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "eac117249d10dd2101b6759daf4e3a85062cb440", "filename": "gcc/ada/a-stzsup.adb", "status": "added", "additions": 1920, "deletions": 0, "changes": 1920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsup.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "55a1db6f1dbf7684f757cdb122215b2b2d1e4ef1", "filename": "gcc/ada/a-stzsup.ads", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsup.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzsup.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsup.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "c6c5c4a9bd8bcc7a9101f69fc4b20fc7405ca075", "filename": "gcc/ada/a-stzunb.adb", "status": "added", "additions": 986, "deletions": 0, "changes": 986, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzunb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzunb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "3090b6ee6b2b916f3402136638c47d989ddd511a", "filename": "gcc/ada/a-stzunb.ads", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzunb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-stzunb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "2d9a2dd0b1ca8150ea6fcbc2188ae7d6e298ee33", "filename": "gcc/ada/a-swunau.adb", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "dbecd4f0b118d00bb082181956bb27d16ee779c1", "filename": "gcc/ada/a-swunau.ads", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "8229494e769a0ffe8106b26fd3419b4b1ccd7657", "filename": "gcc/ada/a-swunha.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunha.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "267392f77f28c9096cfcc5255944d22de5626905", "filename": "gcc/ada/a-swunha.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-swunha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunha.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "d82e2ba8e58e138b07a77b1d57cb14075e2b07f5", "filename": "gcc/ada/a-szmzco.ads", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szmzco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szmzco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szmzco.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e0f1acf50a8a29f7090fe2799480d955cc58529b", "filename": "gcc/ada/a-szunau.adb", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "dff8cb8e6c9fb2c1159e0e6477e7aa0380e27947", "filename": "gcc/ada/a-szunau.ads", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "68e605674cf117a66fbb8be16d06b26a2ce2ea03", "filename": "gcc/ada/a-szunha.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunha.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e1b872104f2711b3acbbf21110a988b847928ee8", "filename": "gcc/ada/a-szunha.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szunha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunha.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e9af2eb1a88523ad4dde6c27057bbb0942bc2340", "filename": "gcc/ada/a-szuzti.adb", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szuzti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szuzti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzti.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "bc4278ac983ed42d3a775825a6cf0fba60d194b9", "filename": "gcc/ada/a-szuzti.ads", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szuzti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-szuzti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzti.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "43406af1c46434d0a198b0930d08be92e764fda2", "filename": "gcc/ada/a-tiunio.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-tiunio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-tiunio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiunio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "665f781a243d39e476b77b23f7d5abe9b0b73b95", "filename": "gcc/ada/a-wwunio.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-wwunio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-wwunio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wwunio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "a1b966fb19436e214be65a3c57e918149d52a68a", "filename": "gcc/ada/a-ztcoau.adb", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcoau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e29fb4c27478b23531911f1096a341540ca1317a", "filename": "gcc/ada/a-ztcoau.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcoau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "9deceee826e5680995479b01bdcfc6809e670a13", "filename": "gcc/ada/a-ztcoio.adb", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcoio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "69e0371ab876e3ce76b41ef118ef3fbfa220196f", "filename": "gcc/ada/a-ztcoio.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcoio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "036964079c42d6b503ec3b25d0d6ac85b133ce75", "filename": "gcc/ada/a-ztcstr.adb", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcstr.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "8627cca287ae5415b89e2b5ef5c9767e18d2c0ab", "filename": "gcc/ada/a-ztcstr.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztcstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztcstr.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "c20d7ad426099356baf86d459c46ee847083c311", "filename": "gcc/ada/a-ztdeau.adb", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztdeau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "e5c8e53d7640e2a98b9d24b18be2446d8605ac27", "filename": "gcc/ada/a-ztdeau.ads", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztdeau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b223cdb44907ab61b9d01f0d8e41a2e715a6a785", "filename": "gcc/ada/a-ztdeio.adb", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztdeio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "694a0bc3c497fb6062546cdef3cff8fa05d21e77", "filename": "gcc/ada/a-ztdeio.ads", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztdeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztdeio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "14de63c1ab21aeb5578f2a1493493139b0e76dac", "filename": "gcc/ada/a-ztedit.adb", "status": "added", "additions": 2773, "deletions": 0, "changes": 2773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztedit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztedit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztedit.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "081b99b24dd14e3f13c0fa36f4c7d526b4453060", "filename": "gcc/ada/a-ztedit.ads", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztedit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztedit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztedit.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "d9ece2b6169e2c00d0a615313d35cac99b08cd27", "filename": "gcc/ada/a-ztenau.adb", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztenau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "0b3f4b49ba245a18165f395fed3117bbd3c60864", "filename": "gcc/ada/a-ztenau.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztenau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "6ab2a192490cb57c9824d0b9af843cadfd659983", "filename": "gcc/ada/a-ztenio.adb", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztenio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "7c06401b195a9b5056cf5909ad00dab88bc89a64", "filename": "gcc/ada/a-ztenio.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztenio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztenio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "25a7cead0963e2ed2318c5b5c185d19fb8a085d4", "filename": "gcc/ada/a-ztexio.adb", "status": "added", "additions": 1898, "deletions": 0, "changes": 1898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztexio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztexio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "d6240674b2c61cb02cc9d9c7f6b94f12116b8e77", "filename": "gcc/ada/a-ztexio.ads", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztexio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztexio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "855e15a7e7374c612138e184c6121e0cbbe3c8f4", "filename": "gcc/ada/a-ztfiio.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztfiio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "ada870c5f77c71b480802bc8f0e0d0a05799ca1f", "filename": "gcc/ada/a-ztfiio.ads", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztfiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztfiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztfiio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b9480521a3dee03e2648dda9f936a3a50e3c72c6", "filename": "gcc/ada/a-ztflau.adb", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztflau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b69d8d4a94f349530813e7964fb517410fea515c", "filename": "gcc/ada/a-ztflau.ads", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztflau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "582fbbc3ba63fd96dd9016cfa674f5c0a9f85ef7", "filename": "gcc/ada/a-ztflio.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztflio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "1b1064eb3d15387f7357aff61e1996fa04b5f6c0", "filename": "gcc/ada/a-ztflio.ads", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztflio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "dd621ef6dc55504bc75a0001878dcb237aa4bdc2", "filename": "gcc/ada/a-ztgeau.adb", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztgeau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "2a41c4251eb9cbfed49c58437334d3f75bea2f46", "filename": "gcc/ada/a-ztgeau.ads", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztgeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztgeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztgeau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "4af54fcf70ea6dd8603f83a43cea85dc918d59ef", "filename": "gcc/ada/a-ztinau.adb", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztinau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "07839965fa4a894eff2c5f01e37ce7a2cb371b0a", "filename": "gcc/ada/a-ztinau.ads", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztinau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "5a8418fdae881406784c93be0442a633499c1ef3", "filename": "gcc/ada/a-ztinio.adb", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztinio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "2ccc0e5290905d12d4ca648991500d7d88ffba1a", "filename": "gcc/ada/a-ztinio.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztinio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "ae673db00669fbb695371304f5ffcb855e24efed", "filename": "gcc/ada/a-ztmoau.adb", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztmoau.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "6b4b2691478c968c14aa2a0ed6fc625b8c4733ca", "filename": "gcc/ada/a-ztmoau.ads", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztmoau.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "ed21c671200b58545858e5c0b50c642e36f81c4c", "filename": "gcc/ada/a-ztmoio.adb", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztmoio.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "dc41a7334e333d0c3004fe529a05655306fcb3ae", "filename": "gcc/ada/a-ztmoio.ads", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-ztmoio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztmoio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "4ba6e00dfc1c3298abdf19cde9e325a5d98ebdd1", "filename": "gcc/ada/a-zttest.adb", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zttest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zttest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zttest.adb?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "b417ecac9253af75c0fc0ba47c47bbad717f5073", "filename": "gcc/ada/a-zttest.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zttest.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zttest.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zttest.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}, {"sha": "fddc8a28c1fef17c513a9d5f5bba1860edfd823e", "filename": "gcc/ada/a-zzunio.ads", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zzunio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2d6a700cb2b4928228a8ebc425750406f1a42a/gcc%2Fada%2Fa-zzunio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zzunio.ads?ref=4c2d6a700cb2b4928228a8ebc425750406f1a42a"}]}