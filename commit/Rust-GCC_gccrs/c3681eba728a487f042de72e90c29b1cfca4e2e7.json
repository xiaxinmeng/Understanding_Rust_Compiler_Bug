{"sha": "c3681eba728a487f042de72e90c29b1cfca4e2e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM2ODFlYmE3MjhhNDg3ZjA0MmRlNzJlOTBjMjliMWNmY2E0ZTJlNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2021-03-28T03:28:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-21T10:45:13Z"}, "message": "[Ada] Implementation of AI12-205: defaults for formal types\n\ngcc/ada/\n\n\t* gen_il-fields.ads: Add Default_Subtype_Mark to enumeration\n\ttype for fields.\n\t* gen_il-gen-gen_nodes.adb: Add call to create new field for\n\tFormal_Type_Declaration node.\n\t* par-ch12.adb (P_Formal_Type_Declaration): in Ada_2022 mode,\n\trecognize new syntax for default: \"or use subtype_mark\".\n\t(P_Formal_Type_Definition): Ditto for the case of a formal\n\tincomplete type.\n\t* sinfo.ads: Add field Default_Subtype_Mark to\n\tN_Formal_Type_Declaration.\n\t* sem_ch12.adb (Validate_Formal_Type_Default): New procedure, to\n\tapply legality rules to default subtypes in formal type\n\tdeclarations. Some legality rules apply to all defaults, such as\n\tthe requirement that the default for a formal type that depends\n\ton previous formal entities must itself be a previously declared\n\tformal of the same unit. Other checks are kind- specific.\n\t(Analyze_Associations): Use specified default if there is no\n\tactual provided for a formal type in an instance.\n\t(Analyze_Formal_Type_Declaration): Call\n\tValidate_Formal_Type_Default when default subtype is present.", "tree": {"sha": "ae1f6f76a8f2f58aabe16968cf238ed88029feaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae1f6f76a8f2f58aabe16968cf238ed88029feaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3681eba728a487f042de72e90c29b1cfca4e2e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3681eba728a487f042de72e90c29b1cfca4e2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3681eba728a487f042de72e90c29b1cfca4e2e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3681eba728a487f042de72e90c29b1cfca4e2e7/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "336438b6d225c3a5f28d57fd766e36f53faf8f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336438b6d225c3a5f28d57fd766e36f53faf8f3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/336438b6d225c3a5f28d57fd766e36f53faf8f3e"}], "stats": {"total": 480, "additions": 474, "deletions": 6}, "files": [{"sha": "768b116fc011536343eb9f1d72a0d9f90aace6c1", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=c3681eba728a487f042de72e90c29b1cfca4e2e7", "patch": "@@ -136,6 +136,7 @@ package Gen_IL.Fields is\n       Default_Expression,\n       Default_Storage_Pool,\n       Default_Name,\n+      Default_Subtype_Mark,\n       Defining_Identifier,\n       Defining_Unit_Name,\n       Delay_Alternative,"}, {"sha": "c50caeb8eab69913ade01dca3704341501d23cbb", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=c3681eba728a487f042de72e90c29b1cfca4e2e7", "patch": "@@ -610,7 +610,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Defining_Identifier, Node_Id),\n         Sy (Formal_Type_Definition, Node_Id),\n         Sy (Discriminant_Specifications, List_Id, Default_No_List),\n-        Sy (Unknown_Discriminants_Present, Flag)));\n+        Sy (Unknown_Discriminants_Present, Flag),\n+        Sy (Default_Subtype_Mark, Node_Id)));\n \n    Cc (N_Full_Type_Declaration, N_Declaration,\n        (Sy (Defining_Identifier, Node_Id),"}, {"sha": "eac3643bdc03f6752a52d09b38f253abde9a7c3f", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=c3681eba728a487f042de72e90c29b1cfca4e2e7", "patch": "@@ -559,6 +559,20 @@ package body Ch12 is\n \n       if Def_Node /= Error then\n          Set_Formal_Type_Definition (Decl_Node, Def_Node);\n+\n+         if Token = Tok_Or then\n+            Error_Msg_Ada_2022_Feature\n+              (\"default for formal type\", Sloc (Decl_Node));\n+            Scan;   --  Past OR\n+\n+            if Token /= Tok_Use then\n+               Error_Msg_SC (\"missing USE for default subtype\");\n+            else\n+               Scan;   -- Past USE\n+               Set_Default_Subtype_Mark (Decl_Node, P_Name);\n+            end if;\n+         end if;\n+\n          P_Aspect_Specifications (Decl_Node);\n \n       else\n@@ -727,11 +741,18 @@ package body Ch12 is\n                return Error;\n             end if;\n \n+         when Tok_Or =>\n+            --  Ada_2022: incomplete type with default\n+            return\n+                 New_Node (N_Formal_Incomplete_Type_Definition, Token_Ptr);\n+\n          when Tok_Private =>\n             return P_Formal_Private_Type_Definition;\n \n          when Tok_Tagged =>\n-            if Next_Token_Is (Tok_Semicolon) then\n+            if Next_Token_Is (Tok_Semicolon)\n+              or else Next_Token_Is (Tok_Or)\n+            then\n                Typedef_Node :=\n                  New_Node (N_Formal_Incomplete_Type_Definition, Token_Ptr);\n                Set_Tagged_Present (Typedef_Node);"}, {"sha": "9ccc5c5263f25e74053592fae75ebb24234cef09", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 448, "deletions": 4, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c3681eba728a487f042de72e90c29b1cfca4e2e7", "patch": "@@ -888,6 +888,17 @@ package body Sem_Ch12 is\n    --  Verify that an attribute that appears as the default for a formal\n    --  subprogram is a function or procedure with the correct profile.\n \n+   procedure Validate_Formal_Type_Default (Decl : Node_Id);\n+   --  Ada_2022 AI12-205: if a default subtype_mark is present, verify\n+   --  that it is the name of a type in the same class as the formal.\n+   --  The treatment parallels what is done in Instantiate_Type but differs\n+   --  in a few ways so that this machinery cannot be reused as is: on one\n+   --  hand there are no visibility issues for a default, because it is\n+   --  analyzed in the same context as the formal type definition; on the\n+   --  other hand the check needs to take into acount the use of a previous\n+   --  formal type in the current formal type definition (see details in\n+   --  AI12-0205).\n+\n    -------------------------------------------\n    -- Data Structures for Generic Renamings --\n    -------------------------------------------\n@@ -1762,6 +1773,14 @@ package body Sem_Ch12 is\n                      if Partial_Parameterization then\n                         Process_Default (Formal);\n \n+                     elsif Present (Default_Subtype_Mark (Formal)) then\n+                        Match := New_Copy (Default_Subtype_Mark (Formal));\n+                        Append_List\n+                         (Instantiate_Type\n+                          (Formal, Match, Analyzed_Formal, Assoc_List),\n+                            Assoc_List);\n+                        Append_Elmt (Entity (Match), Actuals_To_Freeze);\n+\n                      else\n                         Error_Msg_Sloc := Sloc (Gen_Unit);\n                         Error_Msg_NE\n@@ -3528,6 +3547,10 @@ package body Sem_Ch12 is\n       Set_Is_Generic_Type (T);\n       Set_Is_First_Subtype (T);\n \n+      if Present (Default_Subtype_Mark (Original_Node (N))) then\n+         Validate_Formal_Type_Default (N);\n+      end if;\n+\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, T);\n       end if;\n@@ -12683,6 +12706,11 @@ package body Sem_Ch12 is\n       --  declaration, it carries the flag No_Predicate_On_Actual. it is part\n       --  of the generic contract that the actual cannot have predicates.\n \n+      function Subtypes_Match (Gen_T, Act_T : Entity_Id) return Boolean;\n+      --  Check that base types are the same and that the subtypes match\n+      --  statically. Used in several of the validation subprograms for\n+      --  actuals in instantiations.\n+\n       procedure Validate_Array_Type_Instance;\n       procedure Validate_Access_Subprogram_Instance;\n       procedure Validate_Access_Type_Instance;\n@@ -12696,10 +12724,6 @@ package body Sem_Ch12 is\n       --  Validate_Discriminated_Formal_Type is shared by formal private\n       --  types and Ada 2012 formal incomplete types.\n \n-      function Subtypes_Match (Gen_T, Act_T : Entity_Id) return Boolean;\n-      --  Check that base types are the same and that the subtypes match\n-      --  statically. Used in several of the validation subprograms.\n-\n       --------------------------------------------\n       --  Check_Shared_Variable_Control_Aspects --\n       --------------------------------------------\n@@ -16991,4 +17015,424 @@ package body Sem_Ch12 is\n       end if;\n    end Valid_Default_Attribute;\n \n+   ----------------------------------\n+   -- Validate_Formal_Type_Default --\n+   ----------------------------------\n+\n+   procedure Validate_Formal_Type_Default (Decl : Node_Id) is\n+      Default : constant Node_Id :=\n+        Default_Subtype_Mark (Original_Node (Decl));\n+      Formal  : constant Entity_Id := Defining_Identifier (Decl);\n+\n+      Def_Sub  : Entity_Id;     --  Default subtype mark\n+      Type_Def : Node_Id;\n+\n+      procedure Check_Discriminated_Formal;\n+      --  Check that discriminants of default for private or incomplete\n+      --  type match those of formal type.\n+\n+      function Reference_Formal (N : Node_Id) return Traverse_Result;\n+      --  Check whether formal type definition mentions a previous formal\n+      --  type of the same generic.\n+\n+      ----------------------\n+      -- Reference_Formal --\n+      ----------------------\n+\n+      function Reference_Formal (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Entity_Name (N)\n+           and then Scope (Entity (N)) = Current_Scope\n+         then\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Reference_Formal;\n+\n+      function Depends_On_Other_Formals is\n+           new Traverse_Func (Reference_Formal);\n+\n+      function Default_Subtype_Matches\n+        (Gen_T, Def_T : Entity_Id) return Boolean;\n+\n+      procedure Validate_Array_Type_Default;\n+      --  Verify that dimension, indices, and component types of default\n+      --  are compatible with formal array type definition.\n+\n+      procedure Validate_Derived_Type_Default;\n+      --  Verify that ancestor and progenitor types match.\n+\n+      ---------------------------------\n+      -- Check_Discriminated_Formal --\n+      ---------------------------------\n+\n+      procedure Check_Discriminated_Formal is\n+         Formal_Discr : Entity_Id;\n+         Actual_Discr : Entity_Id;\n+         Formal_Subt  : Entity_Id;\n+\n+      begin\n+         if Has_Discriminants (Formal) then\n+            if not Has_Discriminants (Def_Sub) then\n+               Error_Msg_NE\n+                 (\"default for & must have discriminants\", Default, Formal);\n+\n+            elsif Is_Constrained (Def_Sub) then\n+               Error_Msg_NE\n+                 (\"default for & must be unconstrained\", Default, Formal);\n+\n+            else\n+               Formal_Discr := First_Discriminant (Formal);\n+               Actual_Discr := First_Discriminant (Def_Sub);\n+               while Formal_Discr /= Empty loop\n+                  if Actual_Discr = Empty then\n+                     Error_Msg_N\n+                       (\"discriminants on Formal do not match formal\",\n+                        Default);\n+                  end if;\n+\n+                  Formal_Subt := Etype (Formal_Discr);\n+\n+                  --  Access discriminants match if designated types do\n+\n+                  if Ekind (Base_Type (Formal_Subt)) = E_Anonymous_Access_Type\n+                    and then (Ekind (Base_Type (Etype (Actual_Discr)))) =\n+                                E_Anonymous_Access_Type\n+                    and then\n+                        Designated_Type (Base_Type (Formal_Subt)) =\n+                           Designated_Type (Base_Type (Etype (Actual_Discr)))\n+                  then\n+                     null;\n+\n+                  elsif Base_Type (Formal_Subt) /=\n+                          Base_Type (Etype (Actual_Discr))\n+                  then\n+                     Error_Msg_N\n+                       (\"types of discriminants of default must match formal\",\n+                        Default);\n+\n+                  elsif not Subtypes_Statically_Match\n+                              (Formal_Subt, Etype (Actual_Discr))\n+                    and then Ada_Version >= Ada_95\n+                  then\n+                     Error_Msg_N\n+                       (\"subtypes of discriminants of default \"\n+                         & \"must match formal\",\n+                        Default);\n+                  end if;\n+\n+                  Next_Discriminant (Formal_Discr);\n+                  Next_Discriminant (Actual_Discr);\n+               end loop;\n+\n+               if Actual_Discr /= Empty then\n+                  Error_Msg_NE\n+                    (\"discriminants on default do not match formal\",\n+                     Default, Formal);\n+               end if;\n+            end if;\n+         end if;\n+      end Check_Discriminated_Formal;\n+\n+      ---------------------------\n+      -- Default_Subtype_Matches --\n+      ---------------------------\n+\n+      function Default_Subtype_Matches\n+        (Gen_T, Def_T : Entity_Id) return Boolean\n+      is\n+      begin\n+         --  Check that the base types, root types (when dealing with class\n+         --  wide types), or designated types (when dealing with anonymous\n+         --  access types) of Gen_T and Def_T are statically matching subtypes.\n+\n+         return (Base_Type (Gen_T) = Base_Type (Def_T)\n+                  and then Subtypes_Statically_Match (Gen_T, Def_T))\n+\n+           or else (Is_Class_Wide_Type (Gen_T)\n+                     and then Is_Class_Wide_Type (Def_T)\n+                     and then Default_Subtype_Matches\n+                                (Root_Type (Gen_T), Root_Type (Def_T)))\n+\n+           or else (Is_Anonymous_Access_Type (Gen_T)\n+               and then Ekind (Def_T) = Ekind (Gen_T)\n+               and then Subtypes_Statically_Match\n+                          (Designated_Type (Gen_T), Designated_Type (Def_T)));\n+\n+      end Default_Subtype_Matches;\n+\n+      ----------------------------------\n+      --  Validate_Array_Type_Default --\n+      ----------------------------------\n+\n+      procedure Validate_Array_Type_Default is\n+         I1, I2 : Node_Id;\n+         T2     : Entity_Id;\n+      begin\n+         if not Is_Array_Type (Def_Sub) then\n+            Error_Msg_NE (\"default for& must be an array type \",\n+              Default, Formal);\n+            return;\n+\n+         elsif Number_Dimensions (Def_Sub) /= Number_Dimensions (Formal)\n+           or else Is_Constrained (Def_Sub) /=\n+                   Is_Constrained (Formal)\n+         then\n+            Error_Msg_NE (\"default array type does not match&\",\n+              Default, Formal);\n+            return;\n+         end if;\n+\n+         I1 := First_Index (Formal);\n+         I2 := First_Index (Def_Sub);\n+         for J in 1 .. Number_Dimensions (Formal) loop\n+\n+            --  If the indexes of the actual were given by a subtype_mark,\n+            --  the index was transformed into a range attribute. Retrieve\n+            --  the original type mark for checking.\n+\n+            if Is_Entity_Name (Original_Node (I2)) then\n+               T2 := Entity (Original_Node (I2));\n+            else\n+               T2 := Etype (I2);\n+            end if;\n+\n+            if not Subtypes_Statically_Match (Etype (I1), T2) then\n+               Error_Msg_NE\n+                 (\"index types of default do not match those of formal &\",\n+                  Default, Formal);\n+            end if;\n+\n+            Next_Index (I1);\n+            Next_Index (I2);\n+         end loop;\n+\n+         if not Default_Subtype_Matches\n+           (Component_Type (Formal), Component_Type (Def_Sub))\n+         then\n+            Error_Msg_NE\n+              (\"component subtype of default does not match that of formal &\",\n+               Default, Formal);\n+         end if;\n+\n+         if Has_Aliased_Components (Formal)\n+           and then not Has_Aliased_Components (Default)\n+         then\n+            Error_Msg_NE\n+              (\"default must have aliased components to match formal type &\",\n+               Default, Formal);\n+         end if;\n+      end Validate_Array_Type_Default;\n+\n+      -----------------------------------\n+      -- Validate_Derived_Type_Default --\n+      -----------------------------------\n+\n+      procedure Validate_Derived_Type_Default is\n+      begin\n+         if not Is_Ancestor (Etype (Formal), Def_Sub) then\n+            Error_Msg_NE (\"default must be a descendent of&\",\n+              Default, Etype (Formal));\n+         end if;\n+\n+         if Has_Interfaces (Formal) then\n+            if not Has_Interfaces (Def_Sub) then\n+               Error_Msg_NE\n+                 (\"default must implement all interfaces of formal&\",\n+                   Default, Formal);\n+\n+            else\n+               declare\n+                  Act_Iface_List : Elist_Id;\n+                  Iface          : Node_Id;\n+                  Iface_Ent      : Entity_Id;\n+\n+               begin\n+                  Iface := First (Abstract_Interface_List (Formal));\n+                  Collect_Interfaces (Def_Sub, Act_Iface_List);\n+\n+                  while Present (Iface) loop\n+                     Iface_Ent := Entity (Iface);\n+\n+                     if Is_Ancestor (Iface_Ent, Def_Sub)\n+                      or else Is_Progenitor (Iface_Ent, Def_Sub)\n+                     then\n+                        null;\n+\n+                     else\n+                        Error_Msg_NE\n+                          (\"Default must implement interface&\",\n+                           Default, Etype (Iface));\n+                     end if;\n+\n+                     Next (Iface);\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+      end Validate_Derived_Type_Default;\n+\n+      --  Start of processing for Validate_Formal_Type_Default\n+\n+   begin\n+      Analyze (Default);\n+      if not Is_Entity_Name (Default)\n+        or else not Is_Type (Entity (Default))\n+      then\n+         Error_Msg_N\n+           (\"Expect type name for default of formal type\", Default);\n+         return;\n+      else\n+         Def_Sub := Entity (Default);\n+      end if;\n+\n+      --  Formal derived_type declarations are transformed into full\n+      --  type declarations or Private_Type_Extensions for ease of processing.\n+\n+      if Nkind (Decl) = N_Full_Type_Declaration then\n+         Type_Def := Type_Definition (Decl);\n+\n+      elsif Nkind (Decl) = N_Private_Extension_Declaration then\n+         Type_Def := Subtype_Indication (Decl);\n+\n+      else\n+         Type_Def := Formal_Type_Definition (Decl);\n+      end if;\n+\n+      if Depends_On_Other_Formals (Type_Def) = Abandon\n+           and then Scope (Def_Sub) /= Current_Scope\n+      then\n+         Error_Msg_N (\"default of formal type that depends on \"\n+           & \"other formals must be a previous formal type\", Default);\n+         return;\n+\n+      elsif Def_Sub = Formal then\n+         Error_Msg_N\n+           (\"default for formal type cannot be formal itsef\", Default);\n+         return;\n+      end if;\n+\n+      case Nkind (Type_Def) is\n+\n+         when N_Formal_Private_Type_Definition =>\n+            if (Is_Abstract_Type (Formal)\n+              and then not Is_Abstract_Type (Def_Sub))\n+            or else (Is_Limited_Type (Formal)\n+              and then not Is_Limited_Type (Def_Sub))\n+            then\n+               Error_Msg_NE\n+                 (\"default for private type$ does not match\",\n+                     Default, Formal);\n+            end if;\n+\n+            Check_Discriminated_Formal;\n+\n+         when N_Formal_Derived_Type_Definition =>\n+            Check_Discriminated_Formal;\n+            Validate_Derived_Type_Default;\n+\n+         when N_Formal_Incomplete_Type_Definition =>\n+            if Is_Tagged_Type (Formal)\n+              and then not Is_Tagged_Type (Def_Sub)\n+            then\n+               Error_Msg_NE\n+                 (\"default for & must be a tagged type\", Default, Formal);\n+            end if;\n+\n+            Check_Discriminated_Formal;\n+\n+         when N_Formal_Discrete_Type_Definition =>\n+            if not Is_Discrete_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be a discrete type\",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Formal_Signed_Integer_Type_Definition =>\n+            if not Is_Integer_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be a discrete type\",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Formal_Modular_Type_Definition =>\n+            if not Is_Modular_Integer_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be a modular_integer Type\",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Formal_Floating_Point_Definition =>\n+            if not Is_Floating_Point_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be a floating_point type\",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Formal_Ordinary_Fixed_Point_Definition =>\n+            if not Is_Ordinary_Fixed_Point_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be \"\n+                 & \"an ordinary_fixed_point type \",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Formal_Decimal_Fixed_Point_Definition =>\n+            if not Is_Decimal_Fixed_Point_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be \"\n+                 & \"an Decimal_fixed_point type \",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Array_Type_Definition =>\n+            Validate_Array_Type_Default;\n+\n+         when N_Access_Function_Definition |\n+           N_Access_Procedure_Definition =>\n+            if Ekind (Def_Sub) /= E_Access_Subprogram_Type then\n+               Error_Msg_NE (\"default for& must be an Access_To_Subprogram\",\n+                 Default, Formal);\n+            end if;\n+            Check_Subtype_Conformant\n+              (Designated_Type (Formal), Designated_Type (Def_Sub));\n+\n+         when N_Access_To_Object_Definition =>\n+            if not Is_Access_Object_Type (Def_Sub) then\n+               Error_Msg_NE (\"default for& must be an Access_To_Object\",\n+                Default, Formal);\n+\n+            elsif not Default_Subtype_Matches\n+              (Designated_Type (Formal), Designated_Type (Def_Sub))\n+            then\n+               Error_Msg_NE (\"designated type of defaul does not match \"\n+                 & \"designated type of formal type\",\n+                 Default, Formal);\n+            end if;\n+\n+         when N_Record_Definition =>   -- Formal interface type\n+            if not Is_Interface (Def_Sub) then\n+               Error_Msg_NE\n+                 (\"default for formal interface type must be an interface\",\n+                  Default, Formal);\n+\n+            elsif Is_Limited_Type (Def_Sub) /= Is_Limited_Type (Formal)\n+              or else Is_Task_Interface (Formal) /= Is_Task_Interface (Def_Sub)\n+              or else Is_Protected_Interface (Formal) /=\n+                      Is_Protected_Interface (Def_Sub)\n+              or else Is_Synchronized_Interface (Formal) /=\n+                      Is_Synchronized_Interface (Def_Sub)\n+            then\n+               Error_Msg_NE\n+                 (\"default for interface& does not match\", Def_Sub, Formal);\n+            end if;\n+\n+         when N_Derived_Type_Definition =>\n+            Validate_Derived_Type_Default;\n+\n+         when N_Identifier =>   --  case of a private extension\n+            Validate_Derived_Type_Default;\n+\n+         when N_Error =>\n+            null;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Validate_Formal_Type_Default;\n end Sem_Ch12;"}, {"sha": "fe4f4e142b5694c453a1472be4328684785642d9", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3681eba728a487f042de72e90c29b1cfca4e2e7/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=c3681eba728a487f042de72e90c29b1cfca4e2e7", "patch": "@@ -7195,6 +7195,7 @@ package Sinfo is\n       --  Discriminant_Specifications (set to No_List if no\n       --   discriminant part)\n       --  Unknown_Discriminants_Present set if (<>) discriminant\n+      --  Default_Subtype_Mark\n \n       ----------------------------------\n       -- 12.5  Formal type definition --"}]}