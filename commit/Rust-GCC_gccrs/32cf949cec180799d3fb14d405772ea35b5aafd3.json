{"sha": "32cf949cec180799d3fb14d405772ea35b5aafd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJjZjk0OWNlYzE4MDc5OWQzZmIxNGQ0MDU3NzJlYTM1YjVhYWZkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-06-18T14:47:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-06-18T14:47:42Z"}, "message": "[AArch64] Simplify SVE IFN_COND patterns\n\nThis patch makes the binary IFN_COND patterns use the same approach\nas the ternary patterns, with one pattern handling the cases in\nwhich the \"else\" value isn't tied to one of the other inputs.\n\n2019-06-18  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64-sve.md (*cond_<optab><mode>_0): Delete.\n\t(*cond_<optab><mode>_z): Fold into...\n\t(*cond_<optab><mode>_any): ...here.  Also handle cases in which\n\toperand 4 can be tied to operand 0 (either inherently or via RA).\n\nFrom-SVN: r272423", "tree": {"sha": "b8426319a68dcbbac69dfb62873e25dd232bff46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8426319a68dcbbac69dfb62873e25dd232bff46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32cf949cec180799d3fb14d405772ea35b5aafd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32cf949cec180799d3fb14d405772ea35b5aafd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32cf949cec180799d3fb14d405772ea35b5aafd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32cf949cec180799d3fb14d405772ea35b5aafd3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d34c64796b1daf4d9ff452313e021e15d9df4cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34c64796b1daf4d9ff452313e021e15d9df4cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34c64796b1daf4d9ff452313e021e15d9df4cb8"}], "stats": {"total": 196, "additions": 63, "deletions": 133}, "files": [{"sha": "19ab09e0aaae82e20a1a63d3bfbb355536cf3429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32cf949cec180799d3fb14d405772ea35b5aafd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32cf949cec180799d3fb14d405772ea35b5aafd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32cf949cec180799d3fb14d405772ea35b5aafd3", "patch": "@@ -1,3 +1,10 @@\n+2019-06-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-sve.md (*cond_<optab><mode>_0): Delete.\n+\t(*cond_<optab><mode>_z): Fold into...\n+\t(*cond_<optab><mode>_any): ...here.  Also handle cases in which\n+\toperand 4 can be tied to operand 0 (either inherently or via RA).\n+\n 2019-06-18  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/90900"}, {"sha": "ed895a8a17327268769b0af11bc76a03913b393d", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 56, "deletions": 133, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32cf949cec180799d3fb14d405772ea35b5aafd3/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32cf949cec180799d3fb14d405772ea35b5aafd3/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=32cf949cec180799d3fb14d405772ea35b5aafd3", "patch": "@@ -1868,41 +1868,6 @@\n   \"TARGET_SVE\"\n )\n \n-;; Predicated integer operations with select matching the output operand.\n-(define_insn \"*cond_<optab><mode>_0\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"+w, w, ?&w\")\n-\t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n-\t   (SVE_INT_BINARY:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"0, w, w\")\n-\t     (match_operand:SVE_I 3 \"register_operand\" \"w, 0, w\"))\n-\t   (match_dup 0)]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"@\n-   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n-   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n-   movprfx\\t%0, %1/m, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"*,*,yes\")]\n-)\n-\n-(define_insn \"*cond_<optab><mode>_0\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"+w, w, ?&w\")\n-\t(unspec:SVE_SDI\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n-\t   (SVE_INT_BINARY_SD:SVE_SDI\n-\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w, w\")\n-\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w, 0, w\"))\n-\t   (match_dup 0)]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"@\n-   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n-   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n-   movprfx\\t%0, %1/m, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"*,*,yes\")]\n-)\n-\n ;; Predicated integer operations with select matching the first operand.\n (define_insn \"*cond_<optab><mode>_2\"\n   [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, ?&w\")\n@@ -1969,78 +1934,64 @@\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n-;; Predicated integer operations with select matching zero.\n-(define_insn \"*cond_<optab><mode>_z\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w\")\n-\t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (SVE_INT_BINARY:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n-\t   (match_operand:SVE_I 4 \"aarch64_simd_imm_zero\")]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"yes\")]\n-)\n-\n-(define_insn \"*cond_<optab><mode>_z\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w\")\n-\t(unspec:SVE_SDI\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (SVE_INT_BINARY_SD:SVE_SDI\n-\t     (match_operand:SVE_SDI 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w\"))\n-\t   (match_operand:SVE_SDI 4 \"aarch64_simd_imm_zero\")]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"yes\")]\n-)\n-\n-;; Synthetic predications with select unmatched.\n+;; Predicated integer binary operations in which the values of inactive\n+;; lanes are distinct from the other inputs.\n (define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w, &w, &w, &w, ?&w\")\n \t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n \t   (SVE_INT_BINARY:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n-\t   (match_operand:SVE_I 4 \"register_operand\"   \"w\")]\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"0, w, w, w, w\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w, 0, w, w, w\"))\n+\t   (match_operand:SVE_I 4 \"aarch64_simd_reg_or_zero\" \"Dz, Dz, Dz, 0, w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\n-   && !(rtx_equal_p (operands[0], operands[4])\n-        || rtx_equal_p (operands[2], operands[4])\n-        || rtx_equal_p (operands[3], operands[4]))\"\n-  \"#\"\n-  \"&& reload_completed\"\n+   && !rtx_equal_p (operands[2], operands[4])\n+   && !rtx_equal_p (operands[3], operands[4])\"\n+  \"@\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/m, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   #\"\n+  \"&& reload_completed\n+   && register_operand (operands[4], <MODE>mode)\n+   && !rtx_equal_p (operands[0], operands[4])\"\n   {\n     emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n \t\t\t\t\t     operands[4], operands[1]));\n     operands[4] = operands[2] = operands[0];\n   }\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n (define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w\")\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w, &w, &w, &w, ?&w\")\n \t(unspec:SVE_SDI\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (SVE_INT_BINARY_SD:SVE_I\n-\t     (match_operand:SVE_SDI 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w\"))\n-\t   (match_operand:SVE_SDI 4 \"register_operand\"   \"w\")]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n+\t   (SVE_INT_BINARY_SD:SVE_SDI\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w, w, w, w\")\n+\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w, 0, w, w, w\"))\n+\t   (match_operand:SVE_SDI 4 \"aarch64_simd_reg_or_zero\" \"Dz, Dz, Dz, 0, w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\n-   && !(rtx_equal_p (operands[0], operands[4])\n-        || rtx_equal_p (operands[2], operands[4])\n-        || rtx_equal_p (operands[3], operands[4]))\"\n-  \"#\"\n-  \"&& reload_completed\"\n+   && !rtx_equal_p (operands[2], operands[4])\n+   && !rtx_equal_p (operands[3], operands[4])\"\n+  \"@\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/m, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   #\"\n+  \"&& reload_completed\n+   && register_operand (operands[4], <MODE>mode)\n+   && !rtx_equal_p (operands[0], operands[4])\"\n   {\n     emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n \t\t\t\t\t     operands[4], operands[1]));\n     operands[4] = operands[2] = operands[0];\n   }\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n ;; Set operand 0 to the last active element in operand 3, or to tied\n@@ -2874,25 +2825,6 @@\n   \"TARGET_SVE\"\n )\n \n-;; Predicated floating-point operations with select matching output.\n-(define_insn \"*cond_<optab><mode>_0\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"+w, w, ?&w\")\n-\t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n-\t   (unspec:SVE_F\n-\t     [(match_operand:SVE_F 2 \"register_operand\" \"0, w, w\")\n-\t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w\")]\n-\t     SVE_COND_FP_BINARY)\n-\t   (match_dup 0)]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"@\n-   <sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n-   <sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n-   movprfx\\t%0, %1/m, %2\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"*,*,yes\")]\n-)\n-\n ;; Predicated floating-point operations with select matching first operand.\n (define_insn \"*cond_<optab><mode>_2\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n@@ -2929,45 +2861,36 @@\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n-;; Predicated floating-point operations with select matching zero.\n-(define_insn \"*cond_<optab><mode>_z\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w\")\n-\t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (unspec:SVE_F\n-\t     [(match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n-\t     SVE_COND_FP_BINARY)\n-\t   (match_operand:SVE_F 4 \"aarch64_simd_imm_zero\")]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n-  [(set_attr \"movprfx\" \"yes\")]\n-)\n-\n-;; Synthetic predication of floating-point operations with select unmatched.\n+;; Predicated floating-point binary operations in which the values of\n+;; inactive lanes are distinct from the other inputs.\n (define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w, &w, &w, &w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"0, w, w, w, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w, w, w\")]\n \t     SVE_COND_FP_BINARY)\n-\t   (match_operand:SVE_F 4 \"register_operand\" \"w\")]\n+\t   (match_operand:SVE_F 4 \"aarch64_simd_reg_or_zero\" \"Dz, Dz, Dz, 0, w\")]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"#\"\n+  \"TARGET_SVE\n+   && !rtx_equal_p (operands[2], operands[4])\n+   && !rtx_equal_p (operands[3], operands[4])\"\n+  \"@\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0.<Vetype>, %1/m, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   #\"\n   \"&& reload_completed\n-   && !(rtx_equal_p (operands[0], operands[4])\n-        || rtx_equal_p (operands[2], operands[4])\n-        || rtx_equal_p (operands[3], operands[4]))\"\n-  ; Not matchable by any one insn or movprfx insn.  We need a separate select.\n+   && register_operand (operands[4], <MODE>mode)\n+   && !rtx_equal_p (operands[0], operands[4])\"\n   {\n     emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n \t\t\t\t\t     operands[4], operands[1]));\n     operands[4] = operands[2] = operands[0];\n   }\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n ;; Predicated floating-point ternary operations with select."}]}