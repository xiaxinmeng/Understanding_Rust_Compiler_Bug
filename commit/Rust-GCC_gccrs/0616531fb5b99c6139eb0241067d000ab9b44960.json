{"sha": "0616531fb5b99c6139eb0241067d000ab9b44960", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxNjUzMWZiNWI5OWM2MTM5ZWIwMjQxMDY3ZDAwMGFiOWI0NDk2MA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-05-06T18:13:35Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-05-06T18:13:35Z"}, "message": "Use new tail-calling mechanism on ARM.\n\n* arm.md (sibcall, sibcall_value): New expands.\n(sibcall_insn, sibcall_value_insn, sibcall_epilogue): New insns.\n(tailcalling peepholes): Delete.\n(push_multi): Simplify.\n* arm.c (lr_save_eliminated): Delete definition.\n(pattern_really_clobbers_lr, function_really_clobbers_lr): Delete.\n(output_return_instruction): Remove checks on lr_save_eliminated.\n(output_arm_prologue): Remove old tail-calling code.\n(arm_output_epilogue): New parameter, really_return.  All callers\nchanged.  Handle tail-calling epilogues.\n* arm.h (lr_save_eliminated): Delete declaration.\n(frame_pointer_needed): Delete declaration.\n* arm-protos.h (arm_output_epilogue): Adjust prototype.\n\n* arm.md (is_thumb): Examine symbol thumb_code, not expression\nTARGET_ARM.\n* arm.c (thumb_code): Define it.\n(arm_override_options): Set it.\n* arm.h (thumb_code): Declare it.\n\nFrom-SVN: r33731", "tree": {"sha": "d111ccb15b7572bbaf8d52dd2c4ab1c9a3146cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d111ccb15b7572bbaf8d52dd2c4ab1c9a3146cf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0616531fb5b99c6139eb0241067d000ab9b44960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0616531fb5b99c6139eb0241067d000ab9b44960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0616531fb5b99c6139eb0241067d000ab9b44960", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0616531fb5b99c6139eb0241067d000ab9b44960/comments", "author": null, "committer": null, "parents": [{"sha": "76fa6b3b73f655f8739d6704a1769ad98abaaecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fa6b3b73f655f8739d6704a1769ad98abaaecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fa6b3b73f655f8739d6704a1769ad98abaaecf"}], "stats": {"total": 482, "additions": 166, "deletions": 316}, "files": [{"sha": "be9337f39ad86c2a089e96928095f8f251cd0f08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0616531fb5b99c6139eb0241067d000ab9b44960", "patch": "@@ -1,3 +1,26 @@\n+2000-05-06  Richard Earnshaw (reanrsha@arm.com)\n+\n+\tUse new tail-calling mechanism on ARM.\n+\t* arm.md (sibcall, sibcall_value): New expands.\n+\t(sibcall_insn, sibcall_value_insn, sibcall_epilogue): New insns.\n+\t(tailcalling peepholes): Delete.\n+\t(push_multi): Simplify.\n+\t* arm.c (lr_save_eliminated): Delete definition.\n+\t(pattern_really_clobbers_lr, function_really_clobbers_lr): Delete.\n+\t(output_return_instruction): Remove checks on lr_save_eliminated.\n+\t(output_arm_prologue): Remove old tail-calling code.\n+\t(arm_output_epilogue): New parameter, really_return.  All callers\n+\tchanged.  Handle tail-calling epilogues.\n+\t* arm.h (lr_save_eliminated): Delete declaration.\n+\t(frame_pointer_needed): Delete declaration.\n+\t* arm-protos.h (arm_output_epilogue): Adjust prototype.\n+\n+\t* arm.md (is_thumb): Examine symbol thumb_code, not expression\n+\tTARGET_ARM.\n+\t* arm.c (thumb_code): Define it.\n+\t(arm_override_options): Set it.\n+\t* arm.h (thumb_code): Declare it.\n+\t\n 2000-05-06  Richard Earnshaw (reanrsha@arm.com)\n \n \t* arm-protos.h (arm_dllexport_name_p, arm_dllimport_name_p): Constify."}, {"sha": "8a3cb5b3001299d4f82a585b93f10378f9192aa5", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=0616531fb5b99c6139eb0241067d000ab9b44960", "patch": "@@ -27,7 +27,7 @@ extern int    arm_process_pragma\tPARAMS ((int (*)(void), void (*) (int),\n \t\t\t\t\t\tchar *));\n extern void   arm_finalize_pic\t\tPARAMS ((void));\n extern int    arm_volatile_func\t\tPARAMS ((void));\n-extern char * arm_output_epilogue\tPARAMS ((void));\n+extern char * arm_output_epilogue\tPARAMS ((int));\n extern void   output_func_epilogue\tPARAMS ((int));\n extern void   arm_expand_prologue\tPARAMS ((void));\n /* Used in arm.md, but defined in output.c.  */"}, {"sha": "206224d6a0a487f80aa836aeb01d1ba33e0b9e83", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 52, "deletions": 201, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0616531fb5b99c6139eb0241067d000ab9b44960", "patch": "@@ -64,13 +64,11 @@ static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n static rtx\t emit_sfm\t\t\tPARAMS ((int, int));\n static char *    fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n-static int       function_really_clobbers_lr\tPARAMS ((rtx));\n static arm_cc    get_arm_condition_code\t\tPARAMS ((rtx));\n static void      init_fpa_table\t\t\tPARAMS ((void));\n static Hint      int_log2\t\t\tPARAMS ((Hint));\n static rtx       is_jump_table \t\t\tPARAMS ((rtx));\n static char *    output_multi_immediate\t\tPARAMS ((rtx *, char *, char *, int, Hint));\n-static int       pattern_really_clobbers_lr\tPARAMS ((rtx));\n static void      print_multi_reg\t\tPARAMS ((FILE *, char *, int, int, int));\n static Mmode     select_dominance_cc_mode\tPARAMS ((rtx, rtx, Hint));\n static char *    shift_op\t\t\tPARAMS ((rtx, Hint *));\n@@ -171,6 +169,9 @@ int arm_is_strong = 0;\n /* Nonzero if this chip is a an ARM6 or an ARM7.  */\n int arm_is_6_or_7 = 0;\n \n+/* Nonzero if generating Thumb instructions.  */\n+int thumb_code = 0;\n+\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n    PRINT_OPERAND_ADDRESS.  */\n@@ -183,10 +184,6 @@ int current_function_anonymous_args;\n const char * arm_pic_register_string = NULL;\n int arm_pic_register = 9;\n \n-/* Set to one if we think that lr is only saved because of subroutine calls,\n-   but all of these can be `put after' return insns.  */\n-int lr_save_eliminated;\n-\n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed.  */\n int return_used_this_function;\n@@ -569,6 +566,7 @@ arm_override_options ()\n   \n   arm_ld_sched      = (tune_flags & FL_LDSCHED) != 0;\n   arm_is_strong     = (tune_flags & FL_STRONG) != 0;\n+  thumb_code\t    = (TARGET_ARM == 0);\n   arm_is_6_or_7     = (((tune_flags & (FL_MODE26 | FL_MODE32))\n \t\t       && !(tune_flags & FL_ARCH4))) != 0;\n   \n@@ -6449,151 +6447,6 @@ output_ascii_pseudo_op (stream, p, len)\n }\n \f\n \n-/* Try to determine whether a pattern really clobbers the link register.\n-   This information is useful when peepholing, so that lr need not be pushed\n-   if we combine a call followed by a return.\n-   NOTE: This code does not check for side-effect expressions in a SET_SRC:\n-   such a check should not be needed because these only update an existing\n-   value within a register; the register must still be set elsewhere within\n-   the function.  */\n-static int\n-pattern_really_clobbers_lr (x)\n-     rtx x;\n-{\n-  int i;\n-  \n-  switch (GET_CODE (x))\n-    {\n-    case SET:\n-      switch (GET_CODE (SET_DEST (x)))\n-\t{\n-\tcase REG:\n-\t  return REGNO (SET_DEST (x)) == LR_REGNUM;\n-\n-        case SUBREG:\n-\t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == REG)\n-\t    return REGNO (XEXP (SET_DEST (x), 0)) == LR_REGNUM;\n-\n-\t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == MEM)\n-\t    return 0;\n-\t  abort ();\n-\n-        default:\n-\t  return 0;\n-        }\n-\n-    case PARALLEL:\n-      for (i = 0; i < XVECLEN (x, 0); i++)\n-\tif (pattern_really_clobbers_lr (XVECEXP (x, 0, i)))\n-\t  return 1;\n-      return 0;\n-\n-    case CLOBBER:\n-      switch (GET_CODE (XEXP (x, 0)))\n-        {\n-\tcase REG:\n-\t  return REGNO (XEXP (x, 0)) == LR_REGNUM;\n-\n-        case SUBREG:\n-\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n-\t    return REGNO (XEXP (XEXP (x, 0), 0)) == LR_REGNUM;\n-\t  abort ();\n-\n-        default:\n-\t  return 0;\n-        }\n-\n-    case UNSPEC:\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-static int\n-function_really_clobbers_lr (first)\n-     rtx first;\n-{\n-  rtx insn, next;\n-  \n-  for (insn = first; insn; insn = next_nonnote_insn (insn))\n-    {\n-      switch (GET_CODE (insn))\n-        {\n-\tcase BARRIER:\n-\tcase NOTE:\n-\tcase CODE_LABEL:\n-\tcase JUMP_INSN:\t\t/* Jump insns only change the PC (and conds) */\n-\t  break;\n-\n-        case INSN:\n-\t  if (pattern_really_clobbers_lr (PATTERN (insn)))\n-\t    return 1;\n-\t  break;\n-\n-        case CALL_INSN:\n-\t  /* Don't yet know how to handle those calls that are not to a \n-\t     SYMBOL_REF.  */\n-\t  if (GET_CODE (PATTERN (insn)) != PARALLEL)\n-\t    abort ();\n-\n-\t  switch (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)))\n-\t    {\n-\t    case CALL:\n-\t      if (GET_CODE (XEXP (XEXP (XVECEXP (PATTERN (insn), 0, 0), 0), 0))\n-\t\t  != SYMBOL_REF)\n-\t\treturn 1;\n-\t      break;\n-\n-\t    case SET:\n-\t      if (GET_CODE (XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn),\n-\t\t\t\t\t\t\t  0, 0)), 0), 0))\n-\t\t  != SYMBOL_REF)\n-\t\treturn 1;\n-\t      break;\n-\n-\t    default:\t/* Don't recognize it, be safe.  */\n-\t      return 1;\n-\t    }\n-\n-\t  /* A call can be made (by peepholing) not to clobber lr iff it is\n-\t     followed by a return.  There may, however, be a use insn iff\n-\t     we are returning the result of the call. \n-\t     If we run off the end of the insn chain, then that means the\n-\t     call was at the end of the function.  Unfortunately we don't\n-\t     have a return insn for the peephole to recognize, so we\n-\t     must reject this.  (Can this be fixed by adding our own insn?) */\n-\t  if ((next = next_nonnote_insn (insn)) == NULL)\n-\t    return 1;\n-\n-\t  /* No need to worry about lr if the call never returns.  */\n-\t  if (GET_CODE (next) == BARRIER)\n-\t    break;\n-\n-\t  if (GET_CODE (next) == INSN\n-\t      && GET_CODE (PATTERN (next)) == USE\n-\t      && (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t      && (GET_CODE (XEXP (PATTERN (next), 0)) == REG)\n-\t      && (REGNO (SET_DEST (XVECEXP (PATTERN (insn), 0, 0)))\n-\t\t  == REGNO (XEXP (PATTERN (next), 0))))\n-\t    if ((next = next_nonnote_insn (next)) == NULL)\n-\t      return 1;\n-\n-\t  if (GET_CODE (next) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (next)) == RETURN)\n-\t    break;\n-\t  return 1;\n-\n-        default:\n-\t  abort ();\n-        }\n-    }\n-\n-  /* We have reached the end of the chain so lr was _not_ clobbered.  */\n-  return 0;\n-}\n-\n char *\n output_return_instruction (operand, really_return, reverse)\n      rtx operand;\n@@ -6646,7 +6499,7 @@ output_return_instruction (operand, really_return, reverse)\n       && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     live_regs++;\n \n-  if (live_regs || (regs_ever_live[LR_REGNUM] && ! lr_save_eliminated))\n+  if (live_regs || regs_ever_live[LR_REGNUM])\n     live_regs++;\n \n   if (frame_pointer_needed)\n@@ -6656,21 +6509,17 @@ output_return_instruction (operand, really_return, reverse)\n      load a single register.  On other architectures, the cost is the same.  */\n   if (live_regs == 1\n       && regs_ever_live[LR_REGNUM]\n-      && ! lr_save_eliminated\n-      /* FIXME: We ought to handle the case TARGET_APCS_32 is true,\n-\t really_return is true, and only the PC needs restoring.  */\n       && ! really_return)\n     output_asm_insn (reverse ? \"ldr%?%D0\\t%|lr, [%|sp], #4\" \n \t\t     : \"ldr%?%d0\\t%|lr, [%|sp], #4\", &operand);\n   else if (live_regs == 1\n \t   && regs_ever_live[LR_REGNUM]\n-\t   && ! lr_save_eliminated\n \t   && TARGET_APCS_32)\n     output_asm_insn (reverse ? \"ldr%?%D0\\t%|pc, [%|sp], #4\"\n \t\t     : \"ldr%?%d0\\t%|pc, [%|sp], #4\", &operand);\n   else if (live_regs)\n     {\n-      if (lr_save_eliminated || ! regs_ever_live[LR_REGNUM])\n+      if (! regs_ever_live[LR_REGNUM])\n         live_regs++;\n \n       if (frame_pointer_needed)\n@@ -6835,7 +6684,6 @@ output_arm_prologue (f, frame_size)\n     return;\n \n   return_used_this_function = 0;\n-  lr_save_eliminated = 0;\n   \n   asm_fprintf (f, \"\\t%@ args = %d, pretend = %d, frame = %d\\n\",\n \t       current_function_args_size,\n@@ -6868,26 +6716,15 @@ output_arm_prologue (f, frame_size)\n     live_regs_mask |= 0xD800;\n   else if (regs_ever_live[LR_REGNUM])\n     {\n-      if (! current_function_args_size\n-\t  && ! function_really_clobbers_lr (get_insns ()))\n-\tlr_save_eliminated = 1;\n-      else\n-        live_regs_mask |= 1 << LR_REGNUM;\n-    }\n-\n-  if (live_regs_mask)\n-    {\n-      /* If a di mode load/store multiple is used, and the base register\n-\t is r3, then r4 can become an ever live register without lr\n-\t doing so,  in this case we need to push lr as well, or we\n-\t will fail to get a proper return.  */\n       live_regs_mask |= 1 << LR_REGNUM;\n-      lr_save_eliminated = 0;\n-\n     }\n \n-  if (lr_save_eliminated)\n-    asm_fprintf (f,\"\\t%@ I don't think this function clobbers lr\\n\");\n+  if (live_regs_mask)\n+    /* If a di mode load/store multiple is used, and the base register\n+       is r3, then r4 can become an ever live register without lr\n+       doing so,  in this case we need to push lr as well, or we\n+       will fail to get a proper return.  */\n+    live_regs_mask |= 1 << LR_REGNUM;\n \n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n@@ -6896,7 +6733,8 @@ output_arm_prologue (f, frame_size)\n }\n \n char *\n-arm_output_epilogue ()\n+arm_output_epilogue (really_return)\n+     int really_return;\n {\n   int reg;\n   int live_regs_mask = 0;\n@@ -6920,6 +6758,11 @@ arm_output_epilogue ()\n      R1; otherwise, it's in LR.  */\n   return_regnum = eh_ofs ? 2 : LR_REGNUM;\n \n+  /* If we are throwing an exception, then we really must be doing a return,\n+     so we can't tail-call.  */\n+  if (eh_ofs && ! really_return)\n+    abort();\n+\n   /* A volatile function should never return.  Call abort.  */\n   if (TARGET_ABORT_NORETURN && volatile_func)\n     {\n@@ -7010,17 +6853,22 @@ arm_output_epilogue ()\n \t  if (eh_ofs)\n \t    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n \t\t\t REGNO (eh_ofs));\n-\t  asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n+\t  if (really_return)\n+\t    asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n \t}\n-      else if (eh_ofs)\n+      else if (eh_ofs || ! really_return)\n \t{\n \t  live_regs_mask |= 0x6800;\n \t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask, FALSE);\n-\t  asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t       REGNO (eh_ofs));\n-\t  /* Even in 26-bit mode we do a mov (rather than a movs) because\n-\t     we don't have the PSR bits set in the address.  */\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n+\t  if (eh_ofs)\n+\t    {\n+\t      asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n+\t\t\t   REGNO (eh_ofs));\n+\t      /* Even in 26-bit mode we do a mov (rather than a movs)\n+\t\t because we don't have the PSR bits set in the\n+\t\t address.  */\n+\t      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n+\t    }\n \t}\n       else\n \t{\n@@ -7083,8 +6931,7 @@ arm_output_epilogue ()\n \t{\n \t  if (TARGET_INTERWORK)\n \t    {\n-\t      if (! lr_save_eliminated)\n-\t\tlive_regs_mask |= 1 << LR_REGNUM;\n+\t      live_regs_mask |= 1 << LR_REGNUM;\n \n \t      /* Handle LR on its own.  */\n \t      if (live_regs_mask == (1 << LR_REGNUM))\n@@ -7104,12 +6951,9 @@ arm_output_epilogue ()\n \t\tasm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n \t\t\t     REGNO (eh_ofs));\n \n-\t      asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n+\t      if (really_return)\n+\t\tasm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n \t    }\n-\t  else if (lr_save_eliminated)\n-\t    asm_fprintf (f,\n-\t\t\t TARGET_APCS_32 ? \"\\tmov\\t%r, %r\\n\" : \"\\tmovs\\t%r, %r\\n\",\n-\t\t\t PC_REGNUM, LR_REGNUM);\n \t  else if (eh_ofs)\n \t    {\n \t      if (live_regs_mask == 0)\n@@ -7123,8 +6967,13 @@ arm_output_epilogue ()\n \t      /* Jump to the target; even in 26-bit mode.  */\n \t      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n \t    }\n-\t  else if (TARGET_APCS_32 && live_regs_mask == 0)\n+\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && ! really_return)\n+\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n+\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && really_return)\n \t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", PC_REGNUM, SP_REGNUM);\n+\t  else if (! really_return)\n+\t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM,\n+\t\t\t     live_regs_mask | (1 << LR_REGNUM), FALSE);\n \t  else\n \t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM,\n \t\t\t     live_regs_mask | (1 << PC_REGNUM),\n@@ -7135,8 +6984,7 @@ arm_output_epilogue ()\n \t  if (live_regs_mask || regs_ever_live[LR_REGNUM])\n \t    {\n \t      /* Restore the integer regs, and the return address into lr.  */\n-\t      if (! lr_save_eliminated)\n-\t\tlive_regs_mask |= 1 << LR_REGNUM;\n+\t      live_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask == (1 << LR_REGNUM))\n \t\t{\n@@ -7163,14 +7011,17 @@ arm_output_epilogue ()\n \t  if (eh_ofs)\n \t    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n \t\t\t REGNO (eh_ofs));\n-\t  \n-\t  /* And finally, go home.  */\n-\t  if (TARGET_INTERWORK)\n-\t    asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n-\t  else if (TARGET_APCS_32 || eh_ofs)\n-\t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n-\t  else\n-\t    asm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n+\n+\t  if (really_return)\n+\t    {\n+\t      /* And finally, go home.  */\n+\t      if (TARGET_INTERWORK)\n+\t\tasm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n+\t      else if (TARGET_APCS_32 || eh_ofs)\n+\t\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n+\t      else\n+\t\tasm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n+\t    }\n \t}\n     }\n "}, {"sha": "d4c553f6b1ed412c38c813b82cd248c238c24997", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0616531fb5b99c6139eb0241067d000ab9b44960", "patch": "@@ -66,9 +66,6 @@ extern char * arm_condition_codes[];\n extern int arm_target_label;\n extern int arm_ccfsm_state;\n extern struct rtx_def * arm_target_insn;\n-extern int lr_save_eliminated;\n-/* This is needed by the tail-calling peepholes */\n-extern int frame_pointer_needed;\n /* Run-time compilation parameters selecting different hardware subsets.  */\n extern int target_flags;\n /* The floating point instruction architecture, can be 2 or 3 */\n@@ -540,6 +537,9 @@ extern int arm_arch5;\n /* Nonzero if this chip can benefit from load scheduling.  */\n extern int arm_ld_sched;\n \n+/* Nonzero if generating thumb code.  */\n+extern int thumb_code;\n+\n /* Nonzero if this chip is a StrongARM.  */\n extern int arm_is_strong;\n "}, {"sha": "69e7c9bddb133b65beb99db41ffa68ead4d1abab", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 87, "deletions": 111, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0616531fb5b99c6139eb0241067d000ab9b44960/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0616531fb5b99c6139eb0241067d000ab9b44960", "patch": "@@ -40,7 +40,7 @@\n \f\n ;; Attributes\n \n-(define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"TARGET_ARM\")))\n+(define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"thumb_code\")))\n \n ; PROG_MODE attribute is used to determine whether condition codes are\n ; clobbered by a call insn: they are if in prog32 mode.  This is controlled\n@@ -6024,7 +6024,8 @@\n \t (match_operand:SI 1 \"\" \"\"))\n    (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"TARGET_THUMB && operands[2] == const0_rtx && (GET_CODE (operands[0]) == SYMBOL_REF)\"\n+  \"TARGET_THUMB\n+   && operands[2] == const0_rtx && (GET_CODE (operands[0]) == SYMBOL_REF)\"\n   \"bl\\\\t%a0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call\")]\n@@ -6036,12 +6037,79 @@\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"TARGET_THUMB && operands[3] == const0_rtx && (GET_CODE (operands[1]) == SYMBOL_REF)\"\n+  \"TARGET_THUMB\n+   && operands[3] == const0_rtx && (GET_CODE (operands[1]) == SYMBOL_REF)\"\n   \"bl\\\\t%a1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call\")]\n )\n \n+;; We may also be able to do sibcalls for Thumb, but it's much harder...\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n+\t\t    (match_operand 1 \"general_operand\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))])]\n+  \"TARGET_ARM\"\n+  \"\n+  {\n+    if (operands[2] == NULL_RTX)\n+      operands[2] = const0_rtx;\n+\n+    /* If we need to emit a long-call, we can't do it as a sibling call,\n+       so fail over to a normal call.  */\n+    if (arm_is_longcall_p (operands[0], INTVAL (operands[2]), 0))\n+      {\n+\temit_call_insn (gen_call (operands[0], operands[1], operands[2]));\n+\tDONE;\n+      }\n+  }\"\n+)\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand 2 \"general_operand\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))])]\n+  \"TARGET_ARM\"\n+  \"\n+  {\n+    if (operands[3] == NULL_RTX)\n+      operands[3] = const0_rtx;\n+\n+    /* If we need to emit a long-call, we can't do it as a sibling call,\n+       so fail over to a normal call.  */\n+    if (arm_is_longcall_p (operands[1], INTVAL (operands[3]), 0))\n+      {\n+\temit_call_insn (gen_call_value (operands[0], operands[1], operands[2],\n+\t\t\t\t\toperands[3]));\n+\tDONE;\n+      }\n+  }\"\n+)\n+\n+(define_insn \"*sibcall_insn\"\n+ [(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n+\t(match_operand 1 \"\" \"\"))\n+  (use (match_operand 2 \"\" \"\"))]\n+  \"TARGET_ARM && GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"*\n+  return NEED_PLT_RELOC ? \\\"b%?\\\\t%a0(PLT)\\\" : \\\"b%?\\\\t%a0\\\";\n+  \"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*sibcall_value_insn\"\n+ [(set (match_operand 0 \"s_register_operand\" \"=rf\")\n+       (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n+\t     (match_operand 2 \"\" \"\")))\n+  (use (match_operand 3 \"\" \"\"))]\n+  \"TARGET_ARM && GET_CODE (operands[1]) == SYMBOL_REF\"\n+  \"*\n+  return NEED_PLT_RELOC ? \\\"b%?\\\\t%a1(PLT)\\\" : \\\"b%?\\\\t%a1\\\";\n+  \"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n ;; Often the return insn will be the same as loading from memory, so set attr\n (define_insn \"return\"\n   [(return)]\n@@ -7791,103 +7859,6 @@\n   return emit_stm_seq (operands, 2);\n \")\n \n-;; A call followed by return can be replaced by restoring the regs and\n-;; jumping to the subroutine, provided we aren't passing the address of\n-;; any of our local variables.  If we call alloca then this is unsafe\n-;; since restoring the frame frees the memory, which is not what we want.\n-;; Sometimes the return might have been targeted by the final prescan:\n-;; if so then emit a proper return insn as well.\n-;; Unfortunately, if the frame pointer is required, we don't know if the\n-;; current function has any implicit stack pointer adjustments that will \n-;; be restored by the return: we can't therefore do a tail call.\n-;; Another unfortunate that we can't handle is if current_function_args_size\n-;; is non-zero: in this case elimination of the argument pointer assumed\n-;; that lr was pushed onto the stack, so eliminating upsets the offset\n-;; calculations.\n-\n-(define_peephole\n-  [(parallel [(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n-\t\t\t  (match_operand:SI 1 \"general_operand\" \"g\"))\n-\t\t    (use (match_operand 2 \"\" \"\"))\n-\t\t    (clobber (reg:SI 14))])\n-   (return)]\n-  \"TARGET_ARM\n-   && (GET_CODE (operands[0]) == SYMBOL_REF && USE_RETURN_INSN (FALSE)\n-    && !get_frame_size () && !current_function_calls_alloca\n-    && !frame_pointer_needed && !current_function_args_size)\"\n-  \"*\n-{\n-  if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n-    {\n-      arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n-      output_return_instruction (NULL, TRUE, FALSE);\n-      arm_ccfsm_state = 0;\n-      arm_target_insn = NULL;\n-    }\n-\n-  output_return_instruction (NULL, FALSE, FALSE);\n-  return NEED_PLT_RELOC ? \\\"b%?\\\\t%a0(PLT)\\\" : \\\"b%?\\\\t%a0\\\";\n-}\"\n-[(set_attr \"type\" \"call\")\n- (set_attr \"length\" \"8\")])\n-\n-(define_peephole\n-  [(parallel [(set (match_operand 0 \"s_register_operand\" \"=rf\")\n-\t\t   (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI 14))])\n-   (return)]\n-  \"TARGET_ARM && (GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN (FALSE)\n-    && !get_frame_size () && !current_function_calls_alloca\n-    && !frame_pointer_needed && !current_function_args_size)\"\n-  \"*\n-{\n-  if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n-    {\n-      arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n-      output_return_instruction (NULL, TRUE, FALSE);\n-      arm_ccfsm_state = 0;\n-      arm_target_insn = NULL;\n-    }\n-\n-  output_return_instruction (NULL, FALSE, FALSE);\n-  return NEED_PLT_RELOC ? \\\"b%?\\\\t%a1(PLT)\\\" : \\\"b%?\\\\t%a1\\\";\n-}\"\n-[(set_attr \"type\" \"call\")\n- (set_attr \"length\" \"8\")])\n-\n-;; As above but when this function is not void, we must be returning the\n-;; result of the called subroutine.\n-\n-(define_peephole\n-  [(parallel [(set (match_operand 0 \"s_register_operand\" \"=rf\")\n-\t\t   (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI 14))])\n-   (use (match_dup 0))\n-   (return)]\n-  \"TARGET_ARM\n-   && (GET_CODE (operands[1]) == SYMBOL_REF && USE_RETURN_INSN (FALSE)\n-    && !get_frame_size () && !current_function_calls_alloca\n-    && !frame_pointer_needed && !current_function_args_size)\"\n-  \"*\n-{\n-  if (arm_ccfsm_state && arm_target_insn && INSN_DELETED_P (arm_target_insn))\n-    {\n-      arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n-      output_return_instruction (NULL, TRUE, FALSE);\n-      arm_ccfsm_state = 0;\n-      arm_target_insn = NULL;\n-    }\n-\n-  output_return_instruction (NULL, FALSE, FALSE);\n-  return \\\"b%?\\\\t%a1\\\";\n-}\"\n-[(set_attr \"type\" \"call\")\n- (set_attr \"length\" \"8\")])\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(and:SI (ge:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -7952,12 +7923,26 @@\n   \"\n )\n \n+(define_insn \"sibcall_epilogue\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"TARGET_ARM\"\n+  \"*\n+  output_asm_insn (\\\"%@ Sibcall epilogue\\\", operands);\n+  if (USE_RETURN_INSN (FALSE))\n+    return output_return_instruction (NULL, FALSE, FALSE);\n+  return arm_output_epilogue (FALSE);\n+  \"\n+;; Length is absolute worst case\n+  [(set_attr \"length\" \"44\")\n+   (set_attr \"type\" \"block\")]\n+)\n+\n (define_insn \"*epilogue_insns\"\n   [(unspec_volatile [(return)] 1)]\n   \"TARGET_EITHER\"\n   \"*\n   if (TARGET_ARM)\n-    return arm_output_epilogue ();\n+    return arm_output_epilogue (TRUE);\n   else /* TARGET_THUMB */\n     return thumb_unexpanded_epilogue ();\n   \"\n@@ -8094,26 +8079,17 @@\n   \"TARGET_ARM\"\n   \"*\n {\n-  extern int lr_save_eliminated;\n   int num_saves = XVECLEN (operands[2], 0);\n      \n-  if (lr_save_eliminated)\n-    {\n-      if (num_saves > 1)\n-\tabort ();\n-    }\n   /* For the StrongARM at least it is faster to\n      use STR to store only a single register.  */\n-  else if (num_saves == 1)\n+  if (num_saves == 1)\n     output_asm_insn (\\\"str\\\\t%1, [%m0, #-4]!\\\", operands);\n   else\n     {\n       int i;\n       char pattern[100];\n \n-      if (lr_save_eliminated)\n-\tabort ();\n-\n       strcpy (pattern, \\\"stmfd\\\\t%m0!, {%1\\\");\n \t\t       \n       for (i = 1; i < num_saves; i++)"}]}