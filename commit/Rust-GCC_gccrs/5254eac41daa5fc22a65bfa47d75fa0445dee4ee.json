{"sha": "5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI1NGVhYzQxZGFhNWZjMjJhNjViZmE0N2Q3NWZhMDQ0NWRlZTRlZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-09-26T03:28:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-26T03:28:03Z"}, "message": "tree-flow.h (thread_through_all_blocks): Prototype moved into tree-ssa-threadupdate.h.\n\n\t* tree-flow.h (thread_through_all_blocks): Prototype moved into\n\ttree-ssa-threadupdate.h.\n\t(register_jump_thread): Similarly.\n\t* tree-ssa-threadupdate.h: New header file.\n\t* tree-ssa-dom.c: Include tree-ssa-threadupdate.h.\n\t* tree-vrp.c: Likewise.\n\t* tree-ssa-threadedge.c: Include tree-ssa-threadupdate.h.\n\t(thread_around_empty_blocks): Change type of path vector argument to\n\tan edge,type pair from just an edge.  Initialize both elements when\n\tappending to a jump threading path.  Tweak references to elements\n\tappropriately.\n\t(thread_across_edge): Similarly.  Release memory for the elements\n\tas needed.\n\t* tree-ssa-threadupdate.c: Include tree-ssa-threadupdate.h.\n\t(dump_jump_thread_path): New function broken out from\n\tregister_jump_thread.\n\t(register_jump_thread): Use dump_jump_thread_path.  Change type of\n\tpath vector entries.  Search the path for NULL edges and dump\n\tthe path if one is found.  Tweak the conversion of path to 3-edge\n\tform to use the block copy type information embedded in the path.\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-3.c: Update expected output.\n\nFrom-SVN: r202933", "tree": {"sha": "51aec5a2d37e7596f984fc1365e772fdecb9e80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51aec5a2d37e7596f984fc1365e772fdecb9e80b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/comments", "author": null, "committer": null, "parents": [{"sha": "9adc2b3c52c22752ffccfce101959f82e577e0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adc2b3c52c22752ffccfce101959f82e577e0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adc2b3c52c22752ffccfce101959f82e577e0f1"}], "stats": {"total": 230, "additions": 178, "deletions": 52}, "files": [{"sha": "8871aca6d144ef23937e17966bb3d44e0e6d51fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -1,3 +1,26 @@\n+2013-09-25  Jeff Law  <law@redhat.com>\n+\n+\t* tree-flow.h (thread_through_all_blocks): Prototype moved into\n+\ttree-ssa-threadupdate.h.\n+\t(register_jump_thread): Similarly.\n+\t* tree-ssa-threadupdate.h: New header file.\n+\t* tree-ssa-dom.c: Include tree-ssa-threadupdate.h.\n+\t* tree-vrp.c: Likewise.\n+\t* tree-ssa-threadedge.c: Include tree-ssa-threadupdate.h.\n+\t(thread_around_empty_blocks): Change type of path vector argument to\n+\tan edge,type pair from just an edge.  Initialize both elements when\n+\tappending to a jump threading path.  Tweak references to elements\n+\tappropriately.\n+\t(thread_across_edge): Similarly.  Release memory for the elements\n+\tas needed.\n+\t* tree-ssa-threadupdate.c: Include tree-ssa-threadupdate.h.\n+\t(dump_jump_thread_path): New function broken out from\n+\tregister_jump_thread.\n+\t(register_jump_thread): Use dump_jump_thread_path.  Change type of\n+\tpath vector entries.  Search the path for NULL edges and dump\n+\tthe path if one is found.  Tweak the conversion of path to 3-edge\n+\tform to use the block copy type information embedded in the path.\n+\n 2013-09-25  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* lra.c (update_inc_notes): Remove all REG_DEAD and REG_UNUSED notes."}, {"sha": "a72615cb5d507fb1d6d42c21a4b62d464e587b95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -1,3 +1,7 @@\n+2013-09-25  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-3.c: Update expected output.\n+\n 2013-09-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/58436"}, {"sha": "222a97b4a12f572e7965647f7e36f4e327357cbd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-3.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-3.c?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -43,7 +43,6 @@ expand_one_var (tree var, unsigned char toplevel, unsigned char really_expand)\n }\n /* We should thread the jump, through an intermediate block.  */\n /* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Registering jump thread .through joiner block.: \\\\(.*\\\\);  \\\\(.*\\\\);  \\\\(.*\\\\);\" 1 \"dom1\"} } */\n-\n+/* { dg-final { scan-tree-dump-times \"Registering jump thread: \\\\(.*\\\\) incoming edge;  \\\\(.*\\\\) joiner;  \\\\(.*\\\\) nocopy;\" 1 \"dom1\"} } */\n /* { dg-final { cleanup-tree-dump \"dom1\" } } */\n "}, {"sha": "ee691791aae88478bc1f4ee10f781ad5a2b3b852", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -641,10 +641,6 @@ bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t      addr_space_t);\n bool may_be_nonaddressable_p (tree expr);\n \n-/* In tree-ssa-threadupdate.c.  */\n-extern bool thread_through_all_blocks (bool);\n-extern void register_jump_thread (vec<edge>, bool);\n-\n /* In gimplify.c  */\n tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n tree force_gimple_operand (tree, gimple_seq *, bool, tree);"}, {"sha": "81119c3689173d6325c405d23b1f2561cd47f6e9", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"tree-ssa-threadupdate.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n "}, {"sha": "467d9827a52b6e4a03775bfee908ac49e6790008", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"tree-ssa.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"tree-ssa-threadupdate.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n \n@@ -753,7 +754,7 @@ thread_around_empty_blocks (edge taken_edge,\n \t\t\t    bool handle_dominating_asserts,\n \t\t\t    tree (*simplify) (gimple, gimple),\n \t\t\t    bitmap visited,\n-\t\t\t    vec<edge> *path)\n+\t\t\t    vec<jump_thread_edge *> *path)\n {\n   basic_block bb = taken_edge->dest;\n   gimple_stmt_iterator gsi;\n@@ -791,8 +792,10 @@ thread_around_empty_blocks (edge taken_edge,\n \t  if ((taken_edge->flags & EDGE_DFS_BACK) == 0\n \t      && !bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n+\t      jump_thread_edge *x\n+\t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+\t      path->safe_push (x);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n-\t      path->safe_push (taken_edge);\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n \t\t\t\t\t\t handle_dominating_asserts,\n@@ -828,7 +831,11 @@ thread_around_empty_blocks (edge taken_edge,\n       if (bitmap_bit_p (visited, taken_edge->dest->index))\n \treturn false;\n       bitmap_set_bit (visited, taken_edge->dest->index);\n-      path->safe_push (taken_edge);\n+\n+      jump_thread_edge *x\n+\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+      path->safe_push (x);\n+\n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n \t\t\t\t  handle_dominating_asserts,\n@@ -922,9 +929,13 @@ thread_across_edge (gimple dummy_cond,\n \t  if (dest == NULL || dest == e->dest)\n \t    goto fail;\n \n-\t  vec<edge> path = vNULL;\n-\t  path.safe_push (e);\n-\t  path.safe_push (taken_edge);\n+\t  vec<jump_thread_edge *> path = vNULL;\n+          jump_thread_edge *x\n+\t    = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n+\t  path.safe_push (x);\n+\n+\t  x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);\n+\t  path.safe_push (x);\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n@@ -947,8 +958,11 @@ thread_across_edge (gimple dummy_cond,\n \t    }\n \n \t  remove_temporary_equivalences (stack);\n-\t  propagate_threaded_block_debug_into (path.last ()->dest, e->dest);\n-\t  register_jump_thread (path, false);\n+\t  propagate_threaded_block_debug_into (path.last ()->e->dest,\n+\t\t\t\t\t       e->dest);\n+\t  register_jump_thread (path);\n+\t  for (unsigned int i = 0; i < path.length (); i++)\n+\t    delete path[i];\n \t  path.release ();\n \t  return;\n \t}\n@@ -978,15 +992,18 @@ thread_across_edge (gimple dummy_cond,\n \tbitmap_clear (visited);\n \tbitmap_set_bit (visited, taken_edge->dest->index);\n \tbitmap_set_bit (visited, e->dest->index);\n-        vec<edge> path = vNULL;\n+        vec<jump_thread_edge *> path = vNULL;\n \n \t/* Record whether or not we were able to thread through a successor\n \t   of E->dest.  */\n-\tpath.safe_push (e);\n-\tpath.safe_push (taken_edge);\n+        jump_thread_edge *x = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n+\tpath.safe_push (x);\n+\n+        x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);\n+\tpath.safe_push (x);\n \tfound = false;\n \tif ((e->flags & EDGE_DFS_BACK) == 0\n-\t    || ! cond_arg_set_in_bb (path.last (), e->dest))\n+\t    || ! cond_arg_set_in_bb (path.last ()->e, e->dest))\n \t  found = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t      dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n@@ -998,11 +1015,13 @@ thread_across_edge (gimple dummy_cond,\n \t   record the jump threading opportunity.  */\n \tif (found)\n \t  {\n-\t    propagate_threaded_block_debug_into (path.last ()->dest,\n+\t    propagate_threaded_block_debug_into (path.last ()->e->dest,\n \t\t\t\t\t\t taken_edge->dest);\n-\t    register_jump_thread (path, true);\n+\t    register_jump_thread (path);\n \t  }\n \n+\tfor (unsigned int i = 0; i < path.length (); i++)\n+\t  delete path[i];\n         path.release();\n       }\n     BITMAP_FREE (visited);"}, {"sha": "75273ca3da5784521c8d75e23b31608f390d4e34", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 70, "deletions": 32, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"function.h\"\n #include \"tree-ssa.h\"\n+#include \"tree-ssa-threadupdate.h\"\n #include \"dumpfile.h\"\n #include \"cfgloop.h\"\n #include \"hash-table.h\"\n@@ -1380,6 +1381,39 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   return retval;\n }\n \n+/* Dump a jump threading path, including annotations about each\n+   edge in the path.  */\n+\n+static void\n+dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path)\n+{\n+  fprintf (dump_file,\n+\t   \"  Registering jump thread: (%d, %d) incoming edge; \",\n+\t   path[0]->e->src->index, path[0]->e->dest->index);\n+\n+  for (unsigned int i = 1; i < path.length (); i++)\n+    {\n+      /* We can get paths with a NULL edge when the final destination\n+\t of a jump thread turns out to be a constant address.  We dump\n+\t those paths when debugging, so we have to be prepared for that\n+\t possibility here.  */\n+      if (path[i]->e == NULL)\n+\tcontinue;\n+\n+      if (path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\tfprintf (dump_file, \" (%d, %d) joiner; \",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+      if (path[i]->type == EDGE_COPY_SRC_BLOCK)\n+       fprintf (dump_file, \" (%d, %d) normal;\",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+      if (path[i]->type == EDGE_NO_COPY_SRC_BLOCK)\n+       fprintf (dump_file, \" (%d, %d) nocopy;\",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+    }\n+  fputc ('\\n', dump_file);\n+}\n+\n+\n /* Register a jump threading opportunity.  We queue up all the jump\n    threading opportunities discovered by a pass and update the CFG\n    and SSA form all at once.\n@@ -1389,43 +1423,47 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n    after fixing the SSA graph.  */\n \n void\n-register_jump_thread (vec<edge> path, bool through_joiner)\n+register_jump_thread (vec<jump_thread_edge *> path)\n {\n-  /* Convert PATH into 3 edge representation we've been using.  This\n-     is temporary until we convert this file to use a path representation\n-     throughout.  */\n-  edge e = path[0];\n-  edge e2 = path[1];\n-  edge e3;\n-\n-  if (!through_joiner)\n-    e3 = NULL;\n-  else\n-    e3 = path.last ();\n+  /* First make sure there are no NULL outgoing edges on the jump threading\n+     path.  That can happen for jumping to a constant address.  */\n+  for (unsigned int i = 0; i < path.length (); i++)\n+    if (path[i]->e == NULL)\n+      {\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    fprintf (dump_file,\n+\t\t     \"Found NULL edge in jump threading path.  Cancelling jump thread:\\n\");\n+\t    dump_jump_thread_path (dump_file, path);\n+\t  }\n+\treturn;\n+      }\n \n-  /* This can occur if we're jumping to a constant address or\n-     or something similar.  Just get out now.  */\n-  if (e2 == NULL)\n-    return;\n+  if (!threaded_edges.exists ())\n+    threaded_edges.create (15);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      unsigned int i;\n+    dump_jump_thread_path (dump_file, path);\n \n-      fprintf (dump_file,\n-\t       \"  Registering jump thread %s:\",\n-\t       through_joiner ? \"(through joiner block)\" : \"\");\n+  /* The first entry in the vector is always the start of the\n+     jump threading path.  */\n+  threaded_edges.safe_push (path[0]->e);\n \n-      for (i = 0; i < path.length (); i++)\n-\tfprintf (dump_file, \" (%d, %d); \",\n-\t\t path[i]->src->index, path[i]->dest->index);\n-      fputc ('\\n', dump_file);\n-    }\n-    \n-  if (!threaded_edges.exists ())\n-    threaded_edges.create (15);\n+  /* In our 3-edge representation, the joiner, if it exists is always the\n+     2nd edge and the final block on the path is the 3rd edge.  If no\n+     jointer exists, then the final block on the path is the 2nd edge\n+     and the 3rd edge is NULL.\n \n-  threaded_edges.safe_push (e);\n-  threaded_edges.safe_push (e2);\n-  threaded_edges.safe_push (e3);\n+     With upcoming improvements, we're going to be holding onto the entire\n+     path, so we'll be able to clean this wart up shortly.  */\n+  if (path[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+    {\n+      threaded_edges.safe_push (path[1]->e);\n+      threaded_edges.safe_push (path.last ()->e);\n+    }\n+  else\n+    {\n+      threaded_edges.safe_push (path.last ()->e);\n+      threaded_edges.safe_push (NULL);\n+    }\n }"}, {"sha": "723f5bbe0eb49a16b4401a7e7f5f35a791ca9a9e", "filename": "gcc/tree-ssa-threadupdate.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -0,0 +1,45 @@\n+/* Communication between registering jump thread requests and\n+   updating the SSA/CFG for jump threading. \n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _TREE_SSA_THREADUPDATE_H\n+#define _TREE_SSA_THREADUPDATE_H 1\n+\n+/* In tree-ssa-threadupdate.c.  */\n+extern bool thread_through_all_blocks (bool);\n+enum jump_thread_edge_type\n+{\n+  EDGE_START_JUMP_THREAD,\n+  EDGE_COPY_SRC_BLOCK,\n+  EDGE_COPY_SRC_JOINER_BLOCK,\n+  EDGE_NO_COPY_SRC_BLOCK\n+};\n+\n+class jump_thread_edge\n+{\n+public:\n+  jump_thread_edge (edge e, enum jump_thread_edge_type type)\n+    : e (e), type (type) {}\n+\n+  edge e;\n+  enum jump_thread_edge_type type;\n+};\n+\n+extern void register_jump_thread (vec<class jump_thread_edge *>);\n+#endif"}, {"sha": "16007244c9b2b6b07796f3fa5bb36847a7409ed8", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5254eac41daa5fc22a65bfa47d75fa0445dee4ee/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5254eac41daa5fc22a65bfa47d75fa0445dee4ee", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-chrec.h\"\n+#include \"tree-ssa-threadupdate.h\"\n #include \"gimple-fold.h\"\n #include \"expr.h\"\n #include \"optabs.h\""}]}