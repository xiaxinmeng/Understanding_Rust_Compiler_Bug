{"sha": "6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmMDIwYzBkMTBjNDFkOGE3YmQ2MTcxNGU0NDVjY2ZhNjZiOTllNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-16T06:44:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-16T06:44:36Z"}, "message": "compiler: Fix crash: type T1 struct { F *[1]T2 } where T2 is a struct.\n\nThis will become bug417.go.\n\nFrom-SVN: r184299", "tree": {"sha": "9b0a22e05be74ed146107e44c5ce1eb73cd945e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b0a22e05be74ed146107e44c5ce1eb73cd945e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/comments", "author": null, "committer": null, "parents": [{"sha": "cc8b9c31fb3d91662c662af83560b4460b6bab7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8b9c31fb3d91662c662af83560b4460b6bab7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8b9c31fb3d91662c662af83560b4460b6bab7f"}], "stats": {"total": 433, "additions": 352, "deletions": 81}, "files": [{"sha": "0b53f72df213819f87344c6dcb982480e906ba94", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "patch": "@@ -522,8 +522,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n       // first field is just the type descriptor of the object.\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__type_descriptor\") == 0);\n-      go_assert(TREE_TYPE(field) == TREE_TYPE(rhs_type_descriptor));\n-      elt->value = rhs_type_descriptor;\n+      elt->value = fold_convert_loc(location.gcc_location(),\n+\t\t\t\t    TREE_TYPE(field), rhs_type_descriptor);\n     }\n   else\n     {"}, {"sha": "a90ce1df3841b1babebce578a5c26bef8ec177c0", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "patch": "@@ -2929,8 +2929,6 @@ Gogo::convert_named_types()\n \n   Runtime::convert_types(this);\n \n-  Function_type::convert_types(this);\n-\n   this->named_types_are_converted_ = true;\n }\n "}, {"sha": "13cd48a904349535cb7c8240e53bcdea9ec60381", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 324, "deletions": 62, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "patch": "@@ -34,10 +34,28 @@ extern \"C\"\n #include \"backend.h\"\n #include \"types.h\"\n \n+// Forward declarations so that we don't have to make types.h #include\n+// backend.h.\n+\n+static void\n+get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n+\t\t\t  bool use_placeholder,\n+\t\t\t  std::vector<Backend::Btyped_identifier>* bfields);\n+\n+static void\n+get_backend_slice_fields(Gogo* gogo, Array_type* type, bool use_placeholder,\n+\t\t\t std::vector<Backend::Btyped_identifier>* bfields);\n+\n+static void\n+get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n+\t\t\t     bool use_placeholder,\n+\t\t\t     std::vector<Backend::Btyped_identifier>* bfields);\n+\n // Class Type.\n \n Type::Type(Type_classification classification)\n-  : classification_(classification), btype_(NULL), type_descriptor_var_(NULL)\n+  : classification_(classification), btype_is_placeholder_(false),\n+    btype_(NULL), type_descriptor_var_(NULL)\n {\n }\n \n@@ -895,7 +913,11 @@ Btype*\n Type::get_backend(Gogo* gogo)\n {\n   if (this->btype_ != NULL)\n-    return this->btype_;\n+    {\n+      if (this->btype_is_placeholder_ && gogo->named_types_are_converted())\n+\tthis->finish_backend(gogo);\n+      return this->btype_;\n+    }\n \n   if (this->forward_declaration_type() != NULL\n       || this->named_type() != NULL)\n@@ -966,6 +988,189 @@ Type::get_btype_without_hash(Gogo* gogo)\n   return this->btype_;\n }\n \n+// Get the backend representation of a type without forcing the\n+// creation of the backend representation of all supporting types.\n+// This will return a backend type that has the correct size but may\n+// be incomplete.  E.g., a pointer will just be a placeholder pointer,\n+// and will not contain the final representation of the type to which\n+// it points.  This is used while converting all named types to the\n+// backend representation, to avoid problems with indirect references\n+// to types which are not yet complete.  When this is called, the\n+// sizes of all direct references (e.g., a struct field) should be\n+// known, but the sizes of indirect references (e.g., the type to\n+// which a pointer points) may not.\n+\n+Btype*\n+Type::get_backend_placeholder(Gogo* gogo)\n+{\n+  if (gogo->named_types_are_converted())\n+    return this->get_backend(gogo);\n+  if (this->btype_ != NULL)\n+    return this->btype_;\n+\n+  Btype* bt;\n+  switch (this->classification_)\n+    {\n+    case TYPE_ERROR:\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_NIL:\n+      // These are simple types that can just be created directly.\n+      return this->get_backend(gogo);\n+\n+    case TYPE_FUNCTION:\n+      {\n+\tLocation loc = this->function_type()->location();\n+\tbt = gogo->backend()->placeholder_pointer_type(\"\", loc, true);\n+      }\n+      break;\n+\n+    case TYPE_POINTER:\n+      {\n+\tLocation loc = Linemap::unknown_location();\n+\tbt = gogo->backend()->placeholder_pointer_type(\"\", loc, false);\n+      }\n+      break;\n+\n+    case TYPE_STRUCT:\n+      // We don't have to make the struct itself be a placeholder.  We\n+      // are promised that we know the sizes of the struct fields.\n+      // But we may have to use a placeholder for any particular\n+      // struct field.\n+      {\n+\tstd::vector<Backend::Btyped_identifier> bfields;\n+\tget_backend_struct_fields(gogo, this->struct_type()->fields(),\n+\t\t\t\t  true, &bfields);\n+\tbt = gogo->backend()->struct_type(bfields);\n+      }\n+      break;\n+\n+    case TYPE_ARRAY:\n+      if (this->is_slice_type())\n+\t{\n+\t  std::vector<Backend::Btyped_identifier> bfields;\n+\t  get_backend_slice_fields(gogo, this->array_type(), true, &bfields);\n+\t  bt = gogo->backend()->struct_type(bfields);\n+\t}\n+      else\n+\t{\n+\t  Btype* element = this->array_type()->get_backend_element(gogo, true);\n+\t  Bexpression* len = this->array_type()->get_backend_length(gogo);\n+\t  bt = gogo->backend()->array_type(element, len);\n+\t}\n+      break;\n+\t\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+      // All maps and channels have the same backend representation.\n+      return this->get_backend(gogo);\n+\n+    case TYPE_INTERFACE:\n+      if (this->interface_type()->is_empty())\n+\treturn Interface_type::get_backend_empty_interface_type(gogo);\n+      else\n+\t{\n+\t  std::vector<Backend::Btyped_identifier> bfields;\n+\t  get_backend_interface_fields(gogo, this->interface_type(), true,\n+\t\t\t\t       &bfields);\n+\t  bt = gogo->backend()->struct_type(bfields);\n+\t}\n+      break;\n+\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n+      // Named types keep track of their own dependencies and manage\n+      // their own placeholders.\n+      return this->get_backend(gogo);\n+\n+    case TYPE_SINK:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    default:\n+      go_unreachable();\n+    }\n+\n+  this->btype_ = bt;\n+  this->btype_is_placeholder_ = true;\n+  return bt;\n+}\n+\n+// Complete the backend representation.  This is called for a type\n+// using a placeholder type.\n+\n+void\n+Type::finish_backend(Gogo* gogo)\n+{\n+  go_assert(this->btype_ != NULL);\n+  if (!this->btype_is_placeholder_)\n+    return;\n+\n+  switch (this->classification_)\n+    {\n+    case TYPE_ERROR:\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_NIL:\n+      go_unreachable();\n+\n+    case TYPE_FUNCTION:\n+      {\n+\tBtype* bt = this->do_get_backend(gogo);\n+\tif (!gogo->backend()->set_placeholder_function_type(this->btype_, bt))\n+\t  go_assert(saw_errors());\n+      }\n+      break;\n+\n+    case TYPE_POINTER:\n+      {\n+\tBtype* bt = this->do_get_backend(gogo);\n+\tif (!gogo->backend()->set_placeholder_pointer_type(this->btype_, bt))\n+\t  go_assert(saw_errors());\n+      }\n+      break;\n+\n+    case TYPE_STRUCT:\n+      // The struct type itself is done, but we have to make sure that\n+      // all the field types are converted.\n+      this->struct_type()->finish_backend_fields(gogo);\n+      break;\n+\n+    case TYPE_ARRAY:\n+      // The array type itself is done, but make sure the element type\n+      // is converted.\n+      this->array_type()->finish_backend_element(gogo);\n+      break;\n+\t\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+      go_unreachable();\n+\n+    case TYPE_INTERFACE:\n+      // The interface type itself is done, but make sure the method\n+      // types are converted.\n+      this->interface_type()->finish_backend_methods(gogo);\n+      break;\n+\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n+      go_unreachable();\n+\n+    case TYPE_SINK:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    default:\n+      go_unreachable();\n+    }\n+\n+  this->btype_is_placeholder_ = false;\n+}\n+\n // Return a pointer to the type descriptor for this type.\n \n tree\n@@ -2059,7 +2264,8 @@ Type::backend_type_size(Gogo* gogo, unsigned int *psize)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t size = gogo->backend()->type_size(this->get_backend(gogo));\n+  Btype* bt = this->get_backend_placeholder(gogo);\n+  size_t size = gogo->backend()->type_size(bt);\n   *psize = static_cast<unsigned int>(size);\n   if (*psize != size)\n     return false;\n@@ -2074,7 +2280,8 @@ Type::backend_type_align(Gogo* gogo, unsigned int *palign)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t align = gogo->backend()->type_alignment(this->get_backend(gogo));\n+  Btype* bt = this->get_backend_placeholder(gogo);\n+  size_t align = gogo->backend()->type_alignment(bt);\n   *palign = static_cast<unsigned int>(align);\n   if (*palign != align)\n     return false;\n@@ -2089,7 +2296,8 @@ Type::backend_type_field_align(Gogo* gogo, unsigned int *palign)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t a = gogo->backend()->type_field_alignment(this->get_backend(gogo));\n+  Btype* bt = this->get_backend_placeholder(gogo);\n+  size_t a = gogo->backend()->type_field_alignment(bt);\n   *palign = static_cast<unsigned int>(a);\n   if (*palign != a)\n     return false;\n@@ -2712,6 +2920,15 @@ String_type::do_get_backend(Gogo* gogo)\n \n       Type* b = gogo->lookup_global(\"byte\")->type_value();\n       Type* pb = Type::make_pointer_type(b);\n+\n+      // We aren't going to get back to this field to finish the\n+      // backend representation, so force it to be finished now.\n+      if (!gogo->named_types_are_converted())\n+\t{\n+\t  pb->get_backend_placeholder(gogo);\n+\t  pb->finish_backend(gogo);\n+\t}\n+\n       fields[0].name = \"__data\";\n       fields[0].btype = pb->get_backend(gogo);\n       fields[0].location = Linemap::predeclared_location();\n@@ -3117,7 +3334,7 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n // Get the backend representation for a function type.\n \n Btype*\n-Function_type::get_function_backend(Gogo* gogo)\n+Function_type::do_get_backend(Gogo* gogo)\n {\n   Backend::Btyped_identifier breceiver;\n   if (this->receiver_ != NULL)\n@@ -3169,46 +3386,6 @@ Function_type::get_function_backend(Gogo* gogo)\n \t\t\t\t\tthis->location());\n }\n \n-// A hash table mapping function types to their backend placeholders.\n-\n-Function_type::Placeholders Function_type::placeholders;\n-\n-// Get the backend representation for a function type.  If we are\n-// still converting types, and this types has multiple results, return\n-// a placeholder instead.  We do this because for multiple results we\n-// build a struct, and we need to make sure that all the types in the\n-// struct are valid before we create the struct.\n-\n-Btype*\n-Function_type::do_get_backend(Gogo* gogo)\n-{\n-  if (!gogo->named_types_are_converted()\n-      && this->results_ != NULL\n-      && this->results_->size() > 1)\n-    {\n-      Btype* placeholder =\n-\tgogo->backend()->placeholder_pointer_type(\"\", this->location(), true);\n-      Function_type::placeholders.push_back(std::make_pair(this, placeholder));\n-      return placeholder;\n-    }\n-  return this->get_function_backend(gogo);\n-}\n-\n-// Convert function types after all named types are converted.\n-\n-void\n-Function_type::convert_types(Gogo* gogo)\n-{\n-  for (Placeholders::const_iterator p = Function_type::placeholders.begin();\n-       p != Function_type::placeholders.end();\n-       ++p)\n-    {\n-      Btype* bt = p->first->get_function_backend(gogo);\n-      if (!gogo->backend()->set_placeholder_function_type(p->second, bt))\n-\tgo_assert(saw_errors());\n-    }\n-}\n-\n // The type of a function type descriptor.\n \n Type*\n@@ -4346,6 +4523,7 @@ Struct_type::method_function(const std::string& name, bool* is_ambiguous) const\n \n static void\n get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n+\t\t\t  bool use_placeholder,\n \t\t\t  std::vector<Backend::Btyped_identifier>* bfields)\n {\n   bfields->resize(fields->size());\n@@ -4355,7 +4533,9 @@ get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n        ++p, ++i)\n     {\n       (*bfields)[i].name = Gogo::unpack_hidden_name(p->field_name());\n-      (*bfields)[i].btype = p->type()->get_backend(gogo);\n+      (*bfields)[i].btype = (use_placeholder\n+\t\t\t     ? p->type()->get_backend_placeholder(gogo)\n+\t\t\t     : p->type()->get_backend(gogo));\n       (*bfields)[i].location = p->location();\n     }\n   go_assert(i == fields->size());\n@@ -4367,10 +4547,25 @@ Btype*\n Struct_type::do_get_backend(Gogo* gogo)\n {\n   std::vector<Backend::Btyped_identifier> bfields;\n-  get_backend_struct_fields(gogo, this->fields_, &bfields);\n+  get_backend_struct_fields(gogo, this->fields_, false, &bfields);\n   return gogo->backend()->struct_type(bfields);\n }\n \n+// Finish the backend representation of the fields of a struct.\n+\n+void\n+Struct_type::finish_backend_fields(Gogo* gogo)\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields != NULL)\n+    {\n+      for (Struct_field_list::const_iterator p = fields->begin();\n+\t   p != fields->end();\n+\t   ++p)\n+\tp->type()->get_backend(gogo);\n+    }\n+}\n+\n // The type of a struct type descriptor.\n \n Type*\n@@ -4776,8 +4971,8 @@ Struct_type::backend_field_offset(Gogo* gogo, unsigned int index,\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t offset = gogo->backend()->type_field_offset(this->get_backend(gogo),\n-\t\t\t\t\t\t     index);\n+  Btype* bt = this->get_backend_placeholder(gogo);\n+  size_t offset = gogo->backend()->type_field_offset(bt, index);\n   *poffset = static_cast<unsigned int>(offset);\n   if (*poffset != offset)\n     return false;\n@@ -5295,13 +5490,15 @@ Array_type::get_length_tree(Gogo* gogo)\n // size which does not fit in int.\n \n static void\n-get_backend_slice_fields(Gogo* gogo, Array_type* type,\n+get_backend_slice_fields(Gogo* gogo, Array_type* type, bool use_placeholder,\n \t\t\t std::vector<Backend::Btyped_identifier>* bfields)\n {\n   bfields->resize(3);\n \n   Type* pet = Type::make_pointer_type(type->element_type());\n-  Btype* pbet = pet->get_backend(gogo);\n+  Btype* pbet = (use_placeholder\n+\t\t ? pet->get_backend_placeholder(gogo)\n+\t\t : pet->get_backend(gogo));\n   Location ploc = Linemap::predeclared_location();\n \n   Backend::Btyped_identifier* p = &(*bfields)[0];\n@@ -5333,12 +5530,12 @@ Array_type::do_get_backend(Gogo* gogo)\n   if (this->length_ == NULL)\n     {\n       std::vector<Backend::Btyped_identifier> bfields;\n-      get_backend_slice_fields(gogo, this, &bfields);\n+      get_backend_slice_fields(gogo, this, false, &bfields);\n       return gogo->backend()->struct_type(bfields);\n     }\n   else\n     {\n-      Btype* element = this->get_backend_element(gogo);\n+      Btype* element = this->get_backend_element(gogo, false);\n       Bexpression* len = this->get_backend_length(gogo);\n       return gogo->backend()->array_type(element, len);\n     }\n@@ -5347,9 +5544,12 @@ Array_type::do_get_backend(Gogo* gogo)\n // Return the backend representation of the element type.\n \n Btype*\n-Array_type::get_backend_element(Gogo* gogo)\n+Array_type::get_backend_element(Gogo* gogo, bool use_placeholder)\n {\n-  return this->element_type_->get_backend(gogo);\n+  if (use_placeholder)\n+    return this->element_type_->get_backend_placeholder(gogo);\n+  else\n+    return this->element_type_->get_backend(gogo);\n }\n \n // Return the backend representation of the length.\n@@ -5360,6 +5560,22 @@ Array_type::get_backend_length(Gogo* gogo)\n   return tree_to_expr(this->get_length_tree(gogo));\n }\n \n+// Finish backend representation of the array.\n+\n+void\n+Array_type::finish_backend_element(Gogo* gogo)\n+{\n+  Type* et = this->array_type()->element_type();\n+  et->get_backend(gogo);\n+  if (this->is_slice_type())\n+    {\n+      // This relies on the fact that we always use the same\n+      // structure for a pointer to any given type.\n+      Type* pet = Type::make_pointer_type(et);\n+      pet->get_backend(gogo);\n+    }\n+}\n+\n // Return a tree for a pointer to the values in ARRAY.\n \n tree\n@@ -6652,6 +6868,7 @@ Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n \n static void\n get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n+\t\t\t     bool use_placeholder,\n \t\t\t     std::vector<Backend::Btyped_identifier>* bfields)\n {\n   Location loc = type->location();\n@@ -6670,7 +6887,9 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n        ++p, ++i)\n     {\n       mfields[i].name = Gogo::unpack_hidden_name(p->name());\n-      mfields[i].btype = p->type()->get_backend(gogo);\n+      mfields[i].btype = (use_placeholder\n+\t\t\t  ? p->type()->get_backend_placeholder(gogo)\n+\t\t\t  : p->type()->get_backend(gogo));\n       mfields[i].location = loc;\n       // Sanity check: the names should be sorted.\n       go_assert(p->name() > last_name);\n@@ -6710,14 +6929,32 @@ Interface_type::do_get_backend(Gogo* gogo)\n       this->interface_btype_ =\n \tgogo->backend()->placeholder_struct_type(\"\", this->location_);\n       std::vector<Backend::Btyped_identifier> bfields;\n-      get_backend_interface_fields(gogo, this, &bfields);\n+      get_backend_interface_fields(gogo, this, false, &bfields);\n       if (!gogo->backend()->set_placeholder_struct_type(this->interface_btype_,\n \t\t\t\t\t\t\tbfields))\n \tthis->interface_btype_ = gogo->backend()->error_type();\n       return this->interface_btype_;\n     }\n }\n \n+// Finish the backend representation of the methods.\n+\n+void\n+Interface_type::finish_backend_methods(Gogo* gogo)\n+{\n+  if (!this->interface_type()->is_empty())\n+    {\n+      const Typed_identifier_list* methods = this->methods();\n+      if (methods != NULL)\n+\t{\n+\t  for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t       p != methods->end();\n+\t       ++p)\n+\t    p->type()->get_backend(gogo);\n+\t}\n+    }\n+}\n+\n // The type of an interface type descriptor.\n \n Type*\n@@ -7751,7 +7988,7 @@ Named_type::convert(Gogo* gogo)\n       {\n \tstd::vector<Backend::Btyped_identifier> bfields;\n \tget_backend_struct_fields(gogo, base->struct_type()->fields(),\n-\t\t\t\t  &bfields);\n+\t\t\t\t  true, &bfields);\n \tif (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n \t  bt = gogo->backend()->error_type();\n       }\n@@ -7761,7 +7998,7 @@ Named_type::convert(Gogo* gogo)\n       // Slice types were completed in create_placeholder.\n       if (!base->is_slice_type())\n \t{\n-\t  Btype* bet = base->array_type()->get_backend_element(gogo);\n+\t  Btype* bet = base->array_type()->get_backend_element(gogo, true);\n \t  Bexpression* blen = base->array_type()->get_backend_length(gogo);\n \t  if (!gogo->backend()->set_placeholder_array_type(bt, bet, blen))\n \t    bt = gogo->backend()->error_type();\n@@ -7893,7 +8130,7 @@ Named_type::create_placeholder(Gogo* gogo)\n       // because we can fill them in completely here with the final\n       // size.\n       std::vector<Backend::Btyped_identifier> bfields;\n-      get_backend_slice_fields(gogo, base->array_type(), &bfields);\n+      get_backend_slice_fields(gogo, base->array_type(), true, &bfields);\n       if (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n \tthis->named_btype_ = gogo->backend()->error_type();\n     }\n@@ -7904,7 +8141,8 @@ Named_type::create_placeholder(Gogo* gogo)\n       // because we can fill them in completely here with the final\n       // size.\n       std::vector<Backend::Btyped_identifier> bfields;\n-      get_backend_interface_fields(gogo, base->interface_type(), &bfields);\n+      get_backend_interface_fields(gogo, base->interface_type(), true,\n+\t\t\t\t   &bfields);\n       if (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n \tthis->named_btype_ = gogo->backend()->error_type();\n     }\n@@ -7963,9 +8201,33 @@ Named_type::do_get_backend(Gogo* gogo)\n     case TYPE_NIL:\n     case TYPE_MAP:\n     case TYPE_CHANNEL:\n+      return bt;\n+\n     case TYPE_STRUCT:\n+      if (!this->seen_in_get_backend_)\n+\t{\n+\t  this->seen_in_get_backend_ = true;\n+\t  base->struct_type()->finish_backend_fields(gogo);\n+\t  this->seen_in_get_backend_ = false;\n+\t}\n+      return bt;\n+\n     case TYPE_ARRAY:\n+      if (!this->seen_in_get_backend_)\n+\t{\n+\t  this->seen_in_get_backend_ = true;\n+\t  base->array_type()->finish_backend_element(gogo);\n+\t  this->seen_in_get_backend_ = false;\n+\t}\n+      return bt;\n+\n     case TYPE_INTERFACE:\n+      if (!this->seen_in_get_backend_)\n+\t{\n+\t  this->seen_in_get_backend_ = true;\n+\t  base->interface_type()->finish_backend_methods(gogo);\n+\t  this->seen_in_get_backend_ = false;\n+\t}\n       return bt;\n \n     case TYPE_FUNCTION:"}, {"sha": "72c42ebb4ba57d3ffc130a11ff2ae147335d4fae", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df020c0d10c41d8a7bd61714e445ccfa66b99e6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=6df020c0d10c41d8a7bd61714e445ccfa66b99e6", "patch": "@@ -852,6 +852,16 @@ class Type\n   Btype*\n   get_backend(Gogo*);\n \n+  // Return a placeholder for the backend representation of the type.\n+  // This will return a type of the correct size, but for which some\n+  // of the fields may still need to be completed.\n+  Btype*\n+  get_backend_placeholder(Gogo*);\n+\n+  // Finish the backend representation of a placeholder.\n+  void\n+  finish_backend(Gogo*);\n+\n   // Build a type descriptor entry for this type.  Return a pointer to\n   // it.  The location is the location which causes us to need the\n   // entry.\n@@ -1179,6 +1189,9 @@ class Type\n \n   // The type classification.\n   Type_classification classification_;\n+  // Whether btype_ is a placeholder type used while named types are\n+  // being converted.\n+  bool btype_is_placeholder_;\n   // The backend representation of the type, once it has been\n   // determined.\n   Btype* btype_;\n@@ -1730,10 +1743,6 @@ class Function_type : public Type\n   Function_type*\n   copy_with_receiver(Type*) const;\n \n-  // Finishing converting function types.\n-  static void\n-  convert_types(Gogo*);\n-\n   static Type*\n   make_function_type_descriptor_type();\n \n@@ -1773,16 +1782,6 @@ class Function_type : public Type\n   type_descriptor_params(Type*, const Typed_identifier*,\n \t\t\t const Typed_identifier_list*);\n \n-  Btype*\n-  get_function_backend(Gogo*);\n-\n-  // A list of function types with multiple results and their\n-  // placeholder backend representations, used to postpone building\n-  // the structs we use for multiple results until all types are\n-  // converted.\n-  typedef std::vector<std::pair<Function_type*, Btype*> > Placeholders;\n-  static Placeholders placeholders;\n-\n   // The receiver name and type.  This will be NULL for a normal\n   // function, non-NULL for a method.\n   Typed_identifier* receiver_;\n@@ -2079,6 +2078,10 @@ class Struct_type : public Type\n   bool\n   backend_field_offset(Gogo*, unsigned int index, unsigned int* poffset);\n \n+  // Finish the backend representation of all the fields.\n+  void\n+  finish_backend_fields(Gogo*);\n+\n   // Import a struct type.\n   static Struct_type*\n   do_import(Import*);\n@@ -2193,12 +2196,16 @@ class Array_type : public Type\n \n   // Return the backend representation of the element type.\n   Btype*\n-  get_backend_element(Gogo*);\n+  get_backend_element(Gogo*, bool use_placeholder);\n \n   // Return the backend representation of the length.\n   Bexpression*\n   get_backend_length(Gogo*);\n \n+  // Finish the backend representation of the element type.\n+  void\n+  finish_backend_element(Gogo*);\n+\n   static Type*\n   make_array_type_descriptor_type();\n \n@@ -2521,6 +2528,10 @@ class Interface_type : public Type\n   static Btype*\n   get_backend_empty_interface_type(Gogo*);\n \n+  // Finish the backend representation of the method types.\n+  void\n+  finish_backend_methods(Gogo*);\n+\n   static Type*\n   make_interface_type_descriptor_type();\n "}]}