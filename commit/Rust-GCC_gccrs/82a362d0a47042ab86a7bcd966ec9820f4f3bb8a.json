{"sha": "82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJhMzYyZDBhNDcwNDJhYjg2YTdiY2Q5NjZlYzk4MjBmNGYzYmI4YQ==", "commit": {"author": {"name": "Chip Salzenberg", "email": "chip@valinux.com", "date": "2000-06-11T03:57:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-11T03:57:18Z"}, "message": "mangle.c (write_number): Take an unsigned HOST_WIDE_INT as an argument.\n\n\t* mangle.c (write_number): Take an unsigned HOST_WIDE_INT as an\n\targument.\n\t(write_signed_number): New macro.\n\t(write_unsigned_number): Likewise.\n\t(write_source_name): Use them.\n\t(write_number): Handle signed and unsigned values.\n\t(write_integer_cst): Use tree_int_cst_sgn, and use\n\twrite_unsigned_number or write_signed_number as appropriate.\n\t(write_discriminator): Use write_unsigned_number or\n\twrite_signed_number as appropriate.\n\t(write_template_arg_literal): Likewise.\n\t(write_array_type): Use tree_low_cst.\n\t(write_template_parm):  Use write_unsigned_number or\n\twrite_signed_number as appropriate.\n\t(write_substitution): Adjust call to write_number.\n\t(write_type): Get the TYPE_MAIN_VARIANT before mangling it.\n\t(write_expression): Handle non-type template arguments of\n\treference type correctly.\n\t(mangle_thunk): Use write_signed_number.\n\n\t* mangle.c (find_substition): Don't mangle objects with typename\n\tsubstitutions (e.g. \"cin\" as \"Si\").\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r34488", "tree": {"sha": "dd4ccd8ee512024435a3845bac0422d5c159e3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd4ccd8ee512024435a3845bac0422d5c159e3a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/comments", "author": null, "committer": null, "parents": [{"sha": "4d870388ff715ef89999c0c5ed1dd14f011c4b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d870388ff715ef89999c0c5ed1dd14f011c4b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d870388ff715ef89999c0c5ed1dd14f011c4b9e"}], "stats": {"total": 286, "additions": 181, "deletions": 105}, "files": [{"sha": "f26e03d4c5d16c11ba3111e869048f0b8b3a790a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "patch": "@@ -1,3 +1,31 @@\n+2000-06-09  Chip Salzenberg  <chip@valinux.com>\n+\t    Mark Mitchell <mark@codesourcery.com>\n+\n+\t* mangle.c (write_number): Take an unsigned HOST_WIDE_INT as an\n+\targument.\n+\t(write_signed_number): New macro.\n+\t(write_unsigned_number): Likewise.\n+\t(write_source_name): Use them.\n+\t(write_number): Handle signed and unsigned values.\n+\t(write_integer_cst): Use tree_int_cst_sgn, and use\n+\twrite_unsigned_number or write_signed_number as appropriate.\n+\t(write_discriminator): Use write_unsigned_number or\n+\twrite_signed_number as appropriate.\n+\t(write_template_arg_literal): Likewise.\n+\t(write_array_type): Use tree_low_cst.\n+\t(write_template_parm):  Use write_unsigned_number or\n+\twrite_signed_number as appropriate.\n+\t(write_substitution): Adjust call to write_number.\n+\t(write_type): Get the TYPE_MAIN_VARIANT before mangling it.\n+\t(write_expression): Handle non-type template arguments of\n+\treference type correctly.\n+\t(mangle_thunk): Use write_signed_number.\n+\n+2000-06-09  Chip Salzenberg  <chip@valinux.com>\n+\n+\t* mangle.c (find_substition): Don't mangle objects with typename\n+\tsubstitutions (e.g. \"cin\" as \"Si\").\n+\n 2000-06-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* call.c (add_candidate): Use ggc_alloc_cleared."}, {"sha": "f4aa12d6ccbeefd4606b55b9aa98eaf2e0dfcbea", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 141, "deletions": 105, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "patch": "@@ -157,7 +157,8 @@ static void write_template_prefix PARAMS ((tree));\n static void write_component PARAMS ((tree));\n static void write_unqualified_name PARAMS ((tree));\n static void write_source_name PARAMS ((tree));\n-static void write_number PARAMS ((int, int));\n+static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n+\t\t\t\t  unsigned int));\n static void write_integer_cst PARAMS ((tree));\n static void write_identifier PARAMS ((char *));\n static void write_special_name_constructor PARAMS ((tree));\n@@ -219,6 +220,14 @@ static tree mangle_special_for_type PARAMS ((tree, const char *));\n        || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))             \\\n    && TREE_VALUE (NODE1) == TREE_VALUE (NODE2))\n \n+/* Write out a signed quantity in base 10.  */\n+#define write_signed_number(NUMBER) \\\n+  write_number (NUMBER, /*unsigned_p=*/0, 10)\n+\n+/* Write out an unsigned quantity in base 10.  */\n+#define write_unsigned_number(NUMBER) \\\n+  write_number (NUMBER, /*unsigned_p=*/1, 10)\n+\n /* Produce debugging output of current substitution candidates.  */\n \n static void\n@@ -441,7 +450,7 @@ find_substitution (node)\n   /* Check for std::basic_string.  */\n   if (decl && is_std_substitution (decl, SUBID_BASIC_STRING))\n     {\n-      if (type)\n+      if (TYPE_P (node))\n \t{\n \t  /* If this is a type (i.e. a fully-qualified template-id), \n \t     check for \n@@ -473,7 +482,7 @@ find_substitution (node)\n     }\n \n   /* Check for basic_{i,o,io}stream.  */\n-  if (type\n+  if (TYPE_P (node)\n       && CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED\n       && CLASS_TYPE_P (type)\n       && CLASSTYPE_USE_TEMPLATE (type)\n@@ -510,15 +519,14 @@ find_substitution (node)\n     }\n \n   /* Check for namespace std.  */\n-  if (decl&& DECL_NAMESPACE_STD_P (decl))\n+  if (decl && DECL_NAMESPACE_STD_P (decl))\n     {\n       write_string (\"St\");\n       return 1;\n     }\n \n   /* Now check the list of available substitutions for this mangling\n      operation.    */\n-\n   for (i = 0; i < size; ++i)\n     {\n       tree candidate = VARRAY_TREE (G.substitutions, i);\n@@ -604,7 +612,9 @@ static void\n write_name (decl)\n      tree decl;\n {\n-  tree context = CP_DECL_CONTEXT (decl);\n+  tree context;\n+\n+  context = CP_DECL_CONTEXT (decl);\n \n   MANGLE_TRACE_TREE (\"name\", decl);\n \n@@ -913,7 +923,7 @@ write_source_name (identifier)\n   if (IDENTIFIER_TEMPLATE (identifier))\n     identifier = IDENTIFIER_TEMPLATE (identifier);\n \n-  write_number (IDENTIFIER_LENGTH (identifier), 10);\n+  write_unsigned_number (IDENTIFIER_LENGTH (identifier));\n   write_identifier (IDENTIFIER_POINTER (identifier));\n }\n \n@@ -922,27 +932,30 @@ write_source_name (identifier)\n      <number> ::= [n] </decimal integer/>  */\n \n static void\n-write_number (number, base)\n-     int number;\n-     int base;\n+write_number (number, unsigned_p, base)\n+     unsigned HOST_WIDE_INT number;\n+     int unsigned_p;\n+     unsigned int base;\n {\n   static const char digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-  int n;\n-  int m = 1;\n+  unsigned HOST_WIDE_INT n;\n+  unsigned HOST_WIDE_INT m = 1;\n \n-  if (number < 0)\n+  if (!unsigned_p && (HOST_WIDE_INT) number < 0)\n     {\n       write_char ('n');\n-      number = -number;\n+      number = -((HOST_WIDE_INT) number);\n     }\n   \n+  /* Figure out how many digits there are.  */\n   n = number;\n   while (n >= base)\n     {\n       n /= base;\n       m *= base;\n     }\n \n+  /* Write them out.  */\n   while (m > 0)\n     {\n       int digit = number / m;\n@@ -960,7 +973,14 @@ static inline void\n write_integer_cst (cst)\n      tree cst;\n {\n-  write_number (tree_low_cst (cst, TREE_UNSIGNED (TREE_TYPE (cst))), 10);\n+  if (tree_int_cst_sgn (cst) >= 0) \n+    {\n+      if (TREE_INT_CST_HIGH (cst) != 0)\n+\tsorry (\"mangling very large integers\");\n+      write_unsigned_number (TREE_INT_CST_LOW (cst));\n+    }\n+  else\n+    write_signed_number (tree_low_cst (cst, 0));\n }\n \n /* Non-terminal <identifier>.\n@@ -1086,7 +1106,7 @@ write_discriminator (discriminator)\n       /* The number is omitted for discriminator == 1.  Beyond 1, the\n \t numbering starts at 0.  */\n       if (discriminator > 1)\n-\twrite_number (discriminator - 2, 10);\n+\twrite_unsigned_number (discriminator - 2);\n     }\n }\n \n@@ -1151,93 +1171,98 @@ write_type (type)\n \n   if (find_substitution (type))\n     return;\n-\n+  \n   if (write_CV_qualifiers_for_type (type) > 0)\n     /* If TYPE was CV-qualified, we just wrote the qualifiers; now\n        mangle the unqualified type.  The recursive call is needed here\n        since both the qualified and uqualified types are substitution\n        candidates.  */\n     write_type (TYPE_MAIN_VARIANT (type));\n   else\n-    switch (TREE_CODE (type))\n-      {\n-      case VOID_TYPE:\n-      case BOOLEAN_TYPE:\n-      case INTEGER_TYPE:  /* Includes wchar_t.  */\n-      case REAL_TYPE:\n-\t/* If this is a typedef, TYPE may not be one of\n-\t   the standard builtin type nodes, but an alias of one.  Use\n-\t   TYPE_MAIN_VARIANT to get to the underlying builtin type.  */\n-\twrite_builtin_type (TYPE_MAIN_VARIANT (type));\n-\t++is_builtin_type;\n-\tbreak;\n-\n-      case COMPLEX_TYPE:\n-\twrite_char ('C');\n-\twrite_type (TREE_TYPE (type));\n-\tbreak;\n-\n-      case FUNCTION_TYPE:\n-      case METHOD_TYPE:\n-\twrite_function_type (type, 1);\n-\tbreak;\n-\n-      case UNION_TYPE:\n-      case RECORD_TYPE:\n-      case ENUMERAL_TYPE:\n-\t/* A pointer-to-member function is represented as a special\n-\t   RECORD_TYPE, so check for this first.  */\n-\tif (TYPE_PTRMEMFUNC_P (type))\n-\t  write_pointer_to_member_type (type);\n-\telse\n-\t  write_class_enum_type (type);\n-\tbreak;\n-\n-      case TYPENAME_TYPE:\n-\t/* We handle TYPENAME_TYPEs like ordinary nested names.  */\n-\twrite_nested_name (TYPE_STUB_DECL (type));\n-\tbreak;\n-\n-      case ARRAY_TYPE:\n-\twrite_array_type (type);\n-\tbreak;\n-\n-      case POINTER_TYPE:\n-\t/* A pointer-to-member variable is represented by a POINTER_TYPE\n-\t   to an OFFSET_TYPE, so check for this first.  */\n-\tif (TYPE_PTRMEM_P (type))\n-\t  write_pointer_to_member_type (type);\n-\telse\n-\t  {\n-\t    write_char ('P');\n-\t    write_type (TREE_TYPE (type));\n-\t  }\n-\tbreak;\n-\n-      case REFERENCE_TYPE:\n-\twrite_char ('R');\n-\twrite_type (TREE_TYPE (type));\n-\tbreak;\n-\n-      case TEMPLATE_TYPE_PARM:\n-      case TEMPLATE_PARM_INDEX:\n-\twrite_template_param (type);\n-\tbreak;\n-\n-      case TEMPLATE_TEMPLATE_PARM:\n-\twrite_template_template_param (type);\n-\tif (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type))\n-\t  write_template_args \n-\t    (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n-\tbreak;\n-\n-      case OFFSET_TYPE:\n-\twrite_pointer_to_member_type (build_pointer_type (type));\n-\tbreak;\n-\n-      default:\n-\tmy_friendly_abort (20000409);\n-      }\n+    {\n+      /* See through any typedefs.  */\n+      type = TYPE_MAIN_VARIANT (type);\n+\n+      switch (TREE_CODE (type))\n+\t{\n+\tcase VOID_TYPE:\n+\tcase BOOLEAN_TYPE:\n+\tcase INTEGER_TYPE:  /* Includes wchar_t.  */\n+\tcase REAL_TYPE:\n+\t  /* If this is a typedef, TYPE may not be one of\n+\t     the standard builtin type nodes, but an alias of one.  Use\n+\t     TYPE_MAIN_VARIANT to get to the underlying builtin type.  */\n+\t  write_builtin_type (TYPE_MAIN_VARIANT (type));\n+\t  ++is_builtin_type;\n+\t  break;\n+\n+\tcase COMPLEX_TYPE:\n+\t  write_char ('C');\n+\t  write_type (TREE_TYPE (type));\n+\t  break;\n+\n+\tcase FUNCTION_TYPE:\n+\tcase METHOD_TYPE:\n+\t  write_function_type (type, 1);\n+\t  break;\n+\n+\tcase UNION_TYPE:\n+\tcase RECORD_TYPE:\n+\tcase ENUMERAL_TYPE:\n+\t  /* A pointer-to-member function is represented as a special\n+\t     RECORD_TYPE, so check for this first.  */\n+\t  if (TYPE_PTRMEMFUNC_P (type))\n+\t    write_pointer_to_member_type (type);\n+\t  else\n+\t    write_class_enum_type (type);\n+\t  break;\n+\n+\tcase TYPENAME_TYPE:\n+\t  /* We handle TYPENAME_TYPEs like ordinary nested names.  */\n+\t  write_nested_name (TYPE_STUB_DECL (type));\n+\t  break;\n+\n+\tcase ARRAY_TYPE:\n+\t  write_array_type (type);\n+\t  break;\n+\n+\tcase POINTER_TYPE:\n+\t  /* A pointer-to-member variable is represented by a POINTER_TYPE\n+\t     to an OFFSET_TYPE, so check for this first.  */\n+\t  if (TYPE_PTRMEM_P (type))\n+\t    write_pointer_to_member_type (type);\n+\t  else\n+\t    {\n+\t      write_char ('P');\n+\t      write_type (TREE_TYPE (type));\n+\t    }\n+\t  break;\n+\n+\tcase REFERENCE_TYPE:\n+\t  write_char ('R');\n+\t  write_type (TREE_TYPE (type));\n+\t  break;\n+\n+\tcase TEMPLATE_TYPE_PARM:\n+\tcase TEMPLATE_PARM_INDEX:\n+\t  write_template_param (type);\n+\t  break;\n+\n+\tcase TEMPLATE_TEMPLATE_PARM:\n+\t  write_template_template_param (type);\n+\t  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type))\n+\t    write_template_args \n+\t      (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n+\t  break;\n+\n+\tcase OFFSET_TYPE:\n+\t  write_pointer_to_member_type (build_pointer_type (type));\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (20000409);\n+\t}\n+    }\n \n   /* Types other than builtin types are substitution candidates.  */\n   if (!is_builtin_type)\n@@ -1564,8 +1589,17 @@ write_expression (expr)\n       if (TREE_CODE (expr) == ADDR_EXPR\n \t  && TREE_TYPE (expr)\n \t  && TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n-\texpr = TREE_OPERAND (expr, 0);\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  if (DECL_P (expr))\n+\t    {\n+\t      write_expression (expr);\n+\t      return;\n+\t    }\n \n+\t  code = TREE_CODE (expr);\n+\t}\n+      \n       /* If it wasn't any of those, recursively expand the expression.  */\n       write_string (operator_name_info[(int) code].mangled_name);\n \n@@ -1610,9 +1644,9 @@ write_template_arg_literal (value)\n       if (same_type_p (type, boolean_type_node))\n \t{\n \t  if (value == boolean_false_node || integer_zerop (value))\n-\t    write_number (0, 10);\n+\t    write_unsigned_number (0);\n \t  else if (value == boolean_true_node)\n-\t    write_number (1, 10);\n+\t    write_unsigned_number (1);\n \t  else \n \t    my_friendly_abort (20000412);\n \t}\n@@ -1633,7 +1667,9 @@ write_template_arg_literal (value)\n       size_t i;\n       for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n \twrite_number (((unsigned char *) \n-\t\t       &TREE_REAL_CST (value))[i], 16);\n+\t\t       &TREE_REAL_CST (value))[i], \n+\t\t      /*unsigned_p=*/1,\n+\t\t      16);\n #endif\n     }\n   else\n@@ -1732,7 +1768,7 @@ write_array_type (type)\n \t array.  */\n       max = TYPE_MAX_VALUE (index_type);\n       if (TREE_CODE (max) == INTEGER_CST)\n-\twrite_number (TREE_INT_CST_LOW (max) + 1, 10);\n+\twrite_unsigned_number (tree_low_cst (max, 1));\n       else\n \twrite_expression (TREE_OPERAND (max, 0));\n     }\n@@ -1786,7 +1822,7 @@ write_template_param (parm)\n   /* NUMBER as it appears in the mangling is (-1)-indexed, with the\n      earliest template param denoted by `_'.  */\n   if (parm_index > 0)\n-    write_number (parm_index - 1, 10);\n+    write_unsigned_number (parm_index - 1);\n   write_char ('_');\n }\n \n@@ -1831,7 +1867,7 @@ write_substitution (seq_id)\n \n   write_char ('S');\n   if (seq_id > 0)\n-    write_number (seq_id - 1, 36);\n+    write_number (seq_id - 1, /*unsigned=*/1, 36);\n   write_char ('_');\n }\n \n@@ -2063,14 +2099,14 @@ mangle_thunk (fn_decl, offset, vcall_offset)\n     write_char ('h');\n \n   /* For either flavor, write the offset to this.  */\n-  write_number (offset, 10);\n+  write_signed_number (offset);\n   write_char ('_');\n \n   /* For a virtual thunk, add the vcall offset.  */\n   if (vcall_offset != 0)\n     {\n       /* Virtual thunk.  Write the vcall offset and base type name.  */\n-      write_number (vcall_offset, 10);\n+      write_signed_number (vcall_offset);\n       write_char ('_');\n     }\n "}, {"sha": "d7ecba86b6f8df1f5e19237c49755b67b020fcba", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash19.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a362d0a47042ab86a7bcd966ec9820f4f3bb8a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash19.C?ref=82a362d0a47042ab86a7bcd966ec9820f4f3bb8a", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+struct S {};\n+\n+struct X {};\n+\n+void f () {\n+  typedef X Y;\n+  S<Y> s;\n+}"}]}