{"sha": "6656b2ac050b5dc91f53003fe2a640779396fc13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1NmIyYWMwNTBiNWRjOTFmNTMwMDNmZTJhNjQwNzc5Mzk2ZmMxMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-01-02T17:28:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-01-02T17:28:24Z"}, "message": "regrename.c: Add general comment describing the pass.\n\n\t* regrename.c: Add general comment describing the pass.\n\t(struct du_head): Remove 'length' field.\n\t(get_element, merge_sort_comparison, merge, sort_du_head): Remove.\n\t(regrename_optimize): Do not sort chains.  Rework comments, add others.\n\tForce renaming to the preferred class (if any) in the first pass and do\n\tnot consider registers that belong to it in the second pass.\n\t(create_new_chain): Do not set 'length' field.\n\t(scan_rtx_reg): Likewise.\n\nFrom-SVN: r168404", "tree": {"sha": "625a16b26d2bb05cdc347f556cca56cfac519022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/625a16b26d2bb05cdc347f556cca56cfac519022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6656b2ac050b5dc91f53003fe2a640779396fc13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6656b2ac050b5dc91f53003fe2a640779396fc13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6656b2ac050b5dc91f53003fe2a640779396fc13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6656b2ac050b5dc91f53003fe2a640779396fc13/comments", "author": null, "committer": null, "parents": [{"sha": "4c0c3228826735eb08640cea09f6529b2834b67e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0c3228826735eb08640cea09f6529b2834b67e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0c3228826735eb08640cea09f6529b2834b67e"}], "stats": {"total": 283, "additions": 79, "deletions": 204}, "files": [{"sha": "f99a4114e1991a523fc4bed21f6686244411ff66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6656b2ac050b5dc91f53003fe2a640779396fc13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6656b2ac050b5dc91f53003fe2a640779396fc13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6656b2ac050b5dc91f53003fe2a640779396fc13", "patch": "@@ -1,3 +1,14 @@\n+2011-01-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* regrename.c: Add general comment describing the pass.\n+\t(struct du_head): Remove 'length' field.\n+\t(get_element, merge_sort_comparison, merge, sort_du_head): Remove.\n+\t(regrename_optimize): Do not sort chains.  Rework comments, add others.\n+\tForce renaming to the preferred class (if any) in the first pass and do\n+\tnot consider registers that belong to it in the second pass.\n+\t(create_new_chain): Do not set 'length' field.\n+\t(scan_rtx_reg): Likewise.\n+\n 2011-01-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47140\n@@ -6,9 +17,8 @@\n \tto bit_value_binop.\n \n \tPR rtl-optimization/47028\n-\t* cfgexpand.c (gimple_expand_cfg): Insert entry edge\n-\tinsertions after parm_birth_insn instead of at the beginning\n-\tof first bb.\n+\t* cfgexpand.c (gimple_expand_cfg): Insert entry edge insertions after\n+\tparm_birth_insn instead of at the beginning of first bb.\n \n 2011-01-02  Mingjie Xing  <mingjie.xing@gmail.com>\n \n@@ -18,14 +28,13 @@\n \n 2011-01-01  Jan Hubicka  <jh@suse.cz>\n \n-\t* tree-loop-distribution.c (tree_loop_distribution): Do not\n-\tuse freed memory.\n+\t* tree-loop-distribution.c (tree_loop_distribution): Do not use freed\n+\tmemory.\n \n 2011-01-01  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR target/38662\n-\t* tree.c (type_hash_eq): Call\n-\tlanguage hook for METHOD_TYPEs, too.\n+\t* tree.c (type_hash_eq): Call language hook for METHOD_TYPEs, too.\n \n \f\n Copyright (C) 2011 Free Software Foundation, Inc."}, {"sha": "c2292efba90e50c9e38c1fe17a680e34fe9e7c06", "filename": "gcc/regrename.c", "status": "modified", "additions": 63, "deletions": 197, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6656b2ac050b5dc91f53003fe2a640779396fc13/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6656b2ac050b5dc91f53003fe2a640779396fc13/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=6656b2ac050b5dc91f53003fe2a640779396fc13", "patch": "@@ -40,10 +40,33 @@\n #include \"df.h\"\n #include \"target.h\"\n \n+/* This file implements the RTL register renaming pass of the compiler.  It is\n+   a semi-local pass whose goal is to maximize the usage of the register file\n+   of the processor by substituting registers for others in the solution given\n+   by the register allocator.  The algorithm is as follows:\n+\n+     1. Local def/use chains are built: within each basic block, chains are\n+\topened and closed; if a chain isn't closed at the end of the block,\n+\tit is dropped.\n+\n+     2. For each chain, the set of possible renaming registers is computed.\n+\tThis takes into account the renaming of previously processed chains.\n+\tOptionally, a preferred class is computed for the renaming register.\n+\n+     3. The best renaming register is computed for the chain in the above set,\n+\tusing a round-robin allocation.  If a preferred class exists, then the\n+\tround-robin allocation is done within the class first, if possible.\n+\tThe round-robin allocation of renaming registers itself is global.\n+\n+     4. If a renaming register has been found, it is substituted in the chain.\n+\n+  Targets can parameterize the pass by specifying a preferred class for the\n+  renaming register for a given (super)class of registers to be renamed.  */\n+\n #if HOST_BITS_PER_WIDE_INT <= MAX_RECOG_OPERANDS\n #error \"Use a different bitmap implementation for untracked_operands.\"\n #endif\n-   \n+\n /* We keep linked lists of DU_HEAD structures, each of which describes\n    a chain of occurrences of a reg.  */\n struct du_head\n@@ -52,11 +75,6 @@ struct du_head\n   struct du_head *next_chain;\n   /* The first and last elements of this chain.  */\n   struct du_chain *first, *last;\n-  /* The number of elements of this chain, excluding those corresponding\n-     to references of the register in debug insns.  The du_head linked\n-     list can be sorted by this, and register-rename can prefer\n-     register classes according to this order.  */\n-  int length;\n   /* Describes the register being tracked.  */\n   unsigned regno, nregs;\n \n@@ -160,150 +178,6 @@ merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n     }\n }\n \n-/* Return the Nth element in LIST.  If LIST contains less than N\n-   elements, return the last one.  */\n-static struct du_head *\n-get_element (struct du_head *list, int n)\n-{\n-  while (n-- && list->next_chain != NULL)\n-    list = list->next_chain;\n-\n-  return list;\n-}\n-\n-/* Comparison function of merge sort.  Return true if A is less than\n-   B, otherwise return false.  */\n-static inline int\n-merge_sort_comparison(const struct du_head *a,\n-\t\t    const struct du_head *b)\n-{\n-  return a->length < b->length;\n-}\n-\n-/* Merge the first 2 sub-lists of LENGTH nodes contained in the\n-   linked list pointed to by START_NODE.  Update START_NODE to point\n-   to the merged nodes, and return a pointer to the last merged\n-   node.  Return NULL if START_NODE doesn't contain enough\n-   elements, or this pass of merge is done.  */\n-\n-static struct du_head *\n-merge(struct du_head **start_node, int length)\n-{\n-  int i, left_count, right_count;\n-  struct du_head *left, *right;\n-  /* Current node of sort result.  */\n-  struct du_head *current_sorted_node;\n-  /* Tail node of sort, used to connect with next piece of list.  */\n-  struct du_head *current_tail_node;\n-\n-  if (*start_node == NULL)\n-    return NULL;\n-\n-  left = right = *start_node;\n-  right_count = left_count = 0;\n-\n-  /* Step RIGHT along the list by LENGTH places.  */\n-  for (i = 0; i < length; i++)\n-    {\n-      right = right->next_chain;\n-      if (right == NULL)\n-\t{\n-\t  return NULL;\n-\t}\n-    }\n-\n-  /* Initialize current_sorted_node.  */\n-  if (merge_sort_comparison (left, right))\n-    {\n-      ++right_count;\n-      current_sorted_node = right;\n-      *start_node = right;\n-      right = right->next_chain;\n-    }\n-  else\n-    {\n-      ++left_count;\n-      current_sorted_node = left;\n-      left = left->next_chain;\n-    }\n-\n-  while (1)\n-    {\n-      /* Choose LEFT or RIGHT to take the next element from.  If\n-\t either is empty, choose from the other one.  */\n-      if (left_count == length || left == NULL)\n-\t{\n-\t  current_sorted_node->next_chain = right;\n-\t  current_tail_node = get_element (current_sorted_node,\n-\t\t\t\t\t   length - right_count);\n-\n-\t  break;\n-\t}\n-      else if (right_count == length || right == NULL)\n-\t{\n-\t  /* Save the head node of next piece of linked list.  */\n-\t  struct du_head *tmp = current_sorted_node->next_chain;\n-\n-\t  current_sorted_node->next_chain = left;\n-\t  current_tail_node\n-\t    = get_element (current_sorted_node,\n-\t\t\t   length - left_count);\n-\t  /* Connect sorted list to next piece of list.  */\n-\t  current_tail_node->next_chain = tmp;\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  /* Normal merge operations.  If both LEFT and RIGHT are\n-\t     non-empty, compare the first element of each and choose\n-\t     the lower one.  */\n-\t  if (merge_sort_comparison (left, right))\n-\t    {\n-\t      right_count++;\n-\t      current_sorted_node->next_chain = right;\n-\t      right = right->next_chain;\n-\t    }\n-\t  else\n-\t    {\n-\t      left_count++;\n-\t      current_sorted_node->next_chain = left;\n-\t      left = left->next_chain;\n-\t    }\n-\t  current_sorted_node = current_sorted_node->next_chain;\n-\t}\n-    }\n-  /* Return NULL if this pass of merge is done.  */\n-  return (current_tail_node->next_chain ? current_tail_node : NULL);\n-}\n-\n-/* Sort the linked list pointed to by HEAD.  The algorithm is a\n-   non-recursive merge sort to linked list.  */\n-\n-static void\n-sort_du_head (struct du_head **head)\n-{\n-  int current_length = 1;\n-  struct du_head *last_tail;\n-\n-  /* In each pass, lists of size current_length is merged to\n-     lists of size 2xcurrent_length (Initially current_length\n-     is 1).  */\n-  while (1)\n-    {\n-      last_tail = merge(head, current_length);\n-      if (last_tail != NULL)\n-\t{\n-\t  do\n-\t    last_tail = merge (&last_tail->next_chain, current_length);\n-\t  while (last_tail != NULL);\n-\n-\t  current_length *= 2;\n-\t}\n-      else\n-\tbreak;\n-    }\n-}\n-\n /* Check if NEW_REG can be the candidate register to rename for\n    REG in THIS_HEAD chain.  THIS_UNAVAILABLE is a set of unavailable hard\n    registers.  */\n@@ -392,8 +266,6 @@ regrename_optimize (void)\n       if (dump_file)\n \tdump_def_use_chain (all_chains);\n \n-      sort_du_head (&all_chains);\n-\n       CLEAR_HARD_REG_SET (unavailable);\n       /* Don't clobber traceback for noreturn functions.  */\n       if (frame_pointer_needed)\n@@ -413,8 +285,9 @@ regrename_optimize (void)\n \t  HARD_REG_SET this_unavailable;\n \t  int reg = this_head->regno;\n \t  int pass;\n-\t  enum reg_class superunion_class = NO_REGS;\n+\t  enum reg_class super_class = NO_REGS;\n \t  enum reg_class preferred_class;\n+\t  bool has_preferred_class;\n \n \t  all_chains = this_head->next_chain;\n \n@@ -444,79 +317,78 @@ regrename_optimize (void)\n \n \t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n \n-\t  /* Iterate elements in chain in order to:\n+\t  /* Iterate over elements in the chain in order to:\n \t     1. Count number of uses, and narrow the set of registers we can\n-\t     use for renaming.\n+\t\tuse for renaming.\n \t     2. Compute the superunion of register classes in this chain.  */\n \t  n_uses = 0;\n-\t  superunion_class = NO_REGS;\n+\t  super_class = NO_REGS;\n \t  for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n \t    {\n \t      if (DEBUG_INSN_P (tmp->insn))\n \t\tcontinue;\n \t      n_uses++;\n-\n \t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n \t\t\t\t      reg_class_contents[tmp->cl]);\n-\n-\t      superunion_class\n-\t\t= reg_class_superunion[(int) superunion_class][(int) tmp->cl];\n+\t      super_class\n+\t\t= reg_class_superunion[(int) super_class][(int) tmp->cl];\n \t    }\n \n \t  if (n_uses < 2)\n \t    continue;\n \n+\t  /* Further narrow the set of registers we can use for renaming.\n+\t     If the chain needs a call-saved register, mark the call-used\n+\t     registers as unavailable.  */\n \t  if (this_head->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n+\t  /* And mark registers that overlap its lifetime as unavailable.  */\n \t  merge_overlapping_regs (&this_unavailable, this_head);\n+\n \t  /* Compute preferred rename class of super union of all the classes\n-\t     on the chain.  */\n+\t     in the chain.  */\n \t  preferred_class\n-\t    = (enum reg_class) targetm.preferred_rename_class(superunion_class);\n+\t    = (enum reg_class) targetm.preferred_rename_class (super_class);\n \n-\t  /* The register iteration order here is \"preferred-register-first\".\n-\t     Firstly(pass == 0), we iterate registers belong to PREFERRED_CLASS,\n-\t     if we find a new register, we stop immeidately.\n-\t     Otherwise, we iterate over registers that don't belong to\n-\t     PREFERRED_CLASS.\n+\t  /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass\n+\t     over registers that belong to PREFERRED_CLASS and try to find the\n+\t     best register within the class.  If that failed, we iterate in\n+\t     the second pass over registers that don't belong to the class.\n \t     If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n \t     ascending order without any preference.  */\n-\t  for (pass = (preferred_class == NO_REGS ? 1 : 0); pass < 2; pass++)\n+\t  has_preferred_class = (preferred_class != NO_REGS);\n+\t  for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)\n \t    {\n-\t      bool found = false;\n-\t      /* Now potential_regs is a reasonable approximation, let's\n-\t\t have a closer look at each register still in there.  */\n \t      for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n \t\t{\n-\t\t  /* Iterate registers first in prefered class.  */\n-\t\t  if (pass == 0\n-\t\t      && !TEST_HARD_REG_BIT (reg_class_contents[preferred_class],\n-\t\t\t\t\t     new_reg))\n+\t\t  if (has_preferred_class\n+\t\t      && (pass == 0)\n+\t\t\t != TEST_HARD_REG_BIT\n+\t\t\t    (reg_class_contents[preferred_class], new_reg))\n \t\t    continue;\n \n+\t\t  /* In the first pass, we force the renaming of registers that\n+\t\t     don't belong to PREFERRED_CLASS to registers that do, even\n+\t\t     though the latters were used not very long ago.  */\n \t\t  if (check_new_reg_p (reg, new_reg, this_head,\n-\t\t\t\t       this_unavailable))\n+\t\t\t\t       this_unavailable)\n+\t\t      && ((pass == 0\n+\t\t\t   && !TEST_HARD_REG_BIT\n+\t\t\t       (reg_class_contents[preferred_class],\n+\t\t\t        best_new_reg))\n+\t\t\t  || tick[best_new_reg] > tick[new_reg]))\n \t\t    {\n-\t\t      if (tick[best_new_reg] > tick[new_reg])\n-\t\t\t{\n-\t\t\t  enum machine_mode mode\n-\t\t\t    = GET_MODE (*this_head->first->loc);\n-\t\t\t  best_new_reg = new_reg;\n-\t\t\t  best_nregs = hard_regno_nregs[new_reg][mode];\n-\t\t\t  /* If we find a new reg in our preferred class,\n-\t\t\t     stop immediately.  */\n-\t\t\t  if (best_new_reg != reg && pass == 0)\n-\t\t\t    {\n-\t\t\t      found = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n+\t\t      enum machine_mode mode\n+\t\t\t= GET_MODE (*this_head->first->loc);\n+\t\t      best_new_reg = new_reg;\n+\t\t      best_nregs = hard_regno_nregs[new_reg][mode];\n \t\t    }\n \t\t}\n-\t      if (found)\n+\t      if (pass == 0 && best_new_reg != reg)\n \t\tbreak;\n \t    }\n+\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Register %s in insn %d\",\n@@ -732,7 +604,6 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   head->need_caller_save_reg = 0;\n   head->cannot_rename = 0;\n   head->terminated = 0;\n-  head->length = 0;\n \n   VEC_safe_push (du_head_p, heap, id_to_chain, head);\n   head->id = current_id++;\n@@ -778,8 +649,6 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   this_du->loc = loc;\n   this_du->insn = insn;\n   this_du->cl = cl;\n-\n-  head->length = 1;\n }\n \n static void\n@@ -868,9 +737,6 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      else\n \t\thead->last->next_use = this_du;\n \t      head->last = this_du;\n-\n-\t      if (!DEBUG_INSN_P (insn))\n-\t\thead->length++;\n \t    }\n \t  /* Avoid adding the same location in a DEBUG_INSN multiple times,\n \t     which could happen with non-exact overlap.  */"}]}