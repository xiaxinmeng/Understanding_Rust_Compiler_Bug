{"sha": "2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI5YTlhZWEyZjk0MTRhNGFiZTA0NTBkMGM2NjBkZWI4NTMyYmQ4Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-27T22:10:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-27T22:10:02Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1107", "tree": {"sha": "fc995758d89143c072b49963a64928ed40592d22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc995758d89143c072b49963a64928ed40592d22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/comments", "author": null, "committer": null, "parents": [{"sha": "2f3d30bb57917a3925e2e362a74f024b25cafcc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3d30bb57917a3925e2e362a74f024b25cafcc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3d30bb57917a3925e2e362a74f024b25cafcc4"}], "stats": {"total": 88, "additions": 80, "deletions": 8}, "files": [{"sha": "9639dd6d9155169a58ea63060357bbea97c37b3b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "patch": "@@ -938,10 +938,33 @@ singlemove_string (operands)\n       else\n \tabort ();\n     }\n-  if (GET_CODE (operands[1]) == MEM)\n+  else if (GET_CODE (operands[1]) == MEM)\n     return \"ld %1,%0\";\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      int i;\n+      union real_extract u;\n+      union float_extract { float f; int i; } v;\n+\n+      /* Must be SFmode, otherwise this doesn't make sense.  */\n+      if (GET_MODE (operands[1]) != SFmode)\n+\tabort ();\n+\n+      bcopy (&CONST_DOUBLE_LOW (operands[1]), &u, sizeof u);\n+      v.f = REAL_VALUE_TRUNCATE (SFmode, u.d);\n+      i = v.i;\n+\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, i);\n+\n+      if (CONST_OK_FOR_LETTER_P (i, 'I'))\n+\treturn \"mov %1,%0\";\n+      else if ((i & 0x000003FF) != 0)\n+\treturn \"sethi %%hi(%a1),%0\\n\\tor %0,%%lo(%a1),%0\";\n+      else\n+\treturn \"sethi %%hi(%a1),%0\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_INT\n+\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n     {\n       int i = INTVAL (operands[1]);\n \n@@ -952,7 +975,7 @@ singlemove_string (operands)\n       else\n \treturn \"sethi %%hi(%a1),%0\";\n     }\n-  /* ??? Wrong if target is DImode?  */\n+  /* Operand 1 must be a register, or a 'I' type CONST_INT.  */\n   return \"mov %1,%0\";\n }\n \f"}, {"sha": "4eaa1c3d547db78baf7f572f78857058345ee75c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "patch": "@@ -528,7 +528,15 @@ extern char leaf_reg_backmap[];\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+/* We can't load constants into FP registers.  We can't load any FP constant\n+   if an 'E' constraint fails to match it.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n+  (CONSTANT_P (X)\t\t\t\t\t\\\n+   && ((CLASS) == FP_REGS\t\t\t\t\\\n+       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n+\t   && (HOST_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\t\\\n+\t       || HOST_BITS_PER_INT != BITS_PER_WORD)))\t\\\n+   ? NO_REGS : (CLASS))\n \n /* Return the register class of a scratch register needed to load IN into\n    a register of class CLASS in MODE."}, {"sha": "cfc13bd0d615ac14813bd163f947f567dd5248d2", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "patch": "@@ -1115,8 +1115,6 @@\n ;; This pattern forces (set (reg:DF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory.\n ;; It must come before the more general movdf pattern.\n-;; ??? A similar pattern for SF mode values would also be useful, but it\n-;; is not as easy to write.\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=?r,f,o\")\n \t(match_operand:DF 1 \"\" \"?E,m,G\"))]\n@@ -1206,6 +1204,28 @@\n \n ;; Floating-point move insns.\n \n+;; This pattern forces (set (reg:SF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movsf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m\")\n+\t(match_operand:SF 1 \"\" \"?E,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return singlemove_string (operands);\n+    case 1:\n+      return \\\"ld %1,%0\\\";\n+    case 2:\n+      return \\\"st %%g0,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"load,fpload,store\")\n+   (set_attr \"length\" \"2,1,1\")])\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]"}, {"sha": "f285e244d138b488f4a5dcb2b27892e7819c489e", "filename": "gcc/unroll.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9a9aea2f9414a4abe0450d0c660deb8532bd83/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=2b9a9aea2f9414a4abe0450d0c660deb8532bd83", "patch": "@@ -2454,7 +2454,28 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  /* If the giv is an address destination, it could be something other\n \t     than a simple register, these have to be treated differently.  */\n \t  else if (v->giv_type == DEST_REG)\n-\t    splittable_regs[REGNO (v->new_reg)] = value;\n+\t    {\n+\t      /* If value is not a constant, register, or register plus\n+\t\t constant, then compute its value into a register before\n+\t\t loop start.  This prevents illegal rtx sharing, and should\n+\t\t generate better code.  We can use bl->initial_value here\n+\t\t instead of splittable_regs[bl->regno] because this code\n+\t\t is going before the loop start.  */\n+\t      if (unroll_type == UNROLL_COMPLETELY\n+\t\t  && GET_CODE (value) != CONST_INT\n+\t\t  && GET_CODE (value) != REG\n+\t\t  && (GET_CODE (value) != PLUS\n+\t\t      || GET_CODE (XEXP (value, 0)) != REG\n+\t\t      || GET_CODE (XEXP (value, 1)) != CONST_INT))\n+\t\t{\n+\t\t  rtx tem = gen_reg_rtx (v->mode);\n+\t\t  emit_iv_add_mult (bl->initial_value, v->mult_val,\n+\t\t\t\t    v->add_val, tem, loop_start);\n+\t\t  value = tem;\n+\t\t}\n+\t\t\n+\t      splittable_regs[REGNO (v->new_reg)] = value;\n+\t    }\n \t  else\n \t    {\n \t      /* Splitting address givs is useful since it will often allow us"}]}