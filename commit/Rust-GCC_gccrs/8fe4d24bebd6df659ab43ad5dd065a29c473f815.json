{"sha": "8fe4d24bebd6df659ab43ad5dd065a29c473f815", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZlNGQyNGJlYmQ2ZGY2NTlhYjQzYWQ1ZGQwNjVhMjljNDczZjgxNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-06-13T15:58:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-06-13T15:58:10Z"}, "message": "re PR c++/20789 (ICE with incomplete type in template)\n\ncp:\n\tPR c++/20789\n\t* decl.c (cp_finish_decl): Clear runtime runtime initialization if\n\tin-class decl's initializer is bad.\n\n\tPR c++/21929\n\t* parser.c (struct cp_parser): Document that scope could be\n\terror_mark.\n\t(cp_parser_diagnose_invalid_type_name): Cope with error_mark for\n\tscope.\n\t(cp_parser_nested_name_specifier): Return NULL_TREE on error.\n\t(cp_parser_postfix_expression): Deal with null or error_mark\n\tscope.\n\t(cp_parser_elaborated_type_specifier): Adjust\n\tcp_parser_nested_name_specifier call.\n\n\t* parser (cp_parser_skip_to_end_of_block_or_statement): Cleanup.\ntestsuite:\n\tPR c++/21929\n\t* g++.dg/parse/crash26.C: New.\n\n\tPR c++/20789\n\t* g++.dg/init/member1.C: New.\n\nFrom-SVN: r100880", "tree": {"sha": "80df738d7463c3986a421395691d3add01541ee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80df738d7463c3986a421395691d3add01541ee2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fe4d24bebd6df659ab43ad5dd065a29c473f815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe4d24bebd6df659ab43ad5dd065a29c473f815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fe4d24bebd6df659ab43ad5dd065a29c473f815", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe4d24bebd6df659ab43ad5dd065a29c473f815/comments", "author": null, "committer": null, "parents": [{"sha": "56fc483e31987c2936dfee9e141702c848da7a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fc483e31987c2936dfee9e141702c848da7a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56fc483e31987c2936dfee9e141702c848da7a50"}], "stats": {"total": 142, "additions": 109, "deletions": 33}, "files": [{"sha": "00a029de5cb6ff8fff4021a13051cf253a529fe1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -1,3 +1,22 @@\n+2005-06-13  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/20789\n+\t* decl.c (cp_finish_decl): Clear runtime runtime initialization if\n+\tin-class decl's initializer is bad.\n+\n+\tPR c++/21929\n+\t* parser.c (struct cp_parser): Document that scope could be\n+\terror_mark.\n+\t(cp_parser_diagnose_invalid_type_name): Cope with error_mark for\n+\tscope.\n+\t(cp_parser_nested_name_specifier): Return NULL_TREE on error.\n+\t(cp_parser_postfix_expression): Deal with null or error_mark\n+\tscope.\n+\t(cp_parser_elaborated_type_specifier): Adjust\n+\tcp_parser_nested_name_specifier call.\n+\n+\t* parser (cp_parser_skip_to_end_of_block_or_statement): Cleanup.\n+\n 2005-06-12  Roger Sayle  <roger@eyesopen.com>\n \n \tPR c++/21930"}, {"sha": "c17d6f8f3724aacd1c36f10ce1feb18df856358e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -4834,6 +4834,16 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t\t     \"initialized\", decl);\n \t      init = NULL_TREE;\n \t    }\n+\t  if (DECL_EXTERNAL (decl) && init)\n+\t    {\n+\t      /* The static data member cannot be initialized by a\n+\t\t non-constant when being declared.  */\n+\t      error (\"%qD cannot be initialized by a non-constant expression\"\n+\t\t     \" when being declared\", decl);\n+\t      DECL_INITIALIZED_IN_CLASS_P (decl) = 0;\n+\t      init = NULL_TREE;\n+\t    }\n+\t  \n \t  /* Handle:\n \n \t     [dcl.init]"}, {"sha": "f56c9019ce698a57107cded9e43a6298eb847a1f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -1217,15 +1217,16 @@ typedef struct cp_parser GTY(())\n   /* The scope in which names should be looked up.  If NULL_TREE, then\n      we look up names in the scope that is currently open in the\n      source program.  If non-NULL, this is either a TYPE or\n-     NAMESPACE_DECL for the scope in which we should look.\n+     NAMESPACE_DECL for the scope in which we should look.  It can\n+     also be ERROR_MARK, when we've parsed a bogus scope.\n \n      This value is not cleared automatically after a name is looked\n      up, so we must be careful to clear it before starting a new look\n      up sequence.  (If it is not cleared, then `X::Y' followed by `Z'\n      will look up `Z' in the scope of `X', rather than the current\n      scope.)  Unfortunately, it is difficult to tell when name lookup\n      is complete, because we sometimes peek at a token, look it up,\n-     and then decide not to consume it.  */\n+     and then decide not to consume it.   */\n   tree scope;\n \n   /* OBJECT_SCOPE and QUALIFYING_SCOPE give the scopes in which the\n@@ -2045,7 +2046,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     error (\"invalid use of template-name %qE without an argument list\",\n       decl);\n-  else if (!parser->scope)\n+  else if (!parser->scope || parser->scope == error_mark_node)\n     {\n       /* Issue an error message.  */\n       error (\"%qE does not name a type\", id);\n@@ -2313,36 +2314,48 @@ cp_parser_consume_semicolon_at_end_of_statement (cp_parser *parser)\n static void\n cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n {\n-  unsigned nesting_depth = 0;\n+  int nesting_depth = 0;\n \n-  while (true)\n+  while (nesting_depth >= 0)\n     {\n-      cp_token *token;\n-\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If we've run out of tokens, stop.  */\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      \n       if (token->type == CPP_EOF)\n \tbreak;\n-      /* If the next token is a `;', we have reached the end of the\n-\t statement.  */\n-      if (token->type == CPP_SEMICOLON && !nesting_depth)\n+\n+      switch (token->type)\n \t{\n-\t  /* Consume the `;'.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n+\tcase CPP_EOF:\n+\t  /* If we've run out of tokens, stop.  */\n+\t  nesting_depth = -1;\n+\t  continue;\n+\n+\tcase CPP_SEMICOLON:\n+\t  /* Stop if this is an unnested ';'. */\n+\t  if (!nesting_depth)\n+\t    nesting_depth = -1;\n+\t  break;\n+\n+\tcase CPP_CLOSE_BRACE:\n+\t  /* Stop if this is an unnested '}', or closes the outermost\n+\t     nesting level.  */\n+\t  nesting_depth--;\n+\t  if (!nesting_depth)\n+\t    nesting_depth = -1;\n+\t  break;\n+\t  \n+\tcase CPP_OPEN_BRACE:\n+\t  /* Nest. */\n+\t  nesting_depth++;\n+\t  break;\n+\n+\tdefault:\n \t  break;\n \t}\n+      \n       /* Consume the token.  */\n-      token = cp_lexer_consume_token (parser->lexer);\n-      /* If the next token is a non-nested `}', then we have reached\n-\t the end of the current block.  */\n-      if (token->type == CPP_CLOSE_BRACE\n-\t  && (nesting_depth == 0 || --nesting_depth == 0))\n-\tbreak;\n-      /* If it the next token is a `{', then we are entering a new\n-\t block.  Consume the entire block.  */\n-      if (token->type == CPP_OPEN_BRACE)\n-\t++nesting_depth;\n+      cp_lexer_consume_token (parser->lexer);\n+      \n     }\n }\n \n@@ -3664,9 +3677,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n /* Parse a nested-name-specifier.  See\n    cp_parser_nested_name_specifier_opt for details.  This function\n    behaves identically, except that it will an issue an error if no\n-   nested-name-specifier is present, and it will return\n-   ERROR_MARK_NODE, rather than NULL_TREE, if no nested-name-specifier\n-   is present.  */\n+   nested-name-specifier is present.  */\n \n static tree\n cp_parser_nested_name_specifier (cp_parser *parser,\n@@ -3688,7 +3699,6 @@ cp_parser_nested_name_specifier (cp_parser *parser,\n     {\n       cp_parser_error (parser, \"expected nested-name-specifier\");\n       parser->scope = NULL_TREE;\n-      return error_mark_node;\n     }\n \n   return scope;\n@@ -3973,7 +3983,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t  id = cp_parser_identifier (parser);\n \n \t/* Don't process id if nested name specifier is invalid.  */\n-\tif (scope == error_mark_node)\n+\tif (!scope || scope == error_mark_node)\n \t  return error_mark_node;\n \t/* If we look up a template-id in a non-dependent qualifying\n \t   scope, there's no need to create a dependent type.  */\n@@ -9871,12 +9881,11 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n   /* Look for the nested-name-specifier.  */\n   if (tag_type == typename_type)\n     {\n-      if (cp_parser_nested_name_specifier (parser,\n+      if (!cp_parser_nested_name_specifier (parser,\n \t\t\t\t\t   /*typename_keyword_p=*/true,\n \t\t\t\t\t   /*check_dependency_p=*/true,\n \t\t\t\t\t   /*type_p=*/true,\n-\t\t\t\t\t   is_declaration)\n-\t  == error_mark_node)\n+\t\t\t\t\t    is_declaration))\n \treturn error_mark_node;\n     }\n   else"}, {"sha": "8fb457e66516b81615a6c38c7e70a1a51fd14478", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -1,3 +1,11 @@\n+2005-06-13  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/21929\n+\t* g++.dg/parse/crash26.C: New.\n+\n+\tPR c++/20789\n+\t* g++.dg/init/member1.C: New.\n+\n 2005-06-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gfortran.dg/altreturn_1.f90: New test."}, {"sha": "1c89d5a1d43dfb52b5b11529a5b0d2202b9f9792", "filename": "gcc/testsuite/g++.dg/init/member1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fmember1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fmember1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fmember1.C?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -0,0 +1,18 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 13 Jun 2005 <nathan@codesourcery.com>\n+\n+// Origin:   Ivan Godard <igodard@pacbell.net>\n+// Bug 20789: ICE on invalid\n+\n+template<typename> struct A;\n+\n+template<int> struct B {};\n+\n+template<typename T> struct C\n+{\n+  static const int i = A<T>::i;  // { dg-error \"incomplete\" }\n+  static const int j = i;      // { dg-error \"initialized by a non-const\" }\n+  B<j> b;  // { dg-error \"not a valid template arg\" }\n+};\n+\n+C<int> c;"}, {"sha": "2b4f165f8b9a30b444c81e2fe895ef442bdfa686", "filename": "gcc/testsuite/g++.dg/parse/crash26.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe4d24bebd6df659ab43ad5dd065a29c473f815/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash26.C?ref=8fe4d24bebd6df659ab43ad5dd065a29c473f815", "patch": "@@ -0,0 +1,12 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 13 Jun 2005 <nathan@codesourcery.com>\n+\n+// Origin:  Volker Reichelt <reichelt@gcc.gnu.org>\n+// Bug 21929: ICE on invalid\n+\n+template<int> struct A\n+{\n+    struct B;\n+};\n+\n+template<> struct A<void>::B {}; // { dg-error \"mismatch|expected|name a type|extra\" }"}]}