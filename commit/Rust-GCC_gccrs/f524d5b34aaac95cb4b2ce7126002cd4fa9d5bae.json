{"sha": "f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUyNGQ1YjM0YWFhYzk1Y2I0YjJjZTcxMjYwMDJjZDRmYTlkNWJhZQ==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-09-21T16:48:35Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-09-21T16:48:35Z"}, "message": "re PR libstdc++/77537 (pair constructors do not properly SFINAE)\n\n\tPR libstdc++/77537\n\tImplement LWG 2729 for pair.\n\t* include/bits/stl_pair.h (_PCC): New.\n\t(_ConstructiblePair, _ImplicitlyConvertiblePair):\n\tTurn into static member functions of _PCC.\n\t(_MoveConstructiblePair, _ImplicitlyMoveConvertiblePair): Likewise.\n\t(_PCCP): New.\n\t(pair(const _T1&, const _T2&)): Adjust.\n\t(_PCCFP): New.\n\t(pair(const pair<_U1, _U2>&)): Adjust.\n\t(pair(_U1&&, const _T2&)): Likewise.\n\t(pair(const _T1&, _U2&&)): Likewise.\n\t(pair(_U1&&, _U2&&)): Likewise.\n\t(pair(pair<_U1, _U2>&&)): Likewise.\n\t(operator=(const pair&)): Make conditionally deleted.\n\t(operator=(pair&&)): Make conditionally suppressed.\n\t(operator=(const pair<_U1, _U2>&)): Constrain.\n\t(operator=(pair<_U1, _U2>&&): Likewise.\n\t* include/std/type_traits (__nonesuch): New.\n\t* testsuite/20_util/pair/traits.cc: New.\n\nFrom-SVN: r240322", "tree": {"sha": "1620641ceb06be29326134f342843d55e466d9e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1620641ceb06be29326134f342843d55e466d9e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d43b4ccc3737d468df2006814abe47824129e054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43b4ccc3737d468df2006814abe47824129e054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43b4ccc3737d468df2006814abe47824129e054"}], "stats": {"total": 352, "additions": 263, "deletions": 89}, "files": [{"sha": "0c35cd7056b2a97656f10939a6a82960b9813c6f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "patch": "@@ -1,3 +1,26 @@\n+2016-09-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tPR libstdc++/77537\n+\tImplement LWG 2729 for pair.\n+\t* include/bits/stl_pair.h (_PCC): New.\n+\t(_ConstructiblePair, _ImplicitlyConvertiblePair):\n+\tTurn into static member functions of _PCC.\n+\t(_MoveConstructiblePair, _ImplicitlyMoveConvertiblePair): Likewise.\n+\t(_PCCP): New.\n+\t(pair(const _T1&, const _T2&)): Adjust.\n+\t(_PCCFP): New.\n+\t(pair(const pair<_U1, _U2>&)): Adjust.\n+\t(pair(_U1&&, const _T2&)): Likewise.\n+\t(pair(const _T1&, _U2&&)): Likewise.\n+\t(pair(_U1&&, _U2&&)): Likewise.\n+\t(pair(pair<_U1, _U2>&&)): Likewise.\n+\t(operator=(const pair&)): Make conditionally deleted.\n+\t(operator=(pair&&)): Make conditionally suppressed.\n+\t(operator=(const pair<_U1, _U2>&)): Constrain.\n+\t(operator=(pair<_U1, _U2>&&): Likewise.\n+\t* include/std/type_traits (__nonesuch): New.\n+\t* testsuite/20_util/pair/traits.cc: New.\n+\n 2016-09-20  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tPR libstdc++/77619"}, {"sha": "ef5253823efedc0e472994a97c9139d11720cdeb", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 157, "deletions": 89, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "patch": "@@ -88,52 +88,95 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Concept utility functions, reused in conditionally-explicit\n   // constructors.\n   // See PR 70437, don't look at is_constructible or\n-  // is_convertible if the decayed types are the same to\n+  // is_convertible if the types are the same to\n   // avoid querying those properties for incomplete types.\n-  template <typename _T1, typename _T2, typename _U1, typename _U2>\n-  constexpr bool _ConstructiblePair()\n-  {\n-    return __and_<__or_<is_same<typename decay<_T1>::type,\n-\t\t\t\ttypename decay<_U1>::type>,\n-\t\t\tis_constructible<_T1, const _U1&>>,\n-\t\t  __or_<is_same<typename decay<_T2>::type,\n-\t\t\t\ttypename decay<_U2>::type>,\n-\t\t\tis_constructible<_T2, const _U2&>>>::value;\n-  }\n-\n-  template <typename _T1, typename _T2, typename _U1, typename _U2>\n-  constexpr bool _ImplicitlyConvertiblePair()\n-  {\n-    return __and_<__or_<is_same<typename decay<_T1>::type,\n-\t\t\t\ttypename decay<_U1>::type>,\n-\t\t\tis_convertible<const _U1&, _T1>>,\n-\t\t  __or_<is_same<typename decay<_T2>::type,\n-\t\t\t\ttypename decay<_U2>::type>,\n-\t\t       is_convertible<const _U2&, _T2>>>::value;\n-  }\n-\n-  template <typename _T1, typename _T2, typename _U1, typename _U2>\n-  constexpr bool _MoveConstructiblePair()\n-  {\n-    return __and_<__or_<is_same<typename decay<_T1>::type,\n-\t\t\t\ttypename decay<_U1>::type>,\n-\t\t\tis_constructible<_T1, _U1&&>>,\n-\t\t  __or_<is_same<typename decay<_T2>::type,\n-\t\t\t\ttypename decay<_U2>::type>,\n-\t\t\tis_constructible<_T2, _U2&&>>>::value;\n-  }\n-\n-  template <typename _T1, typename _T2, typename _U1, typename _U2>\n-  constexpr bool _ImplicitlyMoveConvertiblePair()\n-  {\n-    return __and_<__or_<is_same<typename decay<_T1>::type,\n-\t\t\t\ttypename decay<_U1>::type>,\n-\t\t\tis_convertible<_U1&&, _T1>>,\n-\t\t  __or_<is_same<typename decay<_T2>::type,\n-\t\t\t\ttypename decay<_U2>::type>,\n-\t\t       is_convertible<_U2&&, _T2>>>::value;\n-  }\n+  template <bool, typename _T1, typename _T2>\n+    struct _PCC\n+    {\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ConstructiblePair()\n+      {\n+\treturn __and_<is_constructible<_T1, const _U1&>,\n+\t\t      is_constructible<_T2, const _U2&>>::value;\n+      }\n+\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ImplicitlyConvertiblePair()\n+      {\n+\treturn __and_<is_convertible<const _U1&, _T1>,\n+\t\t      is_convertible<const _U2&, _T2>>::value;\n+      }\n+\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _MoveConstructiblePair()\n+      {\n+\treturn __and_<is_constructible<_T1, _U1&&>,\n+\t\t      is_constructible<_T2, _U2&&>>::value;\n+      }\n \n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ImplicitlyMoveConvertiblePair()\n+      {\n+\treturn __and_<is_convertible<_U1&&, _T1>,\n+\t\t      is_convertible<_U2&&, _T2>>::value;\n+      }\n+\n+      template <bool __implicit, typename _U1, typename _U2>\n+      static constexpr bool _CopyMovePair()\n+      {\n+\tusing __do_converts = __and_<is_convertible<const _U1&, _T1>,\n+\t\t\t\t  is_convertible<_U2&&, _T2>>;\n+\tusing __converts = typename conditional<__implicit,\n+\t\t\t\t       __do_converts,\n+\t\t\t\t       __not_<__do_converts>>::type;\n+\treturn __and_<is_constructible<_T1, const _U1&>,\n+\t\t      is_constructible<_T2, _U2&&>,\n+\t\t      __converts\n+\t\t      >::value;\n+      }\n+\n+      template <bool __implicit, typename _U1, typename _U2>\n+      static constexpr bool _MoveCopyPair()\n+      {\n+\tusing __do_converts = __and_<is_convertible<_U1&&, _T1>,\n+\t\t\t\t  is_convertible<const _U2&, _T2>>;\n+\tusing __converts = typename conditional<__implicit,\n+\t\t\t\t       __do_converts,\n+\t\t\t\t       __not_<__do_converts>>::type;\n+\treturn __and_<is_constructible<_T1, _U1&&>,\n+\t\t      is_constructible<_T2, const _U2&&>,\n+\t\t      __converts\n+\t\t      >::value;\n+      }\n+  };\n+\n+  template <typename _T1, typename _T2>\n+    struct _PCC<false, _T1, _T2>\n+    {\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ConstructiblePair()\n+      {\n+\treturn false;\n+      }\n+\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ImplicitlyConvertiblePair()\n+      {\n+\treturn false;\n+      }\n+\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _MoveConstructiblePair()\n+      {\n+\treturn false;\n+      }\n+\n+      template <typename _U1, typename _U2>\n+      static constexpr bool _ImplicitlyMoveConvertiblePair()\n+      {\n+\treturn false;\n+      }\n+  };\n \n #endif\n \n@@ -186,16 +229,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n #else\n+      // Shortcut for constraining the templates that don't take pairs.\n+      using _PCCP = _PCC<true, _T1, _T2>;\n+\n       template<typename _U1 = _T1, typename _U2=_T2, typename\n-                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _ConstructiblePair<_U1, _U2>()\n+\t                 && _PCCP::template\n+\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n                          bool>::type=true>\n       constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n \n        template<typename _U1 = _T1, typename _U2=_T2, typename\n-\t       enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+\t\tenable_if<_PCCP::template\n+\t\t\t    _ConstructiblePair<_U1, _U2>()\n+\t                  && !_PCCP::template\n+\t\t\t    _ImplicitlyConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n       explicit constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n@@ -207,16 +257,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tpair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n #else\n+      // Shortcut for constraining the templates that take pairs.\n+      template <typename _U1, typename _U2>\n+        using _PCCFP = _PCC<!is_same<_T1, _U1>::value\n+\t\t\t    || !is_same<_T2, _U2>::value,\n+\t\t\t    _T1, _T2>;\n+\n       template<typename _U1, typename _U2, typename\n-\t       enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n-                         bool>::type=true>\n+\t       enable_if<_PCCFP<_U1, _U2>::template\n+\t\t\t   _ConstructiblePair<_U1, _U2>()\n+\t                 && _PCCFP<_U1, _U2>::template\n+\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n+\t\t\t  bool>::type=true>\n         constexpr pair(const pair<_U1, _U2>& __p)\n         : first(__p.first), second(__p.second) { }\n \n       template<typename _U1, typename _U2, typename\n-               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+\t       enable_if<_PCCFP<_U1, _U2>::template\n+\t\t\t   _ConstructiblePair<_U1, _U2>()\n+\t\t\t && !_PCCFP<_U1, _U2>::template\n+\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n \texplicit constexpr pair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n@@ -226,75 +286,67 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // DR 811.\n       template<typename _U1, typename\n-               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()\n-                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()\n-                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()\n-                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n-\t\t\t\t\t\t\t  _U1, _T2>(),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _MoveCopyPair<true, _U1, _T2>(),\n                          bool>::type=true>\n        constexpr pair(_U1&& __x, const _T2& __y)\n        : first(std::forward<_U1>(__x)), second(__y) { }\n \n       template<typename _U1, typename\n-               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()\n-                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()\n-                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()\n-                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n-                                                                _U1, _T2>()),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _MoveCopyPair<false, _U1, _T2>(),\n                          bool>::type=false>\n        explicit constexpr pair(_U1&& __x, const _T2& __y)\n        : first(std::forward<_U1>(__x)), second(__y) { }\n \n       template<typename _U2, typename\n-               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()\n-                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()\n-                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()\n-                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n-                                                           _T1, _U2>(),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _CopyMovePair<true, _T1, _U2>(),\n                          bool>::type=true>\n        constexpr pair(const _T1& __x, _U2&& __y)\n        : first(__x), second(std::forward<_U2>(__y)) { }\n \n       template<typename _U2, typename\n-               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()\n-                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()\n-                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()\n-                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n-                                                                _T1, _U2>()),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _CopyMovePair<false, _T1, _U2>(),\n                          bool>::type=false>\n        explicit pair(const _T1& __x, _U2&& __y)\n        : first(__x), second(std::forward<_U2>(__y)) { }\n \n       template<typename _U1, typename _U2, typename\n-\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n-\t\t\t\t\t\t\t   _U1, _U2>(),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n+\t\t\t  && _PCCP::template\n+\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=true>\n \tconstexpr pair(_U1&& __x, _U2&& __y)\n \t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n \n       template<typename _U1, typename _U2, typename\n-\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n-\t\t\t\t\t\t\t    _U1, _U2>(),\n+\t       enable_if<_PCCP::template\n+\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n+\t\t\t  && !_PCCP::template\n+\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n \texplicit constexpr pair(_U1&& __x, _U2&& __y)\n \t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n \n \n       template<typename _U1, typename _U2, typename\n-\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n-\t\t\t\t\t\t\t   _U1, _U2>(),\n+\t       enable_if<_PCCFP<_U1, _U2>::template\n+\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n+\t\t\t  && _PCCFP<_U1, _U2>::template\n+\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=true>\n \tconstexpr pair(pair<_U1, _U2>&& __p)\n \t: first(std::forward<_U1>(__p.first)),\n \t  second(std::forward<_U2>(__p.second)) { }\n \n       template<typename _U1, typename _U2, typename\n-\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n-                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n-\t\t\t\t\t\t\t   _U1, _U2>(),\n+\t       enable_if<_PCCFP<_U1, _U2>::template\n+\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n+\t\t\t  && !_PCCFP<_U1, _U2>::template\n+\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n \texplicit constexpr pair(pair<_U1, _U2>&& __p)\n \t: first(std::forward<_U1>(__p.first)),\n@@ -304,15 +356,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n \n       pair&\n-      operator=(const pair& __p)\n+      operator=(typename conditional<\n+\t\t__and_<is_copy_assignable<_T1>,\n+\t\t       is_copy_assignable<_T2>>::value,\n+\t\tconst pair&, const __nonesuch&>::type __p)\n       {\n \tfirst = __p.first;\n \tsecond = __p.second;\n \treturn *this;\n       }\n \n       pair&\n-      operator=(pair&& __p)\n+      operator=(typename conditional<\n+\t\t__not_<__and_<is_copy_assignable<_T1>,\n+\t\t              is_copy_assignable<_T2>>>::value,\n+\t\tconst pair&, const __nonesuch&>::type __p) = delete;\n+\n+      pair&\n+      operator=(typename conditional<\n+\t\t__and_<is_move_assignable<_T1>,\n+\t\t       is_move_assignable<_T2>>::value,\n+\t\tpair&&, __nonesuch&&>::type __p)\n       noexcept(__and_<is_nothrow_move_assignable<_T1>,\n \t              is_nothrow_move_assignable<_T2>>::value)\n       {\n@@ -322,7 +386,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       template<typename _U1, typename _U2>\n-\tpair&\n+      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,\n+\t\t\t\tis_assignable<_T2&, const _U2&>>::value,\n+\t\t\t pair&>::type\n \toperator=(const pair<_U1, _U2>& __p)\n \t{\n \t  first = __p.first;\n@@ -331,7 +397,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _U1, typename _U2>\n-\tpair&\n+      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,\n+\t\t\t\tis_assignable<_T2&, _U2&&>>::value,\n+\t\t\t pair&>::type\n \toperator=(pair<_U1, _U2>&& __p)\n \t{\n \t  first = std::forward<_U1>(__p.first);"}, {"sha": "cd0ba99dcb8c4f5f36df032c2f08876e5b5ee201", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "patch": "@@ -2850,6 +2850,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n              __call_is_nothrow<result_of<_Fn(_Args...)>, _Fn, _Args...>>::type\n     { };\n \n+  struct __nonesuch {\n+    __nonesuch() = delete;\n+    ~__nonesuch() = delete;\n+    __nonesuch(__nonesuch const&) = delete;\n+    void operator=(__nonesuch const&) = delete;\n+  };\n+\n #if __cplusplus > 201402L\n # define __cpp_lib_is_callable 201603\n "}, {"sha": "850f898a4141352510a3eb3bcae69042b15ced9f", "filename": "libstdc++-v3/testsuite/20_util/pair/traits.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Ftraits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Ftraits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Ftraits.cc?ref=f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "patch": "@@ -0,0 +1,76 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+\n+#include <type_traits>\n+#include <memory>\n+\n+using namespace std;\n+\n+struct Poison\n+{\n+\tPoison(Poison&&) = delete;\n+};\n+\n+struct ThrowingCopy\n+{\n+  ThrowingCopy(const ThrowingCopy&) {}\n+  ThrowingCopy& operator=(const ThrowingCopy&) {}\n+};\n+\n+int main()\n+{\n+\tstatic_assert(!is_copy_constructible<Poison>::value, \"\");\n+\tstatic_assert(!is_move_constructible<Poison>::value, \"\");\n+\tstatic_assert(!is_copy_assignable<Poison>::value, \"\");\n+\tstatic_assert(!is_move_assignable<Poison>::value, \"\");\n+\tstatic_assert(!is_copy_constructible<std::pair<int, Poison>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_move_constructible<std::pair<int, Poison>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_copy_assignable<std::pair<int, Poison>>::value, \"\");\n+\tstatic_assert(!is_move_assignable<std::pair<int, Poison>>::value, \"\");\n+\tstatic_assert(!is_constructible<std::pair<int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_assignable<std::pair<int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_constructible<std::pair<int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_assignable<std::pair<int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_copy_constructible<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+\tstatic_assert(is_move_constructible<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_nothrow_move_constructible<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_copy_assignable<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+\tstatic_assert(is_move_assignable<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_nothrow_move_assignable<std::pair<ThrowingCopy,\n+\t\t      std::unique_ptr<int>>>::value,\n+\t\t      \"\");\n+}"}]}