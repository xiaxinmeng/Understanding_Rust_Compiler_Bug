{"sha": "07758d90c7bc6b80b10a83bac52f9ab9e394131d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc3NThkOTBjN2JjNmI4MGIxMGE4M2JhYzUyZjlhYjllMzk0MTMxZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-10-11T15:29:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-10-11T15:29:55Z"}, "message": "PR libstdc++/92059 fix several bugs in tr2::dynamic_bitset\n\n\tPR libstdc++/92059\n\t* include/tr2/dynamic_bitset (__dynamic_bitset_base): Define all\n\tspecial member functions as defaulted. Add noexcept to most members.\n\t(__dynamic_bitset_base(size_t, unsigned long long, const _Alloc&)):\n\tMask off unwanted bits in the __val parameter. Avoid undefined left\n\tshifts.\n\t(__dynamic_bitset_base::_M_assign): Remove.\n\t(__dynamic_bitset_base::_M_do_reset): Use std::fill.\n\t(__dynamic_bitset_base::_M_are_all_aux): Avoid integer promotion when\n\tblock_type has lower rank than int.\n\t(dynamic_bitset): Add noexcept to most members. Use injected-class-name\n\tin return types and parameter types.\n\t(dynamic_bitset::_M_Nb): Add default member initializer.\n\t(dynamic_bitset(), dynamic_bitset(const dynamic_bitset&)): Define as\n\tdefaulted.\n\t(dynamic_bitset(dynamic_bitset&&)): Clear source object after move.\n\t(dynamic_bitset::operator=(const dynamic_bitset&)): Define as\n\tdefaulted.\n\t(dynamic_bitset::operator=(dynamic_bitset&&)): Add noexcept-specifier.\n\tDefine without using swap, to propagate allocator correctly.\n\t(dynamic_bitset(const char*, const _Alloc&)): Use strlen.\n\t(dynamic_bitset::_M_do_sanitize, dynamic_bitset::_M_do_fill): Use\n\tcasts to avoid unwanted integer promotions.\n\t(dynamic_bitset::_M_copy_from_ptr): Rearrange template parameters and\n\tadd default template arguments and default argument to simplify usage.\n\t(dynamic_bitset::_M_copy_from_string): Adjust call to _M_copy_from_ptr.\n\t(operator==(const dynamic_bitset&, const dynamic_bitset&))\n\t(operator<(const dynamic_bitset&, const dynamic_bitset&)): Use _M_Nb.\n\t* include/tr2/dynamic_bitset.tcc (dynamic_bitset::_M_copy_from_ptr):\n\tAdjust template parameters to match declaration.\n\t* testsuite/tr2/dynamic_bitset/cmp.cc: New test.\n\t* testsuite/tr2/dynamic_bitset/cons.cc: New test.\n\t* testsuite/tr2/dynamic_bitset/copy.cc: New test.\n\t* testsuite/tr2/dynamic_bitset/move.cc: New test.\n\t* testsuite/tr2/dynamic_bitset/pr92059.cc: New test.\n\nFrom-SVN: r276890", "tree": {"sha": "471b8a23cc4ad0e7c100d147ad0f5b63bc744864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/471b8a23cc4ad0e7c100d147ad0f5b63bc744864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07758d90c7bc6b80b10a83bac52f9ab9e394131d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07758d90c7bc6b80b10a83bac52f9ab9e394131d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07758d90c7bc6b80b10a83bac52f9ab9e394131d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07758d90c7bc6b80b10a83bac52f9ab9e394131d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf2dacb355af3632fd98b2f9e920f1e03722049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf2dacb355af3632fd98b2f9e920f1e03722049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf2dacb355af3632fd98b2f9e920f1e03722049"}], "stats": {"total": 632, "additions": 478, "deletions": 154}, "files": [{"sha": "3e6a7ddb539b9739e3a51da67d526b5af0137190", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -1,5 +1,41 @@\n 2019-10-11  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/92059\n+\t* include/tr2/dynamic_bitset (__dynamic_bitset_base): Define all\n+\tspecial member functions as defaulted. Add noexcept to most members.\n+\t(__dynamic_bitset_base(size_t, unsigned long long, const _Alloc&)):\n+\tMask off unwanted bits in the __val parameter. Avoid undefined left\n+\tshifts.\n+\t(__dynamic_bitset_base::_M_assign): Remove.\n+\t(__dynamic_bitset_base::_M_do_reset): Use std::fill.\n+\t(__dynamic_bitset_base::_M_are_all_aux): Avoid integer promotion when\n+\tblock_type has lower rank than int.\n+\t(dynamic_bitset): Add noexcept to most members. Use injected-class-name\n+\tin return types and parameter types.\n+\t(dynamic_bitset::_M_Nb): Add default member initializer.\n+\t(dynamic_bitset(), dynamic_bitset(const dynamic_bitset&)): Define as\n+\tdefaulted.\n+\t(dynamic_bitset(dynamic_bitset&&)): Clear source object after move.\n+\t(dynamic_bitset::operator=(const dynamic_bitset&)): Define as\n+\tdefaulted.\n+\t(dynamic_bitset::operator=(dynamic_bitset&&)): Add noexcept-specifier.\n+\tDefine without using swap, to propagate allocator correctly.\n+\t(dynamic_bitset(const char*, const _Alloc&)): Use strlen.\n+\t(dynamic_bitset::_M_do_sanitize, dynamic_bitset::_M_do_fill): Use\n+\tcasts to avoid unwanted integer promotions.\n+\t(dynamic_bitset::_M_copy_from_ptr): Rearrange template parameters and\n+\tadd default template arguments and default argument to simplify usage.\n+\t(dynamic_bitset::_M_copy_from_string): Adjust call to _M_copy_from_ptr.\n+\t(operator==(const dynamic_bitset&, const dynamic_bitset&))\n+\t(operator<(const dynamic_bitset&, const dynamic_bitset&)): Use _M_Nb.\n+\t* include/tr2/dynamic_bitset.tcc (dynamic_bitset::_M_copy_from_ptr):\n+\tAdjust template parameters to match declaration.\n+\t* testsuite/tr2/dynamic_bitset/cmp.cc: New test.\n+\t* testsuite/tr2/dynamic_bitset/cons.cc: New test.\n+\t* testsuite/tr2/dynamic_bitset/copy.cc: New test.\n+\t* testsuite/tr2/dynamic_bitset/move.cc: New test.\n+\t* testsuite/tr2/dynamic_bitset/pr92059.cc: New test.\n+\n \t* include/bits/charconv.h (__to_chars_len): Avoid -Wsign-compare\n \twarnings.\n "}, {"sha": "28c877c048422cd62f73dc81d553603ea2d71050", "filename": "libstdc++-v3/include/tr2/dynamic_bitset", "status": "modified", "additions": 142, "deletions": 153, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -34,10 +34,9 @@\n #include <limits>\n #include <vector>\n #include <string>\n-#include <memory> // For std::allocator\n-#include <bits/functexcept.h>   // For invalid_argument, out_of_range,\n-\t\t\t\t// overflow_error\n-#include <iosfwd>\n+#include <istream>\n+#include <bits/functexcept.h>\n+#include <bits/stl_algo.h>\t// For fill\n #include <bits/cxxabi_forced.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -76,41 +75,48 @@ namespace tr2\n       std::vector<block_type, allocator_type> _M_w;\n \n       explicit\n-      __dynamic_bitset_base(const allocator_type& __alloc = allocator_type())\n+      __dynamic_bitset_base(const allocator_type& __alloc)\n       : _M_w(__alloc)\n       { }\n \n-      explicit\n-      __dynamic_bitset_base(__dynamic_bitset_base&& __b)\n-      { this->_M_w.swap(__b._M_w); }\n+      __dynamic_bitset_base() = default;\n+      __dynamic_bitset_base(const __dynamic_bitset_base&) = default;\n+      __dynamic_bitset_base(__dynamic_bitset_base&& __b) = default;\n+      __dynamic_bitset_base& operator=(const __dynamic_bitset_base&) = default;\n+      __dynamic_bitset_base& operator=(__dynamic_bitset_base&&) = default;\n+      ~__dynamic_bitset_base() = default;\n \n       explicit\n       __dynamic_bitset_base(size_type __nbits, unsigned long long __val = 0ULL,\n \t\t\t   const allocator_type& __alloc = allocator_type())\n-      : _M_w(__nbits / _S_bits_per_block\n-\t     + (__nbits % _S_bits_per_block > 0),\n-\t     __val, __alloc)\n+      : _M_w(__nbits / _S_bits_per_block + (__nbits % _S_bits_per_block > 0),\n+\t     block_type(0), __alloc)\n       {\n-\tunsigned long long __mask = ~static_cast<block_type>(0);\n-\tsize_t __n = std::min(this->_M_w.size(),\n-\t\t\t      sizeof(unsigned long long) / sizeof(block_type));\n-\tfor (size_t __i = 0; __i < __n; ++__i)\n+\tif (__nbits < std::numeric_limits<decltype(__val)>::digits)\n+\t  __val &= ~(-1ULL << __nbits);\n+\tif (__val == 0)\n+\t  return;\n+\n+\tif _GLIBCXX17_CONSTEXPR (sizeof(__val) == sizeof(block_type))\n+\t  _M_w[0] = __val;\n+\telse\n \t  {\n-\t    this->_M_w[__i] = (__val & __mask) >> (__i * _S_bits_per_block);\n-\t    __mask <<= _S_bits_per_block;\n+\t    const size_t __n\n+\t      = std::min(_M_w.size(), sizeof(__val) / sizeof(block_type));\n+\t    for (size_t __i = 0; __val && __i < __n; ++__i)\n+\t      {\n+\t\t_M_w[__i] = static_cast<block_type>(__val);\n+\t\t__val >>= _S_bits_per_block;\n+\t      }\n \t  }\n       }\n \n       void\n-      _M_assign(const __dynamic_bitset_base& __b)\n-      { this->_M_w = __b._M_w; }\n-\n-      void\n-      _M_swap(__dynamic_bitset_base& __b)\n+      _M_swap(__dynamic_bitset_base& __b) noexcept\n       { this->_M_w.swap(__b._M_w); }\n \n       void\n-      _M_clear()\n+      _M_clear() noexcept\n       { this->_M_w.clear(); }\n \n       void\n@@ -129,7 +135,7 @@ namespace tr2\n       }\n \n       allocator_type\n-      _M_get_allocator() const\n+      _M_get_allocator() const noexcept\n       { return this->_M_w.get_allocator(); }\n \n       static size_type\n@@ -149,23 +155,23 @@ namespace tr2\n       { return (static_cast<block_type>(1)) << _S_whichbit(__pos); }\n \n       block_type&\n-      _M_getword(size_type __pos)\n+      _M_getword(size_type __pos) noexcept\n       { return this->_M_w[_S_whichword(__pos)]; }\n \n       block_type\n-      _M_getword(size_type __pos) const\n+      _M_getword(size_type __pos) const noexcept\n       { return this->_M_w[_S_whichword(__pos)]; }\n \n       block_type&\n-      _M_hiword()\n+      _M_hiword() noexcept\n       { return this->_M_w[_M_w.size() - 1]; }\n \n       block_type\n-      _M_hiword() const\n+      _M_hiword() const noexcept\n       { return this->_M_w[_M_w.size() - 1]; }\n \n       void\n-      _M_do_and(const __dynamic_bitset_base& __x)\n+      _M_do_and(const __dynamic_bitset_base& __x) noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n@@ -175,7 +181,7 @@ namespace tr2\n       }\n \n       void\n-      _M_do_or(const __dynamic_bitset_base& __x)\n+      _M_do_or(const __dynamic_bitset_base& __x) noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n@@ -185,7 +191,7 @@ namespace tr2\n       }\n \n       void\n-      _M_do_xor(const __dynamic_bitset_base& __x)\n+      _M_do_xor(const __dynamic_bitset_base& __x) noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n@@ -195,7 +201,7 @@ namespace tr2\n       }\n \n       void\n-      _M_do_dif(const __dynamic_bitset_base& __x)\n+      _M_do_dif(const __dynamic_bitset_base& __x) noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n@@ -211,28 +217,27 @@ namespace tr2\n       _M_do_right_shift(size_t __shift);\n \n       void\n-      _M_do_flip()\n+      _M_do_flip() noexcept\n       {\n \tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n \t  this->_M_w[__i] = ~this->_M_w[__i];\n       }\n \n       void\n-      _M_do_set()\n+      _M_do_set() noexcept\n       {\n \tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n-\t  this->_M_w[__i] = ~static_cast<block_type>(0);\n+\t  this->_M_w[__i] = static_cast<block_type>(-1);\n       }\n \n       void\n-      _M_do_reset()\n+      _M_do_reset() noexcept\n       {\n-\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n-\t  this->_M_w[__i] = static_cast<block_type>(0);\n+\tstd::fill(_M_w.begin(), _M_w.end(), static_cast<block_type>(0));\n       }\n \n       bool\n-      _M_is_equal(const __dynamic_bitset_base& __x) const\n+      _M_is_equal(const __dynamic_bitset_base& __x) const noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  {\n@@ -246,7 +251,7 @@ namespace tr2\n       }\n \n       bool\n-      _M_is_less(const __dynamic_bitset_base& __x) const\n+      _M_is_less(const __dynamic_bitset_base& __x) const noexcept\n       {\n \tif (__x._M_w.size() == this->_M_w.size())\n \t  {\n@@ -264,17 +269,17 @@ namespace tr2\n       }\n \n       size_t\n-      _M_are_all_aux() const\n+      _M_are_all_aux() const noexcept\n       {\n \tfor (size_t __i = 0; __i < this->_M_w.size() - 1; ++__i)\n-\t  if (_M_w[__i] != ~static_cast<block_type>(0))\n+\t  if (_M_w[__i] != static_cast<block_type>(-1))\n \t    return 0;\n \treturn ((this->_M_w.size() - 1) * _S_bits_per_block\n \t\t+ __builtin_popcountll(this->_M_hiword()));\n       }\n \n       bool\n-      _M_is_any() const\n+      _M_is_any() const noexcept\n       {\n \tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n \t  if (this->_M_w[__i] != static_cast<block_type>(0))\n@@ -283,7 +288,7 @@ namespace tr2\n       }\n \n       bool\n-      _M_is_subset_of(const __dynamic_bitset_base& __b)\n+      _M_is_subset_of(const __dynamic_bitset_base& __b) noexcept\n       {\n \tif (__b._M_w.size() == this->_M_w.size())\n \t  {\n@@ -297,7 +302,7 @@ namespace tr2\n       }\n \n       bool\n-      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const\n+      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const noexcept\n       {\n \tif (this->is_subset_of(__b))\n \t  {\n@@ -311,7 +316,7 @@ namespace tr2\n       }\n \n       size_t\n-      _M_do_count() const\n+      _M_do_count() const noexcept\n       {\n \tsize_t __result = 0;\n \tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n@@ -357,6 +362,7 @@ namespace tr2\n    *\n    *  See N2050,\n    *  Proposal to Add a Dynamically Sizeable Bitset to the Standard Library.\n+   *  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf\n    *\n    *  In the general unoptimized case, storage is allocated in\n    *  word-sized blocks.  Let B be the number of bits in a word, then\n@@ -435,7 +441,7 @@ namespace tr2\n       {\n \tsize_type __shift = this->_M_Nb % bits_per_block;\n \tif (__shift > 0)\n-\t  this->_M_hiword() &= ~((~static_cast<block_type>(0)) << __shift);\n+\t  this->_M_hiword() &= block_type(~(block_type(-1) << __shift));\n       }\n \n       //  Set the unused bits in the uppermost word.\n@@ -444,22 +450,22 @@ namespace tr2\n       {\n \tsize_type __shift = this->_M_Nb % bits_per_block;\n \tif (__shift > 0)\n-\t  this->_M_hiword() |= ((~static_cast<block_type>(0)) << __shift);\n+\t  this->_M_hiword() |= block_type(block_type(-1) << __shift);\n       }\n \n       /**\n        *  These versions of single-bit set, reset, flip, and test\n        *  do no range checking.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n-      _M_unchecked_set(size_type __pos)\n+      dynamic_bitset&\n+      _M_unchecked_set(size_type __pos) noexcept\n       {\n \tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      _M_unchecked_set(size_type __pos, int __val)\n+      dynamic_bitset&\n+      _M_unchecked_set(size_type __pos, int __val) noexcept\n       {\n \tif (__val)\n \t  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n@@ -468,26 +474,26 @@ namespace tr2\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      _M_unchecked_reset(size_type __pos)\n+      dynamic_bitset&\n+      _M_unchecked_reset(size_type __pos) noexcept\n       {\n \tthis->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      _M_unchecked_flip(size_type __pos)\n+      dynamic_bitset&\n+      _M_unchecked_flip(size_type __pos) noexcept\n       {\n \tthis->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n \treturn *this;\n       }\n \n       bool\n-      _M_unchecked_test(size_type __pos) const\n+      _M_unchecked_test(size_type __pos) const noexcept\n       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n \t\t!= static_cast<_WordT>(0)); }\n \n-      size_type _M_Nb;\n+      size_type _M_Nb = 0;\n \n     public:\n       /**\n@@ -511,22 +517,16 @@ namespace tr2\n \tblock_type *_M_wp;\n \tsize_type _M_bpos;\n \n-\t// left undefined\n-\treference();\n-\n       public:\n-\treference(dynamic_bitset& __b, size_type __pos)\n+\treference(dynamic_bitset& __b, size_type __pos) noexcept\n \t{\n \t  this->_M_wp = &__b._M_getword(__pos);\n \t  this->_M_bpos = _Base::_S_whichbit(__pos);\n \t}\n \n-\t~reference()\n-\t{ }\n-\n \t// For b[i] = __x;\n \treference&\n-\toperator=(bool __x)\n+\toperator=(bool __x) noexcept\n \t{\n \t  if (__x)\n \t    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);\n@@ -537,7 +537,7 @@ namespace tr2\n \n \t// For b[i] = b[__j];\n \treference&\n-\toperator=(const reference& __j)\n+\toperator=(const reference& __j) noexcept\n \t{\n \t  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))\n \t    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);\n@@ -548,16 +548,16 @@ namespace tr2\n \n \t// Flips the bit\n \tbool\n-\toperator~() const\n+\toperator~() const noexcept\n \t{ return (*(_M_wp) & _Base::_S_maskbit(this->_M_bpos)) == 0; }\n \n \t// For __x = b[i];\n-\toperator bool() const\n+\toperator bool() const noexcept\n \t{ return (*(this->_M_wp) & _Base::_S_maskbit(this->_M_bpos)) != 0; }\n \n \t// For b[i].flip();\n \treference&\n-\tflip()\n+\tflip() noexcept\n \t{\n \t  *this->_M_wp ^= _Base::_S_maskbit(this->_M_bpos);\n \t  return *this;\n@@ -569,10 +569,14 @@ namespace tr2\n       typedef bool const_reference;\n \n       // 23.3.5.1 constructors:\n+\n+      /// All bits set to zero.\n+      dynamic_bitset() = default;\n+\n       /// All bits set to zero.\n       explicit\n-      dynamic_bitset(const allocator_type& __alloc = allocator_type())\n-      : _Base(__alloc), _M_Nb(0)\n+      dynamic_bitset(const allocator_type& __alloc)\n+      : _Base(__alloc)\n       { }\n \n       /// Initial bits bitwise-copied from a single word (others set to zero).\n@@ -585,7 +589,7 @@ namespace tr2\n \n       dynamic_bitset(initializer_list<block_type> __il,\n \t\t     const allocator_type& __alloc = allocator_type())\n-      : _Base(__alloc), _M_Nb(0)\n+      : _Base(__alloc)\n       { this->append(__il); }\n \n       /**\n@@ -609,8 +613,7 @@ namespace tr2\n \t\t       __n = std::basic_string<_CharT, _Traits, _Alloc1>::npos,\n \t\t       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'),\n \t\t       const allocator_type& __alloc = allocator_type())\n-\t: _Base(__alloc),\n-\t  _M_Nb(0) // Watch for npos.\n+\t: _Base(__alloc)\n \t{\n \t  if (__pos > __str.size())\n \t    __throw_out_of_range(__N(\"dynamic_bitset::bitset initial position \"\n@@ -619,8 +622,7 @@ namespace tr2\n \t  // Watch for npos.\n \t  this->_M_Nb = (__n > __str.size() ? __str.size() - __pos : __n);\n \t  this->resize(this->_M_Nb);\n-\t  this->_M_copy_from_string(__str, __pos, __n,\n-\t\t\t\t    _CharT('0'), _CharT('1'));\n+\t  this->_M_copy_from_string(__str, __pos, __n);\n \t}\n \n       /**\n@@ -633,69 +635,50 @@ namespace tr2\n       explicit\n       dynamic_bitset(const char* __str,\n \t\t     const allocator_type& __alloc = allocator_type())\n-      : _Base(__alloc)\n+      : _Base(__builtin_strlen(__str), 0ULL, __alloc),\n+\t_M_Nb(__builtin_strlen(__str))\n       {\n-\tsize_t __len = 0;\n-\tif (__str)\n-\t  while (__str[__len] != '\\0')\n-\t    ++__len;\n-\tthis->resize(__len);\n-\tthis->_M_copy_from_ptr<char,std::char_traits<char>>\n-\t\t   (__str, __len, 0, __len, '0', '1');\n+\tthis->_M_copy_from_ptr(__str, _M_Nb, 0, _M_Nb);\n       }\n \n-      /**\n-       *  @brief  Copy constructor.\n-       */\n-      dynamic_bitset(const dynamic_bitset& __b)\n-      : _Base(__b), _M_Nb(__b.size())\n-      { }\n+      /// Copy constructor.\n+      dynamic_bitset(const dynamic_bitset&) = default;\n \n-      /**\n-       *  @brief  Move constructor.\n-       */\n-      dynamic_bitset(dynamic_bitset&& __b)\n-      : _Base(std::forward<_Base>(__b)), _M_Nb(__b.size())\n-      { }\n+      /// Move constructor.\n+      dynamic_bitset(dynamic_bitset&& __b) noexcept\n+      : _Base(std::move(__b)), _M_Nb(__b._M_Nb)\n+      { __b.clear(); }\n \n-      /**\n-       *  @brief  Swap with another bitset.\n-       */\n+      /// Swap with another bitset.\n       void\n-      swap(dynamic_bitset& __b)\n+      swap(dynamic_bitset& __b) noexcept\n       {\n \tthis->_M_swap(__b);\n \tstd::swap(this->_M_Nb, __b._M_Nb);\n       }\n \n-      /**\n-       *  @brief  Assignment.\n-       */\n-      dynamic_bitset&\n-      operator=(const dynamic_bitset& __b)\n-      {\n-\tif (&__b != this)\n-\t  {\n-\t    this->_M_assign(__b);\n-\t    this->_M_Nb = __b._M_Nb;\n-\t  }\n-      }\n+      /// Copy assignment operator.\n+      dynamic_bitset& operator=(const dynamic_bitset&) = default;\n \n-      /**\n-       *  @brief  Move assignment.\n-       */\n+      /// Move assignment operator.\n       dynamic_bitset&\n       operator=(dynamic_bitset&& __b)\n+      noexcept(std::is_nothrow_move_assignable<_Base>::value)\n       {\n-\tthis->swap(__b);\n+\tstatic_cast<_Base&>(*this) = static_cast<_Base&&>(__b);\n+\t_M_Nb = __b._M_Nb;\n+\tif _GLIBCXX17_CONSTEXPR (std::is_nothrow_move_assignable<_Base>::value)\n+\t  __b._M_Nb = 0;\n+\telse if (get_allocator() == __b.get_allocator())\n+\t  __b._M_Nb = 0;\n \treturn *this;\n       }\n \n       /**\n        *  @brief  Return the allocator for the bitset.\n        */\n       allocator_type\n-      get_allocator() const\n+      get_allocator() const noexcept\n       { return this->_M_get_allocator(); }\n \n       /**\n@@ -734,6 +717,8 @@ namespace tr2\n \t++this->_M_Nb;\n       }\n \n+      // XXX why is there no pop_back() member in the proposal?\n+\n       /**\n        *  @brief  Append a block.\n        */\n@@ -770,36 +755,36 @@ namespace tr2\n        *\n        *  These should be self-explanatory.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n-      operator&=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      dynamic_bitset&\n+      operator&=(const dynamic_bitset& __rhs)\n       {\n \tthis->_M_do_and(__rhs);\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      operator&=(dynamic_bitset<_WordT, _Alloc>&& __rhs)\n+      dynamic_bitset&\n+      operator&=(dynamic_bitset&& __rhs)\n       {\n \tthis->_M_do_and(std::move(__rhs));\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      operator|=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      dynamic_bitset&\n+      operator|=(const dynamic_bitset& __rhs)\n       {\n \tthis->_M_do_or(__rhs);\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      operator^=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      dynamic_bitset&\n+      operator^=(const dynamic_bitset& __rhs)\n       {\n \tthis->_M_do_xor(__rhs);\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n-      operator-=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      dynamic_bitset&\n+      operator-=(const dynamic_bitset& __rhs)\n       {\n \tthis->_M_do_dif(__rhs);\n \treturn *this;\n@@ -813,7 +798,7 @@ namespace tr2\n        *\n        *  These should be self-explanatory.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       operator<<=(size_type __pos)\n       {\n \tif (__builtin_expect(__pos < this->_M_Nb, 1))\n@@ -826,7 +811,7 @@ namespace tr2\n \treturn *this;\n       }\n \n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       operator>>=(size_type __pos)\n       {\n \tif (__builtin_expect(__pos < this->_M_Nb, 1))\n@@ -844,7 +829,7 @@ namespace tr2\n       /**\n        *  @brief Sets every bit to true.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       set()\n       {\n \tthis->_M_do_set();\n@@ -858,7 +843,7 @@ namespace tr2\n        *  @param  __val  Either true or false, defaults to true.\n        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       set(size_type __pos, bool __val = true)\n       {\n \tif (__pos >= _M_Nb)\n@@ -869,7 +854,7 @@ namespace tr2\n       /**\n        *  @brief Sets every bit to false.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       reset()\n       {\n \tthis->_M_do_reset();\n@@ -883,7 +868,7 @@ namespace tr2\n        *\n        *  Same as writing @c set(__pos, false).\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       reset(size_type __pos)\n       {\n \tif (__pos >= _M_Nb)\n@@ -894,7 +879,7 @@ namespace tr2\n       /**\n        *  @brief Toggles every bit to its opposite value.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       flip()\n       {\n \tthis->_M_do_flip();\n@@ -907,7 +892,7 @@ namespace tr2\n        *  @param  __pos  The index of the bit.\n        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.\n        */\n-      dynamic_bitset<_WordT, _Alloc>&\n+      dynamic_bitset&\n       flip(size_type __pos)\n       {\n \tif (__pos >= _M_Nb)\n@@ -916,7 +901,7 @@ namespace tr2\n       }\n \n       /// See the no-argument flip().\n-      dynamic_bitset<_WordT, _Alloc>\n+      dynamic_bitset\n       operator~() const\n       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }\n \n@@ -978,19 +963,23 @@ namespace tr2\n \t}\n \n       // Helper functions for string operations.\n-      template<typename _CharT, typename _Traits>\n+      template<typename _Traits = std::char_traits<char>,\n+\t       typename _CharT = typename _Traits::char_type>\n \tvoid\n \t_M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,\n-\t\t\t _CharT, _CharT);\n+\t\t\t _CharT __zero = _CharT('0'),\n+\t\t\t _CharT __one = _CharT('1'));\n \n       template<typename _CharT, typename _Traits, typename _Alloc1>\n \tvoid\n-\t_M_copy_from_string(const std::basic_string<_CharT,\n-\t\t\t    _Traits, _Alloc1>& __str, size_t __pos, size_t __n,\n+\t_M_copy_from_string(const basic_string<_CharT, _Traits, _Alloc1>& __str,\n+\t\t\t    size_t __pos, size_t __n,\n \t\t\t    _CharT __zero = _CharT('0'),\n \t\t\t    _CharT __one = _CharT('1'))\n-\t{ _M_copy_from_ptr<_CharT, _Traits>(__str.data(), __str.size(),\n-\t\t\t\t\t    __pos, __n, __zero, __one); }\n+\t{\n+\t  _M_copy_from_ptr<_Traits>(__str.data(), __str.size(), __pos, __n,\n+\t\t\t\t    __zero, __one);\n+\t}\n \n       template<typename _CharT, typename _Traits, typename _Alloc1>\n \tvoid\n@@ -1065,13 +1054,13 @@ namespace tr2\n \n       //@{\n       /// Self-explanatory.\n-      dynamic_bitset<_WordT, _Alloc>\n+      dynamic_bitset\n       operator<<(size_type __pos) const\n-      { return dynamic_bitset<_WordT, _Alloc>(*this) <<= __pos; }\n+      { return dynamic_bitset(*this) <<= __pos; }\n \n-      dynamic_bitset<_WordT, _Alloc>\n+      dynamic_bitset\n       operator>>(size_type __pos) const\n-      { return dynamic_bitset<_WordT, _Alloc>(*this) >>= __pos; }\n+      { return dynamic_bitset(*this) >>= __pos; }\n       //@}\n \n       /**\n@@ -1102,14 +1091,14 @@ namespace tr2\n       { return this->_M_is_proper_subset_of(__b); }\n \n       friend bool\n-      operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n-\t\t const dynamic_bitset<_WordT, _Alloc>& __rhs)\n-      { return __lhs._M_is_equal(__rhs); }\n+      operator==(const dynamic_bitset& __lhs,\n+\t\t const dynamic_bitset& __rhs) noexcept\n+      { return __lhs._M_Nb == __rhs._M_Nb && __lhs._M_is_equal(__rhs); }\n \n       friend bool\n-      operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n-\t\tconst dynamic_bitset<_WordT, _Alloc>& __rhs)\n-      { return __lhs._M_is_less(__rhs); }\n+      operator<(const dynamic_bitset& __lhs,\n+\t\tconst dynamic_bitset& __rhs) noexcept\n+      { return __lhs._M_is_less(__rhs) || __lhs._M_Nb < __rhs._M_Nb; }\n     };\n \n   template<typename _WordT, typename _Alloc>"}, {"sha": "bbd2cb3bb045f633fbcc9a96fa582de961c3df4b", "filename": "libstdc++-v3/include/tr2/dynamic_bitset.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -174,7 +174,7 @@ namespace tr2\n \n   // Definitions of non-inline member functions.\n   template<typename _WordT, typename _Alloc>\n-    template<typename _CharT, typename _Traits>\n+    template<typename _Traits, typename _CharT>\n       void\n       dynamic_bitset<_WordT, _Alloc>::\n       _M_copy_from_ptr(const _CharT* __str, size_t __len,"}, {"sha": "a811307c73aba9ecd671c80847999dd076eed20a", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcmp.cc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  std::tr2::dynamic_bitset<> b = a;\n+  VERIFY( a == b );\n+  b.resize(99);\n+  VERIFY( a != b );\n+}\n+\n+void\n+test02()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  std::tr2::dynamic_bitset<> b = a;\n+  VERIFY( !(a < b) );\n+  VERIFY( !(b < a) );\n+  b.resize(99);\n+  VERIFY( !(a < b) );\n+  VERIFY( b < a );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "9e21a91ff52206f6ddeb7f9e1bc73dd632179bc8", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcons.cc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::tr2::dynamic_bitset<> a;\n+  VERIFY( a.size() == 0 );\n+  VERIFY( a.empty() );\n+  std::tr2::dynamic_bitset<> b(1);\n+  VERIFY( b.size() == 1 );\n+  VERIFY( !b.empty() );\n+  VERIFY( a != b );\n+}\n+\n+void\n+test02()\n+{\n+  std::tr2::dynamic_bitset<> a(1, 0); // { 0 }\n+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test03()\n+{\n+  std::tr2::dynamic_bitset<> a;\n+  a.resize(1);                        // { 0 }\n+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test04()\n+{\n+  std::tr2::dynamic_bitset<> a(3, 2); // { 0, 1, 0 }\n+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test05()\n+{\n+  std::tr2::dynamic_bitset<unsigned short> a(1, 0); // { 0 }\n+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test06()\n+{\n+  std::tr2::dynamic_bitset<unsigned short> a;\n+  a.resize(1);                                      // { 0 }\n+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test07()\n+{\n+  std::tr2::dynamic_bitset<unsigned short> a(3, 2); // { 0, 1, 0 }\n+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }\n+  VERIFY( a != b );\n+}\n+\n+void\n+test08()\n+{\n+  std::tr2::dynamic_bitset<> a(65, -1ULL);\n+  std::tr2::dynamic_bitset<> b(64, -1ULL);\n+  b.push_back(0);\n+  VERIFY( a == b );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+}"}, {"sha": "06bc1158a824b870f3821e7516c7ffc14d3184f3", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fcopy.cc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  const auto n = a.num_blocks();\n+  std::tr2::dynamic_bitset<> b = a;\n+  VERIFY(b.num_blocks() == n);\n+  VERIFY(b.size() == 100);\n+  VERIFY(a.num_blocks() == n);\n+  VERIFY(a.size() == 100);\n+  VERIFY(b == a);\n+}\n+\n+void\n+test02()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  const auto n = a.num_blocks();\n+  std::tr2::dynamic_bitset<> b;\n+  b = a;\n+  VERIFY(b.num_blocks() == n);\n+  VERIFY(b.size() == 100);\n+  VERIFY(a.num_blocks() == n);\n+  VERIFY(a.size() == 100);\n+  VERIFY(b == a);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ed320db300da861f31875e23dd264fd5872166a9", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fmove.cc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  const auto n = a.num_blocks();\n+  std::tr2::dynamic_bitset<> b = std::move(a);\n+  VERIFY(b.num_blocks() == n);\n+  VERIFY(b.size() == 100);\n+  VERIFY(a.num_blocks() == 0);\n+  VERIFY(a.size() == 0);\n+}\n+\n+void\n+test02()\n+{\n+  std::tr2::dynamic_bitset<> a(100);\n+  const auto n = a.num_blocks();\n+  std::tr2::dynamic_bitset<> b;\n+  b = std::move(a);\n+  VERIFY(b.num_blocks() == n);\n+  VERIFY(b.size() == 100);\n+  VERIFY(a.num_blocks() == 0);\n+  VERIFY(a.size() == 0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "0aec1adf65b77361333980845f487b0c7abaad0e", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr92059.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07758d90c7bc6b80b10a83bac52f9ab9e394131d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr92059.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr92059.cc?ref=07758d90c7bc6b80b10a83bac52f9ab9e394131d", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  // PR libstdc++/92059\n+  std::tr2::dynamic_bitset<> b1(10000), b2(10000);\n+  b2 = b1; // crashed on missing return\n+  VERIFY( b2 == b1);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}