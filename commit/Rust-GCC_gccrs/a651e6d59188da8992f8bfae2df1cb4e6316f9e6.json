{"sha": "a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "node_id": "C_kwDOANBUbNoAKGE2NTFlNmQ1OTE4OGRhODk5MmY4YmZhZTJkZjFjYjRlNjMxNmY5ZTY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-03T07:41:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-03T08:04:00Z"}, "message": "openmp: Partial OpenMP 5.2 doacross and omp_cur_iteration support\n\nThe following patch implements part of the OpenMP 5.2 changes related\nto ordered loops and with the assumed resolution of\nhttps://github.com/OpenMP/spec/issues/3302 issues.\n\nThe changes are:\n1) the depend clause on stand-alone ordered constructs has been renamed\n   to doacross (because depend clause has different syntax on other\n   constructs) with some syntax changes below, depend clause is deprecated\n   (we'll deprecate stuff on the GCC side only when we have everything else\n   from 5.2 implemented)\n   depend(source) -> doacross(source:) or doacross(source:omp_cur_iteration)\n   depend(sink:vec) -> doacross(sink:vec) (where vec has the same syntax\n\t\t\t\t\t   as before)\n2) in 5.1 and before it has been significant whether ordered clause has or\n   doesn't have an argument, if it didn't, only block-associated ordered\n   could appear in the body, if it did, only stand-alone ordered could appear\n   in the body, all loops had to be perfectly nested, no associated\n   range-based for loops, no linear clause on work-sharing loop and ordered\n   clause with an argument wasn't allowed on composite for simd.\n   In 5.2, whether ordered clause has or doesn't have an argument is\n   insignificant (except for bugs in the standard, #3302 mentions those),\n   if the argument is missing, it is simply treated as equal to collapse\n   argument (if any, otherwise 1).  The implementation better should be able\n   to differentiate between ordered and doacross loops at compile time\n   which previously was through the absence or presence of the argument,\n   now it is done through looking at the body of the construct lexically\n   and looking for stand-alone ordered constructs.  If there are any,\n   it is to be handled as doacross loop, otherwise it is ordered loop\n   (but in that case ordered argument if present must be equal to collapse\n   argument - 5.2 says instead it must be one, but that is clearly wrong\n   and mentioned in #3302) - stand-alone ordered constructs must appear\n   lexically in the body (and had to before as well).  For the restrictions\n   mentioned above, the for simd restriction is gone (stand-alone ordered\n   can't appear in simd construct, so that is enough), and the other rules\n   are expected to be changed into something related to presence of\n   stand-alone ordered constructs in the body\n3) 5.2 allows a new syntax, doacross(sink:omp_cur_iteration-1), which\n   means wait for previous iteration in the iteration space of all the\n   associated loops\n\nThe following patch implements that, except that we sorry for now\non the doacross(sink:omp_cur_iteration-1) syntax during omp expansion\nbecause library side isn't done yet for it.  It doesn't implement it for\nthe Fortran FE either.\nIncrementally, I'd like to change the way we differentiate between\nstand-alone and block-associated ordered constructs, because the current\nway of looking for presence of doacross clause doesn't work well if those\nclauses are removed because they had been invalid (wrong syntax or\nunknown variables in it etc.) and of course implement\ndoacross(sink:omp_cur_iteration-1).\n\n2022-09-03  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_DOACROSS.\n\t(enum omp_clause_depend_kind): Remove OMP_CLAUSE_DEPEND_SOURCE\n\tand OMP_CLAUSE_DEPEND_SINK, add OMP_CLAUSE_DEPEND_INVALID.\n\t(enum omp_clause_doacross_kind): New type.\n\t(struct tree_omp_clause): Add subcode.doacross_kind member.\n\t* tree.h (OMP_CLAUSE_DEPEND_SINK_NEGATIVE): Remove.\n\t(OMP_CLAUSE_DOACROSS_KIND): Define.\n\t(OMP_CLAUSE_DOACROSS_SINK_NEGATIVE): Define.\n\t(OMP_CLAUSE_DOACROSS_DEPEND): Define.\n\t(OMP_CLAUSE_ORDERED_DOACROSS): Define.\n\t* tree.cc (omp_clause_num_ops, omp_clause_code_name): Add\n\tOMP_CLAUSE_DOACROSS entries.\n\t* tree-nested.cc (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle OMP_CLAUSE_DOACROSS.\n\t* tree-pretty-print.cc (dump_omp_clause): Don't handle\n\tOMP_CLAUSE_DEPEND_SOURCE and OMP_CLAUSE_DEPEND_SINK.  Handle\n\tOMP_CLAUSE_DOACROSS.\n\t* gimplify.cc (gimplify_omp_depend): Don't handle\n\tOMP_CLAUSE_DEPEND_SOURCE and OMP_CLAUSE_DEPEND_SINK.\n\t(gimplify_scan_omp_clauses): Likewise.  Handle OMP_CLAUSE_DOACROSS.\n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_DOACROSS.\n\t(find_standalone_omp_ordered): New function.\n\t(gimplify_omp_for): When OMP_CLAUSE_ORDERED is present, search\n\tbody for OMP_ORDERED with OMP_CLAUSE_DOACROSS and if found,\n\tset OMP_CLAUSE_ORDERED_DOACROSS.\n\t(gimplify_omp_ordered): Don't handle OMP_CLAUSE_DEPEND_SINK or\n\tOMP_CLAUSE_DEPEND_SOURCE, instead check OMP_CLAUSE_DOACROSS, adjust\n\tdiagnostics that presence or absence of ordered clause parameter\n\tis irrelevant.  Handle doacross(sink:omp_cur_iteration-1).  Use\n\tactual user name of the clause - doacross or depend - in diagnostics.\n\t* omp-general.cc (omp_extract_for_data): Don't set fd->ordered\n\tif !OMP_CLAUSE_ORDERED_DOACROSS (t).  If\n\tOMP_CLAUSE_ORDERED_DOACROSS (t) but !OMP_CLAUSE_ORDERED_EXPR (t),\n\tset fd->ordered to -1 and set it after the loop in that case to\n\tfd->collapse.\n\t* omp-low.cc (check_omp_nesting_restrictions): Don't handle\n\tOMP_CLAUSE_DEPEND_SOURCE nor OMP_CLAUSE_DEPEND_SINK, instead check\n\tOMP_CLAUSE_DOACROSS.  Use actual user name of the clause - doacross\n\tor depend - in diagnostics.  Diagnose mixing of stand-alone and\n\tblock associated ordered constructs binding to the same loop.\n\t(lower_omp_ordered_clauses): Don't handle OMP_CLAUSE_DEPEND_SINK,\n\tinstead handle OMP_CLAUSE_DOACROSS.\n\t(lower_omp_ordered): Look for OMP_CLAUSE_DOACROSS instead of\n\tOMP_CLAUSE_DEPEND.\n\t(lower_depend_clauses): Don't handle OMP_CLAUSE_DEPEND_SOURCE and\n\tOMP_CLAUSE_DEPEND_SINK.\n\t* omp-expand.cc (expand_omp_ordered_sink): Emit a sorry for\n\tdoacross(sink:omp_cur_iteration-1).\n\t(expand_omp_ordered_source_sink): Use\n\tOMP_CLAUSE_DOACROSS_SINK_NEGATIVE instead of\n\tOMP_CLAUSE_DEPEND_SINK_NEGATIVE.  Use actual user name of the clause\n\t- doacross or depend - in diagnostics.\n\t(expand_omp): Look for OMP_CLAUSE_DOACROSS clause instead of\n\tOMP_CLAUSE_DEPEND.\n\t(build_omp_regions_1): Likewise.\n\t(omp_make_gimple_edges): Likewise.\n\t* lto-streamer-out.cc (hash_tree): Handle OMP_CLAUSE_DOACROSS.\n\t* tree-streamer-in.cc (unpack_ts_omp_clause_value_fields): Likewise.\n\t* tree-streamer-out.cc (pack_ts_omp_clause_value_fields): Likewise.\ngcc/c-family/\n\t* c-pragma.h (enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_DOACROSS.\n\t* c-omp.cc (c_finish_omp_depobj): Check also for OMP_CLAUSE_DOACROSS\n\tclause and diagnose it.  Don't handle OMP_CLAUSE_DEPEND_SOURCE and\n\tOMP_CLAUSE_DEPEND_SINK.  Assert kind is not OMP_CLAUSE_DEPEND_INVALID.\ngcc/c/\n\t* c-parser.cc (c_parser_omp_clause_name): Handle doacross.\n\t(c_parser_omp_clause_depend_sink): Renamed to ...\n\t(c_parser_omp_clause_doacross_sink): ... this.  Add depend_p argument.\n\tHandle parsing of doacross(sink:omp_cur_iteration-1).  Use\n\tOMP_CLAUSE_DOACROSS_SINK_NEGATIVE instead of\n\tOMP_CLAUSE_DEPEND_SINK_NEGATIVE, build OMP_CLAUSE_DOACROSS instead\n\tof OMP_CLAUSE_DEPEND and set OMP_CLAUSE_DOACROSS_DEPEND flag on it.\n\t(c_parser_omp_clause_depend): Use OMP_CLAUSE_DOACROSS_SINK and\n\tOMP_CLAUSE_DOACROSS_SOURCE instead of OMP_CLAUSE_DEPEND_SINK and\n\tOMP_CLAUSE_DEPEND_SOURCE, build OMP_CLAUSE_DOACROSS for depend(source)\n\tand set OMP_CLAUSE_DOACROSS_DEPEND on it.\n\t(c_parser_omp_clause_doacross): New function.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_DOACROSS.\n\t(c_parser_omp_depobj): Use OMP_CLAUSE_DEPEND_INVALID instead of\n\tOMP_CLAUSE_DEPEND_SOURCE.\n\t(c_parser_omp_for_loop): Don't diagnose here linear clause together\n\twith ordered with argument.\n\t(c_parser_omp_simd): Don't diagnose ordered clause with argument on\n\tfor simd.\n\t(OMP_ORDERED_DEPEND_CLAUSE_MASK): Add PRAGMA_OMP_CLAUSE_DOACROSS.\n\t(c_parser_omp_ordered): Handle also doacross and adjust for it\n\tdiagnostic wording.\n\t* c-typeck.cc (c_finish_omp_clauses): Handle OMP_CLAUSE_DOACROSS.\n\tDon't handle OMP_CLAUSE_DEPEND_SOURCE and OMP_CLAUSE_DEPEND_SINK.\ngcc/cp/\n\t* parser.cc (cp_parser_omp_clause_name): Handle doacross.\n\t(cp_parser_omp_clause_depend_sink): Renamed to ...\n\t(cp_parser_omp_clause_doacross_sink): ... this.  Add depend_p\n\targument.  Handle parsing of doacross(sink:omp_cur_iteration-1).  Use\n\tOMP_CLAUSE_DOACROSS_SINK_NEGATIVE instead of\n\tOMP_CLAUSE_DEPEND_SINK_NEGATIVE, build OMP_CLAUSE_DOACROSS instead\n\tof OMP_CLAUSE_DEPEND and set OMP_CLAUSE_DOACROSS_DEPEND flag on it.\n\t(cp_parser_omp_clause_depend): Use OMP_CLAUSE_DOACROSS_SINK and\n\tOMP_CLAUSE_DOACROSS_SOURCE instead of OMP_CLAUSE_DEPEND_SINK and\n\tOMP_CLAUSE_DEPEND_SOURCE, build OMP_CLAUSE_DOACROSS for depend(source)\n\tand set OMP_CLAUSE_DOACROSS_DEPEND on it.\n\t(cp_parser_omp_clause_doacross): New function.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_DOACROSS.\n\t(cp_parser_omp_depobj): Use OMP_CLAUSE_DEPEND_INVALID instead of\n\tOMP_CLAUSE_DEPEND_SOURCE.\n\t(cp_parser_omp_for_loop): Don't diagnose here linear clause together\n\twith ordered with argument.\n\t(cp_parser_omp_simd): Don't diagnose ordered clause with argument on\n\tfor simd.\n\t(OMP_ORDERED_DEPEND_CLAUSE_MASK): Add PRAGMA_OMP_CLAUSE_DOACROSS.\n\t(cp_parser_omp_ordered): Handle also doacross and adjust for it\n\tdiagnostic wording.\n\t* pt.cc (tsubst_omp_clause_decl): Use\n\tOMP_CLAUSE_DOACROSS_SINK_NEGATIVE instead of\n\tOMP_CLAUSE_DEPEND_SINK_NEGATIVE.\n\t(tsubst_omp_clauses): Handle OMP_CLAUSE_DOACROSS.\n\t(tsubst_expr): Use OMP_CLAUSE_DEPEND_INVALID instead of\n\tOMP_CLAUSE_DEPEND_SOURCE.\n\t* semantics.cc (cp_finish_omp_clause_depend_sink): Rename to ...\n\t(cp_finish_omp_clause_doacross_sink): ... this.\n\t(finish_omp_clauses): Handle OMP_CLAUSE_DOACROSS.  Don't handle\n\tOMP_CLAUSE_DEPEND_SOURCE and OMP_CLAUSE_DEPEND_SINK.\ngcc/fortran/\n\t* trans-openmp.cc (gfc_trans_omp_clauses): Use\n\tOMP_CLAUSE_DOACROSS_SINK_NEGATIVE instead of\n\tOMP_CLAUSE_DEPEND_SINK_NEGATIVE, build OMP_CLAUSE_DOACROSS\n\tclause instead of OMP_CLAUSE_DEPEND and set OMP_CLAUSE_DOACROSS_DEPEND\n\ton it.\ngcc/testsuite/\n\t* c-c++-common/gomp/doacross-2.c: Adjust expected diagnostics.\n\t* c-c++-common/gomp/doacross-5.c: New test.\n\t* c-c++-common/gomp/doacross-6.c: New test.\n\t* c-c++-common/gomp/nesting-2.c: Adjust expected diagnostics.\n\t* c-c++-common/gomp/ordered-3.c: Likewise.\n\t* c-c++-common/gomp/sink-3.c: Likewise.\n\t* gfortran.dg/gomp/nesting-2.f90: Likewise.", "tree": {"sha": "ea5383dc6af17ad39a90f8bd40dae7f62d1547ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea5383dc6af17ad39a90f8bd40dae7f62d1547ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64b09471a8a06e929c70bf6017d7163776145e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64b09471a8a06e929c70bf6017d7163776145e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64b09471a8a06e929c70bf6017d7163776145e0"}], "stats": {"total": 1060, "additions": 770, "deletions": 290}, "files": [{"sha": "56bc4b1bfef7dab22abd384e4d6e45edfd67c200", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -714,8 +714,17 @@ c_finish_omp_depobj (location_t loc, tree depobj,\n \n   if (clause)\n     {\n-      gcc_assert (TREE_CODE (clause) == OMP_CLAUSE\n-\t\t  && OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_DEPEND);\n+      gcc_assert (TREE_CODE (clause) == OMP_CLAUSE);\n+      if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_DOACROSS)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (clause),\n+\t\t    \"%<depend(%s)%> is only allowed in %<omp ordered%>\",\n+\t\t    OMP_CLAUSE_DOACROSS_KIND (clause)\n+\t\t    == OMP_CLAUSE_DOACROSS_SOURCE\n+\t\t    ? \"source\" : \"sink\");\n+\t  return;\n+\t}\n+      gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_DEPEND);\n       if (OMP_CLAUSE_CHAIN (clause))\n \terror_at (OMP_CLAUSE_LOCATION (clause),\n \t\t  \"more than one locator in %<depend%> clause on %<depobj%> \"\n@@ -727,13 +736,6 @@ c_finish_omp_depobj (location_t loc, tree depobj,\n \t\t    \"%<depobj%> dependence type specified in %<depend%> \"\n \t\t    \"clause on %<depobj%> construct\");\n \t  return;\n-\tcase OMP_CLAUSE_DEPEND_SOURCE:\n-\tcase OMP_CLAUSE_DEPEND_SINK:\n-\t  error_at (OMP_CLAUSE_LOCATION (clause),\n-\t\t    \"%<depend(%s)%> is only allowed in %<omp ordered%>\",\n-\t\t    OMP_CLAUSE_DEPEND_KIND (clause) == OMP_CLAUSE_DEPEND_SOURCE\n-\t\t    ? \"source\" : \"sink\");\n-\t  return;\n \tcase OMP_CLAUSE_DEPEND_IN:\n \tcase OMP_CLAUSE_DEPEND_OUT:\n \tcase OMP_CLAUSE_DEPEND_INOUT:\n@@ -765,7 +767,7 @@ c_finish_omp_depobj (location_t loc, tree depobj,\n \t}\n     }\n   else\n-    gcc_assert (kind != OMP_CLAUSE_DEPEND_SOURCE);\n+    gcc_assert (kind != OMP_CLAUSE_DEPEND_INVALID);\n \n   if (depobj == error_mark_node)\n     return;"}, {"sha": "c894a2594d622ac2c0bcb3d0cb9402dee88ef4d0", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -108,6 +108,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_DEVICE,\n   PRAGMA_OMP_CLAUSE_DEVICE_TYPE,\n   PRAGMA_OMP_CLAUSE_DIST_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_DOACROSS,\n   PRAGMA_OMP_CLAUSE_ENTER,\n   PRAGMA_OMP_CLAUSE_FILTER,\n   PRAGMA_OMP_CLAUSE_FINAL,"}, {"sha": "65d73a615d4037e7df64d7853bb6f3d30ebca882", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 120, "deletions": 44, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -12823,6 +12823,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE_TYPE;\n \t  else if (!strcmp (\"dist_schedule\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n+\t  else if (!strcmp (\"doacross\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_DOACROSS;\n \t  break;\n \tcase 'e':\n \t  if (!strcmp (\"enter\", p))\n@@ -15971,8 +15973,8 @@ c_parser_omp_clause_simdlen (c_parser *parser, tree list)\n */\n \n static tree\n-c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n-\t\t\t\t tree list)\n+c_parser_omp_clause_doacross_sink (c_parser *parser, location_t clause_loc,\n+\t\t\t\t   tree list, bool depend_p)\n {\n   tree vec = NULL;\n   if (c_parser_next_token_is_not (parser, CPP_NAME)\n@@ -15982,6 +15984,31 @@ c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n       return list;\n     }\n \n+  if (!depend_p)\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"omp_cur_iteration\") == 0\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_MINUS\n+\t  && c_parser_peek_nth_token (parser, 3)->type == CPP_NUMBER\n+\t  && c_parser_peek_nth_token (parser, 4)->type == CPP_CLOSE_PAREN)\n+\t{\n+\t  tree val = c_parser_peek_nth_token (parser, 3)->value;\n+\t  if (integer_onep (val)\n+\t      && comptypes (TREE_TYPE (val), integer_type_node))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t      tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+\t      OMP_CLAUSE_DOACROSS_KIND (u) = OMP_CLAUSE_DOACROSS_SINK;\n+\t      OMP_CLAUSE_CHAIN (u) = list;\n+\t      return u;\n+\t    }\n+\t}\n+    }\n+\n+\n+\n   while (c_parser_next_token_is (parser, CPP_NAME)\n \t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n     {\n@@ -16027,7 +16054,7 @@ c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n \t{\n \t  vec = tree_cons (addend, t, vec);\n \t  if (neg)\n-\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t    OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (vec) = 1;\n \t}\n \n       if (c_parser_next_token_is_not (parser, CPP_COMMA)\n@@ -16041,8 +16068,9 @@ c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n   if (vec == NULL_TREE)\n     return list;\n \n-  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n-  OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;\n+  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+  OMP_CLAUSE_DOACROSS_KIND (u) = OMP_CLAUSE_DOACROSS_SINK;\n+  OMP_CLAUSE_DOACROSS_DEPEND (u) = depend_p;\n   OMP_CLAUSE_DECL (u) = nreverse (vec);\n   OMP_CLAUSE_CHAIN (u) = list;\n   return u;\n@@ -16234,6 +16262,7 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_LAST;\n+  enum omp_clause_doacross_kind dkind = OMP_CLAUSE_DOACROSS_LAST;\n   tree nl, c, iterators = NULL_TREE;\n \n   matching_parens parens;\n@@ -16265,9 +16294,9 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n       else if (strcmp (\"depobj\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_DEPOBJ;\n       else if (strcmp (\"sink\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SINK;\n+\tdkind = OMP_CLAUSE_DOACROSS_SINK;\n       else if (strcmp (\"source\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+\tdkind = OMP_CLAUSE_DOACROSS_SOURCE;\n       else\n \tgoto invalid_kind;\n       break;\n@@ -16277,18 +16306,20 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n   c_parser_consume_token (parser);\n \n   if (iterators\n-      && (kind == OMP_CLAUSE_DEPEND_SOURCE || kind == OMP_CLAUSE_DEPEND_SINK))\n+      && (dkind == OMP_CLAUSE_DOACROSS_SOURCE\n+\t  || dkind == OMP_CLAUSE_DOACROSS_SINK))\n     {\n       pop_scope ();\n       error_at (clause_loc, \"%<iterator%> modifier incompatible with %qs\",\n-\t\tkind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+\t\tdkind == OMP_CLAUSE_DOACROSS_SOURCE ? \"source\" : \"sink\");\n       iterators = NULL_TREE;\n     }\n \n-  if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+  if (dkind == OMP_CLAUSE_DOACROSS_SOURCE)\n     {\n-      c = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n-      OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+      c = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (c) = dkind;\n+      OMP_CLAUSE_DOACROSS_DEPEND (c) = 1;\n       OMP_CLAUSE_DECL (c) = NULL_TREE;\n       OMP_CLAUSE_CHAIN (c) = list;\n       parens.skip_until_found_close (parser);\n@@ -16298,8 +16329,8 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n     goto resync_fail;\n \n-  if (kind == OMP_CLAUSE_DEPEND_SINK)\n-    nl = c_parser_omp_clause_depend_sink (parser, clause_loc, list);\n+  if (dkind == OMP_CLAUSE_DOACROSS_SINK)\n+    nl = c_parser_omp_clause_doacross_sink (parser, clause_loc, list, true);\n   else\n     {\n       nl = c_parser_omp_variable_list (parser, clause_loc,\n@@ -16335,6 +16366,65 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenMP 5.2:\n+   doacross ( source : )\n+   doacross ( source : omp_cur_iteration )\n+\n+   doacross ( sink : vec )\n+   doacross ( sink : omp_cur_iteration - logical_iteration )  */\n+\n+static tree\n+c_parser_omp_clause_doacross (c_parser *parser, tree list)\n+{\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n+  enum omp_clause_doacross_kind kind = OMP_CLAUSE_DOACROSS_LAST;\n+  tree nl;\n+  const char *p;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (c_parser_next_token_is_not (parser, CPP_NAME))\n+    goto invalid_kind;\n+\n+  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (\"sink\", p) == 0)\n+    kind = OMP_CLAUSE_DOACROSS_SINK;\n+  else if (strcmp (\"source\", p) == 0)\n+    kind = OMP_CLAUSE_DOACROSS_SOURCE;\n+  else\n+    goto invalid_kind;\n+\n+  c_parser_consume_token (parser);\n+\n+  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+    goto resync_fail;\n+\n+  if (kind == OMP_CLAUSE_DOACROSS_SOURCE)\n+    {\n+      if (c_parser_next_token_is (parser, CPP_NAME)\n+\t  && strcmp (IDENTIFIER_POINTER (c_parser_peek_token (parser)->value),\n+\t\t     \"omp_cur_iteration\") == 0)\n+\tc_parser_consume_token (parser);\n+      nl = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (nl) = OMP_CLAUSE_DOACROSS_SOURCE;\n+      OMP_CLAUSE_DECL (nl) = NULL_TREE;\n+      OMP_CLAUSE_CHAIN (nl) = list;\n+    }\n+  else\n+    nl = c_parser_omp_clause_doacross_sink (parser, clause_loc, list, false);\n+\n+  parens.skip_until_found_close (parser);\n+  return nl;\n+\n+ invalid_kind:\n+  c_parser_error (parser, \"invalid doacross kind\");\n+ resync_fail:\n+  parens.skip_until_found_close (parser);\n+  return list;\n+}\n+\n /* OpenMP 4.0:\n    map ( map-kind: variable-list )\n    map ( variable-list )\n@@ -17252,6 +17342,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_depend (parser, clauses);\n \t  c_name = \"depend\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DOACROSS:\n+\t  clauses = c_parser_omp_clause_doacross (parser, clauses);\n+\t  c_name = \"doacross\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_MAP:\n \t  clauses = c_parser_omp_clause_map (parser, clauses);\n \t  c_name = \"map\";\n@@ -19196,7 +19290,7 @@ c_parser_omp_depobj (c_parser *parser)\n \n   parens.skip_until_found_close (parser);\n   tree clause = NULL_TREE;\n-  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n   location_t c_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -19235,7 +19329,7 @@ c_parser_omp_depobj (c_parser *parser)\n \t\t  else if (!strcmp (\"inoutset\", p2))\n \t\t    kind = OMP_CLAUSE_DEPEND_INOUTSET;\n \t\t}\n-\t      if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+\t      if (kind == OMP_CLAUSE_DEPEND_INVALID)\n \t\t{\n \t\t  clause = error_mark_node;\n \t\t  error_at (c2_loc, \"expected %<in%>, %<out%>, %<inout%>, \"\n@@ -19247,7 +19341,7 @@ c_parser_omp_depobj (c_parser *parser)\n \t    clause = error_mark_node;\n \t}\n     }\n-  if (!clause && kind == OMP_CLAUSE_DEPEND_SOURCE)\n+  if (!clause && kind == OMP_CLAUSE_DEPEND_INVALID)\n     {\n       clause = error_mark_node;\n       error_at (c_loc, \"expected %<depend%>, %<destroy%> or %<update%> clause\");\n@@ -19446,19 +19540,6 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t= build_int_cst (NULL_TREE, collapse);\n       ordered = collapse;\n     }\n-  if (ordered)\n-    {\n-      for (tree *pc = &clauses; *pc; )\n-\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)\n-\t  {\n-\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n-\t\t      \"%<linear%> clause may not be specified together \"\n-\t\t      \"with %<ordered%> clause with a parameter\");\n-\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n-\t  }\n-\telse\n-\t  pc = &OMP_CLAUSE_CHAIN (*pc);\n-    }\n \n   gcc_assert (tiling || (collapse >= 1 && ordered >= 0));\n   count = ordered ? ordered : collapse;\n@@ -19896,15 +19977,6 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n     {\n       omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n-      tree c = omp_find_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],\n-\t\t\t\tOMP_CLAUSE_ORDERED);\n-      if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n-\t{\n-\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"%<ordered%> clause with parameter may not be specified \"\n-\t\t    \"on %qs construct\", p_name);\n-\t  OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n-\t}\n     }\n \n   block = c_begin_compound_stmt (true);\n@@ -20143,14 +20215,18 @@ c_parser_omp_masked (location_t loc, c_parser *parser,\n    # pragma omp ordered ordered-clauses new-line\n      structured-block\n \n-   # pragma omp ordered depend-clauses new-line  */\n+   # pragma omp ordered depend-clauses new-line\n+\n+   OpenMP 5.2\n+   # pragma omp ordered doacross-clauses new-line  */\n \n #define OMP_ORDERED_CLAUSE_MASK\t\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREADS)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMD))\n \n #define OMP_ORDERED_DEPEND_CLAUSE_MASK\t\t\t\t\\\n-\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DOACROSS))\n \n static bool\n c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n@@ -20170,7 +20246,7 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n \n-      if (!strcmp (\"depend\", p))\n+      if (!strcmp (\"depend\", p) || !strcmp (\"doacross\", p))\n \t{\n \t  if (!flag_openmp)\t/* flag_openmp_simd  */\n \t    {\n@@ -20180,8 +20256,8 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n \t  if (context == pragma_stmt)\n \t    {\n \t      error_at (loc,\n-\t\t\t\"%<#pragma omp ordered%> with %<depend%> clause may \"\n-\t\t\t\"only be used in compound statements\");\n+\t\t\t\"%<#pragma omp ordered%> with %qs clause may \"\n+\t\t\t\"only be used in compound statements\", p);\n \t      c_parser_skip_to_pragma_eol (parser, false);\n \t      return true;\n \t    }"}, {"sha": "9ada5d255316bfab763bfaf0793ea339378dc70d", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -14843,15 +14843,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  break;\n \n-\tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n-\t    {\n-\t      gcc_assert (OMP_CLAUSE_DEPEND_KIND (c)\n-\t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n-\t      break;\n-\t    }\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t    break;\n+\t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n \t    {\n \t      gcc_assert (TREE_CODE (t) == TREE_LIST);\n \t      for (; t; t = TREE_CHAIN (t))\n@@ -14879,7 +14875,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t      break;\n \t    }\n-\t  /* FALLTHRU */\n+\t  gcc_unreachable ();\n+\tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE_AFFINITY:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST"}, {"sha": "076ad62438040b99fc89bcf80cfdd906e78d41f3", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 131, "deletions": 47, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -11994,14 +11994,18 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n \t    if (dir->id == PRAGMA_OMP_ORDERED)\n \t      {\n \t\t/* ordered is C_OMP_DIR_CONSTRUCT only if it doesn't contain\n-\t\t   depend clause.  */\n-\t\tif (directive[1] && strcmp (directive[1], \"depend\") == 0)\n+\t\t   depend/doacross clause.  */\n+\t\tif (directive[1]\n+\t\t    && (strcmp (directive[1], \"depend\") == 0\n+\t\t\t|| strcmp (directive[1], \"doacross\") == 0))\n \t\t  kind = C_OMP_DIR_STANDALONE;\n \t\telse if (first + 2 < last\n \t\t\t && first[1].type == CPP_COMMA\n \t\t\t && first[2].type == CPP_NAME\n-\t\t\t && strcmp (IDENTIFIER_POINTER (first[2].u.value),\n-\t\t\t\t    \"depend\") == 0)\n+\t\t\t && (strcmp (IDENTIFIER_POINTER (first[2].u.value),\n+\t\t\t\t     \"depend\") == 0\n+\t\t\t     || strcmp (IDENTIFIER_POINTER (first[2].u.value),\n+\t\t\t\t\t\"doacross\") == 0))\n \t\t  kind = C_OMP_DIR_STANDALONE;\n \t      }\n \t    else if (dir->id == PRAGMA_OMP_ERROR)\n@@ -36602,6 +36606,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE_TYPE;\n \t  else if (!strcmp (\"dist_schedule\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n+\t  else if (!strcmp (\"doacross\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_DOACROSS;\n \t  break;\n \tcase 'e':\n \t  if (!strcmp (\"enter\", p))\n@@ -39329,8 +39335,8 @@ cp_parser_omp_clause_simdlen (cp_parser *parser, tree list,\n */\n \n static tree\n-cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n-\t\t\t\t  tree list)\n+cp_parser_omp_clause_doacross_sink (cp_parser *parser, location_t clause_loc,\n+\t\t\t\t    tree list, bool depend_p)\n {\n   tree vec = NULL;\n \n@@ -39340,6 +39346,29 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n       return list;\n     }\n \n+  if (!depend_p)\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      if (strcmp (IDENTIFIER_POINTER (id), \"omp_cur_iteration\") == 0\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_MINUS)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 3, CPP_NUMBER)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 4, CPP_CLOSE_PAREN))\n+\t{\n+\t  tree val = cp_lexer_peek_nth_token (parser->lexer, 3)->u.value;\n+\t  if (integer_onep (val)\n+\t      && same_type_p (TREE_TYPE (val), integer_type_node))\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+\t      OMP_CLAUSE_DOACROSS_KIND (u) = OMP_CLAUSE_DOACROSS_SINK;\n+\t      OMP_CLAUSE_CHAIN (u) = list;\n+\t      return u;\n+\t    }\n+\t}\n+    }\n+\n   while (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       location_t id_loc = cp_lexer_peek_token (parser->lexer)->location;\n@@ -39387,7 +39416,7 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n \t{\n \t  vec = tree_cons (addend, t, vec);\n \t  if (neg)\n-\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t    OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (vec) = 1;\n \t}\n \n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n@@ -39399,8 +39428,9 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n \n   if (vec)\n     {\n-      tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n-      OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;\n+      tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (u) = OMP_CLAUSE_DOACROSS_SINK;\n+      OMP_CLAUSE_DOACROSS_DEPEND (u) = depend_p;\n       OMP_CLAUSE_DECL (u) = nreverse (vec);\n       OMP_CLAUSE_CHAIN (u) = list;\n       return u;\n@@ -39649,6 +39679,7 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n {\n   tree nlist, c, iterators = NULL_TREE;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_LAST;\n+  enum omp_clause_doacross_kind dkind = OMP_CLAUSE_DOACROSS_LAST;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -39682,9 +39713,9 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n       else if (strcmp (\"depobj\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_DEPOBJ;\n       else if (strcmp (\"sink\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SINK;\n+\tdkind = OMP_CLAUSE_DOACROSS_SINK;\n       else if (strcmp (\"source\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+\tdkind = OMP_CLAUSE_DOACROSS_SOURCE;\n       else\n \tgoto invalid_kind;\n       break;\n@@ -39694,18 +39725,20 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n   cp_lexer_consume_token (parser->lexer);\n \n   if (iterators\n-      && (kind == OMP_CLAUSE_DEPEND_SOURCE || kind == OMP_CLAUSE_DEPEND_SINK))\n+      && (dkind == OMP_CLAUSE_DOACROSS_SOURCE\n+\t  || dkind == OMP_CLAUSE_DOACROSS_SINK))\n     {\n       poplevel (0, 1, 0);\n       error_at (loc, \"%<iterator%> modifier incompatible with %qs\",\n-\t\tkind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+\t\tdkind == OMP_CLAUSE_DOACROSS_SOURCE ? \"source\" : \"sink\");\n       iterators = NULL_TREE;\n     }\n \n-  if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+  if (dkind == OMP_CLAUSE_DOACROSS_SOURCE)\n     {\n-      c = build_omp_clause (loc, OMP_CLAUSE_DEPEND);\n-      OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+      c = build_omp_clause (loc, OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (c) = dkind;\n+      OMP_CLAUSE_DOACROSS_DEPEND (c) = 1;\n       OMP_CLAUSE_DECL (c) = NULL_TREE;\n       OMP_CLAUSE_CHAIN (c) = list;\n       if (!parens.require_close (parser))\n@@ -39718,9 +39751,9 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n     goto resync_fail;\n \n-  if (kind == OMP_CLAUSE_DEPEND_SINK)\n+  if (dkind == OMP_CLAUSE_DOACROSS_SINK)\n     {\n-      nlist = cp_parser_omp_clause_depend_sink (parser, loc, list);\n+      nlist = cp_parser_omp_clause_doacross_sink (parser, loc, list, true);\n       if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n@@ -39761,6 +39794,73 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n   return list;\n }\n \n+/* OpenMP 5.2:\n+   doacross ( source : )\n+   doacross ( source : omp_cur_iteration )\n+\n+   doacross ( sink : vec )\n+   doacross ( sink : omp_cur_iteration - logical_iteration )  */\n+\n+static tree\n+cp_parser_omp_clause_doacross (cp_parser *parser, tree list, location_t loc)\n+{\n+  tree nlist;\n+  enum omp_clause_doacross_kind kind = OMP_CLAUSE_DOACROSS_LAST;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+    invalid_kind:\n+      cp_parser_error (parser, \"invalid doacross kind\");\n+    resync_fail:\n+      cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t     /*consume_paren=*/true);\n+      return list;\n+    }\n+\n+  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+  const char *p = IDENTIFIER_POINTER (id);\n+\n+  if (strcmp (\"sink\", p) == 0)\n+    kind = OMP_CLAUSE_DOACROSS_SINK;\n+  else if (strcmp (\"source\", p) == 0)\n+    kind = OMP_CLAUSE_DOACROSS_SOURCE;\n+  else\n+    goto invalid_kind;\n+\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+    goto resync_fail;\n+\n+  if (kind == OMP_CLAUSE_DOACROSS_SOURCE)\n+    {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\t  id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  p = IDENTIFIER_POINTER (id);\n+\t  if (strcmp (p, \"omp_cur_iteration\") == 0)\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t}\n+      nlist = build_omp_clause (loc, OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (nlist) = OMP_CLAUSE_DOACROSS_SOURCE;\n+      OMP_CLAUSE_DECL (nlist) = NULL_TREE;\n+      OMP_CLAUSE_CHAIN (nlist) = list;\n+    }\n+  else\n+    nlist = cp_parser_omp_clause_doacross_sink (parser, loc, list, false);\n+\n+  if (!parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+  return nlist;\n+}\n+\n /* OpenMP 4.0:\n    map ( map-kind : variable-list )\n    map ( variable-list )\n@@ -40703,6 +40803,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t token->location);\n \t  c_name = \"depend\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DOACROSS:\n+\t  clauses = cp_parser_omp_clause_doacross (parser, clauses,\n+\t\t\t\t\t\t   token->location);\n+\t  c_name = \"doacross\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_DETACH:\n \t  clauses = cp_parser_omp_clause_detach (parser, clauses);\n \t  c_name = \"detach\";\n@@ -41941,7 +42046,7 @@ cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n \t\t\t\t\t   /*consume_paren=*/true);\n \n   tree clause = NULL_TREE;\n-  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n   location_t c_loc = cp_lexer_peek_token (parser->lexer)->location;\n   /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n   if (parser->lexer->in_omp_attribute_pragma\n@@ -41989,7 +42094,7 @@ cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n \t\t  else if (!strcmp (\"inoutset\", p2))\n \t\t    kind = OMP_CLAUSE_DEPEND_INOUTSET;\n \t\t}\n-\t      if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+\t      if (kind == OMP_CLAUSE_DEPEND_INVALID)\n \t\t{\n \t\t  clause = error_mark_node;\n \t\t  error_at (c2_loc, \"expected %<in%>, %<out%>, %<inout%>, \"\n@@ -42005,7 +42110,7 @@ cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n \t    clause = error_mark_node;\n \t}\n     }\n-  if (!clause && kind == OMP_CLAUSE_DEPEND_SOURCE)\n+  if (!clause && kind == OMP_CLAUSE_DEPEND_INVALID)\n     {\n       clause = error_mark_node;\n       error_at (c_loc, \"expected %<depend%>, %<destroy%> or %<update%> clause\");\n@@ -42837,19 +42942,6 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t= build_int_cst (NULL_TREE, collapse);\n       ordered = collapse;\n     }\n-  if (ordered)\n-    {\n-      for (tree *pc = &clauses; *pc; )\n-\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)\n-\t  {\n-\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n-\t\t      \"%<linear%> clause may not be specified together \"\n-\t\t      \"with %<ordered%> clause with a parameter\");\n-\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n-\t  }\n-\telse\n-\t  pc = &OMP_CLAUSE_CHAIN (*pc);\n-    }\n \n   gcc_assert (tiling || (collapse >= 1 && ordered >= 0));\n   count = ordered ? ordered : collapse;\n@@ -43301,15 +43393,6 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n     {\n       cp_omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n-      tree c = omp_find_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],\n-\t\t\t\tOMP_CLAUSE_ORDERED);\n-      if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n-\t{\n-\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"%<ordered%> clause with parameter may not be specified \"\n-\t\t    \"on %qs construct\", p_name);\n-\t  OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;\n-\t}\n     }\n \n   keep_next_level (true);\n@@ -43571,7 +43654,8 @@ cp_parser_omp_masked (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMD))\n \n #define OMP_ORDERED_DEPEND_CLAUSE_MASK\t\t\t\t\\\n-\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DOACROSS))\n \n static bool\n cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n@@ -43590,7 +43674,7 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n       tree id = cp_lexer_peek_nth_token (parser->lexer, n)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n-      if (strcmp (p, \"depend\") == 0)\n+      if (strcmp (p, \"depend\") == 0 || strcmp (p, \"doacross\") == 0)\n \t{\n \t  if (!flag_openmp)\t/* flag_openmp_simd */\n \t    {\n@@ -43600,8 +43684,8 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n \t  if (context == pragma_stmt)\n \t    {\n \t      error_at (pragma_tok->location, \"%<#pragma omp ordered%> with \"\n-\t\t\t\"%<depend%> clause may only be used in compound \"\n-\t\t\t\"statements\");\n+\t\t\t\"%qs clause may only be used in compound \"\n+\t\t\t\"statements\", p);\n \t      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t      return true;\n \t    }"}, {"sha": "cd0d8920ed02b5a668e2487db43f287a5043661b", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -17830,8 +17830,8 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n     }\n \n   /* Handle an OpenMP array section represented as a TREE_LIST (or\n-     OMP_CLAUSE_DEPEND_KIND).  An OMP_CLAUSE_DEPEND (with a depend\n-     kind of OMP_CLAUSE_DEPEND_SINK) can also be represented as a\n+     OMP_CLAUSE_DOACROSS_KIND).  An OMP_CLAUSE_DOACROSS (with a depend\n+     kind of OMP_CLAUSE_DOACROSS_SINK) can also be represented as a\n      TREE_LIST.  We can handle it exactly the same as an array section\n      (purpose, value, and a chain), even though the nomenclature\n      (low_bound, length, etc) is different.  */\n@@ -17849,8 +17849,8 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t  && TREE_CHAIN (decl) == chain)\n \treturn decl;\n       tree ret = tree_cons (low_bound, length, chain);\n-      OMP_CLAUSE_DEPEND_SINK_NEGATIVE (ret)\n-\t= OMP_CLAUSE_DEPEND_SINK_NEGATIVE (decl);\n+      OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (ret)\n+\t= OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (decl);\n       return ret;\n     }\n   tree ret = tsubst_expr (decl, args, complain, in_decl,\n@@ -17898,6 +17898,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_UNIFORM:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \tcase OMP_CLAUSE_AFFINITY:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n@@ -19414,7 +19415,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       r = RECUR (OMP_DEPOBJ_DEPOBJ (t));\n       if (OMP_DEPOBJ_CLAUSES (t) && OMP_DEPOBJ_CLAUSES (t) != error_mark_node)\n \t{\n-\t  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+\t  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INVALID;\n \t  if (TREE_CODE (OMP_DEPOBJ_CLAUSES (t)) == OMP_CLAUSE)\n \t    {\n \t      tmp = tsubst_omp_clauses (OMP_DEPOBJ_CLAUSES (t), C_ORT_OMP,\n@@ -19432,7 +19433,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t}\n       else\n \tfinish_omp_depobj (EXPR_LOCATION (t), r,\n-\t\t\t   OMP_CLAUSE_DEPEND_SOURCE,\n+\t\t\t   OMP_CLAUSE_DEPEND_INVALID,\n \t\t\t   OMP_DEPOBJ_CLAUSES (t));\n       break;\n "}, {"sha": "7b2c495c4bcbdb83826e6f1ea4c973e5213641bf", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -6477,13 +6477,13 @@ finish_omp_declare_simd_methods (tree t)\n     }\n }\n \n-/* Adjust sink depend clause to take into account pointer offsets.\n+/* Adjust sink depend/doacross clause to take into account pointer offsets.\n \n    Return TRUE if there was a problem processing the offset, and the\n    whole clause should be removed.  */\n \n static bool\n-cp_finish_omp_clause_depend_sink (tree sink_clause)\n+cp_finish_omp_clause_doacross_sink (tree sink_clause)\n {\n   tree t = OMP_CLAUSE_DECL (sink_clause);\n   gcc_assert (TREE_CODE (t) == TREE_LIST);\n@@ -7795,21 +7795,18 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  goto handle_field_decl;\n \n-\tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n+\t    break;\n+\t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n \t    {\n-\t      gcc_assert (OMP_CLAUSE_DEPEND_KIND (c)\n-\t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n-\t      break;\n-\t    }\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n-\t    {\n-\t      if (cp_finish_omp_clause_depend_sink (c))\n+\t      if (cp_finish_omp_clause_doacross_sink (c))\n \t\tremove = true;\n \t      break;\n \t    }\n-\t  /* FALLTHRU */\n+\t  gcc_unreachable ();\n+\tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE_AFFINITY:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST"}, {"sha": "82c1079bc2893afeab4ba325dbb297d884f100f0", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -2897,7 +2897,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t    }\n \t\t\t  vec = tree_cons (addend, t, vec);\n \t\t\t  if (neg)\n-\t\t\t    OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;\n+\t\t\t    OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (vec) = 1;\n \t\t\t}\n \t\t      if (n->next == NULL\n \t\t\t  || n->next->u.depend_op != OMP_DEPEND_SINK)\n@@ -2908,8 +2908,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t    continue;\n \n \t\t  tree node = build_omp_clause (input_location,\n-\t\t\t\t\t\tOMP_CLAUSE_DEPEND);\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_SINK;\n+\t\t\t\t\t\tOMP_CLAUSE_DOACROSS);\n+\t\t  OMP_CLAUSE_DOACROSS_KIND (node) = OMP_CLAUSE_DOACROSS_SINK;\n+\t\t  OMP_CLAUSE_DOACROSS_DEPEND (node) = 1;\n \t\t  OMP_CLAUSE_DECL (node) = nreverse (vec);\n \t\t  omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t\t  continue;\n@@ -4254,8 +4255,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   if (clauses->depend_source)\n     {\n-      c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DEPEND);\n-      OMP_CLAUSE_DEPEND_KIND (c) = OMP_CLAUSE_DEPEND_SOURCE;\n+      c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DOACROSS);\n+      OMP_CLAUSE_DOACROSS_KIND (c) = OMP_CLAUSE_DOACROSS_SOURCE;\n+      OMP_CLAUSE_DOACROSS_DEPEND (c) = 1;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n "}, {"sha": "988fc93a7f71c6ab6c46f14e4e6a6587815e0c22", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 72, "deletions": 34, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -8319,9 +8319,6 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n \t  case OMP_CLAUSE_DEPEND_INOUTSET:\n \t    i = 4;\n \t    break;\n-\t  case OMP_CLAUSE_DEPEND_SOURCE:\n-\t  case OMP_CLAUSE_DEPEND_SINK:\n-\t    continue;\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n@@ -8560,9 +8557,6 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n \t  case OMP_CLAUSE_DEPEND_INOUTSET:\n \t    i = 4;\n \t    break;\n-\t  case OMP_CLAUSE_DEPEND_SOURCE:\n-\t  case OMP_CLAUSE_DEPEND_SINK:\n-\t    continue;\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n@@ -10406,8 +10400,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  gimplify_omp_affinity (list_p, pre_p);\n \t  remove = true;\n \t  break;\n-\tcase OMP_CLAUSE_DEPEND:\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\tcase OMP_CLAUSE_DOACROSS:\n+\t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n \t    {\n \t      tree deps = OMP_CLAUSE_DECL (c);\n \t      while (deps && TREE_CODE (deps) == TREE_LIST)\n@@ -10418,10 +10412,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t   pre_p, NULL, is_gimple_val, fb_rvalue);\n \t\t  deps = TREE_CHAIN (deps);\n \t\t}\n-\t      break;\n \t    }\n-\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n-\t    break;\n+\t  else\n+\t    gcc_assert (OMP_CLAUSE_DOACROSS_KIND (c)\n+\t\t\t== OMP_CLAUSE_DOACROSS_SOURCE);\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND:\n \t  if (handled_depend_iterators == -1)\n \t    handled_depend_iterators = gimplify_omp_depend (list_p, pre_p);\n \t  if (handled_depend_iterators)\n@@ -11946,6 +11942,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n@@ -12429,6 +12426,29 @@ gimplify_omp_taskloop_expr (tree type, tree *tp, gimple_seq *pre_p,\n   OMP_FOR_CLAUSES (orig_for_stmt) = c;\n }\n \n+/* Helper function of gimplify_omp_for, find OMP_ORDERED with\n+   OMP_CLAUSE_DOACROSS clause inside of OMP_FOR's body.  */\n+\n+static tree\n+find_standalone_omp_ordered (tree *tp, int *walk_subtrees, void *)\n+{\n+  switch (TREE_CODE (*tp))\n+    {\n+    case OMP_ORDERED:\n+      if (omp_find_clause (OMP_ORDERED_CLAUSES (*tp), OMP_CLAUSE_DOACROSS))\n+\treturn *tp;\n+      break;\n+    case OMP_SIMD:\n+    case OMP_PARALLEL:\n+    case OMP_TARGET:\n+      *walk_subtrees = 0;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Gimplify the gross structure of an OMP_FOR statement.  */\n \n static enum gimplify_status\n@@ -12804,12 +12824,24 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   tree c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_ORDERED);\n   bool is_doacross = false;\n-  if (c && OMP_CLAUSE_ORDERED_EXPR (c))\n+  if (c && walk_tree_without_duplicates (&OMP_FOR_BODY (for_stmt),\n+\t\t\t\t\t find_standalone_omp_ordered, NULL))\n     {\n+      OMP_CLAUSE_ORDERED_DOACROSS (c) = 1;\n       is_doacross = true;\n-      gimplify_omp_ctxp->loop_iter_var.create (TREE_VEC_LENGTH\n-\t\t\t\t\t\t (OMP_FOR_INIT (for_stmt))\n-\t\t\t\t\t       * 2);\n+      int len = TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt));\n+      gimplify_omp_ctxp->loop_iter_var.create (len * 2);\n+      for (tree *pc = &OMP_FOR_CLAUSES (for_stmt); *pc; )\n+\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<linear%> clause may not be specified together \"\n+\t\t      \"with %<ordered%> clause if stand-alone %<ordered%> \"\n+\t\t      \"construct is nested in it\");\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t  }\n+\telse\n+\t  pc = &OMP_CLAUSE_CHAIN (*pc);\n     }\n   int collapse = 1, tile = 0;\n   c = omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_COLLAPSE);\n@@ -14882,21 +14914,22 @@ gimplify_omp_ordered (tree expr, gimple_seq body)\n   if (gimplify_omp_ctxp)\n     {\n       for (c = OMP_ORDERED_CLAUSES (expr); c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t    && gimplify_omp_ctxp->loop_iter_var.is_empty ()\n-\t    && (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK\n-\t\t|| OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS\n+\t    && gimplify_omp_ctxp->loop_iter_var.is_empty ())\n \t  {\n \t    error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t      \"%<ordered%> construct with %<depend%> clause must be \"\n-\t\t      \"closely nested inside a loop with %<ordered%> clause \"\n-\t\t      \"with a parameter\");\n+\t\t      \"%<ordered%> construct with %qs clause must be \"\n+\t\t      \"closely nested inside a loop with %<ordered%> clause\",\n+\t\t      OMP_CLAUSE_DOACROSS_DEPEND (c) ? \"depend\" : \"doacross\");\n \t    failures++;\n \t  }\n-\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t\t && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS\n+\t\t && OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n \t  {\n \t    bool fail = false;\n+\t    sink_c = c;\n+\t    if (OMP_CLAUSE_DECL (c) == NULL_TREE)\n+\t      continue;  /* omp_cur_iteration - 1 */\n \t    for (decls = OMP_CLAUSE_DECL (c), i = 0;\n \t\t decls && TREE_CODE (decls) == TREE_LIST;\n \t\t decls = TREE_CHAIN (decls), ++i)\n@@ -14919,21 +14952,24 @@ gimplify_omp_ordered (tree expr, gimple_seq body)\n \t    if (!fail && i != gimplify_omp_ctxp->loop_iter_var.length () / 2)\n \t      {\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t  \"number of variables in %<depend%> clause with \"\n+\t\t\t  \"number of variables in %qs clause with \"\n \t\t\t  \"%<sink%> modifier does not match number of \"\n-\t\t\t  \"iteration variables\");\n+\t\t\t  \"iteration variables\",\n+\t\t\t  OMP_CLAUSE_DOACROSS_DEPEND (c)\n+\t\t\t  ? \"depend\" : \"doacross\");\n \t\tfailures++;\n \t      }\n-\t    sink_c = c;\n \t  }\n-\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t\t && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS\n+\t\t && OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SOURCE)\n \t  {\n \t    if (source_c)\n \t      {\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t  \"more than one %<depend%> clause with %<source%> \"\n-\t\t\t  \"modifier on an %<ordered%> construct\");\n+\t\t\t  \"more than one %qs clause with %<source%> \"\n+\t\t\t  \"modifier on an %<ordered%> construct\",\n+\t\t\t  OMP_CLAUSE_DOACROSS_DEPEND (source_c)\n+\t\t\t  ? \"depend\" : \"doacross\");\n \t\tfailures++;\n \t      }\n \t    else\n@@ -14943,9 +14979,11 @@ gimplify_omp_ordered (tree expr, gimple_seq body)\n   if (source_c && sink_c)\n     {\n       error_at (OMP_CLAUSE_LOCATION (source_c),\n-\t\t\"%<depend%> clause with %<source%> modifier specified \"\n-\t\t\"together with %<depend%> clauses with %<sink%> modifier \"\n-\t\t\"on the same construct\");\n+\t\t\"%qs clause with %<source%> modifier specified \"\n+\t\t\"together with %qs clauses with %<sink%> modifier \"\n+\t\t\"on the same construct\",\n+\t\tOMP_CLAUSE_DOACROSS_DEPEND (source_c) ? \"depend\" : \"doacross\",\n+\t\tOMP_CLAUSE_DOACROSS_DEPEND (sink_c) ? \"depend\" : \"doacross\");\n       failures++;\n     }\n "}, {"sha": "1bc3f5515994eadf3dfe4b4fc80c13af978277d5", "filename": "gcc/lto-streamer-out.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Flto-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Flto-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -1553,6 +1553,9 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \tcase OMP_CLAUSE_DEPEND:\n \t  val = OMP_CLAUSE_DEPEND_KIND (t);\n \t  break;\n+\tcase OMP_CLAUSE_DOACROSS:\n+\t  val = OMP_CLAUSE_DOACROSS_KIND (t);\n+\t  break;\n \tcase OMP_CLAUSE_MAP:\n \t  val = OMP_CLAUSE_MAP_KIND (t);\n \t  break;"}, {"sha": "55c513d0d22ab6c4fd803e22d9b853b231035856", "filename": "gcc/omp-expand.cc", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -3298,6 +3298,11 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n   gimple_stmt_iterator gsi2 = *gsi;\n   bool warned_step = false;\n \n+  if (deps == NULL)\n+    {\n+      sorry_at (loc, \"%<doacross(sink:omp_cur_iteration-1)%> not supported yet\");\n+      return;\n+    }\n   for (i = 0; i < fd->ordered; i++)\n     {\n       tree step = NULL_TREE;\n@@ -3321,9 +3326,11 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\tbreak;\n \t      forward = tree_int_cst_sgn (step) != -1;\n \t    }\n-\t  if (forward ^ OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n-\t    warning_at (loc, 0, \"%<depend%> clause with %<sink%> modifier \"\n-\t\t\t\t\"waiting for lexically later iteration\");\n+\t  if (forward ^ OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n+\t    warning_at (loc, 0, \"%qs clause with %<sink%> modifier \"\n+\t\t\t\t\"waiting for lexically later iteration\",\n+\t\t\tOMP_CLAUSE_DOACROSS_DEPEND (c)\n+\t\t\t? \"depend\" : \"doacross\");\n \t  break;\n \t}\n       deps = TREE_CHAIN (deps);\n@@ -3377,13 +3384,13 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t  tree co = fold_convert_loc (loc, itype, off);\n \t  if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i].v)))\n \t    {\n-\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t      if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t\tco = fold_build1_loc (loc, NEGATE_EXPR, itype, co);\n \t      a = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n \t\t\t\t   TREE_TYPE (fd->loops[i].v), fd->loops[i].v,\n \t\t\t\t   co);\n \t    }\n-\t  else if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t  else if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t    a = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (fd->loops[i].v),\n \t\t\t\t fd->loops[i].v, co);\n \t  else\n@@ -3392,13 +3399,13 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t  if (step)\n \t    {\n \t      tree t1, t2;\n-\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t      if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t\tt1 = fold_build2_loc (loc, GE_EXPR, boolean_type_node, a,\n \t\t\t\t      fd->loops[i].n1);\n \t      else\n \t\tt1 = fold_build2_loc (loc, LT_EXPR, boolean_type_node, a,\n \t\t\t\t      fd->loops[i].n2);\n-\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t      if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t\tt2 = fold_build2_loc (loc, LT_EXPR, boolean_type_node, a,\n \t\t\t\t      fd->loops[i].n2);\n \t      else\n@@ -3420,14 +3427,14 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t    }\n \t  else if (fd->loops[i].cond_code == LT_EXPR)\n \t    {\n-\t      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t      if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t\tt = fold_build2_loc (loc, GE_EXPR, boolean_type_node, a,\n \t\t\t\t     fd->loops[i].n1);\n \t      else\n \t\tt = fold_build2_loc (loc, LT_EXPR, boolean_type_node, a,\n \t\t\t\t     fd->loops[i].n2);\n \t    }\n-\t  else if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+\t  else if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \t    t = fold_build2_loc (loc, GT_EXPR, boolean_type_node, a,\n \t\t\t\t fd->loops[i].n2);\n \t  else\n@@ -3459,9 +3466,11 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\t\t       build_int_cst (itype, 0));\n \t  if (integer_zerop (t) && !warned_step)\n \t    {\n-\t      warning_at (loc, 0, \"%<depend%> clause with %<sink%> modifier \"\n+\t      warning_at (loc, 0, \"%qs clause with %<sink%> modifier \"\n \t\t\t\t  \"refers to iteration never in the iteration \"\n-\t\t\t\t  \"space\");\n+\t\t\t\t  \"space\",\n+\t\t\t  OMP_CLAUSE_DOACROSS_DEPEND (c)\n+\t\t\t  ? \"depend\" : \"doacross\");\n \t      warned_step = true;\n \t    }\n \t  cond = fold_build2_loc (loc, BIT_AND_EXPR, boolean_type_node,\n@@ -3486,7 +3495,7 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\t\t\t\t\ts));\n       else\n \toff = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, off, s);\n-      if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (deps))\n+      if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (deps))\n \toff = fold_build1_loc (loc, NEGATE_EXPR, itype, off);\n       off = fold_convert_loc (loc, fd->iter_type, off);\n       if (i <= fd->collapse - 1 && fd->collapse > 1)\n@@ -3559,13 +3568,13 @@ expand_omp_ordered_source_sink (struct omp_region *region,\n \ttree c;\n \tfor (c = gimple_omp_ordered_clauses (ord_stmt);\n \t     c; c = OMP_CLAUSE_CHAIN (c))\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n+\t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SOURCE)\n \t    break;\n \tif (c)\n \t  expand_omp_ordered_source (&gsi, fd, counts, loc);\n \tfor (c = gimple_omp_ordered_clauses (ord_stmt);\n \t     c; c = OMP_CLAUSE_CHAIN (c))\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n \t    expand_omp_ordered_sink (&gsi, fd, counts, c, loc);\n \tgsi_remove (&gsi, true);\n       }\n@@ -10479,7 +10488,7 @@ expand_omp (struct omp_region *region)\n \t    gomp_ordered *ord_stmt\n \t      = as_a <gomp_ordered *> (last_stmt (region->entry));\n \t    if (omp_find_clause (gimple_omp_ordered_clauses (ord_stmt),\n-\t\t\t\t OMP_CLAUSE_DEPEND))\n+\t\t\t\t OMP_CLAUSE_DOACROSS))\n \t      {\n \t\t/* We'll expand these when expanding corresponding\n \t\t   worksharing region with ordered(n) clause.  */\n@@ -10609,7 +10618,7 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t  else if (code == GIMPLE_OMP_ORDERED\n \t\t   && omp_find_clause (gimple_omp_ordered_clauses\n \t\t\t\t\t (as_a <gomp_ordered *> (stmt)),\n-\t\t\t\t       OMP_CLAUSE_DEPEND))\n+\t\t\t\t       OMP_CLAUSE_DOACROSS))\n \t    /* #pragma omp ordered depend is also just a stand-alone\n \t       directive.  */\n \t    region = NULL;\n@@ -10835,7 +10844,7 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n       fallthru = true;\n       if (omp_find_clause (gimple_omp_ordered_clauses\n \t\t\t     (as_a <gomp_ordered *> (last)),\n-\t\t\t   OMP_CLAUSE_DEPEND))\n+\t\t\t   OMP_CLAUSE_DOACROSS))\n \tcur_region = cur_region->outer;\n       break;\n "}, {"sha": "0b4ec823479a578b170377ecf2f98bd42baf0f4f", "filename": "gcc/omp-general.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-general.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-general.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -241,8 +241,13 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tbreak;\n       case OMP_CLAUSE_ORDERED:\n \tfd->have_ordered = true;\n-\tif (OMP_CLAUSE_ORDERED_EXPR (t))\n-\t  fd->ordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (t));\n+\tif (OMP_CLAUSE_ORDERED_DOACROSS (t))\n+\t  {\n+\t    if (OMP_CLAUSE_ORDERED_EXPR (t))\n+\t      fd->ordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (t));\n+\t    else\n+\t      fd->ordered = -1;\n+\t  }\n \tbreak;\n       case OMP_CLAUSE_SCHEDULE:\n \tgcc_assert (!distribute && !taskloop);\n@@ -301,6 +306,9 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tbreak;\n       }\n \n+  if (fd->ordered == -1)\n+    fd->ordered = fd->collapse;\n+\n   /* For order(reproducible:concurrent) schedule ({dynamic,guided,runtime})\n      we have either the option to expensively remember at runtime how we've\n      distributed work from first loop and reuse that in following loops with"}, {"sha": "b32336b8d69102d2bec17ca9202c0c4ec8a1f7ab", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -3636,58 +3636,44 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       break;\n     case GIMPLE_OMP_TASK:\n       for (c = gimple_omp_task_clauses (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t    && (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE\n-\t\t|| OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS)\n \t  {\n-\t    enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_KIND (c);\n+\t    enum omp_clause_doacross_kind kind = OMP_CLAUSE_DOACROSS_KIND (c);\n \t    error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t      \"%<depend(%s)%> is only allowed in %<omp ordered%>\",\n-\t\t      kind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+\t\t      \"%<%s(%s)%> is only allowed in %<omp ordered%>\",\n+\t\t      OMP_CLAUSE_DOACROSS_DEPEND (c) ? \"depend\" : \"doacross\",\n+\t\t      kind == OMP_CLAUSE_DOACROSS_SOURCE ? \"source\" : \"sink\");\n \t    return false;\n \t  }\n       break;\n     case GIMPLE_OMP_ORDERED:\n       for (c = gimple_omp_ordered_clauses (as_a <gomp_ordered *> (stmt));\n \t   c; c = OMP_CLAUSE_CHAIN (c))\n \t{\n-\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DOACROSS)\n \t    {\n-\t      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREADS\n-\t\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SIMD);\n-\t      continue;\n-\t    }\n-\t  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_KIND (c);\n-\t  if (kind == OMP_CLAUSE_DEPEND_SOURCE\n-\t      || kind == OMP_CLAUSE_DEPEND_SINK)\n-\t    {\n-\t      tree oclause;\n-\t      /* Look for containing ordered(N) loop.  */\n-\t      if (ctx == NULL\n-\t\t  || gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n-\t\t  || (oclause\n-\t\t\t= omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n-\t\t\t\t\t   OMP_CLAUSE_ORDERED)) == NULL_TREE)\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<ordered%> construct with %<depend%> clause \"\n-\t\t\t    \"must be closely nested inside an %<ordered%> \"\n-\t\t\t    \"loop\");\n-\t\t  return false;\n-\t\t}\n-\t      else if (OMP_CLAUSE_ORDERED_EXPR (oclause) == NULL_TREE)\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<ordered%> construct with %<depend%> clause \"\n-\t\t\t    \"must be closely nested inside a loop with \"\n-\t\t\t    \"%<ordered%> clause with a parameter\");\n+\t\t\t    \"invalid depend kind in omp %<ordered%> %<depend%>\");\n \t\t  return false;\n \t\t}\n+\t      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREADS\n+\t\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SIMD);\n+\t      continue;\n \t    }\n-\t  else\n+\n+\t  tree oclause;\n+\t  /* Look for containing ordered(N) loop.  */\n+\t  if (ctx == NULL\n+\t      || gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n+\t      || (oclause\n+\t\t  = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n+\t\t\t\t     OMP_CLAUSE_ORDERED)) == NULL_TREE)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"invalid depend kind in omp %<ordered%> %<depend%>\");\n+\t\t\t\"%<ordered%> construct with %<depend%> clause \"\n+\t\t\t\"must be closely nested inside an %<ordered%> loop\");\n \t      return false;\n \t    }\n \t}\n@@ -3732,14 +3718,37 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t\t  \"a loop region with an %<ordered%> clause\");\n \t\treturn false;\n \t      }\n-\t    if (OMP_CLAUSE_ORDERED_EXPR (o) != NULL_TREE\n-\t\t&& omp_find_clause (c, OMP_CLAUSE_DEPEND) == NULL_TREE)\n+\t    if (omp_find_clause (c, OMP_CLAUSE_DOACROSS) == NULL_TREE)\n \t      {\n-\t\terror_at (gimple_location (stmt),\n-\t\t\t  \"%<ordered%> region without %<depend%> clause may \"\n-\t\t\t  \"not be closely nested inside a loop region with \"\n-\t\t\t  \"an %<ordered%> clause with a parameter\");\n-\t\treturn false;\n+\t\tif (OMP_CLAUSE_ORDERED_DOACROSS (o))\n+\t\t  {\n+\t\t    error_at (gimple_location (stmt),\n+\t\t\t      \"%<ordered%> construct without %<doacross%> or \"\n+\t\t\t      \"%<depend%> clauses must not have the same \"\n+\t\t\t      \"binding region as %<ordered%> construct with \"\n+\t\t\t      \"those clauses\");\n+\t\t    return false;\n+\t\t  }\n+\t\telse if (OMP_CLAUSE_ORDERED_EXPR (o))\n+\t\t  {\n+\t\t    tree co\n+\t\t      = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n+\t\t\t\t\t OMP_CLAUSE_COLLAPSE);\n+\t\t    HOST_WIDE_INT\n+\t\t      o_n = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (o));\n+\t\t    HOST_WIDE_INT c_n = 1;\n+\t\t    if (co)\n+\t\t      c_n = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (co));\n+\t\t    if (o_n != c_n)\n+\t\t      {\n+\t\t\terror_at (gimple_location (stmt),\n+\t\t\t\t  \"%<ordered%> construct without %<doacross%> \"\n+\t\t\t\t  \"or %<depend%> clauses binds to loop where \"\n+\t\t\t\t  \"%<collapse%> argument %wd is different from \"\n+\t\t\t\t  \"%<ordered%> argument %wd\", c_n, o_n);\n+\t\t\treturn false;\n+\t\t      }\n+\t\t  }\n \t      }\n \t    return true;\n \t  case GIMPLE_OMP_TARGET:\n@@ -3793,14 +3802,12 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       break;\n     case GIMPLE_OMP_TARGET:\n       for (c = gimple_omp_target_clauses (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t    && (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE\n-\t\t|| OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS)\n \t  {\n-\t    enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_KIND (c);\n+\t    enum omp_clause_doacross_kind kind = OMP_CLAUSE_DOACROSS_KIND (c);\n \t    error_at (OMP_CLAUSE_LOCATION (c),\n \t\t      \"%<depend(%s)%> is only allowed in %<omp ordered%>\",\n-\t\t      kind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+\t\t      kind == OMP_CLAUSE_DOACROSS_SOURCE ? \"source\" : \"sink\");\n \t    return false;\n \t  }\n       if (is_gimple_omp_offloaded (stmt)\n@@ -9740,8 +9747,8 @@ lower_omp_ordered_clauses (gimple_stmt_iterator *gsi_p, gomp_ordered *ord_stmt,\n \n   tree *list_p = gimple_omp_ordered_clauses_ptr (ord_stmt);\n   tree c = gimple_omp_ordered_clauses (ord_stmt);\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-      && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS\n+      && OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n     {\n       /* Merge depend clauses from multiple adjacent\n \t #pragma omp ordered depend(sink:...) constructs\n@@ -9763,8 +9770,8 @@ lower_omp_ordered_clauses (gimple_stmt_iterator *gsi_p, gomp_ordered *ord_stmt,\n \t  gomp_ordered *ord_stmt2 = as_a <gomp_ordered *> (stmt);\n \t  c = gimple_omp_ordered_clauses (ord_stmt2);\n \t  if (c == NULL_TREE\n-\t      || OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t      || OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_SINK)\n+\t      || OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DOACROSS\n+\t      || OMP_CLAUSE_DOACROSS_KIND (c) != OMP_CLAUSE_DOACROSS_SINK)\n \t    break;\n \t  while (*list_p)\n \t    list_p = &OMP_CLAUSE_CHAIN (*list_p);\n@@ -9831,8 +9838,8 @@ lower_omp_ordered_clauses (gimple_stmt_iterator *gsi_p, gomp_ordered *ord_stmt,\n     {\n       bool remove = false;\n \n-      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND);\n-      if (OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_SINK)\n+      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DOACROSS);\n+      if (OMP_CLAUSE_DOACROSS_KIND (c) != OMP_CLAUSE_DOACROSS_SINK)\n \tgoto next_ordered_clause;\n \n       tree vec;\n@@ -9983,7 +9990,7 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t  OMP_CLAUSE_THREADS);\n \n   if (omp_find_clause (gimple_omp_ordered_clauses (ord_stmt),\n-\t\t       OMP_CLAUSE_DEPEND))\n+\t\t       OMP_CLAUSE_DOACROSS))\n     {\n       /* FIXME: This is needs to be moved to the expansion to verify various\n \t conditions only testable on cfg with dominators computed, and also\n@@ -12359,9 +12366,6 @@ lower_depend_clauses (tree *pclauses, gimple_seq *iseq, gimple_seq *oseq)\n \tcase OMP_CLAUSE_DEPEND_INOUTSET:\n \t  cnt[4]++;\n \t  break;\n-\tcase OMP_CLAUSE_DEPEND_SOURCE:\n-\tcase OMP_CLAUSE_DEPEND_SINK:\n-\t  /* FALLTHRU */\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "44c5c212c89762893ae717aae54620295111cc75", "filename": "gcc/testsuite/c-c++-common/gomp/doacross-2.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-2.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -7,13 +7,13 @@ foo (void)\n   #pragma omp for ordered(1)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered\t\t\t/* { dg-error \"'ordered' region without 'depend' clause may not be closely nested inside a loop region with an 'ordered' clause with a parameter\" } */\n+      #pragma omp ordered\n       ;\n     }\n   #pragma omp for ordered(1)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered threads\t\t/* { dg-error \"'ordered' region without 'depend' clause may not be closely nested inside a loop region with an 'ordered' clause with a parameter\" } */\n+      #pragma omp ordered threads\n       ;\n     }\n }\n@@ -25,14 +25,20 @@ bar (void)\n   #pragma omp for ordered\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(source)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter\" } */\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter\" } */\n+      #pragma omp ordered depend(source)\n+      #pragma omp ordered depend(sink: i - 1)\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered doacross(source:)\n+      #pragma omp ordered doacross(sink: i - 1)\n     }\n   #pragma omp for\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(source)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter\" } */\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause with a parameter\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause\" } */\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"'ordered' construct with 'depend' clause must be closely nested inside a loop with 'ordered' clause\" } */\n     }\n   #pragma omp for\n   for (i = 0; i < 64; i++)"}, {"sha": "9dd6dbf4ebc7f3f5e29d8c81b81bda838c4d10f0", "filename": "gcc/testsuite/c-c++-common/gomp/doacross-5.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-5.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -0,0 +1,94 @@\n+void\n+foo (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(source:)\n+      #pragma omp ordered doacross(sink: i - 2)\n+    }\n+}\n+\n+void\n+bar (int n)\n+{\n+  int i, j;\n+  #pragma omp for collapse(2) ordered(2)\n+  for (i = 0; i < 8; i += n)\n+    for (j = 0; j < 8; j += n)\n+      {\n+\t#pragma omp ordered doacross(source:omp_cur_iteration)\n+\t#pragma omp ordered doacross(sink: i - 2, j + 2)\n+      }\n+}\n+\n+void\n+baz (void)\n+{\n+  int i, j;\n+  #pragma omp for ordered(1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered\t\t\t/* { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses must not have the same binding region as 'ordered' construct with those clauses\" } */\n+      ;\n+      #pragma omp ordered doacross(source:)\n+      #pragma omp ordered doacross(sink: i - 1)\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered doacross(source: omp_cur_iteration )\n+      #pragma omp ordered doacross(sink: i - 1)\n+      #pragma omp ordered threads\t\t/* { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses must not have the same binding region as 'ordered' construct with those clauses\" } */\n+      ;\n+    }\n+  #pragma omp for ordered(2)\n+  for (i = 0; i < 8; i++)\n+    for (j = 0; j < 8; j++)\n+      {\n+\t#pragma omp ordered\t\t\t/* { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses binds to loop where 'collapse' argument 1 is different from 'ordered' argument 2\" } */\n+\t;\n+      }\n+  #pragma omp for ordered(2) collapse(1)\n+  for (i = 0; i < 8; i++)\n+    for (j = 0; j < 8; j++)\n+      {\n+\t#pragma omp ordered threads\t\t/* { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses binds to loop where 'collapse' argument 1 is different from 'ordered' argument 2\" } */\n+\t;\n+      }\n+}\n+\n+void\n+qux (void)\n+{\n+  int i, j = 0;\n+  #pragma omp for ordered linear(j)\n+  for (i = 0; i < 64; i++)\n+    {\n+      ++j;\n+      #pragma omp ordered\n+      ;\n+    }\n+  #pragma omp for ordered linear(j)\t\t/* { dg-error \"'linear' clause may not be specified together with 'ordered' clause if stand-alone 'ordered' construct is nested in it\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      ++j;\n+      #pragma omp ordered doacross(source:)\n+      #pragma omp ordered doacross(sink:i-1)\n+    }\n+  #pragma omp for ordered(1) linear(j)\n+  for (i = 0; i < 64; i++)\n+    {\n+      ++j;\n+      #pragma omp ordered\n+      ;\n+    }\n+  #pragma omp for ordered(1) linear(j)\t\t/* { dg-error \"'linear' clause may not be specified together with 'ordered' clause if stand-alone 'ordered' construct is nested in it\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      ++j;\n+      #pragma omp ordered doacross(source:)\n+      #pragma omp ordered doacross(sink:i-1)\n+    }\n+}"}, {"sha": "d126ad1bb2de1a5de2f4bb2536590d918600a0da", "filename": "gcc/testsuite/c-c++-common/gomp/doacross-6.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-6.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -0,0 +1,74 @@\n+void\n+foo (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(source)\t\t/* { dg-error \"expected ':' before '\\\\\\)' token\" } */\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(source:omp_current_iteration)\t/* { dg-error \"expected '\\\\\\)' before 'omp_current_iteration'\" } */\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(source:i - 2)\t/* { dg-error \"expected '\\\\\\)' before 'i'\" } */\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink)\t\t/* { dg-error \"expected ':' before '\\\\\\)' token\" } */\n+    }\n+}\n+\n+void\n+bar (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink:omp_current_iteration - 1)\t/* { dg-error \"'omp_current_iteration' undeclared \\\\\\(first use in this function\\\\\\)\" \"\" { target c } } */\n+    }\t\t\t\t\t\t\t\t\t/* { dg-error \"'omp_current_iteration' has not been declared\" \"\" { target c++ } .-1 } */\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink:omp_cur_iteration)\t/* { dg-error \"'omp_cur_iteration' undeclared \\\\\\(first use in this function\\\\\\)\" \"\" { target c } } */\n+    }\t\t\t\t\t\t\t\t/* { dg-error \"'omp_cur_iteration' has not been declared\" \"\" { target c++ } .-1 } */\n+}\n+\n+void\n+baz (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink:omp_cur_iteration + 1)\t/* { dg-error \"'omp_cur_iteration' undeclared \\\\\\(first use in this function\\\\\\)\" \"\" { target c } } */\n+    }\t\t\t\t\t\t\t\t/* { dg-error \"'omp_cur_iteration' has not been declared\" \"\" { target c++ } .-1 } */\n+}\n+\n+void\n+qux (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink:omp_cur_iteration - (2 - 1))\t/* { dg-error \"'omp_cur_iteration' undeclared \\\\\\(first use in this function\\\\\\)\" \"\" { target c } } */\n+    }\t\t\t\t\t\t\t\t/* { dg-error \"expected integer before '\\\\\\(' token\" \"\" { target *-*-* } .-1 } */\n+}\t\t\t\t\t\t\t\t/* { dg-error \"'omp_cur_iteration' has not been declared\" \"\" { target c++ } .-2 } */\n+\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\)' before '\\\\\\(' token\" \"\" { target c++ } .-3 } */\n+void\n+corge (int n)\n+{\n+  int i;\n+  #pragma omp for ordered\n+  for (i = 0; i < 8; i += n)\n+    {\n+      #pragma omp ordered doacross(sink:omp_cur_iteration - 1LL)\t/* { dg-error \"'omp_cur_iteration' undeclared \\\\\\(first use in this function\\\\\\)\" \"\" { target c } } */\n+    }\t\t\t\t\t\t\t\t\t/* { dg-error \"'omp_cur_iteration' has not been declared\" \"\" { target c++ } .-1 } */\n+}"}, {"sha": "6ce560de7f5e07c81390e34ca68be7f916c2d497", "filename": "gcc/testsuite/c-c++-common/gomp/nesting-2.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnesting-2.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -160,7 +160,14 @@ foo (void)\n   for (i = 0; i < 64; i++)\n     #pragma omp parallel\n     {\n-      #pragma omp ordered depend(source)\t/* { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause\" } */\n+    }\n+  #pragma omp for ordered(1)\n+  for (i = 0; i < 64; i++)\n+    #pragma omp parallel\n+    {\n+      #pragma omp ordered doacross(source:)\t/* { dg-error \".ordered. construct with .doacross. clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered doacross(sink: i - 1)\t/* { dg-error \".ordered. construct with .doacross. clause must be closely nested inside a loop with .ordered. clause\" } */\n     }\n }"}, {"sha": "b007ca7982a367dd275656e11539dba29158f28c", "filename": "gcc/testsuite/c-c++-common/gomp/ordered-3.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fordered-3.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -47,29 +47,53 @@ foo (void)\n       #pragma omp ordered threads, simd, threads, simd\t/* { dg-error \"too many .threads. clauses\" } */\n       ;\t/* { dg-error \"too many .simd. clauses\" \"\" { target *-*-* } .-1 } */\n     }\n-  #pragma omp for simd ordered(1)\t/* { dg-error \".ordered. clause with parameter may not be specified on .#pragma omp for simd. construct\" } */\n+  #pragma omp for simd ordered(1)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n-      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n     }\n-  #pragma omp parallel for simd ordered(1)\t/* { dg-error \".ordered. clause with parameter may not be specified on .#pragma omp parallel for simd. construct\" } */\n+  #pragma omp for simd ordered(1)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n-      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered doacross(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered doacross(source:omp_cur_iteration)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+    }\n+  #pragma omp parallel for simd ordered(1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+    }\n+  #pragma omp parallel for simd ordered(1)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered doacross(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered doacross(source:)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+    }\n+  #pragma omp parallel for ordered\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\n+      #pragma omp ordered depend(source)\n     }\n   #pragma omp parallel for ordered\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n-      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered doacross(sink: i - 1)\n+      #pragma omp ordered doacross(source:)\n+    }\n+  #pragma omp parallel for\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n     }\n   #pragma omp parallel for\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered depend(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n-      #pragma omp ordered depend(source)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause with a parameter\" } */\n+      #pragma omp ordered doacross(sink: i - 1)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n+      #pragma omp ordered doacross(source:)\t/* { dg-error \"clause must be closely nested inside a loop with .ordered. clause\" } */\n     }\n }\n "}, {"sha": "3f7ba5e307db3731b44cf5e7ecc19ef4d37bb359", "filename": "gcc/testsuite/c-c++-common/gomp/sink-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsink-3.c?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -14,7 +14,7 @@ foo ()\n   for (i=0; i < 100; ++i)\n     {\n #pragma omp ordered depend(sink:poo-1,paa+1) /* { dg-error \"poo.*declared.*paa.*declared\" } */\n-    bar(&i);\t\t\t\t     /* { dg-error \"may not be closely nested\" \"\" { target *-*-* } .-1 } */\n+    bar(&i);\t\t\t\t     /* { dg-error \"must not have the same binding region\" \"\" { target *-*-* } .-1 } */\n #pragma omp ordered depend(source)\n     }\n }"}, {"sha": "d8014d6f151a85a9a9995cc4d5b5249c8e301516", "filename": "gcc/testsuite/gfortran.dg/gomp/nesting-2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnesting-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnesting-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnesting-2.f90?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -158,8 +158,8 @@ subroutine foo\n   !$omp do ordered(1)\n   do i = 0, 63\n     !$omp parallel\n-      !$omp ordered depend(source)\t! { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause with a parameter\" }\n-      !$omp ordered depend(sink: i - 1)\t! { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause with a parameter\" }\n+      !$omp ordered depend(source)\t! { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause\" }\n+      !$omp ordered depend(sink: i - 1)\t! { dg-error \".ordered. construct with .depend. clause must be closely nested inside a loop with .ordered. clause\" }\n     !$omp end parallel\n   end do\n end"}, {"sha": "80c2bcb333dd67edec64d69c665d9c3b7455903f", "filename": "gcc/tree-core.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -345,6 +345,9 @@ enum omp_clause_code {\n   /* OpenMP clause: has_device_addr (variable-list).  */\n   OMP_CLAUSE_HAS_DEVICE_ADDR,\n \n+  /* OpenMP clause: doacross ({source,sink}:vec).  */\n+  OMP_CLAUSE_DOACROSS,\n+\n   /* Internal structure to hold OpenACC cache directive's variable-list.\n      #pragma acc cache (variable-list).  */\n   OMP_CLAUSE__CACHE_,\n@@ -1525,12 +1528,18 @@ enum omp_clause_depend_kind\n   OMP_CLAUSE_DEPEND_INOUT,\n   OMP_CLAUSE_DEPEND_MUTEXINOUTSET,\n   OMP_CLAUSE_DEPEND_INOUTSET,\n-  OMP_CLAUSE_DEPEND_SOURCE,\n-  OMP_CLAUSE_DEPEND_SINK,\n   OMP_CLAUSE_DEPEND_DEPOBJ,\n+  OMP_CLAUSE_DEPEND_INVALID,\n   OMP_CLAUSE_DEPEND_LAST\n };\n \n+enum omp_clause_doacross_kind\n+{\n+  OMP_CLAUSE_DOACROSS_SOURCE,\n+  OMP_CLAUSE_DOACROSS_SINK,\n+  OMP_CLAUSE_DOACROSS_LAST\n+};\n+\n enum omp_clause_proc_bind_kind\n {\n   /* Numbers should match omp_proc_bind_t enum in omp.h.  */\n@@ -1620,6 +1629,7 @@ struct GTY(()) tree_omp_clause {\n     enum omp_clause_default_kind   default_kind;\n     enum omp_clause_schedule_kind  schedule_kind;\n     enum omp_clause_depend_kind    depend_kind;\n+    enum omp_clause_doacross_kind  doacross_kind;\n     /* See include/gomp-constants.h for enum gomp_map_kind's values.  */\n     unsigned int\t\t   map_kind;\n     enum omp_clause_proc_bind_kind proc_bind_kind;"}, {"sha": "ea7d57a0591c6fbe08862814b02833f5bf2eb50c", "filename": "gcc/tree-nested.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-nested.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-nested.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -1368,6 +1368,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n@@ -2157,6 +2158,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DOACROSS:\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:"}, {"sha": "33b12c79c4d666a463d39f5869709534c49281ad", "filename": "gcc/tree-pretty-print.cc", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -831,34 +831,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \tcase OMP_CLAUSE_DEPEND_INOUTSET:\n \t  name = \"inoutset\";\n \t  break;\n-\tcase OMP_CLAUSE_DEPEND_SOURCE:\n-\t  pp_string (pp, \"source)\");\n-\t  return;\n \tcase OMP_CLAUSE_DEPEND_LAST:\n \t  name = \"__internal__\";\n \t  break;\n-\tcase OMP_CLAUSE_DEPEND_SINK:\n-\t  pp_string (pp, \"sink:\");\n-\t  for (tree t = OMP_CLAUSE_DECL (clause); t; t = TREE_CHAIN (t))\n-\t    if (TREE_CODE (t) == TREE_LIST)\n-\t      {\n-\t\tdump_generic_node (pp, TREE_VALUE (t), spc, flags, false);\n-\t\tif (TREE_PURPOSE (t) != integer_zero_node)\n-\t\t  {\n-\t\t    if (OMP_CLAUSE_DEPEND_SINK_NEGATIVE (t))\n-\t\t      pp_minus (pp);\n-\t\t    else\n-\t\t      pp_plus (pp);\n-\t\t    dump_generic_node (pp, TREE_PURPOSE (t), spc, flags,\n-\t\t\t\t       false);\n-\t\t  }\n-\t\tif (TREE_CHAIN (t))\n-\t\t  pp_comma (pp);\n-\t      }\n-\t    else\n-\t      gcc_unreachable ();\n-\t  pp_right_paren (pp);\n-\t  return;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -885,6 +860,49 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       }\n       break;\n \n+    case OMP_CLAUSE_DOACROSS:\n+      pp_string (pp, OMP_CLAUSE_DOACROSS_DEPEND (clause)\n+\t\t     ? \"depend(\" : \"doacross(\");\n+      switch (OMP_CLAUSE_DOACROSS_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_DOACROSS_SOURCE:\n+\t  if (OMP_CLAUSE_DOACROSS_DEPEND (clause))\n+\t    pp_string (pp, \"source)\");\n+\t  else\n+\t    pp_string (pp, \"source:)\");\n+\t  break;\n+\tcase OMP_CLAUSE_DOACROSS_SINK:\n+\t  pp_string (pp, \"sink:\");\n+\t  if (OMP_CLAUSE_DECL (clause) == NULL_TREE)\n+\t    {\n+\t      pp_string (pp, \"omp_cur_iteration-1)\");\n+\t      break;\n+\t    }\n+\t  for (tree t = OMP_CLAUSE_DECL (clause); t; t = TREE_CHAIN (t))\n+\t    if (TREE_CODE (t) == TREE_LIST)\n+\t      {\n+\t\tdump_generic_node (pp, TREE_VALUE (t), spc, flags, false);\n+\t\tif (TREE_PURPOSE (t) != integer_zero_node)\n+\t\t  {\n+\t\t    if (OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (t))\n+\t\t      pp_minus (pp);\n+\t\t    else\n+\t\t      pp_plus (pp);\n+\t\t    dump_generic_node (pp, TREE_PURPOSE (t), spc, flags,\n+\t\t\t\t       false);\n+\t\t  }\n+\t\tif (TREE_CHAIN (t))\n+\t\t  pp_comma (pp);\n+\t      }\n+\t    else\n+\t      gcc_unreachable ();\n+\t  pp_right_paren (pp);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n     case OMP_CLAUSE_MAP:\n       pp_string (pp, \"map(\");\n       switch (OMP_CLAUSE_MAP_KIND (clause))"}, {"sha": "219cf5e7ef45af66c9dbce3b32c0dd90d865d054", "filename": "gcc/tree-streamer-in.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -453,6 +453,11 @@ unpack_ts_omp_clause_value_fields (class data_in *data_in,\n       OMP_CLAUSE_DEPEND_KIND (expr)\n \t= bp_unpack_enum (bp, omp_clause_depend_kind, OMP_CLAUSE_DEPEND_LAST);\n       break;\n+    case OMP_CLAUSE_DOACROSS:\n+      OMP_CLAUSE_DOACROSS_KIND (expr)\n+\t= bp_unpack_enum (bp, omp_clause_doacross_kind,\n+\t\t\t  OMP_CLAUSE_DOACROSS_LAST);\n+      break;\n     case OMP_CLAUSE_MAP:\n       OMP_CLAUSE_SET_MAP_KIND (expr, bp_unpack_enum (bp, gomp_map_kind,\n \t\t\t\t\t\t     GOMP_MAP_LAST));"}, {"sha": "9b114dc05bb1c08f0ea57869a1a90817c4d52a06", "filename": "gcc/tree-streamer-out.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -419,6 +419,10 @@ pack_ts_omp_clause_value_fields (struct output_block *ob,\n       bp_pack_enum (bp, omp_clause_depend_kind, OMP_CLAUSE_DEPEND_LAST,\n \t\t    OMP_CLAUSE_DEPEND_KIND (expr));\n       break;\n+    case OMP_CLAUSE_DOACROSS:\n+      bp_pack_enum (bp, omp_clause_doacross_kind, OMP_CLAUSE_DOACROSS_LAST,\n+\t\t    OMP_CLAUSE_DOACROSS_KIND (expr));\n+      break;\n     case OMP_CLAUSE_MAP:\n       bp_pack_enum (bp, gomp_map_kind, GOMP_MAP_LAST,\n \t\t    OMP_CLAUSE_MAP_KIND (expr));"}, {"sha": "2f488e4467c4c2bcacc400a15e83b0971e6087d2", "filename": "gcc/tree.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -294,6 +294,7 @@ unsigned const char omp_clause_num_ops[] =\n   2, /* OMP_CLAUSE_TO  */\n   2, /* OMP_CLAUSE_MAP  */\n   1, /* OMP_CLAUSE_HAS_DEVICE_ADDR  */\n+  1, /* OMP_CLAUSE_DOACROSS  */\n   2, /* OMP_CLAUSE__CACHE_  */\n   2, /* OMP_CLAUSE_GANG  */\n   1, /* OMP_CLAUSE_ASYNC  */\n@@ -384,6 +385,7 @@ const char * const omp_clause_code_name[] =\n   \"to\",\n   \"map\",\n   \"has_device_addr\",\n+  \"doacross\",\n   \"_cache_\",\n   \"gang\",\n   \"async\","}, {"sha": "266e24a056330306a33e0237f6d4767882450b92", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a651e6d59188da8992f8bfae2df1cb4e6316f9e6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a651e6d59188da8992f8bfae2df1cb4e6316f9e6", "patch": "@@ -1722,9 +1722,16 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_DEPEND_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)->omp_clause.subcode.depend_kind)\n \n-#define OMP_CLAUSE_DEPEND_SINK_NEGATIVE(NODE) \\\n+#define OMP_CLAUSE_DOACROSS_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DOACROSS)->omp_clause.subcode.doacross_kind)\n+\n+#define OMP_CLAUSE_DOACROSS_SINK_NEGATIVE(NODE) \\\n   TREE_PUBLIC (TREE_LIST_CHECK (NODE))\n \n+/* True if DOACROSS clause is spelled as DEPEND.  */\n+#define OMP_CLAUSE_DOACROSS_DEPEND(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DOACROSS))\n+\n #define OMP_CLAUSE_MAP_KIND(NODE) \\\n   ((enum gomp_map_kind) OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)\n #define OMP_CLAUSE_SET_MAP_KIND(NODE, MAP_KIND) \\\n@@ -1786,6 +1793,11 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_ORDERED_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED), 0)\n \n+/* True on an OMP_CLAUSE_ORDERED if stand-alone ordered construct is nested\n+   inside of work-sharing loop the clause is on.  */\n+#define OMP_CLAUSE_ORDERED_DOACROSS(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED)->base.public_flag)\n+\n /* True for unconstrained modifier on order(concurrent) clause.  */\n #define OMP_CLAUSE_ORDER_UNCONSTRAINED(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDER)->base.public_flag)"}]}