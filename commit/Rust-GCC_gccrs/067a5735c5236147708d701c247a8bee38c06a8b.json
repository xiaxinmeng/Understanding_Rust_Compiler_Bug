{"sha": "067a5735c5236147708d701c247a8bee38c06a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY3YTU3MzVjNTIzNjE0NzcwOGQ3MDFjMjQ3YThiZWUzOGMwNmE4Yg==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-09T21:09:41Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-09T21:09:41Z"}, "message": "c99_functions.c (nextafterf): New implementation that works correctly with denormalized numbers.\n\n\n\t* intrinsics/c99_functions.c (nextafterf): New implementation that\n\tworks correctly with denormalized numbers.\n\nFrom-SVN: r85724", "tree": {"sha": "f2079c84cbe12921ff8851d7d5ad3c28a97c5a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2079c84cbe12921ff8851d7d5ad3c28a97c5a41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/067a5735c5236147708d701c247a8bee38c06a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067a5735c5236147708d701c247a8bee38c06a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067a5735c5236147708d701c247a8bee38c06a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067a5735c5236147708d701c247a8bee38c06a8b/comments", "author": null, "committer": null, "parents": [{"sha": "9d8646d7b098cd131bd9263ec98d3c03bdf4f66b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d8646d7b098cd131bd9263ec98d3c03bdf4f66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d8646d7b098cd131bd9263ec98d3c03bdf4f66b"}], "stats": {"total": 93, "additions": 49, "deletions": 44}, "files": [{"sha": "de54f0f21155ac885a6f3af6fad2b1724e675230", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067a5735c5236147708d701c247a8bee38c06a8b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067a5735c5236147708d701c247a8bee38c06a8b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=067a5735c5236147708d701c247a8bee38c06a8b", "patch": "@@ -1,4 +1,10 @@\n-2004-09-09  Victor Leikehman  <lei@il.ibm.com>\n+2004-08-09  Richard Henderson  <rth@redhat.com>\n+\t    Roger Sayle  <roger@eyesopen.com>\n+\n+\t* intrinsics/c99_functions.c (nextafterf): New implementation that\n+\tworks correctly with denormalized numbers.\n+\n+2004-08-09  Victor Leikehman  <lei@il.ibm.com>\n \n \t* m4/matmul.m4, m4/matmull.m4, intrinsics/eoshift0.c,\n \tintrinsics/eoshift2.c, intrinsics/transpose_generic.c:"}, {"sha": "eb805c36f088a76b31d678b2f185846f4bc9fbf1", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067a5735c5236147708d701c247a8bee38c06a8b/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067a5735c5236147708d701c247a8bee38c06a8b/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=067a5735c5236147708d701c247a8bee38c06a8b", "patch": "@@ -188,61 +188,60 @@ tanhf(float x)\n #ifndef HAVE_NEXTAFTERF\n /* This is a portable implementation of nextafterf that is intended to be\n    independent of the floating point format or its in memory representation.\n-   This implementation skips denormalized values, for example returning\n-   FLT_MIN as the next value after zero, as many target's frexpf, scalbnf\n-   and ldexpf functions don't work as expected with denormalized values.  */\n+   This implementation works correctly with denormalized values.  */\n float\n nextafterf(float x, float y)\n {\n-  int origexp, newexp;\n+  /* This variable is marked volatile to avoid excess precision problems\n+     on some platforms, including IA-32.  */\n+  volatile float delta;\n+  float absx, denorm_min;\n \n   if (isnan(x) || isnan(y))\n-    return x+y;\n+    return x + y;\n   if (x == y)\n     return x;\n \n-  if (x == 0.0f)\n-    return y > 0.0f ? FLT_MIN : -FLT_MIN;\n+  /* absx = fabsf (x);  */\n+  absx = (x < 0.0) ? -x : x;\n \n-  frexpf(x, &origexp);\n-  if (x >= 0.0)\n-    {\n-      if (y > x)\n-\t{\n-\t  if (x < FLT_MIN)\n-\t    return FLT_MIN;\n-\t  return x + scalbnf(FLT_EPSILON, origexp-1);\n-\t}\n-      else if (x > FLT_MIN)\n-\t{\n-\t  float temp = x - scalbnf(FLT_EPSILON, origexp-1);\n-\t  frexpf(temp, &newexp);\n-\t  if (newexp == origexp)\n-\t    return temp;\n-\t  return x - scalbnf(FLT_EPSILON, origexp-2);\n-\t}\n-      else\n-\treturn 0.0f;\n-    }\n+  /* __FLT_DENORM_MIN__ is non-zero iff the target supports denormals.  */\n+  if (__FLT_DENORM_MIN__ == 0.0f)\n+    denorm_min = __FLT_MIN__;\n+  else\n+    denorm_min = __FLT_DENORM_MIN__;\n+\n+  if (absx < __FLT_MIN__)\n+    delta = denorm_min;\n   else\n     {\n-      if (y < x)\n-\t{\n-\t  if (x > -FLT_MIN)\n-\t    return -FLT_MIN;\n-\t  return x - scalbnf(FLT_EPSILON, origexp-1);\n-\t}\n-      else if (x < -FLT_MIN)\n-\t{\n-\t  float temp = x + scalbnf(FLT_EPSILON, origexp-1);\n-\t  frexpf(temp, &newexp);\n-\t  if (newexp == origexp)\n-\t    return temp;\n-\t  return x + scalbnf(FLT_EPSILON, origexp-2);\n-\t}\n-      else\n-\treturn 0.0f;\n+      float frac;\n+      int exp;\n+\n+      /* Discard the fraction from x.  */\n+      frac = frexpf (absx, &exp);\n+      delta = scalbnf (0.5f, exp);\n+\n+      /* Scale x by the epsilon of the representation.  By rights we should\n+\t have been able to combine this with scalbnf, but some targets don't\n+\t get that correct with denormals.  */\n+      delta *= __FLT_EPSILON__;\n+\n+      /* If we're going to be reducing the absolute value of X, and doing so\n+\t would reduce the exponent of X, then the delta to be applied is\n+\t one exponent smaller.  */\n+      if (frac == 0.5f && (y < x) == (x > 0))\n+\tdelta *= 0.5f;\n+\n+      /* If that underflows to zero, then we're back to the minimum.  */\n+      if (delta == 0.0f)\n+\tdelta = denorm_min;\n     }\n+\n+  if (y < x)\n+    delta = -delta;\n+\n+  return x + delta;\n }\n #endif\n "}]}