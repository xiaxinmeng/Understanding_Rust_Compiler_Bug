{"sha": "514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE0YTFmMThlZWI4ZDliM2RhOTBhZTM2ZDU5MTNkZmFiZTgyMDNmZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-09-02T16:57:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T16:57:18Z"}, "message": "cvt.c (convert_pointer_to_real): Tidy.\n\n\t* cvt.c (convert_pointer_to_real): Tidy.\n\t* search.c (get_base_distance_recursive): Simplify.\n\t(get_base_distance): Likewise.\n\t* pt.c (unify): Only special-case INTEGER_TYPE if it uses template\n\tparms.\n\nFrom-SVN: r22189", "tree": {"sha": "03bc9f8fdd37b939d9adcfefdb8d3e162c7e51c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03bc9f8fdd37b939d9adcfefdb8d3e162c7e51c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/comments", "author": null, "committer": null, "parents": [{"sha": "84fec828466a8ac222055cb920e9beaeaa717329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fec828466a8ac222055cb920e9beaeaa717329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fec828466a8ac222055cb920e9beaeaa717329"}], "stats": {"total": 167, "additions": 83, "deletions": 84}, "files": [{"sha": "61921718f1e98014de569187d20fb5b1773c6302", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "patch": "@@ -1,3 +1,12 @@\n+1998-09-02  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (convert_pointer_to_real): Tidy.\n+\t* search.c (get_base_distance_recursive): Simplify.\n+\t(get_base_distance): Likewise.\n+\n+\t* pt.c (unify): Only special-case INTEGER_TYPE if it uses template\n+\tparms.\n+\n Wed Sep 02 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* lex.c (check_newline):  Call HANDLE_PRAGMA before"}, {"sha": "f2cf150a4ee94200b8c248072da8295bf4202014", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "patch": "@@ -852,7 +852,7 @@ struct lang_type\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (TYPE_BINFO_BASETYPES (NODE) ? TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES(NODE)) : 0)\n \n-/* Memoize the number of super classes (base classes) tha this node\n+/* Memoize the number of super classes (base classes) that this node\n    has.  That way we can know immediately (albeit conservatively how\n    large a multiple-inheritance matrix we need to build to find\n    derivation information.  */"}, {"sha": "edb2d5b22ad764a68a1dbe2626bd092494f0c308", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "patch": "@@ -579,21 +579,21 @@ convert_pointer_to_real (binfo, expr)\n \n   my_friendly_assert (!integer_zerop (expr), 191);\n \n+  intype = TYPE_MAIN_VARIANT (TREE_TYPE (intype));\n   if (TREE_CODE (type) == RECORD_TYPE\n-      && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE\n-      && type != TYPE_MAIN_VARIANT (TREE_TYPE (intype)))\n+      && TREE_CODE (intype) == RECORD_TYPE\n+      && type != intype)\n     {\n       tree path;\n       int distance\n-\t= get_base_distance (binfo, TYPE_MAIN_VARIANT (TREE_TYPE (intype)),\n-\t\t\t     0, &path);\n+\t= get_base_distance (binfo, intype, 0, &path);\n \n       /* This function shouldn't be called with unqualified arguments\n \t but if it is, give them an error message that they can read.  */\n       if (distance < 0)\n \t{\n \t  cp_error (\"cannot convert a pointer of type `%T' to a pointer of type `%T'\",\n-\t\t    TREE_TYPE (intype), type);\n+\t\t    intype, type);\n \n \t  if (distance == -2)\n \t    cp_error (\"because `%T' is an ambiguous base class\", type);"}, {"sha": "abb954e8def2fb1a52283c21200263718cb76ab0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "patch": "@@ -7007,7 +7007,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n \n-      if (TREE_CODE (parm) == INTEGER_TYPE)\n+      if (TREE_CODE (parm) == INTEGER_TYPE\n+\t  && TREE_CODE (TYPE_MAX_VALUE (parm)) != INTEGER_CST)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, TYPE_MIN_VALUE (parm),\n@@ -7018,12 +7019,11 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n \t    return 1;\n \t}\n-      else if (TREE_CODE (parm) == REAL_TYPE\n-\t       /* We use the TYPE_MAIN_VARIANT since we have already\n-\t\t  checked cv-qualification at the top of the\n-\t\t  function.  */\n-\t       && !comptypes (TYPE_MAIN_VARIANT (arg),\n-\t\t\t      TYPE_MAIN_VARIANT (parm), 1))\n+      /* We use the TYPE_MAIN_VARIANT since we have already\n+\t checked cv-qualification at the top of the\n+\t function.  */\n+      else if (!comptypes (TYPE_MAIN_VARIANT (arg),\n+\t\t\t   TYPE_MAIN_VARIANT (parm), 1))\n \treturn 1;\n \n       /* As far as unification is concerned, this wins.\t Later checks"}, {"sha": "c472bf04360bdebe2d544c3ea2af4b33839e264c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 61, "deletions": 71, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "patch": "@@ -93,7 +93,7 @@ static void dfs_check_overlap PROTO((tree));\n static int dfs_no_overlap_yet PROTO((tree));\n static void envelope_add_decl PROTO((tree, tree, tree *));\n static int get_base_distance_recursive\n-\tPROTO((tree, int, int, int, int *, tree *, tree, tree *,\n+\tPROTO((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n static void expand_upcast_fixups \n \tPROTO((tree, tree, tree, tree, tree, tree, tree *));\n@@ -156,8 +156,6 @@ pop_search_level (obstack)\n   return stack;\n }\n \f\n-/* Obstack used for memoizing member and member function lookup.  */\n-\n static tree _vptr_name;\n \n /* Variables for gathering statistics.  */\n@@ -177,7 +175,10 @@ static tree closed_envelopes = NULL_TREE;\n /* Get a virtual binfo that is found inside BINFO's hierarchy that is\n    the same type as the type given in PARENT.  To be optimal, we want\n    the first one that is found by going through the least number of\n-   virtual bases.  */\n+   virtual bases.\n+\n+   This uses a clever algorithm that updates *depth when we find the vbase,\n+   and cuts off other paths of search when they reach that depth.  */\n \n static tree\n get_vbase_1 (parent, binfo, depth)\n@@ -216,6 +217,9 @@ get_vbase_1 (parent, binfo, depth)\n   return rval;\n }\n \n+/* Return the shortest path to vbase PARENT within BINFO, ignoring\n+   access and ambiguity.  */\n+\n tree\n get_vbase (parent, binfo)\n      tree parent;\n@@ -292,13 +296,13 @@ get_binfo (parent, binfo, protect)\n \n static int\n get_base_distance_recursive (binfo, depth, is_private, rval,\n-\t\t\t     rval_private_ptr, new_binfo_ptr, parent, path_ptr,\n+\t\t\t     rval_private_ptr, new_binfo_ptr, parent,\n \t\t\t     protect, via_virtual_ptr, via_virtual,\n \t\t\t     current_scope_in_chain)\n      tree binfo;\n      int depth, is_private, rval;\n      int *rval_private_ptr;\n-     tree *new_binfo_ptr, parent, *path_ptr;\n+     tree *new_binfo_ptr, parent;\n      int protect, *via_virtual_ptr, via_virtual;\n      int current_scope_in_chain;\n {\n@@ -312,38 +316,42 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \n   if (BINFO_TYPE (binfo) == parent || binfo == parent)\n     {\n+      int better = 0;\n+\n       if (rval == -1)\n+\t/* This is the first time we've found parent.  */\n+\tbetter = 1;\n+      else if (tree_int_cst_equal (BINFO_OFFSET (*new_binfo_ptr),\n+\t\t\t\t   BINFO_OFFSET (binfo))\n+\t       && *via_virtual_ptr && via_virtual)\n+\t{\n+\t  /* A new path to the same vbase.  If this one has better\n+\t     access or is shorter, take it.  */\n+\n+\t  if (protect)\n+\t    better = *rval_private_ptr - is_private;\n+\t  if (better == 0)\n+\t    better = rval - depth;\n+\t}\n+      else\n+\t{\n+\t  /* Ambiguous base class.  */\n+\t  rval = depth = -2;\n+\n+\t  /* If we get an ambiguity between virtual and non-virtual base\n+\t     class, return the non-virtual in case we are ignoring\n+\t     ambiguity.  */\n+\t  better = *via_virtual_ptr - via_virtual;\n+\t}\n+\n+      if (better > 0)\n \t{\n \t  rval = depth;\n \t  *rval_private_ptr = is_private;\n \t  *new_binfo_ptr = binfo;\n \t  *via_virtual_ptr = via_virtual;\n \t}\n-      else\n-\t{\n-\t  int same_object = (tree_int_cst_equal (BINFO_OFFSET (*new_binfo_ptr),\n-\t\t\t\t\t\t BINFO_OFFSET (binfo))\n-\t\t\t     && *via_virtual_ptr && via_virtual);\n-\t\t\t     \n-\t  if (*via_virtual_ptr && via_virtual==0)\n-\t    {\n-\t      *rval_private_ptr = is_private;\n-\t      *new_binfo_ptr = binfo;\n-\t      *via_virtual_ptr = via_virtual;\n-\t    }\n-\t  else if (same_object)\n-\t    {\n-\t      if (*rval_private_ptr && ! is_private)\n-\t\t{\n-\t\t  *rval_private_ptr = is_private;\n-\t\t  *new_binfo_ptr = binfo;\n-\t\t  *via_virtual_ptr = via_virtual;\n-\t\t}\n-\t      return rval;\n-\t    }\n \n-\t  rval = -2;\n-\t}\n       return rval;\n     }\n \n@@ -356,44 +364,26 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n-      /* Find any specific instance of a virtual base, when searching with\n-\t a binfo...  */\n-      if (BINFO_MARKED (base_binfo) == 0 || TREE_CODE (parent) == TREE_VEC)\n-\t{\n-\t  int via_private\n-\t    = (protect\n-\t       && (is_private\n-\t\t   || (!TREE_VIA_PUBLIC (base_binfo)\n-\t\t       && !(TREE_VIA_PROTECTED (base_binfo)\n-\t\t\t    && current_scope_in_chain)\n-\t\t       && !is_friend (BINFO_TYPE (binfo), current_scope ()))));\n-\t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n-\t  int was;\n+      int via_private\n+\t= (protect\n+\t   && (is_private\n+\t       || (!TREE_VIA_PUBLIC (base_binfo)\n+\t\t   && !(TREE_VIA_PROTECTED (base_binfo)\n+\t\t\t&& current_scope_in_chain)\n+\t\t   && !is_friend (BINFO_TYPE (binfo), current_scope ()))));\n+      int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n \n-\t  /* When searching for a non-virtual, we cannot mark\n-\t     virtually found binfos.  */\n-\t  if (! this_virtual)\n-\t    SET_BINFO_MARKED (base_binfo);\n-\n-#define WATCH_VALUES(rval, via_private) (rval == -1 ? 3 : via_private)\n-\n-\t  was = WATCH_VALUES (rval, *via_virtual_ptr);\n-\t  rval = get_base_distance_recursive (base_binfo, depth, via_private,\n-\t\t\t\t\t      rval, rval_private_ptr,\n-\t\t\t\t\t      new_binfo_ptr, parent, path_ptr,\n-\t\t\t\t\t      protect, via_virtual_ptr,\n-\t\t\t\t\t      this_virtual,\n-\t\t\t\t\t      current_scope_in_chain);\n-\t  /* watch for updates; only update if path is good.  */\n-\t  if (path_ptr && WATCH_VALUES (rval, *via_virtual_ptr) != was)\n-\t    my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == binfo,\n-\t\t\t\t980827);\n-\t  if (rval == -2 && *via_virtual_ptr == 0)\n-\t    return rval;\n+      rval = get_base_distance_recursive (base_binfo, depth, via_private,\n+\t\t\t\t\t  rval, rval_private_ptr,\n+\t\t\t\t\t  new_binfo_ptr, parent,\n+\t\t\t\t\t  protect, via_virtual_ptr,\n+\t\t\t\t\t  this_virtual,\n+\t\t\t\t\t  current_scope_in_chain);\n \n-#undef WATCH_VALUES\n-\n-\t}\n+      /* If we've found a non-virtual, ambiguous base class, we don't need\n+\t to keep searching.  */\n+      if (rval == -2 && *via_virtual_ptr == 0)\n+\treturn rval;\n     }\n \n   return rval;\n@@ -402,7 +392,7 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n /* Return the number of levels between type PARENT and the type given\n    in BINFO, following the leftmost path to PARENT not found along a\n    virtual path, if there are no real PARENTs (all come from virtual\n-   base classes), then follow the leftmost path to PARENT.\n+   base classes), then follow the shortest public path to PARENT.\n \n    Return -1 if TYPE is not derived from PARENT.\n    Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is\n@@ -465,23 +455,23 @@ get_base_distance (parent, binfo, protect, path_ptr)\n \n   rval = get_base_distance_recursive (binfo, 0, 0, -1,\n \t\t\t\t      &rval_private, &new_binfo, parent,\n-\t\t\t\t      path_ptr, watch_access, &via_virtual, 0,\n+\t\t\t\t      watch_access, &via_virtual, 0,\n \t\t\t\t      0);\n \n-  dfs_walk (binfo, dfs_unmark, markedp);\n-\n   /* Access restrictions don't count if we found an ambiguous basetype.  */\n   if (rval == -2 && protect >= 0)\n     rval_private = 0;\n \n   if (rval && protect && rval_private)\n     return -3;\n \n-  /* find real virtual base classes.  */\n+  /* If they gave us the real vbase binfo, which isn't in the main binfo\n+     tree, deal with it.  */\n   if (rval == -1 && TREE_CODE (parent) == TREE_VEC\n       && parent == binfo_member (BINFO_TYPE (parent),\n \t\t\t\t CLASSTYPE_VBASECLASSES (type)))\n     {\n+      my_friendly_abort (980901);\n       my_friendly_assert (BINFO_INHERITANCE_CHAIN (parent) == binfo, 980827);\n       new_binfo = parent;\n       rval = 1;"}]}