{"sha": "6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzZDFlNDcxYTRkZTJhOTMzMjBkMWZjMTQ1NDliNGE0OTIyM2I5ZA==", "commit": {"author": {"name": "Stan Cox", "email": "scox@redhat.com", "date": "2003-08-08T11:30:25Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2003-08-08T11:30:25Z"}, "message": "iq2000: New port.\n\n\t* config/iq2000: New port.\n\t* config.gcc (iq2000-*-elf): Added.\n\t* doc/install.texi (Specific):  Add iq2000 description.\n\nFrom-SVN: r70245", "tree": {"sha": "7efbd7dd1513de51a841ff21faa6fd8a37df8522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7efbd7dd1513de51a841ff21faa6fd8a37df8522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/comments", "author": {"login": "stanfordcox", "id": 18171344, "node_id": "MDQ6VXNlcjE4MTcxMzQ0", "avatar_url": "https://avatars.githubusercontent.com/u/18171344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stanfordcox", "html_url": "https://github.com/stanfordcox", "followers_url": "https://api.github.com/users/stanfordcox/followers", "following_url": "https://api.github.com/users/stanfordcox/following{/other_user}", "gists_url": "https://api.github.com/users/stanfordcox/gists{/gist_id}", "starred_url": "https://api.github.com/users/stanfordcox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stanfordcox/subscriptions", "organizations_url": "https://api.github.com/users/stanfordcox/orgs", "repos_url": "https://api.github.com/users/stanfordcox/repos", "events_url": "https://api.github.com/users/stanfordcox/events{/privacy}", "received_events_url": "https://api.github.com/users/stanfordcox/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e083bea6c6985eed25a60e506e7af28548f39ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e083bea6c6985eed25a60e506e7af28548f39ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e083bea6c6985eed25a60e506e7af28548f39ec"}], "stats": {"total": 8190, "additions": 8190, "deletions": 0}, "files": [{"sha": "0645031e413216a71a84fa303b5ed0491cbe0132", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -1,3 +1,9 @@\n+2003-08-08  Stan Cox  <scox@redhat.com>\n+\n+\t* config/iq2000: New port.\n+\t* config.gcc (iq2000-*-elf): Added.\n+\t* doc/install.texi (Specific):  Add iq2000 description.\n+\n 2003-08-08  Andreas Schwab  <schwab@suse.de>\n \n \t* configure.in (gcc_cv_as_ia64_ltoffx_ldxmov_relocs): Fix quoting"}, {"sha": "0cb89384ce83faa21274bf81ae34e6dfe27a2a63", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -1296,6 +1296,13 @@ ia64*-*-hpux*)\n ip2k-*-elf)\n \ttm_file=\"elfos.h ${tm_file}\"\n \t;;\n+iq2000*-*-elf*)\n+        tm_file=\"iq2000/iq2000.h\"\n+        tmake_file=iq2000/t-iq2000\n+        out_file=iq2000/iq2000.c\n+        xm_file=iq2000/xm-iq2000.h\n+        md_file=iq2000/iq2000.md\n+        ;;\n m32r-*-elf*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n \textra_parts=\"crtinit.o crtfini.o\""}, {"sha": "fa49a82f94a88f421edf0189decae0f47c2a11a0", "filename": "gcc/config/iq2000/abi", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fabi?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,232 @@\n+\t\t\tIQ2000 ABI\n+\t\t\t=========\n+\n+Sizes and alignments\n+--------------------\n+\n+\tType\t\tSize (bytes)\tAlignment (bytes)\n+\n+\tchar\t\t1\t\t1\n+\tshort\t\t2\t\t2\n+\tint\t\t4\t\t4\n+\tunsigned\t4\t\t4\n+\tlong\t\t4\t\t4 \n+\tlong long\t8\t\t8\n+\tfloat\t\t4\t\t4\n+\tdouble\t\t8\t\t8\n+\tpointers\t4\t\t4 \n+\n+* alignment within aggregates (structs and unions) is as above, with\n+  padding added if needed\n+* aggregates have alignment equal to that of their most aligned\n+  member\n+* aggregates have sizes which are a multiple of their alignment\n+\n+\n+Floating point\n+--------------\n+\n+All emulated using IEEE floating point conventions.\n+\n+Registers\n+----------------\n+\n+%0\t\talways zero\n+%1\t\tcall clobbered\n+%2\t\treturn value\n+%3\t\treturn value\n+%4\t\targument register 1\n+%5\t\targument register 2\n+%6\t\targument register 3\n+%7\t\targument register 4\n+%8\t\targument register 5\n+%9\t\targument register 6\n+%10\t\targument register 7\n+%11\t\targument register 8\n+%12\t\tcall clobbered\n+%13\t\tcall clobbered\n+%14\t\tcall clobbered\n+%15\t\tcall clobbered\n+%16\t\tcall saved\n+%17\t\tcall saved\n+%18\t\tcall saved\n+%19\t\tcall saved\n+%20\t\tcall saved\n+%21\t\tcall saved\n+%22\t\tcall saved\n+%23\t\tcall saved\n+%24\t\tcall clobbered\n+%25\t\tcall clobbered\n+%26\t\treserved\n+%27\t\tframe ptr\n+%28\t\tglobal ptr\n+%29\t\tstack ptr\n+%30\t\treserved\n+%31 \t\treturn address\n+\n+Stack alignment\t\t8 bytes\n+\n+Structures passed\t<= 32 bits as values, else as pointers\n+\n+The IQ2000 Stack\n+---------------\n+\n+Space is allocated as needed in the stack frame for the following at compile\n+time:\n+\n+* Outgoing parameters beyond the eighth\n+\n+* All automatic arrays, automatic data aggregates, automatic\n+  scalars which must be addressable, and automatic scalars for\n+  which there is no room in registers \n+\n+* Compiler-generated temporary values (typically when there are\n+  too many for the compiler to keep them all in registers) \n+\n+Space can be allocated dynamically (at runtime) in the stack frame for the\n+following:\n+\n+* Memory allocated using the alloca() function of the C library\n+\n+Addressable automatic variables on the stack are addressed with positive\n+offsets relative to %27; dynamically allocated space is addressed with positive\n+offsets from the pointer returned by alloca().\n+\n+Stack Frame\n+-----------\n+\n+        +-----------------------+\n+\t|    Caller memory args |\n+        +-----------------------+ <-sp\n+ \t|    Return address\t|\n+\t+-----------------------+\n+\t|    Previous FP\t|\n+\t+-----------------------+\n+\t|    Saved Registers\t|\n+\t+-----------------------+\n+\t|        ...\t\t|\n+\t+-----------------------+\n+\t|    Local Variables\t|\n+\t+-----------------------+ <-fp\n+\t|    Alloca\t\t|\n+\t+-----------------------+\n+\t|        ...\t\t|\n+\t+-----------------------+\n+\t|   Parameter Word 2\t|\n+\t+-----------------------+\n+\t|   Parameter Word 1\t|\n+\t+-----------------------+ <-sp\n+\n+\n+Parameter Assignment to Registers\n+---------------------------------\n+\n+Consider the parameters in a function call as ordered from left (first\n+parameter) to right.  GR contains the number of the next available\n+general-purpose register.  STARG is the address of the next available stack\n+parameter word.\n+\n+INITIALIZE:\n+\tSet GR=r4 and STARG to point to parameter word 1.\n+\n+SCAN:\n+\tIf there are no more parameters, terminate.\n+\tOtherwise, select one of the following depending on the type\n+\tof the next parameter:\n+\n+    SIMPLE ARG:\n+\n+\tA SIMPLE ARG is one of the following:\n+\n+\t* One of the simple integer types which will fit into a\n+\t  general-purpose register,\n+\t* A pointer to an object of any type,\n+\t* A struct or union small enough to fit in a register (<= 32 bits)\n+\t* A larger struct or union, which shall be treated as a\n+\t  pointer to the object or to a copy of the object.\n+\t  (See below for when copies are made.)\n+\n+\tIf GR > r11, go to STACK.  Otherwise, load the parameter value into\n+\tgeneral-purpose register GR and advance GR to the next general-purpose\n+\tregister.  Values shorter than the register size are sign-extended or\n+\tzero-extended depending on whether they are signed or unsigned.  Then\n+\tgo to SCAN.\n+\n+    DOUBLE or LONG LONG\n+\n+\tIf GR > r10, go to STACK.  Otherwise, if GR is odd, advance GR to the\n+\tnext register.  Load the 64-bit long long or double value into register\n+\tpair GR and GR+1.  Advance GR to GR+2 and go to SCAN.\n+\n+    STACK:\n+\n+\tParameters not otherwise handled above are passed in the parameter\n+\twords of the caller's stack frame.  SIMPLE ARGs, as defined above, are\n+\tconsidered to have size and alignment equal to the size of a\n+\tgeneral-purpose register, with simple argument types shorter than this\n+\tsign- or zero-extended to this width.  Round STARG up to a multiple of\n+\tthe alignment requirement of the parameter and copy the argument\n+\tbyte-for-byte into STARG, STARG+1, ...  STARG+size-1.  Set STARG to\n+\tSTARG+size and go to SCAN.\n+\n+\n+Structure passing\n+-----------------\n+\n+As noted above, code which passes structures and unions by value is implemented\n+specially.  (In this section, \"struct\" will refer to structs and unions\n+inclusively.)  Structs small enough to fit in a register are passed by value in\n+a single register or in a stack frame slot the size of a register.  Structs\n+containing a single double or long long component are passed by value in two\n+registers or in a stack frame slot the size of two registers.  Other structs\n+are handled by passing the address of the structure.  In this case, a copy of\n+the structure will be made if necessary in order to preserve the pass-by-value\n+semantics.\n+\n+Copies of large structs are made under the following rules:\n+\n+\t\t\tANSI mode\t\t\tK&R Mode\n+\t\t\t---------\t\t\t--------\n+Normal param\t \tCallee copies if needed\t\tCaller copies\n+Varargs (...) param\tCaller copies\t\t\tCaller copies\n+\n+In the case of normal (non-varargs) large-struct parameters in ANSI mode, the\n+callee is responsible for producing the same effect as if a copy of the\n+structure were passed, preserving the pass-by-value semantics.  This may be\n+accomplished by having the callee make a copy, but in some cases the callee may\n+be able to determine that a copy is not necessary in order to produce the same\n+results.  In such cases, the callee may choose to avoid making a copy of the\n+parameter.\n+\n+\n+Varargs handling\n+----------------\n+\n+No special changes are needed for handling varargs parameters other than the\n+caller knowing that a copy is needed on struct parameters larger than a\n+register (see above).\n+\n+The varargs macros set up a register save area for the general-purpose\n+registers to be saved.  Because the save area lies between the caller and\n+callee stack frames, the saved register parameters are contiguous with\n+parameters passed on the stack.  A pointer advances from the register save area\n+into the caller's stack frame.\n+\n+\n+Function return values\n+----------------------\n+\n+\tType\t\tRegister\n+\t----\t\t--------\n+\tint\t\tr2\n+\tshort\t\tr2\n+\tlong\t\tr2\n+\tlong long\tr2-r3\n+\tfloat\t\tr2\n+\tdouble\t\tr2-r3\n+\tstruct/union\tsee below\n+\n+Structs/unions which will fit into two general-purpose registers are returned\n+in r2, or in r2-r3 if necessary.  Larger structs/unions are handled by the\n+caller passing as a \"hidden\" first argument a pointer to space allocated to\n+receive the return value."}, {"sha": "6a28074ee12f2bd716547e8586c50400f25e11ce", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,64 @@\n+/* Definitions of target machine for GNU compiler for iq2000.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA. */\n+\n+#ifndef GCC_IQ2000_PROTOS_H\n+#define GCC_IQ2000_PROTOS_H\n+\n+extern int iq2000_check_split PARAMS ((rtx, enum machine_mode));\n+extern int iq2000_reg_mode_ok_for_base_p PARAMS ((rtx, enum machine_mode, int));\n+extern int iq2000_legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n+extern const char* iq2000_fill_delay_slot PARAMS ((const char*, enum delay_type, rtx*, rtx));\n+extern const char *iq2000_move_1word PARAMS ((rtx *, rtx, int));\n+extern int iq2000_address_cost PARAMS ((rtx));\n+extern void override_options PARAMS ((void));\n+extern HOST_WIDE_INT iq2000_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n+extern void final_prescan_insn PARAMS ((rtx, rtx*, int));\n+extern HOST_WIDE_INT compute_frame_size PARAMS ((HOST_WIDE_INT));\n+extern int iq2000_initial_elimination_offset (int, int);\n+extern void iq2000_expand_prologue PARAMS ((void));\n+extern void iq2000_expand_epilogue PARAMS ((void));\n+extern void iq2000_expand_eh_return PARAMS ((rtx));\n+extern int iq2000_can_use_return_insn PARAMS ((void));\n+int function_arg_pass_by_reference PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n+int iq2000_adjust_insn_length PARAMS ((rtx, int));\n+char *iq2000_output_conditional_branch PARAMS ((rtx, rtx*, int, int, int, int));\n+extern void iq2000_init_builtins PARAMS ((void));\n+extern void iq2000_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS, int, tree, int*, int));\n+extern void print_operand_address PARAMS ((FILE*, rtx));\n+extern void print_operand PARAMS ((FILE*, rtx, int));\n+\n+#ifdef RTX_CODE\n+extern rtx gen_int_relational PARAMS ((enum rtx_code, rtx, rtx, rtx, int*));\n+extern void gen_conditional_branch PARAMS ((rtx *, enum rtx_code));\n+#endif\n+\n+#ifdef TREE_CODE\n+extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS*, tree, rtx));\n+extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n+extern struct rtx_def* function_arg PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n+extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n+extern void iq2000_va_start PARAMS ((tree, rtx));\n+extern rtx iq2000_va_arg PARAMS ((tree, tree));\n+extern rtx iq2000_function_value PARAMS ((tree, tree));\n+extern rtx iq2000_expand_builtin PARAMS ((tree, rtx, rtx,\n+\t\t\t\t\t  enum machine_mode, int));\n+#endif\n+\n+#endif /* ! GCC_IQ2000_PROTOS_H */"}, {"sha": "f9deb8aa54b01a69e220295e43aae3d4d8d41d43", "filename": "gcc/config/iq2000/iq2000.c", "status": "added", "additions": 3745, "deletions": 0, "changes": 3745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d"}, {"sha": "4f4bf39627d3eccef4a11d07db087404b0e09cc0", "filename": "gcc/config/iq2000/iq2000.h", "status": "added", "additions": 1486, "deletions": 0, "changes": 1486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,1486 @@\n+/* Definitions of target machine for GNU compiler.  \n+   Vitesse IQ2000 processors\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* Set up System V.4 (aka ELF) defaults.  */\n+#include \"svr4.h\"\n+#include \"elfos.h\"\n+\n+\f\n+/* Driver configuration.  */\n+\n+#undef SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n+  (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n+\n+/* The svr4.h LIB_SPEC with -leval and --*group tacked on */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:--start-group -lc -leval -lgcc --end-group}}\"\n+\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+\n+\f\n+/* Run-time target specifications.  */\n+\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do                                            \\\n+    {                                           \\\n+     builtin_define (\"__iq2000__\"); \\\n+     builtin_assert (\"cpu=iq2000\"); \\\n+     builtin_assert (\"machine=iq2000\"); \\\n+    }                                           \\\n+  while (0)\n+\n+\n+extern int\ttarget_flags;\n+\n+#define MASK_GPOPT         0x00000008   /* Optimize for global pointer */\n+#define MASK_EMBEDDED_DATA 0x00008000   /* Reduce RAM usage, not fast code */\n+#define MASK_UNINIT_CONST_IN_RODATA \\\n+                           0x00800000   /* Store uninitialized\n+                                           consts in rodata */\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+#define TARGET_STATS\t\t0\n+\n+\t\t\t\t\t/* for embedded systems, optimize for\n+\t\t\t\t\t   reduced RAM space instead of for\n+\t\t\t\t\t   fastest code.  */\n+#define TARGET_EMBEDDED_DATA\t(target_flags & MASK_EMBEDDED_DATA)\n+\n+#define TARGET_DEBUG_MODE\t(target_flags & 0)\n+#define TARGET_DEBUG_A_MODE\t(target_flags & 0)\n+#define TARGET_DEBUG_B_MODE\t(target_flags & 0)\n+#define TARGET_DEBUG_C_MODE\t(target_flags & 0)\n+#define TARGET_DEBUG_D_MODE\t(target_flags & 0)\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {\"no-crt0\",          0,                                               \\\n+     N_(\"No default crt0.o\") },\t\t\t\t\t \t\\\n+  {\"gpopt\",\t\t  MASK_GPOPT,\t\t\t\t\t\\\n+     N_(\"Use GP relative sdata/sbss sections\")},\t\t\t\\\n+  {\"no-gpopt\",\t\t -MASK_GPOPT,\t\t\t\t\t\\\n+     N_(\"Don't use GP relative sdata/sbss sections\")},\t\t\t\\\n+  {\"embedded-data\",\t  MASK_EMBEDDED_DATA,\t\t\t\t\\\n+     N_(\"Use ROM instead of RAM\")},\t\t\t\t\t\\\n+  {\"no-embedded-data\",\t -MASK_EMBEDDED_DATA,\t\t\t\t\\\n+     N_(\"Don't use ROM instead of RAM\")},\t\t\t\t\\\n+  {\"uninit-const-in-rodata\", MASK_UNINIT_CONST_IN_RODATA,\t\t\\\n+     N_(\"Put uninitialized constants in ROM (needs -membedded-data)\")},\t\\\n+  {\"no-uninit-const-in-rodata\", -MASK_UNINIT_CONST_IN_RODATA,\t\t\\\n+     N_(\"Don't put uninitialized constants in ROM\")},\t\t\t\\\n+  {\"\",\t\t\t  (TARGET_DEFAULT\t\t\t\t\\\n+\t\t\t   | TARGET_CPU_DEFAULT),\t\t\t\\\n+     NULL},\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Default target_flags if no switches are specified.  */\n+\n+#define TARGET_DEFAULT 0\n+\n+#ifndef TARGET_CPU_DEFAULT\n+#define TARGET_CPU_DEFAULT 0\n+#endif\n+\n+#ifndef IQ2000_ISA_DEFAULT\n+#define IQ2000_ISA_DEFAULT 1\n+#endif\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  SUBTARGET_TARGET_OPTIONS\t\t\t\t\t\t\\\n+  { \"cpu=\",\t& iq2000_cpu_string,\t\t\t\t\t\\\n+      N_(\"Specify CPU for scheduling purposes\")},\t\t\t\\\n+  { \"arch=\",    & iq2000_arch_string,                                   \\\n+      N_(\"Specify CPU for code generation purposes\")},                  \\\n+}\n+\n+/* This is meant to be redefined in the host dependent files.  */\n+#define SUBTARGET_TARGET_OPTIONS\n+\n+#define IQ2000_VERSION \"[1.0]\"\n+\n+#ifndef MACHINE_TYPE\n+#define MACHINE_TYPE \"IQ2000\"\n+#endif\n+\n+#ifndef TARGET_VERSION_INTERNAL\n+#define TARGET_VERSION_INTERNAL(STREAM)\t\t\t\t\t\\\n+  fprintf (STREAM, \" %s %s\", IQ2000_VERSION, MACHINE_TYPE)\n+#endif\n+\n+#ifndef TARGET_VERSION\n+#define TARGET_VERSION TARGET_VERSION_INTERNAL (stderr)\n+#endif\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+#define CAN_DEBUG_WITHOUT_FP\n+\f\n+/* Storage Layout.  */\n+\n+#define BITS_BIG_ENDIAN 0\n+\n+#define BYTES_BIG_ENDIAN 1 \n+\n+#define WORDS_BIG_ENDIAN 1\n+\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+\n+#define BITS_PER_UNIT 8\n+\n+#define BITS_PER_WORD 32\n+\n+#define MAX_BITS_PER_WORD 64\n+\n+#define UNITS_PER_WORD 4\n+\n+#define MIN_UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE 32\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   We promote any value smaller than SImode up to SImode.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n+    (MODE) = SImode;\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+#define PROMOTE_FUNCTION_RETURN\n+\n+#define PARM_BOUNDARY 32\n+\n+#define STACK_BOUNDARY 64\n+\n+#define FUNCTION_BOUNDARY 32\n+\n+#define BIGGEST_ALIGNMENT 64\n+\n+#undef DATA_ALIGNMENT\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+#define STRICT_ALIGNMENT 1\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+\f\n+/* Layout of Source Language Data Types.  */\n+\n+#define INT_TYPE_SIZE 32\n+\n+#define MAX_INT_TYPE_SIZE 32\n+\n+#define SHORT_TYPE_SIZE 16\n+\n+#define LONG_TYPE_SIZE 32\n+\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+\n+#define FLOAT_TYPE_SIZE 32\n+\n+#define DOUBLE_TYPE_SIZE 64\n+\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define MAX_WCHAR_TYPE_SIZE MAX_INT_TYPE_SIZE\n+\n+\f\n+/* Register Basics.  */\n+\n+/* On the IQ2000, we have 32 integer registers.  */\n+#define FIRST_PSEUDO_REGISTER 33\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1\t\t\t\\\n+}\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1\t\t\t\\\n+}\n+\n+\f\n+/* Order of allocation of registers.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31\t\\\n+}\n+\n+\f\n+/* How Values Fit in Registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\t\\\n+ ((REGNO_REG_CLASS (REGNO) == GR_REGS)\t\t\t\t\t\\\n+  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4     \t\t\\\n+  : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n+    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n+       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+#define AVOID_CCMODE_COPIES\n+\n+\f\n+/* Register Classes.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* no registers in set */\n+  GR_REGS,\t\t\t/* integer registers */\n+  ALL_REGS,\t\t\t/* all registers */\n+  LIM_REG_CLASSES\t\t/* max value + 1 */\n+};\n+\n+#define GENERAL_REGS GR_REGS\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000 },\t/* no registers */\t\\\n+  { 0xffffffff, 0x00000000 },\t/* integer registers */\t\\\n+  { 0xffffffff, 0x00000001 }\t/* all registers */\t\\\n+}\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+((REGNO) <= GP_REG_LAST + 1 ? GR_REGS : NO_REGS)\n+\n+#define BASE_REG_CLASS  (GR_REGS)\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'd' ? GR_REGS : \\\n+   (C) == 'b' ? ALL_REGS : \\\n+   (C) == 'y' ? GR_REGS : \\\n+   NO_REGS)\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)\t0\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n+  ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n+   ? (CLASS)\t\t\t\t\t\t\t\t\\\n+   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n+      ? (GR_REGS)\t\t\t\t\\\n+      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n+\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n+\t ? (GR_REGS)\t\t\t\t\\\n+\t : (CLASS))))\n+\n+#define SMALL_REGISTER_CLASSES 0\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)    \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* For IQ2000:\n+\n+   `I'\tis used for the range of constants an arithmetic insn can\n+\tactually contain (16 bits signed integers).\n+\n+   `J'\tis used for the range which is just zero (ie, $r0).\n+\n+   `K'\tis used for the range of constants a logical insn can actually\n+\tcontain (16 bit zero-extended integers).\n+\n+   `L'\tis used for the range of constants that be loaded with lui\n+\t(ie, the bottom 16 bits are zero).\n+\n+   `M'\tis used for the range of constants that take two words to load\n+\t(ie, not matched by `I', `K', and `L').\n+\n+   `N'\tis used for constants 0xffffnnnn or 0xnnnnffff\n+\n+   `O'\tis a 5 bit zero-extended integer.\n+*/\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n+   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n+   : (C) == 'K' ? ((unsigned HOST_WIDE_INT) (VALUE) < 0x10000)\t\t\\\n+   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n+\t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n+\t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n+   : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\\\n+\t\t   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\\\n+\t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n+\t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n+\t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n+   : (C) == 'N' ? ((((VALUE) & 0xffff) == 0xffff)\t\t\t\\\n+\t\t   || (((VALUE) & 0xffff0000) == 0xffff0000))\t\t\\\n+   : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x20) < 0x40)\t\\\n+   : 0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'G'\t\t\t\t\t\t\t\t\\\n+   && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n+\n+/* `R' is for memory references which take 1 word for the instruction.  */\n+\n+#define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n+  (((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n+   : FALSE)\n+\n+\f\n+/* Basic Stack Layout.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+  (current_function_outgoing_args_size)\n+\n+/* Use the default value zero.  */\n+/* #define STACK_POINTER_OFFSET 0 */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* The return address for the current frame is in r31 if this is a leaf\n+   function.  Otherwise, it is on the stack.  It is at a variable offset\n+   from sp/fp/ap, so we define a fake hard register rap which is a\n+   pointer to the return address on the stack.  This always gets eliminated\n+   during reload to be either the frame pointer or the stack pointer plus\n+   an offset.  */\n+\n+#define RETURN_ADDR_RTX(count, frame)                                   \\\n+  (((count) == 0)                                                       \\\n+   ? (leaf_function_p ()                                                \\\n+      ? gen_rtx_REG (Pmode, GP_REG_FIRST + 31)                          \\\n+      : gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode,                         \\\n+                                         RETURN_ADDRESS_POINTER_REGNUM))) \\\n+    : (rtx) 0)\n+\n+/* Before the prologue, RA lives in r31.  */\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + 31)\n+\n+\f\n+/* Register That Address the Stack Frame.  */\n+\n+#define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)\n+\n+#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 1)\n+\n+#define HARD_FRAME_POINTER_REGNUM \\\n+  (GP_REG_FIRST + 27)\n+\n+#define ARG_POINTER_REGNUM GP_REG_FIRST\n+\n+#define RETURN_ADDRESS_POINTER_REGNUM RAP_REG_NUM\n+\n+#define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n+\n+\f\n+/* Eliminating the Frame Pointer and the Arg Pointer.  */\n+\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},\t\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 31},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+\n+/* We can always eliminate to the frame pointer.  We can eliminate to the \n+   stack pointer unless a frame pointer is needed.  */\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+  (((FROM) == RETURN_ADDRESS_POINTER_REGNUM && (! leaf_function_p ()\t\\\n+   || (TO == GP_REG_FIRST + 31 && leaf_function_p)))   \t\t\t\\\n+  || ((FROM) != RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n+   && ((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t\\\n+   || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed))))\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n+        (OFFSET) = iq2000_initial_elimination_offset ((FROM), (TO))\n+\f\n+/* Passing Function Arguments on the Stack.  */\n+\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* #define PUSH_ROUNDING(BYTES) 0 */\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define REG_PARM_STACK_SPACE(FNDECL) 0\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+\f\n+/* Function Arguments in Registers.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg( &CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n+  ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+\n+#define MAX_ARGS_IN_REGISTERS 8\n+\n+typedef struct iq2000_args {\n+  int gp_reg_found;\t\t/* whether a gp register was found yet */\n+  unsigned int arg_number;\t/* argument number */\n+  unsigned int arg_words;\t/* # total words the arguments take */\n+  unsigned int fp_arg_words;\t/* # words for FP args (IQ2000_EABI only) */\n+  int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n+  int fp_code;\t\t\t/* Mode of FP arguments */\n+  unsigned int num_adjusts;\t/* number of adjustments made */\n+\t\t\t\t/* Adjustments made to args pass in regs.  */\n+  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];\n+} CUMULATIVE_ARGS;\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\t\\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\t\t\t\t\\\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n+   ? upward\t\t\t\t\t\t\t\t\\\n+   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n+       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n+       : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n+\t  && (GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n+      ? downward : upward))\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+  (((TYPE) != 0)\t\t\t\t\t\t\t\\\n+\t? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n+\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t\t: TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n+\t: ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\t\\\n+\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t\t: GET_MODE_ALIGNMENT(MODE)))\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n+  (((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST))\t\t\t\n+\n+\f\n+/* How Scalar Function Values are Returned.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\tiq2000_function_value (VALTYPE, FUNC)\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  gen_rtx (REG,\t\t\t\t\t\t\t\t\\\n+\t   ((GET_MODE_CLASS (MODE) != MODE_INT\t\t\t\t\\\n+\t     || GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+\t    ? (MODE)\t\t\t\t\t\t\t\\\n+\t    : SImode),\t\t\t\t\t\t\t\\\n+\t   GP_RETURN)\n+\n+/* On the IQ2000, R2 and R3 are the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN)\n+\n+\f\n+/* How Large Values are Returned.  */\n+\n+#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t \\\n+  (((int_size_in_bytes (TYPE)\t\t\t\t\t\t \\\n+       > (2 * UNITS_PER_WORD)) \t\t\t\t\t\t \\\n+      || (int_size_in_bytes (TYPE) == -1)))\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+#define STRUCT_VALUE 0\n+\n+\f\n+/* Function Entry and Exit.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+\f\n+/* Generating Code for Profiling.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set\\tnoreorder\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set\\tnoat\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tmove\\t%s,%s\\t\\t# save current return address\\n\",\t\\\n+\t   reg_names[GP_REG_FIRST + 1], reg_names[GP_REG_FIRST + 31]);\t\\\n+  fprintf (FILE, \"\\tjal\\t_mcount\\n\");\t\t\t\t\t\\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   \"\\t%s\\t%s,%s,%d\\t\\t# _mcount pops 2 words from  stack\\n\",\t\\\n+\t   \"subu\",\t\t\t\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t   Pmode == DImode ? 16 : 8);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set\\treorder\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set\\tat\\n\");\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Implementing the Varargs Macros.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+  iq2000_setup_incoming_varargs (CUM,MODE,TYPE,&PRETEND_SIZE,NO_RTL);\n+\n+#define STRICT_ARGUMENT_NAMING  1\n+\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = ptr_type_node\n+\n+#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n+  iq2000_va_start (valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  iq2000_va_arg (valist, type)\n+\n+\f\n+/* Trampolines for Nested Functions.  */\n+\n+/* A C statement to output, on the stream FILE, assembler code for a\n+   block of data that contains the constant parts of a trampoline.\n+   This code should not include a label--the label is taken care of\n+   automatically.  */\n+\n+#define TRAMPOLINE_TEMPLATE(STREAM)\t\t\t\t\t \\\n+{\t\t\t\t\t\t\t\t\t \\\n+  fprintf (STREAM, \"\\t.word\\t0x03e00821\\t\\t# move   $1,$31\\n\");\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t0x04110001\\t\\t# bgezal $0,.+8\\n\");\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# nop\\n\");\t\t\t\\\n+  if (Pmode == DImode)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0xdfe30014\\t\\t# ld     $3,20($31)\\n\");\t\\\n+      fprintf (STREAM, \"\\t.word\\t0xdfe2001c\\t\\t# ld     $2,28($31)\\n\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x8fe30014\\t\\t# lw     $3,20($31)\\n\");\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x8fe20018\\t\\t# lw     $2,24($31)\\n\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t0x0060c821\\t\\t# move   $25,$3 (abicalls)\\n\"); \\\n+  fprintf (STREAM, \"\\t.word\\t0x00600008\\t\\t# jr     $3\\n\");\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t0x0020f821\\t\\t# move   $31,$1\\n\");\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <function address>\\n\"); \\\n+  fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <static chain value>\\n\"); \\\n+}\n+\n+#define TRAMPOLINE_SIZE (40)\n+\n+#define TRAMPOLINE_ALIGNMENT 32\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t    \\\n+{\t\t\t\t\t\t\t\t\t    \\\n+  rtx addr = ADDR;\t\t\t\t\t\t\t    \\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 32)), FUNC); \\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 36)), CHAIN);\\\n+}\n+\n+\f\n+/* Implicit Calls to Library Routines.  */\n+\n+#define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\f\n+/* Addressing Modes.  */\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n+    || (GET_CODE (X) == CONST)))\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (iq2000_legitimate_address_p (MODE, X, 1))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (iq2000_legitimate_address_p (MODE, X, 0))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+#endif\n+\n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n+\n+/* For the IQ2000, transform:\n+\n+\tmemory(X + <large int>)\n+   into:\n+\tY = <large int> & ~0x7fff;\n+\tZ = X + Y\n+\tmemory (Z + (<large int> & 0x7fff));\n+*/\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  register rtx xinsn = (X);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      GO_PRINTF (\"\\n========== LEGITIMIZE_ADDRESS\\n\");\t\t\t\\\n+      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (iq2000_check_split (X, MODE))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      X = gen_rtx_LO_SUM (Pmode,\t\t\t\t\t\\\n+\t\t\t  copy_to_mode_reg (Pmode,\t\t\t\\\n+\t\t\t\t\t    gen_rtx (HIGH, Pmode, X)),\t\\\n+\t\t\t  X);\t\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n+      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\\\n+      register enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\\\n+      register enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (code0 != REG && code1 == REG)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\t  xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\t  code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n+\t  code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE)\t\t\\\n+\t  && code1 == CONST_INT && !SMALL_INT (xplus1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  rtx int_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t  rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  emit_move_insn (int_reg,\t\t\t\t\t\\\n+\t\t\t  GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\t\t\t\t\\\n+\t\t\t\t  ptr_reg,\t\t\t\t\\\n+\t\t\t\t  gen_rtx_PLUS (Pmode, xplus0, int_reg))); \\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  X = plus_constant (ptr_reg, INTVAL (xplus1) & 0x7fff);\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n+    GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n+}\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) {}\n+\n+#define LEGITIMATE_CONSTANT_P(X) (1)\n+\n+\f\n+/* Describing Relative Costs of Operations.  */\n+\n+#define CONST_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx offset = const0_rtx;\t\t\t\t\t\t\\\n+      rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n+\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (symref) != SYMBOL_REF)\t\t\t\t\\\n+\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* let's be paranoid....  */\t\t\t\t\t\\\n+      if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\t\t\\\n+\treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (SYMBOL_REF_FLAG (X) ? 1 : 2);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx high, low;\t\t\t\t\t\t\t\\\n+      split_double (X, &high, &low);\t\t\t\t\t\\\n+      return COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))\t\\\n+\t\t\t     || low == CONST0_RTX (GET_MODE (low)))\t\\\n+\t\t\t    ? 2 : 4);\t\t\t\t\t\\\n+    }\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int num_words = (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ? 2 : 1; \\\n+      if (simple_memory_operand (X, GET_MODE (X)))\t\t\t\\\n+\treturn COSTS_N_INSNS (num_words);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (2*num_words);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case FFS:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (6);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case NOT:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (GET_MODE (X) == DImode && 2); \t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case AND:\t\t\t\t\t\t\t\t\\\n+  case IOR:\t\t\t\t\t\t\t\t\\\n+  case XOR:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 4 : 12); \\\n+\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ABS:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+      if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t   return COSTS_N_INSNS (6);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (xmode == DImode)\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case NEG:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+      return 4;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+      if (xmode == SFmode)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (7);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (xmode == DFmode)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (8);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+      if (xmode == SFmode)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (23);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (xmode == DFmode)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (36);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (69);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\n+\n+#define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : iq2000_address_cost (ADDR))\n+\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t2\n+\n+#define MEMORY_MOVE_COST(MODE,CLASS,TO_P)\t\\\n+  (TO_P ? 2 : 16)\n+\n+#define BRANCH_COST 2\n+\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define NO_FUNCTION_CSE 1\n+\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n+  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n+    (COST) = 0; /* Anti or output dependence.  */\n+\n+\f\n+/* Dividing the output into sections.  */\n+\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\t/* instructions */\n+\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\t/* large data */\n+\n+\f\n+/* The Overall Framework of an Assembler File.  */\n+\n+#define ASM_COMMENT_START \" #\"\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+\f\n+/* Output and Generation of Labels.  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM,PREFIX,NUM)\t\t\t\\\n+  fprintf (STREAM, \"%s%s%d:\\n\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))\n+\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n+\n+\f\n+/* Output of Assembler Instructions.  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+ \"%0\",   \"%1\",   \"%2\",   \"%3\",   \"%4\",   \"%5\",   \"%6\",   \"%7\",\t\t\\\n+ \"%8\",   \"%9\",   \"%10\",  \"%11\",  \"%12\",  \"%13\",  \"%14\",  \"%15\",\t\t\\\n+ \"%16\",  \"%17\",  \"%18\",  \"%19\",  \"%20\",  \"%21\",  \"%22\",  \"%23\",\t\t\\\n+ \"%24\",  \"%25\",  \"%26\",  \"%27\",  \"%28\",  \"%29\",  \"%30\",  \"%31\",  \"%rap\"\t\\\n+};\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"%0\",\t 0 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%1\",\t 1 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%2\",\t 2 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%3\",\t 3 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%4\",\t 4 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%5\",\t 5 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%6\",\t 6 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%7\",\t 7 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%8\",\t 8 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%9\",\t 9 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%10\",\t10 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%11\",\t11 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%12\",\t12 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%13\",\t13 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%14\",\t14 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%15\",\t15 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%16\",\t16 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%17\",\t17 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%18\",\t18 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%19\",\t19 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%20\",\t20 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%21\",\t21 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%22\",\t22 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%23\",\t23 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%24\",\t24 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%25\",\t25 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%26\",\t26 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%27\",\t27 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%28\",\t28 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%29\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%30\",\t27 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%31\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"%rap\",\t32 + GP_REG_FIRST },\t\t\t\t\t\\\n+}\n+\n+/* Check if the current insn needs a nop in front of it\n+   because of load delays, and also update the delay slot statistics.  */\n+\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\t\t\\\n+  final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+/* See iq2000.c for the IQ2000 specific codes.  */\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) iq2000_print_operand_punct[CODE]\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+#define DBR_OUTPUT_SEQEND(STREAM)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    dslots_jump_filled++;\t\t\t\t\t\t\\\n+    fputs (\"\\n\", STREAM);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define LOCAL_LABEL_PREFIX\t\"$\"\n+\n+#define USER_LABEL_PREFIX\t\"\"\n+\n+\f\n+/* Output of dispatch tables.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n+\t   Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t   LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\t\\\n+} while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n+\t   Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t   LOCAL_LABEL_PREFIX,\t\t\t\t\t\t\\\n+\t   VALUE)\n+\n+\f\n+/* Assembler Commands for Alignment.  */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(STREAM,SIZE)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.space\\t%u\\n\", (SIZE))\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG)\t\t\t\t\t\\\n+  if ((LOG) != 0)                       \t\t\t\t\\\n+    fprintf (STREAM, \"\\t.balign %d\\n\", 1<<(LOG))\n+\n+\f\n+/* Macros Affecting all Debug Formats.  */\n+\n+#define DEBUGGER_AUTO_OFFSET(X)  \\\n+  iq2000_debugger_offset (X, (HOST_WIDE_INT) 0)\n+\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X)  \\\n+  iq2000_debugger_offset (X, (HOST_WIDE_INT) OFFSET)\n+\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+#define DWARF2_DEBUGGING_INFO 1\n+\n+\f\n+/* Miscellaneous Parameters.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n+  {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n+  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG }}, \\\n+  {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n+  {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n+  {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n+\t\t\t\t  LTU, LEU }},\t\t\t\t\\\n+  {\"pc_or_label_operand\",\t{ PC, LABEL_REF }},\t\t\t\\\n+  {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG}},\t\\\n+  {\"move_operand\", \t\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n+\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n+\t\t\t\t  REG, MEM}},\t\t\t\t\\\n+  {\"power_of_2_operand\",\t{ CONST_INT }},\n+\n+#define CASE_VECTOR_MODE SImode\n+\n+#define CASE_VECTOR_PC_RELATIVE 0\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+#define MOVE_MAX 4\n+\n+#define MAX_MOVE_MAX 8\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE SImode\n+\n+/* Standard GCC variables that we reference.  */\n+\n+extern char\tcall_used_regs[];\n+\n+/* IQ2000 external variables defined in iq2000.c.  */\n+\n+/* Comparison type.  */\n+enum cmp_type\n+{\n+  CMP_SI,\t\t\t\t/* compare four byte integers */\n+  CMP_DI,\t\t\t\t/* compare eight byte integers */\n+  CMP_SF,\t\t\t\t/* compare single precision floats */\n+  CMP_DF,\t\t\t\t/* compare double precision floats */\n+  CMP_MAX\t\t\t\t/* max comparison type */\n+};\n+\n+/* Types of delay slot.  */\n+enum delay_type\n+{\n+  DELAY_NONE,\t\t\t\t/* no delay slot */\n+  DELAY_LOAD,\t\t\t\t/* load from memory delay */\n+  DELAY_FCMP\t\t\t\t/* delay after doing c.<xx>.{d,s} */\n+};\n+\n+/* Which processor to schedule for.  */\n+\n+enum processor_type\n+{\n+  PROCESSOR_DEFAULT,\n+  PROCESSOR_IQ2000,\n+  PROCESSOR_IQ10\n+};\n+\n+/* Recast the cpu class to be the cpu attribute.  */\n+#define iq2000_cpu_attr ((enum attr_cpu)iq2000_tune)\n+\n+extern char iq2000_print_operand_punct[];\t/* print_operand punctuation chars */\n+extern int num_source_filenames;\t/* current .file # */\n+extern int iq2000_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n+extern struct rtx_def *branch_cmp[2];\t/* operands for compare */\n+extern enum cmp_type branch_type;\t/* what type of branch to use */\n+extern enum processor_type iq2000_arch;   /* which cpu to codegen for */\n+extern enum processor_type iq2000_tune;   /* which cpu to schedule for */\n+extern int iq2000_isa;\t\t\t/* architectural level */\n+extern const char *iq2000_cpu_string;\t/* for -mcpu=<xxx> */\n+extern const char *iq2000_arch_string;    /* for -march=<xxx> */\n+extern int dslots_load_total;\t\t/* total # load related delay slots */\n+extern int dslots_load_filled;\t\t/* # filled load delay slots */\n+extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n+extern int dslots_jump_filled;\t\t/* # filled jump delay slots */\n+extern int dslots_number_nops;\t\t/* # of nops needed by previous insn */\n+extern int num_refs[3];\t\t\t/* # 1/2/3 word references */\n+extern struct rtx_def *iq2000_load_reg;\t/* register to check for load delay */\n+extern struct rtx_def *iq2000_load_reg2;\t/* 2nd reg to check for load delay */\n+extern struct rtx_def *iq2000_load_reg3;\t/* 3rd reg to check for load delay */\n+extern struct rtx_def *iq2000_load_reg4;\t/* 4th reg to check for load delay */\n+\n+/* Functions to change what output section we are using.  */\n+extern void\t\trdata_section PARAMS ((void));\n+extern void\t\tsdata_section PARAMS ((void));\n+extern void\t\tsbss_section PARAMS ((void));\n+\n+#define BITMASK_UPPER16\t((unsigned long)0xffff << 16)\t/* 0xffff0000 */\n+#define BITMASK_LOWER16\t((unsigned long)0xffff)\t\t/* 0x0000ffff */\n+\n+\f\n+#define GENERATE_BRANCHLIKELY  (ISA_HAS_BRANCHLIKELY)\n+\n+/* Macros to decide whether certain features are available or not,\n+   depending on the instruction set architecture level.  */\n+\n+#define BRANCH_LIKELY_P()\tGENERATE_BRANCHLIKELY\n+\n+/* ISA has branch likely instructions.  */\n+#define ISA_HAS_BRANCHLIKELY\t(iq2000_isa == 1)\n+\n+\f\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{march=iq2000: -m2000} %{march=iq10: -m10} %{!march=*: -m2000}\"\n+\n+\f\n+/* The mapping from gcc register number to DWARF 2 CFA column number.\n+   This mapping does not allow for tracking register 0, since\n+   register 0 is fixed.  */\n+#define DWARF_FRAME_REGNUM(REG)\t\t\t\t\\\n+  (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN : REG)\n+\n+/* The DWARF 2 CFA column which tracks the return address.  */\n+#define DWARF_FRAME_RETURN_COLUMN ( GP_REG_FIRST + 26)\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + GP_ARG_FIRST : INVALID_REGNUM)\n+\n+/* The EH_RETURN_STACKADJ_RTX macro returns RTL which describes the\n+   location used to store the amount to adjust the stack.  This is\n+   usually a register that is available from end of the function's body\n+   to the end of the epilogue. Thus, this cannot be a register used as a\n+   temporary by the epilogue.\n+\n+   This must be an integer register.  */\n+#define EH_RETURN_STACKADJ_REGNO        3\n+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, EH_RETURN_STACKADJ_REGNO)\n+\n+/* The EH_RETURN_HANDLER_RTX macro returns RTL which describes the\n+   location used to store the address the processor should jump to\n+   catch exception.  This is usually a registers that is available from\n+   end of the function's body to the end of the epilogue. Thus, this\n+   cannot be a register used as a temporary by the epilogue.\n+\n+   This must be an address register.  */\n+#define EH_RETURN_HANDLER_REGNO         26\n+#define EH_RETURN_HANDLER_RTX           \\\n+        gen_rtx_REG (Pmode, EH_RETURN_HANDLER_REGNO)\n+\n+/* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n+#define DWARF_CIE_DATA_ALIGNMENT 4\n+\n+/* For IQ2000, width of a floating point register.  */\n+#define UNITS_PER_FPREG 4\n+\n+/* Force right-alignment for small varargs in 32 bit little_endian mode */\n+\n+#define PAD_VARARGS_DOWN !BYTES_BIG_ENDIAN\n+\n+/* Internal macros to classify a register number as to whether it's a\n+   general purpose register, a floating point register, a\n+   multiply/divide register, or a status register.  */\n+\n+#define GP_REG_FIRST 0\n+#define GP_REG_LAST  31\n+#define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)\n+\n+#define RAP_REG_NUM   32\n+#define AT_REGNUM\t(GP_REG_FIRST + 1)\n+\n+#define GP_REG_P(REGNO)\t\\\n+  ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+\n+/* IQ2000 registers used in prologue/epilogue code when the stack frame\n+   is larger than 32K bytes.  These registers must come from the\n+   scratch register set, and not used for passing and returning\n+   arguments and any other information used in the calling sequence.  */\n+\n+#define IQ2000_TEMP1_REGNUM (GP_REG_FIRST + 12)\n+#define IQ2000_TEMP2_REGNUM (GP_REG_FIRST + 13)\n+\n+/* This macro is used later on in the file.  */\n+#define GR_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n+  ((CLASS) == GR_REGS)\n+\n+#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n+#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)\n+\n+/* Certain machines have the property that some registers cannot be\n+   copied to some other registers without using memory.  Define this\n+   macro on those machines to be a C expression that is non-zero if\n+   objects of mode MODE in registers of CLASS1 can only be copied to\n+   registers of class CLASS2 by storing a register of CLASS1 into\n+   memory and loading that memory location into a register of CLASS2.\n+\n+   Do not define this macro if its value would always be zero.  */\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_UNITS(mode, size)\t\t\t\t\t\t\\\n+  ((GET_MODE_SIZE (mode) + (size) - 1) / (size))\n+\n+/* If defined, gives a class of registers that cannot be used as the\n+   operand of a SUBREG that changes the mode of the object illegally.  */\n+\n+#define CLASS_CANNOT_CHANGE_MODE 0\n+\n+/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n+\n+#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+\n+/* Make sure 4 words are always allocated on the stack.  */\n+\n+#ifndef STACK_ARGS_ADJUST\n+#define STACK_ARGS_ADJUST(SIZE)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (SIZE.constant < 4 * UNITS_PER_WORD)\t\t\t\t\\\n+    SIZE.constant = 4 * UNITS_PER_WORD;\t\t\t\t\t\\\n+}\n+#endif\n+\n+\f\n+/* Symbolic macros for the registers used to return integer and floating\n+   point values.  */\n+\n+#define GP_RETURN (GP_REG_FIRST + 2)\n+\n+/* Symbolic macros for the first/last argument registers.  */\n+\n+#define GP_ARG_FIRST (GP_REG_FIRST + 4)\n+#define GP_ARG_LAST  (GP_REG_FIRST + 11)\n+\n+#define MAX_ARGS_IN_REGISTERS\t8\n+\n+\f\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n+\n+#define MUST_SAVE_REGISTER(regno) \\\n+ ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\t\\\n+  || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n+  || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n+\n+/* ALIGN FRAMES on double word boundaries */\n+#ifndef IQ2000_STACK_ALIGN\n+#define IQ2000_STACK_ALIGN(LOC) (((LOC) + 7) & ~7)\n+#endif\n+\n+\f\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   These definitions are NOT overridden anywhere.  */\n+\n+#define BASE_REG_P(regno, mode)\t\t\t\t\t\\\n+  (GP_REG_P (regno))\n+\n+#define GP_REG_OR_PSEUDO_STRICT_P(regno, mode)\t\t\t\t    \\\n+  BASE_REG_P((regno < FIRST_PSEUDO_REGISTER) ? regno : reg_renumber[regno], \\\n+\t     (mode))\n+\n+#define GP_REG_OR_PSEUDO_NONSTRICT_P(regno, mode) \\\n+  (((regno) >= FIRST_PSEUDO_REGISTER) || (BASE_REG_P ((regno), (mode))))\n+\n+#define REGNO_MODE_OK_FOR_BASE_P(regno, mode) \\\n+  GP_REG_OR_PSEUDO_STRICT_P ((regno), (mode))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects them all.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Some source files that are used after register allocation\n+   need to be strict.  */\n+\n+#ifndef REG_OK_STRICT\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  iq2000_reg_mode_ok_for_base_p (X, MODE, 0)\n+#else\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  iq2000_reg_mode_ok_for_base_p (X, MODE, 1)\n+#endif\n+\n+#if 1\n+#define GO_PRINTF(x)\tfprintf(stderr, (x))\n+#define GO_PRINTF2(x,y)\tfprintf(stderr, (x), (y))\n+#define GO_DEBUG_RTX(x) debug_rtx(x)\n+\n+#else\n+#define GO_PRINTF(x)\n+#define GO_PRINTF2(x,y)\n+#define GO_DEBUG_RTX(x)\n+#endif\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+#define SLOW_ZERO_EXTEND\n+\n+/* If defined, modifies the length assigned to instruction INSN as a\n+   function of the context in which it is used.  LENGTH is an lvalue\n+   that contains the initially computed length of the insn and should\n+   be updated with the correct length of the insn.  */\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n+  ((LENGTH) = iq2000_adjust_insn_length ((INSN), (LENGTH)))\n+\n+\f\n+/* A list of predicates that do special things with modes, and so\n+   should not elicit warnings for VOIDmode match_operand.  */\n+\n+#define SPECIAL_MODE_PREDICATES \\\n+  \"pc_or_label_operand\",\n+\n+\f\n+\n+\n+/* How to tell the debugger about changes of source files.  */\n+\n+#ifndef SET_FILE_NUMBER\n+#define SET_FILE_NUMBER() ++num_source_filenames\n+#endif\n+\n+/* This is how to output a note the debugger telling it the line number\n+   to which the following sequence of instructions corresponds.  */\n+\n+#ifndef LABEL_AFTER_LOC\n+#define LABEL_AFTER_LOC(STREAM)\n+#endif\n+\n+/* Handle certain cpp directives used in header files on sysV.  */\n+#define SCCS_DIRECTIVE\n+\n+\f\n+/* Default to -G 8 */\n+#ifndef IQ2000_DEFAULT_GVALUE\n+#define IQ2000_DEFAULT_GVALUE 8\n+#endif\n+\n+#define SDATA_SECTION_ASM_OP\t\"\\t.sdata\"\t/* small data */\n+\n+/* Given a decl node or constant node, choose the section to output it in\n+   and select that section.  */\n+\n+#undef  TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION  iq2000_select_section\n+\f\n+/* See iq2000_expand_prologue's use of loadgp for when this should be\n+   true.  */\n+\n+#define DONT_ACCESS_GBLS_AFTER_EPILOGUE 0\n+\f\n+\n+#ifndef INIT_SUBTARGET_OPTABS\n+#define INIT_SUBTARGET_OPTABS\n+#endif\n+\n+enum iq2000_builtins\n+{\n+  IQ2000_BUILTIN_ADO16,\n+  IQ2000_BUILTIN_CFC0,\n+  IQ2000_BUILTIN_CFC1,\n+  IQ2000_BUILTIN_CFC2,\n+  IQ2000_BUILTIN_CFC3,\n+  IQ2000_BUILTIN_CHKHDR,\n+  IQ2000_BUILTIN_CTC0,\n+  IQ2000_BUILTIN_CTC1,\n+  IQ2000_BUILTIN_CTC2,\n+  IQ2000_BUILTIN_CTC3,\n+  IQ2000_BUILTIN_LU,\n+  IQ2000_BUILTIN_LUC32L,\n+  IQ2000_BUILTIN_LUC64,\n+  IQ2000_BUILTIN_LUC64L,\n+  IQ2000_BUILTIN_LUK,\n+  IQ2000_BUILTIN_LULCK,\n+  IQ2000_BUILTIN_LUM32,\n+  IQ2000_BUILTIN_LUM32L,\n+  IQ2000_BUILTIN_LUM64,\n+  IQ2000_BUILTIN_LUM64L,\n+  IQ2000_BUILTIN_LUR,\n+  IQ2000_BUILTIN_LURL,\n+  IQ2000_BUILTIN_MFC0,\n+  IQ2000_BUILTIN_MFC1,\n+  IQ2000_BUILTIN_MFC2,\n+  IQ2000_BUILTIN_MFC3,\n+  IQ2000_BUILTIN_MRGB,\n+  IQ2000_BUILTIN_MTC0,\n+  IQ2000_BUILTIN_MTC1,\n+  IQ2000_BUILTIN_MTC2,\n+  IQ2000_BUILTIN_MTC3,\n+  IQ2000_BUILTIN_PKRL,\n+  IQ2000_BUILTIN_RAM,\n+  IQ2000_BUILTIN_RB,\n+  IQ2000_BUILTIN_RX,\n+  IQ2000_BUILTIN_SRRD,\n+  IQ2000_BUILTIN_SRRDL,\n+  IQ2000_BUILTIN_SRULC,\n+  IQ2000_BUILTIN_SRULCK,\n+  IQ2000_BUILTIN_SRWR,\n+  IQ2000_BUILTIN_SRWRU,\n+  IQ2000_BUILTIN_TRAPQF,\n+  IQ2000_BUILTIN_TRAPQFL,\n+  IQ2000_BUILTIN_TRAPQN,\n+  IQ2000_BUILTIN_TRAPQNE,\n+  IQ2000_BUILTIN_TRAPRE,\n+  IQ2000_BUILTIN_TRAPREL,\n+  IQ2000_BUILTIN_WB,\n+  IQ2000_BUILTIN_WBR,\n+  IQ2000_BUILTIN_WBU,\n+  IQ2000_BUILTIN_WX,\n+  IQ2000_BUILTIN_SYSCALL\n+};"}, {"sha": "de493b3850a0aa243c882e1eac3e69e7a136d1c3", "filename": "gcc/config/iq2000/iq2000.md", "status": "added", "additions": 2553, "deletions": 0, "changes": 2553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,2553 @@\n+;;  iq2000.md\t     Machine Description for Vitesse IQ2000 processors\n+;;  Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; ??? Currently does not have define_function_unit support for the R8000.\n+;; Must include new entries for fmadd in addition to existing entries.\n+\n+(define_constants\n+  [(UNSPEC_ADO16 0)\n+   (UNSPEC_RAM\t1)\n+   (UNSPEC_CHKHDR 2)\n+   (UNSPEC_PKRL\t3)\n+   (UNSPEC_CFC0\t4)\n+   (UNSPEC_CFC1\t5)\n+   (UNSPEC_CFC2\t6)\n+   (UNSPEC_CFC3\t7)\n+   (UNSPEC_CTC0\t8)\n+   (UNSPEC_CTC1\t9)\n+   (UNSPEC_CTC2\t10)\n+   (UNSPEC_CTC3\t11)\n+   (UNSPEC_MFC0\t12)\n+   (UNSPEC_MFC1\t13)\n+   (UNSPEC_MFC2\t14)\n+   (UNSPEC_MFC3\t15)\n+   (UNSPEC_MTC0\t16)\n+   (UNSPEC_MTC1\t17)\n+   (UNSPEC_MTC2\t18)\n+   (UNSPEC_MTC3\t19)\n+   (UNSPEC_LUR\t20)\n+   (UNSPEC_RB\t21)\n+   (UNSPEC_RX\t22)\n+   (UNSPEC_SRRD\t23)\n+   (UNSPEC_SRWR\t24)\n+   (UNSPEC_WB\t25)\n+   (UNSPEC_WX\t26)\n+   (UNSPEC_LUC32 49)\n+   (UNSPEC_LUC32L 27)\n+   (UNSPEC_LUC64 28)\n+   (UNSPEC_LUC64L 29)\n+   (UNSPEC_LUK 30)\n+   (UNSPEC_LULCK 31)\n+   (UNSPEC_LUM32 32)\n+   (UNSPEC_LUM32L 33)\n+   (UNSPEC_LUM64 34)\n+   (UNSPEC_LUM64L 35)\n+   (UNSPEC_LURL 36)\n+   (UNSPEC_MRGB 37)\n+   (UNSPEC_SRRDL 38)\n+   (UNSPEC_SRULCK 39)\n+   (UNSPEC_SRWRU 40)\n+   (UNSPEC_TRAPQFL 41)\n+   (UNSPEC_TRAPQNE 42)\n+   (UNSPEC_TRAPREL 43)\n+   (UNSPEC_WBU 44)\n+   (UNSPEC_SYSCALL 45)]\n+)\n+;; UNSPEC values used in iq2000.md\n+;; Number\tUSE\n+;; 0\t\tmovsi_ul\n+;; 1\t\tmovsi_us, get_fnaddr\n+;; 3\t\teh_set_return\n+;; 20\t\tbuiltin_setjmp_setup\n+;;\n+;; UNSPEC_VOLATILE values\n+;; 0\t\tblockage\n+;; 2\t\tloadgp\n+;; 3\t\tbuiltin_longjmp\n+;; 4\t\texception_receiver\n+;; 10\t\tconsttable_qi\n+;; 11\t\tconsttable_hi\n+;; 12\t\tconsttable_si\n+;; 13\t\tconsttable_di\n+;; 14\t\tconsttable_sf\n+;; 15\t\tconsttable_df\n+;; 16\t\talign_2\n+;; 17\t\talign_4\n+;; 18\t\talign_8\n+\f\n+\n+;; ....................\n+;;\n+;;\tAttributes\n+;;\n+;; ....................\n+\n+;; Classification of each insn.\n+;; branch\tconditional branch\n+;; jump\t\tunconditional jump\n+;; call\t\tunconditional call\n+;; load\t\tload instruction(s)\n+;; store\tstore instruction(s)\n+;; move\t\tdata movement within same register set\n+;; xfer\t\ttransfer to/from coprocessor\n+;; arith\tinteger arithmetic instruction\n+;; darith\tdouble precision integer arithmetic instructions\n+;; imul\t\tinteger multiply\n+;; idiv\t\tinteger divide\n+;; icmp\t\tinteger compare\n+;; fadd\t\tfloating point add/subtract\n+;; fmul\t\tfloating point multiply\n+;; fmadd\tfloating point multiply-add\n+;; fdiv\t\tfloating point divide\n+;; fabs\t\tfloating point absolute value\n+;; fneg\t\tfloating point negation\n+;; fcmp\t\tfloating point compare\n+;; fcvt\t\tfloating point convert\n+;; fsqrt\tfloating point square root\n+;; multi\tmultiword sequence (or user asm statements)\n+;; nop\t\tno operation\n+\n+(define_attr \"type\"\n+  \"unknown,branch,jump,call,load,store,move,xfer,arith,darith,imul,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,multi,nop\"\n+  (const_string \"unknown\"))\n+\n+;; Main data type used by the insn\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF,FPSW\" (const_string \"unknown\"))\n+\n+;; Length (in # of bytes).  A conditional branch is allowed only to a\n+;; location within a signed 18-bit offset of the delay slot.  If that\n+;; provides too small a range, we use the `j' instruction.  This\n+;; instruction takes a 28-bit value, but that value is not an offset.\n+;; Instead, it's bitwise-ored with the high-order four bits of the\n+;; instruction in the delay slot, which means it cannot be used to\n+;; cross a 256MB boundary.  We could fall back back on the jr,\n+;; instruction which allows full access to the entire address space,\n+;; but we do not do so at present.\n+\n+(define_attr \"length\" \"\"\n+   (cond [(eq_attr \"type\" \"branch\")\n+          (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 4))))\n+                     (const_int 131072))\n+                 (const_int 4)]\n+\t         (const_int 12))]\n+          (const_int 4)))\n+\n+(define_attr \"cpu\"\n+  \"default,iq2000\"\n+  (const (symbol_ref \"iq2000_cpu_attr\")))\n+\n+;; Does the instruction have a mandatory delay slot? has_dslot\n+;; Can the instruction be in a delay slot? ok_in_dslot\n+;; Can the instruction not be in a delay slot? not_in_dslot\n+(define_attr \"dslot\" \"has_dslot,ok_in_dslot,not_in_dslot\"\n+  (if_then_else (eq_attr \"type\" \"branch,jump,call,xfer,fcmp\")\n+\t\t(const_string \"has_dslot\")\n+\t\t(const_string \"ok_in_dslot\")))\n+\n+;; Attribute defining whether or not we can use the branch-likely instructions\n+\n+(define_attr \"branch_likely\" \"no,yes\"\n+  (const\n+   (if_then_else (ne (symbol_ref \"GENERATE_BRANCHLIKELY\") (const_int 0))\n+\t\t (const_string \"yes\")\n+\t\t (const_string \"no\"))))\n+\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n+\f\n+\n+;; .........................\n+;;\n+;;\tDelay slots, can't describe load/fcmp/xfer delay slots here\n+;;\n+;; .........................\n+\n+(define_delay (eq_attr \"type\" \"jump\")\n+  [(and (eq_attr \"dslot\" \"ok_in_dslot\") (eq_attr \"length\" \"4\"))\n+   (nil)\n+   (nil)])\n+\n+(define_delay (eq_attr \"type\" \"branch\")\n+  [(and (eq_attr \"dslot\" \"ok_in_dslot\") (eq_attr \"length\" \"4\"))\n+   (nil)\n+   (and (eq_attr \"branch_likely\" \"yes\") (and (eq_attr \"dslot\" \"ok_in_dslot\") (eq_attr \"length\" \"4\")))])\n+\n+(define_delay (eq_attr \"type\" \"call\")\n+  [(and (eq_attr \"dslot\" \"ok_in_dslot\") (eq_attr \"length\" \"4\"))\n+   (nil)\n+   (nil)])\n+\n+\f\n+\n+;; .........................\n+;;\n+;;\tFunctional units\n+;;\n+;; .........................\n+\n+; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n+;\t\t\tTEST READY-DELAY ISSUE-DELAY [CONFLICT-LIST])\n+\n+;; Make the default case (PROCESSOR_DEFAULT) handle the worst case\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (eq_attr \"type\" \"load\")\n+       (eq_attr \"cpu\" \"iq2000\"))\n+  3 0)\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (eq_attr \"type\" \"move\")\n+       (eq_attr \"cpu\" \"iq2000\"))\n+  3 0)\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (eq_attr \"type\" \"arith\")\n+       (eq_attr \"cpu\" \"iq2000\"))\n+  3 0)\n+\n+(define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\") 1 0)\n+\n+(define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"xfer\") 2 0)\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tCONDITIONAL TRAPS\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 0))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"break\\\";\n+}\")\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tADDITION\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"addsi3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n+  \"\"\n+  \"@\n+   addu\\\\t%0,%z1,%2\n+   addiu\\\\t%0,%z1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tSUBTRACTION\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"subsi3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n+  \"\"\n+  \"@\n+   subu\\\\t%0,%z1,%2\n+   addiu\\\\t%0,%z1,%n2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tNEGATION and ONE'S COMPLEMENT\n+;;\n+;;  ....................\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = const0_rtx;\n+  return \\\"subu\\\\t%0,%z2,%1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = const0_rtx;\n+  return \\\"nor\\\\t%0,%z2,%1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tLOGICAL\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(and:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d,d\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"d,K,N\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(and:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d,d\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"d,K,N\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"and\\\\t%0,%1,%2\\\";\n+  else if (which_alternative == 1)\n+    return \\\"andi\\\\t%0,%1,%x2\\\";\n+  else if (which_alternative == 2)\n+    {\n+      if ((INTVAL (operands[2]) & 0xffff) == 0xffff)\n+\t{\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) >> 16);\n+\t  return \\\"andoui\\\\t%0,%1,%x2\\\";\n+\t}\n+      else\n+\t{\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+\t  return \\\"andoi\\\\t%0,%1,%x2\\\";\n+\t}\n+    }\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ior:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ior:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"@\n+   or\\\\t%0,%1,%2\n+   ori\\\\t%0,%1,%x2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(xor:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(xor:SI (match_operand:SI 1 \"uns_arith_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"@\n+   xor\\\\t%0,%1,%2\n+   xori\\\\t%0,%1,%x2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"*norsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"nor\\\\t%0,%z1,%z2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tZERO EXTENSION\n+;;\n+;;  ....................\n+\n+;; Extension insns.\n+;; Those for integer source operand are ordered widest source type first.\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"andi\\\\t%0,%1,0xffff\\\";\n+  else\n+    return iq2000_move_1word (operands, insn, TRUE);\n+}\"\n+  [(set_attr \"type\"\t\"arith,load,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,4,8\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"andi\\\\t%0,%1,0x00ff\\\";\n+  else\n+    return iq2000_move_1word (operands, insn, TRUE);\n+}\"\n+  [(set_attr \"type\"\t\"arith,load,load\")\n+   (set_attr \"mode\"\t\"HI\")\n+   (set_attr \"length\"\t\"4,4,8\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"andi\\\\t%0,%1,0x00ff\\\";\n+  else\n+    return iq2000_move_1word (operands, insn, TRUE);\n+}\"\n+  [(set_attr \"type\"\t\"arith,load,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,4,8\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSIGN EXTENSION\n+;;\n+;;  ....................\n+\n+;; Extension insns.\n+;; Those for integer source operand are ordered widest source type first.\n+\n+;; These patterns originally accepted general_operands, however, slightly\n+;; better code is generated by only accepting register_operands, and then\n+;; letting combine generate the lh and lb insns.\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (optimize && GET_CODE (operands[1]) == MEM)\n+    operands[1] = force_not_mem (operands[1]);\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx op1   = gen_lowpart (SImode, operands[1]);\n+      rtx temp  = gen_reg_rtx (SImode);\n+      rtx shift = GEN_INT (16);\n+\n+      emit_insn (gen_ashlsi3 (temp, op1, shift));\n+      emit_insn (gen_ashrsi3 (operands[0], temp, shift));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"extendhisi2_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"R,m\")))]\n+  \"\"\n+  \"* return iq2000_move_1word (operands, insn, FALSE);\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,8\")])\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (optimize && GET_CODE (operands[1]) == MEM)\n+    operands[1] = force_not_mem (operands[1]);\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx op0   = gen_lowpart (SImode, operands[0]);\n+      rtx op1   = gen_lowpart (SImode, operands[1]);\n+      rtx temp  = gen_reg_rtx (SImode);\n+      rtx shift = GEN_INT (24);\n+\n+      emit_insn (gen_ashlsi3 (temp, op1, shift));\n+      emit_insn (gen_ashrsi3 (op0, temp, shift));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"extendqihi2_internal\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"R,m\")))]\n+  \"\"\n+  \"* return iq2000_move_1word (operands, insn, FALSE);\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,8\")])\n+\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (optimize && GET_CODE (operands[1]) == MEM)\n+    operands[1] = force_not_mem (operands[1]);\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx op1   = gen_lowpart (SImode, operands[1]);\n+      rtx temp  = gen_reg_rtx (SImode);\n+      rtx shift = GEN_INT (24);\n+\n+      emit_insn (gen_ashlsi3 (temp, op1, shift));\n+      emit_insn (gen_ashrsi3 (operands[0], temp, shift));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"R,m\")))]\n+  \"\"\n+  \"* return iq2000_move_1word (operands, insn, FALSE);\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,8\")])\n+\f\n+;;\n+;;  ........................\n+;;\n+;;      BIT FIELD EXTRACTION\n+;;\n+;;  ........................\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                         (match_operand:SI 2 \"const_int_operand\" \"O\")\n+                         (match_operand:SI 3 \"const_int_operand\" \"O\")))]\n+  \"\"\n+  \"*\n+{\n+  int value[4];\n+  value[2] = INTVAL (operands[2]);\n+  value[3] = INTVAL (operands[3]);\n+  operands[2] = GEN_INT ((value[3]));\n+  operands[3] = GEN_INT ((32 - value[2]));\n+  return \\\"ram\\\\t%0,%1,%2,%3,0x0\\\";  \n+}\"\n+  [(set_attr \"type\" \"arith\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tDATA MOVEMENT\n+;;\n+;;  ....................\n+\n+/* Take care of constants that don't fit in single instruction */\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"(reload_in_progress || reload_completed)\n+   && large_int (operands[1], SImode)\"\n+\n+  [(set (match_dup 0 )\n+        (high:SI (match_dup 1)))\n+   (set (match_dup 0 )\n+        (lo_sum:SI (match_dup 0)\n+                   (match_dup 1)))]\n+)\n+\n+;; ??? iq2000_move_1word has support for HIGH, so this pattern may be\n+;; unnecessary.\n+\n+(define_insn \"high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"lui\\\\t%0,%%hi(%1) # high\"\n+  [(set_attr \"type\"\t\"move\")])\n+\n+(define_insn \"low\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"addiu\\\\t%0,%1,%%lo(%2) # low\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; 32-bit Integer moves\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"large_int\" \"\"))]\n+  \"reload_in_progress | reload_completed\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+     \t(ior:SI (match_dup 0)\n+\t\t(match_dup 3)))]\n+  \"\n+{\n+  operands[2] = GEN_INT (trunc_int_for_mode (INTVAL (operands[1])\n+\t\t\t\t\t     & BITMASK_UPPER16,\n+\t\t\t\t\t     SImode));\n+  operands[3] = GEN_INT (INTVAL (operands[1]) & BITMASK_LOWER16);\n+}\")\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (iq2000_check_split (operands[1], SImode))\n+    {\n+      enum machine_mode mode = GET_MODE (operands[0]);\n+      rtx tem = ((reload_in_progress | reload_completed)\n+\t\t ? operands[0] : gen_reg_rtx (mode));\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t      gen_rtx_HIGH (mode, operands[1])));\n+\n+      operands[1] = gen_rtx_LO_SUM (mode, tem, operands[1]);\n+    }\n+\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], SImode)\n+      && !register_operand (operands[1], SImode)\n+      && (GET_CODE (operands[1]) != CONST_INT\n+\t  || INTVAL (operands[1]) != 0))\n+    {\n+      rtx temp = force_reg (SImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+\n+  /* Take care of constants that don't fit in single instruction */\n+  if ((reload_in_progress || reload_completed)\n+      && CONSTANT_P (operands[1])\n+      && GET_CODE (operands[1]) != HIGH\n+      && GET_CODE (operands[1]) != LO_SUM\n+      && ! SMALL_INT_UNSIGNED (operands[1]))\n+    {\n+      rtx tem = ((reload_in_progress | reload_completed)\n+\t\t ? operands[0] : gen_reg_rtx (SImode));\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t      gen_rtx_HIGH (SImode, operands[1])));\n+      operands[1] = gen_rtx_LO_SUM (SImode, tem, operands[1]);\n+    }\n+}\")\n+\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movsi_internal2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a\"))]\n+  \"(register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode)\n+       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n+  \"* return iq2000_move_1word (operands, insn, FALSE);\"\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,move,move,move\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,4,4\")])\n+\n+;; 16-bit Integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], HImode)\n+      && !register_operand (operands[1], HImode)\n+      && ((GET_CODE (operands[1]) != CONST_INT\n+\t  || INTVAL (operands[1]) != 0)))\n+    {\n+      rtx temp = force_reg (HImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movhi_internal2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n+\t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n+  \"(register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode)\n+       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n+  \"* return iq2000_move_1word (operands, insn, TRUE);\"\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,move,move\")\n+   (set_attr \"mode\"\t\"HI\")\n+   (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4\")])\n+\n+;; 8-bit Integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if ((reload_in_progress | reload_completed) == 0\n+      && !register_operand (operands[0], QImode)\n+      && !register_operand (operands[1], QImode)\n+      && (GET_CODE (operands[1]) != CONST_INT\n+          || INTVAL (operands[1]) != 0))\n+    {\n+      rtx temp = force_reg (QImode, operands[1]);\n+      emit_move_insn (operands[0], temp);\n+      DONE;\n+    }\n+}\")\n+\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movqi_internal2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n+\t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n+  \"(register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode)\n+       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n+  \"* return iq2000_move_1word (operands, insn, TRUE);\"\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,move,move\")\n+   (set_attr \"mode\"\t\"QI\")\n+   (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4\")])\n+\n+;; 32-bit floating point moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+        (match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress\n+      && !reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && (GET_CODE (operands[1]) == MEM\n+         || GET_CODE (operands[1]) == CONST_DOUBLE))\n+    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n+\n+  /* Take care of reg <- SF constant */\n+  if ( const_double_operand (operands[1], GET_MODE (operands[1]) ) )\n+    {\n+      emit_insn (gen_movsf_high (operands[0], operands[1]));\n+      emit_insn (gen_movsf_lo_sum (operands[0], operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movsf_lo_sum\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+                   (match_operand:SF 2 \"const_double_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[2]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[2] = GEN_INT (i);\n+  return \\\"addiu\\\\t%0,%1,%%lo(%2) # low\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"movsf_high\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (high:SF (match_operand:SF 1 \"const_double_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[1] = GEN_INT (i);\n+  return \\\"lui\\\\t%0,%%hi(%1) # high\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+        (match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  \"!memory_operand (operands[0], SFmode) || !memory_operand (operands[1], SFmode)\"\n+  \"*\n+{\n+  iq2000_fill_delay_slot (\\\"\\\", DELAY_LOAD, operands, insn);  \n+  if (which_alternative == 0)\n+    return \\\"or\\\\t%0,%1,%1\\\";\n+  else if (which_alternative == 1)\n+    return \\\"lw\\\\t%0,%1\\\";\n+  else if (which_alternative == 2)\n+    return \\\"sw\\\\t%1,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"4,4,4\")\n+   (set_attr \"type\" \"arith,load,store\")]\n+)\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tSHIFTS\n+;;\n+;;  ....................\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"ashlsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \\\"sll\\\\t%0,%1,%2\\\";\n+    }\n+  else\n+    return \\\"sllv\\\\t%0,%1,%2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"ashrsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \\\"sra\\\\t%0,%1,%2\\\";\n+    }\n+  else\n+    return \\\"srav\\\\t%0,%1,%2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"lshrsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \\\"srl\\\\t%0,%1,%2\\\";\n+    }\n+  else\n+    return \\\"srlv\\\\t%0,%1,%2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Rotate Right\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (rotatert:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                     (match_operand:SI 2 \"uns_arith_operand\" \"O\")))]\n+  \"\"\n+  \"ram %0,%1,%2,0x0,0x0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tCOMPARISONS\n+;;\n+;;  ....................\n+\n+;; Flow here is rather complex:\n+;;\n+;;  1)\tThe cmp{si,di,sf,df} routine is called.  It deposits the\n+;;\targuments into the branch_cmp array, and the type into\n+;;\tbranch_type.  No RTL is generated.\n+;;\n+;;  2)\tThe appropriate branch define_expand is called, which then\n+;;\tcreates the appropriate RTL for the comparison and branch.\n+;;\tDifferent CC modes are used, based on what type of branch is\n+;;\tdone, so that we can constrain things appropriately.  There\n+;;\tare assumptions in the rest of GCC that break if we fold the\n+;;\toperands into the branchs for integer operations, and use cc0\n+;;\tfor floating point, so we use the fp status register instead.\n+;;\tIf needed, an appropriate temporary is created to hold the\n+;;\tof the integer compare.\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code message */\n+    {\n+      branch_cmp[0] = operands[0];\n+      branch_cmp[1] = operands[1];\n+      branch_type = CMP_SI;\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code message */\n+    {\n+      branch_cmp[0] = operands[0];\n+      branch_cmp[1] = const0_rtx;\n+      branch_type = CMP_SI;\n+      DONE;\n+    }\n+}\")\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+\n+;; Conditional branches on comparisons with zero.\n+\n+(define_insn \"branch_zero\"\n+  [(set (pc)\n+\t(if_then_else\n+         (match_operator:SI 0 \"cmp_op\"\n+\t\t\t    [(match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (const_int 0)])\n+        (label_ref (match_operand 1 \"\" \"\"))\n+        (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return iq2000_output_conditional_branch (insn,\n+\t\t\t\t\t operands,\n+\t\t\t\t\t /*two_operands_p=*/0,\n+\t\t\t\t\t /*float_p=*/0,\n+\t\t\t\t\t /*inverted_p=*/0,\n+\t\t\t\t\t get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_insn \"branch_zero_inverted\"\n+  [(set (pc)\n+\t(if_then_else\n+         (match_operator:SI 0 \"cmp_op\"\n+\t\t            [(match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (const_int 0)])\n+        (pc)\n+        (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  return iq2000_output_conditional_branch (insn,\n+\t\t\t\t\t operands,\n+\t\t\t\t\t /*two_operands_p=*/0,\n+\t\t\t\t\t /*float_p=*/0,\n+\t\t\t\t\t /*inverted_p=*/1,\n+\t\t\t\t\t get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Conditional branch on equality comparision.\n+\n+(define_insn \"branch_equality\"\n+  [(set (pc)\n+\t(if_then_else\n+         (match_operator:SI 0 \"equality_op\"\n+\t\t   \t    [(match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return iq2000_output_conditional_branch (insn,\n+\t\t\t\t\t operands,\n+\t\t\t\t\t /*two_operands_p=*/1,\n+\t\t\t\t\t /*float_p=*/0,\n+\t\t\t\t\t /*inverted_p=*/0,\n+\t\t\t\t\t get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_insn \"branch_equality_inverted\"\n+  [(set (pc)\n+\t(if_then_else\n+         (match_operator:SI 0 \"equality_op\"\n+\t\t   \t    [(match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")])\n+         (pc)\n+         (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  return iq2000_output_conditional_branch (insn,\n+\t\t\t\t\t operands,\n+\t\t\t\t\t /*two_operands_p=*/1,\n+\t\t\t\t\t /*float_p=*/0,\n+\t\t\t\t\t /*inverted_p=*/1,\n+\t\t\t\t\t get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, EQ);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, NE);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, GT);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, GE);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, LT);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le:CC (cc0)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, LE);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu:CC (cc0)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, GTU);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu:CC (cc0)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, GEU);\n+      DONE;\n+    }\n+}\")\n+\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu:CC (cc0)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, LTU);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu:CC (cc0)\n+\t\t\t      (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code warning */\n+    {\n+      gen_conditional_branch (operands, LEU);\n+      DONE;\n+    }\n+}\")\n+\n+;; Recognize bbi and bbin instructions.  These use two unusual template\n+;; patterns, %Ax and %Px.  %Ax outputs an 'i' if operand `x' is a LABEL_REF\n+;; otherwise it outputs an 'in'.  %Px does nothing if `x' is PC \n+;; and outputs the operand if `x' is a LABEL_REF.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"arith_operand\" \"I\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A2\\\\t%0(31-%1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"arith_operand\" \"I\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A3\\\\t%0(31-%1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"arith_operand\" \"I\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A2\\\\t%0(31-%1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"arith_operand\" \"I\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A3\\\\t%0(31-%1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 1 \"power_of_2_operand\" \"I\"))\n+\t      (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A3\\\\t%0(%p1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 1 \"power_of_2_operand\" \"I\"))\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_operand\" \"\")\n+\t (match_operand 3 \"pc_or_label_operand\" \"\")))]\n+  \"\"\n+  \"bb%A2\\\\t%0(%p1),%P2%P3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tSETTING A REGISTER FROM A COMPARISON\n+;;\n+;;  ....................\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(eq:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (EQ, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+\n+(define_insn \"seq_si_zero\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"sltiu\\\\t%0,%1,1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (NE, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sne_si_zero\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"sltu\\\\t%0,%.,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(gt:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (GT, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sgt_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n+\t(gt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t       (match_operand:SI 2 \"reg_or_0_operand\" \"d,J\")))]\n+  \"\"\n+  \"@\n+   slt\\\\t%0,%z2,%1\n+   slt\\\\t%0,%z2,%1\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI,SI\")])\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ge:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (GE, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lt:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (LT, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"slt_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t       (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n+  \"\"\n+  \"@\n+   slt\\\\t%0,%1,%2\n+   slti\\\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI,SI\")])\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(le:SI (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (LE, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sle_si_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (match_operand:SI 2 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[2]) < 32767\"\n+  \"*\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2])+1);\n+  return \\\"slti\\\\t%0,%1,%2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(gtu:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (GTU, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sgtu_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(gtu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"reg_or_0_operand\" \"dJ\")))]\n+  \"\"\n+  \"sltu\\\\t%0,%z2,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=t\")\n+\t(gtu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sltu\\\\t%2,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (geu:SI (match_dup 1)\n+                (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (GEU, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ltu:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (LTU, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sltu_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n+  \"\"\n+  \"@\n+   sltu\\\\t%0,%1,%2\n+   sltiu\\\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI,SI\")])\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(leu:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n+    FAIL;\n+\n+  /* set up operands from compare.  */\n+  operands[1] = branch_cmp[0];\n+  operands[2] = branch_cmp[1];\n+\n+  gen_int_relational (LEU, operands[0], operands[1], operands[2], (int *)0);\n+  DONE;\n+}\")\n+\n+(define_insn \"sleu_si_const\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[2]) < 32767\"\n+  \"*\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n+  return \\\"sltiu\\\\t%0,%1,%2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tUNCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+\n+;; Unconditional branches.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"j\\\\t%0\\\";\n+  return \\\"j\\\\t%l0\\\";\n+  /* return \\\"b\\\\t%l0\\\";*/\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"\n+{\n+  rtx dest;\n+\n+  if (operands[0])\t\t/* eliminate unused code warnings */\n+    {\n+      dest = operands[0];\n+      if (GET_CODE (dest) != REG || GET_MODE (dest) != Pmode)\n+\toperands[0] = copy_to_mode_reg (Pmode, dest);\n+\n+      if (!(Pmode == DImode))\n+\temit_jump_insn (gen_indirect_jump_internal1 (operands[0]));\n+      else\n+\temit_jump_insn (gen_indirect_jump_internal2 (operands[0]));\n+\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"indirect_jump_internal1\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))]\n+  \"!(Pmode == DImode)\"\n+  \"j\\\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"tablejump\"\n+  [(set (pc)\n+\t(match_operand 0 \"register_operand\" \"d\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* eliminate unused code warnings */\n+    {\n+      if (GET_MODE (operands[0]) != Pmode)\n+\tabort ();\n+\n+      if (!(Pmode == DImode))\n+\temit_jump_insn (gen_tablejump_internal1 (operands[0], operands[1]));\n+      else\n+\temit_jump_insn (gen_tablejump_internal2 (operands[0], operands[1]));\n+\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"tablejump_internal1\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"d\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"!(Pmode == DImode)\"\n+  \"j\\\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"tablejump_internal3\"\n+  [(parallel [(set (pc)\n+\t\t   (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t    (label_ref:SI (match_operand 1 \"\" \"\"))))\n+\t      (use (label_ref:SI (match_dup 1)))])]\n+  \"\"\n+  \"\")\n+\n+;;; Make sure that this only matches the insn before ADDR_DIFF_VEC.  Otherwise\n+;;; it is not valid.  ??? With the USE, the condition tests may not be required\n+;;; any longer.\n+\n+;;; ??? The length depends on the ABI.  It is two for o32, and one for n32.\n+;;; We just use the conservative number here.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t (label_ref:SI (match_operand 1 \"\" \"\"))))\n+   (use (label_ref:SI (match_dup 1)))]\n+  \"!(Pmode == DImode) && next_active_insn (insn) != 0\n+   && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n+   && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n+  \"*\n+{\n+  return \\\"j\\\\t%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"8\")])\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tFunction prologue/epilogue\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  if (iq2000_isa >= 0)\t\t/* avoid unused code warnings */\n+    {\n+      iq2000_expand_prologue ();\n+      DONE;\n+    }\n+}\")\n+\n+;; Block any insns from being moved before this point, since the\n+;; profiling call to mcount can use various registers that aren't\n+;; saved or used to pass arguments.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\"\t\"unknown\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"0\")])\n+\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+  \"\n+{\n+  if (iq2000_isa >= 0)            /* avoid unused code warnings */\n+    {\n+      iq2000_expand_epilogue ();\n+      DONE;\n+    }\n+}\")\n+\n+;; Trivial return.  Make it look like a normal return insn as that\n+;; allows jump optimizations to work better .\n+(define_insn \"return\"\n+  [(return)]\n+  \"iq2000_can_use_return_insn ()\"\n+  \"j\\\\t%%31\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Normal return.\n+\n+(define_insn \"return_internal\"\n+  [(use (match_operand 0 \"pmode_register_operand\" \"\"))\n+   (return)]\n+  \"\"\n+  \"*\n+{\n+  return \\\"j\\\\t%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_insn \"eh_return_internal\"\n+  [(const_int 4)\n+   (return)\n+   (use (reg:SI 26))\n+   (use (reg:SI 31))]\n+  \"\"\n+  \"j\\\\t%%26\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"\n+{\n+  iq2000_expand_eh_return (operands[0]);\n+  DONE;\n+}\")\n+\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tFUNCTION CALLS\n+;;\n+;;  ....................\n+\n+;; calls.c now passes a third argument, make saber happy\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"memory_operand\" \"m\")\n+\t\t    (match_operand 1 \"\" \"i\"))\n+\t      (clobber (reg:SI 31))\n+\t      (use (match_operand 2 \"\" \"\"))\t\t;; next_arg_reg\n+\t      (use (match_operand 3 \"\" \"\"))])]\t\t;; struct_value_size_rtx\n+  \"\"\n+  \"\n+{\n+  rtx addr;\n+\n+  if (operands[0])\t\t/* eliminate unused code warnings */\n+    {\n+      addr = XEXP (operands[0], 0);\n+      if ((GET_CODE (addr) != REG && (!CONSTANT_ADDRESS_P (addr)))\n+\t  || ! call_insn_operand (addr, VOIDmode))\n+\tXEXP (operands[0], 0) = copy_to_mode_reg (Pmode, addr);\n+\n+      /* In order to pass small structures by value in registers\n+\t compatibly with the IQ2000 compiler, we need to shift the value\n+\t into the high part of the register.  Function_arg has encoded\n+\t a PARALLEL rtx, holding a vector of adjustments to be made\n+\t as the next_arg_reg variable, so we split up the insns,\n+\t and emit them separately.  */\n+\n+      if (operands[2] != (rtx)0 && GET_CODE (operands[2]) == PARALLEL)\n+\t{\n+\t  rtvec adjust = XVEC (operands[2], 0);\n+\t  int num = GET_NUM_ELEM (adjust);\n+\t  int i;\n+\n+\t  for (i = 0; i < num; i++)\n+\t    emit_insn (RTVEC_ELT (adjust, i));\n+\t}\n+\n+      emit_call_insn (gen_call_internal0 (operands[0], operands[1],\n+\t\t\t\t\t  gen_rtx_REG (SImode,\n+\t\t\t\t\t\t       GP_REG_FIRST + 31)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"call_internal0\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"call_internal1\"\n+  [(call (mem (match_operand 0 \"call_insn_operand\" \"ri\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))]\n+  \"\"\n+  \"*\n+{\n+  register rtx target = operands[0];\n+\n+  if (GET_CODE (target) == CONST_INT)\n+    return \\\"li\\\\t%@,%0\\\\n\\\\tjalr\\\\t%2,%@\\\";\n+  else if (CONSTANT_ADDRESS_P (target))\n+    return \\\"jal\\\\t%0\\\";\n+  else\n+    return \\\"jalr\\\\t%2,%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; calls.c now passes a fourth argument, make saber happy\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=df\")\n+\t\t   (call (match_operand 1 \"memory_operand\" \"m\")\n+\t\t\t (match_operand 2 \"\" \"i\")))\n+\t      (clobber (reg:SI 31))\n+\t      (use (match_operand 3 \"\" \"\"))])]\t\t;; next_arg_reg\n+  \"\"\n+  \"\n+{\n+  rtx addr;\n+\n+  if (operands[0])\t\t/* eliminate unused code warning */\n+    {\n+      addr = XEXP (operands[1], 0);\n+      if ((GET_CODE (addr) != REG && (!CONSTANT_ADDRESS_P (addr)))\n+\t  || ! call_insn_operand (addr, VOIDmode))\n+\tXEXP (operands[1], 0) = copy_to_mode_reg (Pmode, addr);\n+\n+      /* In order to pass small structures by value in registers\n+\t compatibly with the IQ2000 compiler, we need to shift the value\n+\t into the high part of the register.  Function_arg has encoded\n+\t a PARALLEL rtx, holding a vector of adjustments to be made\n+\t as the next_arg_reg variable, so we split up the insns,\n+\t and emit them separately.  */\n+\n+      if (operands[3] != (rtx)0 && GET_CODE (operands[3]) == PARALLEL)\n+\t{\n+\t  rtvec adjust = XVEC (operands[3], 0);\n+\t  int num = GET_NUM_ELEM (adjust);\n+\t  int i;\n+\n+\t  for (i = 0; i < num; i++)\n+\t    emit_insn (RTVEC_ELT (adjust, i));\n+\t}\n+\n+      if (GET_CODE (operands[0]) == PARALLEL && XVECLEN (operands[0], 0) > 1)\n+\t{\n+\t  emit_call_insn (gen_call_value_multiple_internal0\n+\t\t\t  (XEXP (XVECEXP (operands[0], 0, 0), 0),\n+\t\t\t   operands[1], operands[2],\n+\t\t\t   XEXP (XVECEXP (operands[0], 0, 1), 0),\n+\t\t\t   gen_rtx_REG (SImode, GP_REG_FIRST + 31)));\n+\t  DONE;\n+\t}\n+\n+      /* We have a call returning a DImode structure in an FP reg.\n+\t Strip off the now unnecessary PARALLEL.  */\n+      if (GET_CODE (operands[0]) == PARALLEL)\n+\toperands[0] = XEXP (XVECEXP (operands[0], 0, 0), 0);\n+\n+      emit_call_insn (gen_call_value_internal0 (operands[0], operands[1], operands[2],\n+\t\t\t\t\t        gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t     GP_REG_FIRST + 31)));\n+\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"call_value_internal0\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (match_operand:SI 3 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"call_value_internal1\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem (match_operand 1 \"call_insn_operand\" \"ri\"))\n+              (match_operand 2 \"\" \"i\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n+  \"\"\n+  \"*\n+{\n+  register rtx target = operands[1];\n+\n+  if (GET_CODE (target) == CONST_INT)\n+    return \\\"li\\\\t%@,%1\\\\n\\\\tjalr\\\\t%3,%@\\\";\n+  else if (CONSTANT_ADDRESS_P (target))\n+    return \\\"jal\\\\t%1\\\";\n+  else\n+    return \\\"jalr\\\\t%3,%1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"call_value_multiple_internal0\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (set (match_operand 3 \"\" \"\")\n+\t\t   (call (match_dup 1)\n+\t\t\t (match_dup 2)))\n+\t      (clobber (match_operand:SI 4 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n+;; ??? May eventually need all 6 versions of the call patterns with multiple\n+;; return values.\n+\n+(define_insn \"call_value_multiple_internal1\"\n+  [(set (match_operand 0 \"register_operand\" \"=df\")\n+        (call (mem (match_operand 1 \"call_insn_operand\" \"ri\"))\n+              (match_operand 2 \"\" \"i\")))\n+   (set (match_operand 3 \"register_operand\" \"=df\")\n+   \t(call (mem (match_dup 1))\n+              (match_dup 2)))\n+  (clobber (match_operand:SI 4 \"register_operand\" \"=d\"))]\n+  \"\"\n+  \"*\n+{\n+  register rtx target = operands[1];\n+\n+  if (GET_CODE (target) == CONST_INT)\n+    return \\\"li\\\\t%@,%1\\\\n\\\\tjalr\\\\t%4,%@\\\";\n+  else if (CONSTANT_ADDRESS_P (target))\n+    return \\\"jal\\\\t%1\\\";\n+  else\n+    return \\\"jalr\\\\t%4,%1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* silence statement not reached warnings */\n+    {\n+      int i;\n+\n+      emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+      for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+\t{\n+\t  rtx set = XVECEXP (operands[2], 0, i);\n+\t  emit_move_insn (SET_DEST (set), SET_SRC (set));\n+\t}\n+\n+      emit_insn (gen_blockage ());\n+      DONE;\n+    }\n+}\")\n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tMISC.\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\"\t\"nop\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+\f\n+;; For the rare case where we need to load an address into a register\n+;; that can not be recognized by the normal movsi/addsi instructions.\n+;; I have no idea how many insns this can actually generate.  It should\n+;; be rare, so over-estimating as 10 instructions should not have any\n+;; real performance impact.\n+(define_insn \"leasi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"Pmode == SImode\"\n+  \"*\n+{\n+  rtx xoperands [3];\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = XEXP (operands[1], 0);\n+  xoperands[2] = XEXP (operands[1], 1);\n+  output_asm_insn (\\\"addiu\\\\t%0,%1,%2\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"40\")])\n+\n+(define_insn \"ado16\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")]\n+\t\tUNSPEC_ADO16))]\n+  \"\"\n+  \"ado16\\\\t%0, %1, %2\"\n+)\n+\n+(define_insn \"ram\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+\t      (unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t                (match_operand:SI 2 \"const_int_operand\" \"I\")\n+\t\t                (match_operand:SI 3 \"const_int_operand\" \"I\")\n+\t\t                (match_operand:SI 4 \"const_int_operand\" \"I\")]\n+\t\t     UNSPEC_RAM))]\n+  \"\"\n+  \"ram\\\\t%0, %1, %2, %3, %4\"\n+)\n+\n+(define_insn \"chkhdr\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_CHKHDR)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"chkhdr\\\\t%0, %1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"pkrl\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_PKRL)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"pkrl\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"cfc0\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+    (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_CFC0))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"cfc0\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"cfc1\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_CFC1))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"cfc1\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"cfc2\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_CFC2))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"cfc2\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"cfc3\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_CFC3))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"cfc3\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"ctc0\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_CTC0)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"ctc0\\\\t%z0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"ctc1\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_CTC1)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"ctc1\\\\t%z0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"ctc2\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_CTC2)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"ctc2\\\\t%z0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"ctc3\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_CTC3)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"ctc3\\\\t%z0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mfc0\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_MFC0))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mfc0\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mfc1\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_MFC1))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mfc1\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mfc2\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_MFC2))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mfc2\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"mfc3\"\n+   [(set (match_operand:SI                0 \"register_operand\" \"=r\")\n+   (unspec_volatile:SI [(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+ \t\tUNSPEC_MFC3))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mfc3\\\\t%0, %%%1\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"mtc0\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_MTC0)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mtc0\\\\t%0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mtc1\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_MTC1)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mtc1\\\\t%0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mtc2\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_MTC2)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mtc2\\\\t%0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"mtc3\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_MTC3)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mtc3\\\\t%0, %%%1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"lur\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUR)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lur\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"rb\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_RB)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"rb\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"rx\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_RX)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"rx\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"srrd\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\tUNSPEC_SRRD)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"srrd\\\\t%0\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"srwr\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_SRWR)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"srwr\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"wb\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_WB)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"wb\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"wx\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_WX)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"wx\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"luc32\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUC32)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"luc32\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"luc32l\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUC32L)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"luc32l\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"luc64\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUC64)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"luc64\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"luc64l\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUC64L)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"luc64l\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"luk\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUK)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"luk\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"lulck\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LULCK)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lulck\\\\t%0\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"lum32\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUM32)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lum32\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"lum32l\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUM32L)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lum32l\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\" \n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"lum64\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUM64)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lum64\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"lum64l\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LUM64L)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lum64l\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"lurl\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_LURL)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"lurl\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"mrgb\"\n+  [(set (match_operand:SI                 0 \"register_operand\" \"=r\")\n+  \t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"I\")]\n+\t\tUNSPEC_MRGB))]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"mrgb\\\\t%0, %1, %2, %3\\\", DELAY_LOAD, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"ok_in_dslot\")]\n+)\n+\n+(define_insn \"srrdl\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\tUNSPEC_SRRDL)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"srrdl\\\\t%0\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"srulck\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\tUNSPEC_SRULCK)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"srulck\\\\t%0\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"srwru\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_SRWRU)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"srwru\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"trapqfl\"\n+  [(unspec_volatile:SI [(const_int 1)] UNSPEC_TRAPQFL)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"trapqfl\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"trapqne\"\n+  [(unspec_volatile:SI [(const_int 2)] UNSPEC_TRAPQNE)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"trapqne\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"traprel\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\tUNSPEC_TRAPREL)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"traprel %0\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"wbu\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\tUNSPEC_WBU)]\n+  \"\"\n+  \"* return iq2000_fill_delay_slot (\\\"wbu\\\\t%0, %1\\\", DELAY_NONE, operands, insn);\"\n+  [(set_attr \"dslot\"\t\"not_in_dslot\")]\n+)\n+\n+(define_insn \"syscall\"\n+  [(unspec_volatile:SI [(const_int 2)] UNSPEC_SYSCALL)]\n+  \"\"\n+  \"syscall\"\n+  [(set_attr \"dslot\"    \"not_in_dslot\")]\n+)"}, {"sha": "e092babdd1117baec9117adb41b78cba65b15d09", "filename": "gcc/config/iq2000/lib2extra-funcs.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Flib2extra-funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Flib2extra-funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Flib2extra-funcs.c?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,17 @@\n+typedef unsigned int USItype\t\t__attribute__ ((mode (SI)));\n+\n+USItype\n+__mulsi3 (USItype a, USItype b)\n+{\n+  USItype c = 0;\n+\n+  while (a != 0)\n+    {\n+      if (a & 1)\n+\tc += b;\n+      a >>= 1;\n+      b <<= 1;\n+    }\n+\n+  return c;\n+}"}, {"sha": "23dc9558e3eb9f55361beeb1763417cdc9bbd4d9", "filename": "gcc/config/iq2000/t-iq2000", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Ft-iq2000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Ft-iq2000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Ft-iq2000?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,36 @@\n+# Suppress building libgcc1.a, since the MIPS compiler port is complete\n+# and does not need anything from libgcc1.a.\n+LIBGCC1 =\n+CROSS_LIBGCC1 =\n+\n+# We must build libgcc2.a with -G 0, in case the user wants to link\n+# without the $gp register.\n+TARGET_LIBGCC2_CFLAGS = -G 0\n+\n+LIB2FUNCS_EXTRA = $(srcdir)/config/udivmod.c $(srcdir)/config/divmod.c $(srcdir)/config/udivmodsi4.c $(srcdir)/config/iq2000/lib2extra-funcs.c\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'\t\t\t\t> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c\t\t\t>> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# Enable the following if multilibs are needed.\n+# See gcc/genmultilib, gcc/gcc.texi and gcc/tm.texi for a\n+# description of the options and their values.\n+#\n+# MULTILIB_OPTIONS    = \n+# MULTILIB_DIRNAMES   = \n+# MULTILIB_MATCHES    =\n+# MULTILIB_EXCEPTIONS =\n+# MULTILIB_EXTRA_OPTS = \n+#\n+# LIBGCC = stmp-multilib\n+# INSTALL_LIBGCC = install-multilib\n+"}, {"sha": "22e46bc222b7efb3f0a9640691fa5035f4cdd00d", "filename": "gcc/config/iq2000/xm-iq2000.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fxm-iq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fconfig%2Fiq2000%2Fxm-iq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fxm-iq2000.h?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -0,0 +1,35 @@\n+/* Configuration for IQ based processors\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Red Hat Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33"}, {"sha": "1ed6876743623d1adbfd0191aeb11356ea641b38", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3d1e471a4de2a93320d1fc14549b4a49223b9d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=6b3d1e471a4de2a93320d1fc14549b4a49223b9d", "patch": "@@ -1906,6 +1906,8 @@ GNU Compiler Collection on your machine.\n @item\n @uref{#ip2k-*-elf,,ip2k-*-elf}\n @item\n+@uref{#iq2000-*-elf,,iq2000-*-elf}\n+@item\n @uref{#m32r-*-elf,,m32r-*-elf}\n @item\n @uref{#m6811-elf,,m6811-elf}\n@@ -2756,6 +2758,13 @@ There are no standard Unix configurations.\n \n Use @samp{configure --target=ip2k-elf --enable-languages=c} to configure GCC@.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{iq2000-*-elf}iq2000-*-elf\n+Vitesse IQ2000 processors.  These are used in embedded\n+applications.  There are no standard Unix configurations.\n+\n @html\n <hr />\n @end html"}]}