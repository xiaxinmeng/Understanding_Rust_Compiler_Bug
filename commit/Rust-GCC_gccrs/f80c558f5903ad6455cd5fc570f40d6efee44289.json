{"sha": "f80c558f5903ad6455cd5fc570f40d6efee44289", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgwYzU1OGY1OTAzYWQ2NDU1Y2Q1ZmM1NzBmNDBkNmVmZWU0NDI4OQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-22T05:43:57Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-22T05:43:57Z"}, "message": "re PR fortran/43072 (unneeded temporary (s=s+f(a)))\n\n2010-02-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43072\n\t* dependency.c (gfc_full_array_ref_p): Check for contiguous by\n\tchecking the rest of the dimensions for elements.\n\n2010-02-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43072\n\t* gfortran.dg/internal_pack_6.f90: Number of 'packs' now zero.\n\t* gfortran.dg/internal_pack_9.f90: New test.\n\nFrom-SVN: r156949", "tree": {"sha": "40034f5c70e709d78c08efea3e3c58c1b9aa0384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40034f5c70e709d78c08efea3e3c58c1b9aa0384"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f80c558f5903ad6455cd5fc570f40d6efee44289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80c558f5903ad6455cd5fc570f40d6efee44289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80c558f5903ad6455cd5fc570f40d6efee44289", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80c558f5903ad6455cd5fc570f40d6efee44289/comments", "author": null, "committer": null, "parents": [{"sha": "3039c3948e6984cff6703f51be03b8dabb86c6df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3039c3948e6984cff6703f51be03b8dabb86c6df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3039c3948e6984cff6703f51be03b8dabb86c6df"}], "stats": {"total": 94, "additions": 83, "deletions": 11}, "files": [{"sha": "dc650fed5f43ca464beda545aa7b0f944ab5b46c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f80c558f5903ad6455cd5fc570f40d6efee44289", "patch": "@@ -1,3 +1,9 @@\n+2010-02-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43072\n+\t* dependency.c (gfc_full_array_ref_p): Check for contiguous by\n+\tchecking the rest of the dimensions for elements.\n+\n 2010-02-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/35259"}, {"sha": "524451c5cc7d4858f92d9fccf63549964eb1392e", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=f80c558f5903ad6455cd5fc570f40d6efee44289", "patch": "@@ -1272,6 +1272,7 @@ bool\n gfc_full_array_ref_p (gfc_ref *ref, bool *contiguous)\n {\n   int i;\n+  int n;\n   bool lbound_OK = true;\n   bool ubound_OK = true;\n \n@@ -1280,27 +1281,36 @@ gfc_full_array_ref_p (gfc_ref *ref, bool *contiguous)\n \n   if (ref->type != REF_ARRAY)\n     return false;\n+\n   if (ref->u.ar.type == AR_FULL)\n     {\n       if (contiguous)\n \t*contiguous = true;\n       return true;\n     }\n+\n   if (ref->u.ar.type != AR_SECTION)\n     return false;\n   if (ref->next)\n     return false;\n \n   for (i = 0; i < ref->u.ar.dimen; i++)\n     {\n-      /* If we have a single element in the reference, we need to check\n-\t that the array has a single element and that we actually reference\n-\t the correct element.  */\n+      /* If we have a single element in the reference, for the reference\n+\t to be full, we need to ascertain that the array has a single\n+\t element in this dimension and that we actually reference the\n+\t correct element.  */\n       if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT)\n \t{\n-\t  /* This is a contiguous reference.  */\n+\t  /* This is unconditionally a contiguous reference if all the\n+\t     remaining dimensions are elements.  */\n \t  if (contiguous)\n-\t    *contiguous = (i + 1 == ref->u.ar.dimen);\n+\t    {\n+\t      *contiguous = true;\n+\t      for (n = i + 1; n < ref->u.ar.dimen; n++)\n+\t\tif (ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n+\t\t  *contiguous = false;\n+\t    }\n \n \t  if (!ref->u.ar.as\n \t      || !ref->u.ar.as->lower[i]\n@@ -1330,12 +1340,19 @@ gfc_full_array_ref_p (gfc_ref *ref, bool *contiguous)\n \t\t\t\t       ref->u.ar.as->upper[i])))\n \tubound_OK = false;\n       /* Check the stride.  */\n-      if (ref->u.ar.stride[i] && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n+      if (ref->u.ar.stride[i]\n+\t    && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n \treturn false;\n \n-      /* This is a contiguous reference.  */\n+      /* This is unconditionally a contiguous reference as long as all\n+\t the subsequent dimensions are elements.  */\n       if (contiguous)\n-\t*contiguous = (i + 1 == ref->u.ar.dimen);\n+\t{\n+\t  *contiguous = true;\n+\t  for (n = i + 1; n < ref->u.ar.dimen; n++)\n+\t    if (ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n+\t      *contiguous = false;\n+\t}\n \n       if (!lbound_OK || !ubound_OK)\n \treturn false;"}, {"sha": "466b065bd8181a4b32db06a37737fcb891e3fe25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f80c558f5903ad6455cd5fc570f40d6efee44289", "patch": "@@ -1,3 +1,9 @@\n+2010-02-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43072\n+\t* gfortran.dg/internal_pack_6.f90: Number of 'packs' now zero.\n+\t* gfortran.dg/internal_pack_9.f90: New test.\n+\n 2010-02-21  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/23510"}, {"sha": "51af7264bf561d0c52513ad92b898205f7edb32a", "filename": "gcc/testsuite/gfortran.dg/internal_pack_6.f90", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_6.f90?ref=f80c558f5903ad6455cd5fc570f40d6efee44289", "patch": "@@ -5,7 +5,7 @@\n ! to internal_pack and internal_unpack were being generated.\n !\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n-!!\n+!\n MODULE M1\n  TYPE T1\n    REAL :: data(10) = [(i, i = 1, 10)]\n@@ -38,7 +38,9 @@ SUBROUTINE S2\n  DO i=-4,5\n     CALL S1(data(:,i), 10, sum (data(:,i)))\n  ENDDO\n-! Being non-contiguous, this is the only time that _internal_pack is called\n+\n+! With the fix for PR41113/7 this is the only time that _internal_pack\n+! was called.  The final part of the fix for PR43072 put paid to it too.\n  DO i=-4,5\n     CALL S1(data(-2:,i), 8, sum (data(-2:,i)))\n  ENDDO\n@@ -53,5 +55,5 @@ END SUBROUTINE S2\n  call s2\n end\n ! { dg-final { cleanup-modules \"M1\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_internal_pack\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_internal_pack\" 0 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "6e69745e68ad74aae16e8a5e7224ec46136479a9", "filename": "gcc/testsuite/gfortran.dg/internal_pack_9.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80c558f5903ad6455cd5fc570f40d6efee44289/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90?ref=f80c558f5903ad6455cd5fc570f40d6efee44289", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! During the discussion of the fix for PR43072, in which unnecessary\n+! calls to internal PACK/UNPACK were being generated, the following,\n+! further unnecessary temporaries or PACk/UNPACK were found.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+! Case 1: Substring encompassing the whole string\n+subroutine foo2\n+  implicit none\n+  external foo\n+  character(len=20) :: str(2) = '1234567890'\n+  call foo(str(:)(1:20)) ! This is still not fixed.\n+end\n+\n+! Case 2: Contiguous array section\n+subroutine bar\n+  implicit none\n+  external foo\n+  integer :: a(3,3,3)\n+  call foo(a(:,:,:)) ! OK, no temporary\n+  call foo(a(:,:,1)) ! OK, no temporary\n+  call foo(a(:,2,2)) ! Used unnecessarily a temporary -FIXED\n+  call foo(a(2,:,1)) ! OK, creates a temporary(1)\n+end\n+\n+! Case 3: Stride 1 section.\n+subroutine foobar\n+  implicit none\n+  external foo\n+  integer :: A(10,10)\n+  call foo(A(3:7,4)) ! Used unnecessarily a temporary - FIXED\n+  call foo(A(:,3:7)) ! OK (no temporary)\n+  call foo(A(1:10,3:7)) ! OK (no temporary)\n+  call foo(A(4,3:7)) ! temporary OK(2)\n+  call foo(A(:,3:7:-1)) ! temporary(3) OK because of stride\n+end\n+! { dg-final { scan-tree-dump-times \"unpack\" 3 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}