{"sha": "eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVjMjc5NGMxN2M4MDJhMzAyNzg3NGFhYTQ5ZjZiYjNlNWVmOWYyMg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-05-22T16:38:05Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-05-22T16:38:05Z"}, "message": "PR 48931 Make backtrace async-signal-safe, reformat output\n\nFrom-SVN: r174030", "tree": {"sha": "1d313e75de83830a8ebf1e687e1c911765f13b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d313e75de83830a8ebf1e687e1c911765f13b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/comments", "author": null, "committer": null, "parents": [{"sha": "15f072f97b41fa6fdbc62c10a9a2c55a3295f65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f072f97b41fa6fdbc62c10a9a2c55a3295f65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f072f97b41fa6fdbc62c10a9a2c55a3295f65a"}], "stats": {"total": 349, "additions": 177, "deletions": 172}, "files": [{"sha": "6f5b0581b5a54bc8ef149afffaba6bf9c70b7c9f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -1,3 +1,20 @@\n+2011-05-22  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/48931\n+        * configure.ac: Check for backtrace_symbols_fd instead of\n+\tbacktrace_symbols, check for readlink.\n+        * config.h.in: Regenerated.\n+        * configure: Regenerated.\n+        * runtime/backtrace.c (local_strcasestr): Remove.\n+        (bt_header): New function.\n+        (dump_glibc_backtrace): Remove.\n+        (fd_gets): New function.\n+        (show_backtrace): Rework to use backtrace_symbols_fd and pipes\n+\tavoiding functions that are not async-signal-safe, reformat\n+\toutput.\n+        * runtime/main.c (store_exe_path): Try to check /proc/self/exe\n+\tfirst.\n+\n 2011-05-20  Janne Blomqvist  <jb@gcc.gnu.org>\n         Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "57f66b51ab99319ef2dba3a4f916eb0ebdd99829", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -84,8 +84,8 @@\n /* Define to 1 if you have the `backtrace' function. */\n #undef HAVE_BACKTRACE\n \n-/* Define to 1 if you have the `backtrace_symbols' function. */\n-#undef HAVE_BACKTRACE_SYMBOLS\n+/* Define to 1 if you have the `backtrace_symbols_fd' function. */\n+#undef HAVE_BACKTRACE_SYMBOLS_FD\n \n /* Define if powf is broken. */\n #undef HAVE_BROKEN_POWF\n@@ -639,6 +639,9 @@\n /* Define to 1 if you have the <pwd.h> header file. */\n #undef HAVE_PWD_H\n \n+/* Define to 1 if you have the `readlink' function. */\n+#undef HAVE_READLINK\n+\n /* libm includes round */\n #undef HAVE_ROUND\n "}, {"sha": "a716ff37fafa6379f3c20f12603d63f095c6208b", "filename": "libgfortran/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -16458,7 +16458,7 @@ _ACEOF\n fi\n done\n \n-for ac_func in clock_gettime strftime\n+for ac_func in clock_gettime strftime readlink\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n@@ -16473,7 +16473,7 @@ done\n \n \n # Check for glibc backtrace functions\n-for ac_func in backtrace backtrace_symbols\n+for ac_func in backtrace backtrace_symbols_fd\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\""}, {"sha": "74cfe441a7518b9223a3770b51cc0b7ba04d4065", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -264,10 +264,10 @@ AC_CHECK_FUNCS(sleep time ttyname signal alarm clock access fork execl)\n AC_CHECK_FUNCS(wait setmode execvp pipe dup2 close fdopen strcasestr getrlimit)\n AC_CHECK_FUNCS(gettimeofday stat fstat lstat getpwuid vsnprintf dup getcwd)\n AC_CHECK_FUNCS(localtime_r gmtime_r strerror_r getpwuid_r ttyname_r)\n-AC_CHECK_FUNCS(clock_gettime strftime)\n+AC_CHECK_FUNCS(clock_gettime strftime readlink)\n \n # Check for glibc backtrace functions\n-AC_CHECK_FUNCS(backtrace backtrace_symbols)\n+AC_CHECK_FUNCS(backtrace backtrace_symbols_fd)\n \n # Check libc for getgid, getpid, getuid\n AC_CHECK_LIB([c],[getgid],[AC_DEFINE([HAVE_GETGID],[1],[libc includes getgid])])"}, {"sha": "dff4466aa56d46bc00f2df32952bcd892d380f94", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 135, "deletions": 165, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -54,59 +54,57 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define CAN_FORK (defined(HAVE_FORK) && defined(HAVE_EXECVP) \\\n \t\t  && defined(HAVE_WAIT))\n #define GLIBC_BACKTRACE (defined(HAVE_BACKTRACE) \\\n-\t\t\t && defined(HAVE_BACKTRACE_SYMBOLS))\n+\t\t\t && defined(HAVE_BACKTRACE_SYMBOLS_FD))\n #define CAN_PIPE (CAN_FORK && defined(HAVE_PIPE) \\\n \t\t  && defined(HAVE_DUP2) && defined(HAVE_FDOPEN) \\\n \t\t  && defined(HAVE_CLOSE))\n \n \n-#if GLIBC_BACKTRACE && CAN_PIPE\n-static char *\n-local_strcasestr (const char *s1, const char *s2)\n-{\n-#ifdef HAVE_STRCASESTR\n-  return strcasestr (s1, s2);\n-#else\n+/* GDB style #NUM index for each stack frame.  */\n \n-  const char *p = s1;\n-  const size_t len = strlen (s2);\n-  const char u = *s2, v = isupper((int) *s2) ? tolower((int) *s2)\n-\t\t\t\t  : (islower((int) *s2) ? toupper((int) *s2)\n-\t\t\t\t\t\t\t: *s2);\n-\n-  while (1)\n-    {\n-      while (*p != u && *p != v && *p)\n-\tp++;\n-      if (*p == 0)\n-\treturn NULL;\n-      if (strncasecmp (p, s2, len) == 0)\n-\treturn (char *)p;\n-    }\n-#endif\n+static void \n+bt_header (int num)\n+{\n+  st_printf (\" #%d  \", num);\n }\n-#endif\n \n \n-#if GLIBC_BACKTRACE\n-static void\n-dump_glibc_backtrace (int depth, char *str[])\n-{\n-  int i;\n+/* fgets()-like function that reads a line from a fd, without\n+   needing to malloc() a buffer, and does not use locks, hence should\n+   be async-signal-safe.  */\n \n-  for (i = 0; i < depth; i++)\n+static char *\n+fd_gets (char *s, int size, int fd)\n+{\n+  for (int i = 0; i < size; i++)\n     {\n-      estr_write (\"  + \");\n-      estr_write (str[i]);\n-      estr_write (\"\\n\");\n+      char c;\n+      ssize_t nread = read (fd, &c, 1);\n+      if (nread == 1)\n+\t{\n+\t  s[i] = c;\n+\t  if (c == '\\n')\n+\t    {\n+\t      if (i + 1 < size)\n+\t\ts[i+1] = '\\0';\n+\t      else\n+\t\ts[i] = '\\0';\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  s[i] = '\\0';\n+\t  break;\n+\t}\n     }\n-\n-  free (str);\n+  return s;\n }\n-#endif\n+\n \n /* show_backtrace displays the backtrace, currently obtained by means of\n    the glibc backtrace* functions.  */\n+\n void\n show_backtrace (void)\n {\n@@ -116,176 +114,160 @@ show_backtrace (void)\n #define BUFSIZE 1024\n \n   void *trace[DEPTH];\n-  char **str;\n   int depth;\n \n   depth = backtrace (trace, DEPTH);\n   if (depth <= 0)\n     return;\n \n-  str = backtrace_symbols (trace, depth);\n-\n #if CAN_PIPE\n \n-#ifndef STDIN_FILENO\n-#define STDIN_FILENO 0\n-#endif\n-\n-#ifndef STDOUT_FILENO\n-#define STDOUT_FILENO 1\n-#endif\n-\n-#ifndef STDERR_FILENO\n-#define STDERR_FILENO 2\n-#endif\n-\n   /* We attempt to extract file and line information from addr2line.  */\n   do\n   {\n     /* Local variables.  */\n-    int f[2], pid, line, i;\n-    FILE *output;\n-    char addr_buf[DEPTH][GFC_XTOA_BUF_SIZE], func[BUFSIZE], file[BUFSIZE];\n-    char *p, *end;\n-    const char *addr[DEPTH];\n-\n-    /* Write the list of addresses in hexadecimal format.  */\n-    for (i = 0; i < depth; i++)\n-      addr[i] = gfc_xtoa ((GFC_UINTEGER_LARGEST) (intptr_t) trace[i], addr_buf[i],\n-\t\t      sizeof (addr_buf[i]));\n+    int f[2], pid, bt[2], inp[2];\n+    char addr_buf[GFC_XTOA_BUF_SIZE], func[BUFSIZE], file[BUFSIZE];\n+    char *p;\n \n     /* Don't output an error message if something goes wrong, we'll simply\n        fall back to the pstack and glibc backtraces.  */\n     if (pipe (f) != 0)\n       break;\n+    if (pipe (inp) != 0)\n+      break;\n     if ((pid = fork ()) == -1)\n       break;\n \n     if (pid == 0)\n       {\n \t/* Child process.  */\n-#define NUM_FIXEDARGS 5\n-\tchar *arg[DEPTH+NUM_FIXEDARGS+1];\n+#define NUM_FIXEDARGS 7\n+\tchar *arg[NUM_FIXEDARGS];\n \n \tclose (f[0]);\n-\tclose (STDIN_FILENO);\n+\n+\tclose (inp[1]);\n+\tif (dup2 (inp[0], STDIN_FILENO) == -1)\n+\t  _exit (1);\n+\tclose (inp[0]);\n+\n \tclose (STDERR_FILENO);\n \n \tif (dup2 (f[1], STDOUT_FILENO) == -1)\n-\t  _exit (0);\n+\t  _exit (1);\n \tclose (f[1]);\n \n \targ[0] = (char *) \"addr2line\";\n \targ[1] = (char *) \"-e\";\n \targ[2] = full_exe_path ();\n \targ[3] = (char *) \"-f\";\n \targ[4] = (char *) \"-s\";\n-\tfor (i = 0; i < depth; i++)\n-\t  arg[NUM_FIXEDARGS+i] = (char *) addr[i];\n-\targ[NUM_FIXEDARGS+depth] = NULL;\n+\targ[5] = (char *) \"-C\";\n+\targ[6] = NULL;\n \texecvp (arg[0], arg);\n-\t_exit (0);\n+\t_exit (1);\n #undef NUM_FIXEDARGS\n       }\n \n     /* Father process.  */\n     close (f[1]);\n-    wait (NULL);\n-    output = fdopen (f[0], \"r\");\n-    i = -1;\n+    close (inp[0]);\n+    if (pipe (bt) != 0)\n+      break;\n+    backtrace_symbols_fd (trace, depth, bt[1]);\n+    close (bt[1]);\n \n-    if (fgets (func, sizeof(func), output))\n+    estr_write (\"\\nBacktrace for this error:\\n\");\n+    for (int j = 0; j < depth; j++)\n       {\n-\testr_write (\"\\nBacktrace for this error:\\n\");\n-\n-\tdo\n+\tconst char *addr = gfc_xtoa \n+\t  ((GFC_UINTEGER_LARGEST) (intptr_t) trace[j], \n+\t   addr_buf, sizeof (addr_buf));\n+\n+\twrite (inp[1], addr, strlen (addr));\n+\twrite (inp[1], \"\\n\", 1);\n+\t\n+\tif (! fd_gets (func, sizeof(func), f[0]))\n+\t  goto fallback;\n+\tif (! fd_gets (file, sizeof(file), f[0]))\n+\t  goto fallback;\n+\t    \n+\tfor (p = func; *p != '\\n' && *p != '\\r'; p++)\n+\t  ;\n+\t*p = '\\0';\n+\t\n+\t/* If we only have the address, use the glibc backtrace.  */\n+\tif (func[0] == '?' && func[1] == '?' && file[0] == '?'\n+\t    && file[1] == '?')\n \t  {\n-\t    if (! fgets (file, sizeof(file), output))\n-\t      goto fallback;\n-\n-\t    i++;\n-\n-\t    for (p = func; *p != '\\n' && *p != '\\r'; p++)\n-\t      ;\n-\n-\t    *p = '\\0';\n-\n-\t    /* Try to recognize the internal libgfortran functions.  */\n-\t    if (strncasecmp (func, \"*_gfortran\", 10) == 0\n-\t\t|| strncasecmp (func, \"_gfortran\", 9) == 0\n-\t\t|| strcmp (func, \"main\") == 0 || strcmp (func, \"_start\") == 0\n-\t\t|| strcmp (func, \"_gfortrani_backtrace_handler\") == 0)\n-\t      continue;\n-\n-\t    if (local_strcasestr (str[i], \"libgfortran.so\") != NULL\n-\t\t|| local_strcasestr (str[i], \"libgfortran.dylib\") != NULL\n-\t\t|| local_strcasestr (str[i], \"libgfortran.a\") != NULL)\n-\t      continue;\n-\n-\t    /* If we only have the address, use the glibc backtrace.  */\n-\t    if (func[0] == '?' && func[1] == '?' && file[0] == '?'\n-\t\t&& file[1] == '?')\n-\t      {\n-\t\testr_write (\"  + \");\n-\t\testr_write (str[i]);\n-\t\testr_write (\"\\n\");\n-\t        continue;\n-\t      }\n-\n-\t    /* Extract the line number.  */\n-\t    for (end = NULL, p = file; *p; p++)\n-\t      if (*p == ':')\n-\t\tend = p;\n-\t    if (end != NULL)\n-\t      {\n-\t\t*end = '\\0';\n-\t\tline = atoi (++end);\n-\t      }\n-\t    else\n-\t      line = -1;\n-\n-\t    if (strcmp (func, \"MAIN__\") == 0)\n-\t      estr_write (\"  + in the main program\\n\");\n-\t    else\n+\t    bt_header (j);\n+\t    while (1)\n \t      {\n-\t\testr_write (\"  + function \");\n-\t\testr_write (func);\n-\t\testr_write (\" (0x\");\n-\t\testr_write (addr[i]);\n-\t\testr_write (\")\\n\");\n+\t\tchar bc;\n+\t\tssize_t nread = read (bt[0], &bc, 1);\n+\t\tif (nread != 1 || bc == '\\n')\n+\t\t  break;\n+\t\twrite (STDERR_FILENO, &bc, 1);\n \t      }\n-\n-\t    if (line <= 0 && strcmp (file, \"??\") == 0)\n-\t      continue;\n-\n-\t    if (line <= 0)\n+\t    estr_write (\"\\n\");\n+\t    continue;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Forward to the next entry in the backtrace. */\n+\t    while (1)\n \t      {\n-\t\testr_write (\"    from file \");\n-\t\testr_write (file);\n-\t\testr_write (\"\\n\");\n+\t\tchar bc;\n+\t\tssize_t nread = read (bt[0], &bc, 1);\n+\t\tif (nread != 1 || bc == '\\n')\n+\t\t  break;\n \t      }\n-\t    else\n-\t      st_printf (\"    at line %d of file %s\\n\", line, file);\n \t  }\n-\twhile (fgets (func, sizeof(func), output));\n \n-\tfree (str);\n-\treturn;\n+\t/* _start is a setup routine that calls main(), and main() is\n+\t   the frontend routine that calls some setup stuff and then\n+\t   calls MAIN__, so at this point we should stop.  */\n+\tif (strcmp (func, \"_start\") == 0 || strcmp (func, \"main\") == 0)\n+\t  break;\n+\t\n+\tbt_header (j);\n+\testr_write (full_exe_path ());\n+\testr_write (\"[0x\");\n+\testr_write (addr);\n+\testr_write (\"] in \");\n+\testr_write (func);\n+\t\n+\tif (strncmp (file, \"??\", 2) == 0)\n+\t  estr_write (\"\\n\");\n+\telse\n+\t  {\n+\t    estr_write (\" at \");\n+\t    estr_write (file);\n+\t  }\n+      } /* Loop over each hex address.  */\n+    close (inp[1]);\n+    close (bt[0]);\n+    wait (NULL);\n+    return;\n \n fallback:\n-\testr_write (\"** Something went wrong while running addr2line. **\\n\"\n-\t\t    \"** Falling back  to a simpler  backtrace scheme. **\\n\");\n-      }\n-    }\n+    estr_write (\"** Something went wrong while running addr2line. **\\n\"\n+\t\t\"** Falling back  to a simpler  backtrace scheme. **\\n\");\n+  }\n   while (0);\n \n #undef DEPTH\n #undef BUFSIZE\n \n-#endif\n-#endif\n+#endif /* CAN_PIPE */\n+\n+  /* Fallback to the glibc backtrace.  */\n+  estr_write (\"\\nBacktrace for this error:\\n\");\n+  backtrace_symbols_fd (trace, depth, STDERR_FILENO);\n+  return;\n \n-#if CAN_FORK && defined(HAVE_GETPPID)\n+#elif defined(CAN_FORK) && defined(HAVE_GETPPID)\n   /* Try to call pstack.  */\n   do\n   {\n@@ -312,29 +294,17 @@ show_backtrace (void)\n \texecvp (arg[0], arg);\n #undef NUM_ARGS\n \n-\t/* pstack didn't work, so we fall back to dumping the glibc\n-\t   backtrace if we can.  */\n-#if GLIBC_BACKTRACE\n-\tdump_glibc_backtrace (depth, str);\n-#else\n+\t/* pstack didn't work.  */\n \testr_write (\"  unable to produce a backtrace, sorry!\\n\");\n-#endif\n-\n-\t_exit (0);\n+\t_exit (1);\n       }\n \n     /* Father process.  */\n     wait (NULL);\n     return;\n   }\n   while(0);\n-#endif\n-\n-#if GLIBC_BACKTRACE\n-  /* Fallback to the glibc backtrace.  */\n-  estr_write (\"\\nBacktrace for this error:\\n\");\n-  dump_glibc_backtrace (depth, str);\n-  return;\n-#endif\n+#else\n   estr_write (\"\\nBacktrace not yet available on this platform, sorry!\\n\");\n+#endif\n }"}, {"sha": "54d9e091ce2413d2770e813867c420057204a25a", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec2794c17c802a3027874aaa49f6bb3e5ef9f22/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=eec2794c17c802a3027874aaa49f6bb3e5ef9f22", "patch": "@@ -92,6 +92,19 @@ store_exe_path (const char * argv0)\n   if (please_free_exe_path_when_done)\n     free ((char *) exe_path);\n \n+  /* Reading the /proc/self/exe symlink is Linux-specific(?), but if\n+     it works it gives the correct answer.  */\n+#ifdef HAVE_READLINK\n+  int len;\n+  if ((len = readlink (\"/proc/self/exe\", buf, sizeof (buf) - 1)) != -1)\n+    {\n+      buf[len] = '\\0';\n+      exe_path = strdup (buf);\n+      please_free_exe_path_when_done = 1;\n+      return;\n+    }\n+#endif\n+\n   /* On the simulator argv is not set.  */\n   if (argv0 == NULL || argv0[0] == '/')\n     {\n@@ -107,7 +120,9 @@ store_exe_path (const char * argv0)\n   cwd = \"\";\n #endif\n \n-  /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\" */\n+  /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\".  This will not work\n+     if the executable is not in the cwd, but at this point we're out\n+     of better ideas.  */\n   size_t pathlen = strlen (cwd) + 1 + strlen (argv0) + 1;\n   path = malloc (pathlen);\n   snprintf (path, pathlen, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);"}]}