{"sha": "37f33df706851a00b2f5c0d429f6b273e8ab0029", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdmMzNkZjcwNjg1MWEwMGIyZjVjMGQ0MjlmNmIyNzNlOGFiMDAyOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-17T01:07:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-17T01:07:54Z"}, "message": "libstdc++: Define C++20 range utilities and range factories\n\nThis adds another chunk of the <ranges> header.\n\nThe changes from P1456R1 (Move-only views) and P1862R1 (Range adaptors\nfor non-copyable iterators) are included, but not the changes from\nP1870R1 (forwarding-range<T> is too subtle).\n\nThe tests for subrange and iota_view are poor and should be improved.\n\n\t* include/bits/regex.h (match_results): Specialize __enable_view_impl.\n\t* include/bits/stl_set.h (set): Likewise.\n\t* include/bits/unordered_set.h (unordered_set, unordered_multiset):\n\tLikewise.\n\t* include/debug/multiset.h (__debug::multiset): Likewise.\n\t* include/debug/set.h (__debug::set): Likewise.\n\t* include/debug/unordered_set (__debug::unordered_set)\n\t(__debug::unordered_multiset): Likewise.\n\t* include/std/ranges (ranges::view, ranges::enable_view)\n\t(ranges::view_interface, ranges::subrange, ranges::empty_view)\n\t(ranges::single_view, ranges::views::single, ranges::iota_view)\n\t(ranges::views::iota): Define for C++20.\n\t* testsuite/std/ranges/empty_view.cc: New test.\n\t* testsuite/std/ranges/iota_view.cc: New test.\n\t* testsuite/std/ranges/single_view.cc: New test.\n\t* testsuite/std/ranges/view.cc: New test.\n\nFrom-SVN: r278370", "tree": {"sha": "89d2a3044496f079abefbef51db26f0773923781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89d2a3044496f079abefbef51db26f0773923781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37f33df706851a00b2f5c0d429f6b273e8ab0029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37f33df706851a00b2f5c0d429f6b273e8ab0029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37f33df706851a00b2f5c0d429f6b273e8ab0029", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37f33df706851a00b2f5c0d429f6b273e8ab0029/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbd2539e1ff2a6155cd5c685aab165fdc760ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efbd2539e1ff2a6155cd5c685aab165fdc760ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efbd2539e1ff2a6155cd5c685aab165fdc760ab0"}], "stats": {"total": 1210, "additions": 1209, "deletions": 1}, "files": [{"sha": "dad29e03f81761c1c50fb2fe49e39e12549db63c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -1,3 +1,22 @@\n+2019-11-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/regex.h (match_results): Specialize __enable_view_impl.\n+\t* include/bits/stl_set.h (set): Likewise.\n+\t* include/bits/unordered_set.h (unordered_set, unordered_multiset):\n+\tLikewise.\n+\t* include/debug/multiset.h (__debug::multiset): Likewise.\n+\t* include/debug/set.h (__debug::set): Likewise.\n+\t* include/debug/unordered_set (__debug::unordered_set)\n+\t(__debug::unordered_multiset): Likewise.\n+\t* include/std/ranges (ranges::view, ranges::enable_view)\n+\t(ranges::view_interface, ranges::subrange, ranges::empty_view)\n+\t(ranges::single_view, ranges::views::single, ranges::iota_view)\n+\t(ranges::views::iota): Define for C++20.\n+\t* testsuite/std/ranges/empty_view.cc: New test.\n+\t* testsuite/std/ranges/iota_view.cc: New test.\n+\t* testsuite/std/ranges/single_view.cc: New test.\n+\t* testsuite/std/ranges/view.cc: New test.\n+\n 2019-11-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/std/ranges: Revert accidentally committed changes."}, {"sha": "49994369563986d1bb6a34b97cdb49c88bf40660", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -2056,9 +2056,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t match_results<_Bi_iter, _Alloc>& __rhs) noexcept\n     { __lhs.swap(__rhs); }\n \n-\n _GLIBCXX_END_NAMESPACE_CXX11\n \n+#if __cplusplus > 201703L\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Bi_iter, typename _Alloc>\n+    inline constexpr bool __enable_view_impl<match_results<_Bi_iter, _Alloc>>\n+      = false;\n+} // namespace ranges::__detail\n+#endif // C++20\n+\n   // [28.11.2] Function template regex_match\n   /**\n    * @name Matching, Searching, and Replacing"}, {"sha": "9e34961f4a56375e85208b1ec2888c7922c20a19", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -1039,6 +1039,16 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       { return __set._M_t; }\n     };\n \n+#if __cplusplus > 201703L\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<_GLIBCXX_STD_C::multiset<_Key, _Compare, _Alloc>>\n+\t= false;\n+} // namespace ranges::__detail\n+#endif // C++20\n #endif // C++17\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "135d57af4961d811063db75f8db43908125ab6ef", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -1051,6 +1051,15 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)\n       { return __set._M_t; }\n     };\n+#if __cplusplus > 201703L\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<_GLIBCXX_STD_C::set<_Key, _Compare, _Alloc>> = false;\n+} // namespace ranges::__detail\n+#endif // C++20\n #endif // C++17\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "98943fb1a47c6992d8c8f17ac24e0624f8649c69", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -1771,6 +1771,21 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)\n       { return __set._M_h; }\n     };\n+\n+#if __cplusplus > 201703L\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Val, typename _Hash, typename _Eq, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<_GLIBCXX_STD_C::unordered_set<_Val, _Hash, _Eq,\n+\t\t\t\t\t\t       _Alloc>> = false;\n+  template<typename _Val, typename _Hash, typename _Eq, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<_GLIBCXX_STD_C::unordered_multiset<_Val, _Hash, _Eq,\n+\t\t\t\t\t\t\t    _Alloc>> = false;\n+} // namespace ranges::__detail\n+#endif // C++20\n #endif // C++17\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "00c5bcc0f24f58affc0b7c6da184da4903e5f87f", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -630,6 +630,19 @@ namespace __debug\n     { return __x.swap(__y); }\n \n } // namespace __debug\n+\n+#if __cplusplus > 201703L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<std::__debug::multiset<_Key, _Compare, _Alloc>>\n+\t= false;\n+} // namespace ranges::__detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++20\n } // namespace std\n \n #endif"}, {"sha": "16eee2947c913b305ee4c64bd63d9e1e24dcc6e3", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -641,6 +641,18 @@ namespace __debug\n     { return __x.swap(__y); }\n \n } // namespace __debug\n+\n+#if __cplusplus > 201703L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<std::__debug::set<_Key, _Compare, _Alloc>> = false;\n+} // namespace ranges::__detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++20\n } // namespace std\n \n #endif"}, {"sha": "5dbb754a1002a6fb70238921a8838f850c78fa99", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -1183,6 +1183,22 @@ namespace __debug\n     { return !(__x == __y); }\n \n } // namespace __debug\n+#if __cplusplus > 201703L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges::__detail\n+{\n+  template<typename _Tp> inline constexpr bool __enable_view_impl;\n+  template<typename _Val, typename _Hash, typename _Eq, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<std::__debug::unordered_set<_Val, _Hash, _Eq, _Alloc>>\n+\t= false;\n+  template<typename _Val, typename _Hash, typename _Eq, typename _Alloc>\n+    inline constexpr bool\n+      __enable_view_impl<std::__debug::unordered_multiset<_Val, _Hash, _Eq,\n+\t\t\t\t\t\t\t  _Alloc>> = false;\n+} // namespace ranges::__detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++20\n } // namespace std\n \n #endif // C++11"}, {"sha": "333d110b67e6637b91c4a58d7a190889bb1e85d2", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 879, "deletions": 0, "changes": 879, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -38,7 +38,11 @@\n \n #if __cpp_lib_concepts\n \n+#include <compare>\n+#include <initializer_list>\n #include <iterator>\n+#include <limits>\n+#include <optional>\n \n /**\n  * @defgroup ranges Ranges\n@@ -68,6 +72,12 @@ namespace ranges\n     using range_rvalue_reference_t\n       = iter_rvalue_reference_t<iterator_t<_Range>>;\n \n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __forwarding_range = range<_Tp> && __range_impl<_Tp>;\n+  } // namespace __detail\n+\n   // [range.sized] The sized_range concept.\n   // Defined in <bits/range_iterator.h>\n   // template<typename> concept sized_range;\n@@ -104,6 +114,875 @@ namespace ranges\n   template<typename _Tp>\n     concept common_range\n       = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n+\n+  struct view_base { };\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __deep_const_range = range<_Tp> && range<const _Tp>\n+\t&& same_as<range_reference_t<_Tp>, range_reference_t<const _Tp>>;\n+\n+    template<typename _Tp>\n+      inline constexpr bool __enable_view_impl\n+\t= derived_from<_Tp, view_base> || (!__deep_const_range<_Tp>);\n+\n+    template<typename _Tp>\n+      inline constexpr bool __enable_view_impl<std::initializer_list<_Tp>>\n+\t= false;\n+\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    inline constexpr bool enable_view\n+      = __detail::__enable_view_impl<remove_cv_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept view\n+      = range<_Tp> && movable<_Tp> && default_initializable<_Tp>\n+\t&& enable_view<_Tp>;\n+\n+  template<typename _Tp>\n+    concept viewable_range = range<_Tp>\n+      && (__detail::__forwarding_range<_Tp> || view<decay_t<_Tp>>);\n+\n+  namespace __detail\n+  {\n+    template<typename _Range>\n+      concept __simple_view = view<_Range> && range<const _Range>\n+\t&& same_as<iterator_t<_Range>, iterator_t<const _Range>>\n+\t&& same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;\n+\n+    template<typename _It>\n+      concept __has_arrow = input_iterator<_It>\n+\t&& (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });\n+\n+    template<typename _Tp, typename _Up>\n+      concept __not_same_as\n+\t= !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;\n+  } // namespace __detail\n+\n+  template<typename _Derived>\n+    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n+    class view_interface : public view_base\n+    {\n+    private:\n+      constexpr _Derived& _M_derived() noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<_Derived&>(*this);\n+      }\n+\n+      constexpr const _Derived& _M_derived() const noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<const _Derived&>(*this);\n+      }\n+\n+    public:\n+      constexpr bool\n+      empty() requires forward_range<_Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr bool\n+      empty() const requires forward_range<const _Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() const requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr auto\n+      data() requires contiguous_iterator<iterator_t<_Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      data() const\n+      requires range<const _Derived>\n+\t&& contiguous_iterator<iterator_t<const _Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      size()\n+      requires forward_range<_Derived>\n+\t&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr auto\n+      size() const\n+      requires forward_range<const _Derived>\n+\t&& sized_sentinel_for<sentinel_t<const _Derived>,\n+\t\t\t      iterator_t<const _Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr decltype(auto)\n+      front() requires forward_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      front() const requires forward_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      back()\n+      requires bidirectional_range<_Derived> && common_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      constexpr decltype(auto)\n+      back() const\n+      requires bidirectional_range<const _Derived>\n+\t&& common_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      template<random_access_range _Range = _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n)\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+\n+      template<random_access_range _Range = const _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n) const\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __pair_like\n+\t= !is_reference_v<_Tp> && requires(_Tp __t)\n+\t{\n+\t  typename tuple_size<_Tp>::type;\n+\t  requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;\n+\t  typename tuple_element_t<0, remove_const_t<_Tp>>;\n+\t  typename tuple_element_t<1, remove_const_t<_Tp>>;\n+\t  { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;\n+\t  { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;\n+\t};\n+\n+    template<typename _Tp, typename _Up, typename _Vp>\n+      concept __pair_like_convertible_to\n+\t= !range<_Tp> && __pair_like<remove_reference_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { get<0>(std::forward<_Tp>(__t)) } -> convertible_to<_Up>;\n+\t  { get<1>(std::forward<_Tp>(__t)) } -> convertible_to<_Vp>;\n+\t};\n+\n+    template<typename _Tp, typename _Up, typename _Vp>\n+      concept __pair_like_convertible_from\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& constructible_from<_Tp, _Up, _Vp>;\n+\n+    template<typename _Tp>\n+      concept __iterator_sentinel_pair\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;\n+\n+    template<typename _Tp, bool _MaxDiff = same_as<_Tp, __max_diff_type>>\n+      using __make_unsigned_like_t\n+\t= conditional_t<_MaxDiff, __max_size_type, make_unsigned_t<_Tp>>;\n+\n+  } // namespace __detail\n+\n+  enum class subrange_kind : bool { unsized, sized };\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,\n+\t   subrange_kind _Kind = sized_sentinel_for<_Sent, _It>\n+\t     ? subrange_kind::sized : subrange_kind::unsized>\n+    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)\n+    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>\n+    {\n+    private:\n+      static constexpr bool _S_store_size\n+\t= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;\n+\n+      _It _M_begin = _It();\n+      _Sent _M_end = _Sent();\n+\n+      template<typename, bool = _S_store_size>\n+\tstruct _Size\n+\t{ };\n+\n+      template<typename _Tp>\n+\tstruct _Size<_Tp, true>\n+\t{ __detail::__make_unsigned_like_t<_Tp> _M_size; };\n+\n+      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};\n+\n+    public:\n+      subrange() = default;\n+\n+      constexpr\n+      subrange(_It __i, _Sent __s) requires (!_S_store_size)\n+      : _M_begin(std::move(__i)), _M_end(__s)\n+      { }\n+\n+      constexpr\n+      subrange(_It __i, _Sent __s,\n+\t       __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+      : _M_begin(std::move(__i)), _M_end(__s)\n+      {\n+\tusing __detail::__to_unsigned_like;\n+\t__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));\n+\tif constexpr (_S_store_size)\n+\t  _M_size._M_size = __n;\n+      }\n+\n+      template<__detail::__not_same_as<subrange> _Rng>\n+\trequires __detail::__forwarding_range<_Rng>\n+\t  && convertible_to<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r) requires (!_S_store_size || sized_range<_Rng>)\n+\t: subrange{ranges::begin(__r), ranges::end(__r)}\n+\t{\n+\t  if constexpr (_S_store_size)\n+\t    _M_size._M_size = ranges::size(__r);\n+\t}\n+\n+      template<__detail::__forwarding_range _Rng>\n+\trequires convertible_to<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r,\n+\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+\t: subrange{ranges::begin(__r), ranges::end(__r), __n}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _PairLike>\n+\trequires __detail::__pair_like_convertible_to<_PairLike, _It, _Sent>\n+\tconstexpr\n+\tsubrange(_PairLike&& __r) requires (!_S_store_size)\n+\t: subrange{std::get<0>(std::forward<_PairLike>(__r)),\n+\t\t   std::get<1>(std::forward<_PairLike>(__r))}\n+\t{ }\n+\n+      template<__detail::__pair_like_convertible_to<_It, _Sent> _PairLike>\n+\tconstexpr\n+\tsubrange(_PairLike&& __r,\n+\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+\t: subrange{std::get<0>(std::forward<_PairLike>(__r)),\n+\t\t   std::get<1>(std::forward<_PairLike>(__r)), __n}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _PairLike>\n+\trequires __detail::__pair_like_convertible_from<_PairLike, const _It&,\n+\t\t\t\t\t\t\tconst _Sent&>\n+      constexpr\n+      operator _PairLike() const\n+      { return _PairLike(_M_begin, _M_end); }\n+\n+      constexpr _It\n+      begin() const requires copyable<_It>\n+      { return _M_begin; }\n+\n+      [[nodiscard]] constexpr _It\n+      begin() requires (!copyable<_It>)\n+      { return std::move(_M_begin); }\n+\n+      constexpr _Sent end() const { return _M_end; }\n+\n+      constexpr bool empty() const { return _M_begin == _M_end; }\n+\n+      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>\n+      size() const requires (_Kind == subrange_kind::sized)\n+      {\n+\tif constexpr (_S_store_size)\n+\t  return _M_size._M_size;\n+\telse\n+\t  return __detail::__to_unsigned_like(_M_end - _M_begin);\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      next(iter_difference_t<_It> __n = 1) const &\n+\trequires forward_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(__n);\n+\treturn __tmp;\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      next(iter_difference_t<_It> __n = 1) &&\n+      {\n+\tadvance(__n);\n+\treturn std::move(*this);\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      prev(iter_difference_t<_It> __n = 1) const\n+\trequires bidirectional_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(--__n);\n+\treturn __tmp;\n+      }\n+\n+      constexpr subrange&\n+      advance(iter_difference_t<_It> __n)\n+      {\n+\tif constexpr (_S_store_size)\n+\t  {\n+\t    auto __d = __n - ranges::advance(_M_begin, __n, _M_end);\n+\t    if (__d >= 0)\n+\t      _M_size._M_size -= __detail::__to_unsigned_like(__d);\n+\t    else\n+\t      _M_size._M_size += __detail::__to_unsigned_like(-__d);\n+\t  }\n+\telse\n+\t  ranges::advance(_M_begin, __n, _M_end);\n+\treturn *this;\n+      }\n+\n+      friend constexpr _It\n+      begin(subrange&& __r) { return __r.begin(); }\n+\n+      friend constexpr _Sent\n+      end(subrange&& __r) { return __r.end(); }\n+    };\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    subrange(_It, _Sent,\n+\t     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)\n+      -> subrange<_It, _Sent, subrange_kind::sized>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<\n+\t\t\t\t\t\t     tuple_element_t<0, _Pr>>>)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,\n+\t\t  subrange_kind::sized>;\n+\n+  template<__detail::__forwarding_range _Rng>\n+    subrange(_Rng&&)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,\n+\t\t (sized_range<_Rng>\n+\t\t  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)\n+\t\t ? subrange_kind::sized : subrange_kind::unsized>;\n+\n+  template<__detail::__forwarding_range _Rng>\n+    subrange(_Rng&&,\n+\t     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;\n+\n+  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n+    requires (_Num < 2)\n+    constexpr auto\n+    get(const subrange<_It, _Sent, _Kind>& __r)\n+    {\n+      if constexpr (_Num == 0)\n+\treturn __r.begin();\n+      else\n+\treturn __r.end();\n+    }\n+\n+  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n+    requires (_Num < 2)\n+    constexpr auto\n+    get(subrange<_It, _Sent, _Kind>&& __r)\n+    {\n+      if constexpr (_Num == 0)\n+\treturn __r.begin();\n+      else\n+\treturn __r.end();\n+    }\n+} // namespace ranges\n+\n+  using ranges::get;\n+\n+namespace ranges\n+{\n+  /// Type returned by algorithms instead of a dangling iterator or subrange.\n+  struct dangling\n+  {\n+    constexpr dangling() noexcept = default;\n+    template<typename... _Args>\n+      constexpr dangling(_Args&&...) noexcept { }\n+  };\n+\n+  template<typename _Tp> requires is_object_v<_Tp>\n+    class empty_view : public view_interface<empty_view<_Tp>>\n+    {\n+    public:\n+      static constexpr _Tp* begin() noexcept { return nullptr; }\n+      static constexpr _Tp* end() noexcept { return nullptr; }\n+      static constexpr _Tp* data() noexcept { return nullptr; }\n+      static constexpr size_t size() noexcept { return 0; }\n+      static constexpr bool empty() noexcept { return true; }\n+\n+      friend constexpr _Tp* begin(empty_view) noexcept { return nullptr; }\n+      friend constexpr _Tp* end(empty_view) noexcept { return nullptr; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<copy_constructible _Tp> requires is_object_v<_Tp>\n+      struct __box : std::optional<_Tp>\n+      {\n+\tusing std::optional<_Tp>::optional;\n+\n+\tconstexpr\n+\t__box()\n+\tnoexcept(is_nothrow_default_constructible_v<_Tp>)\n+\trequires default_initializable<_Tp>\n+\t: std::optional<_Tp>{std::in_place}\n+\t{ }\n+\n+\tusing std::optional<_Tp>::operator=;\n+\n+\t__box&\n+\toperator=(const __box& __that)\n+\tnoexcept(is_nothrow_copy_constructible_v<_Tp>)\n+\trequires (!assignable_from<_Tp&, const _Tp&>)\n+\t{\n+\t  if ((bool)__that)\n+\t    this->emplace(*__that);\n+\t  else\n+\t    this->reset();\n+\t  return *this;\n+\t}\n+\n+\t__box&\n+\toperator=(__box&& __that)\n+\tnoexcept(is_nothrow_move_constructible_v<_Tp>)\n+\trequires (!assignable_from<_Tp&, _Tp>)\n+\t{\n+\t  if ((bool)__that)\n+\t    this->emplace(std::move(*__that));\n+\t  else\n+\t    this->reset();\n+\t  return *this;\n+\t}\n+      };\n+\n+  } // namespace __detail\n+\n+  /// A view that contains exactly one element.\n+  template<copy_constructible _Tp> requires is_object_v<_Tp>\n+    class single_view : public view_interface<single_view<_Tp>>\n+    {\n+    public:\n+      single_view() = default;\n+\n+      constexpr explicit\n+      single_view(const _Tp& __t)\n+      : _M_value(__t)\n+      { }\n+\n+      constexpr explicit\n+      single_view(_Tp&& __t)\n+      : _M_value(std::move(__t))\n+      { }\n+\n+      template<typename... _Args>\n+\trequires constructible_from<_Tp, _Args...>\n+\tconstexpr\n+\tsingle_view(in_place_t, _Args&&... __args)\n+\t: _M_value{in_place, std::forward<_Args>(__args)...}\n+\t{ }\n+\n+      constexpr _Tp*\n+      begin() noexcept\n+      { return data(); }\n+\n+      constexpr const _Tp*\n+      begin() const noexcept\n+      { return data(); }\n+\n+      constexpr _Tp*\n+      end() noexcept\n+      { return data() + 1; }\n+\n+      constexpr const _Tp*\n+      end() const noexcept\n+      { return data() + 1; }\n+\n+      static constexpr size_t\n+      size() noexcept\n+      { return 1; }\n+\n+      constexpr _Tp*\n+      data() noexcept\n+      { return _M_value.operator->(); }\n+\n+      constexpr const _Tp*\n+      data() const noexcept\n+      { return _M_value.operator->(); }\n+\n+    private:\n+      __detail::__box<_Tp> _M_value;\n+    };\n+\n+  namespace __detail\n+  {\n+    template<typename _Wp>\n+      constexpr auto __to_signed_like(_Wp __w) noexcept\n+      {\n+\tif constexpr (!integral<_Wp>)\n+\t  return iter_difference_t<_Wp>();\n+\telse if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))\n+\t  return iter_difference_t<_Wp>(__w);\n+\telse if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))\n+\t  return ptrdiff_t(__w);\n+\telse if constexpr (sizeof(long long) > sizeof(_Wp))\n+\t  return (long long)(__w);\n+#ifdef __SIZEOF_INT128__\n+\telse if constexpr (__SIZEOF_INT128__ > sizeof(_Wp))\n+\t  return __int128(__w);\n+#endif\n+\telse\n+\t  return __max_diff_type(__w);\n+      }\n+\n+    template<typename _Wp>\n+      using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));\n+\n+    template<typename _It>\n+      concept __decrementable = incrementable<_It>\n+\t&& requires(_It __i)\n+\t{\n+\t    { --__i } -> same_as<_It&>;\n+\t    { __i-- } -> same_as<_It>;\n+\t};\n+\n+    template<typename _It>\n+      concept __advanceable = __decrementable<_It> && totally_ordered<_It>\n+\t&& requires( _It __i, const _It __j, const __iota_diff_t<_It> __n)\n+\t{\n+\t  { __i += __n } -> same_as<_It&>;\n+\t  { __i -= __n } -> same_as<_It&>;\n+\t  _It(__j + __n);\n+\t  _It(__n + __j);\n+\t  _It(__j - __n);\n+\t  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;\n+\t};\n+\n+  } // namespace __detail\n+\n+  template<weakly_incrementable _Winc,\n+\t   semiregular _Bound = unreachable_sentinel_t>\n+    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound>\n+    class iota_view : public view_interface<iota_view<_Winc, _Bound>>\n+    {\n+    private:\n+      struct _Iterator\n+      {\n+      private:\n+\tstatic auto\n+\t_S_iter_cat()\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__advanceable<_Winc>)\n+\t    return random_access_iterator_tag{};\n+\t  else if constexpr (__decrementable<_Winc>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (incrementable<_Winc>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return input_iterator_tag{};\n+\t}\n+\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+\tusing value_type = _Winc;\n+\tusing difference_type = __detail::__iota_diff_t<_Winc>;\n+\n+\t_Iterator() = default;\n+\n+\tconstexpr explicit\n+\t_Iterator(_Winc __value)\n+\t: _M_value(__value) { }\n+\n+\tconstexpr _Winc\n+\toperator*() const noexcept(is_nothrow_copy_constructible_v<_Winc>)\n+\t{ return _M_value; }\n+\n+\tconstexpr _Iterator&\n+\toperator++()\n+\t{\n+\t  ++_M_value;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr void\n+\toperator++(int)\n+\t{ ++*this; }\n+\n+\tconstexpr _Iterator\n+\toperator++(int) requires incrementable<_Winc>\n+\t{\n+\t  auto __tmp = *this;\n+\t  ++*this;\n+\t  return __tmp;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator--() requires __detail::__decrementable<_Winc>\n+\t{\n+\t  --_M_value;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Iterator\n+\toperator--(int) requires __detail::__decrementable<_Winc>\n+\t{\n+\t  auto __tmp = *this;\n+\t  --*this;\n+\t  return __tmp;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator+=(difference_type __n) requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__is_integer_like<_Winc>\n+\t      && !__is_signed_integer_like<_Winc>)\n+\t    {\n+\t      if (__n >= difference_type(0))\n+\t\t_M_value += static_cast<_Winc>(__n);\n+\t      else\n+\t\t_M_value -= static_cast<_Winc>(-__n);\n+\t    }\n+\t  else\n+\t    _M_value += __n;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator-=(difference_type __n) requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__is_integer_like<_Winc>\n+\t      && !__is_signed_integer_like<_Winc>)\n+\t    {\n+\t      if (__n >= difference_type(0))\n+\t\t_M_value -= static_cast<_Winc>(__n);\n+\t      else\n+\t\t_M_value += static_cast<_Winc>(-__n);\n+\t    }\n+\t  else\n+\t    _M_value -= __n;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Winc\n+\toperator[](difference_type __n) const\n+\trequires __detail::__advanceable<_Winc>\n+\t{ return _Winc(_M_value + __n); }\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Iterator& __y)\n+\trequires equality_comparable<_Winc>\n+\t{ return __x._M_value == __y._M_value; }\n+\n+\tfriend constexpr bool\n+\toperator<(const _Iterator& __x, const _Iterator& __y)\n+\trequires totally_ordered<_Winc>\n+\t{ return __x._M_value < __y._M_value; }\n+\n+\tfriend constexpr bool\n+\toperator>(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return __y < __x; }\n+\n+\tfriend constexpr bool\n+\toperator<=(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return !(__y < __x); }\n+\n+\tfriend constexpr bool\n+\toperator>=(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return !(__x < __y); }\n+\n+#ifdef __cpp_lib_threeway_comparison\n+\tfriend constexpr compare_three_way_result_t<_Winc>\n+\toperator<=>(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc> && three_way_comparable<_Winc>\n+\t{ return __x._M_value <=> __y._M_value; }\n+#endif\n+\n+\tfriend constexpr _Iterator\n+\toperator+(_Iterator __i, difference_type __n)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i += __n; }\n+\n+\tfriend constexpr _Iterator\n+\toperator+(difference_type __n, _Iterator __i)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i += __n; }\n+\n+\tfriend constexpr _Iterator\n+\toperator-(_Iterator __i, difference_type __n)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i -= __n; }\n+\n+\tfriend constexpr difference_type\n+\toperator-(const _Iterator& __x, const _Iterator& __y)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  using _Dt = difference_type;\n+\t  if constexpr (__is_integer_like<_Winc>)\n+\t    {\n+\t      if constexpr (__is_signed_integer_like<_Winc>)\n+\t\treturn _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));\n+\t      else\n+\t\treturn (__y._M_value > __x._M_value)\n+\t\t  ? _Dt(-_Dt(__y._M_value - __x._M_value))\n+\t\t  : _Dt(__x._M_value - __y._M_value);\n+\t    }\n+\t  else\n+\t    return __x._M_value - __y._M_value;\n+\t}\n+\n+      private:\n+\t_Winc _M_value = _Winc();\n+      };\n+\n+      struct _Sentinel\n+      {\n+      private:\n+\t_Bound _M_bound = _Bound();\n+\n+      public:\n+\t_Sentinel() = default;\n+\n+\tconstexpr explicit\n+\t_Sentinel(_Bound __bound)\n+\t: _M_bound(__bound) { }\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Sentinel& __y)\n+\t{ return __x._M_value == __y._M_bound; }\n+\n+\tfriend constexpr iter_difference_t<_Winc>\n+\toperator-(const _Iterator& __x, const _Sentinel& __y)\n+\t  requires sized_sentinel_for<_Bound, _Winc>\n+\t{ return __x._M_value - __y._M_bound; }\n+\n+\tfriend constexpr iter_difference_t<_Winc>\n+\toperator-(const _Sentinel& __x, const _Iterator& __y)\n+\t  requires sized_sentinel_for<_Bound, _Winc>\n+\t{ return -(__y - __x); }\n+      };\n+\n+      _Winc _M_value = _Winc();\n+      _Bound _M_bound = _Bound();\n+\n+    public:\n+      iota_view() = default;\n+\n+      constexpr explicit\n+      iota_view(_Winc __value)\n+      : _M_value(__value)\n+      { }\n+\n+      constexpr\n+      iota_view(type_identity_t<_Winc> __value,\n+\t\ttype_identity_t<_Bound> __bound)\n+      : _M_value(__value), _M_bound(__bound)\n+      {\n+\tif constexpr (totally_ordered_with<_Winc, _Bound>)\n+\t  __glibcxx_assert( bool(__value <= __bound) );\n+      }\n+\n+      constexpr _Iterator\n+      begin() const { return _Iterator{_M_value}; }\n+\n+      constexpr auto\n+      end() const\n+      {\n+\tif constexpr (same_as<_Bound, unreachable_sentinel_t>)\n+\t  return unreachable_sentinel;\n+\telse\n+\t  return _Sentinel{_M_bound};\n+      }\n+\n+      constexpr _Iterator\n+      end() const requires same_as<_Winc, _Bound>\n+      { return _Iterator{_M_bound}; }\n+\n+      constexpr auto\n+      size() const\n+      requires (same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>)\n+      || (integral<_Winc> && integral<_Bound>)\n+      || sized_sentinel_for<_Bound, _Winc>\n+      {\n+\tusing namespace __detail;\n+\tif constexpr (__is_integer_like<_Winc> && __is_integer_like<_Bound>)\n+\t  return (_M_value < 0)\n+\t    ? ((_M_bound < 0)\n+\t\t? __to_unsigned_like(-_M_value) - __to_unsigned_like(-_M_bound)\n+\t\t: __to_unsigned_like(_M_bound) + __to_unsigned_like(-_M_value))\n+\t    : __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);\n+\telse\n+\t  return __to_unsigned_like(_M_bound - _M_value);\n+      }\n+    };\n+\n+  template<typename _Winc, typename _Bound>\n+    requires (!__detail::__is_integer_like<_Winc>\n+\t|| !__detail::__is_integer_like<_Bound>\n+\t|| (__detail::__is_signed_integer_like<_Winc>\n+\t    == __detail::__is_signed_integer_like<_Bound>))\n+    iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;\n+\n+namespace views\n+{\n+  template<typename _Tp>\n+    inline constexpr empty_view<_Tp> empty{};\n+\n+  struct _Single\n+  {\n+    template<typename _Tp>\n+      auto\n+      operator()(_Tp&& __e) const\n+      { return single_view{std::forward<_Tp>(__e)}; }\n+  };\n+\n+  inline constexpr _Single single{};\n+\n+  struct _Iota\n+  {\n+    template<typename _Tp>\n+      auto\n+      operator()(_Tp&& __e) const\n+      { return iota_view{std::forward<_Tp>(__e)}; }\n+\n+    template<typename _Tp, typename _Up>\n+      auto\n+      operator()(_Tp&& __e, _Up&& __f) const\n+      { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }\n+  };\n+\n+  inline constexpr _Iota iota{};\n+\n+} // namespace views\n } // namespace ranges\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "6524b37d69940553e2b57dfc89b3c7782ffa86c7", "filename": "libstdc++-v3/testsuite/std/ranges/empty_view.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <ranges>\n+\n+static_assert(std::ranges::view<std::ranges::empty_view<int>>);\n+\n+std::ranges::empty_view<int> e;\n+static_assert(std::ranges::empty(e));\n+static_assert(0 == e.size());\n+\n+static_assert(e.begin() == nullptr);\n+static_assert(e.end() == nullptr);\n+static_assert(e.data() == nullptr);\n+static_assert(e.empty());\n+\n+static_assert(begin(e) == nullptr);\n+static_assert(end(e) == nullptr);"}, {"sha": "db63f89d898ccf10a8757f9f5fe429844abb6b47", "filename": "libstdc++-v3/testsuite/std/ranges/iota_view.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota_view.cc?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  int vals[5] = { };\n+  int* out = vals;\n+  for (int i : std::ranges::iota_view{1, 4})\n+    *out++ = i;\n+  VERIFY(out == vals + 3);\n+  VERIFY(vals[0] == 1);\n+  VERIFY(vals[1] == 2);\n+  VERIFY(vals[2] == 3);\n+  VERIFY(vals[3] == 0);\n+}\n+\n+void\n+test02()\n+{\n+  auto v = std::ranges::views::iota(4);\n+  auto it = v.begin();\n+  VERIFY( *it == 4 );\n+  ++it;\n+  VERIFY( *it == 5 );\n+  it++;\n+  VERIFY( *it == 6 );\n+}\n+\n+void\n+test03()\n+{\n+  auto v = std::ranges::views::iota(10, 15);\n+  auto it = v.begin();\n+  VERIFY( *it == 10 );\n+  it += 2;\n+  VERIFY( *it == 12 );\n+  it += 2;\n+  VERIFY( *it == 14 );\n+  ++it;\n+  VERIFY( it == v.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "785ece1b9bf064e065689b1e922708ec60dc01bd", "filename": "libstdc++-v3/testsuite/std/ranges/single_view.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsingle_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsingle_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsingle_view.cc?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::ranges::single_view s{4};\n+  static_assert(std::same_as<std::ranges::range_value_t<decltype(s)>, int>);\n+  static_assert(std::ranges::size(s) == 1);\n+\n+  int count = 0;\n+  for (auto i : s)\n+    ++count;\n+  VERIFY(count == 1);\n+  VERIFY(*std::ranges::begin(s) == 4);\n+}\n+\n+void\n+test02()\n+{\n+  std::ranges::single_view<long> s2;\n+  static_assert(std::same_as<std::ranges::range_value_t<decltype(s2)>, long>);\n+  static_assert(std::ranges::size(s2) == 1);\n+\n+  int count = 0;\n+  for (auto l : s2)\n+    ++count;\n+  VERIFY(count == 1);\n+  VERIFY(*std::ranges::begin(s2) == 0L);\n+}\n+\n+void\n+test03()\n+{\n+  auto s3 = std::ranges::views::single('a');\n+  static_assert(std::same_as<std::ranges::range_value_t<decltype(s3)>, char>);\n+  static_assert(std::ranges::size(s3) == 1);\n+  VERIFY(*std::ranges::begin(s3) == 'a');\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "fc1e04e06adeddced8cc85cb9dfd3cfa0a0c2c7c", "filename": "libstdc++-v3/testsuite/std/ranges/view.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fview.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f33df706851a00b2f5c0d429f6b273e8ab0029/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fview.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fview.cc?ref=37f33df706851a00b2f5c0d429f6b273e8ab0029", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <ranges>\n+#include <vector>\n+#include <set>\n+#include <unordered_set>\n+#include <regex>\n+#include <testsuite_iterators.h>\n+\n+static_assert(std::ranges::view<std::vector<int>>);\n+static_assert(!std::ranges::view<const std::vector<int>>);\n+static_assert(!std::ranges::view<std::initializer_list<int>>);\n+static_assert(!std::ranges::view<const std::initializer_list<int>>);\n+static_assert(!std::ranges::view<std::set<int>>);\n+static_assert(!std::ranges::view<const std::set<int>>);\n+static_assert(!std::ranges::view<std::multiset<int>>);\n+static_assert(!std::ranges::view<std::unordered_set<int>>);\n+static_assert(!std::ranges::view<std::unordered_multiset<int>>);\n+static_assert(!std::ranges::view<std::cmatch>);\n+\n+// const test_random_access_range<T> is not a range:\n+static_assert(!std::ranges::view<__gnu_test::test_random_access_range<int>>);\n+\n+template<typename T>\n+struct test_view\n+: __gnu_test::test_random_access_range<T>, std::ranges::view_base\n+{\n+  // views must be default-initializable:\n+  test_view() : __gnu_test::test_random_access_range<T>(nullptr, nullptr) { }\n+};\n+\n+static_assert(std::ranges::view<test_view<int>>);\n+\n+template<>\n+constexpr bool std::ranges::enable_view<test_view<long>> = false;\n+\n+static_assert(!std::ranges::view<test_view<long>>);"}]}