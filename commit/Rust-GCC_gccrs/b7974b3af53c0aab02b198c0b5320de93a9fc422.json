{"sha": "b7974b3af53c0aab02b198c0b5320de93a9fc422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc5NzRiM2FmNTNjMGFhYjAyYjE5OGMwYjUzMjBkZTkzYTlmYzQyMg==", "commit": {"author": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2006-04-01T01:29:11Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2006-04-01T01:29:11Z"}, "message": "lib1funcs.asm: Rename abi_entry/abi_return macros to leaf_entry/leaf_return.\n\n\t* config/xtensa/lib1funcs.asm: Rename abi_entry/abi_return macros\n\tto leaf_entry/leaf_return.  Change leaf_entry to add 16 bytes to\n\tthe frame size.  Update to use the new macros.\n\t* config/xtensa/ieee754-sf.S: Use new leaf_entry/leaf_return macros.\n\t* config/xtensa/ieee754-df.S: Likewise.\n\nFrom-SVN: r112604", "tree": {"sha": "e64eea562a933783bbc8a535ae6cf5530641e8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e64eea562a933783bbc8a535ae6cf5530641e8eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7974b3af53c0aab02b198c0b5320de93a9fc422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7974b3af53c0aab02b198c0b5320de93a9fc422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7974b3af53c0aab02b198c0b5320de93a9fc422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7974b3af53c0aab02b198c0b5320de93a9fc422/comments", "author": null, "committer": null, "parents": [{"sha": "56e840192173b9533ed176dfd5f327a1cc0a1c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e840192173b9533ed176dfd5f327a1cc0a1c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e840192173b9533ed176dfd5f327a1cc0a1c33"}], "stats": {"total": 423, "additions": 216, "deletions": 207}, "files": [{"sha": "862d85632df3604bb11b7b761c4f066a2b0eacc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7974b3af53c0aab02b198c0b5320de93a9fc422", "patch": "@@ -1,4 +1,12 @@\n-2004-03-31  Richard Henderson  <rth@redhat.com>\n+2006-03-31  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/lib1funcs.asm: Rename abi_entry/abi_return macros\n+\tto leaf_entry/leaf_return.  Change leaf_entry to add 16 bytes to\n+\tthe frame size.  Update to use the new macros.\n+\t* config/xtensa/ieee754-sf.S: Use new leaf_entry/leaf_return macros.\n+\t* config/xtensa/ieee754-df.S: Likewise.\n+\n+2006-03-31  Richard Henderson  <rth@redhat.com>\n \n \t* tree-cfg.c (make_ctrl_stmt_edges, make_exit_edges): Merge into...\n \t(make_edges): ... here.  Control fallthru creation with a local"}, {"sha": "711b10c9df313cf0a50d4427f20ba15d6259cf78", "filename": "gcc/config/xtensa/ieee754-df.S", "status": "modified", "additions": 95, "deletions": 95, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S?ref=b7974b3af53c0aab02b198c0b5320de93a9fc422", "patch": "@@ -51,10 +51,10 @@\n \t.global\t__negdf2\n \t.type\t__negdf2, @function\n __negdf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta4, 0x80000000\n \txor\txh, xh, a4\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_negdf2 */\n \n@@ -74,13 +74,13 @@ __adddf3_aux:\n \tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, .Ladd_ynan_or_inf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_ynan_or_inf:\n \t/* Return y.  */\n \tmov\txh, yh\n \tmov\txl, yl\n-\tabi_return\n+\tleaf_return\n \n .Ladd_opposite_signs:\n \t/* Operand signs differ.  Do a subtraction.  */\n@@ -92,7 +92,7 @@ __adddf3_aux:\n \t.global\t__adddf3\n \t.type\t__adddf3, @function\n __adddf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \n \t/* Check if the two operands have the same sign.  */\n@@ -166,7 +166,7 @@ __adddf3:\n \tadd\txh, xh, yh\n \tbgeu\txl, yl, 1f\n \taddi\txh, xh, 1\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_bigshifty:\n \t/* Exponent difference > 64 -- just return the bigger value.  */\n@@ -229,7 +229,7 @@ __adddf3:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta9, a9, 1\n \tbeqz\ta9, .Ladd_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_bigshiftx:\n \t/* Mostly the same thing as \"bigshifty\"....  */\n@@ -247,7 +247,7 @@ __adddf3:\n .Ladd_returny:\n \tmov\txh, yh\n \tmov\txl, yl\n-\tabi_return\n+\tleaf_return\n \n .Ladd_carry:\t\n \t/* The addition has overflowed into the exponent field, so the\n@@ -288,7 +288,7 @@ __adddf3:\n \taddi\txl, xl, 1\n \tbeqz\txl, .Ladd_roundcarry\n \tbeqz\ta9, .Ladd_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_infinity:\n \t/* Clear the mantissa.  */\n@@ -299,20 +299,20 @@ __adddf3:\n \t/* The sign bit may have been lost in a carry-out.  Put it back.  */\n \tslli\ta8, a8, 1\n \tor\txh, xh, a8\n-\tabi_return\n+\tleaf_return\n \n .Ladd_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n \tsrli\txl, xl, 1\n \tslli\txl, xl, 1\n-\tabi_return\n+\tleaf_return\n \n .Ladd_roundcarry:\n \t/* xl is always zero when the rounding increment overflows, so\n \t   there's no need to round it to an even value.  */\n \taddi\txh, xh, 1\n \t/* Overflow to the exponent is OK.  */\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Subtraction */\n@@ -328,14 +328,14 @@ __subdf3_aux:\n \t/* Both x and y are either NaN or Inf, so the result is NaN.  */\n \tmovi\ta4, 0x80000\t/* make it a quiet NaN */\n \tor\txh, xh, a4\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_ynan_or_inf:\n \t/* Negate y and return it.  */\n \tslli\ta7, a6, 11\n \txor\txh, yh, a7\n \tmov\txl, yl\n-\tabi_return\n+\tleaf_return\n \n .Lsub_opposite_signs:\n \t/* Operand signs differ.  Do an addition.  */\n@@ -347,7 +347,7 @@ __subdf3_aux:\n \t.global\t__subdf3\n \t.type\t__subdf3, @function\n __subdf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \n \t/* Check if the two operands have the same sign.  */\n@@ -415,7 +415,7 @@ __subdf3:\n \t/* The operands are equal.  Return 0.0.  */\n \tmovi\txh, 0\n \tmovi\txl, 0\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_yexpzero:\n \t/* y is a subnormal value.  Replace its sign/exponent with zero,\n@@ -493,7 +493,7 @@ __subdf3:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta9, a9, 1\n \tbeqz\ta9, .Lsub_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_xexpzero:\n \t/* Same as \"yexpzero\".  */\n@@ -523,7 +523,7 @@ __subdf3:\n \tslli\ta7, a6, 11\n \txor\txh, yh, a7\n \tmov\txl, yl\n-\tabi_return\n+\tleaf_return\n \n .Lsub_borrow:\t\n \t/* The subtraction has underflowed into the exponent field, so the\n@@ -560,14 +560,14 @@ __subdf3:\n \t/* Round down to the nearest even value.  */\n \tsrli\txl, xl, 1\n \tslli\txl, xl, 1\n-\tabi_return\n+\tleaf_return\n \n .Lsub_roundcarry:\n \t/* xl is always zero when the rounding increment overflows, so\n \t   there's no need to round it to an even value.  */\n \taddi\txh, xh, 1\n \t/* Overflow to the exponent is OK.  */\n-\tabi_return\n+\tleaf_return\n \n .Lsub_xhzero:\n \t/* When normalizing the result, all the mantissa bits in the high\n@@ -728,7 +728,7 @@ __muldf3_aux:\n \t.global\t__muldf3\n \t.type\t__muldf3, @function\n __muldf3:\n-\tabi_entry sp, 48\n+\tleaf_entry sp, 32\n #if __XTENSA_CALL0_ABI__\n \taddi\tsp, sp, -32\n \ts32i\ta12, sp, 16\n@@ -1093,7 +1093,7 @@ __muldf3:\n \tl32i\ta15, sp, 28\n \taddi\tsp, sp, 32\n #endif\n-\tabi_return\n+\tleaf_return\n \n .Lmul_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n@@ -1246,7 +1246,7 @@ __divdf3_aux:\n \tmovi\ta4, 0x80000\t/* make it a quiet NaN */\n \tor\txh, xh, a4\n 1:\tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_xexpzero:\n \t/* Clear the sign bit of x.  */\n@@ -1287,7 +1287,7 @@ __divdf3_aux:\n \tsrli\txh, a7, 31\n \tslli\txh, xh, 31\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_xnan_or_inf:\n \t/* Set the sign bit of the result.  */\n@@ -1298,7 +1298,7 @@ __divdf3_aux:\n \tbnall\tyh, a6, 1f\n \tmovi\ta4, 0x80000\t/* make it a quiet NaN */\n \tor\txh, xh, a4\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ldiv_ynan_or_inf:\n \t/* If y is Infinity, return zero.  */\n@@ -1308,7 +1308,7 @@ __divdf3_aux:\n \t/* y is NaN; return it.  */\n \tmov\txh, yh\n \tmov\txl, yl\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_highequal1:\n \tbltu\txl, yl, 2f\n@@ -1318,7 +1318,7 @@ __divdf3_aux:\n \t.global\t__divdf3\n \t.type\t__divdf3, @function\n __divdf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \n \t/* Get the sign of the result.  */\n@@ -1431,7 +1431,7 @@ __divdf3:\n \tsrli\ta7, a7, 31\n \tslli\ta7, a7, 31\n \tor\txh, xh, a7\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_highequal2:\n \tbgeu\txl, yl, 2b\n@@ -1510,7 +1510,7 @@ __divdf3:\n \tsrli\txh, a7, 31\n \tslli\txh, xh, 31\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_divdf3 */\n \n@@ -1524,7 +1524,7 @@ __divdf3:\n \t.set\t__nedf2, __eqdf2\n \t.type\t__eqdf2, @function\n __eqdf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbne\txl, yl, 2f\n \tbne\txh, yh, 4f\n \n@@ -1534,11 +1534,11 @@ __eqdf2:\n \n \t/* Equal.  */\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Not equal.  */\n 2:\tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if the mantissas are nonzero.  */\n 3:\tslli\ta7, xh, 12\n@@ -1555,7 +1555,7 @@ __eqdf2:\n 5:\tmovi\ta2, 0\n \tmovi\ta3, 1\n \tmovnez\ta2, a3, a7\t\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Greater Than */\n@@ -1564,7 +1564,7 @@ __eqdf2:\n \t.global\t__gtdf2\n \t.type\t__gtdf2, @function\n __gtdf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \tball\txh, a6, 2f\n 1:\tbnall\tyh, a6, .Lle_cmp\n@@ -1574,14 +1574,14 @@ __gtdf2:\n \tor\ta7, a7, yl\n \tbeqz\ta7, .Lle_cmp\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, 1b\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Less Than or Equal */\n@@ -1590,7 +1590,7 @@ __gtdf2:\n \t.global\t__ledf2\n \t.type\t__ledf2, @function\n __ledf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \tball\txh, a6, 2f\n 1:\tbnall\tyh, a6, .Lle_cmp\n@@ -1600,14 +1600,14 @@ __ledf2:\n \tor\ta7, a7, yl\n \tbeqz\ta7, .Lle_cmp\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, 1b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lle_cmp:\n \t/* Check if x and y have different signs.  */\n@@ -1622,15 +1622,15 @@ __ledf2:\n \tbne\txh, yh, 5f\n \tbltu\tyl, xl, 5f\n 4:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Lle_xneg:\n \t/* Check if y <= x.  */\n \tbltu\tyh, xh, 4b\n \tbne\tyh, xh, 5f\n \tbgeu\txl, yl, 4b\n 5:\tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lle_diff_signs:\n \tbltz\txh, 4b\n@@ -1643,7 +1643,7 @@ __ledf2:\n \tmovi\ta2, 1\n \tmovi\ta3, 0\n \tmoveqz\ta2, a3, a7\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Greater Than or Equal */\n@@ -1652,7 +1652,7 @@ __ledf2:\n \t.global\t__gedf2\n \t.type\t__gedf2, @function\n __gedf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \tball\txh, a6, 2f\n 1:\tbnall\tyh, a6, .Llt_cmp\n@@ -1662,14 +1662,14 @@ __gedf2:\n \tor\ta7, a7, yl\n \tbeqz\ta7, .Llt_cmp\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, 1b\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Less Than */\n@@ -1678,7 +1678,7 @@ __gedf2:\n \t.global\t__ltdf2\n \t.type\t__ltdf2, @function\n __ltdf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \tball\txh, a6, 2f\n 1:\tbnall\tyh, a6, .Llt_cmp\n@@ -1688,14 +1688,14 @@ __ltdf2:\n \tor\ta7, a7, yl\n \tbeqz\ta7, .Llt_cmp\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, 1b\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Llt_cmp:\n \t/* Check if x and y have different signs.  */\n@@ -1710,15 +1710,15 @@ __ltdf2:\n \tbne\txh, yh, 5f\n \tbgeu\txl, yl, 5f\n 4:\tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n .Llt_xneg:\n \t/* Check if y < x.  */\n \tbltu\tyh, xh, 4b\n \tbne\tyh, xh, 5f\n \tbltu\tyl, xl, 4b\n 5:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Llt_diff_signs:\n \tbgez\txh, 5b\n@@ -1731,7 +1731,7 @@ __ltdf2:\n \tmovi\ta2, 0\n \tmovi\ta3, -1\n \tmovnez\ta2, a3, a7\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Unordered */\n@@ -1740,24 +1740,24 @@ __ltdf2:\n \t.global\t__unorddf2\n \t.type\t__unorddf2, @function\n __unorddf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7ff00000\n \tball\txh, a6, 3f\n 1:\tball\tyh, a6, 4f\n 2:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n 3:\tslli\ta7, xh, 12\n \tor\ta7, a7, xl\n \tbeqz\ta7, 1b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n 4:\tslli\ta7, yh, 12\n \tor\ta7, a7, yl\n \tbeqz\ta7, 2b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_cmpdf2 */\n \n@@ -1767,7 +1767,7 @@ __unorddf2:\n \t.global\t__fixdfsi\n \t.type\t__fixdfsi, @function\n __fixdfsi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7ff00000\n@@ -1792,7 +1792,7 @@ __fixdfsi:\n \t/* Negate the result if sign != 0.  */\n \tneg\ta2, a5\n \tmovgez\ta2, a5, a7\n-\tabi_return\n+\tleaf_return\n \n .Lfixdfsi_nan_or_inf:\n \t/* Handle Infinity and NaN.  */\n@@ -1808,11 +1808,11 @@ __fixdfsi:\n \taddi\ta5, a4, -1\t/* 0x7fffffff */\n \tmovgez\ta4, a5, xh\n \tmov\ta2, a4\n-\tabi_return\n+\tleaf_return\n \n .Lfixdfsi_zero:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixdfsi */\n \n@@ -1822,7 +1822,7 @@ __fixdfsi:\n \t.global\t__fixdfdi\n \t.type\t__fixdfdi, @function\n __fixdfdi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7ff00000\n@@ -1854,7 +1854,7 @@ __fixdfdi:\n \tneg\txh, xh\n \tbeqz\txl, 1f\n \taddi\txh, xh, -1\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lfixdfdi_smallshift:\n \tsrc\txl, xh, xl\n@@ -1875,16 +1875,16 @@ __fixdfdi:\n \tbgez\txh, 1f\n \tmov\txh, a7\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n 1:\taddi\txh, a7, -1\t/* 0x7fffffff */\n \tmovi\txl, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixdfdi_zero:\n \tmovi\txh, 0\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixdfdi */\n \n@@ -1894,7 +1894,7 @@ __fixdfdi:\n \t.global\t__fixunsdfsi\n \t.type\t__fixunsdfsi, @function\n __fixunsdfsi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7ff00000\n@@ -1921,7 +1921,7 @@ __fixunsdfsi:\n \t/* Negate the result if sign != 0.  */\n \tneg\ta2, a5\n \tmovgez\ta2, a5, a7\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfsi_nan_or_inf:\n \t/* Handle Infinity and NaN.  */\n@@ -1931,28 +1931,28 @@ __fixunsdfsi:\n \n \t/* Translate NaN to 0xffffffff.  */\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfsi_maxint:\n \tslli\ta4, a6, 11\t/* 0x80000000 */\n \tmovi\ta5, -1\t\t/* 0xffffffff */\n \tmovgez\ta4, a5, xh\n \tmov\ta2, a4\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfsi_zero:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfsi_bigexp:\n \t/* Handle unsigned maximum exponent case.  */\n \tbltz\txh, 1f\n \tmov\ta2, a5\t\t/* no shift needed */\n-\tabi_return\n+\tleaf_return\n \n \t/* Return 0x80000000 if negative.  */\n 1:\tslli\ta2, a6, 11\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixunsdfsi */\n \n@@ -1962,7 +1962,7 @@ __fixunsdfsi:\n \t.global\t__fixunsdfdi\n \t.type\t__fixunsdfdi, @function\n __fixunsdfdi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7ff00000\n@@ -1996,7 +1996,7 @@ __fixunsdfdi:\n \tneg\txh, xh\n \tbeqz\txl, 1f\n \taddi\txh, xh, -1\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lfixunsdfdi_smallshift:\n \tsrc\txl, xh, xl\n@@ -2012,23 +2012,23 @@ __fixunsdfdi:\n \t/* Translate NaN to 0xffffffff.... */\n 1:\tmovi\txh, -1\n \tmovi\txl, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfdi_maxint:\n \tbgez\txh, 1b\n 2:\tslli\txh, a6, 11\t/* 0x80000000 */\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfdi_zero:\n \tmovi\txh, 0\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunsdfdi_bigexp:\n \t/* Handle unsigned maximum exponent case.  */\n \tbltz\ta7, 2b\n-\tabi_return\t\t/* no shift needed */\n+\tleaf_return\t\t/* no shift needed */\n \n #endif /* L_fixunsdfdi */\n \n@@ -2038,7 +2038,7 @@ __fixunsdfdi:\n \t.global\t__floatunsidf\n \t.type\t__floatunsidf, @function\n __floatunsidf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbeqz\ta2, .Lfloatsidf_return_zero\n \n \t/* Set the sign to zero and jump to the floatsidf code.  */\n@@ -2049,7 +2049,7 @@ __floatunsidf:\n \t.global\t__floatsidf\n \t.type\t__floatsidf, @function\n __floatsidf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tbeqz\ta2, .Lfloatsidf_return_zero\n@@ -2084,11 +2084,11 @@ __floatsidf:\n \t/* Add the sign and return. */\n \tslli\ta7, a7, 31\n \tor\txh, xh, a7\n-\tabi_return\n+\tleaf_return\n \n .Lfloatsidf_return_zero:\n \tmovi\ta3, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_floatsidf */\n \n@@ -2098,7 +2098,7 @@ __floatsidf:\n \t.global\t__floatundidf\n \t.type\t__floatundidf, @function\n __floatundidf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tor\ta4, xh, xl\n@@ -2112,7 +2112,7 @@ __floatundidf:\n \t.global\t__floatdidf\n \t.type\t__floatdidf, @function\n __floatdidf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tor\ta4, xh, xl\n@@ -2161,7 +2161,7 @@ __floatdidf:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta6, a6, 1\n \tbeqz\ta6, .Lfloatdidf_exactlyhalf\n-2:\tabi_return\n+2:\tleaf_return\n \n .Lfloatdidf_bigshift:\n \t/* xh is zero.  Normalize with first 1 bit of xl in the msb of xh.  */\n@@ -2176,14 +2176,14 @@ __floatdidf:\n \t/* Round down to the nearest even value.  */\n \tsrli\txl, xl, 1\n \tslli\txl, xl, 1\n-\tabi_return\n+\tleaf_return\n \n .Lfloatdidf_roundcarry:\n \t/* xl is always zero when the rounding increment overflows, so\n \t   there's no need to round it to an even value.  */\n \taddi\txh, xh, 1\n \t/* Overflow to the exponent is OK.  */\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_floatdidf */\n \n@@ -2193,7 +2193,7 @@ __floatdidf:\n \t.global\t__truncdfsf2\n \t.type\t__truncdfsf2, @function\n __truncdfsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Adjust the exponent bias.  */\n \tmovi\ta4, (0x3ff - 0x7f) << 20\n@@ -2228,13 +2228,13 @@ __truncdfsf2:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta4, a4, 1\n \tbeqz\ta4, .Ltrunc_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ltrunc_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n \tsrli\ta2, a2, 1\n \tslli\ta2, a2, 1\n-\tabi_return\n+\tleaf_return\n \n .Ltrunc_overflow:\n \t/* Check if exponent == 0x7ff.  */\n@@ -2254,7 +2254,7 @@ __truncdfsf2:\n \textui\ta6, xh, 31, 1\n \tssai\t1\n \tsrc\ta2, a6, a4\n-\tabi_return\n+\tleaf_return\n \n .Ltrunc_underflow:\n \t/* Find shift count for a subnormal.  Flush to zero if >= 32.  */\n@@ -2287,7 +2287,7 @@ __truncdfsf2:\n \t/* Return +/- zero.  */\n 1:\textui\ta2, xh, 31, 1\n \tslli\ta2, a2, 31\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_truncdfsf2 */\n \n@@ -2297,7 +2297,7 @@ __truncdfsf2:\n \t.global\t__extendsfdf2\n \t.type\t__extendsfdf2, @function\n __extendsfdf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Save the sign bit and then shift it off.  */\n \textui\ta5, a2, 31, 1\n@@ -2320,7 +2320,7 @@ __extendsfdf2:\n \n \t/* Add the sign bit.  */\n \tor\txh, a4, a5\n-\tabi_return\n+\tleaf_return\n \n .Lextend_nan_or_inf:\n \tmovi\ta4, 0x7ff00000\n@@ -2335,7 +2335,7 @@ __extendsfdf2:\n \t/* Add the sign and return.  */\n 1:\tor\txh, a4, a5\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Lextend_expzero:\n \tbeqz\ta4, 1b\n@@ -2358,7 +2358,7 @@ __extendsfdf2:\n \n \t/* Add the sign and return.  */\n \tor\txh, a4, a5\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_extendsfdf2 */\n "}, {"sha": "a75e742898b7ba77560ec56228fff6883be544cc", "filename": "gcc/config/xtensa/ieee754-sf.S", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S?ref=b7974b3af53c0aab02b198c0b5320de93a9fc422", "patch": "@@ -51,10 +51,10 @@\n \t.global\t__negsf2\n \t.type\t__negsf2, @function\n __negsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta4, 0x80000000\n \txor\ta2, a2, a4\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_negsf2 */\n \n@@ -73,12 +73,12 @@ __addsf3_aux:\n \t/* If x is a NaN, return it.  Otherwise, return y.  */\n \tslli\ta7, a2, 9\n \tbeqz\ta7, .Ladd_ynan_or_inf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_ynan_or_inf:\n \t/* Return y.  */\n \tmov\ta2, a3\n-\tabi_return\n+\tleaf_return\n \n .Ladd_opposite_signs:\n \t/* Operand signs differ.  Do a subtraction.  */\n@@ -90,7 +90,7 @@ __addsf3_aux:\n \t.global\t__addsf3\n \t.type\t__addsf3, @function\n __addsf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \n \t/* Check if the two operands have the same sign.  */\n@@ -158,7 +158,7 @@ __addsf3:\n \t   a carry into the exponent field will not work because it\n \t   assumes there is an implicit \"1.0\" that needs to be added.  */\n \tadd\ta2, a2, a3\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_xexpzero:\n \t/* Same as \"yexpzero\" except skip handling the case when both\n@@ -200,11 +200,11 @@ __addsf3:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta9, a9, 1\n \tbeqz\ta9, .Ladd_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_returny:\n \tmov\ta2, a3\n-\tabi_return\n+\tleaf_return\n \n .Ladd_carry:\t\n \t/* The addition has overflowed into the exponent field, so the\n@@ -242,7 +242,7 @@ __addsf3:\n \tbbci.l\ta10, 0, 1f\n \taddi\ta2, a2, 1\n \tbeqz\ta9, .Ladd_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ladd_infinity:\n \t/* Clear the mantissa.  */\n@@ -252,13 +252,13 @@ __addsf3:\n \t/* The sign bit may have been lost in a carry-out.  Put it back.  */\n \tslli\ta8, a8, 1\n \tor\ta2, a2, a8\n-\tabi_return\n+\tleaf_return\n \n .Ladd_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n \tsrli\ta2, a2, 1\n \tslli\ta2, a2, 1\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Subtraction */\n@@ -274,13 +274,13 @@ __subsf3_aux:\n \t/* Both x and y are either NaN or Inf, so the result is NaN.  */\n \tmovi\ta4, 0x400000\t/* make it a quiet NaN */\n \tor\ta2, a2, a4\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_ynan_or_inf:\n \t/* Negate y and return it.  */\n \tslli\ta7, a6, 8\n \txor\ta2, a3, a7\n-\tabi_return\n+\tleaf_return\n \n .Lsub_opposite_signs:\n \t/* Operand signs differ.  Do an addition.  */\n@@ -292,7 +292,7 @@ __subsf3_aux:\n \t.global\t__subsf3\n \t.type\t__subsf3, @function\n __subsf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \n \t/* Check if the two operands have the same sign.  */\n@@ -366,7 +366,7 @@ __subsf3:\n \t/* Negate and return y.  */\n \tslli\ta7, a6, 8\n \txor\ta2, a3, a7\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_xsmaller:\n \t/* Same thing as the \"ysmaller\" code, but with x and y swapped and\n@@ -408,7 +408,7 @@ __subsf3:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta9, a9, 1\n \tbeqz\ta9, .Lsub_exactlyhalf\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lsub_xexpzero:\n \t/* Same as \"yexpzero\".  */\n@@ -421,7 +421,7 @@ __subsf3:\n \n .Lsub_return_zero:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Lsub_borrow:\t\n \t/* The subtraction has underflowed into the exponent field, so the\n@@ -457,7 +457,7 @@ __subsf3:\n \t/* Round down to the nearest even value.  */\n \tsrli\ta2, a2, 1\n \tslli\ta2, a2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lsub_xzero:\n \t/* If there was a borrow from the exponent, and the mantissa and\n@@ -570,7 +570,7 @@ __mulsf3_aux:\n \t.global\t__mulsf3\n \t.type\t__mulsf3, @function\n __mulsf3:\n-\tabi_entry sp, 48\n+\tleaf_entry sp, 32\n #if __XTENSA_CALL0_ABI__\n \taddi\tsp, sp, -32\n \ts32i\ta12, sp, 16\n@@ -780,7 +780,7 @@ __mulsf3:\n \tl32i\ta15, sp, 28\n \taddi\tsp, sp, 32\n #endif\n-\tabi_return\n+\tleaf_return\n \n .Lmul_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n@@ -895,7 +895,7 @@ __divsf3_aux:\n \tbnez\ta4, 1f\n \tmovi\ta4, 0x400000\t/* make it a quiet NaN */\n \tor\ta2, a2, a4\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ldiv_xexpzero:\n \t/* Clear the sign bit of x.  */\n@@ -918,7 +918,7 @@ __divsf3_aux:\n \t/* Return zero with the appropriate sign bit.  */\n \tsrli\ta2, a7, 31\n \tslli\ta2, a2, 31\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_xnan_or_inf:\n \t/* Set the sign bit of the result.  */\n@@ -929,21 +929,21 @@ __divsf3_aux:\n \tbnall\ta3, a6, 1f\n \tmovi\ta4, 0x400000\t/* make it a quiet NaN */\n \tor\ta2, a2, a4\n-1:\tabi_return\n+1:\tleaf_return\n \n .Ldiv_ynan_or_inf:\n \t/* If y is Infinity, return zero.  */\n \tslli\ta8, a3, 9\n \tbeqz\ta8, .Ldiv_return_zero\n \t/* y is NaN; return it.  */\n \tmov\ta2, a3\n-\tabi_return\n+\tleaf_return\n \n \t.align\t4\n \t.global\t__divsf3\n \t.type\t__divsf3, @function\n __divsf3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \n \t/* Get the sign of the result.  */\n@@ -1036,7 +1036,7 @@ __divsf3:\n \tsrli\ta7, a7, 31\n \tslli\ta7, a7, 31\n \tor\ta2, a2, a7\n-\tabi_return\n+\tleaf_return\n \n .Ldiv_overflow:\n \tbltz\ta8, .Ldiv_underflow\n@@ -1085,7 +1085,7 @@ __divsf3:\n \t/* Return zero with the appropriate sign bit.  */\n \tsrli\ta2, a7, 31\n \tslli\ta2, a2, 31\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_divsf3 */\n \n@@ -1099,7 +1099,7 @@ __divsf3:\n \t.set\t__nesf2, __eqsf2\n \t.type\t__eqsf2, @function\n __eqsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbne\ta2, a3, 4f\n \n \t/* The values are equal but NaN != NaN.  Check the exponent.  */\n@@ -1108,11 +1108,11 @@ __eqsf2:\n \n \t/* Equal.  */\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Not equal.  */\n 2:\tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if the mantissas are nonzero.  */\n 3:\tslli\ta7, a2, 9\n@@ -1127,7 +1127,7 @@ __eqsf2:\n 5:\tmovi\ta2, 0\n \tmovi\ta3, 1\n \tmovnez\ta2, a3, a7\t\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Greater Than */\n@@ -1136,7 +1136,7 @@ __eqsf2:\n \t.global\t__gtsf2\n \t.type\t__gtsf2, @function\n __gtsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \tball\ta2, a6, 2f\n 1:\tbnall\ta3, a6, .Lle_cmp\n@@ -1145,13 +1145,13 @@ __gtsf2:\n \tslli\ta7, a3, 9\n \tbeqz\ta7, .Lle_cmp\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, a2, 9\n \tbeqz\ta7, 1b\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Less Than or Equal */\n@@ -1160,7 +1160,7 @@ __gtsf2:\n \t.global\t__lesf2\n \t.type\t__lesf2, @function\n __lesf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \tball\ta2, a6, 2f\n 1:\tbnall\ta3, a6, .Lle_cmp\n@@ -1169,13 +1169,13 @@ __lesf2:\n \tslli\ta7, a3, 9\n \tbeqz\ta7, .Lle_cmp\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, a2, 9\n \tbeqz\ta7, 1b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lle_cmp:\n \t/* Check if x and y have different signs.  */\n@@ -1188,13 +1188,13 @@ __lesf2:\n \t/* Check if x <= y.  */\n \tbltu\ta3, a2, 5f\n 4:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Lle_xneg:\n \t/* Check if y <= x.  */\n \tbgeu\ta2, a3, 4b\n 5:\tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lle_diff_signs:\n \tbltz\ta2, 4b\n@@ -1205,7 +1205,7 @@ __lesf2:\n \tmovi\ta2, 1\n \tmovi\ta3, 0\n \tmoveqz\ta2, a3, a7\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Greater Than or Equal */\n@@ -1214,7 +1214,7 @@ __lesf2:\n \t.global\t__gesf2\n \t.type\t__gesf2, @function\n __gesf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \tball\ta2, a6, 2f\n 1:\tbnall\ta3, a6, .Llt_cmp\n@@ -1223,13 +1223,13 @@ __gesf2:\n \tslli\ta7, a3, 9\n \tbeqz\ta7, .Llt_cmp\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, a2, 9\n \tbeqz\ta7, 1b\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Less Than */\n@@ -1238,7 +1238,7 @@ __gesf2:\n \t.global\t__ltsf2\n \t.type\t__ltsf2, @function\n __ltsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \tball\ta2, a6, 2f\n 1:\tbnall\ta3, a6, .Llt_cmp\n@@ -1247,13 +1247,13 @@ __ltsf2:\n \tslli\ta7, a3, 9\n \tbeqz\ta7, .Llt_cmp\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n \t/* Check if x is a NaN.  */\n 2:\tslli\ta7, a2, 9\n \tbeqz\ta7, 1b\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Llt_cmp:\n \t/* Check if x and y have different signs.  */\n@@ -1266,13 +1266,13 @@ __ltsf2:\n \t/* Check if x < y.  */\n \tbgeu\ta2, a3, 5f\n 4:\tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n .Llt_xneg:\n \t/* Check if y < x.  */\n \tbltu\ta3, a2, 4b\n 5:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Llt_diff_signs:\n \tbgez\ta2, 5b\n@@ -1283,7 +1283,7 @@ __ltsf2:\n \tmovi\ta2, 0\n \tmovi\ta3, -1\n \tmovnez\ta2, a3, a7\n-\tabi_return\n+\tleaf_return\n \n \n \t/* Unordered */\n@@ -1292,22 +1292,22 @@ __ltsf2:\n \t.global\t__unordsf2\n \t.type\t__unordsf2, @function\n __unordsf2:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmovi\ta6, 0x7f800000\n \tball\ta2, a6, 3f\n 1:\tball\ta3, a6, 4f\n 2:\tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n 3:\tslli\ta7, a2, 9\n \tbeqz\ta7, 1b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n 4:\tslli\ta7, a3, 9\n \tbeqz\ta7, 2b\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_cmpsf2 */\n \n@@ -1317,7 +1317,7 @@ __unordsf2:\n \t.global\t__fixsfsi\n \t.type\t__fixsfsi, @function\n __fixsfsi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7f800000\n@@ -1340,7 +1340,7 @@ __fixsfsi:\n \t/* Negate the result if sign != 0.  */\n \tneg\ta2, a5\n \tmovgez\ta2, a5, a7\n-\tabi_return\n+\tleaf_return\n \n .Lfixsfsi_nan_or_inf:\n \t/* Handle Infinity and NaN.  */\n@@ -1355,11 +1355,11 @@ __fixsfsi:\n \taddi\ta5, a4, -1\t/* 0x7fffffff */\n \tmovgez\ta4, a5, a2\n \tmov\ta2, a4\n-\tabi_return\n+\tleaf_return\n \n .Lfixsfsi_zero:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixsfsi */\n \n@@ -1369,7 +1369,7 @@ __fixsfsi:\n \t.global\t__fixsfdi\n \t.type\t__fixsfdi, @function\n __fixsfdi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7f800000\n@@ -1398,7 +1398,7 @@ __fixsfdi:\n \tneg\txh, xh\n \tbeqz\txl, 1f\n \taddi\txh, xh, -1\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lfixsfdi_smallshift:\n \tmovi\txl, 0\n@@ -1419,16 +1419,16 @@ __fixsfdi:\n \tbgez\ta2, 1f\n \tmov\txh, a7\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n 1:\taddi\txh, a7, -1\t/* 0x7fffffff */\n \tmovi\txl, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixsfdi_zero:\n \tmovi\txh, 0\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixsfdi */\n \n@@ -1438,7 +1438,7 @@ __fixsfdi:\n \t.global\t__fixunssfsi\n \t.type\t__fixunssfsi, @function\n __fixunssfsi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7f800000\n@@ -1463,7 +1463,7 @@ __fixunssfsi:\n \t/* Negate the result if sign != 0.  */\n \tneg\ta2, a5\n \tmovgez\ta2, a5, a7\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfsi_nan_or_inf:\n \t/* Handle Infinity and NaN.  */\n@@ -1472,28 +1472,28 @@ __fixunssfsi:\n \n \t/* Translate NaN to 0xffffffff.  */\n \tmovi\ta2, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfsi_maxint:\n \tslli\ta4, a6, 8\t/* 0x80000000 */\n \tmovi\ta5, -1\t\t/* 0xffffffff */\n \tmovgez\ta4, a5, a2\n \tmov\ta2, a4\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfsi_zero:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfsi_bigexp:\n \t/* Handle unsigned maximum exponent case.  */\n \tbltz\ta2, 1f\n \tmov\ta2, a5\t\t/* no shift needed */\n-\tabi_return\n+\tleaf_return\n \n \t/* Return 0x80000000 if negative.  */\n 1:\tslli\ta2, a6, 8\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_fixunssfsi */\n \n@@ -1503,7 +1503,7 @@ __fixunssfsi:\n \t.global\t__fixunssfdi\n \t.type\t__fixunssfdi, @function\n __fixunssfdi:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for NaN and Infinity.  */\n \tmovi\ta6, 0x7f800000\n@@ -1534,7 +1534,7 @@ __fixunssfdi:\n \tneg\txh, xh\n \tbeqz\txl, 1f\n \taddi\txh, xh, -1\n-1:\tabi_return\n+1:\tleaf_return\n \n .Lfixunssfdi_smallshift:\n \tmovi\txl, 0\n@@ -1550,24 +1550,24 @@ __fixunssfdi:\n \t/* Translate NaN to 0xffffffff.... */\n 1:\tmovi\txh, -1\n \tmovi\txl, -1\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfdi_maxint:\n \tbgez\ta2, 1b\n 2:\tslli\txh, a6, 8\t/* 0x80000000 */\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfdi_zero:\n \tmovi\txh, 0\n \tmovi\txl, 0\n-\tabi_return\n+\tleaf_return\n \n .Lfixunssfdi_bigexp:\n \t/* Handle unsigned maximum exponent case.  */\n \tbltz\ta7, 2b\n \tmovi\txl, 0\n-\tabi_return\t\t/* no shift needed */\n+\tleaf_return\t\t/* no shift needed */\n \n #endif /* L_fixunssfdi */\n \n@@ -1577,7 +1577,7 @@ __fixunssfdi:\n \t.global\t__floatunsisf\n \t.type\t__floatunsisf, @function\n __floatunsisf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbeqz\ta2, .Lfloatsisf_return\n \n \t/* Set the sign to zero and jump to the floatsisf code.  */\n@@ -1588,7 +1588,7 @@ __floatunsisf:\n \t.global\t__floatsisf\n \t.type\t__floatsisf, @function\n __floatsisf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tbeqz\ta2, .Lfloatsisf_return\n@@ -1633,13 +1633,13 @@ __floatsisf:\n \tbeqz\ta6, .Lfloatsisf_exactlyhalf\n \n .Lfloatsisf_return:\n-\tabi_return\n+\tleaf_return\n \n .Lfloatsisf_exactlyhalf:\n \t/* Round down to the nearest even value.  */\n \tsrli\ta2, a2, 1\n \tslli\ta2, a2, 1\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_floatsisf */\n \n@@ -1649,7 +1649,7 @@ __floatsisf:\n \t.global\t__floatundisf\n \t.type\t__floatundisf, @function\n __floatundisf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tor\ta4, xh, xl\n@@ -1663,7 +1663,7 @@ __floatundisf:\n \t.global\t__floatdisf\n \t.type\t__floatdisf, @function\n __floatdisf:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n \t/* Check for zero.  */\n \tor\ta4, xh, xl\n@@ -1714,7 +1714,7 @@ __floatdisf:\n \t/* Check if the leftover fraction is exactly 1/2.  */\n \tslli\ta6, a6, 1\n \tbeqz\ta6, .Lfloatdisf_exactlyhalf\n-2:\tabi_return\n+2:\tleaf_return\n \n .Lfloatdisf_bigshift:\n \t/* xh is zero.  Normalize with first 1 bit of xl in the msb of xh.  */\n@@ -1729,6 +1729,6 @@ __floatdisf:\n \t/* Round down to the nearest even value.  */\n \tsrli\ta2, a2, 1\n \tslli\ta2, a2, 1\n-\tabi_return\n+\tleaf_return\n \n #endif /* L_floatdisf */"}, {"sha": "7d316ede8058a4fedc24f8f49976d3eff4e1b6cb", "filename": "gcc/config/xtensa/lib1funcs.asm", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7974b3af53c0aab02b198c0b5320de93a9fc422/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm?ref=b7974b3af53c0aab02b198c0b5320de93a9fc422", "patch": "@@ -30,10 +30,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"xtensa-config.h\"\n \n-# Note: These functions use a minimum stack frame size of 32.  This is\n-# necessary for Xtensa configurations that only support a fixed register\n-# window size of 8, where even leaf functions (such as these) need to\n-# allocate space for a 4-word \"extra save area\".\n+# Force each stack frame to contain an \"Extra Save Area\" (ESA) of at least\n+# 16 bytes.  This is necessary for non-standard Xtensa configurations that\n+# only support a fixed register window size of 8, where even leaf functions\n+# (such as these) need the ESA for interrupt handlers.\n+#define MIN_ESA 16\n \n # Define macros for the ABS and ADDX* instructions to handle cases\n # where they are not included in the Xtensa processor configuration.\n@@ -75,20 +76,20 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #endif\n \t.endm\n \n-# Define macros for function entry and return, supporting either the\n+# Define macros for leaf function entry and return, supporting either the\n # standard register windowed ABI or the non-windowed call0 ABI.  These\n # macros do not allocate any extra stack space, so they only work for\n # leaf functions that do not need to spill anything to the stack.\n \n-\t.macro abi_entry reg, size\n+\t.macro leaf_entry reg, size\n #if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n-\tentry \\reg, \\size\n+\tentry \\reg, \\size + MIN_ESA\n #else\n \t/* do nothing */\n #endif\n \t.endm\n \n-\t.macro abi_return\n+\t.macro leaf_return\n #if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n \tretw\n #else\n@@ -102,14 +103,14 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \t.global\t__mulsi3\n \t.type\t__mulsi3,@function\n __mulsi3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \n #if XCHAL_HAVE_MUL16\n \tor\ta4, a2, a3\n \tsrai\ta4, a4, 16\n \tbnez\ta4, .LMUL16\n \tmul16u\ta2, a2, a3\n-\tabi_return\n+\tleaf_return\n .LMUL16:\n \tsrai\ta4, a2, 16\n \tsrai\ta5, a3, 16\n@@ -165,7 +166,7 @@ __mulsi3:\n \tbgeui\ta3, 16, .Lmult_main_loop\n \tneg\ta3, a2\n \tmovltz\ta2, a3, a5\n-\tabi_return\n+\tleaf_return\n \n \t.align\t4\n .Lmult_main_loop:\n@@ -195,7 +196,7 @@ __mulsi3:\n \n #endif /* !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MAC16 */\n \n-\tabi_return\n+\tleaf_return\n \t.size\t__mulsi3,.-__mulsi3\n \n #endif /* L_mulsi3 */\n@@ -264,7 +265,7 @@ __nsau_data:\n \t.global\t__udivsi3\n \t.type\t__udivsi3,@function\n __udivsi3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbltui\ta3, 2, .Lle_one\t# check if the divisor <= 1\n \n \tmov\ta6, a2\t\t# keep dividend in a6\n@@ -297,24 +298,24 @@ __udivsi3:\n \tbltu\ta6, a3, .Lreturn\n \taddi\ta2, a2, 1\t# increment quotient if dividend >= divisor\n .Lreturn:\n-\tabi_return\n+\tleaf_return\n \n .Lle_one:\n \tbeqz\ta3, .Lerror\t# if divisor == 1, return the dividend\n-\tabi_return\n+\tleaf_return\n \n .Lspecial:\n \t# return dividend >= divisor\n \tbltu\ta6, a3, .Lreturn0\n \tmovi\ta2, 1\n-\tabi_return\n+\tleaf_return\n \n .Lerror:\n \t# just return 0; could throw an exception\n \n .Lreturn0:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \t.size\t__udivsi3,.-__udivsi3\n \n #endif /* L_udivsi3 */\n@@ -325,7 +326,7 @@ __udivsi3:\n \t.global\t__divsi3\n \t.type\t__divsi3,@function\n __divsi3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \txor\ta7, a2, a3\t# sign = dividend ^ divisor\n \tdo_abs\ta6, a2, a4\t# udividend = abs(dividend)\n \tdo_abs\ta3, a3, a4\t# udivisor = abs(divisor)\n@@ -361,27 +362,27 @@ __divsi3:\n .Lreturn:\n \tneg\ta5, a2\n \tmovltz\ta2, a5, a7\t# return (sign < 0) ? -quotient : quotient\n-\tabi_return\n+\tleaf_return\n \n .Lle_one:\n \tbeqz\ta3, .Lerror\n \tneg\ta2, a6\t\t# if udivisor == 1, then return...\n \tmovgez\ta2, a6, a7\t# (sign < 0) ? -udividend : udividend\n-\tabi_return\n+\tleaf_return\n \n .Lspecial:\n \tbltu\ta6, a3, .Lreturn0 #  if dividend < divisor, return 0\n \tmovi\ta2, 1\n \tmovi\ta4, -1\n \tmovltz\ta2, a4, a7\t# else return (sign < 0) ? -1 :\t 1 \n-\tabi_return\n+\tleaf_return\n \n .Lerror:\n \t# just return 0; could throw an exception\n \n .Lreturn0:\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \t.size\t__divsi3,.-__divsi3\n \n #endif /* L_divsi3 */\n@@ -392,7 +393,7 @@ __divsi3:\n \t.global\t__umodsi3\n \t.type\t__umodsi3,@function\n __umodsi3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tbltui\ta3, 2, .Lle_one\t# check if the divisor is <= 1\n \n \tdo_nsau\ta5, a2, a6, a7\t# dividend_shift = nsau(dividend)\n@@ -422,13 +423,13 @@ __umodsi3:\n \tbltu\ta2, a3, .Lreturn\n \tsub\ta2, a2, a3\t# subtract once more if dividend >= divisor\n .Lreturn:\n-\tabi_return\n+\tleaf_return\n \n .Lle_one:\n \t# the divisor is either 0 or 1, so just return 0.\n \t# someday we may want to throw an exception if the divisor is 0.\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \t.size\t__umodsi3,.-__umodsi3\n \n #endif /* L_umodsi3 */\n@@ -439,7 +440,7 @@ __umodsi3:\n \t.global\t__modsi3\n \t.type\t__modsi3,@function\n __modsi3:\n-\tabi_entry sp, 32\n+\tleaf_entry sp, 16\n \tmov\ta7, a2\t\t# save original (signed) dividend\n \tdo_abs\ta2, a2, a4\t# udividend = abs(dividend)\n \tdo_abs\ta3, a3, a4\t# udivisor = abs(divisor)\n@@ -474,13 +475,13 @@ __modsi3:\n \tbgez\ta7, .Lpositive\n \tneg\ta2, a2\t\t# if (dividend < 0), return -udividend\n .Lpositive:\t\n-\tabi_return\n+\tleaf_return\n \n .Lle_one:\n \t# udivisor is either 0 or 1, so just return 0.\n \t# someday we may want to throw an exception if udivisor is 0.\n \tmovi\ta2, 0\n-\tabi_return\n+\tleaf_return\n \t.size\t__modsi3,.-__modsi3\n \n #endif /* L_modsi3 */"}]}