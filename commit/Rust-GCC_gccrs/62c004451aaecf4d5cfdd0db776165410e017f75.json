{"sha": "62c004451aaecf4d5cfdd0db776165410e017f75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjMDA0NDUxYWFlY2Y0ZDVjZmRkMGRiNzc2MTY1NDEwZTAxN2Y3NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-29T12:53:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-29T12:53:39Z"}, "message": "re PR target/64844 (Vectorization inhibited in gcc5 when loop starts with elem[1], aarch64 perf regression from 4.9.1)\n\n2015-01-29  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/64844\n\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Always\n\tdump cost model analysis.\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n\tDo not register adjusted load/store costs here.\n\n\t* gcc.dg/vect/pr64844.c: New testcase.\n\nFrom-SVN: r220244", "tree": {"sha": "bbeea17fac83e1a3b225fee52272427e10e97163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbeea17fac83e1a3b225fee52272427e10e97163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62c004451aaecf4d5cfdd0db776165410e017f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c004451aaecf4d5cfdd0db776165410e017f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c004451aaecf4d5cfdd0db776165410e017f75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c004451aaecf4d5cfdd0db776165410e017f75/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85d44192f61187b585b88c26016a4407cfe90ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d44192f61187b585b88c26016a4407cfe90ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d44192f61187b585b88c26016a4407cfe90ed3"}], "stats": {"total": 134, "additions": 93, "deletions": 41}, "files": [{"sha": "308c0eb20d2805ca992ab50466aead076752d874", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62c004451aaecf4d5cfdd0db776165410e017f75", "patch": "@@ -1,3 +1,11 @@\n+2015-01-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64844\n+\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Always\n+\tdump cost model analysis.\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n+\tDo not register adjusted load/store costs here.\n+\n 2015-01-29  Ilya Enkovich  <ilya.enkovich@intel.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "cda948d64d3c1dcd6f274436a9e578f253730a19", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62c004451aaecf4d5cfdd0db776165410e017f75", "patch": "@@ -1,3 +1,8 @@\n+2015-01-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64844\n+\t* gcc.dg/vect/pr64844.c: New testcase.\n+\n 2015-01-29  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR middle-end/64809"}, {"sha": "fa01efc4506f92853ac59003c577fd8d7cbc57ff", "filename": "gcc/testsuite/gcc.dg/vect/pr64844.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64844.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64844.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64844.c?ref=62c004451aaecf4d5cfdd0db776165410e017f75", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-additional-options \"-ffast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+static double\n+compute(size_t n, double const * __restrict a, double const * __restrict b)\n+{\n+  double res = 0.0;\n+  size_t i;\n+  for (i = 0; i < n; ++i)\n+    res += a[i] + b[i];\n+  return res;\n+}\n+\n+void init(double *, double *);\n+\n+int\n+main()\n+{\n+  double ary1[1024];\n+  double ary2[1024];\n+  size_t i;\n+\n+  check_vect ();\n+\n+  // Initialize arrays\n+  for (i = 0; i < 1024; ++i)\n+    {\n+      ary1[i] = 1 / (double)(i + 1);\n+      ary2[i] = 1 + 1 / (double) (i + 1);\n+      __asm__ volatile (\"\" : : : \"memory\");\n+    }\n+\n+  // Compute two results using different starting elements\n+  if ((int) compute (512, &ary1[0], &ary2[0]) != 525\n+      || (int) compute(512, &ary1[1], &ary2[1]) != 523)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* All targets should allow vectorizing this by some means of\n+   dealing with the known misalignment in loop 2.  */\n+\n+/* { dg-final { scan-tree-dump-times \"loop vectorized\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "302f2df2af21fb9508476276900671dc82cdc572", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=62c004451aaecf4d5cfdd0db776165410e017f75", "patch": "@@ -1763,9 +1763,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       if (do_peeling)\n         {\n-\t  stmt_info_for_cost *si;\n-\t  void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-\n           /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.\n              If the misalignment of DR_i is identical to that of dr0 then set\n              DR_MISALIGNMENT (DR_i) to zero.  If the misalignment of DR_i and\n@@ -1791,20 +1788,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Peeling for alignment will be applied.\\n\");\n             }\n-\t  /* We've delayed passing the inside-loop peeling costs to the\n-\t     target cost model until we were sure peeling would happen.\n-\t     Do so now.  */\n-\t  if (body_cost_vec.exists ())\n-\t    {\n-\t      FOR_EACH_VEC_ELT (body_cost_vec, i, si)\n-\t\t{\n-\t\t  struct _stmt_vec_info *stmt_info\n-\t\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n-\t\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n-\t\t\t\t\tsi->misalign, vect_body);\n-\t\t}\n-\t      body_cost_vec.release ();\n-\t    }\n+\t  /* The inside-loop cost will be accounted for in vectorizable_load\n+\t     and vectorizable_store correctly with adjusted alignments.\n+\t     Drop the body_cst_vec on the floor here.  */\n+\t  body_cost_vec.release ();\n \n \t  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n \t  gcc_assert (stat);"}, {"sha": "c5f1c29cbe29ddfd7bd677a1f3a438afed95cd43", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c004451aaecf4d5cfdd0db776165410e017f75/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=62c004451aaecf4d5cfdd0db776165410e017f75", "patch": "@@ -2990,6 +2990,27 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   vec_outside_cost = (int)(vec_prologue_cost + vec_epilogue_cost);\n   \n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n+      dump_printf (MSG_NOTE, \"  Vector inside of loop cost: %d\\n\",\n+                   vec_inside_cost);\n+      dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\",\n+                   vec_prologue_cost);\n+      dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\",\n+                   vec_epilogue_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar iteration cost: %d\\n\",\n+                   scalar_single_iter_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar outside cost: %d\\n\",\n+                   scalar_outside_cost);\n+      dump_printf (MSG_NOTE, \"  Vector outside cost: %d\\n\",\n+                   vec_outside_cost);\n+      dump_printf (MSG_NOTE, \"  prologue iterations: %d\\n\",\n+                   peel_iters_prologue);\n+      dump_printf (MSG_NOTE, \"  epilogue iterations: %d\\n\",\n+                   peel_iters_epilogue);\n+    }\n+\n   /* Calculate number of iterations required to make the vector version\n      profitable, relative to the loop bodies only.  The following condition\n      must hold true:\n@@ -3037,30 +3058,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       return;\n     }\n \n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n-      dump_printf (MSG_NOTE, \"  Vector inside of loop cost: %d\\n\",\n-                   vec_inside_cost);\n-      dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\",\n-                   vec_prologue_cost);\n-      dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\",\n-                   vec_epilogue_cost);\n-      dump_printf (MSG_NOTE, \"  Scalar iteration cost: %d\\n\",\n-                   scalar_single_iter_cost);\n-      dump_printf (MSG_NOTE, \"  Scalar outside cost: %d\\n\",\n-                   scalar_outside_cost);\n-      dump_printf (MSG_NOTE, \"  Vector outside cost: %d\\n\",\n-                   vec_outside_cost);\n-      dump_printf (MSG_NOTE, \"  prologue iterations: %d\\n\",\n-                   peel_iters_prologue);\n-      dump_printf (MSG_NOTE, \"  epilogue iterations: %d\\n\",\n-                   peel_iters_epilogue);\n-      dump_printf (MSG_NOTE,\n-                   \"  Calculated minimum iters for profitability: %d\\n\",\n-                   min_profitable_iters);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n+  dump_printf (MSG_NOTE,\n+\t       \"  Calculated minimum iters for profitability: %d\\n\",\n+\t       min_profitable_iters);\n \n   min_profitable_iters =\n \tmin_profitable_iters < vf ? vf : min_profitable_iters;"}]}