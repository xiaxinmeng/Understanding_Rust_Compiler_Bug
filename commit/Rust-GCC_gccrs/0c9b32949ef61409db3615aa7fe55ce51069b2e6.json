{"sha": "0c9b32949ef61409db3615aa7fe55ce51069b2e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5YjMyOTQ5ZWY2MTQwOWRiMzYxNWFhN2ZlNTVjZTUxMDY5YjJlNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-01-14T15:25:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-01-14T15:25:22Z"}, "message": "re PR middle-end/68146 (ice in gimple_stmt_nonnegative_warnv_p with -O2)\n\n\tPR middle-end/68146\n\tPR tree-optimization/69155\n\t* tree-complex.c: Include cfganal.h.\n\t(phis_to_revisit): New variable.\n\t(extract_component): Add phiarg_p argument.  Assert that returned\n\tSSA_NAME has non-NULL SSA_NAME_DEF_STMT unless phiarg_p is true.\n\t(update_phi_components): Partly rewrite to use loop over real/imag\n\tcomponents instead of code duplication.  If extract_component returns\n\tSSA_NAME with NULL SSA_NAME_DEF_STMT, store SSA_NAME_VAR or\n\tcreate_tmp_reg into the PHI node instead, and mention the phi triplet\n\tin phis_to_revisit.\n\t(tree_lower_complex): Walk bbs in rpo order.  Adjust phis recorded\n\tin phis_to_revisit at the end.\n\n\t* gfortran.dg/pr68146.f: New test.\n\t* gfortran.dg/pr69155.f90: New test.\n\nFrom-SVN: r232368", "tree": {"sha": "5cd8699fbc1fd76580481caede4120739a694bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cd8699fbc1fd76580481caede4120739a694bd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c9b32949ef61409db3615aa7fe55ce51069b2e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9b32949ef61409db3615aa7fe55ce51069b2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9b32949ef61409db3615aa7fe55ce51069b2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9b32949ef61409db3615aa7fe55ce51069b2e6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3688e13db33177ac065aa0064ebd68e0afbadc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3688e13db33177ac065aa0064ebd68e0afbadc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3688e13db33177ac065aa0064ebd68e0afbadc66"}], "stats": {"total": 161, "additions": 132, "deletions": 29}, "files": [{"sha": "9009a6f47f19964cf7e51918ffcd97bda08ac631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c9b32949ef61409db3615aa7fe55ce51069b2e6", "patch": "@@ -1,3 +1,19 @@\n+2016-01-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/68146\n+\tPR tree-optimization/69155\n+\t* tree-complex.c: Include cfganal.h.\n+\t(phis_to_revisit): New variable.\n+\t(extract_component): Add phiarg_p argument.  Assert that returned\n+\tSSA_NAME has non-NULL SSA_NAME_DEF_STMT unless phiarg_p is true.\n+\t(update_phi_components): Partly rewrite to use loop over real/imag\n+\tcomponents instead of code duplication.  If extract_component returns\n+\tSSA_NAME with NULL SSA_NAME_DEF_STMT, store SSA_NAME_VAR or\n+\tcreate_tmp_reg into the PHI node instead, and mention the phi triplet\n+\tin phis_to_revisit.\n+\t(tree_lower_complex): Walk bbs in rpo order.  Adjust phis recorded\n+\tin phis_to_revisit at the end.\n+\n 2016-01-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68060"}, {"sha": "4b5e9e254d3d2dbcd09af878fdac421123651ea5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c9b32949ef61409db3615aa7fe55ce51069b2e6", "patch": "@@ -1,3 +1,10 @@\n+2016-01-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/68146\n+\tPR tree-optimization/69155\n+\t* gfortran.dg/pr68146.f: New test.\n+\t* gfortran.dg/pr69155.f90: New test.\n+\n 2016-01-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68060"}, {"sha": "1eaf5a563ad78418f297d00c1bae2a7dbc375855", "filename": "gcc/testsuite/gfortran.dg/pr68146.f", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68146.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68146.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr68146.f?ref=0c9b32949ef61409db3615aa7fe55ce51069b2e6", "patch": "@@ -0,0 +1,16 @@\n+C PR middle-end/68146\n+C { dg-do compile }\n+C { dg-options \"-O2 -w\" }\n+      SUBROUTINE CJYVB(V,Z,V0,CBJ,CDJ,CBY,CYY)\n+      IMPLICIT DOUBLE PRECISION (A,B,G,O-Y)\n+      IMPLICIT COMPLEX*16 (C,Z)\n+      DIMENSION CBJ(0:*),CDJ(0:*),CBY(0:*)\n+      N=INT(V)\n+      CALL GAMMA2(VG,GA)\n+      DO 65 K=1,N\n+        CBY(K)=CYY\n+65    CONTINUE\n+      CDJ(0)=V0/Z*CBJ(0)-CBJ(1)\n+      DO 70 K=1,N\n+70      CDJ(K)=-(K+V0)/Z*CBJ(K)+CBJ(K-1)\n+      END"}, {"sha": "a8ee9d70d9a0264327dbbe8828092671a66c3e88", "filename": "gcc/testsuite/gfortran.dg/pr69155.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69155.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69155.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69155.f90?ref=0c9b32949ef61409db3615aa7fe55ce51069b2e6", "patch": "@@ -0,0 +1,15 @@\n+! PR tree-optimization/69155\n+! { dg-do compile }\n+\n+function pr69155 (a, b)\n+  complex(kind=8), value :: a, b\n+  if (dimag (a) .lt. 10) then\n+  1 continue\n+    if (dble (a) .lt. 10) then\n+      b = b - 1 / a\n+      a = a + 1\n+      goto 1\n+    end if\n+  end if\n+  pr69155 = a + b\n+end"}, {"sha": "d781a8aa014c4340adad348f37f4e80e410fdf69", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9b32949ef61409db3615aa7fe55ce51069b2e6/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=0c9b32949ef61409db3615aa7fe55ce51069b2e6", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tree-hasher.h\"\n #include \"cfgloop.h\"\n+#include \"cfganal.h\"\n \n \n /* For each complex ssa name, a lattice value.  We're interested in finding\n@@ -69,6 +70,11 @@ static int_tree_htab_type *complex_variable_components;\n /* For each complex SSA_NAME, a pair of ssa names for the components.  */\n static vec<tree> complex_ssa_name_components;\n \n+/* Vector of PHI triplets (original complex PHI and corresponding real and\n+   imag PHIs if real and/or imag PHIs contain temporarily\n+   non-SSA_NAME/non-invariant args that need to be replaced by SSA_NAMEs.  */\n+static vec<gphi *> phis_to_revisit;\n+\n /* Lookup UID in the complex_variable_components hashtable and return the\n    associated tree.  */\n static tree\n@@ -588,7 +594,7 @@ set_component_ssa_name (tree ssa_name, bool imag_p, tree value)\n \n static tree\n extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n-\t\t   bool gimple_p)\n+\t\t   bool gimple_p, bool phiarg_p = false)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -619,7 +625,10 @@ extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n       }\n \n     case SSA_NAME:\n-      return get_component_ssa_name (t, imagpart_p);\n+      t = get_component_ssa_name (t, imagpart_p);\n+      if (TREE_CODE (t) == SSA_NAME && SSA_NAME_DEF_STMT (t) == NULL)\n+\tgcc_assert (phiarg_p);\n+      return t;\n \n     default:\n       gcc_unreachable ();\n@@ -721,31 +730,48 @@ update_phi_components (basic_block bb)\n \n       if (is_complex_reg (gimple_phi_result (phi)))\n \t{\n-\t  tree lr, li;\n-\t  gimple *pr = NULL, *pi = NULL;\n-\t  unsigned int i, n;\n-\n-\t  lr = get_component_ssa_name (gimple_phi_result (phi), false);\n-\t  if (TREE_CODE (lr) == SSA_NAME)\n-\t    pr = create_phi_node (lr, bb);\n+\t  gphi *p[2] = { NULL, NULL };\n+\t  unsigned int i, j, n;\n+\t  bool revisit_phi = false;\n \n-\t  li = get_component_ssa_name (gimple_phi_result (phi), true);\n-\t  if (TREE_CODE (li) == SSA_NAME)\n-\t    pi = create_phi_node (li, bb);\n+\t  for (j = 0; j < 2; j++)\n+\t    {\n+\t      tree l = get_component_ssa_name (gimple_phi_result (phi), j > 0);\n+\t      if (TREE_CODE (l) == SSA_NAME)\n+\t\tp[j] = create_phi_node (l, bb);\n+\t    }\n \n \t  for (i = 0, n = gimple_phi_num_args (phi); i < n; ++i)\n \t    {\n \t      tree comp, arg = gimple_phi_arg_def (phi, i);\n-\t      if (pr)\n-\t\t{\n-\t\t  comp = extract_component (NULL, arg, false, false);\n-\t\t  SET_PHI_ARG_DEF (pr, i, comp);\n-\t\t}\n-\t      if (pi)\n-\t\t{\n-\t\t  comp = extract_component (NULL, arg, true, false);\n-\t\t  SET_PHI_ARG_DEF (pi, i, comp);\n-\t\t}\n+\t      for (j = 0; j < 2; j++)\n+\t\tif (p[j])\n+\t\t  {\n+\t\t    comp = extract_component (NULL, arg, j > 0, false, true);\n+\t\t    if (TREE_CODE (comp) == SSA_NAME\n+\t\t\t&& SSA_NAME_DEF_STMT (comp) == NULL)\n+\t\t      {\n+\t\t\t/* For the benefit of any gimple simplification during\n+\t\t\t   this pass that might walk SSA_NAME def stmts,\n+\t\t\t   don't add SSA_NAMEs without definitions into the\n+\t\t\t   PHI arguments, but put a decl in there instead\n+\t\t\t   temporarily, and revisit this PHI later on.  */\n+\t\t\tif (SSA_NAME_VAR (comp))\n+\t\t\t  comp = SSA_NAME_VAR (comp);\n+\t\t\telse\n+\t\t\t  comp = create_tmp_reg (TREE_TYPE (comp),\n+\t\t\t\t\t\t get_name (comp));\n+\t\t\trevisit_phi = true;\n+\t\t      }\n+\t\t    SET_PHI_ARG_DEF (p[j], i, comp);\n+\t\t  }\n+\t    }\n+\n+\t  if (revisit_phi)\n+\t    {\n+\t      phis_to_revisit.safe_push (phi);\n+\t      phis_to_revisit.safe_push (p[0]);\n+\t      phis_to_revisit.safe_push (p[1]);\n \t    }\n \t}\n     }\n@@ -1612,9 +1638,10 @@ expand_complex_operations_1 (gimple_stmt_iterator *gsi)\n static unsigned int\n tree_lower_complex (void)\n {\n-  int old_last_basic_block;\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n+  int n_bbs, i;\n+  int *rpo;\n \n   if (!init_dont_simulate_again ())\n     return 0;\n@@ -1632,18 +1659,40 @@ tree_lower_complex (void)\n \n   update_parameter_components ();\n \n-  /* ??? Ideally we'd traverse the blocks in breadth-first order.  */\n-  old_last_basic_block = last_basic_block_for_fn (cfun);\n-  FOR_EACH_BB_FN (bb, cfun)\n+  rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  n_bbs = pre_and_rev_post_order_compute (NULL, rpo, false);\n+  for (i = 0; i < n_bbs; i++)\n     {\n-      if (bb->index >= old_last_basic_block)\n-\tcontinue;\n-\n+      bb = BASIC_BLOCK_FOR_FN (cfun, rpo[i]);\n       update_phi_components (bb);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \texpand_complex_operations_1 (&gsi);\n     }\n \n+  free (rpo);\n+\n+  if (!phis_to_revisit.is_empty ())\n+    {\n+      unsigned int n = phis_to_revisit.length ();\n+      for (unsigned int j = 0; j < n; j += 3)\n+\tfor (unsigned int k = 0; k < 2; k++)\n+\t  if (gphi *phi = phis_to_revisit[j + k + 1])\n+\t    {\n+\t      unsigned int m = gimple_phi_num_args (phi);\n+\t      for (unsigned int l = 0; l < m; ++l)\n+\t\t{\n+\t\t  tree op = gimple_phi_arg_def (phi, l);\n+\t\t  if (TREE_CODE (op) == SSA_NAME\n+\t\t      || is_gimple_min_invariant (op))\n+\t\t    continue;\n+\t\t  tree arg = gimple_phi_arg_def (phis_to_revisit[j], l);\n+\t\t  op = extract_component (NULL, arg, k > 0, false, false);\n+\t\t  SET_PHI_ARG_DEF (phi, l, op);\n+\t\t}\n+\t    }\n+      phis_to_revisit.release ();\n+    }\n+\n   gsi_commit_edge_inserts ();\n \n   delete complex_variable_components;"}]}