{"sha": "8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5NWU5YWQxMThiZWM5OGM0MGUyZmEyNWExOWFiZDc2NmY0ZTFmMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:22:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:22:13Z"}, "message": "Initial revision\n\nFrom-SVN: r11453", "tree": {"sha": "1b705e29bd7d1b6bd5c8702afe380ad95d399446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b705e29bd7d1b6bd5c8702afe380ad95d399446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/comments", "author": null, "committer": null, "parents": [{"sha": "ca10c449d67033a975dbb8a69ef0abfe77b3b61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca10c449d67033a975dbb8a69ef0abfe77b3b61c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca10c449d67033a975dbb8a69ef0abfe77b3b61c"}], "stats": {"total": 1888, "additions": 1888, "deletions": 0}, "files": [{"sha": "fb06fc6d40df5ae7ac7d8a4bff63819e1e7e8c14", "filename": "gcc/objc/objc-list.h", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fobjc-list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fobjc-list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-list.h?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,150 @@\n+/* Generic single linked list to keep various information \n+   Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#ifndef __GNU_OBJC_LIST_H\n+#define __GNU_OBJC_LIST_H\n+void * __objc_xrealloc (void *optr, size_t size);\n+void * __objc_xmalloc (size_t size);\n+\n+struct objc_list {\n+  void *head;\n+  struct objc_list *tail;\n+};\n+\n+/* Return a cons cell produced from (head . tail) */\n+\n+static inline struct objc_list* \n+list_cons(void* head, struct objc_list* tail)\n+{\n+  struct objc_list* cell;\n+\n+  cell = (struct objc_list*)__objc_xmalloc(sizeof(struct objc_list));\n+  cell->head = head;\n+  cell->tail = tail;\n+  return cell;\n+}\n+\n+/* Return the length of a list, list_length(NULL) returns zero */\n+\n+static inline int\n+list_length(struct objc_list* list)\n+{\n+  int i = 0;\n+  while(list)\n+    {\n+      i += 1;\n+      list = list->tail;\n+    }\n+  return i;\n+}\n+\n+/* Return the Nth element of LIST, where N count from zero.  If N \n+   larger than the list length, NULL is returned  */\n+\n+static inline void*\n+list_nth(int index, struct objc_list* list)\n+{\n+  while(index-- != 0)\n+    {\n+      if(list->tail)\n+\tlist = list->tail;\n+      else\n+\treturn 0;\n+    }\n+  return list->head;\n+}\n+\n+/* Remove the element at the head by replacing it by its successor */\n+\n+static inline void\n+list_remove_head(struct objc_list** list)\n+{\n+  if ((*list)->tail)\n+    {\n+      struct objc_list* tail = (*list)->tail; /* fetch next */\n+      *(*list) = *tail;\t\t/* copy next to list head */\n+      free(tail);\t\t\t/* free next */\n+    }\n+  else\t\t\t\t/* only one element in list */\n+    {\n+      free (*list);\n+      (*list) = 0;\n+    }\n+}\n+\n+\n+/* Remove the element with `car' set to ELEMENT */\n+\n+static inline void\n+list_remove_elem(struct objc_list** list, void* elem)\n+{\n+  while (*list) {\n+    if ((*list)->head == elem)\n+      list_remove_head(list);\n+    list = &((*list)->tail);\n+  }\n+}\n+\n+/* Map FUNCTION over all elements in LIST */\n+\n+static inline void\n+list_mapcar(struct objc_list* list, void(*function)(void*))\n+{\n+  while(list)\n+    {\n+      (*function)(list->head);\n+      list = list->tail;\n+    }\n+}\n+\n+/* Return element that has ELEM as car */\n+\n+static inline struct objc_list**\n+list_find(struct objc_list** list, void* elem)\n+{\n+  while(*list)\n+    {\n+    if ((*list)->head == elem)\n+      return list;\n+    list = &((*list)->tail);\n+    }\n+  return NULL;\n+}\n+\n+/* Free list (backwards recursive) */\n+\n+static void\n+list_free(struct objc_list* list)\n+{\n+  if(list)\n+    {\n+      list_free(list->tail);\n+      free(list);\n+    }\n+}\n+#endif __GNU_OBJC_LIST_H"}, {"sha": "00e183d86b544951d4ebff7fb569dbfc56eeab34", "filename": "gcc/objc/thr-decosf1.c", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-decosf1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-decosf1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-decosf1.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,323 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pthread.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+    pthread_mutex_t             lock;           /* pthread mutex.           */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+static pthread_key_t    __objc_thread_data_key; /* Data key for thread data.*/\n+\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+    printf(\"__objc_init_thread_system\\n\");\n+    \n+    if (pthread_keycreate(&__objc_thread_data_key, NULL) == 0)\n+        return 0;                               /* Yes, return success.     */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    pthread_t           new_thread_handle;      /* DCE thread handle.       */\n+\n+    objc_mutex_lock(__objc_runtime_mutex);\n+    \n+    if (pthread_create(&new_thread_handle, pthread_attr_default,\n+                       (void *)func, arg) == 0) {\n+        thread_id = *(_objc_thread_t *)&new_thread_handle; /* ??? May not work! (64bit)*/\n+        pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n+\t__objc_runtime_threads_alive++;\n+    }\n+    \n+    objc_mutex_unlock(__objc_runtime_mutex);\n+    return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+    int         sys_priority = 0;\n+\n+    switch (priority) {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+        sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+        break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+        break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+        break;\n+    }\n+    \n+    if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+        return 0;                               /* Changed priority. End.   */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+    int         sys_priority;                   /* DCE thread priority.     */\n+    \n+    if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n+        if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n+            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+        if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n+            return OBJC_THREAD_BACKGROUND_PRIORITY;\n+        return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+    return -1;                                  /* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+    pthread_yield();                            /* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+      \n+  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  -1 which is reserved as a marker for \"no thread\".\n+ */\n+int\n+objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return *(int *)&self;                        /* Return thread handle.    */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+    if (pthread_setspecific(__objc_thread_data_key, (void *)value) == 0)\n+        return 0;                           \t/* Return thread data.      */\n+    return -1;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+    void *      value = NULL;\n+    \n+    if (pthread_getspecific(__objc_thread_data_key, (void *)&value) == 0)\n+        return value;                           /* Return thread data.      */\n+    \n+    return NULL;\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n+ *  the allocation fails for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    int         err = 0;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+    \n+    err = pthread_mutex_init(&mutex->lock, pthread_mutexattr_default);\n+    \n+    if (err != 0) {                             /* System init failed?      */\n+        free(mutex);                            /* Yes, free local memory.  */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = -1;                          /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    pthread_mutex_unlock(&mutex->lock);         /* Must unlock system mutex.*/\n+    pthread_mutex_destroy(&mutex->lock);        /* Free system mutex.       */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    int         thread_id;                      /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    if (pthread_mutex_lock(&mutex->lock) != 0)  /* Lock DCE system mutex.   */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    int         thread_id;                      /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    if (pthread_mutex_trylock(&mutex->lock) != 1) /* Lock DCE system mutex. */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    int         thread_id;                      /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = -1;                          /* Set owner to \"no thread\".*/\n+    \n+    if (pthread_mutex_unlock(&mutex->lock) != 0)  /* Unlock system mutex.   */\n+        return -1;                              /* Failed, abort.           */\n+    \n+    return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}, {"sha": "7e1236a553081a08074de29c1c7a7b27d34d29ea", "filename": "gcc/objc/thr-irix.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-irix.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,312 @@\n+/* GNU Objective C Runtime Thread Interface - SGI IRIX Implementation\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/sysmp.h>\n+#include <sys/prctl.h>\n+#include <ulocks.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+    ulock_t                     lock;           /* Irix lock.               */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+static void *  __objc_shared_arena_handle = NULL; /* Storage arena locks.   */\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+    char        arena_name[64];                 /* Name of IRIX arena.      */\n+\n+    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+    sprintf(arena_name, \"/usr/tmp/objc_%05u\", (unsigned)getpid());\n+    usconfig(CONF_INITUSERS, 256);              /* Up to 256 threads.       */\n+    usconfig(CONF_ARENATYPE, US_SHAREDONLY);    /* Arena only for threads.  */\n+    if (!(__objc_shared_arena_handle = usinit(arena_name))) /* Init Failed? */ \n+        return -1;                              /* Yes, return error code.  */\n+    \n+    return 0;\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+    _objc_thread_t      thread_id = NULL;\n+    int                 sys_id;\n+    \n+    objc_mutex_lock(__objc_runtime_mutex);\n+    if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0) {\n+        thread_id = (_objc_thread_t)sys_id;\n+        __objc_runtime_threads_alive++;\n+    }\n+    objc_mutex_unlock(__objc_runtime_mutex);\n+\n+    return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+    int         sys_priority = 0;\n+\n+    switch (priority) {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+        break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+        break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+        break;\n+    }\n+    return -1;                                  /* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+    return -1;                                  /* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+    sginap(0);                                  /* Yield to equal process.  */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+    objc_mutex_lock(__objc_runtime_mutex);\n+    __objc_runtime_threads_alive--;\n+    objc_mutex_unlock(__objc_runtime_mutex);\n+\n+    exit(__objc_thread_exit_status);            /* IRIX only has exit.      */\n+    return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  NULL which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+    return (_objc_thread_t)get_pid();           /* Threads are processes.   */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+    *((void **)&PRDA->usr_prda) = value;        /* Set thread data ptr.     */\n+    return 0;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+    return *((void **)&PRDA->usr_prda);         /* Return thread data ptr.  */\n+}\n+\n+/********\n+ *  Allocate a mutex.\n+ *  Return the mutex pointer if successful or NULL if the allocation failed\n+ *  for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t       mutex;\n+    int                 err = 0;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+    \n+    if (!(mutex->lock = usnewlock(__objc_shared_arena_handle)))\n+        err = -1;\n+    \n+    if (err != 0) {                             /* System init failed?      */\n+        free(mutex);                            /* Yes, free local memory.  */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    usfreelock(mutex->lock, __objc_shared_arena_handle); /* Free IRIX lock. */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id) {            /* Already own lock?        */\n+        DEBUG_PRINTF(\"lock owned by: %d:%d\\n\", mutex->owner, mutex->depth);\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    }\n+    \n+    DEBUG_PRINTF(\"lock owned by: %d:%d (attempt by %d)\\n\",\n+                 mutex->owner, mutex->depth, thread_id);\n+\n+    if (ussetlock(mutex->lock) == 0)            /* Did lock acquire fail?   */\n+        return -1;                              /* Yes, abort.              */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    if (ustestlock(mutex->lock) == 0)           /* Did lock acquire fail?   */\n+        return -1;                              /* Yes, abort.              */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t     thread_id;               /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+\n+    DEBUG_PRINTF(\"unlock by: %d:%d\\n\", mutex->owner, mutex->depth - 1);\n+    \n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    usunsetlock(mutex->lock);                   /* Free lock.               */\n+    \n+    return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}, {"sha": "3821a2a15e626774d6e474f7fc781005425747ad", "filename": "gcc/objc/thr-single.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-single.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-single.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-single.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,237 @@\n+/* GNU Objective C Runtime Thread Implementation\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+};\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+  return -1;                                  \t/* Failed.                  */\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+  return NULL;\t\t\t\t   \t/* We can't start threads.  */\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  return -1;                                   \t/* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.        */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+  return;\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  exit(__objc_thread_exit_status);\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  NULL which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  return (_objc_thread_t)1;                     /* No thread support, use 1.*/\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+\n+static void *thread_local_storage = NULL;\n+\n+int\n+objc_thread_set_data(void *value)\n+{\n+  thread_local_storage = value;\n+  return 0;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+  return thread_local_storage;\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n+ *  allocation failed for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+    \n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallocate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    int         thread_id;                      /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}, {"sha": "d27fcb428e9ed73889a131755d4b8e51912beb2f", "filename": "gcc/objc/thr-solaris.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-solaris.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,326 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Cobnrtibuted by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+\n+#include <thread.h>\n+#include <synch.h>\n+#include <errno.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile int                depth;          /* # of acquires.           */\n+    mutex_t                     lock;           /* System mutex.            */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+static thread_key_t     __objc_thread_data_key; /* Data key for thread data.*/\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+\n+    if (thr_keycreate(&__objc_thread_data_key, NULL) == 0)\n+        return 0;                               /* Yes, return success.     */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return -1 if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+  _objc_thread_t        thread_id = NULL;       /* Detached thread id.      */\n+  thread_t              new_thread_id = 0;      /* Solaris thread id type.  */\n+  int                   errn;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  if (thr_create(NULL, 0, (void *)func, arg,\n+                 THR_DETACHED | THR_NEW_LWP,\n+                 &new_thread_id) == 0) {    \t/* Created new thread?      */\n+    thread_id = (_objc_thread_t)new_thread_id;  /* Yes, remember its id.    */\n+    __objc_runtime_threads_alive++;\n+  }\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+    \n+  return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+    int         sys_priority = 0;\n+\n+    switch (priority) {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+        sys_priority = 300;\n+        break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+        sys_priority = 200;\n+        break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+        sys_priority = 1000;\n+        break;\n+    }\n+    \n+    if (thr_setprio(thr_self(), sys_priority) == 0)\n+        return 0;                               /* Changed priority. End.   */\n+    \n+    return -1;                                  /* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+    int         sys_priority;                   /* Solaris thread priority. */\n+                                                   \n+    if (thr_getprio(thr_self(), &sys_priority) == 0) {\n+        if (sys_priority >= 250)\n+            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+        else if (sys_priority >= 150)\n+            return OBJC_THREAD_BACKGROUND_PRIORITY;\n+        return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+    \n+    return -1;                                  /* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+    thr_yield();                                /* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive++;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  thr_exit(&__objc_thread_exit_status);         /* Terminate thread.        */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  NULL which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+    return (_objc_thread_t)thr_self();\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+    if (thr_setspecific(__objc_thread_data_key, value) == 0)\n+        return 0;\n+    return -1;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+    void *      value = NULL;\n+    \n+    if (thr_getspecific(__objc_thread_data_key, &value) == 0)\n+        return value;                           /* Return thread data.      */\n+    \n+    return NULL;\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n+ *  the allocation fails for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    struct _objc_mutex *mutex;\n+    int         err = 0;\n+    \n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+    \n+    err = mutex_init(&mutex->lock, USYNC_THREAD, 0);\n+    \n+    if (err != 0) {                             /* System init failed?      */\n+        free(mutex);                            /* Yes, free local memory.  */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+    \n+    mutex_destroy(&mutex->lock);                /* System deallocate.       */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    if (mutex_lock(&mutex->lock) != 0)          /* Did lock acquire fail?   */\n+        return -1;                              /* Yes, abort.              */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+    if (mutex_trylock(&mutex->lock) != 0)       /* Did lock acquire fail?   */\n+        return -1;                              /* Yes, abort.              */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    if (mutex_unlock(&mutex->lock) != 0)        /* Did lock release fail?   */\n+        return -1;                              /* Yes, return error value. */\n+    \n+    return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}, {"sha": "d933999ccb763df1a7eb7332217ce2faca6f537a", "filename": "gcc/objc/thr-win32.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-win32.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,331 @@\n+/* GNU Objective C Runtime Thread Interface - Win32 Implementation\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <windows.h>\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+  volatile _objc_thread_t       owner;        \t/* Id of thread that owns.  */\n+  volatile int                  depth;          /* # of acquires.           */\n+  HANDLE                        handle;         /* Win32 mutex HANDLE.      */\n+};\n+\n+/*****************************************************************************\n+ *  Static variables.\n+ */\n+static DWORD\t__objc_data_tls = (DWORD)-1;\t/* Win32 Thread Local Index.*/\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+\n+  if ((__objc_data_tls = TlsAlloc()) != (DWORD)-1)\n+    return 0;                               \t/* Yes, return success.     */\n+    \n+  return -1;                                  \t/* Failed.                  */\n+}\n+\n+int\n+__objc_fini_thread_system(void)\n+{\n+  if (__objc_data_tls != (DWORD)-1) {\n+    TlsFree(__objc_data_tls);\n+    return 0;\n+  }\n+  return -1;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+  DWORD        \tthread_id = 0;                  /* Detached thread id.      */\n+  HANDLE\twin32_handle;\t\t\t/* Win32 thread handle.     */\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  \n+  if ((win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n+                                   arg, 0, &thread_id))) {\n+      __objc_runtime_threads_alive++;\n+  }\n+  else\n+      thread_id = 0;\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  return (_objc_thread_t)thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  int         \tsys_priority = 0;\n+\n+  switch (priority) {\n+  case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+    sys_priority = THREAD_PRIORITY_NORMAL;\n+    break;\n+  default:\n+  case OBJC_THREAD_BACKGROUND_PRIORITY:\n+    sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n+    break;\n+  case OBJC_THREAD_LOW_PRIORITY:\n+    sys_priority = THREAD_PRIORITY_LOWEST;\n+    break;\n+  }\n+  if (SetThreadPriority(GetCurrentThread(), sys_priority))\n+    return 0;                                  \t/* Changed priority. End.   */\n+    \n+  return -1;                                  \t/* Failed.                  */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+  int         \tsys_priority;\n+\n+  sys_priority = GetThreadPriority(GetCurrentThread());\n+  \n+  switch (sys_priority) {\n+  case THREAD_PRIORITY_HIGHEST:\n+  case THREAD_PRIORITY_TIME_CRITICAL:\n+  case THREAD_PRIORITY_ABOVE_NORMAL:\n+  case THREAD_PRIORITY_NORMAL:\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+  default:\n+  case THREAD_PRIORITY_BELOW_NORMAL:\n+    return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    \n+  case THREAD_PRIORITY_IDLE:\n+  case THREAD_PRIORITY_LOWEST:\n+    return OBJC_THREAD_LOW_PRIORITY;\n+  }\n+  return -1;                                  \t/* Couldn't get priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+  Sleep(0);\t                            \t/* Yield to equal thread.   */\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  ExitThread(__objc_thread_exit_status);   \t/* Terminate thread.        */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  -1 which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  return (_objc_thread_t)GetCurrentThreadId();  /* Return thread id.        */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+  if (TlsSetValue(__objc_data_tls, value))\n+    return 0;                           \t/* Return thread data.      */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+  return TlsGetValue(__objc_data_tls);          /* Return thread data.      */\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n+ *  the allocation fails for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+    _objc_mutex_t mutex;\n+    int         err = 0;\n+\n+    if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    if ((mutex->handle = CreateMutex(NULL, 0, NULL)) == NULL) {\n+        free(mutex);                            /* Failed, free memory.     */\n+        return NULL;                            /* Abort.                   */\n+    }\n+    mutex->owner = NULL;                        /* No owner.                */\n+    mutex->depth = 0;                           /* No locks.                */\n+    return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+    int         depth;                          /* # of locks on mutex.     */\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+\n+    CloseHandle(mutex->handle);\t\t\t/* Close Win32 handle.      */\n+    \n+    free(mutex);                                /* Free memory.             */\n+    return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    int                 status;\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    status = WaitForSingleObject(mutex->handle, INFINITE);\n+    if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+\n+    return ++mutex->depth;                      /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    DWORD               status;                 /* Return status from Win32.*/\n+\n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner == thread_id)              /* Already own lock?        */\n+        return ++mutex->depth;                  /* Yes, increment depth.    */\n+\n+    status = WaitForSingleObject(mutex->handle, 0);\n+    if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+        return -1;                              /* Failed, abort.           */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    return ++mutex->depth;                      /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Decrements the lock count on this mutex by one.  If the lock count reaches\n+ *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ *  in which case return -1 and the mutex is unaffected.\n+ *  Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    \n+    if (!mutex)                                 /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Released last lock?      */\n+        return --mutex->depth;                  /* No, Decrement depth, end.*/\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+    \n+    if (ReleaseMutex(mutex->handle) == 0)\n+        return -1;                              /* Failed, abort.           */\n+    \n+    return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}, {"sha": "1b51140ada93b2154786e03d70bba5f77160419f", "filename": "gcc/objc/thr.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr.c?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,132 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <stdlib.h>\n+#include \"runtime.h\"\n+\n+/*****************************************************************************\n+ *  Universal static variables:\n+ */\n+int     __objc_thread_exit_status = 0;          /* Global exit status.      */\n+\n+/*****************************************************************************\n+ *  Universal Functionality\n+ */\n+\n+/********\n+ *  First function called in a thread, starts everything else.\n+ */\n+struct __objc_thread_start_state\n+{\n+    SEL         selector;\n+    id          object;\n+    id          argument;\n+};\n+\n+static volatile void\n+__objc_thread_detach_function(struct __objc_thread_start_state *istate)\n+{\n+    if (istate) {                               /* Is state valid?          */\n+        id      (*imp)(id,SEL,id);\n+        SEL     selector = istate->selector;\n+        id      object   = istate->object;\n+        id      argument = istate->argument;\n+\n+        free(istate);\n+\n+        if ((imp = (id(*)(id, SEL, id))objc_msg_lookup(object, selector))) {\n+            (*imp)(object, selector, argument);\n+        }\n+        else\n+            fprintf(stderr, \"__objc_thread_start called with bad selector.\\n\");\n+    }\n+    else {\n+        fprintf(stderr, \"__objc_thread_start called with NULL state.\\n\");\n+    }\n+    objc_thread_exit();\n+}\n+\n+/********\n+ *  Detach a new thread of execution and return its id.  Returns NULL if fails.\n+ *  Thread is started by sending message with selector to object.  Message\n+ *  takes a single argument.\n+ */\n+_objc_thread_t\n+objc_thread_detach(SEL selector, id object, id argument)\n+{\n+  struct __objc_thread_start_state *istate;   /* Initialial thread state. */\n+  _objc_thread_t        thread_id = NULL;     /* Detached thread id.      */\n+\n+  if (!(istate = (struct __objc_thread_start_state *)\n+\t__objc_xmalloc(sizeof(*istate))))     /* Can we allocate state?   */\n+    return NULL;                              /* No, abort.               */\n+\n+  istate->selector = selector;                /* Initialize the thread's  */\n+  istate->object = object;                    /*   state structure.       */\n+  istate->argument = argument;\n+\n+  if ((thread_id = objc_thread_create((void *)__objc_thread_detach_function,\n+                                      istate)) == NULL) {\n+    free(istate);                           /* Release state if failed.   */\n+    return thread_id;\n+  }\n+  return thread_id;\n+}\n+\n+#undef objc_mutex_lock()\n+#undef objc_mutex_unlock()\n+\n+int\n+objc_mutex_unlock_x(_objc_mutex_t mutex, const char *f, int l)\n+{\n+    printf(\"%16.16s#%4d < unlock\", f, l);\n+    return objc_mutex_unlock(mutex);\n+}\n+\n+int\n+objc_mutex_lock_x(_objc_mutex_t mutex, const char *f, int l)\n+{\n+    printf(\"%16.16s#%4d < lock\", f, l);\n+    return objc_mutex_lock(mutex);\n+}\n+\n+/*****************************************************************************\n+ *  Implementation specific functionality:\n+ */\n+\n+#if defined(__sparc__) && defined(__svr4__)     /* Solaris only code.       */\n+#include \"thread-solaris.c\"\n+#elif defined(__sgi__) && defined(__mips__)     /* IRIX only code.          */\n+#include \"thread-irix.c\"\n+#elif defined(__alpha__) && defined(__osf__)    /* Alpha OSF/1 only code.   */\n+#include \"thread-decosf1.c\"\n+#elif defined(__WIN32__)\n+#include \"thread-win32.c\"\n+#else\t\t\t\t\t\t/* Single threaded code.    */\n+#include \"thread-single.c\"\n+#endif\n+\n+/* End of File */"}, {"sha": "3bd1a0b47330550f85c82b5ae30f481b9b2a2870", "filename": "gcc/objc/thr.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d95e9ad118bec98c40e2fa25a19abd766f4e1f3/gcc%2Fobjc%2Fthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr.h?ref=8d95e9ad118bec98c40e2fa25a19abd766f4e1f3", "patch": "@@ -0,0 +1,77 @@\n+/* Thread and mutex controls for Objective C.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#ifndef __thread_INCLUDE_GNU\n+#define __thread_INCLUDE_GNU\n+\n+#include \"objc/objc.h\"\n+\n+/********\n+ *  Thread safe implementation types and functions.  \n+ */\n+\n+#define OBJC_THREAD_INTERACTIVE_PRIORITY        2\n+#define OBJC_THREAD_BACKGROUND_PRIORITY         1\n+#define OBJC_THREAD_LOW_PRIORITY                0\n+\n+typedef struct _objc_mutex *_objc_mutex_t;\n+typedef void * _objc_thread_t;\n+\n+_objc_mutex_t objc_mutex_allocate(void);\n+int     objc_mutex_deallocate(_objc_mutex_t mutex);\n+int     objc_mutex_lock(_objc_mutex_t mutex);\n+int     objc_mutex_unlock(_objc_mutex_t mutex);\n+int     objc_mutex_trylock(_objc_mutex_t mutex);\n+\n+_objc_thread_t objc_thread_create(void (*func)(void *arg), void *arg);\n+void    objc_thread_yield(void);\n+int     objc_thread_exit(void);\n+int     objc_thread_set_priority(int priority);\n+int     objc_thread_get_priority(void);\n+void *  objc_thread_get_data(void);\n+int     objc_thread_set_data(void *value);\n+_objc_thread_t objc_thread_id(void);\n+\n+_objc_thread_t objc_thread_detach(SEL selector, id object, id argument);\n+int     objc_mutex_lock_x(_objc_mutex_t mutex, const char *f, int l);\n+int     objc_mutex_unlock_x(_objc_mutex_t mutex, const char *f, int l);\n+\n+/* For debugging of locks, uncomment these two macros: */\n+/* #define objc_mutex_lock(x)      objc_mutex_lock_x(x, __FILE__, __LINE__) */\n+/* #define objc_mutex_unlock(x)    objc_mutex_unlock_x(x, __FILE__, __LINE__)*/\n+\n+#endif /* not __thread_INCLUDE_GNU */"}]}