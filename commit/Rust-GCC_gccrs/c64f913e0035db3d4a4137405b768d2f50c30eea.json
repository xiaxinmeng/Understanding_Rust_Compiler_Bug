{"sha": "c64f913e0035db3d4a4137405b768d2f50c30eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY0ZjkxM2UwMDM1ZGIzZDRhNDEzNzQwNWI3NjhkMmY1MGMzMGVlYQ==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-05-18T01:05:14Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-18T01:05:14Z"}, "message": "improve open-coding of complex divide, use new method in g77\n\nFrom-SVN: r26993", "tree": {"sha": "bf672e6d747e77a35f1c2998b3ff0cc8a94b55b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf672e6d747e77a35f1c2998b3ff0cc8a94b55b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c64f913e0035db3d4a4137405b768d2f50c30eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64f913e0035db3d4a4137405b768d2f50c30eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64f913e0035db3d4a4137405b768d2f50c30eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64f913e0035db3d4a4137405b768d2f50c30eea/comments", "author": null, "committer": null, "parents": [{"sha": "9580a2d028686c9699e6b8449d4473eb929f4164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9580a2d028686c9699e6b8449d4473eb929f4164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9580a2d028686c9699e6b8449d4473eb929f4164"}], "stats": {"total": 531, "additions": 426, "deletions": 105}, "files": [{"sha": "a117c6c299c3c73454ff930b2d4a62e256b16cf2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -1,3 +1,16 @@\n+Tue May 18 03:53:37 1999  Craig Burley  <craig@jcb-sc.com>\n+\n+\tImprove open-coding of complex divide:\n+\t* flags.h: Declare new front-end-malleable flag.\n+\t* toplev.c: Define new flag.\n+\t* optabs.c (expand_cmplxdiv_straight): New function to do original\n+\topen-coding.\n+\t(expand_cmplxdiv_wide): New function to do new open-coding,\n+\tfrom Toon Moene, with changes (call to emit_barrier, dropping\n+\tof spurious `ok = 1;', plus the obvious `break;' -> `return 0;').\n+\t(expand_binop): A bit of spacing fixing, while at it.\n+\tUse new functions instead of inlining the open-coding code.\n+\n Tue May 18 00:51:46 1999  Krister Walfridsson <cato@df.lth.se>\n \n         * configure.in (arm*-*-netbsd*): Use collect2."}, {"sha": "92de51ab922030da14c504a99e3e9541f61fceef", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -1,3 +1,13 @@\n+Tue May 18 03:52:04 1999  Craig Burley  <craig@jcb-sc.com>\n+\n+\tSupport use of back end's improved open-coding of complex divide:\n+\t* com.c (ffecom_tree_divide_): Use RDIV_EXPR for complex divide,\n+\tinstead of run-time call to [cz]_div, if `-Os' option specified.\n+\t(lang_init_options): Tell back end we want support for wide range\n+\tof inputs to complex divide.\n+\n+\t* Bump version.\n+\n Tue May 18 00:21:34 1999  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \n \t* lang-specs.h: Define __GNUC__ and __GNUC_MINOR__ only if -no-gcc"}, {"sha": "c04c4a770895e86d643a6c6664f8769d89db17c1", "filename": "gcc/f/com.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -9378,6 +9378,10 @@ ffecom_tree_divide_ (tree tree_type, tree left, tree right,\n \t\t       right);\n \n     case COMPLEX_TYPE:\n+      if (! optimize_size)\n+\treturn ffecom_2 (RDIV_EXPR, tree_type,\n+\t\t\t left,\n+\t\t\t right);\n       {\n \tffecomGfrt ix;\n \n@@ -15019,6 +15023,7 @@ lang_init_options ()\n   flag_reduce_all_givs = 1;\n   flag_argument_noalias = 2;\n   flag_errno_math = 0;\n+  flag_complex_divide_method = 1;\n }\n \n void"}, {"sha": "3d7362ad8438b7a2f830deaeb57708284af61f26", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -1 +1 @@\n-const char *ffe_version_string = \"0.5.24-19990513\";\n+const char *ffe_version_string = \"0.5.24-19990515\";"}, {"sha": "a3cc073383e3b77c2d0ea673c56359d6f906b1a9", "filename": "gcc/flags.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -296,6 +296,12 @@ extern int flag_fast_math;\n \n extern int flag_errno_math;\n \n+/* 0 means straightforward implementation of complex divide acceptable.\n+   1 means wide ranges of inputs must work for complex divide.\n+   2 means C9X-like requirements for complex divide (not yet implemented).  */\n+\n+extern int flag_complex_divide_method;\n+\n /* Nonzero means to run loop optimizations twice.  */\n \n extern int flag_rerun_loop_opt;"}, {"sha": "9b4d4f1059c24f6313056d8adc2e41ec0aad507e", "filename": "gcc/optabs.c", "status": "modified", "additions": 385, "deletions": 104, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -246,6 +246,14 @@ enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n static int add_equal_note\tPROTO((rtx, rtx, enum rtx_code, rtx, rtx));\n static rtx widen_operand\tPROTO((rtx, enum machine_mode,\n \t\t\t\t       enum machine_mode, int, int));\n+static int expand_cmplxdiv_straight PROTO((rtx, rtx, rtx, rtx,\n+\t\t\t\t\t   rtx, rtx, enum machine_mode,\n+\t\t\t\t\t   int, enum optab_methods,\n+\t\t\t\t\t   enum mode_class, optab));\n+static int expand_cmplxdiv_wide PROTO((rtx, rtx, rtx, rtx,\n+\t\t\t\t       rtx, rtx, enum machine_mode,\n+\t\t\t\t       int, enum optab_methods,\n+\t\t\t\t       enum mode_class, optab));\n static enum insn_code can_fix_p\tPROTO((enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int *));\n static enum insn_code can_float_p PROTO((enum machine_mode, enum machine_mode,\n@@ -348,6 +356,365 @@ widen_operand (op, mode, oldmode, unsignedp, no_extend)\n   return result;\n }\n \f\n+/* Generate code to perform a straightforward complex divide.  */\n+\n+static int\n+expand_cmplxdiv_straight (rtx real0, rtx real1, rtx imag0, rtx imag1,\n+\t\t\t  rtx realr, rtx imagr, enum machine_mode submode,\n+\t\t\t  int unsignedp, enum optab_methods methods,\n+\t\t\t  enum mode_class class, optab binoptab)\n+{\n+  rtx divisor;\n+  rtx real_t, imag_t;\n+  rtx temp1, temp2;\n+  rtx res;\n+\t      \n+  /* Don't fetch these from memory more than once.  */\n+  real0 = force_reg (submode, real0);\n+  real1 = force_reg (submode, real1);\n+\n+  if (imag0 != 0)\n+    imag0 = force_reg (submode, imag0);\n+\n+  imag1 = force_reg (submode, imag1);\n+\n+  /* Divisor: c*c + d*d.  */\n+  temp1 = expand_binop (submode, smul_optab, real1, real1,\n+\t\t\tNULL_RTX, unsignedp, methods);\n+\n+  temp2 = expand_binop (submode, smul_optab, imag1, imag1,\n+\t\t\tNULL_RTX, unsignedp, methods);\n+\n+  if (temp1 == 0 || temp2 == 0)\n+    return 0;\n+\n+  divisor = expand_binop (submode, add_optab, temp1, temp2,\n+\t\t\t  NULL_RTX, unsignedp, methods);\n+  if (divisor == 0)\n+    return 0;\n+\n+  if (imag0 == 0)\n+    {\n+      /* Mathematically, ((a)(c-id))/divisor.  */\n+      /* Computationally, (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)).  */\n+\n+      /* Calculate the dividend.  */\n+      real_t = expand_binop (submode, smul_optab, real0, real1,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\t\t  \n+      imag_t = expand_binop (submode, smul_optab, real0, imag1,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+\n+      imag_t = expand_unop (submode, neg_optab, imag_t,\n+\t\t\t    NULL_RTX, unsignedp);\n+    }\n+  else\n+    {\n+      /* Mathematically, ((a+ib)(c-id))/divider.  */\n+      /* Calculate the dividend.  */\n+      temp1 = expand_binop (submode, smul_optab, real0, real1,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      temp2 = expand_binop (submode, smul_optab, imag0, imag1,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0 || temp2 == 0)\n+\treturn 0;\n+\n+      real_t = expand_binop (submode, add_optab, temp1, temp2,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\t\t  \n+      temp1 = expand_binop (submode, smul_optab, imag0, real1,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      temp2 = expand_binop (submode, smul_optab, real0, imag1,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0 || temp2 == 0)\n+\treturn 0;\n+\n+      imag_t = expand_binop (submode, sub_optab, temp1, temp2,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+    }\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, real_t, divisor,\n+\t\t\trealr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t real_t, divisor, realr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != realr)\n+    emit_move_insn (realr, res);\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, imag_t, divisor,\n+\t\t\timagr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t imag_t, divisor, imagr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != imagr)\n+    emit_move_insn (imagr, res);\n+\n+  return 1;\n+}\n+\f\n+/* Generate code to perform a wide-input-range-acceptable complex divide.  */\n+\n+static int\n+expand_cmplxdiv_wide (rtx real0, rtx real1, rtx imag0, rtx imag1,\n+\t\t      rtx realr, rtx imagr, enum machine_mode submode,\n+\t\t      int unsignedp, enum optab_methods methods,\n+\t\t      enum mode_class class, optab binoptab)\n+{\n+  rtx ratio, divisor;\n+  rtx real_t, imag_t;\n+  rtx temp1, temp2, lab1, lab2;\n+  enum machine_mode mode;\n+  int align;\n+  rtx res;\n+\t      \n+  /* Don't fetch these from memory more than once.  */\n+  real0 = force_reg (submode, real0);\n+  real1 = force_reg (submode, real1);\n+\n+  if (imag0 != 0)\n+    imag0 = force_reg (submode, imag0);\n+\n+  imag1 = force_reg (submode, imag1);\n+\n+  temp1 = expand_unop (submode, abs_optab, real1, NULL_RTX,\n+\t\t       unsignedp);\n+\n+  temp2 = expand_unop (submode, abs_optab, imag1, NULL_RTX,\n+\t\t       unsignedp);\n+\n+  if (temp1 == 0 || temp2 == 0)\n+    return 0;\n+\n+  mode = GET_MODE (temp1);\n+  align = GET_MODE_ALIGNMENT (mode);\n+  lab1 = gen_label_rtx ();\n+  emit_cmp_and_jump_insns (temp1, temp2, LT, NULL_RTX,\n+\t\t\t   mode, unsignedp, align, lab1);\n+\n+  /* |c| >= |d|; use ratio d/c to scale dividend and divisor.  */\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    ratio = expand_binop (submode, binoptab, imag1, real1,\n+\t\t\t  NULL_RTX, unsignedp, methods);\n+  else\n+    ratio = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t   imag1, real1, NULL_RTX, unsignedp);\n+\n+  if (ratio == 0)\n+    return 0;\n+\n+  /* Calculate divisor.  */\n+\n+  temp1 = expand_binop (submode, smul_optab, imag1, ratio,\n+\t\t\tNULL_RTX, unsignedp, methods);\n+\n+  if (temp1 == 0)\n+    return 0;\n+\n+  divisor = expand_binop (submode, add_optab, temp1, real1,\n+\t\t\t  NULL_RTX, unsignedp, methods);\n+\n+  if (divisor == 0)\n+    return 0;\n+\n+  /* Calculate dividend.  */\n+\n+  if (imag0 == 0)\n+    {\n+      real_t = real0;\n+\n+      /* Compute a / (c+id) as a / (c+d(d/c)) + i (-a(d/c)) / (c+d(d/c)).  */\n+\n+      imag_t = expand_binop (submode, smul_optab, real0, ratio,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      if (imag_t == 0)\n+\treturn 0;\n+\n+      imag_t = expand_unop (submode, neg_optab, imag_t,\n+\t\t\t    NULL_RTX, unsignedp);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      /* Compute (a+ib)/(c+id) as\n+\t (a+b(d/c))/(c+d(d/c) + i(b-a(d/c))/(c+d(d/c)).  */\n+\n+      temp1 = expand_binop (submode, smul_optab, imag0, ratio,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0)\n+\treturn 0;\n+\n+      real_t = expand_binop (submode, add_optab, temp1, real0,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      temp1 = expand_binop (submode, smul_optab, real0, ratio,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0)\n+\treturn 0;\n+\n+      imag_t = expand_binop (submode, sub_optab, imag0, temp1,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+    }\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, real_t, divisor,\n+\t\t\trealr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t real_t, divisor, realr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != realr)\n+    emit_move_insn (realr, res);\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, imag_t, divisor,\n+\t\t\timagr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t imag_t, divisor, imagr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != imagr)\n+    emit_move_insn (imagr, res);\n+\n+  lab2 = gen_label_rtx ();\n+  emit_jump_insn (gen_jump (lab2));\n+  emit_barrier ();\n+\n+  emit_label (lab1);\n+\n+  /* |d| > |c|; use ratio c/d to scale dividend and divisor.  */\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    ratio = expand_binop (submode, binoptab, real1, imag1,\n+\t\t\t  NULL_RTX, unsignedp, methods);\n+  else\n+    ratio = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t   real1, imag1, NULL_RTX, unsignedp);\n+\n+  if (ratio == 0)\n+    return 0;\n+\n+  /* Calculate divisor.  */\n+\n+  temp1 = expand_binop (submode, smul_optab, real1, ratio,\n+\t\t\tNULL_RTX, unsignedp, methods);\n+\n+  if (temp1 == 0)\n+    return 0;\n+\n+  divisor = expand_binop (submode, add_optab, temp1, imag1,\n+\t\t\t  NULL_RTX, unsignedp, methods);\n+\n+  if (divisor == 0)\n+    return 0;\n+\n+  /* Calculate dividend.  */\n+\n+  if (imag0 == 0)\n+    {\n+      /* Compute a / (c+id) as a(c/d) / (c(c/d)+d) + i (-a) / (c(c/d)+d).  */\n+\n+      real_t = expand_binop (submode, smul_optab, real0, ratio,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      imag_t = expand_unop (submode, neg_optab, real0,\n+\t\t\t    NULL_RTX, unsignedp);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      /* Compute (a+ib)/(c+id) as\n+\t (a(c/d)+b)/(c(c/d)+d) + i (b(c/d)-a)/(c(c/d)+d).  */\n+\n+      temp1 = expand_binop (submode, smul_optab, real0, ratio,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0)\n+\treturn 0;\n+\n+      real_t = expand_binop (submode, add_optab, temp1, imag0,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      temp1 = expand_binop (submode, smul_optab, imag0, ratio,\n+\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+      if (temp1 == 0)\n+\treturn 0;\n+\n+      imag_t = expand_binop (submode, sub_optab, temp1, real0,\n+\t\t\t     NULL_RTX, unsignedp, methods);\n+\n+      if (real_t == 0 || imag_t == 0)\n+\treturn 0;\n+    }\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, real_t, divisor,\n+\t\t\trealr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t real_t, divisor, realr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != realr)\n+    emit_move_insn (realr, res);\n+\n+  if (class == MODE_COMPLEX_FLOAT)\n+    res = expand_binop (submode, binoptab, imag_t, divisor,\n+\t\t\timagr, unsignedp, methods);\n+  else\n+    res = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t imag_t, divisor, imagr, unsignedp);\n+\n+  if (res == 0)\n+    return 0;\n+\n+  if (res != imagr)\n+    emit_move_insn (imagr, res);\n+\n+  emit_label (lab2);\n+\n+  return 1;\n+}\n+\f\n /* Generate code to perform an operation specified by BINOPTAB\n    on operands OP0 and OP1, with result having machine-mode MODE.\n \n@@ -1219,20 +1586,20 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       start_sequence ();\n \n-      realr = gen_realpart  (submode, target);\n+      realr = gen_realpart (submode, target);\n       imagr = gen_imagpart (submode, target);\n \n       if (GET_MODE (op0) == mode)\n \t{\n-\t  real0 = gen_realpart  (submode, op0);\n+\t  real0 = gen_realpart (submode, op0);\n \t  imag0 = gen_imagpart (submode, op0);\n \t}\n       else\n \treal0 = op0;\n \n       if (GET_MODE (op1) == mode)\n \t{\n-\t  real1 = gen_realpart  (submode, op1);\n+\t  real1 = gen_realpart (submode, op1);\n \t  imag1 = gen_imagpart (submode, op1);\n \t}\n       else\n@@ -1390,111 +1757,25 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    }\n \t  else\n \t    {\n-\t      /* Divisor is of complex type:\n-\t\t X/(a+ib) */\n-\t      rtx divisor;\n-\t      rtx real_t, imag_t;\n-\t      rtx temp1, temp2;\n-\t      \n-\t      /* Don't fetch these from memory more than once.  */\n-\t      real0 = force_reg (submode, real0);\n-\t      real1 = force_reg (submode, real1);\n-\n-\t      if (imag0 != 0)\n-\t\timag0 = force_reg (submode, imag0);\n-\n-\t      imag1 = force_reg (submode, imag1);\n-\n-\t      /* Divisor: c*c + d*d */\n-\t      temp1 = expand_binop (submode, smul_optab, real1, real1,\n-\t\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-\t      temp2 = expand_binop (submode, smul_optab, imag1, imag1,\n-\t\t\t\t    NULL_RTX, unsignedp, methods);\n-\n-\t      if (temp1 == 0 || temp2 == 0)\n-\t\tbreak;\n-\n-\t      divisor = expand_binop (submode, add_optab, temp1, temp2,\n-\t\t\t\t      NULL_RTX, unsignedp, methods);\n-\t      if (divisor == 0)\n-\t\tbreak;\n-\n-\t      if (imag0 == 0)\n+\t      switch (flag_complex_divide_method)\n \t\t{\n-\t\t  /* ((a)(c-id))/divisor */\n-\t\t  /* (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)) */\n-\n-\t\t  /* Calculate the dividend */\n-\t\t  real_t = expand_binop (submode, smul_optab, real0, real1,\n-\t\t\t\t\t NULL_RTX, unsignedp, methods);\n-\t\t  \n-\t\t  imag_t = expand_binop (submode, smul_optab, real0, imag1,\n-\t\t\t\t\t NULL_RTX, unsignedp, methods);\n-\n-\t\t  if (real_t == 0 || imag_t == 0)\n-\t\t    break;\n-\n-\t\t  imag_t = expand_unop (submode, neg_optab, imag_t,\n-\t\t\t\t\tNULL_RTX, unsignedp);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* ((a+ib)(c-id))/divider */\n-\t\t  /* Calculate the dividend */\n-\t\t  temp1 = expand_binop (submode, smul_optab, real0, real1,\n-\t\t\t\t\tNULL_RTX, unsignedp, methods);\n-\n-\t\t  temp2 = expand_binop (submode, smul_optab, imag0, imag1,\n-\t\t\t\t\tNULL_RTX, unsignedp, methods);\n-\n-\t\t  if (temp1 == 0 || temp2 == 0)\n-\t\t    break;\n-\n-\t\t  real_t = expand_binop (submode, add_optab, temp1, temp2,\n-\t\t\t\t\t NULL_RTX, unsignedp, methods);\n-\t\t  \n-\t\t  temp1 = expand_binop (submode, smul_optab, imag0, real1,\n-\t\t\t\t\tNULL_RTX, unsignedp, methods);\n-\n-\t\t  temp2 = expand_binop (submode, smul_optab, real0, imag1,\n-\t\t\t\t\tNULL_RTX, unsignedp, methods);\n-\n-\t\t  if (temp1 == 0 || temp2 == 0)\n-\t\t    break;\n+\t\tcase 0:\n+\t\t  ok = expand_cmplxdiv_straight (real0, real1, imag0, imag1,\n+\t\t\t\t\t\t realr, imagr, submode,\n+\t\t\t\t\t\t unsignedp, methods,\n+\t\t\t\t\t\t class, binoptab);\n+\t\t  break;\n \n-\t\t  imag_t = expand_binop (submode, sub_optab, temp1, temp2,\n-\t\t\t\t\t NULL_RTX, unsignedp, methods);\n+\t\tcase 1:\n+\t\t  ok = expand_cmplxdiv_wide (real0, real1, imag0, imag1,\n+\t\t\t\t\t     realr, imagr, submode,\n+\t\t\t\t\t     unsignedp, methods,\n+\t\t\t\t\t     class, binoptab);\n+\t\t  break;\n \n-\t\t  if (real_t == 0 || imag_t == 0)\n-\t\t    break;\n+\t\tdefault:\n+\t\t  abort ();\n \t\t}\n-\n-\t      if (class == MODE_COMPLEX_FLOAT)\n-\t\tres = expand_binop (submode, binoptab, real_t, divisor,\n-\t\t\t\t    realr, unsignedp, methods);\n-\t      else\n-\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t\t     real_t, divisor, realr, unsignedp);\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != realr)\n-\t\temit_move_insn (realr, res);\n-\n-\t      if (class == MODE_COMPLEX_FLOAT)\n-\t\tres = expand_binop (submode, binoptab, imag_t, divisor,\n-\t\t\t\t    imagr, unsignedp, methods);\n-\t      else\n-\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n-\t\t\t\t     imag_t, divisor, imagr, unsignedp);\n-\n-\t      if (res == 0)\n-\t\tbreak;\n-\t      else if (res != imagr)\n-\t\temit_move_insn (imagr, res);\n-\n-\t      ok = 1;\n \t    }\n \t  break;\n \t  "}, {"sha": "194535116b3db8fce23f313cf80de1fb0ed8189a", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c64f913e0035db3d4a4137405b768d2f50c30eea/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c64f913e0035db3d4a4137405b768d2f50c30eea", "patch": "@@ -563,6 +563,12 @@ int flag_fast_math = 0;\n \n int flag_errno_math = 1;\n \n+/* 0 means straightforward implementation of complex divide acceptable.\n+   1 means wide ranges of inputs must work for complex divide.\n+   2 means C9X-like requirements for complex divide (not yet implemented).  */\n+\n+int flag_complex_divide_method = 0;\n+\n /* Nonzero means all references through pointers are volatile.  */\n \n int flag_volatile;"}]}