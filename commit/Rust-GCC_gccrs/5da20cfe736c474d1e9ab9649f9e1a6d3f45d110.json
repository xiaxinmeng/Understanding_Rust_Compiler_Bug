{"sha": "5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhMjBjZmU3MzZjNDc0ZDFlOWFiOTY0OWY5ZTFhNmQzZjQ1ZDExMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-05-24T19:19:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-05-24T19:19:31Z"}, "message": "postreload-gcse.c (reg_changed_after_insn_p): New function.\n\ngcc/\n\t* postreload-gcse.c (reg_changed_after_insn_p): New function.\n\t(oprs_unchanged_p): Use it to check all registers in a REG.\n\t(record_opr_changes): Look for clobbers in CALL_INSN_FUNCTION_USAGE.\n\t(reg_set_between_after_reload_p): Delete.\n\t(reg_used_between_after_reload_p): Likewise.\n\t(reg_set_or_used_since_bb_start): Likewise.\n\t(eliminate_partially_redundant_load): Use reg_changed_after_insn_p\n\tand reg_used_between_p instead of reg_set_or_used_since_bb_start.\n\tUse reg_set_between_p instead of reg_set_between_after_reload_p.\n\t* rtlanal.c (reg_set_p): Check whether REG overlaps\n\tregs_invalidated_by_call, rather than just checking the\n\tmembership of REGNO (REG).\n\nFrom-SVN: r125037", "tree": {"sha": "b788b8a85477f4b090108c214fbb28c864313574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b788b8a85477f4b090108c214fbb28c864313574"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/comments", "author": null, "committer": null, "parents": [{"sha": "dc675301cb6df8402a1dc2b7dc1cc42952128150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc675301cb6df8402a1dc2b7dc1cc42952128150", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc675301cb6df8402a1dc2b7dc1cc42952128150"}], "stats": {"total": 160, "additions": 55, "deletions": 105}, "files": [{"sha": "d2fa44daf6a9c6f2e09394940db3bc17d3db8d8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "patch": "@@ -1,3 +1,18 @@\n+2007-05-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* postreload-gcse.c (reg_changed_after_insn_p): New function.\n+\t(oprs_unchanged_p): Use it to check all registers in a REG.\n+\t(record_opr_changes): Look for clobbers in CALL_INSN_FUNCTION_USAGE.\n+\t(reg_set_between_after_reload_p): Delete.\n+\t(reg_used_between_after_reload_p): Likewise.\n+\t(reg_set_or_used_since_bb_start): Likewise.\n+\t(eliminate_partially_redundant_load): Use reg_changed_after_insn_p\n+\tand reg_used_between_p instead of reg_set_or_used_since_bb_start.\n+\tUse reg_set_between_p instead of reg_set_between_after_reload_p.\n+\t* rtlanal.c (reg_set_p): Check whether REG overlaps\n+\tregs_invalidated_by_call, rather than just checking the\n+\tmembership of REGNO (REG).\n+\n 2007-05-24  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* doc/passes.texi: Document predictive commoning."}, {"sha": "3e3f805f1748846f5fcd9ce4c7ac487e983bbcb4", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 38, "deletions": 103, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "patch": "@@ -197,8 +197,6 @@ static void dump_hash_table (FILE *);\n static bool reg_killed_on_edge (rtx, edge);\n static bool reg_used_on_edge (rtx, edge);\n \n-static rtx reg_set_between_after_reload_p (rtx, rtx, rtx);\n-static rtx reg_used_between_after_reload_p (rtx, rtx, rtx);\n static rtx get_avail_load_store_reg (rtx);\n \n static bool bb_has_well_behaved_predecessors (basic_block);\n@@ -470,6 +468,22 @@ dump_hash_table (FILE *file)\n   fprintf (file, \"\\n\");\n }\n \f\n+/* Return true if register X is recorded as being set by an instruction\n+   whose CUID is greater than the one given.  */\n+\n+static bool\n+reg_changed_after_insn_p (rtx x, int cuid)\n+{\n+  unsigned int regno, end_regno;\n+\n+  regno = REGNO (x);\n+  end_regno = END_HARD_REGNO (x);\n+  do\n+    if (reg_avail_info[regno] > cuid)\n+      return true;\n+  while (++regno < end_regno);\n+  return false;\n+}\n \n /* Return nonzero if the operands of expression X are unchanged\n    1) from the start of INSN's basic block up to but not including INSN\n@@ -493,14 +507,9 @@ oprs_unchanged_p (rtx x, rtx insn, bool after_insn)\n       /* We are called after register allocation.  */\n       gcc_assert (REGNO (x) < FIRST_PSEUDO_REGISTER);\n       if (after_insn)\n-\t/* If the last CUID setting the insn is less than the CUID of\n-\t   INSN, then reg X is not changed in or after INSN.  */\n-\treturn reg_avail_info[REGNO (x)] < INSN_CUID (insn);\n+\treturn !reg_changed_after_insn_p (x, INSN_CUID (insn) - 1);\n       else\n-\t/* Reg X is not set before INSN in the current basic block if\n-\t   we have not yet recorded the CUID of an insn that touches\n-\t   the reg.  */\n-\treturn reg_avail_info[REGNO (x)] == 0;\n+\treturn !reg_changed_after_insn_p (x, 0);\n \n     case MEM:\n       if (load_killed_in_block_p (INSN_CUID (insn), x, after_insn))\n@@ -717,12 +726,28 @@ record_opr_changes (rtx insn)\n   /* Finally, if this is a call, record all call clobbers.  */\n   if (CALL_P (insn))\n     {\n-      unsigned int regno;\n+      unsigned int regno, end_regno;\n+      rtx link, x;\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n \t  record_last_reg_set_info (insn, regno);\n \n+      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+\tif (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t  {\n+\t    x = XEXP (XEXP (link, 0), 0);\n+\t    if (REG_P (x))\n+\t      {\n+\t\tgcc_assert (HARD_REGISTER_P (x));\n+\t        regno = REGNO (x);\n+\t\tend_regno = END_HARD_REGNO (x);\n+\t\tdo\n+\t\t  record_last_reg_set_info (insn, regno);\n+\t\twhile (++regno < end_regno);\n+\t      }\n+\t  }\n+\n       if (! CONST_OR_PURE_CALL_P (insn))\n \trecord_last_mem_set_info (insn);\n     }\n@@ -856,96 +881,6 @@ reg_used_on_edge (rtx reg, edge e)\n   return false;\n }\n \f\n-\n-/* Return the insn that sets register REG or clobbers it in between\n-   FROM_INSN and TO_INSN (exclusive of those two).\n-   Just like reg_set_between but for hard registers and not pseudos.  */\n-\n-static rtx\n-reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n-{\n-  rtx insn;\n-\n-  /* We are called after register allocation.  */\n-  gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n-\n-  if (from_insn == to_insn)\n-    return NULL_RTX;\n-\n-  for (insn = NEXT_INSN (from_insn);\n-       insn != to_insn;\n-       insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tif (set_of (reg, insn) != NULL_RTX)\n-\t  return insn;\n-\tif ((CALL_P (insn)\n-\t      && call_used_regs[REGNO (reg)])\n-\t    || find_reg_fusage (insn, CLOBBER, reg))\n-\t  return insn;\n-\n-\tif (FIND_REG_INC_NOTE (insn, reg))\n-\t  return insn;\n-      }\n-\n-  return NULL_RTX;\n-}\n-\n-/* Return the insn that uses register REG in between FROM_INSN and TO_INSN\n-   (exclusive of those two). Similar to reg_used_between but for hard\n-   registers and not pseudos.  */\n-\n-static rtx\n-reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n-{\n-  rtx insn;\n-\n-  /* We are called after register allocation.  */\n-  gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n-\n-  if (from_insn == to_insn)\n-    return NULL_RTX;\n-\n-  for (insn = NEXT_INSN (from_insn);\n-       insn != to_insn;\n-       insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tif (reg_overlap_mentioned_p (reg, PATTERN (insn))\n-\t    || (CALL_P (insn)\n-\t\t&& call_used_regs[REGNO (reg)])\n-\t    || find_reg_fusage (insn, USE, reg)\n-\t    || find_reg_fusage (insn, CLOBBER, reg))\n-\t  return insn;\n-\n-\tif (FIND_REG_INC_NOTE (insn, reg))\n-\t  return insn;\n-      }\n-\n-  return NULL_RTX;\n-}\n-\n-/* Return true if REG is used, set, or killed between the beginning of\n-   basic block BB and UP_TO_INSN.  Caches the result in reg_avail_info.  */\n-\n-static bool\n-reg_set_or_used_since_bb_start (rtx reg, basic_block bb, rtx up_to_insn)\n-{\n-  rtx insn, start = PREV_INSN (BB_HEAD (bb));\n-\n-  if (reg_avail_info[REGNO (reg)] != 0)\n-    return true;\n-\n-  insn = reg_used_between_after_reload_p (reg, start, up_to_insn);\n-  if (! insn)\n-    insn = reg_set_between_after_reload_p (reg, start, up_to_insn);\n-\n-  if (insn)\n-    reg_avail_info[REGNO (reg)] = INSN_CUID (insn);\n-\n-  return insn != NULL_RTX;\n-}\n-\n /* Return the loaded/stored register of a load/store instruction.  */\n \n static rtx\n@@ -1037,7 +972,8 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n \n   /* Check that the loaded register is not used, set, or killed from the\n      beginning of the block.  */\n-  if (reg_set_or_used_since_bb_start (dest, bb, insn))\n+  if (reg_changed_after_insn_p (dest, 0)\n+      || reg_used_between_p (dest, PREV_INSN (BB_HEAD (bb)), insn))\n     return;\n \n   /* Check potential for replacing load with copy for predecessors.  */\n@@ -1068,8 +1004,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n \t      avail_insn = NULL;\n \t      continue;\n \t    }\n-\t  if (! reg_set_between_after_reload_p (avail_reg, avail_insn,\n-\t\t\t\t\t\tnext_pred_bb_end))\n+\t  if (!reg_set_between_p (avail_reg, avail_insn, next_pred_bb_end))\n \t    /* AVAIL_INSN remains non-null.  */\n \t    break;\n \t  else"}, {"sha": "b890b72caec06bcd2ac045e3a72d5da3ad015314", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da20cfe736c474d1e9ab9649f9e1a6d3f45d110/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5da20cfe736c474d1e9ab9649f9e1a6d3f45d110", "patch": "@@ -825,8 +825,8 @@ reg_set_p (rtx reg, rtx insn)\n \t  || (CALL_P (insn)\n \t      && ((REG_P (reg)\n \t\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && TEST_HARD_REG_BIT (regs_invalidated_by_call,\n-\t\t\t\t\t REGNO (reg)))\n+\t\t   && overlaps_hard_reg_set_p (regs_invalidated_by_call,\n+\t\t\t\t\t       GET_MODE (reg), REGNO (reg)))\n \t\t  || MEM_P (reg)\n \t\t  || find_reg_fusage (insn, CLOBBER, reg)))))\n     return 1;"}]}