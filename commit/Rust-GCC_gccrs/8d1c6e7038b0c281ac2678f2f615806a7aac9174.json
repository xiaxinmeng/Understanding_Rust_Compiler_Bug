{"sha": "8d1c6e7038b0c281ac2678f2f615806a7aac9174", "node_id": "C_kwDOANBUbNoAKDhkMWM2ZTcwMzhiMGMyODFhYzI2NzhmMmY2MTU4MDZhN2FhYzkxNzQ", "commit": {"author": {"name": "Haochen Gui", "email": "guihaoc@gcc.gnu.org", "date": "2022-05-30T01:12:34Z"}, "committer": {"name": "Haochen Gui", "email": "guihaoc@gcc.gnu.org", "date": "2022-06-16T08:58:36Z"}, "message": "rs6000: add V1TI into vector comparison expand [PR103316]\n\nThis patch adds V1TI mode into a new mode iterator used in vector comparison,shift and rotation expands.  It also merges some vector comparison, shift and rotation expands for V1T1 and other vector integer modes as they have the similar patterns.  The expands for V1TI only are removed.\n\ngcc/\n\tPR target/103316\n\t* config/rs6000/rs6000-builtin.cc (rs6000_gimple_fold_builtin): Enable\n\tgimple folding for RS6000_BIF_VCMPEQUT, RS6000_BIF_VCMPNET,\n\tRS6000_BIF_CMPGE_1TI, RS6000_BIF_CMPGE_U1TI, RS6000_BIF_VCMPGTUT,\n\tRS6000_BIF_VCMPGTST, RS6000_BIF_CMPLE_1TI, RS6000_BIF_CMPLE_U1TI.\n\t* config/rs6000/vector.md (VEC_IC): New mode iterator.  Add support\n\tfor new Power10 V1TI instructions.\n\t(vec_cmp<mode><mode>): Set mode iterator to VEC_IC.\n\t(vec_cmpu<mode><mode>): Likewise.\n\t(vector_nlt<mode>): Set mode iterator to VEC_IC.\n\t(vector_nltv1ti): Remove.\n\t(vector_gtu<mode>): Set mode iterator to VEC_IC.\n\t(vector_gtuv1ti): Remove.\n\t(vector_nltu<mode>): Set mode iterator to VEC_IC.\n\t(vector_nltuv1ti): Remove.\n\t(vector_geu<mode>): Set mode iterator to VEC_IC.\n\t(vector_ngt<mode>): Likewise.\n\t(vector_ngtv1ti): Remove.\n\t(vector_ngtu<mode>): Set mode iterator to VEC_IC.\n\t(vector_ngtuv1ti): Remove.\n\t(vector_gtu_<mode>_p): Set mode iterator to VEC_IC.\n\t(vector_gtu_v1ti_p): Remove.\n\t(vrotl<mode>3): Set mode iterator to VEC_IC.  Emit insns for V1TI.\n\t(vrotlv1ti3): Remove.\n\t(vashr<mode>3): Set mode iterator to VEC_IC.  Emit insns for V1TI.\n\t(vashrv1ti3): Remove.\n\ngcc/testsuite/\n\tPR target/103316\n\t* gcc.target/powerpc/pr103316.c: New.\n\t* gcc.target/powerpc/fold-vec-cmp-int128.c: New.", "tree": {"sha": "c60e0ecd95ca4fdbaf7289b7f9c68cda5177ae14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c60e0ecd95ca4fdbaf7289b7f9c68cda5177ae14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d1c6e7038b0c281ac2678f2f615806a7aac9174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1c6e7038b0c281ac2678f2f615806a7aac9174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1c6e7038b0c281ac2678f2f615806a7aac9174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1c6e7038b0c281ac2678f2f615806a7aac9174/comments", "author": null, "committer": null, "parents": [{"sha": "42858325e41177ba622a507c398dae2adbc017d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42858325e41177ba622a507c398dae2adbc017d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42858325e41177ba622a507c398dae2adbc017d6"}], "stats": {"total": 384, "additions": 239, "deletions": 145}, "files": [{"sha": "2819773d9f9ed2161f60a023378a8f33b2ad5555", "filename": "gcc/config/rs6000/rs6000-builtin.cc", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc?ref=8d1c6e7038b0c281ac2678f2f615806a7aac9174", "patch": "@@ -2000,16 +2000,14 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case RS6000_BIF_VCMPEQUH:\n     case RS6000_BIF_VCMPEQUW:\n     case RS6000_BIF_VCMPEQUD:\n-    /* We deliberately omit RS6000_BIF_VCMPEQUT for now, because gimple\n-       folding produces worse code for 128-bit compares.  */\n+    case RS6000_BIF_VCMPEQUT:\n       fold_compare_helper (gsi, EQ_EXPR, stmt);\n       return true;\n \n     case RS6000_BIF_VCMPNEB:\n     case RS6000_BIF_VCMPNEH:\n     case RS6000_BIF_VCMPNEW:\n-    /* We deliberately omit RS6000_BIF_VCMPNET for now, because gimple\n-       folding produces worse code for 128-bit compares.  */\n+    case RS6000_BIF_VCMPNET:\n       fold_compare_helper (gsi, NE_EXPR, stmt);\n       return true;\n \n@@ -2021,9 +2019,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case RS6000_BIF_CMPGE_U4SI:\n     case RS6000_BIF_CMPGE_2DI:\n     case RS6000_BIF_CMPGE_U2DI:\n-    /* We deliberately omit RS6000_BIF_CMPGE_1TI and RS6000_BIF_CMPGE_U1TI\n-       for now, because gimple folding produces worse code for 128-bit\n-       compares.  */\n+    case RS6000_BIF_CMPGE_1TI:\n+    case RS6000_BIF_CMPGE_U1TI:\n       fold_compare_helper (gsi, GE_EXPR, stmt);\n       return true;\n \n@@ -2035,9 +2032,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case RS6000_BIF_VCMPGTUW:\n     case RS6000_BIF_VCMPGTUD:\n     case RS6000_BIF_VCMPGTSD:\n-    /* We deliberately omit RS6000_BIF_VCMPGTUT and RS6000_BIF_VCMPGTST\n-       for now, because gimple folding produces worse code for 128-bit\n-       compares.  */\n+    case RS6000_BIF_VCMPGTUT:\n+    case RS6000_BIF_VCMPGTST:\n       fold_compare_helper (gsi, GT_EXPR, stmt);\n       return true;\n \n@@ -2049,9 +2045,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case RS6000_BIF_CMPLE_U4SI:\n     case RS6000_BIF_CMPLE_2DI:\n     case RS6000_BIF_CMPLE_U2DI:\n-    /* We deliberately omit RS6000_BIF_CMPLE_1TI and RS6000_BIF_CMPLE_U1TI\n-       for now, because gimple folding produces worse code for 128-bit\n-       compares.  */\n+    case RS6000_BIF_CMPLE_1TI:\n+    case RS6000_BIF_CMPLE_U1TI:\n       fold_compare_helper (gsi, LE_EXPR, stmt);\n       return true;\n "}, {"sha": "a0d33d2f604432632cf029b286aea0235c9f4a25", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 63, "deletions": 132, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=8d1c6e7038b0c281ac2678f2f615806a7aac9174", "patch": "@@ -26,6 +26,9 @@\n ;; Vector int modes\n (define_mode_iterator VEC_I [V16QI V8HI V4SI V2DI])\n \n+;; Vector int modes for comparison, shift and rotation\n+(define_mode_iterator VEC_IC [V16QI V8HI V4SI V2DI (V1TI \"TARGET_POWER10\")])\n+\n ;; 128-bit int modes\n (define_mode_iterator VEC_TI [V1TI TI])\n \n@@ -533,10 +536,10 @@\n \n ;; For signed integer vectors comparison.\n (define_expand \"vec_cmp<mode><mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n \t(match_operator 1 \"signed_or_equality_comparison_operator\"\n-\t  [(match_operand:VEC_I 2 \"vint_operand\")\n-\t   (match_operand:VEC_I 3 \"vint_operand\")]))]\n+\t  [(match_operand:VEC_IC 2 \"vint_operand\")\n+\t   (match_operand:VEC_IC 3 \"vint_operand\")]))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n@@ -573,10 +576,10 @@\n \n ;; For unsigned integer vectors comparison.\n (define_expand \"vec_cmpu<mode><mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n \t(match_operator 1 \"unsigned_or_equality_comparison_operator\"\n-\t  [(match_operand:VEC_I 2 \"vint_operand\")\n-\t   (match_operand:VEC_I 3 \"vint_operand\")]))]\n+\t  [(match_operand:VEC_IC 2 \"vint_operand\")\n+\t   (match_operand:VEC_IC 3 \"vint_operand\")]))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n@@ -690,116 +693,65 @@\n \n ; >= for integer vectors: swap operands and apply not-greater-than\n (define_expand \"vector_nlt<mode>\"\n-  [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n-\t(gt:VEC_I (match_operand:VEC_I 2 \"vlogical_operand\")\n-\t\t  (match_operand:VEC_I 1 \"vlogical_operand\")))\n-   (set (match_operand:VEC_I 0 \"vlogical_operand\")\n-        (not:VEC_I (match_dup 3)))]\n+  [(set (match_operand:VEC_IC 3 \"vlogical_operand\")\n+\t(gt:VEC_IC (match_operand:VEC_IC 2 \"vlogical_operand\")\n+\t\t   (match_operand:VEC_IC 1 \"vlogical_operand\")))\n+   (set (match_operand:VEC_IC 0 \"vlogical_operand\")\n+\t(not:VEC_IC (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_expand \"vector_nltv1ti\"\n-  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n-\t(gt:V1TI (match_operand:V1TI 2 \"vlogical_operand\")\n-\t\t (match_operand:V1TI 1 \"vlogical_operand\")))\n-   (set (match_operand:V1TI 0 \"vlogical_operand\")\n-        (not:V1TI (match_dup 3)))]\n-  \"TARGET_POWER10\"\n-{\n-  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-})\n-\n (define_expand \"vector_gtu<mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n-\t(gtu:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n-\t\t   (match_operand:VEC_I 2 \"vint_operand\")))]\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n+\t(gtu:VEC_IC (match_operand:VEC_IC 1 \"vint_operand\")\n+\t\t    (match_operand:VEC_IC 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n-(define_expand \"vector_gtuv1ti\"\n-  [(set (match_operand:V1TI 0 \"altivec_register_operand\")\n-\t(gtu:V1TI (match_operand:V1TI 1 \"altivec_register_operand\")\n-\t\t  (match_operand:V1TI 2 \"altivec_register_operand\")))]\n-  \"TARGET_POWER10\"\n-  \"\")\n-\n ; >= for integer vectors: swap operands and apply not-greater-than\n (define_expand \"vector_nltu<mode>\"\n-  [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n-\t(gtu:VEC_I (match_operand:VEC_I 2 \"vlogical_operand\")\n-\t \t   (match_operand:VEC_I 1 \"vlogical_operand\")))\n-   (set (match_operand:VEC_I 0 \"vlogical_operand\")\n-        (not:VEC_I (match_dup 3)))]\n+  [(set (match_operand:VEC_IC 3 \"vlogical_operand\")\n+\t(gtu:VEC_IC (match_operand:VEC_IC 2 \"vlogical_operand\")\n+\t\t    (match_operand:VEC_IC 1 \"vlogical_operand\")))\n+   (set (match_operand:VEC_IC 0 \"vlogical_operand\")\n+\t(not:VEC_IC (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_expand \"vector_nltuv1ti\"\n-  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n-\t(gtu:V1TI (match_operand:V1TI 2 \"vlogical_operand\")\n-\t\t  (match_operand:V1TI 1 \"vlogical_operand\")))\n-   (set (match_operand:V1TI 0 \"vlogical_operand\")\n-\t(not:V1TI (match_dup 3)))]\n-  \"TARGET_POWER10\"\n-{\n-  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-})\n-\n (define_expand \"vector_geu<mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n-\t(geu:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n-\t\t   (match_operand:VEC_I 2 \"vint_operand\")))]\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n+\t(geu:VEC_IC (match_operand:VEC_IC 1 \"vint_operand\")\n+\t\t    (match_operand:VEC_IC 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n ; <= for integer vectors: apply not-greater-than\n (define_expand \"vector_ngt<mode>\"\n-  [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n-\t(gt:VEC_I (match_operand:VEC_I 1 \"vlogical_operand\")\n-\t\t  (match_operand:VEC_I 2 \"vlogical_operand\")))\n-   (set (match_operand:VEC_I 0 \"vlogical_operand\")\n-        (not:VEC_I (match_dup 3)))]\n+  [(set (match_operand:VEC_IC 3 \"vlogical_operand\")\n+\t(gt:VEC_IC (match_operand:VEC_IC 1 \"vlogical_operand\")\n+\t\t   (match_operand:VEC_IC 2 \"vlogical_operand\")))\n+   (set (match_operand:VEC_IC 0 \"vlogical_operand\")\n+\t(not:VEC_IC (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_expand \"vector_ngtv1ti\"\n-  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n-\t(gt:V1TI (match_operand:V1TI 1 \"vlogical_operand\")\n-\t\t (match_operand:V1TI 2 \"vlogical_operand\")))\n-   (set (match_operand:V1TI 0 \"vlogical_operand\")\n-        (not:V1TI (match_dup 3)))]\n-  \"TARGET_POWER10\"\n-{\n-  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-})\n-\n (define_expand \"vector_ngtu<mode>\"\n-  [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n-\t(gtu:VEC_I (match_operand:VEC_I 1 \"vlogical_operand\")\n-\t \t   (match_operand:VEC_I 2 \"vlogical_operand\")))\n-   (set (match_operand:VEC_I 0 \"vlogical_operand\")\n-        (not:VEC_I (match_dup 3)))]\n+  [(set (match_operand:VEC_IC 3 \"vlogical_operand\")\n+\t(gtu:VEC_IC (match_operand:VEC_IC 1 \"vlogical_operand\")\n+\t\t    (match_operand:VEC_IC 2 \"vlogical_operand\")))\n+   (set (match_operand:VEC_IC 0 \"vlogical_operand\")\n+\t(not:VEC_IC (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_expand \"vector_ngtuv1ti\"\n-  [(set (match_operand:V1TI 3 \"vlogical_operand\")\n-\t(gtu:V1TI (match_operand:V1TI 1 \"vlogical_operand\")\n-\t\t  (match_operand:V1TI 2 \"vlogical_operand\")))\n-   (set (match_operand:V1TI 0 \"vlogical_operand\")\n-        (not:V1TI (match_dup 3)))]\n-  \"TARGET_POWER10\"\n-{\n-  operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-})\n-\n ; There are 14 possible vector FP comparison operators, gt and eq of them have\n ; been expanded above, so just support 12 remaining operators here.\n \n@@ -1189,27 +1141,15 @@\n (define_expand \"vector_gtu_<mode>_p\"\n   [(parallel\n     [(set (reg:CC CR6_REGNO)\n-\t  (unspec:CC [(gtu:CC (match_operand:VEC_I 1 \"vint_operand\")\n-\t\t\t      (match_operand:VEC_I 2 \"vint_operand\"))]\n+\t  (unspec:CC [(gtu:CC (match_operand:VEC_IC 1 \"vint_operand\")\n+\t\t\t      (match_operand:VEC_IC 2 \"vint_operand\"))]\n \t\t     UNSPEC_PREDICATE))\n-     (set (match_operand:VEC_I 0 \"vlogical_operand\")\n-\t  (gtu:VEC_I (match_dup 1)\n-\t\t     (match_dup 2)))])]\n+     (set (match_operand:VEC_IC 0 \"vlogical_operand\")\n+\t  (gtu:VEC_IC (match_dup 1)\n+\t\t      (match_dup 2)))])]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n-(define_expand \"vector_gtu_v1ti_p\"\n-  [(parallel\n-    [(set (reg:CC CR6_REGNO)\n-\t  (unspec:CC [(gtu:CC (match_operand:V1TI 1 \"altivec_register_operand\")\n-\t\t\t      (match_operand:V1TI 2 \"altivec_register_operand\"))]\n-\t\t     UNSPEC_PREDICATE))\n-     (set (match_operand:V1TI 0 \"altivec_register_operand\")\n-\t  (gtu:V1TI (match_dup 1)\n-\t\t    (match_dup 2)))])]\n-  \"TARGET_POWER10\"\n-  \"\")\n-\n ;; AltiVec/VSX predicates.\n \n ;; This expansion is triggered during expansion of predicate built-in\n@@ -1582,25 +1522,21 @@\n \n ;; Expanders for rotate each element in a vector\n (define_expand \"vrotl<mode>3\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n-\t(rotate:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n-\t\t      (match_operand:VEC_I 2 \"vint_operand\")))]\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n+\t(rotate:VEC_IC (match_operand:VEC_IC 1 \"vint_operand\")\n+\t\t       (match_operand:VEC_IC 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\")\n-\n-(define_expand \"vrotlv1ti3\"\n-  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n-        (rotate:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n-                     (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n-  \"TARGET_POWER10\"\n {\n-  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2. */\n-  rtx tmp = gen_reg_rtx (V1TImode);\n+  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2.  */\n+  if (<MODE>mode == V1TImode)\n+    {\n+      rtx tmp = gen_reg_rtx (V1TImode);\n \n-  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n-  emit_insn (gen_altivec_vrlq (operands[0], operands[1], tmp));\n-  DONE;\n-})\n+      emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+      emit_insn (gen_altivec_vrlq (operands[0], operands[1], tmp));\n+      DONE;\n+    }\n+ })\n \n ;; Expanders for rotatert to make use of vrotl\n (define_expand \"vrotr<mode>3\"\n@@ -1663,25 +1599,20 @@\n \n ;; Expanders for arithmetic shift right on each vector element\n (define_expand \"vashr<mode>3\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\")\n-\t(ashiftrt:VEC_I (match_operand:VEC_I 1 \"vint_operand\")\n-\t\t\t(match_operand:VEC_I 2 \"vint_operand\")))]\n+  [(set (match_operand:VEC_IC 0 \"vint_operand\")\n+\t(ashiftrt:VEC_IC (match_operand:VEC_IC 1 \"vint_operand\")\n+\t\t\t (match_operand:VEC_IC 2 \"vint_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\")\n-\n-;; No immediate version of this 128-bit instruction\n-(define_expand \"vashrv1ti3\"\n-  [(set (match_operand:V1TI 0 \"vsx_register_operand\" \"=v\")\n-\t(ashiftrt:V1TI (match_operand:V1TI 1 \"vsx_register_operand\" \"v\")\n-\t\t       (match_operand:V1TI 2 \"vsx_register_operand\" \"v\")))]\n-  \"TARGET_POWER10\"\n {\n-  /* Shift amount in needs to be put into bits[57:63] of 128-bit operand2. */\n-  rtx tmp = gen_reg_rtx (V1TImode);\n+  /* Shift amount in needs to be put in bits[57:63] of 128-bit operand2.  */\n+  if (<MODE>mode == V1TImode)\n+    {\n+      rtx tmp = gen_reg_rtx (V1TImode);\n \n-  emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n-  emit_insn (gen_altivec_vsraq (operands[0], operands[1], tmp));\n-  DONE;\n+      emit_insn (gen_xxswapd_v1ti (tmp, operands[2]));\n+      emit_insn (gen_altivec_vsraq (operands[0], operands[1], tmp));\n+      DONE;\n+    }\n })\n \n \f"}, {"sha": "fe667b9cb50f38c41ae8fced62852ac55ba388f1", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-cmp-int128.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-cmp-int128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-cmp-int128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-cmp-int128.c?ref=8d1c6e7038b0c281ac2678f2f615806a7aac9174", "patch": "@@ -0,0 +1,87 @@\n+/* Verify that overloaded built-ins for vec_cmp with __int128\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector bool __int128\n+test_eq (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmpeq (x, y);\n+}\n+\n+vector bool __int128\n+testu_eq (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmpeq (x, y);\n+}\n+\n+vector bool __int128\n+test_ge (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmpge (x, y);\n+}\n+\n+vector bool __int128\n+testu_ge (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmpge (x, y);\n+}\n+\n+vector bool __int128\n+test_gt (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmpgt (x, y);\n+}\n+\n+vector bool __int128\n+testu_gt (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmpgt (x, y);\n+}\n+\n+vector bool __int128\n+test_le (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmple (x, y);\n+}\n+\n+vector bool __int128\n+testu_le (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmple (x, y);\n+}\n+\n+vector bool __int128\n+test_lt (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmplt (x, y);\n+}\n+\n+vector bool __int128\n+testu_lt (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmplt (x, y);\n+}\n+\n+vector bool __int128\n+test_ne (vector signed __int128 x, vector signed __int128 y)\n+{\n+  return vec_cmpne (x, y);\n+}\n+\n+vector bool __int128\n+testu_ne (vector unsigned __int128 x, vector unsigned __int128 y)\n+{\n+  return vec_cmpne (x, y);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vcmpequq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vcmpgtsq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vcmpgtuq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xxlnor\" 6 } } */\n+"}, {"sha": "9f1ba791cc5553c0d928e32c0a5383664b79922a", "filename": "gcc/testsuite/gcc.target/powerpc/pr103316.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103316.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1c6e7038b0c281ac2678f2f615806a7aac9174/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103316.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr103316.c?ref=8d1c6e7038b0c281ac2678f2f615806a7aac9174", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+vector bool __int128\n+test_eq (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a == b;\n+}\n+\n+vector bool __int128\n+test_ne (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a != b;\n+}\n+\n+vector bool __int128\n+test_gt (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a > b;\n+}\n+\n+vector bool __int128\n+test_ge (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a >= b;\n+}\n+\n+vector bool __int128\n+test_lt (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a < b;\n+}\n+\n+vector bool __int128\n+test_le (vector signed __int128 a, vector signed __int128 b)\n+{\n+  return a <= b;\n+}\n+\n+vector bool __int128\n+testu_eq (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a == b;\n+}\n+\n+vector bool __int128\n+testu_ne (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a != b;\n+}\n+\n+vector bool __int128\n+testu_gt (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a > b;\n+}\n+\n+vector bool __int128\n+testu_ge (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a >= b;\n+}\n+\n+vector bool __int128\n+testu_lt (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a < b;\n+}\n+\n+vector bool __int128\n+testu_le (vector unsigned __int128 a, vector unsigned __int128 b)\n+{\n+  return a <= b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vcmpequq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vcmpgtsq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vcmpgtuq\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xxlnor\" 6 } } */"}]}