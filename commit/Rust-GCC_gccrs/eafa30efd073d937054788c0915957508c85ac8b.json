{"sha": "eafa30efd073d937054788c0915957508c85ac8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmYTMwZWZkMDczZDkzNzA1NDc4OGMwOTE1OTU3NTA4Yzg1YWM4Yg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2018-08-24T14:42:32Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2018-08-24T14:42:32Z"}, "message": "emit-rtl.c (init_emit_once): Do not emit MODE_POINTER_BOUNDS RTXes.\n\n\t* emit-rtl.c (init_emit_once): Do not emit MODE_POINTER_BOUNDS RTXes.\n\t* emit-rtl.h (rtl_data): Remove return_bnd.\n\t* explow.c (trunc_int_for_mode): Do not handle POINTER_BOUNDS_MODE_P.\n\t* function.c (diddle_return_value): Do not handle crtl->return_bnd.\n\t* genmodes.c (complete_mode): Do not handle MODE_POINTER_BOUNDS.\n\t(POINTER_BOUNDS_MODE): Remove definition.\n\t(make_pointer_bounds_mode): Remove.\n\t(get_mode_class): Do not handle MODE_POINTER_BOUNDS.\n\t* machmode.h (POINTER_BOUNDS_MODE_P): Remove definition.\n\t(scalare_mode::includes_p): Do not handle MODE_POINTER_BOUNDS.\n\t* mode-classes.def: Do not define MODE_POINTER_BOUNDS.\n\t* stor-layout.c (int_mode_for_mode): Do not handle MODE_POINTER_BOUNDS.\n\t* tree-core.h (enum tree_index): Remove TI_POINTER_BOUNDS_TYPE.\n\t* varasm.c (output_constant_pool_2): Do not handle MODE_POINTER_BOUNDS.\n\n\t* config/i386/i386-modes.def (BND32, BND64): Remove.\n\t* config/i386/i386.c (dbx_register_map): Remove bound registers.\n\t(dbx64_register_map): Ditto.\n\t(svr4_dbx_register_map): Ditto.\n\t(indirect_thunk_bnd_needed): Remove.\n\t(indirect_thunks_bnd_used): Ditto.\n\t(indirect_return_bnd_needed): Ditto.\n\t(indirect_return_via_cx_bnd): Ditto.\n\t(enum indirect_thunk_prefix): Remove indirect_thunk_prefix_bnd.\n\t(indirect_thunk_name): Remove handling of indirect_thunk_prefix_bnd.\n\t(output_indirect_thunk): Ditto.  Remove need_prefix argument.\n\t(output_indirect_thunk_function): Remove handling of\n\tindirect_return_bnd_needed, indirect_return_via_cx_bnd,\n\tindirect_thunk_bnd_needed and indirect_thunks_bnd_used variables.\n\t(ix86_save_reg): Remove handling of crtl->return_bnd.\n\t(ix86_legitimate_constant_p): Remove handling of POINTER_BOUNDS_MODE_P.\n\t(ix86_print_operand_address_as): Remove handling of UNSPEC_BNDMK_ADDR\n\tand UNSPEC_BNDLX_ADDR.\n\t(ix86_output_indirect_branch_via_reg): Remove handling of\n\tindirect_thunk_prefix_bnd.\n\t(ix86_output_indirect_branch_via_push): Ditto.\n\t(ix86_output_function_return): Ditto.\n\t(ix86_output_indirect_function_return): Ditto.\n\t(avoid_func_arg_motion): Do not handle UNSPEC_BNDSTX.\n\t* config/i386/i386.h (FIXED_REGISTERS): Remove bound registers.\n\t(CALL_USED_REGISTERS): Ditto.\n\t(REG_ALLOC_ORDER): Update for removal of bound registers.\n\t(HI_REGISTER_NAMES): Ditto.\n\t* config/i386/i386.md (UNSPEC_BNDMK, UNSPEC_BNDMK_ADDR, UNSPEC_BNDSTX)\n\t(UNSPEC_BNDLDX, UNSPEC_BNDLDX_ADDR, UNSPEC_BNDCL, UNSPEC_BNDCU)\n\t(UNSPEC_BNDCN, UNSPEC_MPX_FENCE): Remove.\n\t(BND0_REG, BND1_REG, BND2_REG, BND3_REG): Remove\n\t(FIRST_PSEUDO_REG): Update.\n\t(BND): Remove mode iterator.\n\t* config/i386/predicates.md (bnd_mem_operator): Remove.\n\nFrom-SVN: r263835", "tree": {"sha": "566dafad2bf402f57fed4d7c60a8ac90ce58ab3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/566dafad2bf402f57fed4d7c60a8ac90ce58ab3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eafa30efd073d937054788c0915957508c85ac8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa30efd073d937054788c0915957508c85ac8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eafa30efd073d937054788c0915957508c85ac8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa30efd073d937054788c0915957508c85ac8b/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5cd4f8ceb89596be02801cd11e8dbf78fb10014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5cd4f8ceb89596be02801cd11e8dbf78fb10014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5cd4f8ceb89596be02801cd11e8dbf78fb10014"}], "stats": {"total": 382, "additions": 102, "deletions": 280}, "files": [{"sha": "3838777a0b5e870b96a7af910c7bec763e68d391", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -1,3 +1,56 @@\n+2018-08-24  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* emit-rtl.c (init_emit_once): Do not emit MODE_POINTER_BOUNDS RTXes.\n+\t* emit-rtl.h (rtl_data): Remove return_bnd.\n+\t* explow.c (trunc_int_for_mode): Do not handle POINTER_BOUNDS_MODE_P.\n+\t* function.c (diddle_return_value): Do not handle crtl->return_bnd.\n+\t* genmodes.c (complete_mode): Do not handle MODE_POINTER_BOUNDS.\n+\t(POINTER_BOUNDS_MODE): Remove definition.\n+\t(make_pointer_bounds_mode): Remove.\n+\t(get_mode_class): Do not handle MODE_POINTER_BOUNDS.\n+\t* machmode.h (POINTER_BOUNDS_MODE_P): Remove definition.\n+\t(scalare_mode::includes_p): Do not handle MODE_POINTER_BOUNDS.\n+\t* mode-classes.def: Do not define MODE_POINTER_BOUNDS.\n+\t* stor-layout.c (int_mode_for_mode): Do not handle MODE_POINTER_BOUNDS.\n+\t* tree-core.h (enum tree_index): Remove TI_POINTER_BOUNDS_TYPE.\n+\t* varasm.c (output_constant_pool_2): Do not handle MODE_POINTER_BOUNDS.\n+\n+\t* config/i386/i386-modes.def (BND32, BND64): Remove.\n+\t* config/i386/i386.c (dbx_register_map): Remove bound registers.\n+\t(dbx64_register_map): Ditto.\n+\t(svr4_dbx_register_map): Ditto.\n+\t(indirect_thunk_bnd_needed): Remove.\n+\t(indirect_thunks_bnd_used): Ditto.\n+\t(indirect_return_bnd_needed): Ditto.\n+\t(indirect_return_via_cx_bnd): Ditto.\n+\t(enum indirect_thunk_prefix): Remove indirect_thunk_prefix_bnd.\n+\t(indirect_thunk_name): Remove handling of indirect_thunk_prefix_bnd.\n+\t(output_indirect_thunk): Ditto.  Remove need_prefix argument.\n+\t(output_indirect_thunk_function): Remove handling of\n+\tindirect_return_bnd_needed, indirect_return_via_cx_bnd,\n+\tindirect_thunk_bnd_needed and indirect_thunks_bnd_used variables.\n+\t(ix86_save_reg): Remove handling of crtl->return_bnd.\n+\t(ix86_legitimate_constant_p): Remove handling of POINTER_BOUNDS_MODE_P.\n+\t(ix86_print_operand_address_as): Remove handling of UNSPEC_BNDMK_ADDR\n+\tand UNSPEC_BNDLX_ADDR.\n+\t(ix86_output_indirect_branch_via_reg): Remove handling of\n+\tindirect_thunk_prefix_bnd.\n+\t(ix86_output_indirect_branch_via_push): Ditto.\n+\t(ix86_output_function_return): Ditto.\n+\t(ix86_output_indirect_function_return): Ditto.\n+\t(avoid_func_arg_motion): Do not handle UNSPEC_BNDSTX.\n+\t* config/i386/i386.h (FIXED_REGISTERS): Remove bound registers.\n+\t(CALL_USED_REGISTERS): Ditto.\n+\t(REG_ALLOC_ORDER): Update for removal of bound registers.\n+\t(HI_REGISTER_NAMES): Ditto.\n+\t* config/i386/i386.md (UNSPEC_BNDMK, UNSPEC_BNDMK_ADDR, UNSPEC_BNDSTX)\n+\t(UNSPEC_BNDLDX, UNSPEC_BNDLDX_ADDR, UNSPEC_BNDCL, UNSPEC_BNDCU)\n+\t(UNSPEC_BNDCN, UNSPEC_MPX_FENCE): Remove.\n+\t(BND0_REG, BND1_REG, BND2_REG, BND3_REG): Remove\n+\t(FIRST_PSEUDO_REG): Update.\n+\t(BND): Remove mode iterator.\n+\t* config/i386/predicates.md (bnd_mem_operator): Remove.\n+\n 2018-08-24  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vectorizable_bswap): Handle variable-length"}, {"sha": "12c17ce7dfc2b010b958ee637b2577af84c5cb15", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -98,9 +98,6 @@ VECTOR_MODE (INT, QI, 14);    /*                  V14QI */\n VECTOR_MODE (INT, HI, 6);     /*                   V6HI */\n VECTOR_MODE (INT, SI, 64);    /* \t\t  V64SI */\n \n-POINTER_BOUNDS_MODE (BND32, 8);\n-POINTER_BOUNDS_MODE (BND64, 16);\n-\n INT_MODE (OI, 32);\n INT_MODE (XI, 64);\n "}, {"sha": "98677386a2b96fc13c108f9bba5097a5a17569a3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 43, "deletions": 207, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -262,7 +262,7 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n   /* Mask registers.  */\n   MASK_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n-  MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n+  MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -278,8 +278,7 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n-  93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n-  101, 102, 103, 104,\t\t\t/* bound registers */\n+  93, 94, 95, 96, 97, 98, 99, 100       /* Mask registers */\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -295,8 +294,7 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   25, 26, 27, 28, 29, 30, 31, 32,\t/* extended SSE registers */\n   67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n   75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n-  118, 119, 120, 121, 122, 123, 124, 125, /* Mask registers */\n-  126, 127, 128, 129,\t\t\t/* bound registers */\n+  118, 119, 120, 121, 122, 123, 124, 125 /* Mask registers */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -364,8 +362,7 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n-  93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n-  101, 102, 103, 104,\t\t\t/* bound registers */\n+  93, 94, 95, 96, 97, 98, 99, 100       /* Mask registers */\n };\n \n /* Define parameter passing and return registers.  */\n@@ -10646,26 +10643,16 @@ static int indirectlabelno;\n \n /* True if call thunk function is needed.  */\n static bool indirect_thunk_needed = false;\n-/* True if call thunk function with the BND prefix is needed.  */\n-static bool indirect_thunk_bnd_needed = false;\n \n /* Bit masks of integer registers, which contain branch target, used\n    by call thunk functions.  */\n static int indirect_thunks_used;\n-/* Bit masks of integer registers, which contain branch target, used\n-   by call thunk functions with the BND prefix.  */\n-static int indirect_thunks_bnd_used;\n \n /* True if return thunk function is needed.  */\n static bool indirect_return_needed = false;\n-/* True if return thunk function with the BND prefix is needed.  */\n-static bool indirect_return_bnd_needed = false;\n \n /* True if return thunk function via CX is needed.  */\n static bool indirect_return_via_cx;\n-/* True if return thunk function via CX with the BND prefix is\n-   needed.  */\n-static bool indirect_return_via_cx_bnd;\n \n #ifndef INDIRECT_LABEL\n # define INDIRECT_LABEL \"LIND\"\n@@ -10675,7 +10662,6 @@ static bool indirect_return_via_cx_bnd;\n enum indirect_thunk_prefix\n {\n   indirect_thunk_prefix_none,\n-  indirect_thunk_prefix_bnd,\n   indirect_thunk_prefix_nt\n };\n \n@@ -10712,10 +10698,8 @@ indirect_thunk_name (char name[32], unsigned int regno,\n     {\n       const char *prefix;\n \n-      if (need_prefix == indirect_thunk_prefix_bnd)\n-\tprefix = \"_bnd\";\n-      else if (need_prefix == indirect_thunk_prefix_nt\n-\t       && regno != INVALID_REGNUM)\n+      if (need_prefix == indirect_thunk_prefix_nt\n+\t  && regno != INVALID_REGNUM)\n \t{\n \t  /* NOTRACK prefix is only used with external thunk via\n \t     register so that NOTRACK prefix can be added to indirect\n@@ -10743,35 +10727,19 @@ indirect_thunk_name (char name[32], unsigned int regno,\n   else\n     {\n       if (regno != INVALID_REGNUM)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    ASM_GENERATE_INTERNAL_LABEL (name, \"LITBR\", regno);\n-\t  else\n-\t    ASM_GENERATE_INTERNAL_LABEL (name, \"LITR\", regno);\n-\t}\n+\tASM_GENERATE_INTERNAL_LABEL (name, \"LITR\", regno);\n       else\n \t{\n \t  if (ret_p)\n-\t    {\n-\t      if (need_prefix == indirect_thunk_prefix_bnd)\n-\t\tASM_GENERATE_INTERNAL_LABEL (name, \"LRTB\", 0);\n-\t      else\n-\t\tASM_GENERATE_INTERNAL_LABEL (name, \"LRT\", 0);\n-\t    }\n+\t    ASM_GENERATE_INTERNAL_LABEL (name, \"LRT\", 0);\n \t  else\n-\t    {\n-\t      if (need_prefix == indirect_thunk_prefix_bnd)\n-\t\tASM_GENERATE_INTERNAL_LABEL (name, \"LITB\", 0);\n-\t      else\n-\t\tASM_GENERATE_INTERNAL_LABEL (name, \"LIT\", 0);\n-\t    }\n+\t    ASM_GENERATE_INTERNAL_LABEL (name, \"LIT\", 0);\n \t}\n     }\n }\n \n-/* Output a call and return thunk for indirect branch.  If BND_P is\n-   true, the BND prefix is needed.   If REGNO != -1,  the function\n-   address is in REGNO and the call and return thunk looks like:\n+/* Output a call and return thunk for indirect branch.  If REGNO != -1,\n+   the function address is in REGNO and the call and return thunk looks like:\n \n \tcall\tL2\n    L1:\n@@ -10796,8 +10764,7 @@ indirect_thunk_name (char name[32], unsigned int regno,\n  */\n \n static void\n-output_indirect_thunk (enum indirect_thunk_prefix need_prefix,\n-\t\t       unsigned int regno)\n+output_indirect_thunk (unsigned int regno)\n {\n   char indirectlabel1[32];\n   char indirectlabel2[32];\n@@ -10808,10 +10775,7 @@ output_indirect_thunk (enum indirect_thunk_prefix need_prefix,\n \t\t\t       indirectlabelno++);\n \n   /* Call */\n-  if (need_prefix == indirect_thunk_prefix_bnd)\n-    fputs (\"\\tbnd call\\t\", asm_out_file);\n-  else\n-    fputs (\"\\tcall\\t\", asm_out_file);\n+  fputs (\"\\tcall\\t\", asm_out_file);\n   assemble_name_raw (asm_out_file, indirectlabel2);\n   fputc ('\\n', asm_out_file);\n \n@@ -10845,17 +10809,13 @@ output_indirect_thunk (enum indirect_thunk_prefix need_prefix,\n       output_asm_insn (\"lea\\t{%E1, %0|%0, %E1}\", xops);\n     }\n \n-  if (need_prefix == indirect_thunk_prefix_bnd)\n-    fputs (\"\\tbnd ret\\n\", asm_out_file);\n-  else\n-    fputs (\"\\tret\\n\", asm_out_file);\n+  fputs (\"\\tret\\n\", asm_out_file);\n }\n \n /* Output a funtion with a call and return thunk for indirect branch.\n-   If BND_P is true, the BND prefix is needed.  If REGNO != UNVALID_REGNUM,\n-   the function address is in REGNO.  Otherwise, the function address is\n-   on the top of stack.  Thunk is used for function return if RET_P is\n-   true.  */\n+   If REGNO != INVALID_REGNUM, the function address is in REGNO.\n+   Otherwise, the function address is on the top of stack.  Thunk is\n+   used for function return if RET_P is true.  */\n \n static void\n output_indirect_thunk_function (enum indirect_thunk_prefix need_prefix,\n@@ -10864,7 +10824,7 @@ output_indirect_thunk_function (enum indirect_thunk_prefix need_prefix,\n   char name[32];\n   tree decl;\n \n-  /* Create __x86_indirect_thunk/__x86_indirect_thunk_bnd.  */\n+  /* Create __x86_indirect_thunk.  */\n   indirect_thunk_name (name, regno, need_prefix, ret_p);\n   decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n \t\t     get_identifier (name),\n@@ -10919,7 +10879,7 @@ output_indirect_thunk_function (enum indirect_thunk_prefix need_prefix,\n   /* Make sure unwind info is emitted for the thunk if needed.  */\n   final_start_function (emit_barrier (), asm_out_file, 1);\n \n-  output_indirect_thunk (need_prefix, regno);\n+  output_indirect_thunk (regno);\n \n   final_end_function ();\n   init_insn_lengths ();\n@@ -10957,34 +10917,19 @@ ix86_code_end (void)\n   if (indirect_return_needed)\n     output_indirect_thunk_function (indirect_thunk_prefix_none,\n \t\t\t\t    INVALID_REGNUM, true);\n-  if (indirect_return_bnd_needed)\n-    output_indirect_thunk_function (indirect_thunk_prefix_bnd,\n-\t\t\t\t    INVALID_REGNUM, true);\n-\n   if (indirect_return_via_cx)\n     output_indirect_thunk_function (indirect_thunk_prefix_none,\n \t\t\t\t    CX_REG, true);\n-  if (indirect_return_via_cx_bnd)\n-    output_indirect_thunk_function (indirect_thunk_prefix_bnd,\n-\t\t\t\t    CX_REG, true);\n-\n   if (indirect_thunk_needed)\n     output_indirect_thunk_function (indirect_thunk_prefix_none,\n \t\t\t\t    INVALID_REGNUM, false);\n-  if (indirect_thunk_bnd_needed)\n-    output_indirect_thunk_function (indirect_thunk_prefix_bnd,\n-\t\t\t\t    INVALID_REGNUM, false);\n \n   for (regno = FIRST_REX_INT_REG; regno <= LAST_REX_INT_REG; regno++)\n     {\n       unsigned int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;\n       if ((indirect_thunks_used & (1 << i)))\n \toutput_indirect_thunk_function (indirect_thunk_prefix_none,\n \t\t\t\t\tregno, false);\n-\n-      if ((indirect_thunks_bnd_used & (1 << i)))\n-\toutput_indirect_thunk_function (indirect_thunk_prefix_bnd,\n-\t\t\t\t\tregno, false);\n     }\n \n   for (regno = FIRST_INT_REG; regno <= LAST_INT_REG; regno++)\n@@ -10996,10 +10941,6 @@ ix86_code_end (void)\n \toutput_indirect_thunk_function (indirect_thunk_prefix_none,\n \t\t\t\t\tregno, false);\n \n-      if ((indirect_thunks_bnd_used & (1 << regno)))\n-\toutput_indirect_thunk_function (indirect_thunk_prefix_bnd,\n-\t\t\t\t\tregno, false);\n-\n       if (!(pic_labels_used & (1 << regno)))\n \tcontinue;\n \n@@ -11274,16 +11215,6 @@ ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined)\n \t  while (nregs-- > 0)\n \t    if ((i + nregs) == regno)\n \t      return false;\n-\n-\t  reg = crtl->return_bnd;\n-\t  if (reg)\n-\t    {\n-\t      i = REGNO (reg);\n-\t      nregs = REG_NREGS (reg);\n-\t      while (nregs-- > 0)\n-\t\tif ((i + nregs) == regno)\n-\t\t  return false;\n-\t    }\n \t}\n \n       return (df_regs_ever_live_p (regno)\n@@ -15494,10 +15425,6 @@ ix86_force_load_from_GOT_p (rtx x)\n static bool\n ix86_legitimate_constant_p (machine_mode mode, rtx x)\n {\n-  /* Pointer bounds constants are not valid.  */\n-  if (POINTER_BOUNDS_MODE_P (GET_MODE (x)))\n-    return false;\n-\n   switch (GET_CODE (x))\n     {\n     case CONST:\n@@ -18636,25 +18563,6 @@ ix86_print_operand_address_as (FILE *file, rtx addr,\n       ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n       code = 'q';\n     }\n-  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDMK_ADDR)\n-    {\n-      ok = ix86_decompose_address (XVECEXP (addr, 0, 1), &parts);\n-      gcc_assert (parts.base == NULL_RTX || parts.index == NULL_RTX);\n-      if (parts.base != NULL_RTX)\n-\t{\n-\t  parts.index = parts.base;\n-\t  parts.scale = 1;\n-\t}\n-      parts.base = XVECEXP (addr, 0, 0);\n-      addr = XVECEXP (addr, 0, 0);\n-    }\n-  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDLDX_ADDR)\n-    {\n-      ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n-      gcc_assert (parts.index == NULL_RTX);\n-      parts.index = XVECEXP (addr, 0, 1);\n-      addr = XVECEXP (addr, 0, 0);\n-    }\n   else\n     ok = ix86_decompose_address (addr, &parts);\n \n@@ -28540,10 +28448,7 @@ ix86_output_indirect_branch_via_reg (rtx call_op, bool sibcall_p)\n \t  int i = regno;\n \t  if (i >= FIRST_REX_INT_REG)\n \t    i -= (FIRST_REX_INT_REG - LAST_INT_REG - 1);\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    indirect_thunks_bnd_used |= 1 << i;\n-\t  else\n-\t    indirect_thunks_used |= 1 << i;\n+\t  indirect_thunks_used |= 1 << i;\n \t}\n       indirect_thunk_name (thunk_name_buf, regno, need_prefix, false);\n       thunk_name = thunk_name_buf;\n@@ -28554,23 +28459,15 @@ ix86_output_indirect_branch_via_reg (rtx call_op, bool sibcall_p)\n   if (sibcall_p)\n     {\n       if (thunk_name != NULL)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t  else\n-\t    fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n-\t}\n+\tfprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n       else\n-\toutput_indirect_thunk (need_prefix, regno);\n+\toutput_indirect_thunk (regno);\n     }\n   else\n     {\n       if (thunk_name != NULL)\n \t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    fprintf (asm_out_file, \"\\tbnd call\\t%s\\n\", thunk_name);\n-\t  else\n-\t    fprintf (asm_out_file, \"\\tcall\\t%s\\n\", thunk_name);\n+\t  fprintf (asm_out_file, \"\\tcall\\t%s\\n\", thunk_name);\n \t  return;\n \t}\n \n@@ -28585,32 +28482,21 @@ ix86_output_indirect_branch_via_reg (rtx call_op, bool sibcall_p)\n \t\t\t\t   indirectlabelno++);\n \n       /* Jump.  */\n-      if (need_prefix == indirect_thunk_prefix_bnd)\n-\tfputs (\"\\tbnd jmp\\t\", asm_out_file);\n-      else\n-\tfputs (\"\\tjmp\\t\", asm_out_file);\n+      fputs (\"\\tjmp\\t\", asm_out_file);\n       assemble_name_raw (asm_out_file, indirectlabel2);\n       fputc ('\\n', asm_out_file);\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);\n \n       if (thunk_name != NULL)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t  else\n-\t    fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n-\t}\n+\tfprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n       else\n-\toutput_indirect_thunk (need_prefix, regno);\n+\toutput_indirect_thunk (regno);\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);\n \n       /* Call.  */\n-      if (need_prefix == indirect_thunk_prefix_bnd)\n-\tfputs (\"\\tbnd call\\t\", asm_out_file);\n-      else\n-\tfputs (\"\\tcall\\t\", asm_out_file);\n+      fputs (\"\\tcall\\t\", asm_out_file);\n       assemble_name_raw (asm_out_file, indirectlabel1);\n       fputc ('\\n', asm_out_file);\n     }\n@@ -28649,12 +28535,7 @@ ix86_output_indirect_branch_via_push (rtx call_op, const char *xasm,\n       != indirect_branch_thunk_inline)\n     {\n       if (cfun->machine->indirect_branch_type == indirect_branch_thunk)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    indirect_thunk_bnd_needed = true;\n-\t  else\n-\t    indirect_thunk_needed = true;\n-\t}\n+\tindirect_thunk_needed = true;\n       indirect_thunk_name (thunk_name_buf, regno, need_prefix, false);\n       thunk_name = thunk_name_buf;\n     }\n@@ -28668,14 +28549,9 @@ ix86_output_indirect_branch_via_push (rtx call_op, const char *xasm,\n     {\n       output_asm_insn (push_buf, &call_op);\n       if (thunk_name != NULL)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t  else\n-\t    fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n-\t}\n+\tfprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n       else\n-\toutput_indirect_thunk (need_prefix, regno);\n+\toutput_indirect_thunk (regno);\n     }\n   else\n     {\n@@ -28690,10 +28566,7 @@ ix86_output_indirect_branch_via_push (rtx call_op, const char *xasm,\n \t\t\t\t   indirectlabelno++);\n \n       /* Jump.  */\n-      if (need_prefix == indirect_thunk_prefix_bnd)\n-\tfputs (\"\\tbnd jmp\\t\", asm_out_file);\n-      else\n-\tfputs (\"\\tjmp\\t\", asm_out_file);\n+      fputs (\"\\tjmp\\t\", asm_out_file);\n       assemble_name_raw (asm_out_file, indirectlabel2);\n       fputc ('\\n', asm_out_file);\n \n@@ -28735,22 +28608,14 @@ ix86_output_indirect_branch_via_push (rtx call_op, const char *xasm,\n       output_asm_insn (push_buf, &call_op);\n \n       if (thunk_name != NULL)\n-\t{\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t  else\n-\t    fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n-\t}\n+\tfprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n       else\n-\toutput_indirect_thunk (need_prefix, regno);\n+\toutput_indirect_thunk (regno);\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);\n \n       /* Call.  */\n-      if (need_prefix == indirect_thunk_prefix_bnd)\n-\tfputs (\"\\tbnd call\\t\", asm_out_file);\n-      else\n-\tfputs (\"\\tcall\\t\", asm_out_file);\n+      fputs (\"\\tcall\\t\", asm_out_file);\n       assemble_name_raw (asm_out_file, indirectlabel1);\n       fputc ('\\n', asm_out_file);\n     }\n@@ -28808,19 +28673,11 @@ ix86_output_function_return (bool long_p)\n \t\t\t     == indirect_branch_thunk);\n \t  indirect_thunk_name (thunk_name, INVALID_REGNUM, need_prefix,\n \t\t\t       true);\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    {\n-\t      indirect_return_bnd_needed |= need_thunk;\n-\t      fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t    }\n-\t  else\n-\t    {\n-\t      indirect_return_needed |= need_thunk;\n-\t      fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n-\t    }\n+\t  indirect_return_needed |= need_thunk;\n+\t  fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n \t}\n       else\n-\toutput_indirect_thunk (need_prefix, INVALID_REGNUM);\n+\toutput_indirect_thunk (INVALID_REGNUM);\n \n       return \"\";\n     }\n@@ -28851,27 +28708,16 @@ ix86_output_indirect_function_return (rtx ret_op)\n \t  bool need_thunk = (cfun->machine->function_return_type\n \t\t\t     == indirect_branch_thunk);\n \t  indirect_thunk_name (thunk_name, regno, need_prefix, true);\n-\t  if (need_prefix == indirect_thunk_prefix_bnd)\n-\t    {\n-\t      if (need_thunk)\n-\t\t{\n-\t\t  indirect_return_via_cx_bnd = true;\n-\t\t  indirect_thunks_bnd_used |= 1 << CX_REG;\n-\t\t}\n-\t      fprintf (asm_out_file, \"\\tbnd jmp\\t%s\\n\", thunk_name);\n-\t    }\n-\t  else\n+\n+\t  if (need_thunk)\n \t    {\n-\t      if (need_thunk)\n-\t\t{\n-\t\t  indirect_return_via_cx = true;\n-\t\t  indirect_thunks_used |= 1 << CX_REG;\n-\t\t}\n-\t      fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n+\t      indirect_return_via_cx = true;\n+\t      indirect_thunks_used |= 1 << CX_REG;\n \t    }\n+\t  fprintf (asm_out_file, \"\\tjmp\\t%s\\n\", thunk_name);\n \t}\n       else\n-\toutput_indirect_thunk (need_prefix, regno);\n+\toutput_indirect_thunk (regno);\n \n       return \"\";\n     }\n@@ -29486,16 +29332,6 @@ avoid_func_arg_motion (rtx_insn *first_arg, rtx_insn *insn)\n   rtx set;\n   rtx tmp;\n \n-  /* Add anti dependencies for bounds stores.  */\n-  if (INSN_P (insn)\n-      && GET_CODE (PATTERN (insn)) == PARALLEL\n-      && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC\n-      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_BNDSTX)\n-    {\n-      add_dependence (first_arg, insn, REG_DEP_ANTI);\n-      return;\n-    }\n-\n   set = single_set (insn);\n   if (!set)\n     return;"}, {"sha": "2a46fccdec11d1b66dd15f4ca7f9fc35b1c523c8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -1033,9 +1033,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n /*  k0,  k1, k2, k3, k4, k5, k6, k7*/\t\t\t\t\\\n-     0,  0,   0,  0,  0,  0,  0,  0,\t\t\t\t\\\n-/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n-     0,  0,  0,  0 }\n+     0,  0,   0,  0,  0,  0,  0,  0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -1072,9 +1070,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n  /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n-/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n-     1,  1,  1,  1 }\n+     1,   1,   1,   1,   1,   1,   1,   1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -1090,8 +1086,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n-   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,  \\\n-   78, 79, 80 }\n+   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -2043,8 +2038,7 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n  \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\",\t\t\t\t\t\\\n- \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\",\t\t\t\\\n- \"bnd0\", \"bnd1\", \"bnd2\", \"bnd3\" }\n+ \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n "}, {"sha": "62dab1662a387451ec9e9c47d2974fd29361f0c3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -184,16 +184,6 @@\n   UNSPEC_PDEP\n   UNSPEC_PEXT\n \n-  UNSPEC_BNDMK\n-  UNSPEC_BNDMK_ADDR\n-  UNSPEC_BNDSTX\n-  UNSPEC_BNDLDX\n-  UNSPEC_BNDLDX_ADDR\n-  UNSPEC_BNDCL\n-  UNSPEC_BNDCU\n-  UNSPEC_BNDCN\n-  UNSPEC_MPX_FENCE\n-\n   ;; IRET support\n   UNSPEC_INTERRUPT_RETURN\n ])\n@@ -428,11 +418,7 @@\n    (MASK5_REG\t\t\t74)\n    (MASK6_REG\t\t\t75)\n    (MASK7_REG\t\t\t76)\n-   (BND0_REG\t\t\t77)\n-   (BND1_REG\t\t\t78)\n-   (BND2_REG\t\t\t79)\n-   (BND3_REG\t\t\t80)\n-   (FIRST_PSEUDO_REG\t\t81)\n+   (FIRST_PSEUDO_REG\t\t77)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -1054,10 +1040,6 @@\n (define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n \t\t\t    (DI \"TARGET_64BIT\")])\n \n-;; Bound modes.\n-(define_mode_iterator BND [(BND32 \"!TARGET_LP64\")\n-\t\t\t   (BND64 \"TARGET_LP64\")])\n-\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n "}, {"sha": "ed3bc7c6619dd61dd6c5be5cc685d71db648d71a", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -1135,9 +1135,6 @@\n (define_predicate \"vsib_mem_operator\"\n   (match_code \"mem\"))\n \n-(define_predicate \"bnd_mem_operator\"\n-  (match_code \"mem\"))\n-\n ;; Return true if the rtx is known to be at least 32 bits aligned.\n (define_predicate \"aligned_operand\"\n   (match_operand 0 \"general_operand\")"}, {"sha": "9a735fab5bfaeda4a4b8ad7baa547713c3d5bac7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -6410,13 +6410,6 @@ init_emit_once (void)\n     if (GET_MODE_CLASS ((machine_mode) i) == MODE_CC)\n       const_tiny_rtx[0][i] = const0_rtx;\n \n-  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_POINTER_BOUNDS)\n-    {\n-      scalar_mode smode = smode_iter.require ();\n-      wide_int wi_zero = wi::zero (GET_MODE_PRECISION (smode));\n-      const_tiny_rtx[0][smode] = immed_wide_int_const (wi_zero, smode);\n-    }\n-\n   pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);\n   ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);\n   simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);"}, {"sha": "f089355aef7e14ff1169a6c5c1d2bf58534c7dfa", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -75,9 +75,6 @@ struct GTY(()) rtl_data {\n      result in a register, current_function_return_rtx will always be\n      the hard register containing the result.  */\n   rtx return_rtx;\n-  /* If nonxero, an RTL expression for the lcoation at which the current\n-     function returns bounds for its result.  */\n-  rtx return_bnd;\n \n   /* Vector of initial-value pairs.  Each pair consists of a pseudo\n      register of approprite mode that stores the initial value a hard"}, {"sha": "7d83eb16b6dd1a63d5d72a9ad8382b33272c9f2a", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -56,8 +56,7 @@ trunc_int_for_mode (HOST_WIDE_INT c, machine_mode mode)\n   int width = GET_MODE_PRECISION (smode);\n \n   /* You want to truncate to a _what_?  */\n-  gcc_assert (SCALAR_INT_MODE_P (mode)\n-\t      || POINTER_BOUNDS_MODE_P (mode));\n+  gcc_assert (SCALAR_INT_MODE_P (mode));\n \n   /* Canonicalize BImode to 0 and STORE_FLAG_VALUE.  */\n   if (smode == BImode)"}, {"sha": "302438323c8761fc339bc3c7949f9c28fb6e3a54", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -5180,7 +5180,6 @@ diddle_return_value_1 (void (*doit) (rtx, void *), void *arg, rtx outgoing)\n void\n diddle_return_value (void (*doit) (rtx, void *), void *arg)\n {\n-  diddle_return_value_1 (doit, arg, crtl->return_bnd);\n   diddle_return_value_1 (doit, arg, crtl->return_rtx);\n }\n "}, {"sha": "6db9ed475f4d3a2b5c7c19f997f94415d79abaf0", "filename": "gcc/genmodes.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -340,7 +340,6 @@ complete_mode (struct mode_data *m)\n       break;\n \n     case MODE_INT:\n-    case MODE_POINTER_BOUNDS:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n     case MODE_FRACT:\n@@ -572,19 +571,6 @@ make_special_mode (enum mode_class cl, const char *name,\n   new_mode (cl, name, file, line);\n }\n \n-#define POINTER_BOUNDS_MODE(N, Y) \\\n-  make_pointer_bounds_mode (#N, Y, __FILE__, __LINE__)\n-\n-static void ATTRIBUTE_UNUSED\n-make_pointer_bounds_mode (const char *name,\n-\t\t\t  unsigned int bytesize,\n-\t\t\t  const char *file, unsigned int line)\n-{\n-  struct mode_data *m = new_mode (MODE_POINTER_BOUNDS, name, file, line);\n-  m->bytesize = bytesize;\n-}\n-\n-\n #define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1U, Y)\n #define FRACTIONAL_INT_MODE(N, B, Y) \\\n   make_int_mode (#N, B, Y, __FILE__, __LINE__)\n@@ -1213,7 +1199,6 @@ get_mode_class (struct mode_data *mode)\n     case MODE_UFRACT:\n     case MODE_ACCUM:\n     case MODE_UACCUM:\n-    case MODE_POINTER_BOUNDS:\n       return \"scalar_mode\";\n \n     case MODE_FLOAT:"}, {"sha": "239a9098f53a0f0c1221e40279b40c129615680b", "filename": "gcc/machmode.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -237,9 +237,6 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n    || CLASS == MODE_ACCUM                      \\\n    || CLASS == MODE_UACCUM)\n \n-#define POINTER_BOUNDS_MODE_P(MODE)      \\\n-  (GET_MODE_CLASS (MODE) == MODE_POINTER_BOUNDS)\n-\n /* An optional T (i.e. a T or nothing), where T is some form of mode class.  */\n template<typename T>\n class opt_mode\n@@ -482,7 +479,6 @@ scalar_mode::includes_p (machine_mode m)\n     case MODE_UACCUM:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n-    case MODE_POINTER_BOUNDS:\n       return true;\n     default:\n       return false;"}, {"sha": "62ec13815f8f08a45f353207120e604a2eae6772", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n   DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n   DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */    \\\n-  DEF_MODE_CLASS (MODE_POINTER_BOUNDS), /* bounds */                       \\\n   DEF_MODE_CLASS (MODE_FRACT),\t\t/* signed fractional number */\t   \\\n   DEF_MODE_CLASS (MODE_UFRACT),\t\t/* unsigned fractional number */   \\\n   DEF_MODE_CLASS (MODE_ACCUM),\t\t/* signed accumulator */\t   \\"}, {"sha": "85937d070b4cded2e687aca651e99852514fa877", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -390,7 +390,6 @@ int_mode_for_mode (machine_mode mode)\n     case MODE_VECTOR_ACCUM:\n     case MODE_VECTOR_UFRACT:\n     case MODE_VECTOR_UACCUM:\n-    case MODE_POINTER_BOUNDS:\n       return int_mode_for_size (GET_MODE_BITSIZE (mode), 0);\n \n     case MODE_RANDOM:"}, {"sha": "0cf8daeb5b177f0b2c98a31c4b05e4654d771e6b", "filename": "gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Findirect-thunk-register-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Findirect-thunk-register-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Findirect-thunk-register-1.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -19,4 +19,3 @@ male_indirect_jump (long offset)\n /* { dg-final { scan-assembler-not \"push(?:l|q)\\[ \\t\\]*_?dispatch\"  } } */\n /* { dg-final { scan-assembler-not \"pushq\\[ \\t\\]%rax\" } } */\n /* { dg-final { scan-assembler-not \"__x86_indirect_thunk\\n\" } } */\n-/* { dg-final { scan-assembler-not \"__x86_indirect_thunk_bnd\\n\" } } */"}, {"sha": "f98cfefef94cff7427a5e744c3bab2c8bff4ddb3", "filename": "gcc/tree-core.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -620,8 +620,6 @@ enum tree_index {\n   TI_CONST_FEXCEPT_T_PTR_TYPE,\n   TI_POINTER_SIZED_TYPE,\n \n-  TI_POINTER_BOUNDS_TYPE,\n-\n   TI_DFLOAT32_TYPE,\n   TI_DFLOAT64_TYPE,\n   TI_DFLOAT128_TYPE,"}, {"sha": "99de27d9d3c400695624fa78733422cfc573fe30", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa30efd073d937054788c0915957508c85ac8b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=eafa30efd073d937054788c0915957508c85ac8b", "patch": "@@ -3923,7 +3923,6 @@ output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n     case MODE_UFRACT:\n     case MODE_ACCUM:\n     case MODE_UACCUM:\n-    case MODE_POINTER_BOUNDS:\n       assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n       break;\n "}]}