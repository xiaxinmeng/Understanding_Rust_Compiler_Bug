{"sha": "57c454d29c12a948fee4a0b437fd57af870710b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdjNDU0ZDI5YzEyYTk0OGZlZTRhMGI0MzdmZDU3YWY4NzA3MTBiNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-01T11:37:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-01T11:37:32Z"}, "message": "tree-vectorizer.h (vect_dr_stmt): New function.\n\n2018-06-01  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_dr_stmt): New function.\n\t(vect_get_load_cost): Adjust.\n\t(vect_get_store_cost): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):\n\tUse vect_dr_stmt instead of DR_SMTT.\n\t(vect_record_base_alignments): Likewise.\n\t(vect_calculate_target_alignment): Likewise.\n\t(vect_compute_data_ref_alignment): Likewise and make static.\n\t(vect_update_misalignment_for_peel): Likewise.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vector_alignment_reachable_p): Likewise.\n\t(vect_get_data_access_cost): Likewise.  Pass down\n\tvinfo to vect_get_load_cost/vect_get_store_cost instead of DR.\n\t(vect_get_peeling_costs_all_drs): Likewise.\n\t(vect_peeling_hash_get_lowest_cost): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_find_same_alignment_drs): Likewise.\n\t(vect_analyze_data_refs_alignment): Likewise.\n\t(vect_analyze_group_access_1): Likewise.\n\t(vect_analyze_group_access): Likewise.\n\t(vect_analyze_data_ref_access): Likewise.\n\t(vect_analyze_data_ref_accesses): Likewise.\n\t(vect_vfa_segment_size): Likewise.\n\t(vect_small_gap_p): Likewise.\n\t(vectorizable_with_step_bound_p): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t(vect_analyze_data_refs): Likewise.\n\t(vect_supportable_dr_alignment): Likewise.\n\t* tree-vect-loop-manip.c (get_misalign_in_elems): Likewise.\n\t(vect_gen_prolog_loop_niters): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Do not\n\tmodify DR_STMT.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t(vect_try_gather_scatter_pattern): Likewise.\n\t* tree-vect-stmts.c (vect_model_store_cost): Pass stmt_info\n\tto vect_get_store_cost.\n\t(vect_get_store_cost): Get stmt_info instead of DR.\n\t(vect_model_load_cost): Pass stmt_info to vect_get_load_cost.\n\t(vect_get_load_cost): Get stmt_info instead of DR.\n\nFrom-SVN: r261062", "tree": {"sha": "98bdde5093c265e50f40f0535806814e4b7f0ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98bdde5093c265e50f40f0535806814e4b7f0ed7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57c454d29c12a948fee4a0b437fd57af870710b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c454d29c12a948fee4a0b437fd57af870710b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c454d29c12a948fee4a0b437fd57af870710b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c454d29c12a948fee4a0b437fd57af870710b4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47cac108ef3a44811ae56fb9c823d5a2339d751b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cac108ef3a44811ae56fb9c823d5a2339d751b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47cac108ef3a44811ae56fb9c823d5a2339d751b"}], "stats": {"total": 234, "additions": 139, "deletions": 95}, "files": [{"sha": "c9f581c0ed5b97d29dda7af04d78c320097f0337", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -1,3 +1,46 @@\n+2018-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_dr_stmt): New function.\n+\t(vect_get_load_cost): Adjust.\n+\t(vect_get_store_cost): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):\n+\tUse vect_dr_stmt instead of DR_SMTT.\n+\t(vect_record_base_alignments): Likewise.\n+\t(vect_calculate_target_alignment): Likewise.\n+\t(vect_compute_data_ref_alignment): Likewise and make static.\n+\t(vect_update_misalignment_for_peel): Likewise.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t(vector_alignment_reachable_p): Likewise.\n+\t(vect_get_data_access_cost): Likewise.  Pass down\n+\tvinfo to vect_get_load_cost/vect_get_store_cost instead of DR.\n+\t(vect_get_peeling_costs_all_drs): Likewise.\n+\t(vect_peeling_hash_get_lowest_cost): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_find_same_alignment_drs): Likewise.\n+\t(vect_analyze_data_refs_alignment): Likewise.\n+\t(vect_analyze_group_access_1): Likewise.\n+\t(vect_analyze_group_access): Likewise.\n+\t(vect_analyze_data_ref_access): Likewise.\n+\t(vect_analyze_data_ref_accesses): Likewise.\n+\t(vect_vfa_segment_size): Likewise.\n+\t(vect_small_gap_p): Likewise.\n+\t(vectorizable_with_step_bound_p): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t(vect_analyze_data_refs): Likewise.\n+\t(vect_supportable_dr_alignment): Likewise.\n+\t* tree-vect-loop-manip.c (get_misalign_in_elems): Likewise.\n+\t(vect_gen_prolog_loop_niters): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Do not\n+\tmodify DR_STMT.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t(vect_try_gather_scatter_pattern): Likewise.\n+\t* tree-vect-stmts.c (vect_model_store_cost): Pass stmt_info\n+\tto vect_get_store_cost.\n+\t(vect_get_store_cost): Get stmt_info instead of DR.\n+\t(vect_model_load_cost): Pass stmt_info to vect_get_load_cost.\n+\t(vect_get_load_cost): Get stmt_info instead of DR.\n+\n 2018-06-01  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/86017"}, {"sha": "0b84f23d81ab62ba2bb92f50d6776b226957dc9c", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -290,8 +290,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n-  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (vect_dr_stmt (dra));\n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (vect_dr_stmt (drb));\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n \n@@ -467,7 +467,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t... = a[i];\n \t\ta[i+1] = ...;\n \t     where loads from the group interleave with the store.  */\n-\t  if (!vect_preserves_scalar_order_p (DR_STMT (dra), DR_STMT (drb)))\n+\t  if (!vect_preserves_scalar_order_p (vect_dr_stmt(dra),\n+\t\t\t\t\t      vect_dr_stmt (drb)))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -618,9 +619,9 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n \n   /* If dra and drb are part of the same interleaving chain consider\n      them independent.  */\n-  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (DR_STMT (dra)))\n-      && (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dra)))\n-\t  == DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (drb)))))\n+  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (vect_dr_stmt (dra)))\n+      && (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (vect_dr_stmt (dra)))\n+\t  == DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (vect_dr_stmt (drb)))))\n     return false;\n \n   /* Unknown data dependence.  */\n@@ -834,22 +835,21 @@ vect_record_base_alignments (vec_info *vinfo)\n   unsigned int i;\n   FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n     {\n-      gimple *stmt = DR_STMT (dr);\n-    if (!DR_IS_CONDITIONAL_IN_STMT (dr)\n-\t&& STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n-      {\n-\tgimple *stmt = DR_STMT (dr);\n-\tvect_record_base_alignment (vinfo, stmt, &DR_INNERMOST (dr));\n+      gimple *stmt = vect_dr_stmt (dr);\n+      if (!DR_IS_CONDITIONAL_IN_STMT (dr)\n+\t  && STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+\t{\n+\t  vect_record_base_alignment (vinfo, stmt, &DR_INNERMOST (dr));\n \n-\t/* If DR is nested in the loop that is being vectorized, we can also\n-\t   record the alignment of the base wrt the outer loop.  */\n-\tif (loop && nested_in_vect_loop_p (loop, stmt))\n-\t  {\n-\t    stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t    vect_record_base_alignment\n-\t      (vinfo, stmt, &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info));\n-\t  }\n-      }\n+\t  /* If DR is nested in the loop that is being vectorized, we can also\n+\t     record the alignment of the base wrt the outer loop.  */\n+\t  if (loop && nested_in_vect_loop_p (loop, stmt))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t      vect_record_base_alignment\n+\t\t (vinfo, stmt, &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info));\n+\t    }\n+\t}\n     }\n }\n \n@@ -858,7 +858,7 @@ vect_record_base_alignments (vec_info *vinfo)\n static unsigned int\n vect_calculate_target_alignment (struct data_reference *dr)\n {\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   return targetm.vectorize.preferred_vector_alignment (vectype);\n@@ -876,10 +876,10 @@ vect_calculate_target_alignment (struct data_reference *dr)\n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n-bool\n+static bool\n vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_base_alignments *base_alignments = &stmt_info->vinfo->base_alignments;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -1068,8 +1068,8 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n   struct data_reference *current_dr;\n   int dr_size = vect_get_scalar_dr_size (dr);\n   int dr_peel_size = vect_get_scalar_dr_size (dr_peel);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n-  stmt_vec_info peel_stmt_info = vinfo_for_stmt (DR_STMT (dr_peel));\n+  stmt_vec_info stmt_info = vinfo_for_stmt (vect_dr_stmt (dr));\n+  stmt_vec_info peel_stmt_info = vinfo_for_stmt (vect_dr_stmt (dr_peel));\n \n  /* For interleaved data accesses the step in the loop must be multiplied by\n      the size of the interleaving group.  */\n@@ -1081,7 +1081,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n   /* It can be assumed that the data refs with the same alignment as dr_peel\n      are aligned in the vector loop.  */\n   same_aligned_drs\n-    = STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr_peel)));\n+    = STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (vect_dr_stmt (dr_peel)));\n   FOR_EACH_VEC_ELT (same_aligned_drs, i, current_dr)\n     {\n       if (current_dr != dr)\n@@ -1161,7 +1161,7 @@ vect_verify_datarefs_alignment (loop_vec_info vinfo)\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      gimple *stmt = DR_STMT (dr);\n+      gimple *stmt = vect_dr_stmt (dr);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1206,7 +1206,7 @@ not_size_aligned (tree exp)\n static bool\n vector_alignment_reachable_p (struct data_reference *dr)\n {\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -1276,7 +1276,7 @@ vect_get_data_access_cost (struct data_reference *dr,\n \t\t\t   stmt_vector_for_cost *body_cost_vec,\n \t\t\t   stmt_vector_for_cost *prologue_cost_vec)\n {\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int ncopies;\n@@ -1287,10 +1287,10 @@ vect_get_data_access_cost (struct data_reference *dr,\n     ncopies = vect_get_num_copies (loop_vinfo, STMT_VINFO_VECTYPE (stmt_info));\n \n   if (DR_IS_READ (dr))\n-    vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost,\n+    vect_get_load_cost (stmt_info, ncopies, true, inside_cost, outside_cost,\n \t\t\tprologue_cost_vec, body_cost_vec, false);\n   else\n-    vect_get_store_cost (dr, ncopies, inside_cost, body_cost_vec);\n+    vect_get_store_cost (stmt_info, ncopies, inside_cost, body_cost_vec);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1406,7 +1406,7 @@ vect_get_peeling_costs_all_drs (vec<data_reference_p> datarefs,\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      gimple *stmt = DR_STMT (dr);\n+      gimple *stmt = vect_dr_stmt (dr);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n \tcontinue;\n@@ -1447,7 +1447,7 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n   vect_peel_info elem = *slot;\n   int dummy;\n   unsigned int inside_cost = 0, outside_cost = 0;\n-  gimple *stmt = DR_STMT (elem->dr);\n+  gimple *stmt = vect_dr_stmt (elem->dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   stmt_vector_for_cost prologue_cost_vec, body_cost_vec,\n@@ -1543,7 +1543,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, struct data_reference *dr0,\n       if (dr == dr0)\n \tcontinue;\n \n-      stmt = DR_STMT (dr);\n+      stmt = vect_dr_stmt (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n       /* For interleaving, only the alignment of the first access\n \t matters.  */\n@@ -1727,7 +1727,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      stmt = DR_STMT (dr);\n+      stmt = vect_dr_stmt (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1938,7 +1938,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       peel_for_unknown_alignment.peel_info.count = 1\n \t+ STMT_VINFO_SAME_ALIGN_REFS\n-\t(vinfo_for_stmt (DR_STMT (dr0))).length ();\n+\t(vinfo_for_stmt (vect_dr_stmt (dr0))).length ();\n     }\n \n   peel_for_unknown_alignment.peel_info.npeel = 0;\n@@ -2019,7 +2019,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (do_peeling)\n     {\n-      stmt = DR_STMT (dr0);\n+      stmt = vect_dr_stmt (dr0);\n       stmt_info = vinfo_for_stmt (stmt);\n       vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -2043,7 +2043,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* For interleaved data access every iteration accesses all the\n \t     members of the group, therefore we divide the number of iterations\n \t     by the group size.  */\n-\t  stmt_info = vinfo_for_stmt (DR_STMT (dr0));\n+\t  stmt_info = vinfo_for_stmt (vect_dr_stmt (dr0));\n \t  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t    npeel /= DR_GROUP_SIZE (stmt_info);\n \n@@ -2117,7 +2117,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      {\n \t\t/* Strided accesses perform only component accesses, alignment\n \t\t   is irrelevant for them.  */\n-\t\tstmt_info = vinfo_for_stmt (DR_STMT (dr));\n+\t\tstmt_info = vinfo_for_stmt (vect_dr_stmt (dr));\n \t\tif (STMT_VINFO_STRIDED_P (stmt_info)\n \t\t    && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t\t  continue;\n@@ -2166,7 +2166,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n     {\n       FOR_EACH_VEC_ELT (datarefs, i, dr)\n         {\n-\t  stmt = DR_STMT (dr);\n+\t  stmt = vect_dr_stmt (dr);\n \t  stmt_info = vinfo_for_stmt (stmt);\n \n \t  /* For interleaving, only the alignment of the first access\n@@ -2202,7 +2202,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                   break;\n                 }\n \n-              stmt = DR_STMT (dr);\n+              stmt = vect_dr_stmt (dr);\n               vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n               gcc_assert (vectype);\n \n@@ -2232,7 +2232,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                           || LOOP_VINFO_PTR_MASK (loop_vinfo) == mask);\n               LOOP_VINFO_PTR_MASK (loop_vinfo) = mask;\n               LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).safe_push (\n-\t\t      DR_STMT (dr));\n+\t\t      vect_dr_stmt (dr));\n             }\n         }\n \n@@ -2292,8 +2292,8 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n-  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (vect_dr_stmt (dra));\n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (vect_dr_stmt (drb));\n \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return;\n@@ -2364,7 +2364,7 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n   vect_record_base_alignments (vinfo);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+      stmt_vec_info stmt_info = vinfo_for_stmt (vect_dr_stmt (dr));\n       if (STMT_VINFO_VECTORIZABLE (stmt_info)\n \t  && !vect_compute_data_ref_alignment (dr))\n \t{\n@@ -2458,7 +2458,7 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n   tree step = DR_STEP (dr);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n   HOST_WIDE_INT type_size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n@@ -2535,7 +2535,7 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n       if (bb_vinfo)\n         {\n           /* Mark the statement as unvectorizable.  */\n-          STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+          STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (vect_dr_stmt (dr))) = false;\n           return true;\n         }\n \n@@ -2696,7 +2696,7 @@ vect_analyze_group_access (struct data_reference *dr)\n     {\n       /* Dissolve the group if present.  */\n       gimple *next;\n-      gimple *stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dr)));\n+      gimple *stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (vect_dr_stmt (dr)));\n       while (stmt)\n \t{\n \t  stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n@@ -2719,7 +2719,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n {\n   tree step = DR_STEP (dr);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n@@ -2948,7 +2948,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   for (i = 0; i < datarefs_copy.length () - 1;)\n     {\n       data_reference_p dra = datarefs_copy[i];\n-      stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n+      stmt_vec_info stmtinfo_a = vinfo_for_stmt (vect_dr_stmt (dra));\n       stmt_vec_info lastinfo = NULL;\n       if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n \t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a))\n@@ -2959,7 +2959,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n       for (i = i + 1; i < datarefs_copy.length (); ++i)\n \t{\n \t  data_reference_p drb = datarefs_copy[i];\n-\t  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+\t  stmt_vec_info stmtinfo_b = vinfo_for_stmt (vect_dr_stmt (drb));\n \t  if (!STMT_VINFO_VECTORIZABLE (stmtinfo_b)\n \t      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n \t    break;\n@@ -2983,7 +2983,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t      || data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n \t\t\t\t\tDR_BASE_ADDRESS (drb)) != 0\n \t      || data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb)) != 0\n-\t      || !can_group_stmts_p (DR_STMT (dra), DR_STMT (drb)))\n+\t      || !can_group_stmts_p (vect_dr_stmt (dra), vect_dr_stmt (drb)))\n \t    break;\n \n \t  /* Check that the data-refs have the same constant size.  */\n@@ -3072,17 +3072,17 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  /* Link the found element into the group list.  */\n \t  if (!DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n \t    {\n-\t      DR_GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (dra);\n+\t      DR_GROUP_FIRST_ELEMENT (stmtinfo_a) = vect_dr_stmt (dra);\n \t      lastinfo = stmtinfo_a;\n \t    }\n-\t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n-\t  DR_GROUP_NEXT_ELEMENT (lastinfo) = DR_STMT (drb);\n+\t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = vect_dr_stmt (dra);\n+\t  DR_GROUP_NEXT_ELEMENT (lastinfo) = vect_dr_stmt (drb);\n \t  lastinfo = stmtinfo_b;\n \t}\n     }\n \n   FOR_EACH_VEC_ELT (datarefs_copy, i, dr)\n-    if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n+    if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (vect_dr_stmt (dr))) \n         && !vect_analyze_data_ref_access (dr))\n       {\n \tif (dump_enabled_p ())\n@@ -3092,7 +3092,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n         if (is_a <bb_vec_info> (vinfo))\n           {\n             /* Mark the statement as not vectorizable.  */\n-            STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+            STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (vect_dr_stmt (dr))) = false;\n             continue;\n           }\n         else\n@@ -3133,13 +3133,13 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n static unsigned HOST_WIDE_INT\n vect_vfa_access_size (data_reference *dr)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (DR_STMT (dr));\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (vect_dr_stmt (dr));\n   tree ref_type = TREE_TYPE (DR_REF (dr));\n   unsigned HOST_WIDE_INT ref_size = tree_to_uhwi (TYPE_SIZE_UNIT (ref_type));\n   unsigned HOST_WIDE_INT access_size = ref_size;\n   if (DR_GROUP_FIRST_ELEMENT (stmt_vinfo))\n     {\n-      gcc_assert (DR_GROUP_FIRST_ELEMENT (stmt_vinfo) == DR_STMT (dr));\n+      gcc_assert (DR_GROUP_FIRST_ELEMENT (stmt_vinfo) == vect_dr_stmt (dr));\n       access_size *= DR_GROUP_SIZE (stmt_vinfo) - DR_GROUP_GAP (stmt_vinfo);\n     }\n   if (STMT_VINFO_VEC_STMT (stmt_vinfo)\n@@ -3307,7 +3307,7 @@ vect_check_lower_bound (loop_vec_info loop_vinfo, tree expr, bool unsigned_p,\n static bool\n vect_small_gap_p (loop_vec_info loop_vinfo, data_reference *dr, poly_int64 gap)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+  stmt_vec_info stmt_info = vinfo_for_stmt (vect_dr_stmt (dr));\n   HOST_WIDE_INT count\n     = estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   if (DR_GROUP_FIRST_ELEMENT (stmt_info))\n@@ -3344,7 +3344,8 @@ vectorizable_with_step_bound_p (data_reference *dr_a, data_reference *dr_b,\n   /* If the two accesses could be dependent within a scalar iteration,\n      make sure that we'd retain their order.  */\n   if (maybe_gt (init_a + vect_get_scalar_dr_size (dr_a), init_b)\n-      && !vect_preserves_scalar_order_p (DR_STMT (dr_a), DR_STMT (dr_b)))\n+      && !vect_preserves_scalar_order_p (vect_dr_stmt (dr_a),\n+\t\t\t\t\t vect_dr_stmt (dr_b)))\n     return false;\n \n   /* There is no alias if abs (DR_STEP) is greater than or equal to\n@@ -3440,10 +3441,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t}\n \n       dr_a = DDR_A (ddr);\n-      stmt_a = DR_STMT (DDR_A (ddr));\n+      stmt_a = vect_dr_stmt (DDR_A (ddr));\n \n       dr_b = DDR_B (ddr);\n-      stmt_b = DR_STMT (DDR_B (ddr));\n+      stmt_b = vect_dr_stmt (DDR_B (ddr));\n \n       /* Skip the pair if inter-iteration dependencies are irrelevant\n \t and intra-iteration dependencies are guaranteed to be honored.  */\n@@ -4094,7 +4095,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n       poly_uint64 vf;\n \n       gcc_assert (DR_REF (dr));\n-      stmt = DR_STMT (dr);\n+      stmt = vect_dr_stmt (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n       /* Check that analysis of the data-ref succeeded.  */\n@@ -6472,7 +6473,7 @@ enum dr_alignment_support\n vect_supportable_dr_alignment (struct data_reference *dr,\n                                bool check_aligned_accesses)\n {\n-  gimple *stmt = DR_STMT (dr);\n+  gimple *stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   machine_mode mode = TYPE_MODE (vectype);"}, {"sha": "7443e7f473e339bac2f54c13d8cd7e58c4dde9ef", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -1560,7 +1560,7 @@ static tree\n get_misalign_in_elems (gimple **seq, loop_vec_info loop_vinfo)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n-  gimple *dr_stmt = DR_STMT (dr);\n+  gimple *dr_stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -1631,7 +1631,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n   tree niters_type = TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo));\n   gimple_seq stmts = NULL, new_stmts = NULL;\n   tree iters, iters_name;\n-  gimple *dr_stmt = DR_STMT (dr);\n+  gimple *dr_stmt = vect_dr_stmt (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   unsigned int target_align = DR_TARGET_ALIGNMENT (dr);"}, {"sha": "385d62f4cb3adcaa941a22c34bd4439a499a9da6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -2165,7 +2165,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t    {\n \t      struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n \t      tree vectype\n-\t\t= STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr)));\n+\t\t= STMT_VINFO_VECTYPE (vinfo_for_stmt (vect_dr_stmt (dr)));\n \t      niters_th += TYPE_VECTOR_SUBPARTS (vectype) - 1;\n \t    }\n \t  else"}, {"sha": "f99484f1da5c84455889c00ad4b64b65a2bf3b30", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -3880,7 +3880,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n       STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n-      DR_STMT (STMT_VINFO_DATA_REF (stmt_vinfo)) = pattern_stmt;\n       *type_out = vectype;\n       *type_in = vectype;\n       stmts->safe_push (last_stmt);\n@@ -4017,7 +4016,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n       STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n-      DR_STMT (STMT_VINFO_DATA_REF (stmt_vinfo)) = pattern_stmt;\n \n       *type_out = vectype1;\n       *type_in = vectype1;\n@@ -4376,7 +4374,6 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n     = STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info);\n   STMT_VINFO_GATHER_SCATTER_P (pattern_stmt_info)\n     = STMT_VINFO_GATHER_SCATTER_P (stmt_info);\n-  DR_STMT (dr) = pattern_stmt;\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   *type_out = vectype;"}, {"sha": "da4cb0737edb1f7e576cc75165362424e1401d94", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -995,7 +995,6 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       stmt_vector_for_cost *cost_vec)\n {\n   unsigned int inside_cost = 0, prologue_cost = 0;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n@@ -1016,10 +1015,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   /* Grouped stores update all elements in the group at once,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n-    {\n-      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-    }\n+    first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   /* True if we should include any once-per-group costs as well as\n      the cost of the statement itself.  For SLP we only get called\n@@ -1058,7 +1054,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n     }\n   else\n-    vect_get_store_cost (dr, ncopies, &inside_cost, cost_vec);\n+    vect_get_store_cost (stmt_info, ncopies, &inside_cost, cost_vec);\n \n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_STRIDED_SLP)\n@@ -1079,13 +1075,12 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \n /* Calculate cost of DR's memory access.  */\n void\n-vect_get_store_cost (struct data_reference *dr, int ncopies,\n+vect_get_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t     unsigned int *inside_cost,\n \t\t     stmt_vector_for_cost *body_cost_vec)\n {\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n-  gimple *stmt = DR_STMT (dr);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   switch (alignment_support_scheme)\n     {\n@@ -1145,7 +1140,6 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t      stmt_vector_for_cost *cost_vec)\n {\n   gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   unsigned int inside_cost = 0, prologue_cost = 0;\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n@@ -1198,16 +1192,10 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t      + assumed_nunits - 1) / assumed_nunits);\n     }\n \n-  /* ???  Need to transition load permutation (and load cost) handling\n-     from vect_analyze_slp_cost_1 to here.  */\n-\n   /* Grouped loads read all elements in the group at once,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n-    {\n-      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-    }\n+    first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   /* True if we should include any once-per-group costs as well as\n      the cost of the statement itself.  For SLP we only get called\n@@ -1246,7 +1234,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n     }\n   else\n-    vect_get_load_cost (dr, ncopies, first_stmt_p,\n+    vect_get_load_cost (stmt_info, ncopies, first_stmt_p,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tcost_vec, cost_vec, true);\n   if (memory_access_type == VMAT_ELEMENTWISE\n@@ -1263,16 +1251,15 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \n /* Calculate cost of DR's memory access.  */\n void\n-vect_get_load_cost (struct data_reference *dr, int ncopies,\n+vect_get_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t    bool add_realign_cost, unsigned int *inside_cost,\n \t\t    unsigned int *prologue_cost,\n \t\t    stmt_vector_for_cost *prologue_cost_vec,\n \t\t    stmt_vector_for_cost *body_cost_vec,\n \t\t    bool record_prologue_costs)\n {\n+  data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n-  gimple *stmt = DR_STMT (dr);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   switch (alignment_support_scheme)\n     {"}, {"sha": "f4b4dec64f0ac2522d92947f9faeafb1912739ec", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57c454d29c12a948fee4a0b437fd57af870710b4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=57c454d29c12a948fee4a0b437fd57af870710b4", "patch": "@@ -1305,6 +1305,22 @@ vect_dr_behavior (data_reference *dr)\n     return &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info);\n }\n \n+/* Return the stmt DR is in.  For DR_STMT that have been replaced by\n+   a pattern this returns the corresponding pattern stmt.  Otherwise\n+   DR_STMT is returned.  */\n+\n+inline gimple *\n+vect_dr_stmt (data_reference *dr)\n+{\n+  gimple *stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+    return STMT_VINFO_RELATED_STMT (stmt_info);\n+  /* DR_STMT should never refer to a stmt in a pattern replacement.  */\n+  gcc_checking_assert (!STMT_VINFO_RELATED_STMT (stmt_info));\n+  return stmt;\n+}\n+\n /* Return true if the vect cost model is unlimited.  */\n static inline bool\n unlimited_cost_model (loop_p loop)\n@@ -1473,11 +1489,11 @@ extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance,\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, tree, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n-extern void vect_get_load_cost (struct data_reference *, int, bool,\n+extern void vect_get_load_cost (stmt_vec_info, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,\n \t\t\t\tstmt_vector_for_cost *, bool);\n-extern void vect_get_store_cost (struct data_reference *, int,\n+extern void vect_get_store_cost (stmt_vec_info, int,\n \t\t\t\t unsigned int *, stmt_vector_for_cost *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n extern tree vect_gen_perm_mask_any (tree, const vec_perm_indices &);"}]}