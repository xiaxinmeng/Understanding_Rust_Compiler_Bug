{"sha": "a9a399fe24303d933a412f01c01bb8e78d97cf9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhMzk5ZmUyNDMwM2Q5MzNhNDEyZjAxYzAxYmI4ZTc4ZDk3Y2Y5Zg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-07-13T05:41:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-07-13T05:41:28Z"}, "message": "re PR libgcj/3426 (java.io.InputStreamReader, infinite loop)\n\n\n\tFix for PR libgcj/3426:\n\t* gnu/gcj/convert/natIconv.cc: Include CharConversionException.h,\n\terrno.h.\n\t(read): Throw exception if character conversion fails.\n\t* java/io/BufferedInputStream.java (refill): Now package-private.\n\t* java/io/InputStreamReader.java (ready): Simplified.\n\t(refill): New method.\n\t(read): Use it.\n\nCo-Authored-By: David Brownell <david-b@pacbell.net>\n\nFrom-SVN: r43975", "tree": {"sha": "4aff078d910dc63cd6e5522da1dc415bc661bb0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aff078d910dc63cd6e5522da1dc415bc661bb0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9a399fe24303d933a412f01c01bb8e78d97cf9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a399fe24303d933a412f01c01bb8e78d97cf9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a399fe24303d933a412f01c01bb8e78d97cf9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a399fe24303d933a412f01c01bb8e78d97cf9f/comments", "author": null, "committer": null, "parents": [{"sha": "c813baa415260f431f2a5c67312338802cbe5671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c813baa415260f431f2a5c67312338802cbe5671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c813baa415260f431f2a5c67312338802cbe5671"}], "stats": {"total": 147, "additions": 83, "deletions": 64}, "files": [{"sha": "017a99a8cf0768a550bc64ce3d120a4eb096a657", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a9a399fe24303d933a412f01c01bb8e78d97cf9f", "patch": "@@ -1,3 +1,15 @@\n+2001-07-12  Tom Tromey  <tromey@redhat.com>\n+\t    David Brownell  <david-b@pacbell.net>\n+\t\n+\tFix for PR libgcj/3426:\n+\t* gnu/gcj/convert/natIconv.cc: Include CharConversionException.h,\n+\terrno.h.\n+\t(read): Throw exception if character conversion fails.\n+\t* java/io/BufferedInputStream.java (refill): Now package-private.\n+\t* java/io/InputStreamReader.java (ready): Simplified.\n+\t(refill): New method.\n+\t(read): Use it.\n+\n 2001-07-12  Tom Tromey  <tromey@redhat.com>\n \n \tReport from Henner Zeller:"}, {"sha": "3c5f52ec4d60e0bad74e1311b2456b3ec2b2ea47", "filename": "libjava/gnu/gcj/convert/natIconv.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc?ref=a9a399fe24303d933a412f01c01bb8e78d97cf9f", "patch": "@@ -1,6 +1,6 @@\n // Input_iconv.java -- Java side of iconv() reader.\n \n-/* Copyright (C) 2000  Free Software Foundation\n+/* Copyright (C) 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -17,8 +17,11 @@ details.  */\n \n #include <gnu/gcj/convert/Input_iconv.h>\n #include <gnu/gcj/convert/Output_iconv.h>\n+#include <java/io/CharConversionException.h>\n #include <java/io/UnsupportedEncodingException.h>\n \n+#include <errno.h>\n+\n #ifdef HAVE_ICONV\n #include <iconv.h>\n \n@@ -84,7 +87,14 @@ gnu::gcj::convert::Input_iconv::read (jcharArray outbuffer,\n   size_t r = iconv_adapter (iconv, (iconv_t) handle,\n \t\t\t    &inbuf, &inavail,\n \t\t\t    &outbuf, &outavail);\n-  // FIXME: what if R==-1?\n+\n+  if (r == (size_t) -1)\n+    {\n+      // Incomplete character.\n+      if (errno == EINVAL)\n+\treturn 0;\n+      throw new java::io::CharConversionException ();\n+    }\n \n   if (iconv_byte_swap)\n     {"}, {"sha": "15fa9368226512b23d2ade407846c977b94e4f51", "filename": "libjava/java/io/BufferedInputStream.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=a9a399fe24303d933a412f01c01bb8e78d97cf9f", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -131,7 +131,7 @@ public synchronized long skip(long n) throws IOException\n     return origN - n;\n   }\n \n-  private boolean refill() throws IOException\n+  boolean refill() throws IOException\n   {\n     if (markpos < 0)\n       count = pos = 0;"}, {"sha": "45fd59821ec081711f39aa4456853006e0b344dc", "filename": "libjava/java/io/InputStreamReader.java", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a399fe24303d933a412f01c01bb8e78d97cf9f/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=a9a399fe24303d933a412f01c01bb8e78d97cf9f", "patch": "@@ -44,6 +44,11 @@ public InputStreamReader(InputStream in, String enc)\n \n   private InputStreamReader(InputStream in, BytesToUnicode decoder)\n   {\n+    // FIXME: someone could pass in a BufferedInputStream whose buffer\n+    // is smaller than the longest encoded character for this\n+    // encoding.  We will probably go into an infinite loop in this\n+    // case.  We probably ought to just have our own byte buffering\n+    // here.\n     this.in = in instanceof BufferedInputStream\n               ? (BufferedInputStream) in\n               : new BufferedInputStream(in);\n@@ -76,28 +81,11 @@ public boolean ready() throws IOException\n \n \tif (wpos < wcount)\n \t  return true;\n-\tif (work == null)\n-\t  {\n-\t    work = new char[100];\n-\t    wpos = 0;\n-\t    wcount = 0;\n-\t  }\n-\tfor (;;)\n-\t  {\n-\t    if (in.available() <= 0)\n-\t      return false;\n-\t    in.mark(1);\n-\t    int b = in.read();\n-\t    if (b < 0)\n-\t      return true;\n-\t    in.reset();\n-\t    converter.setInput(in.buf, in.pos, in.count);\n-\t    wpos = 0;\n-\t    wcount = converter.read(work, 0, work.length);\n-\t    in.skip(converter.inpos - in.pos);\n-\t    if (wcount > 0)\n-\t      return true;\n-\t  }\n+\n+\t// According to the spec, an InputStreamReader is ready if its\n+\t// input buffer is not empty (above), or if bytes are\n+\t// available on the underlying byte stream.\n+\treturn in.available () > 0;\n       }\n   }\n \n@@ -108,33 +96,23 @@ public int read(char buf[], int offset, int length) throws IOException\n \tif (in == null)\n \t  throw new IOException(\"Stream closed\");\n \n+\tif (length == 0)\n+\t  return 0;\n+\n \tint wavail = wcount - wpos;\n-\tif (wavail > 0)\n-\t  {\n-\t    if (length > wavail)\n-\t      length = wavail;\n-\t    System.arraycopy(work, wpos, buf, offset, length);\n-\t    wpos += length;\n-\t    return length;\n-\t  }\n-\telse\n+\tif (wavail <= 0)\n \t  {\n-\t    if (length == 0)\n-\t      return 0;\n-\t    for (;;)\n-\t      {\n-\t\tin.mark(1);\n-\t\tint b = in.read();\n-\t\tif (b < 0)\n-\t\t  return -1;\n-\t\tin.reset();\n-\t\tconverter.setInput(in.buf, in.pos, in.count);\n-\t\tint count = converter.read (buf, offset, length);\n-\t\tin.skip(converter.inpos - in.pos);\n-\t\tif (count > 0)\n-\t\t  return count;\n-\t      }\n+\t    // Nothing waiting, so refill our buffer.\n+\t    if (! refill ())\n+\t      return -1;\n+\t    wavail = wcount - wpos;\n \t  }\n+\n+\tif (length > wavail)\n+\t  length = wavail;\n+\tSystem.arraycopy(work, wpos, buf, offset, length);\n+\twpos += length;\n+\treturn length;\n       }\n   }\n \n@@ -146,24 +124,43 @@ public int read() throws IOException\n \t  throw new IOException(\"Stream closed\");\n \n \tint wavail = wcount - wpos;\n-\tif (wavail > 0)\n-\t  return work[wpos++];\n-\tif (work == null)\n+\tif (wavail <= 0)\n \t  {\n-\t    work = new char[100];\n-\t    wpos = 0;\n-\t    wcount = 0;\n+\t    // Nothing waiting, so refill our buffer.\n+\t    if (! refill ())\n+\t      return -1;\n \t  }\n-\telse if (wavail == 0)\n+\n+\treturn work[wpos++];\n+      }\n+  }\n+\n+  // Read more bytes and convert them into the WORK buffer.\n+  // Return false on EOF.\n+  private boolean refill () throws IOException\n+  {\n+    wcount = wpos = 0;\n+\n+    if (work == null)\n+      work = new char[100];\n+\n+    for (;;)\n+      {\n+\t// We have knowledge of the internals of BufferedInputStream\n+\t// here.  Eww.\n+\tin.mark (0);\n+\tboolean r = in.refill ();\n+\tin.reset ();\n+\tif (! r)\n+\t  return false;\n+\tconverter.setInput(in.buf, in.pos, in.count);\n+\tint count = converter.read (work, wpos, work.length - wpos);\n+\tin.skip(converter.inpos - in.pos);\n+\tif (count > 0)\n \t  {\n-\t    wpos = 0;\n-\t    wcount = 0;\n+\t    wcount += count;\n+\t    return true;\n \t  }\n-\tint count = read(work, wpos, work.length-wpos);\n-\tif (count <= 0)\n-\t  return -1;\n-\twcount = wpos + count;\n-\treturn work[wpos++];\n       }\n   }\n }"}]}