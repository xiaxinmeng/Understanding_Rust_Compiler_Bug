{"sha": "1d3e6248e59e6f7bca2c49ba367de9cc296837de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQzZTYyNDhlNTllNmY3YmNhMmM0OWJhMzY3ZGU5Y2MyOTY4MzdkZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-09-02T08:31:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-09-02T08:31:45Z"}, "message": "re PR libstdc++/24469 (Possible race condition in mt_allocator causing SIGSEGV)\n\n2006-09-02  Paolo Carlini  <pcarlini@suse.de>\n\t    Richard Guenther  <rguenther@suse.de>\n\n\tPR libstdc++/24469\n\t* src/mt_allocator.cc (__pool<true>::_M_reserve_block,\n\t__pool<true>::_M_reclaim_block): Fix the logic to avoid\n\traces, exploit atomic counters stored in second part of\n\tthe memory pointed by _M_used.\n\t(__pool<true>::_M_initialize): Adjust _M_used allocation.\n\t* include/ext/mt_allocator.h (__pool<true>::_Bin_record):\n\tUpdate comment.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r116660", "tree": {"sha": "fccd6471b2b07451f58ce618be89804c2617a96b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fccd6471b2b07451f58ce618be89804c2617a96b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d3e6248e59e6f7bca2c49ba367de9cc296837de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3e6248e59e6f7bca2c49ba367de9cc296837de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3e6248e59e6f7bca2c49ba367de9cc296837de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3e6248e59e6f7bca2c49ba367de9cc296837de/comments", "author": null, "committer": null, "parents": [{"sha": "b73aec4fa5506d3f657aede2e44f989a894cf7aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73aec4fa5506d3f657aede2e44f989a894cf7aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73aec4fa5506d3f657aede2e44f989a894cf7aa"}], "stats": {"total": 99, "additions": 73, "deletions": 26}, "files": [{"sha": "997e319c8862bfb1d9b5b6e5d0f772a4ad326925", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1d3e6248e59e6f7bca2c49ba367de9cc296837de", "patch": "@@ -1,3 +1,15 @@\n+2006-09-02  Paolo Carlini  <pcarlini@suse.de>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\n+\tPR libstdc++/24469\n+\t* src/mt_allocator.cc (__pool<true>::_M_reserve_block,\n+\t__pool<true>::_M_reclaim_block): Fix the logic to avoid\n+\traces, exploit atomic counters stored in second part of\n+\tthe memory pointed by _M_used.\n+\t(__pool<true>::_M_initialize): Adjust _M_used allocation.\n+\t* include/ext/mt_allocator.h (__pool<true>::_Bin_record):\n+\tUpdate comment.\n+\n 2006-08-31  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/28671 continued"}, {"sha": "2379d82c031994e2a0ab725e2c033441987e29f1", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=1d3e6248e59e6f7bca2c49ba367de9cc296837de", "patch": "@@ -298,8 +298,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n \t// An \"array\" of counters used to keep track of the amount of\n \t// blocks that are on the freelist/used for each thread id.\n-\t// Memory to these \"arrays\" is allocated in _S_initialize() for\n-\t// _S_max_threads + global pool 0.\n+\t// - Note that the second part of the allocated _M_used \"array\"\n+\t//   actually hosts (atomic) counters of reclaimed blocks:  in\n+\t//   _M_reserve_block and in _M_reclaim_block those numbers are\n+\t//   subtracted from the first ones to obtain the actual size\n+\t//   of the \"working set\" of the given thread.\n+\t// - Memory to these \"arrays\" is allocated in _S_initialize()\n+\t//   for _S_max_threads + global pool 0.\n \tsize_t*\t\t\t\t_M_free;\n \tsize_t*\t\t\t        _M_used;\n \t"}, {"sha": "f0b98bdd019731ed81556fe635d627e88a6c60b8", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d3e6248e59e6f7bca2c49ba367de9cc296837de/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=1d3e6248e59e6f7bca2c49ba367de9cc296837de", "patch": "@@ -34,6 +34,7 @@\n #include <bits/c++config.h>\n #include <bits/concurrence.h>\n #include <ext/mt_allocator.h>\n+#include <cstring>\n \n namespace\n {\n@@ -263,21 +264,41 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t// number of records is \"high enough\".\n \tconst size_t __thread_id = _M_get_thread_id();\n \tconst _Tune& __options = _M_get_options();\t\n-\tconst unsigned long __limit = 100 * (_M_bin_size - __which)\n-\t\t                      * __options._M_freelist_headroom;\n+\tconst size_t __limit = (100 * (_M_bin_size - __which)\n+\t\t\t\t* __options._M_freelist_headroom);\n \n-\tunsigned long __remove = __bin._M_free[__thread_id];\n+\tsize_t __remove = __bin._M_free[__thread_id];\n \t__remove *= __options._M_freelist_headroom;\n-\tif (__remove >= __bin._M_used[__thread_id])\n-\t  __remove -= __bin._M_used[__thread_id];\n+\n+\t// NB: We assume that reads of _Atomic_words are atomic.\n+\tconst size_t __max_threads = __options._M_max_threads + 1;\n+\t_Atomic_word* const __reclaimed_base =\n+\t  reinterpret_cast<_Atomic_word*>(__bin._M_used + __max_threads);\n+\tconst _Atomic_word __reclaimed = __reclaimed_base[__thread_id];\n+\tconst size_t __used = __bin._M_used[__thread_id] - __reclaimed;\n+\n+\t// NB: For performance sake we don't resync every time, in order\n+\t// to spare atomic ops.  Note that if __reclaimed increased by,\n+\t// say, 1024, since the last sync, it means that the other\n+\t// threads executed the atomic in the else below at least the\n+\t// same number of times (at least, because _M_reserve_block may\n+\t// have decreased the counter), therefore one more cannot hurt.\n+\tif (__reclaimed > 1024)\n+\t  {\n+\t    __bin._M_used[__thread_id] -= __reclaimed;\n+\t    __atomic_add(&__reclaimed_base[__thread_id], -__reclaimed);\n+\t  }\n+\n+\tif (__remove >= __used)\n+\t  __remove -= __used;\n \telse\n \t  __remove = 0;\n \tif (__remove > __limit && __remove > __bin._M_free[__thread_id])\n \t  {\n \t    _Block_record* __first = __bin._M_first[__thread_id];\n \t    _Block_record* __tmp = __first;\n \t    __remove /= __options._M_freelist_headroom;\n-\t    const unsigned long __removed = __remove;\n+\t    const size_t __removed = __remove;\n \t    while (--__remove > 0)\n \t      __tmp = __tmp->_M_next;\n \t    __bin._M_first[__thread_id] = __tmp->_M_next;\n@@ -292,8 +313,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n \t// Return this block to our list and update counters and\n \t// owner id as needed.\n-\t--__bin._M_used[__block->_M_thread_id];\n-\t\n+\tif (__block->_M_thread_id == __thread_id)\n+\t  --__bin._M_used[__thread_id];\n+\telse\n+\t  __atomic_add(&__reclaimed_base[__block->_M_thread_id], 1);\n+\n \t__block->_M_next = __bin._M_first[__thread_id];\n \t__bin._M_first[__thread_id] = __block;\n \t\n@@ -333,6 +357,14 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     _Block_record* __block = NULL;\n     if (__gthread_active_p())\n       {\n+\t// Resync the _M_used counters.\n+\tconst size_t __max_threads = __options._M_max_threads + 1;\n+\t_Atomic_word* const __reclaimed_base =\n+\t  reinterpret_cast<_Atomic_word*>(__bin._M_used + __max_threads);\n+\tconst _Atomic_word __reclaimed = __reclaimed_base[__thread_id];\n+\t__bin._M_used[__thread_id] -= __reclaimed;\n+\t__atomic_add(&__reclaimed_base[__thread_id], -__reclaimed);\n+\n \t__gthread_mutex_lock(__bin._M_mutex);\n \tif (__bin._M_first[0] == NULL)\n \t  {\n@@ -533,14 +565,19 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  {\n \t    _Bin_record& __bin = _M_bin[__n];\n \t    __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n+\t    std::memset(__v, 0, sizeof(_Block_record*) * __max_threads);    \n \t    __bin._M_first = static_cast<_Block_record**>(__v);\n \n \t    __bin._M_address = NULL;\n \n \t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    std::memset(__v, 0, sizeof(size_t) * __max_threads);\t    \t    \n \t    __bin._M_free = static_cast<size_t*>(__v);\n-\t      \n-\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\n+\t    __v = ::operator new(sizeof(size_t) * __max_threads\n+\t\t\t\t + sizeof(_Atomic_word) * __max_threads);\n+\t    std::memset(__v, 0, (sizeof(size_t) * __max_threads\n+\t\t\t\t + sizeof(_Atomic_word) * __max_threads));\n \t    __bin._M_used = static_cast<size_t*>(__v);\n \t      \n \t    __v = ::operator new(sizeof(__gthread_mutex_t));\n@@ -555,12 +592,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #else\n \t    { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n #endif\n-\t    for (size_t __threadn = 0; __threadn < __max_threads; ++__threadn)\n-\t      {\n-\t\t__bin._M_first[__threadn] = NULL;\n-\t\t__bin._M_free[__threadn] = 0;\n-\t\t__bin._M_used[__threadn] = 0;\n-\t      }\n \t  }\n       }\n     else\n@@ -729,16 +760,21 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  {\n \t    _Bin_record& __bin = _M_bin[__n];\n \t    __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n+\t    std::memset(__v, 0, sizeof(_Block_record*) * __max_threads);\n \t    __bin._M_first = static_cast<_Block_record**>(__v);\n \n \t    __bin._M_address = NULL;\n \n \t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    std::memset(__v, 0, sizeof(size_t) * __max_threads);\n \t    __bin._M_free = static_cast<size_t*>(__v);\n \t      \n-\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    __v = ::operator new(sizeof(size_t) * __max_threads + \n+\t\t\t\t sizeof(_Atomic_word) * __max_threads);\n+\t    std::memset(__v, 0, (sizeof(size_t) * __max_threads\n+\t\t\t\t + sizeof(_Atomic_word) * __max_threads));\n \t    __bin._M_used = static_cast<size_t*>(__v);\n-\t      \n+\n \t    __v = ::operator new(sizeof(__gthread_mutex_t));\n \t    __bin._M_mutex = static_cast<__gthread_mutex_t*>(__v);\n \t      \n@@ -751,12 +787,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #else\n \t    { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n #endif\n-\t    for (size_t __threadn = 0; __threadn < __max_threads; ++__threadn)\n-\t      {\n-\t\t__bin._M_first[__threadn] = NULL;\n-\t\t__bin._M_free[__threadn] = 0;\n-\t\t__bin._M_used[__threadn] = 0;\n-\t      }\n \t  }\n       }\n     else"}]}