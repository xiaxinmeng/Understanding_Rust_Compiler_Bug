{"sha": "005e3e053fb770c9a471c22f4dba447b532fe701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1ZTNlMDUzZmI3NzBjOWE0NzFjMjJmNGRiYTQ0N2I1MzJmZTcwMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-21T02:04:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-21T02:04:46Z"}, "message": "* config/h8300/h8300.c: Revise comments about shift code.\n\nFrom-SVN: r49030", "tree": {"sha": "3659b41045c5445978227c7e053d188fc2a22375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3659b41045c5445978227c7e053d188fc2a22375"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005e3e053fb770c9a471c22f4dba447b532fe701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005e3e053fb770c9a471c22f4dba447b532fe701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005e3e053fb770c9a471c22f4dba447b532fe701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005e3e053fb770c9a471c22f4dba447b532fe701/comments", "author": null, "committer": null, "parents": [{"sha": "64bead4cff14afc6ef91fa29870abeb649d5b47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64bead4cff14afc6ef91fa29870abeb649d5b47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64bead4cff14afc6ef91fa29870abeb649d5b47b"}], "stats": {"total": 141, "additions": 43, "deletions": 98}, "files": [{"sha": "05441a9c37639cf09525ac7ce63b3517ee1dd75b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005e3e053fb770c9a471c22f4dba447b532fe701/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005e3e053fb770c9a471c22f4dba447b532fe701/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=005e3e053fb770c9a471c22f4dba447b532fe701", "patch": "@@ -1,3 +1,7 @@\n+2002-01-20  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/h8300/h8300.c: Revise comments about shift code.\n+\n 2002-01-20  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.c (function_arg): Update a comment."}, {"sha": "db12b64a31b008d9f6878a875ab7419da2c3c227", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 39, "deletions": 98, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005e3e053fb770c9a471c22f4dba447b532fe701/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005e3e053fb770c9a471c22f4dba447b532fe701/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=005e3e053fb770c9a471c22f4dba447b532fe701", "patch": "@@ -1669,53 +1669,42 @@ output_logical_op (mode, code, operands)\n \f\n /* Shifts.\n \n-   We devote a fair bit of code to getting efficient shifts since we can only\n-   shift one bit at a time on the H8/300 and H8/300H and only one or two\n-   bits at a time on the H8/S.\n-\n-   The basic shift methods:\n-\n-     * loop shifts -- emit a loop using one (or two on H8/S) bit shifts;\n-     this is the default.  SHIFT_LOOP\n-\n-     * inlined shifts -- emit straight line code for the shift; this is\n-     used when a straight line shift is about the same size or smaller\n-     than a loop.  We allow the inline version to be slightly longer in\n-     some cases as it saves a register.  SHIFT_INLINE\n-\n-     * rotate + and -- rotate the value the opposite direction, then\n-     mask off the values we don't need.  This is used when only a few\n-     of the bits in the original value will survive in the shifted value.\n-     Again, this is used when it's about the same size or smaller than\n-     a loop.  We allow this version to be slightly longer as it is usually\n-     much faster than a loop.  SHIFT_ROT_AND\n-\n-     * swap (+ shifts) -- often it's possible to swap bytes/words to\n-     simulate a shift by 8/16.  Once swapped a few inline shifts can be\n-     added if the shift count is slightly more than 8 or 16.  This is used\n-     when it's about the same size or smaller than a loop.  We allow this\n-     version to be slightly longer as it is usually much faster than a loop.\n-     SHIFT_SPECIAL\n-\n-     * There other oddballs.  Not worth explaining.  SHIFT_SPECIAL\n-\n-   Here are some thoughts on what the absolutely positively best code is.\n-   \"Best\" here means some rational trade-off between code size and speed,\n-   where speed is more preferred but not at the expense of generating 20 insns.\n-\n-   A trailing '*' after the shift count indicates the \"best\" mode isn't\n-   implemented.\n+   We devote a fair bit of code to getting efficient shifts since we\n+   can only shift one bit at a time on the H8/300 and H8/300H and only\n+   one or two bits at a time on the H8/S.\n+\n+   All shift code falls into one of the following ways of\n+   implementation:\n+\n+   o SHIFT_INLINE: Emit straight line code for the shift; this is used\n+     when a straight line shift is about the same size or smaller than\n+     a loop.\n+\n+   o SHIFT_ROT_AND: Rotate the value the opposite direction, then mask\n+     off the bits we don't need.  This is used when only a few of the\n+     bits in the original value will survive in the shifted value.\n+\n+   o SHIFT_SPECIAL: Often it's possible to move a byte or a word to\n+     simulate a shift by 8, 16, or 24 bits.  Once moved, a few inline\n+     shifts can be added if the shift count is slightly more than 8 or\n+     16.  This case also includes other oddballs that are not worth\n+     explaning here.\n+\n+   o SHIFT_LOOP: Emit a loop using one (or two on H8/S) bit shifts.\n+\n+   Here are some thoughts on what the absolutely positively best code\n+   is.  \"Best\" here means some rational trade-off between code size\n+   and speed, where speed is more preferred but not at the expense of\n+   generating 20 insns.\n+\n+   Below, a trailing '*' after the shift count indicates the \"best\"\n+   mode isn't implemented.  We only describe SHIFT_SPECIAL cases to\n+   simplify the table.  For other cases, refer to shift_alg_[qhs]i.\n    \n    H8/300 QImode shifts\n-   1-4    - do them inline\n-   5-6    - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-            ASHIFTRT: loop\n-   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n    H8/300 HImode shifts\n-   1-4    - do them inline\n-   5-6    - loop\n    7      - shift 2nd half other way into carry.\n \t    copy 1st half into 2nd half\n \t    rotate 2nd half other way with carry\n@@ -1724,63 +1713,38 @@ output_logical_op (mode, code, operands)\n \t    sign extend 1st half (ASHIFTRT)\n    8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n    9-12   - do shift by 8, inline remaining shifts\n-   13-14* - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n-          - ASHIFTRT: loop\n-   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n-          - ASHIFTRT: shll, subx, set other byte\n+   15     - ASHIFTRT: shll, subx, set other byte\n \n    H8/300 SImode shifts\n-   1-2    - do them inline\n-   3-6    - loop\n    7*     - shift other way once, move bytes into place,\n             move carry into place (possibly with sign extension)\n    8      - move bytes into place, zero or sign extend other\n-   9-14   - loop\n    15*    - shift other way once, move word into place, move carry into place\n    16     - move word, zero or sign extend other\n-   17-23  - loop\n    24*    - move bytes into place, zero or sign extend other\n-   25-27  - loop\n-   28-30* - ASHIFT | LSHIFTRT: rotate top byte, mask, move byte into place,\n-                               zero others\n-            ASHIFTRT: loop\n-   31     - ASHIFT | LSHIFTRT: rotate top byte, mask, move byte into place,\n-                               zero others\n-            ASHIFTRT: shll top byte, subx, copy to other bytes\n+   31     - ASHIFTRT: shll top byte, subx, copy to other bytes\n \n    H8/300H QImode shifts (same as H8/300 QImode shifts)\n-   1-4    - do them inline\n-   5-6    - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-            ASHIFTRT: loop\n-   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n    H8/300H HImode shifts\n-   1-4    - do them inline\n-   5-6    - loop\n    7      - shift 2nd half other way into carry.\n \t    copy 1st half into 2nd half\n \t    rotate entire word other way using carry\n \t    mask off remaining bits  (ASHIFT | LSHIFTRT)\n \t    sign extend remaining bits (ASHIFTRT)\n    8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n    9-12   - do shift by 8, inline remaining shifts\n-   13-14  - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n-          - ASHIFTRT: loop\n-   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n-          - ASHIFTRT: shll, subx, set other byte\n+   15     - ASHIFTRT: shll, subx, set other byte\n \n    H8/300H SImode shifts\n    (These are complicated by the fact that we don't have byte level access to\n    the top word.)\n    A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n-   1-4    - do them inline\n-   5-14   - loop\n    15*    - shift other way once, move word into place, move carry into place\n             (with sign extension for ASHIFTRT)\n    16     - move word into place, zero or sign extend other\n    17-20  - do 16bit shift, then inline remaining shifts\n-   20-23  - loop\n    24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n                     move word 0 to word 1, zero word 0\n             LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n@@ -1789,36 +1753,24 @@ output_logical_op (mode, code, operands)\n                       sign extend byte 0, sign extend word 0\n    25-27* - either loop, or\n             do 24 bit shift, inline rest\n-   28-30  - ASHIFT: rotate 4/3/2, mask\n-            LSHIFTRT: rotate 4/3/2, mask\n-            ASHIFTRT: loop\n    31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n \n    H8/S QImode shifts\n-   1-6    - do them inline\n-   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n    H8/S HImode shifts\n-   1-7\t  - do them inline\n    8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n    9-12   - do shift by 8, inline remaining shifts\n-   13-14  - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n-          - ASHIFTRT: loop\n-   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n-          - ASHIFTRT: shll, subx, set other byte\n+   15     - ASHIFTRT: shll, subx, set other byte\n \n    H8/S SImode shifts\n    (These are complicated by the fact that we don't have byte level access to\n    the top word.)\n    A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n-   1-10   - do them inline\n-   11-14  - loop\n    15*    - shift other way once, move word into place, move carry into place\n             (with sign extension for ASHIFTRT)\n    16     - move word into place, zero or sign extend other\n    17-20  - do 16bit shift, then inline remaining shifts\n-   21-23  - loop\n    24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n                     move word 0 to word 1, zero word 0\n             LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n@@ -1827,9 +1779,6 @@ output_logical_op (mode, code, operands)\n                       sign extend byte 0, sign extend word 0\n    25-27* - either loop, or\n             do 24 bit shift, inline rest\n-   28-30  - ASHIFT: rotate 4/3/2, mask\n-            LSHIFTRT: rotate 4/3/2, mask\n-            ASHIFTRT: loop\n    31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n \n    Panic!!!  */\n@@ -1878,15 +1827,7 @@ expand_a_shift (mode, code, operands)\n   return 1;\n }\n \n-/* Shift algorithm determination.\n-\n-   There are various ways of doing a shift:\n-   SHIFT_INLINE: If the amount is small enough, just generate as many one-bit\n-                 shifts as we need.\n-   SHIFT_ROT_AND: If the amount is large but close to either end, rotate the\n-                  necessary bits into position and then set the rest to zero.\n-   SHIFT_SPECIAL: Hand crafted assembler.\n-   SHIFT_LOOP:    If the above methods fail, just loop.  */\n+/* See above for explanation of this enum.  */\n \n enum shift_alg\n {"}]}