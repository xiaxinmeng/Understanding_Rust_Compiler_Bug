{"sha": "c0c123ef5222b0e12a5984640f0dd4db4ada569c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjMTIzZWY1MjIyYjBlMTJhNTk4NDY0MGYwZGQ0ZGI0YWRhNTY5Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-01T13:24:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-01T13:24:49Z"}, "message": "cgraph.c (cgraph_release_function_body): Use used_as_abstract_origin.\n\n\t* cgraph.c (cgraph_release_function_body): Use used_as_abstract_origin.\n\t(cgraph_release_function_body): Likewise.\n\t(cgraph_can_remove_if_no_direct_calls_p): Likewise.\n\t* cgraph.h (cgrpah_node): Rename abstract_and_needed\n\tto used_as_abstract_origin.\n\t* tree-inline-transfrom.c (can_remove_node_now_p_1): Do not remove\n\tsymbols used as abstract origins.\n\t* cgraphunit.c (analyze_functions): Update.\n\t* ipa.c (symtab_remove_unreachable_nodes): Recompute used_as_abstract_origin.\n\t* tree-inline.c (tree_function_versioning): Update\n\tused_as_abstract_origin; be ready for DECL_RESULT and DECL_ARGUMENTS to be\n\tNULL.\n\n\t* lto-symtab.c (lto_symtab_merge_symbols): Merge duplicated nodes for abstract functions.\n\t* cgraph.h (symtab_real_symbol_p): Abstract declarations are not real symbols.\n\nFrom-SVN: r201408", "tree": {"sha": "f96fc1c036664588c53ba5479a910145514f98f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f96fc1c036664588c53ba5479a910145514f98f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0c123ef5222b0e12a5984640f0dd4db4ada569c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c123ef5222b0e12a5984640f0dd4db4ada569c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c123ef5222b0e12a5984640f0dd4db4ada569c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c123ef5222b0e12a5984640f0dd4db4ada569c/comments", "author": null, "committer": null, "parents": [{"sha": "0cd1dd571b98da5eaf06a8af62df111c4e6a3b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd1dd571b98da5eaf06a8af62df111c4e6a3b60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd1dd571b98da5eaf06a8af62df111c4e6a3b60"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "19959d6f99a7ce1682d8bcf6e6cb93f3792c8a79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -1,3 +1,21 @@\n+2013-08-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_release_function_body): Use used_as_abstract_origin.\n+\t(cgraph_release_function_body): Likewise.\n+\t(cgraph_can_remove_if_no_direct_calls_p): Likewise.\n+\t* cgraph.h (cgrpah_node): Rename abstract_and_needed\n+\tto used_as_abstract_origin.\n+\t* tree-inline-transfrom.c (can_remove_node_now_p_1): Do not remove\n+\tsymbols used as abstract origins.\n+\t* cgraphunit.c (analyze_functions): Update.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Recompute used_as_abstract_origin.\n+\t* tree-inline.c (tree_function_versioning): Update\n+\tused_as_abstract_origin; be ready for DECL_RESULT and DECL_ARGUMENTS to be\n+\tNULL.\n+\n+\t* lto-symtab.c (lto_symtab_merge_symbols): Merge duplicated nodes for abstract functions.\n+\t* cgraph.h (symtab_real_symbol_p): Abstract declarations are not real symbols.\n+\n 2013-08-01  Jan Hubicka  <jh@suse.cz>\n \n \t* profile.c (compute_value_histograms): Fix thinko."}, {"sha": "5b3fb5abf908ad684662db8d5669a20048699e2b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -1316,15 +1316,15 @@ void\n cgraph_release_function_body (struct cgraph_node *node)\n {\n   node->ipa_transforms_to_apply.release ();\n-  if (!node->abstract_and_needed && cgraph_state != CGRAPH_STATE_PARSING)\n+  if (!node->used_as_abstract_origin && cgraph_state != CGRAPH_STATE_PARSING)\n     {\n       DECL_RESULT (node->symbol.decl) = NULL;\n       DECL_ARGUMENTS (node->symbol.decl) = NULL;\n     }\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n-  if (!node->abstract_and_needed && DECL_INITIAL (node->symbol.decl))\n+  if (!node->used_as_abstract_origin && DECL_INITIAL (node->symbol.decl))\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n   release_function_body (node->symbol.decl);\n }"}, {"sha": "99acb62984c5ce78032a624460e1db33fec57a0d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -303,7 +303,7 @@ struct GTY(()) cgraph_node {\n \n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n-  unsigned abstract_and_needed : 1;\n+  unsigned used_as_abstract_origin : 1;\n   /* Set once the function is lowered (i.e. its CFG is built).  */\n   unsigned lowered : 1;\n   /* Set once the function has been instantiated and its callee\n@@ -1347,13 +1347,13 @@ symtab_real_symbol_p (symtab_node node)\n {\n   struct cgraph_node *cnode;\n \n+  if (DECL_ABSTRACT (node->symbol.decl))\n+    return false;\n   if (!is_a <cgraph_node> (node))\n     return true;\n   cnode = cgraph (node);\n   if (cnode->global.inlined_to)\n     return false;\n-  if (cnode->abstract_and_needed)\n-    return false;\n   return true;\n }\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "de7bb93d2c37b2b535963935f290365e780b9a73", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -928,7 +928,7 @@ analyze_functions (void)\n \t\t{\n \t\t  struct cgraph_node *origin_node\n \t    \t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n-\t\t  origin_node->abstract_and_needed = true;\n+\t\t  origin_node->used_as_abstract_origin = true;\n \t\t}\n \t    }\n \t  else"}, {"sha": "5e666aee3871c7c4c7efc9e9fc1c68e212031cdf", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -87,6 +87,7 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n      the callgraph so references can point to it.  */\n   return (!node->symbol.address_taken\n \t  && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n+\t  && !node->used_as_abstract_origin\n \t  && cgraph_can_remove_if_no_direct_calls_p (node)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed."}, {"sha": "243bf205e026c29e01d6b44f784a17564570e72b", "filename": "gcc/ipa.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -234,20 +234,23 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n      This is mostly when they can be referenced externally.  Inline clones\n      are special since their declarations are shared with master clone and thus\n      cgraph_can_remove_if_no_direct_calls_and_refs_p should not be called on them.  */\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->global.inlined_to\n-\t&& !node->symbol.in_other_partition\n-\t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n-\t    /* Keep around virtual functions for possible devirtualization.  */\n-\t    || (before_inlining_p\n-\t\t&& DECL_VIRTUAL_P (node->symbol.decl))))\n-      {\n-        gcc_assert (!node->global.inlined_to);\n-\tpointer_set_insert (reachable, node);\n-\tenqueue_node ((symtab_node)node, &first, reachable);\n-      }\n-    else\n-      gcc_assert (!node->symbol.aux);\n+  FOR_EACH_FUNCTION (node)\n+    {\n+      node->used_as_abstract_origin = false;\n+      if (node->symbol.definition\n+\t  && !node->global.inlined_to\n+\t  && (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n+\t      /* Keep around virtual functions for possible devirtualization.  */\n+\t      || (before_inlining_p\n+\t\t  && DECL_VIRTUAL_P (node->symbol.decl))))\n+\t{\n+\t  gcc_assert (!node->global.inlined_to);\n+\t  pointer_set_insert (reachable, node);\n+\t  enqueue_node ((symtab_node)node, &first, reachable);\n+\t}\n+      else\n+\tgcc_assert (!node->symbol.aux);\n+     }\n \n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n@@ -272,6 +275,13 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \tnode->symbol.aux = (void *)2;\n       else\n \t{\n+\t  if (DECL_ABSTRACT_ORIGIN (node->symbol.decl))\n+\t    {\n+\t      struct cgraph_node *origin_node\n+\t      = cgraph_get_create_real_symbol_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n+\t      origin_node->used_as_abstract_origin = true;\n+\t      enqueue_node ((symtab_node) origin_node, &first, reachable);\n+\t    }\n \t  /* If any symbol in a comdat group is reachable, force\n \t     all other in the same comdat group to be also reachable.  */\n \t  if (node->symbol.same_comdat_group)"}, {"sha": "3f9c56de7334268e2291bdaeb3751b051e24a213", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -474,7 +474,6 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n   bp_pack_value (&bp, node->symbol.address_taken, 1);\n-  bp_pack_value (&bp, node->abstract_and_needed, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n \t\t && !DECL_EXTERNAL (node->symbol.decl)\n \t\t && !DECL_COMDAT (node->symbol.decl)\n@@ -889,7 +888,6 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->symbol.forced_by_abi = bp_unpack_value (bp, 1);\n   node->symbol.unique_name = bp_unpack_value (bp, 1);\n   node->symbol.address_taken = bp_unpack_value (bp, 1);\n-  node->abstract_and_needed = bp_unpack_value (bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n   node->symbol.analyzed = tag == LTO_symtab_analyzed_node;"}, {"sha": "9bebd09c832da50e19f04304821b0aaac55612e0", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -599,6 +599,13 @@ lto_symtab_merge_symbols (void)\n \t\t  && (cnode2 = cgraph_get_node (node->symbol.decl))\n \t\t  && cnode2 != cnode)\n \t\tlto_cgraph_replace_node (cnode2, cnode);\n+\n+\t      /* Abstract functions may have duplicated cgraph nodes attached;\n+\t\t remove them.  */\n+\t      else if (cnode && DECL_ABSTRACT (cnode->symbol.decl)\n+\t\t       && (cnode2 = cgraph_get_node (node->symbol.decl))\n+\t\t       && cnode2 != cnode)\n+\t\tcgraph_remove_node (cnode2);\n \t      symtab_insert_node_to_hashtable ((symtab_node)node);\n \t    }\n \t}"}, {"sha": "be3917a32e3b68cb39c1d092f4a1976838bf3749", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c123ef5222b0e12a5984640f0dd4db4ada569c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c0c123ef5222b0e12a5984640f0dd4db4ada569c", "patch": "@@ -5085,6 +5085,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   DECL_ARTIFICIAL (new_decl) = 1;\n   DECL_ABSTRACT_ORIGIN (new_decl) = DECL_ORIGIN (old_decl);\n+  if (DECL_ORIGIN (old_decl) == old_decl)\n+    old_version_node->used_as_abstract_origin = true;\n   DECL_FUNCTION_PERSONALITY (new_decl) = DECL_FUNCTION_PERSONALITY (old_decl);\n \n   /* Prepare the data structures for the tree copy.  */\n@@ -5122,6 +5124,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n     (DECL_STRUCT_FUNCTION (old_decl));\n+  DECL_RESULT (new_decl) = DECL_RESULT (old_decl);\n+  DECL_ARGUMENTS (new_decl) = DECL_ARGUMENTS (old_decl);\n   initialize_cfun (new_decl, old_decl,\n \t\t   old_entry_block->count);\n   DECL_STRUCT_FUNCTION (new_decl)->gimple_df->ipa_pta"}]}