{"sha": "2e60feb59198791c0a3b58838af26e6e5cd32677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU2MGZlYjU5MTk4NzkxYzBhM2I1ODgzOGFmMjZlNmU1Y2QzMjY3Nw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-14T16:47:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-14T16:47:32Z"}, "message": "[multiple changes]\n\n2017-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* doc/gnat_rm/implementation_defined_aspects.rst: Add documentation\n\tfor reverse iteration over formal containers.\n\t* gnat_rm.texi: Regenerate.\n\n2017-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_elab.adb (Ensure_Dynamic_Prior_Elaboration): Renamed to\n\tEnsure_Prior_Elaboration_Dynamic for consistency reasons.\n\t(Ensure_Static_Prior_Elaboration): Renamed to\n\tEnsure_Prior_Elaboration_Static for consistency reasons.\n\t(Info_Variable_Reference): Renamed to Info_Variable_Read in order to\n\treflect its new purpose.\n\t(Is_Initialized): New routine.\n\t(Is_Suitable_Variable_Reference): Renamed to Is_Suitable_Variable_Read\n\tin order to reflect its new purpose.\n\t(Is_Variable_Read): New routine.\n\t(Output_Variable_Reference): Renamed to Output_Variable_Read in order\n\tto reflect its new purpose.\n\t(Process_Variable_Assignment): This routine now acts as a top level\n\tdispatcher for variable assignments.\n\t(Process_Variable_Assignment_Ada): New routine.\n\t(Process_Variable_Assignment_SPARK): New routine.\n\t(Process_Variable_Reference): Renamed to Process_Variable_Read in order\n\tto reflects its new purpose. A reference to a variable is now suitable\n\tfor ABE processing only when it is a read. The logic in the routine now\n\treflects the latest SPARK elaboration rules.\n\n2017-10-14  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Modify condition that\n\ttriggers marking on formal subprograms.\n\n2017-10-14  Javier Miranda  <miranda@adacore.com>\n\n\t* checks.adb (Ensure_Valid): Do not skip adding the validity check on\n\trenamings of objects that come from the sources.\n\n2017-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* cstand.adb (Build_Float_Type): Move down Siz parameter, add Align\n\tparameter and set the alignment of the type to Align.\n\t(Copy_Float_Type): Adjust call to Build_Float_Type.\n\t(Register_Float_Type): Add pragma Unreferenced for Precision.  Adjust\n\tcall to Build_Float_Type and do not set RM_Size and Alignment.\n\nFrom-SVN: r253756", "tree": {"sha": "a2803d3e114202f43f862c4e7de524581b8f381c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2803d3e114202f43f862c4e7de524581b8f381c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e60feb59198791c0a3b58838af26e6e5cd32677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e60feb59198791c0a3b58838af26e6e5cd32677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e60feb59198791c0a3b58838af26e6e5cd32677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e60feb59198791c0a3b58838af26e6e5cd32677/comments", "author": null, "committer": null, "parents": [{"sha": "a0b0d710266ee06d1cd17fd16452aff9b614d62a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b0d710266ee06d1cd17fd16452aff9b614d62a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b0d710266ee06d1cd17fd16452aff9b614d62a"}], "stats": {"total": 757, "additions": 516, "deletions": 241}, "files": [{"sha": "5ffb2e428cd8190c88ef458ff766495d54c3d48c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -1,3 +1,50 @@\n+2017-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_aspects.rst: Add documentation\n+\tfor reverse iteration over formal containers.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2017-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_elab.adb (Ensure_Dynamic_Prior_Elaboration): Renamed to\n+\tEnsure_Prior_Elaboration_Dynamic for consistency reasons.\n+\t(Ensure_Static_Prior_Elaboration): Renamed to\n+\tEnsure_Prior_Elaboration_Static for consistency reasons.\n+\t(Info_Variable_Reference): Renamed to Info_Variable_Read in order to\n+\treflect its new purpose.\n+\t(Is_Initialized): New routine.\n+\t(Is_Suitable_Variable_Reference): Renamed to Is_Suitable_Variable_Read\n+\tin order to reflect its new purpose.\n+\t(Is_Variable_Read): New routine.\n+\t(Output_Variable_Reference): Renamed to Output_Variable_Read in order\n+\tto reflect its new purpose.\n+\t(Process_Variable_Assignment): This routine now acts as a top level\n+\tdispatcher for variable assignments.\n+\t(Process_Variable_Assignment_Ada): New routine.\n+\t(Process_Variable_Assignment_SPARK): New routine.\n+\t(Process_Variable_Reference): Renamed to Process_Variable_Read in order\n+\tto reflects its new purpose. A reference to a variable is now suitable\n+\tfor ABE processing only when it is a read. The logic in the routine now\n+\treflects the latest SPARK elaboration rules.\n+\n+2017-10-14  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Modify condition that\n+\ttriggers marking on formal subprograms.\n+\n+2017-10-14  Javier Miranda  <miranda@adacore.com>\n+\n+\t* checks.adb (Ensure_Valid): Do not skip adding the validity check on\n+\trenamings of objects that come from the sources.\n+\n+2017-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cstand.adb (Build_Float_Type): Move down Siz parameter, add Align\n+\tparameter and set the alignment of the type to Align.\n+\t(Copy_Float_Type): Adjust call to Build_Float_Type.\n+\t(Register_Float_Type): Add pragma Unreferenced for Precision.  Adjust\n+\tcall to Build_Float_Type and do not set RM_Size and Alignment.\n+\n 2017-10-14  Patrick Bernardi  <bernardi@adacore.com>\n \n \t* Makefile.rtl (GNATRTL_NONTASKING_OBJ): Add s-soliin to"}, {"sha": "b2c26ca4981fda382878bffd690d578cced8ef1b", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -5940,6 +5940,10 @@ package body Checks is\n       --  In addition, we force a check if Force_Validity_Checks is set\n \n       elsif not Comes_From_Source (Expr)\n+        and then not\n+          (Nkind (Expr) = N_Identifier\n+            and then Present (Renamed_Object (Entity (Expr)))\n+            and then Comes_From_Source (Renamed_Object (Entity (Expr))))\n         and then not Force_Validity_Checks\n         and then (Nkind (Expr) /= N_Unchecked_Type_Conversion\n                     or else Kill_Range_Check (Expr))"}, {"sha": "34617bbe3cc787ae107c4158b1397ad2e3a8de57", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -62,15 +62,22 @@ package body CStand is\n    -----------------------\n \n    procedure Build_Float_Type\n-     (E    : Entity_Id;\n-      Siz  : Int;\n-      Rep  : Float_Rep_Kind;\n-      Digs : Int);\n+     (E     : Entity_Id;\n+      Digs  : Int;\n+      Rep   : Float_Rep_Kind;\n+      Siz   : Int;\n+      Align : Int);\n    --  Procedure to build standard predefined float base type. The first\n-   --  parameter is the entity for the type, and the second parameter is the\n-   --  size in bits. The third parameter indicates the kind of representation\n-   --  to be used. The fourth parameter is the digits value. Each type\n+   --  parameter is the entity for the type. The second parameter is the\n+   --  digits value. The third parameter indicates the representation to\n+   --  be used for the type. The fourth parameter is the size in bits.\n+   --  The fifth parameter is the alignment in storage units. Each type\n    --  is added to the list of predefined floating point types.\n+   --\n+   --  Note that both RM_Size and Esize are set to the specified size, i.e.\n+   --  we do not set the RM_Size to the precision passed by the back end.\n+   --  This is consistent with the semantics of 'Size specified in the RM\n+   --  because we cannot pack components of the type tighter than this size.\n \n    procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Nat);\n    --  Procedure to build standard predefined signed integer subtype. The\n@@ -189,10 +196,11 @@ package body CStand is\n    ----------------------\n \n    procedure Build_Float_Type\n-     (E    : Entity_Id;\n-      Siz  : Int;\n-      Rep  : Float_Rep_Kind;\n-      Digs : Int)\n+     (E     : Entity_Id;\n+      Digs  : Int;\n+      Rep   : Float_Rep_Kind;\n+      Siz   : Int;\n+      Align : Int)\n    is\n    begin\n       Set_Type_Definition (Parent (E),\n@@ -201,10 +209,10 @@ package body CStand is\n \n       Set_Ekind                      (E, E_Floating_Point_Type);\n       Set_Etype                      (E, E);\n-      Set_Float_Rep (E, Rep);\n-      Init_Size                      (E, Siz);\n-      Set_Elem_Alignment             (E);\n       Init_Digits_Value              (E, Digs);\n+      Set_Float_Rep                  (E, Rep);\n+      Init_Size                      (E, Siz);\n+      Set_Alignment                  (E, UI_From_Int (Align));\n       Set_Float_Bounds               (E);\n       Set_Is_Frozen                  (E);\n       Set_Is_Public                  (E);\n@@ -295,8 +303,9 @@ package body CStand is\n \n    procedure Copy_Float_Type (To : Entity_Id; From : Entity_Id) is\n    begin\n-      Build_Float_Type (To, UI_To_Int (Esize (From)), Float_Rep (From),\n-                        UI_To_Int (Digits_Value (From)));\n+      Build_Float_Type\n+        (To, UI_To_Int (Digits_Value (From)), Float_Rep (From),\n+         UI_To_Int (Esize (From)), UI_To_Int (Alignment (From)));\n    end Copy_Float_Type;\n \n    ----------------------\n@@ -2065,15 +2074,17 @@ package body CStand is\n       Size      : Positive;\n       Alignment : Natural)\n    is\n+      pragma Unreferenced (Precision);\n+      --  See Build_Float_Type for the rationale\n+\n       Ent : constant Entity_Id := New_Standard_Entity;\n \n    begin\n       Set_Defining_Identifier (New_Node (N_Full_Type_Declaration, Stloc), Ent);\n       Make_Name (Ent, Name);\n       Set_Scope (Ent, Standard_Standard);\n-      Build_Float_Type (Ent, Int (Size), Float_Rep, Pos (Digs));\n-      Set_RM_Size (Ent, UI_From_Int (Int (Precision)));\n-      Set_Alignment (Ent, UI_From_Int (Int (Alignment / 8)));\n+      Build_Float_Type\n+        (Ent, Pos (Digs), Float_Rep, Int (Size), Int (Alignment / 8));\n \n       if No (Back_End_Float_Types) then\n          Back_End_Float_Types := New_Elmt_List;"}, {"sha": "c6018227b06eee280ba3b1eeaf7d26721424773e", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_aspects.rst", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -302,11 +302,15 @@ Aspect Iterable\n This aspect provides a light-weight mechanism for loops and quantified\n expressions over container types, without the overhead imposed by the tampering\n checks of standard Ada 2012 iterators. The value of the aspect is an aggregate\n-with four named components: ``First``, ``Next``, ``Has_Element``, and ``Element`` (the\n-last one being optional). When only 3 components are specified, only the\n-``for .. in`` form of iteration over cursors is available. When all 4 components\n-are specified, both this form and the ``for .. of`` form of iteration over\n-elements are available. The following is a typical example of use:\n+with six named components, or which the last three are optional: ``First``,\n+ ``Next``, ``Has_Element``,``Element``, ``Last``, and ``Previous``.\n+When only the first three components are specified, only the\n+``for .. in`` form of iteration over cursors is available. When ``Element``\n+is specified, both this form and the ``for .. of`` form of iteration over\n+elements are available. If the last two components are specified, reverse\n+iterations over the container can be specified (analogous to what can be done\n+over predefined containers that support the Reverse_Iterator interface).\n+The following is a typical example of use:\n \n .. code-block:: ada\n "}, {"sha": "b042e2be3e14f81b5dd87f5ec51c025407b55472", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Sep 29, 2017\n+GNAT Reference Manual , Oct 14, 2017\n \n AdaCore\n \n@@ -9413,11 +9413,20 @@ that it is separately controllable using pragma @code{Assertion_Policy}.\n This aspect provides a light-weight mechanism for loops and quantified\n expressions over container types, without the overhead imposed by the tampering\n checks of standard Ada 2012 iterators. The value of the aspect is an aggregate\n-with four named components: @code{First}, @code{Next}, @code{Has_Element}, and @code{Element} (the\n-last one being optional). When only 3 components are specified, only the\n-@code{for .. in} form of iteration over cursors is available. When all 4 components\n-are specified, both this form and the @code{for .. of} form of iteration over\n-elements are available. The following is a typical example of use:\n+with six named components, or which the last three are optional: @code{First},\n+\n+@quotation\n+\n+@code{Next}, @code{Has_Element},`@w{`}Element`@w{`}, @code{Last}, and @code{Previous}.\n+@end quotation\n+\n+When only the first three components are specified, only the\n+@code{for .. in} form of iteration over cursors is available. When @code{Element}\n+is specified, both this form and the @code{for .. of} form of iteration over\n+elements are available. If the last two components are specified, reverse\n+iterations over the container can be specified (analogous to what can be done\n+over predefined containers that support the Reverse_Iterator interface).\n+The following is a typical example of use:\n \n @example\n type List is private with"}, {"sha": "982b2221632265bc9cdf5e463fbde747069e9301", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -3644,19 +3644,16 @@ package body Sem_Ch8 is\n       --  and mark any use_package_clauses that affect the visibility of the\n       --  implicit generic actual.\n \n-      if From_Default (N)\n-        and then Is_Generic_Actual_Subprogram (New_S)\n-        and then Present (Alias (New_S))\n+      if Is_Generic_Actual_Subprogram (New_S)\n+        and then (Is_Intrinsic_Subprogram (New_S) or else From_Default (N))\n       then\n-         Mark_Use_Clauses (Alias (New_S));\n+         Mark_Use_Clauses (New_S);\n \n-      --  Check intrinsic operators used as generic actuals since they may\n-      --  make a use_type_clause effective.\n+         --  Handle overloaded subprograms\n \n-      elsif Is_Generic_Actual_Subprogram (New_S)\n-        and then Is_Intrinsic_Subprogram (New_S)\n-      then\n-         Mark_Use_Clauses (New_S);\n+         if Present (Alias (New_S)) then\n+            Mark_Use_Clauses (Alias (New_S));\n+         end if;\n       end if;\n    end Analyze_Subprogram_Renaming;\n "}, {"sha": "289e853143e5282ab0528815912319786e5cd719", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 404, "deletions": 201, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e60feb59198791c0a3b58838af26e6e5cd32677/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=2e60feb59198791c0a3b58838af26e6e5cd32677", "patch": "@@ -292,7 +292,7 @@ package body Sem_Elab is\n    --  |       |                                                            |\n    --  |       +--> Process_Variable_Assignment                             |\n    --  |       |                                                            |\n-   --  |       +--> Process_Variable_Reference                              |\n+   --  |       +--> Process_Variable_Read                                   |\n    --  |                                                                    |\n    --  +------------------------- Processing phase -------------------------+\n \n@@ -776,14 +776,6 @@ package body Sem_Elab is\n    --  message, otherwise it emits an error. If flag In_SPARK is set, then\n    --  string \" in SPARK\" is added to the end of the message.\n \n-   procedure Ensure_Dynamic_Prior_Elaboration\n-     (N        : Node_Id;\n-      Unit_Id  : Entity_Id;\n-      Prag_Nam : Name_Id);\n-   --  Guarantee the elaboration of unit Unit_Id with respect to the main unit\n-   --  by suggesting the use of Elaborate[_All] with name Prag_Nam. N denotes\n-   --  the related scenario.\n-\n    procedure Ensure_Prior_Elaboration\n      (N            : Node_Id;\n       Unit_Id      : Entity_Id;\n@@ -792,7 +784,15 @@ package body Sem_Elab is\n    --  N denotes the related scenario. Flag In_Task_Body should be set when the\n    --  need for elaboration is initiated from a task body.\n \n-   procedure Ensure_Static_Prior_Elaboration\n+   procedure Ensure_Prior_Elaboration_Dynamic\n+     (N        : Node_Id;\n+      Unit_Id  : Entity_Id;\n+      Prag_Nam : Name_Id);\n+   --  Guarantee the elaboration of unit Unit_Id with respect to the main unit\n+   --  by suggesting the use of Elaborate[_All] with name Prag_Nam. N denotes\n+   --  the related scenario.\n+\n+   procedure Ensure_Prior_Elaboration_Static\n      (N        : Node_Id;\n       Unit_Id  : Entity_Id;\n       Prag_Nam : Name_Id);\n@@ -808,6 +808,7 @@ package body Sem_Elab is\n      (Call      : Node_Id;\n       Target_Id : out Entity_Id;\n       Attrs     : out Call_Attributes);\n+   pragma Inline (Extract_Call_Attributes);\n    --  Obtain attributes Attrs associated with call Call. Target_Id is the\n    --  entity of the call target.\n \n@@ -828,6 +829,7 @@ package body Sem_Elab is\n       Inst_Id  : out Entity_Id;\n       Gen_Id   : out Entity_Id;\n       Attrs    : out Instantiation_Attributes);\n+   pragma Inline (Extract_Instantiation_Attributes);\n    --  Obtain attributes Attrs associated with expanded instantiation Exp_Inst.\n    --  Inst is the instantiation. Inst_Id is the entity of the instance. Gen_Id\n    --  is the entity of the generic unit being instantiated.\n@@ -841,13 +843,15 @@ package body Sem_Elab is\n    procedure Extract_Task_Attributes\n      (Typ   : Entity_Id;\n       Attrs : out Task_Attributes);\n+   pragma Inline (Extract_Task_Attributes);\n    --  Obtain attributes Attrs associated with task type Typ\n \n    procedure Extract_Variable_Reference_Attributes\n      (Ref    : Node_Id;\n       Var_Id : out Entity_Id;\n       Attrs  : out Variable_Attributes);\n-   --  Obtain attributes Attrs associated with reference Ref which mentions\n+   pragma Inline (Extract_Variable_Reference_Attributes);\n+   --  Obtain attributes Attrs associated with reference Ref that mentions\n    --  variable Var_Id.\n \n    function Find_Code_Unit (N : Node_Or_Entity_Id) return Entity_Id;\n@@ -908,6 +912,7 @@ package body Sem_Elab is\n    function In_External_Instance\n      (N           : Node_Id;\n       Target_Decl : Node_Id) return Boolean;\n+   pragma Inline (In_External_Instance);\n    --  Determine whether a target desctibed by its declaration Target_Decl\n    --  resides in a package instance which is external to scenario N.\n \n@@ -931,28 +936,30 @@ package body Sem_Elab is\n       In_SPARK  : Boolean);\n    --  Output information concerning call Call which invokes target Target_Id.\n    --  If flag Info_Msg is set, the routine emits an information message,\n-   --  otherwise it emits an error. If flag In_SPARK is set, then string \" in\n-   --  SPARK\" is added to the end of the message.\n+   --  otherwise it emits an error. If flag In_SPARK is set, then the string\n+   --  \" in SPARK\" is added to the end of the message.\n \n    procedure Info_Instantiation\n      (Inst     : Node_Id;\n       Gen_Id   : Entity_Id;\n       Info_Msg : Boolean;\n       In_SPARK : Boolean);\n+   pragma Inline (Info_Instantiation);\n    --  Output information concerning instantiation Inst which instantiates\n    --  generic unit Gen_Id. If flag Info_Msg is set, the routine emits an\n    --  information message, otherwise it emits an error. If flag In_SPARK\n    --  is set, then string \" in SPARK\" is added to the end of the message.\n \n-   procedure Info_Variable_Reference\n+   procedure Info_Variable_Read\n      (Ref      : Node_Id;\n       Var_Id   : Entity_Id;\n       Info_Msg : Boolean;\n       In_SPARK : Boolean);\n-   --  Output information concerning reference Ref which mentions variable\n-   --  Var_Id. If flag Info_Msg is set, the routine emits an information\n-   --  message, otherwise it emits an error. If flag In_SPARK is set, then\n-   --  string \" in SPARK\" is added to the end of the message.\n+   pragma Inline (Info_Variable_Read);\n+   --  Output information concerning reference Ref which reads variable Var_Id.\n+   --  If flag Info_Msg is set, the routine emits an information message,\n+   --  otherwise it emits an error. If flag In_SPARK is set, then string \" in\n+   --  SPARK\" is added to the end of the message.\n \n    function Insertion_Node (N : Node_Id; Ins_Nod : Node_Id) return Node_Id;\n    pragma Inline (Insertion_Node);\n@@ -1026,6 +1033,7 @@ package body Sem_Elab is\n      (N           : Node_Id;\n       Target_Decl : Node_Id;\n       Target_Body : Node_Id) return Boolean;\n+   pragma Inline (Is_Guaranteed_ABE);\n    --  Determine whether scenario N with a target described by its initial\n    --  declaration Target_Decl and body Target_Decl results in a guaranteed\n    --  ABE.\n@@ -1035,6 +1043,10 @@ package body Sem_Elab is\n    --  Determine whether arbitrary entity Id denotes internally generated\n    --  routine Initial_Condition.\n \n+   function Is_Initialized (Obj_Decl : Node_Id) return Boolean;\n+   pragma Inline (Is_Initialized);\n+   --  Determine whether object declaration Obj_Decl is initialized\n+\n    function Is_Invariant_Proc (Id : Entity_Id) return Boolean;\n    pragma Inline (Is_Invariant_Proc);\n    --  Determine whether arbitrary entity Id denotes an invariant procedure\n@@ -1139,10 +1151,10 @@ package body Sem_Elab is\n    --  Determine whether arbitrary node N denotes a suitable assignment for ABE\n    --  processing.\n \n-   function Is_Suitable_Variable_Reference (N : Node_Id) return Boolean;\n-   pragma Inline (Is_Suitable_Variable_Reference);\n-   --  Determine whether arbitrary node N is a suitable reference to a variable\n-   --  for ABE processing.\n+   function Is_Suitable_Variable_Read (N : Node_Id) return Boolean;\n+   pragma Inline (Is_Suitable_Variable_Read);\n+   --  Determine whether arbitrary node N is a suitable variable read for ABE\n+   --  processing.\n \n    function Is_Task_Entry (Id : Entity_Id) return Boolean;\n    pragma Inline (Is_Task_Entry);\n@@ -1234,7 +1246,7 @@ package body Sem_Elab is\n       Call_Attrs   : Call_Attributes;\n       Target_Id    : Entity_Id;\n       In_Task_Body : Boolean);\n-   --  Top level dispatcher for processing of calls. Perform ABE checks and\n+   --  Top-level dispatcher for processing of calls. Perform ABE checks and\n    --  diagnostics for call Call which invokes target Target_Id. Call_Attrs\n    --  are the attributes of the call. Flag In_Task_Body should be set when\n    --  the processing is initiated from a task body.\n@@ -1334,10 +1346,24 @@ package body Sem_Elab is\n    --  should be set when the processing is initiated from a task body.\n \n    procedure Process_Variable_Assignment (Asmt : Node_Id);\n-   --  Perform ABE checks and diagnostics for assignment statement Asmt\n-\n-   procedure Process_Variable_Reference (Ref : Node_Id);\n-   --  Perform ABE checks and diagnostics for variable reference Ref\n+   --  Top level dispatcher for processing of variable assignments. Perform ABE\n+   --  checks and diagnostics for assignment statement Asmt.\n+\n+   procedure Process_Variable_Assignment_Ada\n+     (Asmt   : Node_Id;\n+      Var_Id : Entity_Id);\n+   --  Perform ABE checks and diagnostics for assignment statement Asmt that\n+   --  updates the value of variable Var_Id using the Ada rules.\n+\n+   procedure Process_Variable_Assignment_SPARK\n+     (Asmt   : Node_Id;\n+      Var_Id : Entity_Id);\n+   --  Perform ABE checks and diagnostics for assignment statement Asmt that\n+   --  updates the value of variable Var_Id using the SPARK rules.\n+\n+   procedure Process_Variable_Read (Ref : Node_Id);\n+   --  Perform ABE checks and diagnostics for reference Ref that reads a\n+   --  variable.\n \n    procedure Push_Active_Scenario (N : Node_Id);\n    pragma Inline (Push_Active_Scenario);\n@@ -1359,6 +1385,7 @@ package body Sem_Elab is\n    --  should be set when the traversal is initiated from a task body.\n \n    procedure Update_Elaboration_Scenario (New_N : Node_Id; Old_N : Node_Id);\n+   pragma Inline (Update_Elaboration_Scenario);\n    --  Update all relevant internal data structures when scenario Old_N is\n    --  transformed into scenario New_N by Atree.Rewrite.\n \n@@ -1939,97 +1966,6 @@ package body Sem_Elab is\n       return Elaboration_Context_Index (Key mod Elaboration_Context_Max);\n    end Elaboration_Context_Hash;\n \n-   --------------------------------------\n-   -- Ensure_Dynamic_Prior_Elaboration --\n-   --------------------------------------\n-\n-   procedure Ensure_Dynamic_Prior_Elaboration\n-     (N        : Node_Id;\n-      Unit_Id  : Entity_Id;\n-      Prag_Nam : Name_Id)\n-   is\n-      procedure Info_Missing_Pragma;\n-      pragma Inline (Info_Missing_Pragma);\n-      --  Output information concerning missing Elaborate or Elaborate_All\n-      --  pragma with name Prag_Nam for scenario N which ensures the prior\n-      --  elaboration of Unit_Id.\n-\n-      -------------------------\n-      -- Info_Missing_Pragma --\n-      -------------------------\n-\n-      procedure Info_Missing_Pragma is\n-      begin\n-         --  Internal units are ignored as they cause unnecessary noise\n-\n-         if not In_Internal_Unit (Unit_Id) then\n-\n-            --  The name of the unit subjected to the elaboration pragma is\n-            --  fully qualified to improve the clarity of the info message.\n-\n-            Error_Msg_Name_1     := Prag_Nam;\n-            Error_Msg_Qual_Level := Nat'Last;\n-\n-            Error_Msg_NE (\"info: missing pragma % for unit &\", N, Unit_Id);\n-            Error_Msg_Qual_Level := 0;\n-         end if;\n-      end Info_Missing_Pragma;\n-\n-      --  Local variables\n-\n-      Elab_Attrs : Elaboration_Attributes;\n-      Level      : Enclosing_Level_Kind;\n-\n-   --  Start of processing for Ensure_Dynamic_Prior_Elaboration\n-\n-   begin\n-      Elab_Attrs := Elaboration_Context.Get (Unit_Id);\n-\n-      --  Nothing to do when the unit is guaranteed prior elaboration by means\n-      --  of a source Elaborate[_All] pragma.\n-\n-      if Present (Elab_Attrs.Source_Pragma) then\n-         return;\n-      end if;\n-\n-      --  Output extra information on a missing Elaborate[_All] pragma when\n-      --  switch -gnatel (info messages on implicit Elaborate[_All] pragmas\n-      --  is in effect.\n-\n-      if Elab_Info_Messages then\n-\n-         --  Performance note: parent traversal\n-\n-         Level := Find_Enclosing_Level (N);\n-\n-         --  Declaration level scenario\n-\n-         if (Is_Suitable_Call (N) or else Is_Suitable_Instantiation (N))\n-           and then Level = Declaration_Level\n-         then\n-            null;\n-\n-         --  Library level scenario\n-\n-         elsif Level in Library_Level then\n-            null;\n-\n-         --  Instantiation library level scenario\n-\n-         elsif Level = Instantiation then\n-            null;\n-\n-         --  Otherwise the scenario does not appear at the proper level and\n-         --  cannot possibly act as a top level scenario.\n-\n-         else\n-            return;\n-         end if;\n-\n-         Info_Missing_Pragma;\n-      end if;\n-   end Ensure_Dynamic_Prior_Elaboration;\n-\n    ------------------------------\n    -- Ensure_Prior_Elaboration --\n    ------------------------------\n@@ -2147,7 +2083,7 @@ package body Sem_Elab is\n       --  effect.\n \n       elsif Dynamic_Elaboration_Checks then\n-         Ensure_Dynamic_Prior_Elaboration\n+         Ensure_Prior_Elaboration_Dynamic\n            (N        => N,\n             Unit_Id  => Unit_Id,\n             Prag_Nam => Prag_Nam);\n@@ -2158,27 +2094,119 @@ package body Sem_Elab is\n       else\n          pragma Assert (Static_Elaboration_Checks);\n \n-         Ensure_Static_Prior_Elaboration\n+         Ensure_Prior_Elaboration_Static\n            (N        => N,\n             Unit_Id  => Unit_Id,\n             Prag_Nam => Prag_Nam);\n       end if;\n    end Ensure_Prior_Elaboration;\n \n+   --------------------------------------\n+   -- Ensure_Prior_Elaboration_Dynamic --\n+   --------------------------------------\n+\n+   procedure Ensure_Prior_Elaboration_Dynamic\n+     (N        : Node_Id;\n+      Unit_Id  : Entity_Id;\n+      Prag_Nam : Name_Id)\n+   is\n+      procedure Info_Missing_Pragma;\n+      pragma Inline (Info_Missing_Pragma);\n+      --  Output information concerning missing Elaborate or Elaborate_All\n+      --  pragma with name Prag_Nam for scenario N, which would ensure the\n+      --  prior elaboration of Unit_Id.\n+\n+      -------------------------\n+      -- Info_Missing_Pragma --\n+      -------------------------\n+\n+      procedure Info_Missing_Pragma is\n+      begin\n+         --  Internal units are ignored as they cause unnecessary noise\n+\n+         if not In_Internal_Unit (Unit_Id) then\n+\n+            --  The name of the unit subjected to the elaboration pragma is\n+            --  fully qualified to improve the clarity of the info message.\n+\n+            Error_Msg_Name_1     := Prag_Nam;\n+            Error_Msg_Qual_Level := Nat'Last;\n+\n+            Error_Msg_NE (\"info: missing pragma % for unit &\", N, Unit_Id);\n+            Error_Msg_Qual_Level := 0;\n+         end if;\n+      end Info_Missing_Pragma;\n+\n+      --  Local variables\n+\n+      Elab_Attrs : Elaboration_Attributes;\n+      Level      : Enclosing_Level_Kind;\n+\n+   --  Start of processing for Ensure_Prior_Elaboration_Dynamic\n+\n+   begin\n+      Elab_Attrs := Elaboration_Context.Get (Unit_Id);\n+\n+      --  Nothing to do when the unit is guaranteed prior elaboration by means\n+      --  of a source Elaborate[_All] pragma.\n+\n+      if Present (Elab_Attrs.Source_Pragma) then\n+         return;\n+      end if;\n+\n+      --  Output extra information on a missing Elaborate[_All] pragma when\n+      --  switch -gnatel (info messages on implicit Elaborate[_All] pragmas\n+      --  is in effect.\n+\n+      if Elab_Info_Messages then\n+\n+         --  Performance note: parent traversal\n+\n+         Level := Find_Enclosing_Level (N);\n+\n+         --  Declaration-level scenario\n+\n+         if (Is_Suitable_Call (N) or else Is_Suitable_Instantiation (N))\n+           and then Level = Declaration_Level\n+         then\n+            null;\n+\n+         --  Library-level scenario\n+\n+         elsif Level in Library_Level then\n+            null;\n+\n+         --  Instantiation library-level scenario\n+\n+         elsif Level = Instantiation then\n+            null;\n+\n+         --  Otherwise the scenario does not appear at the proper level and\n+         --  cannot possibly act as a top-level scenario.\n+\n+         else\n+            return;\n+         end if;\n+\n+         Info_Missing_Pragma;\n+      end if;\n+   end Ensure_Prior_Elaboration_Dynamic;\n+\n    -------------------------------------\n-   -- Ensure_Static_Prior_Elaboration --\n+   -- Ensure_Prior_Elaboration_Static --\n    -------------------------------------\n \n-   procedure Ensure_Static_Prior_Elaboration\n+   procedure Ensure_Prior_Elaboration_Static\n      (N        : Node_Id;\n       Unit_Id  : Entity_Id;\n       Prag_Nam : Name_Id)\n    is\n       function Find_With_Clause\n         (Items     : List_Id;\n          Withed_Id : Entity_Id) return Node_Id;\n-      --  Find a non-limited with clause in the list of context items Items\n-      --  which withs unit Withed_Id. Return Empty if no such clause is found.\n+      pragma Inline (Find_With_Clause);\n+      --  Find a nonlimited with clause in the list of context items Items\n+      --  that withs unit Withed_Id. Return Empty if no such clause is found.\n \n       procedure Info_Implicit_Pragma;\n       pragma Inline (Info_Implicit_Pragma);\n@@ -2253,7 +2281,7 @@ package body Sem_Elab is\n       Elab_Attrs : Elaboration_Attributes;\n       Items      : List_Id;\n \n-   --  Start of processing for Ensure_Static_Prior_Elaboration\n+   --  Start of processing for Ensure_Prior_Elaboration_Static\n \n    begin\n       Elab_Attrs := Elaboration_Context.Get (Unit_Id);\n@@ -2347,7 +2375,7 @@ package body Sem_Elab is\n       if Elab_Info_Messages then\n          Info_Implicit_Pragma;\n       end if;\n-   end Ensure_Static_Prior_Elaboration;\n+   end Ensure_Prior_Elaboration_Static;\n \n    -----------------------------\n    -- Extract_Assignment_Name --\n@@ -2921,7 +2949,7 @@ package body Sem_Elab is\n          Full_Context : Boolean);\n       --  Add unit Unit_Id to the elaboration context. Prag denotes the pragma\n       --  which prompted the inclusion of the unit to the elaboration context.\n-      --  If flag Full_Context is set, examine the non-limited clauses of unit\n+      --  If flag Full_Context is set, examine the nonlimited clauses of unit\n       --  Unit_Id and add each withed unit to the context.\n \n       procedure Find_Elaboration_Context (Comp_Unit : Node_Id);\n@@ -3018,7 +3046,7 @@ package body Sem_Elab is\n \n          if Full_Context then\n \n-            --  Process all non-limited with clauses found in the context of\n+            --  Process all nonlimited with clauses found in the context of\n             --  the current unit. Note that limited clauses do not impose an\n             --  elaboration order.\n \n@@ -4140,24 +4168,24 @@ package body Sem_Elab is\n          In_SPARK => In_SPARK);\n    end Info_Instantiation;\n \n-   -----------------------------\n-   -- Info_Variable_Reference --\n-   -----------------------------\n+   ------------------------\n+   -- Info_Variable_Read --\n+   ------------------------\n \n-   procedure Info_Variable_Reference\n+   procedure Info_Variable_Read\n      (Ref      : Node_Id;\n       Var_Id   : Entity_Id;\n       Info_Msg : Boolean;\n       In_SPARK : Boolean)\n    is\n    begin\n       Elab_Msg_NE\n-        (Msg      => \"reference to variable & during elaboration\",\n+        (Msg      => \"read of variable & during elaboration\",\n          N        => Ref,\n          Id       => Var_Id,\n          Info_Msg => Info_Msg,\n          In_SPARK => In_SPARK);\n-   end Info_Variable_Reference;\n+   end Info_Variable_Read;\n \n    --------------------\n    -- Insertion_Node --\n@@ -4642,6 +4670,18 @@ package body Sem_Elab is\n         Ekind (Id) = E_Procedure and then Is_Initial_Condition_Procedure (Id);\n    end Is_Initial_Condition_Proc;\n \n+   --------------------\n+   -- Is_Initialized --\n+   --------------------\n+\n+   function Is_Initialized (Obj_Decl : Node_Id) return Boolean is\n+   begin\n+      --  To qualify, the object declaration must have an expression\n+\n+      return\n+        Present (Expression (Obj_Decl)) or else Has_Init_Expression (Obj_Decl);\n+   end Is_Initialized;\n+\n    -----------------------\n    -- Is_Invariant_Proc --\n    -----------------------\n@@ -5102,7 +5142,7 @@ package body Sem_Elab is\n           or else Is_Suitable_Call (N)\n           or else Is_Suitable_Instantiation (N)\n           or else Is_Suitable_Variable_Assignment (N)\n-          or else Is_Suitable_Variable_Reference (N);\n+          or else Is_Suitable_Variable_Read (N);\n    end Is_Suitable_Scenario;\n \n    -------------------------------------\n@@ -5182,11 +5222,7 @@ package body Sem_Elab is\n       --  To qualify, the assignment must meet the following prerequisites:\n \n       return\n-\n-        --  The variable must be a source entity and susceptible to warnings\n-\n         Comes_From_Source (Var_Id)\n-          and then not Warnings_Off (Var_Id)\n \n           --  The variable must be declared in the spec of compilation unit U\n \n@@ -5196,29 +5232,23 @@ package body Sem_Elab is\n \n           and then Find_Enclosing_Level (Var_Decl) = Package_Spec\n \n-          --  The variable must lack initialization\n-\n-          and then not Has_Init_Expression (Var_Decl)\n-          and then No (Expression (Var_Decl))\n-\n           --  The assignment must occur in the body of compilation unit U\n \n           and then Nkind (N_Unit) = N_Package_Body\n           and then Present (Corresponding_Body (Var_Unit))\n-          and then Corresponding_Body (Var_Unit) = N_Unit_Id\n-\n-          --  The package spec must lack pragma Elaborate_Body\n-\n-          and then not Has_Pragma_Elaborate_Body (Var_Unit_Id);\n+          and then Corresponding_Body (Var_Unit) = N_Unit_Id;\n    end Is_Suitable_Variable_Assignment;\n \n-   ------------------------------------\n-   -- Is_Suitable_Variable_Reference --\n-   ------------------------------------\n+   -------------------------------\n+   -- Is_Suitable_Variable_Read --\n+   -------------------------------\n \n-   function Is_Suitable_Variable_Reference (N : Node_Id) return Boolean is\n+   function Is_Suitable_Variable_Read (N : Node_Id) return Boolean is\n       function In_Pragma (Nod : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node N appears within a pragma\n+      --  Determine whether arbitrary node Nod appears within a pragma\n+\n+      function Is_Variable_Read (Ref : Node_Id) return Boolean;\n+      --  Determine whether variable reference Ref constitutes a read\n \n       ---------------\n       -- In_Pragma --\n@@ -5245,12 +5275,88 @@ package body Sem_Elab is\n          return False;\n       end In_Pragma;\n \n+      ----------------------\n+      -- Is_Variable_Read --\n+      ----------------------\n+\n+      function Is_Variable_Read (Ref : Node_Id) return Boolean is\n+         function Is_Out_Actual (Call : Node_Id) return Boolean;\n+         --  Determine whether the corresponding formal of actual Ref which\n+         --  appears in call Call has mode OUT.\n+\n+         -------------------\n+         -- Is_Out_Actual --\n+         -------------------\n+\n+         function Is_Out_Actual (Call : Node_Id) return Boolean is\n+            Actual     : Node_Id;\n+            Call_Attrs : Call_Attributes;\n+            Formal     : Entity_Id;\n+            Target_Id  : Entity_Id;\n+\n+         begin\n+            Extract_Call_Attributes\n+              (Call      => Call,\n+               Target_Id => Target_Id,\n+               Attrs     => Call_Attrs);\n+\n+            --  Inspect the actual and formal parameters, trying to find the\n+            --  corresponding formal for Ref.\n+\n+            Actual := First_Actual (Call);\n+            Formal := First_Formal (Target_Id);\n+            while Present (Actual) and then Present (Formal) loop\n+               if Actual = Ref then\n+                  return Ekind (Formal) = E_Out_Parameter;\n+               end if;\n+\n+               Next_Actual (Actual);\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            return False;\n+         end Is_Out_Actual;\n+\n+         --  Local variables\n+\n+         Context : constant Node_Id := Parent (Ref);\n+\n+      --  Start of processing for Is_Variable_Read\n+\n+      begin\n+         --  The majority of variable references are reads, and they can appear\n+         --  in a great number of contexts. To determine whether a reference is\n+         --  a read, it is more practical to find out whether it is a write.\n+\n+         --  A reference is a write when appearing immediately on the left-hand\n+         --  side of an assignment.\n+\n+         if Nkind (Context) = N_Assignment_Statement\n+           and then Name (Context) = Ref\n+         then\n+            return False;\n+\n+         --  A reference is a write when it acts as an actual in a subprogram\n+         --  call and the corresponding formal has mode OUT.\n+\n+         elsif Nkind_In (Context, N_Function_Call,\n+                                  N_Procedure_Call_Statement)\n+           and then Is_Out_Actual (Context)\n+         then\n+            return False;\n+         end if;\n+\n+         --  Any other reference is a read\n+\n+         return True;\n+      end Is_Variable_Read;\n+\n       --  Local variables\n \n       Prag   : Node_Id;\n       Var_Id : Entity_Id;\n \n-   --  Start of processing for Is_Suitable_Variable_Reference\n+   --  Start of processing for Is_Suitable_Variable_Read\n \n    begin\n       --  This scenario is relevant only when the static model is in effect\n@@ -5262,8 +5368,7 @@ package body Sem_Elab is\n          return False;\n \n       --  Attributes and operator sumbols are not considered to be suitable\n-      --  references to variables even though they are part of predicate\n-      --  Is_Entity_Name.\n+      --  references even though they are part of predicate Is_Entity_Name.\n \n       elsif not Nkind_In (N, N_Expanded_Name, N_Identifier) then\n          return False;\n@@ -5303,14 +5408,18 @@ package body Sem_Elab is\n           and then Get_SPARK_Mode_From_Annotation (Prag) = On\n           and then Is_SPARK_Mode_On_Node (N)\n \n+          --  The reference must denote a variable read\n+\n+          and then Is_Variable_Read (N)\n+\n           --  The reference must not be considered when it appears in a pragma.\n           --  If the pragma has run-time semantics, then the reference will be\n           --  reconsidered once the pragma is expanded.\n \n           --  Performance note: parent traversal\n \n           and then not In_Pragma (N);\n-   end Is_Suitable_Variable_Reference;\n+   end Is_Suitable_Variable_Read;\n \n    -------------------\n    -- Is_Task_Entry --\n@@ -5485,8 +5594,8 @@ package body Sem_Elab is\n                Info_Msg => False,\n                In_SPARK => True);\n \n-         elsif Is_Suitable_Variable_Reference (N) then\n-            Info_Variable_Reference\n+         elsif Is_Suitable_Variable_Read (N) then\n+            Info_Variable_Read\n               (Ref      => N,\n                Var_Id   => Target_Id,\n                Info_Msg => False,\n@@ -5650,8 +5759,9 @@ package body Sem_Elab is\n       procedure Output_Variable_Assignment (N : Node_Id);\n       --  Emit a specific diagnostic message for assignment statement N\n \n-      procedure Output_Variable_Reference (N : Node_Id);\n-      --  Emit a specific diagnostic message for variable reference N\n+      procedure Output_Variable_Read (N : Node_Id);\n+      --  Emit a specific diagnostic message for reference N which reads a\n+      --  variable.\n \n       -------------------\n       -- Output_Access --\n@@ -5980,11 +6090,11 @@ package body Sem_Elab is\n          Error_Msg_NE (\"\\\\  variable & assigned #\", Error_Nod, Var_Id);\n       end Output_Variable_Assignment;\n \n-      -------------------------------\n-      -- Output_Variable_Reference --\n-      -------------------------------\n+      --------------------------\n+      -- Output_Variable_Read --\n+      --------------------------\n \n-      procedure Output_Variable_Reference (N : Node_Id) is\n+      procedure Output_Variable_Read (N : Node_Id) is\n          Dummy  : Variable_Attributes;\n          Var_Id : Entity_Id;\n \n@@ -5995,8 +6105,8 @@ package body Sem_Elab is\n             Attrs  => Dummy);\n \n          Error_Msg_Sloc := Sloc (N);\n-         Error_Msg_NE (\"\\\\  variable & referenced #\", Error_Nod, Var_Id);\n-      end Output_Variable_Reference;\n+         Error_Msg_NE (\"\\\\  variable & read #\", Error_Nod, Var_Id);\n+      end Output_Variable_Read;\n \n       --  Local variables\n \n@@ -6057,10 +6167,10 @@ package body Sem_Elab is\n          elsif Nkind (N) = N_Assignment_Statement then\n             Output_Variable_Assignment (N);\n \n-         --  Variable references\n+         --  Variable read\n \n-         elsif Is_Suitable_Variable_Reference (N) then\n-            Output_Variable_Reference (N);\n+         elsif Is_Suitable_Variable_Read (N) then\n+            Output_Variable_Read (N);\n \n          else\n             pragma Assert (False);\n@@ -7732,31 +7842,73 @@ package body Sem_Elab is\n    ---------------------------------\n \n    procedure Process_Variable_Assignment (Asmt : Node_Id) is\n-      Var_Id  : constant Entity_Id := Entity (Extract_Assignment_Name (Asmt));\n-      Spec_Id : Entity_Id;\n+      Var_Id : constant Entity_Id := Entity (Extract_Assignment_Name (Asmt));\n+      Prag   : constant Node_Id   := SPARK_Pragma (Var_Id);\n+\n+      SPARK_Rules_On : Boolean;\n+      --  This flag is set when the SPARK rules are in effect\n \n    begin\n+      --  The SPARK rules are in effect when both the assignment and the\n+      --  variable are subject to SPARK_Mode On.\n+\n+      SPARK_Rules_On :=\n+        Present (Prag)\n+          and then Get_SPARK_Mode_From_Annotation (Prag) = On\n+          and then Is_SPARK_Mode_On_Node (Asmt);\n+\n       --  Output relevant information when switch -gnatel (info messages on\n       --  implicit Elaborate[_All] pragmas) is in effect.\n \n       if Elab_Info_Messages then\n-         Error_Msg_NE\n-           (\"info: assignment to & during elaboration\", Asmt, Var_Id);\n+         Elab_Msg_NE\n+           (Msg      => \"assignment to & during elaboration\",\n+            N        => Asmt,\n+            Id       => Var_Id,\n+            Info_Msg => True,\n+            In_SPARK => SPARK_Rules_On);\n       end if;\n \n-      Spec_Id := Find_Top_Unit (Var_Id);\n+      --  The SPARK rules are in effect\n+\n+      if SPARK_Rules_On then\n+         Process_Variable_Assignment_SPARK\n+           (Asmt   => Asmt,\n+            Var_Id => Var_Id);\n \n-      --  Generate an implicit Elaborate_Body in the spec\n+      --  Otherwise the Ada rules are in effect\n \n-      Set_Elaborate_Body_Desirable (Spec_Id);\n+      else\n+         Process_Variable_Assignment_Ada\n+           (Asmt   => Asmt,\n+            Var_Id => Var_Id);\n+      end if;\n+   end Process_Variable_Assignment;\n \n-      --  No warning is emitted for internal uses. This behaviour parallels\n-      --  that of the old ABE mechanism.\n+   -------------------------------------\n+   -- Process_Variable_Assignment_Ada --\n+   -------------------------------------\n \n-      if GNAT_Mode then\n-         null;\n+   procedure Process_Variable_Assignment_Ada\n+     (Asmt   : Node_Id;\n+      Var_Id : Entity_Id)\n+   is\n+      Var_Decl : constant Node_Id   := Declaration_Node (Var_Id);\n+      Spec_Id  : constant Entity_Id := Find_Top_Unit (Var_Decl);\n+\n+   begin\n+      --  Emit a warning when an uninitialized variable declared in a package\n+      --  spec without a pragma Elaborate_Body is initialized by elaboration\n+      --  code within the corresponding body.\n+\n+      if not Warnings_Off (Var_Id)\n+        and then not Is_Initialized (Var_Decl)\n+        and then not Has_Pragma_Elaborate_Body (Spec_Id)\n+      then\n+         --  Generate an implicit Elaborate_Body in the spec\n+\n+         Set_Elaborate_Body_Desirable (Spec_Id);\n \n-      else\n          Error_Msg_NE\n            (\"??variable & can be accessed by clients before this \"\n             & \"initialization\", Asmt, Var_Id);\n@@ -7767,13 +7919,44 @@ package body Sem_Elab is\n \n          Output_Active_Scenarios (Asmt);\n       end if;\n-   end Process_Variable_Assignment;\n+   end Process_Variable_Assignment_Ada;\n \n-   --------------------------------\n-   -- Process_Variable_Reference --\n-   --------------------------------\n+   ---------------------------------------\n+   -- Process_Variable_Assignment_SPARK --\n+   ---------------------------------------\n+\n+   procedure Process_Variable_Assignment_SPARK\n+     (Asmt   : Node_Id;\n+      Var_Id : Entity_Id)\n+   is\n+      Var_Decl : constant Node_Id   := Declaration_Node (Var_Id);\n+      Spec_Id  : constant Entity_Id := Find_Top_Unit (Var_Decl);\n+\n+   begin\n+      --  Emit an error when an initialized variable declared in a package spec\n+      --  without pragma Elaborate_Body is further modified by elaboration code\n+      --  within the corresponding body.\n+\n+      if Is_Initialized (Var_Decl)\n+        and then not Has_Pragma_Elaborate_Body (Spec_Id)\n+      then\n+         Error_Msg_NE\n+           (\"variable & modified by elaboration code in package body\",\n+            Asmt, Var_Id);\n \n-   procedure Process_Variable_Reference (Ref : Node_Id) is\n+         Error_Msg_NE\n+           (\"\\add pragma \"\"Elaborate_Body\"\" to spec & to ensure full \"\n+            & \"initialization\", Asmt, Spec_Id);\n+\n+         Output_Active_Scenarios (Asmt);\n+      end if;\n+   end Process_Variable_Assignment_SPARK;\n+\n+   ---------------------------\n+   -- Process_Variable_Read --\n+   ---------------------------\n+\n+   procedure Process_Variable_Read (Ref : Node_Id) is\n       Var_Attrs : Variable_Attributes;\n       Var_Id    : Entity_Id;\n \n@@ -7788,22 +7971,42 @@ package body Sem_Elab is\n \n       if Elab_Info_Messages then\n          Elab_Msg_NE\n-           (Msg      => \"reference to variable & during elaboration\",\n+           (Msg      => \"read of variable & during elaboration\",\n             N        => Ref,\n             Id       => Var_Id,\n             Info_Msg => True,\n             In_SPARK => True);\n       end if;\n \n-      --  A source variable reference imposes an Elaborate_All requirement on\n-      --  the context of the main unit. Determine whethe the context has a\n-      --  pragma strong enough to meet the requirement.\n+      --  Nothing to do when the variable appears within the main unit because\n+      --  diagnostics on reads are relevant only for external variables.\n \n-      Meet_Elaboration_Requirement\n-        (N         => Ref,\n-         Target_Id => Var_Id,\n-         Req_Nam   => Name_Elaborate_All);\n-   end Process_Variable_Reference;\n+      if Is_Same_Unit (Var_Attrs.Unit_Id, Cunit_Entity (Main_Unit)) then\n+         null;\n+\n+      --  Nothing to do when the variable is already initialized. Note that the\n+      --  variable may be further modified by the external unit.\n+\n+      elsif Is_Initialized (Declaration_Node (Var_Id)) then\n+         null;\n+\n+      --  Nothing to do when the external unit guarantees the initialization of\n+      --  the variable by means of pragma Elaborate_Body.\n+\n+      elsif Has_Pragma_Elaborate_Body (Var_Attrs.Unit_Id) then\n+         null;\n+\n+      --  A variable read imposes an Elaborate requirement on the context of\n+      --  the main unit. Determine whether the context has a pragma strong\n+      --  enough to meet the requirement.\n+\n+      else\n+         Meet_Elaboration_Requirement\n+           (N         => Ref,\n+            Target_Id => Var_Id,\n+            Req_Nam   => Name_Elaborate);\n+      end if;\n+   end Process_Variable_Read;\n \n    --------------------------\n    -- Push_Active_Scenario --\n@@ -7874,10 +8077,10 @@ package body Sem_Elab is\n       elsif Is_Suitable_Variable_Assignment (N) then\n          Process_Variable_Assignment (N);\n \n-      --  Variable references\n+      --  Variable read\n \n-      elsif Is_Suitable_Variable_Reference (N) then\n-         Process_Variable_Reference (N);\n+      elsif Is_Suitable_Variable_Read (N) then\n+         Process_Variable_Read (N);\n       end if;\n \n       --  Remove the current scenario from the stack of active scenarios once\n@@ -7945,7 +8148,7 @@ package body Sem_Elab is\n \n       elsif Is_Suitable_Access (N)\n         or else Is_Suitable_Variable_Assignment (N)\n-        or else Is_Suitable_Variable_Reference (N)\n+        or else Is_Suitable_Variable_Read (N)\n       then\n          null;\n "}]}