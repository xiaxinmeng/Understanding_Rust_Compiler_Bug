{"sha": "6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1YjRiNjRkMjVhMzZmMDg1YWI5MGVmYzNkNTRjMDI1YTdmZmY0OQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-05-22T11:06:10Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-07-10T15:07:12Z"}, "message": "openacc: Adjust dynamic reference count semantics\n\nThis patch adjusts how dynamic reference counts work so that they match\nthe semantics of the source program more closely, instead of representing\n\"excess\" reference counts beyond those that represent pointers in the\ninternal libgomp splay-tree data structure. This allows some corner\ncases to be handled more gracefully.\n\n2020-07-10  Julian Brown  <julian@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\n\tlibgomp/\n\t* libgomp.h (struct splay_tree_key_s): Change virtual_refcount to\n\tdynamic_refcount.\n\t(struct gomp_device_descr): Remove GOMP_MAP_VARS_OPENACC_ENTER_DATA.\n\t* oacc-mem.c (acc_map_data): Substitute virtual_refcount for\n\tdynamic_refcount.\n\t(acc_unmap_data): Update comment.\n\t(goacc_map_var_existing, goacc_enter_datum): Adjust for\n\tdynamic_refcount semantics.\n\t(goacc_exit_datum_1, goacc_exit_datum): Re-add some error checking.\n\tAdjust for dynamic_refcount semantics.\n\t(goacc_enter_data_internal): Implement \"present\" case of dynamic\n\tmemory-map handling here.  Update \"non-present\" case for\n\tdynamic_refcount semantics.\n\t(goacc_exit_data_internal): Use goacc_exit_datum_1.\n\t* target.c (gomp_map_vars_internal): Remove\n\tGOMP_MAP_VARS_OPENACC_ENTER_DATA handling.  Update for dynamic_refcount\n\thandling.\n\t(gomp_unmap_vars_internal): Remove virtual_refcount handling.\n\t(gomp_load_image_to_device): Substitute dynamic_refcount for\n\tvirtual_refcount.\n\t* testsuite/libgomp.oacc-c-c++-common/pr92843-1.c: Remove XFAILs.\n\t* testsuite/libgomp.oacc-c-c++-common/refcounting-1.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/refcounting-2.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/struct-3-1-1.c: New test.\n\t* testsuite/libgomp.oacc-fortran/deep-copy-6.f90: Remove XFAILs and\n\ttrace output.\n\t* testsuite/libgomp.oacc-fortran/deep-copy-6-no_finalize.F90: Remove\n\ttrace output.\n\t* testsuite/libgomp.oacc-fortran/dynamic-incr-structural-1.f90: New\n\ttest.\n\t* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c:\n\tRemove stale comment.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-1.f90: Remove XFAILs.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-2.F90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-3-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/mdc-refcount-1-4-1.f90: Adjust XFAIL.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "eb93744a9e163ef2b457029fcad9ebf8f5f3dc55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb93744a9e163ef2b457029fcad9ebf8f5f3dc55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb7effde6f36b43d50c8cd7f86eaa05937da7205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7effde6f36b43d50c8cd7f86eaa05937da7205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7effde6f36b43d50c8cd7f86eaa05937da7205"}], "stats": {"total": 495, "additions": 316, "deletions": 179}, "files": [{"sha": "7b52ce7d5c23306141a29b45bac57788225fcfb1", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -1016,11 +1016,8 @@ struct splay_tree_key_s {\n   uintptr_t tgt_offset;\n   /* Reference count.  */\n   uintptr_t refcount;\n-  /* Reference counts beyond those that represent genuine references in the\n-     linked splay tree key/target memory structures, e.g. for multiple OpenACC\n-     \"present increment\" operations (via \"acc enter data\") referring to the same\n-     host-memory block.  */\n-  uintptr_t virtual_refcount;\n+  /* Dynamic reference count.  */\n+  uintptr_t dynamic_refcount;\n   struct splay_tree_aux *aux;\n };\n \n@@ -1153,7 +1150,6 @@ struct gomp_device_descr\n enum gomp_map_vars_kind\n {\n   GOMP_MAP_VARS_OPENACC,\n-  GOMP_MAP_VARS_OPENACC_ENTER_DATA,\n   GOMP_MAP_VARS_TARGET,\n   GOMP_MAP_VARS_DATA,\n   GOMP_MAP_VARS_ENTER_DATA"}, {"sha": "855cad84391192ba9fe65d019e87a58d9ce0665c", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 155, "deletions": 81, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -409,7 +409,7 @@ acc_map_data (void *h, void *d, size_t s)\n       splay_tree_key n = tgt->list[0].key;\n       assert (n);\n       assert (n->refcount == 1);\n-      assert (n->virtual_refcount == 0);\n+      assert (n->dynamic_refcount == 0);\n       /* Special reference counting behavior.  */\n       n->refcount = REFCOUNT_INFINITY;\n \n@@ -456,7 +456,7 @@ acc_unmap_data (void *h)\n \t\t  (void *) n->host_start, (int) host_size, (void *) h);\n     }\n   /* TODO This currently doesn't catch 'REFCOUNT_INFINITY' usage different from\n-     'acc_map_data'.  Maybe 'virtual_refcount' can be used for disambiguating\n+     'acc_map_data'.  Maybe 'dynamic_refcount' can be used for disambiguating\n      the different 'REFCOUNT_INFINITY' cases, or simply separate\n      'REFCOUNT_INFINITY' values per different usage ('REFCOUNT_ACC_MAP_DATA'\n      etc.)?  */\n@@ -520,10 +520,8 @@ goacc_map_var_existing (struct gomp_device_descr *acc_dev, void *hostaddr,\n \n   assert (n->refcount != REFCOUNT_LINK);\n   if (n->refcount != REFCOUNT_INFINITY)\n-    {\n-      n->refcount++;\n-      n->virtual_refcount++;\n-    }\n+    n->refcount++;\n+  n->dynamic_refcount++;\n \n   return d;\n }\n@@ -574,13 +572,14 @@ goacc_enter_datum (void **hostaddrs, size_t *sizes, void *kinds, int async)\n \n       struct target_mem_desc *tgt\n \t= gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes,\n-\t\t\t       kinds, true, GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n+\t\t\t       kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n       assert (tgt);\n       assert (tgt->list_count == 1);\n       n = tgt->list[0].key;\n       assert (n);\n       assert (n->refcount == 1);\n-      assert (n->virtual_refcount == 0);\n+      assert (n->dynamic_refcount == 0);\n+      n->dynamic_refcount++;\n \n       d = (void *) tgt->tgt_start;\n     }\n@@ -676,24 +675,30 @@ goacc_exit_datum_1 (struct gomp_device_descr *acc_dev, void *h, size_t s,\n \t\t  (void *) h, (int) s, (void *) n->host_start, (int) host_size);\n     }\n \n-  bool finalize = (kind == GOMP_MAP_DELETE\n-\t\t   || kind == GOMP_MAP_FORCE_FROM);\n+  bool finalize = (kind == GOMP_MAP_FORCE_FROM\n+\t\t   || kind == GOMP_MAP_DELETE\n+\t\t   || kind == GOMP_MAP_FORCE_DETACH);\n+\n+  assert (n->refcount != REFCOUNT_LINK);\n+  if (n->refcount != REFCOUNT_INFINITY\n+      && n->refcount < n->dynamic_refcount)\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"Dynamic reference counting assert fail\\n\");\n+    }\n \n   if (finalize)\n     {\n       if (n->refcount != REFCOUNT_INFINITY)\n-\tn->refcount -= n->virtual_refcount;\n-      n->virtual_refcount = 0;\n+\tn->refcount -= n->dynamic_refcount;\n+      n->dynamic_refcount = 0;\n     }\n-\n-  if (n->virtual_refcount > 0)\n+  else if (n->dynamic_refcount)\n     {\n       if (n->refcount != REFCOUNT_INFINITY)\n \tn->refcount--;\n-      n->virtual_refcount--;\n+      n->dynamic_refcount--;\n     }\n-  else if (n->refcount > 0 && n->refcount != REFCOUNT_INFINITY)\n-    n->refcount--;\n \n   if (n->refcount == 0)\n     {\n@@ -1068,18 +1073,144 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\t\t   void **hostaddrs, size_t *sizes,\n \t\t\t   unsigned short *kinds, goacc_aq aq)\n {\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   for (size_t i = 0; i < mapnum; i++)\n     {\n-      int group_last = find_group_last (i, mapnum, sizes, kinds);\n+      splay_tree_key n;\n+      size_t group_last = find_group_last (i, mapnum, sizes, kinds);\n+      bool struct_p = false;\n+      size_t size, groupnum = (group_last - i) + 1;\n+\n+      switch (kinds[i] & 0xff)\n+\t{\n+\tcase GOMP_MAP_STRUCT:\n+\t  {\n+\t    size = (uintptr_t) hostaddrs[group_last] + sizes[group_last]\n+\t\t   - (uintptr_t) hostaddrs[i];\n+\t    struct_p = true;\n+\t  }\n+\t  break;\n+\n+\tcase GOMP_MAP_ATTACH:\n+\t  size = sizeof (void *);\n+\t  break;\n+\n+\tdefault:\n+\t  size = sizes[i];\n+\t}\n \n-      gomp_map_vars_async (acc_dev, aq,\n-\t\t\t   (group_last - i) + 1,\n-\t\t\t   &hostaddrs[i], NULL,\n-\t\t\t   &sizes[i], &kinds[i], true,\n-\t\t\t   GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n+      n = lookup_host (acc_dev, hostaddrs[i], size);\n+\n+      if (n && struct_p)\n+\t{\n+\t  for (size_t j = i + 1; j <= group_last; j++)\n+\t    {\n+\t      struct splay_tree_key_s cur_node;\n+\t      cur_node.host_start = (uintptr_t) hostaddrs[j];\n+\t      cur_node.host_end = cur_node.host_start + sizes[j];\n+\t      splay_tree_key n2\n+\t\t= splay_tree_lookup (&acc_dev->mem_map, &cur_node);\n+\t      if (!n2\n+\t\t  || n2->tgt != n->tgt\n+\t\t  || n2->host_start - n->host_start\n+\t\t     != n2->tgt_offset - n->tgt_offset)\n+\t\t{\n+\t\t  gomp_mutex_unlock (&acc_dev->lock);\n+\t\t  gomp_fatal (\"Trying to map into device [%p..%p) structure \"\n+\t\t\t      \"element when other mapped elements from the \"\n+\t\t\t      \"same structure weren't mapped together with \"\n+\t\t\t      \"it\", (void *) cur_node.host_start,\n+\t\t\t      (void *) cur_node.host_end);\n+\t\t}\n+\t    }\n+\t  /* This is a special case because we must increment the refcount by\n+\t     the number of mapped struct elements, rather than by one.  */\n+\t  if (n->refcount != REFCOUNT_INFINITY)\n+\t    n->refcount += groupnum - 1;\n+\t  n->dynamic_refcount += groupnum - 1;\n+\t}\n+      else if (n && groupnum == 1)\n+\t{\n+\t  void *h = hostaddrs[i];\n+\t  size_t s = sizes[i];\n+\n+\t  /* A standalone attach clause.  */\n+\t  if ((kinds[i] & 0xff) == GOMP_MAP_ATTACH)\n+\t    gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n,\n+\t\t\t\t (uintptr_t) h, s, NULL);\n+\n+\t  goacc_map_var_existing (acc_dev, h, s, n);\n+\t}\n+      else if (n && groupnum > 1)\n+\t{\n+\t  assert (n->refcount != REFCOUNT_INFINITY\n+\t\t  && n->refcount != REFCOUNT_LINK);\n+\n+\t  for (size_t j = i + 1; j <= group_last; j++)\n+\t    if ((kinds[j] & 0xff) == GOMP_MAP_ATTACH)\n+\t      {\n+\t\tsplay_tree_key m\n+\t\t  = lookup_host (acc_dev, hostaddrs[j], sizeof (void *));\n+\t\tgomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, m,\n+\t\t\t\t     (uintptr_t) hostaddrs[j], sizes[j], NULL);\n+\t      }\n+\n+\t  bool processed = false;\n+\n+\t  struct target_mem_desc *tgt = n->tgt;\n+\t  for (size_t j = 0; j < tgt->list_count; j++)\n+\t    if (tgt->list[j].key == n)\n+\t      {\n+\t\t/* We are processing a group of mappings (e.g.\n+\t\t   [GOMP_MAP_TO, GOMP_MAP_TO_PSET, GOMP_MAP_POINTER]).\n+\t\t   Find the right group in the target_mem_desc's variable\n+\t\t   list, and increment the refcounts for each item in that\n+\t\t   group.  */\n+\t\tfor (size_t k = 0; k < groupnum; k++)\n+\t\t  if (j + k < tgt->list_count && tgt->list[j + k].key)\n+\t\t    {\n+\t\t      tgt->list[j + k].key->refcount++;\n+\t\t      tgt->list[j + k].key->dynamic_refcount++;\n+\t\t    }\n+\t\tprocessed = true;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (!processed)\n+\t    {\n+\t      gomp_mutex_unlock (&acc_dev->lock);\n+\t      gomp_fatal (\"dynamic refcount incrementing failed for \"\n+\t\t\t  \"pointer/pset\");\n+\t    }\n+\t}\n+      else if (hostaddrs[i])\n+\t{\n+\t  /* The data is not mapped already.  Map it now, unless the first\n+\t     member in the group has a NULL pointer (e.g. a non-present\n+\t     optional parameter).  */\n+\t  gomp_mutex_unlock (&acc_dev->lock);\n+\n+\t  struct target_mem_desc *tgt\n+\t    = gomp_map_vars_async (acc_dev, aq, groupnum, &hostaddrs[i], NULL,\n+\t\t\t\t   &sizes[i], &kinds[i], true,\n+\t\t\t\t   GOMP_MAP_VARS_ENTER_DATA);\n+\t  assert (tgt);\n+\n+\t  gomp_mutex_lock (&acc_dev->lock);\n+\n+\t  for (size_t j = 0; j < tgt->list_count; j++)\n+\t    {\n+\t      n = tgt->list[j].key;\n+\t      if (n)\n+\t\tn->dynamic_refcount++;\n+\t    }\n+\t}\n \n       i = group_last;\n     }\n+\n+  gomp_mutex_unlock (&acc_dev->lock);\n }\n \n /* Unmap variables for OpenACC \"exit data\".  */\n@@ -1128,21 +1259,11 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n   for (size_t i = 0; i < mapnum; ++i)\n     {\n       unsigned char kind = kinds[i] & 0xff;\n-      bool copyfrom = false;\n-      bool finalize = false;\n-\n-      if (kind == GOMP_MAP_FORCE_FROM\n-\t  || kind == GOMP_MAP_DELETE\n-\t  || kind == GOMP_MAP_FORCE_DETACH)\n-\tfinalize = true;\n \n       switch (kind)\n \t{\n \tcase GOMP_MAP_FROM:\n \tcase GOMP_MAP_FORCE_FROM:\n-\t  copyfrom = true;\n-\t  /* Fallthrough.  */\n-\n \tcase GOMP_MAP_TO_PSET:\n \tcase GOMP_MAP_POINTER:\n \tcase GOMP_MAP_DELETE:\n@@ -1166,54 +1287,7 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t    if (n == NULL)\n \t      continue;\n \n-\t    if (finalize)\n-\t      {\n-\t\tif (n->refcount != REFCOUNT_INFINITY)\n-\t\t  n->refcount -= n->virtual_refcount;\n-\t\tn->virtual_refcount = 0;\n-\t      }\n-\n-\t    if (n->virtual_refcount > 0)\n-\t      {\n-\t\tif (n->refcount != REFCOUNT_INFINITY)\n-\t\t  n->refcount--;\n-\t\tn->virtual_refcount--;\n-\t      }\n-\t    else if (n->refcount > 0 && n->refcount != REFCOUNT_INFINITY)\n-\t      n->refcount--;\n-\n-\t    if (n->refcount == 0)\n-\t      {\n-\t\tif (copyfrom)\n-\t\t  {\n-\t\t    void *d = (void *) (n->tgt->tgt_start + n->tgt_offset\n-\t\t\t\t\t+ cur_node.host_start - n->host_start);\n-\t\t    gomp_copy_dev2host (acc_dev, aq,\n-\t\t\t\t\t(void *) cur_node.host_start, d,\n-\t\t\t\t\tcur_node.host_end - cur_node.host_start);\n-\t\t  }\n-\n-\t\tif (aq)\n-\t\t  /* TODO We can't do the 'is_tgt_unmapped' checking -- see the\n-\t\t     'gomp_unref_tgt' comment in\n-\t\t     <http://mid.mail-archive.com/878snl36eu.fsf@euler.schwinge.homeip.net>;\n-\t\t     PR92881.  */\n-\t\t  gomp_remove_var_async (acc_dev, n, aq);\n-\t\telse\n-\t\t  {\n-\t\t    size_t num_mappings = 0;\n-\t\t    /* If the target_mem_desc represents a single data mapping,\n-\t\t       we can check that it is freed when this splay tree key's\n-\t\t       refcount reaches zero.  Otherwise (e.g. for a\n-\t\t       'GOMP_MAP_STRUCT' mapping with multiple members), fall\n-\t\t       back to skipping the test.  */\n-\t\t    for (size_t l_i = 0; l_i < n->tgt->list_count; ++l_i)\n-\t\t      if (n->tgt->list[l_i].key)\n-\t\t\t++num_mappings;\n-\t\t    bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n-\t\t    assert (is_tgt_unmapped || num_mappings > 1);\n-\t\t  }\n-\t      }\n+\t    goacc_exit_datum_1 (acc_dev, hostaddrs[i], size, kind, n, aq);\n \t  }\n \t  break;\n "}, {"sha": "d6b3572c8d88e649cefe005d7e7831c897397958", "filename": "libgomp/target.c", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -668,8 +668,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   struct target_mem_desc *tgt\n     = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n   tgt->list_count = mapnum;\n-  tgt->refcount = (pragma_kind == GOMP_MAP_VARS_ENTER_DATA\n-\t\t   || pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA) ? 0 : 1;\n+  tgt->refcount = pragma_kind == GOMP_MAP_VARS_ENTER_DATA ? 0 : 1;\n   tgt->device_descr = devicep;\n   tgt->prev = NULL;\n   struct gomp_coalesce_buf cbuf, *cbufp = NULL;\n@@ -1095,7 +1094,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t      tgt->list[i].copy_from = false;\n \t\t      tgt->list[i].always_copy_from = false;\n \t\t      tgt->list[i].do_detach\n-\t\t\t= (pragma_kind != GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n+\t\t\t= (pragma_kind != GOMP_MAP_VARS_ENTER_DATA);\n \t\t      n->refcount++;\n \t\t    }\n \t\t  else\n@@ -1156,7 +1155,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n \t\tk->refcount = 1;\n-\t\tk->virtual_refcount = 0;\n+\t\tk->dynamic_refcount = 0;\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n@@ -1295,20 +1294,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   /* If the variable from \"omp target enter data\" map-list was already mapped,\n      tgt is not needed.  Otherwise tgt will be freed by gomp_unmap_vars or\n      gomp_exit_data.  */\n-  if ((pragma_kind == GOMP_MAP_VARS_ENTER_DATA\n-       || pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA)\n-      && tgt->refcount == 0)\n-    {\n-      /* If we're about to discard a target_mem_desc with no \"structural\"\n-\t references (tgt->refcount == 0), any splay keys linked in the tgt's\n-\t list must have their virtual refcount incremented to represent that\n-\t \"lost\" reference in order to implement the semantics of the OpenACC\n-\t \"present increment\" operation properly.  */\n-      if (pragma_kind == GOMP_MAP_VARS_OPENACC_ENTER_DATA)\n-\tfor (i = 0; i < tgt->list_count; i++)\n-\t  if (tgt->list[i].key)\n-\t    tgt->list[i].key->virtual_refcount++;\n-\n+  if (pragma_kind == GOMP_MAP_VARS_ENTER_DATA && tgt->refcount == 0)\n+    {\n       free (tgt);\n       tgt = NULL;\n     }\n@@ -1460,14 +1447,7 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n \tcontinue;\n \n       bool do_unmap = false;\n-      if (k->tgt == tgt\n-\t  && k->virtual_refcount > 0\n-\t  && k->refcount != REFCOUNT_INFINITY)\n-\t{\n-\t  k->virtual_refcount--;\n-\t  k->refcount--;\n-\t}\n-      else if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n+      if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n \tk->refcount--;\n       else if (k->refcount == 1)\n \t{\n@@ -1632,7 +1612,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_table[i].start;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->virtual_refcount = 0;\n+      k->dynamic_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -1666,7 +1646,7 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt = tgt;\n       k->tgt_offset = target_var->start;\n       k->refcount = is_link_var ? REFCOUNT_LINK : REFCOUNT_INFINITY;\n-      k->virtual_refcount = 0;\n+      k->dynamic_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;\n@@ -2936,7 +2916,7 @@ omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,\n       k->tgt = tgt;\n       k->tgt_offset = (uintptr_t) device_ptr + device_offset;\n       k->refcount = REFCOUNT_INFINITY;\n-      k->virtual_refcount = 0;\n+      k->dynamic_refcount = 0;\n       k->aux = NULL;\n       array->left = NULL;\n       array->right = NULL;"}, {"sha": "db5b35b08d9f56b95eb8dae42d07141540f816b5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/pr92843-1.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fpr92843-1.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -4,7 +4,6 @@\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n \n #include <assert.h>\n-#include <stdio.h>\n #include <stdlib.h>\n #include <openacc.h>\n \n@@ -135,15 +134,7 @@ test_acc_data ()\n     assert (acc_is_present (h, sizeof h));\n \n     assign_array (h, N, c1);\n-    fprintf (stderr, \"CheCKpOInT1\\n\");\n-    // { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n     acc_copyout_finalize (h, sizeof h);\n-    //TODO     goacc_exit_datum: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-    //TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-    //TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-    //TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-    fprintf (stderr, \"CheCKpOInT2\\n\");\n-    // { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n     assert (acc_is_present (h, sizeof h));\n     verify_array (h, N, c1);\n "}, {"sha": "4e6d06d48d5c902a3334deae69ae87501b7d6f75", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/refcounting-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-1.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -0,0 +1,31 @@\n+/* Test dynamic unmapping of separate structure members.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include <assert.h>\n+#include <openacc.h>\n+\n+struct s\n+{\n+  char a;\n+  char b;\n+};\n+\n+int main ()\n+{\n+  struct s s;\n+\n+#pragma acc enter data create(s.a, s.b)\n+\n+  assert (acc_is_present (&s.a, sizeof s.a));\n+  assert (acc_is_present (&s.b, sizeof s.b));\n+\n+#pragma acc exit data delete(s.a)\n+#pragma acc exit data delete(s.b)\n+\n+  assert (!acc_is_present (&s.a, sizeof s.a));\n+  assert (!acc_is_present (&s.b, sizeof s.b));\n+\n+  return 0;\n+}\n+"}, {"sha": "5539fd8d57f305a2ca41e8f256249159f3016546", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/refcounting-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Frefcounting-2.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -0,0 +1,31 @@\n+/* Test dynamic unmapping of separate structure members.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include <assert.h>\n+#include <openacc.h>\n+\n+struct s\n+{\n+  char a;\n+  char b;\n+};\n+\n+int main ()\n+{\n+  struct s s;\n+\n+#pragma acc enter data create(s.a, s.b)\n+\n+  assert (acc_is_present (&s.a, sizeof s.a));\n+  assert (acc_is_present (&s.b, sizeof s.b));\n+\n+  acc_delete (&s.a, sizeof s.a);\n+  acc_delete (&s.b, sizeof s.b);\n+\n+  assert (!acc_is_present (&s.a, sizeof s.a));\n+  assert (!acc_is_present (&s.b, sizeof s.b));\n+\n+  return 0;\n+}\n+"}, {"sha": "a644ea9c26f389e872c2f576c9f6cabca8bdffb6", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/struct-3-1-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-3-1-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-3-1-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstruct-3-1-1.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -0,0 +1,34 @@\n+/* Test dynamic mapping of separate structure members.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <openacc.h>\n+\n+struct s\n+{\n+  char a;\n+  float b;\n+};\n+\n+int main ()\n+{\n+  struct s s;\n+\n+#pragma acc enter data create(s.a)\n+  assert (acc_is_present (&s.a, sizeof s.a));\n+\n+  fprintf (stderr, \"CheCKpOInT1\\n\");\n+  /* { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" } */\n+#pragma acc enter data create(s.b)\n+  /* { dg-output \"(\\n|\\r\\n|\\r)libgomp: Trying to map into device \\\\\\[\\[0-9a-fA-FxX.\\]+\\\\\\) structure element when other mapped elements from the same structure weren't mapped together with it(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+     { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n+     { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.  */\n+  fprintf (stderr, \"CheCKpOInT2\\n\");\n+  /* { dg-output \"CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } } */\n+  assert (acc_is_present (&s.b, sizeof s.b));\n+\n+  //TODO PR95236\n+  assert (acc_is_present (&s, sizeof s));\n+\n+  return 0;\n+}"}, {"sha": "09d2ad54e8781edcdb048e8378b4b68f59747fd7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstructured-dynamic-lifetimes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstructured-dynamic-lifetimes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fstructured-dynamic-lifetimes-4.c?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -13,8 +13,6 @@ main (int argc, char *argv[])\n   char *block2 = (char *) malloc (SIZE);\n   char *block3 = (char *) malloc (SIZE);\n \n-  /* Doing this twice ensures that we have a non-zero virtual refcount.  Make\n-     sure that works too.  */\n #ifdef OPENACC_API\n   acc_copyin (block1, SIZE);\n   acc_copyin (block1, SIZE);"}, {"sha": "038f04a3c37e46e5fb6c54f30a6e8502a0f29d28", "filename": "libgomp/testsuite/libgomp.oacc-fortran/deep-copy-6-no_finalize.F90", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n \n-/* Nullify the 'finalize' clause, which disturbs reference counting.  */\n+/* Nullify the 'finalize' clause.  */\n #define finalize\n #include \"deep-copy-6.f90\"\n-\n-! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" }"}, {"sha": "6aab6a4a763378473c5c7c3d0a26499acbc469a1", "filename": "libgomp/testsuite/libgomp.oacc-fortran/deep-copy-6.f90", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -40,15 +40,7 @@ program dtype\n   if (.not. acc_is_present(var%a(5:n - 5))) stop 11\n   if (.not. acc_is_present(var%b(5:n - 5))) stop 12\n   if (.not. acc_is_present(var)) stop 13\n-  print *, \"CheCKpOInT1\"\n-  ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n !$acc exit data copyout(var%a(5:n - 5), var%b(5:n - 5)) finalize\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-  !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-  !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-  print *, \"CheCKpOInT2\"\n-  ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n   if (acc_get_device_type() .ne. acc_device_host) then\n      if (acc_is_present(var%a(5:n - 5))) stop 21\n      if (acc_is_present(var%b(5:n - 5))) stop 22"}, {"sha": "6b17b1dbbc920ffc3f4405dcc30707944102d8a7", "filename": "libgomp/testsuite/libgomp.oacc-fortran/dynamic-incr-structural-1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-incr-structural-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-incr-structural-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-incr-structural-1.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n+\n+program map_multi\n+  use openacc\n+  implicit none\n+  integer, parameter :: n = 512\n+  integer, allocatable :: a(:), b(:), c(:)\n+\n+  allocate(a(1:n))\n+  allocate(b(1:n))\n+  allocate(c(1:n))\n+\n+  !$acc data copy(a, b, c)\n+\n+  ! These arrays have descriptors, so use multiple mappings.  Make sure those\n+  ! are matched up properly with the mappings in the enclosing data region.\n+  !$acc enter data copyin(a)\n+  !$acc enter data copyin(b)\n+  !$acc enter data copyin(c)\n+\n+  !$acc end data\n+\n+  if (.not.acc_is_present (a)) stop 1\n+  if (.not.acc_is_present (b)) stop 2\n+  if (.not.acc_is_present (c)) stop 3\n+\n+  !$acc exit data delete(a)\n+\n+  if (acc_is_present (a)) stop 4\n+  if (.not.acc_is_present (b)) stop 5\n+  if (.not.acc_is_present (c)) stop 6\n+\n+  !$acc exit data delete(b)\n+\n+  if (acc_is_present (a)) stop 7\n+  if (acc_is_present (b)) stop 8\n+  if (.not.acc_is_present (c)) stop 9\n+\n+  !$acc exit data delete(c)\n+\n+  if (acc_is_present (a)) stop 10\n+  if (acc_is_present (b)) stop 11\n+  if (acc_is_present (c)) stop 12\n+\n+  deallocate(a)\n+  deallocate(b)\n+  deallocate(c)\n+end program map_multi"}, {"sha": "1d97dd382d49b2a8a2c2f00260739f40a50f3fa0", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-1.f90", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-1.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -21,15 +21,7 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  print *, \"CheCKpOInT1\"\n-  ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n   !$acc exit data delete(var%a) finalize\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-  !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-  !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-  print *, \"CheCKpOInT2\"\n-  ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}, {"sha": "4307f50c46e97119826f7e441175e53bf5e15851", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-1-2.F90", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-1-2.F90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -1,9 +1,6 @@\n ! { dg-do run }\n ! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n \n-/* Nullify the 'finalize' clause, which disturbs reference counting.  */\n+/* Nullify the 'finalize' clause.  */\n #define finalize\n #include \"mdc-refcount-1-1-1.f90\"\n-\n-! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" }"}, {"sha": "e6f3f4afc3b89f340d53d054b9f9b60fbbb43e57", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-1.f90", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-1.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -23,15 +23,7 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  print *, \"CheCKpOInT1\"\n-  ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n   !$acc exit data delete(var%a) finalize\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-  !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-  !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-  print *, \"CheCKpOInT2\"\n-  ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}, {"sha": "78f54e64dcea6e62bcb0563c8d737d773bbf81ce", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-2-2.f90", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-2-2.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -23,15 +23,7 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n-  print *, \"CheCKpOInT1\"\n-  ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n   !$acc exit data delete(var%a)\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-  !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-  !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-  print *, \"CheCKpOInT2\"\n-  ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}, {"sha": "f9dcb485b2605e3154cd4fe8601bc7fcc29ef827", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-3-1.f90", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-3-1.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -24,15 +24,7 @@ program main\n   if (.not. acc_is_present(var)) stop 2\n \n   !$acc exit data detach(var%a)\n-  print *, \"CheCKpOInT1\"\n-  ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n   !$acc exit data delete(var%a) finalize\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-  !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-  !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n-  print *, \"CheCKpOInT2\"\n-  ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}, {"sha": "fbd52373946baffab1ce38536a57e9e6cb364a95", "filename": "libgomp/testsuite/libgomp.oacc-fortran/mdc-refcount-1-4-1.f90", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b4b64d25a36f085ab90efc3d54c025a7fff49/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fmdc-refcount-1-4-1.f90?ref=6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "patch": "@@ -23,16 +23,15 @@ program main\n   if (.not. acc_is_present(var%a)) stop 1\n   if (.not. acc_is_present(var)) stop 2\n \n+  !$acc exit data detach(var%a) finalize\n   print *, \"CheCKpOInT1\"\n   ! { dg-output \".*CheCKpOInT1(\\n|\\r\\n|\\r)\" }\n-  !$acc exit data detach(var%a) finalize\n-  !TODO     goacc_exit_data_internal: Assertion `is_tgt_unmapped || num_mappings > 1' failed.\n-  !TODO { dg-output \".*\\[Aa\\]ssert.*is_tgt_unmapped\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+  !$acc exit data delete(var%a)\n+  !TODO { dg-output \"(\\n|\\r\\n|\\r)libgomp: attach count underflow(\\n|\\r\\n|\\r)$\" { target { ! openacc_host_selected } } } ! Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n   !TODO { dg-shouldfail \"XFAILed\" { ! openacc_host_selected } } ! ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n   !TODO { dg-final { if { [dg-process-target { xfail { ! openacc_host_selected } }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } } ! ... so that we still get an XFAIL visible in the log.\n   print *, \"CheCKpOInT2\"\n   ! { dg-output \".CheCKpOInT2(\\n|\\r\\n|\\r)\" { target { openacc_host_selected } } }\n-  !$acc exit data delete(var%a)\n   if (acc_is_present(var%a)) stop 3\n   if (.not. acc_is_present(var)) stop 4\n "}]}