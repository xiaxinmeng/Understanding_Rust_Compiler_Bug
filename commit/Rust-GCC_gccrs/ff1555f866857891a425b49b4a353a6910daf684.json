{"sha": "ff1555f866857891a425b49b4a353a6910daf684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYxNTU1Zjg2Njg1Nzg5MWE0MjViNDliNGEzNTNhNjkxMGRhZjY4NA==", "commit": {"author": {"name": "Donn Terry", "email": "donn@interix.com", "date": "1999-04-14T18:53:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-14T18:53:02Z"}, "message": "lib1funcs.asm: New file.\n\n        * alpha/lib1funcs.asm: New file.\n        * alpha/t-interix(lib1funcs.asm): Add to build.\n\nFrom-SVN: r26459", "tree": {"sha": "f3befe13426c77cfa050c5175c50d2898ef88b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3befe13426c77cfa050c5175c50d2898ef88b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff1555f866857891a425b49b4a353a6910daf684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff1555f866857891a425b49b4a353a6910daf684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff1555f866857891a425b49b4a353a6910daf684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff1555f866857891a425b49b4a353a6910daf684/comments", "author": null, "committer": null, "parents": [{"sha": "2abed3c1ac55d0f925ef4e306f1b6e112d79408d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2abed3c1ac55d0f925ef4e306f1b6e112d79408d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2abed3c1ac55d0f925ef4e306f1b6e112d79408d"}], "stats": {"total": 334, "additions": 334, "deletions": 0}, "files": [{"sha": "427cce459f871a805e829b38b7a6f9837a71d779", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff1555f866857891a425b49b4a353a6910daf684/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff1555f866857891a425b49b4a353a6910daf684/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff1555f866857891a425b49b4a353a6910daf684", "patch": "@@ -1,5 +1,8 @@\n Wed Apr 14 19:42:02 1999  Donn Terry (donn@interix.com)\n \n+\t* alpha/lib1funcs.asm: New file.\n+\t* alpha/t-interix (lib1funcs.asm): Add to build.\n+\n \t* explow.c (allocate_dynamic_stack_space): Correctly convert TARGET\n \tto Pmode.\n "}, {"sha": "e63180ade916202565ccb6634aa139f6a3b7e724", "filename": "gcc/config/alpha/lib1funcs.asm", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff1555f866857891a425b49b4a353a6910daf684/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff1555f866857891a425b49b4a353a6910daf684/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flib1funcs.asm?ref=ff1555f866857891a425b49b4a353a6910daf684", "patch": "@@ -0,0 +1,325 @@\n+/* DEC Alpha division and remainder support.\n+   Copyright (C) 1994, 1999 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* This had to be written in assembler because the division functions \n+   use a non-standard calling convention. \n+\n+   This file provides an implementation of __divqu, __divq, __divlu, \n+   __divl, __remqu, __remq, __remlu and __reml.  CPP macros control\n+   the exact operation.\n+\n+   Operation performed: $27 := $24 o $25, clobber $28, return address to\n+   caller in $23, where o one of the operations.\n+\n+   The following macros need to be defined: \n+\n+\tSIZE, the number of bits, 32 or 64.\n+\n+\tTYPE, either UNSIGNED or SIGNED\n+\n+\tOPERATION, either DIVISION or REMAINDER\n+   \n+\tSPECIAL_CALLING_CONVENTION, 0 or 1.  It is useful for debugging to\n+\tdefine this to 0.  That removes the `__' prefix to make the function\n+\tname not collide with the existing libc.a names, and uses the\n+\tstandard Alpha procedure calling convention.\n+*/\n+\n+#ifndef SPECIAL_CALLING_CONVENTION\n+#define SPECIAL_CALLING_CONVENTION 1\n+#endif\n+\n+#ifdef L_divl\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __divl\n+#else\n+#define FUNCTION_NAME divl\n+#endif\n+#define SIZE 32\n+#define TYPE SIGNED\n+#define OPERATION DIVISION\n+#endif\n+\n+#ifdef L_divlu\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __divlu\n+#else\n+#define FUNCTION_NAME divlu\n+#endif\n+#define SIZE 32\n+#define TYPE UNSIGNED\n+#define OPERATION DIVISION\n+#endif\n+\n+#ifdef L_divq\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __divq\n+#else\n+#define FUNCTION_NAME divq\n+#endif\n+#define SIZE 64\n+#define TYPE SIGNED\n+#define OPERATION DIVISION\n+#endif\n+\n+#ifdef L_divqu\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __divqu\n+#else\n+#define FUNCTION_NAME divqu\n+#endif\n+#define SIZE 64\n+#define TYPE UNSIGNED\n+#define OPERATION DIVISION\n+#endif\n+\n+#ifdef L_reml\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __reml\n+#else\n+#define FUNCTION_NAME reml\n+#endif\n+#define SIZE 32\n+#define TYPE SIGNED\n+#define OPERATION REMAINDER\n+#endif\n+\n+#ifdef L_remlu\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __remlu\n+#else\n+#define FUNCTION_NAME remlu\n+#endif\n+#define SIZE 32\n+#define TYPE UNSIGNED\n+#define OPERATION REMAINDER\n+#endif\n+\n+#ifdef L_remq\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __remq\n+#else\n+#define FUNCTION_NAME remq\n+#endif\n+#define SIZE 64\n+#define TYPE SIGNED\n+#define OPERATION REMAINDER\n+#endif\n+\n+#ifdef L_remqu\n+#if SPECIAL_CALLING_CONVENTION\n+#define FUNCTION_NAME __remqu\n+#else\n+#define FUNCTION_NAME remqu\n+#endif\n+#define SIZE 64\n+#define TYPE UNSIGNED\n+#define OPERATION REMAINDER\n+#endif\n+\n+#define tmp0 $3\n+#define tmp1 $28\n+#define cnt $1\n+#define result_sign $2\n+\n+#if SPECIAL_CALLING_CONVENTION\n+#define N $24\n+#define D $25\n+#define Q RETREG\n+#define RETREG $27\n+#else\n+#define N $16\n+#define D $17\n+#define Q RETREG\n+#define RETREG $0\n+#endif\n+\n+/* Misc symbols to make alpha assembler easier to read.  */\n+#define zero $31\n+#define sp $30\n+\n+/* Symbols to make interface nicer.  */\n+#define UNSIGNED 0\n+#define SIGNED 1\n+#define DIVISION 0\n+#define REMAINDER 1\n+\n+\t.set noreorder\n+\t.set noat\n+.text\n+\t.align 3\n+\t.globl FUNCTION_NAME\n+\t.ent FUNCTION_NAME\n+FUNCTION_NAME:\n+\n+\t.frame\t$30,0,$26,0\n+\t.prologue 0\n+\n+/* Under the special calling convention, we have to preserve all register\n+   values but $23 and $28.  */\n+#if SPECIAL_CALLING_CONVENTION\n+\tlda\tsp,-64(sp)\n+#if OPERATION == DIVISION\n+\tstq\tN,0(sp)\n+#endif\n+\tstq\tD,8(sp)\n+\tstq\tcnt,16(sp)\n+\tstq\tresult_sign,24(sp)\n+\tstq\ttmp0,32(sp)\n+#endif\n+\n+/* If we are computing the remainder, move N to the register that is used\n+   for the return value, and redefine what register is used for N.  */\n+#if OPERATION == REMAINDER\n+\tbis\tN,N,RETREG\n+#undef N\n+#define N RETREG\n+#endif\n+\n+/* Perform conversion from 32 bit types to 64 bit types.  */\n+#if SIZE == 32\n+#if TYPE == SIGNED\n+\t/* If there are problems with the signed case, add these instructions.\n+\t   The caller should already have done this.\n+\taddl\tN,0,N\t\t# sign extend N\n+\taddl\tD,0,D\t\t# sign extend D\n+\t*/\n+#else /* UNSIGNED */\n+\tzap\tN,0xf0,N\t# zero extend N (caller required to sign extend)\n+\tzap\tD,0xf0,D\t# zero extend D\n+#endif\n+#endif\n+\n+/* Check for divide by zero.  */\n+\tbne\tD,$34\n+\tlda\t$16,-2(zero)\n+\tcall_pal 0xaa\n+$34:\n+\n+#if TYPE == SIGNED\n+#if OPERATION == DIVISION\n+\txor\tN,D,result_sign\n+#else\n+\tbis\tN,N,result_sign\n+#endif\n+/* Get the absolute values of N and D.  */\n+\tsubq\tzero,N,tmp0\n+\tcmovlt\tN,tmp0,N\n+\tsubq\tzero,D,tmp0\n+\tcmovlt\tD,tmp0,D\n+#endif\n+\n+/* Compute CNT = ceil(log2(N)) - ceil(log2(D)).  This is the number of\n+   divide iterations we will have to perform.  Should you wish to optimize\n+   this, check a few bits at a time, preferably using zap/zapnot.  Be\n+   careful though, this code runs fast fro the most common cases, when the\n+   quotient is small.  */\n+\tbge\tN,$35\n+\tbis\tzero,1,cnt\n+\tblt\tD,$40\n+\t.align\t3\n+$39:\taddq\tD,D,D\n+\taddl\tcnt,1,cnt\n+\tbge\tD,$39\n+\tbr\tzero,$40\n+$35:\tcmpult\tN,D,tmp0\n+\tbis\tzero,zero,cnt\n+\tbne\ttmp0,$42\n+\t.align\t3\n+$44:\taddq\tD,D,D\n+\tcmpult\tN,D,tmp0\n+\taddl\tcnt,1,cnt\n+\tbeq\ttmp0,$44\n+$42:\tsrl\tD,1,D\n+$40:\n+\tsubl\tcnt,1,cnt\n+\n+\n+/* Actual divide.  Could be optimized with unrolling.  */\n+#if OPERATION == DIVISION\n+\tbis\tzero,zero,Q\n+#endif\n+\tblt\tcnt,$46\n+\t.align\t3\n+$49:\tcmpule\tD,N,tmp1\n+\tsubq\tN,D,tmp0\n+\tsrl\tD,1,D\n+\tsubl\tcnt,1,cnt\n+\tcmovne\ttmp1,tmp0,N\n+#if OPERATION == DIVISION\n+\taddq\tQ,Q,Q\n+\tbis\tQ,tmp1,Q\n+#endif\n+\tbge\tcnt,$49\n+$46:\n+\n+\n+/* The result is now in RETREG.  NOTE!  It was written to RETREG using\n+   either N or Q as a synonym!  */\n+\n+\n+/* Change the sign of the result as needed.  */\n+#if TYPE == SIGNED\n+\tsubq\tzero,RETREG,tmp0\n+\tcmovlt\tresult_sign,tmp0,RETREG\n+#endif\n+\n+\n+/* Restore clobbered registers.  */\n+#if SPECIAL_CALLING_CONVENTION\n+#if OPERATION == DIVISION\n+\tldq\tN,0(sp)\n+#endif\n+\tldq\tD,8(sp)\n+\tldq\tcnt,16(sp)\n+\tldq\tresult_sign,24(sp)\n+\tldq\ttmp0,32(sp)\n+\n+\tlda\tsp,64(sp)\n+#endif\n+\n+\n+/* Sign extend an *unsigned* 32 bit result, as required by the Alpha\n+   conventions.  */\n+#if TYPE == UNSIGNED && SIZE == 32\n+\t/* This could be avoided by adding some CPP hair to the divide loop.\n+\t   It is probably not worth the added complexity.    */\n+\taddl\tRETREG,0,RETREG\n+#endif\n+\n+\n+#if SPECIAL_CALLING_CONVENTION\n+\tret\tzero,($23),1\n+#else\n+\tret\tzero,($26),1\n+#endif\n+\t.end\tFUNCTION_NAME"}, {"sha": "d6d80e9c085ec98e414e09a68e1dc5740ecb17bb", "filename": "gcc/config/alpha/t-interix", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff1555f866857891a425b49b4a353a6910daf684/gcc%2Fconfig%2Falpha%2Ft-interix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff1555f866857891a425b49b4a353a6910daf684/gcc%2Fconfig%2Falpha%2Ft-interix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-interix?ref=ff1555f866857891a425b49b4a353a6910daf684", "patch": "@@ -8,3 +8,9 @@ USER_H=$(LANG_EXTRA_HEADERS)\n INSTALL_ASSERT_H=\n \n \n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIBGCC1 = libgcc1-asm.a\n+\n+LIB1ASMSRC = alpha/lib1funcs.asm\n+LIB1ASMFUNCS = _divqu _divq _divlu _divl _remqu _remq _remlu _reml"}]}