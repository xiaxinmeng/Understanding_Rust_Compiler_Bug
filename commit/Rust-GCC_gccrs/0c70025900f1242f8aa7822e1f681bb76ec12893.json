{"sha": "0c70025900f1242f8aa7822e1f681bb76ec12893", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM3MDAyNTkwMGYxMjQyZjhhYTc4MjJlMWY2ODFiYjc2ZWMxMjg5Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-10-10T11:26:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-10T11:26:16Z"}, "message": "ada-tree.h (DECL_BY_DOUBLE_REF_P): New macro.\n\n\t* gcc-interface/ada-tree.h (DECL_BY_DOUBLE_REF_P): New macro.\n\t* gcc-interface/gigi.h (annotate_object): Add BY_DOUBLE_REF parameter.\n\t* gcc-interface/decl.c (annotate_object): Likewise and handle it.\n\t(gnat_to_gnu_entity): Adjust calls to annotate_object.\n\t(gnat_to_gnu_param): If fat pointer types are passed by reference on\n\tthe target, pass them by explicit reference.\n\t* gcc-interface/misc.c (default_pass_by_ref): Fix type of constant.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Do DECL_BY_DOUBLE_REF_P.\n\t(Subprogram_Body_to_gnu): Adjust call to annotate_object.\n\t(call_to_gnu): Handle DECL_BY_DOUBLE_REF_P.\n\t* gcc-interface/utils.c (convert_vms_descriptor): Add BY_REF parameter\n\tand handle it.\n\t(build_function_stub): Iterate on the parameters of the subprogram in\n\tlieu of on the argument types.  Adjust call to convert_vms_descriptor.\n\nFrom-SVN: r165250", "tree": {"sha": "9c1accfcc79570d6e07d2005ef040f4da7a9db32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c1accfcc79570d6e07d2005ef040f4da7a9db32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c70025900f1242f8aa7822e1f681bb76ec12893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c70025900f1242f8aa7822e1f681bb76ec12893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c70025900f1242f8aa7822e1f681bb76ec12893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c70025900f1242f8aa7822e1f681bb76ec12893/comments", "author": null, "committer": null, "parents": [{"sha": "2461ab4bb799e914f519d800592e49624b01f822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2461ab4bb799e914f519d800592e49624b01f822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2461ab4bb799e914f519d800592e49624b01f822"}], "stats": {"total": 139, "additions": 107, "deletions": 32}, "files": [{"sha": "31316e20c9185ed2cf9183259db5f1263ce87c79", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -1,3 +1,20 @@\n+2010-10-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_BY_DOUBLE_REF_P): New macro.\n+\t* gcc-interface/gigi.h (annotate_object): Add BY_DOUBLE_REF parameter.\n+\t* gcc-interface/decl.c (annotate_object): Likewise and handle it.\n+\t(gnat_to_gnu_entity): Adjust calls to annotate_object.\n+\t(gnat_to_gnu_param): If fat pointer types are passed by reference on\n+\tthe target, pass them by explicit reference.\n+\t* gcc-interface/misc.c (default_pass_by_ref): Fix type of constant.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Do DECL_BY_DOUBLE_REF_P.\n+\t(Subprogram_Body_to_gnu): Adjust call to annotate_object.\n+\t(call_to_gnu): Handle DECL_BY_DOUBLE_REF_P.\n+\t* gcc-interface/utils.c (convert_vms_descriptor): Add BY_REF parameter\n+\tand handle it.\n+\t(build_function_stub): Iterate on the parameters of the subprogram in\n+\tlieu of on the argument types.  Adjust call to convert_vms_descriptor.\n+\n 2010-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c: Delete prototypes."}, {"sha": "9002fa1c7b9704c6804f7acf91339b0fc73c04cb", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -332,22 +332,26 @@ do {\t\t\t\t\t\t   \\\n    constant CONSTRUCTOR.  */\n #define DECL_CONST_ADDRESS_P(NODE) DECL_LANG_FLAG_0 (CONST_DECL_CHECK (NODE))\n \n-/* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n+/* Nonzero in a PARM_DECL if it is always used by double reference, i.e. a\n+   pair of INDIRECT_REFs is needed to access the object.  */\n+#define DECL_BY_DOUBLE_REF_P(NODE) DECL_LANG_FLAG_0 (PARM_DECL_CHECK (NODE))\n+\n+/* Nonzero in a DECL if it is always used by reference, i.e. an INDIRECT_REF\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n \n /* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n #define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n \n-/* Nonzero if this decl is a PARM_DECL for an Ada array being passed to a\n+/* Nonzero in a PARM_DECL if it is made for an Ada array being passed to a\n    foreign convention subprogram.  */\n #define DECL_BY_COMPONENT_PTR_P(NODE) DECL_LANG_FLAG_3 (PARM_DECL_CHECK (NODE))\n \n /* Nonzero in a FUNCTION_DECL that corresponds to an elaboration procedure.  */\n #define DECL_ELABORATION_PROC_P(NODE) \\\n   DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))\n \n-/* Nonzero if this is a decl for a pointer that points to something which\n+/* Nonzero in a DECL if it is made for a pointer that points to something which\n    is readonly.  Used mostly for fat pointers.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n "}, {"sha": "98ca932fb35f27af42092334837ef508cabc73f7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -972,7 +972,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n \t\t\tsaved = true;\n \t\t\tannotate_object (gnat_entity, gnu_type, NULL_TREE,\n-\t\t\t\t\t false);\n+\t\t\t\t\t false, false);\n \t\t\tbreak;\n \t\t      }\n \n@@ -1471,7 +1471,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   type of the object and not on the object directly, and makes it\n \t   possible to support all confirming representation clauses.  */\n \tannotate_object (gnat_entity, TREE_TYPE (gnu_decl), gnu_object_size,\n-\t\t\t used_by_ref);\n+\t\t\t used_by_ref, false);\n       }\n       break;\n \n@@ -5282,7 +5282,8 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   bool in_param = (Ekind (gnat_param) == E_In_Parameter);\n   /* The parameter can be indirectly modified if its address is taken.  */\n   bool ro_param = in_param && !Address_Taken (gnat_param);\n-  bool by_return = false, by_component_ptr = false, by_ref = false;\n+  bool by_return = false, by_component_ptr = false;\n+  bool by_ref = false, by_double_ref = false;\n   tree gnu_param;\n \n   /* Copy-return is used only for the first parameter of a valued procedure.\n@@ -5399,6 +5400,19 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n     {\n       gnu_param_type = build_reference_type (gnu_param_type);\n       by_ref = true;\n+\n+      /* In some ABIs, e.g. SPARC 32-bit, fat pointer types are themselves\n+\t passed by reference.  Pass them by explicit reference, this will\n+\t generate more debuggable code at -O0.  */\n+      if (TYPE_IS_FAT_POINTER_P (gnu_param_type)\n+\t  && targetm.calls.pass_by_reference (NULL,\n+\t\t\t\t\t      TYPE_MODE (gnu_param_type),\n+\t\t\t\t\t      gnu_param_type,\n+\t\t\t\t\t      true))\n+\t{\n+\t   gnu_param_type = build_reference_type (gnu_param_type);\n+\t   by_double_ref = true;\n+\t}\n     }\n \n   /* Pass In Out or Out parameters using copy-in copy-out mechanism.  */\n@@ -5441,6 +5455,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   gnu_param = create_param_decl (gnu_param_name, gnu_param_type,\n \t\t\t\t ro_param || by_ref || by_component_ptr);\n   DECL_BY_REF_P (gnu_param) = by_ref;\n+  DECL_BY_DOUBLE_REF_P (gnu_param) = by_double_ref;\n   DECL_BY_COMPONENT_PTR_P (gnu_param) = by_component_ptr;\n   DECL_BY_DESCRIPTOR_P (gnu_param) = (mech == By_Descriptor ||\n                                       mech == By_Short_Descriptor);\n@@ -7397,13 +7412,18 @@ annotate_value (tree gnu_size)\n /* Given GNAT_ENTITY, an object (constant, variable, parameter, exception)\n    and GNU_TYPE, its corresponding GCC type, set Esize and Alignment to the\n    size and alignment used by Gigi.  Prefer SIZE over TYPE_SIZE if non-null.\n-   BY_REF is true if the object is used by reference.  */\n+   BY_REF is true if the object is used by reference and BY_DOUBLE_REF is\n+   true if the object is used by double reference.  */\n \n void\n-annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n+annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref,\n+\t\t bool by_double_ref)\n {\n   if (by_ref)\n     {\n+      if (by_double_ref)\n+\tgnu_type = TREE_TYPE (gnu_type);\n+\n       if (TYPE_IS_FAT_POINTER_P (gnu_type))\n \tgnu_type = TYPE_UNCONSTRAINED_ARRAY (gnu_type);\n       else"}, {"sha": "2fa2a07edeb14eb6862cb5dc695efba5ec1eb68d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -139,9 +139,10 @@ extern tree choices_to_gnu (tree operand, Node_Id choices);\n /* Given GNAT_ENTITY, an object (constant, variable, parameter, exception)\n    and GNU_TYPE, its corresponding GCC type, set Esize and Alignment to the\n    size and alignment used by Gigi.  Prefer SIZE over TYPE_SIZE if non-null.\n-   BY_REF is true if the object is used by reference.  */\n+   BY_REF is true if the object is used by reference and BY_DOUBLE_REF is\n+   true if the object is used by double reference.  */\n extern void annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size,\n-\t\t\t     bool by_ref);\n+\t\t\t     bool by_ref, bool by_double_ref);\n \n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n    type with all size expressions that contain F updated by replacing F"}, {"sha": "0dd29a61b0a2c2005960ea55b5f0a9423eb0ba09", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -619,8 +619,8 @@ gnat_get_subrange_bounds (const_tree gnu_type, tree *lowval, tree *highval)\n   *highval = TYPE_MAX_VALUE (gnu_type);\n }\n \n-/* GNU_TYPE is a type. Determine if it should be passed by reference by\n-   default.  */\n+/* GNU_TYPE is the type of a subprogram parameter.  Determine if it should be\n+   passed by reference by default.  */\n \n bool\n default_pass_by_ref (tree gnu_type)\n@@ -632,7 +632,7 @@ default_pass_by_ref (tree gnu_type)\n      is an In Out parameter, but it's probably best to err on the side of\n      passing more things by reference.  */\n \n-  if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, 1))\n+  if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, true))\n     return true;\n \n   if (targetm.calls.return_in_memory (gnu_type, NULL_TREE))\n@@ -647,8 +647,8 @@ default_pass_by_ref (tree gnu_type)\n   return false;\n }\n \n-/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type if\n-   it should be passed by reference. */\n+/* GNU_TYPE is the type of a subprogram parameter.  Determine if it must be\n+   passed by reference.  */\n \n bool\n must_pass_by_ref (tree gnu_type)"}, {"sha": "36a246297c05a794e7027913198efbb8f6445f91", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -988,6 +988,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       const bool read_only = DECL_POINTS_TO_READONLY_P (gnu_result);\n       tree renamed_obj;\n \n+      if (TREE_CODE (gnu_result) == PARM_DECL\n+\t  && DECL_BY_DOUBLE_REF_P (gnu_result))\n+\tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n+\n       if (TREE_CODE (gnu_result) == PARM_DECL\n \t  && DECL_BY_COMPONENT_PTR_P (gnu_result))\n \tgnu_result\n@@ -2595,9 +2599,13 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     {\n       tree gnu_param = get_gnu_tree (gnat_param);\n+      bool is_var_decl = (TREE_CODE (gnu_param) == VAR_DECL);\n+\n       annotate_object (gnat_param, TREE_TYPE (gnu_param), NULL_TREE,\n-\t\t       DECL_BY_REF_P (gnu_param));\n-      if (TREE_CODE (gnu_param) == VAR_DECL)\n+\t\t       DECL_BY_REF_P (gnu_param),\n+\t\t       !is_var_decl && DECL_BY_DOUBLE_REF_P (gnu_param));\n+\n+      if (is_var_decl)\n \tsave_gnu_tree (gnat_param, NULL_TREE, false);\n     }\n \n@@ -2900,6 +2908,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  /* The symmetry of the paths to the type of an entity is broken here\n \t     since arguments don't know that they will be passed by ref.  */\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n+\n+\t  if (DECL_BY_DOUBLE_REF_P (gnu_formal))\n+\t    gnu_actual\n+\t      = build_unary_op (ADDR_EXPR, TREE_TYPE (gnu_formal_type),\n+\t\t\t\tgnu_actual);\n+\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n       else if (gnu_formal"}, {"sha": "6ee95b76c3a8cbc70679999b628efde15b2194b6", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c70025900f1242f8aa7822e1f681bb76ec12893/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0c70025900f1242f8aa7822e1f681bb76ec12893", "patch": "@@ -3171,24 +3171,35 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \n /* Convert GNU_EXPR, a pointer to a VMS descriptor, to GNU_TYPE, a regular\n    pointer or fat pointer type.  GNU_EXPR_ALT_TYPE is the alternate (32-bit)\n-   pointer type of GNU_EXPR.  GNAT_SUBPROG is the subprogram to which the\n-   VMS descriptor is passed.  */\n+   pointer type of GNU_EXPR.  BY_REF is true if the result is to be used by\n+   reference.  GNAT_SUBPROG is the subprogram to which the VMS descriptor is\n+   passed.  */\n \n static tree\n convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n-\t\t\tEntity_Id gnat_subprog)\n+\t\t\tbool by_ref, Entity_Id gnat_subprog)\n {\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   tree mbo = TYPE_FIELDS (desc_type);\n   const char *mbostr = IDENTIFIER_POINTER (DECL_NAME (mbo));\n   tree mbmo = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (mbo)));\n-  tree is64bit, gnu_expr32, gnu_expr64;\n+  tree real_type, is64bit, gnu_expr32, gnu_expr64;\n+\n+  if (by_ref)\n+    real_type = TREE_TYPE (gnu_type);\n+  else\n+    real_type = gnu_type;\n \n   /* If the field name is not MBO, it must be 32-bit and no alternate.\n      Otherwise primary must be 64-bit and alternate 32-bit.  */\n   if (strcmp (mbostr, \"MBO\") != 0)\n-    return convert_vms_descriptor32 (gnu_type, gnu_expr, gnat_subprog);\n+    {\n+      tree ret = convert_vms_descriptor32 (real_type, gnu_expr, gnat_subprog);\n+      if (by_ref)\n+\tret = build_unary_op (ADDR_EXPR, gnu_type, ret);\n+      return ret;\n+    }\n \n   /* Build the test for 64-bit descriptor.  */\n   mbo = build3 (COMPONENT_REF, TREE_TYPE (mbo), desc, mbo, NULL_TREE);\n@@ -3203,9 +3214,13 @@ convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n \t\t\t\t\tinteger_minus_one_node));\n \n   /* Build the 2 possible end results.  */\n-  gnu_expr64 = convert_vms_descriptor64 (gnu_type, gnu_expr, gnat_subprog);\n+  gnu_expr64 = convert_vms_descriptor64 (real_type, gnu_expr, gnat_subprog);\n+  if (by_ref)\n+    gnu_expr64 =  build_unary_op (ADDR_EXPR, gnu_type, gnu_expr64);\n   gnu_expr = fold_convert (gnu_expr_alt_type, gnu_expr);\n-  gnu_expr32 = convert_vms_descriptor32 (gnu_type, gnu_expr, gnat_subprog);\n+  gnu_expr32 = convert_vms_descriptor32 (real_type, gnu_expr, gnat_subprog);\n+  if (by_ref)\n+    gnu_expr32 =  build_unary_op (ADDR_EXPR, gnu_type, gnu_expr32);\n \n   return build3 (COND_EXPR, gnu_type, is64bit, gnu_expr64, gnu_expr32);\n }\n@@ -3217,7 +3232,7 @@ void\n build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n {\n   tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n-  tree gnu_stub_param, gnu_arg_types, gnu_param;\n+  tree gnu_subprog_param, gnu_stub_param, gnu_param;\n   tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n   VEC(tree,gc) *gnu_param_vec = NULL;\n \n@@ -3235,17 +3250,21 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n   /* Loop over the parameters of the stub and translate any of them\n      passed by descriptor into a by reference one.  */\n   for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n-       gnu_arg_types = TYPE_ARG_TYPES (gnu_subprog_type);\n+       gnu_subprog_param = DECL_ARGUMENTS (gnu_subprog);\n        gnu_stub_param;\n        gnu_stub_param = TREE_CHAIN (gnu_stub_param),\n-       gnu_arg_types = TREE_CHAIN (gnu_arg_types))\n+       gnu_subprog_param = TREE_CHAIN (gnu_subprog_param))\n     {\n       if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n-\tgnu_param\n-\t  = convert_vms_descriptor (TREE_VALUE (gnu_arg_types),\n-\t\t\t\t    gnu_stub_param,\n-\t\t\t\t    DECL_PARM_ALT_TYPE (gnu_stub_param),\n-\t\t\t\t    gnat_subprog);\n+\t{\n+\t  gcc_assert (DECL_BY_REF_P (gnu_subprog_param));\n+\t  gnu_param\n+\t    = convert_vms_descriptor (TREE_TYPE (gnu_subprog_param),\n+\t\t\t\t      gnu_stub_param,\n+\t\t\t\t      DECL_PARM_ALT_TYPE (gnu_stub_param),\n+\t\t\t\t      DECL_BY_DOUBLE_REF_P (gnu_subprog_param),\n+\t\t\t\t      gnat_subprog);\n+\t}\n       else\n \tgnu_param = gnu_stub_param;\n "}]}