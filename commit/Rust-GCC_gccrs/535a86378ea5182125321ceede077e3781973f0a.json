{"sha": "535a86378ea5182125321ceede077e3781973f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1YTg2Mzc4ZWE1MTgyMTI1MzIxY2VlZGUwNzdlMzc4MTk3M2YwYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2015-10-16T11:01:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-16T11:01:53Z"}, "message": "exp_ch5.adb, [...]: Code clean up: remove special handling for .NET and JVM.\n\n2015-10-16  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch5.adb, sem_ch3.adb, frontend.adb, exp_ch7.adb, exp_ch7.ads,\n\tsem_ch5.adb, sem_type.adb, exp_util.adb, exp_util.ads, comperr.adb,\n\texp_attr.adb, sinfo.ads, exp_ch9.adb, make.adb, usage.adb,\n\tlib-writ.adb, sem_ch9.adb, bindgen.adb, debug.adb, einfo.adb,\n\teinfo.ads, types.ads, checks.adb, sem_prag.adb, s-tasini.adb,\n\trtsfind.ads, freeze.adb, sem_util.adb, sem_util.ads, exp_dbug.adb,\n\tgnatlink.adb, gnat1drv.adb, targparm.adb, targparm.ads, exp_ch4.adb,\n\texp_ch11.adb, repinfo.adb, s-soflin.adb, s-soflin.ads, exp_ch6.adb,\n\texp_ch13.adb, sem_mech.adb, sem_ch6.adb, par-prag.adb, exp_disp.adb,\n\tsem_ch8.adb, exp_disp.ads, snames.adb-tmpl, exp_aggr.adb, sem_eval.adb,\n\texp_intr.adb, sem_ch13.adb, snames.ads-tmpl, sem_disp.adb, exp_ch3.adb:\n\tCode clean up: remove special handling for .NET and JVM.\n\nFrom-SVN: r228874", "tree": {"sha": "84ccc871dc5fdb6b16df1277042294ec753ecebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84ccc871dc5fdb6b16df1277042294ec753ecebe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535a86378ea5182125321ceede077e3781973f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535a86378ea5182125321ceede077e3781973f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535a86378ea5182125321ceede077e3781973f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535a86378ea5182125321ceede077e3781973f0a/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07fbef62d559b9b7e9c4563e6c4d17206b91363f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07fbef62d559b9b7e9c4563e6c4d17206b91363f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07fbef62d559b9b7e9c4563e6c4d17206b91363f"}], "stats": {"total": 3229, "additions": 470, "deletions": 2759}, "files": [{"sha": "c44a267a7717cab1f32996db8aa8d5b544801b53", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -1,3 +1,18 @@\n+2015-10-16  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch5.adb, sem_ch3.adb, frontend.adb, exp_ch7.adb, exp_ch7.ads,\n+\tsem_ch5.adb, sem_type.adb, exp_util.adb, exp_util.ads, comperr.adb,\n+\texp_attr.adb, sinfo.ads, exp_ch9.adb, make.adb, usage.adb,\n+\tlib-writ.adb, sem_ch9.adb, bindgen.adb, debug.adb, einfo.adb,\n+\teinfo.ads, types.ads, checks.adb, sem_prag.adb, s-tasini.adb,\n+\trtsfind.ads, freeze.adb, sem_util.adb, sem_util.ads, exp_dbug.adb,\n+\tgnatlink.adb, gnat1drv.adb, targparm.adb, targparm.ads, exp_ch4.adb,\n+\texp_ch11.adb, repinfo.adb, s-soflin.adb, s-soflin.ads, exp_ch6.adb,\n+\texp_ch13.adb, sem_mech.adb, sem_ch6.adb, par-prag.adb, exp_disp.adb,\n+\tsem_ch8.adb, exp_disp.ads, snames.adb-tmpl, exp_aggr.adb, sem_eval.adb,\n+\texp_intr.adb, sem_ch13.adb, snames.ads-tmpl, sem_disp.adb, exp_ch3.adb:\n+\tCode clean up: remove special handling for .NET and JVM.\n+\n 2015-10-16  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_ch12.adb: Minor punctuation fix in comment"}, {"sha": "76e9dc3534678ef5b2ad2ab4d8e1976541dc241c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 93, "deletions": 307, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -352,13 +352,10 @@ package body Bindgen is\n    --  characters of S. The caller must ensure that these characters do in fact\n    --  exist in the Statement_Buffer.\n \n-   type Qualification_Mode is (Dollar_Sign, Dot, Double_Underscores);\n-\n-   procedure Set_Unit_Name (Mode : Qualification_Mode := Double_Underscores);\n+   procedure Set_Unit_Name;\n    --  Given a unit name in the Name_Buffer, copy it into Statement_Buffer,\n    --  starting at the Last + 1 position and update Last past the value.\n-   --  Depending on parameter Mode, a dot (.) can be qualified into double\n-   --  underscores (__), a dollar sign ($) or left as is.\n+   --  Each dot (.) will be qualified into double underscores (__).\n \n    procedure Set_Unit_Number (U : Unit_Id);\n    --  Sets unit number (first unit is 1, leading zeroes output to line up all\n@@ -380,10 +377,7 @@ package body Bindgen is\n    begin\n       WBI (\"   procedure \" & Ada_Final_Name.all & \" is\");\n \n-      if VM_Target = No_VM\n-        and Bind_Main_Program\n-        and not CodePeer_Mode\n-      then\n+      if Bind_Main_Program and not CodePeer_Mode then\n          WBI (\"      procedure s_stalib_adafinal;\");\n          Set_String (\"      pragma Import (C, s_stalib_adafinal, \");\n          Set_String (\"\"\"system__standard_library__adafinal\"\");\");\n@@ -406,10 +400,10 @@ package body Bindgen is\n \n       WBI (\"      Runtime_Finalize;\");\n \n-      --  On non-virtual machine targets, finalization is done differently\n-      --  depending on whether this is the main program or a library.\n+      --  By default (real targets), finalization is done differently depending\n+      --  on whether this is the main program or a library.\n \n-      if VM_Target = No_VM and then not CodePeer_Mode then\n+      if not CodePeer_Mode then\n          if Bind_Main_Program then\n             WBI (\"      s_stalib_adafinal;\");\n          elsif Lib_Final_Built then\n@@ -418,9 +412,9 @@ package body Bindgen is\n             WBI (\"      null;\");\n          end if;\n \n-      --  Pragma Import C cannot be used on virtual machine targets, therefore\n-      --  call the runtime finalization routine directly. Similarly in CodePeer\n-      --  mode, where imported functions are ignored.\n+      --  Pragma Import C cannot be used on virtual targets, therefore call the\n+      --  runtime finalization routine directly in CodePeer mode, where\n+      --  imported functions are ignored.\n \n       else\n          WBI (\"      System.Standard_Library.Adafinal;\");\n@@ -443,12 +437,11 @@ package body Bindgen is\n       --  of __gnat_finalize_library_objects. This is declared at library\n       --  level for compatibility with the type used in System.Soft_Links.\n       --  The import of the soft link which performs library-level object\n-      --  finalization is not needed for VM targets; regular Ada is used in\n+      --  finalization does not work for CodePeer, so regular Ada is used in\n       --  that case. For restricted run-time libraries (ZFP and Ravenscar)\n       --  tasks are non-terminating, so we do not want finalization.\n \n       if not Suppress_Standard_Library_On_Target\n-        and then VM_Target = No_VM\n         and then not CodePeer_Mode\n         and then not Configurable_Run_Time_On_Target\n       then\n@@ -638,12 +631,10 @@ package body Bindgen is\n                  \" \"\"__gnat_activate_all_tasks\"\");\");\n          end if;\n \n-         --  The import of the soft link which performs library-level object\n-         --  finalization is not needed for VM targets; regular Ada is used in\n-         --  that case. For restricted run-time libraries (ZFP and Ravenscar)\n+         --  For restricted run-time libraries (ZFP and Ravenscar)\n          --  tasks are non-terminating, so we do not want finalization.\n \n-         if VM_Target = No_VM and then not Configurable_Run_Time_On_Target then\n+         if not Configurable_Run_Time_On_Target then\n             WBI (\"\");\n             WBI (\"      Finalize_Library_Objects : No_Param_Proc;\");\n             WBI (\"      pragma Import (C, Finalize_Library_Objects, \" &\n@@ -662,38 +653,6 @@ package body Bindgen is\n                  \"\"\"__gnat_initialize_stack_limit\"\");\");\n          end if;\n \n-         --  Special processing when main program is CIL function/procedure\n-\n-         if VM_Target = CLI_Target\n-           and then Bind_Main_Program\n-           and then not No_Main_Subprogram\n-         then\n-            WBI (\"\");\n-\n-            --  Function case, use Set_Exit_Status to report the returned\n-            --  status code, since that is the only mechanism available.\n-\n-            if ALIs.Table (ALIs.First).Main_Program = Func then\n-               WBI (\"      Result : Integer;\");\n-               WBI (\"      procedure Set_Exit_Status (Code : Integer);\");\n-               WBI (\"      pragma Import (C, Set_Exit_Status, \" &\n-                    \"\"\"__gnat_set_exit_status\"\");\");\n-               WBI (\"\");\n-               WBI (\"      function Ada_Main_Program return Integer;\");\n-\n-            --  Procedure case\n-\n-            else\n-               WBI (\"      procedure Ada_Main_Program;\");\n-            end if;\n-\n-            Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-            Name_Len := Name_Len - 2;\n-            WBI (\"      pragma Import (CIL, Ada_Main_Program, \"\"\"\n-                 & Name_Buffer (1 .. Name_Len) & \".\"\n-                 & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len)) & \"\"\");\");\n-         end if;\n-\n          --  When dispatching domains are used then we need to signal it\n          --  before calling the main procedure.\n \n@@ -836,18 +795,8 @@ package body Bindgen is\n \n          --  Generate call to Install_Handler\n \n-         --  In .NET, when binding with -z, we don't install the signal handler\n-         --  to let the caller handle the last exception handler.\n-\n          WBI (\"\");\n-\n-         if VM_Target /= CLI_Target\n-           or else Bind_Main_Program\n-         then\n-            WBI (\"      Runtime_Initialize (1);\");\n-         else\n-            WBI (\"      Runtime_Initialize (0);\");\n-         end if;\n+         WBI (\"      Runtime_Initialize (1);\");\n       end if;\n \n       --  Generate call to set Initialize_Scalar values if active\n@@ -888,37 +837,22 @@ package body Bindgen is\n       if CodePeer_Mode then\n          null;\n \n-      --  On virtual machine targets, or on non-virtual machine ones if this\n-      --  is the main program case, attach finalize_library to the soft link.\n-      --  Do it only when not using a restricted run time, in which case tasks\n-      --  are non-terminating, so we do not want library-level finalization.\n+      --  If this is the main program case, attach finalize_library to the soft\n+      --  link. Do it only when not using a restricted run time, in which case\n+      --  tasks are non-terminating, so we do not want library-level\n+      --  finalization.\n \n-      elsif (VM_Target /= No_VM or else Bind_Main_Program)\n+      elsif Bind_Main_Program\n         and then not Configurable_Run_Time_On_Target\n         and then not Suppress_Standard_Library_On_Target\n       then\n          WBI (\"\");\n \n-         if VM_Target = No_VM then\n-            if Lib_Final_Built then\n-               Set_String (\"      Finalize_Library_Objects := \");\n-               Set_String (\"finalize_library'access;\");\n-            else\n-               Set_String (\"      Finalize_Library_Objects := null;\");\n-            end if;\n-\n-         --  On VM targets use regular Ada to set the soft link\n-\n+         if Lib_Final_Built then\n+            Set_String (\"      Finalize_Library_Objects := \");\n+            Set_String (\"finalize_library'access;\");\n          else\n-            if Lib_Final_Built then\n-               Set_String\n-                 (\"      System.Soft_Links.Finalize_Library_Objects\");\n-               Set_String (\" := finalize_library'access;\");\n-            else\n-               Set_String\n-                 (\"      System.Soft_Links.Finalize_Library_Objects\");\n-               Set_String (\" := null;\");\n-            end if;\n+            Set_String (\"      Finalize_Library_Objects := null;\");\n          end if;\n \n          Write_Statement_Buffer;\n@@ -959,25 +893,6 @@ package body Bindgen is\n          end if;\n       end if;\n \n-      --  Case of main program is CIL function or procedure\n-\n-      if VM_Target = CLI_Target\n-        and then Bind_Main_Program\n-        and then not No_Main_Subprogram\n-      then\n-         --  For function case, use Set_Exit_Status to set result\n-\n-         if ALIs.Table (ALIs.First).Main_Program = Func then\n-            WBI (\"      Result := Ada_Main_Program;\");\n-            WBI (\"      Set_Exit_Status (Result);\");\n-\n-         --  Procedure case\n-\n-         else\n-            WBI (\"      Ada_Main_Program;\");\n-         end if;\n-      end if;\n-\n       WBI (\"   end \" & Ada_Init_Name.all & \";\");\n       WBI (\"\");\n    end Gen_Adainit;\n@@ -1188,37 +1103,24 @@ package body Bindgen is\n                Set_String (\"      \");\n                Get_Decoded_Name_String_With_Brackets (U.Uname);\n \n-               if VM_Target = CLI_Target and then U.Unit_Kind /= 's' then\n-                  if Name_Buffer (Name_Len) = 's' then\n-                     Name_Buffer (Name_Len - 1 .. Name_Len + 12) :=\n-                       \"_pkg'elab_spec\";\n-                  else\n-                     Name_Buffer (Name_Len - 1 .. Name_Len + 12) :=\n-                       \"_pkg'elab_body\";\n-                  end if;\n-\n-                  Name_Len := Name_Len + 12;\n-\n-               else\n-                  if Name_Buffer (Name_Len) = 's' then\n-                     Name_Buffer (Name_Len - 1 .. Name_Len + 8) :=\n-                       \"'elab_spec\";\n-                     Name_Len := Name_Len + 8;\n+               if Name_Buffer (Name_Len) = 's' then\n+                  Name_Buffer (Name_Len - 1 .. Name_Len + 8) :=\n+                    \"'elab_spec\";\n+                  Name_Len := Name_Len + 8;\n \n-                  --  Special case in CodePeer mode for subprogram bodies\n-                  --  which correspond to CodePeer 'Elab_Subp_Body special\n-                  --  init procedure.\n+               --  Special case in CodePeer mode for subprogram bodies\n+               --  which correspond to CodePeer 'Elab_Subp_Body special\n+               --  init procedure.\n \n-                  elsif U.Unit_Kind = 's' and CodePeer_Mode then\n-                     Name_Buffer (Name_Len - 1 .. Name_Len + 13) :=\n-                       \"'elab_subp_body\";\n-                     Name_Len := Name_Len + 13;\n+               elsif U.Unit_Kind = 's' and CodePeer_Mode then\n+                  Name_Buffer (Name_Len - 1 .. Name_Len + 13) :=\n+                    \"'elab_subp_body\";\n+                  Name_Len := Name_Len + 13;\n \n-                  else\n-                     Name_Buffer (Name_Len - 1 .. Name_Len + 8) :=\n-                       \"'elab_body\";\n-                     Name_Len := Name_Len + 8;\n-                  end if;\n+               else\n+                  Name_Buffer (Name_Len - 1 .. Name_Len + 8) :=\n+                    \"'elab_body\";\n+                  Name_Len := Name_Len + 8;\n                end if;\n \n                Set_Casing (U.Icasing);\n@@ -1294,51 +1196,10 @@ package body Bindgen is\n                Set_String (\"   \");\n                Set_String (\"E\");\n                Set_Unit_Number (Unum);\n-\n-               case VM_Target is\n-                  when No_VM | JVM_Target =>\n-                     Set_String (\" : Short_Integer; pragma Import (Ada, \");\n-                  when CLI_Target =>\n-                     Set_String (\" : Short_Integer; pragma Import (CIL, \");\n-               end case;\n-\n-               Set_String (\"E\");\n+               Set_String (\" : Short_Integer; pragma Import (Ada, E\");\n                Set_Unit_Number (Unum);\n                Set_String (\", \"\"\");\n                Get_Name_String (U.Uname);\n-\n-               --  In the case of JGNAT we need to emit an Import name that\n-               --  includes the class name (using '$' separators in the case\n-               --  of a child unit name).\n-\n-               if VM_Target /= No_VM then\n-                  for J in 1 .. Name_Len - 2 loop\n-                     if VM_Target = CLI_Target\n-                       or else Name_Buffer (J) /= '.'\n-                     then\n-                        Set_Char (Name_Buffer (J));\n-                     else\n-                        Set_String (\"$\");\n-                     end if;\n-                  end loop;\n-\n-                  if VM_Target /= CLI_Target or else U.Unit_Kind = 's' then\n-                     Set_String (\".\");\n-                  else\n-                     Set_String (\"_pkg.\");\n-                  end if;\n-\n-                  --  If the unit name is very long, then split the\n-                  --  Import link name across lines using \"&\" (occurs\n-                  --  in some C2 tests).\n-\n-                  if 2 * Name_Len + 60 > Hostparm.Max_Line_Length then\n-                     Set_String (\"\"\" &\");\n-                     Write_Statement_Buffer;\n-                     Set_String (\"         \"\"\");\n-                  end if;\n-               end if;\n-\n                Set_Unit_Name;\n                Set_String (\"_E\"\");\");\n                Write_Statement_Buffer;\n@@ -1467,46 +1328,15 @@ package body Bindgen is\n             Write_Statement_Buffer;\n \n             --  Generate:\n-            --    pragma Import (CIL, F<Count>,\n-            --                   \"xx.yy_pkg.xx__yy__finalize_[body|spec]\");\n-            --    --  for .NET targets\n-\n-            --    pragma Import (Java, F<Count>,\n-            --                   \"xx$yy.xx__yy__finalize_[body|spec]\");\n-            --    --  for JVM targets\n-\n             --    pragma Import (Ada, F<Count>,\n             --                  \"xx__yy__finalize_[body|spec]\");\n-            --    --  for default targets\n-\n-            if VM_Target = CLI_Target then\n-               Set_String (\"         pragma Import (CIL, F\");\n-            elsif VM_Target = JVM_Target then\n-               Set_String (\"         pragma Import (Java, F\");\n-            else\n-               Set_String (\"         pragma Import (Ada, F\");\n-            end if;\n \n+            Set_String (\"         pragma Import (Ada, F\");\n             Set_Int (Count);\n             Set_String (\", \"\"\");\n \n             --  Perform name construction\n \n-            --  .NET   xx.yy_pkg.xx__yy__finalize\n-\n-            if VM_Target = CLI_Target then\n-               Set_Unit_Name (Mode => Dot);\n-               Set_String (\"_pkg.\");\n-\n-            --  JVM   xx$yy.xx__yy__finalize\n-\n-            elsif VM_Target = JVM_Target then\n-               Set_Unit_Name (Mode => Dollar_Sign);\n-               Set_Char ('.');\n-            end if;\n-\n-            --  Default   xx__yy__finalize\n-\n             Set_Unit_Name;\n             Set_String (\"__finalize_\");\n \n@@ -1586,31 +1416,17 @@ package body Bindgen is\n          --  raised an exception. In that case import the actual exception\n          --  and the routine necessary to raise it.\n \n-         if VM_Target = No_VM then\n-            WBI (\"      declare\");\n-            WBI (\"         procedure Reraise_Library_Exception_If_Any;\");\n-\n-            Set_String (\"            pragma Import (Ada, \");\n-            Set_String (\"Reraise_Library_Exception_If_Any, \");\n-            Set_String (\"\"\"__gnat_reraise_library_exception_if_any\"\");\");\n-            Write_Statement_Buffer;\n-\n-            WBI (\"      begin\");\n-            WBI (\"         Reraise_Library_Exception_If_Any;\");\n-            WBI (\"      end;\");\n-\n-         --  VM-specific code, use regular Ada to produce the desired behavior\n+         WBI (\"      declare\");\n+         WBI (\"         procedure Reraise_Library_Exception_If_Any;\");\n \n-         else\n-            WBI (\"      if System.Soft_Links.Library_Exception_Set then\");\n-\n-            Set_String (\"         Ada.Exceptions.Reraise_Occurrence (\");\n-            Set_String (\"System.Soft_Links.Library_Exception);\");\n-            Write_Statement_Buffer;\n-\n-            WBI (\"      end if;\");\n-         end if;\n+         Set_String (\"            pragma Import (Ada, \");\n+         Set_String (\"Reraise_Library_Exception_If_Any, \");\n+         Set_String (\"\"\"__gnat_reraise_library_exception_if_any\"\");\");\n+         Write_Statement_Buffer;\n \n+         WBI (\"      begin\");\n+         WBI (\"         Reraise_Library_Exception_If_Any;\");\n+         WBI (\"      end;\");\n          WBI (\"   end finalize_library;\");\n          WBI (\"\");\n       end if;\n@@ -1980,18 +1796,16 @@ package body Bindgen is\n \n       --  Add a \"-Ldir\" for each directory in the object path\n \n-      if VM_Target /= CLI_Target then\n-         for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n-            declare\n-               Dir : constant String_Ptr := Dir_In_Obj_Search_Path (J);\n-            begin\n-               Name_Len := 0;\n-               Add_Str_To_Name_Buffer (\"-L\");\n-               Add_Str_To_Name_Buffer (Dir.all);\n-               Write_Linker_Option;\n-            end;\n-         end loop;\n-      end if;\n+      for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n+         declare\n+            Dir : constant String_Ptr := Dir_In_Obj_Search_Path (J);\n+         begin\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (\"-L\");\n+            Add_Str_To_Name_Buffer (Dir.all);\n+            Write_Linker_Option;\n+         end;\n+      end loop;\n \n       if not (Opt.No_Run_Time_Mode or Opt.No_Stdlib) then\n          Name_Len := 0;\n@@ -2117,12 +1931,6 @@ package body Bindgen is\n \n       Set_PSD_Pragma_Table;\n \n-      --  For JGNAT the main program is already generated by the compiler\n-\n-      if VM_Target = JVM_Target then\n-         Bind_Main_Program := False;\n-      end if;\n-\n       --  Override time slice value if -T switch is set\n \n       if Time_Slice_Set then\n@@ -2219,9 +2027,6 @@ package body Bindgen is\n       if not Suppress_Standard_Library_On_Target then\n          if CodePeer_Mode then\n             WBI (\"with System.Standard_Library;\");\n-         elsif VM_Target /= No_VM then\n-            WBI (\"with System.Soft_Links;\");\n-            WBI (\"with System.Standard_Library;\");\n          end if;\n       end if;\n \n@@ -2231,45 +2036,42 @@ package body Bindgen is\n       --  Main program case\n \n       if Bind_Main_Program then\n-         if VM_Target = No_VM then\n+         --  Generate argc/argv stuff unless suppressed\n \n-            --  Generate argc/argv stuff unless suppressed\n+         if Command_Line_Args_On_Target\n+           or not Configurable_Run_Time_On_Target\n+         then\n+            WBI (\"\");\n+            WBI (\"   gnat_argc : Integer;\");\n+            WBI (\"   gnat_argv : System.Address;\");\n+            WBI (\"   gnat_envp : System.Address;\");\n \n-            if Command_Line_Args_On_Target\n-              or not Configurable_Run_Time_On_Target\n-            then\n+            --  If the standard library is not suppressed, these variables\n+            --  are in the run-time data area for easy run time access.\n+\n+            if not Suppress_Standard_Library_On_Target then\n                WBI (\"\");\n-               WBI (\"   gnat_argc : Integer;\");\n-               WBI (\"   gnat_argv : System.Address;\");\n-               WBI (\"   gnat_envp : System.Address;\");\n-\n-               --  If the standard library is not suppressed, these variables\n-               --  are in the run-time data area for easy run time access.\n-\n-               if not Suppress_Standard_Library_On_Target then\n-                  WBI (\"\");\n-                  WBI (\"   pragma Import (C, gnat_argc);\");\n-                  WBI (\"   pragma Import (C, gnat_argv);\");\n-                  WBI (\"   pragma Import (C, gnat_envp);\");\n-               end if;\n+               WBI (\"   pragma Import (C, gnat_argc);\");\n+               WBI (\"   pragma Import (C, gnat_argv);\");\n+               WBI (\"   pragma Import (C, gnat_envp);\");\n             end if;\n+         end if;\n \n-            --  Define exit status. Again in normal mode, this is in the\n-            --  run-time library, and is initialized there, but in the\n-            --  configurable runtime case, the variable is declared and\n-            --  initialized in this file.\n-\n-            WBI (\"\");\n+         --  Define exit status. Again in normal mode, this is in the\n+         --  run-time library, and is initialized there, but in the\n+         --  configurable runtime case, the variable is declared and\n+         --  initialized in this file.\n \n-            if Configurable_Run_Time_Mode then\n-               if Exit_Status_Supported_On_Target then\n-                  WBI (\"   gnat_exit_status : Integer := 0;\");\n-               end if;\n+         WBI (\"\");\n \n-            else\n-               WBI (\"   gnat_exit_status : Integer;\");\n-               WBI (\"   pragma Import (C, gnat_exit_status);\");\n+         if Configurable_Run_Time_Mode then\n+            if Exit_Status_Supported_On_Target then\n+               WBI (\"   gnat_exit_status : Integer := 0;\");\n             end if;\n+\n+         else\n+            WBI (\"   gnat_exit_status : Integer;\");\n+            WBI (\"   pragma Import (C, gnat_exit_status);\");\n          end if;\n \n          --  Generate the GNAT_Version and Ada_Main_Program_Name info only for\n@@ -2289,12 +2091,8 @@ package body Bindgen is\n          Set_String (\"   Ada_Main_Program_Name : constant String := \"\"\");\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n \n-         if VM_Target = No_VM then\n-            Set_Main_Program_Name;\n-            Set_String (\"\"\" & ASCII.NUL;\");\n-         else\n-            Set_String (Name_Buffer (1 .. Name_Len - 2) & \"\"\";\");\n-         end if;\n+         Set_Main_Program_Name;\n+         Set_String (\"\"\" & ASCII.NUL;\");\n \n          Write_Statement_Buffer;\n \n@@ -2326,7 +2124,7 @@ package body Bindgen is\n          end if;\n       end if;\n \n-      if Bind_Main_Program and then VM_Target = No_VM then\n+      if Bind_Main_Program then\n \n          WBI (\"\");\n \n@@ -2505,7 +2303,7 @@ package body Bindgen is\n \n       Gen_Adainit;\n \n-      if Bind_Main_Program and then VM_Target = No_VM then\n+      if Bind_Main_Program then\n          Gen_Main;\n       end if;\n \n@@ -2706,17 +2504,11 @@ package body Bindgen is\n       Nlen   : Natural;\n \n    begin\n-      --  The main program generated by JGNAT expects a package called\n-      --  ada_<main procedure>.\n-      if VM_Target /= No_VM then\n-         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-         return \"ada_\" & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n-      end if;\n-\n       --  For CodePeer, we want reproducible names (independent of other\n       --  mains that may or may not be present) that don't collide\n       --  when analyzing multiple mains and which are easily recognizable\n       --  as \"ada_main\" names.\n+\n       if CodePeer_Mode then\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n          return \"ada_main_for_\" &\n@@ -3122,17 +2914,11 @@ package body Bindgen is\n    -- Set_Unit_Name --\n    -------------------\n \n-   procedure Set_Unit_Name (Mode : Qualification_Mode := Double_Underscores) is\n+   procedure Set_Unit_Name is\n    begin\n       for J in 1 .. Name_Len - 2 loop\n          if Name_Buffer (J) = '.' then\n-            if Mode = Double_Underscores then\n-               Set_String (\"__\");\n-            elsif Mode = Dot then\n-               Set_Char ('.');\n-            else\n-               Set_Char ('$');\n-            end if;\n+            Set_String (\"__\");\n          else\n             Set_Char (Name_Buffer (J));\n          end if;"}, {"sha": "929bdc535d9a41a7259ab6bd7b0630baaae96ac0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -1037,17 +1037,12 @@ package body Checks is\n          --  operation on signed integers on which the expander can promote\n          --  later the operands to type Integer (see Expand_N_Type_Conversion).\n \n-         --  Special case CLI target, where arithmetic overflow checks can be\n-         --  performed for integer and long_integer\n-\n          if Backend_Overflow_Checks_On_Target\n            or else not Do_Overflow_Check (N)\n            or else not Expander_Active\n            or else (Present (Parent (N))\n                      and then Nkind (Parent (N)) = N_Type_Conversion\n                      and then Integer_Promotion_Possible (Parent (N)))\n-           or else\n-             (VM_Target = CLI_Target and then Siz >= Standard_Integer_Size)\n          then\n             return;\n          end if;\n@@ -5903,11 +5898,6 @@ package body Checks is\n       elsif Nkind_In (Expr, N_Integer_Literal, N_Character_Literal) then\n          return True;\n \n-      --  Real literals are assumed to be valid in VM targets\n-\n-      elsif VM_Target /= No_VM and then Nkind (Expr) = N_Real_Literal then\n-         return True;\n-\n       --  If we have a type conversion or a qualification of a known valid\n       --  value, then the result will always be valid.\n "}, {"sha": "f32db3267b80283c359ab7ca0aba0a7a692a2ec3", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,6 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sprint;   use Sprint;\n with Sdefault; use Sdefault;\n-with Targparm; use Targparm;\n with Treepr;   use Treepr;\n with Types;    use Types;\n \n@@ -116,35 +115,19 @@ package body Comperr is\n       Abort_In_Progress := True;\n \n       --  Generate a \"standard\" error message instead of a bug box in case\n-      --  of .NET compiler, since we do not support all constructs of the\n-      --  language. Of course ideally, we should detect this before bombing on\n-      --  e.g. an assertion error, but in practice most of these bombs are due\n-      --  to a legitimate case of a construct not being supported (in a sense\n-      --  they all are, since for sure we are not supporting something if we\n-      --  bomb). By giving this message, we provide a more reasonable practical\n-      --  interface, since giving scary bug boxes on unsupported features is\n-      --  definitely not helpful.\n-\n-      --  Similarly if we are generating SCIL, an error message is sufficient\n-      --  instead of generating a bug box.\n+      --  of CodePeer rather than generating a bug box, friendlier.\n \n       --  Note that the call to Error_Msg_N below sets Serious_Errors_Detected\n       --  to 1, so we use the regular mechanism below in order to display a\n       --  \"compilation abandoned\" message and exit, so we still know we have\n       --  this case (and -gnatdk can still be used to get the bug box).\n \n-      if (VM_Target = CLI_Target or else CodePeer_Mode)\n+      if CodePeer_Mode\n         and then Serious_Errors_Detected = 0\n         and then not Debug_Flag_K\n         and then Sloc (Current_Error_Node) > No_Location\n       then\n-         if VM_Target = CLI_Target then\n-            Error_Msg_N\n-              (\"unsupported construct in this context\",\n-               Current_Error_Node);\n-         else\n-            Error_Msg_N (\"cannot generate 'S'C'I'L\", Current_Error_Node);\n-         end if;\n+         Error_Msg_N (\"cannot generate 'S'C'I'L\", Current_Error_Node);\n       end if;\n \n       --  If we are in CodePeer mode, we must also delete SCIL files"}, {"sha": "60c06f62babc4340bdc5aef1eaf054477055007c", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -105,8 +105,8 @@ package body Debug is\n    --  d.l  Use Ada 95 semantics for limited function returns\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n-   --  d.o  Generate .NET listing of CIL code\n-   --  d.p  Enable the .NET CIL verifier\n+   --  d.o\n+   --  d.p\n    --  d.q\n    --  d.r  Enable OK_To_Reorder_Components in non-variant records\n    --  d.s  Disable expansion of slice move, use memmove\n@@ -560,13 +560,6 @@ package body Debug is\n    --       compiler has a bug -- these are the files that need to be included\n    --       in a bug report.\n \n-   --  d.o  Generate listing showing the IL instructions generated by the .NET\n-   --       compiler for each subprogram.\n-\n-   --  d.p  Enable the .NET CIL verifier. During development the verifier is\n-   --       disabled by default and this flag is used to enable it. In the\n-   --       future we will reverse this functionality.\n-\n    --  d.r  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have no discriminants.\n \n@@ -597,10 +590,10 @@ package body Debug is\n \n    --  d.z  Restore previous front-end support for Inline_Always. In default\n    --       mode, for targets that use the GCC back end (i.e. currently all\n-   --       targets except AAMP, .NET, JVM, and GNATprove), Inline_Always is\n-   --       handled by the back end. Use of this switch restores the previous\n-   --       handling of Inline_Always by the front end on such targets. For the\n-   --       targets that do not use the GCC back end, this switch is ignored.\n+   --       targets except AAMP and GNATprove), Inline_Always is handled by the\n+   --       back end. Use of this switch restores the previous handling of\n+   --       Inline_Always by the front end on such targets. For the targets\n+   --       that do not use the GCC back end, this switch is ignored.\n \n    --  d.A  There seems to be a problem with ASIS if we activate the circuit\n    --       for reading and writing the aspect specification hash table, so"}, {"sha": "6dd5c96abc223bc1314bd3c7db66c6e0595ed7f9", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -516,7 +516,6 @@ package body Einfo is\n    --    Has_Pragma_Unreferenced_Objects Flag212\n    --    Requires_Overriding             Flag213\n    --    Has_RACW                        Flag214\n-   --    Has_Uplevel_Reference           Flag215\n    --    Universal_Aliasing              Flag216\n    --    Suppress_Value_Tracking_On_Call Flag217\n    --    Is_Primitive                    Flag218\n@@ -1847,11 +1846,6 @@ package body Einfo is\n       return Flag72 (Id);\n    end Has_Unknown_Discriminants;\n \n-   function Has_Uplevel_Reference (Id : E) return B is\n-   begin\n-      return Flag215 (Id);\n-   end Has_Uplevel_Reference;\n-\n    function Has_Visible_Refinement (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -4756,11 +4750,6 @@ package body Einfo is\n       Set_Flag72 (Id, V);\n    end Set_Has_Unknown_Discriminants;\n \n-   procedure Set_Has_Uplevel_Reference (Id : E; V : B := True) is\n-   begin\n-      Set_Flag215 (Id, V);\n-   end Set_Has_Uplevel_Reference;\n-\n    procedure Set_Has_Visible_Refinement (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -8770,7 +8759,6 @@ package body Einfo is\n       W (\"Has_Thunks\",                      Flag228 (Id));\n       W (\"Has_Unchecked_Union\",             Flag123 (Id));\n       W (\"Has_Unknown_Discriminants\",       Flag72  (Id));\n-      W (\"Has_Uplevel_Reference\",           Flag215 (Id));\n       W (\"Has_Visible_Refinement\",          Flag263 (Id));\n       W (\"Has_Volatile_Components\",         Flag87  (Id));\n       W (\"Has_Xref_Entry\",                  Flag182 (Id));"}, {"sha": "9f291909431039d80e096af1d4f5172e15618dd4", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -2029,15 +2029,6 @@ package Einfo is\n --       on the partial view, to insure that discriminants are properly\n --       inherited in certain contexts.\n \n---    Has_Uplevel_Reference (Flag215)\n---       Defined in all entities. Indicates that the entity is locally defined\n---       within a subprogram P, and there is a reference to the entity within\n---       a subprogram nested within P (at any depth). Set only for the VM case\n---       (where it is set for variables, constants, and loop parameters). Note\n---       that this is similar in usage to Is_Uplevel_Referenced_Entity (which\n---       is used when we are unnesting subprograms), but the usages are a bit\n---       different and it is cleaner to leave the old VM usage unchanged.\n-\n --    Has_Visible_Refinement (Flag263)\n --       Defined in E_Abstract_State entities. Set when a state has at least\n --       one refinement constituent and analysis is in the region between\n@@ -2425,7 +2416,7 @@ package Einfo is\n --       Defined in all entities. Set if the entity is exported. For now we\n --       only allow the export of constants, exceptions, functions, procedures\n --       and variables, but that may well change later on. Exceptions can only\n---       be exported in the Java VM implementation of GNAT.\n+--       be exported in the Java VM implementation of GNAT, which is retired.\n \n --    Is_External_State (synthesized)\n --       Applies to all entities, true for abstract states that are subject to\n@@ -2549,7 +2540,7 @@ package Einfo is\n --       Defined in all entities. Set if the entity is imported. For now we\n --       only allow the import of exceptions, functions, procedures, packages.\n --       and variables. Exceptions, packages and types can only be imported in\n---       the Java VM implementation.\n+--       the Java VM implementation, which is retired.\n \n --    Is_Incomplete_Or_Private_Type (synthesized)\n --       Applies to all entities, true for private and incomplete types\n@@ -3035,9 +3026,7 @@ package Einfo is\n --       static bounds, a record all of whose component types are static types,\n --       or an array, all of whose bounds are of a static type, and also have\n --       a component type that is a static type). See Set_Uplevel_Type for more\n---       information on how this flag is used. Note that if Is_Static_Type is\n---       True, then it is never the case that the Has_Uplevel_Reference flag is\n---       set for the same type.\n+--       information on how this flag is used.\n \n --    Is_Statically_Allocated (Flag28)\n --       Defined in all entities. This can only be set for exception,\n@@ -3162,10 +3151,6 @@ package Einfo is\n --       the cases where the reference is implicit (e.g. the type of an array\n --       used for computing the location of an element in an array. This is\n --       used internally in Exp_Unst, see this package for further details.\n---       Note that this is similar to the Has_Uplevel_Reference flag which\n---       is used in the VM case but we prefer to keep the two cases entirely\n---       separated, so that the VM usage is not disturbed by work on the\n---       Unnesting_Subprograms mode.\n \n --    Is_Valued_Procedure (Flag127)\n --       Defined in procedure entities. Set if an Import_Valued_Procedure\n@@ -5311,7 +5296,6 @@ package Einfo is\n    --    Has_Qualified_Name                  (Flag161)\n    --    Has_Stream_Size_Clause              (Flag184)\n    --    Has_Unknown_Discriminants           (Flag72)\n-   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Xref_Entry                      (Flag182)\n    --    In_Private_Part                     (Flag45)\n    --    Is_Ada_2005_Only                    (Flag185)\n@@ -6868,7 +6852,6 @@ package Einfo is\n    function Has_Thunks                          (Id : E) return B;\n    function Has_Unchecked_Union                 (Id : E) return B;\n    function Has_Unknown_Discriminants           (Id : E) return B;\n-   function Has_Uplevel_Reference               (Id : E) return B;\n    function Has_Visible_Refinement              (Id : E) return B;\n    function Has_Volatile_Components             (Id : E) return B;\n    function Has_Xref_Entry                      (Id : E) return B;\n@@ -7524,7 +7507,6 @@ package Einfo is\n    procedure Set_Has_Thunks                      (Id : E; V : B := True);\n    procedure Set_Has_Unchecked_Union             (Id : E; V : B := True);\n    procedure Set_Has_Unknown_Discriminants       (Id : E; V : B := True);\n-   procedure Set_Has_Uplevel_Reference           (Id : E; V : B := True);\n    procedure Set_Has_Visible_Refinement          (Id : E; V : B := True);\n    procedure Set_Has_Volatile_Components         (Id : E; V : B := True);\n    procedure Set_Has_Xref_Entry                  (Id : E; V : B := True);\n@@ -8299,7 +8281,6 @@ package Einfo is\n    pragma Inline (Has_Thunks);\n    pragma Inline (Has_Unchecked_Union);\n    pragma Inline (Has_Unknown_Discriminants);\n-   pragma Inline (Has_Uplevel_Reference);\n    pragma Inline (Has_Visible_Refinement);\n    pragma Inline (Has_Volatile_Components);\n    pragma Inline (Has_Xref_Entry);"}, {"sha": "cbb1581107529cffb7f036bcfaf51ba14fc0bfde", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -664,16 +664,6 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n-      --  Checks 11: Array aggregates with aliased components are currently\n-      --  not well supported by the VM backend; disable temporarily this\n-      --  backend processing until it is definitely supported.\n-\n-      if VM_Target /= No_VM\n-        and then Has_Aliased_Components (Base_Type (Typ))\n-      then\n-         return False;\n-      end if;\n-\n       --  Backend processing is possible\n \n       Set_Size_Known_At_Compile_Time (Etype (N), True);\n@@ -2534,8 +2524,8 @@ package body Exp_Aggr is\n                Set_No_Ctrl_Actions (First (Assign));\n \n                --  Assign the tag now to make sure that the dispatching call in\n-               --  the subsequent deep_adjust works properly (unless VM_Target,\n-               --  where tags are implicit).\n+               --  the subsequent deep_adjust works properly (unless\n+               --  Tagged_Type_Expansion where tags are implicit).\n \n                if Tagged_Type_Expansion then\n                   Instr :=\n@@ -5475,7 +5465,6 @@ package body Exp_Aggr is\n          --  then we could go into an infinite recursion.\n \n          if (In_Place_Assign_OK_For_Declaration or else Maybe_In_Place_OK)\n-           and then VM_Target = No_VM\n            and then not AAMP_On_Target\n            and then not Generate_SCIL\n            and then not Possible_Bit_Aligned_Component (Target)\n@@ -5851,7 +5840,8 @@ package body Exp_Aggr is\n             --  These are cases where the source expression may have a tag that\n             --  could differ from the component tag (e.g., can occur for type\n             --  conversions and formal parameters). (Tag adjustment not needed\n-            --  if VM_Target because object tags are implicit in the machine.)\n+            --  if Tagged_Type_Expansion because object tags are implicit in\n+            --  the machine.)\n \n             if Is_Tagged_Type (Etype (Expr_Q))\n               and then (Nkind (Expr_Q) = N_Type_Conversion"}, {"sha": "ed10ccda8f13c03528a183d8998b0d75ae473221", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -2223,14 +2223,7 @@ package body Exp_Attr is\n                 Prefix         => Pref,\n                 Attribute_Name => Name_Tag);\n \n-            if VM_Target = No_VM then\n-               New_Node := Build_Get_Alignment (Loc, New_Node);\n-            else\n-               New_Node :=\n-                 Make_Function_Call (Loc,\n-                   Name => New_Occurrence_Of (RTE (RE_Get_Alignment), Loc),\n-                   Parameter_Associations => New_List (New_Node));\n-            end if;\n+            New_Node := Build_Get_Alignment (Loc, New_Node);\n \n             --  Case where the context is a specific integer type with which\n             --  the original attribute was compatible. The function has a\n@@ -2901,17 +2894,8 @@ package body Exp_Attr is\n             begin\n                if Nkind (Nod) = N_Selected_Component then\n                   Make_Elab_String (Prefix (Nod));\n-\n-                  case VM_Target is\n-                     when JVM_Target =>\n-                        Store_String_Char ('$');\n-                     when CLI_Target =>\n-                        Store_String_Char ('.');\n-                     when No_VM =>\n-                        Store_String_Char ('_');\n-                        Store_String_Char ('_');\n-                  end case;\n-\n+                  Store_String_Char ('_');\n+                  Store_String_Char ('_');\n                   Get_Name_String (Chars (Selector_Name (Nod)));\n \n                else\n@@ -2930,14 +2914,8 @@ package body Exp_Attr is\n \n             Start_String;\n             Make_Elab_String (Pref);\n-\n-            if VM_Target = No_VM then\n-               Store_String_Chars (\"___elab\");\n-               Lang := Make_Identifier (Loc, Name_C);\n-            else\n-               Store_String_Chars (\"._elab\");\n-               Lang := Make_Identifier (Loc, Name_Ada);\n-            end if;\n+            Store_String_Chars (\"___elab\");\n+            Lang := Make_Identifier (Loc, Name_C);\n \n             if Id = Attribute_Elab_Body then\n                Store_String_Char ('b');\n@@ -4189,11 +4167,7 @@ package body Exp_Attr is\n          --  are not part of the actual type. Transform the attribute reference\n          --  into a runtime expression to add the size of the hidden header.\n \n-         --  Do not perform this expansion on .NET/JVM targets because the\n-         --  two pointers are already present in the type.\n-\n-         if VM_Target = No_VM\n-           and then Needs_Finalization (Ptyp)\n+         if Needs_Finalization (Ptyp)\n            and then not Header_Size_Added (Attr)\n          then\n             Set_Header_Size_Added (Attr);\n@@ -7554,9 +7528,6 @@ package body Exp_Attr is\n       --  that appear in GNAT's library, but will generate calls via rtsfind\n       --  to library routines for user code.\n \n-      --  ??? For now, disable this code for JVM, since this generates a\n-      --  VerifyError exception at run time on e.g. c330001.\n-\n       --  This is disabled for AAMP, to avoid creating dependences on files not\n       --  supported in the AAMP library (such as s-fileio.adb).\n \n@@ -7567,8 +7538,7 @@ package body Exp_Attr is\n       --  instead. That is why we include the test Is_Available when dealing\n       --  with these cases.\n \n-      if VM_Target /= JVM_Target\n-        and then not AAMP_On_Target\n+      if not AAMP_On_Target\n         and then\n           not Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n       then\n@@ -8044,8 +8014,7 @@ package body Exp_Attr is\n \n       function Is_GCC_Target return Boolean is\n       begin\n-         return VM_Target = No_VM and then not CodePeer_Mode\n-           and then not AAMP_On_Target;\n+         return not CodePeer_Mode and then not AAMP_On_Target;\n       end Is_GCC_Target;\n \n    --  Start of processing for Exp_Attr"}, {"sha": "798704502f9969237dcebcabbe9ad1349c4f517f", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -1094,33 +1094,14 @@ package body Exp_Ch11 is\n                   end;\n                end if;\n \n-               --  The processing at this point is rather different for the JVM\n-               --  case, so we completely separate the processing.\n-\n-               --  For the VM case, we unconditionally call Update_Exception,\n-               --  passing a call to the intrinsic Current_Target_Exception\n-               --  (see JVM/.NET versions of Ada.Exceptions for details).\n-\n-               if VM_Target /= No_VM then\n-                  declare\n-                     Arg : constant Node_Id :=\n-                             Make_Function_Call (Loc,\n-                               Name =>\n-                                 New_Occurrence_Of\n-                                   (RTE (RE_Current_Target_Exception), Loc));\n-                  begin\n-                     Prepend_Call_To_Handler\n-                       (RE_Update_Exception, New_List (Arg));\n-                  end;\n-\n-                  --  For the normal case, we have to worry about the state of\n-                  --  abort deferral. Generally, we defer abort during runtime\n-                  --  handling of exceptions. When control is passed to the\n-                  --  handler, then in the normal case we undefer aborts. In\n-                  --  any case this entire handling is relevant only if aborts\n-                  --  are allowed.\n-\n-               elsif Abort_Allowed\n+               --  For the normal case, we have to worry about the state of\n+               --  abort deferral. Generally, we defer abort during runtime\n+               --  handling of exceptions. When control is passed to the\n+               --  handler, then in the normal case we undefer aborts. In\n+               --  any case this entire handling is relevant only if aborts\n+               --  are allowed.\n+\n+               if Abort_Allowed\n                  and then Exception_Mechanism /= Back_End_Exceptions\n                then\n                   --  There are some special cases in which we do not do the\n@@ -1269,14 +1250,6 @@ package body Exp_Ch11 is\n    --  Start of processing for Expand_N_Exception_Declaration\n \n    begin\n-      --  There is no expansion needed when compiling for the JVM since the\n-      --  JVM has a built-in exception mechanism. See cil/gnatlib/a-except.ads\n-      --  for details.\n-\n-      if VM_Target /= No_VM then\n-         return;\n-      end if;\n-\n       --  Definition of the external name: nam : constant String := \"A.B.NAME\";\n \n       Ex_Id :=\n@@ -1726,13 +1699,12 @@ package body Exp_Ch11 is\n \n       else\n          --  Bypass expansion to a run-time call when back-end exception\n-         --  handling is active, unless the target is a VM, CodePeer or\n-         --  GNATprove. In CodePeer, raising an exception is treated as an\n-         --  error, while in GNATprove all code with exceptions falls outside\n-         --  the subset of code which can be formally analyzed.\n+         --  handling is active, unless the target is CodePeer or GNATprove.\n+         --  In CodePeer, raising an exception is treated as an error, while in\n+         --  GNATprove all code with exceptions falls outside the subset of\n+         --  code which can be formally analyzed.\n \n-         if VM_Target = No_VM\n-           and then not CodePeer_Mode\n+         if not CodePeer_Mode\n            and then Exception_Mechanism = Back_End_Exceptions\n          then\n             return;"}, {"sha": "6fd7dedfcae337df45415523013c1875252e0815", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -47,7 +47,6 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n@@ -291,12 +290,6 @@ package body Exp_Ch13 is\n \n       if Restriction_Active (No_Finalization) then\n          return;\n-\n-      --  Do not create a specialized Deallocate since .NET/JVM compilers do\n-      --  not support pools and address arithmetic.\n-\n-      elsif VM_Target /= No_VM then\n-         return;\n       end if;\n \n       --  Use the base type to perform the check for finalization master"}, {"sha": "8f8b6d741b23d572f44525d9b3b3f5687c007a18", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 61, "deletions": 149, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -671,14 +671,9 @@ package body Exp_Ch3 is\n       --  Nothing to generate in the following cases:\n \n       --    1. Initialization is suppressed for the type\n-      --    2. The type is a value type, in the CIL sense.\n-      --    3. The type has CIL/JVM convention.\n-      --    4. An initialization already exists for the base type\n+      --    2. An initialization already exists for the base type\n \n       if Initialization_Suppressed (A_Type)\n-        or else Is_Value_Type (Comp_Type)\n-        or else Convention (A_Type) = Convention_CIL\n-        or else Convention (A_Type) = Convention_Java\n         or else Present (Base_Init_Proc (A_Type))\n       then\n          return;\n@@ -1480,13 +1475,8 @@ package body Exp_Ch3 is\n       --  Nothing to do if the Init_Proc is null, unless Initialize_Scalars\n       --  is active (in which case we make the call anyway, since in the\n       --  actual compiled client it may be non null).\n-      --  Also nothing to do for value types.\n \n-      if (Is_Null_Init_Proc (Proc) and then not Init_Or_Norm_Scalars)\n-        or else Is_Value_Type (Typ)\n-        or else\n-          (Is_Array_Type (Typ) and then Is_Value_Type (Component_Type (Typ)))\n-      then\n+      if Is_Null_Init_Proc (Proc) and then not Init_Or_Norm_Scalars then\n          return Empty_List;\n       end if;\n \n@@ -1861,8 +1851,8 @@ package body Exp_Ch3 is\n          Set_No_Ctrl_Actions (First (Res));\n \n          --  Adjust the tag if tagged (because of possible view conversions).\n-         --  Suppress the tag adjustment when VM_Target because VM tags are\n-         --  represented implicitly in objects.\n+         --  Suppress the tag adjustment when not Tagged_Type_Expansion because\n+         --  tags are represented implicitly in objects.\n \n          if Is_Tagged_Type (Typ) and then Tagged_Type_Expansion then\n             Append_To (Res,\n@@ -2174,8 +2164,8 @@ package body Exp_Ch3 is\n       begin\n          --  Offset_To_Top_Functions are built only for derivations of types\n          --  with discriminants that cover interface types.\n-         --  Nothing is needed either in case of virtual machines, since\n-         --  interfaces are handled directly by the VM.\n+         --  Nothing is needed either in case of virtual targets, since\n+         --  interfaces are handled directly by the target.\n \n          if not Is_Tagged_Type (Rec_Type)\n            or else Etype (Rec_Type) = Rec_Type\n@@ -2439,10 +2429,10 @@ package body Exp_Ch3 is\n \n          --     _Init._Tag := Typ'Tag;\n \n-         --  Suppress the tag assignment when VM_Target because VM tags are\n-         --  represented implicitly in objects. It is also suppressed in case\n-         --  of CPP_Class types because in this case the tag is initialized in\n-         --  the C++ side.\n+         --  Suppress the tag assignment when not Tagged_Type_Expansion because\n+         --  tags are represented implicitly in objects. It is also suppressed\n+         --  in case of CPP_Class types because in this case the tag is\n+         --  initialized in the C++ side.\n \n          if Is_Tagged_Type (Rec_Type)\n            and then Tagged_Type_Expansion\n@@ -2694,11 +2684,7 @@ package body Exp_Ch3 is\n            --  list by Insert_Actions.\n \n            and then Nkind (First_Non_SCIL_Node (Body_Stmts)) = N_Null_Statement\n-           and then VM_Target = No_VM\n          then\n-            --  Even though the init proc may be null at this time it might get\n-            --  some stuff added to it later by the VM backend.\n-\n             Set_Is_Null_Init_Proc (Proc_Id);\n          end if;\n       end Build_Init_Procedure;\n@@ -3525,14 +3511,8 @@ package body Exp_Ch3 is\n    --  Start of processing for Build_Record_Init_Proc\n \n    begin\n-      --  Check for value type, which means no initialization required\n-\n       Rec_Type := Defining_Identifier (N);\n \n-      if Is_Value_Type (Rec_Type) then\n-         return;\n-      end if;\n-\n       --  This may be full declaration of a private type, in which case\n       --  the visible entity is a record, and the private entity has been\n       --  exchanged with it in the private part of the current package.\n@@ -4761,24 +4741,6 @@ package body Exp_Ch3 is\n \n          elsif Is_Limited_Class_Wide_Type (Desig_Typ)\n            and then Tasking_Allowed\n-\n-           --  Do not create a class-wide master for types whose convention is\n-           --  Java since these types cannot embed Ada tasks anyway. Note that\n-           --  the following test cannot catch the following case:\n-\n-           --      package java.lang.Object is\n-           --         type Typ is tagged limited private;\n-           --         type Ref is access all Typ'Class;\n-           --      private\n-           --         type Typ is tagged limited ...;\n-           --         pragma Convention (Typ, Java)\n-           --      end;\n-\n-           --  Because the convention appears after we have done the\n-           --  processing for type Ref.\n-\n-           and then Convention (Desig_Typ) /= Convention_Java\n-           and then Convention (Desig_Typ) /= Convention_CIL\n          then\n             Build_Class_Wide_Master (Ptr_Typ);\n          end if;\n@@ -5147,12 +5109,11 @@ package body Exp_Ch3 is\n          --  Step 2: Initialize the components of the object\n \n          --  Do not initialize the components if their initialization is\n-         --  prohibited or the type represents a value type in a .NET VM.\n+         --  prohibited.\n \n          if Has_Non_Null_Base_Init_Proc (Typ)\n            and then not No_Initialization (N)\n            and then not Initialization_Suppressed (Typ)\n-           and then not Is_Value_Type (Typ)\n          then\n             --  Do not initialize the components if No_Default_Initialization\n             --  applies as the actual restriction check will occur later\n@@ -5898,10 +5859,10 @@ package body Exp_Ch3 is\n             --  be re-initialized separately in order to avoid the propagation\n             --  of a wrong tag coming from a view conversion unless the type\n             --  is class wide (in this case the tag comes from the init value).\n-            --  Suppress the tag assignment when VM_Target because VM tags are\n-            --  represented implicitly in objects. Ditto for types that are\n-            --  CPP_CLASS, and for initializations that are aggregates, because\n-            --  they have to have the right tag.\n+            --  Suppress the tag assignment when not Tagged_Type_Expansion\n+            --  because tags are represented implicitly in objects. Ditto for\n+            --  types that are CPP_CLASS, and for initializations that are\n+            --  aggregates, because they have to have the right tag.\n \n             --  The re-assignment of the tag has to be done even if the object\n             --  is a constant. The assignment must be analyzed after the\n@@ -6500,18 +6461,10 @@ package body Exp_Ch3 is\n \n       elsif Is_Concurrent_Type (Root)\n         or else Is_C_Derivation (Root)\n-        or else Convention (Typ) = Convention_CIL\n         or else Convention (Typ) = Convention_CPP\n-        or else Convention (Typ) = Convention_Java\n       then\n          return;\n \n-      --  Do not create TSS routine Finalize_Address for .NET/JVM because these\n-      --  targets do not support address arithmetic and unchecked conversions.\n-\n-      elsif VM_Target /= No_VM then\n-         return;\n-\n       --  Do not create TSS routine Finalize_Address when compiling in CodePeer\n       --  mode since the routine contains an Unchecked_Conversion.\n \n@@ -7034,14 +6987,6 @@ package body Exp_Ch3 is\n             then\n                null;\n \n-            --  Do not add the spec of predefined primitives in case of\n-            --  CIL and Java tagged types\n-\n-            elsif Convention (Def_Id) = Convention_CIL\n-              or else Convention (Def_Id) = Convention_Java\n-            then\n-               null;\n-\n             --  Do not add the spec of the predefined primitives if we are\n             --  compiling under restriction No_Dispatching_Calls.\n \n@@ -7098,8 +7043,8 @@ package body Exp_Ch3 is\n             end if;\n \n             --  Create and decorate the tags. Suppress their creation when\n-            --  VM_Target because the dispatching mechanism is handled\n-            --  internally by the VMs.\n+            --  not Tagged_Type_Expansion because the dispatching mechanism is\n+            --  handled internally by the virtual target.\n \n             if Tagged_Type_Expansion then\n                Append_Freeze_Actions (Def_Id, Make_Tags (Def_Id));\n@@ -7111,9 +7056,6 @@ package body Exp_Ch3 is\n                if not Building_Static_DT (Def_Id) then\n                   Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n                end if;\n-\n-            elsif VM_Target /= No_VM then\n-               Append_Freeze_Actions (Def_Id, Make_VM_TSD (Def_Id));\n             end if;\n \n             --  If the type has unknown discriminants, propagate dispatching\n@@ -7240,8 +7182,8 @@ package body Exp_Ch3 is\n \n       if Tagged_Type_Expansion or else not Is_Interface (Def_Id) then\n \n-         --  Do not need init for interfaces on e.g. CIL since they're\n-         --  abstract. Helps operation of peverify (the PE Verify tool).\n+         --  Do not need init for interfaces on virtual targets since they're\n+         --  abstract.\n \n          Build_Record_Init_Proc (Type_Decl, Def_Id);\n       end if;\n@@ -7262,14 +7204,6 @@ package body Exp_Ch3 is\n          then\n             null;\n \n-         --  Do not add the body of predefined primitives in case of CIL and\n-         --  Java tagged types.\n-\n-         elsif Convention (Def_Id) = Convention_CIL\n-           or else Convention (Def_Id) = Convention_Java\n-         then\n-            null;\n-\n          --  Do not add the body of the predefined primitives if we are\n          --  compiling under restriction No_Dispatching_Calls or if we are\n          --  compiling a CPP tagged type.\n@@ -7345,75 +7279,62 @@ package body Exp_Ch3 is\n                  and then Needs_Finalization (Designated_Type (Comp_Typ))\n                  and then Designated_Type (Comp_Typ) /= Def_Id\n                then\n-                  if VM_Target = No_VM then\n-\n-                     --  Build a homogeneous master for the first anonymous\n-                     --  access-to-controlled component. This master may be\n-                     --  converted into a heterogeneous collection if more\n-                     --  components are to follow.\n+                  --  Build a homogeneous master for the first anonymous\n+                  --  access-to-controlled component. This master may be\n+                  --  converted into a heterogeneous collection if more\n+                  --  components are to follow.\n \n-                     if not Master_Built then\n-                        Master_Built := True;\n+                  if not Master_Built then\n+                     Master_Built := True;\n \n-                        --  All anonymous access-to-controlled types allocate\n-                        --  on the global pool. Note that the finalization\n-                        --  master and the associated storage pool must be set\n-                        --  on the root type (both are \"root type only\").\n+                     --  All anonymous access-to-controlled types allocate\n+                     --  on the global pool. Note that the finalization\n+                     --  master and the associated storage pool must be set\n+                     --  on the root type (both are \"root type only\").\n \n-                        Set_Associated_Storage_Pool\n-                          (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n+                     Set_Associated_Storage_Pool\n+                       (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n \n-                        Build_Finalization_Master\n-                          (Typ            => Root_Type (Comp_Typ),\n-                           For_Anonymous  => True,\n-                           Context_Scope  => Encl_Scope,\n-                           Insertion_Node => Ins_Node);\n+                     Build_Finalization_Master\n+                       (Typ            => Root_Type (Comp_Typ),\n+                        For_Anonymous  => True,\n+                        Context_Scope  => Encl_Scope,\n+                        Insertion_Node => Ins_Node);\n \n-                        Fin_Mas_Id := Finalization_Master (Comp_Typ);\n+                     Fin_Mas_Id := Finalization_Master (Comp_Typ);\n \n-                     --  Subsequent anonymous access-to-controlled components\n-                     --  reuse the available master.\n+                  --  Subsequent anonymous access-to-controlled components\n+                  --  reuse the available master.\n \n-                     else\n-                        --  All anonymous access-to-controlled types allocate\n-                        --  on the global pool. Note that both the finalization\n-                        --  master and the associated storage pool must be set\n-                        --  on the root type (both are \"root type only\").\n+                  else\n+                     --  All anonymous access-to-controlled types allocate\n+                     --  on the global pool. Note that both the finalization\n+                     --  master and the associated storage pool must be set\n+                     --  on the root type (both are \"root type only\").\n \n-                        Set_Associated_Storage_Pool\n-                          (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n+                     Set_Associated_Storage_Pool\n+                       (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n \n-                        --  Shared the master among multiple components\n+                     --  Shared the master among multiple components\n \n-                        Set_Finalization_Master\n-                          (Root_Type (Comp_Typ), Fin_Mas_Id);\n+                     Set_Finalization_Master\n+                       (Root_Type (Comp_Typ), Fin_Mas_Id);\n \n-                        --  Convert the master into a heterogeneous collection.\n-                        --  Generate:\n-                        --    Set_Is_Heterogeneous (<Fin_Mas_Id>);\n+                     --  Convert the master into a heterogeneous collection.\n+                     --  Generate:\n+                     --    Set_Is_Heterogeneous (<Fin_Mas_Id>);\n \n-                        if not Attributes_Set then\n-                           Attributes_Set := True;\n+                     if not Attributes_Set then\n+                        Attributes_Set := True;\n \n-                           Insert_Action (Ins_Node,\n-                             Make_Procedure_Call_Statement (Loc,\n-                               Name                   =>\n-                                 New_Occurrence_Of\n-                                   (RTE (RE_Set_Is_Heterogeneous), Loc),\n-                               Parameter_Associations => New_List (\n-                                 New_Occurrence_Of (Fin_Mas_Id, Loc))));\n-                        end if;\n+                        Insert_Action (Ins_Node,\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of\n+                                (RTE (RE_Set_Is_Heterogeneous), Loc),\n+                            Parameter_Associations => New_List (\n+                              New_Occurrence_Of (Fin_Mas_Id, Loc))));\n                      end if;\n-\n-                  --  Since .NET/JVM targets do not support heterogeneous\n-                  --  masters, each component must have its own master.\n-\n-                  else\n-                     Build_Finalization_Master\n-                       (Typ            => Comp_Typ,\n-                        For_Anonymous  => True,\n-                        Context_Scope  => Encl_Scope,\n-                        Insertion_Node => Ins_Node);\n                   end if;\n                end if;\n \n@@ -7747,10 +7668,6 @@ package body Exp_Ch3 is\n             elsif Ada_Version >= Ada_2012\n               and then Present (Associated_Storage_Pool (Def_Id))\n \n-              --  Omit this check on .NET/JVM where pools are not supported\n-\n-              and then VM_Target = No_VM\n-\n               --  Omit this check for the case of a configurable run-time that\n               --  does not provide package System.Storage_Pools.Subpools.\n \n@@ -9859,11 +9776,6 @@ package body Exp_Ch3 is\n       if Restriction_Active (No_Finalization) then\n          null;\n \n-      --  Finalization is not available for CIL value types\n-\n-      elsif Is_Value_Type (Tag_Typ) then\n-         null;\n-\n       else\n          if not Is_Limited_Type (Tag_Typ) then\n             Append_To (Res, Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust));"}, {"sha": "3463d3aae33b6d6b47b39d1e412a7d1f06ca93a6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 33, "deletions": 134, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -544,37 +544,30 @@ package body Exp_Ch4 is\n \n          --  Step 2: Initialization actions\n \n-         --  Do not set the base pool and mode of operation on .NET/JVM since\n-         --  those targets do not support pools and all VM masters defaulted to\n-         --  heterogeneous.\n-\n-         if VM_Target = No_VM then\n-\n-            --  Generate:\n-            --    Set_Base_Pool\n-            --      (<FM_Id>, Global_Pool_Object'Unrestricted_Access);\n+         --  Generate:\n+         --    Set_Base_Pool\n+         --      (<FM_Id>, Global_Pool_Object'Unrestricted_Access);\n \n-            Insert_And_Analyze (Decls,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n-                Parameter_Associations => New_List (\n-                  New_Occurrence_Of (FM_Id, Loc),\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         =>\n-                      New_Occurrence_Of (RTE (RE_Global_Pool_Object), Loc),\n-                    Attribute_Name => Name_Unrestricted_Access))));\n+         Insert_And_Analyze (Decls,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n+             Parameter_Associations => New_List (\n+               New_Occurrence_Of (FM_Id, Loc),\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         =>\n+                   New_Occurrence_Of (RTE (RE_Global_Pool_Object), Loc),\n+                 Attribute_Name => Name_Unrestricted_Access))));\n \n-            --  Generate:\n-            --    Set_Is_Heterogeneous (<FM_Id>);\n+         --  Generate:\n+         --    Set_Is_Heterogeneous (<FM_Id>);\n \n-            Insert_And_Analyze (Decls,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (RTE (RE_Set_Is_Heterogeneous), Loc),\n-                Parameter_Associations => New_List (\n-                  New_Occurrence_Of (FM_Id, Loc))));\n-         end if;\n+         Insert_And_Analyze (Decls,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Set_Is_Heterogeneous), Loc),\n+             Parameter_Associations => New_List (\n+               New_Occurrence_Of (FM_Id, Loc))));\n \n          Pop_Scope;\n          return FM_Id;\n@@ -762,7 +755,7 @@ package body Exp_Ch4 is\n       begin\n          if Ada_Version >= Ada_2005\n            and then Is_Class_Wide_Type (DesigT)\n-           and then (Tagged_Type_Expansion or else VM_Target /= No_VM)\n+           and then Tagged_Type_Expansion\n            and then not Scope_Suppress.Suppress (Accessibility_Check)\n            and then\n              (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n@@ -1079,21 +1072,6 @@ package body Exp_Ch4 is\n                Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n                Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-               --  Attach the object to the associated finalization master.\n-               --  This is done manually on .NET/JVM since those compilers do\n-               --  no support pools and can't benefit from internally generated\n-               --  Allocate / Deallocate procedures.\n-\n-               if VM_Target /= No_VM\n-                 and then Is_Controlled (DesigT)\n-                 and then Present (Finalization_Master (PtrT))\n-               then\n-                  Insert_Action (N,\n-                    Make_Attach_Call\n-                      (Obj_Ref => New_Occurrence_Of (Temp, Loc),\n-                       Ptr_Typ => PtrT));\n-               end if;\n-\n             else\n                Node := Relocate_Node (N);\n                Set_Analyzed (Node);\n@@ -1107,21 +1085,6 @@ package body Exp_Ch4 is\n \n                Insert_Action (N, Temp_Decl);\n                Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n-\n-               --  Attach the object to the associated finalization master.\n-               --  This is done manually on .NET/JVM since those compilers do\n-               --  no support pools and can't benefit from internally generated\n-               --  Allocate / Deallocate procedures.\n-\n-               if VM_Target /= No_VM\n-                 and then Is_Controlled (DesigT)\n-                 and then Present (Finalization_Master (PtrT))\n-               then\n-                  Insert_Action (N,\n-                    Make_Attach_Call\n-                      (Obj_Ref => New_Occurrence_Of (Temp, Loc),\n-                       Ptr_Typ => PtrT));\n-               end if;\n             end if;\n \n          --  Ada 2005 (AI-251): Handle allocators whose designated type is an\n@@ -1223,7 +1186,7 @@ package body Exp_Ch4 is\n \n          --  Generate the tag assignment\n \n-         --  Suppress the tag assignment when VM_Target because VM tags are\n+         --  Suppress the tag assignment for VM targets because VM tags are\n          --  represented implicitly in objects.\n \n          if not Tagged_Type_Expansion then\n@@ -1342,21 +1305,6 @@ package body Exp_Ch4 is\n          Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n          Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-         --  Attach the object to the associated finalization master. Thisis\n-         --  done manually on .NET/JVM since those compilers do no support\n-         --  pools and cannot benefit from internally generated Allocate and\n-         --  Deallocate procedures.\n-\n-         if VM_Target /= No_VM\n-           and then Is_Controlled (DesigT)\n-           and then Present (Finalization_Master (PtrT))\n-         then\n-            Insert_Action (N,\n-              Make_Attach_Call\n-                (Obj_Ref => New_Occurrence_Of (Temp, Loc),\n-                 Ptr_Typ => PtrT));\n-         end if;\n-\n          Rewrite (N, New_Occurrence_Of (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n@@ -1529,12 +1477,10 @@ package body Exp_Ch4 is\n    begin\n       --  Deal first with unpacked case, where we can call a runtime routine\n       --  except that we avoid this for targets for which are not addressable\n-      --  by bytes, and for the JVM/CIL, since they do not support direct\n-      --  addressing of array components.\n+      --  by bytes.\n \n       if not Is_Bit_Packed_Array (Typ1)\n         and then Byte_Addressable\n-        and then VM_Target = No_VM\n       then\n          --  The call we generate is:\n \n@@ -4322,10 +4268,9 @@ package body Exp_Ch4 is\n          end if;\n \n          --  Anonymous access-to-controlled types allocate on the global pool.\n-         --  Do not set this attribute on .NET/JVM since those targets do not\n-         --  support pools. Note that this is a \"root type only\" attribute.\n+         --  Note that this is a \"root type only\" attribute.\n \n-         if No (Associated_Storage_Pool (PtrT)) and then VM_Target = No_VM then\n+         if No (Associated_Storage_Pool (PtrT)) then\n             if Present (Rel_Typ) then\n                Set_Associated_Storage_Pool\n                  (Root_Type (PtrT), Associated_Storage_Pool (Rel_Typ));\n@@ -4361,9 +4306,7 @@ package body Exp_Ch4 is\n             Set_Storage_Pool (N, Pool);\n \n             if Is_RTE (Pool, RE_SS_Pool) then\n-               if VM_Target = No_VM then\n-                  Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n-               end if;\n+               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n \n             --  In the case of an allocator for a simple storage pool, locate\n             --  and save a reference to the pool type's Allocate routine.\n@@ -4563,12 +4506,9 @@ package body Exp_Ch4 is\n          if No_Initialization (N) then\n \n             --  Even though this might be a simple allocation, create a custom\n-            --  Allocate if the context requires it. Since .NET/JVM compilers\n-            --  do not support pools, this step is skipped.\n+            --  Allocate if the context requires it.\n \n-            if VM_Target = No_VM\n-              and then Present (Finalization_Master (PtrT))\n-            then\n+            if Present (Finalization_Master (PtrT)) then\n                Build_Allocate_Deallocate_Proc\n                  (N           => N,\n                   Is_Allocate => True);\n@@ -4870,24 +4810,6 @@ package body Exp_Ch4 is\n                     Make_Init_Call\n                       (Obj_Ref => New_Copy_Tree (Init_Arg1),\n                        Typ     => T));\n-\n-                  --  Special processing for .NET/JVM, the allocated object is\n-                  --  attached to the finalization master. Generate:\n-\n-                  --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n-\n-                  --  Types derived from [Limited_]Controlled are the only ones\n-                  --  considered since they have fields Prev and Next.\n-\n-                  if VM_Target /= No_VM\n-                    and then Is_Controlled (T)\n-                    and then Present (Finalization_Master (PtrT))\n-                  then\n-                     Insert_Action (N,\n-                       Make_Attach_Call\n-                         (Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                          Ptr_Typ => PtrT));\n-                  end if;\n                end if;\n \n                Rewrite (N, New_Occurrence_Of (Temp, Loc));\n@@ -5604,11 +5526,6 @@ package body Exp_Ch4 is\n         and then Nkind (Rop) in N_Has_Entity\n         and then Ltyp = Entity (Rop)\n \n-        --  Skip in VM mode, where we have no sense of invalid values. The\n-        --  warning still seems relevant, but not important enough to worry.\n-\n-        and then VM_Target = No_VM\n-\n         --  Skip this for predicated types, where such expressions are a\n         --  reasonable way of testing if something meets the predicate.\n \n@@ -5684,10 +5601,6 @@ package body Exp_Ch4 is\n               --  Relevant only for source cases\n \n               and then Comes_From_Source (N)\n-\n-              --  Omit for VM cases, where we don't have invalid values\n-\n-              and then VM_Target = No_VM\n             then\n                Substitute_Valid_Check;\n                goto Leave;\n@@ -5845,9 +5758,9 @@ package body Exp_Ch4 is\n \n             if Is_Tagged_Type (Typ) then\n \n-               --  No expansion will be performed when VM_Target, as the VM\n+               --  No expansion will be performed for VM targets, as the VM\n                --  back-ends will handle the membership tests directly (tags\n-               --  are not explicitly represented in Java objects, so the\n+               --  are not explicitly represented in VM objects, so the\n                --  normal tagged membership expansion is not what we want).\n \n                if Tagged_Type_Expansion then\n@@ -6105,10 +6018,10 @@ package body Exp_Ch4 is\n                                 Left_Opnd  => Obj,\n                                 Right_Opnd => Make_Null (Loc))));\n \n-                        --  No expansion will be performed when VM_Target, as\n+                        --  No expansion will be performed for VM targets, as\n                         --  the VM back-ends will handle the membership tests\n                         --  directly (tags are not explicitly represented in\n-                        --  Java objects, so the normal tagged membership\n+                        --  objects, so the normal tagged membership\n                         --  expansion is not what we want).\n \n                         if Tagged_Type_Expansion then\n@@ -11449,15 +11362,6 @@ package body Exp_Ch4 is\n \n               or else Chars (Comp) = Name_uTag\n \n-              --  The .NET/JVM version of type Root_Controlled contains two\n-              --  fields which should not be considered part of the object. To\n-              --  achieve proper equiality between two controlled objects on\n-              --  .NET/JVM, skip _Parent whenever it has type Root_Controlled.\n-\n-              or else (Chars (Comp) = Name_uParent\n-                        and then VM_Target /= No_VM\n-                        and then Etype (Comp) = RTE (RE_Root_Controlled))\n-\n               --  Skip interface elements (secondary tags???)\n \n               or else Is_Interface (Etype (Comp)));\n@@ -13255,11 +13159,6 @@ package body Exp_Ch4 is\n       if Component_Size (Etype (Lhs)) /= System_Storage_Unit then\n          return False;\n \n-      --  Cannot do in place stuff on VM_Target since cannot pass addresses\n-\n-      elsif VM_Target /= No_VM then\n-         return False;\n-\n       --  Cannot do in place stuff if non-standard Boolean representation\n \n       elsif Has_Non_Standard_Rep (Component_Type (Etype (Lhs))) then"}, {"sha": "c0cd6044180f47e94349aae8cd9561bf977b1d5f", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 100, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -387,14 +387,6 @@ package body Exp_Ch5 is\n         and then\n            (not Is_Constrained (Etype (Lhs))\n              or else not Is_First_Subtype (Etype (Lhs)))\n-\n-         --  In the case of compiling for the Java or .NET Virtual Machine,\n-         --  slices are always passed by making a copy, so we don't have to\n-         --  worry about overlap. We also want to prevent generation of \"<\"\n-         --  comparisons for array addresses, since that's a meaningless\n-         --  operation on the VM.\n-\n-        and then VM_Target = No_VM\n       then\n          Set_Forwards_OK  (N, False);\n          Set_Backwards_OK (N, False);\n@@ -764,7 +756,7 @@ package body Exp_Ch5 is\n             --  The GCC back end can deal with all cases of overlap by falling\n             --  back to memmove if it cannot use a more efficient approach.\n \n-            if VM_Target = No_VM and not AAMP_On_Target then\n+            if not AAMP_On_Target then\n                return;\n \n             --  Assume other back ends can handle it if Forwards_OK is set\n@@ -937,9 +929,9 @@ package body Exp_Ch5 is\n             --  We normally compare addresses to find out which way round to\n             --  do the loop, since this is reliable, and handles the cases of\n             --  parameters, conversions etc. But we can't do that in the bit\n-            --  packed case or the VM case, because addresses don't work there.\n+            --  packed case, because addresses don't work there.\n \n-            if not Is_Bit_Packed_Array (L_Type) and then VM_Target = No_VM then\n+            if not Is_Bit_Packed_Array (L_Type) then\n                Condition :=\n                  Make_Op_Le (Loc,\n                    Left_Opnd =>\n@@ -2165,14 +2157,6 @@ package body Exp_Ch5 is\n       then\n          Make_Build_In_Place_Call_In_Assignment (N, Rhs);\n \n-      elsif Is_Tagged_Type (Typ) and then Is_Value_Type (Etype (Lhs)) then\n-\n-         --  Nothing to do for valuetypes\n-         --  ??? Set_Scope_Is_Transient (False);\n-\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n-\n       elsif Is_Tagged_Type (Typ)\n         or else (Needs_Finalization (Typ) and then not Is_Array_Type (Typ))\n       then\n@@ -2208,7 +2192,6 @@ package body Exp_Ch5 is\n                --  generated.\n \n                or else (Is_Tagged_Type (Typ)\n-                         and then not Is_Value_Type (Etype (Lhs))\n                          and then Chars (Current_Scope) /= Name_uAssign\n                          and then Expand_Ctrl_Actions\n                          and then\n@@ -4577,11 +4560,6 @@ package body Exp_Ch5 is\n                                        and then not Comp_Asn\n                                        and then not No_Ctrl_Actions (N)\n                                        and then Tagged_Type_Expansion;\n-      --  Tags are not saved and restored when VM_Target because VM tags are\n-      --  represented implicitly in objects.\n-\n-      Next_Id : Entity_Id;\n-      Prev_Id : Entity_Id;\n       Tag_Id  : Entity_Id;\n \n    begin\n@@ -4642,48 +4620,6 @@ package body Exp_Ch5 is\n          Tag_Id := Empty;\n       end if;\n \n-      --  Save the Prev and Next fields on .NET/JVM. This is not needed on non\n-      --  VM targets since the fields are not part of the object.\n-\n-      if VM_Target /= No_VM\n-        and then Is_Controlled (T)\n-      then\n-         Prev_Id := Make_Temporary (Loc, 'P');\n-         Next_Id := Make_Temporary (Loc, 'N');\n-\n-         --  Generate:\n-         --    Pnn : Root_Controlled_Ptr := Root_Controlled (L).Prev;\n-\n-         Append_To (Res,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Prev_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Root_Controlled_Ptr), Loc),\n-             Expression          =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        =>\n-                   Unchecked_Convert_To\n-                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n-                 Selector_Name =>\n-                   Make_Identifier (Loc, Name_Prev))));\n-\n-         --  Generate:\n-         --    Nnn : Root_Controlled_Ptr := Root_Controlled (L).Next;\n-\n-         Append_To (Res,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Next_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Root_Controlled_Ptr), Loc),\n-             Expression          =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        =>\n-                   Unchecked_Convert_To\n-                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n-                 Selector_Name =>\n-                   Make_Identifier (Loc, Name_Next))));\n-      end if;\n-\n       --  If the tagged type has a full rep clause, expand the assignment into\n       --  component-wise assignments. Mark the node as unanalyzed in order to\n       --  generate the proper code and propagate this scenario by setting a\n@@ -4709,39 +4645,6 @@ package body Exp_Ch5 is\n              Expression => New_Occurrence_Of (Tag_Id, Loc)));\n       end if;\n \n-      --  Restore the Prev and Next fields on .NET/JVM\n-\n-      if VM_Target /= No_VM\n-        and then Is_Controlled (T)\n-      then\n-         --  Generate:\n-         --    Root_Controlled (L).Prev := Prev_Id;\n-\n-         Append_To (Res,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        =>\n-                   Unchecked_Convert_To\n-                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n-                 Selector_Name =>\n-                   Make_Identifier (Loc, Name_Prev)),\n-             Expression => New_Occurrence_Of (Prev_Id, Loc)));\n-\n-         --  Generate:\n-         --    Root_Controlled (L).Next := Next_Id;\n-\n-         Append_To (Res,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        =>\n-                   Unchecked_Convert_To\n-                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n-                 Selector_Name => Make_Identifier (Loc, Name_Next)),\n-             Expression => New_Occurrence_Of (Next_Id, Loc)));\n-      end if;\n-\n       --  Adjust the target after the assignment when controlled (not in the\n       --  init proc since it is an initialization more than an assignment).\n "}, {"sha": "c2165438bf4e892c7bae07da1bf05f136a9edc89", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 33, "deletions": 109, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -369,11 +369,9 @@ package body Exp_Ch6 is\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n \n       --  Pass the Storage_Pool parameter. This parameter is omitted on\n-      --  .NET/JVM/ZFP as those targets do not support pools.\n+      --  ZFP as those targets do not support pools.\n \n-      if VM_Target = No_VM\n-        and then RTE_Available (RE_Root_Storage_Pool_Ptr)\n-      then\n+      if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n          Pool_Formal := Build_In_Place_Formal (Function_Id, BIP_Storage_Pool);\n          Analyze_And_Resolve (Pool_Actual, Etype (Pool_Formal));\n          Add_Extra_Actual_To_Call\n@@ -2357,7 +2355,6 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Curr_S        : constant Entity_Id := Current_Scope;\n       Remote        : constant Boolean   := Is_Remote_Call (Call_Node);\n       Actual        : Node_Id;\n       Formal        : Entity_Id;\n@@ -2458,52 +2455,6 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  Detect the following code in System.Finalization_Masters only on\n-      --  .NET/JVM targets:\n-\n-      --    procedure Finalize (Master : in out Finalization_Master) is\n-      --    begin\n-      --       . . .\n-      --       begin\n-      --          Finalize (Curr_Ptr.all);\n-\n-      --  Since .NET/JVM compilers lack address arithmetic and Deep_Finalize\n-      --  cannot be named in library or user code, the compiler has to deal\n-      --  with this by transforming the call to Finalize into Deep_Finalize.\n-\n-      if VM_Target /= No_VM\n-        and then Chars (Subp) = Name_Finalize\n-        and then Ekind (Curr_S) = E_Block\n-        and then Ekind (Scope (Curr_S)) = E_Procedure\n-        and then Chars (Scope (Curr_S)) = Name_Finalize\n-        and then Etype (First_Formal (Scope (Curr_S))) =\n-                   RTE (RE_Finalization_Master)\n-      then\n-         declare\n-            Deep_Fin : constant Entity_Id :=\n-                         Find_Prim_Op (RTE (RE_Root_Controlled),\n-                                       TSS_Deep_Finalize);\n-         begin\n-            --  Since Root_Controlled is a tagged type, the compiler should\n-            --  always generate Deep_Finalize for it.\n-\n-            pragma Assert (Present (Deep_Fin));\n-\n-            --  Generate:\n-            --    Deep_Finalize (Curr_Ptr.all);\n-\n-            Rewrite (N,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Occurrence_Of (Deep_Fin, Loc),\n-                Parameter_Associations =>\n-                  New_Copy_List_Tree (Parameter_Associations (N))));\n-\n-            Analyze (N);\n-            return;\n-         end;\n-      end if;\n-\n       --  Ada 2005 (AI-345): We have a procedure call as a triggering\n       --  alternative in an asynchronous select or as an entry call in\n       --  a conditional or timed select. Check whether the procedure call\n@@ -2952,15 +2903,6 @@ package body Exp_Ch6 is\n             elsif Nkind_In (Prev, N_Allocator, N_Attribute_Reference) then\n                null;\n \n-            --  Suppress null checks when passing to access parameters of Java\n-            --  and CIL subprograms. (Should this be done for other foreign\n-            --  conventions as well ???)\n-\n-            elsif Convention (Subp) = Convention_Java\n-              or else Convention (Subp) = Convention_CIL\n-            then\n-               null;\n-\n             else\n                Install_Null_Excluding_Check (Prev);\n             end if;\n@@ -3291,7 +3233,7 @@ package body Exp_Ch6 is\n       --  extra actuals since this will be done on the re-analysis of the\n       --  dispatching call. Note that we do not try to shorten the actual list\n       --  for a dispatching call, it would not make sense to do so. Expansion\n-      --  of dispatching calls is suppressed when VM_Target, because the VM\n+      --  of dispatching calls is suppressed for VM targets, because the VM\n       --  back-ends directly handle the generation of dispatching calls and\n       --  would have to undo any expansion to an indirect call.\n \n@@ -4068,12 +4010,9 @@ package body Exp_Ch6 is\n       begin\n          pragma Assert (Is_Build_In_Place_Function (Func_Id));\n \n-         --  Processing for build-in-place object allocation. This is disabled\n-         --  on .NET/JVM because the targets do not support pools.\n+         --  Processing for build-in-place object allocation.\n \n-         if VM_Target = No_VM\n-           and then Needs_Finalization (Ret_Typ)\n-         then\n+         if Needs_Finalization (Ret_Typ) then\n             declare\n                Decls      : constant List_Id := New_List;\n                Fin_Mas_Id : constant Entity_Id :=\n@@ -4667,12 +4606,10 @@ package body Exp_Ch6 is\n                      Pool_Allocator := New_Copy_Tree (Heap_Allocator);\n \n                      --  Do not generate the renaming of the build-in-place\n-                     --  pool parameter on .NET/JVM/ZFP because the parameter\n-                     --  is not created in the first place.\n+                     --  pool parameter on ZFP because the parameter is not\n+                     --  created in the first place.\n \n-                     if VM_Target = No_VM\n-                       and then RTE_Available (RE_Root_Storage_Pool_Ptr)\n-                     then\n+                     if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n                         Pool_Decl :=\n                           Make_Object_Renaming_Declaration (Loc,\n                             Defining_Identifier => Pool_Id,\n@@ -4721,29 +4658,26 @@ package body Exp_Ch6 is\n                         Set_Comes_From_Source (Pool_Allocator, True);\n                      end if;\n \n-                     --  The allocator is returned on the secondary stack. We\n-                     --  don't do this on VM targets, since the SS is not used.\n+                     --  The allocator is returned on the secondary stack.\n \n-                     if VM_Target = No_VM then\n-                        Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n-                        Set_Procedure_To_Call\n-                          (SS_Allocator, RTE (RE_SS_Allocate));\n-\n-                        --  The allocator is returned on the secondary stack,\n-                        --  so indicate that the function return, as well as\n-                        --  the block that encloses the allocator, must not\n-                        --  release it. The flags must be set now because\n-                        --  the decision to use the secondary stack is done\n-                        --  very late in the course of expanding the return\n-                        --  statement, past the point where these flags are\n-                        --  normally set.\n-\n-                        Set_Sec_Stack_Needed_For_Return (Par_Func);\n-                        Set_Sec_Stack_Needed_For_Return\n-                          (Return_Statement_Entity (N));\n-                        Set_Uses_Sec_Stack (Par_Func);\n-                        Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n-                     end if;\n+                     Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n+                     Set_Procedure_To_Call\n+                       (SS_Allocator, RTE (RE_SS_Allocate));\n+\n+                     --  The allocator is returned on the secondary stack,\n+                     --  so indicate that the function return, as well as\n+                     --  the block that encloses the allocator, must not\n+                     --  release it. The flags must be set now because\n+                     --  the decision to use the secondary stack is done\n+                     --  very late in the course of expanding the return\n+                     --  statement, past the point where these flags are\n+                     --  normally set.\n+\n+                     Set_Sec_Stack_Needed_For_Return (Par_Func);\n+                     Set_Sec_Stack_Needed_For_Return\n+                       (Return_Statement_Entity (N));\n+                     Set_Uses_Sec_Stack (Par_Func);\n+                     Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n \n                      --  Create an if statement to test the BIP_Alloc_Form\n                      --  formal and initialize the access object to either the\n@@ -6174,13 +6108,7 @@ package body Exp_Ch6 is\n          else\n             Check_Restriction (No_Secondary_Stack, N);\n             Set_Storage_Pool (N, RTE (RE_SS_Pool));\n-\n-            --  If we are generating code for the VM do not use\n-            --  SS_Allocate since everything is heap-allocated anyway.\n-\n-            if VM_Target = No_VM then\n-               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n-            end if;\n+            Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n          end if;\n       end if;\n \n@@ -8178,8 +8106,8 @@ package body Exp_Ch6 is\n \n    begin\n       --  We suppress the initialization of the dispatch table entry when\n-      --  VM_Target because the dispatching mechanism is handled internally\n-      --  by the VM.\n+      --  not Tagged_Type_Expansion because the dispatching mechanism is\n+      --  handled internally by the target.\n \n       if Is_Dispatching_Operation (Subp)\n         and then not Is_Abstract_Subprogram (Subp)\n@@ -8454,9 +8382,7 @@ package body Exp_Ch6 is\n          --  pool, and pass the pool. Use 'Unrestricted_Access because the\n          --  pool may not be aliased.\n \n-         if VM_Target = No_VM\n-           and then Present (Associated_Storage_Pool (Acc_Type))\n-         then\n+         if Present (Associated_Storage_Pool (Acc_Type)) then\n             Alloc_Form := User_Storage_Pool;\n             Pool :=\n               Make_Attribute_Reference (Loc,\n@@ -8983,14 +8909,12 @@ package body Exp_Ch6 is\n          --  has an unconstrained or tagged result type).\n \n          if Needs_BIP_Alloc_Form (Enclosing_Func) then\n-            if VM_Target = No_VM and then\n-              RTE_Available (RE_Root_Storage_Pool_Ptr)\n-            then\n+            if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n                Pool_Actual :=\n                  New_Occurrence_Of (Build_In_Place_Formal\n                    (Enclosing_Func, BIP_Storage_Pool), Loc);\n \n-            --  The build-in-place pool formal is not built on .NET/JVM\n+            --  The build-in-place pool formal is not built on e.g. ZFP\n \n             else\n                Pool_Actual := Empty;"}, {"sha": "cc5948195ab37bd5019263d4a556bdc0cd492f4f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 78, "deletions": 131, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -61,7 +61,6 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -458,16 +457,13 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Array_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n-         --  .NET do not support address arithmetic and unchecked conversions.\n+         --  Create TSS primitive Finalize_Address.\n \n-         if VM_Target = No_VM then\n-            Set_TSS (Typ,\n-              Make_Deep_Proc\n-                (Prim  => Address_Case,\n-                 Typ   => Typ,\n-                 Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n-         end if;\n+         Set_TSS (Typ,\n+           Make_Deep_Proc\n+             (Prim  => Address_Case,\n+              Typ   => Typ,\n+              Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n       end if;\n    end Build_Array_Deep_Procs;\n \n@@ -845,13 +841,11 @@ package body Exp_Ch7 is\n       if Restriction_Active (No_Finalization) then\n          return;\n \n-      --  Do not process C, C++, CIL and Java types since it is assumend that\n-      --  the non-Ada side will handle their clean up.\n+      --  Do not process C, C++ types since it is assumed that the non-Ada side\n+      --  will handle their clean up.\n \n       elsif Convention (Desig_Typ) = Convention_C\n-        or else Convention (Desig_Typ) = Convention_CIL\n         or else Convention (Desig_Typ) = Convention_CPP\n-        or else Convention (Desig_Typ) = Convention_Java\n       then\n          return;\n \n@@ -896,13 +890,6 @@ package body Exp_Ch7 is\n       then\n          return;\n \n-      --  For .NET/JVM targets, allow the processing of access-to-controlled\n-      --  types where the designated type is explicitly derived from [Limited_]\n-      --  Controlled.\n-\n-      elsif VM_Target /= No_VM and then not Is_Controlled (Desig_Typ) then\n-         return;\n-\n       --  Do not create finalization masters in GNATprove mode because this\n       --  unwanted extra expansion. A compilation in this mode keeps the tree\n       --  as close as possible to the original sources.\n@@ -948,85 +935,81 @@ package body Exp_Ch7 is\n                New_Occurrence_Of (RTE (RE_Finalization_Master), Loc)));\n \n          --  Set the associated pool and primitive Finalize_Address of the new\n-         --  finalization master. This step is skipped on .NET/JVM because the\n-         --  target does not support storage pools or address arithmetic.\n+         --  finalization master.\n \n-         if VM_Target = No_VM then\n+         --  The access type has a user-defined storage pool, use it\n \n-            --  The access type has a user-defined storage pool, use it\n+         if Present (Associated_Storage_Pool (Ptr_Typ)) then\n+            Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n \n-            if Present (Associated_Storage_Pool (Ptr_Typ)) then\n-               Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n+         --  Otherwise the default choice is the global storage pool\n \n-            --  Otherwise the default choice is the global storage pool\n-\n-            else\n-               Pool_Id := RTE (RE_Global_Pool_Object);\n-               Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n-            end if;\n+         else\n+            Pool_Id := RTE (RE_Global_Pool_Object);\n+            Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n+         end if;\n \n-            --  Generate:\n-            --    Set_Base_Pool (<Ptr_Typ>FM, Pool_Id'Unchecked_Access);\n+         --  Generate:\n+         --    Set_Base_Pool (<Ptr_Typ>FM, Pool_Id'Unchecked_Access);\n \n-            Append_To (Actions,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n-                Parameter_Associations => New_List (\n-                  New_Occurrence_Of (Fin_Mas_Id, Loc),\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Occurrence_Of (Pool_Id, Loc),\n-                    Attribute_Name => Name_Unrestricted_Access))));\n+         Append_To (Actions,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n+             Parameter_Associations => New_List (\n+               New_Occurrence_Of (Fin_Mas_Id, Loc),\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Occurrence_Of (Pool_Id, Loc),\n+                 Attribute_Name => Name_Unrestricted_Access))));\n \n-            --  Finalize_Address is not generated in CodePeer mode because the\n-            --  body contains address arithmetic. Skip this step.\n+         --  Finalize_Address is not generated in CodePeer mode because the\n+         --  body contains address arithmetic. Skip this step.\n \n-            if CodePeer_Mode then\n-               null;\n+         if CodePeer_Mode then\n+            null;\n \n-            --  Associate the Finalize_Address primitive of the designated type\n-            --  with the finalization master of the access type. The designated\n-            --  type must be forzen as Finalize_Address is generated when the\n-            --  freeze node is expanded.\n+         --  Associate the Finalize_Address primitive of the designated type\n+         --  with the finalization master of the access type. The designated\n+         --  type must be forzen as Finalize_Address is generated when the\n+         --  freeze node is expanded.\n \n-            elsif Is_Frozen (Desig_Typ)\n-              and then Present (Finalize_Address (Desig_Typ))\n+         elsif Is_Frozen (Desig_Typ)\n+           and then Present (Finalize_Address (Desig_Typ))\n \n-              --  The finalization master of an anonymous access type may need\n-              --  to be inserted in a specific place in the tree. For instance:\n+           --  The finalization master of an anonymous access type may need\n+           --  to be inserted in a specific place in the tree. For instance:\n \n-              --    type Comp_Typ;\n+           --    type Comp_Typ;\n \n-              --    <finalization master of \"access Comp_Typ\">\n+           --    <finalization master of \"access Comp_Typ\">\n \n-              --    type Rec_Typ is record\n-              --       Comp : access Comp_Typ;\n-              --    end record;\n+           --    type Rec_Typ is record\n+           --       Comp : access Comp_Typ;\n+           --    end record;\n \n-              --    <freeze node for Comp_Typ>\n-              --    <freeze node for Rec_Typ>\n+           --    <freeze node for Comp_Typ>\n+           --    <freeze node for Rec_Typ>\n \n-              --  Due to this oddity, the anonymous access type is stored for\n-              --  later processing (see below).\n+           --  Due to this oddity, the anonymous access type is stored for\n+           --  later processing (see below).\n \n-              and then Ekind (Ptr_Typ) /= E_Anonymous_Access_Type\n-            then\n-               --  Generate:\n-               --    Set_Finalize_Address\n-               --      (<Ptr_Typ>FM, <Desig_Typ>FD'Unrestricted_Access);\n+           and then Ekind (Ptr_Typ) /= E_Anonymous_Access_Type\n+         then\n+            --  Generate:\n+            --    Set_Finalize_Address\n+            --      (<Ptr_Typ>FM, <Desig_Typ>FD'Unrestricted_Access);\n \n-               Append_To (Actions,\n-                 Make_Set_Finalize_Address_Call\n-                   (Loc     => Loc,\n-                    Ptr_Typ => Ptr_Typ));\n+            Append_To (Actions,\n+              Make_Set_Finalize_Address_Call\n+                (Loc     => Loc,\n+                 Ptr_Typ => Ptr_Typ));\n \n-            --  Otherwise the designated type is either anonymous access or a\n-            --  Taft-amendment type and has not been frozen. Store the access\n-            --  type for later processing (see Freeze_Type).\n+         --  Otherwise the designated type is either anonymous access or a\n+         --  Taft-amendment type and has not been frozen. Store the access\n+         --  type for later processing (see Freeze_Type).\n \n-            else\n-               Add_Pending_Access_Type (Desig_Typ, Ptr_Typ);\n-            end if;\n+         else\n+            Add_Pending_Access_Type (Desig_Typ, Ptr_Typ);\n          end if;\n \n          --  A finalization master created for an anonymous access type or an\n@@ -2869,10 +2852,9 @@ package body Exp_Ch7 is\n             --    end if;\n \n             --  The generated code effectively detaches the temporary from the\n-            --  caller finalization master and deallocates the object. This is\n-            --  disabled on .NET/JVM because pools are not supported.\n+            --  caller finalization master and deallocates the object.\n \n-            if VM_Target = No_VM and then Is_Return_Object (Obj_Id) then\n+            if Is_Return_Object (Obj_Id) then\n                declare\n                   Func_Id : constant Entity_Id := Enclosing_Function (Obj_Id);\n                begin\n@@ -3261,14 +3243,10 @@ package body Exp_Ch7 is\n       --  order to detect this scenario, save the state of entry into the\n       --  finalization code.\n \n-      --  No need to do this for VM case, since VM version of Ada.Exceptions\n-      --  does not include routine Raise_From_Controlled_Operation which is the\n-      --  the sole user of flag Abort.\n-\n       --  This is not needed for library-level finalizers as they are called by\n       --  the environment task and cannot be aborted.\n \n-      if VM_Target = No_VM and then not For_Package then\n+      if not For_Package then\n          if Abort_Allowed then\n             Data.Abort_Id := Make_Temporary (Loc, 'A');\n \n@@ -3294,7 +3272,7 @@ package body Exp_Ch7 is\n             Data.Abort_Id := Empty;\n          end if;\n \n-      --  .NET/JVM or library-level finalizers\n+      --  Library-level finalizers\n \n       else\n          Data.Abort_Id := Empty;\n@@ -3424,16 +3402,13 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Record_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n-         --  .NET do not support address arithmetic and unchecked conversions.\n+         --  Create TSS primitive Finalize_Address\n \n-         if VM_Target = No_VM then\n-            Set_TSS (Typ,\n-              Make_Deep_Proc\n-                (Prim  => Address_Case,\n-                 Typ   => Typ,\n-                 Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n-         end if;\n+         Set_TSS (Typ,\n+           Make_Deep_Proc\n+             (Prim  => Address_Case,\n+              Typ   => Typ,\n+              Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n       end if;\n    end Build_Record_Deep_Procs;\n \n@@ -3930,8 +3905,7 @@ package body Exp_Ch7 is\n       Needs_Sec_Stack_Mark : constant Boolean :=\n                                Uses_Sec_Stack (Scop)\n                                  and then\n-                                   not Sec_Stack_Needed_For_Return (Scop)\n-                                 and then VM_Target = No_VM;\n+                                   not Sec_Stack_Needed_For_Return (Scop);\n       Needs_Custom_Cleanup : constant Boolean :=\n                                Nkind (N) = N_Block_Statement\n                                  and then Present (Cleanup_Actions (N));\n@@ -4064,9 +4038,6 @@ package body Exp_Ch7 is\n          --\n          --    Mnn : constant Mark_Id := SS_Mark;\n \n-         --  Suppress calls to SS_Mark and SS_Release if VM_Target, since the\n-         --  secondary stack is never used on a VM.\n-\n          if Needs_Sec_Stack_Mark then\n             Mark := Make_Temporary (Loc, 'M');\n \n@@ -5192,27 +5163,6 @@ package body Exp_Ch7 is\n       end if;\n    end Make_Adjust_Call;\n \n-   ----------------------\n-   -- Make_Attach_Call --\n-   ----------------------\n-\n-   function Make_Attach_Call\n-     (Obj_Ref : Node_Id;\n-      Ptr_Typ : Entity_Id) return Node_Id\n-   is\n-      pragma Assert (VM_Target /= No_VM);\n-\n-      Loc : constant Source_Ptr := Sloc (Obj_Ref);\n-   begin\n-      return\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   =>\n-            New_Occurrence_Of (RTE (RE_Attach), Loc),\n-          Parameter_Associations => New_List (\n-            New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n-            Unchecked_Convert_To (RTE (RE_Root_Controlled_Ptr), Obj_Ref)));\n-   end Make_Attach_Call;\n-\n    ----------------------\n    -- Make_Detach_Call --\n    ----------------------\n@@ -7928,8 +7878,7 @@ package body Exp_Ch7 is\n    begin\n       --  Case where only secondary stack use is involved\n \n-      if VM_Target = No_VM\n-        and then Uses_Sec_Stack (Current_Scope)\n+      if Uses_Sec_Stack (Current_Scope)\n         and then Nkind (Action) /= N_Simple_Return_Statement\n         and then Nkind (Par) /= N_Exception_Handler\n       then\n@@ -8144,8 +8093,7 @@ package body Exp_Ch7 is\n         (N         => N,\n          Clean     => True,\n          Manage_SS =>\n-           VM_Target = No_VM\n-             and then Uses_Sec_Stack (Curr_S)\n+           Uses_Sec_Stack (Curr_S)\n              and then Nkind (N) = N_Object_Declaration\n              and then Ekind_In (Encl_S, E_Package, E_Package_Body)\n              and then Is_Library_Level_Entity (Encl_S));\n@@ -8157,10 +8105,9 @@ package body Exp_Ch7 is\n       Transfer_Entities (Curr_S, Encl_S);\n \n       --  Mark the enclosing dynamic scope to ensure that the secondary stack\n-      --  is properly released upon exiting the said scope. This is not needed\n-      --  for .NET/JVM as those do not support the secondary stack.\n+      --  is properly released upon exiting the said scope.\n \n-      if VM_Target = No_VM and then Uses_Sec_Stack (Curr_S) then\n+      if Uses_Sec_Stack (Curr_S) then\n          Curr_S := Enclosing_Dynamic_Scope (Curr_S);\n \n          --  Do not mark a function that returns on the secondary stack as the"}, {"sha": "eac45dc0b63d9fa1f55823301817a3531d2811ec", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -169,18 +169,6 @@ package Exp_Ch7 is\n    --  adjusted. Typ is the expected type of Obj_Ref. When Skip_Self is set,\n    --  only the components (if any) are adjusted.\n \n-   function Make_Attach_Call\n-     (Obj_Ref : Node_Id;\n-      Ptr_Typ : Entity_Id) return Node_Id;\n-   --  Create a call to prepend an object to a finalization collection. Obj_Ref\n-   --  is the object, Ptr_Typ is the access type that owns the collection. This\n-   --  is used only for .NET/JVM, that is, when VM_Target /= No_VM.\n-   --  Generate the following:\n-   --\n-   --    Ada.Finalization.Heap_Management.Attach\n-   --      (<Ptr_Typ>FC,\n-   --       System.Finalization_Root.Root_Controlled_Ptr (Obj_Ref));\n-\n    function Make_Detach_Call (Obj_Ref : Node_Id) return Node_Id;\n    --  Create a call to unhook an object from an arbitrary list. Obj_Ref is the\n    --  object. Generate the following:"}, {"sha": "4c6962cddb5c0e729660bdf1a010031b7f4298a1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 17, "deletions": 64, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -4780,26 +4780,6 @@ package body Exp_Ch9 is\n                     Prefix =>\n                       New_Occurrence_Of (Defining_Identifier (N_Node), Loc)));\n \n-               --  If it is a VM_By_Copy_Actual, copy it to a new variable\n-\n-               elsif Is_VM_By_Copy_Actual (Actual) then\n-                  N_Node :=\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Make_Temporary (Loc, 'J'),\n-                      Aliased_Present     => True,\n-                      Object_Definition   =>\n-                        New_Occurrence_Of (Etype (Formal), Loc),\n-                      Expression => New_Copy_Tree (Actual));\n-                  Set_Assignment_OK (N_Node);\n-\n-                  Append (N_Node, Decls);\n-\n-                  Append_To (Plist,\n-                    Make_Attribute_Reference (Loc,\n-                      Attribute_Name => Name_Unchecked_Access,\n-                    Prefix           =>\n-                      New_Occurrence_Of (Defining_Identifier (N_Node), Loc)));\n-\n                else\n                   --  Interface class-wide formal\n \n@@ -4950,8 +4930,7 @@ package body Exp_Ch9 is\n \n             Set_Assignment_OK (Actual);\n             while Present (Actual) loop\n-               if (Is_By_Copy_Type (Etype (Actual))\n-                    or else Is_VM_By_Copy_Actual (Actual))\n+               if Is_By_Copy_Type (Etype (Actual))\n                  and then Ekind (Formal) /= E_In_Parameter\n                then\n                   N_Node :=\n@@ -7584,29 +7563,17 @@ package body Exp_Ch9 is\n              Has_Created_Identifier => True,\n              Is_Asynchronous_Call_Block => True);\n \n-         --  For the VM call Update_Exception instead of Abort_Undefer.\n-         --  See 4jexcept.ads for an explanation.\n-\n-         if VM_Target = No_VM then\n-            if Exception_Mechanism = Back_End_Exceptions then\n+         if Exception_Mechanism = Back_End_Exceptions then\n \n-               --  Aborts are not deferred at beginning of exception handlers\n-               --  in ZCX.\n+            --  Aborts are not deferred at beginning of exception handlers\n+            --  in ZCX.\n \n-               Handler_Stmt := Make_Null_Statement (Loc);\n+            Handler_Stmt := Make_Null_Statement (Loc);\n \n-            else\n-               Handler_Stmt := Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc),\n-                 Parameter_Associations => No_List);\n-            end if;\n          else\n             Handler_Stmt := Make_Procedure_Call_Statement (Loc,\n-              Name => New_Occurrence_Of (RTE (RE_Update_Exception), Loc),\n-              Parameter_Associations => New_List (\n-                Make_Function_Call (Loc,\n-                  Name => New_Occurrence_Of\n-                            (RTE (RE_Current_Target_Exception), Loc))));\n+              Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc),\n+              Parameter_Associations => No_List);\n          end if;\n \n          Stmts := New_List (\n@@ -14218,31 +14185,17 @@ package body Exp_Ch9 is\n          --  it's actually inside the init procedure for the record type that\n          --  corresponds to the task type.\n \n-         --  This processing is causing a crash in the .NET/JVM back ends that\n-         --  is not yet understood, so skip it in these cases ???\n-\n-         if VM_Target = No_VM then\n-            Set_Itype (Ref, Subp_Ptr_Typ);\n-            Append_Freeze_Action (Task_Rec, Ref);\n-\n-            Append_To (Args,\n-              Unchecked_Convert_To (RTE (RE_Task_Procedure_Access),\n-                Make_Qualified_Expression (Loc,\n-                  Subtype_Mark => New_Occurrence_Of (Subp_Ptr_Typ, Loc),\n-                  Expression   =>\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Occurrence_Of (Body_Proc, Loc),\n-                      Attribute_Name => Name_Unrestricted_Access))));\n-\n-         --  For the .NET/JVM cases revert to the original code below ???\n+         Set_Itype (Ref, Subp_Ptr_Typ);\n+         Append_Freeze_Action (Task_Rec, Ref);\n \n-         else\n-            Append_To (Args,\n-              Unchecked_Convert_To (RTE (RE_Task_Procedure_Access),\n-                Make_Attribute_Reference (Loc,\n-                  Prefix         => New_Occurrence_Of (Body_Proc, Loc),\n-                  Attribute_Name => Name_Address)));\n-         end if;\n+         Append_To (Args,\n+           Unchecked_Convert_To (RTE (RE_Task_Procedure_Access),\n+             Make_Qualified_Expression (Loc,\n+               Subtype_Mark => New_Occurrence_Of (Subp_Ptr_Typ, Loc),\n+               Expression   =>\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Body_Proc, Loc),\n+                   Attribute_Name => Name_Unrestricted_Access))));\n       end;\n \n       --  Discriminants parameter. This is just the address of the task"}, {"sha": "8151923d2c81cde013a598d2da563446a8957a0a", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -38,7 +38,6 @@ with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Table;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Urealp;   use Urealp;\n \n@@ -373,14 +372,6 @@ package body Exp_Dbug is\n          return Empty;\n       end if;\n \n-      --  Do not output those local variables in VM case, as this does not\n-      --  help debugging (they are just unused), and might lead to duplicated\n-      --  local variable names.\n-\n-      if VM_Target /= No_VM then\n-         return Empty;\n-      end if;\n-\n       --  Get renamed entity and compute suffix\n \n       Name_Len := 0;"}, {"sha": "d8ad4f8fd8cffaa8bb91e97b3bedc04b58588a8c", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -62,7 +62,6 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with SCIL_LL;  use SCIL_LL;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n \n package body Exp_Disp is\n@@ -291,7 +290,6 @@ package body Exp_Disp is\n \n       return Static_Dispatch_Tables\n         and then Is_Library_Level_Tagged_Type (Typ)\n-        and then VM_Target = No_VM\n \n          --  If the type is derived from a CPP class we cannot statically\n          --  build the dispatch tables because we must inherit primitives\n@@ -1174,35 +1172,6 @@ package body Exp_Disp is\n       end;\n \n       if not Tagged_Type_Expansion then\n-         if VM_Target /= No_VM then\n-            if Is_Access_Type (Operand_Typ) then\n-               Operand_Typ := Designated_Type (Operand_Typ);\n-            end if;\n-\n-            if Is_Class_Wide_Type (Operand_Typ) then\n-               Operand_Typ := Root_Type (Operand_Typ);\n-            end if;\n-\n-            if not Is_Static and then Operand_Typ /= Iface_Typ then\n-               Insert_Action (N,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Occurrence_Of\n-                            (RTE (RE_Check_Interface_Conversion), Loc),\n-                   Parameter_Associations => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => Duplicate_Subexpr (Expression (N)),\n-                       Attribute_Name => Name_Tag),\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => New_Occurrence_Of (Iface_Typ, Loc),\n-                       Attribute_Name => Name_Tag))));\n-            end if;\n-\n-            --  Just do a conversion ???\n-\n-            Rewrite (N, Unchecked_Convert_To (Etype (N), N));\n-            Analyze (N);\n-         end if;\n-\n          return;\n \n       --  A static conversion to an interface type that is not classwide is\n@@ -4474,8 +4443,6 @@ package body Exp_Disp is\n       if Has_Dispatch_Table (Typ)\n         or else No (Access_Disp_Table (Typ))\n         or else Is_CPP_Class (Typ)\n-        or else Convention (Typ) = Convention_CIL\n-        or else Convention (Typ) = Convention_Java\n       then\n          Ghost_Mode := Save_Ghost_Mode;\n          return Result;\n@@ -6254,537 +6221,6 @@ package body Exp_Disp is\n       return Result;\n    end Make_DT;\n \n-   -----------------\n-   -- Make_VM_TSD --\n-   -----------------\n-\n-   function Make_VM_TSD (Typ : Entity_Id) return List_Id is\n-      Loc    : constant Source_Ptr := Sloc (Typ);\n-      Result : constant List_Id := New_List;\n-\n-      function Count_Primitives (Typ : Entity_Id) return Nat;\n-      --  Count the non-predefined primitive operations of Typ\n-\n-      ----------------------\n-      -- Count_Primitives --\n-      ----------------------\n-\n-      function Count_Primitives (Typ : Entity_Id) return Nat is\n-         Nb_Prim   : Nat;\n-         Prim_Elmt : Elmt_Id;\n-         Prim      : Entity_Id;\n-\n-      begin\n-         Nb_Prim := 0;\n-\n-         Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n-         while Present (Prim_Elmt) loop\n-            Prim := Node (Prim_Elmt);\n-\n-            if Is_Predefined_Dispatching_Operation (Prim)\n-              or else Is_Predefined_Dispatching_Alias (Prim)\n-            then\n-               null;\n-\n-            elsif Present (Interface_Alias (Prim)) then\n-               null;\n-\n-            else\n-               Nb_Prim := Nb_Prim + 1;\n-            end if;\n-\n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n-\n-         return Nb_Prim;\n-      end Count_Primitives;\n-\n-      --------------\n-      -- Make_OSD --\n-      --------------\n-\n-      function Make_OSD (Iface : Entity_Id) return Node_Id;\n-      --  Generate the Object Specific Data table required to dispatch calls\n-      --  through synchronized interfaces. Returns a node that references the\n-      --  generated OSD object.\n-\n-      function Make_OSD (Iface : Entity_Id) return Node_Id is\n-         Nb_Prim       : constant Nat := Count_Primitives (Iface);\n-         OSD           : Entity_Id;\n-         OSD_Aggr_List : List_Id;\n-\n-      begin\n-         --  Generate\n-         --   OSD : Ada.Tags.Object_Specific_Data (Nb_Prims) :=\n-         --          (OSD_Table => (1 => <value>,\n-         --                           ...\n-         --                         N => <value>));\n-\n-         if Nb_Prim = 0\n-           or else Is_Abstract_Type (Typ)\n-           or else Is_Controlled (Typ)\n-           or else Restriction_Active (No_Dispatching_Calls)\n-           or else not Is_Limited_Type (Typ)\n-           or else not Has_Interfaces (Typ)\n-           or else not RTE_Record_Component_Available (RE_OSD_Table)\n-         then\n-            --  No OSD table required\n-\n-            return Make_Null (Loc);\n-\n-         else\n-            OSD_Aggr_List := New_List;\n-\n-            declare\n-               Prim_Table : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n-               Prim       : Entity_Id;\n-               Prim_Alias : Entity_Id;\n-               Prim_Elmt  : Elmt_Id;\n-               E          : Entity_Id;\n-               Count      : Nat := 0;\n-               Pos        : Nat;\n-\n-            begin\n-               Prim_Table := (others => Empty);\n-               Prim_Alias := Empty;\n-\n-               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n-               while Present (Prim_Elmt) loop\n-                  Prim := Node (Prim_Elmt);\n-\n-                  if Present (Interface_Alias (Prim))\n-                    and then Find_Dispatching_Type\n-                               (Interface_Alias (Prim)) = Iface\n-                  then\n-                     Prim_Alias := Interface_Alias (Prim);\n-                     E   := Ultimate_Alias (Prim);\n-                     Pos := UI_To_Int (DT_Position (Prim_Alias));\n-\n-                     if Present (Prim_Table (Pos)) then\n-                        pragma Assert (Prim_Table (Pos) = E);\n-                        null;\n-\n-                     else\n-                        Prim_Table (Pos) := E;\n-\n-                        Append_To (OSD_Aggr_List,\n-                          Make_Component_Association (Loc,\n-                            Choices    => New_List (\n-                              Make_Integer_Literal (Loc,\n-                                DT_Position (Prim_Alias))),\n-                            Expression =>\n-                              Make_Integer_Literal (Loc,\n-                                DT_Position (Alias (Prim)))));\n-\n-                        Count := Count + 1;\n-                     end if;\n-                  end if;\n-\n-                  Next_Elmt (Prim_Elmt);\n-               end loop;\n-\n-               pragma Assert (Count = Nb_Prim);\n-            end;\n-\n-            OSD := Make_Temporary (Loc, 'I');\n-\n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => OSD,\n-                Aliased_Present     => True,\n-                Constant_Present    => True,\n-                Object_Definition   =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Occurrence_Of (RTE (RE_Object_Specific_Data), Loc),\n-                    Constraint   =>\n-                      Make_Index_Or_Discriminant_Constraint (Loc,\n-                        Constraints => New_List (\n-                          Make_Integer_Literal (Loc, Nb_Prim)))),\n-\n-                Expression          =>\n-                  Make_Aggregate (Loc,\n-                    Component_Associations => New_List (\n-                      Make_Component_Association (Loc,\n-                        Choices    => New_List (\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_OSD_Num_Prims), Loc)),\n-                        Expression =>\n-                          Make_Integer_Literal (Loc, Nb_Prim)),\n-\n-                      Make_Component_Association (Loc,\n-                        Choices    => New_List (\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_OSD_Table), Loc)),\n-                        Expression => Make_Aggregate (Loc,\n-                          Component_Associations => OSD_Aggr_List))))));\n-\n-            return\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Occurrence_Of (OSD, Loc),\n-                Attribute_Name => Name_Unchecked_Access);\n-         end if;\n-      end Make_OSD;\n-\n-      --  Local variables\n-\n-      Nb_Prim          : constant Nat := Count_Primitives (Typ);\n-      AI               : Elmt_Id;\n-      I_Depth          : Nat;\n-      Iface_Table_Node : Node_Id;\n-      Num_Ifaces       : Nat;\n-      TSD_Aggr_List    : List_Id;\n-      Typ_Ifaces       : Elist_Id;\n-      TSD_Tags_List    : List_Id;\n-\n-      Tname    : constant Name_Id := Chars (Typ);\n-      Name_SSD : constant Name_Id :=\n-                   New_External_Name (Tname, 'S', Suffix_Index => -1);\n-      Name_TSD : constant Name_Id :=\n-                   New_External_Name (Tname, 'B', Suffix_Index => -1);\n-      SSD      : constant Entity_Id :=\n-                   Make_Defining_Identifier (Loc, Name_SSD);\n-      TSD      : constant Entity_Id :=\n-                   Make_Defining_Identifier (Loc, Name_TSD);\n-   begin\n-      --  Generate code to create the storage for the type specific data object\n-      --  with enough space to store the tags of the ancestors plus the tags\n-      --  of all the implemented interfaces (as described in a-tags.ads).\n-\n-      --   TSD : Type_Specific_Data (I_Depth) :=\n-      --           (Idepth                => I_Depth,\n-      --            Tag_Kind              => <tag_kind-value>,\n-      --            Access_Level          => Type_Access_Level (Typ),\n-      --            Alignment             => Typ'Alignment,\n-      --            HT_Link               => null,\n-      --            Type_Is_Abstract      => <<boolean-value>>,\n-      --            Type_Is_Library_Level => <<boolean-value>>,\n-      --            Interfaces_Table      => <<access-value>>\n-      --            SSD                   => SSD_Table'Address\n-      --            Tags_Table            => (0 => Typ'Tag,\n-      --                                      1 => Parent'Tag\n-      --                                      ...));\n-\n-      TSD_Aggr_List := New_List;\n-\n-      --  Idepth: Count ancestors to compute the inheritance depth. For private\n-      --  extensions, always go to the full view in order to compute the real\n-      --  inheritance depth.\n-\n-      declare\n-         Current_Typ : Entity_Id;\n-         Parent_Typ  : Entity_Id;\n-\n-      begin\n-         I_Depth     := 0;\n-         Current_Typ := Typ;\n-         loop\n-            Parent_Typ := Etype (Current_Typ);\n-\n-            if Is_Private_Type (Parent_Typ) then\n-               Parent_Typ := Full_View (Base_Type (Parent_Typ));\n-            end if;\n-\n-            exit when Parent_Typ = Current_Typ;\n-\n-            I_Depth := I_Depth + 1;\n-            Current_Typ := Parent_Typ;\n-         end loop;\n-      end;\n-\n-      --  I_Depth\n-\n-      Append_To (TSD_Aggr_List,\n-        Make_Integer_Literal (Loc, I_Depth));\n-\n-      --  Tag_Kind\n-\n-      Append_To (TSD_Aggr_List, Tagged_Kind (Typ));\n-\n-      --  Access_Level\n-\n-      Append_To (TSD_Aggr_List,\n-        Make_Integer_Literal (Loc, Type_Access_Level (Typ)));\n-\n-      --  Alignment\n-\n-      --  For CPP types we cannot rely on the value of 'Alignment provided\n-      --  by the backend to initialize this TSD field. Why not???\n-\n-      if Convention (Typ) = Convention_CPP\n-        or else Is_CPP_Class (Root_Type (Typ))\n-      then\n-         Append_To (TSD_Aggr_List,\n-           Make_Integer_Literal (Loc, 0));\n-      else\n-         Append_To (TSD_Aggr_List,\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Typ, Loc),\n-             Attribute_Name => Name_Alignment));\n-      end if;\n-\n-      --  HT_Link\n-\n-      Append_To (TSD_Aggr_List,\n-        Make_Null (Loc));\n-\n-      --  Type_Is_Abstract (Ada 2012: AI05-0173)\n-\n-      declare\n-         Type_Is_Abstract : Entity_Id;\n-\n-      begin\n-         Type_Is_Abstract :=\n-           Boolean_Literals (Is_Abstract_Type (Typ));\n-\n-         Append_To (TSD_Aggr_List,\n-            New_Occurrence_Of (Type_Is_Abstract, Loc));\n-      end;\n-\n-      --  Type_Is_Library_Level\n-\n-      declare\n-         Type_Is_Library_Level : Entity_Id;\n-      begin\n-         Type_Is_Library_Level :=\n-           Boolean_Literals (Is_Library_Level_Entity (Typ));\n-         Append_To (TSD_Aggr_List,\n-            New_Occurrence_Of (Type_Is_Library_Level, Loc));\n-      end;\n-\n-      --  Interfaces_Table (required for AI-405)\n-\n-      if RTE_Record_Component_Available (RE_Interfaces_Table) then\n-\n-         --  Count the number of interface types implemented by Typ\n-\n-         Collect_Interfaces (Typ, Typ_Ifaces);\n-\n-         Num_Ifaces := 0;\n-         AI := First_Elmt (Typ_Ifaces);\n-         while Present (AI) loop\n-            Num_Ifaces := Num_Ifaces + 1;\n-            Next_Elmt (AI);\n-         end loop;\n-\n-         if Num_Ifaces = 0 then\n-            Iface_Table_Node := Make_Null (Loc);\n-\n-         --  Generate the Interface_Table object\n-\n-         else\n-            declare\n-               TSD_Ifaces_List : constant List_Id := New_List;\n-               Iface           : Entity_Id;\n-               ITable          : Node_Id;\n-\n-            begin\n-               AI := First_Elmt (Typ_Ifaces);\n-               while Present (AI) loop\n-                  Iface := Node (AI);\n-\n-                  Append_To (TSD_Ifaces_List,\n-                     Make_Aggregate (Loc,\n-                       Expressions => New_List (\n-\n-                         --  Iface_Tag\n-\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix         => New_Occurrence_Of (Iface, Loc),\n-                           Attribute_Name => Name_Tag),\n-\n-                         --  OSD\n-\n-                         Make_OSD (Iface))));\n-\n-                  Next_Elmt (AI);\n-               end loop;\n-\n-               ITable := Make_Temporary (Loc, 'I');\n-\n-               Append_To (Result,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => ITable,\n-                   Aliased_Present     => True,\n-                   Constant_Present    => True,\n-                   Object_Definition   =>\n-                     Make_Subtype_Indication (Loc,\n-                       Subtype_Mark =>\n-                         New_Occurrence_Of (RTE (RE_Interface_Data), Loc),\n-                       Constraint   => Make_Index_Or_Discriminant_Constraint\n-                         (Loc,\n-                          Constraints => New_List (\n-                            Make_Integer_Literal (Loc, Num_Ifaces)))),\n-\n-                   Expression => Make_Aggregate (Loc,\n-                     Expressions => New_List (\n-                       Make_Integer_Literal (Loc, Num_Ifaces),\n-                       Make_Aggregate (Loc,\n-                         Expressions => TSD_Ifaces_List)))));\n-\n-               Iface_Table_Node :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => New_Occurrence_Of (ITable, Loc),\n-                   Attribute_Name => Name_Unchecked_Access);\n-            end;\n-         end if;\n-\n-         Append_To (TSD_Aggr_List, Iface_Table_Node);\n-      end if;\n-\n-      --  Generate the Select Specific Data table for synchronized types that\n-      --  implement synchronized interfaces. The size of the table is\n-      --  constrained by the number of non-predefined primitive operations.\n-\n-      if RTE_Record_Component_Available (RE_SSD) then\n-         if Ada_Version >= Ada_2005\n-           and then Has_DT (Typ)\n-           and then Is_Concurrent_Record_Type (Typ)\n-           and then Has_Interfaces (Typ)\n-           and then Nb_Prim > 0\n-           and then not Is_Abstract_Type (Typ)\n-           and then not Is_Controlled (Typ)\n-           and then not Restriction_Active (No_Dispatching_Calls)\n-           and then not Restriction_Active (No_Select_Statements)\n-         then\n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => SSD,\n-                Aliased_Present     => True,\n-                Object_Definition   =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark => New_Occurrence_Of (\n-                      RTE (RE_Select_Specific_Data), Loc),\n-                    Constraint   =>\n-                      Make_Index_Or_Discriminant_Constraint (Loc,\n-                        Constraints => New_List (\n-                          Make_Integer_Literal (Loc, Nb_Prim))))));\n-\n-            --  This table is initialized by Make_Select_Specific_Data_Table,\n-            --  which calls Set_Entry_Index and Set_Prim_Op_Kind.\n-\n-            Append_To (TSD_Aggr_List,\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Occurrence_Of (SSD, Loc),\n-                Attribute_Name => Name_Unchecked_Access));\n-         else\n-            Append_To (TSD_Aggr_List, Make_Null (Loc));\n-         end if;\n-      end if;\n-\n-      --  Initialize the table of ancestor tags. In case of interface types\n-      --  this table is not needed.\n-\n-      TSD_Tags_List := New_List;\n-\n-      --  Fill position 0 with Typ'Tag\n-\n-      Append_To (TSD_Tags_List,\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Typ, Loc),\n-          Attribute_Name => Name_Tag));\n-\n-      --  Fill the rest of the table with the tags of the ancestors\n-\n-      declare\n-         Current_Typ : Entity_Id;\n-         Parent_Typ  : Entity_Id;\n-         Pos         : Nat;\n-\n-      begin\n-         Pos := 1;\n-         Current_Typ := Typ;\n-\n-         loop\n-            Parent_Typ := Etype (Current_Typ);\n-\n-            if Is_Private_Type (Parent_Typ) then\n-               Parent_Typ := Full_View (Base_Type (Parent_Typ));\n-            end if;\n-\n-            exit when Parent_Typ = Current_Typ;\n-\n-            Append_To (TSD_Tags_List,\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Occurrence_Of (Parent_Typ, Loc),\n-                Attribute_Name => Name_Tag));\n-\n-            Pos := Pos + 1;\n-            Current_Typ := Parent_Typ;\n-         end loop;\n-\n-         pragma Assert (Pos = I_Depth + 1);\n-      end;\n-\n-      Append_To (TSD_Aggr_List,\n-        Make_Aggregate (Loc,\n-          Expressions => TSD_Tags_List));\n-\n-      --  Build the TSD object\n-\n-      Append_To (Result,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => TSD,\n-          Aliased_Present     => True,\n-          Constant_Present    => True,\n-          Object_Definition   =>\n-            Make_Subtype_Indication (Loc,\n-              Subtype_Mark => New_Occurrence_Of (\n-                RTE (RE_Type_Specific_Data), Loc),\n-              Constraint =>\n-                Make_Index_Or_Discriminant_Constraint (Loc,\n-                  Constraints => New_List (\n-                    Make_Integer_Literal (Loc, I_Depth)))),\n-\n-          Expression => Make_Aggregate (Loc,\n-            Expressions => TSD_Aggr_List)));\n-\n-      --  Generate:\n-      --     Check_TSD (TSD => TSD'Unrestricted_Access);\n-\n-      if Ada_Version >= Ada_2005\n-        and then Is_Library_Level_Entity (Typ)\n-        and then RTE_Available (RE_Check_TSD)\n-        and then not Duplicated_Tag_Checks_Suppressed (Typ)\n-      then\n-         Append_To (Result,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Check_TSD), Loc),\n-             Parameter_Associations => New_List (\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => New_Occurrence_Of (TSD, Loc),\n-                 Attribute_Name => Name_Unrestricted_Access))));\n-      end if;\n-\n-      --  Generate:\n-      --     Register_TSD (TSD'Unrestricted_Access);\n-\n-      Append_To (Result,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (RTE (RE_Register_TSD), Loc),\n-          Parameter_Associations => New_List (\n-            Make_Attribute_Reference (Loc,\n-              Prefix         => New_Occurrence_Of (TSD, Loc),\n-              Attribute_Name => Name_Unrestricted_Access))));\n-\n-      --  Populate the two auxiliary tables used for dispatching asynchronous,\n-      --  conditional and timed selects for synchronized types that implement\n-      --  a limited interface. Skip this step in Ravenscar profile or when\n-      --  general dispatching is forbidden.\n-\n-      if Ada_Version >= Ada_2005\n-        and then Is_Concurrent_Record_Type (Typ)\n-        and then Has_Interfaces (Typ)\n-        and then not Restriction_Active (No_Dispatching_Calls)\n-        and then not Restriction_Active (No_Select_Statements)\n-      then\n-         Append_List_To (Result,\n-           Make_Select_Specific_Data_Table (Typ));\n-      end if;\n-\n-      return Result;\n-   end Make_VM_TSD;\n-\n    -------------------------------------\n    -- Make_Select_Specific_Data_Table --\n    -------------------------------------\n@@ -7646,7 +7082,6 @@ package body Exp_Disp is\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n-      pragma Assert (VM_Target = No_VM);\n \n       --  Do not register in the dispatch table eliminated primitives\n "}, {"sha": "4ec53e127f733f00ee387fa9f9bbcae7d38ea1e0", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -346,10 +346,6 @@ package Exp_Disp is\n    --  tagged types this routine imports the forward declaration of the tag\n    --  entity, that will be declared and exported by Make_DT.\n \n-   function Make_VM_TSD (Typ : Entity_Id) return List_Id;\n-   --  Build the Type Specific Data record associated with tagged type Typ.\n-   --  Invoked only when generating code for VM targets.\n-\n    function Register_Primitive\n      (Loc     : Source_Ptr;\n       Prim    : Entity_Id) return List_Id;"}, {"sha": "282662ba2ca7644c8c762221648d14f1d6d1c98c", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -55,7 +55,6 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -394,7 +393,8 @@ package body Exp_Intr is\n       Analyze_And_Resolve (N, Etype (Act_Constr));\n \n       --  Do not generate a run-time check on the built object if tag\n-      --  checks are suppressed for the result type or VM_Target /= No_VM\n+      --  checks are suppressed for the result type or tagged type expansion\n+      --  is disabled.\n \n       if Tag_Checks_Suppressed (Etype (Result_Typ))\n         or else not Tagged_Type_Expansion\n@@ -1072,14 +1072,6 @@ package body Exp_Intr is\n                  Exception_Handlers => New_List (\n                    Build_Exception_Handler (Finalizer_Data)))));\n \n-         --  For .NET/JVM, detach the object from the containing finalization\n-         --  collection before finalizing it.\n-\n-         if VM_Target /= No_VM and then Is_Controlled (Desig_T) then\n-            Prepend_To (Final_Code,\n-              Make_Detach_Call (New_Copy_Tree (Arg)));\n-         end if;\n-\n          --  If aborts are allowed, then the finalization code must be\n          --  protected by an abort defer/undefer pair.\n "}, {"sha": "3ac68ec3bc9822bce849d6bed4a795e856f6205e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -605,12 +605,6 @@ package body Exp_Util is\n \n          elsif No_Pool_Assigned (Ptr_Typ) then\n             return;\n-\n-         --  Access-to-controlled types are not supported on .NET/JVM since\n-         --  these targets cannot support pools and address arithmetic.\n-\n-         elsif VM_Target /= No_VM then\n-            return;\n          end if;\n \n          --  The allocation / deallocation of a controlled object must be\n@@ -1314,7 +1308,7 @@ package body Exp_Util is\n          Expr := Make_Function_Call (Loc,\n            Name => New_Occurrence_Of (Defining_Entity (Fun), Loc));\n \n-         if not In_Init_Proc and then VM_Target = No_VM then\n+         if not In_Init_Proc then\n             Set_Uses_Sec_Stack (Defining_Entity (Fun));\n          end if;\n       end if;\n@@ -5309,12 +5303,6 @@ package body Exp_Util is\n       T  : constant Entity_Id := Etype (N);\n \n    begin\n-      --  Objects are never unaligned on VMs\n-\n-      if VM_Target /= No_VM then\n-         return False;\n-      end if;\n-\n       --  If renamed object, apply test to underlying object\n \n       if Is_Entity_Name (N)\n@@ -5833,21 +5821,6 @@ package body Exp_Util is\n       end if;\n    end Is_Volatile_Reference;\n \n-   --------------------------\n-   -- Is_VM_By_Copy_Actual --\n-   --------------------------\n-\n-   function Is_VM_By_Copy_Actual (N : Node_Id) return Boolean is\n-   begin\n-      return VM_Target /= No_VM\n-        and then (Nkind (N) = N_Slice\n-                    or else\n-                      (Nkind (N) = N_Identifier\n-                        and then Present (Renamed_Object (Entity (N)))\n-                        and then Nkind (Renamed_Object (Entity (N))) =\n-                                                                 N_Slice));\n-   end Is_VM_By_Copy_Actual;\n-\n    --------------------\n    -- Kill_Dead_Code --\n    --------------------\n@@ -6652,7 +6625,7 @@ package body Exp_Util is\n             EQ_Typ     : Entity_Id := Empty;\n \n          begin\n-            --  A class-wide equivalent type is not needed when VM_Target\n+            --  A class-wide equivalent type is not needed on VM targets\n             --  because the VM back-ends handle the class-wide object\n             --  initialization itself (and doesn't need or want the\n             --  additional intermediate type to handle the assignment).\n@@ -6853,13 +6826,10 @@ package body Exp_Util is\n       if Restriction_Active (No_Finalization) then\n          return False;\n \n-      --  C++, CIL and Java types are not considered controlled. It is assumed\n-      --  that the non-Ada side will handle their clean up.\n+      --  C++ types are not considered controlled. It is assumed that the\n+      --  non-Ada side will handle their clean up.\n \n-      elsif Convention (T) = Convention_CIL\n-        or else Convention (T) = Convention_CPP\n-        or else Convention (T) = Convention_Java\n-      then\n+      elsif Convention (T) = Convention_CPP then\n          return False;\n \n       --  Never needs finalization if Disable_Controlled set\n@@ -8927,7 +8897,7 @@ package body Exp_Util is\n       --  locate here if this node corresponds to a previous invocation of\n       --  Remove_Side_Effects to avoid a never ending loop in the frontend.\n \n-      elsif VM_Target /= No_VM\n+      elsif not Tagged_Type_Expansion\n          and then not Comes_From_Source (N)\n          and then Nkind (Parent (N)) = N_Object_Renaming_Declaration\n          and then Is_Class_Wide_Type (Typ)"}, {"sha": "913c71b97c521c21eb4325d6ed9cd52b77df814d", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -719,10 +719,6 @@ package Exp_Util is\n    --  or has Volatile_Components set. A slice of a volatile variable is\n    --  also volatile.\n \n-   function Is_VM_By_Copy_Actual (N : Node_Id) return Boolean;\n-   --  Returns True if we are compiling on VM targets and N is a node that\n-   --  requires pass-by-copy in these targets.\n-\n    procedure Kill_Dead_Code (N : Node_Id; Warn : Boolean := False);\n    --  N represents a node for a section of code that is known to be dead. Any\n    --  exception handler references and warning messages relating to this code"}, {"sha": "4dcb037de0bc48edfac092f039499778cb80c0a4", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -2923,7 +2923,6 @@ package body Freeze is\n            and then\n              ((Has_Non_Null_Base_Init_Proc (Etype (E))\n                 and then not No_Initialization (Declaration_Node (E))\n-                and then not Is_Value_Type (Etype (E))\n                 and then not Initialization_Suppressed (Etype (E)))\n               or else\n                 (Needs_Simple_Initialization (Etype (E))\n@@ -3126,7 +3125,6 @@ package body Freeze is\n                  and then Convention (F_Type) = Convention_Ada\n                  and then not Has_Warnings_Off (F_Type)\n                  and then not Has_Size_Clause (F_Type)\n-                 and then VM_Target = No_VM\n                then\n                   Error_Msg_N\n                     (\"& is an 8-bit Ada Boolean?x?\", Formal);\n@@ -3173,11 +3171,6 @@ package body Freeze is\n               and then Is_Array_Type (F_Type)\n               and then not Is_Constrained (F_Type)\n               and then Warn_On_Export_Import\n-\n-              --  Exclude VM case, since both .NET and JVM can handle\n-              --  unconstrained arrays without a problem.\n-\n-              and then VM_Target = No_VM\n             then\n                Error_Msg_Qual_Level := 1;\n \n@@ -3295,7 +3288,6 @@ package body Freeze is\n \n                elsif Root_Type (R_Type) = Standard_Boolean\n                  and then Convention (R_Type) = Convention_Ada\n-                 and then VM_Target = No_VM\n                  and then not Has_Warnings_Off (E)\n                  and then not Has_Warnings_Off (R_Type)\n                  and then not Has_Size_Clause (R_Type)\n@@ -3356,11 +3348,6 @@ package body Freeze is\n \n               and then not Is_Imported (E)\n \n-              --  Exclude VM case, since both .NET and JVM can handle return\n-              --  of unconstrained arrays without a problem.\n-\n-              and then VM_Target = No_VM\n-\n               --  Check that general warning is enabled, and that it is not\n               --  suppressed for this particular case.\n \n@@ -5604,7 +5591,6 @@ package body Freeze is\n             while Present (Formal) loop\n                if Ekind (Etype (Formal)) = E_Incomplete_Type\n                  and then No (Full_View (Etype (Formal)))\n-                 and then not Is_Value_Type (Etype (Formal))\n                then\n                   if Is_Tagged_Type (Etype (Formal)) then\n                      null;\n@@ -7677,11 +7663,6 @@ package body Freeze is\n                --  Warnings (Off) on specific entities here, probably so???)\n \n               and then Warn_On_Export_Import\n-\n-              --  Exclude the VM case, since return of unconstrained arrays\n-              --  is properly handled in both the JVM and .NET cases.\n-\n-              and then VM_Target = No_VM\n             then\n                Error_Msg_N\n                 (\"?x?foreign convention function& should not return \" &"}, {"sha": "723096ccc1feeab4ed237013dff14131a0ca297c", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -64,7 +64,6 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n with SCIL_LL;  use SCIL_LL;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Types;    use Types;\n \n@@ -459,14 +458,9 @@ begin\n       end if;\n    end if;\n \n-   --  Qualify all entity names in inner packages, package bodies, etc.,\n-   --  except when compiling for the VM back-ends, which depend on having\n-   --  unqualified names in certain cases and handles the generation of\n-   --  qualified names when needed.\n+   --  Qualify all entity names in inner packages, package bodies, etc.\n \n-   if VM_Target = No_VM then\n-      Exp_Dbug.Qualify_All_Entity_Names;\n-   end if;\n+   Exp_Dbug.Qualify_All_Entity_Names;\n \n    --  SCIL backend requirement. Check that SCIL nodes associated with\n    --  dispatching calls reference subprogram calls."}, {"sha": "6b2046ddcd9344229ccfca6bf2a533d13361c16b", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -599,10 +599,9 @@ procedure Gnat1drv is\n       if Debug_Flag_Dot_LL then\n          Back_End_Handles_Limited_Types := True;\n \n-      --  If no debug flag, usage off for AAMP, VM, SCIL cases\n+      --  If no debug flag, usage off for AAMP, SCIL cases\n \n       elsif AAMP_On_Target\n-        or else VM_Target /= No_VM\n         or else Generate_SCIL\n       then\n          Back_End_Handles_Limited_Types := False;\n@@ -633,20 +632,16 @@ procedure Gnat1drv is\n          --  back end some day, it would not be true for this test, but it\n          --  would be non-GCC, so this is a bit troublesome ???\n \n-         Front_End_Inlining := VM_Target /= No_VM or else AAMP_On_Target;\n+         Front_End_Inlining := AAMP_On_Target;\n       end if;\n \n       --  Set back end inlining indication\n \n       Back_End_Inlining :=\n \n-        --  No back end inlining available for VM targets\n-\n-        VM_Target = No_VM\n-\n         --  No back end inlining available on AAMP\n \n-        and then not AAMP_On_Target\n+        not AAMP_On_Target\n \n         --  No back end inlining in GNATprove mode, since it just confuses\n         --  the formal verification process.\n@@ -868,7 +863,7 @@ procedure Gnat1drv is\n       --  back end for component layout where possible) but only for non-GCC\n       --  back ends, as this is done a priori for GCC back ends.\n \n-      if VM_Target /= No_VM or else AAMP_On_Target then\n+      if AAMP_On_Target then\n          Sem_Ch13.Validate_Independence;\n       end if;\n \n@@ -1273,15 +1268,11 @@ begin\n       --  Annotation is suppressed for targets where front-end layout is\n       --  enabled, because the front end determines representations.\n \n-      --  Annotation is also suppressed in the case of compiling for a VM,\n-      --  since representations are largely symbolic there.\n-\n       if Back_End_Mode = Declarations_Only\n         and then\n           (not (Back_Annotate_Rep_Info or Generate_SCIL or GNATprove_Mode)\n             or else Main_Kind = N_Subunit\n-            or else Frontend_Layout_On_Target\n-            or else VM_Target /= No_VM)\n+            or else Frontend_Layout_On_Target)\n       then\n          Post_Compilation_Validation_Checks;\n          Errout.Finalize (Last_Call => True);"}, {"sha": "c90397de880ff85779d151b1d07e1e292c254790", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1601,12 +1601,6 @@ begin\n    Osint.Add_Default_Search_Dirs;\n    Targparm.Get_Target_Parameters;\n \n-   case VM_Target is\n-      when JVM_Target => Gcc := new String'(\"jvm-gnatcompile\");\n-      when CLI_Target => Gcc := new String'(\"dotnet-gnatcompile\");\n-      when No_VM      => null;\n-   end case;\n-\n    --  Compile the bind file with the following switches:\n \n    --    -gnatA   stops reading gnat.adc, since we don't know what\n@@ -1651,15 +1645,7 @@ begin\n    end if;\n \n    if Linker_Path = null then\n-      if VM_Target = CLI_Target then\n-         Linker_Path := System.OS_Lib.Locate_Exec_On_Path (\"dotnet-ld\");\n-\n-         if Linker_Path = null then\n-            Exit_With_Error (\"Couldn't locate dotnet-ld\");\n-         end if;\n-      else\n-         Linker_Path := Gcc_Path;\n-      end if;\n+      Linker_Path := Gcc_Path;\n    end if;\n \n    Write_Header;\n@@ -1986,7 +1972,7 @@ begin\n             J := J + 1;\n          end loop;\n \n-         if Linker_Path = Gcc_Path and then VM_Target = No_VM then\n+         if Linker_Path = Gcc_Path then\n \n             --  For systems where the default is to link statically with\n             --  libgcc, if gcc is not called with -shared-libgcc, call it\n@@ -2091,10 +2077,7 @@ begin\n       Delete (Binder_Ali_File.all & ASCII.NUL);\n       Delete (Binder_Spec_Src_File.all & ASCII.NUL);\n       Delete (Binder_Body_Src_File.all & ASCII.NUL);\n-\n-      if VM_Target = No_VM then\n-         Delete (Binder_Obj_File.all & ASCII.NUL);\n-      end if;\n+      Delete (Binder_Obj_File.all & ASCII.NUL);\n    end if;\n \n    Exit_Program (E_Success);"}, {"sha": "dfa1a5bc7579fbac52b284c45948cc7a8d16b930", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -454,16 +454,7 @@ package body Lib.Writ is\n                      not Has_No_Elaboration_Code\n                            (Parent (Declaration_Node (Body_Entity (Uent))))))\n          then\n-            if Convention (Uent) = Convention_CIL then\n-\n-               --  Special case for generic CIL packages which never have\n-               --  elaboration code\n-\n-               Write_Info_Str (\" NE\");\n-\n-            else\n-               Write_Info_Str (\" EE\");\n-            end if;\n+            Write_Info_Str (\" EE\");\n          end if;\n \n          if Has_No_Elaboration_Code (Unode) then"}, {"sha": "67e44e0d24501a4014eb2302fe0629b4ad0f2072", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -671,12 +671,7 @@ package body Make is\n    -- Compiler, Binder & Linker Data and Subprograms --\n    ----------------------------------------------------\n \n-   Gcc          : String_Access := Program_Name (\"gcc\", \"gnatmake\");\n-   Original_Gcc : constant String_Access := Gcc;\n-   --  Original_Gcc is used to check if Gcc has been modified by a switch\n-   --  --GCC=, so that for VM platforms, it is not modified again, as it can\n-   --  result in incorrect error messages if the compiler cannot be found.\n-\n+   Gcc      : String_Access := Program_Name (\"gcc\", \"gnatmake\");\n    Gnatbind : String_Access := Program_Name (\"gnatbind\", \"gnatmake\");\n    Gnatlink : String_Access := Program_Name (\"gnatlink\", \"gnatmake\");\n    --  Default compiler, binder, linker programs\n@@ -4861,12 +4856,10 @@ package body Make is\n       end if;\n \n       --  If the objects were up-to-date check if the executable file is also\n-      --  up-to-date. For now always bind and link on the JVM since there is\n-      --  currently no simple way to check whether objects are up to date wrt\n-      --  the executable. Same in CodePeer mode where there is no executable.\n+      --  up-to-date. For now always bind and link in CodePeer mode where there\n+      --  is no executable.\n \n-      if Targparm.VM_Target /= JVM_Target\n-        and then not CodePeer_Mode\n+      if not CodePeer_Mode\n         and then First_Compiled_File = No_File\n       then\n          Executable_Stamp := File_Stamp (Executable);\n@@ -5812,8 +5805,8 @@ package body Make is\n             Finish_Program (Project_Tree, E_Success);\n \n          else\n-            --  Call Get_Target_Parameters to ensure that VM_Target and\n-            --  AAMP_On_Target get set before calling Usage.\n+            --  Call Get_Target_Parameters to ensure that AAMP_On_Target gets\n+            --  set before calling Usage.\n \n             Targparm.Get_Target_Parameters;\n \n@@ -6027,39 +6020,6 @@ package body Make is\n                   Make_Failed (\"*** make failed.\");\n             end;\n \n-            --  Special processing for VM targets\n-\n-            if Targparm.VM_Target /= No_VM then\n-\n-               --  Set proper processing commands\n-\n-               case Targparm.VM_Target is\n-                  when Targparm.JVM_Target =>\n-\n-                     --  Do not check for an object file (\".o\") when compiling\n-                     --  to JVM machine since \".class\" files are generated\n-                     --  instead.\n-\n-                     Check_Object_Consistency := False;\n-\n-                     --  Do not modify Gcc is --GCC= was specified\n-\n-                     if Gcc = Original_Gcc then\n-                        Gcc := new String'(\"jvm-gnatcompile\");\n-                     end if;\n-\n-                  when Targparm.CLI_Target =>\n-                     --  Do not modify Gcc is --GCC= was specified\n-\n-                     if Gcc = Original_Gcc then\n-                        Gcc := new String'(\"dotnet-gnatcompile\");\n-                     end if;\n-\n-                  when Targparm.No_VM =>\n-                     raise Program_Error;\n-               end case;\n-            end if;\n-\n             Gcc_Path       := GNAT.OS_Lib.Locate_Exec_On_Path (Gcc.all);\n             Gnatbind_Path  := GNAT.OS_Lib.Locate_Exec_On_Path (Gnatbind.all);\n             Gnatlink_Path  := GNAT.OS_Lib.Locate_Exec_On_Path (Gnatlink.all);"}, {"sha": "645c8f0015a5bb150878e57ae52bc5b48b56539e", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -1302,7 +1302,6 @@ begin\n            Pragma_Check_Float_Overflow           |\n            Pragma_Check_Name                     |\n            Pragma_Check_Policy                   |\n-           Pragma_CIL_Constructor                |\n            Pragma_Compile_Time_Error             |\n            Pragma_Compile_Time_Warning           |\n            Pragma_Contract_Cases                 |\n@@ -1376,8 +1375,6 @@ begin\n            Pragma_Interrupt_State                |\n            Pragma_Interrupt_Priority             |\n            Pragma_Invariant                      |\n-           Pragma_Java_Constructor               |\n-           Pragma_Java_Interface                 |\n            Pragma_Keep_Names                     |\n            Pragma_License                        |\n            Pragma_Link_With                      |"}, {"sha": "51b8b67d983c258758518dddd5665ba716e22fd0", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -726,16 +726,12 @@ package body Repinfo is\n             Write_Line (\"Assembler\");\n          when Convention_C                     =>\n             Write_Line (\"C\");\n-         when Convention_CIL                   =>\n-            Write_Line (\"CIL\");\n          when Convention_COBOL                 =>\n             Write_Line (\"COBOL\");\n          when Convention_CPP                   =>\n             Write_Line (\"C++\");\n          when Convention_Fortran               =>\n             Write_Line (\"Fortran\");\n-         when Convention_Java                  =>\n-            Write_Line (\"Java\");\n          when Convention_Stdcall               =>\n             Write_Line (\"Stdcall\");\n          when Convention_Stubbed               =>"}, {"sha": "af2b6757875707cd3819c96eebf5c43e2286ce7b", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -550,7 +550,6 @@ package Rtsfind is\n      RE_Set_Deadline,                    -- Ada.Dispatching.EDF\n \n      RE_Code_Loc,                        -- Ada.Exceptions\n-     RE_Current_Target_Exception,        -- Ada.Exceptions (JGNAT use only)\n      RE_Exception_Id,                    -- Ada.Exceptions\n      RE_Exception_Identity,              -- Ada.Exceptions\n      RE_Exception_Information,           -- Ada.Exceptions\n@@ -1596,7 +1595,6 @@ package Rtsfind is\n      RE_Get_Current_Excep,               -- System.Soft_Links\n      RE_Get_GNAT_Exception,              -- System.Soft_Links\n      RE_Save_Library_Occurrence,         -- System.Soft_Links\n-     RE_Update_Exception,                -- System.Soft_Links\n \n      RE_Bits_1,                          -- System.Unsigned_Types\n      RE_Bits_2,                          -- System.Unsigned_Types\n@@ -1783,7 +1781,6 @@ package Rtsfind is\n      RE_Set_Deadline                     => Ada_Dispatching_EDF,\n \n      RE_Code_Loc                         => Ada_Exceptions,\n-     RE_Current_Target_Exception         => Ada_Exceptions, -- of JGNAT\n      RE_Exception_Id                     => Ada_Exceptions,\n      RE_Exception_Identity               => Ada_Exceptions,\n      RE_Exception_Information            => Ada_Exceptions,\n@@ -2833,7 +2830,6 @@ package Rtsfind is\n      RE_Get_Current_Excep                => System_Soft_Links,\n      RE_Get_GNAT_Exception               => System_Soft_Links,\n      RE_Save_Library_Occurrence          => System_Soft_Links,\n-     RE_Update_Exception                 => System_Soft_Links,\n \n      RE_Bits_1                           => System_Unsigned_Types,\n      RE_Bits_2                           => System_Unsigned_Types,"}, {"sha": "b3efac83c47ce8cee8b2c9cc329dad9c3a4908cd", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -303,13 +303,4 @@ package body System.Soft_Links is\n       null;\n    end Task_Unlock_NT;\n \n-   -------------------------\n-   -- Update_Exception_NT --\n-   -------------------------\n-\n-   procedure Update_Exception_NT (X : EO := Current_Target_Exception) is\n-   begin\n-      Ada.Exceptions.Save_Occurrence (NT_TSD.Current_Excep, X);\n-   end Update_Exception_NT;\n-\n end System.Soft_Links;"}, {"sha": "cba89366014bb6a72f23753d1fae2cbd0d518787", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -143,12 +143,6 @@ package System.Soft_Links is\n    --  Handle task abort (non-tasking case, does nothing). Currently, no port\n    --  makes use of this, but we retain the interface for possible future use.\n \n-   procedure Update_Exception_NT (X : EO := Current_Target_Exception);\n-   --  Handle exception setting. This routine is provided for targets that\n-   --  have built-in exception handling such as the Java Virtual Machine.\n-   --  Currently, only JGNAT uses this. See 4jexcept.ads for an explanation on\n-   --  how this routine is used.\n-\n    function Check_Abort_Status_NT return Integer;\n    --  Returns Boolean'Pos (True) iff abort signal should raise\n    --  Standard'Abort_Signal.\n@@ -177,9 +171,6 @@ package System.Soft_Links is\n    Abort_Handler : No_Param_Proc := Abort_Handler_NT'Access;\n    --  Handle task abort (task/non-task case as appropriate)\n \n-   Update_Exception : Special_EO_Call := Update_Exception_NT'Access;\n-   --  Handle exception setting and tasking polling when appropriate\n-\n    Check_Abort_Status : Get_Integer_Call := Check_Abort_Status_NT'Access;\n    --  Called when Abort_Signal is delivered to the process.  Checks to\n    --  see if signal should result in raising Standard'Abort_Signal."}, {"sha": "dddad762e344f76645caba96ebc67bb9fe5618be", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2015, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -58,7 +58,6 @@ package body System.Tasking.Initialization is\n \n    package STPO renames System.Task_Primitives.Operations;\n    package SSL  renames System.Soft_Links;\n-   package AE   renames Ada.Exceptions;\n \n    use Parameters;\n    use Task_Primitives.Operations;\n@@ -94,10 +93,6 @@ package body System.Tasking.Initialization is\n    function Get_Current_Excep return SSL.EOA;\n    --  Task-safe version of SSL.Get_Current_Excep\n \n-   procedure Update_Exception\n-     (X : AE.Exception_Occurrence := SSL.Current_Target_Exception);\n-   --  Handle exception setting and check for pending actions\n-\n    function Task_Name return String;\n    --  Returns current task's name\n \n@@ -371,7 +366,6 @@ package body System.Tasking.Initialization is\n       SSL.Unlock_Task        := Task_Unlock'Access;\n       SSL.Check_Abort_Status := Check_Abort_Status'Access;\n       SSL.Task_Name          := Task_Name'Access;\n-      SSL.Update_Exception   := Update_Exception'Access;\n       SSL.Get_Current_Excep  := Get_Current_Excep'Access;\n \n       --  Initialize the tasking soft links (if not done yet) that are common\n@@ -709,50 +703,6 @@ package body System.Tasking.Initialization is\n       end if;\n    end Abort_Undefer;\n \n-   ----------------------\n-   -- Update_Exception --\n-   ----------------------\n-\n-   --  Call only when holding no locks\n-\n-   procedure Update_Exception\n-     (X : AE.Exception_Occurrence := SSL.Current_Target_Exception)\n-   is\n-      Self_Id : constant Task_Id := Self;\n-      use Ada.Exceptions;\n-\n-   begin\n-      Save_Occurrence (Self_Id.Common.Compiler_Data.Current_Excep, X);\n-\n-      if Self_Id.Deferral_Level = 0 then\n-         if Self_Id.Pending_Action then\n-            Self_Id.Pending_Action := False;\n-            Self_Id.Deferral_Level := Self_Id.Deferral_Level + 1;\n-\n-            if Single_Lock then\n-               Lock_RTS;\n-            end if;\n-\n-            Write_Lock (Self_Id);\n-            Self_Id.Pending_Action := False;\n-            Unlock (Self_Id);\n-\n-            if Single_Lock then\n-               Unlock_RTS;\n-            end if;\n-\n-            Self_Id.Deferral_Level := Self_Id.Deferral_Level - 1;\n-\n-            if Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level then\n-               if not Self_Id.Aborting then\n-                  Self_Id.Aborting := True;\n-                  raise Standard'Abort_Signal;\n-               end if;\n-            end if;\n-         end if;\n-      end if;\n-   end Update_Exception;\n-\n    --------------------------\n    -- Wakeup_Entry_Caller --\n    --------------------------"}, {"sha": "71df079f69c6e8ef38f78e762bcc17ff70474cbb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -4924,49 +4924,36 @@ package body Sem_Ch13 is\n                --  will be used to represent the biased subtype that reflects\n                --  the biased representation of components. We need the subtype\n                --  to get proper conversions on referencing elements of the\n-               --  array. Note: component size clauses are ignored in VM mode.\n-\n-               if VM_Target = No_VM then\n-                  if Biased then\n-                     New_Ctyp :=\n-                       Make_Defining_Identifier (Loc,\n-                         Chars =>\n-                           New_External_Name (Chars (U_Ent), 'C', 0, 'T'));\n-\n-                     Decl :=\n-                       Make_Subtype_Declaration (Loc,\n-                         Defining_Identifier => New_Ctyp,\n-                         Subtype_Indication  =>\n-                           New_Occurrence_Of (Component_Type (Btype), Loc));\n-\n-                     Set_Parent (Decl, N);\n-                     Analyze (Decl, Suppress => All_Checks);\n-\n-                     Set_Has_Delayed_Freeze        (New_Ctyp, False);\n-                     Set_Esize                     (New_Ctyp, Csize);\n-                     Set_RM_Size                   (New_Ctyp, Csize);\n-                     Init_Alignment                (New_Ctyp);\n-                     Set_Is_Itype                  (New_Ctyp, True);\n-                     Set_Associated_Node_For_Itype (New_Ctyp, U_Ent);\n-\n-                     Set_Component_Type (Btype, New_Ctyp);\n-                     Set_Biased (New_Ctyp, N, \"component size clause\");\n-                  end if;\n+               --  array.\n \n-                  Set_Component_Size (Btype, Csize);\n+               if Biased then\n+                  New_Ctyp :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars =>\n+                        New_External_Name (Chars (U_Ent), 'C', 0, 'T'));\n \n-               --  For VM case, we ignore component size clauses\n+                  Decl :=\n+                    Make_Subtype_Declaration (Loc,\n+                      Defining_Identifier => New_Ctyp,\n+                      Subtype_Indication  =>\n+                        New_Occurrence_Of (Component_Type (Btype), Loc));\n \n-               else\n-                  --  Give a warning unless we are in GNAT mode, in which case\n-                  --  the warning is suppressed since it is not useful.\n+                  Set_Parent (Decl, N);\n+                  Analyze (Decl, Suppress => All_Checks);\n \n-                  if not GNAT_Mode then\n-                     Error_Msg_N\n-                       (\"component size ignored in this configuration??\", N);\n-                  end if;\n+                  Set_Has_Delayed_Freeze        (New_Ctyp, False);\n+                  Set_Esize                     (New_Ctyp, Csize);\n+                  Set_RM_Size                   (New_Ctyp, Csize);\n+                  Init_Alignment                (New_Ctyp);\n+                  Set_Is_Itype                  (New_Ctyp, True);\n+                  Set_Associated_Node_For_Itype (New_Ctyp, U_Ent);\n+\n+                  Set_Component_Type (Btype, New_Ctyp);\n+                  Set_Biased (New_Ctyp, N, \"component size clause\");\n                end if;\n \n+               Set_Component_Size (Btype, Csize);\n+\n                --  Deal with warning on overridden size\n \n                if Warn_On_Overridden_Size\n@@ -5142,12 +5129,6 @@ package body Sem_Ch13 is\n                     (\"static string required for tag name!\", Nam);\n                end if;\n \n-               if VM_Target /= No_VM then\n-                  Error_Msg_Name_1 := Attr;\n-                  Error_Msg_N\n-                    (\"% attribute unsupported in this configuration\", Nam);\n-               end if;\n-\n                if not Is_Library_Level_Entity (U_Ent) then\n                   Error_Msg_NE\n                     (\"??non-unique external tag supplied for &\", N, U_Ent);\n@@ -5463,16 +5444,6 @@ package body Sem_Ch13 is\n                  (\"size cannot be given for unconstrained array\", Nam);\n \n             elsif Size /= No_Uint then\n-               if VM_Target /= No_VM and then not GNAT_Mode then\n-\n-                  --  Size clause is not handled properly on VM targets.\n-                  --  Display a warning unless we are in GNAT mode, in which\n-                  --  case this is useless.\n-\n-                  Error_Msg_N\n-                    (\"size clauses are ignored in this configuration??\", N);\n-               end if;\n-\n                if Is_Type (U_Ent) then\n                   Etyp := U_Ent;\n                else\n@@ -11356,7 +11327,7 @@ package body Sem_Ch13 is\n       Address_Clause_Checks.Init;\n       Unchecked_Conversions.Init;\n \n-      if VM_Target /= No_VM or else AAMP_On_Target then\n+      if AAMP_On_Target then\n          Independence_Checks.Init;\n       end if;\n    end Initialize;\n@@ -12412,17 +12383,7 @@ package body Sem_Ch13 is\n            and then Known_Component_Size (T2)\n            and then Component_Size (T1) = Component_Size (T2)\n          then\n-            if VM_Target = No_VM then\n-               return True;\n-\n-            --  In VM targets the representation of arrays with aliased\n-            --  components differs from arrays with non-aliased components\n-\n-            else\n-               return Has_Aliased_Components (Base_Type (T1))\n-                        =\n-                      Has_Aliased_Components (Base_Type (T2));\n-            end if;\n+            return True;\n          end if;\n       end if;\n "}, {"sha": "fc85a5abfb8c6cb85e3dbb8fc3c86d6dfc68688a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -3002,10 +3002,9 @@ package body Sem_Ch3 is\n \n       --  Check runtime support for synchronized interfaces\n \n-      if VM_Target = No_VM\n-        and then (Is_Task_Interface (T)\n-                   or else Is_Protected_Interface (T)\n-                   or else Is_Synchronized_Interface (T))\n+      if (Is_Task_Interface (T)\n+           or else Is_Protected_Interface (T)\n+           or else Is_Synchronized_Interface (T))\n         and then not RTE_Available (RE_Select_Specific_Data)\n       then\n          Error_Msg_CRT (\"synchronized interfaces\", T);\n@@ -10061,7 +10060,6 @@ package body Sem_Ch3 is\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract_Type (T)\n-           and then Convention (T) /= Convention_CIL\n            and then not Is_Predefined_Interface_Primitive (Subp)\n \n             --  Ada 2005 (AI-251): Do not consider hidden entities associated"}, {"sha": "d2d5f25f3f3eef3269986ab9198e6ff27b7e602a", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -473,7 +473,6 @@ package body Sem_Ch5 is\n       elsif Is_Limited_Type (T1)\n         and then not Assignment_OK (Lhs)\n         and then not Assignment_OK (Original_Node (Lhs))\n-        and then not Is_Value_Type (T1)\n       then\n          --  CPP constructors can only be called in declarations\n "}, {"sha": "e942477d3d181e5a943f9d45fbb4a86b2f5ceafd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -83,7 +83,6 @@ with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Style;\n with Stylesw;  use Stylesw;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -2036,11 +2035,6 @@ package body Sem_Ch6 is\n             end if;\n \n             if Ekind (Typ) = E_Incomplete_Type\n-              and then Is_Value_Type (Typ)\n-            then\n-               null;\n-\n-            elsif Ekind (Typ) = E_Incomplete_Type\n               or else (Is_Class_Wide_Type (Typ)\n                         and then Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n             then\n@@ -6931,11 +6925,9 @@ package body Sem_Ch6 is\n \n                --  Add BIP_Storage_Pool, in case BIP_Alloc_Form indicates to\n                --  use a user-defined pool. This formal is not added on\n-               --  .NET/JVM/ZFP as those targets do not support pools.\n+               --  ZFP as those targets do not support pools.\n \n-               if VM_Target = No_VM\n-                 and then RTE_Available (RE_Root_Storage_Pool_Ptr)\n-               then\n+               if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n                   Discard :=\n                     Add_Extra_Formal\n                       (E, RTE (RE_Root_Storage_Pool_Ptr),\n@@ -10077,11 +10069,6 @@ package body Sem_Ch6 is\n                      end if;\n                   end if;\n \n-               --  Special handling of Value_Type for CIL case\n-\n-               elsif Is_Value_Type (Formal_Type) then\n-                  null;\n-\n                elsif not Nkind_In (Parent (T), N_Access_Function_Definition,\n                                                N_Access_Procedure_Definition)\n                then"}, {"sha": "b2c6d821d51971f8fd02d53833149b2bf74ea7a1", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -68,7 +68,6 @@ with Sinfo.CN; use Sinfo.CN;\n with Snames;   use Snames;\n with Style;    use Style;\n with Table;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -3909,15 +3908,14 @@ package body Sem_Ch8 is\n       --  type is still not frozen). We exclude from this processing generic\n       --  formal subprograms found in instantiations.\n \n-      --  We must exclude VM targets and restricted run-time libraries because\n+      --  We must exclude restricted run-time libraries because\n       --  entity AST_Handler is defined in package System.Aux_Dec which is not\n       --  available in those platforms. Note that we cannot use the function\n       --  Restricted_Profile (instead of Configurable_Run_Time_Mode) because\n       --  the ZFP run-time library is not defined as a profile, and we do not\n       --  want to deal with AST_Handler in ZFP mode.\n \n-      if VM_Target = No_VM\n-        and then not Configurable_Run_Time_Mode\n+      if not Configurable_Run_Time_Mode\n         and then not Present (Corresponding_Formal_Spec (N))\n         and then Etype (Nam) /= RTE (RE_AST_Handler)\n       then\n@@ -5606,8 +5604,6 @@ package body Sem_Ch8 is\n                      end case;\n                   end if;\n                end if;\n-\n-               Check_Nested_Access (E);\n             end if;\n \n             Set_Entity_Or_Discriminal (N, E);\n@@ -6602,13 +6598,9 @@ package body Sem_Ch8 is\n \n                   --  Do not build the subtype when referencing components of\n                   --  dispatch table wrappers. Required to avoid generating\n-                  --  elaboration code with HI runtimes. JVM and .NET use a\n-                  --  modified version of Ada.Tags which does not contain RE_\n-                  --  Dispatch_Table_Wrapper and RE_No_Dispatch_Table_Wrapper.\n-                  --  Avoid raising RE_Not_Available exception in those cases.\n+                  --  elaboration code with HI runtimes.\n \n-                  elsif VM_Target = No_VM\n-                    and then RTU_Loaded (Ada_Tags)\n+                  elsif RTU_Loaded (Ada_Tags)\n                     and then\n                       ((RTE_Available (RE_Dispatch_Table_Wrapper)\n                          and then Scope (Selector) ="}, {"sha": "35877e530e1e2b14d7ea629c24ef6a1611be34ee", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -57,7 +57,6 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Style;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -2367,12 +2366,6 @@ package body Sem_Ch9 is\n          Generate_Reference (Entry_Id, Entry_Name);\n \n          if Present (First_Formal (Entry_Id)) then\n-            if VM_Target = JVM_Target then\n-               Error_Msg_N\n-                 (\"arguments unsupported in requeue statement\",\n-                  First_Formal (Entry_Id));\n-               return;\n-            end if;\n \n             --  Ada 2012 (AI05-0030): Perform type conformance after skipping\n             --  the first parameter of Entry_Id since it is the interface"}, {"sha": "74a315dd3f2d967fed76b55b1f7fb7bbd49ca194", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -50,7 +50,6 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Sinfo;    use Sinfo;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -1148,7 +1147,7 @@ package body Sem_Disp is\n                            --  No code required to register primitives in VM\n                            --  targets\n \n-                           elsif VM_Target /= No_VM then\n+                           elsif not Tagged_Type_Expansion then\n                               null;\n \n                            else\n@@ -1309,7 +1308,7 @@ package body Sem_Disp is\n                        and then Present (Interface_Alias (Prim))\n                        and then Alias (Prim) = Subp\n                        and then not Building_Static_DT (Tagged_Type)\n-                       and then VM_Target = No_VM\n+                       and then Tagged_Type_Expansion\n                      then\n                         Insert_Actions_After (Subp_Body,\n                           Register_Primitive (Sloc (Subp_Body), Prim => Prim));\n@@ -2546,7 +2545,7 @@ package body Sem_Disp is\n          Next_Actual (Arg);\n       end loop;\n \n-      --  Expansion of dispatching calls is suppressed when VM_Target, because\n+      --  Expansion of dispatching calls is suppressed on VM targets, because\n       --  the VM back-ends directly handle the generation of dispatching calls\n       --  and would have to undo any expansion to an indirect call.\n "}, {"sha": "9f97836477c7d1531dde2b16fbae09bcfa1d2937", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -52,7 +52,6 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n \n package body Sem_Eval is\n@@ -6238,12 +6237,6 @@ package body Sem_Eval is\n         and then Is_Known_Valid (Typ)\n         and then Esize (Etype (N)) <= Esize (Typ)\n         and then not Has_Biased_Representation (Etype (N))\n-\n-        --  This check cannot be disabled under VM targets because in some\n-        --  unusual cases the backend of the native compiler raises a run-time\n-        --  exception but the virtual machines do not raise any exception.\n-\n-        and then VM_Target = No_VM\n       then\n          return In_Range;\n "}, {"sha": "cfe9f9536c19abf3efb32771cca9f4b54cd98833", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -181,13 +181,11 @@ package body Sem_Mech is\n                -- C --\n                -------\n \n-               --  Note: Assembler, C++, Java, Stdcall also use C conventions\n+               --  Note: Assembler, C++, Stdcall also use C conventions\n \n                when Convention_Assembler |\n                     Convention_C         |\n-                    Convention_CIL       |\n                     Convention_CPP       |\n-                    Convention_Java      |\n                     Convention_Stdcall   =>\n \n                   --  The following values are passed by copy"}, {"sha": "94eac815bdb4f5124f89667758a54db07f1b2c4f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 18, "deletions": 433, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -7738,21 +7738,6 @@ package body Sem_Prag is\n                end if;\n             end loop;\n \n-         --  When the convention is Java or CIL, we also allow Import to\n-         --  be given for packages, generic packages, exceptions, record\n-         --  components, and access to subprograms.\n-\n-         elsif (C = Convention_Java or else C = Convention_CIL)\n-           and then\n-             (Is_Package_Or_Generic_Package (Def_Id)\n-               or else Ekind (Def_Id) = E_Exception\n-               or else Ekind (Def_Id) = E_Access_Subprogram_Type\n-               or else Nkind (Parent (Def_Id)) = N_Component_Declaration)\n-         then\n-            Set_Imported (Def_Id);\n-            Set_Is_Public (Def_Id);\n-            Process_Interface_Name (Def_Id, Arg3, Arg4);\n-\n          --  Import a CPP class\n \n          elsif C = Convention_CPP\n@@ -8254,23 +8239,17 @@ package body Sem_Prag is\n          Link_Nam   : Node_Id;\n          String_Val : String_Id;\n \n-         procedure Check_Form_Of_Interface_Name\n-           (SN            : Node_Id;\n-            Ext_Name_Case : Boolean);\n+         procedure Check_Form_Of_Interface_Name (SN : Node_Id);\n          --  SN is a string literal node for an interface name. This routine\n          --  performs some minimal checks that the name is reasonable. In\n          --  particular that no spaces or other obviously incorrect characters\n          --  appear. This is only a warning, since any characters are allowed.\n-         --  Ext_Name_Case is True for an External_Name, False for a Link_Name.\n \n          ----------------------------------\n          -- Check_Form_Of_Interface_Name --\n          ----------------------------------\n \n-         procedure Check_Form_Of_Interface_Name\n-           (SN            : Node_Id;\n-            Ext_Name_Case : Boolean)\n-         is\n+         procedure Check_Form_Of_Interface_Name (SN : Node_Id) is\n             S  : constant String_Id := Strval (Expr_Value_S (SN));\n             SL : constant Nat       := String_Length (S);\n             C  : Char_Code;\n@@ -8288,21 +8267,12 @@ package body Sem_Prag is\n \n                if not In_Character_Range (C)\n \n-                  --  For all cases except CLI target,\n-                  --  commas, spaces and slashes are dubious (in CLI, we use\n-                  --  commas and backslashes in external names to specify\n-                  --  assembly version and public key, while slashes and spaces\n-                  --  can be used in names to mark nested classes and\n-                  --  valuetypes).\n-\n-                  or else ((not Ext_Name_Case or else VM_Target /= CLI_Target)\n-                             and then (Get_Character (C) = ','\n-                                         or else\n-                                       Get_Character (C) = '\\'))\n-                 or else (VM_Target /= CLI_Target\n-                            and then (Get_Character (C) = ' '\n-                                        or else\n-                                      Get_Character (C) = '/'))\n+                 --  Commas, spaces and (back)slashes are dubious\n+\n+                 or else Get_Character (C) = ','\n+                 or else Get_Character (C) = '\\'\n+                 or else Get_Character (C) = ' '\n+                 or else Get_Character (C) = '/'\n                then\n                   Error_Msg\n                     (\"??interface name contains illegal character\",\n@@ -8316,18 +8286,6 @@ package body Sem_Prag is\n       begin\n          if No (Link_Arg) then\n             if No (Ext_Arg) then\n-               if VM_Target = CLI_Target\n-                 and then Ekind (Subprogram_Def) = E_Package\n-                 and then Nkind (Parent (Subprogram_Def)) =\n-                                                 N_Package_Specification\n-                 and then Present (Generic_Parent (Parent (Subprogram_Def)))\n-               then\n-                  Set_Interface_Name\n-                     (Subprogram_Def,\n-                      Interface_Name\n-                        (Generic_Parent (Parent (Subprogram_Def))));\n-               end if;\n-\n                return;\n \n             elsif Chars (Ext_Arg) = Name_Link_Name then\n@@ -8351,7 +8309,7 @@ package body Sem_Prag is\n \n          if Present (Ext_Nam) then\n             Check_Arg_Is_OK_Static_Expression (Ext_Nam, Standard_String);\n-            Check_Form_Of_Interface_Name (Ext_Nam, Ext_Name_Case => True);\n+            Check_Form_Of_Interface_Name (Ext_Nam);\n \n             --  Verify that external name is not the name of a local entity,\n             --  which would hide the imported one and could lead to run-time\n@@ -8396,7 +8354,7 @@ package body Sem_Prag is\n \n          if Present (Link_Nam) then\n             Check_Arg_Is_OK_Static_Expression (Link_Nam, Standard_String);\n-            Check_Form_Of_Interface_Name (Link_Nam, Ext_Name_Case => False);\n+            Check_Form_Of_Interface_Name (Link_Nam);\n          end if;\n \n          --  If there is no link name, just set the external name\n@@ -8412,11 +8370,7 @@ package body Sem_Prag is\n \n          else\n             Start_String;\n-\n-            if VM_Target = No_VM then\n-               Store_String_Char (Get_Char_Code ('*'));\n-            end if;\n-\n+            Store_String_Char (Get_Char_Code ('*'));\n             String_Val := Strval (Expr_Value_S (Link_Nam));\n             Store_String_Chars (String_Val);\n             Link_Nam :=\n@@ -8435,16 +8389,7 @@ package body Sem_Prag is\n               (Get_Base_Subprogram (Subprogram_Def), Link_Nam);\n          end if;\n \n-         --  We allow duplicated export names in CIL/Java, as they are always\n-         --  enclosed in a namespace that differentiates them, and overloaded\n-         --  entities are supported by the VM.\n-\n-         if Convention (Subprogram_Def) /= Convention_CIL\n-              and then\n-            Convention (Subprogram_Def) /= Convention_Java\n-         then\n-            Check_Duplicated_Export_Name (Link_Nam);\n-         end if;\n+         Check_Duplicated_Export_Name (Link_Nam);\n       end Process_Interface_Name;\n \n       -----------------------------------------\n@@ -9012,7 +8957,7 @@ package body Sem_Prag is\n       begin\n          --  For GCC back ends the validation is done a priori\n \n-         if VM_Target = No_VM and then not AAMP_On_Target then\n+         if not AAMP_On_Target then\n             return;\n          end if;\n \n@@ -11936,14 +11881,6 @@ package body Sem_Prag is\n             end if;\n          end Check_Policy;\n \n-         ---------------------\n-         -- CIL_Constructor --\n-         ---------------------\n-\n-         --  pragma CIL_Constructor ([Entity =>] LOCAL_NAME);\n-\n-         --  Processing for this pragma is shared with Java_Constructor\n-\n          -------------\n          -- Comment --\n          -------------\n@@ -15774,328 +15711,6 @@ package body Sem_Prag is\n             end if;\n          end Invariant;\n \n-         ----------------------\n-         -- Java_Constructor --\n-         ----------------------\n-\n-         --  pragma Java_Constructor ([Entity =>] LOCAL_NAME);\n-\n-         --  Also handles pragma CIL_Constructor\n-\n-         when Pragma_CIL_Constructor | Pragma_Java_Constructor =>\n-         Java_Constructor : declare\n-            Convention  : Convention_Id;\n-            Def_Id      : Entity_Id;\n-            Hom_Id      : Entity_Id;\n-            Id          : Entity_Id;\n-            This_Formal : Entity_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            Id := Get_Pragma_Arg (Arg1);\n-            Find_Program_Unit_Name (Id);\n-\n-            --  If we did not find the name, we are done\n-\n-            if Etype (Id) = Any_Type then\n-               return;\n-            end if;\n-\n-            --  Check wrong use of pragma in wrong VM target\n-\n-            if VM_Target = No_VM then\n-               return;\n-\n-            elsif VM_Target = CLI_Target\n-              and then Prag_Id = Pragma_Java_Constructor\n-            then\n-               Error_Pragma (\"must use pragma 'C'I'L_'Constructor\");\n-\n-            elsif VM_Target = JVM_Target\n-              and then Prag_Id = Pragma_CIL_Constructor\n-            then\n-               Error_Pragma (\"must use pragma 'Java_'Constructor\");\n-            end if;\n-\n-            case Prag_Id is\n-               when Pragma_CIL_Constructor  => Convention := Convention_CIL;\n-               when Pragma_Java_Constructor => Convention := Convention_Java;\n-               when others                  => null;\n-            end case;\n-\n-            Hom_Id := Entity (Id);\n-\n-            --  Loop through homonyms\n-\n-            loop\n-               Def_Id := Get_Base_Subprogram (Hom_Id);\n-\n-               --  The constructor is required to be a function\n-\n-               if Ekind (Def_Id) /= E_Function then\n-                  if VM_Target = JVM_Target then\n-                     Error_Pragma_Arg\n-                       (\"pragma% requires function returning a 'Java access \"\n-                        & \"type\", Def_Id);\n-                  else\n-                     Error_Pragma_Arg\n-                       (\"pragma% requires function returning a 'C'I'L access \"\n-                        & \"type\", Def_Id);\n-                  end if;\n-               end if;\n-\n-               --  Check arguments: For tagged type the first formal must be\n-               --  named \"this\" and its type must be a named access type\n-               --  designating a class-wide tagged type that has convention\n-               --  CIL/Java. The first formal must also have a null default\n-               --  value. For example:\n-\n-               --      type Typ is tagged ...\n-               --      type Ref is access all Typ;\n-               --      pragma Convention (CIL, Typ);\n-\n-               --      function New_Typ (This : Ref) return Ref;\n-               --      function New_Typ (This : Ref; I : Integer) return Ref;\n-               --      pragma Cil_Constructor (New_Typ);\n-\n-               --  Reason: The first formal must NOT be a primitive of the\n-               --  tagged type.\n-\n-               --  This rule also applies to constructors of delegates used\n-               --  to interface with standard target libraries. For example:\n-\n-               --      type Delegate is access procedure ...\n-               --      pragma Import (CIL, Delegate, ...);\n-\n-               --      function new_Delegate\n-               --        (This : Delegate := null; ... ) return Delegate;\n-\n-               --  For value-types this rule does not apply.\n-\n-               if not Is_Value_Type (Etype (Def_Id)) then\n-                  if No (First_Formal (Def_Id)) then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N (\"% function must have parameters\", Def_Id);\n-                     return;\n-                  end if;\n-\n-                  --  In the JRE library we have several occurrences in which\n-                  --  the \"this\" parameter is not the first formal.\n-\n-                  This_Formal := First_Formal (Def_Id);\n-\n-                  --  In the JRE library we have several occurrences in which\n-                  --  the \"this\" parameter is not the first formal. Search for\n-                  --  it.\n-\n-                  if VM_Target = JVM_Target then\n-                     while Present (This_Formal)\n-                       and then Get_Name_String (Chars (This_Formal)) /= \"this\"\n-                     loop\n-                        Next_Formal (This_Formal);\n-                     end loop;\n-\n-                     if No (This_Formal) then\n-                        This_Formal := First_Formal (Def_Id);\n-                     end if;\n-                  end if;\n-\n-                  --  Warning: The first parameter should be named \"this\".\n-                  --  We temporarily allow it because we have the following\n-                  --  case in the Java runtime (file s-osinte.ads) ???\n-\n-                  --    function new_Thread\n-                  --      (Self_Id : System.Address) return Thread_Id;\n-                  --    pragma Java_Constructor (new_Thread);\n-\n-                  if VM_Target = JVM_Target\n-                    and then Get_Name_String (Chars (First_Formal (Def_Id)))\n-                               = \"self_id\"\n-                    and then Etype (First_Formal (Def_Id)) = RTE (RE_Address)\n-                  then\n-                     null;\n-\n-                  elsif Get_Name_String (Chars (This_Formal)) /= \"this\" then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"first formal of % function must be named `this`\",\n-                        Parent (This_Formal));\n-\n-                  elsif not Is_Access_Type (Etype (This_Formal)) then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"first formal of % function must be an access type\",\n-                        Parameter_Type (Parent (This_Formal)));\n-\n-                  --  For delegates the type of the first formal must be a\n-                  --  named access-to-subprogram type (see previous example)\n-\n-                  elsif Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type\n-                    and then Ekind (Etype (This_Formal))\n-                               /= E_Access_Subprogram_Type\n-                  then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"first formal of % function must be a named access \"\n-                        & \"to subprogram type\",\n-                        Parameter_Type (Parent (This_Formal)));\n-\n-                  --  Warning: We should reject anonymous access types because\n-                  --  the constructor must not be handled as a primitive of the\n-                  --  tagged type. We temporarily allow it because this profile\n-                  --  is currently generated by cil2ada???\n-\n-                  elsif Ekind (Etype (Def_Id)) /= E_Access_Subprogram_Type\n-                    and then not Ekind_In (Etype (This_Formal),\n-                                             E_Access_Type,\n-                                             E_General_Access_Type,\n-                                             E_Anonymous_Access_Type)\n-                  then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"first formal of % function must be a named access \"\n-                        & \"type\", Parameter_Type (Parent (This_Formal)));\n-\n-                  elsif Atree.Convention\n-                         (Designated_Type (Etype (This_Formal))) /= Convention\n-                  then\n-                     Error_Msg_Name_1 := Pname;\n-\n-                     if Convention = Convention_Java then\n-                        Error_Msg_N\n-                          (\"pragma% requires convention 'Cil in designated \"\n-                           & \"type\", Parameter_Type (Parent (This_Formal)));\n-                     else\n-                        Error_Msg_N\n-                          (\"pragma% requires convention 'Java in designated \"\n-                           & \"type\", Parameter_Type (Parent (This_Formal)));\n-                     end if;\n-\n-                  elsif No (Expression (Parent (This_Formal)))\n-                    or else Nkind (Expression (Parent (This_Formal))) /= N_Null\n-                  then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"pragma% requires first formal with default `null`\",\n-                        Parameter_Type (Parent (This_Formal)));\n-                  end if;\n-               end if;\n-\n-               --  Check result type: the constructor must be a function\n-               --  returning:\n-               --   * a value type (only allowed in the CIL compiler)\n-               --   * an access-to-subprogram type with convention Java/CIL\n-               --   * an access-type designating a type that has convention\n-               --     Java/CIL.\n-\n-               if Is_Value_Type (Etype (Def_Id)) then\n-                  null;\n-\n-               --  Access-to-subprogram type with convention Java/CIL\n-\n-               elsif Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type then\n-                  if Atree.Convention (Etype (Def_Id)) /= Convention then\n-                     if Convention = Convention_Java then\n-                        Error_Pragma_Arg\n-                          (\"pragma% requires function returning a 'Java \"\n-                           & \"access type\", Arg1);\n-                     else\n-                        pragma Assert (Convention = Convention_CIL);\n-                        Error_Pragma_Arg\n-                          (\"pragma% requires function returning a 'C'I'L \"\n-                           & \"access type\", Arg1);\n-                     end if;\n-                  end if;\n-\n-               elsif Is_Access_Type (Etype (Def_Id)) then\n-                  if not Ekind_In (Etype (Def_Id), E_Access_Type,\n-                                                   E_General_Access_Type)\n-                    or else\n-                      Atree.Convention\n-                        (Designated_Type (Etype (Def_Id))) /= Convention\n-                  then\n-                     Error_Msg_Name_1 := Pname;\n-\n-                     if Convention = Convention_Java then\n-                        Error_Pragma_Arg\n-                          (\"pragma% requires function returning a named \"\n-                           & \"'Java access type\", Arg1);\n-                     else\n-                        Error_Pragma_Arg\n-                          (\"pragma% requires function returning a named \"\n-                           & \"'C'I'L access type\", Arg1);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Set_Is_Constructor (Def_Id);\n-               Set_Convention     (Def_Id, Convention);\n-               Set_Is_Imported    (Def_Id);\n-\n-               exit when From_Aspect_Specification (N);\n-               Hom_Id := Homonym (Hom_Id);\n-\n-               exit when No (Hom_Id) or else Scope (Hom_Id) /= Current_Scope;\n-            end loop;\n-         end Java_Constructor;\n-\n-         ----------------------\n-         -- Java_Interface --\n-         ----------------------\n-\n-         --  pragma Java_Interface ([Entity =>] LOCAL_NAME);\n-\n-         when Pragma_Java_Interface => Java_Interface : declare\n-            Arg : Node_Id;\n-            Typ : Entity_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            Arg := Get_Pragma_Arg (Arg1);\n-            Analyze (Arg);\n-\n-            if Etype (Arg) = Any_Type then\n-               return;\n-            end if;\n-\n-            if not Is_Entity_Name (Arg)\n-              or else not Is_Type (Entity (Arg))\n-            then\n-               Error_Pragma_Arg (\"pragma% requires a type mark\", Arg1);\n-            end if;\n-\n-            Typ := Underlying_Type (Entity (Arg));\n-\n-            --  For now simply check some of the semantic constraints on the\n-            --  type. This currently leaves out some restrictions on interface\n-            --  types, namely that the parent type must be java.lang.Object.Typ\n-            --  and that all primitives of the type should be declared\n-            --  abstract. ???\n-\n-            if not Is_Tagged_Type (Typ) or else not Is_Abstract_Type (Typ) then\n-               Error_Pragma_Arg\n-                 (\"pragma% requires an abstract tagged type\", Arg1);\n-\n-            elsif not Has_Discriminants (Typ)\n-              or else Ekind (Etype (First_Discriminant (Typ)))\n-                        /= E_Anonymous_Access_Type\n-              or else\n-                not Is_Class_Wide_Type\n-                      (Designated_Type (Etype (First_Discriminant (Typ))))\n-            then\n-               Error_Pragma_Arg\n-                 (\"type must have a class-wide access discriminant\", Arg1);\n-            end if;\n-         end Java_Interface;\n-\n          ----------------\n          -- Keep_Names --\n          ----------------\n@@ -17634,18 +17249,6 @@ package body Sem_Prag is\n                   if CodePeer_Mode then\n                      null;\n \n-                  --  Don't attempt any packing for VM targets. We possibly\n-                  --  could deal with some cases of array bit-packing, but we\n-                  --  don't bother, since this is not a typical kind of\n-                  --  representation in the VM context anyway (and would not\n-                  --  for example work nicely with the debugger).\n-\n-                  elsif VM_Target /= No_VM then\n-                     if not GNAT_Mode then\n-                        Error_Pragma\n-                          (\"??pragma% ignored in this configuration\");\n-                     end if;\n-\n                   --  Normal case where we do the pack action\n \n                   else\n@@ -17662,23 +17265,9 @@ package body Sem_Prag is\n \n             else pragma Assert (Is_Record_Type (Typ));\n                if not Rep_Item_Too_Late (Typ, N) then\n-\n-                  --  Ignore pack request with warning in VM mode (skip warning\n-                  --  if we are compiling GNAT run time library).\n-\n-                  if VM_Target /= No_VM then\n-                     if not GNAT_Mode then\n-                        Error_Pragma\n-                          (\"??pragma% ignored in this configuration\");\n-                     end if;\n-\n-                  --  Normal case of pack request active\n-\n-                  else\n-                     Set_Is_Packed            (Base_Type (Typ));\n-                     Set_Has_Pragma_Pack      (Base_Type (Typ));\n-                     Set_Has_Non_Standard_Rep (Base_Type (Typ));\n-                  end if;\n+                  Set_Is_Packed            (Base_Type (Typ));\n+                  Set_Has_Pragma_Pack      (Base_Type (Typ));\n+                  Set_Has_Non_Standard_Rep (Base_Type (Typ));\n                end if;\n             end if;\n          end Pack;\n@@ -26619,7 +26208,6 @@ package body Sem_Prag is\n       Pragma_Check_Float_Overflow           =>  0,\n       Pragma_Check_Name                     =>  0,\n       Pragma_Check_Policy                   =>  0,\n-      Pragma_CIL_Constructor                =>  0,\n       Pragma_CPP_Class                      =>  0,\n       Pragma_CPP_Constructor                =>  0,\n       Pragma_CPP_Virtual                    =>  0,\n@@ -26698,8 +26286,6 @@ package body Sem_Prag is\n       Pragma_Interrupt_Priority             => -1,\n       Pragma_Interrupt_State                => -1,\n       Pragma_Invariant                      => -1,\n-      Pragma_Java_Constructor               => -1,\n-      Pragma_Java_Interface                 => -1,\n       Pragma_Keep_Names                     =>  0,\n       Pragma_License                        =>  0,\n       Pragma_Link_With                      => -1,\n@@ -27380,12 +26966,11 @@ package body Sem_Prag is\n    begin\n       --  If first character is asterisk, this is a link name, and we leave it\n       --  completely unmodified. We also ignore null strings (the latter case\n-      --  happens only in error cases) and no encoding should occur for Java or\n-      --  AAMP interface names.\n+      --  happens only in error cases) and no encoding should occur for AAMP\n+      --  interface names.\n \n       if Len = 0\n         or else Get_String_Char (Str, 1) = Get_Char_Code ('*')\n-        or else VM_Target /= No_VM\n         or else AAMP_On_Target\n       then\n          Set_Interface_Name (E, S);"}, {"sha": "06833fd9957a77f3111b3d272c3eb77821499761", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -1728,18 +1728,6 @@ package body Sem_Type is\n          end if;\n       end if;\n \n-      --  Check for overloaded CIL convention stuff because the CIL libraries\n-      --  do sick things like Console.Write_Line where it matches two different\n-      --  overloads, so just pick the first ???\n-\n-      if Convention (Nam1) = Convention_CIL\n-        and then Convention (Nam2) = Convention_CIL\n-        and then Ekind (Nam1) = Ekind (Nam2)\n-        and then Ekind_In (Nam1, E_Procedure, E_Function)\n-      then\n-         return It2;\n-      end if;\n-\n       --  If the context is universal, the predefined operator is preferred.\n       --  This includes bounds in numeric type declarations, and expressions\n       --  in type conversions. If no interpretation yields a universal type,"}, {"sha": "3295ea3d09f284299492034482232c84620f6fdb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 106, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -3051,48 +3051,6 @@ package body Sem_Util is\n       end loop Outer;\n    end Check_Later_Vs_Basic_Declarations;\n \n-   -------------------------\n-   -- Check_Nested_Access --\n-   -------------------------\n-\n-   procedure Check_Nested_Access (Ent : Entity_Id) is\n-      Scop         : constant Entity_Id := Current_Scope;\n-      Current_Subp : Entity_Id;\n-      Enclosing    : Entity_Id;\n-\n-   begin\n-      --  Currently only enabled for VM back-ends for efficiency\n-\n-      if VM_Target /= No_VM\n-        and then Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter)\n-        and then Scope (Ent) /= Empty\n-        and then not Is_Library_Level_Entity (Ent)\n-\n-        --  Comment the exclusion of imported entities ???\n-\n-        and then not Is_Imported (Ent)\n-      then\n-         --  Get current subprogram that is relevant\n-\n-         if Is_Subprogram (Scop)\n-           or else Is_Generic_Subprogram (Scop)\n-           or else Is_Entry (Scop)\n-         then\n-            Current_Subp := Scop;\n-         else\n-            Current_Subp := Current_Subprogram;\n-         end if;\n-\n-         Enclosing := Enclosing_Subprogram (Ent);\n-\n-         --  Set flag if uplevel reference\n-\n-         if Enclosing /= Empty and then Enclosing /= Current_Subp then\n-            Set_Has_Uplevel_Reference (Ent, True);\n-         end if;\n-      end if;\n-   end Check_Nested_Access;\n-\n    ---------------------------\n    -- Check_No_Hidden_State --\n    ---------------------------\n@@ -11108,54 +11066,6 @@ package body Sem_Util is\n       end case;\n    end Is_Declaration;\n \n-   -----------------\n-   -- Is_Delegate --\n-   -----------------\n-\n-   function Is_Delegate (T : Entity_Id) return Boolean is\n-      Desig_Type : Entity_Id;\n-\n-   begin\n-      if VM_Target /= CLI_Target then\n-         return False;\n-      end if;\n-\n-      --  Access-to-subprograms are delegates in CIL\n-\n-      if Ekind (T) = E_Access_Subprogram_Type then\n-         return True;\n-      end if;\n-\n-      if not Is_Access_Type (T) then\n-\n-         --  A delegate is a managed pointer. If no designated type is defined\n-         --  it means that it's not a delegate.\n-\n-         return False;\n-      end if;\n-\n-      Desig_Type := Etype (Directly_Designated_Type (T));\n-\n-      if not Is_Tagged_Type (Desig_Type) then\n-         return False;\n-      end if;\n-\n-      --  Test if the type is inherited from [mscorlib]System.Delegate\n-\n-      while Etype (Desig_Type) /= Desig_Type loop\n-         if Chars (Scope (Desig_Type)) /= No_Name\n-           and then Is_Imported (Scope (Desig_Type))\n-           and then Get_Name_String (Chars (Scope (Desig_Type))) = \"delegate\"\n-         then\n-            return True;\n-         end if;\n-\n-         Desig_Type := Etype (Desig_Type);\n-      end loop;\n-\n-      return False;\n-   end Is_Delegate;\n-\n    ----------------------------------------------\n    -- Is_Dependent_Component_Of_Mutable_Object --\n    ----------------------------------------------\n@@ -13252,18 +13162,6 @@ package body Sem_Util is\n       return T = Universal_Integer or else T = Universal_Real;\n    end Is_Universal_Numeric_Type;\n \n-   -------------------\n-   -- Is_Value_Type --\n-   -------------------\n-\n-   function Is_Value_Type (T : Entity_Id) return Boolean is\n-   begin\n-      return VM_Target = CLI_Target\n-        and then Nkind (T) in N_Has_Chars\n-        and then Chars (T) /= No_Name\n-        and then Get_Name_String (Chars (T)) = \"valuetype\";\n-   end Is_Value_Type;\n-\n    ----------------------------\n    -- Is_Variable_Size_Array --\n    ----------------------------\n@@ -15856,8 +15754,6 @@ package body Sem_Util is\n                      end;\n                   end if;\n                end if;\n-\n-               Check_Nested_Access (Ent);\n             end if;\n \n             Kill_Checks (Ent);\n@@ -17023,7 +16919,7 @@ package body Sem_Util is\n       --  type temporaries need finalization.\n \n       elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return not Is_Value_Type (Typ);\n+         return True;\n \n       --  Record type\n \n@@ -17235,7 +17131,7 @@ package body Sem_Util is\n       --  since they can't be called via dispatching.\n \n       elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return not Is_Value_Type (Typ);\n+         return True;\n \n       --  Untagged definite subtypes are known size. This includes all\n       --  elementary [sub]types. Tasks are known size even if they have"}, {"sha": "caa35401ee8e369707e970164792bf5b1bd24b2b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -308,11 +308,6 @@ package Sem_Util is\n    --  remains in the Examiner (JB01-005). Note that the Examiner does not\n    --  count package declarations in later declarative items.\n \n-   procedure Check_Nested_Access (Ent : Entity_Id);\n-   --  Check whether Ent denotes an entity declared in an uplevel scope, which\n-   --  is accessed inside a nested procedure, and set Has_Uplevel_Reference\n-   --  flag accordingly. This is currently only enabled for if on a VM target.\n-\n    procedure Check_No_Hidden_State (Id : Entity_Id);\n    --  Determine whether object or state Id introduces a hidden state. If this\n    --  is the case, emit an error.\n@@ -1256,11 +1251,6 @@ package Sem_Util is\n    function Is_Declaration (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a declaration\n \n-   function Is_Delegate (T : Entity_Id) return Boolean;\n-   --  Returns true if type T represents a delegate. A Delegate is the CIL\n-   --  object used to represent access-to-subprogram types. This is only\n-   --  relevant to CIL, will always return false for other targets.\n-\n    function Is_Dependent_Component_Of_Mutable_Object\n      (Object : Node_Id) return Boolean;\n    --  Returns True if Object is the name of a subcomponent that depends on\n@@ -1528,12 +1518,6 @@ package Sem_Util is\n    pragma Inline (Is_Universal_Numeric_Type);\n    --  True if T is Universal_Integer or Universal_Real\n \n-   function Is_Value_Type (T : Entity_Id) return Boolean;\n-   --  Returns true if type T represents a value type. This is only relevant to\n-   --  CIL, will always return false for other targets. A value type is a CIL\n-   --  object that is accessed directly, as opposed to the other CIL objects\n-   --  that are accessed through managed pointers.\n-\n    function Is_Variable_Size_Array (E : Entity_Id) return Boolean;\n    --  Returns true if E has variable size components\n "}, {"sha": "968d87def2ad9eadced43b561934aff0f233569b", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -8098,10 +8098,10 @@ package Sinfo is\n       --  For the case of the standard gigi backend, this means that all\n       --  checks are done in the front end.\n \n-      --  However, in the case of specialized back-ends, notably the JVM\n-      --  backend for JGNAT, additional requirements and restrictions apply\n-      --  to unchecked conversion, and these are most conveniently performed\n-      --  in the specialized back-end.\n+      --  However, in the case of specialized back-ends, in particular the JVM\n+      --  backend in the past, additional requirements and restrictions may\n+      --  apply to unchecked conversion, and these are most conveniently\n+      --  performed in the specialized back-end.\n \n       --  To accommodate this requirement, for such back ends, the following\n       --  special node is generated recording an unchecked conversion that"}, {"sha": "3de2b82cc6b22d88ac81b1c7cfb1d41a60a62b92", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -152,12 +152,10 @@ package body Snames is\n                                               Convention_Ada_Pass_By_Reference;\n          when Name_Assembler             => return Convention_Assembler;\n          when Name_C                     => return Convention_C;\n-         when Name_CIL                   => return Convention_CIL;\n          when Name_COBOL                 => return Convention_COBOL;\n          when Name_CPP                   => return Convention_CPP;\n          when Name_Fortran               => return Convention_Fortran;\n          when Name_Intrinsic             => return Convention_Intrinsic;\n-         when Name_Java                  => return Convention_Java;\n          when Name_Stdcall               => return Convention_Stdcall;\n          when Name_Stubbed               => return Convention_Stubbed;\n \n@@ -188,13 +186,11 @@ package body Snames is\n             return Name_Ada_Pass_By_Reference;\n          when Convention_Assembler             => return Name_Assembler;\n          when Convention_C                     => return Name_C;\n-         when Convention_CIL                   => return Name_CIL;\n          when Convention_COBOL                 => return Name_COBOL;\n          when Convention_CPP                   => return Name_CPP;\n          when Convention_Entry                 => return Name_Entry;\n          when Convention_Fortran               => return Name_Fortran;\n          when Convention_Intrinsic             => return Name_Intrinsic;\n-         when Convention_Java                  => return Name_Java;\n          when Convention_Protected             => return Name_Protected;\n          when Convention_Stdcall               => return Name_Stdcall;\n          when Convention_Stubbed               => return Name_Stubbed;"}, {"sha": "de46bdb93167a8e220085645119ea32342b067d1", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -464,7 +464,6 @@ package Snames is\n    Name_Atomic_Components              : constant Name_Id := N + $;\n    Name_Attach_Handler                 : constant Name_Id := N + $;\n    Name_Check                          : constant Name_Id := N + $; -- GNAT\n-   Name_CIL_Constructor                : constant Name_Id := N + $; -- GNAT\n    Name_Comment                        : constant Name_Id := N + $; -- GNAT\n    Name_Common_Object                  : constant Name_Id := N + $; -- GNAT\n    Name_Complete_Representation        : constant Name_Id := N + $; -- GNAT\n@@ -533,8 +532,6 @@ package Snames is\n    --  Is_Pragma_Id correctly recognize and process Interrupt_Priority.\n \n    Name_Invariant                      : constant Name_Id := N + $; -- GNAT\n-   Name_Java_Constructor               : constant Name_Id := N + $; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + $; -- GNAT\n    Name_Keep_Names                     : constant Name_Id := N + $; -- GNAT\n    Name_Link_With                      : constant Name_Id := N + $; -- GNAT\n    Name_Linker_Alias                   : constant Name_Id := N + $; -- GNAT\n@@ -651,12 +648,10 @@ package Snames is\n    Name_Ada_Pass_By_Copy               : constant Name_Id := N + $;\n    Name_Ada_Pass_By_Reference          : constant Name_Id := N + $;\n    Name_Assembler                      : constant Name_Id := N + $;\n-   Name_CIL                            : constant Name_Id := N + $;\n    Name_COBOL                          : constant Name_Id := N + $;\n    Name_CPP                            : constant Name_Id := N + $;\n    Name_Fortran                        : constant Name_Id := N + $;\n    Name_Intrinsic                      : constant Name_Id := N + $;\n-   Name_Java                           : constant Name_Id := N + $;\n    Name_Stdcall                        : constant Name_Id := N + $;\n    Name_Stubbed                        : constant Name_Id := N + $;\n    Last_Convention_Name                : constant Name_Id := N + $;\n@@ -1682,11 +1677,9 @@ package Snames is\n \n       Convention_Assembler,  --  also Asm, Assembly\n       Convention_C,          --  also Default, External\n-      Convention_CIL,\n       Convention_COBOL,\n       Convention_CPP,\n       Convention_Fortran,\n-      Convention_Java,\n       Convention_Stdcall);   --  also DLL, Win32\n \n       --  Note: Convention C_Pass_By_Copy is allowed only for record types\n@@ -1816,7 +1809,6 @@ package Snames is\n       Pragma_Atomic_Components,\n       Pragma_Attach_Handler,\n       Pragma_Check,\n-      Pragma_CIL_Constructor,\n       Pragma_Comment,\n       Pragma_Common_Object,\n       Pragma_Complete_Representation,\n@@ -1866,8 +1858,6 @@ package Snames is\n       Pragma_Interface_Name,\n       Pragma_Interrupt_Handler,\n       Pragma_Invariant,\n-      Pragma_Java_Constructor,\n-      Pragma_Java_Interface,\n       Pragma_Keep_Names,\n       Pragma_Link_With,\n       Pragma_Linker_Alias,"}, {"sha": "42696cf0ba250f7cfaead77f81ba8154b16f07a6", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -44,14 +44,12 @@ package body Targparm is\n       BDC,  --   Backend_Divide_Checks\n       BOC,  --   Backend_Overflow_Checks\n       CLA,  --   Command_Line_Args\n-      CLI,  --   CLI (.NET)\n       CRT,  --   Configurable_Run_Times\n       D32,  --   Duration_32_Bits\n       DEN,  --   Denorm\n       EXS,  --   Exit_Status_Supported\n       FEL,  --   Frontend_Layout\n       FFO,  --   Fractional_Fixed_Ops\n-      JVM,  --   JVM\n       MOV,  --   Machine_Overflows\n       MRN,  --   Machine_Rounds\n       PAS,  --   Preallocated_Stacks\n@@ -79,14 +77,12 @@ package body Targparm is\n    BDC_Str : aliased constant Source_Buffer := \"Backend_Divide_Checks\";\n    BOC_Str : aliased constant Source_Buffer := \"Backend_Overflow_Checks\";\n    CLA_Str : aliased constant Source_Buffer := \"Command_Line_Args\";\n-   CLI_Str : aliased constant Source_Buffer := \"CLI\";\n    CRT_Str : aliased constant Source_Buffer := \"Configurable_Run_Time\";\n    D32_Str : aliased constant Source_Buffer := \"Duration_32_Bits\";\n    DEN_Str : aliased constant Source_Buffer := \"Denorm\";\n    EXS_Str : aliased constant Source_Buffer := \"Exit_Status_Supported\";\n    FEL_Str : aliased constant Source_Buffer := \"Frontend_Layout\";\n    FFO_Str : aliased constant Source_Buffer := \"Fractional_Fixed_Ops\";\n-   JVM_Str : aliased constant Source_Buffer := \"JVM\";\n    MOV_Str : aliased constant Source_Buffer := \"Machine_Overflows\";\n    MRN_Str : aliased constant Source_Buffer := \"Machine_Rounds\";\n    PAS_Str : aliased constant Source_Buffer := \"Preallocated_Stacks\";\n@@ -114,14 +110,12 @@ package body Targparm is\n       BDC_Str'Access,\n       BOC_Str'Access,\n       CLA_Str'Access,\n-      CLI_Str'Access,\n       CRT_Str'Access,\n       D32_Str'Access,\n       DEN_Str'Access,\n       EXS_Str'Access,\n       FEL_Str'Access,\n       FFO_Str'Access,\n-      JVM_Str'Access,\n       MOV_Str'Access,\n       MRN_Str'Access,\n       PAS_Str'Access,\n@@ -794,33 +788,12 @@ package body Targparm is\n                      when BDC => Backend_Divide_Checks_On_Target     := Result;\n                      when BOC => Backend_Overflow_Checks_On_Target   := Result;\n                      when CLA => Command_Line_Args_On_Target         := Result;\n-                     when CLI =>\n-                        if Result then\n-                           VM_Target := CLI_Target;\n-                           Tagged_Type_Expansion := False;\n-                        end if;\n-                        --  This is wrong, this processing should be done in\n-                        --  Gnat1drv.Adjust_Global_Switches. It is not the\n-                        --  right level for targparm to know about tagged\n-                        --  type extension???\n-\n                      when CRT => Configurable_Run_Time_On_Target     := Result;\n                      when D32 => Duration_32_Bits_On_Target          := Result;\n                      when DEN => Denorm_On_Target                    := Result;\n                      when EXS => Exit_Status_Supported_On_Target     := Result;\n                      when FEL => Frontend_Layout_On_Target           := Result;\n                      when FFO => Fractional_Fixed_Ops_On_Target      := Result;\n-\n-                     when JVM =>\n-                        if Result then\n-                           VM_Target := JVM_Target;\n-                           Tagged_Type_Expansion := False;\n-                        end if;\n-                        --  This is wrong, this processing should be done in\n-                        --  Gnat1drv.Adjust_Global_Switches. It is not the\n-                        --  right level for targparm to know about tagged\n-                        --  type extension???\n-\n                      when MOV => Machine_Overflows_On_Target         := Result;\n                      when MRN => Machine_Rounds_On_Target            := Result;\n                      when PAS => Preallocated_Stacks_On_Target       := Result;"}, {"sha": "21780d1b12c893f452124d0197e83386f8e522af", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -203,13 +203,6 @@ package Targparm is\n    AAMP_On_Target : Boolean := False;\n    --  Set to True if target is AAMP\n \n-   type Virtual_Machine_Kind is (No_VM, JVM_Target, CLI_Target);\n-   VM_Target : Virtual_Machine_Kind := No_VM;\n-   --  Kind of virtual machine targetted\n-   --  No_VM: no virtual machine, default case of a standard processor\n-   --  JVM_Target: Java Virtual Machine\n-   --  CLI_Target: CLI/.NET Virtual Machine\n-\n    -------------------------------\n    -- Backend Arithmetic Checks --\n    -------------------------------"}, {"sha": "dc37f152e76cce95e650d7a427961537dc488a04", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -827,9 +827,8 @@ package Types is\n    --  To add a new code, you need to do the following:\n \n    --    1. Assign a new number to the reason. Do not renumber existing codes,\n-   --       since this causes compatibility/bootstrap issues, and problems in\n-   --       the CIL/JVM backends. So always add the new code at the end of the\n-   --       list.\n+   --       since this causes compatibility/bootstrap issues, so always add the\n+   --       new code at the end of the list.\n \n    --    2. Update the contents of the array Kind\n "}, {"sha": "b18d542f009f3901589ec268a9f435b8da2d1c9e", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a86378ea5182125321ceede077e3781973f0a/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=535a86378ea5182125321ceede077e3781973f0a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,9 +91,9 @@ begin\n \n    Write_Eol;\n \n-   --  Common GCC switches not available for JVM, .NET, and AAMP targets\n+   --  Common GCC switches not available for AAMP targets\n \n-   if VM_Target = No_VM and then not AAMP_On_Target then\n+   if not AAMP_On_Target then\n       Write_Switch_Char (\"fstack-check \", \"\");\n       Write_Line (\"Generate stack checking code\");\n "}]}