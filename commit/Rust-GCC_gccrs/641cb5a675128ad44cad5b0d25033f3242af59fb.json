{"sha": "641cb5a675128ad44cad5b0d25033f3242af59fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQxY2I1YTY3NTEyOGFkNDRjYWQ1YjBkMjUwMzNmMzI0MmFmNTlmYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-10-23T12:11:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-10-23T12:11:22Z"}, "message": "Implement C++17 Filesystem library\n\nBased on Filesystem TS implementation, with the changes applied by:\n\n- P0219R1 Relative Paths for Filesystem\n- P0317R1 Directory Entry Caching for Filesystem\n- P0492R2 Resolution of C++17 National Body Comments\n\nWhere appropriate code is shared between the TS and C++17\nimplementations.\n\n\t* include/Makefile.am: Add new headers for C++17 filesystem library.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/fs_dir.h: New header, based on Filesystem TS code in\n\tinclude/experimental/bits directory.\n\t* include/bits/fs_fwd.h: Likewise.\n\t* include/bits/fs_ops.h: Likewise.\n\t* include/bits/fs_path.h: Likewise.\n\t* include/experimental/bits/fs_dir.h: Rename Doxygen group.\n\t* include/experimental/bits/fs_fwd.h: Likewise.\n\t* include/experimental/bits/fs_ops.h: Likewise.\n\t* include/experimental/bits/fs_path.h: Likewise.\n\t* include/experimental/filesystem (filesystem_error::_M_gen_what):\n\tRemove inline definition.\n\t* include/precompiled/stdc++.h: Add <filesystem> to precompiled\n\theader.\n\t* include/std/filesystem: New header.\n\t* python/libstdcxx/v6/printers.py: Enable printer for std::filesystem\n\tpaths.\n\t* src/filesystem/Makefile.am: Add new files. Compile as C++17.\n\t* src/filesystem/Makefile.in: Regenerate.\n\t* src/filesystem/cow-dir.cc: Update comment.\n\t* src/filesystem/cow-ops.cc: Likewise.\n\t* src/filesystem/cow-path.cc: Likewise.\n\t* src/filesystem/cow-std-dir.cc: New file.\n\t* src/filesystem/cow-std-ops.cc: New file.\n\t* src/filesystem/cow-std-path.cc: New file.\n\t* src/filesystem/dir-common.h (_Dir_base, get_file_type): New header\n\tfor common code.\n\t* src/filesystem/dir.cc (_Dir): Derive from _Dir_base.\n\t(open_dir): Move to _Dir_base constructor.\n\t(get_file_type): Move to dir-common.h.\n\t(recurse): Move to _Dir_base::should_recurse.\n\t* src/filesystem/ops-common.h: New header for common code.\n\t* src/filesystem/ops.cc (is_set, make_file_type, make_file_status)\n\t(is_not_found_errno, file_time, do_copy_file): Move to ops-common.h.\n\t* src/filesystem/path.cc (filesystem_error::_M_gen_what): Define.\n\t* src/filesystem/std-dir.cc: New file, based on Filesystem TS code.\n\t* src/filesystem/std-ops.cc: Likewise.\n\t* src/filesystem/std-dir.cc: Likewise.\n\t* testsuite/27_io/filesystem/iterators/directory_iterator.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/iterators/pop.cc: New test.\n\t* testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc:\n\tNew test.\n\t* testsuite/27_io/filesystem/operations/absolute.cc: New test.\n\t* testsuite/27_io/filesystem/operations/canonical.cc: New test.\n\t* testsuite/27_io/filesystem/operations/copy.cc: New test.\n\t* testsuite/27_io/filesystem/operations/copy_file.cc: New test.\n\t* testsuite/27_io/filesystem/operations/create_directories.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/operations/create_directory.cc: New test.\n\t* testsuite/27_io/filesystem/operations/create_symlink.cc: New test.\n\t* testsuite/27_io/filesystem/operations/current_path.cc: New test.\n\t* testsuite/27_io/filesystem/operations/equivalent.cc: New test.\n\t* testsuite/27_io/filesystem/operations/exists.cc: New test.\n\t* testsuite/27_io/filesystem/operations/file_size.cc: New test.\n\t* testsuite/27_io/filesystem/operations/is_empty.cc: New test.\n\t* testsuite/27_io/filesystem/operations/last_write_time.cc: New test.\n\t* testsuite/27_io/filesystem/operations/permissions.cc: New test.\n\t* testsuite/27_io/filesystem/operations/proximate.cc: New test.\n\t* testsuite/27_io/filesystem/operations/read_symlink.cc: New test.\n\t* testsuite/27_io/filesystem/operations/relative.cc: New test.\n\t* testsuite/27_io/filesystem/operations/remove_all.cc: New test.\n\t* testsuite/27_io/filesystem/operations/space.cc: New test.\n\t* testsuite/27_io/filesystem/operations/status.cc: New test.\n\t* testsuite/27_io/filesystem/operations/symlink_status.cc: New test.\n\t* testsuite/27_io/filesystem/operations/temp_directory_path.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/operations/weakly_canonical.cc: New test.\n\t* testsuite/27_io/filesystem/path/append/path.cc: New test.\n\t* testsuite/27_io/filesystem/path/assign/assign.cc: New test.\n\t* testsuite/27_io/filesystem/path/assign/copy.cc: New test.\n\t* testsuite/27_io/filesystem/path/compare/compare.cc: New test.\n\t* testsuite/27_io/filesystem/path/compare/path.cc: New test.\n\t* testsuite/27_io/filesystem/path/compare/strings.cc: New test.\n\t* testsuite/27_io/filesystem/path/concat/path.cc: New test.\n\t* testsuite/27_io/filesystem/path/concat/strings.cc: New test.\n\t* testsuite/27_io/filesystem/path/construct/copy.cc: New test.\n\t* testsuite/27_io/filesystem/path/construct/default.cc: New test.\n\t* testsuite/27_io/filesystem/path/construct/locale.cc: New test.\n\t* testsuite/27_io/filesystem/path/construct/range.cc: New test.\n\t* testsuite/27_io/filesystem/path/construct/string_view.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/extension.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/filename.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/parent_path.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/relative_path.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/decompose/root_directory.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/decompose/root_name.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/root_path.cc: New test.\n\t* testsuite/27_io/filesystem/path/decompose/stem.cc: New test.\n\t* testsuite/27_io/filesystem/path/generation/normal.cc: New test.\n\t* testsuite/27_io/filesystem/path/generation/proximate.cc: New test.\n\t* testsuite/27_io/filesystem/path/generation/relative.cc: New test.\n\t* testsuite/27_io/filesystem/path/generic/generic_string.cc: New test.\n\t* testsuite/27_io/filesystem/path/itr/traversal.cc: New test.\n\t* testsuite/27_io/filesystem/path/modifiers/clear.cc: New test.\n\t* testsuite/27_io/filesystem/path/modifiers/make_preferred.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/modifiers/remove_filename.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/modifiers/replace_extension.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/modifiers/replace_filename.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/modifiers/swap.cc: New test.\n\t* testsuite/27_io/filesystem/path/native/string.cc: New test.\n\t* testsuite/27_io/filesystem/path/nonmember/hash_value.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/empty.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_extension.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_filename.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_parent_path.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_relative_path.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/query/has_root_directory.cc: New\n\ttest.\n\t* testsuite/27_io/filesystem/path/query/has_root_name.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_root_path.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/has_stem.cc: New test.\n\t* testsuite/27_io/filesystem/path/query/is_relative.cc: New test.\n\t* testsuite/experimental/filesystem/path/construct/string_view.cc:\n\tDefine USE_FILESYSTEM_TS.\n\t* testsuite/util/testsuite_fs.h: Allow use with C++17 paths as well\n\tas Filesystem TS.\n\nFrom-SVN: r254008", "tree": {"sha": "10dddf8d3eafa45b38924701f2a0e58d175aea57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10dddf8d3eafa45b38924701f2a0e58d175aea57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/641cb5a675128ad44cad5b0d25033f3242af59fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641cb5a675128ad44cad5b0d25033f3242af59fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641cb5a675128ad44cad5b0d25033f3242af59fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641cb5a675128ad44cad5b0d25033f3242af59fb/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9"}], "stats": {"total": 11348, "additions": 10854, "deletions": 494}, "files": [{"sha": "6bb7214474657aee11cd4f346a9f0db34e864c62", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,5 +1,131 @@\n 2017-10-23  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/Makefile.am: Add new headers for C++17 filesystem library.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/fs_dir.h: New header, based on Filesystem TS code in\n+\tinclude/experimental/bits directory.\n+\t* include/bits/fs_fwd.h: Likewise.\n+\t* include/bits/fs_ops.h: Likewise.\n+\t* include/bits/fs_path.h: Likewise.\n+\t* include/experimental/bits/fs_dir.h: Rename Doxygen group.\n+\t* include/experimental/bits/fs_fwd.h: Likewise.\n+\t* include/experimental/bits/fs_ops.h: Likewise.\n+\t* include/experimental/bits/fs_path.h: Likewise.\n+\t* include/experimental/filesystem (filesystem_error::_M_gen_what):\n+\tRemove inline definition.\n+\t* include/precompiled/stdc++.h: Add <filesystem> to precompiled\n+\theader.\n+\t* include/std/filesystem: New header.\n+\t* python/libstdcxx/v6/printers.py: Enable printer for std::filesystem\n+\tpaths.\n+\t* src/filesystem/Makefile.am: Add new files. Compile as C++17.\n+\t* src/filesystem/Makefile.in: Regenerate.\n+\t* src/filesystem/cow-dir.cc: Update comment.\n+\t* src/filesystem/cow-ops.cc: Likewise.\n+\t* src/filesystem/cow-path.cc: Likewise.\n+\t* src/filesystem/cow-std-dir.cc: New file.\n+\t* src/filesystem/cow-std-ops.cc: New file.\n+\t* src/filesystem/cow-std-path.cc: New file.\n+\t* src/filesystem/dir-common.h (_Dir_base, get_file_type): New header\n+\tfor common code.\n+\t* src/filesystem/dir.cc (_Dir): Derive from _Dir_base.\n+\t(open_dir): Move to _Dir_base constructor.\n+\t(get_file_type): Move to dir-common.h.\n+\t(recurse): Move to _Dir_base::should_recurse.\n+\t* src/filesystem/ops-common.h: New header for common code.\n+\t* src/filesystem/ops.cc (is_set, make_file_type, make_file_status)\n+\t(is_not_found_errno, file_time, do_copy_file): Move to ops-common.h.\n+\t* src/filesystem/path.cc (filesystem_error::_M_gen_what): Define.\n+\t* src/filesystem/std-dir.cc: New file, based on Filesystem TS code.\n+\t* src/filesystem/std-ops.cc: Likewise.\n+\t* src/filesystem/std-dir.cc: Likewise.\n+\t* testsuite/27_io/filesystem/iterators/directory_iterator.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/iterators/pop.cc: New test.\n+\t* testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc:\n+\tNew test.\n+\t* testsuite/27_io/filesystem/operations/absolute.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/canonical.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/copy.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/copy_file.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/create_directories.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/operations/create_directory.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/create_symlink.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/current_path.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/equivalent.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/exists.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/file_size.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/is_empty.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/last_write_time.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/permissions.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/proximate.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/read_symlink.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/relative.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/remove_all.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/space.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/status.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/symlink_status.cc: New test.\n+\t* testsuite/27_io/filesystem/operations/temp_directory_path.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/operations/weakly_canonical.cc: New test.\n+\t* testsuite/27_io/filesystem/path/append/path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/assign/assign.cc: New test.\n+\t* testsuite/27_io/filesystem/path/assign/copy.cc: New test.\n+\t* testsuite/27_io/filesystem/path/compare/compare.cc: New test.\n+\t* testsuite/27_io/filesystem/path/compare/path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/compare/strings.cc: New test.\n+\t* testsuite/27_io/filesystem/path/concat/path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/concat/strings.cc: New test.\n+\t* testsuite/27_io/filesystem/path/construct/copy.cc: New test.\n+\t* testsuite/27_io/filesystem/path/construct/default.cc: New test.\n+\t* testsuite/27_io/filesystem/path/construct/locale.cc: New test.\n+\t* testsuite/27_io/filesystem/path/construct/range.cc: New test.\n+\t* testsuite/27_io/filesystem/path/construct/string_view.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/extension.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/filename.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/parent_path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/relative_path.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/decompose/root_directory.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/decompose/root_name.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/root_path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/decompose/stem.cc: New test.\n+\t* testsuite/27_io/filesystem/path/generation/normal.cc: New test.\n+\t* testsuite/27_io/filesystem/path/generation/proximate.cc: New test.\n+\t* testsuite/27_io/filesystem/path/generation/relative.cc: New test.\n+\t* testsuite/27_io/filesystem/path/generic/generic_string.cc: New test.\n+\t* testsuite/27_io/filesystem/path/itr/traversal.cc: New test.\n+\t* testsuite/27_io/filesystem/path/modifiers/clear.cc: New test.\n+\t* testsuite/27_io/filesystem/path/modifiers/make_preferred.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/modifiers/remove_filename.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/modifiers/replace_extension.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/modifiers/replace_filename.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/modifiers/swap.cc: New test.\n+\t* testsuite/27_io/filesystem/path/native/string.cc: New test.\n+\t* testsuite/27_io/filesystem/path/nonmember/hash_value.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/empty.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_extension.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_filename.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_parent_path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_relative_path.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/query/has_root_directory.cc: New\n+\ttest.\n+\t* testsuite/27_io/filesystem/path/query/has_root_name.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_root_path.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/has_stem.cc: New test.\n+\t* testsuite/27_io/filesystem/path/query/is_relative.cc: New test.\n+\t* testsuite/experimental/filesystem/path/construct/string_view.cc:\n+\tDefine USE_FILESYSTEM_TS.\n+\t* testsuite/util/testsuite_fs.h: Allow use with C++17 paths as well\n+\tas Filesystem TS.\n+\n \tPR libstdc++/82644\n \t* doc/xml/manual/intro.xml: Include new section.\n \t* doc/xml/manual/status_cxxis29124.xml: New section on IS 29124"}, {"sha": "2c4d193d0a4a529977139f3696dd91c75e689434", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -37,6 +37,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n \t${std_srcdir}/functional \\\n@@ -104,6 +105,10 @@ bits_headers = \\\n \t${bits_srcdir}/enable_special_members.h \\\n \t${bits_srcdir}/forward_list.h \\\n \t${bits_srcdir}/forward_list.tcc \\\n+\t${bits_srcdir}/fs_dir.h \\\n+\t${bits_srcdir}/fs_fwd.h \\\n+\t${bits_srcdir}/fs_ops.h \\\n+\t${bits_srcdir}/fs_path.h \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n \t${bits_srcdir}/functional_hash.h \\"}, {"sha": "bc8556c68d2a5f36db3ab2fad3843ea47800d92e", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -330,6 +330,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n \t${std_srcdir}/functional \\\n@@ -397,6 +398,10 @@ bits_headers = \\\n \t${bits_srcdir}/enable_special_members.h \\\n \t${bits_srcdir}/forward_list.h \\\n \t${bits_srcdir}/forward_list.tcc \\\n+\t${bits_srcdir}/fs_dir.h \\\n+\t${bits_srcdir}/fs_fwd.h \\\n+\t${bits_srcdir}/fs_ops.h \\\n+\t${bits_srcdir}/fs_path.h \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n \t${bits_srcdir}/functional_hash.h \\"}, {"sha": "20ce9beb0237d257b500a0f8967bd974e05bcd9f", "filename": "libstdc++-v3/include/bits/fs_dir.h", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,526 @@\n+// Filesystem directory utilities -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/fs_dir.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_FS_DIR_H\n+#define _GLIBCXX_FS_DIR_H 1\n+\n+#if __cplusplus >= 201703L\n+# include <typeinfo>\n+# include <ext/concurrence.h>\n+# include <bits/unique_ptr.h>\n+# include <bits/shared_ptr.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace filesystem\n+{\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  class file_status\n+  {\n+  public:\n+    // constructors\n+    explicit\n+    file_status(file_type __ft = file_type::none,\n+\t        perms __prms = perms::unknown) noexcept\n+    : _M_type(__ft), _M_perms(__prms) { }\n+\n+    file_status(const file_status&) noexcept = default;\n+    file_status(file_status&&) noexcept = default;\n+    ~file_status() = default;\n+\n+    file_status& operator=(const file_status&) noexcept = default;\n+    file_status& operator=(file_status&&) noexcept = default;\n+\n+    // observers\n+    file_type  type() const noexcept { return _M_type; }\n+    perms      permissions() const noexcept { return _M_perms; }\n+\n+    // modifiers\n+    void       type(file_type __ft) noexcept { _M_type = __ft; }\n+    void       permissions(perms __prms) noexcept { _M_perms = __prms; }\n+\n+  private:\n+    file_type\t_M_type;\n+    perms\t_M_perms;\n+  };\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  struct _Dir;\n+  class directory_iterator;\n+  class recursive_directory_iterator;\n+\n+  class directory_entry\n+  {\n+  public:\n+    // constructors and destructor\n+    directory_entry() noexcept = default;\n+    directory_entry(const directory_entry&) = default;\n+    directory_entry(directory_entry&&) noexcept = default;\n+\n+    explicit\n+    directory_entry(const filesystem::path& __p)\n+    : _M_path(__p)\n+    { refresh(); }\n+\n+    directory_entry(const filesystem::path& __p, error_code& __ec)\n+    : _M_path(__p)\n+    {\n+      refresh(__ec);\n+      if (__ec)\n+\t_M_path.clear();\n+    }\n+\n+    ~directory_entry() = default;\n+\n+    // modifiers\n+    directory_entry& operator=(const directory_entry&) = default;\n+    directory_entry& operator=(directory_entry&&) noexcept = default;\n+\n+    void\n+    assign(const filesystem::path& __p)\n+    {\n+      _M_path = __p;\n+      refresh();\n+    }\n+\n+    void\n+    assign(const filesystem::path& __p, error_code& __ec)\n+    {\n+      _M_path = __p;\n+      refresh(__ec);\n+    }\n+\n+    void\n+    replace_filename(const filesystem::path& __p)\n+    {\n+      _M_path.replace_filename(__p);\n+      refresh();\n+    }\n+\n+    void\n+    replace_filename(const filesystem::path& __p, error_code& __ec)\n+    {\n+      _M_path.replace_filename(__p);\n+      refresh(__ec);\n+    }\n+\n+    void refresh() { _M_type = symlink_status().type(); }\n+    void refresh(error_code& __ec) { _M_type = symlink_status(__ec).type(); }\n+\n+    // observers\n+    const filesystem::path& path() const noexcept { return _M_path; }\n+    operator const filesystem::path& () const noexcept { return _M_path; }\n+\n+    bool\n+    exists() const\n+    { return filesystem::exists(file_status{_M_file_type()}); }\n+\n+    bool\n+    exists(error_code& __ec) const noexcept\n+    { return filesystem::exists(file_status{_M_file_type(__ec)}); }\n+\n+    bool\n+    is_block_file() const\n+    { return _M_file_type() == file_type::block; }\n+\n+    bool\n+    is_block_file(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::block; }\n+\n+    bool\n+    is_character_file() const\n+    { return _M_file_type() == file_type::character; }\n+\n+    bool\n+    is_character_file(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::character; }\n+\n+    bool\n+    is_directory() const\n+    { return _M_file_type() == file_type::directory; }\n+\n+    bool\n+    is_directory(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::directory; }\n+\n+    bool\n+    is_fifo() const\n+    { return _M_file_type() == file_type::fifo; }\n+\n+    bool\n+    is_fifo(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::fifo; }\n+\n+    bool\n+    is_other() const\n+    { return filesystem::is_other(file_status{_M_file_type()}); }\n+\n+    bool\n+    is_other(error_code& __ec) const noexcept\n+    { return filesystem::is_other(file_status{_M_file_type(__ec)}); }\n+\n+    bool\n+    is_regular_file() const\n+    { return _M_file_type() == file_type::regular; }\n+\n+    bool\n+    is_regular_file(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::regular; }\n+\n+    bool\n+    is_socket() const\n+    { return _M_file_type() == file_type::socket; }\n+\n+    bool\n+    is_socket(error_code& __ec) const noexcept\n+    { return _M_file_type(__ec) == file_type::socket; }\n+\n+    bool\n+    is_symlink() const\n+    {\n+      if (_M_type != file_type::none)\n+\treturn _M_type == file_type::symlink;\n+      return symlink_status().type() == file_type::symlink;\n+    }\n+\n+    bool\n+    is_symlink(error_code& __ec) const noexcept\n+    {\n+      if (_M_type != file_type::none)\n+\treturn _M_type == file_type::symlink;\n+      return symlink_status(__ec).type() == file_type::symlink;\n+    }\n+\n+    uintmax_t\n+    file_size() const\n+    { return filesystem::file_size(_M_path); }\n+\n+    uintmax_t\n+    file_size(error_code& __ec) const noexcept\n+    { return filesystem::file_size(_M_path, __ec); }\n+\n+    uintmax_t\n+    hard_link_count() const\n+    { return filesystem::hard_link_count(_M_path); }\n+\n+    uintmax_t\n+    hard_link_count(error_code& __ec) const noexcept\n+    { return filesystem::hard_link_count(_M_path, __ec); }\n+\n+    file_time_type\n+    last_write_time() const\n+    { return filesystem::last_write_time(_M_path); }\n+\n+\n+    file_time_type\n+    last_write_time(error_code& __ec) const noexcept\n+    { return filesystem::last_write_time(_M_path, __ec); }\n+\n+    file_status\n+    status() const\n+    { return filesystem::status(_M_path); }\n+\n+    file_status\n+    status(error_code& __ec) const noexcept\n+    { return filesystem::status(_M_path, __ec); }\n+\n+    file_status\n+    symlink_status() const\n+    { return filesystem::symlink_status(_M_path); }\n+\n+    file_status\n+    symlink_status(error_code& __ec) const noexcept\n+    { return filesystem::symlink_status(_M_path, __ec); }\n+\n+    bool\n+    operator< (const directory_entry& __rhs) const noexcept\n+    { return _M_path < __rhs._M_path; }\n+\n+    bool\n+    operator==(const directory_entry& __rhs) const noexcept\n+    { return _M_path == __rhs._M_path; }\n+\n+    bool\n+    operator!=(const directory_entry& __rhs) const noexcept\n+    { return _M_path != __rhs._M_path; }\n+\n+    bool\n+    operator<=(const directory_entry& __rhs) const noexcept\n+    { return _M_path <= __rhs._M_path; }\n+\n+    bool\n+    operator> (const directory_entry& __rhs) const noexcept\n+    { return _M_path > __rhs._M_path; }\n+\n+    bool\n+    operator>=(const directory_entry& __rhs) const noexcept\n+    { return _M_path >= __rhs._M_path; }\n+\n+  private:\n+    friend class _Dir;\n+    friend class directory_iterator;\n+    friend class recursive_directory_iterator;\n+\n+    directory_entry(const filesystem::path& __p, file_type __t)\n+    : _M_path(__p), _M_type(__t)\n+    { }\n+\n+    // Equivalent to status().type() but uses cached value, if any.\n+    file_type\n+    _M_file_type() const\n+    {\n+      if (_M_type != file_type::none && _M_type != file_type::symlink)\n+\treturn _M_type;\n+      return status().type();\n+    }\n+\n+    // Equivalent to status(__ec).type() but uses cached value, if any.\n+    file_type\n+    _M_file_type(error_code& __ec) const noexcept\n+    {\n+      if (_M_type != file_type::none && _M_type != file_type::symlink)\n+\treturn _M_type;\n+      return status(__ec).type();\n+    }\n+\n+    filesystem::path\t_M_path;\n+    file_type\t\t_M_type = file_type::none;\n+  };\n+\n+  struct __directory_iterator_proxy\n+  {\n+    const directory_entry& operator*() const& noexcept { return _M_entry; }\n+\n+    directory_entry operator*() && noexcept { return std::move(_M_entry); }\n+\n+  private:\n+    friend class directory_iterator;\n+    friend class recursive_directory_iterator;\n+\n+    explicit\n+    __directory_iterator_proxy(const directory_entry& __e) : _M_entry(__e) { }\n+\n+    directory_entry _M_entry;\n+  };\n+\n+  class directory_iterator\n+  {\n+  public:\n+    typedef directory_entry        value_type;\n+    typedef ptrdiff_t              difference_type;\n+    typedef const directory_entry* pointer;\n+    typedef const directory_entry& reference;\n+    typedef input_iterator_tag     iterator_category;\n+\n+    directory_iterator() = default;\n+\n+    explicit\n+    directory_iterator(const path& __p)\n+    : directory_iterator(__p, directory_options::none, nullptr) { }\n+\n+    directory_iterator(const path& __p, directory_options __options)\n+    : directory_iterator(__p, __options, nullptr) { }\n+\n+    directory_iterator(const path& __p, error_code& __ec) noexcept\n+    : directory_iterator(__p, directory_options::none, __ec) { }\n+\n+    directory_iterator(const path& __p,\n+\t\t       directory_options __options,\n+\t\t       error_code& __ec) noexcept\n+    : directory_iterator(__p, __options, &__ec) { }\n+\n+    directory_iterator(const directory_iterator& __rhs) = default;\n+\n+    directory_iterator(directory_iterator&& __rhs) noexcept = default;\n+\n+    ~directory_iterator() = default;\n+\n+    directory_iterator&\n+    operator=(const directory_iterator& __rhs) = default;\n+\n+    directory_iterator&\n+    operator=(directory_iterator&& __rhs) noexcept = default;\n+\n+    const directory_entry& operator*() const;\n+    const directory_entry* operator->() const { return &**this; }\n+    directory_iterator&    operator++();\n+    directory_iterator&    increment(error_code& __ec) noexcept;\n+\n+    __directory_iterator_proxy operator++(int)\n+    {\n+      __directory_iterator_proxy __pr{**this};\n+      ++*this;\n+      return __pr;\n+    }\n+\n+  private:\n+    directory_iterator(const path&, directory_options, error_code*);\n+\n+    friend bool\n+    operator==(const directory_iterator& __lhs,\n+               const directory_iterator& __rhs);\n+\n+    friend class recursive_directory_iterator;\n+\n+    std::shared_ptr<_Dir> _M_dir;\n+  };\n+\n+  inline directory_iterator\n+  begin(directory_iterator __iter) noexcept\n+  { return __iter; }\n+\n+  inline directory_iterator\n+  end(directory_iterator) noexcept\n+  { return directory_iterator(); }\n+\n+  inline bool\n+  operator==(const directory_iterator& __lhs, const directory_iterator& __rhs)\n+  {\n+    return !__rhs._M_dir.owner_before(__lhs._M_dir)\n+      && !__lhs._M_dir.owner_before(__rhs._M_dir);\n+  }\n+\n+  inline bool\n+  operator!=(const directory_iterator& __lhs, const directory_iterator& __rhs)\n+  { return !(__lhs == __rhs); }\n+\n+  class recursive_directory_iterator\n+  {\n+  public:\n+    typedef directory_entry        value_type;\n+    typedef ptrdiff_t              difference_type;\n+    typedef const directory_entry* pointer;\n+    typedef const directory_entry& reference;\n+    typedef input_iterator_tag     iterator_category;\n+\n+    recursive_directory_iterator() = default;\n+\n+    explicit\n+    recursive_directory_iterator(const path& __p)\n+    : recursive_directory_iterator(__p, directory_options::none, nullptr) { }\n+\n+    recursive_directory_iterator(const path& __p, directory_options __options)\n+    : recursive_directory_iterator(__p, __options, nullptr) { }\n+\n+    recursive_directory_iterator(const path& __p,\n+                                 directory_options __options,\n+                                 error_code& __ec) noexcept\n+    : recursive_directory_iterator(__p, __options, &__ec) { }\n+\n+    recursive_directory_iterator(const path& __p, error_code& __ec) noexcept\n+    : recursive_directory_iterator(__p, directory_options::none, &__ec) { }\n+\n+    recursive_directory_iterator(\n+        const recursive_directory_iterator&) = default;\n+\n+    recursive_directory_iterator(recursive_directory_iterator&&) = default;\n+\n+    ~recursive_directory_iterator();\n+\n+    // observers\n+    directory_options  options() const { return _M_options; }\n+    int                depth() const;\n+    bool               recursion_pending() const { return _M_pending; }\n+\n+    const directory_entry& operator*() const;\n+    const directory_entry* operator->() const { return &**this; }\n+\n+    // modifiers\n+    recursive_directory_iterator&\n+    operator=(const recursive_directory_iterator& __rhs) noexcept;\n+    recursive_directory_iterator&\n+    operator=(recursive_directory_iterator&& __rhs) noexcept;\n+\n+    recursive_directory_iterator& operator++();\n+    recursive_directory_iterator& increment(error_code& __ec) noexcept;\n+\n+    __directory_iterator_proxy operator++(int)\n+    {\n+      __directory_iterator_proxy __pr{**this};\n+      ++*this;\n+      return __pr;\n+    }\n+\n+    void pop();\n+    void pop(error_code&);\n+\n+    void disable_recursion_pending() { _M_pending = false; }\n+\n+  private:\n+    recursive_directory_iterator(const path&, directory_options, error_code*);\n+\n+    friend bool\n+    operator==(const recursive_directory_iterator& __lhs,\n+               const recursive_directory_iterator& __rhs);\n+\n+    struct _Dir_stack;\n+    std::shared_ptr<_Dir_stack> _M_dirs;\n+    directory_options _M_options = {};\n+    bool _M_pending = false;\n+  };\n+\n+  inline recursive_directory_iterator\n+  begin(recursive_directory_iterator __iter) noexcept\n+  { return __iter; }\n+\n+  inline recursive_directory_iterator\n+  end(recursive_directory_iterator) noexcept\n+  { return recursive_directory_iterator(); }\n+\n+  inline bool\n+  operator==(const recursive_directory_iterator& __lhs,\n+             const recursive_directory_iterator& __rhs)\n+  {\n+    return !__rhs._M_dirs.owner_before(__lhs._M_dirs)\n+      && !__lhs._M_dirs.owner_before(__rhs._M_dirs);\n+  }\n+\n+  inline bool\n+  operator!=(const recursive_directory_iterator& __lhs,\n+             const recursive_directory_iterator& __rhs)\n+  { return !(__lhs == __rhs); }\n+\n+_GLIBCXX_END_NAMESPACE_CXX11\n+\n+  // @} group filesystem\n+} // namespace filesystem\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_FS_DIR_H"}, {"sha": "f408a39b9749e71a27e4eeff12f725be340f14d0", "filename": "libstdc++-v3/include/bits/fs_fwd.h", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,348 @@\n+// Filesystem declarations -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/fs_fwd.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_FS_FWD_H\n+#define _GLIBCXX_FS_FWD_H 1\n+\n+#if __cplusplus >= 201703L\n+\n+#include <system_error>\n+#include <cstdint>\n+#include <chrono>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace filesystem\n+{\n+#if _GLIBCXX_USE_CXX11_ABI\n+inline namespace __cxx11 __attribute__((__abi_tag__ (\"cxx11\"))) { }\n+#endif\n+\n+  /**\n+   * @defgroup filesystem Filesystem\n+   *\n+   * Utilities for performing operations on file systems and their components,\n+   * such as paths, regular files, and directories.\n+   *\n+   * @{\n+   */\n+\n+  class file_status;\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+  class path;\n+  class filesystem_error;\n+  class directory_entry;\n+  class directory_iterator;\n+  class recursive_directory_iterator;\n+_GLIBCXX_END_NAMESPACE_CXX11\n+\n+  struct space_info\n+  {\n+    uintmax_t capacity;\n+    uintmax_t free;\n+    uintmax_t available;\n+  };\n+\n+  enum class file_type : signed char {\n+      none = 0, not_found = -1, regular = 1, directory = 2, symlink = 3,\n+      block = 4, character = 5, fifo = 6, socket = 7, unknown = 8\n+  };\n+\n+  /// Bitmask type\n+  enum class copy_options : unsigned short {\n+      none = 0,\n+      skip_existing = 1, overwrite_existing = 2, update_existing = 4,\n+      recursive = 8,\n+      copy_symlinks = 16, skip_symlinks = 32,\n+      directories_only = 64, create_symlinks = 128, create_hard_links = 256\n+  };\n+\n+  constexpr copy_options\n+  operator&(copy_options __x, copy_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator|(copy_options __x, copy_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator^(copy_options __x, copy_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator~(copy_options __x) noexcept\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline copy_options&\n+  operator&=(copy_options& __x, copy_options __y) noexcept\n+  { return __x = __x & __y; }\n+\n+  inline copy_options&\n+  operator|=(copy_options& __x, copy_options __y) noexcept\n+  { return __x = __x | __y; }\n+\n+  inline copy_options&\n+  operator^=(copy_options& __x, copy_options __y) noexcept\n+  { return __x = __x ^ __y; }\n+\n+\n+  /// Bitmask type\n+  enum class perms : unsigned {\n+      none\t\t=  0,\n+      owner_read\t=  0400,\n+      owner_write\t=  0200,\n+      owner_exec\t=  0100,\n+      owner_all\t\t=  0700,\n+      group_read\t=   040,\n+      group_write\t=   020,\n+      group_exec\t=   010,\n+      group_all\t\t=   070,\n+      others_read\t=    04,\n+      others_write\t=    02,\n+      others_exec\t=    01,\n+      others_all\t=    07,\n+      all\t\t=  0777,\n+      set_uid\t\t= 04000,\n+      set_gid\t\t= 02000,\n+      sticky_bit\t= 01000,\n+      mask\t\t= 07777,\n+      unknown\t\t=  0xFFFF,\n+  };\n+\n+  constexpr perms\n+  operator&(perms __x, perms __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator|(perms __x, perms __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator^(perms __x, perms __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator~(perms __x) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline perms&\n+  operator&=(perms& __x, perms __y) noexcept\n+  { return __x = __x & __y; }\n+\n+  inline perms&\n+  operator|=(perms& __x, perms __y) noexcept\n+  { return __x = __x | __y; }\n+\n+  inline perms&\n+  operator^=(perms& __x, perms __y) noexcept\n+  { return __x = __x ^ __y; }\n+\n+  /// Bitmask type\n+  enum class perm_options : unsigned {\n+      replace\t= 0x1,\n+      add\t= 0x2,\n+      remove\t= 0x4,\n+      nofollow\t= 0x8\n+  };\n+\n+  constexpr perm_options\n+  operator&(perm_options __x, perm_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perm_options>::type;\n+    return static_cast<perm_options>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perm_options\n+  operator|(perm_options __x, perm_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perm_options>::type;\n+    return static_cast<perm_options>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perm_options\n+  operator^(perm_options __x, perm_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perm_options>::type;\n+    return static_cast<perm_options>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perm_options\n+  operator~(perm_options __x) noexcept\n+  {\n+    using __utype = typename std::underlying_type<perm_options>::type;\n+    return static_cast<perm_options>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline perm_options&\n+  operator&=(perm_options& __x, perm_options __y) noexcept\n+  { return __x = __x & __y; }\n+\n+  inline perm_options&\n+  operator|=(perm_options& __x, perm_options __y) noexcept\n+  { return __x = __x | __y; }\n+\n+  inline perm_options&\n+  operator^=(perm_options& __x, perm_options __y) noexcept\n+  { return __x = __x ^ __y; }\n+\n+  // Bitmask type\n+  enum class directory_options : unsigned char {\n+      none = 0, follow_directory_symlink = 1, skip_permission_denied = 2\n+  };\n+\n+  constexpr directory_options\n+  operator&(directory_options __x, directory_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator|(directory_options __x, directory_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator^(directory_options __x, directory_options __y) noexcept\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator~(directory_options __x) noexcept\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline directory_options&\n+  operator&=(directory_options& __x, directory_options __y) noexcept\n+  { return __x = __x & __y; }\n+\n+  inline directory_options&\n+  operator|=(directory_options& __x, directory_options __y) noexcept\n+  { return __x = __x | __y; }\n+\n+  inline directory_options&\n+  operator^=(directory_options& __x, directory_options __y) noexcept\n+  { return __x = __x ^ __y; }\n+\n+  using file_time_type = std::chrono::system_clock::time_point;\n+\n+  // operational functions\n+\n+  void copy(const path& __from, const path& __to, copy_options __options);\n+  void copy(const path& __from, const path& __to, copy_options __options,\n+\t    error_code&) noexcept;\n+\n+  bool copy_file(const path& __from, const path& __to, copy_options __option);\n+  bool copy_file(const path& __from, const path& __to, copy_options __option,\n+\t\t error_code&) noexcept;\n+\n+  path current_path();\n+\n+  bool exists(file_status) noexcept;\n+\n+  bool is_other(file_status) noexcept;\n+\n+  uintmax_t file_size(const path&);\n+  uintmax_t file_size(const path&, error_code&) noexcept;\n+  uintmax_t hard_link_count(const path&);\n+  uintmax_t hard_link_count(const path&, error_code&) noexcept;\n+  file_time_type last_write_time(const path&);\n+  file_time_type last_write_time(const path&, error_code&) noexcept;\n+\n+  void permissions(const path&, perms, perm_options, error_code&);\n+\n+  path proximate(const path& __p, const path& __base, error_code& __ec);\n+  path proximate(const path& __p, const path& __base, error_code& __ec);\n+\n+  path relative(const path& __p, const path& __base, error_code& __ec);\n+\n+  file_status status(const path&);\n+  file_status status(const path&, error_code&) noexcept;\n+\n+  bool status_known(file_status) noexcept;\n+\n+  file_status symlink_status(const path&);\n+  file_status symlink_status(const path&, error_code&) noexcept;\n+\n+  bool is_regular_file(file_status) noexcept;\n+  bool is_symlink(file_status) noexcept;\n+\n+  // @} group filesystem\n+} // namespace filesystem\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_FS_FWD_H"}, {"sha": "563d63de81a42243448ba3bc2fde7e5f53337bf1", "filename": "libstdc++-v3/include/bits/fs_ops.h", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_ops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_ops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_ops.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,311 @@\n+// Filesystem operational functions -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your __option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/fs_fwd.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_FS_OPS_H\n+#define _GLIBCXX_FS_OPS_H 1\n+\n+#if __cplusplus >= 201703L\n+\n+#include <cstdint>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace filesystem\n+{\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  path absolute(const path& __p);\n+  path absolute(const path& __p, error_code& __ec);\n+\n+  path canonical(const path& __p);\n+  path canonical(const path& __p, error_code& __ec);\n+\n+  inline void\n+  copy(const path& __from, const path& __to)\n+  { copy(__from, __to, copy_options::none); }\n+\n+  inline void\n+  copy(const path& __from, const path& __to, error_code& __ec) noexcept\n+  { copy(__from, __to, copy_options::none, __ec); }\n+\n+  void copy(const path& __from, const path& __to, copy_options __options);\n+  void copy(const path& __from, const path& __to, copy_options __options,\n+\t    error_code& __ec) noexcept;\n+\n+  inline bool\n+  copy_file(const path& __from, const path& __to)\n+  { return copy_file(__from, __to, copy_options::none); }\n+\n+  inline bool\n+  copy_file(const path& __from, const path& __to, error_code& __ec) noexcept\n+  { return copy_file(__from, __to, copy_options::none, __ec); }\n+\n+  bool copy_file(const path& __from, const path& __to, copy_options __option);\n+  bool copy_file(const path& __from, const path& __to, copy_options __option,\n+\t\t error_code& __ec) noexcept;\n+\n+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink);\n+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink,\n+\t\t    error_code& __ec) noexcept;\n+\n+  bool create_directories(const path& __p);\n+  bool create_directories(const path& __p, error_code& __ec) noexcept;\n+\n+  bool create_directory(const path& __p);\n+  bool create_directory(const path& __p, error_code& __ec) noexcept;\n+\n+  bool create_directory(const path& __p, const path& attributes);\n+  bool create_directory(const path& __p, const path& attributes,\n+\t\t\terror_code& __ec) noexcept;\n+\n+  void create_directory_symlink(const path& __to, const path& __new_symlink);\n+  void create_directory_symlink(const path& __to, const path& __new_symlink,\n+\t\t\t\terror_code& __ec) noexcept;\n+\n+  void create_hard_link(const path& __to, const path& __new_hard_link);\n+  void create_hard_link(const path& __to, const path& __new_hard_link,\n+\t\t\terror_code& __ec) noexcept;\n+\n+  void create_symlink(const path& __to, const path& __new_symlink);\n+  void create_symlink(const path& __to, const path& __new_symlink,\n+\t\t      error_code& __ec) noexcept;\n+\n+  path current_path();\n+  path current_path(error_code& __ec);\n+  void current_path(const path& __p);\n+  void current_path(const path& __p, error_code& __ec) noexcept;\n+\n+  bool\n+  equivalent(const path& __p1, const path& __p2);\n+\n+  bool\n+  equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept;\n+\n+  inline bool\n+  exists(file_status __s) noexcept\n+  { return status_known(__s) && __s.type() != file_type::not_found; }\n+\n+  inline bool\n+  exists(const path& __p)\n+  { return exists(status(__p)); }\n+\n+  inline bool\n+  exists(const path& __p, error_code& __ec) noexcept\n+  {\n+    auto __s = status(__p, __ec);\n+    if (status_known(__s))\n+      __ec.clear();\n+    return exists(__s);\n+  }\n+\n+  uintmax_t file_size(const path& __p);\n+  uintmax_t file_size(const path& __p, error_code& __ec) noexcept;\n+\n+  uintmax_t hard_link_count(const path& __p);\n+  uintmax_t hard_link_count(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool\n+  is_block_file(file_status __s) noexcept\n+  { return __s.type() == file_type::block; }\n+\n+  inline bool\n+  is_block_file(const path& __p)\n+  { return is_block_file(status(__p)); }\n+\n+  inline bool\n+  is_block_file(const path& __p, error_code& __ec) noexcept\n+  { return is_block_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_character_file(file_status __s) noexcept\n+  { return __s.type() == file_type::character; }\n+\n+  inline bool\n+  is_character_file(const path& __p)\n+  { return is_character_file(status(__p)); }\n+\n+  inline bool\n+  is_character_file(const path& __p, error_code& __ec) noexcept\n+  { return is_character_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_directory(file_status __s) noexcept\n+  { return __s.type() == file_type::directory; }\n+\n+  inline bool\n+  is_directory(const path& __p)\n+  { return is_directory(status(__p)); }\n+\n+  inline bool\n+  is_directory(const path& __p, error_code& __ec) noexcept\n+  { return is_directory(status(__p, __ec)); }\n+\n+  bool is_empty(const path& __p);\n+  bool is_empty(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool\n+  is_fifo(file_status __s) noexcept\n+  { return __s.type() == file_type::fifo; }\n+\n+  inline bool\n+  is_fifo(const path& __p)\n+  { return is_fifo(status(__p)); }\n+\n+  inline bool\n+  is_fifo(const path& __p, error_code& __ec) noexcept\n+  { return is_fifo(status(__p, __ec)); }\n+\n+  inline bool\n+  is_other(file_status __s) noexcept\n+  {\n+    return exists(__s) && !is_regular_file(__s) && !is_directory(__s)\n+      && !is_symlink(__s);\n+  }\n+\n+  inline bool\n+  is_other(const path& __p)\n+  { return is_other(status(__p)); }\n+\n+  inline bool\n+  is_other(const path& __p, error_code& __ec) noexcept\n+  { return is_other(status(__p, __ec)); }\n+\n+  inline bool\n+  is_regular_file(file_status __s) noexcept\n+  { return __s.type() == file_type::regular; }\n+\n+  inline bool\n+  is_regular_file(const path& __p)\n+  { return is_regular_file(status(__p)); }\n+\n+  inline bool\n+  is_regular_file(const path& __p, error_code& __ec) noexcept\n+  { return is_regular_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_socket(file_status __s) noexcept\n+  { return __s.type() == file_type::socket; }\n+\n+  inline bool\n+  is_socket(const path& __p)\n+  { return is_socket(status(__p)); }\n+\n+  inline bool\n+  is_socket(const path& __p, error_code& __ec) noexcept\n+  { return is_socket(status(__p, __ec)); }\n+\n+  inline bool\n+  is_symlink(file_status __s) noexcept\n+  { return __s.type() == file_type::symlink; }\n+\n+  inline bool\n+  is_symlink(const path& __p)\n+  { return is_symlink(symlink_status(__p)); }\n+\n+  inline bool\n+  is_symlink(const path& __p, error_code& __ec) noexcept\n+  { return is_symlink(symlink_status(__p, __ec)); }\n+\n+  file_time_type  last_write_time(const path& __p);\n+  file_time_type  last_write_time(const path& __p, error_code& __ec) noexcept;\n+  void last_write_time(const path& __p, file_time_type __new_time);\n+  void last_write_time(const path& __p, file_time_type __new_time,\n+\t\t       error_code& __ec) noexcept;\n+\n+  void\n+  permissions(const path& __p, perms __prms,\n+\t      perm_options __opts = perm_options::replace);\n+\n+  inline void\n+  permissions(const path& __p, perms __prms, error_code& __ec) noexcept\n+  { permissions(__p, __prms, perm_options::replace, __ec); }\n+\n+  void\n+  permissions(const path& __p, perms __prms, perm_options __opts,\n+\t      error_code& __ec);\n+\n+  inline path proximate(const path& __p, error_code& __ec)\n+  { return proximate(__p, current_path(), __ec); }\n+\n+  path proximate(const path& __p, const path& __base = current_path());\n+  path proximate(const path& __p, const path& __base, error_code& __ec);\n+\n+  path read_symlink(const path& __p);\n+  path read_symlink(const path& __p, error_code& __ec);\n+\n+  inline path relative(const path& __p, error_code& __ec)\n+  { return relative(__p, current_path(), __ec); }\n+\n+  path relative(const path& __p, const path& __base = current_path());\n+  path relative(const path& __p, const path& __base, error_code& __ec);\n+\n+  bool remove(const path& __p);\n+  bool remove(const path& __p, error_code& __ec) noexcept;\n+\n+  uintmax_t remove_all(const path& __p);\n+  uintmax_t remove_all(const path& __p, error_code& __ec) noexcept;\n+\n+  void rename(const path& __from, const path& __to);\n+  void rename(const path& __from, const path& __to, error_code& __ec) noexcept;\n+\n+  void resize_file(const path& __p, uintmax_t __size);\n+  void resize_file(const path& __p, uintmax_t __size, error_code& __ec) noexcept;\n+\n+  space_info space(const path& __p);\n+  space_info space(const path& __p, error_code& __ec) noexcept;\n+\n+  file_status status(const path& __p);\n+  file_status status(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool status_known(file_status __s) noexcept\n+  { return __s.type() != file_type::none; }\n+\n+  file_status symlink_status(const path& __p);\n+  file_status symlink_status(const path& __p, error_code& __ec) noexcept;\n+\n+  path temp_directory_path();\n+  path temp_directory_path(error_code& __ec);\n+\n+  path weakly_canonical(const path& __p);\n+  path weakly_canonical(const path& __p, error_code& __ec);\n+\n+  // @} group filesystem\n+} // namespace filesystem\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_FS_OPS_H"}, {"sha": "6ba2bd2d43ae428177e8d7cbbae70d110920a89a", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "added", "additions": 1163, "deletions": 0, "changes": 1163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,1163 @@\n+// Class filesystem::path -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/fs_path.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_FS_PATH_H\n+#define _GLIBCXX_FS_PATH_H 1\n+\n+#if __cplusplus >= 201703L\n+\n+#include <utility>\n+#include <type_traits>\n+#include <vector>\n+#include <locale>\n+#include <iosfwd>\n+#include <codecvt>\n+#include <string_view>\n+#include <system_error>\n+#include <bits/stl_algobase.h>\n+#include <bits/quoted_string.h>\n+#include <bits/locale_conv.h>\n+\n+#if defined(_WIN32) && !defined(__CYGWIN__)\n+# define _GLIBCXX_FILESYSTEM_IS_WINDOWS 1\n+# include <algorithm>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace filesystem\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  /// A filesystem path.\n+  class path\n+  {\n+    template<typename _CharT>\n+      struct __is_encoded_char : std::false_type { };\n+\n+    template<typename _Iter,\n+\t     typename _Iter_traits = std::iterator_traits<_Iter>>\n+      using __is_path_iter_src\n+\t= __and_<__is_encoded_char<typename _Iter_traits::value_type>,\n+\t\t std::is_base_of<std::input_iterator_tag,\n+\t\t\t\t typename _Iter_traits::iterator_category>>;\n+\n+    template<typename _Iter>\n+      static __is_path_iter_src<_Iter>\n+      __is_path_src(_Iter, int);\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static __is_encoded_char<_CharT>\n+      __is_path_src(const basic_string<_CharT, _Traits, _Alloc>&, int);\n+\n+    template<typename _CharT, typename _Traits>\n+      static __is_encoded_char<_CharT>\n+      __is_path_src(const basic_string_view<_CharT, _Traits>&, int);\n+\n+    template<typename _Unknown>\n+      static std::false_type\n+      __is_path_src(const _Unknown&, ...);\n+\n+    template<typename _Tp1, typename _Tp2>\n+      struct __constructible_from;\n+\n+    template<typename _Iter>\n+      struct __constructible_from<_Iter, _Iter>\n+      : __is_path_iter_src<_Iter>\n+      { };\n+\n+    template<typename _Source>\n+      struct __constructible_from<_Source, void>\n+      : decltype(__is_path_src(std::declval<_Source>(), 0))\n+      { };\n+\n+    template<typename _Tp1, typename _Tp2 = void>\n+      using _Path = typename\n+\tstd::enable_if<__and_<__not_<is_same<_Tp1, path>>,\n+\t\t\t      __constructible_from<_Tp1, _Tp2>>::value,\n+\t\t       path>::type;\n+\n+    template<typename _Source>\n+      static _Source\n+      _S_range_begin(_Source __begin) { return __begin; }\n+\n+    struct __null_terminated { };\n+\n+    template<typename _Source>\n+      static __null_terminated\n+      _S_range_end(_Source) { return {}; }\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static const _CharT*\n+      _S_range_begin(const basic_string<_CharT, _Traits, _Alloc>& __str)\n+      { return __str.data(); }\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static const _CharT*\n+      _S_range_end(const basic_string<_CharT, _Traits, _Alloc>& __str)\n+      { return __str.data() + __str.size(); }\n+\n+    template<typename _CharT, typename _Traits>\n+      static const _CharT*\n+      _S_range_begin(const basic_string_view<_CharT, _Traits>& __str)\n+      { return __str.data(); }\n+\n+    template<typename _CharT, typename _Traits>\n+      static const _CharT*\n+      _S_range_end(const basic_string_view<_CharT, _Traits>& __str)\n+      { return __str.data() + __str.size(); }\n+\n+    template<typename _Tp,\n+\t     typename _Iter = decltype(_S_range_begin(std::declval<_Tp>())),\n+\t     typename _Val = typename std::iterator_traits<_Iter>::value_type>\n+      using __value_type_is_char\n+\t= typename std::enable_if<std::is_same<_Val, char>::value>::type;\n+\n+  public:\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    typedef wchar_t\t\t\t\tvalue_type;\n+    static constexpr value_type\t\t\tpreferred_separator = L'\\\\';\n+#else\n+    typedef char\t\t\t\tvalue_type;\n+    static constexpr value_type\t\t\tpreferred_separator = '/';\n+#endif\n+    typedef std::basic_string<value_type>\tstring_type;\n+\n+    // constructors and destructor\n+\n+    path() noexcept { }\n+\n+    path(const path& __p) = default;\n+\n+    path(path&& __p) noexcept\n+    : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)\n+    {\n+      _M_split_cmpts();\n+      __p.clear();\n+    }\n+\n+    path(string_type&& __source)\n+    : _M_pathname(std::move(__source))\n+    { _M_split_cmpts(); }\n+\n+    template<typename _Source,\n+\t     typename _Require = _Path<_Source>>\n+      path(_Source const& __source)\n+      : _M_pathname(_S_convert(_S_range_begin(__source),\n+\t\t\t       _S_range_end(__source)))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _InputIterator,\n+\t     typename _Require = _Path<_InputIterator, _InputIterator>>\n+      path(_InputIterator __first, _InputIterator __last)\n+      : _M_pathname(_S_convert(__first, __last))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _Source,\n+\t     typename _Require = _Path<_Source>,\n+\t     typename _Require2 = __value_type_is_char<_Source>>\n+      path(_Source const& __source, const locale& __loc)\n+      : _M_pathname(_S_convert_loc(_S_range_begin(__source),\n+\t\t\t\t   _S_range_end(__source), __loc))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _InputIterator,\n+\t     typename _Require = _Path<_InputIterator, _InputIterator>,\n+\t     typename _Require2 = __value_type_is_char<_InputIterator>>\n+      path(_InputIterator __first, _InputIterator __last, const locale& __loc)\n+      : _M_pathname(_S_convert_loc(__first, __last, __loc))\n+      { _M_split_cmpts(); }\n+\n+    ~path() = default;\n+\n+    // assignments\n+\n+    path& operator=(const path& __p) = default;\n+    path& operator=(path&& __p) noexcept;\n+    path& operator=(string_type&& __source);\n+    path& assign(string_type&& __source);\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      operator=(_Source const& __source)\n+      { return *this = path(__source); }\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      assign(_Source const& __source)\n+      { return *this = path(__source); }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      assign(_InputIterator __first, _InputIterator __last)\n+      { return *this = path(__first, __last); }\n+\n+    // appends\n+\n+    path& operator/=(const path& __p)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      if (__p.is_absolute()\n+\t  || (__p.has_root_name() && __p.root_name() != root_name()))\n+\toperator=(__p);\n+      else\n+\t{\n+\t  string_type __pathname;\n+\t  if (__p.has_root_directory())\n+\t    __pathname = root_name().native();\n+\t  else if (has_filename() || (!has_root_directory() && is_absolute()))\n+\t    __pathname = _M_pathname + preferred_separator;\n+\t  __pathname += __p.relative_path().native(); // XXX is this right?\n+\t  _M_pathname.swap(__pathname);\n+\t  _M_split_cmpts();\n+\t}\n+#else\n+      // Much simpler, as any path with root-name or root-dir is absolute.\n+      if (__p.is_absolute())\n+\toperator=(__p);\n+      else\n+\t{\n+\t  if (has_filename() || (_M_type == _Type::_Root_name))\n+\t    _M_pathname += preferred_separator;\n+\t  _M_pathname += __p.native();\n+\t  _M_split_cmpts();\n+\t}\n+#endif\n+      return *this;\n+    }\n+\n+    template <class _Source>\n+      _Path<_Source>&\n+      operator/=(_Source const& __source)\n+      { return append(__source); }\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      append(_Source const& __source)\n+      {\n+\treturn _M_append(_S_convert(_S_range_begin(__source),\n+\t\t\t\t    _S_range_end(__source)));\n+      }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      append(_InputIterator __first, _InputIterator __last)\n+      { return _M_append(_S_convert(__first, __last)); }\n+\n+    // concatenation\n+\n+    path& operator+=(const path& __x);\n+    path& operator+=(const string_type& __x);\n+    path& operator+=(const value_type* __x);\n+    path& operator+=(value_type __x);\n+    path& operator+=(basic_string_view<value_type> __x);\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      operator+=(_Source const& __x) { return concat(__x); }\n+\n+    template<typename _CharT>\n+      _Path<_CharT*, _CharT*>&\n+      operator+=(_CharT __x);\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      concat(_Source const& __x)\n+      { return *this += _S_convert(_S_range_begin(__x), _S_range_end(__x)); }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      concat(_InputIterator __first, _InputIterator __last)\n+      { return *this += _S_convert(__first, __last); }\n+\n+    // modifiers\n+\n+    void clear() noexcept { _M_pathname.clear(); _M_split_cmpts(); }\n+\n+    path& make_preferred();\n+    path& remove_filename();\n+    path& replace_filename(const path& __replacement);\n+    path& replace_extension(const path& __replacement = path());\n+\n+    void swap(path& __rhs) noexcept;\n+\n+    // native format observers\n+\n+    const string_type&  native() const noexcept { return _M_pathname; }\n+    const value_type*   c_str() const noexcept { return _M_pathname.c_str(); }\n+    operator string_type() const { return _M_pathname; }\n+\n+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,\n+\t     typename _Allocator = std::allocator<_CharT>>\n+      std::basic_string<_CharT, _Traits, _Allocator>\n+      string(const _Allocator& __a = _Allocator()) const;\n+\n+    std::string    string() const;\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring   wstring() const;\n+#endif\n+    std::string    u8string() const;\n+    std::u16string u16string() const;\n+    std::u32string u32string() const;\n+\n+    // generic format observers\n+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,\n+\t     typename _Allocator = std::allocator<_CharT>>\n+      std::basic_string<_CharT, _Traits, _Allocator>\n+      generic_string(const _Allocator& __a = _Allocator()) const;\n+\n+    std::string    generic_string() const;\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring   generic_wstring() const;\n+#endif\n+    std::string    generic_u8string() const;\n+    std::u16string generic_u16string() const;\n+    std::u32string generic_u32string() const;\n+\n+    // compare\n+\n+    int compare(const path& __p) const noexcept;\n+    int compare(const string_type& __s) const;\n+    int compare(const value_type* __s) const;\n+    int compare(const basic_string_view<value_type> __s) const;\n+\n+    // decomposition\n+\n+    path root_name() const;\n+    path root_directory() const;\n+    path root_path() const;\n+    path relative_path() const;\n+    path parent_path() const;\n+    path filename() const;\n+    path stem() const;\n+    path extension() const;\n+\n+    // query\n+\n+    bool empty() const noexcept { return _M_pathname.empty(); }\n+    bool has_root_name() const;\n+    bool has_root_directory() const;\n+    bool has_root_path() const;\n+    bool has_relative_path() const;\n+    bool has_parent_path() const;\n+    bool has_filename() const;\n+    bool has_stem() const;\n+    bool has_extension() const;\n+    bool is_absolute() const;\n+    bool is_relative() const { return !is_absolute(); }\n+\n+    // generation\n+    path lexically_normal() const;\n+    path lexically_relative(const path& base) const;\n+    path lexically_proximate(const path& base) const;\n+\n+    // iterators\n+    class iterator;\n+    typedef iterator const_iterator;\n+\n+    iterator begin() const;\n+    iterator end() const;\n+\n+  private:\n+    enum class _Type : unsigned char {\n+\t_Multi, _Root_name, _Root_dir, _Filename\n+    };\n+\n+    path(string_type __str, _Type __type) : _M_pathname(__str), _M_type(__type)\n+    {\n+      __glibcxx_assert(_M_type != _Type::_Multi);\n+    }\n+\n+    enum class _Split { _Stem, _Extension };\n+\n+    path& _M_append(string_type&& __str)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      operator/=(path(std::move(__str)));\n+#else\n+      if (!_M_pathname.empty() && !_S_is_dir_sep(_M_pathname.back())\n+\t  && (__str.empty() || !_S_is_dir_sep(__str.front())))\n+\t_M_pathname += preferred_separator;\n+      _M_pathname += __str;\n+      _M_split_cmpts();\n+#endif\n+      return *this;\n+    }\n+\n+    pair<const string_type*, size_t> _M_find_extension() const;\n+\n+    template<typename _CharT>\n+      struct _Cvt;\n+\n+    static string_type\n+    _S_convert(value_type* __src, __null_terminated)\n+    { return string_type(__src); }\n+\n+    static string_type\n+    _S_convert(const value_type* __src, __null_terminated)\n+    { return string_type(__src); }\n+\n+    template<typename _Iter>\n+      static string_type\n+      _S_convert(_Iter __first, _Iter __last)\n+      {\n+\tusing __value_type = typename std::iterator_traits<_Iter>::value_type;\n+\treturn _Cvt<typename remove_cv<__value_type>::type>::\n+\t  _S_convert(__first, __last);\n+      }\n+\n+    template<typename _InputIterator>\n+      static string_type\n+      _S_convert(_InputIterator __src, __null_terminated)\n+      {\n+\tusing _Tp = typename std::iterator_traits<_InputIterator>::value_type;\n+\tstd::basic_string<typename remove_cv<_Tp>::type> __tmp;\n+\tfor (; *__src != _Tp{}; ++__src)\n+\t  __tmp.push_back(*__src);\n+\treturn _S_convert(__tmp.c_str(), __tmp.c_str() + __tmp.size());\n+      }\n+\n+    static string_type\n+    _S_convert_loc(const char* __first, const char* __last,\n+\t\t   const std::locale& __loc);\n+\n+    template<typename _Iter>\n+      static string_type\n+      _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)\n+      {\n+\tconst std::string __str(__first, __last);\n+\treturn _S_convert_loc(__str.data(), __str.data()+__str.size(), __loc);\n+      }\n+\n+    template<typename _InputIterator>\n+      static string_type\n+      _S_convert_loc(_InputIterator __src, __null_terminated,\n+\t\t     const std::locale& __loc)\n+      {\n+\tstd::string __tmp;\n+\twhile (*__src != '\\0')\n+\t  __tmp.push_back(*__src++);\n+\treturn _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);\n+      }\n+\n+    template<typename _CharT, typename _Traits, typename _Allocator>\n+      static basic_string<_CharT, _Traits, _Allocator>\n+      _S_str_convert(const string_type&, const _Allocator& __a);\n+\n+    bool _S_is_dir_sep(value_type __ch)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      return __ch == L'/' || __ch == preferred_separator;\n+#else\n+      return __ch == '/';\n+#endif\n+    }\n+\n+    void _M_split_cmpts();\n+    void _M_trim();\n+    void _M_add_root_name(size_t __n);\n+    void _M_add_root_dir(size_t __pos);\n+    void _M_add_filename(size_t __pos, size_t __n);\n+\n+    string_type _M_pathname;\n+\n+    struct _Cmpt;\n+    using _List = _GLIBCXX_STD_C::vector<_Cmpt>;\n+    _List _M_cmpts; // empty unless _M_type == _Type::_Multi\n+    _Type _M_type = _Type::_Multi;\n+  };\n+\n+  template<>\n+    struct path::__is_encoded_char<char> : std::true_type\n+    { using value_type = char; };\n+\n+  template<>\n+    struct path::__is_encoded_char<wchar_t> : std::true_type\n+    { using value_type = wchar_t; };\n+\n+  template<>\n+    struct path::__is_encoded_char<char16_t> : std::true_type\n+    { using value_type = char16_t; };\n+\n+  template<>\n+    struct path::__is_encoded_char<char32_t> : std::true_type\n+    { using value_type = char32_t; };\n+\n+  template<typename _Tp>\n+    struct path::__is_encoded_char<const _Tp> : __is_encoded_char<_Tp> { };\n+\n+  inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }\n+\n+  size_t hash_value(const path& __p) noexcept;\n+\n+  /// Compare paths\n+  inline bool operator<(const path& __lhs, const path& __rhs) noexcept\n+  { return __lhs.compare(__rhs) < 0; }\n+\n+  /// Compare paths\n+  inline bool operator<=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__rhs < __lhs); }\n+\n+  /// Compare paths\n+  inline bool operator>(const path& __lhs, const path& __rhs) noexcept\n+  { return __rhs < __lhs; }\n+\n+  /// Compare paths\n+  inline bool operator>=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__lhs < __rhs); }\n+\n+  /// Compare paths\n+  inline bool operator==(const path& __lhs, const path& __rhs) noexcept\n+  { return __lhs.compare(__rhs) == 0; }\n+\n+  /// Compare paths\n+  inline bool operator!=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__lhs == __rhs); }\n+\n+  /// Append one path to another\n+  inline path operator/(const path& __lhs, const path& __rhs)\n+  { return path(__lhs) /= __rhs; }\n+\n+  /// Write a path to a stream\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)\n+    {\n+      auto __tmp = __p.string<_CharT, _Traits>();\n+      using __quoted_string\n+\t= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;\n+      __os << __quoted_string{__tmp, '\"', '\\\\'};\n+      return __os;\n+    }\n+\n+  /// Read a path from a stream\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __is, path& __p)\n+    {\n+      basic_string<_CharT, _Traits> __tmp;\n+      using __quoted_string\n+\t= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;\n+      if (__is >> __quoted_string{ __tmp, '\"', '\\\\' })\n+\t__p = std::move(__tmp);\n+      return __is;\n+    }\n+\n+  template<typename _Source>\n+    inline auto\n+    u8path(const _Source& __source)\n+    -> decltype(filesystem::path(__source, std::locale::classic()))\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      const std::string __u8str{__source};\n+      return std::filesystem::u8path(__u8str.begin(), __u8str.end());\n+#else\n+      return path{ __source };\n+#endif\n+    }\n+\n+  template<typename _InputIterator>\n+    inline auto\n+    u8path(_InputIterator __first, _InputIterator __last)\n+    -> decltype(filesystem::path(__first, __last, std::locale::classic()))\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      codecvt_utf8<value_type> __cvt;\n+      string_type __tmp;\n+      if (__str_codecvt_in(__first, __last, __tmp, __cvt))\n+\treturn path{ __tmp };\n+      else\n+\treturn {};\n+#else\n+      return path{ __first, __last };\n+#endif\n+    }\n+\n+  class filesystem_error : public std::system_error\n+  {\n+  public:\n+    filesystem_error(const string& __what_arg, error_code __ec)\n+    : system_error(__ec, __what_arg) { }\n+\n+    filesystem_error(const string& __what_arg, const path& __p1,\n+\t\t     error_code __ec)\n+    : system_error(__ec, __what_arg), _M_path1(__p1) { }\n+\n+    filesystem_error(const string& __what_arg, const path& __p1,\n+\t\t     const path& __p2, error_code __ec)\n+    : system_error(__ec, __what_arg), _M_path1(__p1), _M_path2(__p2)\n+    { }\n+\n+    ~filesystem_error();\n+\n+    const path& path1() const noexcept { return _M_path1; }\n+    const path& path2() const noexcept { return _M_path2; }\n+    const char* what() const noexcept { return _M_what.c_str(); }\n+\n+  private:\n+    std::string _M_gen_what();\n+\n+    path _M_path1;\n+    path _M_path2;\n+    std::string _M_what = _M_gen_what();\n+  };\n+\n+  struct path::_Cmpt : path\n+  {\n+    _Cmpt(string_type __s, _Type __t, size_t __pos)\n+      : path(std::move(__s), __t), _M_pos(__pos) { }\n+\n+    _Cmpt() : _M_pos(-1) { }\n+\n+    size_t _M_pos;\n+  };\n+\n+  // specialize _Cvt for degenerate 'noconv' case\n+  template<>\n+    struct path::_Cvt<path::value_type>\n+    {\n+      template<typename _Iter>\n+\tstatic string_type\n+\t_S_convert(_Iter __first, _Iter __last)\n+\t{ return string_type{__first, __last}; }\n+    };\n+\n+  template<typename _CharT>\n+    struct path::_Cvt\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      static string_type\n+      _S_wconvert(const char* __f, const char* __l, true_type)\n+      {\n+\tusing _Cvt = std::codecvt<wchar_t, char, mbstate_t>;\n+\tconst auto& __cvt = std::use_facet<_Cvt>(std::locale{});\n+\tstd::wstring __wstr;\n+\tif (__str_codecvt_in(__f, __l, __wstr, __cvt))\n+\t    return __wstr;\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+\n+      static string_type\n+      _S_wconvert(const _CharT* __f, const _CharT* __l, false_type)\n+      {\n+\tstd::codecvt_utf8<_CharT> __cvt;\n+\tstd::string __str;\n+\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+\t  {\n+\t    const char* __f2 = __str.data();\n+\t    const char* __l2 = __f2 + __str.size();\n+\t    std::codecvt_utf8<wchar_t> __wcvt;\n+\t    std::wstring __wstr;\n+\t    if (__str_codecvt_in(__f2, __l2, __wstr, __wcvt))\n+\t      return __wstr;\n+\t  }\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+\n+      static string_type\n+      _S_convert(const _CharT* __f, const _CharT* __l)\n+      {\n+\treturn _S_wconvert(__f, __l, is_same<_CharT, char>{});\n+      }\n+#else\n+      static string_type\n+      _S_convert(const _CharT* __f, const _CharT* __l)\n+      {\n+\tstd::codecvt_utf8<_CharT> __cvt;\n+\tstd::string __str;\n+\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+\t  return __str;\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+#endif\n+\n+      static string_type\n+      _S_convert(_CharT* __f, _CharT* __l)\n+      {\n+\treturn _S_convert(const_cast<const _CharT*>(__f),\n+\t\t\t  const_cast<const _CharT*>(__l));\n+      }\n+\n+      template<typename _Iter>\n+\tstatic string_type\n+\t_S_convert(_Iter __first, _Iter __last)\n+\t{\n+\t  const std::basic_string<_CharT> __str(__first, __last);\n+\t  return _S_convert(__str.data(), __str.data() + __str.size());\n+\t}\n+\n+      template<typename _Iter, typename _Cont>\n+\tstatic string_type\n+\t_S_convert(__gnu_cxx::__normal_iterator<_Iter, _Cont> __first,\n+\t\t  __gnu_cxx::__normal_iterator<_Iter, _Cont> __last)\n+\t{ return _S_convert(__first.base(), __last.base()); }\n+    };\n+\n+  /// An iterator for the components of a path\n+  class path::iterator\n+  {\n+  public:\n+    using difference_type\t= std::ptrdiff_t;\n+    using value_type\t\t= path;\n+    using reference\t\t= const path&;\n+    using pointer\t\t= const path*;\n+    using iterator_category\t= std::bidirectional_iterator_tag;\n+\n+    iterator() : _M_path(nullptr), _M_cur(), _M_at_end() { }\n+\n+    iterator(const iterator&) = default;\n+    iterator& operator=(const iterator&) = default;\n+\n+    reference operator*() const;\n+    pointer   operator->() const { return std::__addressof(**this); }\n+\n+    iterator& operator++();\n+    iterator  operator++(int) { auto __tmp = *this; ++*this; return __tmp; }\n+\n+    iterator& operator--();\n+    iterator  operator--(int) { auto __tmp = *this; --*this; return __tmp; }\n+\n+    friend bool operator==(const iterator& __lhs, const iterator& __rhs)\n+    { return __lhs._M_equals(__rhs); }\n+\n+    friend bool operator!=(const iterator& __lhs, const iterator& __rhs)\n+    { return !__lhs._M_equals(__rhs); }\n+\n+  private:\n+    friend class path;\n+\n+    iterator(const path* __path, path::_List::const_iterator __iter)\n+    : _M_path(__path), _M_cur(__iter), _M_at_end()\n+    { }\n+\n+    iterator(const path* __path, bool __at_end)\n+    : _M_path(__path), _M_cur(), _M_at_end(__at_end)\n+    { }\n+\n+    bool _M_equals(iterator) const;\n+\n+    const path* \t\t_M_path;\n+    path::_List::const_iterator _M_cur;\n+    bool\t\t\t_M_at_end;  // only used when type != _Multi\n+  };\n+\n+\n+  inline path&\n+  path::operator=(path&& __p) noexcept\n+  {\n+    _M_pathname = std::move(__p._M_pathname);\n+    _M_cmpts = std::move(__p._M_cmpts);\n+    _M_type = __p._M_type;\n+    __p.clear();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator=(string_type&& __source)\n+  { return *this = path(std::move(__source)); }\n+\n+  inline path&\n+  path::assign(string_type&& __source)\n+  { return *this = path(std::move(__source)); }\n+\n+  inline path&\n+  path::operator+=(const path& __p)\n+  {\n+    return operator+=(__p.native());\n+  }\n+\n+  inline path&\n+  path::operator+=(const string_type& __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(const value_type* __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(value_type __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(basic_string_view<value_type> __x)\n+  {\n+    _M_pathname.append(__x.data(), __x.size());\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  template<typename _CharT>\n+    inline path::_Path<_CharT*, _CharT*>&\n+    path::operator+=(_CharT __x)\n+    {\n+      auto* __addr = std::__addressof(__x);\n+      return concat(__addr, __addr + 1);\n+    }\n+\n+  inline path&\n+  path::make_preferred()\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    std::replace(_M_pathname.begin(), _M_pathname.end(), L'/',\n+\t\t preferred_separator);\n+#endif\n+    return *this;\n+  }\n+\n+  inline void path::swap(path& __rhs) noexcept\n+  {\n+    _M_pathname.swap(__rhs._M_pathname);\n+    _M_cmpts.swap(__rhs._M_cmpts);\n+    std::swap(_M_type, __rhs._M_type);\n+  }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    std::basic_string<_CharT, _Traits, _Allocator>\n+    path::_S_str_convert(const string_type& __str, const _Allocator& __a)\n+    {\n+      if (__str.size() == 0)\n+\treturn std::basic_string<_CharT, _Traits, _Allocator>(__a);\n+\n+      const value_type* __first = __str.data();\n+      const value_type* __last = __first + __str.size();\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      using _CharAlloc = __alloc_rebind<_Allocator, char>;\n+      using _String = basic_string<char, char_traits<char>, _CharAlloc>;\n+      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n+\n+      // use codecvt_utf8<wchar_t> to convert native string to UTF-8\n+      codecvt_utf8<value_type> __cvt;\n+      _String __u8str{_CharAlloc{__a}};\n+      if (__str_codecvt_out(__first, __last, __u8str, __cvt))\n+\t{\n+\t  if constexpr (is_same_v<_CharT, char>)\n+\t    return __u8str;\n+\t  else\n+\t    {\n+\t      _WString __wstr;\n+\t      // use codecvt_utf8<_CharT> to convert UTF-8 to wide string\n+\t      codecvt_utf8<_CharT> __cvt;\n+\t      const char* __f = __u8str.data();\n+\t      const char* __l = __f + __u8str.size();\n+\t      if (__str_codecvt_in(__f, __l, __wstr, __cvt))\n+\t\treturn __wstr;\n+\t    }\n+\t}\n+#else\n+      codecvt_utf8<_CharT> __cvt;\n+      basic_string<_CharT, _Traits, _Allocator> __wstr{__a};\n+      if (__str_codecvt_in(__first, __last, __wstr, __cvt))\n+\treturn __wstr;\n+#endif\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t    \"Cannot convert character sequence\",\n+\t    std::make_error_code(errc::illegal_byte_sequence)));\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT, _Traits, _Allocator>\n+    path::string(const _Allocator& __a) const\n+    {\n+      if constexpr (is_same_v<_CharT, value_type>)\n+#if _GLIBCXX_USE_CXX11_ABI\n+\treturn { _M_pathname, __a };\n+#else\n+\treturn { _M_pathname, string_type::size_type(0), __a };\n+#endif\n+      else\n+\treturn _S_str_convert<_CharT, _Traits>(_M_pathname, __a);\n+    }\n+\n+  inline std::string\n+  path::string() const { return string<char>(); }\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+  inline std::wstring\n+  path::wstring() const { return string<wchar_t>(); }\n+#endif\n+\n+  inline std::string\n+  path::u8string() const\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    std::string __str;\n+    // convert from native encoding to UTF-8\n+    codecvt_utf8<value_type> __cvt;\n+    const value_type* __first = _M_pathname.data();\n+    const value_type* __last = __first + _M_pathname.size();\n+    if (__str_codecvt_out(__first, __last, __str, __cvt))\n+      return __str;\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"Cannot convert character sequence\",\n+\t  std::make_error_code(errc::illegal_byte_sequence)));\n+#else\n+    return _M_pathname;\n+#endif\n+  }\n+\n+  inline std::u16string\n+  path::u16string() const { return string<char16_t>(); }\n+\n+  inline std::u32string\n+  path::u32string() const { return string<char32_t>(); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline std::basic_string<_CharT, _Traits, _Allocator>\n+    path::generic_string(const _Allocator& __a) const\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      const value_type __slash = L'/';\n+#else\n+      const value_type __slash = '/';\n+#endif\n+      string_type __str(__a);\n+\n+      if (_M_type == _Type::_Root_dir)\n+\t__str.assign(1, __slash);\n+      else\n+\t{\n+\t  __str.reserve(_M_pathname.size());\n+\t  bool __add_slash = false;\n+\t  for (auto& __elem : *this)\n+\t    {\n+\t      if (__add_slash)\n+\t\t__str += __slash;\n+\t      __str += __elem._M_pathname;\n+\t      __add_slash = __elem._M_type == _Type::_Filename;\n+\t    }\n+\t}\n+\n+      if constexpr (is_same_v<_CharT, value_type>)\n+\treturn __str;\n+      else\n+\treturn _S_str_convert<_CharT, _Traits>(__str, __a);\n+    }\n+\n+  inline std::string\n+  path::generic_string() const\n+  { return generic_string<char>(); }\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+  inline std::wstring\n+  path::generic_wstring() const\n+  { return generic_string<wchar_t>(); }\n+#endif\n+\n+  inline std::string\n+  path::generic_u8string() const\n+  { return generic_string(); }\n+\n+  inline std::u16string\n+  path::generic_u16string() const\n+  { return generic_string<char16_t>(); }\n+\n+  inline std::u32string\n+  path::generic_u32string() const\n+  { return generic_string<char32_t>(); }\n+\n+  inline int\n+  path::compare(const string_type& __s) const { return compare(path(__s)); }\n+\n+  inline int\n+  path::compare(const value_type* __s) const { return compare(path(__s)); }\n+\n+  inline int\n+  path::compare(basic_string_view<value_type> __s) const\n+  { return compare(path(__s)); }\n+\n+  inline path\n+  path::filename() const\n+  {\n+    if (empty())\n+      return {};\n+    else if (_M_type == _Type::_Filename)\n+      return *this;\n+    else if (_M_type == _Type::_Multi)\n+      {\n+\tif (_M_pathname.back() == preferred_separator)\n+\t  return {};\n+\tauto& __last = *--end();\n+\tif (__last._M_type == _Type::_Filename)\n+\t  return __last;\n+      }\n+    return {};\n+  }\n+\n+  inline path\n+  path::stem() const\n+  {\n+    auto ext = _M_find_extension();\n+    if (ext.first && ext.second != 0)\n+      return path{ext.first->substr(0, ext.second)};\n+    return {};\n+  }\n+\n+  inline path\n+  path::extension() const\n+  {\n+    auto ext = _M_find_extension();\n+    if (ext.first && ext.second != string_type::npos)\n+      return path{ext.first->substr(ext.second)};\n+    return {};\n+  }\n+\n+  inline bool\n+  path::has_stem() const\n+  {\n+    auto ext = _M_find_extension();\n+    return ext.first && ext.second != 0;\n+  }\n+\n+  inline bool\n+  path::has_extension() const\n+  {\n+    auto ext = _M_find_extension();\n+    return ext.first && ext.second != string_type::npos;\n+  }\n+\n+  inline bool\n+  path::is_absolute() const\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    return has_root_name();\n+#else\n+    return has_root_directory();\n+#endif\n+  }\n+\n+  inline path::iterator\n+  path::begin() const\n+  {\n+    if (_M_type == _Type::_Multi)\n+      return iterator(this, _M_cmpts.begin());\n+    return iterator(this, false);\n+  }\n+\n+  inline path::iterator\n+  path::end() const\n+  {\n+    if (_M_type == _Type::_Multi)\n+      return iterator(this, _M_cmpts.end());\n+    return iterator(this, true);\n+  }\n+\n+  inline path::iterator&\n+  path::iterator::operator++()\n+  {\n+    __glibcxx_assert(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.end());\n+\t++_M_cur;\n+      }\n+    else\n+      {\n+\t__glibcxx_assert(!_M_at_end);\n+\t_M_at_end = true;\n+      }\n+    return *this;\n+  }\n+\n+  inline path::iterator&\n+  path::iterator::operator--()\n+  {\n+    __glibcxx_assert(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.begin());\n+\t--_M_cur;\n+      }\n+    else\n+      {\n+\t__glibcxx_assert(_M_at_end);\n+\t_M_at_end = false;\n+      }\n+    return *this;\n+  }\n+\n+  inline path::iterator::reference\n+  path::iterator::operator*() const\n+  {\n+    __glibcxx_assert(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.end());\n+\treturn *_M_cur;\n+      }\n+    return *_M_path;\n+  }\n+\n+  inline bool\n+  path::iterator::_M_equals(iterator __rhs) const\n+  {\n+    if (_M_path != __rhs._M_path)\n+      return false;\n+    if (_M_path == nullptr)\n+      return true;\n+    if (_M_path->_M_type == path::_Type::_Multi)\n+      return _M_cur == __rhs._M_cur;\n+    return _M_at_end == __rhs._M_at_end;\n+  }\n+\n+  // @} group filesystem\n+_GLIBCXX_END_NAMESPACE_CXX11\n+} // namespace filesystem\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_FS_PATH_H"}, {"sha": "ecadf37a9cd57b032987bfcbb2c6791644caf2df", "filename": "libstdc++-v3/include/experimental/bits/fs_dir.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_dir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_dir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_dir.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -49,7 +49,7 @@ namespace filesystem\n inline namespace v1\n {\n   /**\n-   * @ingroup filesystem\n+   * @ingroup filesystem-ts\n    * @{\n    */\n \n@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n _GLIBCXX_END_NAMESPACE_CXX11\n \n-  // @} group filesystem\n+  // @} group filesystem-ts\n } // namespace v1\n } // namespace filesystem\n } // namespace experimental"}, {"sha": "ac43c5f44f5440cea9bb787438966a26acc5f51d", "filename": "libstdc++-v3/include/experimental/bits/fs_fwd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -53,7 +53,7 @@ inline namespace __cxx11 __attribute__((__abi_tag__ (\"cxx11\"))) { }\n #endif\n \n   /**\n-   * @defgroup filesystem Filesystem\n+   * @defgroup filesystem-ts Filesystem TS\n    * @ingroup experimental\n    *\n    * Utilities for performing operations on file systems and their components,\n@@ -278,7 +278,7 @@ _GLIBCXX_END_NAMESPACE_CXX11\n   bool is_regular_file(file_status) noexcept;\n   bool is_symlink(file_status) noexcept;\n \n-  // @} group filesystem\n+  // @} group filesystem-ts\n } // namespace v1\n } // namespace filesystem\n } // namespace experimental"}, {"sha": "fa7f1de6bc4d50d9f418676a2eb5b1b25c506dd4", "filename": "libstdc++-v3/include/experimental/bits/fs_ops.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_ops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_ops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_ops.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -47,7 +47,7 @@ namespace filesystem\n inline namespace v1\n {\n   /**\n-   * @ingroup filesystem\n+   * @ingroup filesystem-ts\n    * @{\n    */\n \n@@ -285,7 +285,7 @@ inline namespace v1\n   path temp_directory_path();\n   path temp_directory_path(error_code& __ec);\n \n-  // @} group filesystem\n+  // @} group filesystem-ts\n } // namespace v1\n } // namespace filesystem\n } // namespace experimental"}, {"sha": "3e9bc6357aff8e64dcda9c38bc11a668a07cac70", "filename": "libstdc++-v3/include/experimental/bits/fs_path.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -72,7 +72,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #endif\n \n   /**\n-   * @ingroup filesystem\n+   * @ingroup filesystem-ts\n    * @{\n    */\n \n@@ -1079,7 +1079,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     return _M_at_end == __rhs._M_at_end;\n   }\n \n-  // @} group filesystem\n+  // @} group filesystem-ts\n _GLIBCXX_END_NAMESPACE_CXX11\n } // namespace v1\n } // namespace filesystem"}, {"sha": "90f6f9eabfe5ede46017d815aef92e57ec7d354b", "filename": "libstdc++-v3/include/experimental/filesystem", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -40,36 +40,6 @@\n \n #define __cpp_lib_experimental_filesystem 201406\n \n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-namespace experimental\n-{\n-namespace filesystem\n-{\n-inline namespace v1\n-{\n-  /**\n-   * @ingroup filesystem\n-   */\n-    inline std::string filesystem_error::_M_gen_what()\n-    {\n-      std::string __what = \"filesystem error: \";\n-      __what += system_error::what();\n-      if (!_M_path1.empty())\n-\t  __what += \" [\" + _M_path1.string() + ']';\n-      if (!_M_path2.empty())\n-\t  __what += \" [\" + _M_path2.string() + ']';\n-      return __what;\n-    }\n-} // namespace v1\n-} // namespace filesystem\n-} // namespace experimental\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace std\n-\n #endif // C++11\n \n #endif // _GLIBCXX_EXPERIMENTAL_FILESYSTEM"}, {"sha": "4e1a71afeb0890eb23e930fab89ab8dec5e64e9b", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -122,6 +122,7 @@\n #include <shared_mutex>\n #endif\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n #include <charconv>\n+#include <filesystem>\n #endif"}, {"sha": "b09997704c1bb9bb3544dc1bdd073cb7fe5b314e", "filename": "libstdc++-v3/include/std/filesystem", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffilesystem", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffilesystem", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffilesystem?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,45 @@\n+// <filesystem> -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file filesystem\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_FILESYSTEM\n+#define _GLIBCXX_FILESYSTEM 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201703L\n+\n+#include <bits/fs_fwd.h>\n+#include <bits/fs_path.h>\n+#include <bits/fs_dir.h>\n+#include <bits/fs_ops.h>\n+\n+#define __cpp_lib_filesystem 201703\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_FILESYSTEM"}, {"sha": "9d2119632baac89fb60396fd76c439d1f33b1612", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1592,6 +1592,10 @@ def build_libstdcxx_dictionary ():\n                                   'path', StdExpPathPrinter)\n     libstdcxx_printer.add_version('std::experimental::filesystem::v1::__cxx11::',\n                                   'path', StdExpPathPrinter)\n+    libstdcxx_printer.add_version('std::filesystem::',\n+                                  'path', StdExpPathPrinter)\n+    libstdcxx_printer.add_version('std::filesystem::__cxx11::',\n+                                  'path', StdExpPathPrinter)\n \n     # C++17 components\n     libstdcxx_printer.add_version('std::',"}, {"sha": "19de2a324faf9d903a0b3be0ab5af4757596d6d6", "filename": "libstdc++-v3/src/filesystem/Makefile.am", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -30,7 +30,10 @@ if ENABLE_DUAL_ABI\n cxx11_abi_sources = \\\n \tcow-dir.cc \\\n \tcow-ops.cc \\\n-\tcow-path.cc\n+\tcow-path.cc \\\n+\tcow-std-dir.cc \\\n+\tcow-std-ops.cc \\\n+\tcow-std-path.cc\n else\n cxx11_abi_sources =\n endif\n@@ -39,6 +42,9 @@ sources = \\\n \tdir.cc \\\n \tops.cc \\\n \tpath.cc \\\n+\tstd-dir.cc \\\n+\tstd-ops.cc \\\n+\tstd-path.cc \\\n \t${cxx11_abi_sources}\n \n # vpath % $(top_srcdir)/src/filesystem\n@@ -52,7 +58,7 @@ libstdc__fs_la_SOURCES = $(sources)\n # as the occasion call for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t-std=gnu++14 \\\n+\t-std=gnu++17 \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\"}, {"sha": "847b19b6982e02196382d1f595229923057fff30", "filename": "libstdc++-v3/src/filesystem/Makefile.in", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -114,8 +114,10 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n libstdc__fs_la_LIBADD =\n @ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-dir.lo cow-ops.lo \\\n-@ENABLE_DUAL_ABI_TRUE@\tcow-path.lo\n-am__objects_2 = dir.lo ops.lo path.lo $(am__objects_1)\n+@ENABLE_DUAL_ABI_TRUE@\tcow-path.lo cow-std-dir.lo \\\n+@ENABLE_DUAL_ABI_TRUE@\tcow-std-ops.lo cow-std-path.lo\n+am__objects_2 = dir.lo ops.lo path.lo std-dir.lo std-ops.lo \\\n+\tstd-path.lo $(am__objects_1)\n am_libstdc__fs_la_OBJECTS = $(am__objects_2)\n libstdc__fs_la_OBJECTS = $(am_libstdc__fs_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n@@ -362,12 +364,18 @@ headers =\n @ENABLE_DUAL_ABI_TRUE@cxx11_abi_sources = \\\n @ENABLE_DUAL_ABI_TRUE@\tcow-dir.cc \\\n @ENABLE_DUAL_ABI_TRUE@\tcow-ops.cc \\\n-@ENABLE_DUAL_ABI_TRUE@\tcow-path.cc\n+@ENABLE_DUAL_ABI_TRUE@\tcow-path.cc \\\n+@ENABLE_DUAL_ABI_TRUE@\tcow-std-dir.cc \\\n+@ENABLE_DUAL_ABI_TRUE@\tcow-std-ops.cc \\\n+@ENABLE_DUAL_ABI_TRUE@\tcow-std-path.cc\n \n sources = \\\n \tdir.cc \\\n \tops.cc \\\n \tpath.cc \\\n+\tstd-dir.cc \\\n+\tstd-ops.cc \\\n+\tstd-path.cc \\\n \t${cxx11_abi_sources}\n \n \n@@ -381,7 +389,7 @@ libstdc__fs_la_SOURCES = $(sources)\n # as the occasion call for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t-std=gnu++14 \\\n+\t-std=gnu++17 \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\"}, {"sha": "96907abd71280108fd35fadd36957d9060ade729", "filename": "libstdc++-v3/src/filesystem/cow-dir.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-dir.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,4 +1,4 @@\n-// Class filesystem::directory_entry etc. -*- C++ -*-\n+// Class experimental::filesystem::directory_entry etc. -*- C++ -*-\n \n // Copyright (C) 2015-2017 Free Software Foundation, Inc.\n //"}, {"sha": "3b41d7c98ac7e709e36b20c1ad1dda0b286479f3", "filename": "libstdc++-v3/src/filesystem/cow-ops.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-ops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-ops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-ops.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,4 +1,4 @@\n-// Filesystem operations -*- C++ -*-\n+// Filesystem TS operations -*- C++ -*-\n \n // Copyright (C) 2015-2017 Free Software Foundation, Inc.\n //"}, {"sha": "0817b0ae491cf03aa49a9ff06381311b347c0835", "filename": "libstdc++-v3/src/filesystem/cow-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,4 +1,4 @@\n-// Class filesystem::path -*- C++ -*-\n+// Class experimental::filesystem::path -*- C++ -*-\n \n // Copyright (C) 2015-2017 Free Software Foundation, Inc.\n //"}, {"sha": "edcf24506bb735bea4dbf3324a37fb4c81e0ad2c", "filename": "libstdc++-v3/src/filesystem/cow-std-dir.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-dir.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,26 @@\n+// Class filesystem::directory_entry etc. -*- C++ -*-\n+\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#define _GLIBCXX_USE_CXX11_ABI 0\n+#include \"std-dir.cc\""}, {"sha": "bea5470a890e6b78e02f2936d386176159bc4bb1", "filename": "libstdc++-v3/src/filesystem/cow-std-ops.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-ops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-ops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-ops.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,26 @@\n+// Filesystem operations -*- C++ -*-\n+\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#define _GLIBCXX_USE_CXX11_ABI 0\n+#include \"std-ops.cc\""}, {"sha": "718ff952864aa85f834aef8f96b40fd9bb292642", "filename": "libstdc++-v3/src/filesystem/cow-std-path.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fcow-std-path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,26 @@\n+// Class filesystem::path -*- C++ -*-\n+\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#define _GLIBCXX_USE_CXX11_ABI 0\n+#include \"std-path.cc\""}, {"sha": "e8036321b20c6badd89a41043d0e298d6e7ec9b7", "filename": "libstdc++-v3/src/filesystem/dir-common.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,149 @@\n+// Filesystem directory iterator utilities -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_DIR_COMMON_H\n+#define _GLIBCXX_DIR_COMMON_H 1\n+\n+#include <string.h>  // strcmp\n+#ifdef _GLIBCXX_HAVE_DIRENT_H\n+# ifdef _GLIBCXX_HAVE_SYS_TYPES_H\n+#  include <sys/types.h>\n+# endif\n+# include <dirent.h>\n+#else\n+# error \"the <dirent.h> header is needed to build the Filesystem TS\"\n+#endif\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+# undef opendir\n+# define opendir _wopendir\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace filesystem\n+{\n+\n+struct _Dir_base\n+{\n+  _Dir_base(DIR* dirp = nullptr) : dirp(dirp) { }\n+\n+  // If no error occurs then dirp is non-null,\n+  // otherwise null (whether error ignored or not).\n+  _Dir_base(const char* p, bool skip_permission_denied,\n+\t    error_code& ec) noexcept\n+  : dirp(::opendir(p))\n+  {\n+    if (dirp)\n+      ec.clear();\n+    else\n+    {\n+      const int err = errno;\n+      if (err == EACCES && skip_permission_denied)\n+\tec.clear();\n+      else\n+\tec.assign(err, std::generic_category());\n+    }\n+  }\n+\n+  _Dir_base(_Dir_base&& d) : dirp(std::exchange(d.dirp, nullptr)) { }\n+\n+  _Dir_base& operator=(_Dir_base&&) = delete;\n+\n+  ~_Dir_base() { if (dirp) ::closedir(dirp); }\n+\n+  const struct ::dirent*\n+  advance(bool skip_permission_denied, error_code& ec) noexcept\n+  {\n+    ec.clear();\n+\n+    int err = std::exchange(errno, 0);\n+    const struct ::dirent* entp = readdir(dirp);\n+    // std::swap cannot be used with Bionic's errno\n+    err = std::exchange(errno, err);\n+\n+    if (entp)\n+      {\n+\t// skip past dot and dot-dot\n+\tif (!strcmp(entp->d_name, \".\") || !strcmp(entp->d_name, \"..\"))\n+\t  return advance(skip_permission_denied, ec);\n+\treturn entp;\n+      }\n+    else if (err)\n+      {\n+\tif (err == EACCES && skip_permission_denied)\n+\t  return nullptr;\n+\tec.assign(err, std::generic_category());\n+\treturn nullptr;\n+      }\n+    else\n+      {\n+\t// reached the end\n+\treturn nullptr;\n+      }\n+  }\n+\n+  DIR*\tdirp;\n+};\n+\n+} // namespace filesystem\n+\n+// BEGIN/END macros must be defined before including this file.\n+_GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM\n+inline file_type\n+get_file_type(const ::dirent& d __attribute__((__unused__)))\n+{\n+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n+  switch (d.d_type)\n+  {\n+  case DT_BLK:\n+    return file_type::block;\n+  case DT_CHR:\n+    return file_type::character;\n+  case DT_DIR:\n+    return file_type::directory;\n+  case DT_FIFO:\n+    return file_type::fifo;\n+  case DT_LNK:\n+    return file_type::symlink;\n+  case DT_REG:\n+    return file_type::regular;\n+  case DT_SOCK:\n+    return file_type::socket;\n+  case DT_UNKNOWN:\n+    return file_type::unknown;\n+  default:\n+    return file_type::none;\n+  }\n+#else\n+  return file_type::none;\n+#endif\n+}\n+_GLIBCXX_END_NAMESPACE_FILESYSTEM\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // _GLIBCXX_DIR_COMMON_H"}, {"sha": "42f63e739849574251dbc40c2785486bb46571fb", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "modified", "additions": 89, "deletions": 169, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -31,40 +31,76 @@\n #include <stack>\n #include <string.h>\n #include <errno.h>\n-#ifdef _GLIBCXX_HAVE_DIRENT_H\n-# ifdef _GLIBCXX_HAVE_SYS_TYPES_H\n-#  include <sys/types.h>\n-# endif\n-# include <dirent.h>\n-#else\n-# error \"the <dirent.h> header is needed to build the Filesystem TS\"\n-#endif\n-\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-# undef opendir\n-# define opendir _wopendir\n-#endif\n+#define _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM \\\n+  namespace experimental { namespace filesystem {\n+#define _GLIBCXX_END_NAMESPACE_FILESYSTEM } }\n+#include \"dir-common.h\"\n \n namespace fs = std::experimental::filesystem;\n \n-struct fs::_Dir\n+struct fs::_Dir : std::filesystem::_Dir_base\n {\n-  _Dir() : dirp(nullptr) { }\n+  _Dir(const fs::path& p, bool skip_permission_denied, error_code& ec)\n+  : _Dir_base(p.c_str(), skip_permission_denied, ec)\n+  {\n+    if (!ec)\n+      path = p;\n+  }\n \n-  _Dir(DIR* dirp, const fs::path& path) : dirp(dirp), path(path) { }\n+  _Dir(DIR* dirp, const path& p) : _Dir_base(dirp), path(p) { }\n \n-  _Dir(_Dir&& d)\n-  : dirp(std::exchange(d.dirp, nullptr)), path(std::move(d.path)),\n-    entry(std::move(d.entry)), type(d.type)\n-  { }\n+  _Dir(_Dir&&) = default;\n \n-  _Dir& operator=(_Dir&&) = delete;\n+  // Returns false when the end of the directory entries is reached.\n+  // Reports errors by setting ec.\n+  bool advance(bool skip_permission_denied, error_code& ec) noexcept\n+  {\n+    if (const auto entp = _Dir_base::advance(skip_permission_denied, ec))\n+      {\n+\tentry = fs::directory_entry{path / entp->d_name};\n+\ttype = get_file_type(*entp);\n+\treturn true;\n+      }\n+    else if (!ec)\n+      {\n+\t// reached the end\n+\tentry = {};\n+\ttype = file_type::none;\n+      }\n+    return false;\n+  }\n+\n+  bool advance(error_code& ec) noexcept { return advance(false, ec); }\n \n-  ~_Dir() { if (dirp) ::closedir(dirp); }\n+  // Returns false when the end of the directory entries is reached.\n+  // Reports errors by throwing.\n+  bool advance(bool skip_permission_denied = false)\n+  {\n+    error_code ec;\n+    const bool ok = advance(skip_permission_denied, ec);\n+    if (ec)\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"directory iterator cannot advance\", ec));\n+    return ok;\n+  }\n \n-  bool advance(std::error_code*, directory_options = directory_options::none);\n+  bool should_recurse(bool follow_symlink, error_code& ec) const\n+  {\n+    file_type type = this->type;\n+    if (type == file_type::none || type == file_type::unknown)\n+    {\n+      type = entry.symlink_status(ec).type();\n+      if (ec)\n+\treturn false;\n+    }\n+\n+    if (type == file_type::directory)\n+      return true;\n+    if (type == file_type::symlink)\n+      return follow_symlink && is_directory(entry.status(ec));\n+    return false;\n+  }\n \n-  DIR*\t\t\tdirp;\n   fs::path\t\tpath;\n   directory_entry\tentry;\n   file_type\t\ttype = file_type::none;\n@@ -78,119 +114,28 @@ namespace\n     {\n       return (obj & bits) != Bitmask::none;\n     }\n-\n-  // Returns {dirp, p} on success, {} on error (whether ignored or not).\n-  inline fs::_Dir\n-  open_dir(const fs::path& p, fs::directory_options options,\n-\t   std::error_code* ec)\n-  {\n-    if (ec)\n-      ec->clear();\n-\n-    if (DIR* dirp = ::opendir(p.c_str()))\n-      return {dirp, p};\n-\n-    const int err = errno;\n-    if (err == EACCES\n-        && is_set(options, fs::directory_options::skip_permission_denied))\n-      return {};\n-\n-    if (!ec)\n-      _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n-            \"directory iterator cannot open directory\", p,\n-            std::error_code(err, std::generic_category())));\n-\n-    ec->assign(err, std::generic_category());\n-    return {};\n-  }\n-\n-  inline fs::file_type\n-  get_file_type(const ::dirent& d __attribute__((__unused__)))\n-  {\n-#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n-    switch (d.d_type)\n-    {\n-    case DT_BLK:\n-      return fs::file_type::block;\n-    case DT_CHR:\n-      return fs::file_type::character;\n-    case DT_DIR:\n-      return fs::file_type::directory;\n-    case DT_FIFO:\n-      return fs::file_type::fifo;\n-    case DT_LNK:\n-      return fs::file_type::symlink;\n-    case DT_REG:\n-      return fs::file_type::regular;\n-    case DT_SOCK:\n-      return fs::file_type::socket;\n-    case DT_UNKNOWN:\n-      return fs::file_type::unknown;\n-    default:\n-      return fs::file_type::none;\n-    }\n-#else\n-    return fs::file_type::none;\n-#endif\n-  }\n-}\n-\n-\n-// Returns false when the end of the directory entries is reached.\n-// Reports errors by setting ec or throwing.\n-bool\n-fs::_Dir::advance(error_code* ec, directory_options options)\n-{\n-  if (ec)\n-    ec->clear();\n-\n-  int err = std::exchange(errno, 0);\n-  const auto entp = readdir(dirp);\n-  // std::swap cannot be used with Bionic's errno\n-  err = std::exchange(errno, err);\n-\n-  if (entp)\n-    {\n-      // skip past dot and dot-dot\n-      if (!strcmp(entp->d_name, \".\") || !strcmp(entp->d_name, \"..\"))\n-\treturn advance(ec, options);\n-      entry = fs::directory_entry{path / entp->d_name};\n-      type = get_file_type(*entp);\n-      return true;\n-    }\n-  else if (err)\n-    {\n-      if (err == EACCES\n-        && is_set(options, directory_options::skip_permission_denied))\n-\treturn false;\n-\n-      if (!ec)\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"directory iterator cannot advance\",\n-\t      std::error_code(err, std::generic_category())));\n-      ec->assign(err, std::generic_category());\n-      return false;\n-    }\n-  else\n-    {\n-      // reached the end\n-      entry = {};\n-      type = fs::file_type::none;\n-      return false;\n-    }\n }\n \n fs::directory_iterator::\n-directory_iterator(const path& p, directory_options options, error_code* ec)\n+directory_iterator(const path& p, directory_options options, error_code* ecptr)\n {\n-  _Dir dir = open_dir(p, options, ec);\n+  const bool skip_permission_denied\n+    = is_set(options, directory_options::skip_permission_denied);\n+\n+  error_code ec;\n+  _Dir dir(p, skip_permission_denied, ec);\n \n   if (dir.dirp)\n     {\n       auto sp = std::make_shared<fs::_Dir>(std::move(dir));\n-      if (sp->advance(ec, options))\n+      if (sp->advance(skip_permission_denied, ec))\n \t_M_dir.swap(sp);\n     }\n+  if (ecptr)\n+    *ecptr = ec;\n+  else if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n+\t  \"directory iterator cannot open directory\", p, ec));\n }\n \n const fs::directory_entry&\n@@ -210,7 +155,7 @@ fs::directory_iterator::operator++()\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"cannot advance non-dereferenceable directory iterator\",\n \t  std::make_error_code(errc::invalid_argument)));\n-  if (!_M_dir->advance(nullptr))\n+  if (!_M_dir->advance())\n     _M_dir.reset();\n   return *this;\n }\n@@ -223,13 +168,11 @@ fs::directory_iterator::increment(error_code& ec) noexcept\n       ec = std::make_error_code(errc::invalid_argument);\n       return *this;\n     }\n-  if (!_M_dir->advance(&ec))\n+  if (!_M_dir->advance(ec))\n     _M_dir.reset();\n   return *this;\n }\n \n-using Dir_iter_pair = std::pair<fs::_Dir, fs::directory_iterator>;\n-\n struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n {\n   void clear() { c.clear(); }\n@@ -240,6 +183,8 @@ recursive_directory_iterator(const path& p, directory_options options,\n                              error_code* ec)\n : _M_options(options), _M_pending(true)\n {\n+  if (ec)\n+    ec->clear();\n   if (DIR* dirp = ::opendir(p.c_str()))\n     {\n       auto sp = std::make_shared<_Dir_stack>();\n@@ -252,11 +197,7 @@ recursive_directory_iterator(const path& p, directory_options options,\n       const int err = errno;\n       if (err == EACCES\n \t  && is_set(options, fs::directory_options::skip_permission_denied))\n-\t{\n-\t  if (ec)\n-\t    ec->clear();\n-\t  return;\n-\t}\n+\treturn;\n \n       if (!ec)\n \t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n@@ -300,35 +241,6 @@ fs::recursive_directory_iterator::operator++()\n   return *this;\n }\n \n-namespace\n-{\n-  bool\n-  recurse(const fs::_Dir& d, fs::directory_options options, std::error_code& ec)\n-  {\n-    bool follow_symlink\n-      = is_set(options, fs::directory_options::follow_directory_symlink);\n-#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n-    if (d.type == fs::file_type::directory)\n-      return true;\n-    if (d.type == fs::file_type::symlink && follow_symlink)\n-      return d.entry.status().type() == fs::file_type::directory;\n-    if (d.type != fs::file_type::none && d.type != fs::file_type::unknown)\n-      return false;\n-#endif\n-    const fs::path& path = d.entry.path();\n-    auto type = fs::symlink_status(path, ec).type();\n-    if (ec.value())\n-      return false;\n-    if (type == fs::file_type::symlink)\n-      {\n-\tif (!follow_symlink)\n-\t  return false;\n-\ttype = fs::status(path, ec).type();\n-      }\n-    return type == fs::file_type::directory;\n-  }\n-}\n-\n fs::recursive_directory_iterator&\n fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n {\n@@ -338,11 +250,16 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n       return *this;\n     }\n \n+  const bool follow\n+    = is_set(_M_options, directory_options::follow_directory_symlink);\n+  const bool skip_permission_denied\n+    = is_set(_M_options, directory_options::skip_permission_denied);\n+\n   auto& top = _M_dirs->top();\n \n-  if (std::exchange(_M_pending, true) && recurse(top, _M_options, ec))\n+  if (std::exchange(_M_pending, true) && top.should_recurse(follow, ec))\n     {\n-      _Dir dir = open_dir(top.entry.path(), _M_options, &ec);\n+      _Dir dir(top.entry.path(), skip_permission_denied, ec);\n       if (ec)\n \t{\n \t  _M_dirs.reset();\n@@ -352,7 +269,7 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n \t  _M_dirs->push(std::move(dir));\n     }\n \n-  while (!_M_dirs->top().advance(&ec, _M_options) && !ec)\n+  while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec)\n     {\n       _M_dirs->pop();\n       if (_M_dirs->empty())\n@@ -373,6 +290,9 @@ fs::recursive_directory_iterator::pop(error_code& ec)\n       return;\n     }\n \n+  const bool skip_permission_denied\n+    = is_set(_M_options, directory_options::skip_permission_denied);\n+\n   do {\n     _M_dirs->pop();\n     if (_M_dirs->empty())\n@@ -381,7 +301,7 @@ fs::recursive_directory_iterator::pop(error_code& ec)\n \tec.clear();\n \treturn;\n       }\n-  } while (!_M_dirs->top().advance(&ec, _M_options));\n+  } while (!_M_dirs->top().advance(skip_permission_denied, ec));\n }\n \n void"}, {"sha": "12c12b08f8c50eaa1ca8dc006062f4f13b566ec4", "filename": "libstdc++-v3/src/filesystem/ops-common.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops-common.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,148 @@\n+// Filesystem operation utilities -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_OPS_COMMON_H\n+#define _GLIBCXX_OPS_COMMON_H 1\n+\n+#include <chrono>\n+\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+# include <unistd.h>\n+# if defined(_GLIBCXX_HAVE_SYS_STAT_H) && defined(_GLIBCXX_HAVE_SYS_TYPES_H)\n+#  include <sys/types.h>\n+#  include <sys/stat.h>\n+# endif\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace filesystem\n+{\n+  template<typename Bitmask>\n+    inline bool is_set(Bitmask obj, Bitmask bits)\n+    {\n+      return (obj & bits) != Bitmask::none;\n+    }\n+\n+  inline bool\n+  is_not_found_errno(int err) noexcept\n+  {\n+    return err == ENOENT || err == ENOTDIR;\n+  }\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  typedef struct ::stat stat_type;\n+\n+  inline std::chrono::system_clock::time_point\n+  file_time(const stat_type& st, std::error_code& ec) noexcept\n+  {\n+    using namespace std::chrono;\n+#ifdef _GLIBCXX_USE_ST_MTIM\n+    time_t s = st.st_mtim.tv_sec;\n+    nanoseconds ns{st.st_mtim.tv_nsec};\n+#else\n+    time_t s = st.st_mtime;\n+    nanoseconds ns{};\n+#endif\n+\n+    if (s >= (nanoseconds::max().count() / 1e9))\n+      {\n+\tec = std::make_error_code(std::errc::value_too_large); // EOVERFLOW\n+\treturn system_clock::time_point::min();\n+      }\n+    ec.clear();\n+    return system_clock::time_point{seconds{s} + ns};\n+  }\n+\n+  struct copy_options_existing_file\n+  {\n+    bool skip, update, overwrite;\n+  };\n+\n+  bool\n+  do_copy_file(const char* from, const char* to,\n+\t       copy_options_existing_file options,\n+\t       stat_type* from_st, stat_type* to_st,\n+\t       std::error_code& ec) noexcept;\n+\n+#endif // _GLIBCXX_HAVE_SYS_STAT_H\n+\n+} // namespace filesystem\n+\n+// BEGIN/END macros must be defined before including this file.\n+_GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  typedef struct ::stat stat_type;\n+\n+  inline file_type\n+  make_file_type(const stat_type& st) noexcept\n+  {\n+#ifdef _GLIBCXX_HAVE_S_ISREG\n+    if (S_ISREG(st.st_mode))\n+      return file_type::regular;\n+    else if (S_ISDIR(st.st_mode))\n+      return file_type::directory;\n+    else if (S_ISCHR(st.st_mode))\n+      return file_type::character;\n+    else if (S_ISBLK(st.st_mode))\n+      return file_type::block;\n+    else if (S_ISFIFO(st.st_mode))\n+      return file_type::fifo;\n+    else if (S_ISLNK(st.st_mode))\n+      return file_type::symlink;\n+    else if (S_ISSOCK(st.st_mode))\n+      return file_type::socket;\n+#endif\n+    return file_type::unknown;\n+  }\n+\n+  inline file_status\n+  make_file_status(const stat_type& st) noexcept\n+  {\n+    return file_status{\n+\tmake_file_type(st),\n+\tstatic_cast<perms>(st.st_mode) & perms::mask\n+    };\n+  }\n+\n+  inline std::filesystem::copy_options_existing_file\n+  copy_file_options(copy_options opt)\n+  {\n+    using std::filesystem::is_set;\n+    return {\n+\tis_set(opt, copy_options::skip_existing),\n+\tis_set(opt, copy_options::update_existing),\n+\tis_set(opt, copy_options::overwrite_existing)\n+    };\n+  }\n+#endif // _GLIBCXX_HAVE_SYS_STAT_H\n+\n+_GLIBCXX_END_NAMESPACE_FILESYSTEM\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // _GLIBCXX_OPS_COMMON_H"}, {"sha": "61d9c89e616cd540cc68700db1e93a36b4371ad1", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "modified", "additions": 26, "deletions": 263, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,4 +1,4 @@\n-// Filesystem operations -*- C++ -*-\n+// Filesystem TS operations -*- C++ -*-\n \n // Copyright (C) 2014-2017 Free Software Foundation, Inc.\n //\n@@ -35,26 +35,24 @@\n #include <stdio.h>\n #include <errno.h>\n #include <limits.h>  // PATH_MAX\n-#ifdef _GLIBCXX_HAVE_UNISTD_H\n-# include <unistd.h>\n-# if defined(_GLIBCXX_HAVE_SYS_STAT_H) && defined(_GLIBCXX_HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#  include <sys/stat.h>\n-# endif\n-#endif\n #ifdef _GLIBCXX_HAVE_FCNTL_H\n-# include <fcntl.h>\n+# include <fcntl.h>  // AT_FDCWD, AT_SYMLINK_NOFOLLOW\n #endif\n-#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n-# include <sys/statvfs.h>\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+#  include <sys/stat.h>   // stat, utimensat, fchmodat\n #endif\n-#ifdef _GLIBCXX_USE_SENDFILE\n-# include <sys/sendfile.h>\n+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n+# include <sys/statvfs.h> // statvfs\n #endif\n-#if _GLIBCXX_HAVE_UTIME_H\n-# include <utime.h>\n+#if !_GLIBCXX_USE_UTIMENSAT && _GLIBCXX_HAVE_UTIME_H\n+# include <utime.h> // utime\n #endif\n \n+#define _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM \\\n+  namespace experimental { namespace filesystem {\n+#define _GLIBCXX_END_NAMESPACE_FILESYSTEM } }\n+#include \"ops-common.h\"\n+\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n # undef utime\n # define utime _wutime\n@@ -240,254 +238,16 @@ fs::copy(const path& from, const path& to, copy_options options)\n \n namespace\n {\n-  template<typename Bitmask>\n-    inline bool is_set(Bitmask obj, Bitmask bits)\n-    {\n-      return (obj & bits) != Bitmask::none;\n-    }\n-}\n+  using std::filesystem::is_set;\n \n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-namespace\n-{\n   typedef struct ::stat stat_type;\n \n-  inline fs::file_type\n-  make_file_type(const stat_type& st) noexcept\n-  {\n-    using fs::file_type;\n-#ifdef _GLIBCXX_HAVE_S_ISREG\n-    if (S_ISREG(st.st_mode))\n-      return file_type::regular;\n-    else if (S_ISDIR(st.st_mode))\n-      return file_type::directory;\n-    else if (S_ISCHR(st.st_mode))\n-      return file_type::character;\n-    else if (S_ISBLK(st.st_mode))\n-      return file_type::block;\n-    else if (S_ISFIFO(st.st_mode))\n-      return file_type::fifo;\n-    else if (S_ISLNK(st.st_mode))\n-      return file_type::symlink;\n-    else if (S_ISSOCK(st.st_mode))\n-      return file_type::socket;\n-#endif\n-    return file_type::unknown;\n-\n-  }\n-\n-  inline fs::file_status\n-  make_file_status(const stat_type& st) noexcept\n-  {\n-    return fs::file_status{\n-\tmake_file_type(st),\n-\tstatic_cast<fs::perms>(st.st_mode) & fs::perms::mask\n-    };\n-  }\n-\n-  inline bool\n-  is_not_found_errno(int err) noexcept\n-  {\n-    return err == ENOENT || err == ENOTDIR;\n-  }\n-\n-  inline fs::file_time_type\n-  file_time(const stat_type& st, std::error_code& ec) noexcept\n-  {\n-    using namespace std::chrono;\n-#ifdef _GLIBCXX_USE_ST_MTIM\n-    time_t s = st.st_mtim.tv_sec;\n-    nanoseconds ns{st.st_mtim.tv_nsec};\n-#else\n-    time_t s = st.st_mtime;\n-    nanoseconds ns{};\n-#endif\n-\n-    if (s >= (nanoseconds::max().count() / 1e9))\n-      {\n-\tec = std::make_error_code(std::errc::value_too_large); // EOVERFLOW\n-\treturn fs::file_time_type::min();\n-      }\n-    ec.clear();\n-    return fs::file_time_type{seconds{s} + ns};\n-  }\n-\n-  bool\n-  do_copy_file(const fs::path& from, const fs::path& to,\n-\t       fs::copy_options option,\n-\t       stat_type* from_st, stat_type* to_st,\n-\t       std::error_code& ec) noexcept\n-  {\n-    stat_type st1, st2;\n-    fs::file_status t, f;\n-\n-    if (to_st == nullptr)\n-      {\n-\tif (::stat(to.c_str(), &st1))\n-\t  {\n-\t    int err = errno;\n-\t    if (!is_not_found_errno(err))\n-\t      {\n-\t\tec.assign(err, std::generic_category());\n-\t\treturn false;\n-\t      }\n-\t  }\n-\telse\n-\t  to_st = &st1;\n-      }\n-    else if (to_st == from_st)\n-      to_st = nullptr;\n-\n-    if (to_st == nullptr)\n-      t = fs::file_status{fs::file_type::not_found};\n-    else\n-      t = make_file_status(*to_st);\n-\n-    if (from_st == nullptr)\n-      {\n-\tif (::stat(from.c_str(), &st2))\n-\t  {\n-\t    ec.assign(errno, std::generic_category());\n-\t    return false;\n-\t  }\n-\telse\n-\t  from_st = &st2;\n-      }\n-    f = make_file_status(*from_st);\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 2712. copy_file() has a number of unspecified error conditions\n-    if (!is_regular_file(f))\n-      {\n-\tec = std::make_error_code(std::errc::not_supported);\n-\treturn false;\n-      }\n-\n-    using opts = fs::copy_options;\n-\n-    if (exists(t))\n-      {\n-\tif (!is_regular_file(t))\n-\t  {\n-\t    ec = std::make_error_code(std::errc::not_supported);\n-\t    return false;\n-\t  }\n-\n-\tif (to_st->st_dev == from_st->st_dev\n-\t    && to_st->st_ino == from_st->st_ino)\n-\t  {\n-\t    ec = std::make_error_code(std::errc::file_exists);\n-\t    return false;\n-\t  }\n-\n-\tif (is_set(option, opts::skip_existing))\n-\t  {\n-\t    ec.clear();\n-\t    return false;\n-\t  }\n-\telse if (is_set(option, opts::update_existing))\n-\t  {\n-\t    const auto from_mtime = file_time(*from_st, ec);\n-\t    if (ec)\n-\t      return false;\n-\t    if ((from_mtime <= file_time(*to_st, ec)) || ec)\n-\t      return false;\n-\t  }\n-\telse if (!is_set(option, opts::overwrite_existing))\n-\t  {\n-\t    ec = std::make_error_code(std::errc::file_exists);\n-\t    return false;\n-\t  }\n-\telse if (!is_regular_file(t))\n-\t  {\n-\t    ec = std::make_error_code(std::errc::not_supported);\n-\t    return false;\n-\t  }\n-      }\n-\n-    struct CloseFD {\n-      ~CloseFD() { if (fd != -1) ::close(fd); }\n-      bool close() { return ::close(std::exchange(fd, -1)) == 0; }\n-      int fd;\n-    };\n-\n-    CloseFD in = { ::open(from.c_str(), O_RDONLY) };\n-    if (in.fd == -1)\n-      {\n-\tec.assign(errno, std::generic_category());\n-\treturn false;\n-      }\n-    int oflag = O_WRONLY|O_CREAT;\n-    if (is_set(option, opts::overwrite_existing|opts::update_existing))\n-      oflag |= O_TRUNC;\n-    else\n-      oflag |= O_EXCL;\n-    CloseFD out = { ::open(to.c_str(), oflag, S_IWUSR) };\n-    if (out.fd == -1)\n-      {\n-\tif (errno == EEXIST && is_set(option, opts::skip_existing))\n-\t  ec.clear();\n-\telse\n-\t  ec.assign(errno, std::generic_category());\n-\treturn false;\n-      }\n-\n-#ifdef _GLIBCXX_USE_FCHMOD\n-    if (::fchmod(out.fd, from_st->st_mode))\n-#elif defined _GLIBCXX_USE_FCHMODAT\n-    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))\n-#else\n-    if (::chmod(to.c_str(), from_st->st_mode))\n-#endif\n-      {\n-\tec.assign(errno, std::generic_category());\n-\treturn false;\n-      }\n-\n-#ifdef _GLIBCXX_USE_SENDFILE\n-    off_t offset = 0;\n-    const auto n = ::sendfile(out.fd, in.fd, &offset, from_st->st_size);\n-    if (n < 0 && (errno == ENOSYS || errno == EINVAL))\n-      {\n-#endif\n-\t__gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);\n-\t__gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);\n-\tif (sbin.is_open())\n-\t  in.fd = -1;\n-\tif (sbout.is_open())\n-\t  out.fd = -1;\n-\tif (from_st->st_size && !(std::ostream(&sbout) << &sbin))\n-\t  {\n-\t    ec = std::make_error_code(std::errc::io_error);\n-\t    return false;\n-\t  }\n-\tif (!sbout.close() || !sbin.close())\n-\t  {\n-\t    ec.assign(errno, std::generic_category());\n-\t    return false;\n-\t  }\n-\n-\tec.clear();\n-\treturn true;\n-\n-#ifdef _GLIBCXX_USE_SENDFILE\n-      }\n-    if (n != from_st->st_size)\n-      {\n-\tec.assign(errno, std::generic_category());\n-\treturn false;\n-      }\n-    if (!out.close() || !in.close())\n-      {\n-\tec.assign(errno, std::generic_category());\n-\treturn false;\n-      }\n-\n-    ec.clear();\n-    return true;\n-#endif\n-  }\n-}\n-#endif\n+  using std::filesystem::is_not_found_errno;\n+  using std::filesystem::file_time;\n+  using std::filesystem::do_copy_file;\n+#endif // _GLIBCXX_HAVE_SYS_STAT_H\n+} // namespace\n \n void\n fs::copy(const path& from, const path& to, copy_options options,\n@@ -561,11 +321,13 @@ fs::copy(const path& from, const path& to, copy_options options,\n       else if (is_set(options, copy_options::create_hard_links))\n \tcreate_hard_link(from, to, ec);\n       else if (is_directory(t))\n-\tdo_copy_file(from, to / from.filename(), options, &from_st, 0, ec);\n+\tdo_copy_file(from.c_str(), (to / from.filename()).c_str(),\n+\t\t     copy_file_options(options), &from_st, nullptr, ec);\n       else\n \t{\n \t  auto ptr = exists(t) ? &to_st : &from_st;\n-\t  do_copy_file(from, to, options, &from_st, ptr,  ec);\n+\t  do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),\n+\t\t       &from_st, ptr,  ec);\n \t}\n     }\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -602,11 +364,12 @@ fs::copy_file(const path& from, const path& to, copy_options option)\n }\n \n bool\n-fs::copy_file(const path& from, const path& to, copy_options option,\n+fs::copy_file(const path& from, const path& to, copy_options options,\n \t      error_code& ec) noexcept\n {\n #ifdef _GLIBCXX_HAVE_SYS_STAT_H\n-  return do_copy_file(from, to, option, nullptr, nullptr, ec);\n+  return do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),\n+\t\t      nullptr, nullptr, ec);\n #else\n   ec = std::make_error_code(std::errc::not_supported);\n   return false;"}, {"sha": "a5196674883fac7464ef6bb1b0a28b9a4de5157b", "filename": "libstdc++-v3/src/filesystem/path.cc", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -1,4 +1,4 @@\n-// Class filesystem::path -*- C++ -*-\n+// Class experimental::filesystem::path -*- C++ -*-\n \n // Copyright (C) 2014-2017 Free Software Foundation, Inc.\n //\n@@ -28,9 +28,10 @@\n \n #include <experimental/filesystem>\n \n-using std::experimental::filesystem::path;\n+namespace fs = std::experimental::filesystem;\n+using fs::path;\n \n-std::experimental::filesystem::filesystem_error::~filesystem_error() = default;\n+fs::filesystem_error::~filesystem_error() = default;\n \n constexpr path::value_type path::preferred_separator;\n \n@@ -461,7 +462,7 @@ path::_S_convert_loc(const char* __first, const char* __last,\n }\n \n std::size_t\n-std::experimental::filesystem::hash_value(const path& p) noexcept\n+fs::hash_value(const path& p) noexcept\n {\n   // [path.non-member]\n   // \"If for two paths, p1 == p2 then hash_value(p1) == hash_value(p2).\"\n@@ -477,3 +478,29 @@ std::experimental::filesystem::hash_value(const path& p) noexcept\n     }\n   return seed;\n }\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace filesystem\n+{\n+  extern string\n+  fs_err_concat(const string& __what, const string& __path1,\n+\t\tconst string& __path2);\n+} // namespace filesystem\n+\n+namespace experimental::filesystem::v1 {\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  std::string filesystem_error::_M_gen_what()\n+  {\n+    using std::filesystem::fs_err_concat;\n+    return fs_err_concat(system_error::what(), _M_path1.native(),\n+\t\t\t _M_path2.native());\n+  }\n+\n+_GLIBCXX_END_NAMESPACE_CXX11\n+} // namespace experimental::filesystem::v1\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std"}, {"sha": "8e45890b68e3b3efa27699f1398be0e0d75bc754", "filename": "libstdc++-v3/src/filesystem/std-dir.cc", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-dir.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,318 @@\n+// Class filesystem::directory_entry etc. -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_USE_CXX11_ABI\n+# define _GLIBCXX_USE_CXX11_ABI 1\n+#endif\n+\n+#include <filesystem>\n+#include <experimental/filesystem>\n+#include <utility>\n+#include <stack>\n+#include <string.h>\n+#include <errno.h>\n+#define _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM namespace filesystem {\n+#define _GLIBCXX_END_NAMESPACE_FILESYSTEM }\n+#include \"dir-common.h\"\n+\n+namespace fs = std::filesystem;\n+\n+struct fs::_Dir : _Dir_base\n+{\n+  _Dir(const fs::path& p, bool skip_permission_denied, error_code& ec)\n+  : _Dir_base(p.c_str(), skip_permission_denied, ec)\n+  {\n+    if (!ec)\n+      path = p;\n+  }\n+\n+  _Dir(DIR* dirp, const path& p) : _Dir_base(dirp), path(p) { }\n+\n+  _Dir(_Dir&&) = default;\n+\n+  // Returns false when the end of the directory entries is reached.\n+  // Reports errors by setting ec.\n+  bool advance(bool skip_permission_denied, error_code& ec) noexcept\n+  {\n+    if (const auto entp = _Dir_base::advance(skip_permission_denied, ec))\n+      {\n+\tentry = fs::directory_entry{path / entp->d_name, get_file_type(*entp)};\n+\treturn true;\n+      }\n+    else if (!ec)\n+      {\n+\t// reached the end\n+\tentry = {};\n+      }\n+    return false;\n+  }\n+\n+  bool advance(error_code& ec) noexcept { return advance(false, ec); }\n+\n+  // Returns false when the end of the directory entries is reached.\n+  // Reports errors by throwing.\n+  bool advance(bool skip_permission_denied = false)\n+  {\n+    error_code ec;\n+    const bool ok = advance(skip_permission_denied, ec);\n+    if (ec)\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"directory iterator cannot advance\", ec));\n+    return ok;\n+  }\n+\n+  bool should_recurse(bool follow_symlink, error_code& ec) const\n+  {\n+    file_type type = entry._M_type;\n+    if (type == file_type::none || type == file_type::unknown)\n+    {\n+      type = entry.symlink_status(ec).type();\n+      if (ec)\n+\treturn false;\n+    }\n+\n+    if (type == file_type::directory)\n+      return true;\n+    if (type == file_type::symlink)\n+      return follow_symlink && is_directory(entry.status(ec));\n+    return false;\n+  }\n+\n+  fs::path\t\tpath;\n+  directory_entry\tentry;\n+};\n+\n+namespace\n+{\n+  template<typename Bitmask>\n+    inline bool\n+    is_set(Bitmask obj, Bitmask bits)\n+    {\n+      return (obj & bits) != Bitmask::none;\n+    }\n+}\n+\n+fs::directory_iterator::\n+directory_iterator(const path& p, directory_options options, error_code* ecptr)\n+{\n+  const bool skip_permission_denied\n+    = is_set(options, directory_options::skip_permission_denied);\n+\n+  error_code ec;\n+  _Dir dir(p, skip_permission_denied, ec);\n+\n+  if (dir.dirp)\n+    {\n+      auto sp = std::make_shared<fs::_Dir>(std::move(dir));\n+      if (sp->advance(skip_permission_denied, ec))\n+\t_M_dir.swap(sp);\n+    }\n+  if (ecptr)\n+    *ecptr = ec;\n+  else if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n+\t  \"directory iterator cannot open directory\", p, ec));\n+}\n+\n+const fs::directory_entry&\n+fs::directory_iterator::operator*() const\n+{\n+  if (!_M_dir)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"non-dereferenceable directory iterator\",\n+\t  std::make_error_code(errc::invalid_argument)));\n+  return _M_dir->entry;\n+}\n+\n+fs::directory_iterator&\n+fs::directory_iterator::operator++()\n+{\n+  if (!_M_dir)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"cannot advance non-dereferenceable directory iterator\",\n+\t  std::make_error_code(errc::invalid_argument)));\n+  if (!_M_dir->advance())\n+    _M_dir.reset();\n+  return *this;\n+}\n+\n+fs::directory_iterator&\n+fs::directory_iterator::increment(error_code& ec) noexcept\n+{\n+  if (!_M_dir)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return *this;\n+    }\n+  if (!_M_dir->advance(ec))\n+    _M_dir.reset();\n+  return *this;\n+}\n+\n+struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n+{\n+  void clear() { c.clear(); }\n+};\n+\n+fs::recursive_directory_iterator::\n+recursive_directory_iterator(const path& p, directory_options options,\n+                             error_code* ecptr)\n+: _M_options(options), _M_pending(true)\n+{\n+  if (DIR* dirp = ::opendir(p.c_str()))\n+    {\n+      if (ecptr)\n+\tecptr->clear();\n+      auto sp = std::make_shared<_Dir_stack>();\n+      sp->push(_Dir{ dirp, p });\n+      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())\n+\t_M_dirs.swap(sp);\n+    }\n+  else\n+    {\n+      const int err = errno;\n+      if (err == EACCES\n+\t  && is_set(options, fs::directory_options::skip_permission_denied))\n+\t{\n+\t  if (ecptr)\n+\t    ecptr->clear();\n+\t  return;\n+\t}\n+\n+      if (!ecptr)\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"recursive directory iterator cannot open directory\", p,\n+\t      std::error_code(err, std::generic_category())));\n+\n+      ecptr->assign(err, std::generic_category());\n+    }\n+}\n+\n+fs::recursive_directory_iterator::~recursive_directory_iterator() = default;\n+\n+int\n+fs::recursive_directory_iterator::depth() const\n+{\n+  return int(_M_dirs->size()) - 1;\n+}\n+\n+const fs::directory_entry&\n+fs::recursive_directory_iterator::operator*() const\n+{\n+  return _M_dirs->top().entry;\n+}\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::\n+operator=(const recursive_directory_iterator& other) noexcept = default;\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::\n+operator=(recursive_directory_iterator&& other) noexcept = default;\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::operator++()\n+{\n+  error_code ec;\n+  increment(ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"cannot increment recursive directory iterator\", ec));\n+  return *this;\n+}\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n+{\n+  if (!_M_dirs)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return *this;\n+    }\n+\n+  const bool follow\n+    = is_set(_M_options, directory_options::follow_directory_symlink);\n+  const bool skip_permission_denied\n+    = is_set(_M_options, directory_options::skip_permission_denied);\n+\n+  auto& top = _M_dirs->top();\n+\n+  if (std::exchange(_M_pending, true) && top.should_recurse(follow, ec))\n+    {\n+      _Dir dir(top.entry.path(), skip_permission_denied, ec);\n+      if (ec)\n+\t{\n+\t  _M_dirs.reset();\n+\t  return *this;\n+\t}\n+      if (dir.dirp)\n+\t  _M_dirs->push(std::move(dir));\n+    }\n+\n+  while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec)\n+    {\n+      _M_dirs->pop();\n+      if (_M_dirs->empty())\n+\t{\n+\t  _M_dirs.reset();\n+\t  return *this;\n+\t}\n+    }\n+  return *this;\n+}\n+\n+void\n+fs::recursive_directory_iterator::pop(error_code& ec)\n+{\n+  if (!_M_dirs)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return;\n+    }\n+\n+  const bool skip_permission_denied\n+    = is_set(_M_options, directory_options::skip_permission_denied);\n+\n+  do {\n+    _M_dirs->pop();\n+    if (_M_dirs->empty())\n+      {\n+\t_M_dirs.reset();\n+\tec.clear();\n+\treturn;\n+      }\n+  } while (!_M_dirs->top().advance(skip_permission_denied, ec));\n+}\n+\n+void\n+fs::recursive_directory_iterator::pop()\n+{\n+  error_code ec;\n+  pop(ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(_M_dirs\n+\t  ? \"recursive directory iterator cannot pop\"\n+\t  : \"non-dereferenceable recursive directory iterator cannot pop\",\n+\t  ec));\n+}"}, {"sha": "ff7acbfc1e7737ede8df7cdbecdceab310d1e4cd", "filename": "libstdc++-v3/src/filesystem/std-ops.cc", "status": "added", "additions": 1513, "deletions": 0, "changes": 1513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-ops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-ops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-ops.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,1513 @@\n+// Filesystem operations -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_USE_CXX11_ABI\n+# define _GLIBCXX_USE_CXX11_ABI 1\n+#endif\n+\n+#include <filesystem>\n+#include <experimental/filesystem>\n+#include <functional>\n+#include <ostream>\n+#include <stack>\n+#include <ext/stdio_filebuf.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <limits.h>  // PATH_MAX\n+#ifdef _GLIBCXX_HAVE_FCNTL_H\n+# include <fcntl.h>  // AT_FDCWD, AT_SYMLINK_NOFOLLOW\n+#endif\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+#  include <sys/stat.h>   // stat, utimensat, fchmodat\n+#endif\n+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n+# include <sys/statvfs.h> // statvfs\n+#endif\n+#ifdef _GLIBCXX_USE_SENDFILE\n+# include <sys/sendfile.h> // sendfile\n+#endif\n+#if !_GLIBCXX_USE_UTIMENSAT && _GLIBCXX_HAVE_UTIME_H\n+# include <utime.h> // utime\n+#endif\n+\n+#define _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM namespace filesystem {\n+#define _GLIBCXX_END_NAMESPACE_FILESYSTEM }\n+#include \"ops-common.h\"\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+# undef utime\n+# define utime _wutime\n+# undef chmod\n+# define chmod _wchmod\n+#endif\n+\n+namespace fs = std::filesystem;\n+\n+fs::path\n+fs::absolute(const path& p)\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  error_code ec;\n+  path ret = absolute(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot make absolute path\", p,\n+\tstd::make_error_code(errc::not_supported)));\n+  return ret;\n+#else\n+  return current_path() / p;\n+#endif\n+}\n+\n+fs::path\n+fs::absolute(const path& p, error_code& ec)\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  ec = std::make_error_code(errc::not_supported);\n+  return {};\n+#else\n+  ec.clear();\n+  return current_path() / p;\n+#endif\n+}\n+\n+namespace\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  inline bool is_dot(wchar_t c) { return c == L'.'; }\n+#else\n+  inline bool is_dot(char c) { return c == '.'; }\n+#endif\n+\n+  inline bool is_dot(const fs::path& path)\n+  {\n+    const auto& filename = path.native();\n+    return filename.size() == 1 && is_dot(filename[0]);\n+  }\n+\n+  inline bool is_dotdot(const fs::path& path)\n+  {\n+    const auto& filename = path.native();\n+    return filename.size() == 2 && is_dot(filename[0]) && is_dot(filename[1]);\n+  }\n+\n+  struct free_as_in_malloc\n+  {\n+    void operator()(void* p) const { ::free(p); }\n+  };\n+\n+  using char_ptr = std::unique_ptr<char[], free_as_in_malloc>;\n+}\n+\n+fs::path\n+fs::canonical(const path& p, error_code& ec)\n+{\n+  path result;\n+  const path pa = absolute(p, ec);\n+  if (ec)\n+    return result;\n+\n+#ifdef _GLIBCXX_USE_REALPATH\n+  char_ptr buf{ nullptr };\n+# if _XOPEN_VERSION < 700\n+  // Not safe to call realpath(path, NULL)\n+  buf.reset( (char*)::malloc(PATH_MAX) );\n+# endif\n+  if (char* rp = ::realpath(pa.c_str(), buf.get()))\n+    {\n+      if (buf == nullptr)\n+\tbuf.reset(rp);\n+      result.assign(rp);\n+      ec.clear();\n+      return result;\n+    }\n+  if (errno != ENAMETOOLONG)\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return result;\n+    }\n+#endif\n+\n+  if (!exists(pa, ec))\n+    {\n+      if (!ec)\n+\tec = make_error_code(std::errc::no_such_file_or_directory);\n+      return result;\n+    }\n+  // else: we know there are (currently) no unresolvable symlink loops\n+\n+  result = pa.root_path();\n+\n+  deque<path> cmpts;\n+  for (auto& f : pa.relative_path())\n+    cmpts.push_back(f);\n+\n+  int max_allowed_symlinks = 40;\n+\n+  while (!cmpts.empty() && !ec)\n+    {\n+      path f = std::move(cmpts.front());\n+      cmpts.pop_front();\n+\n+      if (f.empty())\n+\t{\n+\t  // ignore empty element\n+\t}\n+      else if (is_dot(f))\n+\t{\n+\t  if (!is_directory(result, ec) && !ec)\n+\t    ec.assign(ENOTDIR, std::generic_category());\n+\t}\n+      else if (is_dotdot(f))\n+\t{\n+\t  auto parent = result.parent_path();\n+\t  if (parent.empty())\n+\t    result = pa.root_path();\n+\t  else\n+\t    result.swap(parent);\n+\t}\n+      else\n+\t{\n+\t  result /= f;\n+\n+\t  if (is_symlink(result, ec))\n+\t    {\n+\t      path link = read_symlink(result, ec);\n+\t      if (!ec)\n+\t\t{\n+\t\t  if (--max_allowed_symlinks == 0)\n+\t\t    ec.assign(ELOOP, std::generic_category());\n+\t\t  else\n+\t\t    {\n+\t\t      if (link.is_absolute())\n+\t\t\t{\n+\t\t\t  result = link.root_path();\n+\t\t\t  link = link.relative_path();\n+\t\t\t}\n+\t\t      else\n+\t\t\tresult = result.parent_path();\n+\n+\t\t      cmpts.insert(cmpts.begin(), link.begin(), link.end());\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (ec || !exists(result, ec))\n+    result.clear();\n+\n+  return result;\n+}\n+\n+fs::path\n+fs::canonical(const path& p)\n+{\n+  error_code ec;\n+  path res = canonical(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot make canonical path\",\n+\t\t\t\t\t     p, ec));\n+  return res;\n+}\n+\n+void\n+fs::copy(const path& from, const path& to, copy_options options)\n+{\n+  error_code ec;\n+  copy(from, to, options, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy\", from, to, ec));\n+}\n+\n+namespace std::filesystem\n+{\n+  // Need this as there's no 'perm_options::none' enumerator.\n+  inline bool is_set(fs::perm_options obj, fs::perm_options bits)\n+  {\n+    return (obj & bits) != fs::perm_options{};\n+  }\n+}\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+bool\n+fs::do_copy_file(const char* from, const char* to,\n+\t\t copy_options_existing_file options,\n+\t\t stat_type* from_st, stat_type* to_st,\n+\t\t std::error_code& ec) noexcept\n+{\n+  stat_type st1, st2;\n+  fs::file_status t, f;\n+\n+  if (to_st == nullptr)\n+    {\n+      if (::stat(to, &st1))\n+\t{\n+\t  const int err = errno;\n+\t  if (!is_not_found_errno(err))\n+\t    {\n+\t      ec.assign(err, std::generic_category());\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\tto_st = &st1;\n+    }\n+  else if (to_st == from_st)\n+    to_st = nullptr;\n+\n+  if (to_st == nullptr)\n+    t = fs::file_status{fs::file_type::not_found};\n+  else\n+    t = make_file_status(*to_st);\n+\n+  if (from_st == nullptr)\n+    {\n+      if (::stat(from, &st2))\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return false;\n+\t}\n+      else\n+\tfrom_st = &st2;\n+    }\n+  f = make_file_status(*from_st);\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2712. copy_file() has a number of unspecified error conditions\n+  if (!is_regular_file(f))\n+    {\n+      ec = std::make_error_code(std::errc::not_supported);\n+      return false;\n+    }\n+\n+  if (exists(t))\n+    {\n+      if (!is_regular_file(t))\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_supported);\n+\t  return false;\n+\t}\n+\n+      if (to_st->st_dev == from_st->st_dev\n+\t  && to_st->st_ino == from_st->st_ino)\n+\t{\n+\t  ec = std::make_error_code(std::errc::file_exists);\n+\t  return false;\n+\t}\n+\n+      if (options.skip)\n+\t{\n+\t  ec.clear();\n+\t  return false;\n+\t}\n+      else if (options.update)\n+\t{\n+\t  const auto from_mtime = file_time(*from_st, ec);\n+\t  if (ec)\n+\t    return false;\n+\t  if ((from_mtime <= file_time(*to_st, ec)) || ec)\n+\t    return false;\n+\t}\n+      else if (!options.overwrite)\n+\t{\n+\t  ec = std::make_error_code(std::errc::file_exists);\n+\t  return false;\n+\t}\n+      else if (!is_regular_file(t))\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_supported);\n+\t  return false;\n+\t}\n+    }\n+\n+  struct CloseFD {\n+    ~CloseFD() { if (fd != -1) ::close(fd); }\n+    bool close() { return ::close(std::exchange(fd, -1)) == 0; }\n+    int fd;\n+  };\n+\n+  CloseFD in = { ::open(from, O_RDONLY) };\n+  if (in.fd == -1)\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+  int oflag = O_WRONLY|O_CREAT;\n+  if (options.overwrite || options.update)\n+    oflag |= O_TRUNC;\n+  else\n+    oflag |= O_EXCL;\n+  CloseFD out = { ::open(to, oflag, S_IWUSR) };\n+  if (out.fd == -1)\n+    {\n+      if (errno == EEXIST && options.skip)\n+\tec.clear();\n+      else\n+\tec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+\n+#ifdef _GLIBCXX_USE_FCHMOD\n+  if (::fchmod(out.fd, from_st->st_mode))\n+#elif defined _GLIBCXX_USE_FCHMODAT\n+  if (::fchmodat(AT_FDCWD, to, from_st->st_mode, 0))\n+#else\n+  if (::chmod(to, from_st->st_mode))\n+#endif\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+\n+#ifdef _GLIBCXX_USE_SENDFILE\n+  off_t offset = 0;\n+  const auto n = ::sendfile(out.fd, in.fd, &offset, from_st->st_size);\n+  if (n < 0 && (errno == ENOSYS || errno == EINVAL))\n+    {\n+#endif // _GLIBCXX_USE_SENDFILE\n+      __gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);\n+      __gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);\n+      if (sbin.is_open())\n+\tin.fd = -1;\n+      if (sbout.is_open())\n+\tout.fd = -1;\n+      if (from_st->st_size && !(std::ostream(&sbout) << &sbin))\n+\t{\n+\t  ec = std::make_error_code(std::errc::io_error);\n+\t  return false;\n+\t}\n+      if (!sbout.close() || !sbin.close())\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return false;\n+\t}\n+\n+      ec.clear();\n+      return true;\n+\n+#ifdef _GLIBCXX_USE_SENDFILE\n+    }\n+  if (n != from_st->st_size)\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+  if (!out.close() || !in.close())\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+\n+  ec.clear();\n+  return true;\n+#endif // _GLIBCXX_USE_SENDFILE\n+}\n+#endif // _GLIBCXX_HAVE_SYS_STAT_H\n+\n+void\n+fs::copy(const path& from, const path& to, copy_options options,\n+\t error_code& ec) noexcept\n+{\n+  const bool skip_symlinks = is_set(options, copy_options::skip_symlinks);\n+  const bool create_symlinks = is_set(options, copy_options::create_symlinks);\n+  const bool copy_symlinks = is_set(options, copy_options::copy_symlinks);\n+  const bool use_lstat = create_symlinks || skip_symlinks;\n+\n+  file_status f, t;\n+  stat_type from_st, to_st;\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2681. filesystem::copy() cannot copy symlinks\n+  if (use_lstat || copy_symlinks\n+      ? ::lstat(from.c_str(), &from_st)\n+      : ::stat(from.c_str(), &from_st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return;\n+    }\n+  if (use_lstat\n+      ? ::lstat(to.c_str(), &to_st)\n+      : ::stat(to.c_str(), &to_st))\n+    {\n+      if (!is_not_found_errno(errno))\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return;\n+\t}\n+      t = file_status{file_type::not_found};\n+    }\n+  else\n+    t = make_file_status(to_st);\n+  f = make_file_status(from_st);\n+\n+  if (exists(t) && !is_other(t) && !is_other(f)\n+      && to_st.st_dev == from_st.st_dev && to_st.st_ino == from_st.st_ino)\n+    {\n+      ec = std::make_error_code(std::errc::file_exists);\n+      return;\n+    }\n+  if (is_other(f) || is_other(t))\n+    {\n+      ec = std::make_error_code(std::errc::not_supported);\n+      return;\n+    }\n+  if (is_directory(f) && is_regular_file(t))\n+    {\n+      ec = std::make_error_code(std::errc::is_a_directory);\n+      return;\n+    }\n+\n+  if (is_symlink(f))\n+    {\n+      if (skip_symlinks)\n+\tec.clear();\n+      else if (!exists(t) && copy_symlinks)\n+\tcopy_symlink(from, to, ec);\n+      else\n+\t// Not clear what should be done here.\n+\t// \"Otherwise report an error as specified in Error reporting (7).\"\n+\tec = std::make_error_code(std::errc::invalid_argument);\n+    }\n+  else if (is_regular_file(f))\n+    {\n+      if (is_set(options, copy_options::directories_only))\n+\tec.clear();\n+      else if (create_symlinks)\n+\tcreate_symlink(from, to, ec);\n+      else if (is_set(options, copy_options::create_hard_links))\n+\tcreate_hard_link(from, to, ec);\n+      else if (is_directory(t))\n+\tdo_copy_file(from.c_str(), (to / from.filename()).c_str(),\n+\t\t     copy_file_options(options), &from_st, nullptr, ec);\n+      else\n+\t{\n+\t  auto ptr = exists(t) ? &to_st : &from_st;\n+\t  do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),\n+\t\t       &from_st, ptr, ec);\n+\t}\n+    }\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2682. filesystem::copy() won't create a symlink to a directory\n+  else if (is_directory(f) && create_symlinks)\n+    ec = std::make_error_code(errc::is_a_directory);\n+  else if (is_directory(f) && (is_set(options, copy_options::recursive)\n+\t\t\t       || options == copy_options::none))\n+    {\n+      if (!exists(t))\n+\tif (!create_directory(to, from, ec))\n+\t  return;\n+      // set an unused bit in options to disable further recursion\n+      if (!is_set(options, copy_options::recursive))\n+\toptions |= static_cast<copy_options>(4096);\n+      for (const directory_entry& x : directory_iterator(from))\n+\tcopy(x.path(), to/x.path().filename(), options, ec);\n+    }\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 2683. filesystem::copy() says \"no effects\"\n+  else\n+    ec.clear();\n+}\n+\n+bool\n+fs::copy_file(const path& from, const path& to, copy_options option)\n+{\n+  error_code ec;\n+  bool result = copy_file(from, to, option, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy file\", from, to,\n+\t\t\t\t\t     ec));\n+  return result;\n+}\n+\n+bool\n+fs::copy_file(const path& from, const path& to, copy_options options,\n+\t      error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  return do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),\n+\t\t      nullptr, nullptr, ec);\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return false;\n+#endif\n+}\n+\n+\n+void\n+fs::copy_symlink(const path& existing_symlink, const path& new_symlink)\n+{\n+  error_code ec;\n+  copy_symlink(existing_symlink, new_symlink, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy symlink\",\n+\t  existing_symlink, new_symlink, ec));\n+}\n+\n+void\n+fs::copy_symlink(const path& existing_symlink, const path& new_symlink,\n+\t\t error_code& ec) noexcept\n+{\n+  auto p = read_symlink(existing_symlink, ec);\n+  if (ec)\n+    return;\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  if (is_directory(p))\n+    {\n+      create_directory_symlink(p, new_symlink, ec);\n+      return;\n+    }\n+#endif\n+  create_symlink(p, new_symlink, ec);\n+}\n+\n+\n+bool\n+fs::create_directories(const path& p)\n+{\n+  error_code ec;\n+  bool result = create_directories(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directories\", p,\n+\t\t\t\t\t     ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directories(const path& p, error_code& ec) noexcept\n+{\n+  if (p.empty())\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return false;\n+    }\n+  std::stack<path> missing;\n+  path pp = p;\n+\n+  while (pp.has_filename() && status(pp, ec).type() == file_type::not_found)\n+    {\n+      ec.clear();\n+      const auto& filename = pp.filename();\n+      if (!is_dot(filename) && !is_dotdot(filename))\n+\tmissing.push(pp);\n+      pp = pp.parent_path();\n+\n+      if (missing.size() > 1000) // sanity check\n+\t{\n+\t  ec = std::make_error_code(std::errc::filename_too_long);\n+\t  return false;\n+\t}\n+    }\n+\n+  if (ec || missing.empty())\n+    return false;\n+\n+  do\n+    {\n+      const path& top = missing.top();\n+      create_directory(top, ec);\n+      if (ec && is_directory(top))\n+\tec.clear();\n+      missing.pop();\n+    }\n+  while (!missing.empty() && !ec);\n+\n+  return missing.empty();\n+}\n+\n+namespace\n+{\n+  bool\n+  create_dir(const fs::path& p, fs::perms perm, std::error_code& ec)\n+  {\n+    bool created = false;\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+    ::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);\n+    if (::mkdir(p.c_str(), mode))\n+      {\n+\tconst int err = errno;\n+\tif (err != EEXIST || !is_directory(p))\n+\t  ec.assign(err, std::generic_category());\n+\telse\n+\t  ec.clear();\n+      }\n+    else\n+      {\n+\tec.clear();\n+\tcreated = true;\n+      }\n+#else\n+    ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+    return created;\n+  }\n+} // namespace\n+\n+bool\n+fs::create_directory(const path& p)\n+{\n+  error_code ec;\n+  bool result = create_directory(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory\", p,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directory(const path& p, error_code& ec) noexcept\n+{\n+  return create_dir(p, perms::all, ec);\n+}\n+\n+\n+bool\n+fs::create_directory(const path& p, const path& attributes)\n+{\n+  error_code ec;\n+  bool result = create_directory(p, attributes, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory\", p,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directory(const path& p, const path& attributes,\n+\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  stat_type st;\n+  if (::stat(attributes.c_str(), &st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+  return create_dir(p, static_cast<perms>(st.st_mode), ec);\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return false;\n+#endif\n+}\n+\n+\n+void\n+fs::create_directory_symlink(const path& to, const path& new_symlink)\n+{\n+  error_code ec;\n+  create_directory_symlink(to, new_symlink, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory symlink\",\n+\t  to, new_symlink, ec));\n+}\n+\n+void\n+fs::create_directory_symlink(const path& to, const path& new_symlink,\n+\t\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  ec = std::make_error_code(std::errc::not_supported);\n+#else\n+  create_symlink(to, new_symlink, ec);\n+#endif\n+}\n+\n+\n+void\n+fs::create_hard_link(const path& to, const path& new_hard_link)\n+{\n+  error_code ec;\n+  create_hard_link(to, new_hard_link, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create hard link\",\n+\t  to, new_hard_link, ec));\n+}\n+\n+void\n+fs::create_hard_link(const path& to, const path& new_hard_link,\n+\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (::link(to.c_str(), new_hard_link.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+void\n+fs::create_symlink(const path& to, const path& new_symlink)\n+{\n+  error_code ec;\n+  create_symlink(to, new_symlink, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create symlink\",\n+\t  to, new_symlink, ec));\n+}\n+\n+void\n+fs::create_symlink(const path& to, const path& new_symlink,\n+\t\t   error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (::symlink(to.c_str(), new_symlink.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+\n+fs::path\n+fs::current_path()\n+{\n+  error_code ec;\n+  path p = current_path(ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get current path\", ec));\n+  return p;\n+}\n+\n+fs::path\n+fs::current_path(error_code& ec)\n+{\n+  path p;\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#ifdef __GLIBC__\n+  if (char_ptr cwd = char_ptr{::getcwd(nullptr, 0)})\n+    {\n+      p.assign(cwd.get());\n+      ec.clear();\n+    }\n+  else\n+    ec.assign(errno, std::generic_category());\n+#else\n+  long path_max = pathconf(\".\", _PC_PATH_MAX);\n+  size_t size;\n+  if (path_max == -1)\n+      size = 1024;\n+  else if (path_max > 10240)\n+      size = 10240;\n+  else\n+      size = path_max;\n+  for (char_ptr buf; p.empty(); size *= 2)\n+    {\n+      buf.reset((char*)malloc(size));\n+      if (buf)\n+\t{\n+\t  if (getcwd(buf.get(), size))\n+\t    {\n+\t      p.assign(buf.get());\n+\t      ec.clear();\n+\t    }\n+\t  else if (errno != ERANGE)\n+\t    {\n+\t      ec.assign(errno, std::generic_category());\n+\t      return {};\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_enough_memory);\n+\t  return {};\n+\t}\n+    }\n+#endif  // __GLIBC__\n+#else   // _GLIBCXX_HAVE_UNISTD_H\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return p;\n+}\n+\n+void\n+fs::current_path(const path& p)\n+{\n+  error_code ec;\n+  current_path(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set current path\", ec));\n+}\n+\n+void\n+fs::current_path(const path& p, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (::chdir(p.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+bool\n+fs::equivalent(const path& p1, const path& p2)\n+{\n+  error_code ec;\n+  auto result = equivalent(p1, p2, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot check file equivalence\",\n+\t  p1, p2, ec));\n+  return result;\n+}\n+\n+bool\n+fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  int err = 0;\n+  file_status s1, s2;\n+  stat_type st1, st2;\n+  if (::stat(p1.c_str(), &st1) == 0)\n+    s1 = make_file_status(st1);\n+  else if (is_not_found_errno(errno))\n+    s1.type(file_type::not_found);\n+  else\n+    err = errno;\n+\n+  if (::stat(p2.c_str(), &st2) == 0)\n+    s2 = make_file_status(st2);\n+  else if (is_not_found_errno(errno))\n+    s2.type(file_type::not_found);\n+  else\n+    err = errno;\n+\n+  if (exists(s1) && exists(s2))\n+    {\n+      if (is_other(s1) && is_other(s2))\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_supported);\n+\t  return false;\n+\t}\n+      ec.clear();\n+      if (is_other(s1) || is_other(s2))\n+\treturn false;\n+      return st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;\n+    }\n+  else if (!exists(s1) && !exists(s2))\n+    ec = std::make_error_code(std::errc::no_such_file_or_directory);\n+  else if (err)\n+    ec.assign(err, std::generic_category());\n+  else\n+    ec.clear();\n+  return false;\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return false;\n+}\n+\n+std::uintmax_t\n+fs::file_size(const path& p)\n+{\n+  error_code ec;\n+  auto sz = file_size(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get file size\", p, ec));\n+  return sz;\n+}\n+\n+namespace\n+{\n+  template<typename Accessor, typename T>\n+    inline T\n+    do_stat(const fs::path& p, std::error_code& ec, Accessor f, T deflt)\n+    {\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+      fs::stat_type st;\n+      if (::stat(p.c_str(), &st))\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return deflt;\n+\t}\n+      ec.clear();\n+      return f(st);\n+#else\n+      ec = std::make_error_code(std::errc::not_supported);\n+      return deflt;\n+#endif\n+    }\n+}\n+\n+std::uintmax_t\n+fs::file_size(const path& p, error_code& ec) noexcept\n+{\n+  struct S\n+  {\n+    S(const stat_type& st) : type(make_file_type(st)), size(st.st_size) { }\n+    S() : type(file_type::not_found) { }\n+    file_type type;\n+    size_t size;\n+  };\n+  auto s = do_stat(p, ec, [](const auto& st) { return S{st}; }, S{});\n+  if (s.type == file_type::regular)\n+    return s.size;\n+  if (!ec)\n+    {\n+      if (s.type == file_type::directory)\n+\tec = std::make_error_code(std::errc::is_a_directory);\n+      else\n+\tec = std::make_error_code(std::errc::not_supported);\n+    }\n+  return -1;\n+}\n+\n+std::uintmax_t\n+fs::hard_link_count(const path& p)\n+{\n+  error_code ec;\n+  auto count = hard_link_count(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get link count\", p, ec));\n+  return count;\n+}\n+\n+std::uintmax_t\n+fs::hard_link_count(const path& p, error_code& ec) noexcept\n+{\n+  return do_stat(p, ec, std::mem_fn(&stat::st_nlink),\n+\t\t static_cast<uintmax_t>(-1));\n+}\n+\n+bool\n+fs::is_empty(const path& p)\n+{\n+  error_code ec;\n+  bool e = is_empty(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot check if file is empty\",\n+\t\t\t\t\t     p, ec));\n+  return e;\n+}\n+\n+bool\n+fs::is_empty(const path& p, error_code& ec) noexcept\n+{\n+  auto s = status(p, ec);\n+  if (ec)\n+    return false;\n+  bool empty = fs::is_directory(s)\n+    ? fs::directory_iterator(p, ec) == fs::directory_iterator()\n+    : fs::file_size(p, ec) == 0;\n+  return ec ? false : empty;\n+}\n+\n+fs::file_time_type\n+fs::last_write_time(const path& p)\n+{\n+  error_code ec;\n+  auto t = last_write_time(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get file time\", p, ec));\n+  return t;\n+}\n+\n+fs::file_time_type\n+fs::last_write_time(const path& p, error_code& ec) noexcept\n+{\n+  return do_stat(p, ec, [&ec](const auto& st) { return file_time(st, ec); },\n+\t\t file_time_type::min());\n+}\n+\n+void\n+fs::last_write_time(const path& p, file_time_type new_time)\n+{\n+  error_code ec;\n+  last_write_time(p, new_time, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set file time\", p, ec));\n+}\n+\n+void\n+fs::last_write_time(const path& p __attribute__((__unused__)),\n+\t\t    file_time_type new_time, error_code& ec) noexcept\n+{\n+  auto d = new_time.time_since_epoch();\n+  auto s = chrono::duration_cast<chrono::seconds>(d);\n+#if _GLIBCXX_USE_UTIMENSAT\n+  auto ns = chrono::duration_cast<chrono::nanoseconds>(d - s);\n+  if (ns < ns.zero()) // tv_nsec must be non-negative and less than 10e9.\n+    {\n+      --s;\n+      ns += chrono::seconds(1);\n+    }\n+  struct ::timespec ts[2];\n+  ts[0].tv_sec = 0;\n+  ts[0].tv_nsec = UTIME_OMIT;\n+  ts[1].tv_sec = static_cast<std::time_t>(s.count());\n+  ts[1].tv_nsec = static_cast<long>(ns.count());\n+  if (::utimensat(AT_FDCWD, p.c_str(), ts, 0))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#elif _GLIBCXX_HAVE_UTIME_H\n+  ::utimbuf times;\n+  times.modtime = s.count();\n+  times.actime = do_stat(p, ec, [](const auto& st) { return st.st_atime; },\n+\t\t\t times.modtime);\n+  if (::utime(p.c_str(), &times))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+void\n+fs::permissions(const path& p, perms prms, perm_options opts)\n+{\n+  error_code ec;\n+  permissions(p, prms, opts, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set permissions\", p, ec));\n+}\n+\n+void\n+fs::permissions(const path& p, perms prms, perm_options opts,\n+\t\terror_code& ec) noexcept\n+{\n+  const bool replace = is_set(opts, perm_options::replace);\n+  const bool add = is_set(opts, perm_options::add);\n+  const bool remove = is_set(opts, perm_options::remove);\n+  const bool nofollow = is_set(opts, perm_options::nofollow);\n+  if (((int)replace + (int)add + (int)remove) != 1)\n+    {\n+      ec = std::make_error_code(std::errc::invalid_argument);\n+      return;\n+    }\n+\n+  prms &= perms::mask;\n+\n+  file_status st;\n+  if (add || remove || nofollow)\n+    {\n+      st = nofollow ? symlink_status(p, ec) : status(p, ec);\n+      if (ec)\n+\treturn;\n+      auto curr = st.permissions();\n+      if (add)\n+\tprms |= curr;\n+      else if (remove)\n+\tprms = curr & ~prms;\n+    }\n+\n+  int err = 0;\n+#if _GLIBCXX_USE_FCHMODAT\n+  const int flag = (nofollow && is_symlink(st)) ? AT_SYMLINK_NOFOLLOW : 0;\n+  if (::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), flag))\n+    err = errno;\n+#else\n+  if (nofollow && is_symlink(st))\n+    ec = std::make_error_code(std::errc::operation_not_supported);\n+  else if (::chmod(p.c_str(), static_cast<mode_t>(prms)))\n+    err = errno;\n+#endif\n+\n+  if (err)\n+    ec.assign(err, std::generic_category());\n+  else\n+    ec.clear();\n+}\n+\n+fs::path\n+fs::proximate(const path& p, const path& base)\n+{\n+  return weakly_canonical(p).lexically_proximate(weakly_canonical(base));\n+}\n+\n+fs::path\n+fs::proximate(const path& p, const path& base, error_code& ec)\n+{\n+  path result;\n+  const auto p2 = weakly_canonical(p, ec);\n+  if (!ec)\n+    {\n+      const auto base2 = weakly_canonical(base, ec);\n+      if (!ec)\n+\tresult = p2.lexically_proximate(base2);\n+    }\n+  return result;\n+}\n+\n+fs::path\n+fs::read_symlink(const path& p)\n+{\n+  error_code ec;\n+  path tgt = read_symlink(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"read_symlink\", p, ec));\n+  return tgt;\n+}\n+\n+fs::path fs::read_symlink(const path& p, error_code& ec)\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  stat_type st;\n+  if (::lstat(p.c_str(), &st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return {};\n+    }\n+  std::string buf(st.st_size, '\\0');\n+  ssize_t len = ::readlink(p.c_str(), &buf.front(), buf.size());\n+  if (len == -1)\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return {};\n+    }\n+  ec.clear();\n+  return path{buf.data(), buf.data()+len};\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return {};\n+#endif\n+}\n+\n+fs::path\n+fs::relative(const path& p, const path& base)\n+{\n+  return weakly_canonical(p).lexically_relative(weakly_canonical(base));\n+}\n+\n+fs::path\n+fs::relative(const path& p, const path& base, error_code& ec)\n+{\n+  auto result = weakly_canonical(p, ec);\n+  fs::path cbase;\n+  if (!ec)\n+    cbase = weakly_canonical(base, ec);\n+  if (!ec)\n+    result = result.lexically_relative(cbase);\n+  if (ec)\n+    result.clear();\n+  return result;\n+}\n+\n+bool\n+fs::remove(const path& p)\n+{\n+  error_code ec;\n+  bool result = fs::remove(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot remove\", p, ec));\n+  return result;\n+}\n+\n+bool\n+fs::remove(const path& p, error_code& ec) noexcept\n+{\n+  if (exists(symlink_status(p, ec)))\n+    {\n+      if (::remove(p.c_str()) == 0)\n+\t{\n+\t  ec.clear();\n+\t  return true;\n+\t}\n+      else\n+\tec.assign(errno, std::generic_category());\n+    }\n+  return false;\n+}\n+\n+\n+std::uintmax_t\n+fs::remove_all(const path& p)\n+{\n+  error_code ec;\n+  bool result = remove_all(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot remove all\", p, ec));\n+  return result;\n+}\n+\n+std::uintmax_t\n+fs::remove_all(const path& p, error_code& ec) noexcept\n+{\n+  auto fs = symlink_status(p, ec);\n+  uintmax_t count = 0;\n+  if (!ec && fs.type() == file_type::directory)\n+    for (directory_iterator d(p, ec), end; !ec && d != end; ++d)\n+      count += fs::remove_all(d->path(), ec);\n+  if (ec)\n+    return -1;\n+  return fs::remove(p, ec) ? ++count : -1;  // fs:remove() calls ec.clear()\n+}\n+\n+void\n+fs::rename(const path& from, const path& to)\n+{\n+  error_code ec;\n+  rename(from, to, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot rename\", from, to, ec));\n+}\n+\n+void\n+fs::rename(const path& from, const path& to, error_code& ec) noexcept\n+{\n+  if (::rename(from.c_str(), to.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+}\n+\n+void\n+fs::resize_file(const path& p, uintmax_t size)\n+{\n+  error_code ec;\n+  resize_file(p, size, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot resize file\", p, ec));\n+}\n+\n+void\n+fs::resize_file(const path& p, uintmax_t size, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (size > static_cast<uintmax_t>(std::numeric_limits<off_t>::max()))\n+    ec.assign(EINVAL, std::generic_category());\n+  else if (::truncate(p.c_str(), size))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+\n+fs::space_info\n+fs::space(const path& p)\n+{\n+  error_code ec;\n+  space_info s = space(p, ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get free space\", p, ec));\n+  return s;\n+}\n+\n+fs::space_info\n+fs::space(const path& p, error_code& ec) noexcept\n+{\n+  space_info info = {\n+    static_cast<uintmax_t>(-1),\n+    static_cast<uintmax_t>(-1),\n+    static_cast<uintmax_t>(-1)\n+  };\n+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n+  struct ::statvfs f;\n+  if (::statvfs(p.c_str(), &f))\n+      ec.assign(errno, std::generic_category());\n+  else\n+    {\n+      info = space_info{\n+\tf.f_blocks * f.f_frsize,\n+\tf.f_bfree * f.f_frsize,\n+\tf.f_bavail * f.f_frsize\n+      };\n+      ec.clear();\n+    }\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return info;\n+}\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+fs::file_status\n+fs::status(const fs::path& p, error_code& ec) noexcept\n+{\n+  file_status status;\n+  stat_type st;\n+  if (::stat(p.c_str(), &st))\n+    {\n+      int err = errno;\n+      ec.assign(err, std::generic_category());\n+      if (is_not_found_errno(err))\n+\tstatus.type(file_type::not_found);\n+#ifdef EOVERFLOW\n+      else if (err == EOVERFLOW)\n+\tstatus.type(file_type::unknown);\n+#endif\n+    }\n+  else\n+    {\n+      status = make_file_status(st);\n+      ec.clear();\n+    }\n+  return status;\n+}\n+\n+fs::file_status\n+fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept\n+{\n+  file_status status;\n+  stat_type st;\n+  if (::lstat(p.c_str(), &st))\n+    {\n+      int err = errno;\n+      ec.assign(err, std::generic_category());\n+      if (is_not_found_errno(err))\n+\tstatus.type(file_type::not_found);\n+    }\n+  else\n+    {\n+      status = make_file_status(st);\n+      ec.clear();\n+    }\n+  return status;\n+}\n+#endif\n+\n+fs::file_status\n+fs::status(const fs::path& p)\n+{\n+  std::error_code ec;\n+  auto result = status(p, ec);\n+  if (result.type() == file_type::none)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"status\", p, ec));\n+  return result;\n+}\n+\n+fs::file_status\n+fs::symlink_status(const fs::path& p)\n+{\n+  std::error_code ec;\n+  auto result = symlink_status(p, ec);\n+  if (result.type() == file_type::none)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"symlink_status\", p, ec));\n+  return result;\n+}\n+\n+fs::path fs::temp_directory_path()\n+{\n+  error_code ec;\n+  path tmp = temp_directory_path(ec);\n+  if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"temp_directory_path\", ec));\n+  return tmp;\n+}\n+\n+fs::path fs::temp_directory_path(error_code& ec)\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return {}; // TODO\n+#else\n+  const char* tmpdir = nullptr;\n+  const char* env[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\", nullptr };\n+  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)\n+    tmpdir = ::getenv(*e);\n+  path p = tmpdir ? tmpdir : \"/tmp\";\n+  auto st = status(p, ec);\n+  if (!ec)\n+    {\n+      if (is_directory(st))\n+\t{\n+\t  ec.clear();\n+\t  return p;\n+\t}\n+      else\n+\tec = std::make_error_code(std::errc::not_a_directory);\n+    }\n+  return {};\n+#endif\n+}\n+\n+fs::path\n+fs::weakly_canonical(const path& p)\n+{\n+  path result;\n+  if (exists(status(p)))\n+    return canonical(p);\n+\n+  path tmp;\n+  auto iter = p.begin(), end = p.end();\n+  // find leading elements of p that exist:\n+  while (iter != end)\n+    {\n+      tmp = result / *iter;\n+      if (exists(status(tmp)))\n+\tswap(result, tmp);\n+      else\n+\tbreak;\n+      ++iter;\n+    }\n+  // canonicalize:\n+  result = canonical(result);\n+  // append the non-existing elements:\n+  while (iter != end)\n+    result /= *iter++;\n+  // normalize:\n+  return result.lexically_normal();\n+}\n+\n+fs::path\n+fs::weakly_canonical(const path& p, error_code& ec)\n+{\n+  path result;\n+  file_status st = status(p, ec);\n+  if (exists(st))\n+    return canonical(p, ec);\n+  else if (status_known(st))\n+    ec.clear();\n+  else\n+    return result;\n+\n+  path tmp;\n+  auto iter = p.begin(), end = p.end();\n+  // find leading elements of p that exist:\n+  while (iter != end)\n+    {\n+      tmp = result / *iter;\n+      st = status(tmp, ec);\n+      if (exists(st))\n+\tswap(result, tmp);\n+      else\n+\t{\n+\t  if (status_known(st))\n+\t    ec.clear();\n+\t  break;\n+\t}\n+      ++iter;\n+    }\n+  // canonicalize:\n+  if (!ec)\n+    result = canonical(result, ec);\n+  if (ec)\n+    result.clear();\n+  else\n+    {\n+      // append the non-existing elements:\n+      while (iter != end)\n+\tresult /= *iter++;\n+      // normalize:\n+      result = result.lexically_normal();\n+    }\n+  return result;\n+}"}, {"sha": "b5dd36d6ad1876f0b6f4e700bacf200f02b994b1", "filename": "libstdc++-v3/src/filesystem/std-path.cc", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,688 @@\n+// Class filesystem::path -*- C++ -*-\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_USE_CXX11_ABI\n+# define _GLIBCXX_USE_CXX11_ABI 1\n+#endif\n+\n+#include <filesystem>\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+# include <algorithm>\n+#endif\n+\n+namespace fs = std::filesystem;\n+using fs::path;\n+\n+fs::filesystem_error::~filesystem_error() = default;\n+\n+constexpr path::value_type path::preferred_separator;\n+\n+path&\n+path::remove_filename()\n+{\n+  if (_M_type == _Type::_Multi)\n+    {\n+      if (!_M_cmpts.empty())\n+\t{\n+\t  auto cmpt = std::prev(_M_cmpts.end());\n+\t  if (cmpt->_M_type == _Type::_Filename && !cmpt->empty())\n+\t    {\n+\t      _M_pathname.erase(cmpt->_M_pos);\n+\t      auto prev = std::prev(cmpt);\n+\t      if (prev->_M_type == _Type::_Root_dir\n+\t\t  || prev->_M_type == _Type::_Root_name)\n+\t\t{\n+\t\t  _M_cmpts.erase(cmpt);\n+\t\t  _M_trim();\n+\t\t}\n+\t      else\n+\t\tcmpt->clear();\n+\t    }\n+\t}\n+    }\n+  else if (_M_type == _Type::_Filename)\n+    clear();\n+  if (!empty() && _M_pathname.back() != '/')\n+    throw 1;\n+  return *this;\n+}\n+\n+path&\n+path::replace_filename(const path& replacement)\n+{\n+  remove_filename();\n+  operator/=(replacement);\n+  return *this;\n+}\n+\n+path&\n+path::replace_extension(const path& replacement)\n+{\n+  auto ext = _M_find_extension();\n+  // Any existing extension() is removed\n+  if (ext.first && ext.second != string_type::npos)\n+    {\n+      if (ext.first == &_M_pathname)\n+\t_M_pathname.erase(ext.second);\n+      else\n+\t{\n+\t  const auto& back = _M_cmpts.back();\n+\t  if (ext.first != &back._M_pathname)\n+\t    _GLIBCXX_THROW_OR_ABORT(\n+\t\tstd::logic_error(\"path::replace_extension failed\"));\n+\t  _M_pathname.erase(back._M_pos + ext.second);\n+\t}\n+    }\n+   // If replacement is not empty and does not begin with a dot character,\n+   // a dot character is appended\n+  if (!replacement.empty() && replacement.native()[0] != '.')\n+    _M_pathname += '.';\n+  operator+=(replacement);\n+  return *this;\n+}\n+\n+namespace\n+{\n+  template<typename Iter1, typename Iter2>\n+    int do_compare(Iter1 begin1, Iter1 end1, Iter2 begin2, Iter2 end2)\n+    {\n+      int cmpt = 1;\n+      while (begin1 != end1 && begin2 != end2)\n+\t{\n+\t  if (begin1->native() < begin2->native())\n+\t    return -cmpt;\n+\t  if (begin1->native() > begin2->native())\n+\t    return +cmpt;\n+\t  ++begin1;\n+\t  ++begin2;\n+\t  ++cmpt;\n+\t}\n+      if (begin1 == end1)\n+\t{\n+\t  if (begin2 == end2)\n+\t    return 0;\n+\t  return -cmpt;\n+\t}\n+      return +cmpt;\n+    }\n+}\n+\n+int\n+path::compare(const path& p) const noexcept\n+{\n+  struct CmptRef\n+  {\n+    const path* ptr;\n+    const string_type& native() const noexcept { return ptr->native(); }\n+  };\n+\n+  if (empty() && p.empty())\n+    return 0;\n+  else if (_M_type == _Type::_Multi && p._M_type == _Type::_Multi)\n+    return do_compare(_M_cmpts.begin(), _M_cmpts.end(),\n+\t\t      p._M_cmpts.begin(), p._M_cmpts.end());\n+  else if (_M_type == _Type::_Multi)\n+    {\n+      CmptRef c[1] = { { &p } };\n+      return do_compare(_M_cmpts.begin(), _M_cmpts.end(), c, c+1);\n+    }\n+  else if (p._M_type == _Type::_Multi)\n+    {\n+      CmptRef c[1] = { { this } };\n+      return do_compare(c, c+1, p._M_cmpts.begin(), p._M_cmpts.end());\n+    }\n+  else\n+    return _M_pathname.compare(p._M_pathname);\n+}\n+\n+path\n+path::root_name() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_name)\n+    __ret = *this;\n+  else if (_M_cmpts.size() && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+    __ret = *_M_cmpts.begin();\n+  return __ret;\n+}\n+\n+path\n+path::root_directory() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_dir)\n+    {\n+      __ret._M_type = _Type::_Root_dir;\n+      __ret._M_pathname.assign(1, preferred_separator);\n+    }\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        __ret = *__it;\n+    }\n+  return __ret;\n+}\n+\n+path\n+path::root_path() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_name)\n+    __ret = *this;\n+  else if (_M_type == _Type::_Root_dir)\n+    {\n+      __ret._M_pathname.assign(1, preferred_separator);\n+      __ret._M_type = _Type::_Root_dir;\n+    }\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        {\n+          __ret = *__it++;\n+          if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+\t    __ret /= *__it;\n+        }\n+      else if (__it->_M_type == _Type::_Root_dir)\n+        __ret = *__it;\n+    }\n+  return __ret;\n+}\n+\n+path\n+path::relative_path() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Filename)\n+    __ret = *this;\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        ++__it;\n+      if (__it != _M_cmpts.end())\n+        __ret.assign(_M_pathname.substr(__it->_M_pos));\n+    }\n+  return __ret;\n+}\n+\n+path\n+path::parent_path() const\n+{\n+  path __ret;\n+  if (!has_relative_path())\n+    __ret = *this;\n+  else if (_M_cmpts.size() >= 2)\n+    {\n+      for (auto __it = _M_cmpts.begin(), __end = std::prev(_M_cmpts.end());\n+\t   __it != __end; ++__it)\n+\t{\n+\t  __ret /= *__it;\n+\t}\n+    }\n+  return __ret;\n+}\n+\n+bool\n+path::has_root_name() const\n+{\n+  if (_M_type == _Type::_Root_name)\n+    return true;\n+  if (!_M_cmpts.empty() && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+    return true;\n+  return false;\n+}\n+\n+bool\n+path::has_root_directory() const\n+{\n+  if (_M_type == _Type::_Root_dir)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        return true;\n+    }\n+  return false;\n+}\n+\n+bool\n+path::has_root_path() const\n+{\n+  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __type = _M_cmpts.front()._M_type;\n+      if (__type == _Type::_Root_name || __type == _Type::_Root_dir)\n+        return true;\n+    }\n+  return false;\n+}\n+\n+bool\n+path::has_relative_path() const\n+{\n+  if (_M_type == _Type::_Filename)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        ++__it;\n+      if (__it != _M_cmpts.end())\n+        return true;\n+    }\n+  return false;\n+}\n+\n+\n+bool\n+path::has_parent_path() const\n+{\n+  if (!has_relative_path())\n+    return !empty();\n+  return _M_cmpts.size() >= 2;\n+}\n+\n+bool\n+path::has_filename() const\n+{\n+  if (empty())\n+    return false;\n+  if (_M_type == _Type::_Filename)\n+    return !_M_pathname.empty();\n+  if (_M_type == _Type::_Multi)\n+    {\n+      if (_M_pathname.back() == preferred_separator)\n+\treturn false;\n+      return _M_cmpts.back().has_filename();\n+    }\n+  return false;\n+}\n+\n+namespace\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  inline bool is_dot(wchar_t c) { return c == L'.'; }\n+#else\n+  inline bool is_dot(char c) { return c == '.'; }\n+#endif\n+\n+  inline bool is_dot(const fs::path& path)\n+  {\n+    const auto& filename = path.native();\n+    return filename.size() == 1 && is_dot(filename[0]);\n+  }\n+\n+  inline bool is_dotdot(const fs::path& path)\n+  {\n+    const auto& filename = path.native();\n+    return filename.size() == 2 && is_dot(filename[0]) && is_dot(filename[1]);\n+  }\n+} // namespace\n+\n+path\n+path::lexically_normal() const\n+{\n+  /*\n+  C++17 [fs.path.generic] p6\n+  - If the path is empty, stop.\n+  - Replace each slash character in the root-name with a preferred-separator.\n+  - Replace each directory-separator with a preferred-separator.\n+  - Remove each dot filename and any immediately following directory-separator.\n+  - As long as any appear, remove a non-dot-dot filename immediately followed\n+    by a directory-separator and a dot-dot filename, along with any immediately\n+    following directory-separator.\n+  - If the last filename is dot-dot, remove any trailing directory-separator.\n+  - If the path is empty, add a dot.\n+  */\n+  path ret;\n+  // If the path is empty, stop.\n+  if (empty())\n+    return ret;\n+  for (auto& p : *this)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      // Replace each slash character in the root-name\n+      if (p.is_root_name())\n+\t{\n+\t  string_type s = p.native();\n+\t  std::replace(s.begin(), s.end(), L'/', L'\\\\');\n+\t  ret /= s;\n+\t  continue;\n+\t}\n+#endif\n+      if (is_dotdot(p))\n+\t{\n+\t  if (ret.has_filename() && !is_dotdot(ret.filename()))\n+\t    ret.remove_filename();\n+\t  else\n+\t    ret /= p;\n+\t}\n+      else if (is_dot(p))\n+\tret /= path();\n+      else\n+\tret /= p;\n+    }\n+\n+  if (ret._M_cmpts.size() >= 2)\n+    {\n+      auto back = std::prev(ret.end());\n+      // If the last filename is dot-dot, ...\n+      if (back->empty() && is_dotdot(*std::prev(back)))\n+\t// ... remove any trailing directory-separator.\n+\tret = ret.parent_path();\n+    }\n+  // If the path is empty, add a dot.\n+  else if (ret.empty())\n+    ret = \".\";\n+\n+  return ret;\n+}\n+\n+path\n+path::lexically_relative(const path& base) const\n+{\n+  path ret;\n+  if (root_name() != base.root_name())\n+    return ret;\n+  if (is_absolute() != base.is_absolute())\n+    return ret;\n+  if (!has_root_directory() && base.has_root_directory())\n+    return ret;\n+  auto [a, b] = std::mismatch(begin(), end(), base.begin(), base.end());\n+  if (a == end() && b == base.end())\n+    ret = \".\";\n+  else\n+  {\n+    int n = 0;\n+    for (; b != base.end(); ++b)\n+    {\n+      const path& p = *b;\n+      if (is_dotdot(p))\n+\t--n;\n+      else if (!is_dot(p))\n+\t++n;\n+    }\n+    if (n >= 0)\n+    {\n+      const path dotdot(\"..\");\n+      while (n--)\n+\tret /= dotdot;\n+      for (; a != end(); ++a)\n+\tret /= *a;\n+    }\n+  }\n+  return ret;\n+}\n+\n+path\n+path::lexically_proximate(const path& base) const\n+{\n+  path rel = lexically_relative(base);\n+  if (rel.empty())\n+    rel = *this;\n+  return rel;\n+}\n+\n+std::pair<const path::string_type*, std::size_t>\n+path::_M_find_extension() const\n+{\n+  const std::string* s = nullptr;\n+\n+  if (_M_type == _Type::_Filename)\n+    s = &_M_pathname;\n+  else if (_M_type == _Type::_Multi && !_M_cmpts.empty())\n+    {\n+      const auto& c = _M_cmpts.back();\n+      if (c._M_type == _Type::_Filename)\n+\ts = &c._M_pathname;\n+    }\n+\n+  if (s)\n+    {\n+      if (auto sz = s->size())\n+\t{\n+\t  if (sz <= 2 && (*s)[0] == '.')\n+\t    return { s, string_type::npos };\n+\t  const auto pos = s->rfind('.');\n+\t  return { s, pos ? pos : string_type::npos };\n+\t}\n+    }\n+  return {};\n+}\n+\n+void\n+path::_M_split_cmpts()\n+{\n+  _M_type = _Type::_Multi;\n+  _M_cmpts.clear();\n+\n+  if (_M_pathname.empty())\n+    return;\n+\n+  size_t pos = 0;\n+  const size_t len = _M_pathname.size();\n+\n+  // look for root name or root directory\n+  if (_S_is_dir_sep(_M_pathname[0]))\n+    {\n+#ifdef __CYGWIN__\n+      // look for root name, such as \"//foo\"\n+      if (len > 2 && _M_pathname[1] == _M_pathname[0])\n+\t{\n+\t  if (!_S_is_dir_sep(_M_pathname[2]))\n+\t    {\n+\t      // got root name, find its end\n+\t      pos = 3;\n+\t      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))\n+\t\t++pos;\n+\t      _M_add_root_name(pos);\n+\t      if (pos < len) // also got root directory\n+\t\t_M_add_root_dir(pos);\n+\t    }\n+\t  else\n+\t    {\n+\t      // got something like \"///foo\" which is just a root directory\n+\t      // composed of multiple redundant directory separators\n+\t      _M_add_root_dir(0);\n+\t    }\n+\t}\n+      else\n+#endif\n+        {\n+\t  // got root directory\n+\t  if (_M_pathname.find_first_not_of('/') == string_type::npos)\n+\t    {\n+\t      // entire path is just slashes\n+\t      _M_type = _Type::_Root_dir;\n+\t      return;\n+\t    }\n+\t  _M_add_root_dir(0);\n+\t  ++pos;\n+\t}\n+    }\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  else if (len > 1 && _M_pathname[1] == L':')\n+    {\n+      // got disk designator\n+      _M_add_root_name(2);\n+      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))\n+\t_M_add_root_dir(2);\n+      pos = 2;\n+    }\n+#endif\n+\n+  size_t back = pos;\n+  while (pos < len)\n+    {\n+      if (_S_is_dir_sep(_M_pathname[pos]))\n+\t{\n+\t  if (back != pos)\n+\t    _M_add_filename(back, pos - back);\n+\t  back = ++pos;\n+\t}\n+      else\n+\t++pos;\n+    }\n+\n+  if (back != pos)\n+    _M_add_filename(back, pos - back);\n+  else if (_S_is_dir_sep(_M_pathname.back()))\n+    {\n+      // [fs.path.itr]/4\n+      // An empty element, if trailing non-root directory-separator present.\n+      if (_M_cmpts.back()._M_type == _Type::_Filename)\n+\t{\n+\t  const auto& last = _M_cmpts.back();\n+\t  pos = last._M_pos + last._M_pathname.size();\n+\t  _M_cmpts.emplace_back(string_type(), _Type::_Filename, pos);\n+\t}\n+    }\n+\n+  _M_trim();\n+}\n+\n+void\n+path::_M_add_root_name(size_t n)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(0, n), _Type::_Root_name, 0);\n+}\n+\n+void\n+path::_M_add_root_dir(size_t pos)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(pos, 1), _Type::_Root_dir, pos);\n+}\n+\n+void\n+path::_M_add_filename(size_t pos, size_t n)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(pos, n), _Type::_Filename, pos);\n+}\n+\n+void\n+path::_M_trim()\n+{\n+  if (_M_cmpts.size() == 1)\n+    {\n+      _M_type = _M_cmpts.front()._M_type;\n+      _M_cmpts.clear();\n+    }\n+}\n+\n+path::string_type\n+path::_S_convert_loc(const char* __first, const char* __last,\n+\t\t     const std::locale& __loc)\n+{\n+#if _GLIBCXX_USE_WCHAR_T\n+  auto& __cvt = std::use_facet<codecvt<wchar_t, char, mbstate_t>>(__loc);\n+  basic_string<wchar_t> __ws;\n+  if (!__str_codecvt_in(__first, __last, __ws, __cvt))\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"Cannot convert character sequence\",\n+\t  std::make_error_code(errc::illegal_byte_sequence)));\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  return __ws;\n+#else\n+  return _Cvt<wchar_t>::_S_convert(__ws.data(), __ws.data() + __ws.size());\n+#endif\n+#else\n+  return {__first, __last};\n+#endif\n+}\n+\n+std::size_t\n+fs::hash_value(const path& p) noexcept\n+{\n+  // [path.non-member]\n+  // \"If for two paths, p1 == p2 then hash_value(p1) == hash_value(p2).\"\n+  // Equality works as if by traversing the range [begin(), end()), meaning\n+  // e.g. path(\"a//b\") == path(\"a/b\"), so we cannot simply hash _M_pathname\n+  // but need to iterate over individual elements. Use the hash_combine from\n+  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf\n+  size_t seed = 0;\n+  for (const auto& x : p)\n+    {\n+      seed ^= std::hash<path::string_type>()(x.native()) + 0x9e3779b9\n+\t+ (seed<<6) + (seed>>2);\n+    }\n+  return seed;\n+}\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace filesystem\n+{\n+  string\n+  fs_err_concat(const string& __what, const string& __path1,\n+\t\t  const string& __path2)\n+  {\n+    const size_t __len = 18 + __what.length()\n+      + (__path1.length() ? __path1.length() + 3 : 0)\n+      + (__path2.length() ? __path2.length() + 3 : 0);\n+    string __ret;\n+    __ret.reserve(__len);\n+    __ret = \"filesystem error: \";\n+    __ret += __what;\n+    if (!__path1.empty())\n+      {\n+\t__ret += \" [\";\n+\t__ret += __path1;\n+\t__ret += ']';\n+      }\n+    if (!__path2.empty())\n+      {\n+\t__ret += \" [\";\n+\t__ret += __path2;\n+\t__ret += ']';\n+      }\n+    return __ret;\n+  }\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  std::string filesystem_error::_M_gen_what()\n+  {\n+    return fs_err_concat(system_error::what(), _M_path1.native(),\n+\t\t\t _M_path2.native());\n+  }\n+\n+_GLIBCXX_END_NAMESPACE_CXX11\n+\n+} // filesystem\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // std"}, {"sha": "c3e6f01670aeb50c36776d2910d90f99130cf389", "filename": "libstdc++-v3/testsuite/27_io/filesystem/iterators/directory_iterator.cc", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,150 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  // Test non-existent path.\n+  const auto p = __gnu_test::nonexistent_path();\n+  fs::directory_iterator iter(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test empty directory.\n+  create_directory(p, fs::current_path(), ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test non-empty directory.\n+  ec = bad_ec;\n+  create_directory_symlink(p, p / \"l\", ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != fs::directory_iterator() );\n+  VERIFY( iter->path() == p/\"l\" );\n+  ++iter;\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible directory.\n+  ec = bad_ec;\n+  permissions(p, fs::perms::none, ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible directory, skipping permission denied.\n+  const auto opts = fs::directory_options::skip_permission_denied;\n+  ec = bad_ec;\n+  iter = fs::directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == end(iter) );\n+\n+  permissions(p, fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  const auto p = __gnu_test::nonexistent_path();\n+  ec = bad_ec;\n+  create_directory(p, fs::current_path(), ec);\n+  create_directory_symlink(p, p / \"l\", ec);\n+  VERIFY( !ec );\n+\n+  // Test post-increment (libstdc++/71005)\n+  ec = bad_ec;\n+  auto iter = fs::directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != end(iter) );\n+  const auto entry1 = *iter;\n+  const auto entry2 = *iter++;\n+  VERIFY( entry1 == entry2 );\n+  VERIFY( entry1.path() == p/\"l\" );\n+  VERIFY( iter == end(iter) );\n+\n+  remove_all(p, ec);\n+}\n+\n+void\n+test03()\n+{\n+  std::error_code ec = make_error_code(std::errc::invalid_argument);\n+  const auto p = __gnu_test::nonexistent_path();\n+  create_directories(p / \"longer_than_small_string_buffer\", ec);\n+  VERIFY( !ec );\n+\n+  // Test for no reallocation on each dereference (this is a GNU extension)\n+  auto iter = fs::directory_iterator(p, ec);\n+  const auto* s1 = iter->path().c_str();\n+  const auto* s2 = iter->path().c_str();\n+  VERIFY( s1 == s2 );\n+\n+  remove_all(p, ec);\n+}\n+\n+void\n+test04()\n+{\n+  const fs::directory_iterator it;\n+  VERIFY( it == fs::directory_iterator() );\n+}\n+\n+void\n+test05()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  create_directory(p);\n+  create_directory_symlink(p, p / \"l\");\n+  fs::directory_iterator it(p), endit;\n+  VERIFY( begin(it) == it );\n+  static_assert( noexcept(begin(it)), \"begin is noexcept\" );\n+  VERIFY( end(it) == endit );\n+  static_assert( noexcept(end(it)), \"end is noexcept\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "02dc04f2ba9dd8b6862816f68794ff80477ae197", "filename": "libstdc++-v3/testsuite/27_io/filesystem/iterators/pop.cc", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fpop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fpop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Fpop.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,117 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec;\n+  fs::recursive_directory_iterator dir;\n+  dir.pop(ec);  // This is undefined, but our implementation\n+  VERIFY( ec ); // checks and returns an error.\n+  VERIFY( dir == end(dir) );\n+\n+  std::error_code ec2;\n+  try\n+  {\n+    dir.pop();\n+  }\n+  catch (const fs::filesystem_error& ex)\n+  {\n+    ec2 = ex.code();\n+  }\n+  VERIFY( ec2 == ec );\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  const auto p = __gnu_test::nonexistent_path();\n+  create_directories(p / \"d1/d2/d3\");\n+  for (int i = 0; i < 3; ++i)\n+  {\n+    fs::recursive_directory_iterator dir(p);\n+    VERIFY( dir != end(dir) );\n+    std::advance(dir, i);\n+    VERIFY( dir != end(dir) );\n+    VERIFY( dir.depth() == i );\n+    ec = bad_ec;\n+    dir.pop(ec);\n+    VERIFY( !ec );\n+    VERIFY( dir == end(dir) );\n+\n+    dir = fs::recursive_directory_iterator(p);\n+    std::advance(dir, i);\n+    VERIFY( dir != end(dir) );\n+    VERIFY( dir.depth() == i );\n+    dir.pop();\n+    VERIFY( dir == end(dir) );\n+  }\n+  remove_all(p, ec);\n+}\n+\n+void\n+test03()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  const auto p = __gnu_test::nonexistent_path();\n+  create_directories(p / \"d1/d2/d3\");\n+  create_directories(p / \"d1/d2/e3\");\n+  create_directories(p / \"d1/e2/d3\");\n+  for (int i = 0; i < 3; ++i)\n+  {\n+    fs::recursive_directory_iterator dir(p);\n+    std::advance(dir, i);\n+    VERIFY( dir != end(dir) );\n+    int expected_depth = i;\n+    VERIFY( dir.depth() == expected_depth );\n+    ec = bad_ec;\n+    dir.pop(ec);\n+    VERIFY( !ec );\n+    if (dir != end(dir))\n+      VERIFY( dir.depth() == (expected_depth - 1) );\n+\n+    dir = fs::recursive_directory_iterator(p);\n+    std::advance(dir, i);\n+    VERIFY( dir != end(dir) );\n+    VERIFY( dir.depth() == i );\n+    dir.pop();\n+    if (dir != end(dir))\n+      VERIFY( dir.depth() == (i -1) );\n+  }\n+  remove_all(p, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "1ef450fc9072997beaf8a28c36e80cf8fd35aa69", "filename": "libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,188 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  // Test non-existent path.\n+  const auto p = __gnu_test::nonexistent_path();\n+  fs::recursive_directory_iterator iter(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test empty directory.\n+  ec = bad_ec;\n+  create_directory(p, fs::current_path(), ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test non-empty directory.\n+  ec = bad_ec;\n+  create_directories(p / \"d1/d2\", ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != end(iter) );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  ++iter;\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible directory.\n+  ec = bad_ec;\n+  permissions(p, fs::perms::none, ec);\n+  VERIFY( !ec );\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible directory, skipping permission denied.\n+  const auto opts = fs::directory_options::skip_permission_denied;\n+  iter = fs::recursive_directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible sub-directory.\n+  ec = bad_ec;\n+  permissions(p, fs::perms::owner_all, ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  permissions(p/\"d1/d2\", fs::perms::none, ec);\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != end(iter) );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;              // should recurse into d1\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  iter.increment(ec);  // should fail to recurse into p/d1/d2\n+  VERIFY( ec );\n+  VERIFY( iter == end(iter) );\n+\n+  // Test inaccessible sub-directory, skipping permission denied.\n+  ec = bad_ec;\n+  iter = fs::recursive_directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != end(iter) );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;              // should recurse into d1\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  ec = bad_ec;\n+  iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it\n+  VERIFY( !ec );\n+  VERIFY( iter == end(iter) );\n+\n+  permissions(p/\"d1/d2\", fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  const auto p = __gnu_test::nonexistent_path();\n+  ec = bad_ec;\n+  create_directories(p / \"d1/d2\", ec);\n+  VERIFY( !ec );\n+\n+  // Test post-increment (libstdc++/71005)\n+  ec = bad_ec;\n+  auto iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != end(iter) );\n+  const auto entry1 = *iter;\n+  const auto entry2 = *iter++;\n+  VERIFY( entry1 == entry2 );\n+  VERIFY( entry1.path() == p/\"d1\" );\n+  const auto entry3 = *iter;\n+  const auto entry4 = *iter++;\n+  VERIFY( entry3 == entry4 );\n+  VERIFY( entry3.path() == p/\"d1/d2\" );\n+  VERIFY( iter == end(iter) );\n+\n+  remove_all(p, ec);\n+}\n+\n+void\n+test03()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  const auto p = __gnu_test::nonexistent_path();\n+  ec = bad_ec;\n+  create_directories(p / \"longer_than_small_string_buffer\", ec);\n+  VERIFY( !ec );\n+\n+  // Test for no reallocation on each dereference (this is a GNU extension)\n+  auto iter = fs::recursive_directory_iterator(p, ec);\n+  const auto* s1 = iter->path().c_str();\n+  const auto* s2 = iter->path().c_str();\n+  VERIFY( s1 == s2 );\n+\n+  remove_all(p, ec);\n+}\n+\n+void\n+test04()\n+{\n+  // libstdc++/71004\n+  const fs::recursive_directory_iterator it;\n+  VERIFY( it == end(it) );\n+}\n+\n+void\n+test05()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  create_directory(p);\n+  create_directory_symlink(p, p / \"l\");\n+  fs::recursive_directory_iterator it(p), endit;\n+  VERIFY( begin(it) == it );\n+  static_assert( noexcept(begin(it)), \"begin is noexcept\" );\n+  VERIFY( end(it) == endit );\n+  static_assert( noexcept(end(it)), \"end is noexcept\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "de1cd318f966459b4faac56a6bc61e2d9e7a09e2", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fabsolute.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fabsolute.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fabsolute.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.14.1 Absolute [fs.op.absolute]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+    VERIFY( absolute(p).is_absolute() );\n+}\n+\n+void\n+test02()\n+{\n+  path p1(\"/\");\n+  VERIFY( absolute(p1) == p1 );\n+  path p2(\"/foo\");\n+  VERIFY( absolute(p2) == p2 );\n+  path p3(\"foo\");\n+  VERIFY( absolute(p3) != p3 );\n+  VERIFY( absolute(p3) == (std::filesystem::current_path()/p3) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "646c37c4c3ccffd0c7944a383342bab55a174f97", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/canonical.cc", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcanonical.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcanonical.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcanonical.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,139 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  auto p = __gnu_test::nonexistent_path();\n+  canonical( p, ec );\n+  VERIFY( ec );\n+\n+  create_directory(p);\n+  auto p2 = canonical( p, ec );\n+  VERIFY( p2 == fs::current_path()/p );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p2 = canonical( fs::current_path() / \".\" / (p.native() + \"////././.\"), ec );\n+  VERIFY( p2 == fs::current_path()/p );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p = fs::current_path();\n+  p2 = canonical( p, ec );\n+  VERIFY( p2 == p );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p = \"/\";\n+  p = canonical( p, ec );\n+  VERIFY( p == \"/\" );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p = \"/.\";\n+  p = canonical( p, ec );\n+  VERIFY( p == \"/\" );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p = \"/..\";\n+  p = canonical( p, ec );\n+  VERIFY( p == \"/\" );\n+  VERIFY( !ec );\n+\n+  ec = bad_ec;\n+  p = \"/../.././.\";\n+  p = canonical( p, ec );\n+  VERIFY( p == \"/\" );\n+  VERIFY( !ec );\n+}\n+\n+void\n+test02()\n+{\n+  const fs::path p = __gnu_test::nonexistent_path();\n+  std::error_code ec, ec2;\n+  const fs::path res = canonical(p, ec);\n+  VERIFY( ec );\n+  VERIFY( res.empty() );\n+\n+#if __cpp_exceptions\n+  fs::path e1, e2;\n+  try {\n+    canonical(p);\n+  } catch (const fs::filesystem_error& e) {\n+    e1 = e.path1();\n+    e2 = e.path2();\n+    ec2 = e.code();\n+  }\n+  VERIFY( e1 == p );\n+  VERIFY( e2.empty() );\n+  VERIFY( ec == ec2 );\n+#endif\n+}\n+\n+\n+void\n+test03()\n+{\n+  std::error_code ec;\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  fs::path foo = dir/\"foo\", bar = dir/\"bar\";\n+  fs::create_directory(foo);\n+  fs::create_directory(bar);\n+  fs::create_symlink(\"../bar\", foo/\"baz\");\n+\n+  auto dirc = canonical(dir);\n+  auto barc = canonical(bar);\n+\n+  auto p1 = fs::canonical(dir/\"foo//.///..//./\");\n+  VERIFY( p1 == dirc );\n+  auto p2 = fs::canonical(dir/\"foo//./baz///..//./\");\n+  VERIFY( p2 == dirc );\n+  auto p3 = fs::canonical(dir/\"foo//./baz////./\");\n+  VERIFY( p3 == barc );\n+  auto p4 = fs::canonical(dir/\"foo//./baz///..//./bar\");\n+  VERIFY( p4 == barc );\n+  auto p5 = fs::canonical(dir/\"foo//./baz///..//./bar/\");\n+  VERIFY( p5 == p4 );\n+  auto p6 = fs::canonical(dir/\"foo//./baz///..//./bar/.\");\n+  VERIFY( p6 == p4 );\n+\n+  remove_all(dir);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "7825a4ef5dde704fc0c60ddc2d6a9ff0f8efe055", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,200 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 15.3 Copy [fs.op.copy]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+// Test error conditions.\n+void\n+test01()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  VERIFY( !fs::exists(p) );\n+  fs::copy(p, \".\", fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  ec.clear();\n+  fs::copy(\".\", \".\", fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  __gnu_test::scoped_file f(p);\n+  VERIFY( fs::is_directory(\".\") );\n+  VERIFY( fs::is_regular_file(p) );\n+  ec.clear();\n+  fs::copy(\".\", p, fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  auto to = __gnu_test::nonexistent_path();\n+  ec.clear();\n+  auto opts = fs::copy_options::create_symlinks;\n+  fs::copy(\"/\", to, opts, ec);\n+  VERIFY( ec == std::make_error_code(std::errc::is_a_directory) );\n+  VERIFY( !exists(to) );\n+\n+  ec.clear();\n+  opts != fs::copy_options::recursive;\n+  fs::copy(\"/\", to, opts, ec);\n+  VERIFY( ec == std::make_error_code(std::errc::is_a_directory) );\n+  VERIFY( !exists(to) );\n+}\n+\n+// Test is_symlink(f) case.\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  ec = bad_ec;\n+  fs::create_symlink(\".\", from, ec);\n+  VERIFY( !ec );\n+  VERIFY( fs::exists(from) );\n+\n+  ec = bad_ec;\n+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  ec = bad_ec;\n+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  ec = bad_ec;\n+  fs::copy(from, to,\n+           fs::copy_options::skip_symlinks|fs::copy_options::copy_symlinks,\n+           ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  ec = bad_ec;\n+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( fs::exists(to) );\n+  VERIFY( is_symlink(to) );\n+\n+  ec.clear();\n+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);\n+  VERIFY( ec );\n+\n+  remove(from, ec);\n+  remove(to, ec);\n+}\n+\n+// Test is_regular_file(f) case.\n+void\n+test03()\n+{\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+\n+  // test empty file\n+  std::ofstream{from.native()};\n+  VERIFY( fs::exists(from) );\n+  VERIFY( fs::file_size(from) == 0 );\n+  fs::copy(from, to);\n+  VERIFY( fs::exists(to) );\n+  VERIFY( fs::file_size(to) == 0 );\n+\n+  remove(to);\n+  VERIFY( !fs::exists(to) );\n+  std::ofstream{from.native()} << \"Hello, filesystem!\";\n+  VERIFY( fs::file_size(from) != 0 );\n+  fs::copy(from, to);\n+  VERIFY( fs::exists(to) );\n+  VERIFY( fs::file_size(to) == fs::file_size(from) );\n+\n+  remove(from);\n+  remove(to);\n+}\n+\n+// Test is_directory(f) case.\n+void\n+test04()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  create_directories(from/\"a/b/c\");\n+\n+  {\n+    __gnu_test::scoped_file f(to);\n+    copy(from, to, ec);\n+    VERIFY( ec );\n+  }\n+\n+  __gnu_test::scoped_file f1(from/\"a/f1\");\n+  std::ofstream{f1.path} << \"file one\";\n+  __gnu_test::scoped_file f2(from/\"a/b/f2\");\n+  std::ofstream{f2.path} << \"file two\";\n+\n+  copy(from, to, ec);\n+  VERIFY( !ec );\n+  VERIFY( exists(to) && is_empty(to) );\n+  remove(to);\n+\n+  ec = bad_ec;\n+  copy(from, to, fs::copy_options::recursive, ec);\n+  VERIFY( !ec );\n+  VERIFY( exists(to) && !is_empty(to) );\n+  VERIFY( is_regular_file(to/\"a/f1\") && !is_empty(to/\"a/f1\") );\n+  VERIFY( file_size(from/\"a/f1\") == file_size(to/\"a/f1\") );\n+  VERIFY( is_regular_file(to/\"a/b/f2\") && !is_empty(to/\"a/b/f2\") );\n+  VERIFY( file_size(from/\"a/b/f2\") == file_size(to/\"a/b/f2\") );\n+  VERIFY( is_directory(to/\"a/b/c\") && is_empty(to/\"a/b/c\") );\n+\n+  f1.path.clear();\n+  f2.path.clear();\n+  remove_all(from, ec);\n+  remove_all(to, ec);\n+}\n+\n+// Test no-op cases.\n+void\n+test05()\n+{\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec = std::make_error_code(std::errc::invalid_argument);\n+\n+  fs::copy(\"/\", to, fs::copy_options::copy_symlinks, ec);\n+  VERIFY( !ec );  // Previous value should be cleared (LWG 2683)\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "69ab7fbab8d5e6643a5b69a34f88d9995a21eda5", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/copy_file.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy_file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy_file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcopy_file.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// 15.4 Copy [fs.op.copy_file]\n+\n+#include <filesystem>\n+#include <fstream>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using std::filesystem::copy_options;\n+  std::error_code ec;\n+\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+\n+  // test non-existent file\n+  bool b = copy_file(from, to, ec);\n+  VERIFY( !b );\n+  VERIFY( ec );\n+  VERIFY( !exists(to) );\n+\n+  // test empty file\n+  std::ofstream{from.native()};\n+  VERIFY( exists(from) );\n+  VERIFY( file_size(from) == 0 );\n+\n+  b = copy_file(from, to);\n+  VERIFY( b );\n+  VERIFY( exists(to) );\n+  VERIFY( file_size(to) == 0 );\n+  remove(to);\n+  VERIFY( !exists(to) );\n+  b = copy_file(from, to, copy_options::none, ec);\n+  VERIFY( b );\n+  VERIFY( !ec );\n+  VERIFY( exists(to) );\n+  VERIFY( file_size(to) == 0 );\n+\n+  std::ofstream{from.native()} << \"Hello, filesystem!\";\n+  VERIFY( file_size(from) != 0 );\n+  remove(to);\n+  VERIFY( !exists(to) );\n+  b = copy_file(from, to);\n+  VERIFY( b );\n+  VERIFY( exists(to) );\n+  VERIFY( file_size(to) == file_size(from) );\n+  remove(to);\n+  VERIFY( !exists(to) );\n+  b = copy_file(from, to);\n+  VERIFY( b );\n+  VERIFY( exists(to) );\n+  VERIFY( file_size(to) == file_size(from) );\n+\n+  remove(from);\n+  remove(to);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "94596787196be3a50f42e06e8c4a1bb19ad4b0f1", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directories.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directories.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directories.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  // Test empty path.\n+  bool b = fs::create_directories( \"\", ec );\n+  VERIFY( ec );\n+  VERIFY( !b );\n+\n+  // Test existing path.\n+  ec = bad_ec;\n+  b = fs::create_directories( fs::current_path(), ec );\n+  VERIFY( !ec );\n+  VERIFY( !b );\n+\n+  // Test non-existent path.\n+  const auto p = __gnu_test::nonexistent_path();\n+  ec = bad_ec;\n+  b = fs::create_directories( p, ec );\n+  VERIFY( !ec );\n+  VERIFY( b );\n+  VERIFY( is_directory(p) );\n+\n+  ec = bad_ec;\n+  b = fs::create_directories( p/\".\", ec );\n+  VERIFY( !ec );\n+  VERIFY( !b );\n+\n+  ec = bad_ec;\n+  b = fs::create_directories( p/\"..\", ec );\n+  VERIFY( !ec );\n+  VERIFY( !b );\n+\n+  ec = bad_ec;\n+  b = fs::create_directories( p/\"d1/d2/d3\", ec );\n+  VERIFY( !ec );\n+  VERIFY( b );\n+  VERIFY( is_directory(p/\"d1/d2/d3\") );\n+\n+  ec = bad_ec;\n+  b = fs::create_directories( p/\"./d4/../d5\", ec );\n+  VERIFY( !ec );\n+  VERIFY( b );\n+  VERIFY( is_directory(p/\"./d4/../d5\") );\n+\n+  std::uintmax_t count = remove_all(p, ec);\n+  VERIFY( count == 6 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "927a97c7a84492dfa089c201113479f58837be36", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_directory.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  // Test empty path.\n+  fs::path p;\n+  bool b = create_directory( p, ec );\n+  VERIFY( ec );\n+  VERIFY( !b );\n+\n+  // Test non-existent path\n+  p = __gnu_test::nonexistent_path();\n+  VERIFY( !exists(p) );\n+\n+  ec = bad_ec;\n+  b = create_directory(p, ec); // create the directory once\n+  VERIFY( !ec );\n+  VERIFY( b );\n+  VERIFY( exists(p) );\n+\n+  // Test existing path (libstdc++/71036).\n+  ec = bad_ec;\n+  b = create_directory(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( !b );\n+  b = create_directory(p);\n+  VERIFY( !b );\n+\n+  remove_all(p, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "7eff356b883872090cbb90f2f1933bc7e69994f2", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/create_symlink.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_symlink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_symlink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcreate_symlink.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec, ec2;\n+  __gnu_test::scoped_file f;\n+  auto tgt = f.path;\n+\n+  // Test empty path.\n+  fs::path p;\n+  create_symlink(tgt, p, ec );\n+  VERIFY( ec );\n+  try\n+  {\n+    create_symlink(tgt, p);\n+  }\n+  catch (const std::filesystem::filesystem_error& ex)\n+  {\n+    ec2 = ex.code();\n+    VERIFY( ex.path1() == tgt );\n+    VERIFY( ex.path2() == p );\n+  }\n+  VERIFY( ec2 == ec );\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec, ec2;\n+  __gnu_test::scoped_file f;\n+  auto tgt = f.path;\n+\n+  // Test non-existent path\n+  auto p = __gnu_test::nonexistent_path();\n+  VERIFY( !exists(p) );\n+\n+  ec = bad_ec;\n+  create_symlink(tgt, p, ec); // create the symlink once\n+  VERIFY( !ec );\n+  VERIFY( exists(p) );\n+  VERIFY( is_symlink(p) );\n+  remove(p);\n+  create_symlink(tgt, p); // create the symlink again\n+  VERIFY( exists(p) );\n+  VERIFY( is_symlink(p) );\n+\n+  ec.clear();\n+  create_symlink(tgt, p, ec); // Try to create existing symlink\n+  VERIFY( ec );\n+  try\n+  {\n+    create_symlink(tgt, p);\n+  }\n+  catch (const std::filesystem::filesystem_error& ex)\n+  {\n+    ec2 = ex.code();\n+    VERIFY( ex.path1() == tgt );\n+    VERIFY( ex.path2() == p );\n+  }\n+  VERIFY( ec2 == ec );\n+\n+  remove(p);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "2ba3ff9fc5359ffbc6ffe012cfb7705997a32637", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/current_path.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcurrent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcurrent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fcurrent_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 15.11 Current path [fs.op.current_path]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  fs::path dot(\".\");\n+  fs::path cwd = fs::current_path();\n+  std::error_code ec;\n+  fs::path cwd2 = fs::current_path(ec);\n+  VERIFY( cwd == cwd2 );\n+}\n+\n+void\n+test02()\n+{\n+  auto oldwd = fs::current_path();\n+  auto tmpdir = fs::temp_directory_path();\n+  current_path(tmpdir);\n+  VERIFY( canonical(fs::current_path()) == canonical(tmpdir) );\n+  std::error_code ec;\n+  current_path(oldwd, ec);\n+  VERIFY( canonical(fs::current_path()) == canonical(oldwd) );\n+  VERIFY( canonical(fs::current_path(ec)) == canonical(oldwd) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "92d69c604ac2fbbe86c5e6ba4fd17f49df393342", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/equivalent.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fequivalent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fequivalent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fequivalent.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  auto p1 = __gnu_test::nonexistent_path();\n+  auto p2 = __gnu_test::nonexistent_path();\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+  bool result;\n+\n+  result = equivalent(p1, p2, ec);\n+  VERIFY( ec );\n+  VERIFY( !result );\n+\n+  __gnu_test::scoped_file f1(p1);\n+  ec = bad_ec;\n+  result = equivalent(p1, p2, ec);\n+  VERIFY( !ec );\n+  VERIFY( !result );\n+\n+  __gnu_test::scoped_file f2(p2);\n+  ec = bad_ec;\n+  result = equivalent(p1, p2, ec);\n+  VERIFY( !ec );\n+  VERIFY( !result );\n+\n+  auto p3 = __gnu_test::nonexistent_path();\n+  create_hard_link(p1, p3, ec);\n+  if (ec)\n+    return;  // hard links not supported\n+  __gnu_test::scoped_file f3(p3, __gnu_test::scoped_file::adopt_file);\n+\n+  ec = bad_ec;\n+  result = equivalent(p1, p3, ec);\n+  VERIFY( !ec );\n+  VERIFY( result );\n+\n+  ec = bad_ec;\n+  result = equivalent(p2, p3, ec);\n+  VERIFY( !ec );\n+  VERIFY( !result );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "0775eff4d9bd8362e07d018438ef456f591b0a9a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fexists.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fexists.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fexists.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+\n+  VERIFY( exists(path{\"/\"}) );\n+  VERIFY( exists(path{\"/.\"}) );\n+  VERIFY( exists(path{\".\"}) );\n+  VERIFY( exists(path{\"..\"}) );\n+  VERIFY( exists(std::filesystem::current_path()) );\n+\n+  std::error_code ec;\n+  ec = bad_ec;\n+  VERIFY( exists(path{\"/\"}, ec) );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( exists(path{\"/.\"}, ec) );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( exists(path{\".\"}, ec) );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( exists(path{\"..\"}, ec) );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( exists(std::filesystem::current_path(), ec) );\n+  VERIFY( !ec );\n+}\n+\n+void\n+test02()\n+{\n+  path rel = __gnu_test::nonexistent_path();\n+  VERIFY( !exists(rel) );\n+\n+  std::error_code ec = std::make_error_code(std::errc::invalid_argument);\n+  VERIFY( !exists(rel, ec) );\n+  VERIFY( !ec ); // DR 2725\n+}\n+\n+void\n+test03()\n+{\n+  path abs = absolute(__gnu_test::nonexistent_path());\n+  VERIFY( !exists(abs) );\n+\n+  std::error_code ec = std::make_error_code(std::errc::invalid_argument);\n+  VERIFY( !exists(abs, ec) );\n+  VERIFY( !ec ); // DR 2725\n+}\n+\n+void\n+test04()\n+{\n+  using std::filesystem::perms;\n+  using std::filesystem::perm_options;\n+  path p = __gnu_test::nonexistent_path();\n+  create_directory(p);\n+  permissions(p, perms::all, perm_options::remove);\n+\n+  auto unr = p / \"unreachable\";\n+  std::error_code ec;\n+  VERIFY( !exists(unr, ec) );\n+  VERIFY( ec == std::errc::permission_denied );\n+  ec.clear();\n+  try\n+  {\n+    exists(unr);\n+  }\n+  catch(const std::filesystem::filesystem_error& ex)\n+  {\n+    ec = ex.code();\n+    VERIFY( ex.path1() == unr );\n+  }\n+  VERIFY( ec == std::errc::permission_denied );\n+\n+  permissions(p, perms::owner_all);\n+  remove(p);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "250d31891a0518f697fa9eb4323fde045db2761f", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/file_size.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ffile_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ffile_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ffile_size.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec;\n+  size_t size = fs::file_size(\".\", ec);\n+  VERIFY( ec == std::errc::is_a_directory );\n+  VERIFY( size == -1 );\n+\n+  try {\n+    size = fs::file_size(\".\");\n+    ec.clear();\n+  } catch (const fs::filesystem_error& e) {\n+    ec = e.code();\n+  }\n+  VERIFY( ec == std::errc::is_a_directory );\n+  VERIFY( size == -1 );\n+}\n+\n+void\n+test02()\n+{\n+  fs::path p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  size_t size = fs::file_size(p, ec);\n+  VERIFY( ec );\n+  VERIFY( size == -1 );\n+\n+  try {\n+    size = fs::file_size(p);\n+    ec.clear();\n+  } catch (const fs::filesystem_error& e) {\n+    ec = e.code();\n+  }\n+  VERIFY( ec );\n+  VERIFY( size == -1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "6d79a9139cfea976326a0d007949a94592dc50bb", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fis_empty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fis_empty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fis_empty.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  create_directory(p);\n+  permissions(p, fs::perms::none);\n+  std::error_code ec, ec2;\n+\n+  bool result = fs::is_empty(p, ec);\n+  VERIFY( ec == std::make_error_code(std::errc::permission_denied) );\n+  VERIFY( !result );\n+\n+  try {\n+    fs::is_empty(p);\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+\n+  result = fs::is_empty(p/\"f\", ec);\n+  VERIFY( ec == std::make_error_code(std::errc::permission_denied) );\n+  VERIFY( !result );\n+\n+  try {\n+    fs::is_empty(p/\"f\");\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+\n+  permissions(p, fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+void\n+test02()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  create_directory(p);\n+  std::error_code ec, bad_ec = make_error_code(std::errc::invalid_argument);\n+  bool empty;\n+\n+  ec = bad_ec;\n+  empty = is_empty(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( empty );\n+  empty = is_empty(p);\n+  VERIFY( empty );\n+\n+  __gnu_test::scoped_file f(p/\"f\");\n+  ec = bad_ec;\n+  empty = is_empty(f.path, ec);\n+  VERIFY( !ec );\n+  VERIFY( empty );\n+  empty = is_empty(f.path);\n+  VERIFY( empty );\n+\n+  std::ofstream{f.path.native()} << \"data\";\n+  ec = bad_ec;\n+  empty = is_empty(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( !empty );\n+  empty = is_empty(p);\n+  VERIFY( !empty );\n+\n+  ec = bad_ec;\n+  empty = is_empty(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( !empty );\n+  empty = is_empty(p);\n+  VERIFY( !empty );\n+\n+  f.path.clear();\n+  remove_all(p, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ecef3f8572159fdc1e0ad866b9ae3ff07a870f66", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,162 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// 15.25 Permissions [fs.op.last_write_time]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+#ifdef _GLIBCXX_HAVE_FCNTL_H\n+# include <fcntl.h>\n+#endif\n+#if _GLIBCXX_HAVE_UTIME_H\n+# include <utime.h>\n+#endif\n+\n+using time_type = std::filesystem::file_time_type;\n+\n+void\n+test01()\n+{\n+  // read times\n+\n+  auto p = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+  time_type mtime = last_write_time(p, ec);\n+  VERIFY( ec );\n+  VERIFY( ec == std::make_error_code(std::errc::no_such_file_or_directory) );\n+#if __cpp_exceptions\n+  bool caught = false;\n+  try {\n+    mtime = last_write_time(p);\n+  } catch (std::system_error const& e) {\n+    caught = true;\n+    ec = e.code();\n+  }\n+  VERIFY( caught );\n+  VERIFY( ec );\n+  VERIFY( ec == std::make_error_code(std::errc::no_such_file_or_directory) );\n+#endif\n+\n+  __gnu_test::scoped_file file(p);\n+  VERIFY( exists(p) );\n+  mtime = last_write_time(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( mtime <= time_type::clock::now() );\n+  VERIFY( mtime == last_write_time(p) );\n+\n+  auto end_of_time = time_type::duration::max();\n+  auto last_second\n+    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();\n+  if (last_second > std::numeric_limits<std::time_t>::max())\n+    return; // can't test overflow\n+\n+#if _GLIBCXX_USE_UTIMENSAT\n+  struct ::timespec ts[2];\n+  ts[0].tv_sec = 0;\n+  ts[0].tv_nsec = UTIME_NOW;\n+  ts[1].tv_sec = std::numeric_limits<std::time_t>::max() - 1;\n+  ts[1].tv_nsec = 0;\n+  VERIFY( !::utimensat(AT_FDCWD, p.c_str(), ts, 0) );\n+#elif _GLIBCXX_HAVE_UTIME_H\n+  ::utimbuf times;\n+  times.modtime = std::numeric_limits<std::time_t>::max() - 1;\n+  times.actime = std::numeric_limits<std::time_t>::max() - 1;\n+  VERIFY( !::utime(p.c_str(), &times) );\n+#else\n+  return;\n+#endif\n+\n+  mtime = last_write_time(p, ec);\n+  VERIFY( ec );\n+  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n+  VERIFY( mtime == time_type::min() );\n+\n+#if __cpp_exceptions\n+  caught = false;\n+  try {\n+    mtime = last_write_time(p);\n+  } catch (std::system_error const& e) {\n+    caught = true;\n+    ec = e.code();\n+  }\n+  VERIFY( caught );\n+  VERIFY( ec );\n+  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n+#endif\n+}\n+\n+bool approx_equal(time_type file_time, time_type expected)\n+{\n+  auto delta = expected - file_time;\n+  if (delta < delta.zero())\n+    delta = -delta;\n+  return delta < std::chrono::seconds(1);\n+}\n+\n+void\n+test02()\n+{\n+  // write times\n+\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  __gnu_test::scoped_file f;\n+  std::error_code ec;\n+  time_type time;\n+\n+  time = last_write_time(f.path);\n+  ec = bad_ec;\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+\n+  ec = bad_ec;\n+  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+\n+  ec = bad_ec;\n+  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+\n+  ec = bad_ec;\n+  time = time_type();\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+\n+  ec = bad_ec;\n+  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "97b7a7874f768049c9349a707fdc6ca874a22c30", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/permissions.cc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fpermissions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fpermissions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fpermissions.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,167 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// C++17 30.10.14.26 Permissions [fs.op.permissions]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using std::filesystem::perms;\n+  using std::filesystem::perm_options;\n+\n+  auto p = __gnu_test::nonexistent_path();\n+\n+  __gnu_test::scoped_file f(p);\n+  VERIFY( exists(p) );\n+  permissions(p, perms::owner_all);\n+  VERIFY( status(p).permissions() == perms::owner_all );\n+  permissions(p, perms::group_read, perm_options::add);\n+  VERIFY( status(p).permissions() == (perms::owner_all | perms::group_read) );\n+  permissions(p, perms::group_read, perm_options::remove);\n+  VERIFY( status(p).permissions() == perms::owner_all );\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  using std::filesystem::perms;\n+  using std::filesystem::perm_options;\n+\n+  auto p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  permissions(p, perms::owner_all, ec);\n+  VERIFY( ec );\n+\n+  __gnu_test::scoped_file f(p);\n+  VERIFY( exists(p) );\n+\n+  ec = bad_ec;\n+  permissions(p, perms::owner_all, ec);\n+  VERIFY( !ec );\n+  VERIFY( status(p).permissions() == perms::owner_all );\n+  ec = bad_ec;\n+  permissions(p, perms::group_read, perm_options::add, ec);\n+  VERIFY( !ec );\n+  VERIFY( status(p).permissions() == (perms::owner_all | perms::group_read) );\n+  ec = bad_ec;\n+  permissions(p, perms::group_read, perm_options::remove, ec);\n+  VERIFY( !ec );\n+  VERIFY( status(p).permissions() == perms::owner_all );\n+}\n+\n+void\n+test03()\n+{\n+  using std::filesystem::perms;\n+  using std::filesystem::perm_options;\n+\n+  __gnu_test::scoped_file f;\n+  VERIFY( exists(f.path) );\n+\n+  auto p = __gnu_test::nonexistent_path();\n+  create_symlink(f.path, p);\n+\n+  std::error_code ec = make_error_code(std::errc::no_such_file_or_directory);\n+  std::error_code ec2 = make_error_code(std::errc::invalid_argument);\n+  permissions(p, perms::owner_all,\n+\t      perm_options::replace|perm_options::nofollow, ec);\n+  try\n+  {\n+    permissions(p, perms::owner_all,\n+\t\tperm_options::replace|perm_options::nofollow);\n+  }\n+  catch (const std::filesystem::filesystem_error& ex)\n+  {\n+    ec2 = ex.code();\n+    VERIFY( ex.path1() == p );\n+  }\n+  // Both calls should succeed, or both should fail with same error:\n+  VERIFY( ec == ec2 );\n+\n+  remove(p);\n+}\n+\n+void\n+test04()\n+{\n+  using perms = std::filesystem::perms;\n+\n+  auto p = __gnu_test::nonexistent_path();\n+  create_symlink(__gnu_test::nonexistent_path(), p);\n+\n+  std::error_code ec = make_error_code(std::errc::no_such_file_or_directory);\n+  std::error_code ec2 = make_error_code(std::errc::invalid_argument);\n+  permissions(p, perms::owner_all, ec);\n+  VERIFY( ec );\n+  try\n+  {\n+    permissions(p, perms::owner_all);\n+  }\n+  catch (const std::filesystem::filesystem_error& ex)\n+  {\n+    ec2 = ex.code();\n+    VERIFY( ex.path1() == p );\n+  }\n+  VERIFY( ec == ec2 );\n+\n+  remove(p);\n+}\n+\n+void\n+test05()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  using std::filesystem::perms;\n+  using std::filesystem::perm_options;\n+  std::error_code ec;\n+\n+  __gnu_test::scoped_file f;\n+  auto p = perms::owner_write;\n+\n+  // symlink_nofollow should not give an error for non-symlinks\n+  ec = bad_ec;\n+  permissions(f.path, p, perm_options::replace|perm_options::nofollow, ec);\n+  VERIFY( !ec );\n+  auto st = status(f.path);\n+  VERIFY( st.permissions() == p );\n+  p |= perms::owner_read;\n+  ec = bad_ec;\n+  permissions(f.path, p, perm_options::replace|perm_options::nofollow, ec);\n+  VERIFY( !ec );\n+  st = status(f.path);\n+  VERIFY( st.permissions() == p );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "02da2507d4636c4ea66c5befe46726163f83880a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/proximate.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fproximate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fproximate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fproximate.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::proximate;\n+\n+void\n+test01()\n+{\n+  VERIFY( proximate(\"/a/d\", \"/a/b/c\") == \"../../d\" );\n+  VERIFY( proximate(\"/a/b/c\", \"/a/d\") == \"../b/c\" );\n+  VERIFY( proximate(\"a/b/c\", \"a\") == \"b/c\" );\n+  VERIFY( proximate(\"a/b/c\", \"a/b/c/x/y\") == \"../..\" );\n+  VERIFY( proximate(\"a/b/c\", \"a/b/c\") == \".\" );\n+  VERIFY( proximate(\"a/b\", \"c/d\") == \"../../a/b\" );\n+}\n+\n+void\n+test02()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec = bad_ec;\n+  VERIFY( proximate(\"/a/d\", \"/a/b/c\", ec) == \"../../d\" );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( proximate(\"/a/b/c\", \"/a/d\", ec) == \"../b/c\" );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( proximate(\"a/b/c\", \"a\", ec) == \"b/c\" );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( proximate(\"a/b/c\", \"a/b/c/x/y\", ec) == \"../..\" );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( proximate(\"a/b/c\", \"a/b/c\", ec) == \".\" );\n+  VERIFY( !ec );\n+  ec = bad_ec;\n+  VERIFY( proximate(\"a/b\", \"c/d\", ec) == \"../../a/b\" );\n+  VERIFY( !ec );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "067a60950ea1b964d673deee0fed52b673b8753d", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/read_symlink.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fread_symlink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fread_symlink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fread_symlink.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  read_symlink(p, ec);\n+  VERIFY( ec );\n+\n+  fs::path tgt = \".\";\n+  create_symlink(tgt, p);\n+\n+  auto result = read_symlink(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( result == tgt );\n+\n+  remove(p);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "c9765fa5680ba617c0cee08f2d14af83048b3437", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/relative.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Frelative.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Frelative.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Frelative.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  auto q = __gnu_test::nonexistent_path();\n+\n+  auto r = relative(p, q);\n+  VERIFY( r == \"..\"/p );\n+\n+  r = relative(p, p/q);\n+  VERIFY( r == \"..\" );\n+\n+  r = relative(p/q, p);\n+  VERIFY( r == q );\n+\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  ec = bad_ec;\n+  r = relative(p, q, ec);\n+  VERIFY( !ec );\n+  VERIFY( r == \"..\"/p );\n+\n+  ec = bad_ec;\n+  r = relative(p, p/q, ec);\n+  VERIFY( !ec );\n+  VERIFY( r == \"..\" );\n+\n+  ec = bad_ec;\n+  r = relative(p/q, p, ec);\n+  VERIFY( !ec );\n+  VERIFY( r == q );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "3f68f17f992c9cf482729612e237098e926c7e15", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec;\n+  std::uintmax_t n;\n+\n+  n = fs::remove_all(\"\", ec);\n+  VERIFY( ec );\n+  VERIFY( n == std::uintmax_t(-1) );\n+\n+  auto p = __gnu_test::nonexistent_path();\n+  ec.clear();\n+  n = remove_all(p, ec);\n+  VERIFY( ec );\n+  VERIFY( n == std::uintmax_t(-1) );\n+\n+  const auto bad_ec = ec;\n+  auto link = __gnu_test::nonexistent_path();\n+  create_symlink(p, link);  // dangling symlink\n+  ec = bad_ec;\n+  n = remove_all(link, ec);\n+  VERIFY( !ec );\n+  VERIFY( n == 1 );\n+  VERIFY( !exists(symlink_status(link)) ); // DR 2721\n+\n+  __gnu_test::scoped_file f(p);\n+  create_symlink(p, link);\n+  ec = bad_ec;\n+  n = remove_all(link, ec);\n+  VERIFY( !ec );\n+  VERIFY( n == 1 );\n+  VERIFY( !exists(symlink_status(link)) );  // The symlink is removed, but\n+  VERIFY( exists(p) );                      // its target is not.\n+\n+  auto dir = __gnu_test::nonexistent_path();\n+  create_directories(dir/\"a/b/c\");\n+  ec = bad_ec;\n+  n = remove_all(dir/\"a\", ec);\n+  VERIFY( !ec );\n+  VERIFY( n == 3 );\n+  VERIFY( exists(dir) );\n+  VERIFY( !exists(dir/\"a\") );\n+\n+  create_directories(dir/\"a/b/c\");\n+  __gnu_test::scoped_file a1(dir/\"a/1\");\n+  __gnu_test::scoped_file a2(dir/\"a/2\");\n+  __gnu_test::scoped_file b1(dir/\"a/b/1\");\n+  __gnu_test::scoped_file b2(dir/\"a/b/2\");\n+  ec = bad_ec;\n+  n = remove_all(dir, ec);\n+  VERIFY( !ec );\n+  VERIFY( n == 8 );\n+  VERIFY( !exists(dir) );\n+\n+  a1.path.clear();\n+  a2.path.clear();\n+  b1.path.clear();\n+  b2.path.clear();\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "7b61135296772d8ee1f91f8a70c31292aaa85b79", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/space.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fspace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fspace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fspace.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// 30.10.14.3 Permissions [fs.op.space]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::filesystem::space_info s = std::filesystem::space(\"/\");\n+  std::error_code ec = make_error_code(std::errc::invalid_argument);\n+  s = std::filesystem::space(\"/\", ec);\n+  VERIFY( !ec );\n+  s = std::filesystem::space(__gnu_test::nonexistent_path(), ec);\n+  VERIFY( ec );\n+  VERIFY( s.capacity ==  static_cast<uintmax_t>(-1) );\n+  VERIFY( s.free ==  static_cast<uintmax_t>(-1) );\n+  VERIFY( s.available ==  static_cast<uintmax_t>(-1) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "efe92b26a781c9e2ddab7e3dea4b78832c5cc32d", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fstatus.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fstatus.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fstatus.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  std::error_code ec = make_error_code(std::errc::invalid_argument);\n+  fs::path dot = \".\";\n+\n+  fs::file_status st1 = fs::status(dot, ec);\n+  VERIFY( !ec );\n+  VERIFY( st1.type() == fs::file_type::directory );\n+\n+  fs::file_status st2 = fs::status(dot);\n+  VERIFY( st2.type() == fs::file_type::directory );\n+}\n+\n+void\n+test02()\n+{\n+  fs::path p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  fs::file_status st1 = fs::status(p, ec);\n+  VERIFY( ec );\n+  VERIFY( st1.type() == fs::file_type::not_found );\n+\n+  fs::file_status st2 = fs::status(p);\n+  VERIFY( st2.type() == fs::file_type::not_found );\n+}\n+\n+void\n+test03()\n+{\n+  fs::path dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  __gnu_test::scoped_file d(dir, __gnu_test::scoped_file::adopt_file);\n+  __gnu_test::scoped_file f(dir / \"file\");\n+  fs::permissions(dir, fs::perms::none);\n+\n+  std::error_code ec;\n+  fs::file_status st = fs::status(f.path, ec);\n+  VERIFY( ec.value() == (int)std::errc::permission_denied );\n+  VERIFY( st.type() == fs::file_type::none );\n+\n+#if __cpp_exceptions\n+  bool caught = false;\n+  std::error_code ec2;\n+  fs::path p, p2;\n+  try {\n+    fs::symlink_status(f.path);\n+  } catch (const fs::filesystem_error& e) {\n+    caught = true;\n+    p = e.path1();\n+    p2 = e.path2();\n+    ec2 = e.code();\n+  }\n+  VERIFY( caught );\n+  VERIFY( ec2 == ec );\n+  VERIFY( p == f.path );\n+  VERIFY( p2.empty() );\n+#endif\n+\n+  fs::permissions(dir, fs::perms::owner_all, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "ae7a76be7c3e1c9596e46cc98d3143cdc95f6ba3", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fsymlink_status.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fsymlink_status.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fsymlink_status.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,118 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec = bad_ec;\n+  fs::path dot = \".\";\n+\n+  fs::file_status st1 = fs::symlink_status(dot, ec);\n+  VERIFY( !ec );\n+  VERIFY( st1.type() == fs::file_type::directory );\n+\n+  fs::file_status st2 = fs::symlink_status(dot);\n+  VERIFY( st2.type() == fs::file_type::directory );\n+\n+  fs::path link = __gnu_test::nonexistent_path();\n+  create_directory_symlink(dot, link);\n+\n+  st1 = fs::symlink_status(link);\n+  VERIFY( st1.type() == fs::file_type::symlink );\n+  ec = bad_ec;\n+  st2 = fs::symlink_status(link, ec);\n+  VERIFY( !ec );\n+  VERIFY( st2.type() == fs::file_type::symlink );\n+}\n+\n+void\n+test02()\n+{\n+  fs::path p = __gnu_test::nonexistent_path();\n+\n+  std::error_code ec;\n+  fs::file_status st1 = fs::symlink_status(p, ec);\n+  VERIFY( ec );\n+  VERIFY( st1.type() == fs::file_type::not_found );\n+\n+  fs::file_status st2 = fs::symlink_status(p);\n+  VERIFY( st2.type() == fs::file_type::not_found );\n+}\n+\n+void\n+test03()\n+{\n+  fs::path dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  __gnu_test::scoped_file d(dir, __gnu_test::scoped_file::adopt_file);\n+  __gnu_test::scoped_file f(dir / \"file\");\n+  fs::permissions(dir, fs::perms::none);\n+  auto link = __gnu_test::nonexistent_path();\n+  fs::create_symlink(f.path, link);\n+  __gnu_test::scoped_file l(link, __gnu_test::scoped_file::adopt_file);\n+\n+  std::error_code ec;\n+  fs::file_status st = fs::symlink_status(f.path, ec);\n+  VERIFY( ec.value() == (int)std::errc::permission_denied );\n+  VERIFY( st.type() == fs::file_type::none );\n+\n+  st = fs::symlink_status(link, ec);\n+  VERIFY( !ec );\n+  VERIFY( st.type() == fs::file_type::symlink );\n+\n+#if __cpp_exceptions\n+  bool caught = false;\n+  std::error_code ec2;\n+  fs::path p, p2;\n+  try {\n+    fs::symlink_status(f.path);\n+  } catch (const fs::filesystem_error& e) {\n+    caught = true;\n+    p = e.path1();\n+    p2 = e.path2();\n+    ec2 = e.code();\n+  }\n+  VERIFY( caught );\n+  VERIFY( ec2.value() == (int)std::errc::permission_denied );\n+  VERIFY( p == f.path );\n+  VERIFY( p2.empty() );\n+#endif\n+\n+  fs::file_status st2 = symlink_status(link);\n+  VERIFY( st2.type() == fs::file_type::symlink );\n+\n+  fs::permissions(dir, fs::perms::owner_all, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "ee065f0679fd980788208ad2487306de2f2c1689", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Ftemp_directory_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,127 @@\n+// Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <stdlib.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+void\n+clean_env()\n+{\n+  ::unsetenv(\"TMPDIR\");\n+  ::unsetenv(\"TMP\");\n+  ::unsetenv(\"TEMPDIR\");\n+  ::unsetenv(\"TEMP\");\n+}\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  clean_env();\n+\n+  if (!fs::exists(\"/tmp\"))\n+    return; // just give up\n+\n+  std::error_code ec = make_error_code(std::errc::invalid_argument);\n+  fs::path p1 = fs::temp_directory_path(ec);\n+  VERIFY( !ec );\n+  VERIFY( exists(p1) );\n+\n+  fs::path p2 = fs::temp_directory_path();\n+  VERIFY( p1 == p2 );\n+}\n+\n+void\n+test02()\n+{\n+  clean_env();\n+\n+  if (::setenv(\"TMPDIR\", __gnu_test::nonexistent_path().string().c_str(), 1))\n+    return; // just give up\n+\n+  std::error_code ec;\n+  fs::path p = fs::temp_directory_path(ec);\n+  VERIFY( ec );\n+  VERIFY( p == fs::path() );\n+\n+  std::error_code ec2;\n+  try {\n+    p = fs::temp_directory_path();\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+}\n+\n+void\n+test03()\n+{\n+  auto p = __gnu_test::nonexistent_path();\n+  create_directories(p/\"tmp\");\n+  permissions(p, fs::perms::none);\n+  setenv(\"TMPDIR\", (p/\"tmp\").c_str(), 1);\n+  std::error_code ec;\n+  auto r = fs::temp_directory_path(ec); // libstdc++/PR71337\n+  VERIFY( ec == std::make_error_code(std::errc::permission_denied) );\n+  VERIFY( r == fs::path() );\n+\n+  std::error_code ec2;\n+  try {\n+    fs::temp_directory_path();\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+\n+  permissions(p, fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+void\n+test04()\n+{\n+  __gnu_test::scoped_file f;\n+  setenv(\"TMPDIR\", f.path.c_str(), 1);\n+  std::error_code ec;\n+  auto r = fs::temp_directory_path(ec);\n+  VERIFY( ec == std::make_error_code(std::errc::not_a_directory) );\n+  VERIFY( r == fs::path() );\n+\n+  std::error_code ec2;\n+  try {\n+    fs::temp_directory_path();\n+  } catch (const fs::filesystem_error& e) {\n+    ec2 = e.code();\n+  }\n+  VERIFY( ec2 == ec );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "0f285e2bb59bbb77f21f78faaaedc0b4e7b28826", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/weakly_canonical.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fweakly_canonical.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fweakly_canonical.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fweakly_canonical.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::filesystem;\n+\n+void\n+test01()\n+{\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  const auto dirc = canonical(dir);\n+  fs::path foo = dir/\"foo\", bar = dir/\"bar\";\n+  fs::create_directory(foo);\n+  fs::create_directory(bar);\n+  fs::create_directory(bar/\"baz\");\n+  fs::create_symlink(\"../bar\", foo/\"bar\");\n+\n+  auto p = fs::weakly_canonical(dir/\"foo//./bar///../biz/.\");\n+  VERIFY( p == dirc/\"biz/\" );\n+  p = fs::weakly_canonical(dir/\"foo/.//bar/././baz/.\");\n+  VERIFY( p == dirc/\"bar/baz\" );\n+  p = fs::weakly_canonical(fs::current_path()/dir/\"bar//../foo/bar/baz\");\n+  VERIFY( p == dirc/\"bar/baz\" );\n+\n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n+  std::error_code ec;\n+\n+  ec = bad_ec;\n+  p = fs::weakly_canonical(dir/\"foo//./bar///../biz/.\", ec);\n+  VERIFY( !ec );\n+  VERIFY( p == dirc/\"biz/\" );\n+  ec = bad_ec;\n+  p = fs::weakly_canonical(dir/\"foo/.//bar/././baz/.\", ec);\n+  VERIFY( !ec );\n+  VERIFY( p == dirc/\"bar/baz\" );\n+  ec = bad_ec;\n+  p = fs::weakly_canonical(fs::current_path()/dir/\"bar//../foo/bar/baz\", ec);\n+  VERIFY( !ec );\n+  VERIFY( p == dirc/\"bar/baz\" );\n+\n+  fs::remove_all(dir, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "64c638ed1e395c6a153080d8c02bdd6759841158", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/append/path.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,87 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.3 path appends [path.append]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+\n+  path pp = p;\n+  pp /= p;\n+  VERIFY( pp.native() == p.native() );\n+\n+  path q(\"baz\");\n+\n+  path qq = q;\n+  qq /= q;\n+  VERIFY( qq.native() == \"baz/baz\" );\n+\n+  q /= p;\n+  VERIFY( q.native() == p.native() );\n+\n+  path r = \"\";\n+  r /= path();\n+  VERIFY( r.empty() );\n+\n+  r /= path(\"rel\");\n+  VERIFY( !r.is_absolute() );\n+\n+  path s = \"dir/\";\n+  s /= path(\"/file\");\n+  VERIFY( s.native() == \"/file\" );\n+\n+  s = \"dir/\";\n+  s /= path(\"file\");\n+  VERIFY( s.native() == \"dir/file\" );\n+}\n+\n+void\n+test02()\n+{\n+  // C++17 [fs.path.append] p4\n+\n+  path p = path(\"//host\") / \"foo\";\n+  VERIFY( p == \"//host/foo\" );\n+\n+  path pp = path(\"//host/\") / \"foo\";\n+  VERIFY( pp == \"//host/foo\" );\n+\n+  path q = path(\"foo\") / \"\";\n+  VERIFY( q == \"foo/\" );\n+\n+  path qq = path(\"foo\") / \"/bar\";\n+  VERIFY( qq == \"/bar\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d8797cae168c47ef08e4376ad9733624c47c4355", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/assign/assign.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,94 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p0 = s, p1, p2, p3, p4;\n+\n+    p1 = s;\n+    compare_paths(p0, p1);\n+\n+    p2 = s.c_str();\n+    compare_paths(p0, p2);\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring ws(s.begin(), s.end());\n+\n+    p3 = ws;\n+    compare_paths(p0, p3);\n+\n+    p4 = ws.c_str();\n+    compare_paths(p0, p4);\n+#endif\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p0 = s, p1, p2, p3, p4, p5, p6, p7, p8;\n+\n+    p1.assign(s);\n+    compare_paths(p0, p1);\n+\n+    p2.assign( s.begin(), s.end() );\n+    compare_paths(p0, p2);\n+\n+    p3.assign( s.c_str() );\n+    compare_paths(p0, p3);\n+\n+    p4.assign( s.c_str(), s.c_str() + s.size() );\n+    compare_paths(p0, p4);\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring ws(s.begin(), s.end());\n+\n+    p5.assign(ws);\n+    compare_paths(p0, p5);\n+\n+    p6.assign( ws.begin(), ws.end() );\n+    compare_paths(p0, p6);\n+\n+    p7.assign( ws.c_str() );\n+    compare_paths(p0, p7);\n+\n+    p8.assign( ws.c_str(), ws.c_str() + ws.size() );\n+    compare_paths(p0, p8);\n+#endif\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "27bf00ab126979028f90d859dbe5a41337996dd8", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy;\n+    copy = p;\n+    __gnu_test::compare_paths(p, copy);\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    path move;\n+    move = std::move(copy);\n+    __gnu_test::compare_paths(p, move);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e444220ec25e49376a7a63b2f0b11710df7e195f", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/compare.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/foo/bar\");\n+  VERIFY( p.compare(p) == 0 );\n+  VERIFY( p.compare(\"/foo//bar\") == 0 );\n+\n+  path q(\"/foo/baz\");\n+  VERIFY( p.compare(q) < 0 );\n+  VERIFY( q.compare(p) > 0 );\n+\n+  path r(\"/foo/bar/.\");\n+  VERIFY( p.compare(r) < 0 );\n+\n+  VERIFY( path(\"a/b/\").compare(\"a/b//\") == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4bed5a23fd55746adc91a6099978b09453be63ee", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/path.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p0 = \"/a/a/b/b\";\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.compare(p) == 0 );\n+    int cmp = p.compare(p0);\n+    if (cmp == 0)\n+      VERIFY( p0.compare(p) == 0 );\n+    else if (cmp < 0)\n+      VERIFY( p0.compare(p) > 0 );\n+    else if (cmp > 0)\n+      VERIFY( p0.compare(p) < 0 );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "be8f8b0d709e24aeddd6101b700af7623adedb8b", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/strings.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const std::string s0 = \"/a/a/b/b\";\n+  const path p0 = s0;\n+  for (const std::string& s : __gnu_test::test_paths)\n+  {\n+    path p(s);\n+    VERIFY( p.compare(s) == 0 );\n+    VERIFY( p.compare(s.c_str()) == 0 );\n+    VERIFY( p.compare(p0) == p.compare(s0) );\n+    VERIFY( p.compare(p0) == p.compare(s0.c_str()) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "46cf09abe164f9ca59c501512a06d50e9e6a971c", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/concat/path.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.4 path concatenation [path.concat]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+\n+  path pp = p;\n+  pp += p;\n+  VERIFY( pp.native() == \"/foo/bar/foo/bar\" );\n+  VERIFY( std::distance(pp.begin(), pp.end()) == 5 );\n+\n+  path q(\"foo/bar\");\n+\n+  path qq = q;\n+  qq += q;\n+  VERIFY( qq.native() == \"foo/barfoo/bar\" );\n+  VERIFY( std::distance(qq.begin(), qq.end()) == 3 );\n+\n+  q += p;\n+  VERIFY( q.native() == \"foo/bar/foo/bar\" );\n+  VERIFY( std::distance(q.begin(), q.end()) == 4 );\n+}\n+\n+void\n+test02()\n+{\n+  for (path p : __gnu_test::test_paths)\n+  {\n+    auto prior_native = p.native();\n+    path x(\"//blah/di/blah\");\n+    p += x;\n+    VERIFY( p.native() == prior_native + x.native() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "3eb4d1a3cb1af8027df2170d3126bf662f8eaa4a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.4 path concatenation [path.concat]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/\");\n+  p += path::string_type(\"foo\");\n+  VERIFY( p.filename() == \"foo\" );\n+  p += \"bar\";\n+  VERIFY( p.filename() == \"foobar\" );\n+  p += '/';\n+  VERIFY( p.parent_path() == \"/foobar\" && p.filename() == \"\" );\n+#if _GLIBCXX_USE_WCHAR_T\n+  p += L\"baz.txt\";\n+#else\n+  p += \"baz.txt\";\n+#endif\n+  VERIFY( p.filename() == \"baz.txt\" );\n+  p.concat(\"/dir/\");\n+  VERIFY( p.parent_path() == \"/foobar/baz.txt/dir\" && p.filename() == \"\" );\n+  std::string file = \"file\";\n+  p.concat(file.begin(), file.end());\n+  VERIFY( p.filename() == \"file\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "cb084bdfeda05063b0efca7f2883444faba6dcf9", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/copy.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    __gnu_test::compare_paths(p, copy);\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    path move = std::move(copy);\n+    __gnu_test::compare_paths(p, move);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "85ce129436da7721fd2273528d8dc390033f0dce", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/default.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p;\n+  VERIFY(  p.empty() );\n+  VERIFY( !p.has_root_path() );\n+  VERIFY( !p.has_root_name() );\n+  VERIFY( !p.has_root_directory() );\n+  VERIFY( !p.has_relative_path() );\n+  VERIFY( !p.has_parent_path() );\n+  VERIFY( !p.has_filename() );\n+  VERIFY( !p.has_stem() );\n+  VERIFY( !p.has_extension() );\n+  VERIFY( !p.is_absolute() );\n+  VERIFY(  p.is_relative() );\n+  VERIFY( std::distance(p.begin(), p.end()) == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "e313412386d175f07ad1c00d3ef7d7b532a9b416", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/locale.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/foo/bar\", std::locale::classic());\n+  VERIFY( p.string() == \"/foo/bar\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "ad2cc18e51256fa2077610ea2e122840bc726c66", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/range.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,112 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <filesystem>\n+#include <string>\n+#include <testsuite_fs.h>\n+#include <testsuite_iterators.h>\n+\n+using std::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p1 = s;\n+    path p2( s.begin(), s.end() );\n+    path p3( s.c_str() );\n+    path p4( s.c_str(), s.c_str() + s.size() );\n+\n+    compare_paths(p1, p2);\n+    compare_paths(p1, p3);\n+    compare_paths(p1, p4);\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring ws(s.begin(), s.end());\n+    path p5 = ws;\n+    path p6( ws.begin(), ws.end() );\n+    path p7( ws.c_str() );\n+    path p8( ws.c_str(), ws.c_str() + ws.size() );\n+\n+    compare_paths(p1, p5);\n+    compare_paths(p1, p6);\n+    compare_paths(p1, p7);\n+    compare_paths(p1, p8);\n+#endif\n+\n+    using __gnu_test::test_container;\n+    using __gnu_test::input_iterator_wrapper;\n+    // Test with input iterators and const value_types\n+\n+    test_container<char, input_iterator_wrapper>\n+      r1((char*)s.c_str(), (char*)s.c_str() + s.size());\n+    path p9(r1.begin(), r1.end());\n+    compare_paths(p1, p9);\n+\n+    test_container<char, input_iterator_wrapper>\n+      r2((char*)s.c_str(), (char*)s.c_str() + s.size() + 1); // includes null-terminator\n+    path p10(r2.begin());\n+    compare_paths(p1, p10);\n+\n+    test_container<const char, input_iterator_wrapper>\n+      r3(s.c_str(), s.c_str() + s.size());\n+    path p11(r3.begin(), r3.end());\n+    compare_paths(p1, p11);\n+\n+    test_container<const char, input_iterator_wrapper>\n+      r4(s.c_str(), s.c_str() + s.size() + 1); // includes null-terminator\n+    path p12(r4.begin());\n+    compare_paths(p1, p12);\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+    // Test with input iterators and const value_types\n+    test_container<wchar_t, input_iterator_wrapper>\n+      r5((wchar_t*)ws.c_str(), (wchar_t*)ws.c_str() + ws.size());\n+    path p13(r5.begin(), r5.end());\n+    compare_paths(p1, p13);\n+\n+    test_container<wchar_t, input_iterator_wrapper>\n+      r6((wchar_t*)ws.c_str(), (wchar_t*)ws.c_str() + ws.size() + 1); // includes null-terminator\n+    path p14(r6.begin());\n+    compare_paths(p1, p14);\n+\n+    test_container<const wchar_t, input_iterator_wrapper>\n+      r7(ws.c_str(), ws.c_str() + ws.size());\n+    path p15(r7.begin(), r7.end());\n+    compare_paths(p1, p15);\n+\n+    test_container<const wchar_t, input_iterator_wrapper>\n+      r8(ws.c_str(), ws.c_str() + ws.size() + 1); // includes null-terminator\n+    path p16(r8.begin());\n+    compare_paths(p1, p16);\n+#endif\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "b9a52058791d39700d4ef70b89e57ec3bb03361d", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/string_view.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-lstdc++fs -std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <filesystem>\n+#include <string_view>\n+#include <string>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p1 = s;\n+    std::string_view sv(s);\n+    path p2 = sv;\n+    compare_paths(p1, p2);\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+    std::wstring ws(s.begin(), s.end());\n+    path p3 = ws;\n+    std::wstring_view wsv(ws);\n+    path p4 = wsv;\n+    compare_paths(p1, p4);\n+#endif\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "13c9db275a0ce9fa3d4eabbfcf70d9694bbbf51b", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/extension.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").extension() == path(\".txt\") );\n+  VERIFY( path(\"/foo/bar.baz.txt\").extension() == path(\".txt\") );\n+  VERIFY( path(\".bar.baz.txt\").extension() == path(\".txt\") );\n+\n+  VERIFY( path(\".profile\").extension() == path(\"\") );\n+  VERIFY( path(\".profile.old\").extension() == path(\".old\") );\n+  VERIFY( path(\"..abc\").extension() == path(\".abc\") );\n+  VERIFY( path(\"...abc\").extension() == path(\".abc\") );\n+  VERIFY( path(\"abc..def\").extension() == path(\".def\") );\n+  VERIFY( path(\"abc...def\").extension() == path(\".def\") );\n+  VERIFY( path(\"abc.\").extension() == path(\".\") );\n+  VERIFY( path(\"abc..\").extension() == path(\".\") );\n+  VERIFY( path(\"abc.d.\").extension() == path(\".\") );\n+  VERIFY( path(\"..\").extension() == path(\"\") );\n+  VERIFY( path(\".\").extension() == path(\"\") );\n+\n+  VERIFY( path().extension() == path() );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    auto stem = p.stem();\n+    auto ext = p.extension();\n+    auto file = p.filename();\n+    VERIFY( stem.native() + ext.native() == file.native() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "8ba0fcc8cb9ce4b46066d4dc0ce939122640b5c1", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/filename.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.4.9 path decomposition [fs.path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").filename() == \"bar.txt\" );\n+  VERIFY( path(\"/foo/bar\").filename()     == \"bar\"     );\n+  VERIFY( path(\"/foo/bar/\").filename()    == \"\"        );\n+  VERIFY( path(\"/\").filename()            == \"\"        );\n+#ifdef __CYGWIN__\n+  VERIFY( path(\"//host\").filename()       == \"\"        );\n+#else\n+  VERIFY( path(\"//host\").filename()       == \"host\"    );\n+#endif\n+  VERIFY( path(\".\").filename()            == \".\"       );\n+  VERIFY( path(\"..\").filename()           == \"..\"      );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path f = p.filename();\n+    if (p.empty())\n+      VERIFY( f.empty() );\n+    else\n+    {\n+      const path back = *--p.end();\n+      if (back.has_root_path())\n+\tVERIFY( f.empty() );\n+      else\n+\tVERIFY( f == back );\n+    }\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c46566dad405d3476d5194df977fb1f34b661eeb", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/parent_path.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p0;\n+  VERIFY( p0.parent_path() == p0 );\n+  path p1 = \"foo\";\n+  VERIFY( p1.parent_path() == p0 );\n+  path p2 = \"foo/bar\";\n+  VERIFY( p2.parent_path() == p1 );\n+  path p3 = \"/foo/bar\";\n+  VERIFY( p3.parent_path() == path(\"/foo\") );\n+  VERIFY( p3.parent_path().parent_path() == path(\"/\") );\n+  VERIFY( p3.parent_path().parent_path().parent_path() == path(\"/\") );\n+  path p4 = \"/\";\n+  VERIFY( p4.parent_path() == p4 );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    if (p.begin() == p.end())\n+      continue;\n+    if (p.has_relative_path())\n+    {\n+      path pp;\n+      for (auto i = p.begin(), end = --p.end(); i != end; ++i)\n+      {\n+\tpp /= *i;\n+      }\n+      VERIFY( p.parent_path() == pp );\n+    }\n+    else\n+      VERIFY( p.parent_path() == p );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c8649724671cba6e327eb11f75f627eec8ef4822", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/relative_path.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo\";\n+  VERIFY( p1.relative_path() == p1 );\n+  path p2 = \"foo/bar\";\n+  VERIFY( p2.relative_path() == p2 );\n+  path p3 = \"/foo/bar\";\n+  VERIFY( p3.relative_path() == p2 );\n+}\n+\n+#include <iostream> // XXX\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    bool after_root = false;\n+    const path prel = p.relative_path();\n+    VERIFY( !prel.has_root_name() );\n+    path rel;\n+    for (const auto& cmpt : p)\n+    {\n+      if (!cmpt.has_root_path())\n+        after_root = true;\n+      if (after_root)\n+        rel /= cmpt;\n+    }\n+    if (prel != rel)\n+      std::cout << prel << ' ' << rel << '\\n';\n+    VERIFY( prel == rel );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "8220c589efcf037c5695b4dcf283063dced24eca", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_directory.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo/bar\";\n+  VERIFY( p1.root_directory() == path() );\n+  path p2 = \"/foo/bar\";\n+  VERIFY( p2.root_directory() == path(\"/\") );\n+  path p3 = \"//foo\";\n+  VERIFY( p3.root_directory() == path(\"/\") );\n+  path p4 = \"///foo\";\n+  VERIFY( p4.root_directory() == path(\"/\") );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path rootdir = p.root_directory();\n+    VERIFY( !rootdir.has_relative_path() );\n+    VERIFY( rootdir.empty() || rootdir.native() == \"/\");\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "5bb2ccd177e1d2a845ce3354f207118a85651e6d", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_name.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").extension() == \".txt\" );\n+  VERIFY( path(\"/foo/bar.baz.txt\").extension() == \".txt\" );\n+  VERIFY( path(\".\").extension().empty() );\n+  VERIFY( path(\"..\").extension().empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "bce0134a447be0872181f0fa53943457601c7644", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.4.9 path decomposition [fs.path.decompose]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo/bar\";\n+  VERIFY( p1.root_path() == path() );\n+  path p2 = \"/foo/bar\";\n+  VERIFY( p2.root_path() == path(\"/\") );\n+}\n+\n+#undef VERIFY\n+#define VERIFY(X) do { if (!(X)) { __builtin_puts(\"FAIL: \" #X); } } while(false)\n+#define DUMP(X, Y, Z) do { if (!(Y == Z)) { __builtin_printf(\"%s %s %s\\n\", X.c_str(), Y.c_str(), Z.c_str()); } } while(false)\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path rootp = p.root_path();\n+    path rootn = p.root_name();\n+    path rootd = p.root_directory();\n+    VERIFY( rootp == (rootn / rootd) );\n+    DUMP(p,  rootp , (rootn / rootd) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "aec64e172ff199e7593a34f4c9293b5a012e292e", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/decompose/stem.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").stem() == path(\"bar\") );\n+  path p = \"foo.bar.baz.tar\";\n+  std::vector<std::string> v;\n+  for (; !p.extension().empty(); p = p.stem())\n+    v.push_back(p.extension().native());\n+  VERIFY( v.at(0) == \".tar\" );\n+  VERIFY( v.at(1) == \".baz\" );\n+  VERIFY( v.at(2) == \".bar\" );\n+\n+  VERIFY( path(\".profile\").stem() == path(\".profile\") );\n+  VERIFY( path(\".profile.old\").stem() == path(\".profile\") );\n+  VERIFY( path(\"..abc\").stem() == path(\".\") );\n+  VERIFY( path(\"...abc\").stem() == path(\"..\") );\n+  VERIFY( path(\"abc..def\").stem() == path(\"abc.\") );\n+  VERIFY( path(\"abc...def\").stem() == path(\"abc..\") );\n+  VERIFY( path(\"abc.\").stem() == path(\"abc\") );\n+  VERIFY( path(\"abc..\").stem() == path(\"abc.\") );\n+  VERIFY( path(\"abc.d.\").stem() == path(\"abc.d\") );\n+  VERIFY( path(\"..\").stem() == path(\"..\") );\n+  VERIFY( path(\".\").stem() == path(\".\") );\n+\n+  VERIFY( path().stem() == path() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "2e4ec5bc98ed7a6c389da82111698de57cd54d4a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generation/normal.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  // C++17 [fs.path.gen] p2\n+  VERIFY( path(\"foo/./bar/..\").lexically_normal() == \"foo/\" );\n+  VERIFY( path(\"foo/.///bar/../\").lexically_normal() == \"foo/\" );\n+}\n+\n+void\n+test02()\n+{\n+  VERIFY( path(\"foo/../bar\").lexically_normal() == \"bar\" );\n+  VERIFY( path(\"../foo/../bar\").lexically_normal() == \"../bar\" );\n+  VERIFY( path(\"foo/../\").lexically_normal() == \".\" );\n+  VERIFY( path(\"../../\").lexically_normal() == \"../..\" );\n+  VERIFY( path(\"../\").lexically_normal() == \"..\" );\n+  VERIFY( path(\"./\").lexically_normal() == \".\" );\n+  VERIFY( path().lexically_normal() == \"\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "7a25f7b417d92340568e6633e4c1945a3654b88e", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generation/proximate.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fproximate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fproximate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fproximate.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  // C++17 [fs.path.gen] p5\n+  VERIFY( path(\"/a/d\").lexically_proximate(\"/a/b/c\") == \"../../d\" );\n+  VERIFY( path(\"/a/b/c\").lexically_proximate(\"/a/d\") == \"../b/c\" );\n+  VERIFY( path(\"a/b/c\").lexically_proximate(\"a\") == \"b/c\" );\n+  VERIFY( path(\"a/b/c\").lexically_proximate(\"a/b/c/x/y\") == \"../..\" );\n+  VERIFY( path(\"a/b/c\").lexically_proximate(\"a/b/c\") == \".\" );\n+  VERIFY( path(\"a/b\").lexically_proximate(\"c/d\") == \"../../a/b\" );\n+}\n+\n+void\n+test02()\n+{\n+  path p = \"a/b/c\";\n+  VERIFY( p.lexically_proximate(p) == \".\" );\n+  VERIFY( p.lexically_proximate(\"a/../a/b/../b/c/../c/.\") == \"../../b/c\" );\n+  VERIFY( p.lexically_proximate(\"../../../\") == p );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "64770fb1fe53d8f803b6f4b89cd0d1419d22a179", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generation/relative.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Frelative.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Frelative.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Frelative.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  // C++17 [fs.path.gen] p5\n+  VERIFY( path(\"/a/d\").lexically_relative(\"/a/b/c\") == \"../../d\" );\n+  VERIFY( path(\"/a/b/c\").lexically_relative(\"/a/d\") == \"../b/c\" );\n+  VERIFY( path(\"a/b/c\").lexically_relative(\"a\") == \"b/c\" );\n+  VERIFY( path(\"a/b/c\").lexically_relative(\"a/b/c/x/y\") == \"../..\" );\n+  VERIFY( path(\"a/b/c\").lexically_relative(\"a/b/c\") == \".\" );\n+  VERIFY( path(\"a/b\").lexically_relative(\"c/d\") == \"../../a/b\" );\n+}\n+\n+void\n+test02()\n+{\n+  path p = \"a/b/c\";\n+  VERIFY( p.lexically_relative(p) == \".\" );\n+  VERIFY( p.lexically_relative(\"a/../a/b/../b/c/../c/.\") == \"../../b/c\" );\n+  VERIFY( p.lexically_relative(\"../../../\") == \"\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d25d5056c607320183187a9cdc3c5d2c89bea187", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path().generic_string() == \"\" );\n+  VERIFY( path(\"/\").generic_string() == \"/\" );\n+  VERIFY( path(\"////\").generic_string() == \"/\" );\n+#ifdef __CYGWIN__\n+  VERIFY( path(\"//a\").generic_string() == \"//a\" );\n+  VERIFY( path(\"//a/\").generic_string() == \"//a/\" );\n+  VERIFY( path(\"//a/b\").generic_string() == \"//a/b\" );\n+#else\n+  VERIFY( path(\"//a\").generic_string() == \"/a\" );\n+  VERIFY( path(\"//a/\").generic_string() == \"/a/\" );\n+  VERIFY( path(\"//a/b\").generic_string() == \"/a/b\" );\n+#endif\n+  VERIFY( path(\"/a//b\").generic_string() == \"/a/b\" );\n+  VERIFY( path(\"/a//b/\").generic_string() == \"/a/b/\" );\n+  VERIFY( path(\"/a//b//\").generic_string() == \"/a/b/\" );\n+  VERIFY( path(\"/a//b//.\").generic_string() == \"/a/b/.\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "7754140a714b48e60122c0d10b55251949d355b0", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/itr/traversal.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,127 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.5 path iterators [fs.path.itr]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p;\n+  VERIFY( p.begin() == p.end() );\n+\n+  std::vector<path> v, v2;\n+\n+  p = \"/\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"/\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"filename\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"filename\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"dir/.\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"dir\", \".\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"dir/\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"dir\", \"\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"//rootname/dir/.\";\n+  v.assign(p.begin(), p.end());\n+#ifdef __CYGWIN__\n+  v2 = { \"//rootname\", \"/\", \"dir\", \".\" };\n+#else\n+  v2 = { \"/\", \"rootname\", \"dir\", \".\" };\n+#endif\n+  VERIFY( v == v2 );\n+\n+  p = \"//rootname/dir/\";\n+  v.assign(p.begin(), p.end());\n+#ifdef __CYGWIN__\n+  v2 = { \"//rootname\", \"/\", \"dir\", \"\" };\n+#else\n+  v2 = { \"/\", \"rootname\", \"dir\", \"\" };\n+#endif\n+  VERIFY( v == v2 );\n+\n+  p = \"//rootname/dir/filename\";\n+  v.assign(p.begin(), p.end());\n+#ifdef __CYGWIN__\n+  v2 = { \"//rootname\", \"/\", \"dir\", \"filename\" };\n+#else\n+  v2 = { \"/\", \"rootname\", \"dir\", \"filename\" };\n+#endif\n+  VERIFY( v == v2 );\n+}\n+\n+void\n+test02()\n+{\n+  using reverse_iterator = std::reverse_iterator<path::iterator>;\n+  std::vector<path> fwd, rev;\n+\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    const auto begin = p.begin(), end = p.end();\n+    fwd.assign(begin, end);\n+    rev.assign(reverse_iterator(end), reverse_iterator(begin));\n+    VERIFY( fwd.size() == rev.size() );\n+    VERIFY( std::equal(fwd.begin(), fwd.end(), rev.rbegin()) );\n+  }\n+}\n+\n+void\n+test03()\n+{\n+  path paths[] = { \"single\", \"multiple/elements\" };\n+  for (const path& p : paths)\n+    for (auto iter = p.begin(); iter != p.end(); ++iter)\n+    {\n+      auto iter2 = iter;\n+      ++iter;\n+      iter2++;\n+      VERIFY( iter2 == iter );\n+      --iter;\n+      iter2--;\n+      VERIFY( iter2 == iter );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "31d984f1aa07b77617fff96de160b93f81660f3a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/clear.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (path p : __gnu_test::test_paths)\n+  {\n+    path empty;\n+    p.clear();\n+    VERIFY( p.empty() );\n+    __gnu_test::compare_paths(p, empty);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "1df10093777e26ea55f8318b8aac1003576989b3", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/make_preferred.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,64 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+template<typename T, T sep>\n+struct checker\n+{\n+  static void check(const char* s) { }\n+};\n+\n+template<>\n+struct checker<char, '/'>\n+{\n+  static void check()\n+  {\n+    VERIFY( path(\"foo/bar\").make_preferred() == \"foo/bar\" );\n+  }\n+};\n+\n+template<>\n+struct checker<wchar_t, L'\\\\'>\n+{\n+  static void check()\n+  {\n+    VERIFY( path(\"foo/bar\").make_preferred() == L\"foo\\\\bar\" );\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  checker<path::value_type, path::preferred_separator>::check();\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "02e1b05cd411c5909b89d1e620da4ccfbc431ce4", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/remove_filename.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.4.5 path modifiers [fs.path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  // C++17 [fs.path.modifiers] p8\n+  VERIFY( path(\"foo/bar\").remove_filename() == \"foo/\" );\n+  VERIFY( path(\"foo/\").remove_filename()    == \"foo/\" );\n+  VERIFY( path(\"/foo\").remove_filename()    == \"/\" );\n+  VERIFY( path(\"/\").remove_filename()       == \"/\" );\n+}\n+\n+#undef VERIFY\n+#define VERIFY(X) do { if (!(X)) { __builtin_puts(\"FAIL: \" #X); } } while(false)\n+#define DUMP(X, Y) do { if (!(X == Y)) { __builtin_printf(\"%s %s\\n\", X.c_str(), Y.c_str()); } } while(false)\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2(p);\n+    p2.remove_filename();\n+    p2 /= p.filename();\n+    VERIFY( p2 == p );\n+    DUMP( p2 , p );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "cf7ca094c0f7874c7531fe24d08ee592e443cc62", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/replace_extension.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo.txt\").replace_extension(\"cpp\") == \"/foo.cpp\" );\n+  VERIFY( path(\"/foo.txt\").replace_extension(\".cpp\") == \"/foo.cpp\" );\n+  VERIFY( path(\"/\").replace_extension(\"bar\") == \"/.bar\" );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2 = p;\n+    VERIFY(p2.replace_extension(p2.extension()) == p);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "6d3b9b70d079dd04926e870f8ee3ea1ea083a10e", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/replace_filename.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++17 30.10.7.4.5 path modifiers [fs.path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  // C++17 [fs.path.modifiers] p11\n+  VERIFY( path(\"/foo\").replace_filename(\"bar\") == \"/bar\" );\n+  VERIFY( path(\"/\").replace_filename(\"bar\")    == \"/bar\" );\n+}\n+\n+#undef VERIFY\n+#define VERIFY(X) do { if (!(X)) { __builtin_puts(\"FAIL: \" #X); } } while(false)\n+#define DUMP(X, Y) do { if (!(X == Y)) { __builtin_printf(\"%s %s\\n\", X.c_str(), Y.c_str()); } } while(false)\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2(p);\n+    p2.replace_filename(p.filename());\n+    VERIFY( p2 == p );\n+    DUMP( p2 , p );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "f1276042a959bf16ebd53c58d8d0d17ced6599ec", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/modifiers/swap.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+  path p1;\n+  path p2 = p;\n+  p1.swap(p2);\n+  VERIFY( p2.empty() );\n+  __gnu_test::compare_paths(p1, p);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "23d79700d9752e422ed150d31cb946b63e18e6f3", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/native/string.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnative%2Fstring.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std::filesystem;\n+  const std::string s = \"abc\";\n+  path p(s);\n+\n+  VERIFY( p.native() == s );\n+  VERIFY( p.c_str() == s );\n+  VERIFY( static_cast<std::string>(p) == s );\n+\n+  std::string s2 = p; // implicit conversion\n+  VERIFY( s2 == p.native() );\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::filesystem;\n+  const char* s = \"abc\";\n+  path p(s);\n+\n+  auto str = p.string<char>();\n+  VERIFY( str == u\"abc\" );\n+  VERIFY( str == p.string() );\n+\n+  auto strw = p.string<wchar_t>();\n+  VERIFY( strw == L\"abc\" );\n+  VERIFY( strw == p.wstring() );\n+\n+  auto str16 = p.string<char16_t>();\n+  VERIFY( str16 == u\"abc\" );\n+  VERIFY( str16 == p.u16string() );\n+\n+  auto str32 = p.string<char32_t>();\n+  VERIFY( str32 == U\"abc\" );\n+  VERIFY( str32 == p.u32string() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "20f42ac6ee5a829ee8595d7c7cdee621d02ec82a", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.6 path non-member functions [path.non-member]\n+\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( hash_value(path(\"a//b\")) == hash_value(path(\"a/b\")) );\n+  VERIFY( hash_value(path(\"a/\")) == hash_value(path(\"a//\")) );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path pp = p.native();\n+    VERIFY( hash_value(p) == hash_value(pp) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "76277a0c9ff2921f03d772f6a5de14a032f3a0fe", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/empty.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const std::string& s : __gnu_test::test_paths)\n+  {\n+    VERIFY( s.empty() == path(s).empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "693bd389dcd28a7908243365749a8a7a37c9550f", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_extension.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_extension() == !p.extension().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "ce99af3025fc969f0e44ca8357078f7472c5f341", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_filename.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_filename() == !p.filename().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4e23b249607ae782ac0b8f506a8a9bbb61b7d640", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_parent_path.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_parent_path() == !p.parent_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "25e2dd5ea297bc40c4ba9921f47840a9b5f58add", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_relative_path.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_relative_path() == !p.relative_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "66c8df20976e7a264d60dc0af72de42756ca347d", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_root_directory.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_directory() == !p.root_directory().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "f9d7157d646e1561e08af4ef2d0a2934988e6dba", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_root_name.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_name() == !p.root_name().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "f0bdb8156c6dc6e6e75858f45ba22b436f24d9e2", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_root_path.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_path() == !p.root_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "18bf0159825e7b6449007042337941003d7fbad2", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/has_stem.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_stem() == !p.stem().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "c6f6c7f98b1f1abdc244134946d1dd13253c13bf", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/query/is_relative.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.is_relative() == !p.is_absolute() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "6879909c7771b8ce1770434c303791adbbdb0672", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/string_view.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fstring_view.cc?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -24,6 +24,7 @@\n #include <experimental/filesystem>\n #include <string_view>\n #include <string>\n+#define USE_FILESYSTEM_TS\n #include <testsuite_fs.h>\n \n using std::experimental::filesystem::path;"}, {"sha": "e0db46ca1560b4cff72d6182c4c956e7d798dd35", "filename": "libstdc++-v3/testsuite/util/testsuite_fs.h", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641cb5a675128ad44cad5b0d25033f3242af59fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h?ref=641cb5a675128ad44cad5b0d25033f3242af59fb", "patch": "@@ -22,7 +22,14 @@\n #ifndef _TESTSUITE_FS_H\n #define _TESTSUITE_FS_H 1\n \n+// Assume we want std::filesystem in C++17, unless USE_FILESYSTEM_TS defined:\n+#if __cplusplus >= 201703L && ! defined USE_FILESYSTEM_TS\n+#include <filesystem>\n+namespace test_fs = std::filesystem;\n+#else\n #include <experimental/filesystem>\n+namespace test_fs = std::experimental::filesystem;\n+#endif\n #include <fstream>\n #include <string>\n #include <cstdio>\n@@ -33,12 +40,12 @@ namespace __gnu_test\n {\n #define PATH_CHK(p1, p2, fn) \\\n     if ( p1.fn() != p2.fn() ) \\\n-      throw std::experimental::filesystem::filesystem_error( #fn, p1, p2, \\\n+      throw test_fs::filesystem_error( #fn, p1, p2, \\\n \t  std::make_error_code(std::errc::invalid_argument) )\n \n   void\n-  compare_paths(const std::experimental::filesystem::path& p1,\n-\t\tconst std::experimental::filesystem::path& p2)\n+  compare_paths(const test_fs::path& p1,\n+\t\tconst test_fs::path& p2)\n   {\n     PATH_CHK( p1, p2, string );\n     PATH_CHK( p1, p2, empty );\n@@ -55,7 +62,7 @@ namespace __gnu_test\n     auto d1 = std::distance(p1.begin(), p1.end());\n     auto d2 = std::distance(p2.begin(), p2.end());\n     if( d1 != d2 )\n-      throw std::experimental::filesystem::filesystem_error(\n+      throw test_fs::filesystem_error(\n \t  \"distance(begin, end)\", p1, p2,\n \t  std::make_error_code(std::errc::invalid_argument) );\n   }\n@@ -67,15 +74,15 @@ namespace __gnu_test\n \n   // This is NOT supposed to be a secure way to get a unique name!\n   // We just need a path that doesn't exist for testing purposes.\n-  std::experimental::filesystem::path\n+  test_fs::path\n   nonexistent_path()\n   {\n-    std::experimental::filesystem::path p;\n+    test_fs::path p;\n #if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L\n-    char tmp[] = \"filesystem-ts-test.XXXXXX\";\n+    char tmp[] = \"filesystem-test.XXXXXX\";\n     int fd = ::mkstemp(tmp);\n     if (fd == -1)\n-      throw std::experimental::filesystem::filesystem_error(\"mkstemp failed\",\n+      throw test_fs::filesystem_error(\"mkstemp failed\",\n \t  std::error_code(errno, std::generic_category()));\n     ::unlink(tmp);\n     ::close(fd);\n@@ -88,7 +95,7 @@ namespace __gnu_test\n #else\n     std::sprintf(buf,\n #endif\n-      \"filesystem-ts-test.%d.%lu\", counter++, (unsigned long) ::getpid());\n+      \"filesystem-test.%d.%lu\", counter++, (unsigned long) ::getpid());\n     p = buf;\n #endif\n     return p;\n@@ -97,7 +104,7 @@ namespace __gnu_test\n   // RAII helper to remove a file on scope exit.\n   struct scoped_file\n   {\n-    using path_type = std::experimental::filesystem::path;\n+    using path_type = test_fs::path;\n \n     enum adopt_file_t { adopt_file };\n "}]}