{"sha": "0a2f0c5497342d01717c93db97aeb5318c3ec42c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyZjBjNTQ5NzM0MmQwMTcxN2M5M2RiOTdhZWI1MzE4YzNlYzQyYw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-01-12T02:14:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-01-12T02:14:56Z"}, "message": "* All Files: Convert to ISO C style function definitions.\n\nFrom-SVN: r61218", "tree": {"sha": "ae14f5fe1cbe481163ab4bcb25d7f4cec4d064a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae14f5fe1cbe481163ab4bcb25d7f4cec4d064a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a2f0c5497342d01717c93db97aeb5318c3ec42c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2f0c5497342d01717c93db97aeb5318c3ec42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2f0c5497342d01717c93db97aeb5318c3ec42c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2f0c5497342d01717c93db97aeb5318c3ec42c/comments", "author": null, "committer": null, "parents": [{"sha": "8e37cba890b62aa56f48cfbbca16e16b748355d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e37cba890b62aa56f48cfbbca16e16b748355d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e37cba890b62aa56f48cfbbca16e16b748355d6"}], "stats": {"total": 2688, "additions": 842, "deletions": 1846}, "files": [{"sha": "8d190ef2ba184178dcf575113d529bc3889d31ad", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -1,3 +1,7 @@\n+2003-01-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* All Files: Convert to ISO C style function definitions.\n+\n 2003-01-09  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* parse.y (check_pkg_class_access): ANSIfy definition."}, {"sha": "b806a32af25e16cae02136c2a9e376616067f231", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -43,9 +43,8 @@ static void set_bit (unsigned HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n /* Treat two HOST_WIDE_INT's as a contiguous bitmap, with bit 0 being\n    the least significant.  This function sets bit N in the bitmap.  */\n static void\n-set_bit (low, high, n)\n-     unsigned HOST_WIDE_INT *low, *high;\n-     unsigned int n;\n+set_bit (unsigned HOST_WIDE_INT *low, unsigned HOST_WIDE_INT *high,\n+\t unsigned int n)\n {\n   HOST_WIDE_INT *which;\n \n@@ -62,15 +61,14 @@ set_bit (low, high, n)\n \n /* Recursively mark reference fields.  */\n static void\n-mark_reference_fields (field, low, high, ubit,\n-\t\t       pointer_after_end, all_bits_set,\n-\t\t       last_set_index, last_view_index)\n-     tree field;\n-     unsigned HOST_WIDE_INT *low, *high;\n-     unsigned int ubit;\n-     int *pointer_after_end, *all_bits_set;\n-     int *last_set_index;\n-     HOST_WIDE_INT *last_view_index;\n+mark_reference_fields (tree field,\n+\t\t       unsigned HOST_WIDE_INT *low,\n+\t\t       unsigned HOST_WIDE_INT *high,\n+\t\t       unsigned int ubit,\n+\t\t       int *pointer_after_end,\n+\t\t       int *all_bits_set,\n+\t\t       int *last_set_index,\n+\t\t       HOST_WIDE_INT *last_view_index)\n {\n   /* See if we have fields from our superclass.  */\n   if (DECL_NAME (field) == NULL_TREE)"}, {"sha": "f878cebe40d08a425494d3271fb6a8aeb3b35598", "filename": "gcc/java/buffer.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuffer.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -29,9 +29,7 @@ Boston, MA 02111-1307, USA.  */\n /* Grow BUFP so there is room for at least SIZE more bytes. */\n \n void\n-buffer_grow (bufp, size)\n-     struct buffer *bufp;\n-     int size;\n+buffer_grow (struct buffer *bufp, int size)\n {\n   if (bufp->limit - bufp->ptr >= size)\n     return;"}, {"sha": "ce8fe6d3847e4c69bf3abf0866757eec2a71a86d", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -116,26 +116,23 @@ static tree builtin_types[(int) BT_LAST];\n /* Internal functions which implement various builtin conversions.  */\n \n static tree\n-max_builtin (method_return_type, method_arguments)\n-     tree method_return_type, method_arguments;\n+max_builtin (tree method_return_type, tree method_arguments)\n {\n   return build (MAX_EXPR, method_return_type,\n \t\tTREE_VALUE (method_arguments),\n \t\tTREE_VALUE (TREE_CHAIN (method_arguments)));\n }\n \n static tree\n-min_builtin (method_return_type, method_arguments)\n-     tree method_return_type, method_arguments;\n+min_builtin (tree method_return_type, tree method_arguments)\n {\n   return build (MIN_EXPR, method_return_type,\n \t\tTREE_VALUE (method_arguments),\n \t\tTREE_VALUE (TREE_CHAIN (method_arguments)));\n }\n \n static tree\n-abs_builtin (method_return_type, method_arguments)\n-     tree method_return_type, method_arguments;\n+abs_builtin (tree method_return_type, tree method_arguments)\n {\n   return build1 (ABS_EXPR, method_return_type,\n \t\t TREE_VALUE (method_arguments));\n@@ -155,8 +152,7 @@ build_function_call_expr (tree fn, tree arglist)\n }\n \n static tree\n-cos_builtin (method_return_type, method_arguments)\n-     tree method_return_type ATTRIBUTE_UNUSED, method_arguments;\n+cos_builtin (tree method_return_type ATTRIBUTE_UNUSED, tree method_arguments)\n {\n   /* FIXME: this assumes that jdouble and double are the same.  */\n   tree fn = built_in_decls[BUILT_IN_COS];\n@@ -166,8 +162,7 @@ cos_builtin (method_return_type, method_arguments)\n }\n \n static tree\n-sin_builtin (method_return_type, method_arguments)\n-     tree method_return_type ATTRIBUTE_UNUSED, method_arguments;\n+sin_builtin (tree method_return_type ATTRIBUTE_UNUSED, tree method_arguments)\n {\n   /* FIXME: this assumes that jdouble and double are the same.  */\n   tree fn = built_in_decls[BUILT_IN_SIN];\n@@ -177,8 +172,7 @@ sin_builtin (method_return_type, method_arguments)\n }\n \n static tree\n-sqrt_builtin (method_return_type, method_arguments)\n-     tree method_return_type ATTRIBUTE_UNUSED, method_arguments;\n+sqrt_builtin (tree method_return_type ATTRIBUTE_UNUSED, tree method_arguments)\n {\n   /* FIXME: this assumes that jdouble and double are the same.  */\n   tree fn = built_in_decls[BUILT_IN_SQRT];\n@@ -191,12 +185,11 @@ sqrt_builtin (method_return_type, method_arguments)\n \n /* Define a single builtin.  */\n static void\n-define_builtin (val, name, class, type, fallback_p)\n-     enum built_in_function val;\n-     const char *name;\n-     enum built_in_class class;\n-     tree type;\n-     int fallback_p;\n+define_builtin (enum built_in_function val,\n+\t\tconst char *name,\n+\t\tenum built_in_class class,\n+\t\ttree type,\n+\t\tint fallback_p)\n {\n   tree decl;\n \n@@ -220,8 +213,7 @@ define_builtin (val, name, class, type, fallback_p)\n \n /* Compute the type for a builtin.  */\n static tree\n-define_builtin_type (ret, arg1, arg2, arg3, arg4)\n-     int ret, arg1, arg2, arg3, arg4;\n+define_builtin_type (int ret, int arg1, int arg2, int arg3, int arg4)\n {\n   tree args;\n \n@@ -262,7 +254,7 @@ define_builtin_type (ret, arg1, arg2, arg3, arg4)\n \n /* Initialize the builtins.  */\n void\n-initialize_builtins ()\n+initialize_builtins (void)\n {\n   int i;\n \n@@ -322,9 +314,7 @@ initialize_builtins ()\n /* If the call matches a builtin, return the\n    appropriate builtin expression instead.  */\n tree\n-check_for_builtin (method, call)\n-     tree method;\n-     tree call;\n+check_for_builtin (tree method, tree call)\n {\n   if (! flag_emit_class_files && optimize && TREE_CODE (call) == CALL_EXPR)\n     {"}, {"sha": "c9a71627b7941d15c9af3f7ef150aa6aba77eaee", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -162,8 +162,7 @@ static void check_final_reassigned (tree, words);\n    Return the declaration or NULL_TREE if no interesting declaration.  */\n \n static tree\n-get_variable_decl (exp)\n-     tree exp;\n+get_variable_decl (tree exp)\n {\n   if (TREE_CODE (exp) == VAR_DECL)\n     {\n@@ -196,18 +195,15 @@ get_variable_decl (exp)\n }\n \n static void\n-final_assign_error (name)\n-     tree name;\n+final_assign_error (tree name)\n {\n   static const char format[]\n     = \"can't reassign a value to the final variable '%s'\";\n   parse_error_context (wfl, format, IDENTIFIER_POINTER (name));\n }\n \n static void\n-check_final_reassigned (decl, before)\n-     tree decl;\n-     words before;\n+check_final_reassigned (tree decl, words before)\n {\n   int index = DECL_BIT_INDEX (decl);\n   /* A final local already assigned or a final parameter\n@@ -225,10 +221,8 @@ check_final_reassigned (decl, before)\n    BEFORE, WHEN_FALSE, and WHEN_TRUE are as in check_bool_init. */\n \n static void\n-check_cond_init (test_exp, then_exp, else_exp,\n-\t\t before, when_false, when_true)\n-     tree test_exp, then_exp, else_exp;\n-     words before, when_false, when_true;\n+check_cond_init (tree test_exp, tree then_exp, tree else_exp,\n+\t\t words before, words when_false, words when_true)\n {\n   int save_start_current_locals = start_current_locals;\n   DECLARE_BUFFERS(test_false, 6);\n@@ -253,9 +247,8 @@ check_cond_init (test_exp, then_exp, else_exp,\n    BEFORE, WHEN_FALSE, and WHEN_TRUE are as in check_bool_init. */\n \n static void\n-check_bool2_init (code, exp0, exp1, before, when_false, when_true)\n-     enum tree_code code;  tree exp0, exp1;\n-     words before, when_false, when_true;\n+check_bool2_init (enum tree_code code, tree exp0, tree exp1,\n+\t\t  words before, words when_false, words when_true)\n {\n   word buf[2*4];\n   words tmp = num_current_words <= 2 ? buf\n@@ -321,9 +314,7 @@ check_bool2_init (code, exp0, exp1, before, when_false, when_true)\n    be used as temporary working areas. */\n \n static void\n-check_bool_init (exp, before, when_false, when_true)\n-     tree exp;\n-     words before, when_false, when_true;\n+check_bool_init (tree exp, words before, words when_false, words when_true)\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -455,9 +446,7 @@ struct alternatives * alternatives = NULL;\n    of previous alternative branches. */\n \n static void\n-done_alternative (after, current)\n-     words after;\n-     struct alternatives *current; \n+done_alternative (words after, struct alternatives *current)\n {\n   INTERSECTN (current->combined, current->combined, after,\n \t      WORDS_NEEDED (2 * current->num_locals));\n@@ -479,9 +468,7 @@ done_alternative (after, current)\n /* Check for (un)initialized local variables in EXP.  */\n \n static void\n-check_init (exp, before)\n-     tree exp;\n-     words before;\n+check_init (tree exp, words before)\n {\n   tree tmp;\n  again:\n@@ -924,8 +911,7 @@ check_init (exp, before)\n }\n \n void\n-check_for_initialization (body, mdecl)\n-     tree body, mdecl;\n+check_for_initialization (tree body, tree mdecl)\n {\n   tree decl;\n   word buf[2];"}, {"sha": "b5746718f28fd939b48ad6e2e56463710ce0de2f", "filename": "gcc/java/class.c", "status": "modified", "additions": 66, "deletions": 141, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -105,9 +105,7 @@ static GTY(()) tree class_roots[5];\n    appropriate node does not exist.  */\n \n static assume_compiled_node *\n-find_assume_compiled_node (node, ident)\n-     assume_compiled_node *node;\n-     const char *ident;\n+find_assume_compiled_node (assume_compiled_node *node, const char *ident)\n {\n   while (node)\n     {\n@@ -146,9 +144,7 @@ find_assume_compiled_node (node, ident)\n    if EXCLUDEP is nonzero.  */\n \n void\n-add_assume_compiled (ident, excludep)\n-     const char *ident;\n-     int excludep;\n+add_assume_compiled (const char *ident, int excludep)\n {\n   int len;\n   assume_compiled_node *parent;\n@@ -199,8 +195,7 @@ add_assume_compiled (ident, excludep)\n    should assume has been compiled to object code.  */\n \n static int\n-assume_compiled (ident)\n-     const char *ident;\n+assume_compiled (const char *ident)\n {\n   assume_compiled_node *i;\n   int result;\n@@ -221,13 +216,12 @@ assume_compiled (ident)\n    Also, PREFIX is prepended, and SUFFIX is appended. */\n \n tree\n-ident_subst (old_name, old_length, prefix, old_char, new_char, suffix)\n-     const char* old_name;\n-     int old_length;\n-     const char *prefix;\n-     int old_char;\n-     int new_char;\n-     const char *suffix;\n+ident_subst (const char* old_name,\n+\t     int old_length,\n+\t     const char *prefix,\n+\t     int old_char,\n+\t     int new_char,\n+\t     const char *suffix)\n {\n   int prefix_len = strlen (prefix);\n   int suffix_len = strlen (suffix);\n@@ -254,12 +248,11 @@ ident_subst (old_name, old_length, prefix, old_char, new_char, suffix)\n    Also, PREFIX is prepended, and SUFFIX is appended. */\n \n tree\n-identifier_subst (old_id, prefix, old_char, new_char, suffix)\n-     const tree old_id;\n-     const char *prefix;\n-     int old_char;\n-     int new_char;\n-     const char *suffix;\n+identifier_subst (const tree old_id,\n+\t\t  const char *prefix,\n+\t\t  int old_char,\n+\t\t  int new_char,\n+\t\t  const char *suffix)\n {\n   return ident_subst (IDENTIFIER_POINTER (old_id), IDENTIFIER_LENGTH (old_id),\n \t\t      prefix, old_char, new_char, suffix);\n@@ -269,9 +262,7 @@ identifier_subst (old_id, prefix, old_char, new_char, suffix)\n    prefixed by PREFIX. */\n \n tree\n-mangled_classname (prefix, type)\n-  const char *prefix;\n-  tree type;\n+mangled_classname (const char *prefix, tree type)\n {\n   tree ident = TYPE_NAME (type);\n   if (TREE_CODE (ident) != IDENTIFIER_NODE)\n@@ -280,7 +271,7 @@ mangled_classname (prefix, type)\n }\n \n tree\n-make_class ()\n+make_class (void)\n {\n   tree type;\n   type = make_node (RECORD_TYPE);\n@@ -295,8 +286,7 @@ make_class ()\n    return a corresponding IDENTIFIER_NODE, except using '.' as separator. */\n \n tree\n-unmangle_classname (name, name_length)\n-     const char *name;  int name_length;\n+unmangle_classname (const char *name, int name_length)\n {\n   tree to_return = ident_subst (name, name_length, \"\", '/', '.', \"\");\n   /* It's not sufficient to compare to_return and get_identifier\n@@ -315,8 +305,7 @@ unmangle_classname (name, name_length)\n }\n \n tree\n-push_class (class_type, class_name)\n-     tree class_type, class_name;\n+push_class (tree class_type, tree class_name)\n {\n   tree decl, signature;\n   const char *save_input_filename = input_filename;\n@@ -351,8 +340,7 @@ push_class (class_type, class_name)\n    fill in field or methods, or do layout_type. */\n \n tree\n-lookup_class (name)\n-     tree name;\n+lookup_class (tree name)\n {\n   tree decl = IDENTIFIER_CLASS_VALUE (name);\n   if (decl == NULL_TREE)\n@@ -361,11 +349,8 @@ lookup_class (name)\n }\n \n void\n-set_super_info (access_flags, this_class, super_class, interfaces_count)\n-     int access_flags;\n-     tree this_class;\n-     tree super_class;\n-     int interfaces_count;\n+set_super_info (int access_flags, tree this_class,\n+\t\ttree super_class, int interfaces_count)\n {\n   int total_supers = interfaces_count;\n   tree class_decl = TYPE_NAME (this_class);\n@@ -388,9 +373,7 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n }\n \n void\n-set_class_decl_access_flags (access_flags, class_decl)\n-     int access_flags;\n-     tree class_decl;\n+set_class_decl_access_flags (int access_flags, tree class_decl)\n {\n   if (access_flags & ACC_PUBLIC)    CLASS_PUBLIC (class_decl) = 1;\n   if (access_flags & ACC_FINAL)     CLASS_FINAL (class_decl) = 1;\n@@ -407,8 +390,7 @@ set_class_decl_access_flags (access_flags, class_decl)\n    direct sub-classes of Object are 1, and so on. */\n \n int\n-class_depth (clas)\n-     tree clas;\n+class_depth (tree clas)\n {\n   int depth = 0;\n   if (! CLASS_LOADED_P (clas))\n@@ -426,8 +408,7 @@ class_depth (clas)\n /* Return true iff TYPE2 is an interface that extends interface TYPE1 */\n \n int\n-interface_of_p (type1, type2)\n-     tree type1, type2;\n+interface_of_p (tree type1, tree type2)\n {\n   int n, i;\n   tree basetype_vec;\n@@ -454,8 +435,7 @@ interface_of_p (type1, type2)\n /* Return true iff TYPE1 inherits from TYPE2. */\n \n int\n-inherits_from_p (type1, type2)\n-     tree type1, type2;\n+inherits_from_p (tree type1, tree type2)\n {\n   while (type1 != NULL_TREE && TREE_CODE (type1) == RECORD_TYPE)\n     {\n@@ -469,8 +449,7 @@ inherits_from_p (type1, type2)\n /* Return a 1 iff TYPE1 is an enclosing context for TYPE2 */\n \n int\n-enclosing_context_p (type1, type2)\n-     tree type1, type2;\n+enclosing_context_p (tree type1, tree type2)\n {\n   if (!INNER_CLASS_TYPE_P (type2))\n     return 0;\n@@ -490,8 +469,7 @@ enclosing_context_p (type1, type2)\n /* Return 1 iff there exists a common enclosing context between TYPE1\n    and TYPE2.  */\n \n-int common_enclosing_context_p (type1, type2)\n-     tree type1, type2;\n+int common_enclosing_context_p (tree type1, tree type2)\n {\n   if (!PURE_INNER_CLASS_TYPE_P (type1) || !PURE_INNER_CLASS_TYPE_P (type2))\n     return 0;\n@@ -512,9 +490,7 @@ int common_enclosing_context_p (type1, type2)\n }\n \n static void\n-add_interface_do (basetype_vec, interface_class, i)\n-     tree basetype_vec, interface_class;\n-     int i;\n+add_interface_do (tree basetype_vec, tree interface_class, int i)\n {\n   tree interface_binfo = make_tree_vec (6);\n   BINFO_TYPE (interface_binfo) = interface_class;\n@@ -530,8 +506,7 @@ add_interface_do (basetype_vec, interface_class, i)\n    if attempt is made to add it twice. */\n \n tree\n-maybe_add_interface (this_class, interface_class)\n-     tree this_class, interface_class;\n+maybe_add_interface (tree this_class, tree interface_class)\n {\n   tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n   int i;\n@@ -555,8 +530,7 @@ maybe_add_interface (this_class, interface_class)\n /* Add the INTERFACE_CLASS as one of the interfaces of THIS_CLASS. */\n \n void\n-add_interface (this_class, interface_class)\n-     tree this_class, interface_class;\n+add_interface (tree this_class, tree interface_class)\n {\n   tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n   int i;\n@@ -579,9 +553,7 @@ add_interface (this_class, interface_class)\n    in the list (*LIST) whose DECL_NAME is NAME. */\n \n static tree *\n-find_named_method (list, name)\n-     tree *list;\n-     tree name;\n+find_named_method (tree *list, tree name)\n {\n   while (*list && DECL_NAME (*list) != name)\n     list = &TREE_CHAIN (*list);\n@@ -590,22 +562,15 @@ find_named_method (list, name)\n #endif\n \n static tree\n-build_java_method_type (fntype, this_class, access_flags)\n-     tree fntype;\n-     tree this_class;\n-     int access_flags;\n+build_java_method_type (tree fntype, tree this_class, int access_flags)\n {\n   if (access_flags & ACC_STATIC)\n     return fntype;\n   return build_method_type (this_class, fntype);\n }\n \n tree\n-add_method_1 (this_class, access_flags, name, function_type)\n-     tree this_class;\n-     int access_flags;\n-     tree name;\n-     tree function_type;\n+add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n {\n   tree method_type, fndecl;\n \n@@ -667,11 +632,7 @@ add_method_1 (this_class, access_flags, name, function_type)\n    Its signature (mangled type) is METHOD_SIG (an IDENTIFIER_NODE). */\n \n tree\n-add_method (this_class, access_flags, name, method_sig)\n-     tree this_class;\n-     int access_flags;\n-     tree name;\n-     tree method_sig;\n+add_method (tree this_class, int access_flags, tree name, tree method_sig)\n {\n   tree function_type, fndecl;\n   const unsigned char *sig\n@@ -687,11 +648,7 @@ add_method (this_class, access_flags, name, method_sig)\n }\n \n tree\n-add_field (class, name, field_type, flags)\n-     tree class;\n-     tree name;\n-     tree field_type;\n-     int flags;\n+add_field (tree class, tree name, tree field_type, int flags)\n {\n   int is_static = (flags & ACC_STATIC) != 0;\n   tree field;\n@@ -723,8 +680,7 @@ add_field (class, name, field_type, flags)\n /* Associate a constant value CONSTANT with VAR_DECL FIELD. */\n \n void\n-set_constant_value (field, constant)\n-     tree field, constant;\n+set_constant_value (tree field, tree constant)\n {\n   if (field == NULL_TREE)\n     warning (\"misplaced ConstantValue attribute (not in any field)\");\n@@ -751,9 +707,7 @@ set_constant_value (field, constant)\n \n #if 0\n int\n-strLengthUtf8 (str, len)\n-     char *str;\n-     int len;\n+strLengthUtf8 (char *str, int len)\n {\n   register unsigned char* ptr = (unsigned char*) str;\n   register unsigned char *limit = ptr + len;\n@@ -772,9 +726,7 @@ strLengthUtf8 (str, len)\n  */\n \n static int32\n-hashUtf8String (str, len)\n-     const char *str;\n-     int len;\n+hashUtf8String (const char *str, int len)\n {\n   register const unsigned char* ptr = (const unsigned char*) str;\n   register const unsigned char *limit = ptr + len;\n@@ -794,9 +746,7 @@ hashUtf8String (str, len)\n    compiled Java resource, which is accessed by the runtime using\n    NAME.  */\n void\n-compile_resource_file (name, filename)\n-     char *name;\n-     const char *filename;\n+compile_resource_file (char *name, const char *filename)\n {\n   struct stat stat_buf;\n   int fd;\n@@ -898,8 +848,7 @@ compile_resource_file (name, filename)\n tree utf8_decl_list = NULL_TREE;\n \n tree\n-build_utf8_ref (name)\n-     tree name;\n+build_utf8_ref (tree name)\n {\n   const char * name_ptr = IDENTIFIER_POINTER(name);\n   int name_len = IDENTIFIER_LENGTH(name);\n@@ -971,8 +920,7 @@ build_utf8_ref (name)\n    Also handles primitive types and array types. */\n \n tree\n-build_class_ref (type)\n-     tree type;\n+build_class_ref (tree type)\n {\n   int is_compiled = is_compiled_class (type);\n   if (is_compiled)\n@@ -1073,8 +1021,7 @@ build_class_ref (type)\n }\n \n tree\n-build_static_field_ref (fdecl)\n-     tree fdecl;\n+build_static_field_ref (tree fdecl)\n {\n   tree fclass = DECL_CONTEXT (fdecl);\n   int is_compiled = is_compiled_class (fclass);\n@@ -1124,8 +1071,7 @@ build_static_field_ref (fdecl)\n }\n \n int\n-get_access_flags_from_decl (decl)\n-     tree decl;\n+get_access_flags_from_decl (tree decl)\n {\n   int access_flags = 0;\n   if (TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL)\n@@ -1196,8 +1142,7 @@ get_access_flags_from_decl (decl)\n }\n \n static tree\n-make_field_value (fdecl)\n-  tree fdecl;\n+make_field_value (tree fdecl)\n {\n   tree finit;\n   int flags;\n@@ -1241,8 +1186,7 @@ make_field_value (fdecl)\n }\n \n static tree\n-make_method_value (mdecl)\n-     tree mdecl;\n+make_method_value (tree mdecl)\n {\n   static int method_name_count = 0;\n   tree minit;\n@@ -1318,8 +1262,7 @@ make_method_value (mdecl)\n }\n \n static tree\n-get_dispatch_vector (type)\n-     tree type;\n+get_dispatch_vector (tree type)\n {\n   tree vtable = TYPE_VTABLE (type);\n   if (vtable == NULL)\n@@ -1350,8 +1293,7 @@ get_dispatch_vector (type)\n }\n \n static tree\n-get_dispatch_table (type, this_class_addr)\n-     tree type, this_class_addr;\n+get_dispatch_table (tree type, tree this_class_addr)\n {\n   int abstract_p = CLASS_ABSTRACT (TYPE_NAME (type));\n   tree vtable = get_dispatch_vector (type);\n@@ -1426,8 +1368,7 @@ get_dispatch_table (type, this_class_addr)\n }\n \n void\n-make_class_data (type)\n-     tree type;\n+make_class_data (tree type)\n {\n   tree decl, cons, temp;\n   tree field, fields_decl;\n@@ -1685,7 +1626,7 @@ make_class_data (type)\n }\n \n void\n-finish_class ()\n+finish_class (void)\n {\n   tree method;\n   tree type_methods = TYPE_METHODS (current_class);\n@@ -1729,8 +1670,7 @@ finish_class ()\n    return 0 if we cannot assume that CLASS is compiled.\n    Returns 1 for primitive and 0 for array types.  */\n int\n-is_compiled_class (class)\n-     tree class;\n+is_compiled_class (tree class)\n {\n   int seen_in_zip;\n   if (TREE_CODE (class) == POINTER_TYPE)\n@@ -1776,8 +1716,7 @@ is_compiled_class (class)\n /* Build a VAR_DECL for the dispatch table (vtable) for class TYPE. */\n \n tree\n-build_dtable_decl (type)\n-     tree type;\n+build_dtable_decl (tree type)\n {\n   tree dtype;\n \n@@ -1835,8 +1774,7 @@ build_dtable_decl (type)\n    fields inherited from SUPER_CLASS. */\n \n void\n-push_super_field (this_class, super_class)\n-     tree this_class, super_class;\n+push_super_field (tree this_class, tree super_class)\n {\n   tree base_decl;\n   /* Don't insert the field if we're just re-laying the class out. */ \n@@ -1853,9 +1791,7 @@ push_super_field (this_class, super_class)\n /* Handle the different manners we may have to lay out a super class.  */\n \n static tree\n-maybe_layout_super_class (super_class, this_class)\n-     tree super_class;\n-     tree this_class;\n+maybe_layout_super_class (tree super_class, tree this_class)\n {\n   if (TREE_CODE (super_class) == RECORD_TYPE)\n     {\n@@ -1886,8 +1822,7 @@ maybe_layout_super_class (super_class, this_class)\n }\n \n void\n-layout_class (this_class)\n-     tree this_class;\n+layout_class (tree this_class)\n {\n   tree super_class = CLASSTYPE_SUPER (this_class);\n   tree field;\n@@ -1990,8 +1925,7 @@ layout_class (this_class)\n }\n \n void\n-layout_class_methods (this_class)\n-     tree this_class;\n+layout_class_methods (tree this_class)\n {\n   tree method_decl, dtable_count;\n   tree super_class;\n@@ -2028,8 +1962,8 @@ layout_class_methods (this_class)\n    DTABLE_COUNT. Also mangle the method's name. */\n \n tree\n-layout_class_method (this_class, super_class, method_decl, dtable_count)\n-     tree this_class, super_class, method_decl, dtable_count;\n+layout_class_method (tree this_class, tree super_class,\n+\t\t     tree method_decl, tree dtable_count)\n {\n   tree method_name = DECL_NAME (method_decl);\n \n@@ -2087,7 +2021,7 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n }\n \n void\n-register_class ()\n+register_class (void)\n {\n   /* END does not need to be registered with the garbage collector\n      because it always points into the list given by REGISTERED_CLASS,\n@@ -2114,7 +2048,7 @@ register_class ()\n    class in this file.  */\n \n void\n-emit_register_classes ()\n+emit_register_classes (void)\n {\n   /* ??? This isn't quite the correct test.  We also have to know\n      that the target is using gcc's crtbegin/crtend objects rather\n@@ -2205,7 +2139,7 @@ build_method_symbols_entry (tree method)\n /* Emit the offset symbols table for indirect virtual dispatch. */\n \n void\n-emit_offset_symbol_table ()\n+emit_offset_symbol_table (void)\n {\n   tree method_list, method, table, list, null_symbol;\n   tree otable_bound, otable_array_type;\n@@ -2260,7 +2194,7 @@ emit_offset_symbol_table ()\n }\n \n void\n-init_class_processing ()\n+init_class_processing (void)\n {\n   registerClass_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterClass\");\n   registerResource_libfunc = \n@@ -2278,27 +2212,22 @@ static int java_treetreehash_compare (const void *, const void *);\n #define JAVA_TREEHASHHASH_H(t) (htab_hash_pointer (t))\n \n static hashval_t\n-java_treetreehash_hash (k_p)\n-     const void *k_p;\n+java_treetreehash_hash (const void *k_p)\n {\n   struct treetreehash_entry *k = (struct treetreehash_entry *) k_p;\n   return JAVA_TREEHASHHASH_H (k->key);\n }\n \n static int\n-java_treetreehash_compare (k1_p, k2_p)\n-     const void * k1_p;\n-     const void * k2_p;\n+java_treetreehash_compare (const void * k1_p, const void * k2_p)\n {\n   struct treetreehash_entry * k1 = (struct treetreehash_entry *) k1_p;\n   tree k2 = (tree) k2_p;\n   return (k1->key == k2);\n }\n \n tree \n-java_treetreehash_find (ht, t)\n-     htab_t ht;\n-     tree t;\n+java_treetreehash_find (htab_t ht, tree t)\n {\n   struct treetreehash_entry *e;\n   hashval_t hv = JAVA_TREEHASHHASH_H (t);\n@@ -2310,9 +2239,7 @@ java_treetreehash_find (ht, t)\n }\n \n tree *\n-java_treetreehash_new (ht, t)\n-     htab_t ht;\n-     tree t;\n+java_treetreehash_new (htab_t ht, tree t)\n {\n   void **e;\n   struct treetreehash_entry *tthe;\n@@ -2331,9 +2258,7 @@ java_treetreehash_new (ht, t)\n }\n \n htab_t\n-java_treetreehash_create (size, gc)\n-     size_t size;\n-     int gc;\n+java_treetreehash_create (size_t size, int gc)\n {\n   if (gc)\n     return htab_create_ggc (size, java_treetreehash_hash,"}, {"sha": "583e0bd7134c5ccb10a4b6c9781c44d07b29faba", "filename": "gcc/java/constants.c", "status": "modified", "additions": 21, "deletions": 63, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -41,11 +41,7 @@ static tree build_constant_data_ref (void);\n /* Set the INDEX'th constant in CPOOL to have the given TAG and VALUE. */\n \n static void\n-set_constant_entry (cpool, index, tag, value)\n-     CPool *cpool;\n-     int index;\n-     int tag;\n-     jword value;\n+set_constant_entry (CPool *cpool, int index, int tag, jword value)\n {\n   if (cpool->data == NULL)\n     {\n@@ -73,10 +69,7 @@ set_constant_entry (cpool, index, tag, value)\n /* Find (or create) a constant pool entry matching TAG and VALUE. */\n \n int\n-find_constant1 (cpool, tag, value)\n-     CPool *cpool;\n-     int tag;\n-     jword value;\n+find_constant1 (CPool *cpool, int tag, jword value)\n {\n   int i;\n   for (i = cpool->count;  --i > 0; )\n@@ -92,10 +85,7 @@ find_constant1 (cpool, tag, value)\n /* Find a double-word constant pool entry matching TAG and WORD1/WORD2. */\n \n int\n-find_constant2 (cpool, tag, word1, word2)\n-     CPool *cpool;\n-     int tag;\n-     jword word1, word2;\n+find_constant2 (CPool *cpool, int tag, jword word1, jword word2)\n {\n   int i;\n   for (i = cpool->count - 1;  --i > 0; )\n@@ -112,10 +102,7 @@ find_constant2 (cpool, tag, word1, word2)\n }\n \n static int\n-find_tree_constant (cpool, tag, value)\n-     CPool *cpool;\n-     int tag;\n-     tree value;\n+find_tree_constant (CPool *cpool, int tag, tree value)\n {\n   int i;\n   for (i = cpool->count;  --i > 0; )\n@@ -131,20 +118,15 @@ find_tree_constant (cpool, tag, value)\n \n \n int\n-find_utf8_constant (cpool, name)\n-     CPool *cpool;\n-     tree name;\n+find_utf8_constant (CPool *cpool, tree name)\n {\n   if (name == NULL_TREE)\n     return 0;\n   return find_tree_constant (cpool, CONSTANT_Utf8, name);\n }\n \n static int\n-find_class_or_string_constant (cpool, tag, name)\n-     CPool *cpool;\n-     int tag;\n-     tree name;\n+find_class_or_string_constant (CPool *cpool, int tag, tree name)\n {\n   jword j = find_utf8_constant (cpool, name);\n   int i;\n@@ -159,9 +141,7 @@ find_class_or_string_constant (cpool, tag, name)\n }\n \n int\n-find_class_constant (cpool, type)\n-     CPool *cpool;\n-     tree type;\n+find_class_constant (CPool *cpool, tree type)\n {\n   return find_class_or_string_constant (cpool, CONSTANT_Class,\n \t\t\t\t\tbuild_internal_class_name (type));\n@@ -170,9 +150,7 @@ find_class_constant (cpool, type)\n /* Allocate a CONSTANT_string entry given a STRING_CST. */\n \n int\n-find_string_constant (cpool, string)\n-     CPool *cpool;\n-     tree string;\n+find_string_constant (CPool *cpool, tree string)\n {\n   string = get_identifier (TREE_STRING_POINTER (string));\n   return find_class_or_string_constant (cpool, CONSTANT_String, string);\n@@ -183,10 +161,7 @@ find_string_constant (cpool, string)\n    Return its index in the constant pool CPOOL. */\n \n static int\n-find_name_and_type_constant (cpool, name, type)\n-     CPool *cpool;\n-     tree name;\n-     tree type;\n+find_name_and_type_constant (CPool *cpool, tree name, tree type)\n {\n   int name_index = find_utf8_constant (cpool, name);\n   int type_index = find_utf8_constant (cpool, build_java_signature (type));\n@@ -198,9 +173,7 @@ find_name_and_type_constant (cpool, name, type)\n    Return its index in the constant pool CPOOL. */\n \n int\n-find_fieldref_index (cpool, decl)\n-     CPool *cpool;\n-     tree decl;\n+find_fieldref_index (CPool *cpool, tree decl)\n {\n   int class_index = find_class_constant (cpool, DECL_CONTEXT (decl));\n   int name_type_index\n@@ -213,18 +186,13 @@ find_fieldref_index (cpool, decl)\n    Return its index in the constant pool CPOOL. */\n \n int\n-find_methodref_index (cpool, decl)\n-     CPool *cpool;\n-     tree decl;\n+find_methodref_index (CPool *cpool, tree decl)\n {\n   return find_methodref_with_class_index (cpool, decl, DECL_CONTEXT (decl));\n }\n \n int\n-find_methodref_with_class_index (cpool, decl, mclass)\n-     CPool *cpool;\n-     tree decl;\n-     tree mclass;\n+find_methodref_with_class_index (CPool *cpool, tree decl, tree mclass)\n {\n   int class_index = find_class_constant (cpool, mclass);\n   tree name = DECL_CONSTRUCTOR_P (decl) ? init_identifier_node\n@@ -248,8 +216,7 @@ find_methodref_with_class_index (cpool, decl, mclass)\n    constant pool.  Includes the 2-byte constant_pool_count. */\n \n int\n-count_constant_pool_bytes (cpool)\n-     CPool *cpool;\n+count_constant_pool_bytes (CPool *cpool)\n {\n   int size = 2;\n   int i = 1;\n@@ -294,10 +261,7 @@ count_constant_pool_bytes (cpool)\n    The length of BUFFER is LENGTH, which must match the needed length. */\n \n void\n-write_constant_pool (cpool, buffer, length)\n-     CPool *cpool;\n-     unsigned char *buffer;\n-     int length;\n+write_constant_pool (CPool *cpool, unsigned char *buffer, int length)\n {\n   unsigned char *ptr = buffer;\n   int i = 1;\n@@ -348,8 +312,7 @@ CPool *outgoing_cpool;\n \n static GTY(()) tree tag_nodes[13];\n static tree\n-get_tag_node (tag)\n-     int tag;\n+get_tag_node (int tag)\n {\n   /* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n \n@@ -365,18 +328,15 @@ get_tag_node (tag)\n    Returns the index of the entry. */\n \n int\n-alloc_name_constant (tag, name)\n-     int tag;\n-     tree name;\n+alloc_name_constant (int tag, tree name)\n {\n   return find_tree_constant (outgoing_cpool, tag, name);\n }\n \n /* Build an identifier for the internal name of reference type TYPE. */\n \n tree\n-build_internal_class_name (type)\n-     tree type;\n+build_internal_class_name (tree type)\n {\n   tree name;\n   if (TYPE_ARRAY_P (type))\n@@ -394,8 +354,7 @@ build_internal_class_name (type)\n /* Look for a CONSTANT_Class entry for CLAS, creating a new one if needed. */\n \n int\n-alloc_class_constant (clas)\n-     tree clas;\n+alloc_class_constant (tree clas)\n {\n   tree class_name = build_internal_class_name (clas);\n   \n@@ -408,7 +367,7 @@ alloc_class_constant (clas)\n /* Return a reference to the data array of the current constant pool. */\n \n static tree\n-build_constant_data_ref ()\n+build_constant_data_ref (void)\n {\n   tree cpool_data_ref = NULL_TREE;\n \n@@ -433,8 +392,7 @@ build_constant_data_ref ()\n /* Get the pointer value at the INDEX'th element of the constant pool. */\n \n tree\n-build_ref_from_constant_pool (index)\n-     int index;\n+build_ref_from_constant_pool (int index)\n {\n   tree t = build_constant_data_ref ();\n   index *= int_size_in_bytes (ptr_type_node);\n@@ -447,7 +405,7 @@ build_ref_from_constant_pool (index)\n    Should only be called at top-level, since it may emit declarations. */\n \n tree\n-build_constants_constructor ()\n+build_constants_constructor (void)\n {\n   tree tags_value, data_value;\n   tree cons;"}, {"sha": "d07f83ee098c3fac93bb1db8a6df18e06ebfbb3f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 40, "deletions": 81, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -93,7 +93,7 @@ int is_class_level = 0;\n int current_pc;\n \n void\n-indent ()\n+indent (void)\n {\n   register unsigned i;\n \n@@ -103,9 +103,7 @@ indent ()\n #endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n \n static tree\n-push_jvm_slot (index, decl)\n-     int index;\n-     tree decl;\n+push_jvm_slot (int index, tree decl)\n {\n   struct rtx_def *rtl = NULL;\n   tree type = TREE_TYPE (decl);\n@@ -152,11 +150,7 @@ push_jvm_slot (index, decl)\n    is returned, then updated is set to true.  */\n \n static tree\n-check_local_named_variable (best, decl, pc, updated)\n-     tree best;\n-     tree decl;\n-     int pc;\n-     int *updated;\n+check_local_named_variable (tree best, tree decl, int pc, int *updated)\n {\n   if (pc >= DECL_LOCAL_START_PC (decl)\n       && pc < DECL_LOCAL_END_PC (decl))\n@@ -177,10 +171,7 @@ check_local_named_variable (best, decl, pc, updated)\n    than 'best', return 'decl'.  Otherwise return 'best'.  */\n \n static tree\n-check_local_unnamed_variable (best, decl, type)\n-     tree best;\n-     tree decl;\n-     tree type;\n+check_local_unnamed_variable (tree best, tree decl, tree type)\n {\n     if (TREE_TYPE (decl) == type\n \t|| (TREE_CODE (TREE_TYPE (decl)) == TREE_CODE (type)\n@@ -204,10 +195,7 @@ check_local_unnamed_variable (best, decl, type)\n    If there is no existing matching decl, allocate one.  */\n \n tree\n-find_local_variable (index, type, pc)\n-     int index;\n-     tree type;\n-     int pc;\n+find_local_variable (int index, tree type, int pc)\n {\n   tree decl = TREE_VEC_ELT (decl_map, index);\n   tree best = NULL_TREE;\n@@ -253,9 +241,7 @@ find_local_variable (index, type, pc)\n /* Same as find_local_index, except that INDEX is a stack index. */\n \n tree\n-find_stack_slot (index, type)\n-     int index;\n-     tree type;\n+find_stack_slot (int index, tree type)\n {\n   return find_local_variable (index + DECL_MAX_LOCALS (current_function_decl),\n \t\t\t      type, -1);\n@@ -341,9 +327,7 @@ tree java_global_trees[JTI_MAX];\n    types shorter than int.  */\n \n static tree\n-push_promoted_type (name, actual_type)\n-     const char *name;\n-     tree actual_type;\n+push_promoted_type (const char *name, tree actual_type)\n {\n   tree type = make_node (TREE_CODE (actual_type));\n #if 1\n@@ -373,13 +357,12 @@ push_promoted_type (name, actual_type)\n    ATTRS is nonzero, use that for the function's attribute list.  */\n \n tree\n-builtin_function (name, type, function_code, class, library_name, attrs)\n-     const char *name;\n-     tree type;\n-     int function_code;\n-     enum built_in_class class;\n-     const char *library_name;\n-     tree attrs ATTRIBUTE_UNUSED;\n+builtin_function (const char *name,\n+\t\t  tree type,\n+\t\t  int function_code,\n+\t\t  enum built_in_class class,\n+\t\t  const char *library_name,\n+\t\t  tree attrs ATTRIBUTE_UNUSED)\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n@@ -395,8 +378,7 @@ builtin_function (name, type, function_code, class, library_name, attrs)\n \n /* Return tree that represents a vtable for a primitive array.  */\n static tree\n-create_primitive_vtable (name)\n-     const char *name;\n+create_primitive_vtable (const char *name)\n {\n   tree r;\n   char buf[50];\n@@ -408,7 +390,7 @@ create_primitive_vtable (name)\n }\n \n void\n-java_init_decl_processing ()\n+java_init_decl_processing (void)\n {\n   register tree endlink;\n   tree field = NULL_TREE;\n@@ -952,8 +934,7 @@ java_init_decl_processing ()\n    or return 0 if it is undefined.  */\n \n tree\n-lookup_name (name)\n-     tree name;\n+lookup_name (tree name)\n {\n   register tree val;\n   if (current_binding_level != global_binding_level\n@@ -968,8 +949,7 @@ lookup_name (name)\n    the previous one if its the parameter level.  */\n \n static tree\n-lookup_name_current_level (name)\n-     tree name;\n+lookup_name_current_level (tree name)\n {\n   register tree t;\n \n@@ -989,8 +969,7 @@ lookup_name_current_level (name)\n /* Use a binding level to record a labeled block declaration */\n \n void\n-push_labeled_block (lb)\n-    tree lb;\n+push_labeled_block (tree lb)\n {\n   register tree name = DECL_NAME (LABELED_BLOCK_LABEL (lb));\n   register struct binding_level *b = current_binding_level;\n@@ -1006,7 +985,7 @@ push_labeled_block (lb)\n    labeled block */\n \n void\n-pop_labeled_block ()\n+pop_labeled_block (void)\n {\n   struct binding_level *b = current_binding_level;\n   tree label =  b->names;\n@@ -1031,8 +1010,7 @@ pop_labeled_block ()\n    to agree with what X says.  */\n \n tree\n-pushdecl (x)\n-     tree x;\n+pushdecl (tree x)\n {\n   register tree t;\n   register tree name = DECL_NAME (x);\n@@ -1150,17 +1128,15 @@ pushdecl (x)\n }\n \n void\n-pushdecl_force_head (x)\n-     tree x;\n+pushdecl_force_head (tree x)\n {\n   current_binding_level->names = x;\n }\n \n /* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */\n \n tree\n-pushdecl_top_level (x)\n-     tree x;\n+pushdecl_top_level (tree x)\n {\n   register tree t;\n   register struct binding_level *b = current_binding_level;\n@@ -1174,7 +1150,7 @@ pushdecl_top_level (x)\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n-global_bindings_p ()\n+global_bindings_p (void)\n {\n   return current_binding_level == global_binding_level;\n }\n@@ -1185,23 +1161,22 @@ global_bindings_p ()\n    store the result back using `storedecls' or you will lose.  */\n \n tree\n-getdecls ()\n+getdecls (void)\n {\n   return current_binding_level->names;\n }\n \n /* Create a new `struct binding_level'.  */\n \n static struct binding_level *\n-make_binding_level ()\n+make_binding_level (void)\n {\n   /* NOSTRICT */\n   return xmalloc (sizeof (struct binding_level));\n }\n \n void\n-pushlevel (unused)\n-  int unused ATTRIBUTE_UNUSED;\n+pushlevel (int unused ATTRIBUTE_UNUSED)\n {\n   register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n \n@@ -1257,10 +1232,7 @@ pushlevel (unused)\n    them into the BLOCK.  */\n \n tree\n-poplevel (keep, reverse, functionbody)\n-     int keep;\n-     int reverse;\n-     int functionbody;\n+poplevel (int keep, int reverse, int functionbody)\n {\n   register tree link;\n   /* The chain of decls was accumulated in reverse order.\n@@ -1464,8 +1436,7 @@ poplevel (keep, reverse, functionbody)\n }\n \n void\n-maybe_pushlevels (pc)\n-     int pc;\n+maybe_pushlevels (int pc)\n {\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   current_pc = pc;\n@@ -1507,8 +1478,7 @@ maybe_pushlevels (pc)\n }\n \n void\n-maybe_poplevels (pc)\n-     int pc;\n+maybe_poplevels (int pc)\n {\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   current_pc = pc;\n@@ -1529,8 +1499,7 @@ maybe_poplevels (pc)\n    range is forcibly terminated when that exception ends. */\n \n void\n-force_poplevels (start_pc)\n-     int start_pc;\n+force_poplevels (int start_pc)\n {\n   while (current_binding_level->start_pc > start_pc)\n     {\n@@ -1548,8 +1517,7 @@ force_poplevels (start_pc)\n    to handle the BLOCK node inside the BIND_EXPR.  */\n \n void\n-insert_block (block)\n-     tree block;\n+insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n   current_binding_level->blocks\n@@ -1560,8 +1528,7 @@ insert_block (block)\n    (the one we are currently in).  */\n \n void\n-set_block (block)\n-     register tree block;\n+set_block (tree block)\n {\n   current_binding_level->this_block = block;\n   current_binding_level->names = chainon (current_binding_level->names,\n@@ -1573,8 +1540,7 @@ set_block (block)\n /* integrate_decl_tree calls this function. */\n \n void\n-java_dup_lang_specific_decl (node)\n-     tree node;\n+java_dup_lang_specific_decl (tree node)\n {\n   int lang_decl_size;\n   struct lang_decl *x;\n@@ -1589,8 +1555,7 @@ java_dup_lang_specific_decl (node)\n }\n \n void\n-give_name_to_locals (jcf)\n-     JCF *jcf;\n+give_name_to_locals (JCF *jcf)\n {\n   int i, n = DECL_LOCALVARIABLES_OFFSET (current_function_decl);\n   int code_offset = DECL_CODE_OFFSET (current_function_decl);\n@@ -1688,8 +1653,7 @@ give_name_to_locals (jcf)\n }\n \n tree\n-build_result_decl (fndecl)\n-  tree fndecl;\n+build_result_decl (tree fndecl)\n {\n   tree restype = TREE_TYPE (TREE_TYPE (fndecl));\n   tree result = DECL_RESULT (fndecl);\n@@ -1707,8 +1671,7 @@ build_result_decl (fndecl)\n }\n \n void\n-complete_start_java_method (fndecl)\n-  tree fndecl;\n+complete_start_java_method (tree fndecl)\n {\n   if (! flag_emit_class_files)\n     {\n@@ -1780,8 +1743,7 @@ complete_start_java_method (fndecl)\n }\n \n void\n-start_java_method (fndecl)\n-     tree fndecl;\n+start_java_method (tree fndecl)\n {\n   tree tem, *ptr;\n   int i;\n@@ -1840,7 +1802,7 @@ start_java_method (fndecl)\n }\n \n void\n-end_java_method ()\n+end_java_method (void)\n {\n   tree fndecl = current_function_decl;\n \n@@ -1865,9 +1827,7 @@ end_java_method ()\n /* Dump FUNCTION_DECL FN as tree dump PHASE. */\n \n static void\n-dump_function (phase, fn)\n-     enum tree_dump_index phase;\n-     tree fn;\n+dump_function (enum tree_dump_index phase, tree fn)\n {\n   FILE *stream;\n   int flags;\n@@ -1880,8 +1840,7 @@ dump_function (phase, fn)\n     }\n }\n  \n-void java_optimize_inline (fndecl)\n-     tree fndecl;\n+void java_optimize_inline (tree fndecl)\n {\n   if (flag_inline_trees)\n     {"}, {"sha": "600deb89f45fc70915055b151b4127212002dea0", "filename": "gcc/java/except.c", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -77,10 +77,7 @@ extern void indent ();\n    previous children have end_pc values that are too low. */\n \n static struct eh_range *\n-find_handler_in_range (pc, range, child)\n-     int pc;\n-     struct eh_range *range;\n-     register struct eh_range *child;\n+find_handler_in_range (int pc, struct eh_range *range, struct eh_range *child)\n {\n   for (; child != NULL;  child = child->next_sibling)\n     {\n@@ -99,8 +96,7 @@ find_handler_in_range (pc, range, child)\n /* Find the inner-most handler that contains PC. */\n \n struct eh_range *\n-find_handler (pc)\n-     int pc;\n+find_handler (int pc)\n {\n   struct eh_range *h;\n   if (pc >= cache_range_start)\n@@ -125,8 +121,7 @@ find_handler (pc)\n /* Recursive helper routine for check_nested_ranges. */\n \n static void\n-link_handler (range, outer)\n-     struct eh_range *range, *outer;\n+link_handler (struct eh_range *range, struct eh_range *outer)\n {\n   struct eh_range **ptr;\n \n@@ -208,7 +203,7 @@ link_handler (range, outer)\n    ensure that exception ranges are properly nested.  */\n \n void\n-handle_nested_ranges ()\n+handle_nested_ranges (void)\n {\n   struct eh_range *ptr, *next;\n \n@@ -225,8 +220,7 @@ handle_nested_ranges ()\n /* Free RANGE as well as its children and siblings.  */\n \n static void\n-free_eh_ranges (range)\n-     struct eh_range *range;\n+free_eh_ranges (struct eh_range *range)\n {\n   while (range) \n     {\n@@ -241,7 +235,7 @@ free_eh_ranges (range)\n /* Called to re-initialize the exception machinery for a new method. */\n \n void\n-method_init_exceptions ()\n+method_init_exceptions (void)\n {\n   free_eh_ranges (&whole_range);\n   whole_range.start_pc = 0;\n@@ -267,10 +261,7 @@ method_init_exceptions ()\n    what the sorting counteracts.  */\n \n void\n-add_handler (start_pc, end_pc, handler, type)\n-     int start_pc, end_pc;\n-     tree handler;\n-     tree type;\n+add_handler (int start_pc, int end_pc, tree handler, tree type)\n {\n   struct eh_range *ptr, *prev = NULL, *h;\n \n@@ -306,8 +297,7 @@ add_handler (start_pc, end_pc, handler, type)\n \n /* if there are any handlers for this range, issue start of region */\n static void\n-expand_start_java_handler (range)\n-  struct eh_range *range;\n+expand_start_java_handler (struct eh_range *range)\n {\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   indent ();\n@@ -319,8 +309,7 @@ expand_start_java_handler (range)\n }\n \n tree\n-prepare_eh_table_type (type)\n-    tree type;\n+prepare_eh_table_type (tree type)\n {\n   tree exp;\n \n@@ -347,8 +336,7 @@ prepare_eh_table_type (type)\n    exception header.  */\n \n tree\n-build_exception_object_ref (type)\n-     tree type;\n+build_exception_object_ref (tree type)\n {\n   tree obj;\n \n@@ -365,8 +353,7 @@ build_exception_object_ref (type)\n /* If there are any handlers for this range, isssue end of range,\n    and then all handler blocks */\n static void\n-expand_end_java_handler (range)\n-     struct eh_range *range;\n+expand_end_java_handler (struct eh_range *range)\n {  \n   tree handler = range->handlers;\n   force_poplevels (range->start_pc);\n@@ -398,9 +385,7 @@ expand_end_java_handler (range)\n /* Recursive helper routine for maybe_start_handlers. */\n \n static void\n-check_start_handlers (range, pc)\n-     struct eh_range *range;\n-     int pc;\n+check_start_handlers (struct eh_range *range, int pc)\n {\n   if (range != NULL_EH_RANGE && range->start_pc == pc)\n     {\n@@ -417,9 +402,7 @@ static struct eh_range *current_range;\n    end_pc. */\n \n void\n-maybe_start_try (start_pc, end_pc)\n-     int start_pc;\n-     int end_pc;\n+maybe_start_try (int start_pc, int end_pc)\n {\n   struct eh_range *range;\n   if (! doing_eh (1))\n@@ -438,9 +421,7 @@ maybe_start_try (start_pc, end_pc)\n    start_pc. */\n \n void\n-maybe_end_try (start_pc, end_pc)\n-     int start_pc;\n-     int end_pc;\n+maybe_end_try (int start_pc, int end_pc)\n {\n   if (! doing_eh (1))\n     return;"}, {"sha": "b36e368304110605586321a899a281d73540be12", "filename": "gcc/java/expr.c", "status": "modified", "additions": 86, "deletions": 198, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -137,7 +137,7 @@ const unsigned char *linenumber_table;\n int linenumber_count;\n \n void\n-init_expr_processing()\n+init_expr_processing (void)\n {\n   operand_type[21] = operand_type[54] = int_type_node;\n   operand_type[22] = operand_type[55] = long_type_node;\n@@ -147,8 +147,7 @@ init_expr_processing()\n }\n \n tree\n-java_truthvalue_conversion (expr)\n-     tree expr;\n+java_truthvalue_conversion (tree expr)\n {\n   /* It is simpler and generates better code to have only TRUTH_*_EXPR\n      or comparison expressions as truth values at this level.\n@@ -206,7 +205,7 @@ java_truthvalue_conversion (expr)\n    higher (or the same) index, but not lower. */\n \n static void\n-flush_quick_stack ()\n+flush_quick_stack (void)\n {\n   int stack_index = stack_pointer;\n   register tree prev, cur, next;\n@@ -242,8 +241,7 @@ flush_quick_stack ()\n    Return true on success, 0 on overflow. */\n \n int\n-push_type_0 (type)\n-     tree type;\n+push_type_0 (tree type)\n {\n   int n_words;\n   type = promote_type (type);\n@@ -258,16 +256,14 @@ push_type_0 (type)\n }\n \n void\n-push_type (type)\n-     tree type;\n+push_type (tree type)\n {\n   if (! push_type_0 (type))\n     abort ();\n }\n \n static void\n-push_value (value)\n-     tree value;\n+push_value (tree value)\n {\n   tree type = TREE_TYPE (value);\n   if (TYPE_PRECISION (type) < 32 && INTEGRAL_TYPE_P (type))\n@@ -294,9 +290,7 @@ push_value (value)\n    On an error, *MESSAGEP is set to a freshly malloc'd error message. */\n \n tree\n-pop_type_0 (type, messagep)\n-     tree type;\n-     char **messagep;\n+pop_type_0 (tree type, char **messagep)\n {\n   int n_words;\n   tree t;\n@@ -355,8 +349,7 @@ pop_type_0 (type, messagep)\n    convertible to TYPE, otherwise call error. */\n \n tree\n-pop_type (type)\n-     tree type;\n+pop_type (tree type)\n {\n   char *message = NULL;\n   type = pop_type_0 (type, &message);\n@@ -372,8 +365,7 @@ pop_type (type)\n    Handles array types and interfaces.  */\n \n int\n-can_widen_reference_to (source_type, target_type)\n-     tree source_type, target_type;\n+can_widen_reference_to (tree source_type, tree target_type)\n {\n   if (source_type == ptr_type_node || target_type == object_ptr_type_node)\n     return 1;\n@@ -449,8 +441,7 @@ can_widen_reference_to (source_type, target_type)\n }\n \n static tree\n-pop_value (type)\n-     tree type;\n+pop_value (tree type)\n {\n   type = pop_type (type);\n   if (quick_stack)\n@@ -470,8 +461,7 @@ pop_value (type)\n /* Pop and discrad the top COUNT stack slots. */\n \n static void\n-java_stack_pop (count)\n-     int count;\n+java_stack_pop (int count)\n {\n   while (count > 0)\n     {\n@@ -497,7 +487,7 @@ java_stack_pop (count)\n /* Implement the 'swap' operator (to swap two top stack slots). */\n \n static void\n-java_stack_swap ()\n+java_stack_swap (void)\n {\n   tree type1, type2;\n   rtx temp;\n@@ -522,8 +512,7 @@ java_stack_swap ()\n }\n \n static void\n-java_stack_dup (size, offset)\n-     int size, offset;\n+java_stack_dup (int size, int offset)\n {\n   int low_index = stack_pointer - size - offset;\n   int dst_index;\n@@ -571,8 +560,7 @@ java_stack_dup (size, offset)\n    value stack. */\n \n static void\n-build_java_athrow (node)\n-    tree node;\n+build_java_athrow (tree node)\n {\n   tree call;\n \n@@ -589,8 +577,7 @@ build_java_athrow (node)\n /* Implementation for jsr/ret */\n \n static void\n-build_java_jsr (target_pc, return_pc)\n-     int target_pc, return_pc;\n+build_java_jsr (int target_pc, int return_pc)\n {\n   tree where =  lookup_label (target_pc);\n   tree ret = lookup_label (return_pc);\n@@ -604,17 +591,15 @@ build_java_jsr (target_pc, return_pc)\n }\n \n static void\n-build_java_ret (location)\n-  tree location;\n+build_java_ret (tree location)\n {\n   expand_computed_goto (location);\n }\n  \n /* Implementation of operations on array: new, load, store, length */\n \n tree\n-decode_newarray_type (atype)\n-  int atype;\n+decode_newarray_type (int atype)\n {\n   switch (atype)\n     {\n@@ -633,8 +618,7 @@ decode_newarray_type (atype)\n /* Map primitive type to the code used by OPCODE_newarray. */\n \n int\n-encode_newarray_type (type)\n-     tree type;\n+encode_newarray_type (tree type)\n {\n   if (type == boolean_type_node)\n     return 4;\n@@ -660,8 +644,7 @@ encode_newarray_type (type)\n    ArrayIndexOfBoundsException exception handler.  */\n \n static tree\n-build_java_throw_out_of_bounds_exception (index)\n-    tree index;\n+build_java_throw_out_of_bounds_exception (tree index)\n {\n   tree node = build (CALL_EXPR, int_type_node,\n \t\t     build_address_of (soft_badarrayindex_node), \n@@ -674,8 +657,7 @@ build_java_throw_out_of_bounds_exception (index)\n    or value of the array NODE. May be used to implement some bytecodes.  */\n \n tree\n-build_java_array_length_access (node)\n-    tree node;\n+build_java_array_length_access (tree node)\n {\n   tree type = TREE_TYPE (node);\n   tree array_type = TREE_TYPE (type);\n@@ -710,9 +692,7 @@ build_java_array_length_access (node)\n    checks if we're not generating code.  */\n \n tree \n-java_check_reference (expr, check)\n-     tree expr;\n-     int check;\n+java_check_reference (tree expr, int check)\n {\n   if (!flag_syntax_only && check)\n     {\n@@ -733,10 +713,7 @@ java_check_reference (expr, check)\n /* Reference an object: just like an INDIRECT_REF, but with checking.  */\n \n tree\n-build_java_indirect_ref (type, expr, check)\n-     tree type;\n-     tree expr;\n-     int check;\n+build_java_indirect_ref (tree type, tree expr, int check)\n {\n   return build1 (INDIRECT_REF, type, java_check_reference (expr, check));\n }\n@@ -747,8 +724,7 @@ build_java_indirect_ref (type, expr, check)\n    At this point, ARRAY should have been verified as an array.  */\n \n tree\n-build_java_arrayaccess (array, type, index)\n-    tree array, type, index;\n+build_java_arrayaccess (tree array, tree type, tree index)\n {\n   tree node, throw = NULL_TREE;\n   tree data_field;\n@@ -798,9 +774,7 @@ build_java_arrayaccess (array, type, index)\n    determine that no check is required. */\n \n tree\n-build_java_arraystore_check (array, object)\n-   tree array; \n-   tree object;\n+build_java_arraystore_check (tree array, tree object)\n {\n   tree check, element_type, source;\n   tree array_type_p = TREE_TYPE (array);\n@@ -871,9 +845,7 @@ build_java_arraystore_check (array, object)\n    As a side effect, it also makes sure that ARRAY_NODE is an array.  */\n \n static tree\n-build_java_check_indexed_type (array_node, indexed_type)\n-    tree array_node;\n-    tree indexed_type;\n+build_java_check_indexed_type (tree array_node, tree indexed_type)\n {\n   tree elt_type;\n \n@@ -900,9 +872,7 @@ build_java_check_indexed_type (array_node, indexed_type)\n    of the array to create.  */\n \n tree\n-build_newarray (atype_value, length)\n-     int atype_value;\n-     tree length;\n+build_newarray (int atype_value, tree length)\n {\n   tree type_arg;\n \n@@ -932,9 +902,7 @@ build_newarray (atype_value, length)\n    of the dimension. */\n \n tree\n-build_anewarray (class_type, length)\n-    tree class_type;\n-    tree length;\n+build_anewarray (tree class_type, tree length)\n {\n   tree type\n     = build_java_array_type (class_type,\n@@ -953,9 +921,7 @@ build_anewarray (class_type, length)\n /* Return a node the evaluates 'new TYPE[LENGTH]'. */\n \n tree\n-build_new_array (type, length)\n-     tree type;\n-     tree length;\n+build_new_array (tree type, tree length)\n {\n   if (JPRIMITIVE_TYPE_P (type))\n     return build_newarray (encode_newarray_type (type), length);\n@@ -968,9 +934,7 @@ build_new_array (type, length)\n    dimensions. The argument list is NULL terminated.  */\n \n static void\n-expand_java_multianewarray (class_type, ndim)\n-    tree class_type;\n-    int  ndim;\n+expand_java_multianewarray (tree class_type, int ndim)\n {\n   int i;\n   tree args = build_tree_list( NULL_TREE, null_pointer_node );\n@@ -998,8 +962,7 @@ expand_java_multianewarray (class_type, ndim)\n     type. It is not necessary to generate this code if ARRAY is final.  */\n \n static void\n-expand_java_arraystore (rhs_type_node)\n-     tree rhs_type_node;\n+expand_java_arraystore (tree rhs_type_node)\n {\n   tree rhs_node    = pop_value ((INTEGRAL_TYPE_P (rhs_type_node) \n \t\t\t\t && TYPE_PRECISION (rhs_type_node) <= 32) ? \n@@ -1034,8 +997,7 @@ expand_java_arraystore (rhs_type_node)\n */\n \n static void\n-expand_java_arrayload (lhs_type_node )\n-    tree lhs_type_node;\n+expand_java_arrayload (tree lhs_type_node )\n {\n   tree load_node;\n   tree index_node = pop_value (int_type_node);\n@@ -1067,7 +1029,7 @@ expand_java_arrayload (lhs_type_node )\n    a NULL check on the array object.  */\n \n static void\n-expand_java_array_length ()\n+expand_java_array_length (void)\n {\n   tree array  = pop_value (ptr_type_node);\n   tree length = build_java_array_length_access (array);\n@@ -1079,9 +1041,7 @@ expand_java_array_length ()\n    either soft_monitorenter_node or soft_monitorexit_node.  */\n \n static tree\n-build_java_monitor (call, object)\n-    tree call;\n-    tree object;\n+build_java_monitor (tree call, tree object)\n {\n   return (build (CALL_EXPR,\n \t\t void_type_node,\n@@ -1093,9 +1053,7 @@ build_java_monitor (call, object)\n /* Emit code for one of the PUSHC instructions. */\n \n static void\n-expand_java_pushc (ival, type)\n-     int ival;\n-     tree type;\n+expand_java_pushc (int ival, tree type)\n {\n   tree value;\n   if (type == ptr_type_node && ival == 0)\n@@ -1118,8 +1076,7 @@ expand_java_pushc (ival, type)\n }\n \n static void\n-expand_java_return (type)\n-     tree type;\n+expand_java_return (tree type)\n {\n   if (type == void_type_node)\n     expand_null_return ();\n@@ -1144,10 +1101,7 @@ expand_java_return (type)\n }\n \n static void\n-expand_load_internal (index, type, pc)\n-     int index;\n-     tree type;\n-     int pc;\n+expand_load_internal (int index, tree type, int pc)\n {\n   tree copy;\n   tree var = find_local_variable (index, type, pc);\n@@ -1170,14 +1124,12 @@ expand_load_internal (index, type, pc)\n }\n \n tree\n-build_address_of (value)\n-     tree value;\n+build_address_of (tree value)\n {\n   return build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (value)), value);\n }\n \n-bool class_has_finalize_method (type)\n-     tree type;\n+bool class_has_finalize_method (tree type)\n {\n   tree super = CLASSTYPE_SUPER (type);\n \n@@ -1189,8 +1141,7 @@ bool class_has_finalize_method (type)\n }\n \n static void\n-expand_java_NEW (type)\n-     tree type;\n+expand_java_NEW (tree type)\n {\n   tree alloc_node;\n \n@@ -1211,8 +1162,7 @@ expand_java_NEW (type)\n    object.  */\n \n tree\n-build_get_class (value)\n-     tree value;\n+build_get_class (tree value)\n {\n   tree class_field = lookup_field (&dtable_type, get_identifier (\"class\"));\n   tree vtable_field = lookup_field (&object_type_node,\n@@ -1231,8 +1181,7 @@ build_get_class (value)\n    known.  */\n \n tree\n-build_instanceof (value, type)\n-     tree value, type;\n+build_instanceof (tree value, tree type)\n {\n   tree expr;\n   tree itype = TREE_TYPE (TREE_TYPE (soft_instanceof_node));\n@@ -1295,17 +1244,15 @@ build_instanceof (value, type)\n }\n \n static void\n-expand_java_INSTANCEOF (type)\n-     tree type;\n+expand_java_INSTANCEOF (tree type)\n {\n   tree value = pop_value (object_ptr_type_node);\n   value = build_instanceof (value, type);\n   push_value (value);\n }\n \n static void\n-expand_java_CHECKCAST (type)\n-     tree type;\n+expand_java_CHECKCAST (tree type)\n {\n   tree value = pop_value (ptr_type_node);\n   value = build (CALL_EXPR, promote_type (type),\n@@ -1317,10 +1264,7 @@ expand_java_CHECKCAST (type)\n }\n \n static void\n-expand_iinc (local_var_index, ival, pc)\n-     unsigned int local_var_index;\n-     int ival;\n-     int pc;\n+expand_iinc (unsigned int local_var_index, int ival, int pc)\n {\n     tree local_var, res;\n     tree constant_value;\n@@ -1334,9 +1278,7 @@ expand_iinc (local_var_index, ival, pc)\n \n       \n tree\n-build_java_soft_divmod (op, type, op1, op2)\n-    enum tree_code op;\n-    tree type, op1, op2;\n+build_java_soft_divmod (enum tree_code op, tree type, tree op1, tree op2)\n {\n   tree call = NULL;\n   tree arg1 = convert (type, op1);\n@@ -1384,9 +1326,7 @@ build_java_soft_divmod (op, type, op1, op2)\n }\n \n tree\n-build_java_binop (op, type, arg1, arg2)\n-     enum tree_code op;\n-     tree type, arg1, arg2;\n+build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n {\n   tree mask;\n   switch (op)\n@@ -1465,8 +1405,7 @@ build_java_binop (op, type, arg1, arg2)\n }\n \n static void\n-expand_java_binop (type, op)\n-     tree type;  enum tree_code op;\n+expand_java_binop (tree type, enum tree_code op)\n {\n   tree larg, rarg;\n   tree ltype = type;\n@@ -1494,9 +1433,7 @@ expand_java_binop (type, op)\n    class containing the field. */\n \n tree\n-lookup_field (typep, name)\n-     tree *typep;\n-     tree name;\n+lookup_field (tree *typep, tree name)\n {\n   if (CLASS_P (*typep) && !CLASS_LOADED_P (*typep))\n     {\n@@ -1554,8 +1491,7 @@ lookup_field (typep, name)\n    SELF_VALUE is NULL_TREE if looking for a static field. */\n \n tree\n-build_field_ref (self_value, self_class, name)\n-     tree self_value, self_class, name;\n+build_field_ref (tree self_value, tree self_class, tree name)\n {\n   tree base_class = self_class;\n   tree field_decl = lookup_field (&base_class, name);\n@@ -1585,8 +1521,7 @@ build_field_ref (self_value, self_class, name)\n }\n \n tree\n-lookup_label (pc)\n-     int pc;\n+lookup_label (int pc)\n {\n   tree name;\n   char buf[32];\n@@ -1608,7 +1543,7 @@ lookup_label (pc)\n    labels, and try-catch-finally blocks label or temporary variables.  */\n \n tree\n-generate_name ()\n+generate_name (void)\n {\n   static int l_number = 0;\n   char buff [32];\n@@ -1618,8 +1553,7 @@ generate_name ()\n }\n \n tree\n-create_label_decl (name)\n-     tree name;\n+create_label_decl (tree name)\n {\n   tree decl;\n   decl = build_decl (LABEL_DECL, name, \n@@ -1633,8 +1567,7 @@ create_label_decl (name)\n char *instruction_bits;\n \n static void\n-note_label (current_pc, target_pc)\n-     int current_pc ATTRIBUTE_UNUSED, target_pc;\n+note_label (int current_pc ATTRIBUTE_UNUSED, int target_pc)\n {\n   lookup_label (target_pc);\n   instruction_bits [target_pc] |= BCODE_JUMP_TARGET;\n@@ -1644,10 +1577,8 @@ note_label (current_pc, target_pc)\n    where CONDITION is one of one the compare operators. */\n \n static void\n-expand_compare (condition, value1, value2, target_pc)\n-     enum tree_code condition;\n-     tree value1, value2;\n-     int target_pc;\n+expand_compare (enum tree_code condition, tree value1, tree value2,\n+\t\tint target_pc)\n {\n   tree target = lookup_label (target_pc);\n   tree cond = fold (build (condition, boolean_type_node, value1, value2));\n@@ -1659,10 +1590,7 @@ expand_compare (condition, value1, value2, target_pc)\n /* Emit code for a TEST-type opcode. */\n \n static void\n-expand_test (condition, type, target_pc)\n-     enum tree_code condition;\n-     tree type;\n-     int target_pc;\n+expand_test (enum tree_code condition, tree type, int target_pc)\n {\n   tree value1, value2;\n   flush_quick_stack ();\n@@ -1674,10 +1602,7 @@ expand_test (condition, type, target_pc)\n /* Emit code for a COND-type opcode. */\n \n static void\n-expand_cond (condition, type, target_pc)\n-     enum tree_code condition;\n-     tree type;\n-     int target_pc;\n+expand_cond (enum tree_code condition, tree type, int target_pc)\n {\n   tree value1, value2;\n   flush_quick_stack ();\n@@ -1689,8 +1614,7 @@ expand_cond (condition, type, target_pc)\n }\n \n static void\n-expand_java_goto (target_pc)\n-     int target_pc;\n+expand_java_goto (int target_pc)\n {\n   tree target_label = lookup_label (target_pc);\n   flush_quick_stack ();\n@@ -1699,7 +1623,7 @@ expand_java_goto (target_pc)\n \n #if 0\n static void\n-expand_java_call (target_pc, return_address)\n+expand_java_call (int target_pc, int return_address)\n      int target_pc, return_address;\n {\n   tree target_label = lookup_label (target_pc);\n@@ -1710,8 +1634,7 @@ expand_java_call (target_pc, return_address)\n }\n \n static void\n-expand_java_ret (return_address)\n-     tree return_address ATTRIBUTE_UNUSED;\n+expand_java_ret (tree return_address ATTRIBUTE_UNUSED)\n {\n   warning (\"ret instruction not implemented\");\n #if 0\n@@ -1723,8 +1646,7 @@ expand_java_ret (return_address)\n #endif\n \n static tree\n-pop_arguments (arg_types)\n-     tree arg_types;\n+pop_arguments (tree arg_types)\n {\n   if (arg_types == end_params_node)\n     return NULL_TREE;\n@@ -1747,8 +1669,7 @@ pop_arguments (arg_types)\n    (if it is needed) and then calls EXPR. */\n \n tree\n-build_class_init (clas, expr)\n-     tree clas, expr;\n+build_class_init (tree clas, tree expr)\n {\n   tree init;\n   if (inherits_from_p (current_class, clas))\n@@ -1810,10 +1731,9 @@ build_class_init (clas, expr)\n }\n \n tree\n-build_known_method_ref (method, method_type, self_type,\n-\t\t\tmethod_signature, arg_list)\n-     tree method, method_type ATTRIBUTE_UNUSED, self_type,\n-          method_signature ATTRIBUTE_UNUSED, arg_list ATTRIBUTE_UNUSED;\n+build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n+\t\t\ttree self_type, tree method_signature ATTRIBUTE_UNUSED,\n+\t\t\ttree arg_list ATTRIBUTE_UNUSED)\n {\n   tree func;\n   if (is_compiled_class (self_type))\n@@ -1864,9 +1784,7 @@ build_known_method_ref (method, method_type, self_type,\n }\n \n tree\n-invoke_build_dtable (is_invoke_interface, arg_list)\n-     int is_invoke_interface;\n-     tree arg_list;\n+invoke_build_dtable (int is_invoke_interface, tree arg_list)\n {\n   tree dtable, objectref;\n \n@@ -1894,8 +1812,7 @@ invoke_build_dtable (is_invoke_interface, arg_list)\n    otable_methods. If it has, the existing otable slot will be reused. */\n \n int\n-get_offset_table_index (method)\n-     tree method;\n+get_offset_table_index (tree method)\n {\n   int i = 1;\n   tree method_list;\n@@ -1924,8 +1841,7 @@ get_offset_table_index (method)\n }\n \n tree \n-build_invokevirtual (dtable, method)\n-     tree dtable, method;\n+build_invokevirtual (tree dtable, tree method)\n {\n   tree func;\n   tree nativecode_ptr_ptr_type_node\n@@ -1971,8 +1887,7 @@ build_invokevirtual (dtable, method)\n \n static GTY(()) tree class_ident;\n tree\n-build_invokeinterface (dtable, method)\n-     tree dtable, method;\n+build_invokeinterface (tree dtable, tree method)\n {\n   tree lookup_arg;\n   tree interface;\n@@ -2032,10 +1947,7 @@ build_invokeinterface (dtable, method)\n    NARGS is the number of arguments, or -1 if not specified. */\n \n static void\n-expand_invoke (opcode, method_ref_index, nargs)\n-     int opcode;\n-     int method_ref_index;\n-     int nargs ATTRIBUTE_UNUSED;\n+expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n {\n   tree method_signature = COMPONENT_REF_SIGNATURE(&current_jcf->cpool, method_ref_index);\n   tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool, method_ref_index);\n@@ -2163,8 +2075,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n    a JNI function.  */\n \n tree\n-build_jni_stub (method)\n-     tree method;\n+build_jni_stub (tree method)\n {\n   tree jnifunc, call, args, body, lookup_arg, method_sig, arg_types;\n   tree jni_func_type, tem;\n@@ -2345,10 +2256,7 @@ build_jni_stub (method)\n    FIELD_REF_INDEX is an index into the constant pool.  */\n \n static void\n-expand_java_field_op (is_static, is_putting, field_ref_index)\n-     int is_static;\n-     int is_putting;\n-     int field_ref_index;\n+expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n {\n   tree self_type = \n       get_class_constant (current_jcf, \n@@ -2420,8 +2328,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n }\n \n void\n-load_type_state (label)\n-     tree label;\n+load_type_state (tree label)\n {\n   int i;\n   tree vec = LABEL_TYPE_STATE (label);\n@@ -2436,9 +2343,7 @@ load_type_state (label)\n    placed here because it uses things defined locally in parse.y. */\n \n static tree\n-case_identity (t, v)\n-     tree t __attribute__ ((__unused__));\n-     tree v;\n+case_identity (tree t __attribute__ ((__unused__)), tree v)\n {\n   return v;\n }\n@@ -2471,11 +2376,8 @@ get_primitive_array_vtable (tree elt)\n }\n \n struct rtx_def *\n-java_expand_expr (exp, target, tmode, modifier)\n-     register tree exp;\n-     rtx target;\n-     enum machine_mode tmode;\n-     int modifier; /* Actually an enum expand_modifier.  */\n+java_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n+\t\t  int modifier /* Actually an enum expand_modifier.  */)\n {\n   tree current;\n \n@@ -2665,9 +2567,7 @@ java_expand_expr (exp, target, tmode, modifier)\n    instruction_bits[].  */\n \n void\n-note_instructions (jcf, method)\n-     JCF *jcf;\n-     tree method;\n+note_instructions (JCF *jcf, tree method)\n {\n   int PC; \n   unsigned char* byte_ops;\n@@ -2810,9 +2710,7 @@ note_instructions (jcf, method)\n }\n \n void\n-expand_byte_code (jcf, method)\n-     JCF *jcf;\n-     tree method;\n+expand_byte_code (JCF *jcf, tree method)\n {\n   int PC;\n   int i;\n@@ -2921,9 +2819,7 @@ expand_byte_code (jcf, method)\n }\n \n static void\n-java_push_constant_from_pool (jcf, index)\n-     JCF *jcf;\n-     int index;\n+java_push_constant_from_pool (JCF *jcf, int index)\n {\n   tree c;\n   if (JPOOL_TAG (jcf, index) == CONSTANT_String)\n@@ -2940,10 +2836,8 @@ java_push_constant_from_pool (jcf, index)\n } \n \n int\n-process_jvm_instruction (PC, byte_ops, length)\n-     int PC;\n-     const unsigned char* byte_ops;\n-     long length ATTRIBUTE_UNUSED;\n+process_jvm_instruction (int PC, const unsigned char* byte_ops,\n+\t\t\t long length ATTRIBUTE_UNUSED)\n { \n   const char *opname; /* Temporary ??? */\n   int oldpc = PC; /* PC at instruction start. */\n@@ -3255,9 +3149,7 @@ process_jvm_instruction (PC, byte_ops, length)\n    CODE_OFFSET.  */\n \n static unsigned char\n-peek_opcode_at_pc (jcf, code_offset, pc)\n-    JCF *jcf;\n-    int code_offset, pc;\n+peek_opcode_at_pc (JCF *jcf, int code_offset, int pc)\n {\n   unsigned char opcode;\n   long absolute_offset = (long)JCF_TELL (jcf);\n@@ -3293,9 +3185,8 @@ peek_opcode_at_pc (jcf, code_offset, pc)\n    have allocated and filled properly.  */\n \n int\n-maybe_adjust_start_pc (jcf, code_offset, start_pc, slot)\n-     struct JCF *jcf;\n-     int code_offset, start_pc, slot;\n+maybe_adjust_start_pc (struct JCF *jcf, int code_offset,\n+\t\t       int start_pc, int slot)\n {\n   int first, index, opcode;\n   int pc, insn_pc;\n@@ -3398,8 +3289,7 @@ maybe_adjust_start_pc (jcf, code_offset, start_pc, slot)\n */\n \n tree\n-force_evaluation_order (node)\n-     tree  node;\n+force_evaluation_order (tree node)\n {\n   if (flag_syntax_only)\n     return node;\n@@ -3458,9 +3348,7 @@ force_evaluation_order (node)\n    method in order to emit initialization code for each test flag.  */\n \n static int\n-emit_init_test_initialization (entry, x)\n-     void * * entry;\n-     void * x ATTRIBUTE_UNUSED;\n+emit_init_test_initialization (void **entry, void *x ATTRIBUTE_UNUSED)\n {\n   struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n   tree klass = build_class_ref (ite->key);"}, {"sha": "7c7e3685d5d1f3a36a8538863478588a4e10d619", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 31, "deletions": 85, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -254,8 +254,7 @@ static int decompiled = 0;\n \n /* Return 1 if F is not Inf or NaN.  */\n static int\n-java_float_finite (f)\n-     jfloat f;\n+java_float_finite (jfloat f)\n {\n   union Word u;\n   u.f = f;\n@@ -268,8 +267,7 @@ java_float_finite (f)\n \n /* Return 1 if D is not Inf or NaN.  */\n static int\n-java_double_finite (d)\n-     jdouble d;\n+java_double_finite (jdouble d)\n {\n   union DWord u;\n   u.d = d;\n@@ -281,9 +279,7 @@ java_double_finite (d)\n /* Print a character, appropriately mangled for JNI.  */\n \n static void\n-jni_print_char (stream, ch)\n-     FILE *stream;\n-     int ch;\n+jni_print_char (FILE *stream, int ch)\n {\n   if (! flag_jni)\n     jcf_print_char (stream, ch);\n@@ -345,10 +341,7 @@ print_name (FILE* stream, JCF* jcf, int name_index)\n    final separator.  */\n \n static void\n-print_base_classname (stream, jcf, index)\n-     FILE *stream;\n-     JCF *jcf;\n-     int index;\n+print_base_classname (FILE *stream, JCF *jcf, int index)\n {\n   int name_index = JPOOL_USHORT1 (jcf, index);\n   int len;\n@@ -379,10 +372,7 @@ print_base_classname (stream, jcf, index)\n    and 1 if STR is \"greater\" than NAME.  */\n \n static int\n-utf8_cmp (str, length, name)\n-     const unsigned char *str;\n-     int length;\n-     const char *name;\n+utf8_cmp (const unsigned char *str, int length, const char *name)\n {\n   const unsigned char *limit = str + length;\n   int i;\n@@ -513,9 +503,7 @@ static const char *const cxx_keywords[] =\n    Otherwise, return NULL.  The return value is malloc()d.  */\n \n static char *\n-cxx_keyword_subst (str, length)\n-     const unsigned char *str;\n-     int length;\n+cxx_keyword_subst (const unsigned char *str, int length)\n {\n   int last = ARRAY_SIZE (cxx_keywords);\n   int first = 0;\n@@ -562,9 +550,7 @@ cxx_keyword_subst (str, length)\n /* Generate an access control keyword based on FLAGS.  */\n \n static void\n-generate_access (stream, flags)\n-     FILE *stream;\n-     JCF_u2 flags;\n+generate_access (FILE *stream, JCF_u2 flags)\n {\n   if ((flags & ACC_VISIBILITY) == last_access)\n     return;\n@@ -594,9 +580,7 @@ generate_access (stream, flags)\n \n /* See if NAME is already the name of a method.  */\n static int\n-name_is_method_p (name, length)\n-     const unsigned char *name;\n-     int length;\n+name_is_method_p (const unsigned char *name, int length)\n {\n   struct method_name *p;\n \n@@ -611,11 +595,8 @@ name_is_method_p (name, length)\n /* If there is already a method named NAME, whose signature is not\n    SIGNATURE, then return true.  Otherwise return false.  */\n static int\n-overloaded_jni_method_exists_p (name, length, signature, sig_length)\n-     const unsigned char *name;\n-     int length;\n-     const char *signature;\n-     int sig_length;\n+overloaded_jni_method_exists_p (const unsigned char *name, int length,\n+\t\t\t\tconst char *signature, int sig_length)\n {\n   struct method_name *p;\n \n@@ -632,10 +613,7 @@ overloaded_jni_method_exists_p (name, length, signature, sig_length)\n \n /* Get name of a field.  This handles renamings due to C++ clash.  */\n static char *\n-get_field_name (jcf, name_index, flags)\n-     JCF *jcf;\n-     int name_index;\n-     JCF_u2 flags;\n+get_field_name (JCF *jcf, int name_index, JCF_u2 flags)\n {\n   unsigned char *name = JPOOL_UTF_DATA (jcf, name_index);\n   int length = JPOOL_UTF_LENGTH (jcf, name_index);\n@@ -667,11 +645,7 @@ get_field_name (jcf, name_index, flags)\n /* Print a field name.  Convenience function for use with\n    get_field_name.  */\n static void\n-print_field_name (stream, jcf, name_index, flags)\n-     FILE *stream;\n-     JCF *jcf;\n-     int name_index;\n-     JCF_u2 flags;\n+print_field_name (FILE *stream, JCF *jcf, int name_index, JCF_u2 flags)\n {\n   char *override = get_field_name (jcf, name_index, flags);\n \n@@ -905,10 +879,8 @@ print_method_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n    signature.  NAMEINDEX is the index of the field name; -1 for\n    `this'.  OBJECTTYPE is the index of the object's type.  */\n static void\n-decompile_return_statement (out, jcf, methodtype, nameindex, objecttype)\n-     FILE *out;\n-     JCF *jcf;\n-     int methodtype, nameindex, objecttype;\n+decompile_return_statement (FILE *out, JCF *jcf, int methodtype,\n+\t\t\t    int nameindex, int objecttype)\n {\n   int cast = 0;\n   int obj_name_len, method_name_len;\n@@ -1027,10 +999,7 @@ decompile_return_statement (out, jcf, methodtype, nameindex, objecttype)\n /* Try to decompile a method body.  Right now we just try to handle a\n    simple case that we can do.  Expand as desired.  */\n static void\n-decompile_method (out, jcf, code_len)\n-     FILE *out;\n-     JCF *jcf;\n-     int code_len;\n+decompile_method (FILE *out, JCF *jcf, int code_len)\n {\n   const unsigned char *codes = jcf->read_ptr;\n   int index;\n@@ -1099,8 +1068,7 @@ decompile_method (out, jcf, code_len)\n    should probably be in hashtab.c to complement the existing string\n    hash function.  */\n static int\n-gcjh_streq (p1, p2)\n-     const void *p1, *p2;\n+gcjh_streq (const void *p1, const void *p2)\n {\n   return ! strcmp ((char *) p1, (char *) p2);\n }\n@@ -1109,8 +1077,7 @@ gcjh_streq (p1, p2)\n    or 0 if not.  CLNAME may be extracted from a signature, and can be \n    terminated with either `;' or NULL.  */\n static int\n-throwable_p (clname)\n-     const unsigned char *clname;\n+throwable_p (const unsigned char *clname)\n {\n   int length;\n   unsigned char *current;\n@@ -1209,10 +1176,8 @@ throwable_p (clname)\n /* Print one piece of a signature.  Returns pointer to next parseable\n    character on success, NULL on error.  */\n static const unsigned char *\n-decode_signature_piece (stream, signature, limit, need_space)\n-     FILE *stream;\n-     const unsigned char *signature, *limit;\n-     int *need_space;\n+decode_signature_piece (FILE *stream, const unsigned char *signature,\n+\t\t\tconst unsigned char *limit, int *need_space)\n {\n   const char *ctype;\n   int array_depth = 0;\n@@ -1630,12 +1595,8 @@ print_mangled_classname (FILE *stream, JCF *jcf, const char *prefix, int index)\n    to an array, ignore it and don't print PREFIX.  Returns 1 if\n    something was printed, 0 otherwise.  */\n static int\n-print_cxx_classname (stream, prefix, jcf, index, add_scope)\n-     FILE *stream;\n-     const char *prefix;\n-     JCF *jcf;\n-     int index;\n-     int add_scope;\n+print_cxx_classname (FILE *stream, const char *prefix,\n+\t\t     JCF *jcf, int index, int add_scope)\n {\n   int name_index = JPOOL_USHORT1 (jcf, index);\n   int len, c;\n@@ -1674,9 +1635,7 @@ int written_class_count = 0;\n /* Return name of superclass.  If LEN is not NULL, fill it with length\n    of name.  */\n static const unsigned char *\n-super_class_name (derived_jcf, len)\n-     JCF *derived_jcf;\n-     int *len;\n+super_class_name (JCF *derived_jcf, int *len)\n {\n   int supername_index = JPOOL_USHORT1 (derived_jcf, derived_jcf->super_class);\n   int supername_length = JPOOL_UTF_LENGTH (derived_jcf, supername_index);\n@@ -1704,10 +1663,7 @@ static struct include *all_includes = NULL;\n \n /* Generate a #include.  */\n static void\n-print_include (out, utf8, len)\n-     FILE *out;\n-     const unsigned char *utf8;\n-     int len;\n+print_include (FILE *out, const unsigned char *utf8, int len)\n {\n   struct include *incl;\n \n@@ -1771,9 +1727,8 @@ static struct namelet root =\n    package or class name and links it into the tree.  It does this\n    recursively.  */\n static void\n-add_namelet (name, name_limit, parent)\n-     const unsigned char *name, *name_limit;\n-     struct namelet *parent;\n+add_namelet (const unsigned char *name, const unsigned char *name_limit,\n+\t     struct namelet *parent)\n {\n   const unsigned char *p;\n   struct namelet *n = NULL, *np;\n@@ -1830,10 +1785,7 @@ add_namelet (name, name_limit, parent)\n \n /* Print a single namelet.  Destroys namelets while printing.  */\n static void\n-print_namelet (out, name, depth)\n-     FILE *out;\n-     struct namelet *name;\n-     int depth;\n+print_namelet (FILE *out, struct namelet *name, int depth)\n {\n   int i, term = 0;\n   struct namelet *c;\n@@ -1886,10 +1838,7 @@ print_namelet (out, name, depth)\n    we need decls.  The signature argument can be a function\n    signature.  */\n static void\n-add_class_decl (out, jcf, signature)\n-     FILE *out;\n-     JCF *jcf;\n-     JCF_u2 signature;\n+add_class_decl (FILE *out, JCF *jcf, JCF_u2 signature)\n {\n   const unsigned char *s = JPOOL_UTF_DATA (jcf, signature);\n   int len = JPOOL_UTF_LENGTH (jcf, signature);\n@@ -1923,10 +1872,7 @@ add_class_decl (out, jcf, signature)\n    statically in libjava; we don't generate declarations for these.\n    This makes the generated headers a bit easier to read.  */\n static void\n-print_class_decls (out, jcf, self)\n-     FILE *out;\n-     JCF *jcf;\n-     int self;\n+print_class_decls (FILE *out, JCF *jcf, int self)\n {\n   /* Make sure to always add the current class to the list of things\n      that should be declared.  */\n@@ -2244,14 +2190,14 @@ static const struct option options[] =\n };\n \n static void\n-usage ()\n+usage (void)\n {\n   fprintf (stderr, \"Try `gcjh --help' for more information.\\n\");\n   exit (1);\n }\n \n static void\n-help ()\n+help (void)\n {\n   printf (\"Usage: gcjh [OPTION]... CLASS...\\n\\n\");\n   printf (\"Generate C++ header files from .class files\\n\\n\");\n@@ -2289,7 +2235,7 @@ help ()\n }\n \n static void\n-version ()\n+version (void)\n {\n   printf (\"gcjh (GCC) %s\\n\\n\", version_string);\n   printf (\"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");"}, {"sha": "3f9aade1434166d60237e0434250e8f1098da2da", "filename": "gcc/java/jcf-depend.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-depend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-depend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-depend.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -56,7 +56,7 @@ static int print_dummies;\n    invocation.  FIXME: we should change our API or just completely use\n    the one in mkdeps.h.  */\n void\n-jcf_dependency_reset ()\n+jcf_dependency_reset (void)\n {\n   if (dep_out != NULL)\n     {\n@@ -73,25 +73,22 @@ jcf_dependency_reset ()\n }\n \n void\n-jcf_dependency_set_target (name)\n-     const char *name;\n+jcf_dependency_set_target (const char *name)\n {\n   /* We just handle this the same as an `add_target'.  */\n   if (dependencies != NULL && name != NULL)\n     deps_add_target (dependencies, name, 1);\n }\n \n void\n-jcf_dependency_add_target (name)\n-     const char *name;\n+jcf_dependency_add_target (const char *name)\n {\n   if (dependencies != NULL)\n     deps_add_target (dependencies, name, 1);\n }\n \n void\n-jcf_dependency_set_dep_file (name)\n-     const char *name;\n+jcf_dependency_set_dep_file (const char *name)\n {\n   assert (dep_out != stdout);\n   if (dep_out)\n@@ -103,9 +100,7 @@ jcf_dependency_set_dep_file (name)\n }\n \n void\n-jcf_dependency_add_file (filename, system_p)\n-     const char *filename;\n-     int system_p;\n+jcf_dependency_add_file (const char *filename, int system_p)\n {\n   if (! dependencies)\n     return;\n@@ -118,22 +113,21 @@ jcf_dependency_add_file (filename, system_p)\n }\n \n void\n-jcf_dependency_init (system_p)\n-     int system_p;\n+jcf_dependency_init (int system_p)\n {\n   assert (! dependencies);\n   system_files = system_p;\n   dependencies = deps_init ();\n }\n \n void\n-jcf_dependency_print_dummies ()\n+jcf_dependency_print_dummies (void)\n {\n   print_dummies = 1;\n }\n \n void\n-jcf_dependency_write ()\n+jcf_dependency_write (void)\n {\n   if (! dep_out)\n     return;"}, {"sha": "66358f5d47414ac55fe1829a8d22a9f08f8c22e9", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -800,14 +800,14 @@ static const struct option options[] =\n };\n \n static void\n-usage ()\n+usage (void)\n {\n   fprintf (stderr, \"Try `jcf-dump --help' for more information.\\n\");\n   exit (1);\n }\n \n static void\n-help ()\n+help (void)\n {\n   printf (\"Usage: jcf-dump [OPTION]... CLASS...\\n\\n\");\n   printf (\"Display contents of a class file in readable form.\\n\\n\");\n@@ -830,7 +830,7 @@ help ()\n }\n \n static void\n-version ()\n+version (void)\n {\n   printf (\"jcf-dump (GCC) %s\\n\\n\", version_string);\n   printf (\"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");"}, {"sha": "5ecac053dd70e0cfe0da774045521d7cf353f653", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -106,9 +106,7 @@ static void load_inner_classes (tree);\n /* Handle \"SourceFile\" attribute. */\n \n static void\n-set_source_filename (jcf, index)\n-     JCF *jcf;\n-     int index;\n+set_source_filename (JCF *jcf, int index)\n {\n   tree sfname_id = get_name_constant (jcf, index);\n   const char *sfname = IDENTIFIER_POINTER (sfname_id);\n@@ -223,9 +221,7 @@ set_source_filename (jcf, index)\n #include \"jcf-reader.c\"\n \n tree\n-parse_signature (jcf, sig_index)\n-     JCF *jcf;\n-     int sig_index;\n+parse_signature (JCF *jcf, int sig_index)\n {\n   if (sig_index <= 0 || sig_index >= JPOOL_SIZE (jcf)\n       || JPOOL_TAG (jcf, sig_index) != CONSTANT_Utf8)\n@@ -236,9 +232,7 @@ parse_signature (jcf, sig_index)\n }\n \n tree\n-get_constant (jcf, index)\n-  JCF *jcf;\n-  int index;\n+get_constant (JCF *jcf, int index)\n {\n   tree value;\n   int tag;\n@@ -336,9 +330,7 @@ get_constant (jcf, index)\n }\n \n tree\n-get_name_constant (jcf, index)\n-  JCF *jcf;\n-  int index;\n+get_name_constant (JCF *jcf, int index)\n {\n   tree name = get_constant (jcf, index);\n \n@@ -353,9 +345,7 @@ get_name_constant (jcf, index)\n    the outer context with the newly resolved innerclass.  */\n \n static void\n-handle_innerclass_attribute (count, jcf)\n-     int count;\n-     JCF *jcf;\n+handle_innerclass_attribute (int count, JCF *jcf)\n {\n   int c = (count);\n   while (c--)\n@@ -391,9 +381,7 @@ handle_innerclass_attribute (count, jcf)\n }\n \n static tree\n-give_name_to_class (jcf, i)\n-     JCF *jcf;\n-     int i;\n+give_name_to_class (JCF *jcf, int i)\n {\n   if (i <= 0 || i >= JPOOL_SIZE (jcf)\n       || JPOOL_TAG (jcf, i) != CONSTANT_Class)\n@@ -420,7 +408,7 @@ give_name_to_class (jcf, i)\n /* Get the class of the CONSTANT_Class whose constant pool index is I. */\n \n tree\n-get_class_constant (JCF *jcf , int i)\n+get_class_constant (JCF *jcf, int i)\n {\n   tree type;\n   if (i <= 0 || i >= JPOOL_SIZE (jcf)\n@@ -455,8 +443,7 @@ get_class_constant (JCF *jcf , int i)\n    define the class it is supposed to.) */\n \n int\n-read_class (name)\n-     tree name;\n+read_class (tree name)\n {\n   JCF this_jcf, *jcf;\n   tree icv, class = NULL_TREE;\n@@ -548,9 +535,7 @@ read_class (name)\n    - and then perhaps rename read_class to load_class.  FIXME */\n \n void\n-load_class (class_or_name, verbose)\n-     tree class_or_name;\n-     int verbose;\n+load_class (tree class_or_name, int verbose)\n {\n   tree name, saved;\n   int class_loaded;\n@@ -596,8 +581,7 @@ load_class (class_or_name, verbose)\n /* Parse the .class file JCF. */\n \n void\n-jcf_parse (jcf)\n-     JCF* jcf;\n+jcf_parse (JCF* jcf)\n {\n   int i, code;\n \n@@ -667,8 +651,7 @@ jcf_parse (jcf)\n \n /* If we came across inner classes, load them now. */\n static void\n-load_inner_classes (cur_class)\n-     tree cur_class;\n+load_inner_classes (tree cur_class)\n {\n   tree current;\n   for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (cur_class)); current;\n@@ -683,13 +666,13 @@ load_inner_classes (cur_class)\n }\n \n void\n-init_outgoing_cpool ()\n+init_outgoing_cpool (void)\n {\n   outgoing_cpool = ggc_alloc_cleared (sizeof (struct CPool));\n }\n \n static void\n-parse_class_file ()\n+parse_class_file (void)\n {\n   tree method, field;\n   const char *save_input_filename = input_filename;\n@@ -799,9 +782,7 @@ parse_class_file ()\n /* Parse a source file, as pointed by the current value of INPUT_FILENAME. */\n \n static void\n-parse_source_file_1 (file, finput)\n-     tree file;\n-     FILE *finput;\n+parse_source_file_1 (tree file, FILE *finput)\n {\n   int save_error_count = java_error_count;\n   /* Mark the file as parsed */\n@@ -833,15 +814,15 @@ parse_source_file_1 (file, finput)\n /* Process a parsed source file, resolving names etc. */\n \n static void\n-parse_source_file_2 ()\n+parse_source_file_2 (void)\n {\n   int save_error_count = java_error_count;\n   java_complete_class ();\t    /* Parse unsatisfied class decl. */\n   java_parse_abort_on_error ();\n }\n \n static void\n-parse_source_file_3 ()\n+parse_source_file_3 (void)\n {\n   int save_error_count = java_error_count;\n   java_check_circular_reference (); /* Check on circular references */\n@@ -852,15 +833,13 @@ parse_source_file_3 ()\n }\n \n void\n-add_predefined_file (name)\n-     tree name;\n+add_predefined_file (tree name)\n {\n   predef_filenames = tree_cons (NULL_TREE, name, predef_filenames);\n }\n \n int\n-predefined_filename_p (node)\n-     tree node;\n+predefined_filename_p (tree node)\n {\n   tree iter;\n \n@@ -873,8 +852,7 @@ predefined_filename_p (node)\n }\n \n void\n-java_parse_file (set_yydebug)\n-     int set_yydebug ATTRIBUTE_UNUSED;\n+java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n   int filename_count = 0;\n   char *list, *next;\n@@ -1229,7 +1207,7 @@ process_zip_dir (FILE *finput)\n /* Initialization.  */\n \n void\n-init_jcf_parse ()\n+init_jcf_parse (void)\n {\n   init_src_parse ();\n }"}, {"sha": "33f4f80f3c41c233bb86cb6e6c48f694d85f16cd", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -105,8 +105,7 @@ static int longest_path = 0;\n \f\n \n static void\n-free_entry (entp)\n-     struct entry **entp;\n+free_entry (struct entry **entp)\n {\n   struct entry *e, *n;\n \n@@ -120,9 +119,7 @@ free_entry (entp)\n }\n \n static void\n-append_entry (entp, ent)\n-     struct entry **entp;\n-     struct entry *ent;\n+append_entry (struct entry **entp, struct entry *ent)\n {\n   /* It doesn't matter if this is slow, since it is run only at\n      startup, and then infrequently.  */\n@@ -139,10 +136,7 @@ append_entry (entp, ent)\n }\n \n static void\n-add_entry (entp, filename, is_system)\n-     struct entry **entp;\n-     const char *filename;\n-     int is_system;\n+add_entry (struct entry **entp, const char *filename, int is_system)\n {\n   int len;\n   struct entry *n;\n@@ -186,10 +180,7 @@ add_entry (entp, filename, is_system)\n }\n \n static void\n-add_path (entp, cp, is_system)\n-     struct entry **entp;\n-     const char *cp;\n-     int is_system;\n+add_path (struct entry **entp, const char *cp, int is_system)\n {\n   const char *startp, *endp;\n \n@@ -228,7 +219,7 @@ static int init_done = 0;\n \n /* Initialize the path module.  */\n void\n-jcf_path_init ()\n+jcf_path_init (void)\n {\n   char *cp;\n   char *try, sep[2];\n@@ -321,8 +312,7 @@ jcf_path_init ()\n    This overrides only the $CLASSPATH environment variable.\n  */\n void\n-jcf_path_classpath_arg (path)\n-     const char *path;\n+jcf_path_classpath_arg (const char *path)\n {\n   free_entry (&classpath_user);\n   add_path (&classpath_user, path, 0);\n@@ -331,8 +321,7 @@ jcf_path_classpath_arg (path)\n /* Call this when -bootclasspath is seen on the command line.\n  */\n void\n-jcf_path_bootclasspath_arg (path)\n-     const char *path;\n+jcf_path_bootclasspath_arg (const char *path)\n {\n   free_entry (&sys_dirs);\n   add_path (&sys_dirs, path, 1);\n@@ -341,8 +330,7 @@ jcf_path_bootclasspath_arg (path)\n /* Call this when -extdirs is seen on the command line.\n  */\n void\n-jcf_path_extdirs_arg (cp)\n-     const char *cp;\n+jcf_path_extdirs_arg (const char *cp)\n {\n   const char *startp, *endp;\n \n@@ -406,8 +394,7 @@ jcf_path_extdirs_arg (cp)\n \n /* Call this when -I is seen on the command line.  */\n void\n-jcf_path_include_arg (path)\n-     const char *path;\n+jcf_path_include_arg (const char *path)\n {\n   add_entry (&include_dirs, path, 0);\n }\n@@ -416,8 +403,7 @@ jcf_path_include_arg (path)\n    we provide a way to iterate through the sealed list.  If PRINT is\n    true then we print the final class path to stderr.  */\n void\n-jcf_path_seal (print)\n-     int print;\n+jcf_path_seal (int print)\n {\n   struct entry *secondary;\n \n@@ -465,14 +451,13 @@ jcf_path_seal (print)\n }\n \n void *\n-jcf_path_start ()\n+jcf_path_start (void)\n {\n   return (void *) sealed;\n }\n \n void *\n-jcf_path_next (x)\n-     void *x;\n+jcf_path_next (void *x)\n {\n   struct entry *ent = (struct entry *) x;\n   return (void *) ent->next;\n@@ -481,31 +466,28 @@ jcf_path_next (x)\n /* We guarantee that the return path will either be a zip file, or it\n    will end with a directory separator.  */\n char *\n-jcf_path_name (x)\n-     void *x;\n+jcf_path_name (void *x)\n {\n   struct entry *ent = (struct entry *) x;\n   return ent->name;\n }\n \n int\n-jcf_path_is_zipfile (x)\n-     void *x;\n+jcf_path_is_zipfile (void *x)\n {\n   struct entry *ent = (struct entry *) x;\n   return (ent->flags & FLAG_ZIP);\n }\n \n int\n-jcf_path_is_system (x)\n-     void *x;\n+jcf_path_is_system (void *x)\n {\n   struct entry *ent = (struct entry *) x;\n   return (ent->flags & FLAG_SYSTEM);\n }\n \n int\n-jcf_path_max_len ()\n+jcf_path_max_len (void)\n {\n   return longest_path;\n }"}, {"sha": "e1c131d54ad9ddd3ac44e65632cf2f6dc4126c6e", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -50,11 +50,8 @@ static void skip_attribute (JCF *, int);\n \n #ifdef NEED_PEEK_ATTRIBUTE\t/* Not everyone uses this function */\n static int\n-peek_attribute (jcf, attribute_number, peeked_name, peeked_name_length)\n-      JCF *jcf;\n-      int attribute_number;\n-      const char *peeked_name;\n-      int peeked_name_length;\n+peek_attribute (JCF *jcf, int attribute_number, const char *peeked_name,\n+\t\tint peeked_name_length)\n {\n   int to_return = 0;\n   long absolute_offset = (long)JCF_TELL (jcf);\n@@ -92,9 +89,7 @@ peek_attribute (jcf, attribute_number, peeked_name, peeked_name_length)\n \n #ifdef NEED_SKIP_ATTRIBUTE\t/* Not everyone uses this function */\n static void\n-skip_attribute (jcf, number_of_attribute)\n-     JCF *jcf;\n-     int number_of_attribute;\n+skip_attribute (JCF *jcf, int number_of_attribute)\n {\n   while (number_of_attribute--)\n     {"}, {"sha": "fe00812842bc22790affde132c10dc093eaa005a", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 66, "deletions": 168, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -352,10 +352,7 @@ static void append_gcj_attribute (struct jcf_partial *, tree);\n static int CHECK_PUT (void *, struct jcf_partial *, int);\n \n static int\n-CHECK_PUT (ptr, state, i)\n-     void *ptr;\n-     struct jcf_partial *state;\n-     int i;\n+CHECK_PUT (void *ptr, struct jcf_partial *state, int i)\n {\n   if ((unsigned char *) ptr < state->chunk->data\n       || (unsigned char *) ptr + i > state->chunk->data + state->chunk->size)\n@@ -385,11 +382,8 @@ CHECK_PUT (ptr, state, i)\n    However, if DATA is NULL and SIZE>0, allocate a buffer as well. */\n \n static struct chunk *\n-alloc_chunk (last, data, size, work)\n-     struct chunk *last;\n-     unsigned char *data;\n-     int size;\n-     struct obstack *work;\n+alloc_chunk (struct chunk *last, unsigned char *data,\n+\t     int size, struct obstack *work)\n {\n   struct chunk *chunk = (struct chunk *)\n     obstack_alloc (work, sizeof(struct chunk));\n@@ -409,8 +403,7 @@ alloc_chunk (last, data, size, work)\n static int CHECK_OP (struct jcf_partial *);\n \n static int\n-CHECK_OP (state)\n-     struct jcf_partial *state;\n+CHECK_OP (struct jcf_partial *state)\n {\n   if (state->bytecode.ptr > state->bytecode.limit)\n     abort ();\n@@ -422,10 +415,7 @@ CHECK_OP (state)\n #endif\n \n static unsigned char *\n-append_chunk (data, size, state)\n-     unsigned char *data;\n-     int size;\n-     struct jcf_partial *state;\n+append_chunk (unsigned char *data, int size, struct jcf_partial *state)\n {\n   state->chunk = alloc_chunk (state->chunk, data, size, state->chunk_obstack);\n   if (state->first == NULL)\n@@ -434,18 +424,14 @@ append_chunk (data, size, state)\n }\n \n static void\n-append_chunk_copy (data, size, state)\n-     unsigned char *data;\n-     int size;\n-     struct jcf_partial *state;\n+append_chunk_copy (unsigned char *data, int size, struct jcf_partial *state)\n {\n   unsigned char *ptr = append_chunk (NULL, size, state);\n   memcpy (ptr, data, size);\n }\n \f\n static struct jcf_block *\n-gen_jcf_label (state)\n-     struct jcf_partial *state;\n+gen_jcf_label (struct jcf_partial *state)\n {\n   struct jcf_block *block = (struct jcf_block *)\n     obstack_alloc (state->chunk_obstack, sizeof (struct jcf_block));\n@@ -456,8 +442,7 @@ gen_jcf_label (state)\n }\n \n static void\n-finish_jcf_block (state)\n-     struct jcf_partial *state;\n+finish_jcf_block (struct jcf_partial *state)\n {\n   struct jcf_block *block = state->last_block;\n   struct jcf_relocation *reloc;\n@@ -483,9 +468,7 @@ finish_jcf_block (state)\n }\n \n static void\n-define_jcf_label (label, state)\n-     struct jcf_block *label;\n-     struct jcf_partial *state;\n+define_jcf_label (struct jcf_block *label, struct jcf_partial *state)\n {\n   if (state->last_block != NULL)\n     finish_jcf_block (state);\n@@ -500,8 +483,7 @@ define_jcf_label (label, state)\n }\n \n static struct jcf_block *\n-get_jcf_label_here (state)\n-     struct jcf_partial *state;\n+get_jcf_label_here (struct jcf_partial *state)\n {\n   if (state->last_block != NULL && BUFFER_LENGTH (&state->bytecode) == 0)\n     return state->last_block;\n@@ -516,9 +498,7 @@ get_jcf_label_here (state)\n /* Note a line number entry for the current PC and given LINE. */\n \n static void\n-put_linenumber (line, state)\n-     int line;\n-     struct jcf_partial *state;\n+put_linenumber (int line, struct jcf_partial *state)\n {\n   struct jcf_block *label = get_jcf_label_here (state);\n   if (label->linenumber > 0)\n@@ -534,10 +514,8 @@ put_linenumber (line, state)\n    in the range (START_LABEL, END_LABEL). */\n \n static struct jcf_handler *\n-alloc_handler (start_label, end_label, state)\n-     struct jcf_block *start_label;\n-     struct jcf_block *end_label;\n-     struct jcf_partial *state;\n+alloc_handler (struct jcf_block *start_label, struct jcf_block *end_label,\n+\t       struct jcf_partial *state)\n {\n   struct jcf_handler *handler = (struct jcf_handler *)\n     obstack_alloc (state->chunk_obstack, sizeof (struct jcf_handler));\n@@ -576,9 +554,7 @@ struct localvar_info\n   ((struct localvar_info**) state->localvars.ptr - localvar_buffer)\n \n static void\n-localvar_alloc (decl, state)\n-     tree decl;\n-     struct jcf_partial *state;\n+localvar_alloc (tree decl, struct jcf_partial *state)\n {\n   struct jcf_block *start_label = get_jcf_label_here (state);\n   int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n@@ -623,9 +599,7 @@ localvar_alloc (decl, state)\n }\n \n static void\n-localvar_free (decl, state)\n-     tree decl;     \n-     struct jcf_partial *state;\n+localvar_free (tree decl, struct jcf_partial *state)\n {\n   struct jcf_block *end_label = get_jcf_label_here (state);\n   int index = DECL_LOCAL_INDEX (decl);\n@@ -654,8 +628,7 @@ localvar_free (decl, state)\n    a field (FIELD_DECL or VAR_DECL, if static), as encoded in a .class file. */\n \n static int\n-get_access_flags (decl)\n-    tree decl;\n+get_access_flags (tree decl)\n {\n   int flags = 0;\n   int isfield = TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL;\n@@ -721,9 +694,7 @@ get_access_flags (decl)\n /* Write the list of segments starting at CHUNKS to STREAM. */\n \n static void\n-write_chunks (stream, chunks)\n-     FILE* stream;\n-     struct chunk *chunks;\n+write_chunks (FILE* stream, struct chunk *chunks)\n {\n   for (;  chunks != NULL;  chunks = chunks->next)\n     fwrite (chunks->data, chunks->size, 1, stream);\n@@ -733,9 +704,7 @@ write_chunks (stream, chunks)\n    (Caller is responsible for doing NOTE_PUSH.) */\n \n static void\n-push_constant1 (index, state)\n-     HOST_WIDE_INT index;\n-     struct jcf_partial *state;\n+push_constant1 (HOST_WIDE_INT index, struct jcf_partial *state)\n {\n   RESERVE (3);\n   if (index < 256)\n@@ -754,9 +723,7 @@ push_constant1 (index, state)\n    (Caller is responsible for doing NOTE_PUSH.) */\n \n static void\n-push_constant2 (index, state)\n-     HOST_WIDE_INT index;\n-     struct jcf_partial *state;\n+push_constant2 (HOST_WIDE_INT index, struct jcf_partial *state)\n {\n   RESERVE (3);\n   OP1 (OPCODE_ldc2_w);\n@@ -767,9 +734,7 @@ push_constant2 (index, state)\n    Caller is responsible for doing NOTE_PUSH. */\n \n static void\n-push_int_const (i, state)\n-     HOST_WIDE_INT i;\n-     struct jcf_partial *state;\n+push_int_const (HOST_WIDE_INT i, struct jcf_partial *state)\n {\n   RESERVE(3);\n   if (i >= -1 && i <= 5)\n@@ -793,9 +758,8 @@ push_int_const (i, state)\n }\n \n static int\n-find_constant_wide (lo, hi, state)\n-     HOST_WIDE_INT lo, hi;\n-     struct jcf_partial *state;\n+find_constant_wide (HOST_WIDE_INT lo, HOST_WIDE_INT hi,\n+\t\t    struct jcf_partial *state)\n {\n   HOST_WIDE_INT w1, w2;\n   lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n@@ -807,9 +771,7 @@ find_constant_wide (lo, hi, state)\n    Return the index in the constant pool. */\n \n static int\n-find_constant_index (value, state)\n-     tree value;\n-     struct jcf_partial *state;\n+find_constant_index (tree value, struct jcf_partial *state)\n {\n   if (TREE_CODE (value) == INTEGER_CST)\n     {\n@@ -847,9 +809,7 @@ find_constant_index (value, state)\n    Caller is responsible for doing NOTE_PUSH. */\n \n static void\n-push_long_const (lo, hi, state)\n-     HOST_WIDE_INT lo, hi;\n-     struct jcf_partial *state;\n+push_long_const (HOST_WIDE_INT lo, HOST_WIDE_INT hi, struct jcf_partial *state)\n {\n   HOST_WIDE_INT highpart, dummy;\n   jint lowpart = WORD_TO_INT (lo);\n@@ -873,10 +833,7 @@ push_long_const (lo, hi, state)\n }\n \n static void\n-field_op (field, opcode, state)\n-     tree field;\n-     int opcode;\n-     struct jcf_partial *state;\n+field_op (tree field, int opcode, struct jcf_partial *state)\n {\n   int index = find_fieldref_index (&state->cpool, field);\n   RESERVE (3);\n@@ -889,9 +846,7 @@ field_op (field, opcode, state)\n    opcodes typically depend on the operand type. */\n \n static int\n-adjust_typed_op (type, max)\n-     tree type;\n-     int max;\n+adjust_typed_op (tree type, int max)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -924,9 +879,7 @@ adjust_typed_op (type, max)\n }\n \n static void\n-maybe_wide (opcode, index, state)\n-     int opcode, index;\n-     struct jcf_partial *state;\n+maybe_wide (int opcode, int index, struct jcf_partial *state)\n {\n   if (index >= 256)\n     {\n@@ -949,9 +902,7 @@ maybe_wide (opcode, index, state)\n    (The new words get inserted at stack[SP-size-offset].) */\n \n static void\n-emit_dup (size, offset, state)\n-     int size, offset;\n-     struct jcf_partial *state;\n+emit_dup (int size, int offset, struct jcf_partial *state)\n {\n   int kind;\n   if (size == 0)\n@@ -970,19 +921,14 @@ emit_dup (size, offset, state)\n }\n \n static void\n-emit_pop (size, state)\n-     int size;\n-     struct jcf_partial *state;\n+emit_pop (int size, struct jcf_partial *state)\n {\n   RESERVE (1);\n   OP1 (OPCODE_pop - 1 + size);\n }\n \n static void\n-emit_iinc (var, value, state)\n-     tree var;\n-     HOST_WIDE_INT value;\n-     struct jcf_partial *state;\n+emit_iinc (tree var, HOST_WIDE_INT value, struct jcf_partial *state)\n {\n   int slot = DECL_LOCAL_INDEX (var);\n \n@@ -1004,10 +950,9 @@ emit_iinc (var, value, state)\n }\n \n static void\n-emit_load_or_store (var, opcode, state)\n-     tree var;    /* Variable to load from or store into. */\n-     int opcode;  /* Either OPCODE_iload or OPCODE_istore. */\n-     struct jcf_partial *state;\n+emit_load_or_store (tree var,    /* Variable to load from or store into. */\n+\t\t    int opcode,  /* Either OPCODE_iload or OPCODE_istore. */\n+\t\t    struct jcf_partial *state)\n {\n   tree type = TREE_TYPE (var);\n   int kind = adjust_typed_op (type, 4);\n@@ -1022,38 +967,29 @@ emit_load_or_store (var, opcode, state)\n }\n \n static void\n-emit_load (var, state)\n-     tree var;\n-     struct jcf_partial *state;\n+emit_load (tree var, struct jcf_partial *state)\n {\n   emit_load_or_store (var, OPCODE_iload, state);\n   NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (var)) ? 2 : 1);\n }\n \n static void\n-emit_store (var, state)\n-     tree var;\n-     struct jcf_partial *state;\n+emit_store (tree var, struct jcf_partial *state)\n {\n   emit_load_or_store (var, OPCODE_istore, state);\n   NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (var)) ? 2 : 1);\n }\n \n static void\n-emit_unop (opcode, type, state)\n-     enum java_opcode opcode;\n-     tree type ATTRIBUTE_UNUSED;\n-     struct jcf_partial *state;\n+emit_unop (enum java_opcode opcode, tree type ATTRIBUTE_UNUSED,\n+\t   struct jcf_partial *state)\n {\n   RESERVE(1);\n   OP1 (opcode);\n }\n \n static void\n-emit_binop (opcode, type, state)\n-     enum java_opcode opcode;\n-     tree type;\n-     struct jcf_partial *state;\n+emit_binop (enum java_opcode opcode, tree type, struct jcf_partial *state)\n {\n   int size = TYPE_IS_WIDE (type) ? 2 : 1;\n   RESERVE(1);\n@@ -1062,11 +998,8 @@ emit_binop (opcode, type, state)\n }\n \n static void\n-emit_reloc (value, kind, target, state)\n-     HOST_WIDE_INT value;\n-     int kind;\n-     struct jcf_block *target;\n-     struct jcf_partial *state;\n+emit_reloc (HOST_WIDE_INT value, int kind,\n+\t    struct jcf_block *target, struct jcf_partial *state)\n {\n   struct jcf_relocation *reloc = (struct jcf_relocation *)\n     obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n@@ -1083,9 +1016,7 @@ emit_reloc (value, kind, target, state)\n }\n \n static void\n-emit_switch_reloc (label, state)\n-     struct jcf_block *label;\n-     struct jcf_partial *state;\n+emit_switch_reloc (struct jcf_block *label, struct jcf_partial *state)\n {\n   emit_reloc (RELOCATION_VALUE_0, BLOCK_START_RELOC, label, state);\n }\n@@ -1094,9 +1025,7 @@ emit_switch_reloc (label, state)\n    but re-uses an existing case reloc. */\n \n static void\n-emit_case_reloc (reloc, state)\n-     struct jcf_relocation *reloc;\n-     struct jcf_partial *state;\n+emit_case_reloc (struct jcf_relocation *reloc, struct jcf_partial *state)\n {\n   struct jcf_block *block = state->last_block;\n   reloc->next = block->u.relocations;\n@@ -1110,10 +1039,8 @@ emit_case_reloc (reloc, state)\n    The opcode is OPCODE, the inverted opcode is INV_OPCODE. */\n \n static void\n-emit_if (target, opcode, inv_opcode, state)\n-     struct jcf_block *target;\n-     int opcode, inv_opcode;\n-     struct jcf_partial *state;\n+emit_if (struct jcf_block *target, int opcode, int inv_opcode,\n+\t struct jcf_partial *state)\n {\n   RESERVE(3);\n   OP1 (opcode);\n@@ -1122,9 +1049,7 @@ emit_if (target, opcode, inv_opcode, state)\n }\n \n static void\n-emit_goto (target, state)\n-     struct jcf_block *target;\n-     struct jcf_partial *state;\n+emit_goto (struct jcf_block *target, struct jcf_partial *state)\n {\n   RESERVE(3);\n   OP1 (OPCODE_goto);\n@@ -1133,9 +1058,7 @@ emit_goto (target, state)\n }\n \n static void\n-emit_jsr (target, state)\n-     struct jcf_block *target;\n-     struct jcf_partial *state;\n+emit_jsr (struct jcf_block *target, struct jcf_partial *state)\n {\n   RESERVE(3);\n   OP1 (OPCODE_jsr);\n@@ -1150,13 +1073,11 @@ emit_jsr (target, state)\n    may be able to optimize away GOTO TRUE_LABEL; TRUE_LABEL:) */\n \n static void\n-generate_bytecode_conditional (exp, true_label, false_label,\n-\t\t\t       true_branch_first, state)\n-     tree exp;\n-     struct jcf_block *true_label;\n-     struct jcf_block *false_label;\n-     int true_branch_first;\n-     struct jcf_partial *state;\n+generate_bytecode_conditional (tree exp,\n+\t\t\t       struct jcf_block *true_label,\n+\t\t\t       struct jcf_block *false_label,\n+\t\t\t       int true_branch_first,\n+\t\t\t       struct jcf_partial *state)\n {\n   tree exp0, exp1, type;\n   int save_SP = state->code_SP;\n@@ -1361,9 +1282,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n    emit label that is LIMIT). */\n \n static void\n-call_cleanups (limit, state)\n-     struct jcf_block *limit;\n-     struct jcf_partial *state;\n+call_cleanups (struct jcf_block *limit, struct jcf_partial *state)\n {\n   struct jcf_block *block = state->labeled_blocks;\n   for (;  block != limit;  block = block->next)\n@@ -1374,9 +1293,7 @@ call_cleanups (limit, state)\n }\n \n static void\n-generate_bytecode_return (exp, state)\n-     tree exp;\n-     struct jcf_partial *state;\n+generate_bytecode_return (tree exp, struct jcf_partial *state)\n {\n   tree return_type = TREE_TYPE (TREE_TYPE (state->current_method));\n   int returns_void = TREE_CODE (return_type) == VOID_TYPE;\n@@ -1443,10 +1360,7 @@ generate_bytecode_return (exp, state)\n    TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n \n static void\n-generate_bytecode_insns (exp, target, state)\n-     tree exp;\n-     int target;\n-     struct jcf_partial *state;\n+generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n {\n   tree type, arg;\n   enum java_opcode jopcode;\n@@ -2641,8 +2555,7 @@ generate_bytecode_insns (exp, target, state)\n }\n \n static void\n-perform_relocations (state)\n-     struct jcf_partial *state;\n+perform_relocations (struct jcf_partial *state)\n {\n   struct jcf_block *block;\n   struct jcf_relocation *reloc;\n@@ -2840,9 +2753,7 @@ perform_relocations (state)\n }\n \n static void\n-init_jcf_state (state, work)\n-     struct jcf_partial *state;\n-     struct obstack *work;\n+init_jcf_state (struct jcf_partial *state, struct obstack *work)\n {\n   state->chunk_obstack = work;\n   state->first = state->chunk = NULL;\n@@ -2852,9 +2763,7 @@ init_jcf_state (state, work)\n }\n \n static void\n-init_jcf_method (state, method)\n-     struct jcf_partial *state;\n-     tree method;\n+init_jcf_method (struct jcf_partial *state, tree method)\n {\n   state->current_method = method;\n   state->blocks = state->last_block = NULL;\n@@ -2875,8 +2784,7 @@ init_jcf_method (state, method)\n }\n \n static void\n-release_jcf_state (state)\n-     struct jcf_partial *state;\n+release_jcf_state (struct jcf_partial *state)\n {\n   CPOOL_FINISH (&state->cpool);\n   obstack_free (state->chunk_obstack, state->first);\n@@ -2888,9 +2796,7 @@ release_jcf_state (state)\n \n static GTY(()) tree SourceFile_node;\n static struct chunk *\n-generate_classfile (clas, state)\n-     tree clas;\n-     struct jcf_partial *state;\n+generate_classfile (tree clas, struct jcf_partial *state)\n {\n   struct chunk *cpool_chunk;\n   const char *source_file, *s;\n@@ -3210,8 +3116,7 @@ generate_classfile (clas, state)\n \n static GTY(()) tree Synthetic_node;\n static unsigned char *\n-append_synthetic_attribute (state)\n-     struct jcf_partial *state;\n+append_synthetic_attribute (struct jcf_partial *state)\n {\n   unsigned char *ptr = append_chunk (NULL, 6, state);\n   int i;\n@@ -3228,9 +3133,7 @@ append_synthetic_attribute (state)\n }\n \n static void\n-append_gcj_attribute (state, class)\n-     struct jcf_partial *state;\n-     tree class;\n+append_gcj_attribute (struct jcf_partial *state, tree class)\n {\n   unsigned char *ptr;\n   int i;\n@@ -3247,9 +3150,7 @@ append_gcj_attribute (state, class)\n \n static tree InnerClasses_node;\n static void\n-append_innerclasses_attribute (state, class)\n-     struct jcf_partial *state;\n-     tree class;\n+append_innerclasses_attribute (struct jcf_partial *state, tree class)\n {\n   tree orig_decl = TYPE_NAME (class);\n   tree current, decl;\n@@ -3302,9 +3203,8 @@ append_innerclasses_attribute (state, class)\n }\n \n static void\n-append_innerclasses_attribute_entry (state, decl, name)\n-     struct jcf_partial *state;\n-     tree decl, name;\n+append_innerclasses_attribute_entry (struct jcf_partial *state,\n+\t\t\t\t     tree decl, tree name)\n {\n   int icii, icaf;\n   int ocii = 0, ini = 0;\n@@ -3328,8 +3228,7 @@ append_innerclasses_attribute_entry (state, decl, name)\n }\n \n static char *\n-make_class_file_name (clas)\n-     tree clas;\n+make_class_file_name (tree clas)\n {\n   const char *dname, *cname, *slash;\n   char *r;\n@@ -3396,8 +3295,7 @@ make_class_file_name (clas)\n    The output .class file name is make_class_file_name(CLAS). */\n \n void\n-write_classfile (clas)\n-     tree clas;\n+write_classfile (tree clas)\n {\n   struct obstack *work = &temporary_obstack;\n   struct jcf_partial state[1];"}, {"sha": "90e16e7cec9495c885350dfcc47ced4ff8c19e4d", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -95,14 +95,14 @@ static const struct option options[] =\n };\n \n static void\n-usage ()\n+usage (void)\n {\n   fprintf (stderr, \"Try `jv-scan --help' for more information.\\n\");\n   exit (1);\n }\n \n static void\n-help ()\n+help (void)\n {\n   printf (\"Usage: jv-scan [OPTION]... FILE...\\n\\n\");\n   printf (\"Print useful information read from Java source files.\\n\\n\");\n@@ -123,7 +123,7 @@ help ()\n }\n \n static void\n-version ()\n+version (void)\n {\n   printf (\"jv-scan (GCC) %s\\n\\n\", version_string);\n   printf (\"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");\n@@ -264,8 +264,7 @@ warning (const char *s, ...)\n }\n \n void\n-gcc_obstack_init (obstack)\n-     struct obstack *obstack;\n+gcc_obstack_init (struct obstack *obstack)\n {\n   /* Let particular systems override the size of a chunk.  */\n #ifndef OBSTACK_CHUNK_SIZE"}, {"sha": "ba3ac8882046a27448b5c7efca6a084b204b6a55", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -40,8 +40,7 @@ struct obstack  name_obstack;\n struct obstack *mangle_obstack = &name_obstack;\n \n void\n-gcc_obstack_init (obstack)\n-     struct obstack *obstack;\n+gcc_obstack_init (struct obstack *obstack)\n {\n   /* Let particular systems override the size of a chunk.  */\n #ifndef OBSTACK_CHUNK_SIZE\n@@ -157,8 +156,7 @@ main (int argc, char **argv)\n \n \n static char *\n-do_mangle_classname (string)\n-     const char *string;\n+do_mangle_classname (const char *string)\n {\n   const char *ptr;\n   int count = 0;"}, {"sha": "1feb63993b50b79222ae7621c6fa115e55221818", "filename": "gcc/java/lang.c", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -292,10 +292,8 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n /* Process an option that can accept a `no-' form.\n    Return 1 if option found, 0 otherwise.  */\n static int\n-process_option_with_no (p, table, table_size)\n-     const char *p;\n-     const struct string_option *table;\n-     int table_size;\n+process_option_with_no (const char *p, const struct string_option *table,\n+\t\t\tint table_size)\n {\n   int j;\n \n@@ -322,9 +320,7 @@ process_option_with_no (p, table, table_size)\n  * return 0, but do not complain if the option is not recognized.\n  */\n static int\n-java_decode_option (argc, argv)\n-     int argc __attribute__ ((__unused__));\n-     char **argv;\n+java_decode_option (int argc __attribute__ ((__unused__)), char **argv)\n {\n   char *p = argv[0];\n \n@@ -509,8 +505,7 @@ java_decode_option (argc, argv)\n FILE *finput;\n \n static const char *\n-java_init (filename)\n-     const char *filename;\n+java_init (const char *filename)\n {\n #if 0\n   extern int flag_minimal_debug;\n@@ -599,7 +594,7 @@ java_init (filename)\n }\n \n static void\n-java_finish ()\n+java_finish (void)\n {\n   jcf_dependency_write ();\n }\n@@ -617,9 +612,7 @@ static int decl_bufpos = 0;\n    It length is given by LEN;  -1 means the string is nul-terminated. */\n \n static void\n-put_decl_string (str, len)\n-     const char *str;\n-     int len;\n+put_decl_string (const char *str, int len)\n {\n   if (len < 0)\n     len = strlen (str);\n@@ -643,8 +636,7 @@ put_decl_string (str, len)\n /* Append to decl_buf a printable name for NODE. */\n \n static void\n-put_decl_node (node)\n-     tree node;\n+put_decl_node (tree node)\n {\n   int was_pointer = 0;\n   if (TREE_CODE (node) == POINTER_TYPE)\n@@ -719,9 +711,7 @@ put_decl_node (node)\n    which is also called directly by java_print_error_function. */\n \n const char *\n-lang_printable_name (decl, v)\n-     tree decl;\n-     int v  __attribute__ ((__unused__));\n+lang_printable_name (tree decl, int v  __attribute__ ((__unused__)))\n {\n   decl_bufpos = 0;\n   put_decl_node (decl);\n@@ -733,9 +723,7 @@ lang_printable_name (decl, v)\n    space to the DECL name string -- With Leading Space.  */\n \n const char *\n-lang_printable_name_wls (decl, v)\n-     tree decl;\n-     int v  __attribute__ ((__unused__));\n+lang_printable_name_wls (tree decl, int v  __attribute__ ((__unused__)))\n {\n   decl_bufpos = 1;\n   put_decl_node (decl);\n@@ -750,9 +738,8 @@ lang_printable_name_wls (decl, v)\n static GTY(()) tree last_error_function_context;\n static GTY(()) tree last_error_function;\n static void\n-java_print_error_function (context, file)\n-     diagnostic_context *context __attribute__((__unused__));\n-     const char *file;\n+java_print_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n+\t\t\t   const char *file)\n {\n   /* Don't print error messages with bogus function prototypes.  */\n   if (inhibit_error_function_printing)\n@@ -796,14 +783,13 @@ java_print_error_function (context, file)\n    2, function prototypes are fully resolved and can be printed when\n    reporting errors.  */\n \n-void lang_init_source (level)\n-     int level;\n+void lang_init_source (int level)\n {\n   inhibit_error_function_printing = (level == 1);\n }\n \n static void\n-java_init_options ()\n+java_init_options (void)\n {\n   flag_bounds_check = 1;\n   flag_exceptions = 1;\n@@ -814,7 +800,7 @@ java_init_options ()\n }\n \n static bool\n-java_can_use_bit_fields_p ()\n+java_can_use_bit_fields_p (void)\n {\n   /* The bit-field optimizations cause problems when generating class\n      files.  */\n@@ -823,7 +809,7 @@ java_can_use_bit_fields_p ()\n \n /* Post-switch processing.  */\n static bool\n-java_post_options ()\n+java_post_options (void)\n {\n  /* Use tree inlining if possible.  Function instrumentation is only\n      done in the RTL level, so we disable tree inlining.  */\n@@ -845,8 +831,7 @@ java_post_options ()\n /* Return either DECL or its known constant value (if it has one).  */\n \n tree\n-decl_constant_value (decl)\n-     tree decl;\n+decl_constant_value (tree decl)\n {\n   if (/* Don't change a variable array bound or initial value to a constant\n \t in a place where a variable is invalid.  */\n@@ -868,12 +853,11 @@ decl_constant_value (decl)\n /* Walk the language specific tree nodes during inlining.  */\n \n static tree\n-java_tree_inlining_walk_subtrees (tp,subtrees,func,data,htab)\n-     tree *tp ATTRIBUTE_UNUSED;\n-     int *subtrees ATTRIBUTE_UNUSED;\n-     walk_tree_fn func ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-     void *htab ATTRIBUTE_UNUSED;\n+java_tree_inlining_walk_subtrees (tree *tp ATTRIBUTE_UNUSED,\n+\t\t\t\t  int *subtrees ATTRIBUTE_UNUSED,\n+\t\t\t\t  walk_tree_fn func ATTRIBUTE_UNUSED,\n+\t\t\t\t  void *data ATTRIBUTE_UNUSED,\n+\t\t\t\t  void *htab ATTRIBUTE_UNUSED)\n {\n   enum tree_code code;\n   tree result;\n@@ -914,8 +898,7 @@ java_tree_inlining_walk_subtrees (tp,subtrees,func,data,htab)\n \n /* Called from unsafe_for_reeval.  */\n static int\n-java_unsafe_for_reeval (t)\n-     tree t;\n+java_unsafe_for_reeval (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -961,9 +944,7 @@ java_unsafe_for_reeval (t)\n    to one in the scope of the method being inlined into.  */\n \n static int\n-merge_init_test_initialization (entry, x)\n-     void * * entry;\n-     void * x;\n+merge_init_test_initialization (void **entry, void *x)\n {\n   struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n   splay_tree decl_map = (splay_tree)x;\n@@ -991,9 +972,7 @@ merge_init_test_initialization (entry, x)\n    inlining.  */\n \n void\n-java_inlining_merge_static_initializers (fn, decl_map)\n-     tree fn;\n-     void *decl_map;\n+java_inlining_merge_static_initializers (tree fn, void *decl_map)\n {\n   htab_traverse \n     (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n@@ -1007,9 +986,7 @@ java_inlining_merge_static_initializers (fn, decl_map)\n    pre-existing one.  */\n \n static int\n-inline_init_test_initialization (entry, x)\n-     void * * entry;\n-     void * x;\n+inline_init_test_initialization (void **entry, void *x)\n {\n   struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n   splay_tree decl_map = (splay_tree)x;\n@@ -1032,9 +1009,7 @@ inline_init_test_initialization (entry, x)\n    into, create a new mapping for it.  */\n \n void\n-java_inlining_map_static_initializers (fn, decl_map)\n-     tree fn;\n-     void *decl_map;\n+java_inlining_map_static_initializers (tree fn, void *decl_map)\n {\n   htab_traverse \n     (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n@@ -1044,9 +1019,7 @@ java_inlining_map_static_initializers (fn, decl_map)\n /* Avoid voluminous output for deep recursion of compound exprs.  */\n \n static void\n-dump_compound_expr (di, t)\n-     dump_info_p di;\n-     tree t;\n+dump_compound_expr (dump_info_p di, tree t)\n {\n   int i;\n \n@@ -1072,9 +1045,7 @@ dump_compound_expr (di, t)\n }\n   \n static int\n-java_dump_tree (dump_info, t)\n-     void *dump_info;\n-     tree t;\n+java_dump_tree (void *dump_info, tree t)\n {\n   enum tree_code code;\n   dump_info_p di = (dump_info_p) dump_info;"}, {"sha": "0aded3f162df1d37d0904a1e587076ff6111cd94", "filename": "gcc/java/lex.c", "status": "modified", "additions": 31, "deletions": 66, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -82,9 +82,7 @@ static int need_byteswap = 0;\n #endif\n \n void\n-java_init_lex (finput, encoding)\n-     FILE *finput;\n-     const char *encoding;\n+java_init_lex (FILE *finput, const char *encoding)\n {\n #ifndef JC1_LITE\n   int java_lang_imported = 0;\n@@ -139,9 +137,7 @@ java_init_lex (finput, encoding)\n }\n \n static char *\n-java_sprint_unicode (line, i)\n-    struct java_line *line;\n-    int i;\n+java_sprint_unicode (struct java_line *line, int i)\n {\n   static char buffer [10];\n   if (line->unicode_escape_p [i] || line->line [i] > 128)\n@@ -155,13 +151,13 @@ java_sprint_unicode (line, i)\n }\n \n static unicode_t\n-java_sneak_unicode ()\n+java_sneak_unicode (void)\n {\n   return (ctxp->c_line->line [ctxp->c_line->current]);\n }\n \n static void\n-java_unget_unicode ()\n+java_unget_unicode (void)\n {\n   if (!ctxp->c_line->current)\n     /* Can't unget unicode.  */\n@@ -172,7 +168,7 @@ java_unget_unicode ()\n }\n \n static void\n-java_allocate_new_line ()\n+java_allocate_new_line (void)\n {\n   unicode_t ahead = (ctxp->c_line ? ctxp->c_line->ahead[0] : '\\0');\n   char ahead_escape_p = (ctxp->c_line ? \n@@ -217,9 +213,7 @@ java_allocate_new_line ()\n /* Create a new lexer object.  */\n \n java_lexer *\n-java_new_lexer (finput, encoding)\n-     FILE *finput;\n-     const char *encoding;\n+java_new_lexer (FILE *finput, const char *encoding)\n {\n   java_lexer *lex = xmalloc (sizeof (java_lexer));\n   int enc_error = 0;\n@@ -306,8 +300,7 @@ java_new_lexer (finput, encoding)\n }\n \n void\n-java_destroy_lexer (lex)\n-     java_lexer *lex;\n+java_destroy_lexer (java_lexer *lex)\n {\n #ifdef HAVE_ICONV\n   if (! lex->use_fallback)\n@@ -317,8 +310,7 @@ java_destroy_lexer (lex)\n }\n \n static int\n-java_read_char (lex)\n-     java_lexer *lex;\n+java_read_char (java_lexer *lex)\n {\n   if (lex->unget_value)\n     {\n@@ -509,10 +501,7 @@ java_read_char (lex)\n }\n \n static void\n-java_store_unicode (l, c, unicode_escape_p)\n-    struct java_line *l;\n-    unicode_t c;\n-    int unicode_escape_p;\n+java_store_unicode (struct java_line *l, unicode_t c, int unicode_escape_p)\n {\n   if (l->size == l->max)\n     {\n@@ -526,9 +515,7 @@ java_store_unicode (l, c, unicode_escape_p)\n }\n \n static int\n-java_read_unicode (lex, unicode_escape_p)\n-     java_lexer *lex;\n-     int *unicode_escape_p;\n+java_read_unicode (java_lexer *lex, int *unicode_escape_p)\n {\n   int c;\n \n@@ -582,9 +569,8 @@ java_read_unicode (lex, unicode_escape_p)\n }\n \n static int\n-java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n-     java_lexer *lex;\n-     int *unicode_escape_p;\n+java_read_unicode_collapsing_terminators (java_lexer *lex,\n+\t\t\t\t\t  int *unicode_escape_p)\n {\n   int c = java_read_unicode (lex, unicode_escape_p);\n \n@@ -604,7 +590,7 @@ java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n }\n \n static int\n-java_get_unicode ()\n+java_get_unicode (void)\n {\n   /* It's time to read a line when...  */\n   if (!ctxp->c_line || ctxp->c_line->current == ctxp->c_line->size)\n@@ -651,8 +637,7 @@ java_get_unicode ()\n /* Parse the end of a C style comment.\n  * C is the first character following the '/' and '*'.  */\n static void\n-java_parse_end_comment (c)\n-     int c;\n+java_parse_end_comment (int c)\n {\n   for ( ;; c = java_get_unicode ())\n     {\n@@ -681,8 +666,7 @@ java_parse_end_comment (c)\n    character). Parsed keyword(s): @DEPRECATED.  */\n \n static int\n-java_parse_doc_section (c)\n-     int c;\n+java_parse_doc_section (int c)\n {\n   int valid_tag = 0, seen_star = 0;\n \n@@ -734,8 +718,7 @@ java_parse_doc_section (c)\n    This is only called if C >= 128 -- smaller values are handled\n    inline.  However, this function handles all values anyway.  */\n static int\n-java_start_char_p (c)\n-     unicode_t c;\n+java_start_char_p (unicode_t c)\n {\n   unsigned int hi = c / 256;\n   const char *const page = type_table[hi];\n@@ -754,8 +737,7 @@ java_start_char_p (c)\n    This is only called if C >= 128 -- smaller values are handled\n    inline.  However, this function handles all values anyway.  */\n static int\n-java_part_char_p (c)\n-     unicode_t c;\n+java_part_char_p (unicode_t c)\n {\n   unsigned int hi = c / 256;\n   const char *const page = type_table[hi];\n@@ -771,7 +753,7 @@ java_part_char_p (c)\n }\n \n static int\n-java_parse_escape_sequence ()\n+java_parse_escape_sequence (void)\n {\n   unicode_t char_lit;\n   int c;\n@@ -840,11 +822,8 @@ java_parse_escape_sequence ()\n static void java_perform_atof (YYSTYPE *, char *, int, int);\n \n static void\n-java_perform_atof (java_lval, literal_token, fflag, number_beginning)\n-     YYSTYPE *java_lval;\n-     char *literal_token;\n-     int fflag;\n-     int number_beginning;\n+java_perform_atof (YYSTYPE *java_lval, char *literal_token, int fflag,\n+\t\t   int number_beginning)\n {\n   REAL_VALUE_TYPE value;\n   tree type = (fflag ? FLOAT_TYPE_NODE : DOUBLE_TYPE_NODE);\n@@ -891,11 +870,10 @@ static int yylex (YYSTYPE *);\n \n static int\n #ifdef JC1_LITE\n-yylex (java_lval)\n+yylex (YYSTYPE *java_lval)\n #else\n-java_lex (java_lval)\n+java_lex (YYSTYPE *java_lval)\n #endif\n-     YYSTYPE *java_lval;\n {\n   int c;\n   unicode_t first_unicode;\n@@ -1654,8 +1632,7 @@ java_lex (java_lval)\n    case of the largest negative value, and is only called in the case\n    where this value is not preceded by `-'.  */\n static void\n-error_if_numeric_overflow (value)\n-     tree value;\n+error_if_numeric_overflow (tree value)\n {\n   if (TREE_CODE (value) == INTEGER_CST\n       && JAVA_RADIX10_FLAG (value)\n@@ -1670,8 +1647,7 @@ error_if_numeric_overflow (value)\n #endif /* JC1_LITE */\n \n static void\n-java_unicode_2_utf8 (unicode)\n-    unicode_t unicode;\n+java_unicode_2_utf8 (unicode_t unicode)\n {\n   if (RANGE (unicode, 0x01, 0x7f))\n     obstack_1grow (&temporary_obstack, (char)unicode);\n@@ -1695,8 +1671,7 @@ java_unicode_2_utf8 (unicode)\n \n #ifndef JC1_LITE\n static tree\n-build_wfl_node (node)\n-     tree node;\n+build_wfl_node (tree node)\n {\n   node = build_expr_wfl (node, ctxp->filename, ctxp->elc.line, ctxp->elc.col);\n   /* Prevent java_complete_lhs from short-circuiting node (if constant).  */\n@@ -1706,9 +1681,7 @@ build_wfl_node (node)\n #endif\n \n static void\n-java_lex_error (msg, forward)\n-     const char *msg ATTRIBUTE_UNUSED;\n-     int forward ATTRIBUTE_UNUSED;\n+java_lex_error (const char *msg ATTRIBUTE_UNUSED, int forward ATTRIBUTE_UNUSED)\n {\n #ifndef JC1_LITE\n   ctxp->elc.line = ctxp->c_line->lineno;\n@@ -1723,9 +1696,7 @@ java_lex_error (msg, forward)\n \n #ifndef JC1_LITE\n static int\n-java_is_eol (fp, c)\n-  FILE *fp;\n-  int c;\n+java_is_eol (FILE *fp, int c)\n {\n   int next;\n   switch (c)\n@@ -1744,9 +1715,8 @@ java_is_eol (fp, c)\n #endif\n \n char *\n-java_get_line_col (filename, line, col)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     int line ATTRIBUTE_UNUSED, col ATTRIBUTE_UNUSED;\n+java_get_line_col (const char *filename ATTRIBUTE_UNUSED,\n+\t\t   int line ATTRIBUTE_UNUSED, int col ATTRIBUTE_UNUSED)\n {\n #ifdef JC1_LITE\n   return 0;\n@@ -1822,10 +1792,7 @@ java_get_line_col (filename, line, col)\n \n #ifndef JC1_LITE\n static int\n-utf8_cmp (str, length, name)\n-     const unsigned char *str;\n-     int length;\n-     const char *name;\n+utf8_cmp (const unsigned char *str, int length, const char *name)\n {\n   const unsigned char *limit = str + length;\n   int i;\n@@ -1953,9 +1920,7 @@ static const char *const cxx_keywords[] =\n /* Return true if NAME is a C++ keyword.  */\n \n int\n-cxx_keyword_p (name, length)\n-     const char *name;\n-     int length;\n+cxx_keyword_p (const char *name, int length)\n {\n   int last = ARRAY_SIZE (cxx_keywords);\n   int first = 0;"}, {"sha": "9b52b2b1bebc9750232e1d276d8a865e8b465427", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 19, "deletions": 43, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -71,9 +71,7 @@ struct obstack *mangle_obstack;\n    the vtable. */\n \n tree\n-java_mangle_decl (obstack, decl)\n-     struct obstack *obstack;\n-     tree decl;\n+java_mangle_decl (struct obstack *obstack, tree decl)\n {\n   init_mangling (obstack);\n   switch (TREE_CODE (decl))\n@@ -91,9 +89,7 @@ java_mangle_decl (obstack, decl)\n }\n \n tree \n-java_mangle_class_field (obstack, type)\n-     struct obstack *obstack;\n-     tree type;\n+java_mangle_class_field (struct obstack *obstack, tree type)\n {\n   init_mangling (obstack);\n   mangle_record_type (type, /* for_pointer = */ 0);\n@@ -103,9 +99,7 @@ java_mangle_class_field (obstack, type)\n }\n \n tree\n-java_mangle_vtable (obstack, type)\n-     struct obstack *obstack;\n-     tree type;\n+java_mangle_vtable (struct obstack *obstack, tree type)\n {\n   init_mangling (obstack);\n   MANGLE_RAW_STRING (\"TV\");\n@@ -119,8 +113,7 @@ java_mangle_vtable (obstack, type)\n /* This mangles a field decl */\n \n static void\n-mangle_field_decl (decl)\n-     tree decl;\n+mangle_field_decl (tree decl)\n {\n   /* Mangle the name of the this the field belongs to */\n   mangle_record_type (DECL_CONTEXT (decl), /* for_pointer = */ 0);\n@@ -136,8 +129,7 @@ mangle_field_decl (decl)\n    its arguments. */\n \n static void\n-mangle_method_decl (mdecl)\n-     tree mdecl;\n+mangle_method_decl (tree mdecl)\n {\n   tree method_name = DECL_NAME (mdecl);\n   tree arglist;\n@@ -177,8 +169,7 @@ mangle_method_decl (mdecl)\n    value if unicode encoding was required.  */\n \n static void\n-mangle_member_name (name)\n-     tree name;\n+mangle_member_name (tree name)\n {\n   append_gpp_mangled_name (IDENTIFIER_POINTER (name),\n \t\t\t   IDENTIFIER_LENGTH (name));\n@@ -191,8 +182,7 @@ mangle_member_name (name)\n /* Append the mangled name of TYPE onto OBSTACK.  */\n \n static void\n-mangle_type (type)\n-     tree type;\n+mangle_type (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -255,8 +245,7 @@ static int  compression_next;\n    function to match pointer entries and start from the end */\n \n static int\n-find_compression_pointer_match (type)\n-     tree type;\n+find_compression_pointer_match (tree type)\n {\n   int i;\n \n@@ -270,17 +259,15 @@ find_compression_pointer_match (type)\n    associated with it.  */\n \n static int\n-find_compression_array_match (type)\n-     tree type;\n+find_compression_array_match (tree type)\n {\n   return find_compression_pointer_match (type);\n }\n \n /* Match the table of type against STRING.  */\n \n static int\n-find_compression_array_template_match (string)\n-     tree string;\n+find_compression_array_template_match (tree string)\n {\n   int i;\n   for (i = 0; i < compression_next; i++)\n@@ -295,9 +282,7 @@ find_compression_array_template_match (string)\n    to the rest of TYPE to be mangled. */\n \n static int\n-find_compression_record_match (type, next_current)\n-     tree type;\n-     tree *next_current;\n+find_compression_record_match (tree type, tree *next_current)\n {\n   int i, match;\n   tree current, saved_current = NULL_TREE;\n@@ -349,9 +334,7 @@ find_compression_record_match (type, next_current)\n    symbol, meaning it was preceded by a 'P'. */\n \n static int\n-mangle_record_type (type, for_pointer)\n-     tree type;\n-     int for_pointer;\n+mangle_record_type (tree type, int for_pointer)\n {\n   tree current;\n   int match;\n@@ -402,8 +385,7 @@ mangle_record_type (type, for_pointer)\n    a partial compression or/plus the rest of the mangling. */\n \n static void\n-mangle_pointer_type (type)\n-     tree type;\n+mangle_pointer_type (tree type)\n {\n   int match;\n   tree pointer_type;\n@@ -437,8 +419,7 @@ mangle_pointer_type (type)\n /* atms: array template mangled string. */\n static GTY(()) tree atms;\n static void\n-mangle_array_type (p_type)\n-     tree p_type;\n+mangle_array_type (tree p_type)\n {\n   tree type, elt_type;\n   int match;\n@@ -526,9 +507,7 @@ emit_compression_string (int i)\n    might all be unique, we find the same RECORD_TYPE.) */\n \n static int\n-entry_match_pointer_p (type, i)\n-     tree type;\n-     int i;\n+entry_match_pointer_p (tree type, int i)\n {\n   tree t = TREE_VEC_ELT (compression_table, i);\n   \n@@ -549,8 +528,7 @@ entry_match_pointer_p (type, i)\n    part. The result is stored in TYPE_PACKAGE_LIST to be reused.  */\n \n static void\n-set_type_package_list (type)\n-     tree type;\n+set_type_package_list (tree type)\n {\n   int i;\n   const char *type_string = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n@@ -593,8 +571,7 @@ set_type_package_list (type)\n    compression table if necessary.  */\n \n static void\n-compression_table_add (type)\n-     tree type;\n+compression_table_add (tree type)\n {\n   if (compression_next == TREE_VEC_LENGTH (compression_table))\n     {\n@@ -612,8 +589,7 @@ compression_table_add (type)\n /* Mangling initialization routine.  */\n \n static void\n-init_mangling (obstack)\n-     struct obstack *obstack;\n+init_mangling (struct obstack *obstack)\n {\n   mangle_obstack = obstack;\n   if (!compression_table)\n@@ -630,7 +606,7 @@ init_mangling (obstack)\n    IDENTIFIER_NODE.  */\n \n static tree\n-finish_mangling ()\n+finish_mangling (void)\n {\n   tree result;\n "}, {"sha": "fb085842b412e175dccb54e8c38e238f672bda7a", "filename": "gcc/java/mangle_name.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fmangle_name.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fmangle_name.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle_name.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -53,9 +53,7 @@ extern struct obstack *mangle_obstack;\n    frequently that they could be cached.  */\n \n void\n-append_gpp_mangled_name (name, len)\n-     const char *name;\n-     int len;\n+append_gpp_mangled_name (const char *name, int len)\n {\n   int encoded_len = unicode_mangling_length (name, len);\n   int needs_escapes = encoded_len > 0;\n@@ -76,9 +74,7 @@ append_gpp_mangled_name (name, len)\n    which case `__U' will be mangled `__U_'.  */\n \n static void\n-append_unicode_mangled_name (name, len)\n-     const char *name;\n-     int len;\n+append_unicode_mangled_name (const char *name, int len)\n {\n   const unsigned char *ptr;\n   const unsigned char *limit = (const unsigned char *)name + len;\n@@ -129,9 +125,7 @@ append_unicode_mangled_name (name, len)\n    escapes.  If no escapes are needed, return 0.  */\n \n static int\n-unicode_mangling_length (name, len)\n-     const char *name; \n-     int len; \n+unicode_mangling_length (const char *name, int len)\n {\n   const unsigned char *ptr;\n   const unsigned char *limit = (const unsigned char *)name + len;\n@@ -199,9 +193,7 @@ unicode_mangling_length (name, len)\n    so frequently that they could be cached.  */\n \n void\n-append_gpp_mangled_name (name, len)\n-     const char *name;\n-     int len;\n+append_gpp_mangled_name (const char *name, int len)\n {\n   const unsigned char *ptr;\n   const unsigned char *limit = (const unsigned char *)name + len;"}, {"sha": "981ed477b2eeef61a1eaa37472d143b24608a079", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -1176,7 +1176,7 @@ constant_expression:\n /* Create a new parser context */\n \n void\n-java_push_parser_context ()\n+java_push_parser_context (void)\n {\n   struct parser_ctxt *new = xcalloc (1, sizeof (struct parser_ctxt));\n \n@@ -1185,8 +1185,7 @@ java_push_parser_context ()\n }  \n \n static void\n-push_class_context (name)\n-    const char *name;\n+push_class_context (const char *name)\n {\n   struct class_context *ctx;\n \n@@ -1197,7 +1196,7 @@ push_class_context (name)\n }\n \n static void\n-pop_class_context ()\n+pop_class_context (void)\n {\n   struct class_context *ctx;\n \n@@ -1217,9 +1216,7 @@ pop_class_context ()\n /* Recursively construct the class name.  This is just a helper\n    function for get_class_name().  */\n static int\n-make_class_name_recursive (stack, ctx)\n-     struct obstack *stack;\n-     struct class_context *ctx;\n+make_class_name_recursive (struct obstack *stack, struct class_context *ctx)\n {\n   if (! ctx)\n     return 0;\n@@ -1243,7 +1240,7 @@ make_class_name_recursive (stack, ctx)\n \n /* Return a newly allocated string holding the name of the class.  */\n static char *\n-get_class_name ()\n+get_class_name (void)\n {\n   char *result;\n   int last_was_digit;\n@@ -1287,8 +1284,7 @@ get_class_name ()\n /* Actions defined here */\n \n static void\n-report_class_declaration (name)\n-     const char * name;\n+report_class_declaration (const char * name)\n {\n   extern int flag_dump_class, flag_list_filename;\n \n@@ -1314,8 +1310,7 @@ report_class_declaration (name)\n }\n \n static void\n-report_main_declaration (declarator)\n-     struct method_declarator *declarator;\n+report_main_declaration (struct method_declarator *declarator)\n {\n   extern int flag_find_main;\n \n@@ -1342,7 +1337,7 @@ report_main_declaration (declarator)\n }\n \n void\n-report ()\n+report (void)\n {\n   extern int flag_complexity;\n   if (flag_complexity)\n@@ -1351,7 +1346,7 @@ report ()\n \n /* Reset global status used by the report functions.  */\n \n-void reset_report ()\n+void reset_report (void)\n {\n   previous_output = 0;\n   package_name = NULL;\n@@ -1360,8 +1355,7 @@ void reset_report ()\n }\n \n void\n-yyerror (msg)\n-     const char *msg ATTRIBUTE_UNUSED;\n+yyerror (const char *msg ATTRIBUTE_UNUSED)\n {\n   fprintf (stderr, \"%s: %d: %s\\n\", input_filename, lineno, msg);\n   exit (1);"}, {"sha": "dcdcc41ed97f1e80e63fe8738b3e5cb04b18dc30", "filename": "gcc/java/parse.y", "status": "modified", "additions": 282, "deletions": 598, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -2630,8 +2630,7 @@ constant_expression:\n    `dims:' rule is being used.  */\n \n static int\n-pop_current_osb (ctxp)\n-     struct parser_ctxt *ctxp;\n+pop_current_osb (struct parser_ctxt *ctxp)\n {\n   int to_return;\n \n@@ -2655,8 +2654,7 @@ pop_current_osb (ctxp)\n    created context becomes the current one.  */\n \n static void\n-create_new_parser_context (copy_from_previous)\n-    int copy_from_previous;\n+create_new_parser_context (int copy_from_previous)\n {\n   struct parser_ctxt *new;\n \n@@ -2676,14 +2674,13 @@ create_new_parser_context (copy_from_previous)\n /* Create a new parser context and make it the current one. */\n \n void\n-java_push_parser_context ()\n+java_push_parser_context (void)\n {\n   create_new_parser_context (0);\n }\n \n void\n-java_pop_parser_context (generate)\n-     int generate;\n+java_pop_parser_context (int generate)\n {\n   tree current;\n   struct parser_ctxt *toFree, *next;\n@@ -2727,7 +2724,7 @@ java_pop_parser_context (generate)\n    variables.  */\n \n void\n-java_parser_context_save_global ()\n+java_parser_context_save_global (void)\n {\n   if (!ctxp)\n     {\n@@ -2751,7 +2748,7 @@ java_parser_context_save_global ()\n    previous context the current one.  */\n \n void\n-java_parser_context_restore_global ()\n+java_parser_context_restore_global (void)\n {\n   lineno = ctxp->lineno;\n   current_class = ctxp->class_type;\n@@ -2773,7 +2770,7 @@ java_parser_context_restore_global ()\n    classes be parsed.  */\n \n static void\n-java_parser_context_suspend ()\n+java_parser_context_suspend (void)\n {\n   /* This makes debugging through java_debug_context easier */\n   static const char *const name = \"<inner buffer context>\";\n@@ -2799,7 +2796,7 @@ java_parser_context_suspend ()\n    can resume as if no context was ever saved. */\n \n static void\n-java_parser_context_resume ()\n+java_parser_context_resume (void)\n {\n   struct parser_ctxt *old = ctxp;             /* This one is to be discarded */\n   struct parser_ctxt *saver = old->next;      /* This one contain saved info */\n@@ -2826,7 +2823,7 @@ java_parser_context_resume ()\n    linked.  */\n \n static void\n-java_parser_context_push_initialized_field ()\n+java_parser_context_push_initialized_field (void)\n {\n   tree node;\n \n@@ -2848,7 +2845,7 @@ java_parser_context_push_initialized_field ()\n    or <clinit> functions. */\n \n static void\n-java_parser_context_pop_initialized_field ()\n+java_parser_context_pop_initialized_field (void)\n {\n   tree stmts;\n   tree class_type = TREE_TYPE (GET_CPC ());\n@@ -2883,8 +2880,7 @@ java_parser_context_pop_initialized_field ()\n }\n \n static tree\n-reorder_static_initialized (list)\n-     tree list;\n+reorder_static_initialized (tree list)\n {\n   /* We have to keep things in order. The alias initializer have to\n      come first, then the initialized regular field, in reverse to\n@@ -2920,8 +2916,7 @@ reorder_static_initialized (list)\n   {int i; for (i = 0; i < (C); i++) fputc (' ', stderr);}\n \n static void\n-java_debug_context_do (tab)\n-     int tab;\n+java_debug_context_do (int tab)\n {\n   struct parser_ctxt *copy = ctxp;\n   while (copy)\n@@ -2949,7 +2944,7 @@ java_debug_context_do (tab)\n    debugger.  */\n \n void\n-java_debug_context ()\n+java_debug_context (void)\n {\n   java_debug_context_do (0);\n }\n@@ -2964,7 +2959,7 @@ static int force_error = 0;\n \n /* Reporting an constructor invocation error.  */\n static void\n-parse_ctor_invocation_error ()\n+parse_ctor_invocation_error (void)\n {\n   if (DECL_CONSTRUCTOR_P (current_function_decl))\n     yyerror (\"Constructor invocation must be first thing in a constructor\");\n@@ -2975,8 +2970,7 @@ parse_ctor_invocation_error ()\n /* Reporting JDK1.1 features not implemented.  */\n \n static tree\n-parse_jdk1_1_error (msg)\n-    const char *msg;\n+parse_jdk1_1_error (const char *msg)\n {\n   sorry (\": `%s' JDK1.1(TM) feature\", msg);\n   java_error_count++;\n@@ -2986,8 +2980,7 @@ parse_jdk1_1_error (msg)\n static int do_warning = 0;\n \n void\n-yyerror (msg)\n-     const char *msg;\n+yyerror (const char *msg)\n {\n   static java_lc elc;\n   static int  prev_lineno;\n@@ -3051,10 +3044,7 @@ yyerror (msg)\n }\n \n static void\n-issue_warning_error_from_context (cl, msg, ap)\n-     tree cl;\n-     const char *msg;\n-     va_list ap;\n+issue_warning_error_from_context (tree cl, const char *msg, va_list ap)\n {\n   const char *saved, *saved_input_filename;\n   char buffer [4096];\n@@ -3104,8 +3094,7 @@ parse_warning_context (tree cl, const char *msg, ...)\n }\n \n static tree\n-find_expr_with_wfl (node)\n-     tree node;\n+find_expr_with_wfl (tree node)\n {\n   while (node)\n     {\n@@ -3148,8 +3137,7 @@ find_expr_with_wfl (node)\n    last line of the method the error occurs in.  */\n \n static void\n-missing_return_error (method)\n-     tree method;\n+missing_return_error (tree method)\n {\n   EXPR_WFL_SET_LINECOL (wfl_operator, DECL_SOURCE_LINE_LAST (method), -2);\n   parse_error_context (wfl_operator, \"Missing return statement\");\n@@ -3158,8 +3146,7 @@ missing_return_error (method)\n /* Issue an unreachable statement error. From NODE, find the next\n    statement to report appropriately.  */\n static void\n-unreachable_stmt_error (node)\n-     tree node;\n+unreachable_stmt_error (tree node)\n {\n   /* Browse node to find the next expression node that has a WFL. Use\n      the location to report the error */\n@@ -3178,7 +3165,7 @@ unreachable_stmt_error (node)\n }\n \n int\n-java_report_errors ()\n+java_report_errors (void)\n {\n   if (java_error_count)\n     fprintf (stderr, \"%d error%s\",\n@@ -3192,8 +3179,7 @@ java_report_errors ()\n }\n \n static char *\n-java_accstring_lookup (flags)\n-     int flags;\n+java_accstring_lookup (int flags)\n {\n   static char buffer [80];\n #define COPY_RETURN(S) {strcpy (buffer, S); return buffer;}\n@@ -3221,9 +3207,7 @@ java_accstring_lookup (flags)\n    variables. */\n \n static void\n-classitf_redefinition_error (context, id, decl, cl)\n-     const char *context;\n-     tree id, decl, cl;\n+classitf_redefinition_error (const char *context, tree id, tree decl, tree cl)\n {\n   parse_error_context (cl, \"%s `%s' already defined in %s:%d\",\n \t\t       context, IDENTIFIER_POINTER (id),\n@@ -3232,9 +3216,7 @@ classitf_redefinition_error (context, id, decl, cl)\n }\n \n static void\n-variable_redefinition_error (context, name, type, line)\n-     tree context, name, type;\n-     int line;\n+variable_redefinition_error (tree context, tree name, tree type, int line)\n {\n   const char *type_name;\n \n@@ -3256,9 +3238,7 @@ variable_redefinition_error (context, name, type, line)\n    the node pointed to by TRIMMED unless TRIMMED is null.  */\n \n static int\n-build_type_name_from_array_name (aname, trimmed)\n-     tree aname;\n-     tree *trimmed;\n+build_type_name_from_array_name (tree aname, tree *trimmed)\n {\n   const char *name = IDENTIFIER_POINTER (aname);\n   int len = IDENTIFIER_LENGTH (aname);\n@@ -3273,8 +3253,7 @@ build_type_name_from_array_name (aname, trimmed)\n }\n \n static tree\n-build_array_from_name (type, type_wfl, name, ret_name)\n-     tree type, type_wfl, name, *ret_name;\n+build_array_from_name (tree type, tree type_wfl, tree name, tree *ret_name)\n {\n   int more_dims = 0;\n \n@@ -3326,8 +3305,7 @@ build_array_from_name (type, type_wfl, name, ret_name)\n    identifier. */\n \n static tree\n-build_unresolved_array_type (type_or_wfl)\n-     tree type_or_wfl;\n+build_unresolved_array_type (tree type_or_wfl)\n {\n   const char *ptr;\n   tree wfl;\n@@ -3353,8 +3331,7 @@ build_unresolved_array_type (type_or_wfl)\n }\n \n static void\n-parser_add_interface (class_decl, interface_decl, wfl)\n-     tree class_decl, interface_decl, wfl;\n+parser_add_interface (tree class_decl, tree interface_decl, tree wfl)\n {\n   if (maybe_add_interface (TREE_TYPE (class_decl), TREE_TYPE (interface_decl)))\n     parse_error_context (wfl, \"Interface `%s' repeated\",\n@@ -3365,9 +3342,8 @@ parser_add_interface (class_decl, interface_decl, wfl)\n    encountered. TAG is 0 for a class, 1 for an interface.  */\n \n static int\n-check_class_interface_creation (is_interface, flags, raw_name, qualified_name, decl, cl)\n-     int is_interface, flags;\n-     tree raw_name, qualified_name, decl, cl;\n+check_class_interface_creation (int is_interface, int flags, tree raw_name,\n+\t\t\t\ttree qualified_name, tree decl, tree cl)\n {\n   tree node;\n   int sca = 0;\t\t\t/* Static class allowed */\n@@ -3483,8 +3459,7 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n /* Construct a nested class name.  If the final component starts with\n    a digit, return true.  Otherwise return false.  */\n static int\n-make_nested_class_name (cpc_list)\n-     tree cpc_list;\n+make_nested_class_name (tree cpc_list)\n {\n   tree name;\n \n@@ -3507,8 +3482,7 @@ make_nested_class_name (cpc_list)\n /* Can't redefine a class already defined in an earlier scope. */\n \n static int\n-check_inner_class_redefinition (raw_name, cl)\n-     tree raw_name, cl;\n+check_inner_class_redefinition (tree raw_name, tree cl)\n {\n   tree scope_list;\n \n@@ -3528,9 +3502,8 @@ check_inner_class_redefinition (raw_name, cl)\n    we remember ENCLOSING and SUPER.  */\n \n static tree\n-resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n-     htab_t circularity_hash;\n-     tree cl, *enclosing, *super, class_type;\n+resolve_inner_class (htab_t circularity_hash, tree cl, tree *enclosing,\n+\t\t     tree *super, tree class_type)\n {\n   tree local_enclosing = *enclosing;\n   tree local_super = NULL_TREE;\n@@ -3593,8 +3566,7 @@ resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n    qualified. */\n \n static tree\n-find_as_inner_class (enclosing, name, cl)\n-     tree enclosing, name, cl;\n+find_as_inner_class (tree enclosing, tree name, tree cl)\n {\n   tree qual, to_return;\n   if (!enclosing)\n@@ -3647,8 +3619,7 @@ find_as_inner_class (enclosing, name, cl)\n    through. */\n \n static tree\n-find_as_inner_class_do (qual, enclosing)\n-     tree qual, enclosing;\n+find_as_inner_class_do (tree qual, tree enclosing)\n {\n   if (!qual)\n     return NULL_TREE;\n@@ -3678,9 +3649,7 @@ find_as_inner_class_do (qual, enclosing)\n    DECL. */\n \n static void\n-set_nested_class_simple_name_value (outer, set)\n-     tree outer;\n-     int set;\n+set_nested_class_simple_name_value (tree outer, int set)\n {\n   tree l;\n \n@@ -3690,7 +3659,7 @@ set_nested_class_simple_name_value (outer, set)\n }\n \n static void\n-link_nested_class_to_enclosing ()\n+link_nested_class_to_enclosing (void)\n {\n   if (GET_ENCLOSING_CPC ())\n     {\n@@ -3702,8 +3671,7 @@ link_nested_class_to_enclosing ()\n }\n \n static tree\n-maybe_make_nested_class_name (name)\n-     tree name;\n+maybe_make_nested_class_name (tree name)\n {\n   tree id = NULL_TREE;\n \n@@ -3737,8 +3705,8 @@ maybe_make_nested_class_name (name)\n    line CL and do other maintenance things.  */\n \n static tree\n-maybe_create_class_interface_decl (decl, raw_name, qualified_name, cl)\n-     tree decl, raw_name, qualified_name, cl;\n+maybe_create_class_interface_decl (tree decl, tree raw_name,\n+\t\t\t\t   tree qualified_name, tree cl)\n {\n   if (!decl)\n     decl = push_class (make_class (), qualified_name);\n@@ -3775,8 +3743,7 @@ maybe_create_class_interface_decl (decl, raw_name, qualified_name, cl)\n }\n \n static void\n-add_superinterfaces (decl, interface_list)\n-     tree decl, interface_list;\n+add_superinterfaces (tree decl, tree interface_list)\n {\n   tree node;\n   /* Superinterface(s): if present and defined, parser_check_super_interface ()\n@@ -3805,9 +3772,7 @@ add_superinterfaces (decl, interface_list)\n    interface's decl in pass 2.  */\n \n static tree\n-create_interface (flags, id, super)\n-     int flags;\n-     tree id, super;\n+create_interface (int flags, tree id, tree super)\n {\n   tree raw_name = EXPR_WFL_NODE (id);\n   tree q_name = parser_qualified_classname (raw_name);\n@@ -3866,8 +3831,7 @@ create_interface (flags, id, super)\n    DEP.  */\n \n static void\n-patch_anonymous_class (type_decl, class_decl, wfl)\n-    tree type_decl, class_decl, wfl;\n+patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n {\n   tree class = TREE_TYPE (class_decl);\n   tree type =  TREE_TYPE (type_decl);\n@@ -3899,9 +3863,7 @@ patch_anonymous_class (type_decl, class_decl, wfl)\n }\n \n static tree\n-create_anonymous_class (location, type_name)\n-    int location;\n-    tree type_name;\n+create_anonymous_class (int location, tree type_name)\n {\n   char buffer [80];\n   tree super = NULL_TREE, itf = NULL_TREE;\n@@ -3943,9 +3905,7 @@ create_anonymous_class (location, type_name)\n    interface's decl in pass 2.  */\n \n static tree\n-create_class (flags, id, super, interfaces)\n-     int flags;\n-     tree id, super, interfaces;\n+create_class (int flags, tree id, tree super, tree interfaces)\n {\n   tree raw_name = EXPR_WFL_NODE (id);\n   tree class_id, decl;\n@@ -4051,8 +4011,7 @@ create_class (flags, id, super, interfaces)\n    parser context if necessary.  */\n \n static void\n-end_class_declaration (resume)\n-     int resume;\n+end_class_declaration (int resume)\n {\n   /* If an error occurred, context weren't pushed and won't need to be\n      popped by a resume. */\n@@ -4075,9 +4034,7 @@ end_class_declaration (resume)\n }\n \n static void\n-add_inner_class_fields (class_decl, fct_decl)\n-     tree class_decl;\n-     tree fct_decl;\n+add_inner_class_fields (tree class_decl, tree fct_decl)\n {\n   tree block, marker, f;\n \n@@ -4165,9 +4122,7 @@ add_inner_class_fields (class_decl, fct_decl)\n    can't set the CLASS_LOADED_P flag */\n \n static tree\n-find_field (class, name)\n-     tree class;\n-     tree name;\n+find_field (tree class, tree name)\n {\n   tree decl;\n   for (decl = TYPE_FIELDS (class); decl; decl = TREE_CHAIN (decl))\n@@ -4182,8 +4137,7 @@ find_field (class, name)\n    of CLASS */\n \n static tree\n-lookup_field_wrapper (class, name)\n-     tree class, name;\n+lookup_field_wrapper (tree class, tree name)\n {\n   tree type = class;\n   tree decl = NULL_TREE;\n@@ -4222,8 +4176,7 @@ lookup_field_wrapper (class, name)\n    otherwise.  */\n \n static int\n-duplicate_declaration_error_p (new_field_name, new_type, cl)\n-     tree new_field_name, new_type, cl;\n+duplicate_declaration_error_p (tree new_field_name, tree new_type, tree cl)\n {\n   /* This might be modified to work with method decl as well */\n   tree decl = find_field (TREE_TYPE (GET_CPC ()), new_field_name);\n@@ -4258,9 +4211,7 @@ duplicate_declaration_error_p (new_field_name, new_type, cl)\n    be later resolved in java_complete_class () */\n \n static void\n-register_fields (flags, type, variable_list)\n-     int flags;\n-     tree type, variable_list;\n+register_fields (int flags, tree type, tree variable_list)\n {\n   tree current, saved_type;\n   tree class_type = NULL_TREE;\n@@ -4405,8 +4356,7 @@ register_fields (flags, type, variable_list)\n    local(s).  */\n \n static tree\n-generate_finit (class_type)\n-     tree class_type;\n+generate_finit (tree class_type)\n {\n   int count = 0;\n   tree list = TYPE_FINIT_STMT_LIST (class_type);\n@@ -4440,8 +4390,7 @@ generate_finit (class_type)\n    statements in a try/catch/rethrow sequence.  */\n \n static tree\n-generate_instinit (class_type)\n-     tree class_type;\n+generate_instinit (tree class_type)\n {\n   tree current;\n   tree compound = NULL_TREE;\n@@ -4483,8 +4432,7 @@ generate_instinit (class_type)\n \n /* FIXME */\n static tree\n-build_instinit_invocation (class_type)\n-     tree class_type;\n+build_instinit_invocation (tree class_type)\n {\n   tree to_return = NULL_TREE;\n \n@@ -4514,9 +4462,7 @@ static int patch_stage;\n    with a constructor.  */\n \n static tree\n-method_header (flags, type, mdecl, throws)\n-     int flags;\n-     tree type, mdecl, throws;\n+method_header (int flags, tree type, tree mdecl, tree throws)\n {\n   tree type_wfl = NULL_TREE;\n   tree meth_name = NULL_TREE;\n@@ -4726,8 +4672,7 @@ method_header (flags, type, mdecl, throws)\n }\n \n static void\n-fix_method_argument_names (orig_arg, meth)\n-    tree orig_arg, meth;\n+fix_method_argument_names (tree orig_arg, tree meth)\n {\n   tree arg = TYPE_ARG_TYPES (TREE_TYPE (meth));\n   if (TREE_CODE (TREE_TYPE (meth)) == METHOD_TYPE)\n@@ -4746,8 +4691,7 @@ fix_method_argument_names (orig_arg, meth)\n /* Complete the method declaration with METHOD_BODY.  */\n \n static void\n-finish_method_declaration (method_body)\n-     tree method_body;\n+finish_method_declaration (tree method_body)\n {\n   int flags;\n \n@@ -4805,8 +4749,7 @@ finish_method_declaration (method_body)\n /* Build a an error message for constructor circularity errors.  */\n \n static char *\n-constructor_circularity_msg (from, to)\n-     tree from, to;\n+constructor_circularity_msg (tree from, tree to)\n {\n   static char string [4096];\n   char *t = xstrdup (lang_printable_name (from, 0));\n@@ -4820,8 +4763,7 @@ constructor_circularity_msg (from, to)\n \n static GTY(()) tree vcc_list;\n static int\n-verify_constructor_circularity (meth, current)\n-     tree meth, current;\n+verify_constructor_circularity (tree meth, tree current)\n {\n   tree c;\n \n@@ -4865,8 +4807,7 @@ verify_constructor_circularity (meth, current)\n /* Check modifiers that can be declared but exclusively */\n \n static void\n-check_modifiers_consistency (flags)\n-     int flags;\n+check_modifiers_consistency (int flags)\n {\n   int acc_count = 0;\n   tree cl = NULL_TREE;\n@@ -4890,8 +4831,7 @@ check_modifiers_consistency (flags)\n /* Check the methode header METH for abstract specifics features */\n \n static void\n-check_abstract_method_header (meth)\n-     tree meth;\n+check_abstract_method_header (tree meth)\n {\n   int flags = get_access_flags_from_decl (meth);\n \n@@ -4912,8 +4852,7 @@ check_abstract_method_header (meth)\n    incomplete types.  */\n \n static tree\n-method_declarator (id, list)\n-     tree id, list;\n+method_declarator (tree id, tree list)\n {\n   tree arg_types = NULL_TREE, current, node;\n   tree meth = make_node (FUNCTION_TYPE);\n@@ -5010,9 +4949,7 @@ method_declarator (id, list)\n }\n \n static int\n-unresolved_type_p (wfl, returned)\n-     tree wfl;\n-     tree *returned;\n+unresolved_type_p (tree wfl, tree *returned)\n \n {\n   if (TREE_CODE (wfl) == EXPR_WITH_FILE_LOCATION)\n@@ -5038,8 +4975,7 @@ unresolved_type_p (wfl, returned)\n    qualification from the current package definition. */\n \n static tree\n-parser_qualified_classname (name)\n-     tree name;\n+parser_qualified_classname (tree name)\n {\n   tree nested_class_name;\n \n@@ -5056,8 +4992,7 @@ parser_qualified_classname (name)\n    everything is OK.  */\n \n static int\n-parser_check_super_interface (super_decl, this_decl, this_wfl)\n-     tree super_decl, this_decl, this_wfl;\n+parser_check_super_interface (tree super_decl, tree this_decl, tree this_wfl)\n {\n   tree super_type = TREE_TYPE (super_decl);\n \n@@ -5091,8 +5026,7 @@ parser_check_super_interface (super_decl, this_decl, this_wfl)\n    0 if everthing is OK.  */\n \n static int\n-parser_check_super (super_decl, this_decl, wfl)\n-     tree super_decl, this_decl, wfl;\n+parser_check_super (tree super_decl, tree this_decl, tree wfl)\n {\n   tree super_type = TREE_TYPE (super_decl);\n \n@@ -5130,8 +5064,7 @@ parser_check_super (super_decl, this_decl, wfl)\n    CTXP list of type dependency list.  */\n \n static void\n-create_jdep_list (ctxp)\n-     struct parser_ctxt *ctxp;\n+create_jdep_list (struct parser_ctxt *ctxp)\n {\n   jdeplist *new = xmalloc (sizeof (jdeplist));\n   new->first = new->last = NULL;\n@@ -5140,8 +5073,7 @@ create_jdep_list (ctxp)\n }\n \n static jdeplist *\n-reverse_jdep_list (ctxp)\n-     struct parser_ctxt *ctxp;\n+reverse_jdep_list (struct parser_ctxt *ctxp)\n {\n   register jdeplist *prev = NULL, *current, *next;\n   for (current = ctxp->classd_list; current; current = next)\n@@ -5158,8 +5090,7 @@ reverse_jdep_list (ctxp)\n    registered again. */\n \n static tree\n-obtain_incomplete_type (type_name)\n-     tree type_name;\n+obtain_incomplete_type (tree type_name)\n {\n   tree ptr = NULL_TREE, name;\n \n@@ -5184,9 +5115,7 @@ obtain_incomplete_type (type_name)\n    manner.  */\n \n static tree\n-register_incomplete_type (kind, wfl, decl, ptr)\n-     int kind;\n-     tree wfl, decl, ptr;\n+register_incomplete_type (int kind, tree wfl, tree decl, tree ptr)\n {\n   jdep *new = xmalloc (sizeof (jdep));\n \n@@ -5225,9 +5154,7 @@ register_incomplete_type (kind, wfl, decl, ptr)\n    otherwise.  */\n \n static tree\n-check_inner_circular_reference (source, target)\n-     tree source;\n-     tree target;\n+check_inner_circular_reference (tree source, tree target)\n {\n   tree basetype_vec = TYPE_BINFO_BASETYPES (source);\n   tree ctx, cl;\n@@ -5273,8 +5200,7 @@ check_inner_circular_reference (source, target)\n    otherwise. TYPE can be an interface or a class.   */\n \n static tree\n-check_circular_reference (type)\n-     tree type;\n+check_circular_reference (tree type)\n {\n   tree basetype_vec = TYPE_BINFO_BASETYPES (type);\n   int i;\n@@ -5300,7 +5226,7 @@ check_circular_reference (type)\n }\n \n void\n-java_check_circular_reference ()\n+java_check_circular_reference (void)\n {\n   tree current;\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n@@ -5326,10 +5252,8 @@ java_check_circular_reference ()\n    finit$.  */\n \n static tree\n-build_alias_initializer_parameter_list (mode, class_type, parm, artificial)\n-    int mode;\n-    tree class_type, parm;\n-    int *artificial;\n+build_alias_initializer_parameter_list (int mode, tree class_type, tree parm,\n+\t\t\t\t\tint *artificial)\n {\n   tree field;\n   tree additional_parms = NULL_TREE;\n@@ -5407,8 +5331,7 @@ build_alias_initializer_parameter_list (mode, class_type, parm, artificial)\n    enforced. This is the case for anonymous classes.  */\n \n static tree\n-craft_constructor (class_decl, args)\n-     tree class_decl, args;\n+craft_constructor (tree class_decl, tree args)\n {\n   tree class_type = TREE_TYPE (class_decl);\n   tree parm = NULL_TREE;\n@@ -5466,7 +5389,7 @@ craft_constructor (class_decl, args)\n    compilation triggered this one to be simply loaded.  */\n \n void\n-java_fix_constructors ()\n+java_fix_constructors (void)\n {\n   tree current;\n \n@@ -5500,8 +5423,7 @@ java_fix_constructors ()\n    about the class processed currently.  */\n \n void\n-safe_layout_class (class)\n-     tree class;\n+safe_layout_class (tree class)\n {\n   tree save_current_class = current_class;\n   const char *save_input_filename = input_filename;\n@@ -5515,8 +5437,7 @@ safe_layout_class (class)\n }\n \n static tree\n-jdep_resolve_class (dep)\n-     jdep *dep;\n+jdep_resolve_class (jdep *dep)\n {\n   tree decl;\n \n@@ -5548,7 +5469,7 @@ jdep_resolve_class (dep)\n /* Complete unsatisfied class declaration and their dependencies */\n \n void\n-java_complete_class ()\n+java_complete_class (void)\n {\n   tree cclass;\n   jdeplist *cclassd;\n@@ -5696,8 +5617,7 @@ java_complete_class ()\n    array.  */\n \n static tree\n-resolve_class (enclosing, class_type, decl, cl)\n-     tree enclosing, class_type, decl, cl;\n+resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n {\n   tree tname = TYPE_NAME (class_type);\n   tree resolved_type = TREE_TYPE (class_type);\n@@ -5747,8 +5667,7 @@ resolve_class (enclosing, class_type, decl, cl)\n    qualify_and_find.  */\n \n tree\n-do_resolve_class (enclosing, class_type, decl, cl)\n-     tree enclosing, class_type, decl, cl;\n+do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n {\n   tree new_class_decl = NULL_TREE, super = NULL_TREE;\n   tree saved_enclosing_type = enclosing ? TREE_TYPE (enclosing) : NULL_TREE;\n@@ -5901,8 +5820,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n }\n \n static tree\n-qualify_and_find (class_type, package, name)\n-     tree class_type, package, name;\n+qualify_and_find (tree class_type, tree package, tree name)\n {\n   tree new_qualified = merge_qualified_name (package, name);\n   tree new_class_decl;\n@@ -5925,9 +5843,7 @@ qualify_and_find (class_type, package, name)\n    called when type resolution is necessary during the walk pass.  */\n \n static tree\n-resolve_and_layout (something, cl)\n-     tree something;\n-     tree cl;\n+resolve_and_layout (tree something, tree cl)\n {\n   tree decl, decl_type;\n \n@@ -5988,8 +5904,7 @@ resolve_and_layout (something, cl)\n    layout. The current parsing context is saved and restored */\n \n static tree\n-resolve_no_layout (name, cl)\n-     tree name, cl;\n+resolve_no_layout (tree name, tree cl)\n {\n   tree ptr, decl;\n   BUILD_PTR_FROM_NAME (ptr, name);\n@@ -6005,8 +5920,7 @@ resolve_no_layout (name, cl)\n    use an identifier tree.  */\n \n static const char *\n-purify_type_name (name)\n-     const char *name;\n+purify_type_name (const char *name)\n {\n   int len = strlen (name);\n   int bracket_found;\n@@ -6024,8 +5938,7 @@ purify_type_name (name)\n /* The type CURRENT refers to can't be found. We print error messages.  */\n \n static void\n-complete_class_report_errors (dep)\n-     jdep *dep;\n+complete_class_report_errors (jdep *dep)\n {\n   const char *name;\n \n@@ -6091,8 +6004,7 @@ complete_class_report_errors (dep)\n    <init> */\n \n static const char *\n-get_printable_method_name (decl)\n-     tree decl;\n+get_printable_method_name (tree decl)\n {\n   const char *to_return;\n   tree name = NULL_TREE;\n@@ -6115,8 +6027,7 @@ get_printable_method_name (decl)\n    function it's a FWL, so we can track errors more accurately.)  */\n \n static int\n-check_method_redefinition (class, method)\n-     tree class, method;\n+check_method_redefinition (tree class, tree method)\n {\n   tree redef, sig;\n \n@@ -6146,9 +6057,8 @@ check_method_redefinition (class, method)\n \n /* Return 1 if check went ok, 0 otherwise.  */\n static int\n-check_abstract_method_definitions (do_interface, class_decl, type)\n-     int do_interface;\n-     tree class_decl, type;\n+check_abstract_method_definitions (int do_interface, tree class_decl,\n+\t\t\t\t   tree type)\n {\n   tree class = TREE_TYPE (class_decl);\n   tree method, end_type;\n@@ -6242,8 +6152,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n    methods.  */\n \n static void\n-java_check_abstract_method_definitions (class_decl)\n-     tree class_decl;\n+java_check_abstract_method_definitions (tree class_decl)\n {\n   tree class = TREE_TYPE (class_decl);\n   tree super, vector;\n@@ -6273,8 +6182,7 @@ java_check_abstract_method_definitions (class_decl)\n    safe to build a method signature or not.  */\n \n static int\n-check_method_types_complete (decl)\n-     tree decl;\n+check_method_types_complete (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n   tree args;\n@@ -6295,8 +6203,7 @@ check_method_types_complete (decl)\n /* Visible interface to check methods contained in CLASS_DECL */\n \n void\n-java_check_methods (class_decl)\n-     tree class_decl;\n+java_check_methods (tree class_decl)\n {\n   if (CLASS_METHOD_CHECKED_P (TREE_TYPE (class_decl)))\n     return;\n@@ -6315,8 +6222,7 @@ java_check_methods (class_decl)\n    declaration.  */\n \n static void\n-java_check_regular_methods (class_decl)\n-     tree class_decl;\n+java_check_regular_methods (tree class_decl)\n {\n   int saw_constructor = ANONYMOUS_CLASS_P (TREE_TYPE (class_decl));\n   tree method;\n@@ -6490,8 +6396,7 @@ java_check_regular_methods (class_decl)\n    is incompatible with the `throws' clause of FOUND (if any).  */\n \n static void\n-check_throws_clauses (method, method_wfl, found)\n-     tree method, method_wfl, found;\n+check_throws_clauses (tree method, tree method_wfl, tree found)\n {\n   tree mthrows, fthrows;\n \n@@ -6525,8 +6430,7 @@ check_throws_clauses (method, method_wfl, found)\n /* Check abstract method of interface INTERFACE */\n \n static void\n-java_check_abstract_methods (interface_decl)\n-     tree interface_decl;\n+java_check_abstract_methods (tree interface_decl)\n {\n   int i, n;\n   tree method, basetype_vec, found;\n@@ -6594,8 +6498,7 @@ java_check_abstract_methods (interface_decl)\n    signature. Return a matching method only if their types differ.  */\n \n static tree\n-lookup_java_interface_method2 (class, method_decl)\n-     tree class, method_decl;\n+lookup_java_interface_method2 (tree class, tree method_decl)\n {\n   int i, n;\n   tree basetype_vec = TYPE_BINFO_BASETYPES (class), to_return;\n@@ -6627,9 +6530,7 @@ lookup_java_interface_method2 (class, method_decl)\n    matching method only if their types differ.  */\n \n static tree\n-lookup_java_method2 (clas, method_decl, do_interface)\n-     tree clas, method_decl;\n-     int do_interface;\n+lookup_java_method2 (tree clas, tree method_decl, int do_interface)\n {\n   tree method, method_signature, method_name, method_type, name;\n \n@@ -6662,8 +6563,7 @@ lookup_java_method2 (clas, method_decl, do_interface)\n \n static GTY(()) tree cl_v;\n static tree\n-lookup_cl (decl)\n-     tree decl;\n+lookup_cl (tree decl)\n {\n   char *line, *found;\n \n@@ -6692,8 +6592,7 @@ lookup_cl (decl)\n /* Look for a simple name in the single-type import list */\n \n static tree\n-find_name_in_single_imports (name)\n-     tree name;\n+find_name_in_single_imports (tree name)\n {\n   tree node;\n \n@@ -6707,7 +6606,7 @@ find_name_in_single_imports (name)\n /* Process all single-type import. */\n \n static int\n-process_imports ()\n+process_imports (void)\n {\n   tree import;\n   int error_found;\n@@ -6766,9 +6665,7 @@ process_imports ()\n    statement.  */\n \n static void\n-find_in_imports (enclosing_type, class_type)\n-     tree enclosing_type;\n-     tree class_type;\n+find_in_imports (tree enclosing_type, tree class_type)\n {\n   tree import = (enclosing_type ? TYPE_IMPORT_LIST (enclosing_type) :\n \t\t ctxp->import_list);\n@@ -6785,9 +6682,7 @@ find_in_imports (enclosing_type, class_type)\n }\n \n static int\n-note_possible_classname (name, len)\n-     const char *name;\n-     int len;\n+note_possible_classname (const char *name, int len)\n {\n   tree node;\n   if (len > 5 && strncmp (&name [len-5], \".java\", 5) == 0)\n@@ -6807,8 +6702,7 @@ note_possible_classname (name, len)\n    directory.  */\n \n static void\n-read_import_dir (wfl)\n-     tree wfl;\n+read_import_dir (tree wfl)\n {\n   tree package_id = EXPR_WFL_NODE (wfl);\n   const char *package_name = IDENTIFIER_POINTER (package_id);\n@@ -6929,9 +6823,7 @@ read_import_dir (wfl)\n    entire list, to detected potential double definitions.  */\n \n static int\n-find_in_imports_on_demand (enclosing_type, class_type)\n-     tree enclosing_type;\n-     tree class_type;\n+find_in_imports_on_demand (tree enclosing_type, tree class_type)\n {\n   tree class_type_name = TYPE_NAME (class_type);\n   tree import = (enclosing_type ? TYPE_IMPORT_DEMAND_LIST (enclosing_type) :\n@@ -7031,8 +6923,7 @@ find_in_imports_on_demand (enclosing_type, class_type)\n    particular package is added only once.  */\n \n static void\n-register_package (name)\n-     tree name;\n+register_package (tree name)\n {\n   static htab_t pht;\n   void **e;\n@@ -7049,8 +6940,7 @@ register_package (name)\n }\n \n static tree\n-resolve_package (pkg, next, type_name)\n-     tree pkg, *next, *type_name;\n+resolve_package (tree pkg, tree *next, tree *type_name)\n {\n   tree current;\n   tree decl = NULL_TREE;\n@@ -7091,8 +6981,7 @@ resolve_package (pkg, next, type_name)\n    access is being attempted. */\n \n static void\n-check_inner_class_access (decl, enclosing_decl, cl)\n-     tree decl, enclosing_decl, cl;\n+check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n {\n   const char *access;\n   tree enclosing_decl_type;\n@@ -7207,10 +7096,7 @@ check_pkg_class_access (tree class_name, tree cl, bool verbose)\n /* Local variable declaration. */\n \n static void\n-declare_local_variables (modifier, type, vlist)\n-     int modifier;\n-     tree type;\n-     tree vlist;\n+declare_local_variables (int modifier, tree type, tree vlist)\n {\n   tree decl, current, saved_type;\n   tree type_wfl = NULL_TREE;\n@@ -7318,8 +7204,7 @@ declare_local_variables (modifier, type, vlist)\n /* Called during parsing. Build decls from argument list.  */\n \n static void\n-source_start_java_method (fndecl)\n-     tree fndecl;\n+source_start_java_method (tree fndecl)\n {\n   tree tem;\n   tree parm_decl;\n@@ -7374,10 +7259,8 @@ source_start_java_method (fndecl)\n /* Called during parsing. Creates an artificial method declaration.  */\n \n static tree\n-create_artificial_method (class, flags, type, name, args)\n-     tree class;\n-     int flags;\n-     tree type, name, args;\n+create_artificial_method (tree class, int flags, tree type,\n+\t\t\t  tree name, tree args)\n {\n   tree mdecl;\n \n@@ -7395,8 +7278,7 @@ create_artificial_method (class, flags, type, name, args)\n /* Starts the body if an artificial method.  */\n \n static void\n-start_artificial_method_body (mdecl)\n-     tree mdecl;\n+start_artificial_method_body (tree mdecl)\n {\n   DECL_SOURCE_LINE (mdecl) = 1;\n   DECL_SOURCE_LINE_MERGE (mdecl, 1);\n@@ -7405,8 +7287,7 @@ start_artificial_method_body (mdecl)\n }\n \n static void\n-end_artificial_method_body (mdecl)\n-     tree mdecl;\n+end_artificial_method_body (tree mdecl)\n {\n   /* exit_block modifies DECL_FUNCTION_BODY (current_function_decl).\n      It has to be evaluated first. (if mdecl is current_function_decl,\n@@ -7419,9 +7300,7 @@ end_artificial_method_body (mdecl)\n /* Dump a tree of some kind.  This is a convenience wrapper for the\n    dump_* functions in tree-dump.c.  */\n static void\n-dump_java_tree (phase, t)\n-     enum tree_dump_index phase;\n-     tree t;\n+dump_java_tree (enum tree_dump_index phase, tree t)\n {\n   FILE *stream;\n   int flags;\n@@ -7438,7 +7317,7 @@ dump_java_tree (phase, t)\n /* Terminate a function and expand its body.  */\n \n static void\n-source_end_java_method ()\n+source_end_java_method (void)\n {\n   tree fndecl = current_function_decl;\n \n@@ -7491,17 +7370,15 @@ source_end_java_method ()\n    expression second operand if necessary.  */\n \n tree\n-java_method_add_stmt (fndecl, expr)\n-     tree fndecl, expr;\n+java_method_add_stmt (tree fndecl, tree expr)\n {\n   if (!GET_CURRENT_BLOCK (fndecl))\n     return NULL_TREE;\n   return add_stmt_to_block (GET_CURRENT_BLOCK (fndecl), NULL_TREE, expr);\n }\n \n static tree\n-add_stmt_to_block (b, type, stmt)\n-     tree b, type, stmt;\n+add_stmt_to_block (tree b, tree type, tree stmt)\n {\n   tree body = BLOCK_EXPR_BODY (b), c;\n \n@@ -7520,8 +7397,7 @@ add_stmt_to_block (b, type, stmt)\n    COMPOUND_EXPR and add STMT to it. */\n \n static tree\n-add_stmt_to_compound (existing, type, stmt)\n-     tree existing, type, stmt;\n+add_stmt_to_compound (tree existing, tree type, tree stmt)\n {\n   /* Keep track of this for inlining.  */\n   if (current_function_decl)\n@@ -7533,7 +7409,7 @@ add_stmt_to_compound (existing, type, stmt)\n     return stmt;\n }\n \n-void java_layout_seen_class_methods ()\n+void java_layout_seen_class_methods (void)\n {\n   tree previous_list = all_class_list;\n   tree end = NULL_TREE;\n@@ -7557,7 +7433,7 @@ void java_layout_seen_class_methods ()\n \n static GTY(()) tree stop_reordering;\n void\n-java_reorder_fields ()\n+java_reorder_fields (void)\n {\n   tree current;\n \n@@ -7602,7 +7478,7 @@ java_reorder_fields ()\n    classes */\n \n void\n-java_layout_classes ()\n+java_layout_classes (void)\n {\n   tree current;\n   int save_error_count = java_error_count;\n@@ -7639,7 +7515,7 @@ java_layout_classes ()\n    generation.  */\n \n static void\n-java_complete_expand_classes ()\n+java_complete_expand_classes (void)\n {\n   tree current;\n \n@@ -7654,8 +7530,7 @@ java_complete_expand_classes ()\n    classes, if any.  */\n \n static void\n-java_complete_expand_class (outer)\n-     tree outer;\n+java_complete_expand_class (tree outer)\n {\n   tree inner_list;\n \n@@ -7681,8 +7556,7 @@ java_complete_expand_class (outer)\n    constructors and then <clinit>.  */\n \n static void\n-java_complete_expand_methods (class_decl)\n-     tree class_decl;\n+java_complete_expand_methods (tree class_decl)\n {\n   tree clinit, decl, first_decl;\n \n@@ -7783,8 +7657,7 @@ java_complete_expand_methods (class_decl)\n    safely used in some other methods/constructors.  */\n \n static tree\n-maybe_generate_pre_expand_clinit (class_type)\n-     tree class_type;\n+maybe_generate_pre_expand_clinit (tree class_type)\n {\n   tree current, mdecl;\n \n@@ -7843,8 +7716,7 @@ maybe_generate_pre_expand_clinit (class_type)\n    MODIFY_EXPR with a constant value.  */\n \n static int\n-analyze_clinit_body (this_class, bbody)\n-     tree this_class, bbody;\n+analyze_clinit_body (tree this_class, tree bbody)\n {\n   while (bbody)\n     switch (TREE_CODE (bbody))\n@@ -7892,8 +7764,7 @@ analyze_clinit_body (this_class, bbody)\n    is empty. Return 1 if <clinit> was discarded, 0 otherwise. */\n \n static int\n-maybe_yank_clinit (mdecl)\n-     tree mdecl;\n+maybe_yank_clinit (tree mdecl)\n {\n   tree type, current;\n   tree fbody, bbody;\n@@ -7966,8 +7837,7 @@ maybe_yank_clinit (mdecl)\n    expansion of mdecl's body.  */\n \n static void\n-start_complete_expand_method (mdecl)\n-     tree mdecl;\n+start_complete_expand_method (tree mdecl)\n {\n   tree tem;\n \n@@ -8000,8 +7870,7 @@ start_complete_expand_method (mdecl)\n /* Complete and expand a method.  */\n \n static void\n-java_complete_expand_method (mdecl)\n-     tree mdecl;\n+java_complete_expand_method (tree mdecl)\n {\n   tree fbody, block_body, exception_copy;\n \n@@ -8105,8 +7974,7 @@ java_complete_expand_method (mdecl)\n /* For with each class for which there's code to generate. */\n \n static void\n-java_expand_method_bodies (class)\n-     tree class;\n+java_expand_method_bodies (tree class)\n {\n   tree decl;\n   for (decl = TYPE_METHODS (class); decl; decl = TREE_CHAIN (decl))\n@@ -8178,8 +8046,7 @@ java_expand_method_bodies (class)\n    be later turned into a write by calling outer_field_access_fix.  */\n \n static tree\n-build_outer_field_access (id, decl)\n-     tree id, decl;\n+build_outer_field_access (tree id, tree decl)\n {\n   tree access = NULL_TREE;\n   tree ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n@@ -8228,8 +8095,7 @@ build_outer_field_access (id, decl)\n    access.  */\n \n static int\n-outer_field_access_p (type, decl)\n-    tree type, decl;\n+outer_field_access_p (tree type, tree decl)\n {\n   if (!INNER_CLASS_TYPE_P (type)\n       || TREE_CODE (decl) != FIELD_DECL\n@@ -8267,8 +8133,8 @@ outer_field_access_p (type, decl)\n    call if necessary. */\n \n static int\n-outer_field_expanded_access_p (node, name, arg_type, arg)\n-    tree node, *name, *arg_type, *arg;\n+outer_field_expanded_access_p (tree node, tree *name, tree *arg_type,\n+\t\t\t       tree *arg)\n {\n   int identified = 0;\n \n@@ -8314,8 +8180,7 @@ outer_field_expanded_access_p (node, name, arg_type, arg)\n    be identified. */\n \n static tree\n-outer_field_access_fix (wfl, node, rhs)\n-    tree wfl, node, rhs;\n+outer_field_access_fix (tree wfl, tree node, tree rhs)\n {\n   tree name, arg_type, arg;\n \n@@ -8335,9 +8200,8 @@ outer_field_access_fix (wfl, node, rhs)\n    read access.  */\n \n static tree\n-build_outer_field_access_expr (lc, type, access_method_name, arg1, arg2)\n-    int lc;\n-    tree type, access_method_name, arg1, arg2;\n+build_outer_field_access_expr (int lc, tree type, tree access_method_name,\n+\t\t\t       tree arg1, tree arg2)\n {\n   tree args, cn, access;\n \n@@ -8354,7 +8218,7 @@ build_outer_field_access_expr (lc, type, access_method_name, arg1, arg2)\n }\n \n static tree\n-build_new_access_id ()\n+build_new_access_id (void)\n {\n   static int access_n_counter = 1;\n   char buffer [128];\n@@ -8378,8 +8242,7 @@ build_new_access_id ()\n */\n \n static tree\n-build_outer_field_access_methods (decl)\n-    tree decl;\n+build_outer_field_access_methods (tree decl)\n {\n   tree id, args, stmt, mdecl;\n \n@@ -8429,8 +8292,8 @@ build_outer_field_access_methods (decl)\n /* Build an field access method NAME.  */\n \n static tree\n-build_outer_field_access_method (class, type, name, args, body)\n-    tree class, type, name, args, body;\n+build_outer_field_access_method (tree class, tree type, tree name,\n+\t\t\t\t tree args, tree body)\n {\n   tree saved_current_function_decl, mdecl;\n \n@@ -8454,8 +8317,7 @@ build_outer_field_access_method (class, type, name, args, body)\n    certain kinds of method invocation from inner classes.  */\n \n static tree\n-build_outer_method_access_method (decl)\n-    tree decl;\n+build_outer_method_access_method (tree decl)\n {\n   tree saved_current_function_decl, mdecl;\n   tree args = NULL_TREE, call_args = NULL_TREE;\n@@ -8544,9 +8406,7 @@ build_outer_method_access_method (decl)\n    for example build_outer_field_access).  */\n \n static tree\n-build_access_to_thisn (from, to, lc)\n-     tree from, to;\n-     int lc;\n+build_access_to_thisn (tree from, tree to, int lc)\n {\n   tree access = NULL_TREE;\n \n@@ -8588,8 +8448,7 @@ build_access_to_thisn (from, to, lc)\n    attribute so that they can't be referred to directly.  */\n \n static tree\n-maybe_build_thisn_access_method (type)\n-    tree type;\n+maybe_build_thisn_access_method (tree type)\n {\n   tree mdecl, args, stmt, rtype;\n   tree saved_current_function_decl;\n@@ -8634,8 +8493,7 @@ static GTY(()) tree saved_thisn;\n static GTY(()) tree saved_type;\n \n static tree\n-build_current_thisn (type)\n-    tree type;\n+build_current_thisn (tree type)\n {\n   static int saved_i = -1;\n   static int saved_type_i = 0;\n@@ -8674,7 +8532,7 @@ build_current_thisn (type)\n    form used is `this.this$<n> = this$<n>;'.  */\n \n static tree\n-build_thisn_assign ()\n+build_thisn_assign (void)\n {\n   if (current_class && PURE_INNER_CLASS_TYPE_P (current_class))\n     {\n@@ -8703,8 +8561,7 @@ static GTY(()) tree get_message_wfl;\n static GTY(()) tree type_parm_wfl;\n \n static tree\n-build_dot_class_method (class)\n-     tree class;\n+build_dot_class_method (tree class)\n {\n #define BWF(S) build_wfl_node (get_identifier ((S)))\n #define MQN(X,Y) make_qualified_name ((X), (Y), 0)\n@@ -8772,8 +8629,7 @@ build_dot_class_method (class)\n }\n \n static tree\n-build_dot_class_method_invocation (type)\n-     tree type;\n+build_dot_class_method_invocation (tree type)\n {\n   tree sig_id, s;\n \n@@ -8799,8 +8655,7 @@ build_dot_class_method_invocation (type)\n    necessary.  */\n \n static void\n-fix_constructors (mdecl)\n-     tree mdecl;\n+fix_constructors (tree mdecl)\n {\n   tree iii;\t\t\t/* Instance Initializer Invocation */\n   tree body = DECL_FUNCTION_BODY (mdecl);\n@@ -8920,8 +8775,7 @@ fix_constructors (mdecl)\n    for something that has the same signature. */\n \n static int\n-verify_constructor_super (mdecl)\n-     tree mdecl;\n+verify_constructor_super (tree mdecl)\n {\n   tree class = CLASSTYPE_SUPER (current_class);\n   int super_inner = PURE_INNER_CLASS_TYPE_P (class);\n@@ -8973,7 +8827,7 @@ verify_constructor_super (mdecl)\n \n static GTY(()) tree reversed_class_list;\n void\n-java_expand_classes ()\n+java_expand_classes (void)\n {\n   int save_error_count = 0;\n   static struct parser_ctxt *cur_ctxp = NULL;\n@@ -9096,9 +8950,7 @@ java_expand_classes ()\n    separating `.' operator.  */\n \n static tree\n-make_qualified_primary (primary, right, location)\n-     tree primary, right;\n-     int location;\n+make_qualified_primary (tree primary, tree right, int location)\n {\n   tree wfl;\n \n@@ -9122,8 +8974,7 @@ make_qualified_primary (primary, right, location)\n /* Simple merge of two name separated by a `.' */\n \n static tree\n-merge_qualified_name (left, right)\n-     tree left, right;\n+merge_qualified_name (tree left, tree right)\n {\n   tree node;\n   if (!left && !right)\n@@ -9151,9 +9002,7 @@ merge_qualified_name (left, right)\n    inherited from the location information of the `.' operator. */\n \n static tree\n-make_qualified_name (left, right, location)\n-     tree left, right;\n-     int location;\n+make_qualified_name (tree left, tree right, int location)\n {\n #ifdef USE_COMPONENT_REF\n   tree node = build (COMPONENT_REF, NULL_TREE, left, right);\n@@ -9187,8 +9036,7 @@ make_qualified_name (left, right, location)\n    last identifier is removed from the linked list */\n \n static tree\n-cut_identifier_in_qualified (wfl)\n-     tree wfl;\n+cut_identifier_in_qualified (tree wfl)\n {\n   tree q;\n   tree previous = NULL_TREE;\n@@ -9207,9 +9055,7 @@ cut_identifier_in_qualified (wfl)\n /* Resolve the expression name NAME. Return its decl.  */\n \n static tree\n-resolve_expression_name (id, orig)\n-     tree id;\n-     tree *orig;\n+resolve_expression_name (tree id, tree *orig)\n {\n   tree name = EXPR_WFL_NODE (id);\n   tree decl;\n@@ -9311,8 +9157,7 @@ resolve_expression_name (id, orig)\n }\n \n static void\n-static_ref_err (wfl, field_id, class_type)\n-    tree wfl, field_id, class_type;\n+static_ref_err (tree wfl, tree field_id, tree class_type)\n {\n   parse_error_context\n     (wfl,\n@@ -9327,9 +9172,7 @@ static_ref_err (wfl, field_id, class_type)\n    recipient's address can be null. */\n \n static tree\n-resolve_field_access (qual_wfl, field_decl, field_type)\n-     tree qual_wfl;\n-     tree *field_decl, *field_type;\n+resolve_field_access (tree qual_wfl, tree *field_decl, tree *field_type)\n {\n   int is_static = 0;\n   tree field_ref;\n@@ -9392,8 +9235,7 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n    NODE. */\n \n static tree\n-strip_out_static_field_access_decl (node)\n-    tree node;\n+strip_out_static_field_access_decl (tree node)\n {\n   if (TREE_CODE (node) == COMPOUND_EXPR)\n     {\n@@ -9416,9 +9258,8 @@ strip_out_static_field_access_decl (node)\n /* 6.5.5.2: Qualified Expression Names */\n \n static int\n-resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n-     tree wfl;\n-     tree *found_decl, *type_found, *where_found;\n+resolve_qualified_expression_name (tree wfl, tree *found_decl,\n+\t\t\t\t   tree *where_found, tree *type_found)\n {\n   int from_type = 0;\t\t/* Field search initiated from a type */\n   int from_super = 0, from_cast = 0, from_qualified_this = 0;\n@@ -9966,10 +9807,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n    method.  */\n \n static int\n-not_accessible_p (reference, member, where, from_super)\n-     tree reference, member;\n-     tree where;\n-     int from_super;\n+not_accessible_p (tree reference, tree member, tree where, int from_super)\n {\n   int access_flag = get_access_flags_from_decl (member);\n \n@@ -10041,8 +9879,7 @@ not_accessible_p (reference, member, where, from_super)\n \n /* Test deprecated decl access.  */\n static void\n-check_deprecation (wfl, decl)\n-     tree wfl, decl;\n+check_deprecation (tree wfl, tree decl)\n {\n   const char *file = DECL_SOURCE_FILE (decl);\n   /* Complain if the field is deprecated and the file it was defined\n@@ -10082,8 +9919,7 @@ check_deprecation (wfl, decl)\n \n static GTY(()) tree cicp_cache;\n static int\n-class_in_current_package (class)\n-     tree class;\n+class_in_current_package (tree class)\n {\n   int qualified_flag;\n   tree left;\n@@ -10119,8 +9955,7 @@ class_in_current_package (class)\n    done only if certain conditions meet.  */\n \n static tree\n-maybe_access_field (decl, where, type)\n-  tree decl, where, type;\n+maybe_access_field (tree decl, tree where, tree type)\n {\n   if (TREE_CODE (decl) == FIELD_DECL && decl != current_this\n       && !FIELD_STATIC (decl))\n@@ -10135,12 +9970,8 @@ maybe_access_field (decl, where, type)\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation (patch, primary, where, from_super,\n-                        is_static, ret_decl)\n-     tree patch, primary, where;\n-     int from_super;\n-     int *is_static;\n-     tree *ret_decl;\n+patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n+\t\t\t int *is_static, tree *ret_decl)\n {\n   tree wfl = TREE_OPERAND (patch, 0);\n   tree args = TREE_OPERAND (patch, 1);\n@@ -10549,8 +10380,8 @@ patch_method_invocation (patch, primary, where, from_super,\n    non static method. Return 1 if it's the case, 0 otherwise. */\n \n static int\n-check_for_static_method_reference (wfl, node, method, where, primary)\n-     tree wfl, node, method, where, primary;\n+check_for_static_method_reference (tree wfl, tree node, tree method,\n+\t\t\t\t   tree where, tree primary)\n {\n   if (METHOD_STATIC (current_function_decl)\n       && !METHOD_STATIC (method) && !primary && !CALL_CONSTRUCTOR_P (node))\n@@ -10572,9 +10403,7 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n    returned.  */\n \n static int\n-maybe_use_access_method (is_super_init, mdecl, this_arg)\n-     int is_super_init;\n-     tree *mdecl, *this_arg;\n+maybe_use_access_method (int is_super_init, tree *mdecl, tree *this_arg)\n {\n   tree ctx;\n   tree md = *mdecl, ta = *this_arg;\n@@ -10642,8 +10471,7 @@ maybe_use_access_method (is_super_init, mdecl, this_arg)\n    mode.  */\n \n static tree\n-patch_invoke (patch, method, args)\n-     tree patch, method, args;\n+patch_invoke (tree patch, tree method, tree args)\n {\n   tree dtable, func;\n   tree original_call, t, ta;\n@@ -10801,9 +10629,7 @@ patch_invoke (patch, method, args)\n }\n \n static int\n-invocation_mode (method, super)\n-     tree method;\n-     int super;\n+invocation_mode (tree method, int super)\n {\n   int access = get_access_flags_from_decl (method);\n \n@@ -10834,10 +10660,7 @@ invocation_mode (method, super)\n    15.11.2 (Compile-Time Step 2) */\n \n static tree\n-lookup_method_invoke (lc, cl, class, name, arg_list)\n-     int lc;\n-     tree cl;\n-     tree class, name, arg_list;\n+lookup_method_invoke (int lc, tree cl, tree class, tree name, tree arg_list)\n {\n   tree atl = end_params_node;\t\t/* Arg Type List */\n   tree method, signature, list, node;\n@@ -10920,9 +10743,8 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n    when we're looking for a constructor. */\n \n static tree\n-find_applicable_accessible_methods_list (lc, class, name, arglist)\n-     int lc;\n-     tree class, name, arglist;\n+find_applicable_accessible_methods_list (int lc, tree class, tree name,\n+\t\t\t\t\t tree arglist)\n {\n   static htab_t searched_classes;\n   static int search_not_done = 0;\n@@ -11040,10 +10862,8 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n /* Effectively search for the appropriate method in method */\n \n static void\n-search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n-     int lc;\n-     tree method, name, arglist;\n-     tree *list, *all_list;\n+search_applicable_methods_list (int lc, tree method, tree name, tree arglist,\n+\t\t\t\ttree *list, tree *all_list)\n {\n   for (; method; method = TREE_CHAIN (method))\n     {\n@@ -11071,8 +10891,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n /* 15.11.2.2 Choose the Most Specific Method */\n \n static tree\n-find_most_specific_methods_list (list)\n-     tree list;\n+find_most_specific_methods_list (tree list)\n {\n   int max = 0;\n   int abstract, candidates;\n@@ -11162,8 +10981,7 @@ static GTY(()) tree m2_arg_value;\n static GTY(()) tree m2_arg_cache;\n \n static int\n-argument_types_convertible (m1, m2_or_arglist)\n-    tree m1, m2_or_arglist;\n+argument_types_convertible (tree m1, tree m2_or_arglist)\n {\n   register tree m1_arg, m2_arg;\n \n@@ -11203,8 +11021,7 @@ argument_types_convertible (m1, m2_or_arglist)\n /* Qualification routines */\n \n static void\n-qualify_ambiguous_name (id)\n-     tree id;\n+qualify_ambiguous_name (tree id)\n {\n   tree qual, qual_wfl, name = NULL_TREE, decl, ptr_type = NULL_TREE,\n     saved_current_class;\n@@ -11436,8 +11253,7 @@ qualify_ambiguous_name (id)\n }\n \n static int\n-breakdown_qualified (left, right, source)\n-    tree *left, *right, source;\n+breakdown_qualified (tree *left, tree *right, tree source)\n {\n   char *p, *base;\n   int l = IDENTIFIER_LENGTH (source);\n@@ -11465,8 +11281,7 @@ breakdown_qualified (left, right, source)\n /* Return TRUE if two classes are from the same package. */\n \n static int\n-in_same_package (name1, name2)\n-  tree name1, name2;\n+in_same_package (tree name1, tree name2)\n {\n   tree tmp;\n   tree pkg1;\n@@ -11496,8 +11311,7 @@ in_same_package (name1, name2)\n    Same as java_complete_lhs, but does resolve static finals to values. */\n \n static tree\n-java_complete_tree (node)\n-     tree node;\n+java_complete_tree (tree node)\n {\n   node = java_complete_lhs (node);\n   if (JDECL_P (node) && CLASS_FINAL_VARIABLE_P (node)\n@@ -11512,8 +11326,7 @@ java_complete_tree (node)\n }\n \n static tree\n-java_stabilize_reference (node)\n-     tree node;\n+java_stabilize_reference (tree node)\n {\n   if (TREE_CODE (node) == COMPOUND_EXPR)\n     {\n@@ -11531,8 +11344,7 @@ java_stabilize_reference (node)\n    Same as java_complete_tree, but does not resolve static finals to values. */\n \n static tree\n-java_complete_lhs (node)\n-     tree node;\n+java_complete_lhs (tree node)\n {\n   tree nn, cn, wfl_op1, wfl_op2, wfl_op3;\n   int flag;\n@@ -12293,8 +12105,7 @@ java_complete_lhs (node)\n    error was found.  */\n \n static int\n-complete_function_arguments (node)\n-     tree node;\n+complete_function_arguments (tree node)\n {\n   int flag = 0;\n   tree cn;\n@@ -12327,9 +12138,7 @@ complete_function_arguments (node)\n    debugable.  */\n \n static tree\n-build_debugable_stmt (location, stmt)\n-    int location;\n-    tree stmt;\n+build_debugable_stmt (int location, tree stmt)\n {\n   if (TREE_CODE (stmt) != EXPR_WITH_FILE_LOCATION)\n     {\n@@ -12341,8 +12150,8 @@ build_debugable_stmt (location, stmt)\n }\n \n static tree\n-build_expr_block (body, decls)\n-     tree body, decls;\n+build_expr_block (tree body, tree decls)\n+\n {\n   tree node = make_node (BLOCK);\n   BLOCK_EXPR_DECLS (node) = decls;\n@@ -12357,7 +12166,7 @@ build_expr_block (body, decls)\n    function block chain */\n \n static tree\n-enter_block ()\n+enter_block (void)\n {\n   tree b = build_expr_block (NULL_TREE, NULL_TREE);\n \n@@ -12391,7 +12200,7 @@ enter_block ()\n    the block being exited isn't the method's top level one.  */\n \n static tree\n-exit_block ()\n+exit_block (void)\n {\n   tree b;\n   if (current_function_decl)\n@@ -12415,8 +12224,7 @@ exit_block ()\n    scoping rules.  */\n \n static tree\n-lookup_name_in_blocks (name)\n-     tree name;\n+lookup_name_in_blocks (tree name)\n {\n   tree b = GET_CURRENT_BLOCK (current_function_decl);\n \n@@ -12438,7 +12246,7 @@ lookup_name_in_blocks (name)\n }\n \n static void\n-maybe_absorb_scoping_blocks ()\n+maybe_absorb_scoping_blocks (void)\n {\n   while (BLOCK_IS_IMPLICIT (GET_CURRENT_BLOCK (current_function_decl)))\n     {\n@@ -12456,9 +12264,7 @@ maybe_absorb_scoping_blocks ()\n /* Wrap a non WFL node around a WFL.  */\n \n static tree\n-build_wfl_wrap (node, location)\n-    tree node;\n-    int location;\n+build_wfl_wrap (tree node, int location)\n {\n   tree wfl, node_to_insert = node;\n \n@@ -12479,8 +12285,7 @@ build_wfl_wrap (node, location)\n    we're currently dealing with the class java.lang.Object. */\n \n static tree\n-build_super_invocation (mdecl)\n-     tree mdecl;\n+build_super_invocation (tree mdecl)\n {\n   if (DECL_CONTEXT (mdecl) == object_type_node)\n     return empty_stmt_node;\n@@ -12503,10 +12308,8 @@ build_super_invocation (mdecl)\n /* Build a SUPER/THIS qualified method invocation.  */\n \n static tree\n-build_this_super_qualified_invocation (use_this, name, args, lloc, rloc)\n-     int use_this;\n-     tree name, args;\n-     int lloc, rloc;\n+build_this_super_qualified_invocation (int use_this, tree name, tree args,\n+\t\t\t\t       int lloc, int rloc)\n {\n   tree invok;\n   tree wfl =\n@@ -12519,9 +12322,7 @@ build_this_super_qualified_invocation (use_this, name, args, lloc, rloc)\n /* Build an incomplete CALL_EXPR node. */\n \n static tree\n-build_method_invocation (name, args)\n-    tree name;\n-    tree args;\n+build_method_invocation (tree name, tree args)\n {\n   tree call = build (CALL_EXPR, NULL_TREE, name, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n@@ -12532,8 +12333,7 @@ build_method_invocation (name, args)\n /* Build an incomplete new xxx(...) node. */\n \n static tree\n-build_new_invocation (name, args)\n-    tree name, args;\n+build_new_invocation (tree name, tree args)\n {\n   tree call = build (NEW_CLASS_EXPR, NULL_TREE, name, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n@@ -12544,9 +12344,7 @@ build_new_invocation (name, args)\n /* Build an incomplete assignment expression. */\n \n static tree\n-build_assignment (op, op_location, lhs, rhs)\n-     int op, op_location;\n-     tree lhs, rhs;\n+build_assignment (int op, int op_location, tree lhs, tree rhs)\n {\n   tree assignment;\n   /* Build the corresponding binop if we deal with a Compound\n@@ -12566,8 +12364,7 @@ build_assignment (op, op_location, lhs, rhs)\n /* Print an INTEGER_CST node as decimal in a static buffer, and return\n    the buffer.  This is used only for string conversion.  */\n static char *\n-string_convert_int_cst (node)\n-     tree node;\n+string_convert_int_cst (tree node)\n {\n   static char buffer[80];\n \n@@ -12640,8 +12437,7 @@ string_convert_int_cst (node)\n /* Print an INTEGER_CST node in a static buffer, and return the\n    buffer.  This is used only for error handling.  */\n char *\n-print_int_node (node)\n-    tree node;\n+print_int_node (tree node)\n {\n   static char buffer [80];\n   if (TREE_CONSTANT_OVERFLOW (node))\n@@ -12671,9 +12467,7 @@ print_int_node (node)\n /* 15.25 Assignment operators. */\n \n static tree\n-patch_assignment (node, wfl_op1)\n-     tree node;\n-     tree wfl_op1;\n+patch_assignment (tree node, tree wfl_op1)\n {\n   tree rhs = TREE_OPERAND (node, 1);\n   tree lvalue = TREE_OPERAND (node, 0), llvalue;\n@@ -12844,8 +12638,7 @@ patch_assignment (node, wfl_op1)\n    modified rhs.  */\n \n static tree\n-try_reference_assignconv (lhs_type, rhs)\n-     tree lhs_type, rhs;\n+try_reference_assignconv (tree lhs_type, tree rhs)\n {\n   tree new_rhs = NULL_TREE;\n   tree rhs_type = TREE_TYPE (rhs);\n@@ -12871,8 +12664,7 @@ try_reference_assignconv (lhs_type, rhs)\n    builtin type. Return a converted RHS if the conversion is possible.  */\n \n static tree\n-try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n-     tree wfl_op1, lhs_type, rhs;\n+try_builtin_assignconv (tree wfl_op1, tree lhs_type, tree rhs)\n {\n   tree new_rhs = NULL_TREE;\n   tree rhs_type = TREE_TYPE (rhs);\n@@ -12922,8 +12714,7 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n    invocation convertion (5.3).  */\n \n static int\n-valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n-     tree lhs_type, rhs_type;\n+valid_builtin_assignconv_identity_widening_p (tree lhs_type, tree rhs_type)\n {\n   /* 5.1.1: This is the identity conversion part. */\n   if (lhs_type == rhs_type)\n@@ -12968,10 +12759,7 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n    assignment check. */\n \n static int\n-valid_ref_assignconv_cast_p (source, dest, cast)\n-     tree source;\n-     tree dest;\n-     int cast;\n+valid_ref_assignconv_cast_p (tree source, tree dest, int cast)\n {\n   /* SOURCE or DEST might be null if not from a declared entity. */\n   if (!source || !dest)\n@@ -13101,9 +12889,7 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n }\n \n static int\n-valid_cast_to_p (source, dest)\n-     tree source;\n-     tree dest;\n+valid_cast_to_p (tree source, tree dest)\n {\n   if (TREE_CODE (source) == POINTER_TYPE)\n     source = TREE_TYPE (source);\n@@ -13124,8 +12910,7 @@ valid_cast_to_p (source, dest)\n }\n \n static tree\n-do_unary_numeric_promotion (arg)\n-     tree arg;\n+do_unary_numeric_promotion (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n   if ((TREE_CODE (type) == INTEGER_TYPE && TYPE_PRECISION (type) < 32)\n@@ -13137,8 +12922,7 @@ do_unary_numeric_promotion (arg)\n /* Return a nonzero value if SOURCE can be converted into DEST using\n    the method invocation conversion rule (5.3).  */\n static int\n-valid_method_invocation_conversion_p (dest, source)\n-     tree dest, source;\n+valid_method_invocation_conversion_p (tree dest, tree source)\n {\n   return ((JPRIMITIVE_TYPE_P (source) && JPRIMITIVE_TYPE_P (dest)\n \t   && valid_builtin_assignconv_identity_widening_p (dest, source))\n@@ -13150,10 +12934,7 @@ valid_method_invocation_conversion_p (dest, source)\n /* Build an incomplete binop expression. */\n \n static tree\n-build_binop (op, op_location, op1, op2)\n-     enum tree_code op;\n-     int op_location;\n-     tree op1, op2;\n+build_binop (enum tree_code op, int op_location, tree op1, tree op2)\n {\n   tree binop = build (op, NULL_TREE, op1, op2);\n   TREE_SIDE_EFFECTS (binop) = 1;\n@@ -13170,8 +12951,7 @@ build_binop (op, op_location, op1, op2)\n    buffer. */\n \n static char *\n-operator_string (node)\n-     tree node;\n+operator_string (tree node)\n {\n #define BUILD_OPERATOR_STRING(S)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -13220,8 +13000,7 @@ operator_string (node)\n /* Return 1 if VAR_ACCESS1 is equivalent to VAR_ACCESS2.  */\n \n static int\n-java_decl_equiv (var_acc1, var_acc2)\n-     tree var_acc1, var_acc2;\n+java_decl_equiv (tree var_acc1, tree var_acc2)\n {\n   if (JDECL_P (var_acc1))\n     return (var_acc1 == var_acc2);\n@@ -13237,8 +13016,7 @@ java_decl_equiv (var_acc1, var_acc2)\n    used in conjunction with the `=' operator in a compound assignment.  */\n \n static int\n-binop_compound_p (code)\n-    enum tree_code code;\n+binop_compound_p (enum tree_code code)\n {\n   int i;\n   for (i = 0; i < BINOP_COMPOUND_CANDIDATES; i++)\n@@ -13251,8 +13029,7 @@ binop_compound_p (code)\n /* Reorganize after a fold to get SAVE_EXPR to generate what we want.  */\n \n static tree\n-java_refold (t)\n-     tree t;\n+java_refold (tree t)\n {\n   tree c, b, ns, decl;\n \n@@ -13299,10 +13076,7 @@ java_refold (t)\n    of remaining nodes and detects more errors in certain cases.  */\n \n static tree\n-patch_binop (node, wfl_op1, wfl_op2)\n-     tree node;\n-     tree wfl_op1;\n-     tree wfl_op2;\n+patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n {\n   tree op1 = TREE_OPERAND (node, 0);\n   tree op2 = TREE_OPERAND (node, 1);\n@@ -13722,10 +13496,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n    zero value, the value of CSTE comes after the valude of STRING */\n \n static tree\n-do_merge_string_cste (cste, string, string_len, after)\n-     tree cste;\n-     const char *string;\n-     int string_len, after;\n+do_merge_string_cste (tree cste, const char *string, int string_len, int after)\n {\n   const char *old = TREE_STRING_POINTER (cste);\n   int old_len = TREE_STRING_LENGTH (cste);\n@@ -13750,9 +13521,7 @@ do_merge_string_cste (cste, string, string_len, after)\n    new STRING_CST on success, NULL_TREE on failure */\n \n static tree\n-merge_string_cste (op1, op2, after)\n-     tree op1, op2;\n-     int after;\n+merge_string_cste (tree op1, tree op2, int after)\n {\n   /* Handle two string constants right away */\n   if (TREE_CODE (op2) == STRING_CST)\n@@ -13808,8 +13577,7 @@ merge_string_cste (op1, op2, after)\n    NULL_TREE for each invocation of this routine. FIXME */\n \n static tree\n-string_constant_concatenation (op1, op2)\n-     tree op1, op2;\n+string_constant_concatenation (tree op1, tree op2)\n {\n   if (TREE_CODE (op1) == STRING_CST || (TREE_CODE (op2) == STRING_CST))\n     {\n@@ -13843,8 +13611,7 @@ string_constant_concatenation (op1, op2)\n    called on it to turn it into a String object. */\n \n static tree\n-build_string_concatenation (op1, op2)\n-     tree op1, op2;\n+build_string_concatenation (tree op1, tree op2)\n {\n   tree result;\n   int side_effects = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n@@ -13913,8 +13680,7 @@ build_string_concatenation (op1, op2)\n    NULL. */\n \n static tree\n-patch_string (node)\n-    tree node;\n+patch_string (tree node)\n {\n   if (node == error_mark_node)\n     return error_mark_node;\n@@ -13940,8 +13706,7 @@ patch_string (node)\n /* Build the internal representation of a string constant.  */\n \n static tree\n-patch_string_cst (node)\n-     tree node;\n+patch_string_cst (tree node)\n {\n   int location;\n   if (! flag_emit_class_files)\n@@ -13958,9 +13723,7 @@ patch_string_cst (node)\n /* Build an incomplete unary operator expression. */\n \n static tree\n-build_unaryop (op_token, op_location, op1)\n-     int op_token, op_location;\n-     tree op1;\n+build_unaryop (int op_token, int op_location, tree op1)\n {\n   enum tree_code op;\n   tree unaryop;\n@@ -13986,10 +13749,7 @@ build_unaryop (op_token, op_location, op1)\n    later. IS_POST_P is 1 if the operator, 0 otherwise.  */\n \n static tree\n-build_incdec (op_token, op_location, op1, is_post_p)\n-     int op_token, op_location;\n-     tree op1;\n-     int is_post_p;\n+build_incdec (int op_token, int op_location, tree op1, int is_post_p)\n {\n   static const enum tree_code lookup [2][2] =\n     {\n@@ -14011,9 +13771,7 @@ build_incdec (op_token, op_location, op1, is_post_p)\n    though its type is already set.  */\n \n static tree\n-build_cast (location, type, exp)\n-     int location;\n-     tree type, exp;\n+build_cast (int location, tree type, tree exp)\n {\n   tree node = build1 (CONVERT_EXPR, type, exp);\n   EXPR_WFL_LINECOL (node) = location;\n@@ -14022,9 +13780,7 @@ build_cast (location, type, exp)\n \n /* Build an incomplete class reference operator.  */\n static tree\n-build_incomplete_class_ref (location, class_name)\n-    int location;\n-    tree class_name;\n+build_incomplete_class_ref (int location, tree class_name)\n {\n   tree node = build1 (CLASS_LITERAL, NULL_TREE, class_name);\n   EXPR_WFL_LINECOL (node) = location;\n@@ -14033,8 +13789,7 @@ build_incomplete_class_ref (location, class_name)\n \n /* Complete an incomplete class reference operator.  */\n static tree\n-patch_incomplete_class_ref (node)\n-    tree node;\n+patch_incomplete_class_ref (tree node)\n {\n   tree type = TREE_OPERAND (node, 0);\n   tree ref_type;\n@@ -14071,9 +13826,7 @@ patch_incomplete_class_ref (node)\n    but preserve the type of NODE if the type is fixed.  */\n \n static tree\n-patch_unaryop (node, wfl_op)\n-     tree node;\n-     tree wfl_op;\n+patch_unaryop (tree node, tree wfl_op)\n {\n   tree op = TREE_OPERAND (node, 0);\n   tree op_type = TREE_TYPE (op);\n@@ -14261,8 +14014,7 @@ patch_unaryop (node, wfl_op)\n    message. Return the resolved type or NULL_TREE.  */\n \n static tree\n-resolve_type_during_patch (type)\n-     tree type;\n+resolve_type_during_patch (tree type)\n {\n   if (unresolved_type_p (type, NULL))\n     {\n@@ -14282,9 +14034,7 @@ resolve_type_during_patch (type)\n    found. Otherwise NODE or something meant to replace it is returned.  */\n \n static tree\n-patch_cast (node, wfl_op)\n-     tree node;\n-     tree wfl_op;\n+patch_cast (tree node, tree wfl_op)\n {\n   tree op = TREE_OPERAND (node, 0);\n   tree cast_type = TREE_TYPE (node);\n@@ -14367,8 +14117,7 @@ patch_cast (node, wfl_op)\n /* Build a null constant and give it the type TYPE.  */\n \n static tree\n-build_null_of_type (type)\n-     tree type;\n+build_null_of_type (tree type)\n {\n   tree node = build_int_2 (0, 0);\n   TREE_TYPE (node) = promote_type (type);\n@@ -14378,9 +14127,7 @@ build_null_of_type (type)\n /* Build an ARRAY_REF incomplete tree node. Note that operand 1 isn't\n    a list of indices. */\n static tree\n-build_array_ref (location, array, index)\n-     int location;\n-     tree array, index;\n+build_array_ref (int location, tree array, tree index)\n {\n   tree node = build (ARRAY_REF, NULL_TREE, array, index);\n   EXPR_WFL_LINECOL (node) = location;\n@@ -14390,8 +14137,7 @@ build_array_ref (location, array, index)\n /* 15.12 Array Access Expression */\n \n static tree\n-patch_array_ref (node)\n-     tree node;\n+patch_array_ref (tree node)\n {\n   tree array = TREE_OPERAND (node, 0);\n   tree array_type  = TREE_TYPE (array);\n@@ -14451,10 +14197,7 @@ patch_array_ref (node)\n /* 15.9 Array Creation Expressions */\n \n static tree\n-build_newarray_node (type, dims, extra_dims)\n-     tree type;\n-     tree dims;\n-     int extra_dims;\n+build_newarray_node (tree type, tree dims, int extra_dims)\n {\n   tree node =\n     build (NEW_ARRAY_EXPR, NULL_TREE, type, nreverse (dims),\n@@ -14463,8 +14206,7 @@ build_newarray_node (type, dims, extra_dims)\n }\n \n static tree\n-patch_newarray (node)\n-     tree node;\n+patch_newarray (tree node)\n {\n   tree type = TREE_OPERAND (node, 0);\n   tree dims = TREE_OPERAND (node, 1);\n@@ -14567,8 +14309,7 @@ patch_newarray (node)\n    pin-point errors.  */\n \n static tree\n-maybe_build_array_element_wfl (node)\n-     tree node;\n+maybe_build_array_element_wfl (tree node)\n {\n   if (TREE_CODE (node) != EXPR_WITH_FILE_LOCATION)\n     return build_expr_wfl (NULL_TREE, ctxp->filename,\n@@ -14582,9 +14323,7 @@ maybe_build_array_element_wfl (node)\n    and expansion.  */\n \n static tree\n-build_new_array_init (location, values)\n-     int location;\n-     tree values;\n+build_new_array_init (int location, tree values)\n {\n   tree constructor = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, values);\n   tree to_return = build1 (NEW_ARRAY_INIT, NULL_TREE, constructor);\n@@ -14597,8 +14336,7 @@ build_new_array_init (location, values)\n    appropriately.  */\n \n static tree\n-patch_new_array_init (type, node)\n-     tree type, node;\n+patch_new_array_init (tree type, tree node)\n {\n   int error_seen = 0;\n   tree current, element_type;\n@@ -14661,8 +14399,7 @@ patch_new_array_init (type, node)\n    otherwise.  */\n \n static int\n-array_constructor_check_entry (type, entry)\n-     tree type, entry;\n+array_constructor_check_entry (tree type, tree entry)\n {\n   char *array_type_string = NULL;\t/* For error reports */\n   tree value, type_value, new_value, wfl_value, patched;\n@@ -14711,8 +14448,7 @@ array_constructor_check_entry (type, entry)\n }\n \n static tree\n-build_this (location)\n-     int location;\n+build_this (int location)\n {\n   tree node = build_wfl_node (this_identifier_node);\n   TREE_SET_CODE (node, THIS_EXPR);\n@@ -14725,9 +14461,7 @@ build_this (location)\n    to be returned. */\n \n static tree\n-build_return (location, op)\n-     int location;\n-     tree op;\n+build_return (int location, tree op)\n {\n   tree node = build1 (RETURN_EXPR, NULL_TREE, op);\n   EXPR_WFL_LINECOL (node) = location;\n@@ -14736,8 +14470,7 @@ build_return (location, op)\n }\n \n static tree\n-patch_return (node)\n-     tree node;\n+patch_return (tree node)\n {\n   tree return_exp = TREE_OPERAND (node, 0);\n   tree meth = current_function_decl;\n@@ -14821,9 +14554,8 @@ patch_return (node)\n /* 14.8 The if Statement */\n \n static tree\n-build_if_else_statement (location, expression, if_body, else_body)\n-     int location;\n-     tree expression, if_body, else_body;\n+build_if_else_statement (int location, tree expression, tree if_body,\n+\t\t\t tree else_body)\n {\n   tree node;\n   if (!else_body)\n@@ -14835,8 +14567,7 @@ build_if_else_statement (location, expression, if_body, else_body)\n }\n \n static tree\n-patch_if_else_statement (node)\n-     tree node;\n+patch_if_else_statement (tree node)\n {\n   tree expression = TREE_OPERAND (node, 0);\n   int can_complete_normally\n@@ -14883,9 +14614,7 @@ patch_if_else_statement (node)\n    label, yet.  LABEL can be NULL_TREE for artificially-generated blocks. */\n \n static tree\n-build_labeled_block (location, label)\n-     int location;\n-     tree label;\n+build_labeled_block (int location, tree label)\n {\n   tree label_name ;\n   tree label_decl, node;\n@@ -14921,9 +14650,8 @@ build_labeled_block (location, label)\n /* A labeled statement LBE is attached a statement.  */\n \n static tree\n-finish_labeled_statement (lbe, statement)\n-     tree lbe;\t\t\t/* Labeled block expr */\n-     tree statement;\n+finish_labeled_statement (tree lbe, /* Labeled block expr */\n+\t\t\t  tree statement)\n {\n   /* In anyways, tie the loop to its statement */\n   LABELED_BLOCK_BODY (lbe) = statement;\n@@ -14938,8 +14666,7 @@ finish_labeled_statement (lbe, statement)\n    list. */\n \n static tree\n-build_new_loop (loop_body)\n-     tree loop_body;\n+build_new_loop (tree loop_body)\n {\n   tree loop =  build (LOOP_EXPR, NULL_TREE, loop_body);\n   TREE_SIDE_EFFECTS (loop) = 1;\n@@ -14968,10 +14695,7 @@ build_new_loop (loop_body)\n        <structure described above> */\n \n static tree\n-build_loop_body (location, condition, reversed)\n-     int location;\n-     tree condition;\n-     int reversed;\n+build_loop_body (int location, tree condition, int reversed)\n {\n   tree first, second, body;\n \n@@ -14993,10 +14717,7 @@ build_loop_body (location, condition, reversed)\n    loop list.  */\n \n static tree\n-finish_loop_body (location, condition, body, reversed)\n-     int location;\n-     tree condition, body;\n-     int reversed;\n+finish_loop_body (int location, tree condition, tree body, int reversed)\n {\n   tree to_return = ctxp->current_loop;\n   tree loop_body = LOOP_EXPR_BODY (to_return);\n@@ -15019,9 +14740,7 @@ finish_loop_body (location, condition, body, reversed)\n    loops feature the condition part */\n \n static tree\n-finish_for_loop (location, condition, update, body)\n-    int location;\n-    tree condition, update, body;\n+finish_for_loop (int location, tree condition, tree update, tree body)\n {\n   /* Put the condition and the loop body in place */\n   tree loop = finish_loop_body (location, condition, body, 0);\n@@ -15055,8 +14774,7 @@ finish_for_loop (location, condition, update, body)\n    LABELED_BLOCK_EXPR's block.  */\n \n static tree\n-search_loop (statement)\n-    tree statement;\n+search_loop (tree statement)\n {\n   if (TREE_CODE (statement) == LOOP_EXPR)\n     return statement;\n@@ -15078,8 +14796,7 @@ search_loop (statement)\n    returned otherwise.  */\n \n static int\n-labeled_block_contains_loop_p (block, loop)\n-    tree block, loop;\n+labeled_block_contains_loop_p (tree block, tree loop)\n {\n   if (!block)\n     return 0;\n@@ -15097,8 +14814,7 @@ labeled_block_contains_loop_p (block, loop)\n    insert LOOP as its body.  */\n \n static tree\n-patch_loop_statement (loop)\n-     tree loop;\n+patch_loop_statement (tree loop)\n {\n   tree loop_label;\n \n@@ -15120,9 +14836,7 @@ patch_loop_statement (loop)\n    unlabeled break/continue statement.  */\n \n static tree\n-build_bc_statement (location, is_break, name)\n-     int location, is_break;\n-     tree name;\n+build_bc_statement (int location, int is_break, tree name)\n {\n   tree break_continue, label_block_expr = NULL_TREE;\n \n@@ -15151,8 +14865,7 @@ build_bc_statement (location, is_break, name)\n /* Verification of a break/continue statement. */\n \n static tree\n-patch_bc_statement (node)\n-     tree node;\n+patch_bc_statement (tree node)\n {\n   tree bc_label = EXIT_BLOCK_LABELED_BLOCK (node), target_stmt;\n   tree labeled_block = ctxp->current_labeled_block;\n@@ -15228,8 +14941,7 @@ patch_bc_statement (node)\n    boolean.  */\n \n static tree\n-patch_exit_expr (node)\n-     tree node;\n+patch_exit_expr (tree node)\n {\n   tree expression = TREE_OPERAND (node, 0);\n   TREE_TYPE (node) = error_mark_node;\n@@ -15264,8 +14976,7 @@ patch_exit_expr (node)\n /* 14.9 Switch statement */\n \n static tree\n-patch_switch_statement (node)\n-     tree node;\n+patch_switch_statement (tree node)\n {\n   tree se = TREE_OPERAND (node, 0), se_type;\n   tree save, iter;\n@@ -15342,9 +15053,7 @@ patch_switch_statement (node)\n /* Build an assertion expression for `assert CONDITION : VALUE'; VALUE\n    might be NULL_TREE.  */\n static tree\n-build_assertion (location, condition, value)\n-     int location;\n-     tree condition, value;\n+build_assertion (int location, tree condition, tree value)\n {\n   tree node;\n   tree klass = GET_CPC ();\n@@ -15421,9 +15130,8 @@ build_assertion (location, condition, value)\n    catches TYPE and executes CATCH_STMTS.  */\n \n static tree\n-encapsulate_with_try_catch (location, type, try_stmts, catch_stmts)\n-     int location;\n-     tree type, try_stmts, catch_stmts;\n+encapsulate_with_try_catch (int location, tree type, tree try_stmts,\n+\t\t\t    tree catch_stmts)\n {\n   tree try_block, catch_clause_param, catch_block, catch;\n \n@@ -15451,28 +15159,23 @@ encapsulate_with_try_catch (location, type, try_stmts, catch_stmts)\n }\n \n static tree\n-build_try_statement (location, try_block, catches)\n-     int location;\n-     tree try_block, catches;\n+build_try_statement (int location, tree try_block, tree catches)\n {\n   tree node = build (TRY_EXPR, NULL_TREE, try_block, catches);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n \n static tree\n-build_try_finally_statement (location, try_block, finally)\n-     int location;\n-     tree try_block, finally;\n+build_try_finally_statement (int location, tree try_block, tree finally)\n {\n   tree node = build (TRY_FINALLY_EXPR, NULL_TREE, try_block, finally);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n \n static tree\n-patch_try_statement (node)\n-     tree node;\n+patch_try_statement (tree node)\n {\n   int error_found = 0;\n   tree try = TREE_OPERAND (node, 0);\n@@ -15583,8 +15286,7 @@ patch_try_statement (node)\n /* 14.17 The synchronized Statement */\n \n static tree\n-patch_synchronized_statement (node, wfl_op1)\n-    tree node, wfl_op1;\n+patch_synchronized_statement (tree node, tree wfl_op1)\n {\n   tree expr = java_complete_tree (TREE_OPERAND (node, 0));\n   tree block = TREE_OPERAND (node, 1);\n@@ -15653,8 +15355,7 @@ patch_synchronized_statement (node, wfl_op1)\n /* 14.16 The throw Statement */\n \n static tree\n-patch_throw_statement (node, wfl_op1)\n-    tree node, wfl_op1;\n+patch_throw_statement (tree node, tree wfl_op1)\n {\n   tree expr = TREE_OPERAND (node, 0);\n   tree type = TREE_TYPE (expr);\n@@ -15756,9 +15457,7 @@ patch_throw_statement (node, wfl_op1)\n    effectively caught from where DECL is invoked.  */\n \n static void\n-check_thrown_exceptions (location, decl)\n-     int location;\n-     tree decl;\n+check_thrown_exceptions (int location, tree decl)\n {\n   tree throws;\n   /* For all the unchecked exceptions thrown by DECL */\n@@ -15793,8 +15492,7 @@ check_thrown_exceptions (location, decl)\n    current method.  */\n \n static int\n-check_thrown_exceptions_do (exception)\n-     tree exception;\n+check_thrown_exceptions_do (tree exception)\n {\n   tree list = currently_caught_type_list;\n   resolve_and_layout (exception, NULL_TREE);\n@@ -15814,8 +15512,7 @@ check_thrown_exceptions_do (exception)\n }\n \n static void\n-purge_unchecked_exceptions (mdecl)\n-     tree mdecl;\n+purge_unchecked_exceptions (tree mdecl)\n {\n   tree throws = DECL_FUNCTION_THROWS (mdecl);\n   tree new = NULL_TREE;\n@@ -15840,8 +15537,7 @@ purge_unchecked_exceptions (mdecl)\n    otherwise.  */\n \n static bool\n-ctors_unchecked_throws_clause_p (class_type)\n-     tree class_type;\n+ctors_unchecked_throws_clause_p (tree class_type)\n {\n   tree current;\n \n@@ -15869,8 +15565,7 @@ ctors_unchecked_throws_clause_p (class_type)\n /* 15.24 Conditional Operator ?: */\n \n static tree\n-patch_conditional_expr (node, wfl_cond, wfl_op1)\n-     tree node, wfl_cond, wfl_op1;\n+patch_conditional_expr (tree node, tree wfl_cond, tree wfl_op1)\n {\n   tree cond = TREE_OPERAND (node, 0);\n   tree op1 = TREE_OPERAND (node, 1);\n@@ -15983,8 +15678,7 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n /* Wrap EXPR with code to initialize DECL's class, if appropriate. */\n \n static tree\n-maybe_build_class_init_for_field (decl, expr)\n-    tree decl, expr;\n+maybe_build_class_init_for_field (tree decl, tree expr)\n {\n   tree clas = DECL_CONTEXT (decl);\n   if (flag_emit_class_files || flag_emit_xref)\n@@ -16008,9 +15702,7 @@ maybe_build_class_init_for_field (decl, expr)\n    CONTEXT is a static final VAR_DECL whose initializer we are folding. */\n \n static tree\n-fold_constant_for_init (node, context)\n-     tree node;\n-     tree context;\n+fold_constant_for_init (tree node, tree context)\n {\n   tree op0, op1, val;\n   enum tree_code code = TREE_CODE (node);\n@@ -16157,22 +15849,18 @@ fold_constant_for_init (node, context)\n    'M' for MethodName, 'E' for ExpressionName, and 'A' for AmbiguousName. */\n \n tree\n-resolve_simple_name (name, context)\n-     tree name;\n-     int context;\n+resolve_simple_name (tree name, int context)\n {\n }\n \n tree\n-resolve_qualified_name (name, context)\n-     tree name;\n-     int context;\n+resolve_qualified_name (tree name, int context)\n {\n }\n #endif\n \n void\n-init_src_parse ()\n+init_src_parse (void)\n {\n   /* Sanity check; we've been bit by this before.  */\n   if (ARRAY_SIZE (ctxp->modifier_ctx) != MODIFIER_TK - PUBLIC_TK)\n@@ -16187,9 +15875,7 @@ init_src_parse ()\n /* Attach to PTR (a block) the declaration found in ENTRY. */\n \n static int\n-attach_init_test_initialization_flags (entry, ptr)\n-     void **entry;\n-     void *ptr;\n+attach_init_test_initialization_flags (void **entry, void *ptr)\n {\n   tree block = (tree)ptr;\n   struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n@@ -16209,9 +15895,7 @@ attach_init_test_initialization_flags (entry, ptr)\n    a new one is created.  */\n \n static int\n-emit_test_initialization (entry_p, info)\n-     void **entry_p;\n-     void *info;\n+emit_test_initialization (void **entry_p, void *info)\n {\n   tree l = (tree) info;\n   tree decl, init;"}, {"sha": "8990a9934c2a26e534bb85ad0a965447659a1f0e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 30, "deletions": 71, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -50,9 +50,7 @@ tree * type_map;\n /* Set the type of the local variable with index SLOT to TYPE. */\n \n void\n-set_local_type (slot, type)\n-     int slot;\n-     tree type;\n+set_local_type (int slot, tree type)\n {\n   int max_locals = DECL_MAX_LOCALS(current_function_decl);\n   int nslots = TYPE_IS_WIDE (type) ? 2 : 1;\n@@ -80,8 +78,7 @@ set_local_type (slot, type)\n \t     : (int)expr))) */\n \n static tree\n-convert_ieee_real_to_integer (type, expr)\n-     tree type, expr;\n+convert_ieee_real_to_integer (tree type, tree expr)\n {\n   tree result;\n   expr = save_expr (expr);\n@@ -113,8 +110,7 @@ convert_ieee_real_to_integer (type, expr)\n    not permitted by the language being compiled.  */\n \n tree\n-convert (type, expr)\n-     tree type, expr;\n+convert (tree type, tree expr)\n {\n   register enum tree_code code = TREE_CODE (type);\n \n@@ -155,15 +151,13 @@ convert (type, expr)\n \n \n tree\n-convert_to_char (type, expr)\n-    tree type, expr;\n+convert_to_char (tree type, tree expr)\n {\n   return build1 (NOP_EXPR, type, expr);\n }\n \n tree\n-convert_to_boolean (type, expr)\n-     tree type, expr;\n+convert_to_boolean (tree type, tree expr)\n {\n   return build1 (NOP_EXPR, type, expr);\n }\n@@ -173,9 +167,7 @@ convert_to_boolean (type, expr)\n    then UNSIGNEDP selects between signed and unsigned types.  */\n \n tree\n-java_type_for_mode (mode, unsignedp)\n-     enum machine_mode mode;\n-     int unsignedp;\n+java_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n   if (mode == TYPE_MODE (int_type_node))\n     return unsignedp ? unsigned_int_type_node : int_type_node;\n@@ -197,9 +189,7 @@ java_type_for_mode (mode, unsignedp)\n    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n \n tree\n-java_type_for_size (bits, unsignedp)\n-     unsigned bits;\n-     int unsignedp;\n+java_type_for_size (unsigned bits, int unsignedp)\n {\n   if (bits <= TYPE_PRECISION (byte_type_node))\n     return unsignedp ? unsigned_byte_type_node : byte_type_node;\n@@ -216,9 +206,7 @@ java_type_for_size (bits, unsignedp)\n    signed according to UNSIGNEDP.  */\n \n tree\n-java_signed_or_unsigned_type (unsignedp, type)\n-     int unsignedp;\n-     tree type;\n+java_signed_or_unsigned_type (int unsignedp, tree type)\n {\n   if (! INTEGRAL_TYPE_P (type))\n     return type;\n@@ -236,17 +224,15 @@ java_signed_or_unsigned_type (unsignedp, type)\n /* Return a signed type the same as TYPE in other respects.  */\n \n tree\n-java_signed_type (type)\n-     tree type;\n+java_signed_type (tree type)\n {\n   return java_signed_or_unsigned_type (0, type);\n }\n \n /* Return an unsigned type the same as TYPE in other respects.  */\n \n tree\n-java_unsigned_type (type)\n-     tree type;\n+java_unsigned_type (tree type)\n {\n   return java_signed_or_unsigned_type (1, type);\n }\n@@ -256,8 +242,7 @@ java_unsigned_type (type)\n    Value is true if successful.  */\n \n bool\n-java_mark_addressable (exp)\n-     tree exp;\n+java_mark_addressable (tree exp)\n {\n   register tree x = exp;\n   while (1)\n@@ -320,8 +305,7 @@ java_mark_addressable (exp)\n /* Thorough checking of the arrayness of TYPE.  */\n \n int\n-is_array_type_p (type)\n-     tree type;\n+is_array_type_p (tree type)\n {\n   return TREE_CODE (type) == POINTER_TYPE\n     && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n@@ -332,8 +316,7 @@ is_array_type_p (type)\n    Return -1 if the length is unknown or non-constant. */\n \n HOST_WIDE_INT\n-java_array_type_length (array_type)\n-     tree array_type;\n+java_array_type_length (tree array_type)\n {\n   tree arfld;\n   if (TREE_CODE (array_type) == POINTER_TYPE)\n@@ -358,9 +341,7 @@ java_array_type_length (array_type)\n    `length' from static arrays. We could restore it, FIXME.  */\n \n tree\n-build_prim_array_type (element_type, length)\n-     tree element_type;\n-     HOST_WIDE_INT length;\n+build_prim_array_type (tree element_type, HOST_WIDE_INT length)\n {\n   tree index = NULL;\n \n@@ -378,9 +359,7 @@ build_prim_array_type (element_type, length)\n    The LENGTH is -1 if the length is unknown. */\n \n tree\n-build_java_array_type (element_type, length)\n-     tree element_type;\n-     HOST_WIDE_INT length;\n+build_java_array_type (tree element_type, HOST_WIDE_INT length)\n {\n   tree sig, t, fld, atype, arfld;\n   char buf[12];\n@@ -441,8 +420,7 @@ build_java_array_type (element_type, length)\n /* Promote TYPE to the type actually used for fields and parameters. */\n \n tree\n-promote_type (type)\n-     tree type;\n+promote_type (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -476,8 +454,7 @@ promote_type (type)\n    Return the seen TREE_TYPE, updating *PTR. */\n \n static tree\n-parse_signature_type (ptr, limit)\n-     const unsigned char **ptr, *limit;\n+parse_signature_type (const unsigned char **ptr, const unsigned char *limit)\n {\n   tree type;\n \n@@ -526,9 +503,7 @@ parse_signature_type (ptr, limit)\n    Return a gcc type node. */\n \n tree\n-parse_signature_string (sig_string, sig_length)\n-     const unsigned char *sig_string;\n-     int sig_length;\n+parse_signature_string (const unsigned char *sig_string, int sig_length)\n {\n   tree result_type;\n   const unsigned char *str = sig_string;\n@@ -581,17 +556,15 @@ get_type_from_signature (tree signature)\n /* Ignore signature and always return null.  Used by has_method. */\n \n static tree\n-build_null_signature (type)\n-     tree type ATTRIBUTE_UNUSED;\n+build_null_signature (tree type ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }\n \n /* Return the signature string for the arguments of method type TYPE. */\n \n tree\n-build_java_argument_signature (type)\n-     tree type;\n+build_java_argument_signature (tree type)\n {\n   extern struct obstack temporary_obstack;\n   tree sig = TYPE_ARGUMENT_SIGNATURE (type);\n@@ -618,8 +591,7 @@ build_java_argument_signature (type)\n /* Return the signature of the given TYPE. */\n \n tree\n-build_java_signature (type)\n-     tree type;\n+build_java_signature (tree type)\n {\n   tree sig, t;\n   while (TREE_CODE (type) == POINTER_TYPE)\n@@ -699,9 +671,7 @@ build_java_signature (type)\n /* Save signature string SIG (an IDENTIFIER_NODE) in TYPE for future use. */\n \n void\n-set_java_signature (type, sig)\n-     tree type;\n-     tree sig;\n+set_java_signature (tree type, tree sig)\n {\n   tree old_sig;\n   while (TREE_CODE (type) == POINTER_TYPE)\n@@ -725,8 +695,7 @@ set_java_signature (type, sig)\n    signature.  */\n \n tree\n-lookup_argument_method (searched_class, method_name, method_signature)\n-     tree searched_class, method_name, method_signature;\n+lookup_argument_method (tree searched_class, tree method_name, tree method_signature)\n {\n   return lookup_do (searched_class, NULL_TREE, method_name, method_signature, \n \t\t    build_java_argument_signature);\n@@ -739,8 +708,7 @@ lookup_argument_method (searched_class, method_name, method_signature)\n    which takes into account return type.) */\n \n tree\n-lookup_argument_method2 (searched_class, method_name, method_signature)\n-     tree searched_class, method_name, method_signature;\n+lookup_argument_method2 (tree searched_class, tree method_name, tree method_signature)\n {\n   return lookup_do (CLASSTYPE_SUPER (searched_class), searched_class,\n \t\t    method_name, method_signature, \n@@ -754,8 +722,7 @@ lookup_argument_method2 (searched_class, method_name, method_signature)\n    SEARCHED_CLASS is an interface, search it too. */\n \n tree\n-lookup_java_method (searched_class, method_name, method_signature)\n-     tree searched_class, method_name, method_signature;\n+lookup_java_method (tree searched_class, tree method_name, tree method_signature)\n {\n   tree searched_interface;\n   \n@@ -772,9 +739,7 @@ lookup_java_method (searched_class, method_name, method_signature)\n /* Return true iff CLASS (or its ancestors) has a method METHOD_NAME. */\n \n int\n-has_method (class, method_name)\n-     tree class;\n-     tree method_name;\n+has_method (tree class, tree method_name)\n {\n   return lookup_do (class, class,  method_name,\n \t\t    NULL_TREE, build_null_signature) != NULL_TREE;\n@@ -788,9 +753,8 @@ has_method (class, method_name)\n    signature.  */\n \n static tree\n-lookup_do (searched_class, searched_interface, method_name, signature, signature_builder)\n-     tree searched_class, searched_interface, method_name, signature;\n-     tree (*signature_builder) (tree);\n+lookup_do (tree searched_class, tree searched_interface, tree method_name,\n+\t   tree signature, tree (*signature_builder) (tree))\n {\n   tree method;\n   \n@@ -851,8 +815,7 @@ lookup_do (searched_class, searched_interface, method_name, signature, signature\n    Return a FUNCTION_DECL on success, or NULL_TREE if none found. */\n \n tree\n-lookup_java_constructor (clas, method_signature)\n-     tree clas, method_signature;\n+lookup_java_constructor (tree clas, tree method_signature)\n {\n   tree method = TYPE_METHODS (clas);\n   for ( ; method != NULL_TREE;  method = TREE_CHAIN (method))\n@@ -869,11 +832,7 @@ lookup_java_constructor (clas, method_signature)\n    Promotion. It assumes that both T1 and T2 are eligible to BNP. */\n \n tree\n-binary_numeric_promotion (t1, t2, exp1, exp2)\n-     tree t1;\n-     tree t2;\n-     tree *exp1;\n-     tree *exp2;\n+binary_numeric_promotion (tree t1, tree t2, tree *exp1, tree *exp2)\n {\n   if (t1 == double_type_node || t2 == double_type_node)\n     {"}, {"sha": "d67f30c40963ef6a97442eb12cf332f8010e54e0", "filename": "gcc/java/verify.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -56,8 +56,7 @@ tree pending_blocks;\n /* Append TARGET_LABEL to the pending_block stack unless already in it. */\n \n static void\n-push_pending_label (target_label) \n-     tree target_label;\n+push_pending_label (tree target_label) \n {\n   if (! LABEL_CHANGED (target_label))\n     {\n@@ -72,8 +71,7 @@ push_pending_label (target_label)\n    Return NULL on success, or an error message on failure. */\n \n static const char *\n-check_pending_block (target_label)\n-     tree target_label;\n+check_pending_block (tree target_label)\n {\n   int changed = merge_type_state (target_label);\n \n@@ -129,8 +127,7 @@ subroutine_nesting (tree label)\n    Return TYPE_UNKNOWN if the types cannot be merged. */   \n \n static tree\n-merge_types (type1, type2)\n-     tree type1, type2;\n+merge_types (tree type1, tree type2)\n {\n   if (type1 == type2)\n     return type1;\n@@ -245,8 +242,7 @@ merge_types (type1, type2)\n    0 if there was no change, and 1 if there was a change. */\n \n int\n-merge_type_state (label)\n-     tree label;\n+merge_type_state (tree label)\n {\n   int nlocals = DECL_MAX_LOCALS (current_function_decl);\n   int cur_length = stack_pointer + nlocals;\n@@ -308,8 +304,7 @@ merge_type_state (label)\n /* Handle dup-like operations. */\n \n static void\n-type_stack_dup (size, offset)\n-     int size, offset;\n+type_stack_dup (int size, int offset)\n {\n   tree type[4];\n   int index;\n@@ -350,9 +345,7 @@ struct pc_index\n \n /* A helper that is used when sorting exception ranges.  */\n static int\n-start_pc_cmp (xp, yp)\n-     const void *xp;\n-     const void *yp;\n+start_pc_cmp (const void *xp, const void *yp)\n {\n   const struct pc_index *x = (const struct pc_index *) xp;\n   const struct pc_index *y = (const struct pc_index *) yp;\n@@ -375,8 +368,7 @@ start_pc_cmp (xp, yp)\n    Return NULL on success and a freshly malloc'd error message on failure. */\n \n static char *\n-pop_argument_types (arg_types)\n-     tree arg_types;\n+pop_argument_types (tree arg_types)\n {\n   if (arg_types == end_params_node)\n     return NULL;\n@@ -419,10 +411,7 @@ pop_argument_types (arg_types)\n /* Verify the bytecodes of the current method.\n    Return 1 on success, 0 on failure. */\n int\n-verify_jvm_instructions (jcf, byte_ops, length)\n-     JCF* jcf;\n-     const unsigned char *byte_ops;\n-     long length;\n+verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n {\n   tree label;\n   int wide = 0;"}, {"sha": "51684509989439a2f05770fddaf642bb76537bb8", "filename": "gcc/java/xref.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fxref.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -41,8 +41,7 @@ static xref_flag_table xref_table [] = {\n /* Decode an xref flag value. Return 0 if the flag wasn't found. */\n \n int\n-xref_flag_value (flag)\n-     const char *flag;\n+xref_flag_value (const char *flag)\n {\n   int i;\n   for (i = 0; xref_table [i].key; i++)\n@@ -52,32 +51,27 @@ xref_flag_value (flag)\n }\n \n void\n-xref_set_data (flag, data)\n-     int flag;\n-     void *data;\n+xref_set_data (int flag, void *data)\n {\n   xref_table [flag-1].data = data;\n }\n \n void *\n-xref_get_data (flag)\n-     int flag;\n+xref_get_data (int flag)\n {\n   return xref_table [flag-1].data;\n }\n \n void\n-xref_set_current_fp (fp)\n-     FILE *fp;\n+xref_set_current_fp (FILE *fp)\n {\n   xref_table [flag_emit_xref-1].fp = fp;\n }\n \n /* Branch to the right xref \"back-end\".  */\n \n void\n-expand_xref (node)\n-     tree node;\n+expand_xref (tree node)\n {\n   /* Maintain these two cached. */\n   static FILE *fp = NULL;"}, {"sha": "8800bd4ecfca927e8c1b3d967c0384357aa9e28b", "filename": "gcc/java/zextract.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2f0c5497342d01717c93db97aeb5318c3ec42c/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=0a2f0c5497342d01717c93db97aeb5318c3ec42c", "patch": "@@ -222,8 +222,7 @@ static long find_zip_file_start (int fd, long offset);\n /* Function makeword() */\n /***********************/\n \n-static ush makeword(b)\n-    const uch *b;\n+static ush makeword(const uch *b)\n {\n     /*\n      * Convert Intel style 'short' integer to non-Intel non-16-bit\n@@ -237,8 +236,7 @@ static ush makeword(b)\n /* Function makelong() */\n /***********************/\n \n-static ulg makelong(sig)\n-    const uch *sig;\n+static ulg makelong(const uch *sig)\n {\n     /*\n      * Convert intel style 'long' variable to non-Intel non-16-bit\n@@ -254,9 +252,7 @@ static ulg makelong(sig)\n    start of the actual data.  Return -1 on error.  OFFSET is the\n    offset from the beginning of the zip file of the file's header.  */\n static long\n-find_zip_file_start (fd, offset)\n-     int fd;\n-     long offset;\n+find_zip_file_start (int fd, long offset)\n {\n   int filename_length, extra_field_length;\n   unsigned char buffer[LREC_SIZE + 4];\n@@ -277,8 +273,7 @@ find_zip_file_start (fd, offset)\n }\n \n int\n-read_zip_archive (zipf)\n-     register ZipFile *zipf;\n+read_zip_archive (ZipFile *zipf)\n {\n   int i;\n   int dir_last_pad;\n@@ -356,7 +351,7 @@ read_zip_archive (zipf)\n }\n \n #ifdef TEST\n-main ()\n+main (void)\n {\n   ZipFile zipf[1];\n   ZipDirectory *zipd;"}]}