{"sha": "e4850f36e545325e3309870d13dfe4582e7cb9d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4NTBmMzZlNTQ1MzI1ZTMzMDk4NzBkMTNkZmU0NTgyZTdjYjlkNA==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2002-09-18T18:51:14Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2002-09-18T18:51:14Z"}, "message": "stor-layout.c (place_field): Handle alignment of whole structures when MSVC compatible bitfields are involved.\n\n        * stor-layout.c (place_field): Handle alignment of whole\n        structures when MSVC compatible bitfields are involved.\n        Change method of computing location of MS bitfields to\n        be compatible with #pragma pack(n).\n\n        * tree.h (record_layout_info): Add new field\n        remaining_in_alignment.\n\n        * doc/tm.texi: (TARGET_MS_BITFIELD_LAYOUT_P): Update.\n        (pragma pack): Add paragraph on MSVC bitfield packing.\n\nCo-Authored-By: Donn Terry <donnte@microsoft.com>\n\nFrom-SVN: r57281", "tree": {"sha": "db1286b6218421cfbaf55c157f77ee8912f2bf17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db1286b6218421cfbaf55c157f77ee8912f2bf17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4850f36e545325e3309870d13dfe4582e7cb9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4850f36e545325e3309870d13dfe4582e7cb9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4850f36e545325e3309870d13dfe4582e7cb9d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4850f36e545325e3309870d13dfe4582e7cb9d4/comments", "author": null, "committer": null, "parents": [{"sha": "62f1a74c0f77dbe42561774579317fe56fda7401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62f1a74c0f77dbe42561774579317fe56fda7401", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62f1a74c0f77dbe42561774579317fe56fda7401"}], "stats": {"total": 247, "additions": 203, "deletions": 44}, "files": [{"sha": "365c689a447c05665517079bcf2c995d4c931e03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4850f36e545325e3309870d13dfe4582e7cb9d4", "patch": "@@ -1,3 +1,17 @@\n+2002-09-18  Douglas Rupp  <rupp@gnat.com>\n+\t    Donn Terry  <donnte@microsoft.com>\n+\n+\t* stor-layout.c (place_field): Handle alignment of whole\n+\tstructures when MSVC compatible bitfields are involved.\n+\tChange method of computing location of MS bitfields to\n+\tbe compatible with #pragma pack(n).\n+\n+\t* tree.h (record_layout_info): Add new field\n+\tremaining_in_alignment.\n+\n+\t* doc/tm.texi: (TARGET_MS_BITFIELD_LAYOUT_P): Update.\n+\t(pragma pack): Add paragraph on MSVC bitfield packing.\n+\n 2002-09-18  Richard Earnshaw  (reanrsha@arm.com)\n \n \tPR optimization/7967"}, {"sha": "2fd4a7b8207749da51bd37bd42c668c909f41610", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e4850f36e545325e3309870d13dfe4582e7cb9d4", "patch": "@@ -1429,6 +1429,20 @@ the whole enclosing structure, even if it is unnamed; except that\n (iii) a zero-sized bit-field will be disregarded unless it follows\n another bit-field of non-zero size.  If this hook returns @code{true},\n other macros that control bit-field layout are ignored.\n+\n+When a bit-field is inserted into a packed record, the whole size\n+of the underlying type is used by one or more same-size adjacent\n+bit-fields (that is, if its long:3, 32 bits is used in the record,\n+and any additional adjacent long bit-fields are packed into the same\n+chunk of 32 bits. However, if the size changes, a new field of that\n+size is allocated). In an unpacked record, this is the same as using\n+alignment, but not equivalent when packing.\n+\n+If both MS bit-fields and @samp{__attribute__((packed))} are used,\n+the latter will take precedence. If @samp{__attribute__((packed))} is\n+used on a single field when MS bit-fields are in use, it will take\n+precedence for that field, but the alignment of the rest of the structure\n+may affect its placement.\n @end deftypefn\n \n @node Type Layout\n@@ -8802,6 +8816,21 @@ within a structure, in much the same way as the @samp{__aligned__} and\n @samp{__packed__} @code{__attribute__}s do.  A pack value of zero resets\n the behavior to the default.\n \n+A subtlety for Microsoft Visual C/C++ style bit-field packing\n+(e.g. -mms-bitfields) for targets that support it:\n+When a bit-field is inserted into a packed record, the whole size\n+of the underlying type is used by one or more same-size adjacent\n+bit-fields (that is, if its long:3, 32 bits is used in the record,\n+and any additional adjacent long bit-fields are packed into the same\n+chunk of 32 bits. However, if the size changes, a new field of that\n+size is allocated).\n+\n+If both MS bit-fields and @samp{__attribute__((packed))} are used,\n+the latter will take precedence. If @samp{__attribute__((packed))} is\n+used on a single field when MS bit-fields are in use, it will take\n+precedence for that field, but the alignment of the rest of the structure\n+may affect its placement.\n+\n The weak pragma only works if @code{SUPPORTS_WEAK} and\n @code{ASM_WEAKEN_LABEL} are defined.  If enabled it allows the creation\n of specifically named weak labels, optionally with a value."}, {"sha": "dae4c2df38ec9f857df0fd5a8234b5dda5864855", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 158, "deletions": 44, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e4850f36e545325e3309870d13dfe4582e7cb9d4", "patch": "@@ -801,15 +801,27 @@ place_field (rli, field)\n   if ((* targetm.ms_bitfield_layout_p) (rli->t)\n       && type != error_mark_node\n       && DECL_BIT_FIELD_TYPE (field)\n-      && ! integer_zerop (TYPE_SIZE (type))\n-      && integer_zerop (DECL_SIZE (field)))\n+      && ! integer_zerop (TYPE_SIZE (type)))\n     {\n-      if (rli->prev_field\n-\t  && DECL_BIT_FIELD_TYPE (rli->prev_field)\n-\t  && ! integer_zerop (DECL_SIZE (rli->prev_field)))\n+      /* Here, the alignment of the underlying type of a bitfield can\n+\t affect the alignment of a record; even a zero-sized field\n+\t can do this.  The alignment should be to the alignment of\n+\t the type, except that for zero-size bitfields this only\n+\t applies if there was an immediately prior, non-zero-size\n+\t bitfield.  (That's the way it is, experimentally.) */\n+      if (! integer_zerop (DECL_SIZE (field))\n+ \t  ? ! DECL_PACKED (field)\n+ \t  : (rli->prev_field\n+ \t     && DECL_BIT_FIELD_TYPE (rli->prev_field)\n+ \t     && ! integer_zerop (DECL_SIZE (rli->prev_field))))\n \t{\n-\t  rli->record_align = MAX (rli->record_align, desired_align);\n+\t  unsigned int type_align = TYPE_ALIGN (type);\n+\t  type_align = MAX (type_align, desired_align);\n+\t  if (maximum_field_alignment != 0)\n+\t    type_align = MIN (type_align, maximum_field_alignment);\n+\t  rli->record_align = MAX (rli->record_align, type_align);\n \t  rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n+\t  rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n \t}\n       else\n \tdesired_align = 1;\n@@ -991,48 +1003,148 @@ place_field (rli, field)\n     }\n #endif\n \n-  /* See the docs for TARGET_MS_BITFIELD_LAYOUT_P for details.  */\n+  /* See the docs for TARGET_MS_BITFIELD_LAYOUT_P for details.\n+     A subtlety:\n+\tWhen a bit field is inserted into a packed record, the whole\n+\tsize of the underlying type is used by one or more same-size\n+\tadjacent bitfields.  (That is, if its long:3, 32 bits is \n+\tused in the record, and any additional adjacent long bitfields are\n+\tpacked into the same chunk of 32 bits. However, if the size\n+\tchanges, a new field of that size is allocated.)  In an unpacked\n+\trecord, this is the same as using alignment, but not eqivalent\n+\twhen packing. \n+\n+     Note: for compatability, we use the type size, not the type alignment\n+     to determine alignment, since that matches the documentation */\n+\n   if ((* targetm.ms_bitfield_layout_p) (rli->t)\n-      && TREE_CODE (field) == FIELD_DECL\n-      && type != error_mark_node\n-      && ! DECL_PACKED (field)\n-      && rli->prev_field\n-      && DECL_SIZE (field)\n-      && host_integerp (DECL_SIZE (field), 1)\n-      && DECL_SIZE (rli->prev_field)\n-      && host_integerp (DECL_SIZE (rli->prev_field), 1)\n-      && host_integerp (rli->offset, 1)\n-      && host_integerp (TYPE_SIZE (type), 1)\n-      && host_integerp (TYPE_SIZE (TREE_TYPE (rli->prev_field)), 1)\n-      && ((DECL_BIT_FIELD_TYPE (rli->prev_field)\n-\t   && ! integer_zerop (DECL_SIZE (rli->prev_field)))\n-\t  || (DECL_BIT_FIELD_TYPE (field)\n-\t      && ! integer_zerop (DECL_SIZE (field))))\n-      && (! simple_cst_equal (TYPE_SIZE (type),\n-\t\t\t      TYPE_SIZE (TREE_TYPE (rli->prev_field)))\n-\t  /* If the previous field was a zero-sized bit-field, either\n-\t     it was ignored, in which case we must ensure the proper\n-\t     alignment of this field here, or it already forced the\n-\t     alignment of this field, in which case forcing the\n-\t     alignment again is harmless.  So, do it in both cases.  */\n-\t  || (DECL_BIT_FIELD_TYPE (rli->prev_field)\n-\t      && integer_zerop (DECL_SIZE (rli->prev_field)))))\n+       && ((DECL_BIT_FIELD_TYPE (field) && ! DECL_PACKED (field))\n+ \t  || (rli->prev_field && ! DECL_PACKED (rli->prev_field))))\n     {\n-      unsigned int type_align = TYPE_ALIGN (type);\n+      /* At this point, either the prior or current are bitfields,\n+\t (possibly both), and we're dealing with MS packing. */\n+      tree prev_saved = rli->prev_field;\n \n-      if (rli->prev_field\n-\t  && DECL_BIT_FIELD_TYPE (rli->prev_field)\n-\t  /* If the previous bit-field is zero-sized, we've already\n-\t     accounted for its alignment needs (or ignored it, if\n-\t     appropriate) while placing it.  */\n-\t  && ! integer_zerop (DECL_SIZE (rli->prev_field)))\n-\ttype_align = MAX (type_align,\n-\t\t\t  TYPE_ALIGN (TREE_TYPE (rli->prev_field)));\n+      /* Is the prior field a bitfield?  If so, handle \"runs\" of same\n+\t type size fields. */\n+      if (rli->prev_field /* necessarily a bitfield if it exists. */) \n+\t{\n+\t  /* If both are bitfields, nonzero, and the same size, this is\n+\t     the middle of a run.  Zero declared size fields are special\n+\t     and handled as \"end of run\". (Note: it's nonzero declared\n+\t     size, but equal type sizes!) (Since we know that both\n+\t     the current and previous fields are bitfields by the\n+\t     time we check it, DECL_SIZE must be present for both.) */\n+\t  if (DECL_BIT_FIELD_TYPE (field)\n+\t      && !integer_zerop (DECL_SIZE (field))\n+\t      && !integer_zerop (DECL_SIZE (rli->prev_field))\n+\t      && simple_cst_equal (TYPE_SIZE (type),\n+\t\t   TYPE_SIZE (TREE_TYPE (rli->prev_field))) )\n+\t    {\n+\t      /* We're in the middle of a run of equal type size fields; make\n+\t\t sure we realign if we run out of bits.  (Not decl size,\n+\t\t type size!) */\n+\t      int bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t      tree type_size = TYPE_SIZE(TREE_TYPE(rli->prev_field));\n+\n+\t      if (rli->remaining_in_alignment < bitsize)\n+\t\t{\n+\t\t  /* out of bits; bump up to next 'word'. */\n+\t\t  rli->bitpos = size_binop (PLUS_EXPR,\n+\t\t\t\t      type_size,\n+\t\t\t\t      DECL_FIELD_BIT_OFFSET(rli->prev_field));\n+\t\t  rli->prev_field = field;\n+\t\t  rli->remaining_in_alignment = TREE_INT_CST_LOW (type_size);\n+\t\t}\n+\t      rli->remaining_in_alignment -= bitsize;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* End of a run: if leaving a run of bitfields of the same type \n+\t\t size, we have to \"use up\" the rest of the bits of the type \n+\t\t size.\n+\n+\t\t Compute the new position as the sum of the size for the prior\n+\t\t type and where we first started working on that type.\n+\t\t Note: since the beginning of the field was aligned then\n+\t\t of course the end will be too.  No round needed.  */\n+\n+\t      if (!integer_zerop (DECL_SIZE (rli->prev_field)))\n+\t\t{\n+\t\t  tree type_size = TYPE_SIZE(TREE_TYPE(rli->prev_field));\n+\t\t  rli->bitpos = size_binop (PLUS_EXPR,\n+\t\t\t\t      type_size,\n+\t\t\t\t      DECL_FIELD_BIT_OFFSET(rli->prev_field));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* We \"use up\" size zero fields; the code below should behave\n+\t\t     as if the prior field was not a bitfield. */\n+\t\t  prev_saved = NULL;\n+\t\t}\n+\n+\t      /* Cause a new bitfield to be captured, either this time (if \n+\t\t currently a bitfield) or next time we see one. */\n+\t      if (!DECL_BIT_FIELD_TYPE(field)\n+\t\t || integer_zerop (DECL_SIZE (field)))\n+\t\t{\n+\t\t  rli->prev_field = NULL;\n+\t\t}\n+\t    }\n+\t  normalize_rli (rli);\n+        }\n+\n+      /* If we're starting a new run of same size type bitfields\n+\t (or a run of non-bitfields), set up the \"first of the run\"\n+\t fields. \n+\n+\t That is, if the current field is not a bitfield, or if there\n+\t was a prior bitfield the type sizes differ, or if there wasn't\n+\t a prior bitfield the size of the current field is nonzero.\n+\n+\t Note: we must be sure to test ONLY the type size if there was\n+\t a prior bitfield and ONLY for the current field being zero if\n+\t there wasn't.  */\n+\n+      if (!DECL_BIT_FIELD_TYPE (field)\n+\t  || ( prev_saved != NULL \n+\t       ? !simple_cst_equal (TYPE_SIZE (type),\n+\t              TYPE_SIZE (TREE_TYPE (prev_saved)))\n+\t       : !integer_zerop (DECL_SIZE (field)) ))\n+\t{\n+\t  unsigned int type_align = 8;  /* Never below 8 for compatability */\n+\n+\t  /* (When not a bitfield), we could be seeing a flex array (with \n+\t     no DECL_SIZE).  Since we won't be using remaining_in_alignment\n+\t     until we see a bitfield (and come by here again) we just skip \n+\t     calculating it.  */\n+\t     \n+\t  if (DECL_SIZE (field) != NULL)\n+\t      rli->remaining_in_alignment \n+\t\t  = TREE_INT_CST_LOW (TYPE_SIZE(TREE_TYPE(field)))\n+\t\t    - TREE_INT_CST_LOW (DECL_SIZE (field));\n+\n+\t  /* Now align (conventionally) for the new type. */\n+\t  if (!DECL_PACKED(field))\n+\t      type_align = MAX(TYPE_ALIGN (type), type_align);\n+\n+\t  if (prev_saved\n+\t      && DECL_BIT_FIELD_TYPE (prev_saved)\n+\t      /* If the previous bit-field is zero-sized, we've already\n+\t\t accounted for its alignment needs (or ignored it, if\n+\t\t appropriate) while placing it.  */\n+\t      && ! integer_zerop (DECL_SIZE (prev_saved)))\n+\t    type_align = MAX (type_align,\n+\t\t\t      TYPE_ALIGN (TREE_TYPE (prev_saved)));\n \n-      if (maximum_field_alignment != 0)\n-\ttype_align = MIN (type_align, maximum_field_alignment);\n+\t  if (maximum_field_alignment != 0)\n+\t    type_align = MIN (type_align, maximum_field_alignment);\n \n-      rli->bitpos = round_up (rli->bitpos, type_align);\n+\t  rli->bitpos = round_up (rli->bitpos, type_align);\n+          /* If we really aligned, don't allow subsequent bitfields\n+\t     to undo that. */\n+\t  rli->prev_field = NULL;\n+\t}\n     }\n \n   /* Offset so far becomes the position of this field after normalizing.  */\n@@ -1061,7 +1173,9 @@ place_field (rli, field)\n   if (known_align != actual_align)\n     layout_decl (field, actual_align);\n \n-  rli->prev_field = field;\n+  /* Only the MS bitfields use this. */\n+  if (rli->prev_field == NULL && DECL_BIT_FIELD_TYPE(field))\n+      rli->prev_field = field;\n \n   /* Now add size of this field to the size of the record.  If the size is\n      not constant, treat the field as being a multiple of bytes and just"}, {"sha": "310d643b6e5c979fbaefd2d3d8a3dbaea49123fc", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4850f36e545325e3309870d13dfe4582e7cb9d4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e4850f36e545325e3309870d13dfe4582e7cb9d4", "patch": "@@ -2403,6 +2403,8 @@ typedef struct record_layout_info_s\n   /* The static variables (i.e., class variables, as opposed to\n      instance variables) encountered in T.  */\n   tree pending_statics;\n+  /* Bits remaining in the current alignment group */\n+  int remaining_in_alignment;\n   int packed_maybe_necessary;\n } *record_layout_info;\n "}]}