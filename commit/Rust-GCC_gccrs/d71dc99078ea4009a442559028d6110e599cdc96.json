{"sha": "d71dc99078ea4009a442559028d6110e599cdc96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcxZGM5OTA3OGVhNDAwOWE0NDI1NTkwMjhkNjExMGU1OTljZGM5Ng==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2018-05-23T13:26:05Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2018-05-23T13:26:05Z"}, "message": "gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add first_interp field.\n\n2018-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add\n\tfirst_interp field.\n\t(alloc_cand_and_find_basis): Initialize first_interp field.\n\t(slsr_process_mul): Modify first_interp field.\n\t(slsr_process_add): Likewise.\n\t(slsr_process_cast): Modify first_interp field for each new\n\tinterpretation.\n\t(slsr_process_copy): Likewise.\n\t(dump_candidate): Dump first_interp field.\n\t(replace_mult_candidate): Process all interpretations, not just\n\tsubsequent ones.\n\t(replace_rhs_if_not_dup): Likewise.\n\t(replace_one_candidate): Likewise.\n\nFrom-SVN: r260608", "tree": {"sha": "3ed64441c8fec3760555b6c3a3b6612250a99d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ed64441c8fec3760555b6c3a3b6612250a99d12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d71dc99078ea4009a442559028d6110e599cdc96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71dc99078ea4009a442559028d6110e599cdc96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d71dc99078ea4009a442559028d6110e599cdc96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71dc99078ea4009a442559028d6110e599cdc96/comments", "author": null, "committer": null, "parents": [{"sha": "d6cb6d6a1c2279deebb45e658cde66f1f91cae05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6cb6d6a1c2279deebb45e658cde66f1f91cae05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6cb6d6a1c2279deebb45e658cde66f1f91cae05"}], "stats": {"total": 92, "additions": 65, "deletions": 27}, "files": [{"sha": "09a70256d764bb207b077c9a7810b2605e3d5ec1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d71dc99078ea4009a442559028d6110e599cdc96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d71dc99078ea4009a442559028d6110e599cdc96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d71dc99078ea4009a442559028d6110e599cdc96", "patch": "@@ -1,3 +1,19 @@\n+2018-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add\n+\tfirst_interp field.\n+\t(alloc_cand_and_find_basis): Initialize first_interp field.\n+\t(slsr_process_mul): Modify first_interp field.\n+\t(slsr_process_add): Likewise.\n+\t(slsr_process_cast): Modify first_interp field for each new\n+\tinterpretation.\n+\t(slsr_process_copy): Likewise.\n+\t(dump_candidate): Dump first_interp field.\n+\t(replace_mult_candidate): Process all interpretations, not just\n+\tsubsequent ones.\n+\t(replace_rhs_if_not_dup): Likewise.\n+\t(replace_one_candidate): Likewise.\n+\n 2018-05-23  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_use_frame_pointer):"}, {"sha": "a4e5a52836c7f234f3be933a07bdc299b02ce2d6", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d71dc99078ea4009a442559028d6110e599cdc96/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d71dc99078ea4009a442559028d6110e599cdc96/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=d71dc99078ea4009a442559028d6110e599cdc96", "patch": "@@ -266,6 +266,10 @@ struct slsr_cand_d\n      of a statement.  */\n   cand_idx next_interp;\n \n+  /* Index of the first candidate record in a chain for the same\n+     statement.  */\n+  cand_idx first_interp;\n+\n   /* Index of the basis statement S0, if any, in the candidate vector.  */\n   cand_idx basis;\n \n@@ -686,6 +690,7 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple *gs, tree base,\n   c->kind = kind;\n   c->cand_num = cand_vec.length () + 1;\n   c->next_interp = 0;\n+  c->first_interp = c->cand_num;\n   c->dependent = 0;\n   c->sibling = 0;\n   c->def_phi = kind == CAND_MULT ? find_phi_def (base) : 0;\n@@ -1261,6 +1266,7 @@ slsr_process_mul (gimple *gs, tree rhs1, tree rhs2, bool speed)\n \t is the stride and RHS2 is the base expression.  */\n       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);\n       c->next_interp = c2->cand_num;\n+      c2->first_interp = c->cand_num;\n     }\n   else if (TREE_CODE (rhs2) == INTEGER_CST)\n     {\n@@ -1498,7 +1504,10 @@ slsr_process_add (gimple *gs, tree rhs1, tree rhs2, bool speed)\n \t{\n \t  c2 = create_add_ssa_cand (gs, rhs2, rhs1, false, speed);\n \t  if (c)\n-\t    c->next_interp = c2->cand_num;\n+\t    {\n+\t      c->next_interp = c2->cand_num;\n+\t      c2->first_interp = c->cand_num;\n+\t    }\n \t  else\n \t    add_cand_for_stmt (gs, c2);\n \t}\n@@ -1621,6 +1630,8 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)\n \n   if (base_cand && base_cand->kind != CAND_PHI)\n     {\n+      slsr_cand_t first_cand = NULL;\n+\n       while (base_cand)\n \t{\n \t  /* Propagate all data from the base candidate except the type,\n@@ -1635,6 +1646,12 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)\n \t\t\t\t\t base_cand->index, base_cand->stride,\n \t\t\t\t\t ctype, base_cand->stride_type,\n \t\t\t\t\t savings);\n+\t  if (!first_cand)\n+\t    first_cand = c;\n+\n+\t  if (first_cand != c)\n+\t    c->first_interp = first_cand->cand_num;\n+\n \t  if (base_cand->next_interp)\n \t    base_cand = lookup_cand (base_cand->next_interp);\n \t  else\n@@ -1657,6 +1674,7 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)\n       c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, 0,\n \t\t\t\t      integer_one_node, ctype, sizetype, 0);\n       c->next_interp = c2->cand_num;\n+      c2->first_interp = c->cand_num;\n     }\n \n   /* Add the first (or only) interpretation to the statement-candidate\n@@ -1681,6 +1699,8 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)\n \n   if (base_cand && base_cand->kind != CAND_PHI)\n     {\n+      slsr_cand_t first_cand = NULL;\n+\n       while (base_cand)\n \t{\n \t  /* Propagate all data from the base candidate.  */\n@@ -1693,6 +1713,12 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)\n \t\t\t\t\t base_cand->index, base_cand->stride,\n \t\t\t\t\t base_cand->cand_type,\n \t\t\t\t\t base_cand->stride_type, savings);\n+\t  if (!first_cand)\n+\t    first_cand = c;\n+\n+\t  if (first_cand != c)\n+\t    c->first_interp = first_cand->cand_num;\n+\n \t  if (base_cand->next_interp)\n \t    base_cand = lookup_cand (base_cand->next_interp);\n \t  else\n@@ -1717,6 +1743,7 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)\n \t\t\t\t      integer_one_node, TREE_TYPE (rhs1),\n \t\t\t\t      sizetype, 0);\n       c->next_interp = c2->cand_num;\n+      c2->first_interp = c->cand_num;\n     }\n \n   /* Add the first (or only) interpretation to the statement-candidate\n@@ -1887,8 +1914,9 @@ dump_candidate (slsr_cand_t c)\n   print_generic_expr (dump_file, c->cand_type);\n   fprintf (dump_file, \"\\n     basis: %d  dependent: %d  sibling: %d\\n\",\n \t   c->basis, c->dependent, c->sibling);\n-  fprintf (dump_file, \"     next-interp: %d  dead-savings: %d\\n\",\n-\t   c->next_interp, c->dead_savings);\n+  fprintf (dump_file,\n+\t   \"     next-interp: %d  first-interp: %d  dead-savings: %d\\n\",\n+\t   c->next_interp, c->first_interp, c->dead_savings);\n   if (c->def_phi)\n     fprintf (dump_file, \"     phi:  %d\\n\", c->def_phi);\n   fputs (\"\\n\", dump_file);\n@@ -2147,14 +2175,13 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n       tree lhs = gimple_assign_lhs (c->cand_stmt);\n       gassign *copy_stmt = gimple_build_assign (lhs, basis_name);\n       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-      slsr_cand_t cc = c;\n+      slsr_cand_t cc = lookup_cand (c->first_interp);\n       gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n       gsi_replace (&gsi, copy_stmt, false);\n-      c->cand_stmt = copy_stmt;\n-      while (cc->next_interp)\n+      while (cc)\n \t{\n-\t  cc = lookup_cand (cc->next_interp);\n \t  cc->cand_stmt = copy_stmt;\n+\t  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tstmt_to_print = copy_stmt;\n@@ -2181,14 +2208,13 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n       else\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  slsr_cand_t cc = c;\n+\t  slsr_cand_t cc = lookup_cand (c->first_interp);\n \t  gimple_assign_set_rhs_with_ops (&gsi, code, basis_name, bump_tree);\n \t  update_stmt (gsi_stmt (gsi));\n-\t  c->cand_stmt = gsi_stmt (gsi);\n-\t  while (cc->next_interp)\n+\t  while (cc)\n \t    {\n-\t      cc = lookup_cand (cc->next_interp);\n \t      cc->cand_stmt = gsi_stmt (gsi);\n+\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t    }\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    stmt_to_print = gsi_stmt (gsi);\n@@ -3597,14 +3623,13 @@ replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,\n \t      || !operand_equal_p (new_rhs2, old_rhs1, 0))))\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-      slsr_cand_t cc = c;\n+      slsr_cand_t cc = lookup_cand (c->first_interp);\n       gimple_assign_set_rhs_with_ops (&gsi, new_code, new_rhs1, new_rhs2);\n       update_stmt (gsi_stmt (gsi));\n-      c->cand_stmt = gsi_stmt (gsi);\n-      while (cc->next_interp)\n+      while (cc)\n \t{\n-\t  cc = lookup_cand (cc->next_interp);\n \t  cc->cand_stmt = gsi_stmt (gsi);\n+\t  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3709,14 +3734,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t  || !operand_equal_p (rhs2, orig_rhs2, 0))\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  slsr_cand_t cc = c;\n+\t  slsr_cand_t cc = lookup_cand (c->first_interp);\n \t  gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, basis_name, rhs2);\n \t  update_stmt (gsi_stmt (gsi));\n-          c->cand_stmt = gsi_stmt (gsi);\n-\t  while (cc->next_interp)\n+\t  while (cc)\n \t    {\n-\t      cc = lookup_cand (cc->next_interp);\n \t      cc->cand_stmt = gsi_stmt (gsi);\n+\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3736,14 +3760,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t{\n \t  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  slsr_cand_t cc = c;\n+\t  slsr_cand_t cc = lookup_cand (c->first_interp);\n \t  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, copy_stmt, false);\n-\t  c->cand_stmt = copy_stmt;\n-\t  while (cc->next_interp)\n+\t  while (cc)\n \t    {\n-\t      cc = lookup_cand (cc->next_interp);\n \t      cc->cand_stmt = copy_stmt;\n+\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3753,14 +3776,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n \t  gassign *cast_stmt = gimple_build_assign (lhs, NOP_EXPR, basis_name);\n-\t  slsr_cand_t cc = c;\n+\t  slsr_cand_t cc = lookup_cand (c->first_interp);\n \t  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, cast_stmt, false);\n-\t  c->cand_stmt = cast_stmt;\n-\t  while (cc->next_interp)\n+\t  while (cc)\n \t    {\n-\t      cc = lookup_cand (cc->next_interp);\n \t      cc->cand_stmt = cast_stmt;\n+\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}]}