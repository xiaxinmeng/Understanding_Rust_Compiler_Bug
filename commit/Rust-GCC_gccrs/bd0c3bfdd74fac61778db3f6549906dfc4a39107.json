{"sha": "bd0c3bfdd74fac61778db3f6549906dfc4a39107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQwYzNiZmRkNzRmYWM2MTc3OGRiM2Y2NTQ5OTA2ZGZjNGEzOTEwNw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2012-09-04T13:22:54Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-09-04T13:22:54Z"}, "message": "Make all VEC_* functions, member functions of vec_t.\n\nThis patch is the first step towards making the API for VEC use\nmember functions.\n\nThere are no user code modifications in this patch.  Everything\nis still using the VEC_* macros, but this time they expand into\nmember function calls.\n\nBecause of the way VECs are used, this required some trickery.\nThe API allows VECs to be NULL.  This means that services like\nVEC_length(V) will return 0 when V is a NULL pointer.  This is,\nof course, not possible to do if we call V->length().\n\nFor functions that either need to allocate/re-allocate the\nvector, or they need to handle NULL vectors, I implemented them\nas static member functions or free functions.\n\nAnother wart that I did not address in this patch is the fact\nthat vectors of pointers and vectors of objects have slightly\ndifferent semantics when handling elements in the vector.  In\nvector of pointers, we pass them around by value, but in vectors\nof objects, they are passed around via pointers.  That's why we\nneed TYPE * and TYPE ** overloads for some functions (e.g.,\nvec_t::iterate).\n\nI will fix these two warts in a subsequent patch.  The idea is to\nmake vec_t a single-word structure, which acts as a handler for\nthe structure containing the actual vector.  Something like this:\n\ntemplate<typename T>\nstruct vec_t\n{\n  struct vec_internal<T> *vec_;\n};\n\nThis has the advantage that we can now declare the actual vector\ninstances as regular variables, instead of pointers.  They will\nuse the same amount of memory when embedded in other structures,\nand we will be able to allocate and reallocate the actual data\nwithout having to mutate the vector instance.\n\nAll the functions that are now static members in vec_t, will\nbecome instance members in the new vec_t.  This will mean that\nall the callers will need to be changed, of course.\n\nTested on x86_64 and ppc64 with all languages plus ada, go and obj-c++.\n\n\tRewrite VEC_* functions as member functions of vec_t.\n\n\t* vec.h: Update documentation.\n\t(ALONE_VEC_CHECK_INFO): Define.\n\t(ALONE_VEC_CHECK_DECL): Define.\n\t(ALONE_VEC_CHECK_PASS): Define.\n\t(struct vec_prefix): Rename field NUM to NUM_.\n\tRename field ALLOC to ALLOC_.\n\tUpdate all users.\n\t(struct vec_t): Rename field PREFIX to PREFIX_.\n\tRename field VEC to VEC_.\n\tUpdate all users.\n\t(vec_t::length): Rename from VEC_length_1.  Update all users.\n\t(vec_t::empty): Rename from VEC_empty_1.  Update all users.\n\t(vec_t::address): Rename from VEC_address_1.  Update all users.\n\t(vec_address): New.\n\t(vec_t::last): Rename from VEC_last_1.  Update all users.\n\t(vec_t::operator[]): Rename from VEC_index_1.  Update all users.\n\t(vec_t::iterate): Rename from VEC_iterate_1.  Update all users.\n\t(vec_t::embedded_size): Rename from VEC_embedded_size_1.\n\tUpdate all users.\n\t(vec_t::embedded_init): Rename from VEC_embedded_init_1.\n\tUpdate all users.\n\t(vec_t::alloc): Rename from VEC_alloc_1.  Update all users.\n\t(vec_t::free): Rename from VEC_free_1.  Update all users.\n\t(vec_t::copy): Rename from VEC_copy_1.  Update all users.\n\t(vec_t::space): Rename from VEC_space_1.  Update all users.\n\t(vec_t::reserve): Rename from VEC_reserve_1.  Update all users.\n\t(vec_t::reserve_exact): Rename from VEC_reserve_exact_1.\n\tUpdate all users.\n\t(vec_t::splice): Rename from VEC_splice_1.  Update all users.\n\t(vec_t::safe_splice): Rename from VEC_safe_splice_1.  Update all users.\n\t(vec_t::quick_push): Rename from VEC_quick_push_1.  Update all users.\n\t(vec_t::safe_push): Rename from VEC_safe_push_1.  Update all users.\n\t(vec_t::pop): Rename from VEC_pop_1.  Update all users.\n\t(vec_t::truncate): Rename from VEC_truncate_1.  Update all users.\n\t(vec_t::safe_grow): Rename from VEC_safe_grow_1.  Update all users.\n\t(vec_t::safe_grow_cleared): Rename from VEC_safe_grow_cleared_1.\n\tUpdate all users.\n\t(vec_t::replace): Rename from VEC_replace_1.  Update all users.\n\t(vec_t::quick_insert): Rename from VEC_quick_insert_1.\n\tUpdate all users.\n\t(vec_t::safe_insert): Rename from VEC_safe_insert_1.  Update all users.\n\t(vec_t::ordered_remove): Rename from VEC_ordered_remove_1.\n\tUpdate all users.\n\t(vec_t::unordered_remove): Rename from VEC_unordered_remove_1.\n\tUpdate all users.\n\t(vec_t::block_remove): Rename from VEC_block_remove_1. Update all users.\n\t(vec_t::lower_bound): Rename from VEC_lower_bound_1. Update all users.\n\nFrom-SVN: r190927", "tree": {"sha": "b421865bc50b947c03aacf5cb721ef0ac0e65fa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b421865bc50b947c03aacf5cb721ef0ac0e65fa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd0c3bfdd74fac61778db3f6549906dfc4a39107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0c3bfdd74fac61778db3f6549906dfc4a39107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0c3bfdd74fac61778db3f6549906dfc4a39107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0c3bfdd74fac61778db3f6549906dfc4a39107/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd8d363e257e2a8c9a22fcc276421bec68e1bb94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8d363e257e2a8c9a22fcc276421bec68e1bb94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8d363e257e2a8c9a22fcc276421bec68e1bb94"}], "stats": {"total": 1347, "additions": 711, "deletions": 636}, "files": [{"sha": "20e103ef7168389e58928eebb3af559b372ae8e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd0c3bfdd74fac61778db3f6549906dfc4a39107", "patch": "@@ -1,3 +1,55 @@\n+2012-09-04   Diego Novillo  <dnovillo@google.com>\n+\n+\tRewrite VEC_* functions as member functions of vec_t.\n+\n+\t* vec.h: Update documentation.\n+\t(ALONE_VEC_CHECK_INFO): Define.\n+\t(ALONE_VEC_CHECK_DECL): Define.\n+\t(ALONE_VEC_CHECK_PASS): Define.\n+\t(struct vec_prefix): Rename field NUM to NUM_.\n+\tRename field ALLOC to ALLOC_.\n+\tUpdate all users.\n+\t(struct vec_t): Rename field PREFIX to PREFIX_.\n+\tRename field VEC to VEC_.\n+\tUpdate all users.\n+\t(vec_t::length): Rename from VEC_length_1.  Update all users.\n+\t(vec_t::empty): Rename from VEC_empty_1.  Update all users.\n+\t(vec_t::address): Rename from VEC_address_1.  Update all users.\n+\t(vec_address): New.\n+\t(vec_t::last): Rename from VEC_last_1.  Update all users.\n+\t(vec_t::operator[]): Rename from VEC_index_1.  Update all users.\n+\t(vec_t::iterate): Rename from VEC_iterate_1.  Update all users.\n+\t(vec_t::embedded_size): Rename from VEC_embedded_size_1.\n+\tUpdate all users.\n+\t(vec_t::embedded_init): Rename from VEC_embedded_init_1.\n+\tUpdate all users.\n+\t(vec_t::alloc): Rename from VEC_alloc_1.  Update all users.\n+\t(vec_t::free): Rename from VEC_free_1.  Update all users.\n+\t(vec_t::copy): Rename from VEC_copy_1.  Update all users.\n+\t(vec_t::space): Rename from VEC_space_1.  Update all users.\n+\t(vec_t::reserve): Rename from VEC_reserve_1.  Update all users.\n+\t(vec_t::reserve_exact): Rename from VEC_reserve_exact_1.\n+\tUpdate all users.\n+\t(vec_t::splice): Rename from VEC_splice_1.  Update all users.\n+\t(vec_t::safe_splice): Rename from VEC_safe_splice_1.  Update all users.\n+\t(vec_t::quick_push): Rename from VEC_quick_push_1.  Update all users.\n+\t(vec_t::safe_push): Rename from VEC_safe_push_1.  Update all users.\n+\t(vec_t::pop): Rename from VEC_pop_1.  Update all users.\n+\t(vec_t::truncate): Rename from VEC_truncate_1.  Update all users.\n+\t(vec_t::safe_grow): Rename from VEC_safe_grow_1.  Update all users.\n+\t(vec_t::safe_grow_cleared): Rename from VEC_safe_grow_cleared_1.\n+\tUpdate all users.\n+\t(vec_t::replace): Rename from VEC_replace_1.  Update all users.\n+\t(vec_t::quick_insert): Rename from VEC_quick_insert_1.\n+\tUpdate all users.\n+\t(vec_t::safe_insert): Rename from VEC_safe_insert_1.  Update all users.\n+\t(vec_t::ordered_remove): Rename from VEC_ordered_remove_1.\n+\tUpdate all users.\n+\t(vec_t::unordered_remove): Rename from VEC_unordered_remove_1.\n+\tUpdate all users.\n+\t(vec_t::block_remove): Rename from VEC_block_remove_1. Update all users.\n+\t(vec_t::lower_bound): Rename from VEC_lower_bound_1. Update all users.\n+\n 2012-09-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gimple.h (gimple_build_switch): Remove."}, {"sha": "be9f54a5b57b61b252be79ec4ea4438cd48a7e00", "filename": "gcc/vec.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=bd0c3bfdd74fac61778db3f6549906dfc4a39107", "patch": "@@ -175,8 +175,8 @@ calculate_allocation (const struct vec_prefix *pfx, int reserve, bool exact)\n \n   if (pfx)\n     {\n-      alloc = pfx->alloc;\n-      num = pfx->num;\n+      alloc = pfx->alloc_;\n+      num = pfx->num_;\n     }\n   else if (!reserve)\n     /* If there's no prefix, and we've not requested anything, then we\n@@ -240,9 +240,9 @@ vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n \n   vec = ggc_realloc_stat (vec, size PASS_MEM_STAT);\n \n-  ((struct vec_prefix *)vec)->alloc = alloc;\n+  ((struct vec_prefix *)vec)->alloc_ = alloc;\n   if (!pfx)\n-    ((struct vec_prefix *)vec)->num = 0;\n+    ((struct vec_prefix *)vec)->num_ = 0;\n \n   return vec;\n }\n@@ -268,9 +268,9 @@ vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n     free_overhead (pfx);\n \n   vec = xrealloc (vec, vec_offset + alloc * elt_size);\n-  ((struct vec_prefix *)vec)->alloc = alloc;\n+  ((struct vec_prefix *)vec)->alloc_ = alloc;\n   if (!pfx)\n-    ((struct vec_prefix *)vec)->num = 0;\n+    ((struct vec_prefix *)vec)->num_ = 0;\n   if (GATHER_STATISTICS && vec)\n     register_overhead ((struct vec_prefix *)vec,\n     \t\t       vec_offset + alloc * elt_size FINAL_PASS_MEM_STAT);\n@@ -306,8 +306,8 @@ vec_stack_p_reserve_exact_1 (int alloc, void *space)\n \n   VEC_safe_push (void_p, heap, stack_vecs, space);\n \n-  pfx->num = 0;\n-  pfx->alloc = alloc;\n+  pfx->num_ = 0;\n+  pfx->alloc_ = alloc;\n \n   return space;\n }\n@@ -343,15 +343,15 @@ vec_stack_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n     }\n \n   /* Move VEC to the heap.  */\n-  reserve += ((struct vec_prefix *) vec)->num;\n+  reserve += ((struct vec_prefix *) vec)->num_;\n   newvec = vec_heap_o_reserve_1 (NULL, reserve, vec_offset, elt_size,\n \t\t\t\t exact PASS_MEM_STAT);\n   if (newvec && vec)\n     {\n-      ((struct vec_prefix *) newvec)->num = ((struct vec_prefix *) vec)->num;\n+      ((struct vec_prefix *) newvec)->num_ = ((struct vec_prefix *) vec)->num_;\n       memcpy (((struct vec_prefix *) newvec)+1,\n \t      ((struct vec_prefix *) vec)+1,\n-\t      ((struct vec_prefix *) vec)->num * elt_size);\n+\t      ((struct vec_prefix *) vec)->num_ * elt_size);\n     }\n   return newvec;\n }"}, {"sha": "74a85c795974f7411a4ebfc0df379ddd70ddb1f8", "filename": "gcc/vec.h", "status": "modified", "additions": 648, "deletions": 625, "changes": 1273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0c3bfdd74fac61778db3f6549906dfc4a39107/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=bd0c3bfdd74fac61778db3f6549906dfc4a39107", "patch": "@@ -25,26 +25,34 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"statistics.h\"\t\t/* For MEM_STAT_DECL.  */\n \n-/* The macros here implement a set of templated vector types and\n-   associated interfaces.  These templates are implemented with\n-   macros, as we're not in C++ land.  The interface functions are\n-   typesafe and use static inline functions, sometimes backed by\n-   out-of-line generic functions.  The vectors are designed to\n-   interoperate with the GTY machinery.\n-\n-   Because of the different behavior of structure objects, scalar\n-   objects and of pointers, there are three flavors, one for each of\n-   these variants.  Both the structure object and pointer variants\n-   pass pointers to objects around -- in the former case the pointers\n-   are stored into the vector and in the latter case the pointers are\n-   dereferenced and the objects copied into the vector.  The scalar\n-   object variant is suitable for int-like objects, and the vector\n-   elements are returned by value.\n-\n-   There are both 'index' and 'iterate' accessors.  The iterator\n-   returns a boolean iteration condition and updates the iteration\n-   variable passed by reference.  Because the iterator will be\n-   inlined, the address-of can be optimized away.\n+/* Templated vector type and associated interfaces.\n+\n+   The interface functions are typesafe and use inline functions,\n+   sometimes backed by out-of-line generic functions.  The vectors are\n+   designed to interoperate with the GTY machinery.\n+\n+   FIXME - Remove the following compatibility notes after a handler\n+   class for vec_t is implemented.\n+\n+   To preserve compatibility with the existing API, some functions\n+   that manipulate vector elements implement two overloads: one taking\n+   a pointer to the element and others that take a pointer to a\n+   pointer to the element.\n+\n+   This used to be implemented with three different families of macros\n+   and structures: structure objects, scalar objects and of pointers.\n+   Both the structure object and pointer variants passed pointers to\n+   objects around -- in the former case the pointers were stored into\n+   the vector and in the latter case the pointers were dereferenced and\n+   the objects copied into the vector.  The scalar object variant was\n+   suitable for int-like objects, and the vector elements were returned\n+   by value.\n+\n+   There are both 'index' and 'iterate' accessors.  The index accessor\n+   is implemented by operator[].  The iterator returns a boolean\n+   iteration condition and updates the iteration variable passed by\n+   reference.  Because the iterator will be inlined, the address-of\n+   can be optimized away.\n \n    The vectors are implemented using the trailing array idiom, thus\n    they are not resizeable without changing the address of the vector\n@@ -87,43 +95,27 @@ along with GCC; see the file COPYING3.  If not see\n    When a vector type is defined, first a non-memory managed version\n    is created.  You can then define either or both garbage collected\n    and heap allocated versions.  The allocation mechanism is specified\n-   when the type is defined, and is therefore part of the type.  If\n-   you need both gc'd and heap allocated versions, you still must have\n-   *exactly* one definition of the common non-memory managed base vector.\n+   when the vector is allocated.  This can occur via the VEC_alloc\n+   call or one of the VEC_safe_* functions that add elements to a\n+   vector.  If the vector is NULL, it will be allocated using the\n+   allocation strategy selected in the call.  The valid allocations\n+   are defined in enum vec_allocation_t.\n \n    If you need to directly manipulate a vector, then the 'address'\n    accessor will return the address of the start of the vector.  Also\n    the 'space' predicate will tell you whether there is spare capacity\n    in the vector.  You will not normally need to use these two functions.\n \n-   Vector types are defined using a DEF_VEC_{O,A,P,I}(TYPEDEF) macro, to\n-   get the non-memory allocation version, and then a\n-   DEF_VEC_ALLOC_{O,A,P,I}(TYPEDEF,ALLOC) macro to get memory managed\n-   vectors.  Variables of vector type are declared using a\n-   VEC(TYPEDEF,ALLOC) macro.  The ALLOC argument specifies the\n-   allocation strategy, and can be either 'gc' or 'heap' for garbage\n-   collected and heap allocated respectively.  It can be 'none' to get\n-   a vector that must be explicitly allocated (for instance as a\n-   trailing array of another structure).  The characters O, A, P and I\n-   indicate whether TYPEDEF is a pointer (P), object (O), atomic object\n-   (A) or integral (I) type.  Be careful to pick the correct one, as\n-   you'll get an awkward and inefficient API if you use the wrong one or\n-   a even a crash if you pick the atomic object version when the object\n-   version should have been chosen instead.  There is a check, which\n-   results in a compile-time warning, for the P and I versions, but there\n-   is no check for the O versions, as that is not possible in plain C.\n-   Due to the way GTY works, you must annotate any structures you wish to\n-   insert or reference from a vector with a GTY(()) tag.  You need to do\n-   this even if you never declare the GC allocated variants.\n+   Variables of vector type are of type vec_t<ETYPE> where ETYPE is\n+   the type of the elements of the vector. Due to the way GTY works,\n+   you must annotate any structures you wish to insert or reference\n+   from a vector with a GTY(()) tag.  You need to do this even if you\n+   never use the GC allocated variants.\n \n    An example of their use would be,\n \n-   DEF_VEC_P(tree);   // non-managed tree vector.\n-   DEF_VEC_ALLOC_P(tree,gc);\t// gc'd vector of tree pointers.  This must\n-   \t\t\t        // appear at file scope.\n-\n    struct my_struct {\n-     VEC(tree,gc) *v;      // A (pointer to) a vector of tree pointers.\n+     vec_t<tree> *v;      // A (pointer to) a vector of tree pointers.\n    };\n \n    struct my_struct *s;\n@@ -136,9 +128,12 @@ along with GCC; see the file COPYING3.  If not see\n */\n \n #if ENABLE_CHECKING\n-#define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n-#define VEC_CHECK_DECL ,const char *file_,unsigned line_,const char *function_\n-#define VEC_CHECK_PASS ,file_,line_,function_\n+#define ALONE_VEC_CHECK_INFO __FILE__, __LINE__, __FUNCTION__\n+#define VEC_CHECK_INFO , ALONE_VEC_CHECK_INFO\n+#define ALONE_VEC_CHECK_DECL const char *file_, unsigned line_, const char *function_\n+#define VEC_CHECK_DECL , ALONE_VEC_CHECK_DECL\n+#define ALONE_VEC_CHECK_PASS file_, line_, function_\n+#define VEC_CHECK_PASS , ALONE_VEC_CHECK_PASS\n \n #define VEC_ASSERT(EXPR,OP,T,A) \\\n   (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(T,A)), 0))\n@@ -147,8 +142,11 @@ extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n      ATTRIBUTE_NORETURN;\n #define VEC_ASSERT_FAIL(OP,VEC) vec_assert_fail (OP,#VEC VEC_CHECK_PASS)\n #else\n+#define ALONE_VEC_CHECK_INFO\n #define VEC_CHECK_INFO\n+#define ALONE_VEC_CHECK_DECL void\n #define VEC_CHECK_DECL\n+#define ALONE_VEC_CHECK_PASS\n #define VEC_CHECK_PASS\n #define VEC_ASSERT(EXPR,OP,T,A) (void)(EXPR)\n #endif\n@@ -159,27 +157,106 @@ enum vec_allocation_t { heap, gc, stack };\n \n struct vec_prefix\n {\n-  unsigned num;\n-  unsigned alloc;\n+  unsigned num_;\n+  unsigned alloc_;\n };\n \n /* Vector type, user visible.  */\n template<typename T>\n struct GTY(()) vec_t\n {\n-  vec_prefix prefix;\n-  T vec[1];\n+  unsigned length (void) const;\n+  bool empty (void) const;\n+  T *address (void);\n+  T &last (ALONE_VEC_CHECK_DECL);\n+  const T &operator[] (unsigned) const;\n+  T &operator[] (unsigned);\n+  void embedded_init (int, int);\n+\n+  template<enum vec_allocation_t A>\n+  vec_t<T> *copy (ALONE_MEM_STAT_DECL);\n+\n+  bool space (int VEC_CHECK_DECL);\n+  void splice (vec_t<T> * VEC_CHECK_DECL);\n+  T &quick_push (T VEC_CHECK_DECL);\n+  T *quick_push (const T * VEC_CHECK_DECL);\n+  T &pop (ALONE_VEC_CHECK_DECL);\n+  void truncate (unsigned VEC_CHECK_DECL);\n+  void replace (unsigned, T VEC_CHECK_DECL);\n+  void quick_insert (unsigned, T VEC_CHECK_DECL);\n+  void quick_insert (unsigned, const T * VEC_CHECK_DECL);\n+  void ordered_remove (unsigned VEC_CHECK_DECL);\n+  void unordered_remove (unsigned VEC_CHECK_DECL);\n+  void block_remove (unsigned, unsigned VEC_CHECK_DECL);\n+\n+  unsigned lower_bound (T, bool (*)(T, T)) const;\n+  unsigned lower_bound (const T *, bool (*)(const T *, const T *)) const;\n+\n+  /* Class-static member functions.  Some of these will become member\n+     functions of a future handler class wrapping vec_t.  */\n+  static size_t embedded_size (int);\n+\n+  template<enum vec_allocation_t A>\n+  static vec_t<T> *alloc (int MEM_STAT_DECL);\n+\n+  static vec_t<T> *alloc (int, vec_t<T> *);\n+\n+  template<enum vec_allocation_t A>\n+  static void free (vec_t<T> **);\n+\n+  template<enum vec_allocation_t A>\n+  static vec_t<T> *reserve_exact (vec_t<T> *, int MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static bool reserve_exact (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static vec_t<T> *reserve (vec_t<T> *, int MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static bool reserve (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static void safe_splice (vec_t<T> **, vec_t<T> * VEC_CHECK_DECL\n+\t\t\t   MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static T &safe_push (vec_t<T> **, T VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static T *safe_push (vec_t<T> **, const T * VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static void safe_grow (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static void safe_grow_cleared (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static void safe_insert (vec_t<T> **, unsigned, T * VEC_CHECK_DECL\n+\t\t\t   MEM_STAT_DECL);\n+\n+  template<enum vec_allocation_t A>\n+  static void safe_insert (vec_t<T> **, unsigned, T obj VEC_CHECK_DECL\n+\t\t\t   MEM_STAT_DECL);\n+\n+  static bool iterate (const vec_t<T> *, unsigned, T *);\n+  static bool iterate (const vec_t<T> *, unsigned, T **);\n+\n+  vec_prefix prefix_;\n+  T vec_[1];\n };\n \n+\n /* Garbage collection support for vec_t.  */\n \n template<typename T>\n void\n gt_ggc_mx (vec_t<T> *v)\n {\n-  extern void gt_ggc_mx (T&);\n-  for (unsigned i = 0; i < v->prefix.num; i++)\n-    gt_ggc_mx (v->vec[i]);\n+  extern void gt_ggc_mx (T &);\n+  for (unsigned i = 0; i < v->length (); i++)\n+    gt_ggc_mx ((*v)[i]);\n }\n \n \n@@ -189,31 +266,32 @@ template<typename T>\n void\n gt_pch_nx (vec_t<T> *v)\n {\n-  extern void gt_pch_nx (T&);\n-  for (unsigned i = 0; i < v->prefix.num; i++)\n-    gt_pch_nx (v->vec[i]);\n+  extern void gt_pch_nx (T &);\n+  for (unsigned i = 0; i < v->length (); i++)\n+    gt_pch_nx ((*v)[i]);\n }\n \n template<typename T>\n void\n gt_pch_nx (vec_t<T *> *v, gt_pointer_operator op, void *cookie)\n {\n-  for (unsigned i = 0; i < v->prefix.num; i++)\n-    op (&(v->vec[i]), cookie);\n+  for (unsigned i = 0; i < v->length (); i++)\n+    op (&((*v)[i]), cookie);\n }\n \n template<typename T>\n void\n gt_pch_nx (vec_t<T> *v, gt_pointer_operator op, void *cookie)\n {\n   extern void gt_pch_nx (T *, gt_pointer_operator, void *);\n-  for (unsigned i = 0; i < v->prefix.num; i++)\n-    gt_pch_nx (&(v->vec[i]), op, cookie);\n+  for (unsigned i = 0; i < v->length (); i++)\n+    gt_pch_nx (&((*v)[i]), op, cookie);\n }\n \n \n-/* FIXME cxx-conversion.  Remove these definitions and update all\n-   calling sites.  */\n+/* FIXME.  Remove these definitions and update all calling sites after\n+   the handler class for vec_t is implemented.  */\n+\n /* Vector of integer-like object.  */\n #define DEF_VEC_I(T)\t\t\tstruct vec_swallow_trailing_semi\n #define DEF_VEC_ALLOC_I(T,A)\t\tstruct vec_swallow_trailing_semi\n@@ -270,138 +348,194 @@ extern void *vec_stack_o_reserve_exact (void *, int, size_t, size_t\n \t\t\t\t\t MEM_STAT_DECL);\n extern void vec_stack_free (void *);\n \n-/* Reallocate an array of elements with prefix.  */\n-template<typename T, enum vec_allocation_t A>\n-extern vec_t<T> *vec_reserve (vec_t<T> *, int MEM_STAT_DECL);\n-\n-template<typename T, enum vec_allocation_t A>\n-extern vec_t<T> *vec_reserve_exact (vec_t<T> *, int MEM_STAT_DECL);\n-\n extern void dump_vec_loc_statistics (void);\n extern void ggc_free (void *);\n extern void vec_heap_free (void *);\n \n \n-/* Macros to invoke API calls.  A single macro works for both pointer\n-   and object vectors, but the argument and return types might well be\n-   different.  In each macro, T is the typedef of the vector elements,\n-   and A is the allocation strategy.  The allocation strategy is only\n-   present when it is required.  Some of these macros pass the vector,\n-   V, by reference (by taking its address), this is noted in the\n-   descriptions.  */\n+/* API compatibility macros (to be removed).  */\n+#define VEC_length(T,V)\t\t\t\t\t\t\t\\\n+\t((V) ? (V)->length () : 0)\n \n-/* Length of vector\n-   unsigned VEC_T_length(const VEC(T) *v);\n+#define VEC_empty(T,V)\t\t\t\t\t\t\t\\\n+\t((V) ? (V)->empty () : true)\n \n-   Return the number of active elements in V.  V can be NULL, in which\n-   case zero is returned.  */\n+#define VEC_address(T,V)\t\t\t\t\t\t\\\n+\tvec_address<T> (V)\n \n-#define VEC_length(T,V)\t(VEC_length_1<T> (V))\n+/* FIXME.  For now, we need to continue expanding VEC_address into a\n+   function call.  Otherwise, the warning machinery for -Wnonnull gets\n+   confused thinking that VEC_address may return null in calls to\n+   memcpy and qsort.  This will disappear once vec_address becomes\n+   a member function for a handler class wrapping vec_t.  */\n \n template<typename T>\n-static inline unsigned\n-VEC_length_1 (const vec_t<T> *vec_)\n+static inline T *\n+vec_address (vec_t<T> *vec)\n {\n-  return vec_ ? vec_->prefix.num : 0;\n+  return vec ? vec->address() : NULL;\n }\n \n+#define VEC_last(T,V)\t\t\t\t\t\t\t\\\n+\t((V)->last (ALONE_VEC_CHECK_INFO))\n \n-/* Check if vector is empty\n-   int VEC_T_empty(const VEC(T) *v);\n+#define VEC_index(T,V,I)\t\t\t\t\t\t\\\n+\t((*(V))[I])\n \n-   Return nonzero if V is an empty vector (or V is NULL), zero otherwise.  */\n+#define VEC_iterate(T,V,I,P)\t\t\t\t\t\t\\\n+\t(vec_t<T>::iterate(V, I, &(P)))\n \n-#define VEC_empty(T,V)\t(VEC_empty_1<T> (V))\n+#define VEC_embedded_size(T,N)\t\t\t\t\t\t\\\n+\t(vec_t<T>::embedded_size (N))\n \n-template<typename T>\n-static inline bool\n-VEC_empty_1 (const vec_t<T> *vec_)\n-{\n-  return VEC_length (T, vec_) == 0;\n-}\n+#define VEC_embedded_init(T,V,N)\t\t\t\t\t\\\n+\t((V)->embedded_init (N))\n+\n+#define VEC_free(T,A,V)\t\t\t\t\t\t\t\\\n+\t(vec_t<T>::free<A> (&(V)))\n+\n+#define VEC_copy(T,A,V)\t\t\t\t\t\t\t\\\n+\t((V)->copy<A> (ALONE_MEM_STAT_INFO))\n+\n+#define VEC_space(T,V,R)\t\t\t\t\t\t\\\n+\t((V) ? (V)->space (R VEC_CHECK_INFO) : (R) == 0)\n+\n+#define VEC_reserve(T,A,V,R)\t\t\t\t\t\t\\\n+\t(vec_t<T>::reserve<A> (&(V), (int)(R) VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+#define VEC_reserve_exact(T,A,V,R)\t\t\t\t\t\\\n+\t(vec_t<T>::reserve_exact<A> (&(V), R VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+#define VEC_splice(T,DST,SRC)\t        \t\t\t\t\\\n+\t(DST)->splice (SRC VEC_CHECK_INFO)\n+\n+#define VEC_safe_splice(T,A,DST,SRC)\t\t\t\t\t\\\n+\t vec_t<T>::safe_splice<A> (&(DST), SRC VEC_CHECK_INFO MEM_STAT_INFO)\n+\n+#define VEC_quick_push(T,V,O)\t\t\t\t\t\t\\\n+\t((V)->quick_push (O VEC_CHECK_INFO))\n+\n+#define VEC_safe_push(T,A,V,O)\t\t\t\t\t\t\\\n+\t(vec_t<T>::safe_push<A> (&(V), O VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+#define VEC_pop(T,V)\t\t\t\t\t\t\t\\\n+\t((V)->pop (ALONE_VEC_CHECK_INFO))\n+\n+#define VEC_truncate(T,V,I)\t\t\t\t\t\t\\\n+\t(V\t\t\t\t\t\t\t\t\\\n+\t ? (V)->truncate ((unsigned)(I) VEC_CHECK_INFO)\t\t\t\\\n+\t : gcc_assert ((I) == 0))\n+\n+#define VEC_safe_grow(T,A,V,I)\t\t\t\t\t\t\\\n+\t(vec_t<T>::safe_grow<A> (&(V), (int)(I) VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+#define VEC_safe_grow_cleared(T,A,V,I)\t\t\t\t\t\\\n+\t(vec_t<T>::safe_grow_cleared<A> (&(V), (int)(I)\t\t\t\\\n+\t\t\t\t         VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+#define VEC_replace(T,V,I,O)\t\t\t\t\t\t\\\n+\t((V)->replace ((unsigned)(I), O VEC_CHECK_INFO))\n+\n+#define VEC_quick_insert(T,V,I,O)\t\t\t\t\t\\\n+\t((V)->quick_insert (I,O VEC_CHECK_INFO))\n+\n+#define VEC_safe_insert(T,A,V,I,O)\t\t\t\t\t\\\n+\t(vec_t<T>::safe_insert<A> (&(V), I, O VEC_CHECK_INFO MEM_STAT_INFO))\n \n+#define VEC_ordered_remove(T,V,I)\t\t\t\t\t\\\n+\t((V)->ordered_remove (I VEC_CHECK_INFO))\n \n-/* Get the address of the array of elements\n-   T *VEC_T_address (VEC(T) v)\n+#define VEC_unordered_remove(T,V,I)\t\t\t\t\t\\\n+\t((V)->unordered_remove (I VEC_CHECK_INFO))\n \n-   If you need to directly manipulate the array (for instance, you\n-   want to feed it to qsort), use this accessor.  */\n+#define VEC_block_remove(T,V,I,L)\t\t\t\t\t\\\n+\t((V)->block_remove (I, L VEC_CHECK_INFO))\n \n-#define VEC_address(T,V)\t(VEC_address_1<T> (V))\n+#define VEC_lower_bound(T,V,O,LT)\t\t\t\t\t\\\n+\t((V)->lower_bound (O, LT))\n+\n+\n+/* Return the number of active elements in this vector.  */\n \n template<typename T>\n-static inline T *\n-VEC_address_1 (vec_t<T> *vec_)\n+inline unsigned\n+vec_t<T>::length (void) const\n {\n-  return vec_ ? vec_->vec : 0;\n+  return prefix_.num_;\n }\n \n \n-/* Get the final element of the vector.\n-   T VEC_T_last(VEC(T) *v); // Integer\n-   T VEC_T_last(VEC(T) *v); // Pointer\n-   T *VEC_T_last(VEC(T) *v); // Object\n+/* Return true if this vector has no active elements.  */\n+\n+template<typename T>\n+inline bool\n+vec_t<T>::empty (void) const\n+{\n+  return length () == 0;\n+}\n \n-   Return the final element.  V must not be empty.  */\n \n-#define VEC_last(T,V)\t(VEC_last_1<T> (V VEC_CHECK_INFO))\n+/* Return the address of the array of elements.  If you need to\n+   directly manipulate the array (for instance, you want to feed it\n+   to qsort), use this accessor.  */\n \n template<typename T>\n-static inline T&\n-VEC_last_1 (vec_t<T> *vec_ VEC_CHECK_DECL)\n+inline T *\n+vec_t<T>::address (void)\n {\n-  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\n-  return vec_->vec[vec_->prefix.num - 1];\n+  return vec_;\n }\n \n \n-/* Index into vector\n-   T VEC_T_index(VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n-   T *VEC_T_index(VEC(T) *v, unsigned ix); // Object\n+/* Get the final element of the vector, which must not be empty.  */\n+\n+template<typename T>\n+T &\n+vec_t<T>::last (ALONE_VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (prefix_.num_, \"last\", T, base);\n+  return (*this)[prefix_.num_ - 1];\n+}\n \n-   Return the IX'th element.  IX must be in the domain of V.  */\n \n-#define VEC_index(T,V,I) (VEC_index_1<T> (V, I VEC_CHECK_INFO))\n+/* Index into vector.  Return the IX'th element.  IX must be in the\n+   domain of the vector.  */\n \n template<typename T>\n-static inline T&\n-VEC_index_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+const T &\n+vec_t<T>::operator[] (unsigned ix) const\n {\n-  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\n-  return vec_->vec[ix_];\n+  gcc_assert (ix < prefix_.num_);\n+  return vec_[ix];\n }\n \n template<typename T>\n-static inline const T&\n-VEC_index_1 (const vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+T &\n+vec_t<T>::operator[] (unsigned ix)\n {\n-  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\n-  return vec_->vec[ix_];\n+  gcc_assert (ix < prefix_.num_);\n+  return vec_[ix];\n }\n \n \n-/* Iterate over vector\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Integer\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Pointer\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T *&ptr); // Object\n-\n-   Return iteration condition and update PTR to point to the IX'th\n-   element.  At the end of iteration, sets PTR to NULL.  Use this to\n-   iterate over the elements of a vector as follows,\n+/* Return iteration condition and update PTR to point to the IX'th\n+   element of VEC.  Use this to iterate over the elements of a vector\n+   as follows,\n \n-     for (ix = 0; VEC_iterate(T,v,ix,ptr); ix++)\n-       continue;  */\n-\n-#define VEC_iterate(T,V,I,P)\t(VEC_iterate_1<T> (V, I, &(P)))\n+     for (ix = 0; vec_t<T>::iterate(v, ix, &ptr); ix++)\n+       continue;\n+   \n+   FIXME.  This is a static member function because if VEC is NULL,\n+   PTR should be initialized to NULL.  This will become a regular\n+   member function of the handler class.  */\n \n template<typename T>\n-static inline bool\n-VEC_iterate_1 (const vec_t<T> *vec_, unsigned ix_, T *ptr)\n+bool\n+vec_t<T>::iterate (const vec_t<T> *vec, unsigned ix, T *ptr)\n {\n-  if (vec_ && ix_ < vec_->prefix.num)\n+  if (vec && ix < vec->prefix_.num_)\n     {\n-      *ptr = vec_->vec[ix_];\n+      *ptr = vec->vec_[ix];\n       return true;\n     }\n   else\n@@ -411,13 +545,24 @@ VEC_iterate_1 (const vec_t<T> *vec_, unsigned ix_, T *ptr)\n     }\n }\n \n+\n+/* Return iteration condition and update *PTR to point to the\n+   IX'th element of VEC.  Use this to iterate over the elements of a\n+   vector as follows,\n+\n+     for (ix = 0; v->iterate(ix, &ptr); ix++)\n+       continue;\n+\n+   This variant is for vectors of objects.  FIXME, to be removed\n+   once the distinction between vec_t<T> and vec_t<T *> disappears.  */\n+\n template<typename T>\n-static inline bool\n-VEC_iterate_1 (vec_t<T> *vec_, unsigned ix_, T **ptr)\n+bool\n+vec_t<T>::iterate (const vec_t<T> *vec, unsigned ix, T **ptr)\n {\n-  if (vec_ && ix_ < vec_->prefix.num)\n+  if (vec && ix < vec->prefix_.num_)\n     {\n-      *ptr = &vec_->vec[ix_];\n+      *ptr = CONST_CAST (T *, &vec->vec_[ix]);\n       return true;\n     }\n   else\n@@ -427,9 +572,10 @@ VEC_iterate_1 (vec_t<T> *vec_, unsigned ix_, T **ptr)\n     }\n }\n \n+\n /* Convenience macro for forward iteration.  */\n \n-#define FOR_EACH_VEC_ELT(T, V, I, P)\t\t\\\n+#define FOR_EACH_VEC_ELT(T, V, I, P)\t\t\t\\\n   for (I = 0; VEC_iterate (T, (V), (I), (P)); ++(I))\n \n /* Likewise, but start from FROM rather than 0.  */\n@@ -439,640 +585,517 @@ VEC_iterate_1 (vec_t<T> *vec_, unsigned ix_, T **ptr)\n \n /* Convenience macro for reverse iteration.  */\n \n-#define FOR_EACH_VEC_ELT_REVERSE(T,V,I,P) \\\n-  for (I = VEC_length (T, (V)) - 1;           \\\n-       VEC_iterate (T, (V), (I), (P));\t  \\\n+#define FOR_EACH_VEC_ELT_REVERSE(T, V, I, P)\t\t\\\n+  for (I = VEC_length (T, (V)) - 1;\t\t\t\\\n+       VEC_iterate (T, (V), (I), (P));\t\t\t\\\n        (I)--)\n \n \n-/* Use these to determine the required size and initialization of a\n-   vector embedded within another structure (as the final member).\n+/* Return the number of bytes needed to embed an instance of vec_t inside\n+   another data structure.\n \n-   size_t VEC_T_embedded_size(int reserve);\n-   void VEC_T_embedded_init(VEC(T) *v, int reserve);\n+   Use these methods to determine the required size and initialization\n+   of a vector V of type T embedded within another structure (as the\n+   final member):\n \n-   These allow the caller to perform the memory allocation.  */\n+   size_t vec_t<T>::embedded_size<T> (int reserve);\n+   void v->embedded_init(int reserve, int active = 0);\n \n-#define VEC_embedded_size(T,N)\t (VEC_embedded_size_1<T> (N))\n+   These allow the caller to perform the memory allocation.  */\n \n template<typename T>\n-static inline size_t\n-VEC_embedded_size_1 (int alloc_)\n+size_t\n+vec_t<T>::embedded_size (int nelems)\n {\n-  return offsetof (vec_t<T>, vec) + alloc_ * sizeof (T);\n+  return offsetof (vec_t<T>, vec_) + nelems * sizeof (T);\n }\n \n-#define VEC_embedded_init(T,O,N) (VEC_embedded_init_1<T> (O, N))\n+\n+/* Initialize the vector to contain room for NELEMS elements and\n+   ACTIVE active elements.  */\n \n template<typename T>\n-static inline void\n-VEC_embedded_init_1 (vec_t<T> *vec_, int alloc_)\n+void\n+vec_t<T>::embedded_init (int nelems, int active = 0)\n {\n-  vec_->prefix.num = 0;\n-  vec_->prefix.alloc = alloc_;\n+  prefix_.num_ = active;\n+  prefix_.alloc_ = nelems;\n }\n \n \n-/* Allocate new vector.\n-   VEC(T,A) *VEC_T_A_alloc(int reserve);\n-\n-   Allocate a new vector with space for RESERVE objects.  If RESERVE\n+/* Allocate a new vector with space for RESERVE objects.  If RESERVE\n    is zero, NO vector is created.\n \n+   Note that this allocator must always be a macro:\n+\n    We support a vector which starts out with space on the stack and\n    switches to heap space when forced to reallocate.  This works a\n-   little differently.  In the case of stack vectors, VEC_alloc will\n-   expand to a call to VEC_alloc_1 that calls XALLOCAVAR to request the\n+   little differently.  In the case of stack vectors, vec_alloc will\n+   expand to a call to vec_alloc_1 that calls XALLOCAVAR to request the\n    initial allocation.  This uses alloca to get the initial space.\n    Since alloca can not be usefully called in an inline function,\n-   VEC_alloc must always be a macro.\n-\n-   Only the initial allocation will be made using alloca, so pass a\n-   reasonable estimate that doesn't use too much stack space; don't\n-   pass zero.  Don't return a VEC(TYPE,stack) vector from the function\n-   which allocated it.  */\n-\n-#define VEC_alloc(T,A,N)\t\t\t\t\t\\\n-  ((A == stack)\t\t\t\t\t\t\t\\\n-    ? VEC_alloc_1 (N,\t\t\t\t\t\t\\\n- \t\t   XALLOCAVAR (vec_t<T>, \t\t\t\\\n-\t\t\t       VEC_embedded_size_1<T> (N)))\t\\\n-    : VEC_alloc_1<T, A> (N MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline vec_t<T> *\n-VEC_alloc_1 (int alloc_ MEM_STAT_DECL)\n+   vec_alloc must always be a macro.\n+\n+   Important limitations of stack vectors:\n+\n+   - Only the initial allocation will be made using alloca, so pass a\n+     reasonable estimate that doesn't use too much stack space; don't\n+     pass zero.\n+\n+   - Don't return a stack-allocated vector from the function which\n+     allocated it.  */\n+\n+#define VEC_alloc(T,A,N)\t\t\t\t\t\t\\\n+  ((A == stack)\t\t\t\t\t\t\t\t\\\n+    ? vec_t<T>::alloc (N, XALLOCAVAR (vec_t<T>, vec_t<T>::embedded_size (N)))\\\n+    : vec_t<T>::alloc<A> (N MEM_STAT_INFO))\n+\n+template<typename T>\n+template<enum vec_allocation_t A>\n+vec_t<T> *\n+vec_t<T>::alloc (int nelems MEM_STAT_DECL)\n {\n-  return vec_reserve_exact<T, A> (NULL, alloc_ PASS_MEM_STAT);\n+  return vec_t<T>::reserve_exact<A> ((vec_t<T> *) NULL, nelems PASS_MEM_STAT);\n }\n \n template<typename T>\n-static inline vec_t<T> *\n-VEC_alloc_1 (int alloc_, vec_t<T> *space)\n+vec_t<T> *\n+vec_t<T>::alloc (int nelems, vec_t<T> *space)\n {\n-  return (vec_t<T> *) vec_stack_p_reserve_exact_1 (alloc_, space);\n+  return static_cast <vec_t<T> *> (vec_stack_p_reserve_exact_1 (nelems, space));\n }\n \n \n-/* Free a vector.\n-   void VEC_T_A_free(VEC(T,A) *&);\n-\n-   Free a vector and set it to NULL.  */\n-\n-#define VEC_free(T,A,V)\t\t(VEC_free_1<T, A> (&V))\n+/* Free vector *V and set it to NULL.  */\n \n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_free_1 (vec_t<T> **vec_)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::free (vec_t<T> **v)\n {\n-  if (*vec_)\n+  if (*v)\n     {\n       if (A == heap)\n-\tvec_heap_free (*vec_);\n+\tvec_heap_free (*v);\n       else if (A == gc)\n-\tggc_free (*vec_);\n+\tggc_free (*v);\n       else if (A == stack)\n-\tvec_stack_free (*vec_);\n+\tvec_stack_free (*v);\n     }\n-  *vec_ = NULL;\n+  *v = NULL;\n }\n \n \n-/* Copy a vector.\n-   VEC(T,A) *VEC_T_A_copy(VEC(T) *);\n-\n-   Copy the live elements of a vector into a new vector.  The new and\n-   old vectors need not be allocated by the same mechanism.  */\n+/* Return a copy of this vector.  The new and old vectors need not be\n+   allocated by the same mechanism.  */\n \n-#define VEC_copy(T,A,V) (VEC_copy_1<T, A> (V MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline vec_t<T> *\n-VEC_copy_1 (vec_t<T> *vec_ MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+vec_t<T> *\n+vec_t<T>::copy (ALONE_MEM_STAT_DECL)\n {\n-  size_t len_ = vec_ ? vec_->prefix.num : 0;\n-  vec_t<T> *new_vec_ = NULL;\n+  unsigned len = VEC_length (T, this);\n+  vec_t<T> *new_vec = NULL;\n \n-  if (len_)\n+  if (len)\n     {\n-      new_vec_ = vec_reserve_exact<T, A> (NULL, len_ PASS_MEM_STAT);\n-      new_vec_->prefix.num = len_;\n-      memcpy (new_vec_->vec, vec_->vec, sizeof (T) * len_);\n+      new_vec = vec_t<T>::reserve_exact<A> (NULL, len PASS_MEM_STAT);\n+      new_vec->embedded_init (len, len);\n+      memcpy (new_vec->address (), vec_, sizeof (T) * len);\n     }\n-  return new_vec_;\n-}\n-\n \n-/* Determine if a vector has additional capacity.\n+  return new_vec;\n+}\n \n-   int VEC_T_space (VEC(T) *v,int reserve)\n \n-   If V has space for RESERVE additional entries, return nonzero.  You\n-   usually only need to use this if you are doing your own vector\n-   reallocation, for instance on an embedded vector.  This returns\n-   nonzero in exactly the same circumstances that VEC_T_reserve\n+/* If this vector has space for RESERVE additional entries, return\n+   true.  You usually only need to use this if you are doing your\n+   own vector reallocation, for instance on an embedded vector.  This\n+   returns true in exactly the same circumstances that vec_reserve\n    will.  */\n \n-#define VEC_space(T,V,R)\t(VEC_space_1<T> (V, R VEC_CHECK_INFO))\n-\n template<typename T>\n-static inline int\n-VEC_space_1 (vec_t<T> *vec_, int alloc_ VEC_CHECK_DECL)\n+bool\n+vec_t<T>::space (int nelems VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\n-  return vec_\n-\t ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_\n-\t : !alloc_;\n+  VEC_ASSERT (nelems >= 0, \"space\", T, base);\n+  return prefix_.alloc_ - prefix_.num_ >= static_cast <unsigned> (nelems);\n }\n \n \n-/* Reserve space.\n-   int VEC_T_A_reserve(VEC(T,A) *&v, int reserve);\n-\n-   Ensure that V has at least RESERVE slots available.  This will\n-   create additional headroom.  Note this can cause V to be\n-   reallocated.  Returns nonzero iff reallocation actually\n-   occurred.  */\n+/* Ensure that the vector **VEC has at least RESERVE slots available.  This\n+   will create additional headroom.  Note this can cause **VEC to\n+   be reallocated.  Returns true iff reallocation actually occurred.  */\n \n-#define VEC_reserve(T,A,V,R)\t\\\n-  \t(VEC_reserve_1<T, A> (&(V), (int)(R) VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline int\n-VEC_reserve_1 (vec_t<T> **vec_, int alloc_  VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+bool\n+vec_t<T>::reserve (vec_t<T> **vec, int nelems VEC_CHECK_DECL MEM_STAT_DECL)\n {\n-  int extend = !VEC_space_1 (*vec_, alloc_ VEC_CHECK_PASS);\n+  bool extend = (*vec) ? !(*vec)->space (nelems VEC_CHECK_PASS) : nelems != 0;\n \n   if (extend)\n-    *vec_ = vec_reserve<T, A> (*vec_, alloc_ PASS_MEM_STAT);\n+    *vec = vec_t<T>::reserve<A> (*vec, nelems PASS_MEM_STAT);\n \n   return extend;\n }\n \n \n-/* Reserve space exactly.\n-   int VEC_T_A_reserve_exact(VEC(T,A) *&v, int reserve);\n-\n-   Ensure that V has at least RESERVE slots available.  This will not\n-   create additional headroom.  Note this can cause V to be\n-   reallocated.  Returns nonzero iff reallocation actually\n-   occurred.  */\n+/* Ensure that **VEC has at least NELEMS slots available.  This will not\n+   create additional headroom.  Note this can cause VEC to be\n+   reallocated.  Returns true iff reallocation actually occurred.  */\n \n-#define VEC_reserve_exact(T,A,V,R)\t\\\n-\t(VEC_reserve_exact_1<T, A> (&(V), R VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline int\n-VEC_reserve_exact_1 (vec_t<T> **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+bool\n+vec_t<T>::reserve_exact (vec_t<T> **vec, int nelems VEC_CHECK_DECL\n+\t\t\t MEM_STAT_DECL)\n {\n-  int extend = !VEC_space_1 (*vec_, alloc_ VEC_CHECK_PASS);\n+  bool extend = (*vec) ? !(*vec)->space (nelems VEC_CHECK_PASS) : nelems != 0;\n \n   if (extend)\n-    *vec_ = vec_reserve_exact<T, A> (*vec_, alloc_ PASS_MEM_STAT);\n+    *vec = vec_t<T>::reserve_exact<A> (*vec, nelems PASS_MEM_STAT);\n \n   return extend;\n }\n \n \n-/* Copy elements with no reallocation\n-   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Integer\n-   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Pointer\n-   void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Object\n-\n-   Copy the elements in SRC to the end of DST as if by memcpy.  DST and\n-   SRC need not be allocated with the same mechanism, although they most\n-   often will be.  DST is assumed to have sufficient headroom\n-   available.  */\n-\n-#define VEC_splice(T,DST,SRC)\t(VEC_splice_1<T> (DST, SRC VEC_CHECK_INFO))\n+/* Copy the elements from SRC to the end of this vector as if by memcpy.\n+   SRC and this vector need not be allocated with the same mechanism,\n+   although they most often will be.  This vector is assumed to have\n+   sufficient headroom available.  */\n \n template<typename T>\n-static inline void\n-VEC_splice_1 (vec_t<T> *dst_, vec_t<T> *src_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::splice (vec_t<T> *src VEC_CHECK_DECL)\n {\n-  if (src_)\n+  if (src)\n     {\n-      unsigned len_ = src_->prefix.num;\n-      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\",\n-\t\t  T, base);\n-\n-      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\n-      dst_->prefix.num += len_;\n+      unsigned len = VEC_length (T, src);\n+      VEC_ASSERT (VEC_length (T, this) + len <= prefix_.alloc_, \"splice\", T,\n+\t\t  base);\n+      memcpy (address () + VEC_length (T, this),\n+\t      src->address (),\n+\t      len * sizeof (T));\n+      prefix_.num_ += len;\n     }\n }\n \n \n-/* Copy elements with reallocation\n-   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Integer\n-   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Pointer\n-   void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Object\n-\n-   Copy the elements in SRC to the end of DST as if by memcpy.  DST and\n+/* Copy the elements in SRC to the end of DST as if by memcpy.  DST and\n    SRC need not be allocated with the same mechanism, although they most\n    often will be.  DST need not have sufficient headroom and will be\n    reallocated if needed.  */\n \n-#define VEC_safe_splice(T,A,DST,SRC)\t\t\t\t\t\\\n-\t(VEC_safe_splice_1<T, A> (&(DST), SRC VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_safe_splice_1 (vec_t<T> **dst_, vec_t<T> *src_ VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::safe_splice (vec_t<T> **dst, vec_t<T> *src VEC_CHECK_DECL\n+\t\t       MEM_STAT_DECL)\n {\n-  if (src_)\n+  if (src)\n     {\n-      VEC_reserve_exact_1<T, A> (dst_, src_->prefix.num\n-\t\t\t\t VEC_CHECK_PASS MEM_STAT_INFO);\n-\n-      VEC_splice_1 (*dst_, src_ VEC_CHECK_PASS);\n+      vec_t<T>::reserve_exact<A> (dst, VEC_length (T, src) VEC_CHECK_PASS\n+\t\t\t          MEM_STAT_INFO);\n+      (*dst)->splice (src VEC_CHECK_PASS);\n     }\n }\n \n   \n-/* Push object with no reallocation\n-   T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n-   T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n-   T *VEC_T_quick_push (VEC(T) *v, T *obj); // Object\n-\n-   Push a new element onto the end, returns a pointer to the slot\n-   filled in. For object vectors, the new value can be NULL, in which\n-   case NO initialization is performed.  There must\n-   be sufficient space in the vector.  */\n-\n-#define VEC_quick_push(T,V,O)\t(VEC_quick_push_1<T> (V, O VEC_CHECK_INFO))\n+/* Push OBJ (a new element) onto the end, returns a reference to the slot\n+   filled in.  There must be sufficient space in the vector.  */\n \n template<typename T>\n-static inline T &\n-VEC_quick_push_1 (vec_t<T> *vec_, T obj_ VEC_CHECK_DECL)\n+T &\n+vec_t<T>::quick_push (T obj VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\n-  vec_->vec[vec_->prefix.num] = obj_;\n-  T &val_ = vec_->vec[vec_->prefix.num];\n-  vec_->prefix.num++;\n-  return val_;\n+  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"push\", T, base);\n+  vec_[prefix_.num_] = obj;\n+  T &val = vec_[prefix_.num_];\n+  prefix_.num_++;\n+  return val;\n }\n \n+\n+/* Push PTR (a new pointer to an element) onto the end, returns a\n+   pointer to the slot filled in. The new value can be NULL, in which\n+   case NO initialization is performed.  There must be sufficient\n+   space in the vector.  */\n+\n template<typename T>\n-static inline T *\n-VEC_quick_push_1 (vec_t<T> *vec_, const T *ptr_ VEC_CHECK_DECL)\n+T *\n+vec_t<T>::quick_push (const T *ptr VEC_CHECK_DECL)\n {\n-  T *slot_;\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\n-  slot_ = &vec_->vec[vec_->prefix.num++];\n-  if (ptr_)\n-    *slot_ = *ptr_;\n-  return slot_;\n+  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"push\", T, base);\n+  T *slot = &vec_[prefix_.num_++];\n+  if (ptr)\n+    *slot = *ptr;\n+  return slot;\n }\n \n \n-/* Push object with reallocation\n-   T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Integer\n-   T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Pointer\n-   T *VEC_T_A_safe_push (VEC(T,A) *&v, T *obj); // Object\n-\n-   Push a new element onto the end, returns a pointer to the slot\n-   filled in. For object vectors, the new value can be NULL, in which\n-   case NO initialization is performed.  Reallocates V, if needed.  */\n+/* Push a new element OBJ onto the end of VEC.  Returns a reference to\n+   the slot filled in.  Reallocates V, if needed.  */\n \n-#define VEC_safe_push(T,A,V,O)\t\t\\\n-\t(VEC_safe_push_1<T, A> (&(V), O VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline T &\n-VEC_safe_push_1 (vec_t<T> **vec_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+T &\n+vec_t<T>::safe_push (vec_t<T> **vec, T obj VEC_CHECK_DECL MEM_STAT_DECL)\n {\n-  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  return VEC_quick_push_1 (*vec_, obj_ VEC_CHECK_PASS);\n+  vec_t<T>::reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  return (*vec)->quick_push (obj VEC_CHECK_PASS);\n }\n \n-template<typename T, enum vec_allocation_t A>\n-static inline T *\n-VEC_safe_push_1 (vec_t<T> **vec_, const T *ptr_ VEC_CHECK_DECL MEM_STAT_DECL)\n+\n+/* Push a pointer PTR to a new element onto the end of VEC.  Returns a\n+   pointer to the slot filled in. For object vectors, the new value\n+   can be NULL, in which case NO initialization is performed.\n+   Reallocates VEC, if needed.  */\n+\n+template<typename T>\n+template<enum vec_allocation_t A>\n+T *\n+vec_t<T>::safe_push (vec_t<T> **vec, const T *ptr VEC_CHECK_DECL MEM_STAT_DECL)\n {\n-  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  return VEC_quick_push_1 (*vec_, ptr_ VEC_CHECK_PASS);\n+  vec_t<T>::reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  return (*vec)->quick_push (ptr VEC_CHECK_PASS);\n }\n \n \n-/* Pop element off end\n-   T VEC_T_pop (VEC(T) *v);\t\t// Integer\n-   T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n-   void VEC_T_pop (VEC(T) *v);\t\t// Object\n+/* Pop and return the last element off the end of the vector.  */\n \n-   Pop the last element off the end. Returns the element popped, for\n-   pointer vectors.  */\n-\n-#define VEC_pop(T,V)\t(VEC_pop_1<T> (V VEC_CHECK_INFO))\n \n template<typename T>\n-static inline T&\n-VEC_pop_1 (vec_t<T> *vec_ VEC_CHECK_DECL)\n+T &\n+vec_t<T>::pop (ALONE_VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\n-  return vec_->vec[--vec_->prefix.num];\n+  VEC_ASSERT (prefix_.num_, \"pop\", T, base);\n+  return vec_[--prefix_.num_];\n }\n \n \n-/* Truncate to specific length\n-   void VEC_T_truncate (VEC(T) *v, unsigned len);\n-\n-   Set the length as specified.  The new length must be less than or\n-   equal to the current length.  This is an O(1) operation.  */\n-\n-#define VEC_truncate(T,V,I)\t\\\n-\t(VEC_truncate_1<T> (V, (unsigned)(I) VEC_CHECK_INFO))\n+/* Set the length of the vector to LEN.  The new length must be less\n+   than or equal to the current length.  This is an O(1) operation.  */\n \n template<typename T>\n-static inline void\n-VEC_truncate_1 (vec_t<T> *vec_, unsigned size_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::truncate (unsigned size VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\n-  if (vec_)\n-    vec_->prefix.num = size_;\n+  VEC_ASSERT (prefix_.num_ >= size, \"truncate\", T, base);\n+  prefix_.num_ = size;\n }\n \n \n-/* Grow to a specific length.\n-   void VEC_T_A_safe_grow (VEC(T,A) *&v, int len);\n-\n-   Grow the vector to a specific length.  The LEN must be as\n+/* Grow the vector VEC to a specific length.  The LEN must be as\n    long or longer than the current length.  The new elements are\n    uninitialized.  */\n \n-#define VEC_safe_grow(T,A,V,I)\t\t\\\n-\t(VEC_safe_grow_1<T, A> (&(V), (int)(I) VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_safe_grow_1 (vec_t<T> **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::safe_grow (vec_t<T> **vec, int size VEC_CHECK_DECL MEM_STAT_DECL)\n {\n-  VEC_ASSERT (size_ >= 0 && VEC_length (T, *vec_) <= (unsigned)size_,\n+  VEC_ASSERT (size >= 0 && VEC_length (T, *vec) <= (unsigned)size,\n \t      \"grow\", T, A);\n-  VEC_reserve_exact_1<T, A> (vec_,\n-\t\t\t     size_ - (int)(*vec_ ? (*vec_)->prefix.num : 0)\n-\t\t\t     VEC_CHECK_PASS PASS_MEM_STAT);\n-  (*vec_)->prefix.num = size_;\n+  vec_t<T>::reserve_exact<A> (vec, size - (int)VEC_length (T, *vec)\n+\t\t              VEC_CHECK_PASS PASS_MEM_STAT);\n+  (*vec)->prefix_.num_ = size;\n }\n \n \n-/* Grow to a specific length.\n-   void VEC_T_A_safe_grow_cleared (VEC(T,A) *&v, int len);\n-\n-   Grow the vector to a specific length.  The LEN must be as\n+/* Grow the vector *VEC to a specific length.  The LEN must be as\n    long or longer than the current length.  The new elements are\n    initialized to zero.  */\n \n-#define VEC_safe_grow_cleared(T,A,V,I)\t\t\t\\\n-\t(VEC_safe_grow_cleared_1<T,A> (&(V), (int)(I)\t\\\n-\t\t\t\t       VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_safe_grow_cleared_1 (vec_t<T> **vec_, int size_ VEC_CHECK_DECL\n-\t\t\t MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::safe_grow_cleared (vec_t<T> **vec, int size VEC_CHECK_DECL\n+\t\t\t     MEM_STAT_DECL)\n {\n-  int oldsize = VEC_length (T, *vec_);\n-  VEC_safe_grow_1<T, A> (vec_, size_ VEC_CHECK_PASS PASS_MEM_STAT);\n-  memset (&(VEC_address (T, *vec_)[oldsize]), 0,\n-\t  sizeof (T) * (size_ - oldsize));\n+  int oldsize = VEC_length (T, *vec);\n+  vec_t<T>::safe_grow<A> (vec, size VEC_CHECK_PASS PASS_MEM_STAT);\n+  memset (&((*vec)->address ()[oldsize]), 0, sizeof (T) * (size - oldsize));\n }\n \n \n-/* Replace element\n-   T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Integer\n-   T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Pointer\n-   T *VEC_T_replace (VEC(T) *v, unsigned ix, T *val);  // Object\n-\n-   Replace the IXth element of V with a new value, VAL.  For pointer\n-   vectors returns the original value. For object vectors returns a\n-   pointer to the new value.  For object vectors the new value can be\n-   NULL, in which case no overwriting of the slot is actually\n-   performed.  */\n-\n-#define VEC_replace(T,V,I,O)\t\t\\\n-\t(VEC_replace_1<T> (V, (unsigned)(I), O VEC_CHECK_INFO))\n+/* Replace the IXth element of this vector with a new value, VAL.  */\n \n template<typename T>\n-static inline T&\n-VEC_replace_1 (vec_t<T> *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::replace (unsigned ix, T obj VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\n-  vec_->vec[ix_] = obj_;\n-  return vec_->vec[ix_];\n+  VEC_ASSERT (ix < prefix_.num_, \"replace\", T, base);\n+  vec_[ix] = obj;\n }\n \n \n-/* Insert object with no reallocation\n-   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Integer\n-   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n-   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T *val); // Object\n+/* Insert an element, OBJ, at the IXth position of VEC.  There must be\n+   sufficient space.  */\n \n-   Insert an element, VAL, at the IXth position of V.  For vectors of\n-   object, the new value can be NULL, in which case no initialization\n-   of the inserted slot takes place. There must be sufficient space.  */\n+template<typename T>\n+void\n+vec_t<T>::quick_insert (unsigned ix, T obj VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"insert\", T, base);\n+  VEC_ASSERT (ix <= prefix_.num_, \"insert\", T, base);\n+  T *slot = &vec_[ix];\n+  memmove (slot + 1, slot, (prefix_.num_++ - ix) * sizeof (T));\n+  *slot = obj;\n+}\n \n-#define VEC_quick_insert(T,V,I,O)\t\\\n-\t(VEC_quick_insert_1<T> (V,I,O VEC_CHECK_INFO))\n+\n+/* Insert an element, *PTR, at the IXth position of V.  The new value\n+   can be NULL, in which case no initialization of the inserted slot\n+   takes place. There must be sufficient space.  */\n \n template<typename T>\n-static inline void\n-VEC_quick_insert_1 (vec_t<T> *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::quick_insert (unsigned ix, const T *ptr VEC_CHECK_DECL)\n {\n-  T *slot_;\n-\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\n-  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\n-  slot_ = &vec_->vec[ix_];\n-  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\n-  *slot_ = obj_;\n+  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"insert\", T, base);\n+  VEC_ASSERT (ix <= prefix_.num_, \"insert\", T, base);\n+  T *slot = &vec_[ix];\n+  memmove (slot + 1, slot, (prefix_.num_++ - ix) * sizeof (T));\n+  if (ptr)\n+    *slot = *ptr;\n }\n \n+\n+/* Insert an element, VAL, at the IXth position of VEC. Reallocate\n+   VEC, if necessary.  */\n+\n template<typename T>\n-static inline void\n-VEC_quick_insert_1 (vec_t<T> *vec_, unsigned ix_, const T *ptr_ VEC_CHECK_DECL)\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::safe_insert (vec_t<T> **vec, unsigned ix, T obj VEC_CHECK_DECL\n+\t\t       MEM_STAT_DECL)\n {\n-  T *slot_;\n-\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\n-  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\n-  slot_ = &vec_->vec[ix_];\n-  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\n-  if (ptr_)\n-    *slot_ = *ptr_;\n+  vec_t<T>::reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  (*vec)->quick_insert (ix, obj VEC_CHECK_PASS);\n }\n \n \n-/* Insert object with reallocation\n-   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Integer\n-   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Pointer\n-   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T *val); // Object\n-\n-   Insert an element, VAL, at the IXth position of V. Return a pointer\n+/* Insert an element, *PTR, at the IXth position of VEC. Return a pointer\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n    place. Reallocate V, if necessary.  */\n \n-#define VEC_safe_insert(T,A,V,I,O)\t\\\n-\t(VEC_safe_insert_1<T, A> (&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_safe_insert_1 (vec_t<T> **vec_, unsigned ix_, T obj_\n-\t\t   VEC_CHECK_DECL MEM_STAT_DECL)\n-{\n-  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  VEC_quick_insert_1 (*vec_, ix_, obj_ VEC_CHECK_PASS);\n-}\n-\n-template<typename T, enum vec_allocation_t A>\n-static inline void\n-VEC_safe_insert_1 (vec_t<T> **vec_, unsigned ix_, T *ptr_\n-\t\t   VEC_CHECK_DECL MEM_STAT_DECL)\n+template<typename T>\n+template<enum vec_allocation_t A>\n+void\n+vec_t<T>::safe_insert (vec_t<T> **vec, unsigned ix, T *ptr VEC_CHECK_DECL\n+\t\t       MEM_STAT_DECL)\n {\n-  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  VEC_quick_insert_1 (*vec_, ix_, ptr_ VEC_CHECK_PASS);\n+  vec_t<T>::reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  (*vec)->quick_insert (ix, ptr VEC_CHECK_PASS);\n }\n \n \n-\n-/* Remove element retaining order\n-   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n-   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Object\n-\n-   Remove an element from the IXth position of V. Ordering of\n+/* Remove an element from the IXth position of this vector.  Ordering of\n    remaining elements is preserved.  This is an O(N) operation due to\n    a memmove.  */\n \n-#define VEC_ordered_remove(T,V,I)\t\\\n-\t(VEC_ordered_remove_1<T> (V,I VEC_CHECK_INFO))\n-\n template<typename T>\n-static inline void\n-VEC_ordered_remove_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::ordered_remove (unsigned ix VEC_CHECK_DECL)\n {\n-  T *slot_;\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\n-  slot_ = &vec_->vec[ix_];\n-  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));\n+  VEC_ASSERT (ix < prefix_.num_, \"remove\", T, base);\n+  T *slot = &vec_[ix];\n+  memmove (slot, slot + 1, (--prefix_.num_ - ix) * sizeof (T));\n }\n \n \n-/* Remove element destroying order\n-   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n-   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Object\n-\n-   Remove an element from the IXth position of V.  Ordering of\n+/* Remove an element from the IXth position of VEC.  Ordering of\n    remaining elements is destroyed.  This is an O(1) operation.  */\n \n-#define VEC_unordered_remove(T,V,I)\t\\\n-\t(VEC_unordered_remove_1<T> (V,I VEC_CHECK_INFO))\n-\n template<typename T>\n-static inline void\n-VEC_unordered_remove_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::unordered_remove (unsigned ix VEC_CHECK_DECL)\n {\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\n-  vec_->vec[ix_] = vec_->vec[--vec_->prefix.num];\n+  VEC_ASSERT (ix < prefix_.num_, \"remove\", T, base);\n+  vec_[ix] = vec_[--prefix_.num_];\n }\n \n \n-/* Remove a block of elements\n-   void VEC_T_block_remove (VEC(T) *v, unsigned ix, unsigned len);\n-\n-   Remove LEN elements starting at the IXth.  Ordering is retained.\n+/* Remove LEN elements starting at the IXth.  Ordering is retained.\n    This is an O(N) operation due to memmove.  */\n \n-#define VEC_block_remove(T,V,I,L)\t\\\n-\t(VEC_block_remove_1<T> (V, I, L VEC_CHECK_INFO))\n-\n template<typename T>\n-static inline void\n-VEC_block_remove_1 (vec_t<T> *vec_, unsigned ix_, unsigned len_ VEC_CHECK_DECL)\n+void\n+vec_t<T>::block_remove (unsigned ix, unsigned len VEC_CHECK_DECL)\n {\n-  T *slot_;\n-  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\n-  slot_ = &vec_->vec[ix_];\n-  vec_->prefix.num -= len_;\n-  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\n+  VEC_ASSERT (ix + len <= prefix_.num_, \"block_remove\", T, base);\n+  T *slot = &vec_[ix];\n+  prefix_.num_ -= len;\n+  memmove (slot, slot + len, (prefix_.num_ - ix) * sizeof (T));\n }\n \n+/* Sort the contents of V with qsort.  Use CMP as the comparison function.  */\n+#define VEC_qsort(T,V,CMP)\t\t\t\t\t\t\\\n+\tqsort (VEC_address (T, V), VEC_length (T, V), sizeof (T), CMP)\n \n-/* Conveniently sort the contents of the vector with qsort.\n-   void VEC_qsort (VEC(T) *v, int (*cmp_func)(const void *, const void *))  */\n-\n-#define VEC_qsort(T,V,CMP) qsort(VEC_address (T, V), VEC_length (T, V),\t\\\n-\t\t\t\t sizeof (T), CMP)\n-\n-\n-/* Find the first index in the vector not less than the object.\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T val,\n-                               bool (*lessthan) (const T, const T)); // Integer\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T val,\n-                               bool (*lessthan) (const T, const T)); // Pointer\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T *val,\n-                               bool (*lessthan) (const T*, const T*)); // Object\n \n-   Find the first position in which VAL could be inserted without\n-   changing the ordering of V.  LESSTHAN is a function that returns\n-   true if the first argument is strictly less than the second.  */\n-\n-#define VEC_lower_bound(T,V,O,LT)\t\\\n-        (VEC_lower_bound_1<T> (V, O, LT VEC_CHECK_INFO))\n+/* Find and return the first position in which OBJ could be inserted\n+   without changing the ordering of this vector.  LESSTHAN is a\n+   function that returns true if the first argument is strictly less\n+   than the second.  */\n \n template<typename T>\n-static inline unsigned\n-VEC_lower_bound_1 (vec_t<T> *vec_, T obj_,\n-\t\t   bool (*lessthan_)(T, T) VEC_CHECK_DECL)\n+unsigned\n+vec_t<T>::lower_bound (T obj, bool (*lessthan)(T, T)) const\n {\n-  unsigned int len_ = VEC_length (T, vec_);\n-  unsigned int half_, middle_;\n-  unsigned int first_ = 0;\n-  while (len_ > 0)\n+  unsigned int len = VEC_length (T, this);\n+  unsigned int half, middle;\n+  unsigned int first = 0;\n+  while (len > 0)\n     {\n-      T middle_elem_;\n-      half_ = len_ >> 1;\n-      middle_ = first_;\n-      middle_ += half_;\n-      middle_elem_ = VEC_index_1 (vec_, middle_ VEC_CHECK_PASS);\n-      if (lessthan_ (middle_elem_, obj_))\n+      half = len >> 1;\n+      middle = first;\n+      middle += half;\n+      T middle_elem = (*this)[middle];\n+      if (lessthan (middle_elem, obj))\n \t{\n-\t  first_ = middle_;\n-\t  ++first_;\n-\t  len_ = len_ - half_ - 1;\n+\t  first = middle;\n+\t  ++first;\n+\t  len = len - half - 1;\n \t}\n       else\n-\tlen_ = half_;\n+\tlen = half;\n     }\n-  return first_;\n+  return first;\n }\n \n+\n+/* Find and return the first position in which *PTR could be inserted\n+   without changing the ordering of this vector.  LESSTHAN is a\n+   function that returns true if the first argument is strictly less\n+   than the second.  */\n+\n template<typename T>\n-static inline unsigned\n-VEC_lower_bound_1 (vec_t<T> *vec_, const T *ptr_,\n-\t\t   bool (*lessthan_)(const T*, const T*) VEC_CHECK_DECL)\n+unsigned\n+vec_t<T>::lower_bound (const T *ptr,\n+\t\t       bool (*lessthan_)(const T *, const T *)) const\n {\n-  unsigned int len_ = VEC_length (T, vec_);\n-  unsigned int half_, middle_;\n-  unsigned int first_ = 0;\n-  while (len_ > 0)\n+  unsigned int len = VEC_length (T, this);\n+  unsigned int half, middle;\n+  unsigned int first = 0;\n+  while (len > 0)\n     {\n-      T *middle_elem_;\n-      half_ = len_ >> 1;\n-      middle_ = first_;\n-      middle_ += half_;\n-      middle_elem_ = &VEC_index_1 (vec_, middle_ VEC_CHECK_PASS);\n-      if (lessthan_ (middle_elem_, ptr_))\n+      half = len >> 1;\n+      middle = first;\n+      middle += half;\n+      const T *middle_elem = &(*this)[middle];\n+      if (lessthan (middle_elem, ptr))\n \t{\n-\t  first_ = middle_;\n-\t  ++first_;\n-\t  len_ = len_ - half_ - 1;\n+\t  first = middle;\n+\t  ++first;\n+\t  len = len - half - 1;\n \t}\n       else\n-\tlen_ = half_;\n+\tlen = half;\n     }\n-  return first_;\n+  return first;\n }\n \n \n@@ -1084,62 +1107,62 @@ void *vec_gc_o_reserve_1 (void *, int, size_t, size_t, bool MEM_STAT_DECL);\n    exponentially.  As a special case, if VEC_ is NULL, and RESERVE is\n    0, no vector will be created. */\n \n-template<typename T, enum vec_allocation_t A>\n+template<typename T>\n+template<enum vec_allocation_t A>\n vec_t<T> *\n-vec_reserve (vec_t<T> *vec_, int reserve MEM_STAT_DECL)\n+vec_t<T>::reserve (vec_t<T> *vec, int reserve MEM_STAT_DECL)\n {\n-  if (A == gc)\n-    return (vec_t<T> *) vec_gc_o_reserve_1 (vec_, reserve,\n-\t\t\t\t\t    offsetof (vec_t<T>, vec),\n-\t\t\t\t\t    sizeof (T), false\n-\t\t\t\t\t    PASS_MEM_STAT);\n-  else if (A == heap)\n-    return (vec_t<T> *) vec_heap_o_reserve_1 (vec_, reserve,\n-\t\t\t\t\t      offsetof (vec_t<T>, vec),\n-\t\t\t\t\t      sizeof (T), false\n-\t\t\t\t\t      PASS_MEM_STAT);\n-  else\n-    return (vec_t<T> *) vec_stack_o_reserve (vec_, reserve,\n-\t\t\t\t\t     offsetof (vec_t<T>, vec),\n-\t\t\t\t\t     sizeof (T) PASS_MEM_STAT);\n+  void *res = NULL;\n+  size_t off = offsetof (vec_t<T>, vec_);\n+  size_t sz = sizeof (T);\n+\n+  switch (A)\n+    {\n+      case gc:\n+\tres = vec_gc_o_reserve_1 (vec, reserve, off, sz, false PASS_MEM_STAT);\n+\tbreak;\n+      case heap:\n+\tres = vec_heap_o_reserve_1 (vec, reserve, off, sz, false PASS_MEM_STAT);\n+\tbreak;\n+      case stack:\n+\tres = vec_stack_o_reserve (vec, reserve, off, sz PASS_MEM_STAT);\n+\tbreak;\n+    }\n+\n+  return static_cast <vec_t<T> *> (res);\n }\n \n \n-/* Ensure there are at least RESERVE free slots in VEC_, growing\n+/* Ensure there are at least RESERVE free slots in VEC, growing\n    exactly.  If RESERVE < 0 grow exactly, else grow exponentially.  As\n-   a special case, if VEC_ is NULL, and RESERVE is 0, no vector will be\n+   a special case, if VEC is NULL, and RESERVE is 0, no vector will be\n    created. */\n \n-template<typename T, enum vec_allocation_t A>\n+template<typename T>\n+template<enum vec_allocation_t A>\n vec_t<T> *\n-vec_reserve_exact (vec_t<T> *vec_, int reserve MEM_STAT_DECL)\n+vec_t<T>::reserve_exact (vec_t<T> *vec, int reserve MEM_STAT_DECL)\n {\n-  if (A == gc)\n-    return (vec_t<T> *) vec_gc_o_reserve_1 (vec_, reserve,\n-\t\t\t\t\t    sizeof (struct vec_prefix),\n-\t\t\t\t\t    sizeof (T), true\n-\t\t\t\t\t    PASS_MEM_STAT);\n-  else if (A == heap)\n-    return (vec_t<T> *) vec_heap_o_reserve_1 (vec_, reserve,\n-\t\t\t\t\t      sizeof (struct vec_prefix),\n-\t\t\t\t\t      sizeof (T), true\n-\t\t\t\t\t      PASS_MEM_STAT);\n-  else if (A == stack)\n+  void *res = NULL;\n+  size_t off = sizeof (struct vec_prefix);\n+  size_t sz = sizeof (T);\n+\n+  gcc_assert (offsetof (vec_t<T>, vec_) == sizeof (struct vec_prefix));\n+\n+  switch (A)\n     {\n-      /* Only allow stack vectors when re-growing them.  The initial\n-\t allocation of stack vectors must be done with VEC_alloc,\n-\t because it uses alloca() for the allocation.  */\n-      if (vec_ == NULL)\n-\t{\n-\t  fprintf (stderr, \"Stack vectors must be initially allocated \"\n-\t\t   \"with VEC_stack_alloc.\\n\");\n-\t  gcc_unreachable ();\n-\t}\n-      return (vec_t<T> *) vec_stack_o_reserve_exact (vec_, reserve,\n-\t\t\t\t\t\t     sizeof (struct vec_prefix),\n-\t\t\t\t\t\t     sizeof (T)\n-\t\t\t\t\t\t     PASS_MEM_STAT);\n+      case gc:\n+\tres = vec_gc_o_reserve_1 (vec, reserve, off, sz, true PASS_MEM_STAT);\n+\tbreak;\n+      case heap:\n+\tres = vec_heap_o_reserve_1 (vec, reserve, off, sz, true PASS_MEM_STAT);\n+\tbreak;\n+      case stack:\n+\tres = vec_stack_o_reserve_exact (vec, reserve, off, sz PASS_MEM_STAT);\n+\tbreak;\n     }\n+\n+  return static_cast <vec_t<T> *> (res);\n }\n \n #endif /* GCC_VEC_H */"}]}