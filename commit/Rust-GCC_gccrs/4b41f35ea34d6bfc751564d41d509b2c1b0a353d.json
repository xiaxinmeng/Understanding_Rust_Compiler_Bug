{"sha": "4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI0MWYzNWVhMzRkNmJmYzc1MTU2NGQ0MWQ1MDliMmMxYjBhMzUzZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-07-09T09:42:34Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-07-09T09:42:34Z"}, "message": "re PR fortran/40604 (ICE with -fcheck=pointer)\n\n2009-07-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40604\n        * intrinsic.c (gfc_convert_type_warn): Set sym->result.\n        * trans-expr.c (gfc_conv_procedure_call): Fix -fcheck=pointer\n        for optional arguments.\n\n2009-07-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40604\n        * gfortran.dg/pointer_check_6.f90: New test.\n\nFrom-SVN: r149405", "tree": {"sha": "f8fab92988316790b4ce29576447c8884f3c0b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8fab92988316790b4ce29576447c8884f3c0b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fcaf7e12508287e62674b64bb2813930dfccb49b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcaf7e12508287e62674b64bb2813930dfccb49b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcaf7e12508287e62674b64bb2813930dfccb49b"}], "stats": {"total": 222, "additions": 201, "deletions": 21}, "files": [{"sha": "3f3feec92437f764e42dd3e3b2e7c2ddd890ef24", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "patch": "@@ -1,3 +1,10 @@\n+2009-07-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40604\n+\t* intrinsic.c (gfc_convert_type_warn): Set sym->result.\n+\t* trans-expr.c (gfc_conv_procedure_call): Fix -fcheck=pointer\n+\tfor optional arguments.\n+\n 2009-07-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40675"}, {"sha": "9402234b034f0e82b9e00d45b60ed1410def973e", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "patch": "@@ -3994,6 +3994,7 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n   new_expr->shape = gfc_copy_shape (shape, rank);\n \n   gfc_get_ha_sym_tree (sym->name, &new_expr->symtree);\n+  new_expr->symtree->n.sym->result = new_expr->symtree->n.sym;\n   new_expr->symtree->n.sym->ts = *ts;\n   new_expr->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n   new_expr->symtree->n.sym->attr.function = 1;"}, {"sha": "fe33286a402a16389f679046fafc43b0aa8118e5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "patch": "@@ -2784,37 +2784,86 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       /* Add argument checking of passing an unallocated/NULL actual to\n          a nonallocatable/nonpointer dummy.  */\n \n-      if (gfc_option.rtcheck & GFC_RTCHECK_POINTER)\n+      if (gfc_option.rtcheck & GFC_RTCHECK_POINTER && e != NULL)\n         {\n-\t  gfc_symbol *sym;\n+\t  symbol_attribute *attr;\n \t  char *msg;\n \t  tree cond;\n \n \t  if (e->expr_type == EXPR_VARIABLE)\n-\t    sym = e->symtree->n.sym;\n+\t    attr = &e->symtree->n.sym->attr;\n \t  else if (e->expr_type == EXPR_FUNCTION)\n-\t    sym = e->symtree->n.sym->result;\n-\t  else\n-\t    goto end_pointer_check;\n+\t    {\n+\t      /* For intrinsic functions, the gfc_attr are not available.  */\n+\t      if (e->symtree->n.sym->attr.generic && e->value.function.isym)\n+\t\tgoto end_pointer_check;\n \n-\t  if (sym->attr.allocatable\n-\t      && (fsym == NULL || !fsym->attr.allocatable))\n-\t    asprintf (&msg, \"Allocatable actual argument '%s' is not \"\n-\t\t      \"allocated\", sym->name);\n-\t  else if (sym->attr.pointer\n-\t      && (fsym == NULL || !fsym->attr.pointer))\n-\t    asprintf (&msg, \"Pointer actual argument '%s' is not \"\n-\t\t      \"associated\", sym->name);\n-          else if (sym->attr.proc_pointer\n-\t      && (fsym == NULL || !fsym->attr.proc_pointer))\n-\t    asprintf (&msg, \"Proc-pointer actual argument '%s' is not \"\n-\t\t      \"associated\", sym->name);\n+\t      if (e->symtree->n.sym->attr.generic)\n+\t\tattr = &e->value.function.esym->attr;\n+\t      else\n+\t\tattr = &e->symtree->n.sym->result->attr;\n+\t    }\n \t  else\n \t    goto end_pointer_check;\n \n-\t  cond  = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n-\t\t\t       fold_convert (TREE_TYPE (parmse.expr),\n-\t\t\t\t\t     null_pointer_node));\n+          if (attr->optional)\n+\t    {\n+              /* If the actual argument is an optional pointer/allocatable and\n+\t\t the formal argument takes an nonpointer optional value,\n+\t\t it is invalid to pass a non-present argument on, even\n+\t\t though there is no technical reason for this in gfortran.\n+\t\t See Fortran 2003, Section 12.4.1.6 item (7)+(8).  */\n+\t      tree present, nullptr, type;\n+\n+\t      if (attr->allocatable\n+\t\t  && (fsym == NULL || !fsym->attr.allocatable))\n+\t\tasprintf (&msg, \"Allocatable actual argument '%s' is not \"\n+\t\t\t  \"allocated or not present\", e->symtree->n.sym->name);\n+\t      else if (attr->pointer\n+\t\t       && (fsym == NULL || !fsym->attr.pointer))\n+\t\tasprintf (&msg, \"Pointer actual argument '%s' is not \"\n+\t\t\t  \"associated or not present\",\n+\t\t\t  e->symtree->n.sym->name);\n+\t      else if (attr->proc_pointer\n+\t\t       && (fsym == NULL || !fsym->attr.proc_pointer))\n+\t\tasprintf (&msg, \"Proc-pointer actual argument '%s' is not \"\n+\t\t\t  \"associated or not present\",\n+\t\t\t  e->symtree->n.sym->name);\n+\t      else\n+\t\tgoto end_pointer_check;\n+\n+\t      present = gfc_conv_expr_present (e->symtree->n.sym);\n+\t      type = TREE_TYPE (present);\n+\t      present = fold_build2 (EQ_EXPR, boolean_type_node, present,\n+\t\t\t\t     fold_convert (type, null_pointer_node));\n+\t      type = TREE_TYPE (parmse.expr);\n+\t      nullptr = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n+\t\t\t\t     fold_convert (type, null_pointer_node));\n+\t      cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t\t  present, nullptr);\n+\t    }\n+          else\n+\t    {\n+\t      if (attr->allocatable\n+\t\t  && (fsym == NULL || !fsym->attr.allocatable))\n+\t\tasprintf (&msg, \"Allocatable actual argument '%s' is not \"\n+\t\t      \"allocated\", e->symtree->n.sym->name);\n+\t      else if (attr->pointer\n+\t\t       && (fsym == NULL || !fsym->attr.pointer))\n+\t\tasprintf (&msg, \"Pointer actual argument '%s' is not \"\n+\t\t      \"associated\", e->symtree->n.sym->name);\n+\t      else if (attr->proc_pointer\n+\t\t       && (fsym == NULL || !fsym->attr.proc_pointer))\n+\t\tasprintf (&msg, \"Proc-pointer actual argument '%s' is not \"\n+\t\t      \"associated\", e->symtree->n.sym->name);\n+\t      else\n+\t\tgoto end_pointer_check;\n+\n+\n+\t      cond = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n+\t\t\t\t  fold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t\tnull_pointer_node));\n+\t    }\n  \n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &e->where,\n \t\t\t\t   msg);"}, {"sha": "63b2df4d0ce1950eb95de57944e4951bb0710aa7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "patch": "@@ -1,3 +1,8 @@\n+2009-07-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40604\n+\t* gfortran.dg/pointer_check_6.f90: New test.\n+\n 2009-07-08  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/truncate-5.c: New test."}, {"sha": "2f7373fe6ba2e39a80b927239f89e179b50107d7", "filename": "gcc/testsuite/gfortran.dg/pointer_check_6.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b41f35ea34d6bfc751564d41d509b2c1b0a353d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_6.f90?ref=4b41f35ea34d6bfc751564d41d509b2c1b0a353d", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+!\n+! { dg-shouldfail \"pointer check\" }\n+! { dg-output \".*At line 104 of file .*Fortran runtime error: Pointer actual argument 'a' is not associated.*\" }\n+!\n+! PR fortran/40604\n+!\n+! The following cases are all valid, but were failing\n+! for one or the other reason.\n+!\n+! Contributed by Janus Weil and Tobias Burnus.\n+!\n+\n+subroutine test1()\n+  call test(uec=-1)\n+contains \n+  subroutine test(str,uec)\n+    implicit none\n+    character*(*), intent(in), optional:: str\n+    integer, intent(in), optional :: uec\n+  end subroutine\n+end subroutine test1\n+\n+module m\n+  interface matrixMult\n+     Module procedure matrixMult_C2\n+  End Interface\n+contains\n+  subroutine test\n+    implicit none\n+    complex, dimension(0:3,0:3) :: m1,m2\n+    print *,Trace(MatrixMult(m1,m2))\n+  end subroutine\n+  complex function trace(a)\n+    implicit none\n+    complex, intent(in),  dimension(0:3,0:3) :: a \n+  end function trace\n+  function matrixMult_C2(a,b) result(matrix)\n+    implicit none\n+    complex, dimension(0:3,0:3) :: matrix,a,b\n+  end function matrixMult_C2\n+end module m\n+\n+SUBROUTINE plotdop(amat)\n+      IMPLICIT NONE\n+      REAL,    INTENT (IN) :: amat(3,3)\n+      integer :: i1\n+      real :: pt(3)\n+      i1 = 1\n+      pt = MATMUL(amat,(/i1,i1,i1/))\n+END SUBROUTINE plotdop\n+\n+        FUNCTION evaluateFirst(s,n)result(number)\n+          IMPLICIT NONE\n+          CHARACTER(len =*), INTENT(inout) :: s\n+          INTEGER,OPTIONAL                 :: n\n+          REAL                             :: number\n+          number = 1.1\n+        end function\n+\n+SUBROUTINE rw_inp(scpos)\n+      IMPLICIT NONE\n+      REAL scpos\n+\n+      interface\n+        FUNCTION evaluateFirst(s,n)result(number)\n+          IMPLICIT NONE\n+          CHARACTER(len =*), INTENT(inout) :: s\n+          INTEGER,OPTIONAL                 :: n\n+          REAL                             :: number\n+        end function\n+      end interface\n+\n+      CHARACTER(len=100) :: line\n+      scpos = evaluatefirst(line)\n+END SUBROUTINE rw_inp\n+\n+program test\n+  integer, pointer :: a\n+!  nullify(a)\n+  allocate(a)\n+  a = 1\n+  call sub1a(a)\n+  call sub1b(a)\n+  call sub1c()\n+contains\n+  subroutine sub1a(a)\n+   integer, pointer :: a\n+   call sub2(a)\n+   call sub3(a)\n+   call sub4(a)\n+  end subroutine sub1a\n+  subroutine sub1b(a)\n+   integer, pointer,optional :: a\n+   call sub2(a)\n+   call sub3(a)\n+   call sub4(a)\n+  end subroutine sub1b\n+  subroutine sub1c(a)\n+   integer, pointer,optional :: a\n+   call sub4(a)\n+!   call sub2(a)  ! << Invalid - working correctly, but not allowed in F2003\n+   call sub3(a) ! << INVALID\n+  end subroutine sub1c\n+  subroutine sub4(b)\n+    integer, optional,pointer :: b\n+  end subroutine\n+  subroutine sub2(b)\n+    integer, optional :: b\n+  end subroutine\n+  subroutine sub3(b)\n+    integer :: b\n+  end subroutine\n+end\n+\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}