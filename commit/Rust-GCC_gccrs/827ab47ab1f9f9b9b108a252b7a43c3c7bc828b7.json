{"sha": "827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3YWI0N2FiMWY5ZjliOWIxMDhhMjUyYjdhNDNjM2M3YmM4MjhiNw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2016-12-02T17:13:08Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2016-12-02T17:13:08Z"}, "message": "[AArch64] Separate shrink wrapping hooks implementation\n\n\t* config/aarch64/aarch64.h (machine_function): Add\n\treg_is_wrapped_separately field.\n\t* config/aarch64/aarch64.md (LAST_SAVED_REGNUM): Define new constant.\n\t* config/aarch64/aarch64.c (emit_set_insn): Change return type to\n\trtx_insn *.\n\t(aarch64_save_callee_saves): Don't save registers that are wrapped\n\tseparately.\n\t(aarch64_restore_callee_saves): Don't restore registers that are\n\twrapped separately.\n\t(offset_9bit_signed_unscaled_p, offset_12bit_unsigned_scaled_p,\n\taarch64_offset_7bit_signed_scaled_p): Move earlier in the file.\n\t(aarch64_get_separate_components): New function.\n\t(aarch64_get_next_set_bit): Likewise.\n\t(aarch64_components_for_bb): Likewise.\n\t(aarch64_disqualify_components): Likewise.\n\t(aarch64_emit_prologue_components): Likewise.\n\t(aarch64_emit_epilogue_components): Likewise.\n\t(aarch64_set_handled_components): Likewise.\n\t(aarch64_process_components): Likewise.\n\t(TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_COMPONENTS_FOR_BB,\n\tTARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS,\n\tTARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS): Define.\n\nFrom-SVN: r243200", "tree": {"sha": "d2beeb1022da22912b9274f88221d8f833ef454a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2beeb1022da22912b9274f88221d8f833ef454a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a87dced20fc6cc3951038df3bdc30e453af5fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a87dced20fc6cc3951038df3bdc30e453af5fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a87dced20fc6cc3951038df3bdc30e453af5fb9"}], "stats": {"total": 327, "additions": 303, "deletions": 24}, "files": [{"sha": "7957649de9a28974457d48ec858b3495a8700e05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "patch": "@@ -1,3 +1,31 @@\n+2016-12-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.h (machine_function): Add\n+\treg_is_wrapped_separately field.\n+\t* config/aarch64/aarch64.md (LAST_SAVED_REGNUM): Define new constant.\n+\t* config/aarch64/aarch64.c (emit_set_insn): Change return type to\n+\trtx_insn *.\n+\t(aarch64_save_callee_saves): Don't save registers that are wrapped\n+\tseparately.\n+\t(aarch64_restore_callee_saves): Don't restore registers that are\n+\twrapped separately.\n+\t(offset_9bit_signed_unscaled_p, offset_12bit_unsigned_scaled_p,\n+\taarch64_offset_7bit_signed_scaled_p): Move earlier in the file.\n+\t(aarch64_get_separate_components): New function.\n+\t(aarch64_get_next_set_bit): Likewise.\n+\t(aarch64_components_for_bb): Likewise.\n+\t(aarch64_disqualify_components): Likewise.\n+\t(aarch64_emit_prologue_components): Likewise.\n+\t(aarch64_emit_epilogue_components): Likewise.\n+\t(aarch64_set_handled_components): Likewise.\n+\t(aarch64_process_components): Likewise.\n+\t(TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_COMPONENTS_FOR_BB,\n+\tTARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS): Define.\n+\n 2016-12-02  Martin Jambor  <mjambor@suse.cz>\n \n \t* passes.def: Move pass_rebuild_cgraph_edges to the end of"}, {"sha": "af3aa0b895674a67164458cd26f12827b3243dbb", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 272, "deletions": 24, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "patch": "@@ -1137,7 +1137,7 @@ aarch64_is_extend_from_extract (machine_mode mode, rtx mult_imm,\n \n /* Emit an insn that's a simple single-set.  Both the operands must be\n    known to be valid.  */\n-inline static rtx\n+inline static rtx_insn *\n emit_set_insn (rtx x, rtx y)\n {\n   return emit_insn (gen_rtx_SET (x, y));\n@@ -3134,6 +3134,9 @@ aarch64_save_callee_saves (machine_mode mode, HOST_WIDE_INT start_offset,\n \t      || regno == cfun->machine->frame.wb_candidate2))\n \tcontinue;\n \n+      if (cfun->machine->reg_is_wrapped_separately[regno])\n+       continue;\n+\n       reg = gen_rtx_REG (mode, regno);\n       offset = start_offset + cfun->machine->frame.reg_offset[regno];\n       mem = gen_mem_ref (mode, plus_constant (Pmode, stack_pointer_rtx,\n@@ -3142,6 +3145,7 @@ aarch64_save_callee_saves (machine_mode mode, HOST_WIDE_INT start_offset,\n       regno2 = aarch64_next_callee_save (regno + 1, limit);\n \n       if (regno2 <= limit\n+\t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n \t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n \t      == cfun->machine->frame.reg_offset[regno2]))\n \n@@ -3190,6 +3194,9 @@ aarch64_restore_callee_saves (machine_mode mode,\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n+      if (cfun->machine->reg_is_wrapped_separately[regno])\n+       continue;\n+\n       rtx reg, mem;\n \n       if (skip_wb\n@@ -3204,6 +3211,7 @@ aarch64_restore_callee_saves (machine_mode mode,\n       regno2 = aarch64_next_callee_save (regno + 1, limit);\n \n       if (regno2 <= limit\n+\t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n \t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n \t      == cfun->machine->frame.reg_offset[regno2]))\n \t{\n@@ -3223,6 +3231,245 @@ aarch64_restore_callee_saves (machine_mode mode,\n     }\n }\n \n+static inline bool\n+offset_9bit_signed_unscaled_p (machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       HOST_WIDE_INT offset)\n+{\n+  return offset >= -256 && offset < 256;\n+}\n+\n+static inline bool\n+offset_12bit_unsigned_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n+{\n+  return (offset >= 0\n+\t  && offset < 4096 * GET_MODE_SIZE (mode)\n+\t  && offset % GET_MODE_SIZE (mode) == 0);\n+}\n+\n+bool\n+aarch64_offset_7bit_signed_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n+{\n+  return (offset >= -64 * GET_MODE_SIZE (mode)\n+\t  && offset < 64 * GET_MODE_SIZE (mode)\n+\t  && offset % GET_MODE_SIZE (mode) == 0);\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS.  */\n+\n+static sbitmap\n+aarch64_get_separate_components (void)\n+{\n+  aarch64_layout_frame ();\n+\n+  sbitmap components = sbitmap_alloc (LAST_SAVED_REGNUM + 1);\n+  bitmap_clear (components);\n+\n+  /* The registers we need saved to the frame.  */\n+  for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n+    if (aarch64_register_saved_on_entry (regno))\n+      {\n+\tHOST_WIDE_INT offset = cfun->machine->frame.reg_offset[regno];\n+\tif (!frame_pointer_needed)\n+\t  offset += cfun->machine->frame.frame_size\n+\t\t    - cfun->machine->frame.hard_fp_offset;\n+\t/* Check that we can access the stack slot of the register with one\n+\t   direct load with no adjustments needed.  */\n+\tif (offset_12bit_unsigned_scaled_p (DImode, offset))\n+\t  bitmap_set_bit (components, regno);\n+      }\n+\n+  /* Don't mess with the hard frame pointer.  */\n+  if (frame_pointer_needed)\n+    bitmap_clear_bit (components, HARD_FRAME_POINTER_REGNUM);\n+\n+  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  /* If aarch64_layout_frame has chosen registers to store/restore with\n+     writeback don't interfere with them to avoid having to output explicit\n+     stack adjustment instructions.  */\n+  if (reg2 != INVALID_REGNUM)\n+    bitmap_clear_bit (components, reg2);\n+  if (reg1 != INVALID_REGNUM)\n+    bitmap_clear_bit (components, reg1);\n+\n+  bitmap_clear_bit (components, LR_REGNUM);\n+  bitmap_clear_bit (components, SP_REGNUM);\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB.  */\n+\n+static sbitmap\n+aarch64_components_for_bb (basic_block bb)\n+{\n+  bitmap in = DF_LIVE_IN (bb);\n+  bitmap gen = &DF_LIVE_BB_INFO (bb)->gen;\n+  bitmap kill = &DF_LIVE_BB_INFO (bb)->kill;\n+\n+  sbitmap components = sbitmap_alloc (LAST_SAVED_REGNUM + 1);\n+  bitmap_clear (components);\n+\n+  /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n+  for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n+    if ((!call_used_regs[regno])\n+       && (bitmap_bit_p (in, regno)\n+\t   || bitmap_bit_p (gen, regno)\n+\t   || bitmap_bit_p (kill, regno)))\n+\t  bitmap_set_bit (components, regno);\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS.\n+   Nothing to do for aarch64.  */\n+\n+static void\n+aarch64_disqualify_components (sbitmap, edge, sbitmap, bool)\n+{\n+}\n+\n+/* Return the next set bit in BMP from START onwards.  Return the total number\n+   of bits in BMP if no set bit is found at or after START.  */\n+\n+static unsigned int\n+aarch64_get_next_set_bit (sbitmap bmp, unsigned int start)\n+{\n+  unsigned int nbits = SBITMAP_SIZE (bmp);\n+  if (start == nbits)\n+    return start;\n+\n+  gcc_assert (start < nbits);\n+  for (unsigned int i = start; i < nbits; i++)\n+    if (bitmap_bit_p (bmp, i))\n+      return i;\n+\n+  return nbits;\n+}\n+\n+/* Do the work for aarch64_emit_prologue_components and\n+   aarch64_emit_epilogue_components.  COMPONENTS is the bitmap of registers\n+   to save/restore, PROLOGUE_P indicates whether to emit the prologue sequence\n+   for these components or the epilogue sequence.  That is, it determines\n+   whether we should emit stores or loads and what kind of CFA notes to attach\n+   to the insns.  Otherwise the logic for the two sequences is very\n+   similar.  */\n+\n+static void\n+aarch64_process_components (sbitmap components, bool prologue_p)\n+{\n+  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed\n+\t\t\t     ? HARD_FRAME_POINTER_REGNUM\n+\t\t\t     : STACK_POINTER_REGNUM);\n+\n+  unsigned last_regno = SBITMAP_SIZE (components);\n+  unsigned regno = aarch64_get_next_set_bit (components, R0_REGNUM);\n+  rtx_insn *insn = NULL;\n+\n+  while (regno != last_regno)\n+    {\n+      /* AAPCS64 section 5.1.2 requires only the bottom 64 bits to be saved\n+\t so DFmode for the vector registers is enough.  */\n+      machine_mode mode = GP_REGNUM_P (regno) ? DImode : DFmode;\n+      rtx reg = gen_rtx_REG (mode, regno);\n+      HOST_WIDE_INT offset = cfun->machine->frame.reg_offset[regno];\n+      if (!frame_pointer_needed)\n+\toffset += cfun->machine->frame.frame_size\n+\t\t  - cfun->machine->frame.hard_fp_offset;\n+      rtx addr = plus_constant (Pmode, ptr_reg, offset);\n+      rtx mem = gen_frame_mem (mode, addr);\n+\n+      rtx set = prologue_p ? gen_rtx_SET (mem, reg) : gen_rtx_SET (reg, mem);\n+      unsigned regno2 = aarch64_get_next_set_bit (components, regno + 1);\n+      /* No more registers to handle after REGNO.\n+\t Emit a single save/restore and exit.  */\n+      if (regno2 == last_regno)\n+\t{\n+\t  insn = emit_insn (set);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  if (prologue_p)\n+\t    add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n+\t  else\n+\t    add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  break;\n+\t}\n+\n+      HOST_WIDE_INT offset2 = cfun->machine->frame.reg_offset[regno2];\n+      /* The next register is not of the same class or its offset is not\n+\t mergeable with the current one into a pair.  */\n+      if (!satisfies_constraint_Ump (mem)\n+\t  || GP_REGNUM_P (regno) != GP_REGNUM_P (regno2)\n+\t  || (offset2 - cfun->machine->frame.reg_offset[regno])\n+\t\t!= GET_MODE_SIZE (mode))\n+\t{\n+\t  insn = emit_insn (set);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  if (prologue_p)\n+\t    add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n+\t  else\n+\t    add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\n+\t  regno = regno2;\n+\t  continue;\n+\t}\n+\n+      /* REGNO2 can be saved/restored in a pair with REGNO.  */\n+      rtx reg2 = gen_rtx_REG (mode, regno2);\n+      if (!frame_pointer_needed)\n+\toffset2 += cfun->machine->frame.frame_size\n+\t\t  - cfun->machine->frame.hard_fp_offset;\n+      rtx addr2 = plus_constant (Pmode, ptr_reg, offset2);\n+      rtx mem2 = gen_frame_mem (mode, addr2);\n+      rtx set2 = prologue_p ? gen_rtx_SET (mem2, reg2)\n+\t\t\t     : gen_rtx_SET (reg2, mem2);\n+\n+      if (prologue_p)\n+\tinsn = emit_insn (aarch64_gen_store_pair (mode, mem, reg, mem2, reg2));\n+      else\n+\tinsn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2, mem2));\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (prologue_p)\n+\t{\n+\t  add_reg_note (insn, REG_CFA_OFFSET, set);\n+\t  add_reg_note (insn, REG_CFA_OFFSET, set2);\n+\t}\n+      else\n+\t{\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n+\t}\n+\n+      regno = aarch64_get_next_set_bit (components, regno2 + 1);\n+    }\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS.  */\n+\n+static void\n+aarch64_emit_prologue_components (sbitmap components)\n+{\n+  aarch64_process_components (components, true);\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS.  */\n+\n+static void\n+aarch64_emit_epilogue_components (sbitmap components)\n+{\n+  aarch64_process_components (components, false);\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS.  */\n+\n+static void\n+aarch64_set_handled_components (sbitmap components)\n+{\n+  for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n+    if (bitmap_bit_p (components, regno))\n+      cfun->machine->reg_is_wrapped_separately[regno] = true;\n+}\n+\n /* AArch64 stack frames generated by this compiler look like:\n \n \t+-------------------------------+\n@@ -3981,29 +4228,6 @@ aarch64_classify_index (struct aarch64_address_info *info, rtx x,\n   return false;\n }\n \n-bool\n-aarch64_offset_7bit_signed_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n-{\n-  return (offset >= -64 * GET_MODE_SIZE (mode)\n-\t  && offset < 64 * GET_MODE_SIZE (mode)\n-\t  && offset % GET_MODE_SIZE (mode) == 0);\n-}\n-\n-static inline bool\n-offset_9bit_signed_unscaled_p (machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t       HOST_WIDE_INT offset)\n-{\n-  return offset >= -256 && offset < 256;\n-}\n-\n-static inline bool\n-offset_12bit_unsigned_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n-{\n-  return (offset >= 0\n-\t  && offset < 4096 * GET_MODE_SIZE (mode)\n-\t  && offset % GET_MODE_SIZE (mode) == 0);\n-}\n-\n /* Return true if MODE is one of the modes for which we\n    support LDP/STP operations.  */\n \n@@ -14567,6 +14791,30 @@ aarch64_libgcc_floating_mode_supported_p\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD \\\n   aarch64_first_cycle_multipass_dfa_lookahead_guard\n \n+#undef TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS \\\n+  aarch64_get_separate_components\n+\n+#undef TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB\n+#define TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB \\\n+  aarch64_components_for_bb\n+\n+#undef TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS\n+#define TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS \\\n+  aarch64_disqualify_components\n+\n+#undef TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS \\\n+  aarch64_emit_prologue_components\n+\n+#undef TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS \\\n+  aarch64_emit_epilogue_components\n+\n+#undef TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS\n+#define TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS \\\n+  aarch64_set_handled_components\n+\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT aarch64_trampoline_init\n "}, {"sha": "c417569572c726b4a7b3f0f3cb2e5cc5ecc45581", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "patch": "@@ -591,6 +591,8 @@ struct GTY (()) aarch64_frame\n typedef struct GTY (()) machine_function\n {\n   struct aarch64_frame frame;\n+  /* One entry for each hard register.  */\n+  bool reg_is_wrapped_separately[LAST_SAVED_REGNUM];\n } machine_function;\n #endif\n "}, {"sha": "1e6b6f5ba7cd20778cb9550f58d4771970a59a6d", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=827ab47ab1f9f9b9b108a252b7a43c3c7bc828b7", "patch": "@@ -59,6 +59,7 @@\n     (V0_REGNUM\t\t32)\n     (V15_REGNUM\t\t47)\n     (V31_REGNUM\t\t63)\n+    (LAST_SAVED_REGNUM\t63)\n     (SFP_REGNUM\t\t64)\n     (AP_REGNUM\t\t65)\n     (CC_REGNUM\t\t66)"}]}