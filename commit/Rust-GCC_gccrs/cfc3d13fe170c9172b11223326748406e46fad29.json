{"sha": "cfc3d13fe170c9172b11223326748406e46fad29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjM2QxM2ZlMTcwYzkxNzJiMTEyMjMzMjY3NDg0MDZlNDZmYWQyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:51:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:51:45Z"}, "message": "Finish installation of last change.\n\nFrom-SVN: r7125", "tree": {"sha": "c25d99fea13366e3eaac2ab0003b536a6851c622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c25d99fea13366e3eaac2ab0003b536a6851c622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfc3d13fe170c9172b11223326748406e46fad29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc3d13fe170c9172b11223326748406e46fad29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc3d13fe170c9172b11223326748406e46fad29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc3d13fe170c9172b11223326748406e46fad29/comments", "author": null, "committer": null, "parents": [{"sha": "8d09227450c03328a943db0cd5cfd0985964987b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d09227450c03328a943db0cd5cfd0985964987b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d09227450c03328a943db0cd5cfd0985964987b"}], "stats": {"total": 91, "additions": 60, "deletions": 31}, "files": [{"sha": "bdf7dca69dd00a5e68365e8de6b317ce3ca56ba1", "filename": "gcc/stmt.c", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc3d13fe170c9172b11223326748406e46fad29/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc3d13fe170c9172b11223326748406e46fad29/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=cfc3d13fe170c9172b11223326748406e46fad29", "patch": "@@ -179,37 +179,6 @@ typedef struct case_node *case_node_ptr;\n /* This must be a signed type, and non-ANSI compilers lack signed char.  */\n static short *cost_table;\n static int use_cost_table;\n-\n-static int estimate_case_costs ();\n-static void balance_case_nodes ();\n-static void emit_case_nodes ();\n-static void group_case_nodes ();\n-static void emit_jump_if_reachable ();\n-\n-static int warn_if_unused_value ();\n-static void expand_goto_internal ();\n-static void bc_expand_goto_internal ();\n-static int expand_fixup ();\n-static void bc_expand_fixup ();\n-void fixup_gotos ();\n-static void bc_fixup_gotos ();\n-void free_temp_slots ();\n-static void expand_cleanups ();\n-static void expand_null_return_1 ();\n-static int tail_recursion_args ();\n-static void do_jump_if_equal ();\n-int bc_expand_exit_loop_if_false ();\n-void bc_expand_start_cond ();\n-void bc_expand_end_cond ();\n-void bc_expand_start_else ();\n-void bc_expand_end_bindings ();\n-void bc_expand_start_case ();\n-void bc_check_for_full_enumeration_handling ();\n-void bc_expand_end_case ();\n-void bc_expand_decl ();\n-\n-extern rtx bc_allocate_local ();\n-extern rtx bc_allocate_variable_array ();\n \f\n /* Stack of control and binding constructs we are currently inside.\n \n@@ -482,6 +451,56 @@ struct label_chain\n   struct label_chain *next;\n   tree label;\n };\n+static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n+static void bc_expand_goto_internal\tPROTO((enum bytecode_opcode,\n+\t\t\t\t\t       struct bc_label *, tree));\n+static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n+static void bc_expand_fixup\t\tPROTO((enum bytecode_opcode,\n+\t\t\t\t\t       struct bc_label *, int));\n+static void fixup_gotos\t\t\tPROTO((struct nesting *, rtx, tree,\n+\t\t\t\t\t       rtx, int));\n+static void bc_fixup_gotos\t\tPROTO((struct nesting *, int, tree,\n+\t\t\t\t\t       rtx, int));\n+static int warn_if_unused_value\t\tPROTO((tree));\n+static void bc_expand_start_cond\tPROTO((tree, int));\n+static void bc_expand_end_cond\t\tPROTO((void));\n+static void bc_expand_start_else\tPROTO((void));\n+static void bc_expand_end_loop\t\tPROTO((void));\n+static void bc_expand_end_bindings\tPROTO((tree, int, int));\n+static void bc_expand_decl\t\tPROTO((tree, tree));\n+static void bc_expand_variable_local_init PROTO((tree));\n+static void bc_expand_decl_init\t\tPROTO((tree));\n+static void expand_null_return_1\tPROTO((rtx, int));\n+static int tail_recursion_args\t\tPROTO((tree, tree));\n+static void expand_cleanups\t\tPROTO((tree, tree));\n+static void bc_expand_start_case\tPROTO((struct nesting *, tree,\n+\t\t\t\t\t       tree, char *));\n+static int bc_pushcase\t\t\tPROTO((tree, tree));\n+static void bc_check_for_full_enumeration_handling PROTO((tree));\n+static void bc_expand_end_case\t\tPROTO((tree));\n+static void do_jump_if_equal\t\tPROTO((rtx, rtx, rtx, int));\n+static int estimate_case_costs\t\tPROTO((case_node_ptr));\n+static void group_case_nodes\t\tPROTO((case_node_ptr));\n+static void balance_case_nodes\t\tPROTO((case_node_ptr *,\n+\t\t\t\t\t       case_node_ptr));\n+static int node_has_low_bound\t\tPROTO((case_node_ptr, tree));\n+static int node_has_high_bound\t\tPROTO((case_node_ptr, tree));\n+static int node_is_bounded\t\tPROTO((case_node_ptr, tree));\n+static void emit_jump_if_reachable\tPROTO((rtx));\n+static void emit_case_nodes\t\tPROTO((rtx, case_node_ptr, rtx, tree));\n+\n+int bc_expand_exit_loop_if_false ();\n+void bc_expand_start_cond ();\n+void bc_expand_end_cond ();\n+void bc_expand_start_else ();\n+void bc_expand_end_bindings ();\n+void bc_expand_start_case ();\n+void bc_check_for_full_enumeration_handling ();\n+void bc_expand_end_case ();\n+void bc_expand_decl ();\n+\n+extern rtx bc_allocate_local ();\n+extern rtx bc_allocate_variable_array ();\n \f\n void\n init_stmt ()\n@@ -841,6 +860,7 @@ expand_goto_internal (body, label, last_insn)\n \f\n /* Generate a jump with OPCODE to the given bytecode LABEL which is\n    found within BODY. */\n+\n static void\n bc_expand_goto_internal (opcode, label, body)\n      enum bytecode_opcode opcode;\n@@ -1070,7 +1090,16 @@ bc_expand_fixup (opcode, label, stack_level)\n   fputc ('\\n', stderr);\n #endif\n }\n+\f\n+/* Expand any needed fixups in the outputmost binding level of the\n+   function.  FIRST_INSN is the first insn in the function.  */\n \n+void\n+expand_fixups (first_insn)\n+     rtx first_insn;\n+{\n+  fixup_gotos (NULL_PTR, NULL_RTX, NULL_TREE, first_insn, 0);\n+}\n \n /* When exiting a binding contour, process all pending gotos requiring fixups.\n    THISBLOCK is the structure that describes the block being exited."}]}