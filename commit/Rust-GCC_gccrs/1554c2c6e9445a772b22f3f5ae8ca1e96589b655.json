{"sha": "1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU1NGMyYzZlOTQ0NWE3NzJiMjJmM2Y1YWU4Y2ExZTk2NTg5YjY1NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-11T12:07:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-11T12:07:33Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r436", "tree": {"sha": "374edfa69fb9d51ab7b22541c363660c666f25f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374edfa69fb9d51ab7b22541c363660c666f25f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1554c2c6e9445a772b22f3f5ae8ca1e96589b655/comments", "author": null, "committer": null, "parents": [{"sha": "a03618e9a3cf99a44a6973697fe70eae064ee68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03618e9a3cf99a44a6973697fe70eae064ee68c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03618e9a3cf99a44a6973697fe70eae064ee68c"}], "stats": {"total": 113, "additions": 71, "deletions": 42}, "files": [{"sha": "7bad21b5fa8f7101a6906b4df1a8126f9aa60081", "filename": "gcc/config/romp/romp.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1554c2c6e9445a772b22f3f5ae8ca1e96589b655/gcc%2Fconfig%2Fromp%2Fromp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1554c2c6e9445a772b22f3f5ae8ca1e96589b655/gcc%2Fconfig%2Fromp%2Fromp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.md?ref=1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "patch": "@@ -245,9 +245,9 @@\n ;; NO_REGS, so we need not have any predicates here.\n \n (define_expand \"reload_outsi\"\n-  [(set (match_operand:SI 0 \"symbolic_memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"\" \"r\"))\n-   (match_operand:SI 2 \"\" \"=&b\")]\n+  [(parallel [(set (match_operand:SI 0 \"symbolic_memory_operand\" \"=m\")\n+\t\t   (match_operand:SI 1 \"\" \"r\"))\n+\t      (clobber (match_operand:SI 2 \"\" \"=&b\"))])]\n   \"\"\n   \"\")\n \f"}, {"sha": "685247374a48fa17fd66d14791dce63c1d753681", "filename": "gcc/reload1.c", "status": "modified", "additions": 68, "deletions": 39, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1554c2c6e9445a772b22f3f5ae8ca1e96589b655/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1554c2c6e9445a772b22f3f5ae8ca1e96589b655/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1554c2c6e9445a772b22f3f5ae8ca1e96589b655", "patch": "@@ -4732,6 +4732,22 @@ emit_reload_insns (insn)\n \t      if (reload_secondary_reload[j] >= 0)\n \t\t{\n \t\t  int secondary_reload = reload_secondary_reload[j];\n+\t\t  rtx real_oldequiv = oldequiv;\n+\t\t  rtx real_old = old;\n+\n+\t\t  /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n+\t\t     and similarly for OLD.\n+\t\t     See comments in find_secondary_reload in reload.c.  */\n+\t\t  if (GET_CODE (oldequiv) == REG\n+\t\t      && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n+\t\t      && reg_equiv_mem[REGNO (oldequiv)] != 0)\n+\t\t    real_oldequiv = reg_equiv_mem[REGNO (oldequiv)];\n+\n+\t\t  if (GET_CODE (old) == REG\n+\t\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+\t\t      && reg_equiv_mem[REGNO (old)] != 0)\n+\t\t    real_old = reg_equiv_mem[REGNO (old)];\n+\n \t\t  second_reload_reg = reload_reg_rtx[secondary_reload];\n \t\t  icode = reload_secondary_icode[j];\n \n@@ -4740,7 +4756,7 @@ emit_reload_insns (insn)\n \t\t    {\n \t\t      enum reg_class new_class\n \t\t\t= SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n-\t\t\t\t\t\t\tmode, oldequiv);\n+\t\t\t\t\t\t\tmode, real_oldequiv);\n \n \t\t      if (new_class == NO_REGS)\n \t\t\tsecond_reload_reg = 0;\n@@ -4751,7 +4767,7 @@ emit_reload_insns (insn)\n \n \t\t\t  if (! TEST_HARD_REG_BIT (reg_class_contents[(int) new_class],\n \t\t\t\t\t\t   REGNO (second_reload_reg)))\n-\t\t\t    oldequiv = old;\n+\t\t\t    oldequiv = old, real_oldequiv = real_old;\n \t\t\t  else\n \t\t\t    {\n \t\t\t      new_icode = reload_in_optab[(int) mode];\n@@ -4761,7 +4777,7 @@ emit_reload_insns (insn)\n \t\t\t\t\t     (reloadreg, mode)))\n \t\t\t\t      || (insn_operand_predicate[(int) new_icode][1]\n \t\t\t\t\t  && ! ((*insn_operand_predicate[(int) new_icode][1])\n-\t\t\t\t\t\t(oldequiv, mode)))))\n+\t\t\t\t\t\t(real_oldequiv, mode)))))\n \t\t\t\tnew_icode = CODE_FOR_nothing;\n \n \t\t\t      if (new_icode == CODE_FOR_nothing)\n@@ -4773,7 +4789,7 @@ emit_reload_insns (insn)\n \t\t\t\t{\n \t\t\t\t  if (!HARD_REGNO_MODE_OK (REGNO (second_reload_reg),\n \t\t\t\t\t\t\t   new_mode))\n-\t\t\t\t    oldequiv = old;\n+\t\t\t\t    oldequiv = old, real_oldequiv = real_old;\n \t\t\t\t  else\n \t\t\t\t    second_reload_reg\n \t\t\t\t      = gen_reg_rtx (REG, new_mode,\n@@ -4785,14 +4801,18 @@ emit_reload_insns (insn)\n \n \t\t  /* If we still need a secondary reload register, check\n \t\t     to see if it is being used as a scratch or intermediate\n-\t\t     register and generate code appropriately.  */\n+\t\t     register and generate code appropriately.  If we need\n+\t\t     a scratch register, use REAL_OLDEQUIV since the form of\n+\t\t     the insn may depend on the actual address if it is \n+\t\t     a MEM.  */\n \n \t\t  if (second_reload_reg)\n \t\t    {\n \t\t      if (icode != CODE_FOR_nothing)\n \t\t\t{\n \t\t\t  reload_insn = emit_insn_before (GEN_FCN (icode)\n-\t\t\t\t\t\t\t  (reloadreg, oldequiv,\n+\t\t\t\t\t\t\t  (reloadreg,\n+\t\t\t\t\t\t\t   real_oldequiv,\n \t\t\t\t\t\t\t   second_reload_reg),\n \t\t\t\t\t\t\t  where);\n \t\t\t  if (this_reload_insn == 0)\n@@ -4814,7 +4834,7 @@ emit_reload_insns (insn)\n \t\t\t      reload_insn\n \t\t\t\t= emit_insn_before ((GEN_FCN (tertiary_icode)\n \t\t\t\t\t\t     (second_reload_reg,\n-\t\t\t\t\t\t      oldequiv,\n+\t\t\t\t\t\t      real_oldequiv,\n \t\t\t\t\t\t      third_reload_reg)),\n \t\t\t\t\t\t    where);\n \t\t\t      if (this_reload_insn == 0)\n@@ -5100,46 +5120,55 @@ emit_reload_insns (insn)\n \t     one, since it will be stored into OUT.  We might need a secondary\n \t     register only for an input reload, so check again here.  */\n \n-\t  if (reload_secondary_reload[j] >= 0\n-\t      && (SECONDARY_OUTPUT_RELOAD_CLASS (reload_reg_class[j],\n-\t\t\t\t\t\t mode, old)\n-\t\t  != NO_REGS))\n+\t  if (reload_secondary_reload[j] >= 0)\n \t    {\n-\t      second_reloadreg = reloadreg;\n-\t      reloadreg = reload_reg_rtx[reload_secondary_reload[j]];\n+\t      rtx real_old = old;\n \n-\t      /* See if RELOADREG is to be used as a scratch register\n-\t\t or as an intermediate register.  */\n-\t      if (reload_secondary_icode[j] != CODE_FOR_nothing)\n-\t\t{\n-\t\t  emit_insn_before ((GEN_FCN (reload_secondary_icode[j])\n-\t\t\t\t     (old, second_reloadreg, reloadreg)),\n-\t\t\t\t    first_output_reload_insn);\n-\t\t  special = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* See if we need both a scratch and intermediate reload\n-\t\t     register.  */\n-\t\t  int secondary_reload = reload_secondary_reload[j];\n-\t\t  enum insn_code tertiary_icode\n-\t\t    = reload_secondary_icode[secondary_reload];\n-\t\t  rtx pat;\n+\t      if (GET_CODE (old) == REG && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+\t\t  && reg_equiv_mem[REGNO (old)] != 0)\n+\t\treal_old = reg_equiv_mem[REGNO (old)];\n \n-\t\t  if (GET_MODE (reloadreg) != mode)\n-\t\t    reloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n+\t      if((SECONDARY_OUTPUT_RELOAD_CLASS (reload_reg_class[j],\n+\t\t\t\t\t\t mode, real_old)\n+\t\t  != NO_REGS))\n+\t\t{\n+\t\t  second_reloadreg = reloadreg;\n+\t\t  reloadreg = reload_reg_rtx[reload_secondary_reload[j]];\n \n-\t\t  if (tertiary_icode != CODE_FOR_nothing)\n+\t\t  /* See if RELOADREG is to be used as a scratch register\n+\t\t     or as an intermediate register.  */\n+\t\t  if (reload_secondary_icode[j] != CODE_FOR_nothing)\n \t\t    {\n-\t\t      rtx third_reloadreg\n-\t\t\t= reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n-\t\t      pat = (GEN_FCN (tertiary_icode)\n-\t\t\t     (reloadreg, second_reloadreg, third_reloadreg));\n+\t\t      emit_insn_before ((GEN_FCN (reload_secondary_icode[j])\n+\t\t\t\t\t (real_old, second_reloadreg,\n+\t\t\t\t\t  reloadreg)),\n+\t\t\t\t\tfirst_output_reload_insn);\n+\t\t      special = 1;\n \t\t    }\n \t\t  else\n-\t\t    pat = gen_move_insn (reloadreg, second_reloadreg);\n+\t\t    {\n+\t\t      /* See if we need both a scratch and intermediate reload\n+\t\t\t register.  */\n+\t\t      int secondary_reload = reload_secondary_reload[j];\n+\t\t      enum insn_code tertiary_icode\n+\t\t\t= reload_secondary_icode[secondary_reload];\n+\t\t      rtx pat;\n \n-\t\t  emit_insn_before (pat, first_output_reload_insn);\n+\t\t      if (GET_MODE (reloadreg) != mode)\n+\t\t\treloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n+\n+\t\t      if (tertiary_icode != CODE_FOR_nothing)\n+\t\t\t{\n+\t\t\t  rtx third_reloadreg\n+\t\t\t    = reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n+\t\t\t  pat = (GEN_FCN (tertiary_icode)\n+\t\t\t\t (reloadreg, second_reloadreg, third_reloadreg));\n+\t\t\t}\n+\t\t      else\n+\t\t\tpat = gen_move_insn (reloadreg, second_reloadreg);\n+\n+\t\t      emit_insn_before (pat, first_output_reload_insn);\n+\t\t    }\n \t\t}\n \t    }\n #endif"}]}