{"sha": "9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5MDFkNTBiYmY5NGIzM2Y0YmFkZTljMmEwOTNiNzZiZWYyYWZkNw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-04-07T11:24:11Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-04-07T11:24:11Z"}, "message": "arm.c (arm_const_double_inline_cost): Handle any constant by using gen_lowpart and gen_highpart_mode.\n\n\t* arm.c (arm_const_double_inline_cost): Handle any constant by\n\tusing gen_lowpart and gen_highpart_mode.\n\t(note_invalid_constants): All constants in an RTX with a constraint\n\tthat permits memory are now pushed to the constant pool.\n\t(output_move_double): Delete code to handle reg to reg and\n\tconstant to reg moves.\n\t(const_double_needs_minipool, output_mov_immediate): Delete.\n\t* arm.h (EXTRA_CONSTRAINT_STR_ARM): All 'D' variants now handle\n\tCONST_INT and CONST_VECTOR.\n\t* arm.md (ANY64): New mode macro.\n\t(arm_movdi): Split reg-reg and const-reg moves.  Simplify constraints.\n\t(movdf_soft_insn): Split reg-reg and const-reg moves.\n\t(split patterns for 64-bit constant and register moves): New.\n\t* cirrus.md (cirrus_arm_movdi): Split reg-reg and const-reg moves.\n\t(cirrus_movdf_hard_insn): Likewise.\n\t* fpa.md (movdf_fpa): Likewise.\n\t* iwmmxt.md (iwmmxt_arm_movdi): Likewise.\n\t(movv8qi_internal, movv4hi_internal, movv2si_internal): Fix\n\tconstraints.\n\t(movv2si_internal_2): Likewise.\n\t* vfp.md (arm_movdi_vfp): Split reg-reg and const-reg moves.\n\t(movdf_vfp): Likewise.\n\t* arm-protos.h (output_mov_immediate): Delete prototype.\n\nFrom-SVN: r97778", "tree": {"sha": "8588996f87869b15eb7ed84df12df651ae3e5086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8588996f87869b15eb7ed84df12df651ae3e5086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/comments", "author": null, "committer": null, "parents": [{"sha": "7443a71d621f8d7ceeb5f3210785238681f18183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7443a71d621f8d7ceeb5f3210785238681f18183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7443a71d621f8d7ceeb5f3210785238681f18183"}], "stats": {"total": 416, "additions": 152, "deletions": 264}, "files": [{"sha": "f2591678a32059f3500efb9b65978434ff25cd1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -1,3 +1,29 @@\n+2005-04-07  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* arm.c (arm_const_double_inline_cost): Handle any constant by\n+\tusing gen_lowpart and gen_highpart_mode.\n+\t(note_invalid_constants): All constants in an RTX with a constraint\n+\tthat permits memory are now pushed to the constant pool.\n+\t(output_move_double): Delete code to handle reg to reg and \n+\tconstant to reg moves.\n+\t(const_double_needs_minipool, output_mov_immediate): Delete.\n+\t* arm.h (EXTRA_CONSTRAINT_STR_ARM): All 'D' variants now handle\n+\tCONST_INT and CONST_VECTOR.\n+\t* arm.md (ANY64): New mode macro.\n+\t(arm_movdi): Split reg-reg and const-reg moves.  Simplify constraints.\n+\t(movdf_soft_insn): Split reg-reg and const-reg moves.\n+\t(split patterns for 64-bit constant and register moves): New.\n+\t* cirrus.md (cirrus_arm_movdi): Split reg-reg and const-reg moves.\n+\t(cirrus_movdf_hard_insn): Likewise.\n+\t* fpa.md (movdf_fpa): Likewise.\n+\t* iwmmxt.md (iwmmxt_arm_movdi): Likewise.\n+\t(movv8qi_internal, movv4hi_internal, movv2si_internal): Fix\n+\tconstraints.\n+\t(movv2si_internal_2): Likewise.\n+\t* vfp.md (arm_movdi_vfp): Split reg-reg and const-reg moves.\n+\t(movdf_vfp): Likewise.\n+\t* arm-protos.h (output_mov_immediate): Delete prototype.\n+\n 2005-04-07  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR target/20093"}, {"sha": "0baca5783ff9af7be5a0f4466e36bb7ed1292c2d", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -100,7 +100,6 @@ extern const char *output_mov_long_double_arm_from_arm (rtx *);\n extern const char *output_mov_double_fpa_from_arm (rtx *);\n extern const char *output_mov_double_arm_from_fpa (rtx *);\n extern const char *output_move_double (rtx *);\n-extern const char *output_mov_immediate (rtx *);\n extern const char *output_add_immediate (rtx *);\n extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);"}, {"sha": "27c6f75a5e56c727fb351b97d251d2fb2524d521", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 248, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -7390,57 +7390,37 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   minipool_fix_tail = fix;\n }\n \n-/* Return the cost of synthesizing the const_double VAL inline.\n+/* Return the cost of synthesizing a 64-bit constant VAL inline.\n    Returns the number of insns needed, or 99 if we don't know how to\n    do it.  */\n int\n arm_const_double_inline_cost (rtx val)\n {\n-  long parts[2];\n+  rtx lowpart, highpart;\n+  enum machine_mode mode;\n   \n-  if (GET_MODE (val) == DFmode)\n-    {\n-      REAL_VALUE_TYPE r;\n-      if (!TARGET_SOFT_FLOAT)\n-\treturn 99;\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, val);\n-      REAL_VALUE_TO_TARGET_DOUBLE (r, parts);\n-    }\n-  else if (GET_MODE (val) != VOIDmode)\n-    return 99;\n-  else\n-    {\n-      parts[0] = CONST_DOUBLE_LOW (val);\n-      parts[1] = CONST_DOUBLE_HIGH (val);\n-    }\n+  mode = GET_MODE (val);\n \n-  return (arm_gen_constant (SET, SImode, NULL_RTX, parts[0],\n-\t\t\t    NULL_RTX, NULL_RTX, 0, 0)\n-\t  + arm_gen_constant (SET, SImode, NULL_RTX, parts[1],\n-\t\t\t      NULL_RTX, NULL_RTX, 0, 0));\n-}\n+  if (mode == VOIDmode)\n+    mode = DImode;\n \n-/* Determine if a CONST_DOUBLE should be pushed to the minipool */\n-static bool\n-const_double_needs_minipool (rtx val)\n-{\n-  /* thumb only knows to load a CONST_DOUBLE from memory at the moment */\n-  if (TARGET_THUMB)\n-    return true;\n+  gcc_assert (GET_MODE_SIZE (mode) == 8);\n+  \n+  lowpart = gen_lowpart (SImode, val);\n+  highpart = gen_highpart_mode (SImode, mode, val);\n+  \n+  gcc_assert (GET_CODE (lowpart) == CONST_INT);\n+  gcc_assert (GET_CODE (highpart) == CONST_INT);\n \n-  /* Don't push anything to the minipool if a CONST_DOUBLE can be built with\n-     a few ALU insns directly. On balance, the optimum is likely to be around\n-     3 insns, except when there are no load delay slots where it should be 4.\n-     When optimizing for size, a limit of 3 allows saving at least one word\n-     except for cases where a single minipool entry could be shared more than\n-     2 times which is rather unlikely to outweight the overall savings. */\n-  return (arm_const_double_inline_cost (val)\n-\t  > ((optimize_size || arm_ld_sched) ? 3 : 4));\n+  return (arm_gen_constant (SET, SImode, NULL_RTX, INTVAL (lowpart),\n+\t\t\t    NULL_RTX, NULL_RTX, 0, 0)\n+\t  + arm_gen_constant (SET, SImode, NULL_RTX, INTVAL (highpart),\n+\t\t\t      NULL_RTX, NULL_RTX, 0, 0));\n }\n \n /* Scan INSN and note any of its operands that need fixing.\n    If DO_PUSHES is false we do not actually push any of the fixups\n-   needed.  The function returns TRUE is any fixups were needed/pushed.\n+   needed.  The function returns TRUE if any fixups were needed/pushed.\n    This is used by arm_memory_load_p() which needs to know about loads\n    of constants that will be converted into minipool loads.  */\n static bool\n@@ -7457,7 +7437,8 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n   if (recog_data.n_alternatives == 0)\n     return false;\n \n-  /* Fill in recog_op_alt with information about the constraints of this insn.  */\n+  /* Fill in recog_op_alt with information about the constraints of\n+     this insn.  */\n   preprocess_constraints ();\n \n   for (opno = 0; opno < recog_data.n_operands; opno++)\n@@ -7474,9 +7455,7 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n \t{\n \t  rtx op = recog_data.operand[opno];\n \n-\t  if (CONSTANT_P (op)\n-\t      && (GET_CODE (op) != CONST_DOUBLE\n-\t\t  || const_double_needs_minipool (op)))\n+\t  if (CONSTANT_P (op))\n \t    {\n \t      if (do_pushes)\n \t\tpush_minipool_fix (insn, address, recog_data.operand_loc[opno],\n@@ -8072,175 +8051,7 @@ output_move_double (rtx *operands)\n \n       otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n \n-      if (code1 == REG)\n-\t{\n-\t  int reg1 = REGNO (operands[1]);\n-\t  if (reg1 == IP_REGNUM)\n-\t    abort ();\n-\n-\t  /* Ensure the second source is not overwritten.  */\n-\t  if (reg1 == reg0 + (WORDS_BIG_ENDIAN ? -1 : 1))\n-\t    output_asm_insn (\"mov%?\\t%Q0, %Q1\\n\\tmov%?\\t%R0, %R1\", operands);\n-\t  else\n-\t    output_asm_insn (\"mov%?\\t%R0, %R1\\n\\tmov%?\\t%Q0, %Q1\", operands);\n-\t}\n-      else if (code1 == CONST_VECTOR)\n-\t{\n-\t  HOST_WIDE_INT hint = 0;\n-\n-\t  switch (GET_MODE (operands[1]))\n-\t    {\n-\t    case V2SImode:\n-\t      otherops[1] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 1)));\n-\t      operands[1] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 0)));\n-\t      break;\n-\n-\t    case V4HImode:\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  hint = INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n-\t\t  hint <<= 16;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  hint = INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n-\t\t  hint <<= 16;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n-\t\t}\n-\n-\t      otherops[1] = GEN_INT (hint);\n-\t      hint = 0;\n-\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n-\t\t  hint <<= 16;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n-\t\t  hint <<= 16;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n-\t\t}\n-\n-\t      operands[1] = GEN_INT (hint);\n-\t      break;\n-\n-\t    case V8QImode:\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 4));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 5));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 6));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 7));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 7));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 6));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 5));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 4));\n-\t\t}\n-\n-\t      otherops[1] = GEN_INT (hint);\n-\t      hint = 0;\n-\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n-\t\t  hint <<= 8;\n-\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n-\t\t}\n-\n-\t      operands[1] = GEN_INT (hint);\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t  output_mov_immediate (operands);\n-\t  output_mov_immediate (otherops);\n-\t}\n-      else if (code1 == CONST_DOUBLE)\n-\t{\n-\t  if (GET_MODE (operands[1]) == DFmode)\n-\t    {\n-\t      REAL_VALUE_TYPE r;\n-\t      long l[2];\n-\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\t      otherops[1] = GEN_INT (l[1]);\n-\t      operands[1] = GEN_INT (l[0]);\n-\t    }\n-\t  else if (GET_MODE (operands[1]) != VOIDmode)\n-\t    abort ();\n-\t  else if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      otherops[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-\t    }\n-\t  else\n-\t    {\n-\t      otherops[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t    }\n-\n-\t  output_mov_immediate (operands);\n-\t  output_mov_immediate (otherops);\n-\t}\n-      else if (code1 == CONST_INT)\n-\t{\n-#if HOST_BITS_PER_WIDE_INT > 32\n-\t  /* If HOST_WIDE_INT is more than 32 bits, the intval tells us\n-\t     what the upper word is.  */\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      otherops[1] = GEN_INT (ARM_SIGN_EXTEND (INTVAL (operands[1])));\n-\t      operands[1] = GEN_INT (INTVAL (operands[1]) >> 32);\n-\t    }\n-\t  else\n-\t    {\n-\t      otherops[1] = GEN_INT (INTVAL (operands[1]) >> 32);\n-\t      operands[1] = GEN_INT (ARM_SIGN_EXTEND (INTVAL (operands[1])));\n-\t    }\n-#else\n-\t  /* Sign extend the intval into the high-order word.  */\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      otherops[1] = operands[1];\n-\t      operands[1] = (INTVAL (operands[1]) < 0\n-\t\t\t     ? constm1_rtx : const0_rtx);\n-\t    }\n-\t  else\n-\t    otherops[1] = INTVAL (operands[1]) < 0 ? constm1_rtx : const0_rtx;\n-#endif\n-\t  output_mov_immediate (otherops);\n-\t  output_mov_immediate (operands);\n-\t}\n-      else if (code1 == MEM)\n+      if (code1 == MEM)\n \t{\n \t  switch (GET_CODE (XEXP (operands[1], 0)))\n \t    {\n@@ -8479,43 +8290,6 @@ output_move_double (rtx *operands)\n   return \"\";\n }\n \n-\n-/* Output an arbitrary MOV reg, #n.\n-   OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */\n-const char *\n-output_mov_immediate (rtx *operands)\n-{\n-  HOST_WIDE_INT n = INTVAL (operands[1]);\n-\n-  /* Try to use one MOV.  */\n-  if (const_ok_for_arm (n))\n-    output_asm_insn (\"mov%?\\t%0, %1\", operands);\n-\n-  /* Try to use one MVN.  */\n-  else if (const_ok_for_arm (~n))\n-    {\n-      operands[1] = GEN_INT (~n);\n-      output_asm_insn (\"mvn%?\\t%0, %1\", operands);\n-    }\n-  else\n-    {\n-      int n_ones = 0;\n-      int i;\n-\n-      /* If all else fails, make it out of ORRs or BICs as appropriate.  */\n-      for (i = 0; i < 32; i++)\n-\tif (n & 1 << i)\n-\t  n_ones++;\n-\n-      if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n-\toutput_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1, ~ n);\n-      else\n-\toutput_multi_immediate (operands, \"mov%?\\t%0, %1\", \"orr%?\\t%0, %0, %1\", 1, n);\n-    }\n-\n-  return \"\";\n-}\n-\n /* Output an ADD r, s, #n where n may be too big for one instruction.\n    If adding zero to one register, output nothing.  */\n const char *"}, {"sha": "088c003f524ee46665f10d52d3c5e385b3387ed6", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -1323,7 +1323,9 @@ enum reg_class\n    'Uq' is an address valid for ldrsb.  */\n \n #define EXTRA_CONSTRAINT_STR_ARM(OP, C, STR)\t\t\t\t\\\n-  (((C) == 'D') ? (GET_CODE (OP) == CONST_DOUBLE\t\t\t\\\n+  (((C) == 'D') ? ((GET_CODE (OP) == CONST_DOUBLE\t\t\t\\\n+\t\t    || GET_CODE (OP) == CONST_INT\t\t\t\\\n+\t\t    || GET_CODE (OP) == CONST_VECTOR)\t\t\t\\\n \t\t   && (((STR)[1] == 'a'\t\t\t\t\t\\\n \t\t\t&& arm_const_double_inline_cost (OP) == 2)\t\\\n \t\t       || ((STR)[1] == 'b'\t\t\t\t\\"}, {"sha": "9474c0db55a4488f781632f6ae35daeacdfb9d9f", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 81, "deletions": 4, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -289,6 +289,18 @@\n ;; distant label.  Only applicable to Thumb code.\n (define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n \n+\n+;;---------------------------------------------------------------------------\n+;; Mode macros\n+\n+; A list of modes that are exactly 64 bits in size.  We use this to expand\n+; some splits that are the same for all modes when operating on ARM \n+; registers.\n+(define_mode_macro ANY64 [DI DF V8QI V4HI V2SI V2SF])\n+\n+;;---------------------------------------------------------------------------\n+;; Predicates\n+\n (include \"predicates.md\")\n \n ;;---------------------------------------------------------------------------\n@@ -4137,20 +4149,75 @@\n )\n \n (define_insn \"*arm_movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,   r, r, r, m\")\n-\t(match_operand:DI 1 \"di_operand\"              \"rIKDa,Db,Dc,mi,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, r, r, m\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rDa,Db,Dc,mi,r\"))]\n   \"TARGET_ARM\n   && !(TARGET_HARD_FLOAT && (TARGET_MAVERICK || TARGET_VFP))\n   && !TARGET_IWMMXT\"\n   \"*\n-  return (output_move_double (operands));\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+    case 2:\n+      return \\\"#\\\";\n+    default:\n+      return output_move_double (operands);\n+    }\n   \"\n   [(set_attr \"length\" \"8,12,16,8,8\")\n    (set_attr \"type\" \"*,*,*,load2,store2\")\n    (set_attr \"pool_range\" \"*,*,*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,*,*,1008,*\")]\n )\n \n+(define_split\n+  [(set (match_operand:ANY64 0 \"arm_general_register_operand\" \"\")\n+\t(match_operand:ANY64 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_ARM\n+   && reload_completed\n+   && (arm_const_double_inline_cost (operands[1])\n+       <= ((optimize_size || arm_ld_sched) ? 3 : 4))\"\n+  [(const_int 0)]\n+  \"\n+  arm_split_constant (SET, SImode, curr_insn,\n+\t\t      INTVAL (gen_lowpart (SImode, operands[1])),\n+\t\t      gen_lowpart (SImode, operands[0]), NULL_RTX, 0);\n+  arm_split_constant (SET, SImode, curr_insn,\n+\t\t      INTVAL (gen_highpart_mode (SImode,\n+\t\t\t\t\t\t GET_MODE (operands[0]),\n+\t\t\t\t\t\t operands[1])),\n+\t\t      gen_highpart (SImode, operands[0]), NULL_RTX, 0);\n+  DONE;\n+  \"\n+)\n+\n+(define_split\n+  [(set (match_operand:ANY64 0 \"arm_general_register_operand\" \"\")\n+\t(match_operand:ANY64 1 \"arm_general_register_operand\" \"\"))]\n+  \"TARGET_EITHER && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_highpart (SImode, operands[1]);\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+  /* Handle a partial overlap.  */\n+  if (rtx_equal_p (operands[0], operands[3]))\n+    {\n+      rtx tmp0 = operands[0];\n+      rtx tmp1 = operands[1];\n+\n+      operands[0] = operands[2];\n+      operands[1] = operands[3];\n+      operands[2] = tmp0;\n+      operands[3] = tmp1;\n+    }\n+  \"\n+)\n+\n ;; We can't actually do base+index doubleword loads if the index and\n ;; destination overlap.  Split here so that we at least have chance to\n ;; schedule.\n@@ -5150,7 +5217,17 @@\n \t(match_operand:DF 1 \"soft_df_operand\" \"rDa,Db,Dc,mF,r\"))]\n   \"TARGET_ARM && TARGET_SOFT_FLOAT\n   \"\n-  \"* return output_move_double (operands);\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+    case 2:\n+      return \\\"#\\\";\n+    default:\n+      return output_move_double (operands);\n+    }\n+  \"\n   [(set_attr \"length\" \"8,12,16,8,8\")\n    (set_attr \"type\" \"*,*,*,load2,store2\")\n    (set_attr \"pool_range\" \"1020\")"}, {"sha": "ece341e4155bc71a2a0710721dac410361e08274", "filename": "gcc/config/arm/cirrus.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fcirrus.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fcirrus.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcirrus.md?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -377,9 +377,10 @@\n   switch (which_alternative)\n     {\n     case 0:\n+      return \\\"#\\\";\n     case 1:\n     case 2:\n-      return (output_move_double (operands));\n+      return output_move_double (operands);\n \n     case 3: return \\\"cfmv64lr%?\\\\t%V0, %Q1\\;cfmv64hr%?\\\\t%V0, %R1\\\";\n     case 4: return \\\"cfmvr64l%?\\\\t%Q0, %V1\\;cfmvr64h%?\\\\t%R0, %V1\\\";\n@@ -460,7 +461,8 @@\n     {\n     case 0: return \\\"ldm%?ia\\\\t%m1, %M0\\\\t%@ double\\\";\n     case 1: return \\\"stm%?ia\\\\t%m0, %M1\\\\t%@ double\\\";\n-    case 2: case 3: case 4: return output_move_double (operands);\n+    case 2: return \\\"#\\\";\n+    case 3: case 4: return output_move_double (operands);\n     case 5: return \\\"cfcpyd%?\\\\t%V0, %V1\\\";\n     case 6: return \\\"cfldrd%?\\\\t%V0, %1\\\";\n     case 7: return \\\"cfmvdlr\\\\t%V0, %Q1\\;cfmvdhr%?\\\\t%V0, %R1\\\";"}, {"sha": "cbcfc13cd8a0edbd926776dcd14c37b832dfc7d3", "filename": "gcc/config/arm/fpa.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Ffpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Ffpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffpa.md?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -563,7 +563,8 @@\n     default:\n     case 0: return \\\"ldm%?ia\\\\t%m1, %M0\\\\t%@ double\\\";\n     case 1: return \\\"stm%?ia\\\\t%m0, %M1\\\\t%@ double\\\";\n-    case 2: case 3: case 4: return output_move_double (operands);\n+    case 2: return \\\"#\\\";\n+    case 3: case 4: return output_move_double (operands);\n     case 5: return \\\"mvf%?d\\\\t%0, %1\\\";\n     case 6: return \\\"mnf%?d\\\\t%0, #%N1\\\";\n     case 7: return \\\"ldf%?d\\\\t%0, %1\\\";"}, {"sha": "a87d78ffce4233a9d0fe8f2b447cdd7cd2c2c191", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -73,6 +73,8 @@\n     {\n     default:\n       return output_move_double (operands);\n+    case 0:\n+      return \\\"#\\\";\n     case 3:\n       return \\\"wmov%?\\\\t%0,%1\\\";\n     case 4:\n@@ -155,7 +157,7 @@\n \n (define_insn \"movv8qi_internal\"\n   [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n-\t(match_operand:V8QI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+\t(match_operand:V8QI 1 \"general_operand\"       \"y,y,mi,y,r,mi\"))]\n   \"TARGET_REALLY_IWMMXT\"\n   \"*\n    switch (which_alternative)\n@@ -175,7 +177,7 @@\n \n (define_insn \"movv4hi_internal\"\n   [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n-\t(match_operand:V4HI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+\t(match_operand:V4HI 1 \"general_operand\"       \"y,y,mi,y,r,mi\"))]\n   \"TARGET_REALLY_IWMMXT\"\n   \"*\n    switch (which_alternative)\n@@ -195,7 +197,7 @@\n \n (define_insn \"movv2si_internal\"\n   [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n-\t(match_operand:V2SI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+\t(match_operand:V2SI 1 \"general_operand\"       \"y,y,mi,y,r,mi\"))]\n   \"TARGET_REALLY_IWMMXT\"\n   \"*\n    switch (which_alternative)\n@@ -220,7 +222,7 @@\n ;; deliberately omitted.\n (define_insn \"movv2si_internal_2\"\n   [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=?r\")\n-\t(match_operand      1 \"immediate_operand\"      \"i\"))]\n+\t(match_operand      1 \"immediate_operand\"      \"mi\"))]\n   \"TARGET_REALLY_IWMMXT\"\n   \"* return output_move_double (operands);\"\n   [(set_attr \"predicable\"     \"yes\")"}, {"sha": "4086a5c66434a719d6cbb97be57a20bd721ef9cd", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b901d50bbf94b33f4bade9c2a093b76bef2afd7/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=9b901d50bbf94b33f4bade9c2a093b76bef2afd7", "patch": "@@ -142,8 +142,11 @@\n   \"*\n   switch (which_alternative)\n     {\n-    case 0: case 1: case 2:\n-      return (output_move_double (operands));\n+    case 0: \n+      return \\\"#\\\";\n+    case 1:\n+    case 2:\n+      return output_move_double (operands);\n     case 3:\n       return \\\"fmdrr%?\\\\t%P0, %1\\\\t%@ int\\\";\n     case 4:\n@@ -203,14 +206,16 @@\n \treturn \\\"fmdrr%?\\\\t%P0, %Q1, %R1\\\";\n       case 1:\n \treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n-      case 2: case 3: case 7:\n+      case 2: case 3:\n \treturn output_move_double (operands);\n       case 4:\n \treturn \\\"fldd%?\\\\t%P0, %1\\\";\n       case 5:\n \treturn \\\"fstd%?\\\\t%P1, %0\\\";\n       case 6:\n \treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n+      case 7:\n+        return \\\"#\\\";\n       default:\n \tabort ();\n       }"}]}