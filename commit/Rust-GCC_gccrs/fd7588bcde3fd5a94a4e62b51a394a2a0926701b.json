{"sha": "fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NTg4YmNkZTNmZDVhOTRhNGU2MmI1MWEzOTRhMmEwOTI2NzAxYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-05T14:27:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-05T14:27:39Z"}, "message": "re PR lto/40902 (LTO doesn't merge CV differences properly)\n\n2009-10-05  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/40902\n\t* lto-symtab.c (lto_compatible_attributes_p): Remove.\n\t(external_aggregate_decl_p): Likewise.\n\t(lto_symtab_compatible): Re-structure.  Remove dead code.\n\tFor variables ignore toplevel qualifiers when comparing types.\n\tIssue warnings, not errors for mismatched user-alignment.\n\n\t* gcc.dg/lto/20091005-1_0.c: New testcase.\n\t* gcc.dg/lto/20091005-1_1.c: Likewise.\n\nFrom-SVN: r152452", "tree": {"sha": "4e43893fdcd55979833a36ef94e1565238f19dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e43893fdcd55979833a36ef94e1565238f19dee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe03b3df84399b6e2f63ea4286b295e8dc145c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe03b3df84399b6e2f63ea4286b295e8dc145c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe03b3df84399b6e2f63ea4286b295e8dc145c60"}], "stats": {"total": 310, "additions": 101, "deletions": 209}, "files": [{"sha": "6060ebf924c55f1fa8bc14729be1b6afe60d853e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "patch": "@@ -1,3 +1,12 @@\n+2009-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/40902\n+\t* lto-symtab.c (lto_compatible_attributes_p): Remove.\n+\t(external_aggregate_decl_p): Likewise.\n+\t(lto_symtab_compatible): Re-structure.  Remove dead code.\n+\tFor variables ignore toplevel qualifiers when comparing types.\n+\tIssue warnings, not errors for mismatched user-alignment.\n+\n 2009-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41552"}, {"sha": "bb3183c80f6fe30729855468caed5f436e9e4629", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 81, "deletions": 209, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "patch": "@@ -109,35 +109,6 @@ lto_symtab_maybe_init_hash_table (void)\n \t\t     lto_symtab_entry_eq, NULL);\n }\n \n-/* Returns true iff the union of ATTRIBUTES_1 and ATTRIBUTES_2 can be\n-   applied to DECL.  */\n-static bool\n-lto_compatible_attributes_p (tree decl ATTRIBUTE_UNUSED, \n-\t\t\t     tree attributes_1, \n-\t\t\t     tree attributes_2)\n-{\n-#if 0\n-  /* ??? For now, assume two attribute sets are compatible only if they\n-     are both empty.  */\n-  return !attributes_1 && !attributes_2;\n-#else\n-  /* FIXME.  For the moment, live dangerously, and assume the user knows\n-     what he's doing. I don't think the linker would distinguish these cases.  */\n-  return true || (!attributes_1 && !attributes_2);\n-#endif\n-}\n-\n-/* Helper for lto_symtab_compatible. Return TRUE if DECL is an external\n-   variable declaration of an aggregate type. */\n-\n-static bool\n-external_aggregate_decl_p (tree decl)\n-{\n-  return (TREE_CODE (decl) == VAR_DECL\n-\t  && DECL_EXTERNAL (decl)\n-\t  && AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n-}\n-\n static bool maybe_merge_incomplete_and_complete_type (tree, tree);\n \n /* Try to merge an incomplete type INCOMPLETE with a complete type\n@@ -194,7 +165,7 @@ maybe_merge_incomplete_and_complete_type (tree type1, tree type2)\n static bool\n lto_symtab_compatible (tree old_decl, tree new_decl)\n {\n-  tree merged_type = NULL_TREE;\n+  tree old_type, new_type;\n \n   if (TREE_CODE (old_decl) != TREE_CODE (new_decl))\n     {\n@@ -221,213 +192,114 @@ lto_symtab_compatible (tree old_decl, tree new_decl)\n \t}\n     }\n \n+  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+    {\n+      if (!gimple_types_compatible_p (TREE_TYPE (old_decl),\n+\t\t\t\t      TREE_TYPE (new_decl)))\n+\t/* If we don't have a merged type yet...sigh.  The linker\n+\t   wouldn't complain if the types were mismatched, so we\n+\t   probably shouldn't either.  Just use the type from\n+\t   whichever decl appears to be associated with the\n+\t   definition.  If for some odd reason neither decl is, the\n+\t   older one wins.  */\n+\t(void) 0;\n+\n+      return true;\n+    }\n+\n+  /* Now we exclusively deal with VAR_DECLs.  */\n+\n   /* Handle external declarations with incomplete type or pointed-to\n      incomplete types by forcefully merging the types.\n      ???  In principle all types involved in the two decls should\n      be merged forcefully, for example without considering type or\n      field names.  */\n-  if (TREE_CODE (old_decl) == VAR_DECL)\n+  old_type = TREE_TYPE (old_decl);\n+  new_type = TREE_TYPE (new_decl);\n+\n+  if (DECL_EXTERNAL (old_decl) || DECL_EXTERNAL (new_decl))\n+    maybe_merge_incomplete_and_complete_type (old_type, new_type);\n+  else if (POINTER_TYPE_P (old_type)\n+\t   && POINTER_TYPE_P (new_type))\n+    maybe_merge_incomplete_and_complete_type (TREE_TYPE (old_type),\n+\t\t\t\t\t      TREE_TYPE (new_type));\n+\n+  /* For array types we have to accept external declarations with\n+     different sizes than the actual definition (164.gzip).\n+     ???  We could emit a warning here.  */\n+  if (TREE_CODE (old_type) == TREE_CODE (new_type)\n+      && TREE_CODE (old_type) == ARRAY_TYPE\n+      && COMPLETE_TYPE_P (old_type)\n+      && COMPLETE_TYPE_P (new_type)\n+      && tree_int_cst_compare (TYPE_SIZE (old_type),\n+\t\t\t       TYPE_SIZE (new_type)) != 0\n+      && gimple_types_compatible_p (TREE_TYPE (old_type),\n+\t\t\t\t    TREE_TYPE (new_type)))\n     {\n-      tree old_type = TREE_TYPE (old_decl);\n-      tree new_type = TREE_TYPE (new_decl);\n-\n-      if (DECL_EXTERNAL (old_decl) || DECL_EXTERNAL (new_decl))\n-\tmaybe_merge_incomplete_and_complete_type (old_type, new_type);\n-      else if (POINTER_TYPE_P (old_type)\n-\t       && POINTER_TYPE_P (new_type))\n-\tmaybe_merge_incomplete_and_complete_type (TREE_TYPE (old_type),\n-\t\t\t\t\t\t  TREE_TYPE (new_type));\n-\n-      /* For array types we have to accept external declarations with\n-\t different sizes than the actual definition (164.gzip).\n-\t ???  We could emit a warning here.  */\n-      if (TREE_CODE (old_type) == TREE_CODE (new_type)\n-\t  && TREE_CODE (old_type) == ARRAY_TYPE\n-\t  && COMPLETE_TYPE_P (old_type)\n-\t  && COMPLETE_TYPE_P (new_type)\n-\t  && tree_int_cst_compare (TYPE_SIZE (old_type),\n-\t\t\t\t   TYPE_SIZE (new_type)) != 0\n-\t  && gimple_types_compatible_p (TREE_TYPE (old_type),\n-\t\t\t\t\tTREE_TYPE (new_type)))\n+      /* If only one is external use the type of the non-external decl.\n+\t Else use the larger one and also adjust the decl size.\n+\t ???  Directional merging would allow us to simply pick the\n+\t larger one instead of rewriting it.  */\n+      if (DECL_EXTERNAL (old_decl) ^ DECL_EXTERNAL (new_decl))\n \t{\n-\t  /* If only one is external use the type of the non-external decl.\n-\t     Else use the larger one and also adjust the decl size.\n-\t     ???  Directional merging would allow us to simply pick the\n-\t     larger one instead of rewriting it.  */\n-\t  if (DECL_EXTERNAL (old_decl) ^ DECL_EXTERNAL (new_decl))\n-\t    {\n-\t      if (DECL_EXTERNAL (old_decl))\n-\t\tTREE_TYPE (old_decl) = new_type;\n-\t      else if (DECL_EXTERNAL (new_decl))\n-\t\tTREE_TYPE (new_decl) = old_type;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (tree_int_cst_compare (TYPE_SIZE (old_type),\n-\t\t\t\t\tTYPE_SIZE (new_type)) < 0)\n-\t\t{\n-\t\t  TREE_TYPE (old_decl) = new_type;\n-\t\t  DECL_SIZE (old_decl) = DECL_SIZE (new_decl);\n-\t\t  DECL_SIZE_UNIT (old_decl) = DECL_SIZE_UNIT (new_decl);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TREE_TYPE (new_decl) = old_type;\n-\t\t  DECL_SIZE (new_decl) = DECL_SIZE (old_decl);\n-\t\t  DECL_SIZE_UNIT (new_decl) = DECL_SIZE_UNIT (old_decl);\n-\t\t}\n-\t    }\n+\t  if (DECL_EXTERNAL (old_decl))\n+\t    TREE_TYPE (old_decl) = new_type;\n+\t  else if (DECL_EXTERNAL (new_decl))\n+\t    TREE_TYPE (new_decl) = old_type;\n \t}\n-    }\n-\n-  if (!gimple_types_compatible_p (TREE_TYPE (old_decl), TREE_TYPE (new_decl)))\n-    {\n-      if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+      else\n \t{\n-\t  if (!merged_type\n-\t      /* We want either of the types to have argument types,\n-\t\t but not both.  */\n-\t      && ((TYPE_ARG_TYPES (TREE_TYPE (old_decl)) != NULL)\n-\t\t  ^ (TYPE_ARG_TYPES (TREE_TYPE (new_decl)) != NULL)))\n+\t  if (tree_int_cst_compare (TYPE_SIZE (old_type),\n+\t\t\t\t    TYPE_SIZE (new_type)) < 0)\n \t    {\n-\t      /* The situation here is that (in C) somebody was smart\n-\t\t enough to use proper declarations in a header file, but\n-\t\t the actual definition of the function uses\n-\t\t non-ANSI-style argument lists.  Or we have a situation\n-\t\t where declarations weren't used anywhere and we're\n-\t\t merging the actual definition with a use.  One of the\n-\t\t decls will then have a complete function type, whereas\n-\t\t the other will only have a result type.  Assume that\n-\t\t the more complete type is the right one and don't\n-\t\t complain.  */\n-\t      if (TYPE_ARG_TYPES (TREE_TYPE (old_decl)))\n-\t\t{\n-\t\t  merged_type = TREE_TYPE (old_decl);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  merged_type = TREE_TYPE (new_decl);\n-\t\t}\n+\t      TREE_TYPE (old_decl) = new_type;\n+\t      DECL_SIZE (old_decl) = DECL_SIZE (new_decl);\n+\t      DECL_SIZE_UNIT (old_decl) = DECL_SIZE_UNIT (new_decl);\n \t    }\n-\n-\t  /* If we don't have a merged type yet...sigh.  The linker\n-\t     wouldn't complain if the types were mismatched, so we\n-\t     probably shouldn't either.  Just use the type from\n-\t     whichever decl appears to be associated with the\n-\t     definition.  If for some odd reason neither decl is, the\n-\t     older one wins.  */\n-\t  if (!merged_type)\n+\t  else\n \t    {\n-\t      if (!DECL_EXTERNAL (new_decl))\n-\t\t{\n-\t\t  merged_type = TREE_TYPE (new_decl);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  merged_type = TREE_TYPE (old_decl);\n-\t\t}\n+\t      TREE_TYPE (new_decl) = old_type;\n+\t      DECL_SIZE (new_decl) = DECL_SIZE (old_decl);\n+\t      DECL_SIZE_UNIT (new_decl) = DECL_SIZE_UNIT (old_decl);\n \t    }\n \t}\n-\n-      if (!merged_type)\n-\t{\n-\t  if (warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n-\t\t\t  \"type of %qD does not match original declaration\",\n-\t\t\t  new_decl))\n-\t    inform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t    \"previously declared here\");\n-\t  return false;\n-\t}\n     }\n \n-  if (DECL_UNSIGNED (old_decl) != DECL_UNSIGNED (new_decl))\n+  /* We can tolerate differences in type qualification, the\n+     qualification of the prevailing definition will prevail.  */\n+  old_type = TYPE_MAIN_VARIANT (TREE_TYPE (old_decl));\n+  new_type = TYPE_MAIN_VARIANT (TREE_TYPE (new_decl));\n+  if (!gimple_types_compatible_p (old_type, new_type))\n     {\n-      error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t\"signedness of %qD does not match original declaration\",\n-\t\tnew_decl);\n-      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n+      if (warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n+\t\t      \"type of %qD does not match original declaration\",\n+\t\t      new_decl))\n+\tinform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t\"previously declared here\");\n       return false;\n     }\n \n-  if (!tree_int_cst_equal (DECL_SIZE (old_decl),\n-\t\t\t   DECL_SIZE (new_decl))\n-      || !tree_int_cst_equal (DECL_SIZE_UNIT (old_decl),\n-\t\t\t      DECL_SIZE_UNIT (new_decl)))\n-    {\n-      /* Permit cases where we are declaring aggregates and at least one\n-\t of the decls is external and one of the decls has a size whereas\n-\t the other one does not.  This is perfectly legal in C:\n-\n-         struct s;\n-\t extern struct s x;\n-\n-\t void*\n-\t f (void)\n-\t {\n-\t   return &x;\n-\t }\n-\n-\t There is no way a compiler can tell the size of x.  So we cannot\n-\t assume that external aggreates have complete types.  */\n-\n-      if (!((TREE_CODE (TREE_TYPE (old_decl))\n-\t     == TREE_CODE (TREE_TYPE (new_decl)))\n-\t    && ((external_aggregate_decl_p (old_decl)\n-\t\t && DECL_SIZE (old_decl) == NULL_TREE)\n-\t\t|| (external_aggregate_decl_p (new_decl)\n-\t\t    && DECL_SIZE (new_decl) == NULL_TREE))))\n-\t{\n-\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t    \"size of %qD does not match original declaration\",\n-\t\t    new_decl);\n-\t  inform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t  \"previously declared here\");\n-\t  return false;\n-\t}\n-    }\n+  /* ???  We might want to emit a warning here if type qualification\n+     differences were spotted.  Do not do this unconditionally though.  */\n \n-  /* Report an error if user-specified alignments do not match.  */\n-  if ((DECL_USER_ALIGN (old_decl) && DECL_USER_ALIGN (new_decl))\n-      && DECL_ALIGN (old_decl) != DECL_ALIGN (new_decl))\n-    {\n-      error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t\"alignment of %qD does not match original declaration\",\n-\t\tnew_decl);\n-      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n-      return false;\n-    }\n+  /* There is no point in comparing too many details of the decls here.\n+     The type compatibility checks or the completing of types has properly\n+     dealt with most issues.  */\n \n-  /* Do not compare the modes of the decls.  The type compatibility\n-     checks or the completing of types has properly dealt with all issues.  */\n+  /* The following should all not invoke fatal errors as in non-LTO\n+     mode the linker wouldn't complain either.  Just emit warnings.  */\n \n-  if (!lto_compatible_attributes_p (old_decl,\n-\t\t\t\t    DECL_ATTRIBUTES (old_decl),\n-\t\t\t\t    DECL_ATTRIBUTES (new_decl)))\n+  /* Report a warning if user-specified alignments do not match.  */\n+  if ((DECL_USER_ALIGN (old_decl) && DECL_USER_ALIGN (new_decl))\n+      && DECL_ALIGN (old_decl) != DECL_ALIGN (new_decl))\n     {\n-      error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t\"attributes applied to %qD are incompatible with original \"\n-\t\t\"declaration\", new_decl);\n+      warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n+\t\t  \"alignment of %qD does not match original declaration\",\n+\t\t  new_decl);\n       inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n       return false;\n     }\n \n-  /* We do not require matches for:\n-\n-     - DECL_NAME\n-\n-       Only the name used in object files matters.\n-\n-     - DECL_CONTEXT  \n-\n-       An entity might be declared in a C++ namespace in one file and\n-       with a C identifier in another file.  \n-\n-     - TREE_PRIVATE, TREE_PROTECTED\n-\n-       Access control is the problem of the front end that created the\n-       object file.  \n-       \n-     Therefore, at this point we have decided to merge the declarations.  */\n   return true;\n }\n "}, {"sha": "c48f680272ef57ef50ea2a6cf4acfdfb8ad1553a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "patch": "@@ -1,3 +1,9 @@\n+2009-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/40902\n+\t* gcc.dg/lto/20091005-1_0.c: New testcase.\n+\t* gcc.dg/lto/20091005-1_1.c: Likewise.\n+\n 2009-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41552"}, {"sha": "f4316efbc35563b102a1ee48d1fed3ff375bd2b4", "filename": "gcc/testsuite/gcc.dg/lto/20091005-1_0.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_0.c?ref=fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-lto-do run } */\n+\n+const int i[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };"}, {"sha": "52eb8e78b3f611b5b46d8f77712c849eea32a739", "filename": "gcc/testsuite/gcc.dg/lto/20091005-1_1.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7588bcde3fd5a94a4e62b51a394a2a0926701b/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20091005-1_1.c?ref=fd7588bcde3fd5a94a4e62b51a394a2a0926701b", "patch": "@@ -0,0 +1,2 @@\n+extern int i[10];\n+int main () { return i[0]; }"}]}