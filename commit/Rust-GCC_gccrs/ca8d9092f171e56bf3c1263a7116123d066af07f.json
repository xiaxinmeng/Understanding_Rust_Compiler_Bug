{"sha": "ca8d9092f171e56bf3c1263a7116123d066af07f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4ZDkwOTJmMTcxZTU2YmYzYzEyNjNhNzExNjEyM2QwNjZhZjA3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-05-31T13:40:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-31T13:40:03Z"}, "message": "tree-dfa.c (get_ref_base_and_extent): Compute the offset using double ints throughout.\n\n\t* tree-dfa.c (get_ref_base_and_extent): Compute the offset using\n\tdouble ints throughout.\n\t* tree-sra.c (build_user_friendly_ref_for_offset) <RECORD_TYPE>:\n\tCheck that the position of the field is representable as an integer.\n\nFrom-SVN: r188060", "tree": {"sha": "c0d15f7d75f8cf76f0c8d683165904a59be7ad35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d15f7d75f8cf76f0c8d683165904a59be7ad35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca8d9092f171e56bf3c1263a7116123d066af07f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8d9092f171e56bf3c1263a7116123d066af07f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8d9092f171e56bf3c1263a7116123d066af07f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8d9092f171e56bf3c1263a7116123d066af07f/comments", "author": null, "committer": null, "parents": [{"sha": "1db1c6f520ef3c2c0f7e2c3b398e1614887cc1e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db1c6f520ef3c2c0f7e2c3b398e1614887cc1e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db1c6f520ef3c2c0f7e2c3b398e1614887cc1e5"}], "stats": {"total": 122, "additions": 80, "deletions": 42}, "files": [{"sha": "d38d0cbe144c89c01db99cb9c4e1892b1f192f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca8d9092f171e56bf3c1263a7116123d066af07f", "patch": "@@ -1,3 +1,10 @@\n+2012-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-dfa.c (get_ref_base_and_extent): Compute the offset using\n+\tdouble ints throughout.\n+\t* tree-sra.c (build_user_friendly_ref_for_offset) <RECORD_TYPE>:\n+\tCheck that the position of the field is representable as an integer.\n+\n 2012-05-31  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-data-ref.c (dr_analyze_innermost): Properly convert"}, {"sha": "ef87fd4284442b6dfa07f913cee1e73a71ba0b7c", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 67, "deletions": 39, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=ca8d9092f171e56bf3c1263a7116123d066af07f", "patch": "@@ -621,7 +621,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   HOST_WIDE_INT bitsize = -1;\n   HOST_WIDE_INT maxsize = -1;\n   tree size_tree = NULL_TREE;\n-  HOST_WIDE_INT bit_offset = 0;\n+  double_int bit_offset = double_int_zero;\n+  HOST_WIDE_INT hbit_offset;\n   bool seen_variable_array_ref = false;\n   tree base_type;\n \n@@ -659,30 +660,33 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       switch (TREE_CODE (exp))\n \t{\n \tcase BIT_FIELD_REF:\n-\t  bit_offset += TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n+\t  bit_offset\n+\t    = double_int_add (bit_offset,\n+\t\t\t      tree_to_double_int (TREE_OPERAND (exp, 2)));\n \t  break;\n \n \tcase COMPONENT_REF:\n \t  {\n \t    tree field = TREE_OPERAND (exp, 1);\n \t    tree this_offset = component_ref_field_offset (exp);\n \n-\t    if (this_offset\n-\t\t&& TREE_CODE (this_offset) == INTEGER_CST\n-\t\t&& host_integerp (this_offset, 0))\n+\t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n \t      {\n-\t\tHOST_WIDE_INT hthis_offset = TREE_INT_CST_LOW (this_offset);\n-\t\ththis_offset *= BITS_PER_UNIT;\n-\t\ththis_offset\n-\t\t  += TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field));\n-\t\tbit_offset += hthis_offset;\n+\t\tdouble_int doffset = tree_to_double_int (this_offset);\n+\t\tdoffset = double_int_lshift (doffset,\n+\t\t\t\t\t     BITS_PER_UNIT == 8\n+\t\t\t\t\t     ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t\t     HOST_BITS_PER_DOUBLE_INT, true);\n+\t\tdoffset = double_int_add (doffset,\n+\t\t\t\t\t  tree_to_double_int\n+\t\t\t\t\t  (DECL_FIELD_BIT_OFFSET (field)));\n+\t\tbit_offset = double_int_add (bit_offset, doffset);\n \n \t\t/* If we had seen a variable array ref already and we just\n \t\t   referenced the last field of a struct or a union member\n \t\t   then we have to adjust maxsize by the padding at the end\n \t\t   of our field.  */\n-\t\tif (seen_variable_array_ref\n-\t\t    && maxsize != -1)\n+\t\tif (seen_variable_array_ref && maxsize != -1)\n \t\t  {\n \t\t    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t\t    tree next = DECL_CHAIN (field);\n@@ -694,10 +698,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\ttree fsize = DECL_SIZE_UNIT (field);\n \t\t\ttree ssize = TYPE_SIZE_UNIT (stype);\n \t\t\tif (host_integerp (fsize, 0)\n-\t\t\t    && host_integerp (ssize, 0))\n+\t\t\t    && host_integerp (ssize, 0)\n+\t\t\t    && double_int_fits_in_shwi_p (doffset))\n \t\t\t  maxsize += ((TREE_INT_CST_LOW (ssize)\n \t\t\t\t       - TREE_INT_CST_LOW (fsize))\n-\t\t\t\t      * BITS_PER_UNIT - hthis_offset);\n+\t\t\t\t      * BITS_PER_UNIT\n+\t\t\t\t\t- double_int_to_shwi (doffset));\n \t\t\telse\n \t\t\t  maxsize = -1;\n \t\t      }\n@@ -709,8 +715,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole structure bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us out of the structure otherwise.  */\n-\t\tif (maxsize != -1 && csize && host_integerp (csize, 1))\n-\t\t  maxsize = TREE_INT_CST_LOW (csize) - bit_offset;\n+\t\tif (maxsize != -1\n+\t\t    && csize\n+\t\t    && host_integerp (csize, 1)\n+\t\t    && double_int_fits_in_shwi_p (bit_offset))\n+\t\t  maxsize = TREE_INT_CST_LOW (csize)\n+\t\t\t    - double_int_to_shwi (bit_offset);\n \t\telse\n \t\t  maxsize = -1;\n \t      }\n@@ -722,24 +732,26 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t  {\n \t    tree index = TREE_OPERAND (exp, 1);\n \t    tree low_bound, unit_size;\n-\t    double_int doffset;\n \n \t    /* If the resulting bit-offset is constant, track it.  */\n \t    if (TREE_CODE (index) == INTEGER_CST\n \t\t&& (low_bound = array_ref_low_bound (exp),\n  \t\t    TREE_CODE (low_bound) == INTEGER_CST)\n \t\t&& (unit_size = array_ref_element_size (exp),\n-\t\t    host_integerp (unit_size, 1))\n-\t\t&& (doffset = double_int_sext\n-\t\t\t      (double_int_sub (TREE_INT_CST (index),\n-\t\t\t\t\t       TREE_INT_CST (low_bound)),\n-\t\t\t       TYPE_PRECISION (TREE_TYPE (index))),\n-\t\t    double_int_fits_in_shwi_p (doffset)))\n+\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n \t      {\n-\t\tHOST_WIDE_INT hoffset = double_int_to_shwi (doffset);\n-\t\thoffset *= TREE_INT_CST_LOW (unit_size);\n-\t\thoffset *= BITS_PER_UNIT;\n-\t\tbit_offset += hoffset;\n+\t\tdouble_int doffset\n+\t\t  = double_int_sext\n+\t\t    (double_int_sub (TREE_INT_CST (index),\n+\t\t\t\t     TREE_INT_CST (low_bound)),\n+\t\t     TYPE_PRECISION (TREE_TYPE (index)));\n+\t\tdoffset = double_int_mul (doffset,\n+\t\t\t\t\t  tree_to_double_int (unit_size));\n+\t\tdoffset = double_int_lshift (doffset,\n+\t\t\t\t\t     BITS_PER_UNIT == 8\n+\t\t\t\t\t     ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t\t     HOST_BITS_PER_DOUBLE_INT, true);\n+\t\tbit_offset = double_int_add (bit_offset, doffset);\n \n \t\t/* An array ref with a constant index up in the structure\n \t\t   hierarchy will constrain the size of any variable array ref\n@@ -752,8 +764,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole array bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us outside of the array otherwise.  */\n-\t\tif (maxsize != -1 && asize && host_integerp (asize, 1))\n-\t\t  maxsize = TREE_INT_CST_LOW (asize) - bit_offset;\n+\t\tif (maxsize != -1\n+\t\t    && asize\n+\t\t    && host_integerp (asize, 1)\n+\t\t    && double_int_fits_in_shwi_p (bit_offset))\n+\t\t  maxsize = TREE_INT_CST_LOW (asize)\n+\t\t\t    - double_int_to_shwi (bit_offset);\n \t\telse\n \t\t  maxsize = -1;\n \n@@ -768,7 +784,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t  break;\n \n \tcase IMAGPART_EXPR:\n-\t  bit_offset += bitsize;\n+\t  bit_offset\n+\t    = double_int_add (bit_offset, uhwi_to_double_int (bitsize));\n \t  break;\n \n \tcase VIEW_CONVERT_EXPR:\n@@ -787,10 +804,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\t\t\t   BITS_PER_UNIT == 8\n \t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n \t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT, true);\n-\t\t  off = double_int_add (off, shwi_to_double_int (bit_offset));\n+\t\t  off = double_int_add (off, bit_offset);\n \t\t  if (double_int_fits_in_shwi_p (off))\n \t\t    {\n-\t\t      bit_offset = double_int_to_shwi (off);\n+\t\t      bit_offset = off;\n \t\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n \t\t    }\n \t\t}\n@@ -806,7 +823,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      if (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n \t\t{\n \t\t  exp = TREE_OPERAND (TMR_BASE (exp), 0);\n-\t\t  bit_offset = 0;\n+\t\t  bit_offset = double_int_zero;\n \t\t  maxsize = -1;\n \t\t  goto done;\n \t\t}\n@@ -819,10 +836,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\t\t\t   BITS_PER_UNIT == 8\n \t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n \t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT, true);\n-\t\t  off = double_int_add (off, shwi_to_double_int (bit_offset));\n+\t\t  off = double_int_add (off, bit_offset);\n \t\t  if (double_int_fits_in_shwi_p (off))\n \t\t    {\n-\t\t      bit_offset = double_int_to_shwi (off);\n+\t\t      bit_offset = off;\n \t\t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t\t    }\n \t\t}\n@@ -837,6 +854,17 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n     }\n  done:\n \n+  if (!double_int_fits_in_shwi_p (bit_offset))\n+    {\n+      *poffset = 0;\n+      *psize = bitsize;\n+      *pmax_size = -1;\n+\n+      return exp;\n+    }\n+\n+  hbit_offset = double_int_to_shwi (bit_offset);\n+\n   /* We need to deal with variable arrays ending structures such as\n        struct { int length; int a[1]; } x;           x.a[d]\n        struct { struct { int a; int b; } a[1]; } x;  x.a[d].a\n@@ -851,7 +879,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   if (seen_variable_array_ref\n       && maxsize != -1\n       && (!host_integerp (TYPE_SIZE (base_type), 1)\n-\t  || (bit_offset + maxsize\n+\t  || (hbit_offset + maxsize\n \t      == (signed) TREE_INT_CST_LOW (TYPE_SIZE (base_type)))))\n     maxsize = -1;\n \n@@ -863,21 +891,21 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n          base decl.  */\n       if (maxsize == -1\n \t  && host_integerp (DECL_SIZE (exp), 1))\n-\tmaxsize = TREE_INT_CST_LOW (DECL_SIZE (exp)) - bit_offset;\n+\tmaxsize = TREE_INT_CST_LOW (DECL_SIZE (exp)) - hbit_offset;\n     }\n   else if (CONSTANT_CLASS_P (exp))\n     {\n       /* If maxsize is unknown adjust it according to the size of the\n          base type constant.  */\n       if (maxsize == -1\n \t  && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1))\n-\tmaxsize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))) - bit_offset;\n+\tmaxsize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))) - hbit_offset;\n     }\n \n   /* ???  Due to negative offsets in ARRAY_REF we can end up with\n      negative bit_offset here.  We might want to store a zero offset\n      in this case.  */\n-  *poffset = bit_offset;\n+  *poffset = hbit_offset;\n   *psize = bitsize;\n   *pmax_size = maxsize;\n "}, {"sha": "2e3e97898fee5e821f2c8052ac5ca5e8fef93c5b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca8d9092f171e56bf3c1263a7116123d066af07f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ca8d9092f171e56bf3c1263a7116123d066af07f", "patch": "@@ -1549,17 +1549,20 @@ build_user_friendly_ref_for_offset (tree *res, tree type, HOST_WIDE_INT offset,\n \t  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \t    {\n \t      HOST_WIDE_INT pos, size;\n-\t      tree expr, *expr_ptr;\n+\t      tree tr_pos, expr, *expr_ptr;\n \n \t      if (TREE_CODE (fld) != FIELD_DECL)\n \t\tcontinue;\n \n-\t      pos = int_bit_position (fld);\n+\t      tr_pos = bit_position (fld);\n+\t      if (!tr_pos || !host_integerp (tr_pos, 1))\n+\t\tcontinue;\n+\t      pos = TREE_INT_CST_LOW (tr_pos);\n \t      gcc_assert (TREE_CODE (type) == RECORD_TYPE || pos == 0);\n \t      tr_size = DECL_SIZE (fld);\n \t      if (!tr_size || !host_integerp (tr_size, 1))\n \t\tcontinue;\n-\t      size = tree_low_cst (tr_size, 1);\n+\t      size = TREE_INT_CST_LOW (tr_size);\n \t      if (size == 0)\n \t\t{\n \t\t  if (pos != offset)"}]}