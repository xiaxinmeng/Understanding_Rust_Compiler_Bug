{"sha": "efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZiN2UxZTAyNjE3Yjc3OWQ4YmQzNzZkOWRjY2NkMGNkYjRkM2E5NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-01-17T17:42:10Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-01-17T17:42:10Z"}, "message": "vec.h (VEC_reserve_exact): Define.\n\n./:\t* vec.h (VEC_reserve_exact): Define.\n\t(vec_gc_p_reserve_exact): Declare.\n\t(vec_gc_o_reserve_exact): Declare.\n\t(vec_heap_p_reserve_exact): Declare.\n\t(vec_heap_o_reserve_exact): Declare.\n\t(VEC_OP (T,A,reserve_exact)): New static inline function, three\n\tversions.\n\t(VEC_OP (T,A,reserve)) [all versions]: Remove handling of\n\tnegative parameter.\n\t(VEC_OP (T,A,alloc)) [all versions]: Call ...reserve_exact.\n\t(VEC_OP (T,A,copy)) [all versions]: Likewise.\n\t(VEC_OP (T,a,safe_grow)) [all versions]: Likewise.\n\t* vec.c (calculate_allocation): Add exact parameter.  Change all\n\tcallers.\n\t(vec_gc_o_reserve_1): New static function, from vec_gc_o_reserve.\n\t(vec_gc_p_reserve, vec_gc_o_reserve): Call vec_gc_o_reserve_1.\n\t(vec_gc_p_reserve_exact, vec_gc_o_reserve_exact): New functions.\n\t(vec_heap_o_reserve_1): New static function, from vec_heap_o_reserve.\n\t(vec_heap_p_reserve, vec_heap_o_reserve): Call vec_heap_o_reserve_1.\n\t(vec_heap_p_reserve_exact): New function.\n\t(vec_heap_o_reserve_exact): New function.\ncp/:\n\t* class.c (add_method): Call VEC_reserve_exact rather than passing\n\ta negative size to VEC_reserve.\n\nFrom-SVN: r120861", "tree": {"sha": "d11736fef8af73b7b6d37819f905d5ad1e594615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d11736fef8af73b7b6d37819f905d5ad1e594615"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/comments", "author": null, "committer": null, "parents": [{"sha": "9dd8004e9108e08d45b25781bc6d44a624f690b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd8004e9108e08d45b25781bc6d44a624f690b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd8004e9108e08d45b25781bc6d44a624f690b8"}], "stats": {"total": 313, "additions": 237, "deletions": 76}, "files": [{"sha": "1b8bbcecc511c3d771e8e87822415d8ee6b69380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "patch": "@@ -1,3 +1,27 @@\n+2007-01-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* vec.h (VEC_reserve_exact): Define.\n+\t(vec_gc_p_reserve_exact): Declare.\n+\t(vec_gc_o_reserve_exact): Declare.\n+\t(vec_heap_p_reserve_exact): Declare.\n+\t(vec_heap_o_reserve_exact): Declare.\n+\t(VEC_OP (T,A,reserve_exact)): New static inline function, three\n+\tversions.\n+\t(VEC_OP (T,A,reserve)) [all versions]: Remove handling of\n+\tnegative parameter.\n+\t(VEC_OP (T,A,alloc)) [all versions]: Call ...reserve_exact.\n+\t(VEC_OP (T,A,copy)) [all versions]: Likewise.\n+\t(VEC_OP (T,a,safe_grow)) [all versions]: Likewise.\n+\t* vec.c (calculate_allocation): Add exact parameter.  Change all\n+\tcallers.\n+\t(vec_gc_o_reserve_1): New static function, from vec_gc_o_reserve.\n+\t(vec_gc_p_reserve, vec_gc_o_reserve): Call vec_gc_o_reserve_1.\n+\t(vec_gc_p_reserve_exact, vec_gc_o_reserve_exact): New functions.\n+\t(vec_heap_o_reserve_1): New static function, from vec_heap_o_reserve.\n+\t(vec_heap_p_reserve, vec_heap_o_reserve): Call vec_heap_o_reserve_1.\n+\t(vec_heap_p_reserve_exact): New function.\n+\t(vec_heap_o_reserve_exact): New function.\n+\n 2007-01-17  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-type-escape.c (look_for_casts): Revamp using handled_component_p."}, {"sha": "5123c18f8b8c0bc6e4693a13c9c3a559c61992bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "patch": "@@ -1,3 +1,8 @@\n+2007-01-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* class.c (add_method): Call VEC_reserve_exact rather than passing\n+\ta negative size to VEC_reserve.\n+\n 2007-01-11  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/29573"}, {"sha": "3e0758a47b1ff4f7baf6712cd601bc8b79db5d3b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "patch": "@@ -1071,9 +1071,15 @@ add_method (tree type, tree method, tree using_decl)\n \n   if (insert_p)\n     {\n+      bool reallocated;\n+\n       /* We only expect to add few methods in the COMPLETE_P case, so\n \t just make room for one more method in that case.  */\n-      if (VEC_reserve (tree, gc, method_vec, complete_p ? -1 : 1))\n+      if (complete_p)\n+\treallocated = VEC_reserve_exact (tree, gc, method_vec, 1);\n+      else\n+\treallocated = VEC_reserve (tree, gc, method_vec, 1);\n+      if (reallocated)\n \tCLASSTYPE_METHOD_VEC (type) = method_vec;\n       if (slot == VEC_length (tree, method_vec))\n \tVEC_quick_push (tree, method_vec, overload);"}, {"sha": "9e9dd858fbd7d2567e2a9750994231fc5fcf1d9b", "filename": "gcc/vec.c", "status": "modified", "additions": 109, "deletions": 34, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "patch": "@@ -40,16 +40,17 @@ struct vec_prefix\n   void *vec[1];\n };\n \n-/* Calculate the new ALLOC value, making sure that abs(RESERVE) slots\n-   are free.  If RESERVE < 0 grow exactly, otherwise grow\n-   exponentially.  */\n+/* Calculate the new ALLOC value, making sure that RESERVE slots are\n+   free.  If EXACT grow exactly, otherwise grow exponentially.  */\n \n static inline unsigned\n-calculate_allocation (const struct vec_prefix *pfx, int reserve)\n+calculate_allocation (const struct vec_prefix *pfx, int reserve, bool exact)\n {\n   unsigned alloc = 0;\n   unsigned num = 0;\n \n+  gcc_assert (reserve >= 0);\n+\n   if (pfx)\n     {\n       alloc = pfx->alloc;\n@@ -61,11 +62,11 @@ calculate_allocation (const struct vec_prefix *pfx, int reserve)\n     return 0;\n   \n   /* We must have run out of room.  */\n-  gcc_assert (alloc - num < (unsigned)(reserve < 0 ? -reserve : reserve));\n+  gcc_assert (alloc - num < (unsigned) reserve);\n   \n-  if (reserve < 0)\n+  if (exact)\n     /* Exact size.  */\n-    alloc = num + -reserve;\n+    alloc = num + reserve;\n   else\n     {\n       /* Exponential growth. */\n@@ -85,28 +86,18 @@ calculate_allocation (const struct vec_prefix *pfx, int reserve)\n   return alloc;\n }\n \n-/* Ensure there are at least abs(RESERVE) free slots in VEC.  If\n-   RESERVE < 0 grow exactly, else grow exponentially.  As a special\n-   case, if VEC is NULL, and RESERVE is 0, no vector will be created. */\n+/* Ensure there are at least RESERVE free slots in VEC.  If EXACT grow\n+   exactly, else grow exponentially.  As a special case, if VEC is\n+   NULL and RESERVE is 0, no vector will be created.  The vector's\n+   trailing array is at VEC_OFFSET offset and consists of ELT_SIZE\n+   sized elements.  */\n \n-void *\n-vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_gc_o_reserve (vec, reserve,\n-\t\t\t   offsetof (struct vec_prefix, vec), sizeof (void *)\n-\t\t\t   PASS_MEM_STAT);\n-}\n-\n-/* As vec_gc_p_reserve, but for object vectors.  The vector's trailing\n-   array is at VEC_OFFSET offset and consists of ELT_SIZE sized\n-   elements.  */\n-\n-void *\n-vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n-\t\t   MEM_STAT_DECL)\n+static void *\n+vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n+\t\t    bool exact MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n-  unsigned alloc = alloc = calculate_allocation (pfx, reserve);\n+  unsigned alloc = alloc = calculate_allocation (pfx, reserve, exact);\n   \n   if (!alloc)\n     return NULL;\n@@ -119,24 +110,66 @@ vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   return vec;\n }\n \n-/* As for vec_gc_p_reserve, but for heap allocated vectors.  */\n+/* Ensure there are at least RESERVE free slots in VEC, growing\n+   exponentially.  If RESERVE < 0 grow exactly, else grow\n+   exponentially.  As a special case, if VEC is NULL, and RESERVE is\n+   0, no vector will be created. */\n \n void *\n-vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n+vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n-  return vec_heap_o_reserve (vec, reserve,\n-\t\t\t     offsetof (struct vec_prefix, vec), sizeof (void *)\n+  return vec_gc_o_reserve_1 (vec, reserve,\n+\t\t\t     offsetof (struct vec_prefix, vec),\n+\t\t\t     sizeof (void *), false\n \t\t\t     PASS_MEM_STAT);\n }\n \n-/* As for vec_gc_o_reserve, but for heap allocated vectors.  */\n+/* Ensure there are at least RESERVE free slots in VEC, growing\n+   exactly.  If RESERVE < 0 grow exactly, else grow exponentially.  As\n+   a special case, if VEC is NULL, and RESERVE is 0, no vector will be\n+   created. */\n \n void *\n-vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n-\t\t    MEM_STAT_DECL)\n+vec_gc_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n+{\n+  return vec_gc_o_reserve_1 (vec, reserve,\n+\t\t\t     offsetof (struct vec_prefix, vec),\n+\t\t\t     sizeof (void *), true\n+\t\t\t     PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_p_reserve, but for object vectors.  The vector's\n+   trailing array is at VEC_OFFSET offset and consists of ELT_SIZE\n+   sized elements.  */\n+\n+void *\n+vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n+\t\t  MEM_STAT_DECL)\n+{\n+  return vec_gc_o_reserve_1 (vec, reserve, vec_offset, elt_size, false\n+\t\t\t     PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_p_reserve_exact, but for object vectors.  The\n+   vector's trailing array is at VEC_OFFSET offset and consists of\n+   ELT_SIZE sized elements.  */\n+\n+void *\n+vec_gc_o_reserve_exact (void *vec, int reserve, size_t vec_offset,\n+\t\t\tsize_t elt_size MEM_STAT_DECL)\n+{\n+  return vec_gc_o_reserve_1 (vec, reserve, vec_offset, elt_size, true\n+\t\t\t     PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_o_reserve_1, but for heap allocated vectors.  */\n+\n+static void *\n+vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n+\t\t      size_t elt_size, bool exact MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n-  unsigned alloc = calculate_allocation (pfx, reserve);\n+  unsigned alloc = calculate_allocation (pfx, reserve, exact);\n \n   if (!alloc)\n     return NULL;\n@@ -149,6 +182,48 @@ vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   return vec;\n }\n \n+/* As for vec_gc_p_reserve, but for heap allocated vectors.  */\n+\n+void *\n+vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n+{\n+  return vec_heap_o_reserve_1 (vec, reserve,\n+\t\t\t       offsetof (struct vec_prefix, vec),\n+\t\t\t       sizeof (void *), false\n+\t\t\t       PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_p_reserve_exact, but for heap allocated vectors.  */\n+\n+void *\n+vec_heap_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n+{\n+  return vec_heap_o_reserve_1 (vec, reserve,\n+\t\t\t       offsetof (struct vec_prefix, vec),\n+\t\t\t       sizeof (void *), true\n+\t\t\t       PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_o_reserve, but for heap allocated vectors.  */\n+\n+void *\n+vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n+\t\t    MEM_STAT_DECL)\n+{\n+  return vec_heap_o_reserve_1 (vec, reserve, vec_offset, elt_size, false\n+\t\t\t       PASS_MEM_STAT);\n+}\n+\n+/* As for vec_gc_o_reserve_exact, but for heap allocated vectors.  */\n+\n+void *\n+vec_heap_o_reserve_exact (void *vec, int reserve, size_t vec_offset,\n+\t\t\t  size_t elt_size MEM_STAT_DECL)\n+{\n+  return vec_heap_o_reserve_1 (vec, reserve, vec_offset, elt_size, true\n+\t\t\t       PASS_MEM_STAT);\n+}\n+\n #if ENABLE_CHECKING\n /* Issue a vector domain error, and then fall over.  */\n "}, {"sha": "3bc6566a1bb6678c2ed4fcf72ea9983eca09e2e1", "filename": "gcc/vec.h", "status": "modified", "additions": 92, "deletions": 41, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=efb7e1e02617b779d8bd376d9dcccd0cdb4d3a94", "patch": "@@ -66,8 +66,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    least as many elements as you ask for, it will exponentially\n    increase if there are too few spare slots.  If you want reserve a\n    specific number of slots, but do not want the exponential increase\n-   (for instance, you know this is the last allocation), use a\n-   negative number for reservation.  You can also create a vector of a\n+   (for instance, you know this is the last allocation), use the\n+   reserve_exact operation.  You can also create a vector of a\n    specific size from the get go.\n \n    You should prefer the push and pop operations, as they append and\n@@ -238,16 +238,25 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Reserve space.\n    int VEC_T_A_reserve(VEC(T,A) *&v, int reserve);\n \n-   Ensure that V has at least abs(RESERVE) slots available.  The\n-   signedness of RESERVE determines the reallocation behavior.  A\n-   negative value will not create additional headroom beyond that\n-   requested.  A positive value will create additional headroom.  Note\n-   this can cause V to be reallocated.  Returns nonzero iff\n-   reallocation actually occurred.  */\n+   Ensure that V has at least RESERVE slots available.  This will\n+   create additional headroom.  Note this can cause V to be\n+   reallocated.  Returns nonzero iff reallocation actually\n+   occurred.  */\n \n #define VEC_reserve(T,A,V,R)\t\\\n \t(VEC_OP(T,A,reserve)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n \n+/* Reserve space exactly.\n+   int VEC_T_A_reserve_exact(VEC(T,A) *&v, int reserve);\n+\n+   Ensure that V has at least RESERVE slots available.  This will not\n+   create additional headroom.  Note this can cause V to be\n+   reallocated.  Returns nonzero iff reallocation actually\n+   occurred.  */\n+\n+#define VEC_reserve_exact(T,A,V,R)\t\\\n+\t(VEC_OP(T,A,reserve_exact)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n+\n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n@@ -411,11 +420,17 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n extern void *vec_gc_p_reserve (void *, int MEM_STAT_DECL);\n+extern void *vec_gc_p_reserve_exact (void *, int MEM_STAT_DECL);\n extern void *vec_gc_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void *vec_gc_o_reserve_exact (void *, int, size_t, size_t\n+\t\t\t\t     MEM_STAT_DECL);\n extern void ggc_free (void *);\n #define vec_gc_free(V) ggc_free (V)\n extern void *vec_heap_p_reserve (void *, int MEM_STAT_DECL);\n+extern void *vec_heap_p_reserve_exact (void *, int MEM_STAT_DECL);\n extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void *vec_heap_o_reserve_exact (void *, int, size_t, size_t\n+\t\t\t\t       MEM_STAT_DECL);\n #define vec_heap_free(V) free (V)\n \n #if ENABLE_CHECKING\n@@ -702,8 +717,8 @@ static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,alloc)\t\t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T,A) *) vec_##A##_p_reserve (NULL, -alloc_ PASS_MEM_STAT);  \\\n+  return (VEC(T,A) *) vec_##A##_p_reserve_exact (NULL, alloc_\t\t  \\\n+\t\t\t\t\t\t PASS_MEM_STAT);\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n@@ -721,9 +736,8 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation. */\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_p_reserve\t\t\t  \\\n-\t\t\t       (NULL, -len_ PASS_MEM_STAT));\t\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_p_reserve_exact\t\t  \\\n+\t\t\t       (NULL, len_ PASS_MEM_STAT));\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n       new_vec_->base.num = len_;\t\t\t\t\t  \\\n       memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n@@ -734,8 +748,7 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n static inline int VEC_OP (T,A,reserve)\t       \t\t\t\t  \\\n      (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n-\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n \t\t  \t\t\t\t\t\t\t  \\\n   if (extend)\t  \t\t\t\t\t\t\t  \\\n@@ -744,14 +757,28 @@ static inline int VEC_OP (T,A,reserve)\t       \t\t\t\t  \\\n   return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve_exact)  \t\t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  if (extend)\t  \t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_p_reserve_exact (*vec_, alloc_\t  \\\n+\t\t\t\t\t\t    PASS_MEM_STAT);\t  \\\n+\t\t  \t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n      (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n-\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n   VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -972,11 +999,10 @@ static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T,A) *) vec_##A##_o_reserve (NULL, -alloc_,\t\t  \\\n-                                           offsetof (VEC(T,A),base.vec),  \\\n-\t\t\t\t\t   sizeof (T)\t\t\t  \\\n-                                           PASS_MEM_STAT);\t\t  \\\n+  return (VEC(T,A) *) vec_##A##_o_reserve_exact (NULL, alloc_,\t\t  \\\n+\t\t\t\t\t\t offsetof (VEC(T,A),base.vec), \\\n+\t\t\t\t\t\t sizeof (T)\t\t  \\\n+\t\t\t\t\t\t PASS_MEM_STAT);\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n@@ -986,9 +1012,8 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation. */\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve\t\t\t  \\\n-\t\t\t       (NULL, -len_,\t\t\t\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve_exact\t\t  \\\n+\t\t\t       (NULL, len_,\t\t\t\t  \\\n \t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n \t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -1009,8 +1034,7 @@ static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n      (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n-\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (extend)\t\t\t\t\t\t\t\t  \\\n@@ -1022,14 +1046,30 @@ static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n   return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve_exact)   \t    \t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (extend)\t\t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t  \\\n+\t\t\t (*vec_, alloc_,\t\t\t\t  \\\n+\t\t\t  offsetof (VEC(T,A),base.vec),\t\t\t  \\\n+\t\t\t  sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n      (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n-\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n   VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -1064,11 +1104,9 @@ static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T,A) *) vec_##A##_o_reserve (NULL, -alloc_,\t\t  \\\n-                                           offsetof (VEC(T,A),base.vec),  \\\n-\t\t\t\t\t   sizeof (T)\t\t\t  \\\n-                                           PASS_MEM_STAT);\t\t  \\\n+  return (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t\t  \\\n+\t\t      (NULL, alloc_, offsetof (VEC(T,A),base.vec),\t  \\\n+\t\t       sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n@@ -1078,9 +1116,8 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation. */\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve\t\t\t  \\\n-\t\t\t       (NULL, -len_,\t\t\t\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve_exact\t\t  \\\n+\t\t\t       (NULL, len_,\t\t\t\t  \\\n \t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n \t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -1101,8 +1138,7 @@ static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n      (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n-\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (extend)\t\t\t\t\t\t\t\t  \\\n@@ -1114,14 +1150,29 @@ static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n   return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve_exact)   \t    \t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (extend)\t\t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t  \\\n+\t\t\t (*vec_, alloc_, offsetof (VEC(T,A),base.vec),\t  \\\n+\t\t\t  sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n      (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n-\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n   VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\"}]}