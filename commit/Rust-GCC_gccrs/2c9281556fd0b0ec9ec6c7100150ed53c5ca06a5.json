{"sha": "2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5MjgxNTU2ZmQwYjBlYzllYzZjNzEwMDE1MGVkNTNjNWNhMDZhNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-22T15:38:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-22T15:38:23Z"}, "message": "lto-streamer.h (lto_symtab_merge_cgraph_nodes): Declare.\n\n2009-10-22  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-streamer.h (lto_symtab_merge_cgraph_nodes): Declare.\n\t* lto-symtab.c (struct lto_symtab_entry_def): Add node member.\n\t(lto_symtab_merge): Do not merge cgraph nodes here.\n\t(lto_symtab_resolve_can_prevail_p): Simplify.\n\t(lto_symtab_resolve_symbols): Store cgraph node.\n\t(lto_symtab_merge_decls_1): Simplify.  Do not drop non-prevailing\n\tfunctions from the symtab.\n\t(lto_symtab_merge_cgraph_nodes_1): New function.\n\t(lto_symtab_merge_cgraph_nodes): Likewise.\n\n\tlto/\n\t* lto.c (lto_fixup_jump_functions): Remove.\n\t(lto_fixup_decls): Do not fixup jump functions.\n\t(read_cgraph_and_symbols): Schedule cgraph merging after\n\tsummary reading.  Schedule type and decl fixup before\n\tsummary reading.\n\nFrom-SVN: r153460", "tree": {"sha": "44c3670b0d26100af79b3e3c0f8a0456a2cd342f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44c3670b0d26100af79b3e3c0f8a0456a2cd342f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea989a1f5a0e68fac1a5673a6bf20dd7840615a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea989a1f5a0e68fac1a5673a6bf20dd7840615a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea989a1f5a0e68fac1a5673a6bf20dd7840615a9"}], "stats": {"total": 143, "additions": 74, "deletions": 69}, "files": [{"sha": "24928d2e011e1ac615a4de4f705cee8e3b3fe4b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "patch": "@@ -1,3 +1,15 @@\n+2009-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-streamer.h (lto_symtab_merge_cgraph_nodes): Declare.\n+\t* lto-symtab.c (struct lto_symtab_entry_def): Add node member.\n+\t(lto_symtab_merge): Do not merge cgraph nodes here.\n+\t(lto_symtab_resolve_can_prevail_p): Simplify.\n+\t(lto_symtab_resolve_symbols): Store cgraph node.\n+\t(lto_symtab_merge_decls_1): Simplify.  Do not drop non-prevailing\n+\tfunctions from the symtab.\n+\t(lto_symtab_merge_cgraph_nodes_1): New function.\n+\t(lto_symtab_merge_cgraph_nodes): Likewise.\n+\n 2009-10-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41791"}, {"sha": "de1ee080b84d5588538fd2a0fff75ac976ff1de2", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "patch": "@@ -845,6 +845,7 @@ void input_cgraph (void);\n extern void lto_symtab_register_decl (tree, ld_plugin_symbol_resolution_t,\n \t\t\t\t      struct lto_file_decl_data *);\n extern void lto_symtab_merge_decls (void);\n+extern void lto_symtab_merge_cgraph_nodes (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n extern enum ld_plugin_symbol_resolution lto_symtab_get_resolution (tree decl);\n "}, {"sha": "642b6235d90a0470c5783752949d6800c89b80ee", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "patch": "@@ -41,6 +41,9 @@ struct GTY(()) lto_symtab_entry_def\n   tree id;\n   /* The symbol table entry, a DECL.  */\n   tree decl;\n+  /* The cgraph node if decl is a function decl.  Filled in during the\n+     merging process.  */\n+  struct cgraph_node *node;\n   /* LTO file-data and symbol resolution for this decl.  */\n   struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n   enum ld_plugin_symbol_resolution resolution;\n@@ -232,18 +235,12 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n   tree prevailing_decl = prevailing->decl;\n   tree decl = entry->decl;\n   tree prevailing_type, type;\n-  struct cgraph_node *node;\n \n   /* Merge decl state in both directions, we may still end up using\n      the new decl.  */\n   TREE_ADDRESSABLE (prevailing_decl) |= TREE_ADDRESSABLE (decl);\n   TREE_ADDRESSABLE (decl) |= TREE_ADDRESSABLE (prevailing_decl);\n \n-  /* Replace a cgraph node of entry with the prevailing one.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && (node = cgraph_get_node (decl)) != NULL)\n-    lto_cgraph_replace_node (node, cgraph_get_node (prevailing_decl));\n-\n   /* The linker may ask us to combine two incompatible symbols.\n      Detect this case and notify the caller of required diagnostics.  */\n \n@@ -355,15 +352,12 @@ lto_symtab_resolve_replaceable_p (lto_symtab_entry_t e)\n static bool\n lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n {\n-  struct cgraph_node *node;\n-\n   if (!TREE_STATIC (e->decl))\n     return false;\n \n   /* For functions we need a non-discarded body.  */\n   if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-    return ((node = cgraph_get_node (e->decl))\n-\t    && node->analyzed);\n+    return (e->node && e->node->analyzed);\n \n   /* A variable should have a size.  */\n   else if (TREE_CODE (e->decl) == VAR_DECL)\n@@ -393,6 +387,9 @@ lto_symtab_resolve_symbols (void **slot)\n      diagnose ODR violations.  */\n   for (; e; e = e->next)\n     {\n+      if (TREE_CODE (e->decl) == FUNCTION_DECL)\n+\te->node = cgraph_get_node (e->decl);\n+\n       if (!lto_symtab_resolve_can_prevail_p (e))\n \t{\n \t  e->resolution = LDPR_RESOLVED_IR;\n@@ -531,7 +528,7 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n       prevailing = (lto_symtab_entry_t) *slot;\n       /* For functions choose one with a cgraph node.  */\n       if (TREE_CODE (prevailing->decl) == FUNCTION_DECL)\n-\twhile (!cgraph_get_node (prevailing->decl)\n+\twhile (!prevailing->node\n \t       && prevailing->next)\n \t  prevailing = prevailing->next;\n       /* We do not stream varpool nodes, so the first decl has to\n@@ -600,7 +597,8 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   lto_symtab_merge_decls_2 (slot);\n \n   /* Drop all but the prevailing decl from the symtab.  */\n-  prevailing->next = NULL;\n+  if (TREE_CODE (prevailing->decl) != FUNCTION_DECL)\n+    prevailing->next = NULL;\n \n   return 1;\n }\n@@ -614,6 +612,40 @@ lto_symtab_merge_decls (void)\n   htab_traverse (lto_symtab_identifiers, lto_symtab_merge_decls_1, NULL);\n }\n \n+/* Helper to process the decl chain for the symbol table entry *SLOT.  */\n+\n+static int\n+lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  lto_symtab_entry_t e, prevailing = (lto_symtab_entry_t) *slot;\n+\n+  if (!prevailing->next)\n+    return 1;\n+\n+  gcc_assert (TREE_CODE (prevailing->decl) == FUNCTION_DECL);\n+\n+  /* Replace the cgraph node of each entry with the prevailing one.  */\n+  for (e = prevailing->next; e; e = e->next)\n+    {\n+      if (e->node != NULL)\n+\tlto_cgraph_replace_node (e->node, prevailing->node);\n+    }\n+\n+  /* Drop all but the prevailing decl from the symtab.  */\n+  prevailing->next = NULL;\n+\n+  return 1;\n+}\n+\n+/* Merge cgraph nodes according to the symbol merging done by\n+   lto_symtab_merge_decls.  */\n+\n+void\n+lto_symtab_merge_cgraph_nodes (void)\n+{\n+  lto_symtab_maybe_init_hash_table ();\n+  htab_traverse (lto_symtab_identifiers, lto_symtab_merge_cgraph_nodes_1, NULL);\n+}\n \n /* Given the decl DECL, return the prevailing decl with the same name. */\n "}, {"sha": "d6c3325846dc13fc1030bd538191585212015842", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "patch": "@@ -1,3 +1,11 @@\n+2009-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (lto_fixup_jump_functions): Remove.\n+\t(lto_fixup_decls): Do not fixup jump functions.\n+\t(read_cgraph_and_symbols): Schedule cgraph merging after\n+\tsummary reading.  Schedule type and decl fixup before\n+\tsummary reading.\n+\n 2009-10-22  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (lto_fixup_data_t): Remove free_list member."}, {"sha": "54fde65c69a65a85ae74ff7b2488f7a5d570235a", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 9, "deletions": 57, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=2c9281556fd0b0ec9ec6c7100150ed53c5ca06a5", "patch": "@@ -1635,53 +1635,6 @@ lto_fixup_state_aux (void **slot, void *aux)\n   return 1;\n }\n \n-/* Fixup pointers in jump functions.\n-   TODO: We need some generic solution that will allow tree pointers in\n-   function summaries.  */\n-static void\n-lto_fixup_jump_functions (lto_fixup_data_t * data)\n-{\n-  struct cgraph_node *node;\n-  struct cgraph_edge *cs;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (!node->analyzed)\n-\tcontinue;\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  int i;\n-\t  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n-\t  for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n-\t    {\n-\t      struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n-\t      switch (jf->type)\n-\t\t{\n-\t\tcase IPA_JF_UNKNOWN:\n-\t\t  break;\n-\t\tcase IPA_JF_CONST:\n-\t\t  walk_tree (&jf->value.constant, lto_fixup_tree, data, NULL);\n-\t\t  break;\n-\t\tcase IPA_JF_PASS_THROUGH:\n-\t\t  walk_tree (&jf->value.pass_through.operand, lto_fixup_tree,\n-\t\t\t     data, NULL);\n-\t\t  break;\n-\t\tcase IPA_JF_ANCESTOR:\n-\t\t  walk_tree (&jf->value.ancestor.type, lto_fixup_tree, data,\n-\t\t\t     NULL);\n-\t\t  break;\n-\t\tcase IPA_JF_CONST_MEMBER_PTR:\n-\t\t  walk_tree (&jf->value.member_cst.pfn, lto_fixup_tree, data,\n-\t\t\t     NULL);\n-\t\t  walk_tree (&jf->value.member_cst.delta, lto_fixup_tree,\n-\t\t\t     data, NULL);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Fix the decls from all FILES. Replaces each decl with the corresponding\n    prevailing one.  */\n \n@@ -1710,8 +1663,6 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n       if (decl != saved_decl)\n \tVEC_replace (tree, lto_global_var_decls, i, decl);\n     }\n-  if (ipa_edge_args_vector)\n-    lto_fixup_jump_functions (&data);\n \n   pointer_set_destroy (seen);\n }\n@@ -1851,11 +1802,18 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Read the callgraph.  */\n   input_cgraph ();\n \n+  /* Merge global decls.  */\n+  lto_symtab_merge_decls ();\n+\n+  /* Fixup all decls and types and free the type hash tables.  */\n+  lto_fixup_decls (all_file_decl_data);\n+  free_gimple_type_tables ();\n+\n   /* Read the IPA summary data.  */\n   ipa_read_summaries ();\n \n-  /* Merge global decls.  */\n-  lto_symtab_merge_decls ();\n+  /* Finally merge the cgraph according to the decl merging decisions.  */\n+  lto_symtab_merge_cgraph_nodes ();\n \n   /* Mark cgraph nodes needed in the merged cgraph\n      This normally happens in whole-program pass, but for\n@@ -1872,12 +1830,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   timevar_push (TV_IPA_LTO_DECL_IO);\n \n-  /* Fixup all decls and types.  */\n-  lto_fixup_decls (all_file_decl_data);\n-\n-  /* Free the type hash tables.  */\n-  free_gimple_type_tables ();\n-\n   /* FIXME lto. This loop needs to be changed to use the pass manager to\n      call the ipa passes directly.  */\n   if (!errorcount)"}]}