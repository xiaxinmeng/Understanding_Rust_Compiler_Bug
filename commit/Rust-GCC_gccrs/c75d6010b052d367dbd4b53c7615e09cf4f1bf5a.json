{"sha": "c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1ZDYwMTBiMDUyZDM2N2RiZDRiNTNjNzYxNWUwOWNmNGYxYmY1YQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-11-09T17:06:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-11-09T17:06:03Z"}, "message": "re PR target/18230 (SPARC VIS instructions are not generated by GCC)\n\n\tPR target/18230\n\t* doc/md.texi (SPARC constraints): Document 'Y' constraint.\n\t* config/sparc/sparc-modes.def: Add vector modes of 4 and 8 bytes.\n\t* config/sparc/sparc.c (sparc_vector_mode_supported_p): New function.\n\t(TARGET_VECTOR_MODE_SUPPORTED_P): Set to sparc_vector_mode_supported_p.\n\t(fp_zero_operand): Accept MODE_VECTOR_INT modes.\n\t(input_operand): Accept CONST_VECTOR with MODE_VECTOR_INT modes.\n\t(sparc_cannot_force_const_mem): Return false for CONST_VECTOR.\n\t(sparc_init_modes): Set sparc_mode_class to SF_MODE or DF_MODE for\n\tMODE_VECTOR_INT modes.\n\t(sparc_extra_constraint_check): Add new constraint 'Y'.\n\t* config/sparc/sparc.h: Define UNITS_PER_SIMD_WORD to 8 for TARGET_VIS.\n\t* config/sparc/sparc.md (V32): New mode macro for 32-bit modes.\n\t(V64): New mode macro for 64-bit modes.\n\t(movsf): Use V32 for mode instead of SF.\n\t(movsf_insn_vis): Use V32 for mode instead of SF.  Add 'Y' constraint\n\talongside 'G' constraint.\n\t(movdf): Use V64 for mode instead of DF.\n\t(movdf_insn_v9only_vis, modf_insn_sp64_vis): Use V64 for mode instead\n\tof DF.  Add 'Y' constraint alongside 'G' constraint.\n\t(multi-isn and misaligned mems DFmode splitters): Use V64 for mode\n\tinstead of DF.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@libertysurf.fr>\n\nFrom-SVN: r90348", "tree": {"sha": "674046a0364c024f7b74eb9076fb8b241aec8ad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/674046a0364c024f7b74eb9076fb8b241aec8ad0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/comments", "author": null, "committer": null, "parents": [{"sha": "26a8930190b8a1e9f7afb866870e85ec48c7b9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a8930190b8a1e9f7afb866870e85ec48c7b9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a8930190b8a1e9f7afb866870e85ec48c7b9be"}], "stats": {"total": 297, "additions": 202, "deletions": 95}, "files": [{"sha": "5ce802b6d144d40cb8a46f800bd6f73efe134316", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -1,3 +1,29 @@\n+2004-11-09  James A. Morrison  <phython@gcc.gnu.org>\n+            Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/18230\n+\t* doc/md.texi (SPARC constraints): Document 'Y' constraint.\n+\t* config/sparc/sparc-modes.def: Add vector modes of 4 and 8 bytes.\n+\t* config/sparc/sparc.c (sparc_vector_mode_supported_p): New function.\n+\t(TARGET_VECTOR_MODE_SUPPORTED_P): Set to sparc_vector_mode_supported_p.\n+\t(fp_zero_operand): Accept MODE_VECTOR_INT modes.\n+\t(input_operand): Accept CONST_VECTOR with MODE_VECTOR_INT modes.\n+\t(sparc_cannot_force_const_mem): Return false for CONST_VECTOR.\n+\t(sparc_init_modes): Set sparc_mode_class to SF_MODE or DF_MODE for\n+\tMODE_VECTOR_INT modes.\n+\t(sparc_extra_constraint_check): Add new constraint 'Y'.\n+\t* config/sparc/sparc.h: Define UNITS_PER_SIMD_WORD to 8 for TARGET_VIS.\n+\t* config/sparc/sparc.md (V32): New mode macro for 32-bit modes.\n+\t(V64): New mode macro for 64-bit modes.\n+\t(movsf): Use V32 for mode instead of SF.\n+\t(movsf_insn_vis): Use V32 for mode instead of SF.  Add 'Y' constraint\n+\talongside 'G' constraint.\n+\t(movdf): Use V64 for mode instead of DF.\n+\t(movdf_insn_v9only_vis, modf_insn_sp64_vis): Use V64 for mode instead\n+\tof DF.  Add 'Y' constraint alongside 'G' constraint.\n+\t(multi-isn and misaligned mems DFmode splitters): Use V64 for mode\n+\tinstead of DF.\n+\n 2004-11-09  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_select_ccmode): Return CCAPmode for"}, {"sha": "bf85aed5bec3c44ecb009d48605c13157fbb6e81", "filename": "gcc/config/sparc/sparc-modes.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GCC, for Sun SPARC.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n@@ -42,3 +42,7 @@ CC_MODE (CC_NOOV);\n CC_MODE (CCX_NOOV);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);\n+\n+/* Vector modes.  */\n+VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n+VECTOR_MODES (INT, 4);        /*       V4QI V2HI */"}, {"sha": "0f3488492ed4161d0992c275d6fc666405c678d2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -348,6 +348,7 @@ static rtx sparc_struct_value_rtx (tree, int);\n static bool sparc_return_in_memory (tree, tree);\n static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n static tree sparc_gimplify_va_arg (tree, tree, tree *, tree *);\n+static bool sparc_vector_mode_supported_p (enum machine_mode);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, bool);\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n@@ -466,6 +467,9 @@ enum processor_type sparc_cpu;\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR sparc_gimplify_va_arg\n \n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P sparc_vector_mode_supported_p\n+\n #ifdef SUBTARGET_INSERT_ATTRIBUTES\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES SUBTARGET_INSERT_ATTRIBUTES\n@@ -769,7 +773,8 @@ const1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n fp_zero_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_MODE_CLASS (GET_MODE (op)) != MODE_FLOAT)\n+  enum mode_class mclass = GET_MODE_CLASS (GET_MODE (op));\n+  if (mclass != MODE_FLOAT && mclass != MODE_VECTOR_INT)\n     return 0;\n   return op == CONST0_RTX (mode);\n }\n@@ -1498,6 +1503,8 @@ clobbered_register (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n input_operand (rtx op, enum machine_mode mode)\n {\n+  enum mode_class mclass;\n+\n   /* If both modes are non-void they must be the same.  */\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1538,8 +1545,9 @@ input_operand (rtx op, enum machine_mode mode)\n   if (register_operand (op, mode))\n     return 1;\n \n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_CODE (op) == CONST_DOUBLE)\n+  mclass = GET_MODE_CLASS (mode);\n+  if ((mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)\n+      || (mclass == MODE_VECTOR_INT && GET_CODE (op) == CONST_VECTOR))\n     return 1;\n \n   /* If this is a SUBREG, look inside so that we handle\n@@ -3293,6 +3301,7 @@ sparc_cannot_force_const_mem (rtx x)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n       /* Accept all non-symbolic constants.  */\n       return false;\n \n@@ -4181,6 +4190,12 @@ sparc_init_modes (void)\n \t  else \n \t    sparc_mode_class[i] = 0;\n \t  break;\n+\tcase MODE_VECTOR_INT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    sparc_mode_class[i] = 1 << (int)SF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    sparc_mode_class[i] = 1 << (int)DF_MODE;\n+\t  break;\n \tcase MODE_FLOAT:\n \tcase MODE_COMPLEX_FLOAT:\n \t  if (GET_MODE_SIZE (i) <= 4)\n@@ -6263,6 +6278,15 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   return build_va_arg_indirect_ref (addr);\n }\n \f\n+/* Implement the TARGET_VECTOR_MODE_SUPPORTED_P target hook.\n+   Specify whether the vector mode is supported by the hardware.  */\n+\n+static bool\n+sparc_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  return TARGET_VIS && VECTOR_MODE_P (mode) ? true : false;\n+}\n+\f\n /* Return the string to output an unconditional branch to LABEL, which is\n    the operand number of the label.\n \n@@ -8445,6 +8469,9 @@ sparc_extra_constraint_check (rtx op, int c, int strict)\n     case 'T':\n       break;\n \n+    case 'Y':\n+      return fp_zero_operand (op, GET_MODE (op));\n+\n     default:\n       return 0;\n     }"}, {"sha": "37f1905bb58cbb902e5a2cb5319c1c546a53e06e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -769,6 +769,8 @@ extern struct sparc_cpu_select sparc_select[];\n #define MIN_UNITS_PER_WORD\t4\n #endif\n \n+#define UNITS_PER_SIMD_WORD\t(TARGET_VIS ? 8 : 0)\n+\n /* Now define the sizes of the C data types.  */\n \n #define SHORT_TYPE_SIZE\t\t16\n@@ -2042,7 +2044,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n        integer register, needed for ldd/std instructions.\n \n    'W' handles the memory operand when moving operands in/out\n-       of 'e' constraint floating point registers.  */\n+       of 'e' constraint floating point registers.\n+\n+   'Y' handles the zero vector constant.  */\n \n #ifndef REG_OK_STRICT\n "}, {"sha": "0118a3c30372850e235156cd1b85708758e521d6", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 132, "deletions": 89, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -2207,6 +2207,10 @@\n   [(set_attr \"type\" \"*,*,*,load,store,fpmove,fpload,fpstore\")\n    (set_attr \"fptype\" \"*,*,*,*,*,double,*,*\")])\n \n+;; We don't define V1SI because SI should work just fine.\n+(define_mode_macro V64 [DF V4HI V8QI V2SI])\n+(define_mode_macro V32 [SF V2HI V4QI])\n+\n (define_insn \"*movdi_insn_sp64_vis\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?W,b\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e,J\"))]\n@@ -2627,12 +2631,12 @@\n   [(set_attr \"type\" \"fpmove,*,*,*,*,load,fpload,fpstore,store\")])\n \n (define_insn \"*movsf_insn_vis\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,*r,*r,*r,f,m,m\")\n-\t(match_operand:SF 1 \"input_operand\"         \"f,G,G,Q,*rR,S,m,m,f,*rG\"))]\n+  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"=f,f,*r,*r,*r,*r,*r,f,m,m\")\n+\t(match_operand:V32 1 \"input_operand\"         \"f,GY,GY,Q,*rR,S,m,m,f,*rGY\"))]\n   \"(TARGET_FPU && TARGET_VIS)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || fp_zero_operand (operands[1], SFmode))\"\n+   && (register_operand (operands[0], <V32:MODE>mode)\n+       || register_operand (operands[1], <V32:MODE>mode)\n+       || fp_zero_operand (operands[1], <V32:MODE>mode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 3\n@@ -2718,6 +2722,8 @@\n }\n   [(set_attr \"type\" \"*,*,*,*,load,store\")])\n \n+;; The following 3 patterns build SFmode constants in integer registers.\n+\n (define_insn \"*movsf_lo_sum\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n         (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n@@ -2756,27 +2762,29 @@\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n+;; Yes, you guessed it right, the former movsf expander.\n+(define_expand \"mov<V32:mode>\"\n+  [(set (match_operand:V32 0 \"general_operand\" \"\")\n+\t(match_operand:V32 1 \"general_operand\" \"\"))]\n+  \"<V32:MODE>mode == SFmode || TARGET_VIS\"\n {\n-  /* Force SFmode constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && CONSTANT_P (operands[1]))\n+  /* Force constants into memory.  */\n+  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n     {\n       /* emit_group_store will send such bogosity to us when it is\n          not storing directly into memory.  So fix this up to avoid\n          crashes in output_constant_pool.  */\n       if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (SFmode);\n+        operands[1] = CONST0_RTX (<V32:MODE>mode);\n \n-      if (TARGET_VIS && fp_zero_operand (operands[1], SFmode))\n+      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n+\t  && fp_zero_operand (operands[1], <V32:MODE>mode))\n \tgoto movsf_is_ok;\n \n       /* We are able to build any SF constant in integer registers\n \t with at most 2 instructions.  */\n-      if (REGNO (operands[0]) < 32)\n+      if (REGNO (operands[0]) < 32\n+\t  && <V32:MODE>mode == SFmode)\n \tgoto movsf_is_ok;\n \n       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n@@ -2786,14 +2794,14 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], SFmode)\n-\t  || fp_zero_operand (operands[1], SFmode))\n+      if (register_operand (operands[1], <V32:MODE>mode)\n+\t  || fp_zero_operand (operands[1], <V32:MODE>mode))\n \tgoto movsf_is_ok;\n \n       if (! reload_in_progress)\n \t{\n \t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (SFmode, operands[1]);\n+\t  operands[1] = force_reg (<V32:MODE>mode, operands[1]);\n \t}\n     }\n \n@@ -2802,12 +2810,12 @@\n     {\n       if (CONSTANT_P (operands[1])\n \t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], SFmode, 0);\n+\toperands[1] = legitimize_pic_address (operands[1], <V32:MODE>mode, 0);\n \n-      if (symbolic_operand (operands[1], SFmode))\n+      if (symbolic_operand (operands[1], <V32:MODE>mode))\n \t{\n \t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tSFmode,\n+\t\t\t\t\t\t<V32:MODE>mode,\n \t\t\t\t\t\t(reload_in_progress ?\n \t\t\t\t\t\t operands[0] :\n \t\t\t\t\t\t NULL_RTX));\n@@ -2818,27 +2826,28 @@\n   ;\n })\n \n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n+;; Yes, you again guessed it right, the former movdf expander.\n+(define_expand \"mov<V64:mode>\"\n+  [(set (match_operand:V64 0 \"general_operand\" \"\")\n+\t(match_operand:V64 1 \"general_operand\" \"\"))]\n+  \"<V64:MODE>mode == DFmode || TARGET_VIS\"\n {\n-  /* Force DFmode constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && CONSTANT_P (operands[1]))\n+  /* Force constants into memory.  */\n+  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n     {\n       /* emit_group_store will send such bogosity to us when it is\n          not storing directly into memory.  So fix this up to avoid\n          crashes in output_constant_pool.  */\n       if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (DFmode);\n+        operands[1] = CONST0_RTX (<V64:MODE>mode);\n \n       if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && fp_zero_operand (operands[1], DFmode))\n+\t  && fp_zero_operand (operands[1], <V64:MODE>mode))\n \tgoto movdf_is_ok;\n \n       /* We are able to build any DF constant in integer registers.  */\n       if (REGNO (operands[0]) < 32\n+\t  && <V64:MODE>mode == DFmode\n \t  && (reload_completed || reload_in_progress))\n \tgoto movdf_is_ok;\n \n@@ -2849,14 +2858,14 @@\n   /* Handle MEM cases first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], DFmode)\n-\t  || fp_zero_operand (operands[1], DFmode))\n+      if (register_operand (operands[1], <V64:MODE>mode)\n+\t  || fp_zero_operand (operands[1], <V64:MODE>mode))\n \tgoto movdf_is_ok;\n \n       if (! reload_in_progress)\n \t{\n \t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (DFmode, operands[1]);\n+\t  operands[1] = force_reg (<V64:MODE>mode, operands[1]);\n \t}\n     }\n \n@@ -2865,12 +2874,12 @@\n     {\n       if (CONSTANT_P (operands[1])\n \t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], DFmode, 0);\n+\toperands[1] = legitimize_pic_address (operands[1], <V64:MODE>mode, 0);\n \n-      if (symbolic_operand (operands[1], DFmode))\n+      if (symbolic_operand (operands[1], <V64:MODE>mode))\n \t{\n \t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tDFmode,\n+\t\t\t\t\t\t<V64:MODE>mode,\n \t\t\t\t\t\t(reload_in_progress ?\n \t\t\t\t\t\t operands[0] :\n \t\t\t\t\t\t NULL_RTX));\n@@ -2969,14 +2978,14 @@\n ;; We have available v9 double floats but not 64-bit\n ;; integer registers but we have VIS.\n (define_insn \"*movdf_insn_v9only_vis\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,e,T,W,U,T,f,*r,o\")\n-        (match_operand:DF 1 \"input_operand\" \"G,e,W#F,G,e,T,U,o#F,*roGF,*rGf\"))]\n+  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=e,e,e,T,W,U,T,f,*r,o\")\n+        (match_operand:V64 1 \"input_operand\" \"GY,e,W#F,GY,e,T,U,o#F,*roGYF,*rGYf\"))]\n   \"TARGET_FPU\n    && TARGET_VIS\n    && ! TARGET_ARCH64\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+   && (register_operand (operands[0], <V64:MODE>mode)\n+       || register_operand (operands[1], <V64:MODE>mode)\n+       || fp_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -3018,14 +3027,14 @@\n ;; We have available both v9 double floats and 64-bit\n ;; integer registers. And we have VIS.\n (define_insn \"*movdf_insn_sp64_vis\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,e,W,*r,*r,m,*r\")\n-        (match_operand:DF 1 \"input_operand\"    \"G,e,W#F,e,*rG,m,*rG,F\"))]\n+  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=e,e,e,W,*r,*r,m,*r\")\n+        (match_operand:V64 1 \"input_operand\"    \"GY,e,W#F,e,*rGY,m,*rGY,F\"))]\n   \"TARGET_FPU\n    && TARGET_VIS\n    && TARGET_ARCH64\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+   && (register_operand (operands[0], <V64:MODE>mode)\n+       || register_operand (operands[1], <V64:MODE>mode)\n+       || fp_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -3053,6 +3062,7 @@\n   stx\\t%r1, %0\"\n   [(set_attr \"type\" \"*,load,store\")])\n \n+;; This pattern build DFmode constants in integer registers.\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]\n@@ -3112,8 +3122,8 @@\n ;; careful when V9 but not ARCH64 because the integer\n ;; register DFmode cases must be handled.\n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"register_operand\" \"\")\n+        (match_operand:V64 1 \"register_operand\" \"\"))]\n   \"(! TARGET_V9\n     || (! TARGET_ARCH64\n         && ((GET_CODE (operands[0]) == REG\n@@ -3128,100 +3138,126 @@\n   rtx set_src = operands[1];\n   rtx dest1, dest2;\n   rtx src1, src2;\n+  enum machine_mode half_mode;\n \n-  dest1 = gen_highpart (SFmode, set_dest);\n-  dest2 = gen_lowpart (SFmode, set_dest);\n-  src1 = gen_highpart (SFmode, set_src);\n-  src2 = gen_lowpart (SFmode, set_src);\n+  /* We can be expanded for DFmode or integral vector modes.  */\n+  if (<V64:MODE>mode == DFmode)\n+    half_mode = SFmode;\n+  else\n+    half_mode = SImode;\n+  \n+  dest1 = gen_highpart (half_mode, set_dest);\n+  dest2 = gen_lowpart (half_mode, set_dest);\n+  src1 = gen_highpart (half_mode, set_src);\n+  src2 = gen_lowpart (half_mode, set_src);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n   if (reg_overlap_mentioned_p (dest1, src2))\n     {\n-      emit_insn (gen_movsf (dest2, src2));\n-      emit_insn (gen_movsf (dest1, src1));\n+      emit_move_insn_1 (dest2, src2);\n+      emit_move_insn_1 (dest1, src1);\n     }\n   else\n     {\n-      emit_insn (gen_movsf (dest1, src1));\n-      emit_insn (gen_movsf (dest2, src2));\n+      emit_move_insn_1 (dest1, src1);\n+      emit_move_insn_1 (dest2, src2);\n     }\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(match_operand:DF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"register_operand\" \"\")\n+\t(match_operand:V64 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && (((REGNO (operands[0]) % 2) != 0)\n        || ! mem_min_alignment (operands[1], 8))\n    && offsettable_memref_p (operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0 = adjust_address (operands[1], SFmode, 0);\n-  rtx word1 = adjust_address (operands[1], SFmode, 4);\n+  enum machine_mode half_mode;\n+  rtx word0, word1;\n+\n+  /* We can be expanded for DFmode or integral vector modes.  */\n+  if (<V64:MODE>mode == DFmode)\n+    half_mode = SFmode;\n+  else\n+    half_mode = SImode;\n+\n+  word0 = adjust_address (operands[1], half_mode, 0);\n+  word1 = adjust_address (operands[1], half_mode, 4);\n \n-  if (reg_overlap_mentioned_p (gen_highpart (SFmode, operands[0]), word1))\n+  if (reg_overlap_mentioned_p (gen_highpart (half_mode, operands[0]), word1))\n     {\n-      emit_insn (gen_movsf (gen_lowpart (SFmode, operands[0]),\n-\t\t\t    word1));\n-      emit_insn (gen_movsf (gen_highpart (SFmode, operands[0]),\n-\t\t\t    word0));\n+      emit_move_insn_1 (gen_lowpart (half_mode, operands[0]), word1);\n+      emit_move_insn_1 (gen_highpart (half_mode, operands[0]), word0);\n     }\n   else\n     {\n-      emit_insn (gen_movsf (gen_highpart (SFmode, operands[0]),\n-\t\t\t    word0));\n-      emit_insn (gen_movsf (gen_lowpart (SFmode, operands[0]),\n-\t\t\t    word1));\n+      emit_move_insn_1 (gen_highpart (half_mode, operands[0]), word0);\n+      emit_move_insn_1 (gen_lowpart (half_mode, operands[0]), word1);\n     }\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n-\t(match_operand:DF 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"memory_operand\" \"\")\n+\t(match_operand:V64 1 \"register_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && (((REGNO (operands[1]) % 2) != 0)\n        || ! mem_min_alignment (operands[0], 8))\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  rtx word0 = adjust_address (operands[0], SFmode, 0);\n-  rtx word1 = adjust_address (operands[0], SFmode, 4);\n+  enum machine_mode half_mode;\n+  rtx word0, word1;\n \n-  emit_insn (gen_movsf (word0,\n-\t\t\tgen_highpart (SFmode, operands[1])));\n-  emit_insn (gen_movsf (word1,\n-\t\t\tgen_lowpart (SFmode, operands[1])));\n+  /* We can be expanded for DFmode or integral vector modes.  */\n+  if (<V64:MODE>mode == DFmode)\n+    half_mode = SFmode;\n+  else\n+    half_mode = SImode;\n+\n+  word0 = adjust_address (operands[0], half_mode, 0);\n+  word1 = adjust_address (operands[0], half_mode, 4);\n+\n+  emit_move_insn_1 (word0, gen_highpart (half_mode, operands[1]));\n+  emit_move_insn_1 (word1, gen_lowpart (half_mode, operands[1]));\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n-        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"memory_operand\" \"\")\n+        (match_operand:V64 1 \"fp_zero_operand\" \"\"))]\n   \"reload_completed\n    && (! TARGET_V9\n        || (! TARGET_ARCH64\n \t   && ! mem_min_alignment (operands[0], 8)))\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n+  enum machine_mode half_mode;\n   rtx dest1, dest2;\n \n-  dest1 = adjust_address (operands[0], SFmode, 0);\n-  dest2 = adjust_address (operands[0], SFmode, 4);\n+  /* We can be expanded for DFmode or integral vector modes.  */\n+  if (<V64:MODE>mode == DFmode)\n+    half_mode = SFmode;\n+  else\n+    half_mode = SImode;\n+\n+  dest1 = adjust_address (operands[0], half_mode, 0);\n+  dest2 = adjust_address (operands[0], half_mode, 4);\n \n-  emit_insn (gen_movsf (dest1, CONST0_RTX (SFmode)));\n-  emit_insn (gen_movsf (dest2, CONST0_RTX (SFmode)));\n+  emit_move_insn_1 (dest1, CONST0_RTX (half_mode));\n+  emit_move_insn_1 (dest2, CONST0_RTX (half_mode));\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"register_operand\" \"\")\n+        (match_operand:V64 1 \"fp_zero_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && ((GET_CODE (operands[0]) == REG\n@@ -3231,13 +3267,20 @@\n \t   && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(clobber (const_int 0))]\n {\n+  enum machine_mode half_mode;\n   rtx set_dest = operands[0];\n   rtx dest1, dest2;\n \n-  dest1 = gen_highpart (SFmode, set_dest);\n-  dest2 = gen_lowpart (SFmode, set_dest);\n-  emit_insn (gen_movsf (dest1, CONST0_RTX (SFmode)));\n-  emit_insn (gen_movsf (dest2, CONST0_RTX (SFmode)));\n+  /* We can be expanded for DFmode or integral vector modes.  */\n+  if (<V64:MODE>mode == DFmode)\n+    half_mode = SFmode;\n+  else\n+    half_mode = SImode;\n+\n+  dest1 = gen_highpart (half_mode, set_dest);\n+  dest2 = gen_lowpart (half_mode, set_dest);\n+  emit_move_insn_1 (dest1, CONST0_RTX (half_mode));\n+  emit_move_insn_1 (dest2, CONST0_RTX (half_mode));\n   DONE;\n })\n "}, {"sha": "adf9fe5d1951d86cb9d235f356cd5c3ecd234770", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75d6010b052d367dbd4b53c7615e09cf4f1bf5a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=c75d6010b052d367dbd4b53c7615e09cf4f1bf5a", "patch": "@@ -2367,7 +2367,10 @@ Memory address aligned to an 8-byte boundary\n Even register\n \n @item W\n-Memory address for @samp{e} constraint registers.\n+Memory address for @samp{e} constraint registers\n+\n+@item Y\n+Vector zero\n \n @end table\n "}]}