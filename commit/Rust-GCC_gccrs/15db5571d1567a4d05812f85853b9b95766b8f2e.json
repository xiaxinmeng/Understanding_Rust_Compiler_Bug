{"sha": "15db5571d1567a4d05812f85853b9b95766b8f2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkYjU1NzFkMTU2N2E0ZDA1ODEyZjg1ODUzYjliOTU3NjZiOGYyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-19T16:04:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-19T16:04:03Z"}, "message": "basic-block.h (update_bb_profile_after_threading): Declare.\n\n\t* basic-block.h (update_bb_profile_after_threading): Declare.\n\t* cfg.c (update_bb_profile_after_threading): Break out from ...\n\t* cfgcleanup.c (try_forward_edges): ... here; use it.\n\t* tree-ssa-dom.c (thread_across_edge): Use it.\n\t* tree-ssa-threadupdate.c (create_block_for_threading): Zero out\n\tprofile of the new BB.\n\nFrom-SVN: r87730", "tree": {"sha": "2864608d6a5ce3c527756be3a276cd609e29f91f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2864608d6a5ce3c527756be3a276cd609e29f91f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15db5571d1567a4d05812f85853b9b95766b8f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15db5571d1567a4d05812f85853b9b95766b8f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15db5571d1567a4d05812f85853b9b95766b8f2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15db5571d1567a4d05812f85853b9b95766b8f2e/comments", "author": null, "committer": null, "parents": [{"sha": "9714133875a19fcb1258b79d8c035d7a8d240d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9714133875a19fcb1258b79d8c035d7a8d240d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9714133875a19fcb1258b79d8c035d7a8d240d61"}], "stats": {"total": 115, "additions": 89, "deletions": 26}, "files": [{"sha": "6bc408a20c71116aa1a327355d2bdde59d186a70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -1,3 +1,12 @@\n+2004-09-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (update_bb_profile_after_threading): Declare.\n+\t* cfg.c (update_bb_profile_after_threading): Break out from ...\n+\t* cfgcleanup.c (try_forward_edges): ... here; use it.\n+\t* tree-ssa-dom.c (thread_across_edge): Use it.\n+\t* tree-ssa-threadupdate.c (create_block_for_threading): Zero out\n+\tprofile of the new BB.\n+\n 2004-09-19  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-pre.c (insert_into_set): Don't put"}, {"sha": "21fd7bb3babf98cf1aa1d8b83ddde24a197c68d3", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -746,6 +746,7 @@ extern basic_block next_dom_son (enum cdi_direction, basic_block);\n extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void break_superblocks (void);\n extern void check_bb_profile (basic_block, FILE *);\n+extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n \n #include \"cfghooks.h\"\n "}, {"sha": "b5d28c3bed6421da7d01da406ae50f0b99b9a594", "filename": "gcc/cfg.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -888,3 +888,64 @@ brief_dump_cfg (FILE *file)\n       dump_cfg_bb_info (file, bb);\n     }\n }\n+\n+/* An edge originally destinating BB of FREQUENCY and COUNT has been proved to\n+   leave the block by TAKEN_EDGE.  Update profile of BB such that edge E can be\n+   redirected to destiantion of TAKEN_EDGE. \n+\n+   This function may leave the profile inconsistent in the case TAKEN_EDGE\n+   frequency or count is believed to be lower than FREQUENCY or COUNT\n+   respectivly.  */\n+void\n+update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n+\t\t\t\t gcov_type count, edge taken_edge)\n+{\n+  edge c;\n+  int prob;\n+\n+  bb->count -= count;\n+  if (bb->count < 0)\n+    bb->count = 0;\n+\n+  /* Compute the probability of TAKEN_EDGE being reached via threaded edge.\n+     Watch for overflows.  */\n+  if (bb->frequency)\n+    prob = edge_frequency * REG_BR_PROB_BASE / bb->frequency;\n+  else\n+    prob = 0;\n+  if (prob > taken_edge->probability)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Jump threading proved probability of edge \"\n+\t\t \"%i->%i too small (it is %i, should be %i).\\n\",\n+\t\t taken_edge->src->index, taken_edge->dest->index,\n+\t\t taken_edge->probability, prob);\n+      prob = taken_edge->probability;\n+    }\n+\n+  /* Now rescale the probabilities.  */\n+  taken_edge->probability -= prob;\n+  prob = REG_BR_PROB_BASE - prob;\n+  bb->frequency -= edge_frequency;\n+  if (bb->frequency < 0)\n+    bb->frequency = 0;\n+  if (prob <= 0)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Edge frequencies of bb %i has been reset, \"\n+\t\t \"frequency of block should end up being 0, it is %i\\n\",\n+\t\t bb->index, bb->frequency);\n+      bb->succ->probability = REG_BR_PROB_BASE;\n+      for (c = bb->succ->succ_next; c; c = c->succ_next)\n+\tc->probability = 0;\n+    }\n+  else\n+    for (c = bb->succ; c; c = c->succ_next)\n+      c->probability = ((c->probability * REG_BR_PROB_BASE) / (double) prob);\n+\n+  if (bb != taken_edge->src)\n+    abort ();\n+  taken_edge->count -= count;\n+  if (taken_edge->count < 0)\n+    taken_edge->count = 0;\n+}"}, {"sha": "f9d06075caad6531eb29cc157153241f8b6acd9c", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -614,41 +614,23 @@ try_forward_edges (int mode, basic_block b)\n \t    {\n \t      edge t;\n \n-\t      first->count -= edge_count;\n-\t      if (first->count < 0)\n-\t\tfirst->count = 0;\n-\t      first->frequency -= edge_frequency;\n-\t      if (first->frequency < 0)\n-\t\tfirst->frequency = 0;\n \t      if (first->succ->succ_next)\n \t\t{\n-\t\t  edge e;\n-\t\t  int prob;\n-\t\t  \n \t\t  gcc_assert (n < nthreaded_edges);\n \t\t  t = threaded_edges [n++];\n \t\t  gcc_assert (t->src == first);\n-\t\t  if (first->frequency)\n-\t\t    prob = edge_frequency * REG_BR_PROB_BASE / first->frequency;\n-\t\t  else\n-\t\t    prob = 0;\n-\t\t  if (prob > t->probability)\n-\t\t    prob = t->probability;\n-\t\t  t->probability -= prob;\n-\t\t  prob = REG_BR_PROB_BASE - prob;\n-\t\t  if (prob <= 0)\n-\t\t    {\n-\t\t      first->succ->probability = REG_BR_PROB_BASE;\n-\t\t      first->succ->succ_next->probability = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    for (e = first->succ; e; e = e->succ_next)\n-\t\t      e->probability = ((e->probability * REG_BR_PROB_BASE)\n-\t\t\t\t\t/ (double) prob);\n+\t\t  update_bb_profile_for_threading (first, edge_frequency,\n+\t\t\t\t\t\t   edge_count, t);\n \t\t  update_br_prob_note (first);\n \t\t}\n \t      else\n \t\t{\n+\t\t  first->count -= edge_count;\n+\t\t  if (first->count < 0)\n+\t\t    first->count = 0;\n+\t\t  first->frequency -= edge_frequency;\n+\t\t  if (first->frequency < 0)\n+\t\t    first->frequency = 0;\n \t\t  /* It is possible that as the result of\n \t\t     threading we've removed edge as it is\n \t\t     threaded to the fallthru edge.  Avoid"}, {"sha": "f285011ad49ac19bdcce1cd39fe99098ddc8b8bf", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -697,6 +697,8 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t     bypass the conditional at our original destination.   */\n \t  if (dest)\n \t    {\n+\t      update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n+\t\t\t\t\t       e->count, taken_edge);\n \t      e->aux = taken_edge;\n \t      bb_ann (e->dest)->incoming_edge_threaded = true;\n \t    }"}, {"sha": "112509f46012575973ea32f49e241ee6494b2bda", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15db5571d1567a4d05812f85853b9b95766b8f2e/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=15db5571d1567a4d05812f85853b9b95766b8f2e", "patch": "@@ -172,17 +172,25 @@ static void\n create_block_for_threading (basic_block bb, struct redirection_data *rd)\n {\n   tree phi;\n+  edge e;\n \n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n   rd->dup_block = duplicate_block (bb, NULL);\n \n+  /* Zero out the profile, since the block is unreachable for now.  */\n+  rd->dup_block->frequency = 0;\n+  rd->dup_block->count = 0;\n+\n   /* The call to duplicate_block will copy everything, including the\n      useless COND_EXPR or SWITCH_EXPR at the end of the block.  We just remove\n      the useless COND_EXPR or SWITCH_EXPR here rather than having a\n      specialized block copier.  */\n   remove_last_stmt_and_useless_edges (rd->dup_block, rd->outgoing_edge->dest);\n \n+  for (e = rd->dup_block->succ; e; e = e->succ_next)\n+    e->count = 0;\n+\n   /* If there are any PHI nodes at the destination of the outgoing edge\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument"}]}