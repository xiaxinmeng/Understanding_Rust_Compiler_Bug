{"sha": "df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzYzRjODE0ODA0NzJkNmNkNjliMDlkZGU4ODU2Y2IwYmM0YWNhZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-01-06T01:21:56Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-01-06T01:21:56Z"}, "message": "re PR fortran/24268 (gfortran rejects valid format statement)\n\n2006-01-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/24268\n\t* io.c (next_char_not_space): New function that returns the next\n\tcharacter that is not white space.\n\t(format_lex): Use the new function to skip whitespace within\n\ta format string.\n\nFrom-SVN: r109402", "tree": {"sha": "fd11fbf08f0a3ff1b1225d5d87b413aab1514994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd11fbf08f0a3ff1b1225d5d87b413aab1514994"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3c4c81480472d6cd69b09dde8856cb0bc4acaf/comments", "author": null, "committer": null, "parents": [{"sha": "1058a848dcd220965dd4d126eb9f4159782dd586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1058a848dcd220965dd4d126eb9f4159782dd586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1058a848dcd220965dd4d126eb9f4159782dd586"}], "stats": {"total": 46, "additions": 32, "deletions": 14}, "files": [{"sha": "2b47dc876aea03b6e32af4710ff3573550668498", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3c4c81480472d6cd69b09dde8856cb0bc4acaf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3c4c81480472d6cd69b09dde8856cb0bc4acaf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "patch": "@@ -1,3 +1,11 @@\n+2006-01-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/24268\n+\t* io.c (next_char_not_space): New function that returns the next\n+\tcharacter that is not white space.\n+\t(format_lex): Use the new function to skip whitespace within\n+\ta format string.\n+\n 2006-01-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/23675"}, {"sha": "e72fe5d01caf9c8ea12834bc079c3a8f22862692", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3c4c81480472d6cd69b09dde8856cb0bc4acaf/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3c4c81480472d6cd69b09dde8856cb0bc4acaf/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=df3c4c81480472d6cd69b09dde8856cb0bc4acaf", "patch": "@@ -154,6 +154,20 @@ unget_char (void)\n   use_last_char = 1;\n }\n \n+/* Eat up the spaces and return a character. */\n+\n+static char\n+next_char_not_space(void)\n+{\n+  char c;\n+  do\n+    {\n+      c = next_char (0);\n+    }\n+  while (gfc_is_whitespace (c));\n+  return c;\n+}\n+\n static int value = 0;\n \n /* Simple lexical analyzer for getting the next token in a FORMAT\n@@ -174,19 +188,15 @@ format_lex (void)\n       return token;\n     }\n \n-  do\n-    {\n-      c = next_char (0);\n-    }\n-  while (gfc_is_whitespace (c));\n-\n+  c = next_char_not_space ();\n+  \n   negative_flag = 0;\n   switch (c)\n     {\n     case '-':\n       negative_flag = 1;\n     case '+':\n-      c = next_char (0);\n+      c = next_char_not_space ();\n       if (!ISDIGIT (c))\n \t{\n \t  token = FMT_UNKNOWN;\n@@ -197,7 +207,7 @@ format_lex (void)\n \n       do\n \t{\n-\t  c = next_char (0);\n+\t  c = next_char_not_space ();\n           if(ISDIGIT (c))\n             value = 10 * value + c - '0';\n \t}\n@@ -227,13 +237,13 @@ format_lex (void)\n \n       do\n \t{\n-\t  c = next_char (0);\n+\t  c = next_char_not_space ();\n \t  if (c != '0')\n \t    zflag = 0;\n           if (ISDIGIT (c))\n             value = 10 * value + c - '0';\n \t}\n-      while (ISDIGIT (c) || gfc_is_whitespace(c));\n+      while (ISDIGIT (c));\n \n       unget_char ();\n       token = zflag ? FMT_ZERO : FMT_POSINT;\n@@ -260,7 +270,7 @@ format_lex (void)\n       break;\n \n     case 'T':\n-      c = next_char (0);\n+      c = next_char_not_space ();\n       if (c != 'L' && c != 'R')\n \tunget_char ();\n \n@@ -280,15 +290,15 @@ format_lex (void)\n       break;\n \n     case 'S':\n-      c = next_char (0);\n+      c = next_char_not_space ();\n       if (c != 'P' && c != 'S')\n \tunget_char ();\n \n       token = FMT_SIGN;\n       break;\n \n     case 'B':\n-      c = next_char (0);\n+      c = next_char_not_space ();\n       if (c == 'N' || c == 'Z')\n \ttoken = FMT_BLANK;\n       else\n@@ -350,7 +360,7 @@ format_lex (void)\n       break;\n \n     case 'E':\n-      c = next_char (0);\n+      c = next_char_not_space ();\n       if (c == 'N' || c == 'S')\n \ttoken = FMT_EXT;\n       else"}]}