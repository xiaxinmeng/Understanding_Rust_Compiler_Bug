{"sha": "38295e01e2688696523e999002060a39545d218b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyOTVlMDFlMjY4ODY5NjUyM2U5OTkwMDIwNjBhMzk1NDVkMjE4Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T19:03:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T19:03:32Z"}, "message": "optabs.c: Use rtx_insn and rtx_code_label\n\ngcc/\n\t* optabs.c (expand_doubleword_shift): Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\t(expand_binop): Likewise for locals \"entry_last\", \"last\", \"insns\"\n\t(expand_twoval_unop): Likewise for locals entry_last\", \"last\".\n\t(expand_twoval_binop): Likewise.\n\t(expand_twoval_binop_libfunc): Likewise for local \"insns\".\n\t(widen_leading): Likewise for local \"last\".\n\t(expand_doubleword_clz): Likewise for local \"seq\".  Strengthen\n\tlocals \"hi0_label\", \"after_label\" from rtx to rtx_code_label *.\n\t(widen_bswap): Strengthen local \"last\" from rtx to rtx_insn *.\n\t(expand_parity): Likewise for locals \"last\" and \"seq\".\n\t(expand_ffs): Likewise for local \"seq\".  Strengthen local\n\t\"nonzero_label\" from rtx to rtx_code_label *.\n\t(expand_absneg_bit): Strengthen local \"insns\" from rtx to\n\trtx_insn *.\n\t(expand_unop_direct): Likewise for local \"last\".\n\t(expand_unop): Likewise for locals \"last\", \"insns\".\n\t(expand_abs_nojump): Likewise for local \"last\".\n\t(expand_abs): Strengthen local \"op1\" from rtx to rtx_code_label *.\n\t(expand_one_cmpl_abs_nojump): Strengthen local \"last\" from rtx to\n\trtx_insn *.\n\t(expand_copysign_absneg): Strengthen local \"label\" from rtx to\n\trtx_code_label *.\n\t(expand_copysign_bit): Strengthen local \"insns\" from rtx to\n\trtx_insn *.\n\t(struct no_conflict_data): Likewise for fields \"first\", \"insn\".\n\t(emit_libcall_block_1): Likewise for param \"insns\" and locals\n\t\"next\", \"last\", \"insn\".\n\t(emit_libcall_block): For now, add a checked cast to rtx_insn *\n\ton \"insns\" when invoking emit_libcall_block_1.  Ultimately we\n\twant to strengthen insns itself.\n\t(prepare_cmp_insn): Strengthen local \"last\" from rtx to\n\trtx_insn *.\n\t(emit_cmp_and_jump_insn_1): Likewise for local \"insn\".\n\t(prepare_float_lib_cmp): Likewise for local \"insns\".\n\t(emit_conditional_move): Likewise for local \"last\".\n\t(emit_conditional_add): Likewise.\n\t(have_sub2_insn): Likewise for local \"seq\".\n\t(expand_float): Likewise for local \"insns\".  Strengthen locals\n\t\"label\", \"neglabel\" from rtx to rtx_code_label *.\n\t(expand_fix): Likewise for locals \"last\", \"insn\", \"insns\" (to\n\trtx_insn *) and locals \"lab1\", \"lab2\" (to rtx_code_label *).\n\t(expand_fixed_convert): Likewise for local \"insns\" (to\n\trtx_insn *).\n\t(expand_sfix_optab): Likewise for local \"last\".\n\t(expand_compare_and_swap_loop): Strengthen local \"label\" from rtx\n\tto rtx_code_label *.\n\t(maybe_emit_sync_lock_test_and_set): Strengthen local \"last_insn\"\n\tfrom rtx to rtx_insn *.\n\t(expand_atomic_fetch_op): Likewise for local \"insn\".\n\t(maybe_legitimize_operand_same_code): Likewise for local \"last\".\n\t(maybe_legitimize_operands): Likewise.\n\nFrom-SVN: r214355", "tree": {"sha": "11fddc323c1a74924f1634abcfb3871822435727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fddc323c1a74924f1634abcfb3871822435727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38295e01e2688696523e999002060a39545d218b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38295e01e2688696523e999002060a39545d218b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38295e01e2688696523e999002060a39545d218b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38295e01e2688696523e999002060a39545d218b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6210ec61d92762184a7c53e4fa2c9e1e037251ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6210ec61d92762184a7c53e4fa2c9e1e037251ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6210ec61d92762184a7c53e4fa2c9e1e037251ee"}], "stats": {"total": 189, "additions": 132, "deletions": 57}, "files": [{"sha": "7d1775f968480ab950a26c803529172d5fc8b4a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38295e01e2688696523e999002060a39545d218b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38295e01e2688696523e999002060a39545d218b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38295e01e2688696523e999002060a39545d218b", "patch": "@@ -1,3 +1,58 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* optabs.c (expand_doubleword_shift): Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(expand_binop): Likewise for locals \"entry_last\", \"last\", \"insns\"\n+\t(expand_twoval_unop): Likewise for locals entry_last\", \"last\".\n+\t(expand_twoval_binop): Likewise.\n+\t(expand_twoval_binop_libfunc): Likewise for local \"insns\".\n+\t(widen_leading): Likewise for local \"last\".\n+\t(expand_doubleword_clz): Likewise for local \"seq\".  Strengthen\n+\tlocals \"hi0_label\", \"after_label\" from rtx to rtx_code_label *.\n+\t(widen_bswap): Strengthen local \"last\" from rtx to rtx_insn *.\n+\t(expand_parity): Likewise for locals \"last\" and \"seq\".\n+\t(expand_ffs): Likewise for local \"seq\".  Strengthen local\n+\t\"nonzero_label\" from rtx to rtx_code_label *.\n+\t(expand_absneg_bit): Strengthen local \"insns\" from rtx to\n+\trtx_insn *.\n+\t(expand_unop_direct): Likewise for local \"last\".\n+\t(expand_unop): Likewise for locals \"last\", \"insns\".\n+\t(expand_abs_nojump): Likewise for local \"last\".\n+\t(expand_abs): Strengthen local \"op1\" from rtx to rtx_code_label *.\n+\t(expand_one_cmpl_abs_nojump): Strengthen local \"last\" from rtx to\n+\trtx_insn *.\n+\t(expand_copysign_absneg): Strengthen local \"label\" from rtx to\n+\trtx_code_label *.\n+\t(expand_copysign_bit): Strengthen local \"insns\" from rtx to\n+\trtx_insn *.\n+\t(struct no_conflict_data): Likewise for fields \"first\", \"insn\".\n+\t(emit_libcall_block_1): Likewise for param \"insns\" and locals\n+\t\"next\", \"last\", \"insn\".\n+\t(emit_libcall_block): For now, add a checked cast to rtx_insn *\n+\ton \"insns\" when invoking emit_libcall_block_1.  Ultimately we\n+\twant to strengthen insns itself.\n+\t(prepare_cmp_insn): Strengthen local \"last\" from rtx to\n+\trtx_insn *.\n+\t(emit_cmp_and_jump_insn_1): Likewise for local \"insn\".\n+\t(prepare_float_lib_cmp): Likewise for local \"insns\".\n+\t(emit_conditional_move): Likewise for local \"last\".\n+\t(emit_conditional_add): Likewise.\n+\t(have_sub2_insn): Likewise for local \"seq\".\n+\t(expand_float): Likewise for local \"insns\".  Strengthen locals\n+\t\"label\", \"neglabel\" from rtx to rtx_code_label *.\n+\t(expand_fix): Likewise for locals \"last\", \"insn\", \"insns\" (to\n+\trtx_insn *) and locals \"lab1\", \"lab2\" (to rtx_code_label *).\n+\t(expand_fixed_convert): Likewise for local \"insns\" (to\n+\trtx_insn *).\n+\t(expand_sfix_optab): Likewise for local \"last\".\n+\t(expand_compare_and_swap_loop): Strengthen local \"label\" from rtx\n+\tto rtx_code_label *.\n+\t(maybe_emit_sync_lock_test_and_set): Strengthen local \"last_insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(expand_atomic_fetch_op): Likewise for local \"insn\".\n+\t(maybe_legitimize_operand_same_code): Likewise for local \"last\".\n+\t(maybe_legitimize_operands): Likewise.\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* modulo-sched.c (struct ps_reg_move_info): Strengthen field"}, {"sha": "08d5c6e43be4d02be253b05239d92f73d8a906bf", "filename": "gcc/optabs.c", "status": "modified", "additions": 77, "deletions": 57, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38295e01e2688696523e999002060a39545d218b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38295e01e2688696523e999002060a39545d218b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=38295e01e2688696523e999002060a39545d218b", "patch": "@@ -59,7 +59,7 @@ struct target_libfuncs *this_target_libfuncs = &default_target_libfuncs;\n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   enum machine_mode *);\n static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n-static void emit_libcall_block_1 (rtx, rtx, rtx, rtx, bool);\n+static void emit_libcall_block_1 (rtx_insn *, rtx, rtx, rtx, bool);\n \n /* Debug facility for use in GDB.  */\n void debug_optab_libfuncs (void);\n@@ -1105,7 +1105,7 @@ expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n #ifdef HAVE_conditional_move\n   /* Try using conditional moves to generate straight-line code.  */\n   {\n-    rtx start = get_last_insn ();\n+    rtx_insn *start = get_last_insn ();\n     if (expand_doubleword_shift_condmove (op1_mode, binoptab,\n \t\t\t\t\t  cmp_code, cmp1, cmp2,\n \t\t\t\t\t  outof_input, into_input,\n@@ -1543,8 +1543,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   enum machine_mode wider_mode;\n   rtx libfunc;\n   rtx temp;\n-  rtx entry_last = get_last_insn ();\n-  rtx last;\n+  rtx_insn *entry_last = get_last_insn ();\n+  rtx_insn *last;\n \n   mclass = GET_MODE_CLASS (mode);\n \n@@ -1740,7 +1740,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (binoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n-      rtx insns;\n+      rtx_insn *insns;\n \n       /* If TARGET is the same as one of the operands, the REG_EQUAL note\n \t won't be accurate, so use a new target.  */\n@@ -1809,7 +1809,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  || (shift_mask == BITS_PER_WORD - 1\n \t      && double_shift_mask == BITS_PER_WORD * 2 - 1))\n \t{\n-\t  rtx insns;\n+\t  rtx_insn *insns;\n \t  rtx into_target, outof_target;\n \t  rtx into_input, outof_input;\n \t  int left_shift, outof_word;\n@@ -1861,7 +1861,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (ashl_optab, word_mode) != CODE_FOR_nothing\n       && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n-      rtx insns;\n+      rtx_insn *insns;\n       rtx into_target, outof_target;\n       rtx into_input, outof_input;\n       rtx inter;\n@@ -2146,7 +2146,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if (libfunc\n       && (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN))\n     {\n-      rtx insns;\n+      rtx_insn *insns;\n       rtx op1x = op1;\n       enum machine_mode op1_mode = mode;\n       rtx value;\n@@ -2334,8 +2334,8 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n   enum mode_class mclass;\n   enum machine_mode wider_mode;\n-  rtx entry_last = get_last_insn ();\n-  rtx last;\n+  rtx_insn *entry_last = get_last_insn ();\n+  rtx_insn *last;\n \n   mclass = GET_MODE_CLASS (mode);\n \n@@ -2408,8 +2408,8 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n   enum mode_class mclass;\n   enum machine_mode wider_mode;\n-  rtx entry_last = get_last_insn ();\n-  rtx last;\n+  rtx_insn *entry_last = get_last_insn ();\n+  rtx_insn *last;\n \n   mclass = GET_MODE_CLASS (mode);\n \n@@ -2490,7 +2490,7 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   enum machine_mode mode;\n   enum machine_mode libval_mode;\n   rtx libval;\n-  rtx insns;\n+  rtx_insn *insns;\n   rtx libfunc;\n \n   /* Exactly one of TARG0 or TARG1 should be non-NULL.  */\n@@ -2556,7 +2556,8 @@ widen_leading (enum machine_mode mode, rtx op0, rtx target, optab unoptab)\n \t{\n \t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n-\t      rtx xop0, temp, last;\n+\t      rtx xop0, temp;\n+\t      rtx_insn *last;\n \n \t      last = get_last_insn ();\n \n@@ -2591,9 +2592,10 @@ expand_doubleword_clz (enum machine_mode mode, rtx op0, rtx target)\n   rtx xop0 = force_reg (mode, op0);\n   rtx subhi = gen_highpart (word_mode, xop0);\n   rtx sublo = gen_lowpart (word_mode, xop0);\n-  rtx hi0_label = gen_label_rtx ();\n-  rtx after_label = gen_label_rtx ();\n-  rtx seq, temp, result;\n+  rtx_code_label *hi0_label = gen_label_rtx ();\n+  rtx_code_label *after_label = gen_label_rtx ();\n+  rtx_insn *seq;\n+  rtx temp, result;\n \n   /* If we were not given a target, use a word_mode register, not a\n      'mode' register.  The result will fit, and nobody is expecting\n@@ -2662,7 +2664,8 @@ widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n {\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n-  rtx x, last;\n+  rtx x;\n+  rtx_insn *last;\n \n   if (!CLASS_HAS_WIDER_MODES_P (mclass))\n     return NULL_RTX;\n@@ -2736,7 +2739,8 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n \t{\n \t  if (optab_handler (popcount_optab, wider_mode) != CODE_FOR_nothing)\n \t    {\n-\t      rtx xop0, temp, last;\n+\t      rtx xop0, temp;\n+\t      rtx_insn *last;\n \n \t      last = get_last_insn ();\n \n@@ -2773,7 +2777,8 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n static rtx\n expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n {\n-  rtx seq, temp;\n+  rtx_insn *seq;\n+  rtx temp;\n \n   if (optab_handler (clz_optab, mode) == CODE_FOR_nothing)\n     return 0;\n@@ -2817,7 +2822,8 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n {\n   HOST_WIDE_INT val = 0;\n   bool defined_at_zero = false;\n-  rtx temp, seq;\n+  rtx temp;\n+  rtx_insn *seq;\n \n   if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing)\n     {\n@@ -2859,7 +2865,7 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n \t the operation sets condition codes that can be recycled for this.\n \t (This is true on i386, for instance.)  */\n \n-      rtx nonzero_label = gen_label_rtx ();\n+      rtx_code_label *nonzero_label = gen_label_rtx ();\n       emit_cmp_and_jump_insns (op0, CONST0_RTX (mode), NE, 0,\n \t\t\t       mode, true, nonzero_label);\n \n@@ -2916,7 +2922,8 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n   const struct real_format *fmt;\n   int bitpos, word, nwords, i;\n   enum machine_mode imode;\n-  rtx temp, insns;\n+  rtx temp;\n+  rtx_insn *insns;\n \n   /* The format has to have a simple sign bit.  */\n   fmt = REAL_MODE_FORMAT (mode);\n@@ -3013,7 +3020,7 @@ expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n     {\n       struct expand_operand ops[2];\n       enum insn_code icode = optab_handler (unoptab, mode);\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n       rtx pat;\n \n       create_output_operand (&ops[0], target, mode);\n@@ -3098,7 +3105,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t be always more efficient than the other fallback methods.  */\n       if (mode == HImode)\n \t{\n-\t  rtx last, temp1, temp2;\n+\t  rtx_insn *last;\n+\t  rtx temp1, temp2;\n \n \t  if (optab_handler (rotl_optab, mode) != CODE_FOR_nothing)\n \t    {\n@@ -3156,7 +3164,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \tif (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t  {\n \t    rtx xop0 = op0;\n-\t    rtx last = get_last_insn ();\n+\t    rtx_insn *last = get_last_insn ();\n \n \t    /* For certain operations, we need not actually extend\n \t       the narrow operand, as long as we will truncate the\n@@ -3195,7 +3203,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n-      rtx insns;\n+      rtx_insn *insns;\n \n       if (target == 0 || target == op0 || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n@@ -3273,7 +3281,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n   libfunc = optab_libfunc (unoptab, mode);\n   if (libfunc)\n     {\n-      rtx insns;\n+      rtx_insn *insns;\n       rtx value;\n       rtx eq_value;\n       enum machine_mode outmode = mode;\n@@ -3320,7 +3328,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t      || optab_libfunc (unoptab, wider_mode))\n \t    {\n \t      rtx xop0 = op0;\n-\t      rtx last = get_last_insn ();\n+\t      rtx_insn *last = get_last_insn ();\n \n \t      /* For certain operations, we need not actually extend\n \t\t the narrow operand, as long as we will truncate the\n@@ -3430,7 +3438,7 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n   if (optab_handler (smax_optab, mode) != CODE_FOR_nothing\n       && !HONOR_SIGNED_ZEROS (mode))\n     {\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n \n       temp = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n \t\t\t  op0, NULL_RTX, 0);\n@@ -3473,7 +3481,8 @@ rtx\n expand_abs (enum machine_mode mode, rtx op0, rtx target,\n \t    int result_unsignedp, int safe)\n {\n-  rtx temp, op1;\n+  rtx temp;\n+  rtx_code_label *op1;\n \n   if (GET_MODE_CLASS (mode) != MODE_INT\n       || ! flag_trapv)\n@@ -3534,7 +3543,7 @@ expand_one_cmpl_abs_nojump (enum machine_mode mode, rtx op0, rtx target)\n   /* If we have a MAX insn, we can do this as MAX (x, ~x).  */\n   if (optab_handler (smax_optab, mode) != CODE_FOR_nothing)\n     {\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n \n       temp = expand_unop (mode, one_cmpl_optab, op0, NULL_RTX, 0);\n       if (temp != 0)\n@@ -3579,7 +3588,8 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n {\n   enum machine_mode imode;\n   enum insn_code icode;\n-  rtx sign, label;\n+  rtx sign;\n+  rtx_code_label *label;\n \n   if (target == op1)\n     target = NULL_RTX;\n@@ -3662,7 +3672,8 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n {\n   enum machine_mode imode;\n   int word, nwords, i;\n-  rtx temp, insns;\n+  rtx temp;\n+  rtx_insn *insns;\n \n   if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n     {\n@@ -3842,7 +3853,8 @@ emit_unop_insn (enum insn_code icode, rtx target, rtx op0, enum rtx_code code)\n \f\n struct no_conflict_data\n {\n-  rtx target, first, insn;\n+  rtx target;\n+  rtx_insn *first, *insn;\n   bool must_stay;\n };\n \n@@ -3894,11 +3906,11 @@ no_conflict_move_test (rtx dest, const_rtx set, void *p0)\n    note with an operand of EQUIV.  */\n \n static void\n-emit_libcall_block_1 (rtx insns, rtx target, rtx result, rtx equiv,\n+emit_libcall_block_1 (rtx_insn *insns, rtx target, rtx result, rtx equiv,\n \t\t      bool equiv_may_trap)\n {\n   rtx final_dest = target;\n-  rtx next, last, insn;\n+  rtx_insn *next, *last, *insn;\n \n   /* If this is a reg with REG_USERVAR_P set, then it could possibly turn\n      into a MEM later.  Protect the libcall block from this change.  */\n@@ -3994,7 +4006,8 @@ emit_libcall_block_1 (rtx insns, rtx target, rtx result, rtx equiv,\n void\n emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n {\n-  emit_libcall_block_1 (insns, target, result, equiv, false);\n+  emit_libcall_block_1 (safe_as_a <rtx_insn *> (insns),\n+\t\t\ttarget, result, equiv, false);\n }\n \f\n /* Nonzero if we can perform a comparison of mode MODE straightforwardly.\n@@ -4185,7 +4198,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n       if (icode != CODE_FOR_nothing\n \t  && insn_operand_matches (icode, 0, test))\n \t{\n-\t  rtx last = get_last_insn ();\n+\t  rtx_insn *last = get_last_insn ();\n \t  rtx op0 = prepare_operand (icode, x, 1, mode, cmp_mode, unsignedp);\n \t  rtx op1 = prepare_operand (icode, y, 2, mode, cmp_mode, unsignedp);\n \t  if (op0 && op1\n@@ -4297,7 +4310,7 @@ emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label, int prob)\n   enum machine_mode optab_mode;\n   enum mode_class mclass;\n   enum insn_code icode;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   mclass = GET_MODE_CLASS (mode);\n   optab_mode = (mclass == MODE_CC) ? CCmode : mode;\n@@ -4378,7 +4391,8 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n   enum machine_mode orig_mode = GET_MODE (x);\n   enum machine_mode mode, cmp_mode;\n   rtx true_rtx, false_rtx;\n-  rtx value, target, insns, equiv;\n+  rtx value, target, equiv;\n+  rtx_insn *insns;\n   rtx libfunc = 0;\n   bool reversed_p = false;\n   cmp_mode = targetm.libgcc_cmp_return_mode ();\n@@ -4532,7 +4546,8 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t       enum machine_mode cmode, rtx op2, rtx op3,\n \t\t       enum machine_mode mode, int unsignedp)\n {\n-  rtx tem, comparison, last;\n+  rtx tem, comparison;\n+  rtx_insn *last;\n   enum insn_code icode;\n   enum rtx_code reversed;\n \n@@ -4653,7 +4668,8 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t      enum machine_mode cmode, rtx op2, rtx op3,\n \t\t      enum machine_mode mode, int unsignedp)\n {\n-  rtx tem, comparison, last;\n+  rtx tem, comparison;\n+  rtx_insn *last;\n   enum insn_code icode;\n \n   /* If one operand is constant, make it the second one.  Only do this\n@@ -4871,7 +4887,7 @@ have_sub2_insn (rtx x, rtx y)\n rtx\n gen_move_insn (rtx x, rtx y)\n {\n-  rtx seq;\n+  rtx_insn *seq;\n \n   start_sequence ();\n   emit_move_insn_1 (x, y);\n@@ -5077,7 +5093,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n      then unconditionally adjust the result.  */\n   if (unsignedp && can_do_signed)\n     {\n-      rtx label = gen_label_rtx ();\n+      rtx_code_label *label = gen_label_rtx ();\n       rtx temp;\n       REAL_VALUE_TYPE offset;\n \n@@ -5101,7 +5117,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t      < GET_MODE_PRECISION (GET_MODE (from)))\n \t    {\n \t      rtx temp1;\n-\t      rtx neglabel = gen_label_rtx ();\n+\t      rtx_code_label *neglabel = gen_label_rtx ();\n \n \t      /* Don't use TARGET if it isn't a register, is a hard register,\n \t\t or is the wrong mode.  */\n@@ -5180,7 +5196,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n   /* No hardware instruction available; call a library routine.  */\n     {\n       rtx libfunc;\n-      rtx insns;\n+      rtx_insn *insns;\n       rtx value;\n       convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n \n@@ -5246,7 +5262,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n \tif (icode != CODE_FOR_nothing)\n \t  {\n-\t    rtx last = get_last_insn ();\n+\t    rtx_insn *last = get_last_insn ();\n \t    if (fmode != GET_MODE (from))\n \t      from = convert_to_mode (fmode, from, 0);\n \n@@ -5304,7 +5320,9 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \t{\n \t  int bitsize;\n \t  REAL_VALUE_TYPE offset;\n-\t  rtx limit, lab1, lab2, insn;\n+\t  rtx limit;\n+\t  rtx_code_label *lab1, *lab2;\n+\t  rtx_insn *insn;\n \n \t  bitsize = GET_MODE_PRECISION (GET_MODE (to));\n \t  real_2expN (&offset, bitsize - 1, fmode);\n@@ -5368,7 +5386,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n     }\n   else\n     {\n-      rtx insns;\n+      rtx_insn *insns;\n       rtx value;\n       rtx libfunc;\n \n@@ -5410,7 +5428,8 @@ expand_fixed_convert (rtx to, rtx from, int uintp, int satp)\n   convert_optab tab;\n   enum rtx_code this_code;\n   enum insn_code code;\n-  rtx insns, value;\n+  rtx_insn *insns;\n+  rtx value;\n   rtx libfunc;\n \n   if (to_mode == from_mode)\n@@ -5473,7 +5492,7 @@ expand_sfix_optab (rtx to, rtx from, convert_optab tab)\n \ticode = convert_optab_handler (tab, imode, fmode);\n \tif (icode != CODE_FOR_nothing)\n \t  {\n-\t    rtx last = get_last_insn ();\n+\t    rtx_insn *last = get_last_insn ();\n \t    if (fmode != GET_MODE (from))\n \t      from = convert_to_mode (fmode, from, 0);\n \n@@ -7089,7 +7108,8 @@ static bool\n expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  rtx label, cmp_reg, success, oldval;\n+  rtx_code_label *label;\n+  rtx cmp_reg, success, oldval;\n \n   /* The loop we want to generate looks like\n \n@@ -7169,7 +7189,7 @@ maybe_emit_sync_lock_test_and_set (rtx target, rtx mem, rtx val,\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx last_insn = get_last_insn ();\n+  rtx_insn *last_insn = get_last_insn ();\n \n   icode = optab_handler (sync_lock_test_and_set_optab, mode);\n \n@@ -8083,7 +8103,7 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n   /* If nothing else has succeeded, default to a compare and swap loop.  */\n   if (can_compare_and_swap_p (mode, true))\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       rtx t0 = gen_reg_rtx (mode), t1;\n \n       start_sequence ();\n@@ -8176,7 +8196,7 @@ maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n       if (!(REG_P (addr) && REGNO (addr) > LAST_VIRTUAL_REGISTER)\n \t  && !side_effects_p (addr))\n \t{\n-\t  rtx last;\n+\t  rtx_insn *last;\n \t  enum machine_mode mode;\n \n \t  last = get_last_insn ();\n@@ -8290,7 +8310,7 @@ bool\n maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n \t\t\t   unsigned int nops, struct expand_operand *ops)\n {\n-  rtx last;\n+  rtx_insn *last;\n   unsigned int i;\n \n   last = get_last_insn ();"}]}