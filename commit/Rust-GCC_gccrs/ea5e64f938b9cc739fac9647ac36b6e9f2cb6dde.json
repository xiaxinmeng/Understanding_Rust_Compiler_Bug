{"sha": "ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE1ZTY0ZjkzOGI5Y2M3MzlmYWM5NjQ3YWMzNmI2ZTlmMmNiNmRkZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-14T23:37:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-14T23:37:42Z"}, "message": "Initial revision\n\nFrom-SVN: r184", "tree": {"sha": "eff47f3f6d9c3829dc31bbb569187ee030533259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eff47f3f6d9c3829dc31bbb569187ee030533259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde/comments", "author": null, "committer": null, "parents": [{"sha": "4c9c8227aebebb538fe503925cbd07d2656fb071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9c8227aebebb538fe503925cbd07d2656fb071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9c8227aebebb538fe503925cbd07d2656fb071"}], "stats": {"total": 1286, "additions": 1286, "deletions": 0}, "files": [{"sha": "e9568d547e7e09891f1f1cded5195e6179f8c99a", "filename": "gcc/config/a29k/a29k.c", "status": "added", "additions": 1286, "deletions": 0, "changes": 1286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=ea5e64f938b9cc739fac9647ac36b6e9f2cb6dde", "patch": "@@ -0,0 +1,1286 @@\n+/* Subroutines used for code generation on AMD Am29000.\n+   Copyright (C) 1987, 1988, 1990, 1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+\n+#define min(A,B)\t((A) < (B) ? (A) : (B))\n+\n+/* This gives the size in words of the register stack for the current\n+   procedure.  */\n+\n+static int a29k_regstack_size;\n+\n+/* This points to the last insn of the insn prologue.  It is set when\n+   an insn without a filled delay slot is found near the start of the\n+   function.  */\n+\n+static char *a29k_last_prologue_insn;\n+\n+/* This points to the first insn that will be in the epilogue.  It is null if\n+   no epilogue is required.  */\n+\n+static char *a29k_first_epilogue_insn;\n+\n+/* This is nonzero if a a29k_first_epilogue_insn was put in a delay slot.  It\n+   indicates that an intermediate label needs to be written.  */\n+\n+static int a29k_first_epilogue_insn_used;\n+\n+/* Location to hold the name of the current function.  We need this prolog to\n+   contain the tag words prior to the declaration.  So the name must be stored\n+   away.  */\n+\n+char *a29k_function_name;\n+\n+/* Mapping of registers to debug register numbers.  The only change is\n+   for the frame pointer and the register numbers used for the incoming\n+   arguments.  */\n+\n+int a29k_debug_reg_map[FIRST_PSEUDO_REGISTER];\n+\n+/* Save information from a \"cmpxx\" operation until the branch or scc is\n+   emitted.  */\n+\n+rtx a29k_compare_op0, a29k_compare_op1;\n+int a29k_compare_fp_p;\n+\n+/* Gives names for registers.  */\n+extern char *reg_names[];\n+\f\n+/* Returns 1 if OP is a 8-bit constant. */\n+\n+int\n+cint_8_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffffff00) == 0;\n+}\n+\n+/* Returns 1 if OP is a 16-bit constant.  */\n+\n+int\n+cint_16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff0000) == 0;\n+}\n+\n+/* Returns 1 if OP cannot be moved in a single insn.  */\n+\n+int\n+long_const_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! CONSTANT_P (op))\n+    return 0;\n+\n+  if (TARGET_29050 && GET_CODE (op) == CONST_INT\n+      && (INTVAL (op) & 0xffff) == 0)\n+    return 0;\n+\n+  return (GET_CODE (op) != CONST_INT\n+\t  || ((INTVAL (op) & 0xffff0000) != 0\n+\t      && (INTVAL (op) & 0xffff0000) != 0xffff0000\n+\t      && INTVAL (op) != 0x80000000));\n+}\n+\f\n+/* The following four functions detect constants of 0, 8, 16, and 24 used as\n+   a position in ZERO_EXTRACT operations.  They can either be the appropriate\n+   constant integer or a shift (which will be produced by combine).  */\n+\n+static int\n+shift_constant_operand (op, mode, val)\n+     rtx op;\n+     enum machine_mode mode;\n+     int val;\n+{\n+  return ((GET_CODE (op) == CONST_INT && INTVAL (op) == val)\n+\t  || (GET_CODE (op) == ASHIFT\n+\t      && GET_CODE (XEXP (op, 0)) == CONST_INT\n+\t      && INTVAL (XEXP (op, 0)) == val / 8\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t      && INTVAL (XEXP (op, 1)) == 3));\n+}\n+\n+int\n+const_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return shift_constant_operand (op, mode, 0);\n+}\n+\n+int\n+const_8_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return shift_constant_operand (op, mode, 8);\n+}\n+\n+int\n+const_16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode;\n+{\n+  return shift_constant_operand (op, mode, 16);\n+}\n+\n+int\n+const_24_operand (op, mode)\n+     rtx op;\n+     enum machine_mode;\n+{\n+  return shift_constant_operand (op, mode, 24);\n+}\n+\n+/* Returns 1 if OP is a floating-point constant of the proper mode.  */\n+\n+int\n+float_const_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == mode;\n+}\n+\n+/* Returns 1 if OP is a floating-point constant of the proper mode or a\n+   general-purpose register.  */\n+\n+int\n+gen_reg_or_float_constant_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return float_const_operand (op, mode) || gen_reg_operand (op, mode);\n+}\n+\n+/* Returns 1 if OP is an integer constant of the proper mode or a\n+   general-purpose register.  */\n+\n+int\n+gen_reg_or_integer_constant_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_MODE (op) == VOIDmode\n+\t   && (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE))\n+\t  || gen_reg_operand (op, mode));\n+}\n+\f     \n+/* Returns 1 if OP is a special machine register.  */\n+\n+int\n+spec_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_MODE (op) == SImode && GET_CODE (op) == REG\n+\t && REGNO (op) >= R_BP && REGNO (op) <= R_EXO;\n+}\n+\n+/* Returns 1 if OP is an accumulator register.  */\n+\n+int\n+accum_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == REG\n+\t  && REGNO (op) >= R_ACC (0) && REGNO (op) <= R_ACC (3));\n+}\n+\n+/* Returns 1 if OP is a normal data register.  */\n+\n+int\n+gen_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int regno;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == REG)\n+    regno = REGNO (op);\n+  else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+    {\n+      regno = REGNO (SUBREG_REG (op));\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tregno += SUBREG_WORD (op);\n+    }\n+  else\n+    return 0;\n+\n+  return regno >= FIRST_PSEUDO_REGISTER || regno < R_BP;\n+}\n+\n+/* Returns 1 if OP is either an 8-bit constant integer or a general register.\n+   If a register, it must be in the proper mode unless MODE is VOIDmode.  */\n+\n+int\n+srcb_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT\n+      && (mode == QImode\n+\t  || (INTVAL (op) & 0xffffff00) == 0))\n+    return 1;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  return gen_reg_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is either an immediate or a general register.  This is used\n+   for the input operand of mtsr/mtrsim.  */\n+\n+int\n+gen_reg_or_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode;\n+{\n+  return gen_reg_operand (op, mode) || immediate_operand (op, mode);\n+}\n+\n+/* Return 1 if OP can be used as the second operand of and AND insn.  This\n+   includes srcb_operand and a constant whose complement fits in 8 bits.  */\n+\n+int\n+and_operand (op, mode)\n+     rtx op;\n+     enum machine_mode;\n+{\n+  return (srcb_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && ((unsigned) ((~ INTVAL (op)) & GET_MODE_MASK (mode)) < 256)));\n+}\n+\n+/* Return 1 if OP can be used as the second operand of an ADD insn.\n+   This is the same as above, except we use negative, rather than\n+   complement.   */\n+\n+int\n+add_operand (op, mode)\n+     rtx op;\n+     enum machine_mode;\n+{\n+  return (srcb_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && ((unsigned) ((- INTVAL (op)) & GET_MODE_MASK (mode)) < 256)));\n+}\n+\f\n+/* Return 1 if OP can be used as the input operand for a move insn.  */\n+\n+int\n+in_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx orig_op = op;\n+\n+  if (! general_operand (op, mode))\n+    return 0;\n+\n+  while (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return (GET_MODE_SIZE (mode) >= UNITS_PER_WORD || TARGET_DW_ENABLE);\n+\n+    case CONST_INT:\n+      if (GET_MODE_CLASS (mode) != MODE_INT)\n+\treturn 0;\n+\n+      return 1;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return (GET_MODE (op) == mode\n+\t      || mode == SImode || mode == HImode || mode == QImode);\n+\n+    case CONST_DOUBLE:\n+      return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t       && mode == GET_MODE (op))\n+\t      || (GET_MODE (op) == VOIDmode\n+\t\t  && GET_MODE_CLASS (mode) == MODE_INT));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if OP can be used as the output operand for a move insn.  */\n+\n+int\n+out_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx orig_op = op;\n+\n+  if (! general_operand (op, mode))\n+    return 0;\n+\n+  while (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) == REG)\n+    return (mode == SImode || gen_reg_operand (orig_op, mode)\n+\t    || (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t&& accum_reg_operand (orig_op, mode)));\n+\n+  else if (GET_CODE (op) == MEM)\n+    return mode == SImode || mode == SFmode || TARGET_DW_ENABLE;\n+\n+  else\n+    return 0;\n+}\n+\n+/* Return 1 if OP is some extension operator.  */\n+\n+int\n+extend_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n+}\n+\n+/* Return 1 if OP is a comparison operator that we have in floating-point.  */\n+\n+int\n+fp_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (GET_CODE (op) == EQ || GET_CODE (op) == GT ||\n+\t      GET_CODE (op) == GE));\n+}\n+\n+/* Return 1 if OP is a valid branch comparison.  */\n+\n+int\n+branch_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (GET_CODE (op) == GE || GET_CODE (op) == LT));\n+}\n+\f\n+/* Return 1 if OP is a load multiple operation.  It is known to be a\n+   PARALLEL and the first three sections will be tested.  */\n+\n+int\n+load_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0) - 2;\n+  int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i + 2);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Similar, but tests for store multiple.  */\n+\n+int\n+store_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int num_special = TARGET_NO_STOREM_BUG ? 2 : 1;\n+  int count = XVECLEN (op, 0) - num_special;\n+  int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i + num_special);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\f\n+/* Given a special register REG and MASK, a value being masked against a\n+   quantity to which the special register is set, return 1 if the masking\n+   operation is built-in to the setting of that special register.  */\n+\n+int\n+masks_bits_for_special (reg, mask)\n+     rtx reg;\n+     rtx mask;\n+{\n+   int needed_mask_value;\n+\n+  if (GET_CODE (reg) != REG || GET_CODE (mask) != CONST_INT)\n+    abort ();\n+\n+  switch (REGNO (reg))\n+    {\n+    case R_BP:\n+    case R_INT:\n+      needed_mask_value = 3;\n+      break;\n+\n+    case R_FC:\n+      needed_mask_value = 31;\n+      break;\n+\n+    case R_CR:\n+    case R_LRU:\n+      needed_mask_value = 255;\n+      break;\n+\n+    case R_FPE:\n+      needed_mask_value = 511;\n+      break;\n+\n+    case R_MMU:\n+      needed_mask_value = 0x3ff;\n+      break;\n+\n+    case R_OPS:\n+    case R_CPS:\n+    case R_RBP:\n+    case R_FPS:\n+      needed_mask_value = 0xffff;\n+      break;\n+\n+    case R_VAB:\n+      needed_mask_value = 0xffff0000;\n+      break;\n+\n+    case R_Q:\n+    case R_CFG:\n+    case R_CHA:\n+    case R_CHD:\n+    case R_CHC:\n+    case R_TMC:\n+    case R_TMR:\n+    case R_PC0:\n+    case R_PC1:\n+    case R_PC2:\n+      return 0;\n+\n+    default:\n+      abort ();\n+    }\n+\n+   return (INTVAL (mask) & ~ needed_mask_value) == 0;\n+}\n+\f\n+/* Return nonzero if this label is that of the return point, but there is\n+   a non-null epilogue.  */\n+\n+int\n+epilogue_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return next_active_insn (op) == 0 && a29k_first_epilogue_insn != 0;\n+}\n+\f\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = -1;\n+\n+  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n+    regno = true_regnum (in);\n+\n+  /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n+     into anything.  */\n+  if (class == GENERAL_REGS || (regno != -1 && regno < R_BP))\n+    return NO_REGS;\n+\n+  /* We can place 16-bit constants into a special register.  */\n+  if (GET_CODE (in) == CONST_INT\n+      && (GET_MODE_BITSIZE (mode) <= 16\n+\t  || (unsigned) INTVAL (in) <= 65535)\n+      && (class == BP_REGS || class == Q_REGS || class == SPECIAL_REGS))\n+    return NO_REGS;\n+\n+  /* Otherwise, we need GENERAL_REGS.  */\n+  return GENERAL_REGS;\n+}\n+\f\n+/* START is the zero-based incoming argument register index used (0 is 160,\n+   i.e., the first incoming argument register) and COUNT is the number used.\n+\n+   Mark the corresponding incoming registers as neither fixed nor call used.\n+   For each register used for incoming arguments, we have one less local\n+   register that can be used.  So also mark some high-numbered registers as\n+   fixed.\n+\n+   Return the first register number to use for the argument.  */\n+\n+int\n+incoming_reg (start, count)\n+     int start;\n+     int count;\n+{\n+  int i;\n+\n+  if (! TARGET_NO_REUSE_ARGS)\n+    /* Mark all the used registers as not fixed and saved over calls.  */\n+    for (i = R_AR (start); i < R_AR (16) && i < R_AR (start + count); i++)\n+      {\n+\tfixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 0;\n+\tCLEAR_HARD_REG_BIT (fixed_reg_set, i);\n+\tCLEAR_HARD_REG_BIT (call_used_reg_set, i);\n+\tCLEAR_HARD_REG_BIT (call_fixed_reg_set, i);\n+      }\n+\n+  /* Shorten the maximum size of the frame.  */\n+  for (i = R_AR (0) - start - count; i < R_AR (0) - start; i++)\n+    {\n+      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 1;\n+      SET_HARD_REG_BIT (fixed_reg_set, i);\n+      SET_HARD_REG_BIT (call_used_reg_set, i);\n+      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+    }\n+\n+  return R_AR (start);\n+}\n+\f\n+/* These routines are used in finding insns to fill delay slots in the\n+   epilogue.  */\n+\n+/* Return 1 if the current function will adjust the register stack.  */\n+\n+int\n+needs_regstack_p ()\n+{\n+  int i;\n+  rtx insn;\n+\n+  if (frame_pointer_needed)\n+    return 1;\n+\n+  /* If any local register is used, we need to adjust the regstack.  */\n+  for (i = R_LR (127); i >= R_LR (0); i --)\n+    if (regs_ever_live[i])\n+      return 1;\n+\n+  /* We need a register stack if we make any calls.  */\n+  for (insn = get_insns (); insn; insn = next_insn (insn))\n+    if (GET_CODE (insn) == CALL_INSN\n+\t|| (GET_CODE (insn) == INSN\n+\t    && GET_CODE (PATTERN (insn)) == SEQUENCE\n+\t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN))\n+      return 1;\n+\n+  /* Otherwise, we don't.  */\n+  return 0;\n+}\n+\n+/* Return 1 if X uses a local register.  */\n+\n+int\n+uses_local_reg_p (x)\n+     rtx x;\n+{\n+  char *fmt;\n+  int i, j;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      return REGNO (x) >= R_LR (0) && REGNO (x) <= R_FP;\n+\n+    case CONST_INT:\n+    case CONST:\n+    case PC:\n+    case CC0:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return 0;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (uses_local_reg_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (uses_local_reg_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Returns 1 if this function is known to have a null epilogue.  */\n+\n+int\n+null_epilogue ()\n+{\n+  return (reload_completed && ! needs_regstack_p ()\n+\t  && get_frame_size () == 0\n+\t  && current_function_pretend_args_size == 0);\n+}\n+\f\n+/* Write out the assembler form of an operand.  Recognize the following\n+   special options:\n+\n+\t%N means write the low-order 8 bits of the negative of the constant\n+\t%Q means write a QImode operand (truncate constants to 8 bits)\n+\t%M means write the low-order 16 bits of the constant\n+\t%C means write the low-order 8 bits of the complement of the constant\n+\t%X means write the cntl values for LOAD with operand an extension op\n+\t%b means write `f' is this is a reversed condition, `t' otherwise\n+\t%B means write `t' is this is a reversed condition, `f' otherwise\n+\t%J means write the 29k opcode part for a comparison operation\n+\t%e means write the label with an extra `X' is this is the epilogue\n+\t               otherwise the normal label name\n+\t%E means write nothing if this insn has a delay slot,\n+\t\t       a nop unless this is the epilogue label, in which case\n+\t\t       write the first epilogue insn\n+\t%F means write just the normal operand if the insn has a delay slot;\n+\t\t       otherwise, this is a recursive call so output the\n+\t\t       symbol + 4 and write the first prologue insn in the\n+\t\t       delay slot.\n+\t%L means write the register number plus one (\"low order\" register)\n+\t\t       or the low-order part of a multi-word constant\n+\t%O means write the register number plus two\n+\t%P means write the register number plus three (\"low order\" of TImode)\n+\t%S means write the number of words in the mode of the operand,\n+\t\t       minus one (for CR)\n+        %V means write the number of elements in a PARALLEL minus 1\n+\t%# means write nothing if we have a delay slot, \"\\n\\tnop\" otherwise\n+\t%* means write the register name for TPC.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     char code;\n+{\n+  char buf[100];\n+\n+  /* These macros test for integers and extract the low-order bits.  */\n+#define INT_P(X)  \\\n+((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n+ && GET_MODE (X) == VOIDmode)\n+\n+#define INT_LOWPART(X) \\\n+  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n+\n+  switch (code)\n+    {\n+    case 'Q':\n+      if (GET_CODE (x) == REG)\n+\tbreak;\n+      else if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%Q value\");\n+      fprintf (file, \"%d\", INT_LOWPART (x) & 0xff);\n+      return;\n+\n+    case 'C':\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%C value\");\n+      fprintf (file, \"%d\", (~ INT_LOWPART (x)) & 0xff);\n+      return;\n+\n+    case 'N':\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%N value\");\n+      fprintf (file, \"%d\", (- INT_LOWPART (x)) & 0xff);\n+      return;\n+\n+    case 'M':\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%M value\");\n+      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+      return;\n+\n+    case 'X':\n+      fprintf (file, \"%d\", ((GET_MODE (XEXP (x, 0)) == QImode ? 1 : 2)\n+\t\t\t    + (GET_CODE (x) == SIGN_EXTEND ? 16 : 0)));\n+      return;\n+  \n+    case 'b':\n+      if (GET_CODE (x) == GE)\n+\tfprintf (file, \"f\");\n+      else\n+\tfprintf (file, \"t\");\n+      return;\n+\n+    case 'B':\n+      if (GET_CODE (x) == GE)\n+\tfprintf (file, \"t\");\n+      else\n+\tfprintf (file, \"f\");\n+      return;\n+\n+    case 'J':\n+      /* It so happens that the RTX names for the conditions are the same as\n+\t the 29k's insns except for \"ne\", which requires \"neq\".  */\n+      fprintf (file, GET_RTX_NAME (GET_CODE (x)));\n+      if (GET_CODE (x) == NE)\n+\tfprintf (file, \"q\");\n+      return;\n+\n+    case 'e':\n+      if (optimize && flag_delayed_branch\n+\t  && a29k_last_prologue_insn == 0 && epilogue_operand (x, VOIDmode)\n+\t  && dbr_sequence_length () == 0)\n+\t{\n+\t  /* We need to output the label number of the last label in the\n+\t     function, which is not necessarily X since there might be\n+\t     a USE insn in between.  First go forward to the last insn, then\n+\t     back up to a label.  */\n+\t  while (NEXT_INSN (x) != 0)\n+\t    x = NEXT_INSN (x);\n+\n+\t  while (GET_CODE (x) != CODE_LABEL)\n+\t    x = PREV_INSN (x);\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LX\", CODE_LABEL_NUMBER (x));\n+\t  assemble_name (file, buf);\n+\t}\n+      else\n+\toutput_asm_label (x);\n+      return;\n+\n+    case 'E':\n+      if (dbr_sequence_length ())\n+\t;\n+      else if (a29k_last_prologue_insn)\n+\t{\n+\t  fprintf (file, \"\\n\\t%s\", a29k_last_prologue_insn);\n+\t  a29k_last_prologue_insn = 0;\n+\t}\n+      else if (optimize && flag_delayed_branch\n+\t       && epilogue_operand (x, VOIDmode))\n+\t{\n+\t  fprintf (file, \"\\n\\t%s\", a29k_first_epilogue_insn);\n+\t  a29k_first_epilogue_insn_used = 1;\n+\t}\n+      else\n+\tfprintf (file, \"\\n\\tnop\");\n+      return;\n+      \n+    case 'F':\n+      output_addr_const (file, x);\n+      if (! strcmp (XSTR (x, 0), current_function_name)\n+\t  && dbr_sequence_length () == 0)\n+\tfprintf (file, \"+4\\n\\t%s,%d\",\n+\t\t a29k_regstack_size >= 64 ? \"const gr121\" : \"sub gr1,gr1\",\n+\t\t a29k_regstack_size * 4);\n+      return;\n+\n+    case 'L':\n+      if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+\t{\n+\t  union real_extract u;\n+\n+\t  bcopy (&CONST_DOUBLE_LOW (x), &u, sizeof u);\n+\t  fprintf (file, \"$double1(%.20e)\", u.d);\n+\t}\n+      else if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+      else\n+\toutput_operand_lossage (\"invalid %%L value\");\n+      return;\n+\n+    case 'O':\n+      if (GET_CODE (x) != REG)\n+\toutput_operand_lossage (\"invalid %%O value\");\n+      fprintf (file, \"%s\", reg_names[REGNO (x) + 2]);\n+      return;\n+\n+    case 'P':\n+      if (GET_CODE (x) != REG)\n+\toutput_operand_lossage (\"invalid %%P value\");\n+      fprintf (file, \"%s\", reg_names[REGNO (x) + 3]);\n+      return;\n+\n+    case 'S':\n+      fprintf (file, \"%d\", (GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD)-1);\n+      return;\n+\n+    case 'V':\n+      if (GET_CODE (x) != PARALLEL)\n+\toutput_operand_lossage (\"invalid %%V value\");\n+      fprintf (file, \"%d\", XVECLEN (x, 0) - 2);\n+      return;\n+\n+    case '#':\n+      if (dbr_sequence_length () == 0)\n+\t{\n+\t  if (a29k_last_prologue_insn)\n+\t    {\n+\t      fprintf (file, \"\\n\\t%s\", a29k_last_prologue_insn);\n+\t      a29k_last_prologue_insn = 0;\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\n\\tnop\");\n+\t}\n+      return;\n+\n+    case '*':\n+      fprintf (file, \"%s\", reg_names [R_TPC]);\n+      return;\n+    }\n+\n+  if (GET_CODE (x) == REG)\n+    fprintf (file, \"%s\", reg_names [REGNO (x)]);\n+\n+  else if (GET_CODE (x) == MEM)\n+    output_address (XEXP (x, 0));\n+\n+  else if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (XEXP (x, 0))) == CONST_DOUBLE)\n+    {\n+      union real_extract u;\n+\n+      if (GET_MODE (SUBREG_REG (XEXP (x, 0))) == SFmode)\n+\tfprintf (file, \"$float\");\n+      else\n+\tfprintf (file, \"$double%d\", SUBREG_WORD (XEXP (x, 0)));\n+      bcopy (&CONST_DOUBLE_LOW (SUBREG_REG (XEXP (x, 0))), &u, sizeof u);\n+      fprintf (file, \"(%.20e)\", u.d);\n+    }\n+\n+  else if (GET_CODE (x) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    {\n+      union real_extract u;\n+\n+      bcopy (&CONST_DOUBLE_LOW (x), &u, sizeof u);\n+      fprintf (file, \"$%s(%.20e)\",\n+\t       GET_MODE (x) == SFmode ? \"float\" : \"double0\", u.d);\n+    }\n+\n+  else\n+    output_addr_const (file, x);\n+}\n+\f\n+/* This page contains routines to output function prolog and epilog code. */\n+\n+/* Output function prolog code to file FILE.  Memory stack size is SIZE.\n+\n+   Also sets register names for incoming arguments and frame pointer.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int makes_calls = 0;\n+  int arg_count = 0;\n+  rtx insn;\n+  int i;\n+  unsigned int tag_word;\n+\n+  /* See if we make any calls.  We need to set lr1 if so.  */\n+  for (insn = get_insns (); insn; insn = next_insn (insn))\n+    if (GET_CODE (insn) == CALL_INSN\n+\t|| (GET_CODE (insn) == INSN\n+\t    && GET_CODE (PATTERN (insn)) == SEQUENCE\n+\t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN))\n+      {\n+\tmakes_calls = 1;\n+\tbreak;\n+      }\n+\n+  /* Find the highest local register used.  */\n+  for (i = R_LR (127); i >= R_LR (0); i--)\n+    if (regs_ever_live[i])\n+      break;\n+\n+  a29k_regstack_size = i - (R_LR (0) - 1);\n+\n+  /* If calling routines, ensure we count lr0 & lr1.  */\n+  if (makes_calls && a29k_regstack_size < 2)\n+    a29k_regstack_size = 2;\n+\n+  /* Count frame pointer and align to 8 byte boundary (even number of\n+     registers).  */\n+  a29k_regstack_size += frame_pointer_needed;\n+  if (a29k_regstack_size & 1) a29k_regstack_size++;\n+\n+  /* See how many incoming arguments we have in registers.  */\n+  for (i = R_AR (0); i < R_AR (16); i++)\n+    if (! fixed_regs[i])\n+      arg_count++;\n+\n+  /* The argument count includes the caller's lr0 and lr1.  */\n+  arg_count += 2;\n+\n+  /* Set the names and numbers of the frame pointer and incoming argument\n+     registers.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    a29k_debug_reg_map[i] = i;\n+\n+  reg_names[FRAME_POINTER_REGNUM] = reg_names[R_LR (a29k_regstack_size - 1)];\n+  a29k_debug_reg_map[FRAME_POINTER_REGNUM] = R_LR (a29k_regstack_size - 1);\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      reg_names[R_AR (i)] = reg_names[R_LR (a29k_regstack_size + i + 2)];\n+      a29k_debug_reg_map[R_AR (i)] = R_LR (a29k_regstack_size + i + 2);\n+    }\n+\n+  /* Compute memory stack size.  Add in number of bytes that the we should\n+     push and pretend the caller did and the size of outgoing arguments.\n+     Then round to a doubleword boundary.  */\n+  size += (current_function_pretend_args_size\n+\t   + current_function_outgoing_args_size);\n+  size = (size + 7) & ~7;\n+\n+  /* Write header words.  See if one or two word form.  */\n+  tag_word = (frame_pointer_needed ? 0x400000 : 0) + (arg_count << 16);\n+\n+  if (size / 8 > 0xff)\n+    fprintf (file, \"\\t.word %d, 0x%0x\\n\", (size / 8) << 2,\n+\t     0x800000 + tag_word);\n+  else\n+    fprintf (file, \"\\t.word 0x%0x\\n\", tag_word + ((size / 8) << 3));\n+\n+  /* Define the function name.  */\n+  assemble_name (file, a29k_function_name);\n+  fprintf (file, \":\\n\");\n+\n+  /* Push the register stack by the proper amount.  There are two possible\n+     ways to do this.  */\n+  if (a29k_regstack_size >= 256/4)\n+    fprintf (file, \"\\tconst %s,%d\\n\\tsub gr1,gr1,%s\\n\",\n+\t     reg_names[R_TAV], a29k_regstack_size * 4, reg_names[R_TAV]);\n+  else if (a29k_regstack_size)\n+    fprintf (file, \"\\tsub gr1,gr1,%d\\n\", a29k_regstack_size * 4);\n+\n+  /* Test that the registers are available.  */\n+  if (a29k_regstack_size)\n+    fprintf (file, \"\\tasgeu V_%sSPILL,gr1,%s\\n\",\n+\t     TARGET_KERNEL_REGISTERS ? \"K\" : \"\", reg_names[R_RAB]);\n+\n+  /* Set up frame pointer, if one is needed.  */\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tsll %s,%s,0\\n\", reg_names[FRAME_POINTER_REGNUM],\n+\t     reg_names[R_MSP]);\n+\n+  /* Make room for any frame space.  There are three ways to do this.  */\n+  if (size >= 256)\n+    {\n+      fprintf (file, \"\\tconst %s,%d\\n\", reg_names[R_TAV], size);\n+      if (size >= 65536)\n+\tfprintf (file, \"\\tconsth %s,%d\\n\", reg_names[R_TAV], size);\n+      if (TARGET_STACK_CHECK)\n+\tfprintf (file, \"\\tcall %s,__msp_check\\n\", reg_names[R_TPC]);\n+      fprintf (file, \"\\tsub %s,%s,%s\\n\",\n+\t       reg_names[R_MSP], reg_names[R_MSP], reg_names[R_TAV]);\n+    }\n+  else if (size)\n+    {\n+      if (TARGET_STACK_CHECK)\n+\tfprintf (file, \"\\tcall %s,__msp_check\\n\", reg_names[R_TPC]);\n+      fprintf (file, \"\\tsub %s,%s,%d\\n\",\n+\t       reg_names[R_MSP], reg_names[R_MSP], size);\n+    }\n+\n+  /* If this routine will make calls, set lr1.  If we see an insn that\n+     can use a delay slot before a call or jump, save this insn for that\n+     slot (this condition is equivalent to seeing if we have an insn that\n+     needs delay slots before an insn that has a filled delay slot).  */\n+  a29k_last_prologue_insn = 0;\n+  if (makes_calls)\n+    {\n+      i = (a29k_regstack_size + arg_count) * 4;\n+      if (i >= 256)\n+\tfprintf (file, \"\\tconst %s,%d\\n\\tsub lr1,gr1,%s\\n\",\n+\t\t reg_names[R_TAV], i, reg_names[R_TAV]);\n+      else\n+\t{\n+\t  if (optimize && flag_delayed_branch)\n+\t    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t      {\n+\t\tif (GET_CODE (insn) == CODE_LABEL\n+\t\t    || (GET_CODE (insn) == INSN\n+\t\t\t&& GET_CODE (PATTERN (insn)) == SEQUENCE))\n+\t\t  break;\n+\n+\t\tif (GET_CODE (insn) == NOTE\n+\t\t    || (GET_CODE (insn) == INSN\n+\t\t\t&& (GET_CODE (PATTERN (insn)) == USE\n+\t\t\t    || GET_CODE (PATTERN (insn)) == CLOBBER)))\n+\t\t  continue;\n+\n+\t\tif (num_delay_slots (insn) > 0)\n+\t\t  {\n+\t\t    a29k_last_prologue_insn = (char *) oballoc (100);\n+\t\t    sprintf (a29k_last_prologue_insn, \"add lr1,gr1,%d\", i);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t  if (a29k_last_prologue_insn == 0)\n+\t    fprintf (file, \"\\tadd lr1,gr1,%d\\n\", i);\n+\t}\n+    }\n+\n+  /* Compute the first insn of the epilogue.  */\n+  a29k_first_epilogue_insn_used = 0;\n+\n+  if (size == 0 && a29k_regstack_size == 0 && ! frame_pointer_needed)\n+    a29k_first_epilogue_insn = 0;\n+  else\n+    a29k_first_epilogue_insn = (char *) oballoc (100);\n+\n+  if (frame_pointer_needed)\n+    sprintf (a29k_first_epilogue_insn, \"sll %s,%s,0\",\n+\t     reg_names[R_MSP], reg_names[FRAME_POINTER_REGNUM]);\n+  else if (a29k_regstack_size)\n+    {\n+      if (a29k_regstack_size >= 256 / 4)\n+\tsprintf (a29k_first_epilogue_insn, \"const %s,%d\",\n+\t\t reg_names[R_TAV], a29k_regstack_size * 4);\n+      else\n+\tsprintf (a29k_first_epilogue_insn, \"add gr1,gr1,%d\",\n+\t\t a29k_regstack_size * 4);\n+    }\n+  else if (size)\n+    {\n+      if (size >= 256)\n+\tsprintf (a29k_first_epilogue_insn, \"const %s,%d\",\n+\t\t reg_names[R_TAV], size);\n+      else\n+\tsprintf (a29k_first_epilogue_insn, \"add %s,%s,%d\",\n+\t\t reg_names[R_MSP], reg_names[R_MSP], size);\n+    }\n+}\n+\f\n+/* Call this after writing what might be the first instruction of the\n+   epilogue.  If that first insn was used in a delay slot, an intermediate\n+   label is written.  */\n+\n+static void\n+check_epilogue_internal_label (file)\n+     FILE *file;\n+{\n+  rtx insn;\n+\n+  if (! a29k_first_epilogue_insn_used)\n+    return;\n+\n+  for (insn = get_last_insn ();\n+       GET_CODE (insn) != CODE_LABEL;\n+       insn = PREV_INSN (insn))\n+    ;\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"LX\", CODE_LABEL_NUMBER (insn));\n+  a29k_first_epilogue_insn_used = 0;\n+}\n+\n+/* Output the epilog of the last procedure to file FILE.  SIZE is the memory\n+   stack size.  The register stack size is in the variable\n+   A29K_REGSTACK_SIZE.  */\n+\n+void\n+output_epilog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  rtx insn;\n+  int locals_unavailable = 0;\t/* True until after first insn\n+\t\t\t\t   after gr1 update. */\n+\n+  /* If we hit a BARRIER before a real insn or CODE_LABEL, we don't\n+     need to do anything because we are never jumped to.  */\n+  insn = get_last_insn ();\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    return;\n+\n+  /* If a frame pointer was needed we must restore the memory stack pointer\n+     before adjusting the register stack.  */\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (file, \"\\tsll %s,%s,0\\n\",\n+\t       reg_names[R_MSP], reg_names[FRAME_POINTER_REGNUM]);\n+      check_epilogue_internal_label (file);\n+    }\n+\n+  /* Restore the register stack.  There are two ways to do this.  */\n+  if (a29k_regstack_size)\n+    {\n+      if (a29k_regstack_size >= 256/4)\n+\t{\n+\t  fprintf (file, \"\\tconst %s,%d\\n\",\n+\t\t   reg_names[R_TAV], a29k_regstack_size * 4);\n+\t  check_epilogue_internal_label (file);\n+\t  fprintf (file, \"\\tadd gr1,gr1,%s\\n\", reg_names[R_TAV]);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tadd gr1,gr1,%d\\n\", a29k_regstack_size * 4);\n+\t  check_epilogue_internal_label (file);\n+\t}\n+      locals_unavailable = 1;\n+    }\n+\n+  /* Restore the memory stack pointer if there is no frame pointer.\n+     Adjust the size to include any pretend arguments and pushed\n+     arguments and round to doubleword boundary.  */\n+  size += (current_function_pretend_args_size\n+\t   + current_function_outgoing_args_size);\n+  size = (size + 7) & ~7;\n+\n+  if (size && ! frame_pointer_needed)\n+    {\n+      if (size >= 256)\n+\t{\n+\t  fprintf (file, \"\\tconst %s,%d\\n\", reg_names[R_TAV], size);\n+\t  check_epilogue_internal_label (file);\n+\t  locals_unavailable = 0;\n+\t  if (size >= 65536)\n+\t    fprintf (file, \"\\tconsth %s,%d\\n\", reg_names[R_TAV], size);\n+\t  fprintf (file, \"\\tadd %s,%s,%s\\n\",\n+\t\t   reg_names[R_MSP], reg_names[R_MSP], reg_names[R_TAV]);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tadd %s,%s,%d\\n\",\n+\t\t   reg_names[R_MSP], reg_names[R_MSP], size);\n+\t  check_epilogue_internal_label (file);\n+\t  locals_unavailable = 0;\n+\t}\n+    }\n+\n+  if (locals_unavailable)\n+    {\n+      /* If we have an insn for this delay slot, write it.  */\n+      if (current_function_epilogue_delay_list)\n+\tfinal_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t\t file, 1, -2, 1);\n+      else\n+\tfprintf (file, \"\\tnop\\n\");\n+    }\n+\n+  fprintf (file, \"\\tjmpi lr0\\n\");\n+  if (a29k_regstack_size)\n+    fprintf (file, \"\\tasleu V_%sFILL,lr1,%s\\n\",\n+\t     TARGET_KERNEL_REGISTERS ? \"K\" : \"\", reg_names[R_RFB]);\n+  else if (current_function_epilogue_delay_list)\n+    final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t     file, 1, -2, 1);\n+  else\n+    fprintf (file, \"\\tnop\\n\");\n+}"}]}