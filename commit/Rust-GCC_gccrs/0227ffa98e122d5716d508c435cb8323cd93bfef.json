{"sha": "0227ffa98e122d5716d508c435cb8323cd93bfef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyN2ZmYTk4ZTEyMmQ1NzE2ZDUwOGM0MzVjYjgzMjNjZDkzYmZlZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-15T08:32:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-15T08:32:36Z"}, "message": "gimplify.c (gimplify_call_expr): Don't call omp_resolve_declare_variant after gimplification.\n\n\t* gimplify.c (gimplify_call_expr): Don't call\n\tomp_resolve_declare_variant after gimplification.\n\t* omp-general.c (omp_context_selector_matches): For isa that might\n\tmatch in some other function, defer if in declare simd function.\n\t(omp_context_compute_score): Don't look for \" score\" in construct\n\ttrait set.  Set *score to -1 if it can't ever match.\n\t(omp_resolve_declare_variant): If any variants need to be deferred,\n\tdon't punt immediately, but compute scores of all variants and if\n\tther eis a score winner that doesn't need to be deferred, return that.\n\n\t* c-c++-common/gomp/declare-variant-13.c: New test.\n\nFrom-SVN: r278280", "tree": {"sha": "1061bae3610fd33b8be8ea3ae45c260c201f3812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1061bae3610fd33b8be8ea3ae45c260c201f3812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0227ffa98e122d5716d508c435cb8323cd93bfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0227ffa98e122d5716d508c435cb8323cd93bfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0227ffa98e122d5716d508c435cb8323cd93bfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0227ffa98e122d5716d508c435cb8323cd93bfef/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c9676e2076b403eb1f6b22351bf0c58cc367ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c9676e2076b403eb1f6b22351bf0c58cc367ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c9676e2076b403eb1f6b22351bf0c58cc367ee3"}], "stats": {"total": 161, "additions": 152, "deletions": 9}, "files": [{"sha": "6810dfb194bcc408e856edef5cfb66bc3eead846", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0227ffa98e122d5716d508c435cb8323cd93bfef", "patch": "@@ -1,3 +1,15 @@\n+2019-11-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (gimplify_call_expr): Don't call\n+\tomp_resolve_declare_variant after gimplification.\n+\t* omp-general.c (omp_context_selector_matches): For isa that might\n+\tmatch in some other function, defer if in declare simd function.\n+\t(omp_context_compute_score): Don't look for \" score\" in construct\n+\ttrait set.  Set *score to -1 if it can't ever match.\n+\t(omp_resolve_declare_variant): If any variants need to be deferred,\n+\tdon't punt immediately, but compute scores of all variants and if\n+\tther eis a score winner that doesn't need to be deferred, return that.\n+\n 2019-11-15  Luo Xiong Hu  <luoxhu@linux.ibm.com>\n \n \t* ipa-comdats.c: Fix comments typo."}, {"sha": "0bbd475b3dd1b37f3333b8268661d487c60d64fb", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0227ffa98e122d5716d508c435cb8323cd93bfef", "patch": "@@ -3391,7 +3391,10 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   /* Remember the original function pointer type.  */\n   fnptrtype = TREE_TYPE (CALL_EXPR_FN (*expr_p));\n \n-  if (flag_openmp && fndecl)\n+  if (flag_openmp\n+      && fndecl\n+      && cfun\n+      && (cfun->curr_properties & PROP_gimple_any) == 0)\n     {\n       tree variant = omp_resolve_declare_variant (fndecl);\n       if (variant != fndecl)"}, {"sha": "c9c4f3aba97299b41ec023f7abc4d9337910fc71", "filename": "gcc/omp-general.c", "status": "modified", "additions": 108, "deletions": 8, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=0227ffa98e122d5716d508c435cb8323cd93bfef", "patch": "@@ -939,6 +939,21 @@ omp_context_selector_matches (tree ctx)\n \t\t\t\t\t\t\t    isa);\n \t\t    if (r == 0 || (r == -1 && symtab->state != PARSING))\n \t\t      {\n+\t\t\t/* If isa is valid on the target, but not in the\n+\t\t\t   current function and current function has\n+\t\t\t   #pragma omp declare simd on it, some simd clones\n+\t\t\t   might have the isa added later on.  */\n+\t\t\tif (r == -1\n+\t\t\t    && targetm.simd_clone.compute_vecsize_and_simdlen)\n+\t\t\t  {\n+\t\t\t    tree attrs\n+\t\t\t      = DECL_ATTRIBUTES (current_function_decl);\n+\t\t\t    if (lookup_attribute (\"omp declare simd\", attrs))\n+\t\t\t      {\n+\t\t\t\tret = -1;\n+\t\t\t\tcontinue;\n+\t\t\t      }\n+\t\t\t  }\n \t\t\t/* If we are or might be in a target region or\n \t\t\t   declare target function, need to take into account\n \t\t\t   also offloading values.  */\n@@ -1355,12 +1370,13 @@ omp_context_compute_score (tree ctx, widest_int *score, bool declare_simd)\n   bool ret = false;\n   *score = 1;\n   for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n-    for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n-      if (tree t3 = TREE_VALUE (t2))\n-\tif (TREE_PURPOSE (t3)\n-\t    && strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t3)), \" score\") == 0\n-\t    && TREE_CODE (TREE_VALUE (t3)) == INTEGER_CST)\n-\t  *score += wi::to_widest (TREE_VALUE (t3));\n+    if (TREE_VALUE (t1) != construct)\n+      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\tif (tree t3 = TREE_VALUE (t2))\n+\t  if (TREE_PURPOSE (t3)\n+\t      && strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t3)), \" score\") == 0\n+\t      && TREE_CODE (TREE_VALUE (t3)) == INTEGER_CST)\n+\t    *score += wi::to_widest (TREE_VALUE (t3));\n   if (construct || has_kind || has_arch || has_isa)\n     {\n       int scores[12];\n@@ -1378,7 +1394,7 @@ omp_context_compute_score (tree ctx, widest_int *score, bool declare_simd)\n \t    {\n \t      if (scores[b + n] < 0)\n \t\t{\n-\t\t  *score = 0;\n+\t\t  *score = -1;\n \t\t  return ret;\n \t\t}\n \t      *score += wi::shifted_mask <widest_int> (scores[b + n], 1, false);\n@@ -1407,6 +1423,8 @@ omp_resolve_declare_variant (tree base)\n {\n   tree variant1 = NULL_TREE, variant2 = NULL_TREE;\n   auto_vec <tree, 16> variants;\n+  auto_vec <bool, 16> defer;\n+  bool any_deferred = false;\n   for (tree attr = DECL_ATTRIBUTES (base); attr; attr = TREE_CHAIN (attr))\n     {\n       attr = lookup_attribute (\"omp declare variant base\", attr);\n@@ -1421,13 +1439,95 @@ omp_resolve_declare_variant (tree base)\n \t  break;\n \tcase -1:\n \t  /* Needs to be deferred.  */\n-\t  return base;\n+\t  any_deferred = true;\n+\t  variants.safe_push (attr);\n+\t  defer.safe_push (true);\n+\t  break;\n \tdefault:\n \t  variants.safe_push (attr);\n+\t  defer.safe_push (false);\n+\t  break;\n \t}\n     }\n   if (variants.length () == 0)\n     return base;\n+\n+  if (any_deferred)\n+    {\n+      widest_int max_score1 = 0;\n+      widest_int max_score2 = 0;\n+      bool first = true;\n+      unsigned int i;\n+      tree attr1, attr2;\n+      FOR_EACH_VEC_ELT (variants, i, attr1)\n+\t{\n+\t  widest_int score1;\n+\t  widest_int score2;\n+\t  bool need_two;\n+\t  tree ctx = TREE_VALUE (TREE_VALUE (attr1));\n+\t  need_two = omp_context_compute_score (ctx, &score1, false);\n+\t  if (need_two)\n+\t    omp_context_compute_score (ctx, &score2, true);\n+\t  else\n+\t    score2 = score1;\n+\t  if (first)\n+\t    {\n+\t      first = false;\n+\t      max_score1 = score1;\n+\t      max_score2 = score2;\n+\t      if (!defer[i])\n+\t\t{\n+\t\t  variant1 = attr1;\n+\t\t  variant2 = attr1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (max_score1 == score1)\n+\t\tvariant1 = NULL_TREE;\n+\t      else if (score1 > max_score1)\n+\t\t{\n+\t\t  max_score1 = score1;\n+\t\t  variant1 = defer[i] ? NULL_TREE : attr1;\n+\t\t}\n+\t      if (max_score2 == score2)\n+\t\tvariant2 = NULL_TREE;\n+\t      else if (score2 > max_score2)\n+\t\t{\n+\t\t  max_score2 = score2;\n+\t\t  variant2 = defer[i] ? NULL_TREE : attr1;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If there is a clear winner variant with the score which is not\n+\t deferred, verify it is not a strict subset of any other context\n+\t selector and if it is not, it is the best alternative no matter\n+\t whether the others do or don't match.  */\n+      if (variant1 && variant1 == variant2)\n+\t{\n+\t  tree ctx1 = TREE_VALUE (TREE_VALUE (variant1));\n+\t  FOR_EACH_VEC_ELT (variants, i, attr2)\n+\t    {\n+\t      if (attr2 == variant1)\n+\t\tcontinue;\n+\t      tree ctx2 = TREE_VALUE (TREE_VALUE (attr2));\n+\t      int r = omp_context_selector_compare (ctx1, ctx2);\n+\t      if (r == -1)\n+\t\t{\n+\t\t  /* The winner is a strict subset of ctx2, can't\n+\t\t     decide now.  */\n+\t\t  variant1 = NULL_TREE;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (variant1)\n+\t    return TREE_PURPOSE (TREE_VALUE (variant1));\n+\t}\n+\n+      return base;\n+    }\n+\n   if (variants.length () == 1)\n     return TREE_PURPOSE (TREE_VALUE (variants[0]));\n "}, {"sha": "6d7a132f08f185e48c42ef86788b18786a763541", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0227ffa98e122d5716d508c435cb8323cd93bfef", "patch": "@@ -1,3 +1,7 @@\n+2019-11-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-13.c: New test.\n+\n 2019-11-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR testsuite/92520"}, {"sha": "68e6a8979504d7452ab6bda6c109b45db6763089", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-13.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0227ffa98e122d5716d508c435cb8323cd93bfef/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-13.c?ref=0227ffa98e122d5716d508c435cb8323cd93bfef", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile { target vect_simd_clones } } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+int f01 (int);\n+int f02 (int);\n+int f03 (int);\n+int f04 (int);\n+#pragma omp declare variant (f01) match (device={isa(\"avx512f\")}) /* 4 or 8 */\n+#pragma omp declare variant (f02) match (implementation={vendor(score(3):gnu)},device={kind(cpu)}) /* (1 or 2) + 3 */\n+#pragma omp declare variant (f03) match (user={condition(score(9):1)})\n+#pragma omp declare variant (f04) match (implementation={vendor(score(6):gnu)},device={kind(host)}) /* (1 or 2) + 6 */\n+int f05 (int);\n+\n+#pragma omp declare simd\n+int\n+test1 (int x)\n+{\n+  /* 0 or 1 (the latter if in a declare simd clone) constructs in OpenMP context,\n+     isa has score 2^2 or 2^3.  We can't decide on whether avx512f will match or\n+     not, that also depends on whether it is a declare simd clone or not and which\n+     one, but the f03 variant has a higher score anyway.  */\n+  return f05 (x);\t/* { dg-final { scan-tree-dump-times \"f03 \\\\\\(x\" 1 \"gimple\" } } */\n+}"}]}