{"sha": "5ca9980fc86242505ffdaaf62bca1fd5db26550b", "node_id": "C_kwDOANBUbNoAKDVjYTk5ODBmYzg2MjQyNTA1ZmZkYWFmNjJiY2ExZmQ1ZGIyNjU1MGI", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-11-20T07:52:53Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-09-02T09:23:50Z"}, "message": "Add TARGET_COMPUTE_MULTILIB hook to override multi-lib result.\n\nCreate a new hook to let target could override the multi-lib result,\nthe motivation is RISC-V might have very complicated multi-lib re-use\nrule*, which is hard to maintain and use current multi-lib scripts,\nwe even hit the \"argument list too long\" error when we tried to add more\nmulti-lib reuse rule.\n\nSo I think it would be great to have a target specific way to determine\nthe multi-lib re-use rule, then we could write those rule in C, instead\nof expand every possible case in MULTILIB_REUSE.\n\n* Here is an example for RISC-V multi-lib rules:\nhttps://gist.github.com/kito-cheng/0289cd42d9a756382e5afeb77b42b73b\n\ngcc/ChangeLog:\n\n\t* common/common-target.def (compute_multilib): New.\n\t* common/common-targhooks.h (default_compute_multilib): New.\n\t* common/common-targhooks.cc (default_compute_multilib): New.\n\t* doc/tm.texi.in (TARGET_COMPUTE_MULTILIB): New.\n\t* doc/tm.texi: Regen.\n\t* gcc.cc: Include common/common-target.h.\n\t(set_multilib_dir) Call targetm_common.compute_multilib.\n\t(SWITCH_LIVE): Move to opts.h.\n\t(SWITCH_FALSE): Ditto.\n\t(SWITCH_IGNORE): Ditto.\n\t(SWITCH_IGNORE_PERMANENTLY): Ditto.\n\t(SWITCH_KEEP_FOR_GCC): Ditto.\n\t(struct switchstr): Ditto.\n\t* opts.h (SWITCH_LIVE): Move from gcc.c.\n\t(SWITCH_FALSE): Ditto.\n\t(SWITCH_IGNORE): Ditto.\n\t(SWITCH_IGNORE_PERMANENTLY): Ditto.\n\t(SWITCH_KEEP_FOR_GCC): Ditto.\n\t(struct switchstr): Ditto.", "tree": {"sha": "521cee052ab40f5e473ae4731286addd34f6c678", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/521cee052ab40f5e473ae4731286addd34f6c678"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ca9980fc86242505ffdaaf62bca1fd5db26550b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca9980fc86242505ffdaaf62bca1fd5db26550b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca9980fc86242505ffdaaf62bca1fd5db26550b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca9980fc86242505ffdaaf62bca1fd5db26550b/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "347dec125b662bdeb6d426ead3449e1209c2ce28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347dec125b662bdeb6d426ead3449e1209c2ce28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347dec125b662bdeb6d426ead3449e1209c2ce28"}], "stats": {"total": 155, "additions": 119, "deletions": 36}, "files": [{"sha": "c4c6230073ab77991a9651697fc4cdf52c51862d", "filename": "gcc/common/common-target.def", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-target.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-target.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-target.def?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -84,6 +84,31 @@ The result will be pruned to cases with PREFIX if not NULL.\",\n  vec<const char *>, (int option_code, const char *prefix),\n  default_get_valid_option_values)\n \n+DEFHOOK\n+(compute_multilib,\n+ \"Some targets like RISC-V might have complicated multilib reuse rules which\\n\\\n+are hard to implement with the current multilib scheme.  This hook allows\\n\\\n+targets to override the result from the built-in multilib mechanism.\\n\\\n+@var{switches} is the raw option list with @var{n_switches} items;\\n\\\n+@var{multilib_dir} is the multi-lib result which is computed by the built-in\\n\\\n+multi-lib mechanism;\\n\\\n+@var{multilib_defaults} is the default options list for multi-lib;\\n\\\n+@var{multilib_select} is the string containing the list of supported\\n\\\n+multi-libs, and the option checking list.\\n\\\n+@var{multilib_matches}, @var{multilib_exclusions}, and @var{multilib_reuse}\\n\\\n+are corresponding to @var{MULTILIB_MATCHES}, @var{MULTILIB_EXCLUSIONS},\\n\\\n+and @var{MULTILIB_REUSE}.\\n\\\n+The default definition does nothing but return @var{multilib_dir} directly.\",\n+ const char *, (const struct switchstr *switches,\n+\t\tint n_switches,\n+\t\tconst char *multilib_dir,\n+\t\tconst char *multilib_defaults,\n+\t\tconst char *multilib_select,\n+\t\tconst char *multilib_matches,\n+\t\tconst char *multilib_exclusions,\n+\t\tconst char *multilib_reuse),\n+ default_compute_multilib)\n+\n /* Leave the boolean fields at the end.  */\n \n /* True if unwinding tables should be generated by default.  */"}, {"sha": "7499be27b68ca64ee98843314fe89972dd41443c", "filename": "gcc/common/common-targhooks.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-targhooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-targhooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-targhooks.cc?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -90,3 +90,18 @@ const struct default_options empty_optimization_table[] =\n   {\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n+\n+/* Default version of TARGET_COMPUTE_MULTILIB.  */\n+const char *\n+default_compute_multilib(\n+  const struct switchstr *,\n+  int,\n+  const char *multilib,\n+  const char *,\n+  const char *,\n+  const char *,\n+  const char *,\n+  const char *)\n+{\n+  return multilib;\n+}"}, {"sha": "1f03495010377cf4e9eb2acf38e7d1abe389d323", "filename": "gcc/common/common-targhooks.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-targhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fcommon%2Fcommon-targhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-targhooks.h?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -32,4 +32,15 @@ extern vec<const char *> default_get_valid_option_values (int, const char *);\n \n extern const struct default_options empty_optimization_table[];\n \n+const char *\n+default_compute_multilib(\n+  const struct switchstr *,\n+  int,\n+  const char *multilib,\n+  const char *,\n+  const char *,\n+  const char *,\n+  const char *,\n+  const char *);\n+\n #endif"}, {"sha": "11be5d0a54a178efa0ecd2c65a367a89a0fa617b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -778,6 +778,23 @@ options are changed via @code{#pragma GCC optimize} or by using the\n Set target-dependent initial values of fields in @var{opts}.\n @end deftypefn\n \n+@deftypefn {Common Target Hook} {const char *} TARGET_COMPUTE_MULTILIB (const struct switchstr *@var{switches}, int @var{n_switches}, const char *@var{multilib_dir}, const char *@var{multilib_defaults}, const char *@var{multilib_select}, const char *@var{multilib_matches}, const char *@var{multilib_exclusions}, const char *@var{multilib_reuse})\n+Some targets like RISC-V might have complicated multilib reuse rules which\n+are hard to implement with the current multilib scheme.  This hook allows\n+targets to override the result from the built-in multilib mechanism.\n+@var{switches} is the raw option list with @var{n_switches} items;\n+@var{multilib_dir} is the multi-lib result which is computed by the built-in\n+multi-lib mechanism;\n+@var{multilib_defaults} is the default options list for multi-lib;\n+@var{multilib_select} is the string containing the list of supported\n+multi-libs, and the option checking list.\n+@var{multilib_matches}, @var{multilib_exclusions}, and @var{multilib_reuse}\n+are corresponding to @var{MULTILIB_MATCHES}, @var{MULTILIB_EXCLUSIONS},\n+and @var{MULTILIB_REUSE}.\n+The default definition does nothing but return @var{multilib_dir} directly.\n+@end deftypefn\n+\n+\n @defmac SWITCHABLE_TARGET\n Some targets need to switch between substantially different subtargets\n during compilation.  For example, the MIPS target has one subtarget for"}, {"sha": "0d8cd2eba38e055f7138e4be79d86b4026f27de9", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -736,6 +736,9 @@ options are changed via @code{#pragma GCC optimize} or by using the\n \n @hook TARGET_OPTION_INIT_STRUCT\n \n+@hook TARGET_COMPUTE_MULTILIB\n+\n+\n @defmac SWITCHABLE_TARGET\n Some targets need to switch between substantially different subtargets\n during compilation.  For example, the MIPS target has one subtarget for"}, {"sha": "158461167951c1b9540322fb19be6a89d6da07fc", "filename": "gcc/gcc.cc", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fgcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fgcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.cc?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -45,6 +45,7 @@ compilation is specified by a string called a \"spec\".  */\n #include \"filenames.h\"\n #include \"spellcheck.h\"\n #include \"opts-jobserver.h\"\n+#include \"common/common-target.h\"\n \n \f\n \n@@ -3563,42 +3564,6 @@ execute (void)\n   }\n }\n \f\n-/* Find all the switches given to us\n-   and make a vector describing them.\n-   The elements of the vector are strings, one per switch given.\n-   If a switch uses following arguments, then the `part1' field\n-   is the switch itself and the `args' field\n-   is a null-terminated vector containing the following arguments.\n-   Bits in the `live_cond' field are:\n-   SWITCH_LIVE to indicate this switch is true in a conditional spec.\n-   SWITCH_FALSE to indicate this switch is overridden by a later switch.\n-   SWITCH_IGNORE to indicate this switch should be ignored (used in %<S).\n-   SWITCH_IGNORE_PERMANENTLY to indicate this switch should be ignored.\n-   SWITCH_KEEP_FOR_GCC to indicate that this switch, otherwise ignored,\n-   should be included in COLLECT_GCC_OPTIONS.\n-   in all do_spec calls afterwards.  Used for %<S from self specs.\n-   The `known' field describes whether this is an internal switch.\n-   The `validated' field describes whether any spec has looked at this switch;\n-   if it remains false at the end of the run, the switch must be meaningless.\n-   The `ordering' field is used to temporarily mark switches that have to be\n-   kept in a specific order.  */\n-\n-#define SWITCH_LIVE    \t\t\t(1 << 0)\n-#define SWITCH_FALSE   \t\t\t(1 << 1)\n-#define SWITCH_IGNORE\t\t\t(1 << 2)\n-#define SWITCH_IGNORE_PERMANENTLY\t(1 << 3)\n-#define SWITCH_KEEP_FOR_GCC\t\t(1 << 4)\n-\n-struct switchstr\n-{\n-  const char *part1;\n-  const char **args;\n-  unsigned int live_cond;\n-  bool known;\n-  bool validated;\n-  bool ordering;\n-};\n-\n static struct switchstr *switches;\n \n static int n_switches;\n@@ -9827,6 +9792,17 @@ set_multilib_dir (void)\n       ++p;\n     }\n \n+  multilib_dir =\n+    targetm_common.compute_multilib (\n+      switches,\n+      n_switches,\n+      multilib_dir,\n+      multilib_defaults,\n+      multilib_select,\n+      multilib_matches,\n+      multilib_exclusions,\n+      multilib_reuse);\n+\n   if (multilib_dir == NULL && multilib_os_dir != NULL\n       && strcmp (multilib_os_dir, \".\") == 0)\n     {"}, {"sha": "ce4fd5c39b9cc016c9a5f84efb74b64022ec36dc", "filename": "gcc/opts.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca9980fc86242505ffdaaf62bca1fd5db26550b/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=5ca9980fc86242505ffdaaf62bca1fd5db26550b", "patch": "@@ -527,4 +527,40 @@ extern char *gen_producer_string (const char *language_string,\n \n #define OPTION_SET_P(OPTION) global_options_set.x_ ## OPTION\n \n+/* Find all the switches given to us\n+   and make a vector describing them.\n+   The elements of the vector are strings, one per switch given.\n+   If a switch uses following arguments, then the `part1' field\n+   is the switch itself and the `args' field\n+   is a null-terminated vector containing the following arguments.\n+   Bits in the `live_cond' field are:\n+   SWITCH_LIVE to indicate this switch is true in a conditional spec.\n+   SWITCH_FALSE to indicate this switch is overridden by a later switch.\n+   SWITCH_IGNORE to indicate this switch should be ignored (used in %<S).\n+   SWITCH_IGNORE_PERMANENTLY to indicate this switch should be ignored.\n+   SWITCH_KEEP_FOR_GCC to indicate that this switch, otherwise ignored,\n+   should be included in COLLECT_GCC_OPTIONS.\n+   in all do_spec calls afterwards.  Used for %<S from self specs.\n+   The `known' field describes whether this is an internal switch.\n+   The `validated' field describes whether any spec has looked at this switch;\n+   if it remains false at the end of the run, the switch must be meaningless.\n+   The `ordering' field is used to temporarily mark switches that have to be\n+   kept in a specific order.  */\n+\n+#define SWITCH_LIVE    \t\t\t(1 << 0)\n+#define SWITCH_FALSE   \t\t\t(1 << 1)\n+#define SWITCH_IGNORE\t\t\t(1 << 2)\n+#define SWITCH_IGNORE_PERMANENTLY\t(1 << 3)\n+#define SWITCH_KEEP_FOR_GCC\t\t(1 << 4)\n+\n+struct switchstr\n+{\n+  const char *part1;\n+  const char **args;\n+  unsigned int live_cond;\n+  bool known;\n+  bool validated;\n+  bool ordering;\n+};\n+\n #endif"}]}