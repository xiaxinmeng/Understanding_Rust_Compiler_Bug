{"sha": "422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "node_id": "C_kwDOANBUbNoAKDQyMmY5ZWI3MDExYjc2YzEyZmYwMGZmYWVlMmJjYzljZGRkZjE2ZDU", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-12-17T01:37:18Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-12-17T03:45:30Z"}, "message": "tree-object-size: Use trees and support negative offsets\n\nTransform tree-object-size to operate on tree objects instead of host\nwide integers.  This makes it easier to extend to dynamic expressions\nfor object sizes.\n\nThe compute_builtin_object_size interface also now returns a tree\nexpression instead of HOST_WIDE_INT, so callers have been adjusted to\naccount for that.\n\nThe trees in object_sizes are each an object_size object with members\nsize (the bytes from the pointer to the end of the object) and wholesize\n(the size of the whole object).  This allows analysis of negative\noffsets, which can now be allowed to the extent of the object bounds.\nTests have been added to verify that it actually works.\n\ngcc/ChangeLog:\n\n\t* tree-object-size.h (compute_builtin_object_size): Return tree\n\tinstead of HOST_WIDE_INT.\n\t* builtins.c (fold_builtin_object_size): Adjust.\n\t* gimple-fold.c (gimple_fold_builtin_strncat): Likewise.\n\t* ubsan.c (instrument_object_size): Likewise.\n\t* tree-object-size.c (object_size): New structure.\n\t(object_sizes): Change type to vec<object_size>.\n\t(initval): New function.\n\t(unknown): Use it.\n\t(size_unknown_p, size_initval, size_unknown): New functions.\n\t(object_sizes_unknown_p): Use it.\n\t(object_sizes_get): Return tree.\n\t(object_sizes_initialize): Rename from object_sizes_set_force\n\tand set VAL parameter type as tree.  Add new parameter WHOLEVAL.\n\t(object_sizes_set): Set VAL parameter type as tree and adjust\n\timplementation.  Add new parameter WHOLEVAL.\n\t(size_for_offset): New function.\n\t(decl_init_size): Adjust comment.\n\t(addr_object_size): Change PSIZE parameter to tree and adjust\n\timplementation.  Add new parameter PWHOLESIZE.\n\t(alloc_object_size): Return tree.\n\t(compute_builtin_object_size): Return tree in PSIZE.\n\t(expr_object_size, call_object_size, unknown_object_size):\n\tAdjust for object_sizes_set change.\n\t(merge_object_sizes): Drop OFFSET parameter and adjust\n\timplementation for tree change.\n\t(plus_stmt_object_size): Call collect_object_sizes_for directly\n\tinstead of merge_object_size and call size_for_offset to get net\n\tsize.\n\t(cond_expr_object_size, collect_object_sizes_for,\n\tobject_sizes_execute): Adjust for change of type from\n\tHOST_WIDE_INT to tree.\n\t(check_for_plus_in_loops_1): Likewise and skip non-positive\n\toffsets.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/builtin-object-size-1.c (test9): New test.\n\t(main): Call it.\n\t* gcc.dg/builtin-object-size-2.c (test8): New test.\n\t(main): Call it.\n\t* gcc.dg/builtin-object-size-3.c (test9): New test.\n\t(main): Call it.\n\t* gcc.dg/builtin-object-size-4.c (test8): New test.\n\t(main): Call it.\n\t* gcc.dg/builtin-object-size-5.c (test5, test6, test7): New\n\ttests.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "7caf8a641a42f07397a39931545e113efba5ee36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7caf8a641a42f07397a39931545e113efba5ee36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871504b0dd5cd023d3a28cf9e5ccbda75928b102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871504b0dd5cd023d3a28cf9e5ccbda75928b102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/871504b0dd5cd023d3a28cf9e5ccbda75928b102"}], "stats": {"total": 568, "additions": 409, "deletions": 159}, "files": [{"sha": "abe342e111dde63b1ed9737170628eeea58a0e89", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -10255,7 +10255,7 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n static tree\n fold_builtin_object_size (tree ptr, tree ost)\n {\n-  unsigned HOST_WIDE_INT bytes;\n+  tree bytes;\n   int object_size_type;\n \n   if (!validate_arg (ptr, POINTER_TYPE)\n@@ -10280,17 +10280,17 @@ fold_builtin_object_size (tree ptr, tree ost)\n   if (TREE_CODE (ptr) == ADDR_EXPR)\n     {\n       compute_builtin_object_size (ptr, object_size_type, &bytes);\n-      if (wi::fits_to_tree_p (bytes, size_type_node))\n-\treturn build_int_cstu (size_type_node, bytes);\n+      if (int_fits_type_p (bytes, size_type_node))\n+\treturn fold_convert (size_type_node, bytes);\n     }\n   else if (TREE_CODE (ptr) == SSA_NAME)\n     {\n       /* If object size is not known yet, delay folding until\n        later.  Maybe subsequent passes will help determining\n        it.  */\n       if (compute_builtin_object_size (ptr, object_size_type, &bytes)\n-\t  && wi::fits_to_tree_p (bytes, size_type_node))\n-\treturn build_int_cstu (size_type_node, bytes);\n+\t  && int_fits_type_p (bytes, size_type_node))\n+\treturn fold_convert (size_type_node, bytes);\n     }\n \n   return NULL_TREE;"}, {"sha": "64515aabc04a930e15615d61b34eee48604e7612", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -2493,17 +2493,16 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n   if (!src_len || known_lower (stmt, len, src_len, true))\n     return false;\n \n-  unsigned HOST_WIDE_INT dstsize;\n-  bool found_dstsize = compute_builtin_object_size (dst, 1, &dstsize);\n-\n   /* Warn on constant LEN.  */\n   if (TREE_CODE (len) == INTEGER_CST)\n     {\n       bool nowarn = warning_suppressed_p (stmt, OPT_Wstringop_overflow_);\n+      tree dstsize;\n \n-      if (!nowarn && found_dstsize)\n+      if (!nowarn && compute_builtin_object_size (dst, 1, &dstsize)\n+\t  && TREE_CODE (dstsize) == INTEGER_CST)\n \t{\n-\t  int cmpdst = compare_tree_int (len, dstsize);\n+\t  int cmpdst = tree_int_cst_compare (len, dstsize);\n \n \t  if (cmpdst >= 0)\n \t    {\n@@ -2519,7 +2518,7 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n \t\t\t\t   ? G_(\"%qD specified bound %E equals \"\n \t\t\t\t\t\"destination size\")\n \t\t\t\t   : G_(\"%qD specified bound %E exceeds \"\n-\t\t\t\t\t\"destination size %wu\"),\n+\t\t\t\t\t\"destination size %E\"),\n \t\t\t\t   fndecl, len, dstsize);\n \t      if (nowarn)\n \t\tsuppress_warning (stmt, OPT_Wstringop_overflow_);"}, {"sha": "0154f4e9695703e66f324e356b719c6594513be9", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-1.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -424,6 +424,35 @@ test8 (void)\n     abort ();\n }\n \n+void\n+__attribute__ ((noinline))\n+test9 (unsigned cond)\n+{\n+  char *buf2 = malloc (10);\n+  char *p;\n+\n+  if (cond)\n+    p = &buf2[8];\n+  else\n+    p = &buf2[4];\n+\n+  if (__builtin_object_size (&p[-4], 0) != 10)\n+    abort ();\n+\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 0) != 10)\n+    abort ();\n+\n+  p = &y.c[8];\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 0) != sizeof (y))\n+    abort ();\n+}\n+\n int\n main (void)\n {\n@@ -437,5 +466,6 @@ main (void)\n   test6 (4);\n   test7 ();\n   test8 ();\n+  test9 (1);\n   exit (0);\n }"}, {"sha": "5cf29291afff5e9375cac57cbcc504c0ce5eaab6", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-2.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -382,6 +382,35 @@ test7 (void)\n     abort ();\n }\n \n+void\n+__attribute__ ((noinline))\n+test8 (unsigned cond)\n+{\n+  char *buf2 = malloc (10);\n+  char *p;\n+\n+  if (cond)\n+    p = &buf2[8];\n+  else\n+    p = &buf2[4];\n+\n+  if (__builtin_object_size (&p[-4], 1) != 10)\n+    abort ();\n+\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 1) != 10)\n+    abort ();\n+\n+  p = &y.c[8];\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 1) != sizeof (y.c))\n+    abort ();\n+}\n+\n int\n main (void)\n {\n@@ -394,5 +423,6 @@ main (void)\n   test5 (4);\n   test6 ();\n   test7 ();\n+  test8 (1);\n   exit (0);\n }"}, {"sha": "3a692c4e3d2c5a26e0c5ecc294fd0e00485aaa65", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-3.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -430,6 +430,36 @@ test8 (void)\n     abort ();\n }\n \n+void\n+__attribute__ ((noinline))\n+test9 (unsigned cond)\n+{\n+  char *buf2 = malloc (10);\n+  char *p;\n+\n+  if (cond)\n+    p = &buf2[8];\n+  else\n+    p = &buf2[4];\n+\n+  if (__builtin_object_size (&p[-4], 2) != 6)\n+    abort ();\n+\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 2) != 2)\n+    abort ();\n+\n+  p = &y.c[8];\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 2)\n+      != sizeof (y) - __builtin_offsetof (struct A, c) - 8)\n+    abort ();\n+}\n+\n int\n main (void)\n {\n@@ -443,5 +473,6 @@ main (void)\n   test6 (4);\n   test7 ();\n   test8 ();\n+  test9 (1);\n   exit (0);\n }"}, {"sha": "87381620cc90e65989b50e84a45360b3ba2e395f", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-4.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -395,6 +395,35 @@ test7 (void)\n     abort ();\n }\n \n+void\n+__attribute__ ((noinline))\n+test8 (unsigned cond)\n+{\n+  char *buf2 = malloc (10);\n+  char *p;\n+\n+  if (cond)\n+    p = &buf2[8];\n+  else\n+    p = &buf2[4];\n+\n+  if (__builtin_object_size (&p[-4], 3) != 6)\n+    abort ();\n+\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 3) != 2)\n+    abort ();\n+\n+  p = &y.c[8];\n+  for (unsigned i = cond; i > 0; i--)\n+    p--;\n+\n+  if (__builtin_object_size (p, 3) != sizeof (y.c) - 8)\n+    abort ();\n+}\n+\n int\n main (void)\n {\n@@ -407,5 +436,6 @@ main (void)\n   test5 (4);\n   test6 ();\n   test7 ();\n+  test8 (1);\n   exit (0);\n }"}, {"sha": "8e63d9c7a5e2e24ecbab3b478bf6b5f2e63b47af", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-5.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -53,4 +53,29 @@ test4 (size_t x)\n     abort ();\n }\n \n+void\n+test5 (void)\n+{\n+  char *p = &buf[0x90000004];\n+  if (__builtin_object_size (p + 2, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test6 (void)\n+{\n+  char *p = &buf[-4];\n+  if (__builtin_object_size (p + 2, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test7 (void)\n+{\n+  char *buf2 = __builtin_malloc (8);\n+  char *p = &buf2[0x90000004];\n+  if (__builtin_object_size (p + 2, 0) != 0)\n+    abort ();\n+}\n+\n /* { dg-final { scan-assembler-not \"abort\" } } */"}, {"sha": "32ef6dd513315088bdbb43f99cbed637dde97aa0", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 250, "deletions": 144, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -45,6 +45,14 @@ struct object_size_info\n   unsigned int *stack, *tos;\n };\n \n+struct GTY(()) object_size\n+{\n+  /* Estimate of bytes till the end of the object.  */\n+  tree size;\n+  /* Estimate of the size of the whole object.  */\n+  tree wholesize;\n+};\n+\n enum\n {\n   OST_SUBOBJECT = 1,\n@@ -54,38 +62,73 @@ enum\n \n static tree compute_object_offset (const_tree, const_tree);\n static bool addr_object_size (struct object_size_info *,\n-\t\t\t      const_tree, int, unsigned HOST_WIDE_INT *);\n-static unsigned HOST_WIDE_INT alloc_object_size (const gcall *, int);\n+\t\t\t      const_tree, int, tree *, tree *t = NULL);\n+static tree alloc_object_size (const gcall *, int);\n static tree pass_through_call (const gcall *);\n static void collect_object_sizes_for (struct object_size_info *, tree);\n static void expr_object_size (struct object_size_info *, tree, tree);\n-static bool merge_object_sizes (struct object_size_info *, tree, tree,\n-\t\t\t\tunsigned HOST_WIDE_INT);\n+static bool merge_object_sizes (struct object_size_info *, tree, tree);\n static bool plus_stmt_object_size (struct object_size_info *, tree, gimple *);\n static bool cond_expr_object_size (struct object_size_info *, tree, gimple *);\n static void init_offset_limit (void);\n static void check_for_plus_in_loops (struct object_size_info *, tree);\n static void check_for_plus_in_loops_1 (struct object_size_info *, tree,\n \t\t\t\t       unsigned int);\n \n-/* object_sizes[0] is upper bound for number of bytes till the end of\n-   the object.\n-   object_sizes[1] is upper bound for number of bytes till the end of\n-   the subobject (innermost array or field with address taken).\n-   object_sizes[2] is lower bound for number of bytes till the end of\n-   the object and object_sizes[3] lower bound for subobject.  */\n-static vec<unsigned HOST_WIDE_INT> object_sizes[OST_END];\n+/* object_sizes[0] is upper bound for the object size and number of bytes till\n+   the end of the object.\n+   object_sizes[1] is upper bound for the object size and number of bytes till\n+   the end of the subobject (innermost array or field with address taken).\n+   object_sizes[2] is lower bound for the object size and number of bytes till\n+   the end of the object and object_sizes[3] lower bound for subobject.  */\n+static vec<object_size> object_sizes[OST_END];\n \n /* Bitmaps what object sizes have been computed already.  */\n static bitmap computed[OST_END];\n \n /* Maximum value of offset we consider to be addition.  */\n static unsigned HOST_WIDE_INT offset_limit;\n \n+/* Initial value of object sizes; zero for maximum and SIZE_MAX for minimum\n+   object size.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+initval (int object_size_type)\n+{\n+  return (object_size_type & OST_MINIMUM) ? HOST_WIDE_INT_M1U : 0;\n+}\n+\n+/* Unknown object size value; it's the opposite of initval.  */\n+\n static inline unsigned HOST_WIDE_INT\n unknown (int object_size_type)\n {\n-  return ((unsigned HOST_WIDE_INT) -((object_size_type >> 1) ^ 1));\n+  return ~initval (object_size_type);\n+}\n+\n+/* Return true if VAL is represents an unknown size for OBJECT_SIZE_TYPE.  */\n+\n+static inline bool\n+size_unknown_p (tree val, int object_size_type)\n+{\n+  return (tree_fits_uhwi_p (val)\n+\t  && tree_to_uhwi (val) == unknown (object_size_type));\n+}\n+\n+/* Return a tree with initial value for OBJECT_SIZE_TYPE.  */\n+\n+static inline tree\n+size_initval (int object_size_type)\n+{\n+  return size_int (initval (object_size_type));\n+}\n+\n+/* Return a tree with unknown value for OBJECT_SIZE_TYPE.  */\n+\n+static inline tree\n+size_unknown (int object_size_type)\n+{\n+  return size_int (unknown (object_size_type));\n }\n \n /* Grow object_sizes[OBJECT_SIZE_TYPE] to num_ssa_names.  */\n@@ -110,47 +153,57 @@ object_sizes_release (int object_size_type)\n static inline bool\n object_sizes_unknown_p (int object_size_type, unsigned varno)\n {\n-  return (object_sizes[object_size_type][varno]\n-\t  == unknown (object_size_type));\n+  return size_unknown_p (object_sizes[object_size_type][varno].size,\n+\t\t\t object_size_type);\n }\n \n-/* Return size for VARNO corresponding to OSI.  */\n+/* Return size for VARNO corresponding to OSI.  If WHOLE is true, return the\n+   whole object size.  */\n \n-static inline unsigned HOST_WIDE_INT\n-object_sizes_get (struct object_size_info *osi, unsigned varno)\n+static inline tree\n+object_sizes_get (struct object_size_info *osi, unsigned varno,\n+\t\t  bool whole = false)\n {\n-  return object_sizes[osi->object_size_type][varno];\n+  if (whole)\n+    return object_sizes[osi->object_size_type][varno].wholesize;\n+  else\n+    return object_sizes[osi->object_size_type][varno].size;\n }\n \n /* Set size for VARNO corresponding to OSI to VAL.  */\n \n-static inline bool\n-object_sizes_set_force (struct object_size_info *osi, unsigned varno,\n-\t\t\tunsigned HOST_WIDE_INT val)\n+static inline void\n+object_sizes_initialize (struct object_size_info *osi, unsigned varno,\n+\t\t\t tree val, tree wholeval)\n {\n-  object_sizes[osi->object_size_type][varno] = val;\n-  return true;\n+  int object_size_type = osi->object_size_type;\n+\n+  object_sizes[object_size_type][varno].size = val;\n+  object_sizes[object_size_type][varno].wholesize = wholeval;\n }\n \n /* Set size for VARNO corresponding to OSI to VAL if it is the new minimum or\n    maximum.  */\n \n static inline bool\n-object_sizes_set (struct object_size_info *osi, unsigned varno,\n-\t\t  unsigned HOST_WIDE_INT val)\n+object_sizes_set (struct object_size_info *osi, unsigned varno, tree val,\n+\t\t  tree wholeval)\n {\n   int object_size_type = osi->object_size_type;\n-  if ((object_size_type & OST_MINIMUM) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < val)\n-\treturn object_sizes_set_force (osi, varno, val);\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > val)\n-\treturn object_sizes_set_force (osi, varno, val);\n-    }\n-  return false;\n+  object_size osize = object_sizes[object_size_type][varno];\n+\n+  tree oldval = osize.size;\n+  tree old_wholeval = osize.wholesize;\n+\n+  enum tree_code code = object_size_type & OST_MINIMUM ? MIN_EXPR : MAX_EXPR;\n+\n+  val = size_binop (code, val, oldval);\n+  wholeval = size_binop (code, wholeval, old_wholeval);\n+\n+  object_sizes[object_size_type][varno].size = val;\n+  object_sizes[object_size_type][varno].wholesize = wholeval;\n+  return (tree_int_cst_compare (oldval, val) != 0\n+\t  || tree_int_cst_compare (old_wholeval, wholeval) != 0);\n }\n \n /* Initialize OFFSET_LIMIT variable.  */\n@@ -164,6 +217,48 @@ init_offset_limit (void)\n   offset_limit /= 2;\n }\n \n+/* Bytes at end of the object with SZ from offset OFFSET.  If WHOLESIZE is not\n+   NULL_TREE, use it to get the net offset of the pointer, which should always\n+   be positive and hence, be within OFFSET_LIMIT for valid offsets.  */\n+\n+static tree\n+size_for_offset (tree sz, tree offset, tree wholesize = NULL_TREE)\n+{\n+  gcc_checking_assert (TREE_CODE (offset) == INTEGER_CST);\n+  gcc_checking_assert (TREE_CODE (sz) == INTEGER_CST);\n+  gcc_checking_assert (types_compatible_p (TREE_TYPE (sz), sizetype));\n+\n+  /* For negative offsets, if we have a distinct WHOLESIZE, use it to get a net\n+     offset from the whole object.  */\n+  if (wholesize && tree_int_cst_compare (sz, wholesize))\n+    {\n+      gcc_checking_assert (TREE_CODE (wholesize) == INTEGER_CST);\n+      gcc_checking_assert (types_compatible_p (TREE_TYPE (wholesize),\n+\t\t\t\t\t       sizetype));\n+\n+      /* Restructure SZ - OFFSET as\n+\t WHOLESIZE - (WHOLESIZE + OFFSET - SZ) so that the offset part, i.e.\n+\t WHOLESIZE + OFFSET - SZ is only allowed to be positive.  */\n+      tree tmp = size_binop (MAX_EXPR, wholesize, sz);\n+      offset = fold_build2 (PLUS_EXPR, sizetype, tmp, offset);\n+      offset = fold_build2 (MINUS_EXPR, sizetype, offset, sz);\n+      sz = tmp;\n+    }\n+\n+  /* Safe to convert now, since a valid net offset should be non-negative.  */\n+  if (!types_compatible_p (TREE_TYPE (offset), sizetype))\n+    fold_convert (sizetype, offset);\n+\n+  if (integer_zerop (offset))\n+    return sz;\n+\n+  /* Negative or too large offset even after adjustment, cannot be within\n+     bounds of an object.  */\n+  if (compare_tree_int (offset, offset_limit) > 0)\n+    return size_zero_node;\n+\n+  return size_binop (MINUS_EXPR, size_binop (MAX_EXPR, sz, offset), offset);\n+}\n \n /* Compute offset of EXPR within VAR.  Return error_mark_node\n    if unknown.  */\n@@ -274,19 +369,22 @@ decl_init_size (tree decl, bool min)\n \n /* Compute __builtin_object_size for PTR, which is a ADDR_EXPR.\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n-   If unknown, return unknown (object_size_type).  */\n+   If unknown, return size_unknown (object_size_type).  */\n \n static bool\n addr_object_size (struct object_size_info *osi, const_tree ptr,\n-\t\t  int object_size_type, unsigned HOST_WIDE_INT *psize)\n+\t\t  int object_size_type, tree *psize, tree *pwholesize)\n {\n-  tree pt_var, pt_var_size = NULL_TREE, var_size, bytes;\n+  tree pt_var, pt_var_size = NULL_TREE, pt_var_wholesize = NULL_TREE;\n+  tree var_size, bytes, wholebytes;\n \n   gcc_assert (TREE_CODE (ptr) == ADDR_EXPR);\n \n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n-  *psize = unknown (object_size_type);\n+  *psize = size_unknown (object_size_type);\n+  if (pwholesize)\n+    *pwholesize = size_unknown (object_size_type);\n \n   pt_var = TREE_OPERAND (ptr, 0);\n   while (handled_component_p (pt_var))\n@@ -297,13 +395,14 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \n   if (TREE_CODE (pt_var) == MEM_REF)\n     {\n-      unsigned HOST_WIDE_INT sz;\n+      tree sz, wholesize;\n \n       if (!osi || (object_size_type & OST_SUBOBJECT) != 0\n \t  || TREE_CODE (TREE_OPERAND (pt_var, 0)) != SSA_NAME)\n \t{\n \t  compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n \t\t\t\t       object_size_type & ~OST_SUBOBJECT, &sz);\n+\t  wholesize = sz;\n \t}\n       else\n \t{\n@@ -312,46 +411,47 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t    collect_object_sizes_for (osi, var);\n \t  if (bitmap_bit_p (computed[object_size_type],\n \t\t\t    SSA_NAME_VERSION (var)))\n-\t    sz = object_sizes_get (osi, SSA_NAME_VERSION (var));\n+\t    {\n+\t      sz = object_sizes_get (osi, SSA_NAME_VERSION (var));\n+\t      wholesize = object_sizes_get (osi, SSA_NAME_VERSION (var), true);\n+\t    }\n \t  else\n-\t    sz = unknown (object_size_type);\n+\t    sz = wholesize = size_unknown (object_size_type);\n \t}\n-      if (sz != unknown (object_size_type))\n+      if (!size_unknown_p (sz, object_size_type))\n \t{\n-\t  offset_int mem_offset;\n-\t  if (mem_ref_offset (pt_var).is_constant (&mem_offset))\n-\t    {\n-\t      offset_int dsz = wi::sub (sz, mem_offset);\n-\t      if (wi::neg_p (dsz))\n-\t\tsz = 0;\n-\t      else if (wi::fits_uhwi_p (dsz))\n-\t\tsz = dsz.to_uhwi ();\n-\t      else\n-\t\tsz = unknown (object_size_type);\n-\t    }\n+\t  tree offset = TREE_OPERAND (pt_var, 1);\n+\t  if (TREE_CODE (offset) != INTEGER_CST\n+\t      || TREE_CODE (sz) != INTEGER_CST)\n+\t    sz = wholesize = size_unknown (object_size_type);\n \t  else\n-\t    sz = unknown (object_size_type);\n+\t    sz = size_for_offset (sz, offset, wholesize);\n \t}\n \n-      if (sz != unknown (object_size_type) && sz < offset_limit)\n-\tpt_var_size = size_int (sz);\n+      if (!size_unknown_p (sz, object_size_type)\n+\t  && TREE_CODE (sz) == INTEGER_CST\n+\t  && compare_tree_int (sz, offset_limit) < 0)\n+\t{\n+\t  pt_var_size = sz;\n+\t  pt_var_wholesize = wholesize;\n+\t}\n     }\n   else if (DECL_P (pt_var))\n     {\n-      pt_var_size = decl_init_size (pt_var, object_size_type & OST_MINIMUM);\n+      pt_var_size = pt_var_wholesize\n+\t= decl_init_size (pt_var, object_size_type & OST_MINIMUM);\n       if (!pt_var_size)\n \treturn false;\n     }\n   else if (TREE_CODE (pt_var) == STRING_CST)\n-    pt_var_size = TYPE_SIZE_UNIT (TREE_TYPE (pt_var));\n+    pt_var_size = pt_var_wholesize = TYPE_SIZE_UNIT (TREE_TYPE (pt_var));\n   else\n     return false;\n \n   if (pt_var_size)\n     {\n       /* Validate the size determined above.  */\n-      if (!tree_fits_uhwi_p (pt_var_size)\n-\t  || tree_to_uhwi (pt_var_size) >= offset_limit)\n+      if (compare_tree_int (pt_var_size, offset_limit) >= 0)\n \treturn false;\n     }\n \n@@ -496,28 +596,35 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t      bytes = size_binop (MIN_EXPR, bytes, bytes2);\n \t    }\n \t}\n+\n+      wholebytes\n+\t= object_size_type & OST_SUBOBJECT ? var_size : pt_var_wholesize;\n     }\n   else if (!pt_var_size)\n     return false;\n   else\n-    bytes = pt_var_size;\n-\n-  if (tree_fits_uhwi_p (bytes))\n     {\n-      *psize = tree_to_uhwi (bytes);\n-      return true;\n+      bytes = pt_var_size;\n+      wholebytes = pt_var_wholesize;\n     }\n \n-  return false;\n+  if (TREE_CODE (bytes) != INTEGER_CST\n+      || TREE_CODE (wholebytes) != INTEGER_CST)\n+    return false;\n+\n+  *psize = bytes;\n+  if (pwholesize)\n+    *pwholesize = wholebytes;\n+  return true;\n }\n \n \n /* Compute __builtin_object_size for CALL, which is a GIMPLE_CALL.\n    Handles calls to functions declared with attribute alloc_size.\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n-   If unknown, return unknown (object_size_type).  */\n+   If unknown, return size_unknown (object_size_type).  */\n \n-static unsigned HOST_WIDE_INT\n+static tree\n alloc_object_size (const gcall *call, int object_size_type)\n {\n   gcc_assert (is_gimple_call (call));\n@@ -529,7 +636,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n     calltype = gimple_call_fntype (call);\n \n   if (!calltype)\n-    return unknown (object_size_type);\n+    return size_unknown (object_size_type);\n \n   /* Set to positions of alloc_size arguments.  */\n   int arg1 = -1, arg2 = -1;\n@@ -549,7 +656,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n       || (arg2 >= 0\n \t  && (arg2 >= (int)gimple_call_num_args (call)\n \t      || TREE_CODE (gimple_call_arg (call, arg2)) != INTEGER_CST)))\n-    return unknown (object_size_type);\n+    return size_unknown (object_size_type);\n \n   tree bytes = NULL_TREE;\n   if (arg2 >= 0)\n@@ -559,10 +666,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n   else if (arg1 >= 0)\n     bytes = fold_convert (sizetype, gimple_call_arg (call, arg1));\n \n-  if (bytes && tree_fits_uhwi_p (bytes))\n-    return tree_to_uhwi (bytes);\n-\n-  return unknown (object_size_type);\n+  return bytes;\n }\n \n \n@@ -598,13 +702,13 @@ pass_through_call (const gcall *call)\n \n bool\n compute_builtin_object_size (tree ptr, int object_size_type,\n-\t\t\t     unsigned HOST_WIDE_INT *psize)\n+\t\t\t     tree *psize)\n {\n   gcc_assert (object_size_type >= 0 && object_size_type < OST_END);\n \n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n-  *psize = unknown (object_size_type);\n+  *psize = size_unknown (object_size_type);\n \n   if (! offset_limit)\n     init_offset_limit ();\n@@ -638,8 +742,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t\t\t\t\t\t  psize))\n \t\t{\n \t\t  /* Return zero when the offset is out of bounds.  */\n-\t\t  unsigned HOST_WIDE_INT off = tree_to_shwi (offset);\n-\t\t  *psize = off < *psize ? *psize - off : 0;\n+\t\t  *psize = size_for_offset (*psize, offset);\n \t\t  return true;\n \t\t}\n \t    }\n@@ -747,12 +850,13 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t\tprint_generic_expr (dump_file, ssa_name (i),\n \t\t\t\t    dump_flags);\n \t\tfprintf (dump_file,\n-\t\t\t \": %s %sobject size \"\n-\t\t\t HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n+\t\t\t \": %s %sobject size \",\n \t\t\t ((object_size_type & OST_MINIMUM) ? \"minimum\"\n \t\t\t  : \"maximum\"),\n-\t\t\t (object_size_type & OST_SUBOBJECT) ? \"sub\" : \"\",\n-\t\t\t object_sizes_get (&osi, i));\n+\t\t\t (object_size_type & OST_SUBOBJECT) ? \"sub\" : \"\");\n+\t\tprint_generic_expr (dump_file, object_sizes_get (&osi, i),\n+\t\t\t\t    dump_flags);\n+\t\tfprintf (dump_file, \"\\n\");\n \t      }\n \t}\n \n@@ -761,7 +865,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n     }\n \n   *psize = object_sizes_get (&osi, SSA_NAME_VERSION (ptr));\n-  return *psize != unknown (object_size_type);\n+  return !size_unknown_p (*psize, object_size_type);\n }\n \n /* Compute object_sizes for PTR, defined to VALUE, which is not an SSA_NAME.  */\n@@ -771,7 +875,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n-  unsigned HOST_WIDE_INT bytes;\n+  tree bytes, wholesize;\n \n   gcc_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_assert (osi->pass == 0);\n@@ -784,11 +888,11 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n \t      || !POINTER_TYPE_P (TREE_TYPE (value)));\n \n   if (TREE_CODE (value) == ADDR_EXPR)\n-    addr_object_size (osi, value, object_size_type, &bytes);\n+    addr_object_size (osi, value, object_size_type, &bytes, &wholesize);\n   else\n-    bytes = unknown (object_size_type);\n+    bytes = wholesize = size_unknown (object_size_type);\n \n-  object_sizes_set (osi, varno, bytes);\n+  object_sizes_set (osi, varno, bytes, wholesize);\n }\n \n \n@@ -799,16 +903,14 @@ call_object_size (struct object_size_info *osi, tree ptr, gcall *call)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n-  unsigned HOST_WIDE_INT bytes;\n \n   gcc_assert (is_gimple_call (call));\n \n   gcc_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_assert (osi->pass == 0);\n+  tree bytes = alloc_object_size (call, object_size_type);\n \n-  bytes = alloc_object_size (call, object_size_type);\n-\n-  object_sizes_set (osi, varno, bytes);\n+  object_sizes_set (osi, varno, bytes, bytes);\n }\n \n \n@@ -822,39 +924,32 @@ unknown_object_size (struct object_size_info *osi, tree ptr)\n \n   gcc_checking_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_checking_assert (osi->pass == 0);\n+  tree bytes = size_unknown (object_size_type);\n \n-  object_sizes_set (osi, varno, unknown (object_size_type));\n+  object_sizes_set (osi, varno, bytes, bytes);\n }\n \n \n /* Merge object sizes of ORIG + OFFSET into DEST.  Return true if\n    the object size might need reexamination later.  */\n \n static bool\n-merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n-\t\t    unsigned HOST_WIDE_INT offset)\n+merge_object_sizes (struct object_size_info *osi, tree dest, tree orig)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (dest);\n-  unsigned HOST_WIDE_INT orig_bytes;\n+  tree orig_bytes, wholesize;\n \n   if (object_sizes_unknown_p (object_size_type, varno))\n     return false;\n-  if (offset >= offset_limit)\n-    {\n-      object_sizes_set (osi, varno, unknown (object_size_type));\n-      return false;\n-    }\n \n   if (osi->pass == 0)\n     collect_object_sizes_for (osi, orig);\n \n   orig_bytes = object_sizes_get (osi, SSA_NAME_VERSION (orig));\n-  if (orig_bytes != unknown (object_size_type))\n-    orig_bytes = (offset > orig_bytes)\n-\t\t ? HOST_WIDE_INT_0U : orig_bytes - offset;\n+  wholesize = object_sizes_get (osi, SSA_NAME_VERSION (orig), true);\n \n-  if (object_sizes_set (osi, varno, orig_bytes))\n+  if (object_sizes_set (osi, varno, orig_bytes, wholesize))\n     osi->changed = true;\n \n   return bitmap_bit_p (osi->reexamine, SSA_NAME_VERSION (orig));\n@@ -870,8 +965,9 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (var);\n-  unsigned HOST_WIDE_INT bytes;\n+  tree bytes, wholesize;\n   tree op0, op1;\n+  bool reexamine = false;\n \n   if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n     {\n@@ -896,31 +992,38 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n       && (TREE_CODE (op0) == SSA_NAME\n \t  || TREE_CODE (op0) == ADDR_EXPR))\n     {\n-      if (! tree_fits_uhwi_p (op1))\n-\tbytes = unknown (object_size_type);\n-      else if (TREE_CODE (op0) == SSA_NAME)\n-\treturn merge_object_sizes (osi, var, op0, tree_to_uhwi (op1));\n+      if (TREE_CODE (op0) == SSA_NAME)\n+\t{\n+\t  if (osi->pass == 0)\n+\t    collect_object_sizes_for (osi, op0);\n+\n+\t  bytes = object_sizes_get (osi, SSA_NAME_VERSION (op0));\n+\t  wholesize = object_sizes_get (osi, SSA_NAME_VERSION (op0), true);\n+\t  reexamine = bitmap_bit_p (osi->reexamine, SSA_NAME_VERSION (op0));\n+\t}\n       else\n \t{\n-\t  unsigned HOST_WIDE_INT off = tree_to_uhwi (op1);\n-\n-          /* op0 will be ADDR_EXPR here.  */\n-\t  addr_object_size (osi, op0, object_size_type, &bytes);\n-\t  if (bytes == unknown (object_size_type))\n-\t    ;\n-\t  else if (off > offset_limit)\n-\t    bytes = unknown (object_size_type);\n-\t  else if (off > bytes)\n-\t    bytes = 0;\n-\t  else\n-\t    bytes -= off;\n+\t  /* op0 will be ADDR_EXPR here.  We should never come here during\n+\t     reexamination.  */\n+\t  gcc_checking_assert (osi->pass == 0);\n+\t  addr_object_size (osi, op0, object_size_type, &bytes, &wholesize);\n \t}\n+\n+      /* In the first pass, do not compute size for offset if either the\n+\t maximum size is unknown or the minimum size is not initialized yet;\n+\t the latter indicates a dependency loop and will be resolved in\n+\t subsequent passes.  We attempt to compute offset for 0 minimum size\n+\t too because a negative offset could be within bounds of WHOLESIZE,\n+\t giving a non-zero result for VAR.  */\n+      if (osi->pass != 0 || !size_unknown_p (bytes, 0))\n+\tbytes = size_for_offset (bytes, op1, wholesize);\n     }\n   else\n-    bytes = unknown (object_size_type);\n+    bytes = wholesize = size_unknown (object_size_type);\n \n-  object_sizes_set (osi, varno, bytes);\n-  return false;\n+  if (object_sizes_set (osi, varno, bytes, wholesize))\n+    osi->changed = true;\n+  return reexamine;\n }\n \n \n@@ -945,15 +1048,15 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else_ = gimple_assign_rhs3 (stmt);\n \n   if (TREE_CODE (then_) == SSA_NAME)\n-    reexamine |= merge_object_sizes (osi, var, then_, 0);\n+    reexamine |= merge_object_sizes (osi, var, then_);\n   else\n     expr_object_size (osi, var, then_);\n \n   if (object_sizes_unknown_p (object_size_type, varno))\n     return reexamine;\n \n   if (TREE_CODE (else_) == SSA_NAME)\n-    reexamine |= merge_object_sizes (osi, var, else_, 0);\n+    reexamine |= merge_object_sizes (osi, var, else_);\n   else\n     expr_object_size (osi, var, else_);\n \n@@ -970,11 +1073,11 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n    object size is object size of the first operand minus the constant.\n    If the constant is bigger than the number of remaining bytes until the\n    end of the object, object size is 0, but if it is instead a pointer\n-   subtraction, object size is unknown (object_size_type).\n+   subtraction, object size is size_unknown (object_size_type).\n    To differentiate addition from subtraction, ADDR_EXPR returns\n-   unknown (object_size_type) for all objects bigger than half of the address\n-   space, and constants less than half of the address space are considered\n-   addition, while bigger constants subtraction.\n+   size_unknown (object_size_type) for all objects bigger than half of the\n+   address space, and constants less than half of the address space are\n+   considered addition, while bigger constants subtraction.\n    For a memcpy like GIMPLE_CALL that always returns one of its arguments, the\n    object size is object size of that argument.\n    Otherwise, object size is the maximum of object sizes of variables\n@@ -997,8 +1100,9 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t{\n \t  /* Initialize to 0 for maximum size and M1U for minimum size so that\n \t     it gets immediately overridden.  */\n-\t  object_sizes_set_force (osi, varno,\n-\t\t\t\t  unknown (object_size_type ^ OST_MINIMUM));\n+\t  object_sizes_initialize (osi, varno,\n+\t\t\t\t   size_initval (object_size_type),\n+\t\t\t\t   size_initval (object_size_type));\n \t}\n       else\n \t{\n@@ -1041,7 +1145,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n           {\n             if (TREE_CODE (rhs) == SSA_NAME\n                 && POINTER_TYPE_P (TREE_TYPE (rhs)))\n-              reexamine = merge_object_sizes (osi, var, rhs, 0);\n+\t      reexamine = merge_object_sizes (osi, var, rhs);\n             else\n               expr_object_size (osi, var, rhs);\n           }\n@@ -1058,7 +1162,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n           {\n             if (TREE_CODE (arg) == SSA_NAME\n                 && POINTER_TYPE_P (TREE_TYPE (arg)))\n-              reexamine = merge_object_sizes (osi, var, arg, 0);\n+\t      reexamine = merge_object_sizes (osi, var, arg);\n             else\n               expr_object_size (osi, var, arg);\n           }\n@@ -1069,7 +1173,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \n     case GIMPLE_ASM:\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n-      object_sizes_set (osi, varno, unknown (object_size_type));\n+      unknown_object_size (osi, var);\n       break;\n \n     case GIMPLE_NOP:\n@@ -1078,7 +1182,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \texpr_object_size (osi, var, SSA_NAME_VAR (var));\n       else\n \t/* Uninitialized SSA names point nowhere.  */\n-\tobject_sizes_set (osi, varno, unknown (object_size_type));\n+\tunknown_object_size (osi, var);\n       break;\n \n     case GIMPLE_PHI:\n@@ -1093,7 +1197,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t      break;\n \n \t    if (TREE_CODE (rhs) == SSA_NAME)\n-\t      reexamine |= merge_object_sizes (osi, var, rhs, 0);\n+\t      reexamine |= merge_object_sizes (osi, var, rhs);\n \t    else if (osi->pass == 0)\n \t      expr_object_size (osi, var, rhs);\n \t  }\n@@ -1144,7 +1248,8 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n \t      --sp;\n \t      bitmap_clear_bit (osi->reexamine, *sp);\n \t      bitmap_set_bit (computed[osi->object_size_type], *sp);\n-\t      object_sizes_set_force (osi, *sp, 0);\n+\t      object_sizes_set (osi, *sp, size_zero_node,\n+\t\t\t\tobject_sizes_get (osi, *sp, true));\n \t      if (*sp == varno)\n \t\tbreak;\n \t    }\n@@ -1244,7 +1349,8 @@ check_for_plus_in_loops (struct object_size_info *osi, tree var)\n \n       gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n \n-      if (integer_zerop (cst))\n+      /* Skip non-positive offsets.  */\n+      if (integer_zerop (cst) || compare_tree_int (cst, offset_limit) > 0)\n         return;\n \n       osi->depths[SSA_NAME_VERSION (basevar)] = 1;\n@@ -1335,17 +1441,17 @@ object_sizes_execute (function *fun, bool insert_min_max_p)\n \t\t\t  || TREE_CODE (ptr) == SSA_NAME))\n \t\t    {\n \t\t      tree type = TREE_TYPE (lhs);\n-\t\t      unsigned HOST_WIDE_INT bytes;\n+\t\t      tree bytes;\n \t\t      if (compute_builtin_object_size (ptr, object_size_type,\n \t\t\t\t\t\t       &bytes)\n-\t\t\t  && wi::fits_to_tree_p (bytes, type))\n+\t\t\t  && int_fits_type_p (bytes, type))\n \t\t\t{\n \t\t\t  tree tem = make_ssa_name (type);\n \t\t\t  gimple_call_set_lhs (call, tem);\n \t\t\t  enum tree_code code\n \t\t\t    = (object_size_type & OST_MINIMUM\n \t\t\t       ? MAX_EXPR : MIN_EXPR);\n-\t\t\t  tree cst = build_int_cstu (type, bytes);\n+\t\t\t  tree cst = fold_convert (type, bytes);\n \t\t\t  gimple *g\n \t\t\t    = gimple_build_assign (lhs, code, tem, cst);\n \t\t\t  gsi_insert_after (&i, g, GSI_NEW_STMT);"}, {"sha": "b2d6a58324cbd4b19daf4ce769006131b8d5fece", "filename": "gcc/tree-object-size.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftree-object-size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Ftree-object-size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.h?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void init_object_sizes (void);\n extern void fini_object_sizes (void);\n-extern bool compute_builtin_object_size (tree, int, unsigned HOST_WIDE_INT *);\n+extern bool compute_builtin_object_size (tree, int, tree *);\n extern tree decl_init_size (tree, bool);\n \n #endif  // GCC_TREE_OBJECT_SIZE_H"}, {"sha": "364cf174bf0aa4921feb42613aeedd6f54fe9199", "filename": "gcc/ubsan.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=422f9eb7011b76c12ff00ffaee2bcc9cdddf16d5", "patch": "@@ -2160,9 +2160,8 @@ instrument_object_size (gimple_stmt_iterator *gsi, tree t, bool is_lhs)\n   if (decl_p)\n     base_addr = build1 (ADDR_EXPR,\n \t\t\tbuild_pointer_type (TREE_TYPE (base)), base);\n-  unsigned HOST_WIDE_INT size;\n-  if (compute_builtin_object_size (base_addr, 0, &size))\n-    sizet = build_int_cst (sizetype, size);\n+  if (compute_builtin_object_size (base_addr, 0, &sizet))\n+    ;\n   else if (optimize)\n     {\n       if (LOCATION_LOCUS (loc) == UNKNOWN_LOCATION)"}]}