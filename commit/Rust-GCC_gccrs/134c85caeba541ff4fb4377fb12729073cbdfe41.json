{"sha": "134c85caeba541ff4fb4377fb12729073cbdfe41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM0Yzg1Y2FlYmE1NDFmZjRmYjQzNzdmYjEyNzI5MDczY2JkZmU0MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-07-06T08:13:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-07-06T08:13:49Z"}, "message": "[4/7] Add a gather_scatter_info structure\n\nThis patch just refactors the gather/scatter support so that all\ninformation is in a single structure, rather than separate variables.\nThis reduces the number of arguments to a function added in patch 6.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vectorizer.h (gather_scatter_info): New structure.\n\t(vect_check_gather_scatter): Return a bool rather than a decl.\n\tReplace return-by-pointer arguments with a single\n\tgather_scatter_info *.\n\t* tree-vect-data-refs.c (vect_check_gather_scatter): Likewise.\n\t(vect_analyze_data_refs): Update call accordingly.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n\t(vectorizable_mask_load_store): Likewise.  Also record the\n\toffset dt and vectype in the gather_scatter_info.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r238036", "tree": {"sha": "a217ca5a0f098d0bb1ddba69195d254a7b18c348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a217ca5a0f098d0bb1ddba69195d254a7b18c348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/134c85caeba541ff4fb4377fb12729073cbdfe41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134c85caeba541ff4fb4377fb12729073cbdfe41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134c85caeba541ff4fb4377fb12729073cbdfe41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134c85caeba541ff4fb4377fb12729073cbdfe41/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "071e8018fe67cabb165255ac88a165b80fadbcc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071e8018fe67cabb165255ac88a165b80fadbcc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/071e8018fe67cabb165255ac88a165b80fadbcc7"}], "stats": {"total": 193, "additions": 110, "deletions": 83}, "files": [{"sha": "e911b16a62808a8e2107e8d2112dd2ddee7a734e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=134c85caeba541ff4fb4377fb12729073cbdfe41", "patch": "@@ -1,3 +1,17 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (gather_scatter_info): New structure.\n+\t(vect_check_gather_scatter): Return a bool rather than a decl.\n+\tReplace return-by-pointer arguments with a single\n+\tgather_scatter_info *.\n+\t* tree-vect-data-refs.c (vect_check_gather_scatter): Likewise.\n+\t(vect_analyze_data_refs): Update call accordingly.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vectorizable_mask_load_store): Likewise.  Also record the\n+\toffset dt and vectype in the gather_scatter_info.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\n 2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vect_model_store_cost): For non-SLP"}, {"sha": "71155c9228bbdf72dc0333f9c5f891dd3265e257", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=134c85caeba541ff4fb4377fb12729073cbdfe41", "patch": "@@ -3187,12 +3187,12 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   return true;\n }\n \n-/* Check whether a non-affine read or write in stmt is suitable for gather load\n-   or scatter store and if so, return a builtin decl for that operation.  */\n+/* Return true if a non-affine read or write in STMT is suitable for a\n+   gather load or scatter store.  Describe the operation in *INFO if so.  */\n \n-tree\n-vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n-\t\t\t   tree *offp, int *scalep)\n+bool\n+vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n+\t\t\t   gather_scatter_info *info)\n {\n   HOST_WIDE_INT scale = 1, pbitpos, pbitsize;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -3266,7 +3266,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n   if (!expr_invariant_in_loop_p (loop, base))\n     {\n       if (!integer_zerop (off))\n-\treturn NULL_TREE;\n+\treturn false;\n       off = base;\n       base = size_int (pbitpos / BITS_PER_UNIT);\n     }\n@@ -3292,7 +3292,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (off);\n \n \t  if (expr_invariant_in_loop_p (loop, off))\n-\t    return NULL_TREE;\n+\t    return false;\n \n \t  if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n \t    break;\n@@ -3304,7 +3304,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n       else\n \t{\n \t  if (get_gimple_rhs_class (TREE_CODE (off)) == GIMPLE_TERNARY_RHS)\n-\t    return NULL_TREE;\n+\t    return false;\n \t  code = TREE_CODE (off);\n \t  extract_ops_from_tree (off, &code, &op0, &op1);\n \t}\n@@ -3379,7 +3379,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n      defined in the loop, punt.  */\n   if (TREE_CODE (off) != SSA_NAME\n       || expr_invariant_in_loop_p (loop, off))\n-    return NULL_TREE;\n+    return false;\n \n   if (offtype == NULL_TREE)\n     offtype = TREE_TYPE (off);\n@@ -3392,15 +3392,15 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n \t\t\t\t\t      offtype, scale);\n \n   if (decl == NULL_TREE)\n-    return NULL_TREE;\n-\n-  if (basep)\n-    *basep = base;\n-  if (offp)\n-    *offp = off;\n-  if (scalep)\n-    *scalep = scale;\n-  return decl;\n+    return false;\n+\n+  info->decl = decl;\n+  info->base = base;\n+  info->offset = off;\n+  info->offset_dt = vect_unknown_def_type;\n+  info->offset_vectype = NULL_TREE;\n+  info->scale = scale;\n+  return true;\n }\n \n /* Function vect_analyze_data_refs.\n@@ -3878,10 +3878,10 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \n       if (gatherscatter != SG_NONE)\n \t{\n-\t  tree off;\n+\t  gather_scatter_info gs_info;\n \t  if (!vect_check_gather_scatter (stmt, as_a <loop_vec_info> (vinfo),\n-\t\t\t\t\t  NULL, &off, NULL)\n-\t      || get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n+\t\t\t\t\t  &gs_info)\n+\t      || !get_vectype_for_scalar_type (TREE_TYPE (gs_info.offset)))\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n \t      free_data_ref (dr);"}, {"sha": "1a616b2428ebef15df85613912d07893f3eb962f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=134c85caeba541ff4fb4377fb12729073cbdfe41", "patch": "@@ -772,10 +772,11 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n       if (STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo))\n \t{\n-\t  tree off;\n-\t  tree decl = vect_check_gather_scatter (stmt, loop_vinfo, NULL, &off, NULL);\n-\t  gcc_assert (decl);\n-\t  if (!process_use (stmt, off, loop_vinfo, relevant, &worklist, true))\n+\t  gather_scatter_info gs_info;\n+\t  if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n+\t    gcc_unreachable ();\n+\t  if (!process_use (stmt, gs_info.offset, loop_vinfo, relevant,\n+\t\t\t    &worklist, true))\n \t    return false;\n \t}\n     } /* while worklist */\n@@ -1703,10 +1704,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   int ncopies;\n   int i, j;\n   bool inv_p;\n-  tree gather_base = NULL_TREE, gather_off = NULL_TREE;\n-  tree gather_off_vectype = NULL_TREE, gather_decl = NULL_TREE;\n-  int gather_scale = 1;\n-  enum vect_def_type gather_dt = vect_unknown_def_type;\n+  gather_scatter_info gs_info;\n   bool is_store;\n   tree mask;\n   gimple *def_stmt;\n@@ -1774,19 +1772,18 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n-\t\t\t\t       &gather_off, &gather_scale);\n-      gcc_assert (gather_decl);\n-      if (!vect_is_simple_use (gather_off, loop_vinfo, &def_stmt, &gather_dt,\n-\t\t\t       &gather_off_vectype))\n+      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n+\tgcc_unreachable ();\n+      if (!vect_is_simple_use (gs_info.offset, loop_vinfo, &def_stmt,\n+\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"gather index use not simple.\");\n \t  return false;\n \t}\n \n-      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gather_decl));\n+      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree masktype\n \t= TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n       if (TREE_CODE (masktype) == INTEGER_TYPE)\n@@ -1825,7 +1822,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n-      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gather_decl));\n+      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree rettype, srctype, ptrtype, idxtype, masktype, scaletype;\n       tree ptr, vec_mask = NULL_TREE, mask_op = NULL_TREE, var, scale;\n       tree perm_mask = NULL_TREE, prev_res = NULL_TREE;\n@@ -1834,9 +1831,9 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n       gimple_seq seq;\n       basic_block new_bb;\n       enum { NARROW, NONE, WIDEN } modifier;\n-      int gather_off_nunits = TYPE_VECTOR_SUBPARTS (gather_off_vectype);\n+      int gather_off_nunits = TYPE_VECTOR_SUBPARTS (gs_info.offset_vectype);\n \n-      rettype = TREE_TYPE (TREE_TYPE (gather_decl));\n+      rettype = TREE_TYPE (TREE_TYPE (gs_info.decl));\n       srctype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       ptrtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       idxtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n@@ -1855,7 +1852,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  for (i = 0; i < gather_off_nunits; ++i)\n \t    sel[i] = i | nunits;\n \n-\t  perm_mask = vect_gen_perm_mask_checked (gather_off_vectype, sel);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n@@ -1877,15 +1874,15 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       vec_dest = vect_create_destination_var (gimple_call_lhs (stmt), vectype);\n \n-      ptr = fold_convert (ptrtype, gather_base);\n+      ptr = fold_convert (ptrtype, gs_info.base);\n       if (!is_gimple_min_invariant (ptr))\n \t{\n \t  ptr = force_gimple_operand (ptr, &seq, true, NULL_TREE);\n \t  new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n \t  gcc_assert (!new_bb);\n \t}\n \n-      scale = build_int_cst (scaletype, gather_scale);\n+      scale = build_int_cst (scaletype, gs_info.scale);\n \n       prev_stmt_info = NULL;\n       for (j = 0; j < ncopies; ++j)\n@@ -1895,10 +1892,10 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t       perm_mask, stmt, gsi);\n \t  else if (j == 0)\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_operand (gather_off, stmt);\n+\t      = vect_get_vec_def_for_operand (gs_info.offset, stmt);\n \t  else\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_stmt_copy (gather_dt, vec_oprnd0);\n+\t      = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt, vec_oprnd0);\n \n \t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t    {\n@@ -1940,7 +1937,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \n \t  new_stmt\n-\t    = gimple_build_call (gather_decl, 5, mask_op, ptr, op, mask_op,\n+\t    = gimple_build_call (gs_info.decl, 5, mask_op, ptr, op, mask_op,\n \t\t\t\t scale);\n \n \t  if (!useless_type_conversion_p (vectype, rettype))\n@@ -5207,10 +5204,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n   tree aggr_type;\n-  tree scatter_base = NULL_TREE, scatter_off = NULL_TREE;\n-  tree scatter_off_vectype = NULL_TREE, scatter_decl = NULL_TREE;\n-  int scatter_scale = 1;\n-  enum vect_def_type scatter_idx_dt = vect_unknown_def_type;\n+  gather_scatter_info gs_info;\n   enum vect_def_type scatter_src_dt = vect_unknown_def_type;\n   gimple *new_stmt;\n   int vf;\n@@ -5374,11 +5368,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      scatter_decl = vect_check_gather_scatter (stmt, loop_vinfo, &scatter_base,\n-\t\t\t\t\t\t&scatter_off, &scatter_scale);\n-      gcc_assert (scatter_decl);\n-      if (!vect_is_simple_use (scatter_off, vinfo, &def_stmt, &scatter_idx_dt,\n-\t\t\t       &scatter_off_vectype))\n+      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n+\tgcc_unreachable ();\n+      if (!vect_is_simple_use (gs_info.offset, vinfo, &def_stmt,\n+\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5404,14 +5397,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE, op, src;\n-      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (scatter_decl));\n+      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree rettype, srctype, ptrtype, idxtype, masktype, scaletype;\n       tree ptr, mask, var, scale, perm_mask = NULL_TREE;\n       edge pe = loop_preheader_edge (loop);\n       gimple_seq seq;\n       basic_block new_bb;\n       enum { NARROW, NONE, WIDEN } modifier;\n-      int scatter_off_nunits = TYPE_VECTOR_SUBPARTS (scatter_off_vectype);\n+      int scatter_off_nunits = TYPE_VECTOR_SUBPARTS (gs_info.offset_vectype);\n \n       if (nunits == (unsigned int) scatter_off_nunits)\n \tmodifier = NONE;\n@@ -5423,7 +5416,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < (unsigned int) scatter_off_nunits; ++i)\n \t    sel[i] = i | nunits;\n \n-\t  perm_mask = vect_gen_perm_mask_checked (scatter_off_vectype, sel);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t}\n       else if (nunits == (unsigned int) scatter_off_nunits * 2)\n@@ -5441,7 +5434,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       else\n \tgcc_unreachable ();\n \n-      rettype = TREE_TYPE (TREE_TYPE (scatter_decl));\n+      rettype = TREE_TYPE (TREE_TYPE (gs_info.decl));\n       ptrtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       masktype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       idxtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n@@ -5451,7 +5444,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       gcc_checking_assert (TREE_CODE (masktype) == INTEGER_TYPE\n \t\t\t   && TREE_CODE (rettype) == VOID_TYPE);\n \n-      ptr = fold_convert (ptrtype, scatter_base);\n+      ptr = fold_convert (ptrtype, gs_info.base);\n       if (!is_gimple_min_invariant (ptr))\n \t{\n \t  ptr = force_gimple_operand (ptr, &seq, true, NULL_TREE);\n@@ -5464,7 +5457,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       mask = build_int_cst (masktype, -1);\n       mask = vect_init_vector (stmt, mask, masktype, NULL);\n \n-      scale = build_int_cst (scaletype, scatter_scale);\n+      scale = build_int_cst (scaletype, gs_info.scale);\n \n       prev_stmt_info = NULL;\n       for (j = 0; j < ncopies; ++j)\n@@ -5474,7 +5467,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      src = vec_oprnd1\n \t\t= vect_get_vec_def_for_operand (gimple_assign_rhs1 (stmt), stmt);\n \t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_operand (scatter_off, stmt);\n+\t\t= vect_get_vec_def_for_operand (gs_info.offset, stmt);\n \t    }\n \t  else if (modifier != NONE && (j & 1))\n \t    {\n@@ -5490,7 +5483,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  src = permute_vec_elements (vec_oprnd1, vec_oprnd1, perm_mask,\n \t\t\t\t\t      stmt, gsi);\n \t\t  op = vec_oprnd0\n-\t\t    = vect_get_vec_def_for_stmt_copy (scatter_idx_dt, vec_oprnd0);\n+\t\t    = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n+\t\t\t\t\t\t      vec_oprnd0);\n \t\t}\n \t      else\n \t\tgcc_unreachable ();\n@@ -5500,7 +5494,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      src = vec_oprnd1\n \t\t= vect_get_vec_def_for_stmt_copy (scatter_src_dt, vec_oprnd1);\n \t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_stmt_copy (scatter_idx_dt, vec_oprnd0);\n+\t\t= vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n+\t\t\t\t\t\t  vec_oprnd0);\n \t    }\n \n \t  if (!useless_type_conversion_p (srctype, TREE_TYPE (src)))\n@@ -5526,7 +5521,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \n \t  new_stmt\n-\t    = gimple_build_call (scatter_decl, 5, ptr, mask, op, src, scale);\n+\t    = gimple_build_call (gs_info.decl, 5, ptr, mask, op, src, scale);\n \n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n@@ -6221,10 +6216,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n   tree aggr_type;\n-  tree gather_base = NULL_TREE, gather_off = NULL_TREE;\n-  tree gather_off_vectype = NULL_TREE, gather_decl = NULL_TREE;\n-  int gather_scale = 1;\n-  enum vect_def_type gather_dt = vect_unknown_def_type;\n+  gather_scatter_info gs_info;\n   vec_info *vinfo = stmt_info->vinfo;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n@@ -6421,11 +6413,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple *def_stmt;\n-      gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n-\t\t\t\t\t       &gather_off, &gather_scale);\n-      gcc_assert (gather_decl);\n-      if (!vect_is_simple_use (gather_off, vinfo, &def_stmt, &gather_dt,\n-\t\t\t       &gather_off_vectype))\n+      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n+\tgcc_unreachable ();\n+      if (!vect_is_simple_use (gs_info.offset, vinfo, &def_stmt,\n+\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6500,14 +6491,14 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n-      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gather_decl));\n+      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree rettype, srctype, ptrtype, idxtype, masktype, scaletype;\n       tree ptr, mask, var, scale, merge, perm_mask = NULL_TREE, prev_res = NULL_TREE;\n       edge pe = loop_preheader_edge (loop);\n       gimple_seq seq;\n       basic_block new_bb;\n       enum { NARROW, NONE, WIDEN } modifier;\n-      int gather_off_nunits = TYPE_VECTOR_SUBPARTS (gather_off_vectype);\n+      int gather_off_nunits = TYPE_VECTOR_SUBPARTS (gs_info.offset_vectype);\n \n       if (nunits == gather_off_nunits)\n \tmodifier = NONE;\n@@ -6519,7 +6510,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < gather_off_nunits; ++i)\n \t    sel[i] = i | nunits;\n \n-\t  perm_mask = vect_gen_perm_mask_checked (gather_off_vectype, sel);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n@@ -6536,7 +6527,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       else\n \tgcc_unreachable ();\n \n-      rettype = TREE_TYPE (TREE_TYPE (gather_decl));\n+      rettype = TREE_TYPE (TREE_TYPE (gs_info.decl));\n       srctype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       ptrtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n       idxtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n@@ -6546,7 +6537,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-      ptr = fold_convert (ptrtype, gather_base);\n+      ptr = fold_convert (ptrtype, gs_info.base);\n       if (!is_gimple_min_invariant (ptr))\n \t{\n \t  ptr = force_gimple_operand (ptr, &seq, true, NULL_TREE);\n@@ -6578,7 +6569,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       else\n \tgcc_unreachable ();\n \n-      scale = build_int_cst (scaletype, gather_scale);\n+      scale = build_int_cst (scaletype, gs_info.scale);\n \n       if (TREE_CODE (TREE_TYPE (rettype)) == INTEGER_TYPE)\n \tmerge = build_int_cst (TREE_TYPE (rettype), 0);\n@@ -6604,10 +6595,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t       perm_mask, stmt, gsi);\n \t  else if (j == 0)\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_operand (gather_off, stmt);\n+\t      = vect_get_vec_def_for_operand (gs_info.offset, stmt);\n \t  else\n \t    op = vec_oprnd0\n-\t      = vect_get_vec_def_for_stmt_copy (gather_dt, vec_oprnd0);\n+\t      = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt, vec_oprnd0);\n \n \t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t    {\n@@ -6622,7 +6613,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \n \t  new_stmt\n-\t    = gimple_build_call (gather_decl, 5, merge, ptr, op, mask, scale);\n+\t    = gimple_build_call (gs_info.decl, 5, merge, ptr, op, mask, scale);\n \n \t  if (!useless_type_conversion_p (vectype, rettype))\n \t    {"}, {"sha": "180b3061c2c8a965d514bf52808e42a47231347f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134c85caeba541ff4fb4377fb12729073cbdfe41/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=134c85caeba541ff4fb4377fb12729073cbdfe41", "patch": "@@ -608,6 +608,28 @@ typedef struct _stmt_vec_info {\n   unsigned int num_slp_uses;\n } *stmt_vec_info;\n \n+/* Information about a gather/scatter call.  */\n+struct gather_scatter_info {\n+  /* The FUNCTION_DECL for the built-in gather/scatter function.  */\n+  tree decl;\n+\n+  /* The loop-invariant base value.  */\n+  tree base;\n+\n+  /* The original scalar offset, which is a non-loop-invariant SSA_NAME.  */\n+  tree offset;\n+\n+  /* Each offset element should be multiplied by this amount before\n+     being added to the base.  */\n+  int scale;\n+\n+  /* The definition type for the vectorized offset.  */\n+  enum vect_def_type offset_dt;\n+\n+  /* The type of the vectorized offset.  */\n+  tree offset_vectype;\n+};\n+\n /* Access Functions.  */\n #define STMT_VINFO_TYPE(S)                 (S)->type\n #define STMT_VINFO_STMT(S)                 (S)->stmt\n@@ -1031,8 +1053,8 @@ extern bool vect_verify_datarefs_alignment (loop_vec_info);\n extern bool vect_slp_analyze_and_verify_instance_alignment (slp_instance);\n extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n-extern tree vect_check_gather_scatter (gimple *, loop_vec_info, tree *, tree *,\n-\t\t\t\t       int *);\n+extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n+\t\t\t\t       gather_scatter_info *);\n extern bool vect_analyze_data_refs (vec_info *, int *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,"}]}