{"sha": "f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1ZWJlNzc5ZjU0NmM5ZTljOGE2NmM1NmMwNGViZjVmZTFiN2RkYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-01-27T22:08:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-01-27T22:08:02Z"}, "message": "re PR rtl-optimization/69447 (wrong code with -O2 -fno-schedule-insns and mixed 8/16/32/64bit arithmetics @ armv7a)\n\nPR rtl-opt/69447\n\n  * lra-remat.c (subreg_regs): New.\n  (dump_candidates_and_remat_bb_data): Dump it.\n  (operand_to_remat): Reject if operand in subreg_regs.\n  (set_bb_regs): Collect subreg_regs.\n  (lra_remat): Init and free subreg_regs.  Compute\n  calculate_local_reg_remat_bb_data before create_cands.\n\nFrom-SVN: r232905", "tree": {"sha": "b73d554ab53c509b4cfa2110e4372821e41583a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b73d554ab53c509b4cfa2110e4372821e41583a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/comments", "author": null, "committer": null, "parents": [{"sha": "49847d759f449f0b299fae28932e996037338f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49847d759f449f0b299fae28932e996037338f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49847d759f449f0b299fae28932e996037338f88"}], "stats": {"total": 119, "additions": 85, "deletions": 34}, "files": [{"sha": "41075467555d5cdd44645c7b8e22ba366aae0ac2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "patch": "@@ -1,3 +1,13 @@\n+2016-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/69447\n+\t* lra-remat.c (subreg_regs): New.\n+\t(dump_candidates_and_remat_bb_data): Dump it.\n+\t(operand_to_remat): Reject if operand in subreg_regs.\n+\t(set_bb_regs): Collect subreg_regs.\n+\t(lra_remat): Init and free subreg_regs.  Compute\n+\tcalculate_local_reg_remat_bb_data before create_cands.\n+\n 2016-01-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/68986"}, {"sha": "4d8099fcd8e1a6ca6d8643c195c12bc3583ead43", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "patch": "@@ -77,6 +77,9 @@ static int call_used_regs_arr[FIRST_PSEUDO_REGISTER];\n /* Bitmap used for different calculations.  */\n static bitmap_head temp_bitmap;\n \n+/* Registers accessed via subreg_p.  */\n+static bitmap_head subreg_regs;\n+\n typedef struct cand *cand_t;\n typedef const struct cand *const_cand_t;\n \n@@ -383,30 +386,30 @@ operand_to_remat (rtx_insn *insn)\n     return -1;\n   /* First find a pseudo which can be rematerialized.  */\n   for (reg = id->regs; reg != NULL; reg = reg->next)\n-    /* True FRAME_POINTER_NEEDED might be because we can not follow\n-       changing sp offsets, e.g. alloca is used.  If the insn contains\n-       stack pointer in such case, we can not rematerialize it as we\n-       can not know sp offset at a rematerialization place.  */\n-    if (reg->regno == STACK_POINTER_REGNUM && frame_pointer_needed)\n-      return -1;\n-    else if (reg->type == OP_OUT && ! reg->subreg_p\n-\t     && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)\n-      {\n-\t/* We permits only one spilled reg.  */\n-\tif (found_reg != NULL)\n-\t  return -1;\n-\tfound_reg = reg;\n-      }\n-    /* IRA calculates conflicts separately for subregs of two words\n-       pseudo.  Even if the pseudo lives, e.g. one its subreg can be\n-       used lately, another subreg hard register can be already used\n-       for something else.  In such case, it is not safe to\n-       rematerialize the insn.  */\n-    else if (reg->type == OP_IN && reg->subreg_p\n-\t     && reg->regno >= FIRST_PSEUDO_REGISTER\n-\t     && (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno))\n-\t\t == 2 * UNITS_PER_WORD))\n-      return -1;\n+    {\n+      /* True FRAME_POINTER_NEEDED might be because we can not follow\n+\t changing sp offsets, e.g. alloca is used.  If the insn contains\n+\t stack pointer in such case, we can not rematerialize it as we\n+\t can not know sp offset at a rematerialization place.  */\n+      if (reg->regno == STACK_POINTER_REGNUM && frame_pointer_needed)\n+\treturn -1;\n+      else if (reg->type == OP_OUT && ! reg->subreg_p\n+\t       && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)\n+\t{\n+\t  /* We permits only one spilled reg.  */\n+\t  if (found_reg != NULL)\n+\t    return -1;\n+\t  found_reg = reg;\n+        }\n+      /* IRA calculates conflicts separately for subregs of two words\n+\t pseudo.  Even if the pseudo lives, e.g. one its subreg can be\n+\t used lately, another subreg hard register can be already used\n+\t for something else.  In such case, it is not safe to\n+\t rematerialize the insn.  */\n+      if (reg->regno >= FIRST_PSEUDO_REGISTER\n+\t  && bitmap_bit_p (&subreg_regs, reg->regno))\n+\treturn -1;\n+    }\n   if (found_reg == NULL)\n     return -1;\n   if (found_reg->regno < FIRST_PSEUDO_REGISTER)\n@@ -631,6 +634,9 @@ dump_candidates_and_remat_bb_data (void)\n       lra_dump_bitmap_with_title (\"avout cands in BB\",\n \t\t\t\t  &get_remat_bb_data (bb)->avout_cands, bb->index);\n     }\n+  fprintf (lra_dump_file, \"subreg regs:\");\n+  dump_regset (&subreg_regs, lra_dump_file);\n+  putc ('\\n', lra_dump_file);\n }\n \n /* Free all BB data.  */\n@@ -655,21 +661,24 @@ finish_remat_bb_data (void)\n \n \f\n \n-/* Update changed_regs and dead_regs of BB from INSN.  */\n+/* Update changed_regs, dead_regs, subreg_regs of BB from INSN.  */\n static void\n set_bb_regs (basic_block bb, rtx_insn *insn)\n {\n   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  remat_bb_data_t bb_info = get_remat_bb_data (bb);\n   struct lra_insn_reg *reg;\n \n   for (reg = id->regs; reg != NULL; reg = reg->next)\n-    if (reg->type != OP_IN)\n-      bitmap_set_bit (&get_remat_bb_data (bb)->changed_regs, reg->regno);\n-    else\n-      {\n-\tif (find_regno_note (insn, REG_DEAD, (unsigned) reg->regno) != NULL)\n-\t  bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs, reg->regno);\n-      }\n+    {\n+      unsigned regno = reg->regno;\n+      if (reg->type != OP_IN)\n+        bitmap_set_bit (&bb_info->changed_regs, regno);\n+      else if (find_regno_note (insn, REG_DEAD, regno) != NULL)\n+\tbitmap_set_bit (&bb_info->dead_regs, regno);\n+      if (regno >= FIRST_PSEUDO_REGISTER && reg->subreg_p)\n+\tbitmap_set_bit (&subreg_regs, regno);\n+    }\n   if (CALL_P (insn))\n     for (int i = 0; i < call_used_regs_arr_len; i++)\n       bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs,\n@@ -1284,10 +1293,11 @@ lra_remat (void)\n     if (call_used_regs[i])\n       call_used_regs_arr[call_used_regs_arr_len++] = i;\n   initiate_cand_table ();\n-  create_cands ();\n   create_remat_bb_data ();\n   bitmap_initialize (&temp_bitmap, &reg_obstack);\n+  bitmap_initialize (&subreg_regs, &reg_obstack);\n   calculate_local_reg_remat_bb_data ();\n+  create_cands ();\n   calculate_livein_cands ();\n   calculate_gen_cands ();\n   bitmap_initialize (&all_blocks, &reg_obstack);\n@@ -1298,6 +1308,7 @@ lra_remat (void)\n   result = do_remat ();\n   all_cands.release ();\n   bitmap_clear (&temp_bitmap);\n+  bitmap_clear (&subreg_regs);\n   finish_remat_bb_data ();\n   finish_cand_table ();\n   bitmap_clear (&all_blocks);"}, {"sha": "22c65a7d11706d71d79fe7b1a85ad68d2c4d7d3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "patch": "@@ -1,4 +1,8 @@\n-2015-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+2016-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.c-torture/execute/pr69447.c: New test.\n+\n+2016-01-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69385\n \t* gfortran.dg/alloc_comp_assign_15.f03: New test."}, {"sha": "b6d8591f6d677dd46f4726850bd7261be53ed069", "filename": "gcc/testsuite/gcc.c-torture/execute/pr69447.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr69447.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr69447.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr69447.c?ref=f75ebe779f546c9e9c8a66c56c04ebf5fe1b7dda", "patch": "@@ -0,0 +1,26 @@\n+typedef unsigned char u8;\n+typedef unsigned short u16;\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+\n+u64 __attribute__((noinline, noclone))\n+foo(u8 u8_0, u16 u16_0, u64 u64_0, u8 u8_1, u16 u16_1, u64 u64_1, u64 u64_2, u8 u8_3, u64 u64_3)\n+{\n+\tu64_1 *= 0x7730;\n+\tu64_3 *= u64_3;\n+\tu16_1 |= u64_3;\n+\tu64_3 -= 2;\n+\tu8_3 /= u64_2;\n+\tu8_0 |= 3;\n+\tu64_3 %= u8_0;\n+\tu8_0 -= 1;\n+\treturn u8_0 + u16_0 + u64_0 + u8_1 + u16_1 + u64_1 + u8_3 + u64_3;\n+}\n+\n+int main()\n+{\n+\tunsigned x = foo(1, 1, 1, 1, 1, 1, 1, 1, 1);\n+\tif (x != 0x7737)\n+\t\t__builtin_abort();\n+\treturn 0;\n+}"}]}