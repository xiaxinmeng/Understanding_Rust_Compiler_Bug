{"sha": "c845cfe1af6a72609e04a68b967f2b919599b32b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg0NWNmZTFhZjZhNzI2MDllMDRhNjhiOTY3ZjJiOTE5NTk5YjMyYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-03-21T17:35:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-03-21T17:35:39Z"}, "message": "re PR debug/55608 (Debug info quality regressions with file scope vars)\n\n\tPR debug/55608\n\t* dwarf2out.c (tree_add_const_value_attribute): Call ggc_free (array)\n\ton failure.\n\t(resolve_one_addr): Fail if referenced STRING_CST hasn't been written.\n\t(string_cst_pool_decl): New function.\n\t(optimize_one_addr_into_implicit_ptr): New function.\n\t(resolve_addr_in_expr): Optimize DWARF location expression\n\tDW_OP_addr DW_OP_stack_value where DW_OP_addr refers to some variable\n\twhich doesn't live in memory, but has DW_AT_location or\n\tDW_AT_const_value, or refers to a string literal, into\n\tDW_OP_GNU_implicit_pointer.\n\t(optimize_location_into_implicit_ptr): New function.\n\t(resolve_addr): If removing DW_AT_location of a variable because\n\tit was DW_OP_addr of address of the variable, but the variable doesn't\n\tlive in memory, try to emit const value attribute for the initializer.\n\nFrom-SVN: r196886", "tree": {"sha": "ceb9b4cba8f3ed7614a17bae32388520d9fd8686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ceb9b4cba8f3ed7614a17bae32388520d9fd8686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c845cfe1af6a72609e04a68b967f2b919599b32b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c845cfe1af6a72609e04a68b967f2b919599b32b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c845cfe1af6a72609e04a68b967f2b919599b32b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c845cfe1af6a72609e04a68b967f2b919599b32b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a5e2469172776e76626c1849d2e0c07f79226d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5e2469172776e76626c1849d2e0c07f79226d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a5e2469172776e76626c1849d2e0c07f79226d1"}], "stats": {"total": 239, "additions": 227, "deletions": 12}, "files": [{"sha": "b8a1b19e699d70083f6ebe55811c5974220bf8cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c845cfe1af6a72609e04a68b967f2b919599b32b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c845cfe1af6a72609e04a68b967f2b919599b32b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c845cfe1af6a72609e04a68b967f2b919599b32b", "patch": "@@ -1,3 +1,21 @@\n+2013-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/55608\n+\t* dwarf2out.c (tree_add_const_value_attribute): Call ggc_free (array)\n+\ton failure.\n+\t(resolve_one_addr): Fail if referenced STRING_CST hasn't been written.\n+\t(string_cst_pool_decl): New function.\n+\t(optimize_one_addr_into_implicit_ptr): New function.\n+\t(resolve_addr_in_expr): Optimize DWARF location expression\n+\tDW_OP_addr DW_OP_stack_value where DW_OP_addr refers to some variable\n+\twhich doesn't live in memory, but has DW_AT_location or\n+\tDW_AT_const_value, or refers to a string literal, into\n+\tDW_OP_GNU_implicit_pointer.\n+\t(optimize_location_into_implicit_ptr): New function.\n+\t(resolve_addr): If removing DW_AT_location of a variable because\n+\tit was DW_OP_addr of address of the variable, but the variable doesn't\n+\tlive in memory, try to emit const value attribute for the initializer.\n+\n 2013-03-21  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* tree.h (VECTOR_TYPE_P): New macro."}, {"sha": "9be77286dacb95080a955358c3d77f8107f1c243", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 209, "deletions": 12, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c845cfe1af6a72609e04a68b967f2b919599b32b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c845cfe1af6a72609e04a68b967f2b919599b32b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c845cfe1af6a72609e04a68b967f2b919599b32b", "patch": "@@ -15527,6 +15527,7 @@ tree_add_const_value_attribute (dw_die_ref die, tree t)\n \t      add_AT_vec (die, DW_AT_const_value, size, 1, array);\n \t      return true;\n \t    }\n+\t  ggc_free (array);\n \t}\n     }\n   return false;\n@@ -22494,6 +22495,10 @@ resolve_one_addr (rtx *addr, void *data ATTRIBUTE_UNUSED)\n       if (!rtl || !MEM_P (rtl))\n \treturn 1;\n       rtl = XEXP (rtl, 0);\n+      if (GET_CODE (rtl) == SYMBOL_REF\n+\t  && SYMBOL_REF_DECL (rtl)\n+\t  && !TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))\n+\treturn 1;\n       vec_safe_push (used_rtx_array, rtl);\n       *addr = rtl;\n       return 0;\n@@ -22518,6 +22523,103 @@ resolve_one_addr (rtx *addr, void *data ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n+/* For STRING_CST, return SYMBOL_REF of its constant pool entry,\n+   if possible, and create DW_TAG_dwarf_procedure that can be referenced\n+   from DW_OP_GNU_implicit_pointer if the string hasn't been seen yet.  */\n+\n+static rtx\n+string_cst_pool_decl (tree t)\n+{\n+  rtx rtl = output_constant_def (t, 1);\n+  unsigned char *array;\n+  dw_loc_descr_ref l;\n+  tree decl;\n+  size_t len;\n+  dw_die_ref ref;\n+\n+  if (!rtl || !MEM_P (rtl))\n+    return NULL_RTX;\n+  rtl = XEXP (rtl, 0);\n+  if (GET_CODE (rtl) != SYMBOL_REF\n+      || SYMBOL_REF_DECL (rtl) == NULL_TREE)\n+    return NULL_RTX;\n+\n+  decl = SYMBOL_REF_DECL (rtl);\n+  if (!lookup_decl_die (decl))\n+    {\n+      len = TREE_STRING_LENGTH (t);\n+      vec_safe_push (used_rtx_array, rtl);\n+      ref = new_die (DW_TAG_dwarf_procedure, comp_unit_die (), decl);\n+      array = (unsigned char *) ggc_alloc_atomic (len);\n+      memcpy (array, TREE_STRING_POINTER (t), len);\n+      l = new_loc_descr (DW_OP_implicit_value, len, 0);\n+      l->dw_loc_oprnd2.val_class = dw_val_class_vec;\n+      l->dw_loc_oprnd2.v.val_vec.length = len;\n+      l->dw_loc_oprnd2.v.val_vec.elt_size = 1;\n+      l->dw_loc_oprnd2.v.val_vec.array = array;\n+      add_AT_loc (ref, DW_AT_location, l);\n+      equate_decl_number_to_die (decl, ref);\n+    }\n+  return rtl;\n+}\n+\n+/* Helper function of resolve_addr_in_expr.  LOC is\n+   a DW_OP_addr followed by DW_OP_stack_value, either at the start\n+   of exprloc or after DW_OP_{,bit_}piece, and val_addr can't be\n+   resolved.  Replace it (both DW_OP_addr and DW_OP_stack_value)\n+   with DW_OP_GNU_implicit_pointer if possible\n+   and return true, if unsuccesful, return false.  */\n+\n+static bool\n+optimize_one_addr_into_implicit_ptr (dw_loc_descr_ref loc)\n+{\n+  rtx rtl = loc->dw_loc_oprnd1.v.val_addr;\n+  HOST_WIDE_INT offset = 0;\n+  dw_die_ref ref = NULL;\n+  tree decl;\n+\n+  if (GET_CODE (rtl) == CONST\n+      && GET_CODE (XEXP (rtl, 0)) == PLUS\n+      && CONST_INT_P (XEXP (XEXP (rtl, 0), 1)))\n+    {\n+      offset = INTVAL (XEXP (XEXP (rtl, 0), 1));\n+      rtl = XEXP (XEXP (rtl, 0), 0);\n+    }\n+  if (GET_CODE (rtl) == CONST_STRING)\n+    {\n+      size_t len = strlen (XSTR (rtl, 0)) + 1;\n+      tree t = build_string (len, XSTR (rtl, 0));\n+      tree tlen = size_int (len - 1);\n+\n+      TREE_TYPE (t)\n+\t= build_array_type (char_type_node, build_index_type (tlen));\n+      rtl = string_cst_pool_decl (t);\n+      if (!rtl)\n+\treturn false;\n+    }\n+  if (GET_CODE (rtl) == SYMBOL_REF && SYMBOL_REF_DECL (rtl))\n+    {\n+      decl = SYMBOL_REF_DECL (rtl);\n+      if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+\t{\n+\t  ref = lookup_decl_die (decl);\n+\t  if (ref && (get_AT (ref, DW_AT_location)\n+\t\t      || get_AT (ref, DW_AT_const_value)))\n+\t    {\n+\t      loc->dw_loc_opc = DW_OP_GNU_implicit_pointer;\n+\t      loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      loc->dw_loc_oprnd1.val_entry = NULL;\n+\t      loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t      loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      loc->dw_loc_next = loc->dw_loc_next->dw_loc_next;\n+\t      loc->dw_loc_oprnd2.v.val_int = offset;\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Helper function for resolve_addr, handle one location\n    expression, return false if at least one CONST_STRING or SYMBOL_REF in\n    the location list couldn't be resolved.  */\n@@ -22526,23 +22628,31 @@ static bool\n resolve_addr_in_expr (dw_loc_descr_ref loc)\n {\n   dw_loc_descr_ref keep = NULL;\n-  for (; loc; loc = loc->dw_loc_next)\n+  for (dw_loc_descr_ref prev = NULL; loc; prev = loc, loc = loc->dw_loc_next)\n     switch (loc->dw_loc_opc)\n       {\n       case DW_OP_addr:\n \tif (resolve_one_addr (&loc->dw_loc_oprnd1.v.val_addr, NULL))\n-\t  return false;\n+\t  {\n+\t    if ((prev == NULL\n+\t\t || prev->dw_loc_opc == DW_OP_piece\n+\t\t || prev->dw_loc_opc == DW_OP_bit_piece)\n+\t\t&& loc->dw_loc_next\n+\t\t&& loc->dw_loc_next->dw_loc_opc == DW_OP_stack_value\n+\t\t&& !dwarf_strict\n+\t\t&& optimize_one_addr_into_implicit_ptr (loc))\n+\t      break;\n+\t    return false;\n+\t  }\n \tbreak;\n       case DW_OP_GNU_addr_index:\n       case DW_OP_GNU_const_index:\n-        {\n-          if ((loc->dw_loc_opc == DW_OP_GNU_addr_index\n-               || (loc->dw_loc_opc == DW_OP_GNU_const_index && loc->dtprel))\n-              && resolve_one_addr (&loc->dw_loc_oprnd1.val_entry->addr.rtl,\n-                                   NULL))\n-            return false;\n-        }\n-       break;\n+\tif ((loc->dw_loc_opc == DW_OP_GNU_addr_index\n+\t     || (loc->dw_loc_opc == DW_OP_GNU_const_index && loc->dtprel))\n+\t    && resolve_one_addr (&loc->dw_loc_oprnd1.val_entry->addr.rtl,\n+\t\t\t\t NULL))\n+\t  return false;\n+\tbreak;\n       case DW_OP_const4u:\n       case DW_OP_const8u:\n \tif (loc->dtprel\n@@ -22637,6 +22747,80 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n   return true;\n }\n \n+/* Helper function of resolve_addr.  DIE had DW_AT_location of\n+   DW_OP_addr alone, which referred to DECL in DW_OP_addr's operand\n+   and DW_OP_addr couldn't be resolved.  resolve_addr has already\n+   removed the DW_AT_location attribute.  This function attempts to\n+   add a new DW_AT_location attribute with DW_OP_GNU_implicit_pointer\n+   to it or DW_AT_const_value attribute, if possible.  */\n+\n+static void\n+optimize_location_into_implicit_ptr (dw_die_ref die, tree decl)\n+{\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || lookup_decl_die (decl) != die\n+      || DECL_EXTERNAL (decl)\n+      || !TREE_STATIC (decl)\n+      || DECL_INITIAL (decl) == NULL_TREE\n+      || DECL_P (DECL_INITIAL (decl))\n+      || get_AT (die, DW_AT_const_value))\n+    return;\n+\n+  tree init = DECL_INITIAL (decl);\n+  HOST_WIDE_INT offset = 0;\n+  /* For variables that have been optimized away and thus\n+     don't have a memory location, see if we can emit\n+     DW_AT_const_value instead.  */\n+  if (tree_add_const_value_attribute (die, init))\n+    return;\n+  if (dwarf_strict)\n+    return;\n+  /* If init is ADDR_EXPR or POINTER_PLUS_EXPR of ADDR_EXPR,\n+     and ADDR_EXPR refers to a decl that has DW_AT_location or\n+     DW_AT_const_value (but isn't addressable, otherwise\n+     resolving the original DW_OP_addr wouldn't fail), see if\n+     we can add DW_OP_GNU_implicit_pointer.  */\n+  STRIP_NOPS (init);\n+  if (TREE_CODE (init) == POINTER_PLUS_EXPR\n+      && host_integerp (TREE_OPERAND (init, 1), 0))\n+    {\n+      offset = tree_low_cst (TREE_OPERAND (init, 1), 0);\n+      init = TREE_OPERAND (init, 0);\n+      STRIP_NOPS (init);\n+    }\n+  if (TREE_CODE (init) != ADDR_EXPR)\n+    return;\n+  if ((TREE_CODE (TREE_OPERAND (init, 0)) == STRING_CST\n+       && !TREE_ASM_WRITTEN (TREE_OPERAND (init, 0)))\n+      || (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL\n+\t  && !DECL_EXTERNAL (TREE_OPERAND (init, 0))\n+\t  && TREE_OPERAND (init, 0) != decl))\n+    {\n+      dw_die_ref ref;\n+      dw_loc_descr_ref l;\n+\n+      if (TREE_CODE (TREE_OPERAND (init, 0)) == STRING_CST)\n+\t{\n+\t  rtx rtl = string_cst_pool_decl (TREE_OPERAND (init, 0));\n+\t  if (!rtl)\n+\t    return;\n+\t  decl = SYMBOL_REF_DECL (rtl);\n+\t}\n+      else\n+\tdecl = TREE_OPERAND (init, 0);\n+      ref = lookup_decl_die (decl);\n+      if (ref == NULL\n+\t  || (!get_AT (ref, DW_AT_location)\n+\t      && !get_AT (ref, DW_AT_const_value)))\n+\treturn;\n+      l = new_loc_descr (DW_OP_GNU_implicit_pointer, 0, offset);\n+      l->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      l->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+      l->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_AT_loc (die, DW_AT_location, l);\n+    }\n+}\n+\n /* Resolve DW_OP_addr and DW_AT_const_value CONST_STRING arguments to\n    an address in .rodata section if the string literal is emitted there,\n    or remove the containing location list or replace DW_AT_const_value\n@@ -22723,8 +22907,21 @@ resolve_addr (dw_die_ref die)\n \t       || l->dw_loc_next != NULL)\n \t      && !resolve_addr_in_expr (l))\n \t    {\n-              if (dwarf_split_debug_info)\n-                remove_loc_list_addr_table_entries (l);\n+\t      if (dwarf_split_debug_info)\n+\t\tremove_loc_list_addr_table_entries (l);\n+\t      if (l != NULL\n+\t\t  && l->dw_loc_next == NULL\n+\t\t  && l->dw_loc_opc == DW_OP_addr\n+\t\t  && GET_CODE (l->dw_loc_oprnd1.v.val_addr) == SYMBOL_REF\n+\t\t  && SYMBOL_REF_DECL (l->dw_loc_oprnd1.v.val_addr)\n+\t\t  && a->dw_attr == DW_AT_location)\n+\t\t{\n+\t\t  tree decl = SYMBOL_REF_DECL (l->dw_loc_oprnd1.v.val_addr);\n+\t\t  remove_AT (die, a->dw_attr);\n+\t\t  ix--;\n+\t\t  optimize_location_into_implicit_ptr (die, decl);\n+\t\t  break;\n+\t\t}\n \t      remove_AT (die, a->dw_attr);\n \t      ix--;\n \t    }"}]}