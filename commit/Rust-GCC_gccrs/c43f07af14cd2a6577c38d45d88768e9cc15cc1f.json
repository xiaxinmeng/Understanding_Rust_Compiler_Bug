{"sha": "c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzZjA3YWYxNGNkMmE2NTc3YzM4ZDQ1ZDg4NzY4ZTljYzE1Y2MxZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2008-05-06T14:15:18Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-05-06T14:15:18Z"}, "message": "ipa-cp.c (ipcp_method_orig_node): Renamed to ipcp_get_orig_node.\n\n2008-05-06  Martin Jambor  <mjambor@suse.cz>\n\n        * ipa-cp.c (ipcp_method_orig_node): Renamed to ipcp_get_orig_node.\n        (ipcp_method_is_cloned): Renamed to ipcp_node_is_clone\n        (ipcp_method_set_orig_node): Removed.\n        (ipcp_cval_get_cvalue_type): Removed.\n        (ipcp_method_get_scale): Renamed to ipcp_get_node_scale.\n        (ipcp_method_set_scale): Renamed to ipcp_set_node_scale.\n        (ipcp_cval_set_cvalue_type): Removed.\n        (ipcp_cval_get_cvalue): Removed.\n        (ipcp_cval_set_cvalue): Removed.\n        (ipcp_type_is_const): Renamed to ipcp_lat_is_const.\n        (ipcp_cval_equal_cvalues): Renamed to ipcp_lats_are_equal\n        (ipcp_lats_are_equal): Changed parameters to two ipcp_lattice's\n        (ipcp_cval_meet): Renamed to ipa_lattice_meet\n        (ipcp_cval_changed): Changed to use ipcp_lat_is_const\n        (ipcp_method_cval): Renamed to ipcp_get_ith_lattice\n        (ipcp_get_ith_lattice): Changed parameters.\n        (ipcp_cval_compute): Renamed to ipcp_lattice_from_jfunc\n        (ipcp_lattice_from_jfunc): Changed parameters.\n\t(ipcp_redirect): Local lattice pointer instead of lattice type variable.\n\t(ipcp_method_cval_print): Added temporary variable info.\n\t(ipcp_redirect): Removed already unused local variable caller.\n\t(ipcp_redirect): New temporary variable orig_callee_info\n\t(ipcp_redirect): Removed newly unused local variable callee.\n\t(ipcp_redirect): Removed (a bit confusing) local variable type.\n\t(ipcp_insert_stage): Added local variable info.\n\t(ipcp_cval_changed): Renamed to ipcp_lattice_changed, parameters \n\trenamed too\n\t(ipcp_formal_create): Removed.\n\t(ipcp_method_cval_set): Removed.\n\t(ipcp_propagate_stage): Renamed lattice variables.\n\t(ipcp_method_cval_set_cvalue_type): Removed.\n\t(ipcp_method_cval_print): Renamed to ipcp_print_all_lattices\n\t(ipcp_print_all_lattices): Changed printed strings to refer to \n\tlattices rather than cvals.\n\t(ipcp_method_cval_init): Renamed to ipcp_initialize_node_lattices\n\t(ipcp_propagate_const): Changed formal parameters.\n\t(build_const_val): Changed formal parameters.\n\t(ipcp_insert_stage): Removed useless variable cvalue\n\t(build_const_val): Changed formal parameters.\n\t(ipcp_method_compute_scale): Renamed to ipcp_compute_node_scale\n\t(ipcp_after_propagate): Renamed to ipcp_change_tops_to_bottom\n\t(ipcp_callsite_param_print): Renamed to ipcp_print_all_jump_functions\n\t(ipcp_profile_mt_count_print): Renamed to ipcp_print_func_profile_counts\n\t(ipcp_print_func_profile_counts): Changed string from \"method\" to \n\t\"function\"\n\t(ipcp_profile_cs_count_print): Renamed to ipcp_print_call_profile_counts\n\t(ipcp_profile_edge_print): Renamed to ipcp_print_edge_profiles\n\t(ipcp_profile_bb_print): Renamed to ipcp_print_bb_profiles\n\t(ipcp_structures_print): Renamed to ipcp_print_all_structures\n\t(ipcp_profile_print): Renamed to ipcp_print_profile_data\n\t(ipcp_lat_is_const): Changed parameters and made inline.\n\t(ipcp_replace_map_create): Renamed to ipcp_create_replace_map\n\t(ipcp_redirect): Renamed to ipcp_need_redirect_p\n\t(ipcp_need_redirect_p): Calls ipcp_lat_is_const instead of using \n\tthe predicate condition directly\n\t(ipcp_propagate_stage): Added local variable args. Removed local\n\tvariable callee.  (Both are mere code simplifications.)\n\t(ipcp_method_dont_insert_const): Renamed to\n\tipcp_node_not_modifiable_p.\n\t(ipcp_node_not_modifiable_p): Made inline.\n\t(ipcp_cloned_create): Renamed to ipcp_init_cloned_node\n\t(ipcp_propagate_const): Renamed to ipcp_propagate_one_const\n\t(ipcp_print_all_lattices): Removed variable cvalue\n\t(ipcp_method_scale_print): Renamed to ipcp_function_scale_print\n\tUpdated comments.\n\nFrom-SVN: r134984", "tree": {"sha": "3441653f03e2152be9175a4f41eb174d3e2fc594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3441653f03e2152be9175a4f41eb174d3e2fc594"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43f07af14cd2a6577c38d45d88768e9cc15cc1f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b9d6cf30e659c40d8458b22c6400f6da7bb0856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9d6cf30e659c40d8458b22c6400f6da7bb0856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9d6cf30e659c40d8458b22c6400f6da7bb0856"}], "stats": {"total": 744, "additions": 352, "deletions": 392}, "files": [{"sha": "2cb1a41401a5135cdf910a9ea7785240038d09b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f07af14cd2a6577c38d45d88768e9cc15cc1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f07af14cd2a6577c38d45d88768e9cc15cc1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "patch": "@@ -1,3 +1,71 @@\n+2008-05-06  Martin Jambor  <mjambor@suse.cz>\n+\n+        * ipa-cp.c (ipcp_method_orig_node): Renamed to ipcp_get_orig_node.\n+        (ipcp_method_is_cloned): Renamed to ipcp_node_is_clone\n+        (ipcp_method_set_orig_node): Removed.\n+        (ipcp_cval_get_cvalue_type): Removed.\n+        (ipcp_method_get_scale): Renamed to ipcp_get_node_scale.\n+        (ipcp_method_set_scale): Renamed to ipcp_set_node_scale.\n+        (ipcp_cval_set_cvalue_type): Removed.\n+        (ipcp_cval_get_cvalue): Removed.\n+        (ipcp_cval_set_cvalue): Removed.\n+        (ipcp_type_is_const): Renamed to ipcp_lat_is_const.\n+        (ipcp_cval_equal_cvalues): Renamed to ipcp_lats_are_equal\n+        (ipcp_lats_are_equal): Changed parameters to two ipcp_lattice's\n+        (ipcp_cval_meet): Renamed to ipa_lattice_meet\n+        (ipcp_cval_changed): Changed to use ipcp_lat_is_const\n+        (ipcp_method_cval): Renamed to ipcp_get_ith_lattice\n+        (ipcp_get_ith_lattice): Changed parameters.\n+        (ipcp_cval_compute): Renamed to ipcp_lattice_from_jfunc\n+        (ipcp_lattice_from_jfunc): Changed parameters.\n+\t(ipcp_redirect): Local lattice pointer instead of lattice type variable.\n+\t(ipcp_method_cval_print): Added temporary variable info.\n+\t(ipcp_redirect): Removed already unused local variable caller.\n+\t(ipcp_redirect): New temporary variable orig_callee_info\n+\t(ipcp_redirect): Removed newly unused local variable callee.\n+\t(ipcp_redirect): Removed (a bit confusing) local variable type.\n+\t(ipcp_insert_stage): Added local variable info.\n+\t(ipcp_cval_changed): Renamed to ipcp_lattice_changed, parameters \n+\trenamed too\n+\t(ipcp_formal_create): Removed.\n+\t(ipcp_method_cval_set): Removed.\n+\t(ipcp_propagate_stage): Renamed lattice variables.\n+\t(ipcp_method_cval_set_cvalue_type): Removed.\n+\t(ipcp_method_cval_print): Renamed to ipcp_print_all_lattices\n+\t(ipcp_print_all_lattices): Changed printed strings to refer to \n+\tlattices rather than cvals.\n+\t(ipcp_method_cval_init): Renamed to ipcp_initialize_node_lattices\n+\t(ipcp_propagate_const): Changed formal parameters.\n+\t(build_const_val): Changed formal parameters.\n+\t(ipcp_insert_stage): Removed useless variable cvalue\n+\t(build_const_val): Changed formal parameters.\n+\t(ipcp_method_compute_scale): Renamed to ipcp_compute_node_scale\n+\t(ipcp_after_propagate): Renamed to ipcp_change_tops_to_bottom\n+\t(ipcp_callsite_param_print): Renamed to ipcp_print_all_jump_functions\n+\t(ipcp_profile_mt_count_print): Renamed to ipcp_print_func_profile_counts\n+\t(ipcp_print_func_profile_counts): Changed string from \"method\" to \n+\t\"function\"\n+\t(ipcp_profile_cs_count_print): Renamed to ipcp_print_call_profile_counts\n+\t(ipcp_profile_edge_print): Renamed to ipcp_print_edge_profiles\n+\t(ipcp_profile_bb_print): Renamed to ipcp_print_bb_profiles\n+\t(ipcp_structures_print): Renamed to ipcp_print_all_structures\n+\t(ipcp_profile_print): Renamed to ipcp_print_profile_data\n+\t(ipcp_lat_is_const): Changed parameters and made inline.\n+\t(ipcp_replace_map_create): Renamed to ipcp_create_replace_map\n+\t(ipcp_redirect): Renamed to ipcp_need_redirect_p\n+\t(ipcp_need_redirect_p): Calls ipcp_lat_is_const instead of using \n+\tthe predicate condition directly\n+\t(ipcp_propagate_stage): Added local variable args. Removed local\n+\tvariable callee.  (Both are mere code simplifications.)\n+\t(ipcp_method_dont_insert_const): Renamed to\n+\tipcp_node_not_modifiable_p.\n+\t(ipcp_node_not_modifiable_p): Made inline.\n+\t(ipcp_cloned_create): Renamed to ipcp_init_cloned_node\n+\t(ipcp_propagate_const): Renamed to ipcp_propagate_one_const\n+\t(ipcp_print_all_lattices): Removed variable cvalue\n+\t(ipcp_method_scale_print): Renamed to ipcp_function_scale_print\n+\tUpdated comments.\n+\n 2008-05-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* tree-sra.c (try_instantiate_multiple_fields): Early return"}, {"sha": "80774327d314e03e50d170a730d1c6576e3e15ce", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 284, "deletions": 392, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f07af14cd2a6577c38d45d88768e9cc15cc1f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f07af14cd2a6577c38d45d88768e9cc15cc1f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c43f07af14cd2a6577c38d45d88768e9cc15cc1f", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural constant propagation\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <RAZYA@il.ibm.com>\n    \n This file is part of GCC.\n@@ -18,113 +18,101 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Interprocedural constant propagation.\n-   The aim of interprocedural constant propagation (IPCP) is to find which \n-   function's argument has the same constant value in each invocation throughout \n-   the whole program. For example, for an application consisting of two files, \n-   foo1.c, foo2.c:\n+/* Interprocedural constant propagation.  The aim of interprocedural constant\n+   propagation (IPCP) is to find which function's argument has the same\n+   constant value in each invocation throughout the whole program. For example,\n+   consider the following program:\n \n-   foo1.c contains :\n+   int g (int y)\n+   {\n+     printf (\"value is %d\",y);\n+   }\n    \n    int f (int x)\n    {\n      g (x);\n    }\n-   void main (void)\n-   {\n-     f (3);\n-     h (3);\n-   }\n-   \n-   foo2.c contains :\n-   \n+\n    int h (int y)\n    {\n      g (y);\n    }\n-   int g (int y)\n+\n+   void main (void)\n    {\n-     printf (\"value is %d\",y);\n+     f (3);\n+     h (3);\n    }\n    \n-   The IPCP algorithm will find that g's formal argument y\n-   is always called with the value 3.\n    \n-   The algorithm used is based on \"Interprocedural Constant Propagation\",\n-   by Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, \n-   pg 152-161\n+   The IPCP algorithm will find that g's formal argument y is always called\n+   with the value 3.\n+\n+   The algorithm used is based on \"Interprocedural Constant Propagation\", by\n+   Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, pg\n+   152-161\n    \n    The optimization is divided into three stages:\n \n    First stage - intraprocedural analysis\n    =======================================\n-   This phase computes jump_function and modify information.\n+   This phase computes jump_function and modification flags.\n    \n-   A jump function for a callsite represents the values passed as actual \n-   arguments\n-   of the callsite. There are three types of values :\n-   Formal - the caller's formal parameter is passed as an actual argument.\n+   A jump function for a callsite represents the values passed as an actual\n+   arguments of a given callsite. There are three types of values:\n+   Pass through - the caller's formal parameter is passed as an actual argument.\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n    \n-   In order to compute the jump functions, we need the modify information for \n-   the formal parameters of methods.\n-   \n-   The jump function info, ipa_jump_func, is defined in ipa_edge\n+   The jump function info, ipa_jump_func, is stored in ipa_edge_args\n    structure (defined in ipa_prop.h and pointed to by cgraph_node->aux)\n-   The modify info, modified_flags, is defined in ipa_node_params structure\n+   modified_flags are defined in ipa_node_params structure\n    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n    \n    -ipcp_init_stage() is the first stage driver.\n \n    Second stage - interprocedural analysis\n    ========================================\n    This phase does the interprocedural constant propagation.\n-   It computes for all formal parameters in the program\n-   their cval value that may be:\n+   It computes lattices for all formal parameters in the program\n+   and their value that may be:\n    TOP - unknown.\n    BOTTOM - non constant.\n-   CONSTANT_TYPE - constant value.\n+   CONSTANT - constant value.\n    \n-   Cval of formal f will have a constant value if all callsites to this\n-   function have the same constant value passed to f.\n+   Lattice describing a formal parameter p will have a constant value if all\n+   callsites invoking this function have the same constant value passed to p.\n    \n-   The cval info, ipcp_lattice, is defined in ipa_node_params structure\n-   (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n+   The lattices are stored in ipcp_lattice which is itself in ipa_node_params\n+   structure (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n \n    -ipcp_iterate_stage() is the second stage driver.\n \n-   Third phase - transformation of methods code\n+   Third phase - transformation of function code\n    ============================================\n    Propagates the constant-valued formals into the function.\n-   For each method mt, whose parameters are consts, we create a clone/version.\n+   For each function whose parameters are constants, we create its clone.\n \n-   We use two ways to annotate the versioned function with the constant \n-   formal information:\n+   Then we process the clone in two ways:\n    1. We insert an assignment statement 'parameter = const' at the beginning\n-   of the cloned method.\n-   2. For read-only formals whose address is not taken, we replace all uses \n-   of the formal with the constant (we provide versioning with an \n-   ipa_replace_map struct representing the trees we want to replace).\n+      of the cloned function.\n+   2. For read-only parameters that do not live in memory, we replace all their\n+      uses with the constant.\n \n-   We also need to modify some callsites to call to the cloned methods instead\n-   of the original ones. For a callsite passing an argument found to be a\n+   We also need to modify some callsites to call the cloned functiosns instead\n+   of the original ones.  For a callsite passing an argument found to be a\n    constant by IPCP, there are two different cases to handle:\n-   1. A constant is passed as an argument.\n-   2. A parameter (of the caller) passed as an argument (pass through argument).\n-\n-   In the first case, the callsite in the original caller should be redirected\n-   to call the cloned callee.\n-   In the second case, both the caller and the callee have clones\n-   and the callsite of the cloned caller would be redirected to call to\n-   the cloned callee.\n-\n-   The callgraph is updated accordingly.\n-\n-   This update is done in two stages:\n-   First all cloned methods are created during a traversal of the callgraph,\n-   during which all callsites are redirected to call the cloned method.\n-   Then the callsites are traversed and updated as described above.\n+   1. A constant is passed as an argument.  In this case the callsite in the\n+      should be redirected to call the cloned callee.\n+   2. A parameter (of the caller) passed as an argument (pass through\n+      argument).  In such cases both the caller and the callee have clones and\n+      only the callsite in the cloned caller is redirected to call to the\n+      cloned callee.\n+\n+   This update is done in two steps: First all cloned functionss are created\n+   during a traversal of the call graph, during which all callsites are\n+   redirected to call the cloned function.  Then the callsites are traversed\n+   and many calls redirected back to fit the description above.\n \n    -ipcp_insert_stage() is the third phase driver.\n    \n@@ -145,105 +133,65 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"tree-inline.h\"\n \n-/* Get orig node field of ipa_node_params associated with method MT.  */\n+/* Get the original node field of ipa_node_params associated with node NODE.  */\n static inline struct cgraph_node *\n-ipcp_method_orig_node (struct cgraph_node *mt)\n+ipcp_get_orig_node (struct cgraph_node *node)\n {\n-  return IPA_NODE_REF (mt)->ipcp_orig_node;\n+  return IPA_NODE_REF (node)->ipcp_orig_node;\n }\n \n-/* Return true if NODE is a cloned/versioned method.  */\n+/* Return true if NODE describes a cloned/versioned function.  */\n static inline bool\n-ipcp_method_is_cloned (struct cgraph_node *node)\n-{\n-  return (ipcp_method_orig_node (node) != NULL);\n-}\n-\n-/* Set ORIG_NODE in ipa_node associated with method NODE.  */\n-static inline void\n-ipcp_method_set_orig_node (struct cgraph_node *node,\n-\t\t\t   struct cgraph_node *orig_node)\n+ipcp_node_is_clone (struct cgraph_node *node)\n {\n-  IPA_NODE_REF (node)->ipcp_orig_node = orig_node;\n+  return (ipcp_get_orig_node (node) != NULL);\n }\n \n-/* Create ipa_node and its data structures for NEW_NODE.\n-   Set ORIG_NODE as the orig_node field in ipa_node.  */\n+/* Create ipa_node_params and its data structures for NEW_NODE.  Set ORIG_NODE\n+   as the ipcp_orig_node field in ipa_node_params.  */\n static void\n-ipcp_cloned_create (struct cgraph_node *orig_node,\n-\t\t    struct cgraph_node *new_node)\n+ipcp_init_cloned_node (struct cgraph_node *orig_node,\n+\t\t       struct cgraph_node *new_node)\n {\n   ipa_create_node_params (new_node);\n-  ipcp_method_set_orig_node (new_node, orig_node);\n+  IPA_NODE_REF (new_node)->ipcp_orig_node = orig_node;\n   ipa_count_formal_params (new_node);\n   ipa_create_param_decls_array (new_node);\n }\n \n-/* Return cval_type field of CVAL.  */\n-static inline enum ipa_lattice_type\n-ipcp_cval_get_cvalue_type (struct ipcp_lattice *cval)\n-{\n-  return cval->type;\n-}\n-\n-/* Return scale for MT.  */\n+/* Return scale for NODE.  */\n static inline gcov_type\n-ipcp_method_get_scale (struct cgraph_node *mt)\n+ipcp_get_node_scale (struct cgraph_node *node)\n {\n-  return IPA_NODE_REF (mt)->count_scale;\n+  return IPA_NODE_REF (node)->count_scale;\n }\n \n-/* Set COUNT as scale for MT.  */\n+/* Set COUNT as scale for NODE.  */\n static inline void\n-ipcp_method_set_scale (struct cgraph_node *node, gcov_type count)\n+ipcp_set_node_scale (struct cgraph_node *node, gcov_type count)\n {\n   IPA_NODE_REF (node)->count_scale = count;\n }\n \n-/* Set TYPE as cval_type field of CVAL.  */\n-static inline void\n-ipcp_cval_set_cvalue_type (struct ipcp_lattice *cval, enum jump_func_type type)\n-{\n-  cval->type = type;\n-}\n-\n-/* Return cvalue field of CVAL.  */\n-static inline tree\n-ipcp_cval_get_cvalue (struct ipcp_lattice *cval)\n-{\n-  return cval->constant;\n-}\n-\n-/* Set VALUE as cvalue field  CVAL.  */\n-static inline void\n-ipcp_cval_set_cvalue (struct ipcp_lattice *cval, tree value,\n-\t\t      enum ipa_lattice_type type)\n-{\n-  if (type == IPA_CONST_VALUE || type == IPA_CONST_VALUE_REF)\n-    cval->constant = value;\n-}\n-\n-/* Return whether TYPE is a constant type.  */\n-static bool\n-ipcp_type_is_const (enum ipa_lattice_type type)\n+/* Return whether LAT is a constant lattice.  */\n+static inline bool\n+ipcp_lat_is_const (struct ipcp_lattice *lat)\n {\n-  if (type == IPA_CONST_VALUE || type == IPA_CONST_VALUE_REF)\n+  if (lat->type == IPA_CONST_VALUE || lat->type == IPA_CONST_VALUE_REF)\n     return true;\n   else\n     return false;\n }\n \n-/* Return true if CONST_VAL1 and CONST_VAL2 are equal.  */\n+/* Return true if LAT1 and LAT2 are equal.  */\n static inline bool\n-ipcp_cval_equal_cvalues (tree const_val1, tree const_val2,\n-\t\t\t enum ipa_lattice_type type1,\n-\t\t\t enum ipa_lattice_type type2)\n+ipcp_lats_are_equal (struct ipcp_lattice *lat1, struct ipcp_lattice *lat2)\n {\n-  gcc_assert (ipcp_type_is_const (type1) && ipcp_type_is_const (type2));\n-  if (type1 != type2)\n+  gcc_assert (ipcp_lat_is_const (lat1) && ipcp_lat_is_const (lat2));\n+  if (lat1->type != lat2->type)\n     return false;\n \n-  if (operand_equal_p (const_val1, const_val2, 0))\n+  if (operand_equal_p (lat1->constant, lat2->constant, 0))\n     return true;\n \n   return false;\n@@ -255,198 +203,144 @@ ipcp_cval_equal_cvalues (tree const_val1, tree const_val2,\n    Meet (const_a,const_b) = IPA_BOTTOM,  if const_a != const_b.\n    MEET (const_a,const_b) = const_a, if const_a == const_b.*/\n static void\n-ipcp_cval_meet (struct ipcp_lattice *cval, struct ipcp_lattice *cval1,\n-\t\tstruct ipcp_lattice *cval2)\n+ipa_lattice_meet (struct ipcp_lattice *res, struct ipcp_lattice *lat1,\n+\t\t  struct ipcp_lattice *lat2)\n {\n-  if (ipcp_cval_get_cvalue_type (cval1) == IPA_BOTTOM\n-      || ipcp_cval_get_cvalue_type (cval2) == IPA_BOTTOM)\n+  if (lat1->type == IPA_BOTTOM || lat2->type == IPA_BOTTOM)\n     {\n-      ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n+      res->type = IPA_BOTTOM;\n       return;\n     }\n-  if (ipcp_cval_get_cvalue_type (cval1) == IPA_TOP)\n+  if (lat1->type == IPA_TOP)\n     {\n-      ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval2));\n-      ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval2),\n-\t\t\t    ipcp_cval_get_cvalue_type (cval2));\n+      res->type = lat2->type;\n+      res->constant = lat2->constant;\n       return;\n     }\n-  if (ipcp_cval_get_cvalue_type (cval2) == IPA_TOP)\n+  if (lat2->type == IPA_TOP)\n     {\n-      ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n-      ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval1),\n-\t\t\t    ipcp_cval_get_cvalue_type (cval1));\n+      res->type = lat1->type;\n+      res->constant = lat1->constant;\n       return;\n     }\n-  if (!ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n-\t\t\t\tipcp_cval_get_cvalue (cval2),\n-\t\t\t\tipcp_cval_get_cvalue_type (cval1),\n-\t\t\t\tipcp_cval_get_cvalue_type (cval2)))\n+  if (!ipcp_lats_are_equal (lat1, lat2))\n     {\n-      ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n+      res->type = IPA_BOTTOM;\n       return;\n     }\n-  ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n-  ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval1),\n-\t\t\tipcp_cval_get_cvalue_type (cval1));\n+  res->type = lat1->type;\n+  res->constant = lat1->constant;\n }\n \n-/* Return cval structure for the formal at index INFO_TYPE in MT.  */\n+/* Return the lattice corresponding to the Ith formal parameter of the function\n+   described by INFO.  */\n static inline struct ipcp_lattice *\n-ipcp_method_cval (struct cgraph_node *mt, int info_type)\n+ipcp_get_ith_lattice (struct ipa_node_params *info, int i)\n {\n-  return &(IPA_NODE_REF (mt)->ipcp_lattices[info_type]);\n+  return &(info->ipcp_lattices[i]);\n }\n \n-/* Given the jump function (TYPE, INFO_TYPE), compute a new value of CVAL.  \n-   If TYPE is FORMAL_IPA_TYPE, the cval of the corresponding formal is \n-   drawn from MT.  */\n+/* Given the jump function JFUNC, compute the lattice LAT that describes the\n+   value coming down the callsite. INFO describes the caller node so that\n+   pass-through jump functions can be evaluated.  */\n static void\n-ipcp_cval_compute (struct ipcp_lattice *cval, struct cgraph_node *mt,\n-\t\t   enum jump_func_type type,\n-\t\t   union jump_func_value *info_type)\n+ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n+\t\t\t struct ipa_jump_func *jfunc)\n {\n-  if (type == IPA_UNKNOWN)\n-    ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n-  else if (type == IPA_CONST)\n+  if (jfunc->type == IPA_UNKNOWN)\n+    lat->type = IPA_BOTTOM;\n+  else if (jfunc->type == IPA_CONST)\n     {\n-      ipcp_cval_set_cvalue_type (cval, IPA_CONST_VALUE);\n-      ipcp_cval_set_cvalue (cval, info_type->constant, IPA_CONST_VALUE);\n+      lat->type = IPA_CONST_VALUE;\n+      lat->constant = jfunc->value.constant;\n     }\n-  else if (type == IPA_CONST_REF)\n+  else if (jfunc->type == IPA_CONST_REF)\n     {\n-      ipcp_cval_set_cvalue_type (cval, IPA_CONST_VALUE_REF);\n-      ipcp_cval_set_cvalue (cval, info_type->constant, IPA_CONST_VALUE_REF);\n+      lat->type = IPA_CONST_VALUE_REF;\n+      lat->constant = jfunc->value.constant;\n     }\n-  else if (type == IPA_PASS_THROUGH)\n+  else if (jfunc->type == IPA_PASS_THROUGH)\n     {\n-      enum ipa_lattice_type type =\n-\tipcp_cval_get_cvalue_type (ipcp_method_cval\n-\t\t\t\t   (mt, info_type->formal_id));\n-      ipcp_cval_set_cvalue_type (cval, type);\n-      ipcp_cval_set_cvalue (cval,\n-\t\t\t    ipcp_cval_get_cvalue (ipcp_method_cval\n-\t\t\t\t\t\t  (mt, info_type->formal_id)),\n-\t\t\t    type);\n+      struct ipcp_lattice *caller_lat;\n+\n+      caller_lat = ipcp_get_ith_lattice (info, jfunc->value.formal_id);\n+      lat->type = caller_lat->type;\n+      lat->constant = caller_lat->constant;\n     }\n }\n \n-/* True when CVAL1 and CVAL2 values are not the same.  */\n+/* True when OLD and NEW values are not the same.  */\n static bool\n-ipcp_cval_changed (struct ipcp_lattice *cval1, struct ipcp_lattice *cval2)\n+ipcp_lattice_changed (struct ipcp_lattice *old, struct ipcp_lattice *new)\n {\n-  if (ipcp_cval_get_cvalue_type (cval1) == ipcp_cval_get_cvalue_type (cval2))\n+  if (old->type == new->type)\n     {\n-      if (ipcp_cval_get_cvalue_type (cval1) != IPA_CONST_VALUE\n-\t  && ipcp_cval_get_cvalue_type (cval1) != IPA_CONST_VALUE_REF)\n+      if (!ipcp_lat_is_const (old))\n \treturn false;\n-      if (ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n-\t\t\t\t   ipcp_cval_get_cvalue (cval2),\n-\t\t\t\t   ipcp_cval_get_cvalue_type (cval1),\n-\t\t\t\t   ipcp_cval_get_cvalue_type (cval2)))\n+      if (ipcp_lats_are_equal (old, new))\n \treturn false;\n     }\n   return true;\n }\n \n-/* Create cval structure for method MT.  */\n-static inline void\n-ipcp_formal_create (struct cgraph_node *mt)\n-{\n-  IPA_NODE_REF (mt)->ipcp_lattices =\n-    XCNEWVEC (struct ipcp_lattice, ipa_get_param_count (IPA_NODE_REF (mt)));\n-}\n-\n-/* Set cval structure of I-th formal of MT to CVAL.  */\n-static inline void\n-ipcp_method_cval_set (struct cgraph_node *mt, int i, struct ipcp_lattice *cval)\n-{\n-  IPA_NODE_REF (mt)->ipcp_lattices[i].type = cval->type;\n-  ipcp_cval_set_cvalue (ipcp_method_cval (mt, i),\n-\t\t\tipcp_cval_get_cvalue (cval), cval->type);\n-}\n-\n-/* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */\n-static inline void\n-ipcp_method_cval_set_cvalue_type (struct cgraph_node *mt, int i,\n-\t\t\t\t  enum ipa_lattice_type type)\n-{\n-  IPA_NODE_REF (mt)->ipcp_lattices[i].type = type;\n-}\n-\n-/* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */\n-static inline void\n-ipcp_method_cval_set_lattice_type (struct cgraph_node *mt, int i,\n-\t\t\t\t   enum ipa_lattice_type type)\n-{\n-  IPA_NODE_REF (mt)->ipcp_lattices[i].type = type;\n-}\n-\n-/* Print ipcp_cval data structures to F.  */\n+/* Print all ipcp_lattices of all functions to F.  */\n static void\n-ipcp_method_cval_print (FILE * f)\n+ipcp_print_all_lattices (FILE * f)\n {\n   struct cgraph_node *node;\n   int i, count;\n-  tree cvalue;\n \n-  fprintf (f, \"\\nCVAL PRINT\\n\");\n+  fprintf (f, \"\\nLATTICE PRINT\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"Printing cvals %s:\\n\", cgraph_node_name (node));\n-      count = ipa_get_param_count (IPA_NODE_REF (node));\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n+      fprintf (f, \"Printing lattices %s:\\n\", cgraph_node_name (node));\n+      count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  if (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i))\n-\t      == IPA_CONST_VALUE\n-\t      || ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) ==\n-\t      IPA_CONST_VALUE_REF)\n+\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  if (lat->type == IPA_CONST_VALUE || lat->type == IPA_CONST_VALUE_REF)\n \t    {\n \t      fprintf (f, \" param [%d]: \", i);\n \t      fprintf (f, \"type is CONST \");\n-\t      cvalue =\n-\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t      print_generic_expr (f, cvalue, 0);\n+\t      print_generic_expr (f, lat->constant, 0);\n \t      fprintf (f, \"\\n\");\n \t    }\n-\t  else if (ipcp_method_cval (node, i)->type == IPA_TOP)\n+\t  else if (lat->type == IPA_TOP)\n \t    fprintf (f, \"param [%d]: type is TOP  \\n\", i);\n \t  else\n \t    fprintf (f, \"param [%d]: type is BOTTOM  \\n\", i);\n \t}\n     }\n }\n \n-/* Initialize ipcp_cval array of MT with IPA_TOP values.\n-   All cvals for a method's formal parameters are initialized to IPA_BOTTOM\n-   The currently supported types are integer types, real types and\n-   Fortran constants (i.e. references to constants defined as\n-   const_decls). All other types are not analyzed and therefore are\n-   assigned with IPA_BOTTOM.  */\n+/* Initialize ipcp_lattices array.  The lattices corresponding to supported\n+   types (integers, real types and Fortran constants defined as const_decls)\n+   are initialized to IPA_TOP, the rest of them to IPA_BOTTOM.  */\n static void\n-ipcp_method_cval_init (struct cgraph_node *mt)\n+ipcp_initialize_node_lattices (struct cgraph_node *node)\n {\n   int i;\n-  tree parm_tree;\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  ipcp_formal_create (mt);\n-  for (i = 0; i < ipa_get_param_count (IPA_NODE_REF (mt)) ; i++)\n+  info->ipcp_lattices = XCNEWVEC (struct ipcp_lattice,\n+\t\t\t\t  ipa_get_param_count (info));\n+  for (i = 0; i < ipa_get_param_count (info) ; i++)\n     {\n-      parm_tree = ipa_get_ith_param (IPA_NODE_REF (mt), i);\n+      tree parm_tree = ipa_get_ith_param (info, i);\n+      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\n       if (INTEGRAL_TYPE_P (TREE_TYPE (parm_tree))\n \t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (parm_tree))\n \t  || POINTER_TYPE_P (TREE_TYPE (parm_tree)))\n-\tipcp_method_cval_set_cvalue_type (mt, i, IPA_TOP);\n+\tlat->type = IPA_TOP;\n       else\n-\tipcp_method_cval_set_cvalue_type (mt, i, IPA_BOTTOM);\n+\tlat->type = IPA_BOTTOM;\n     }\n }\n \n-/* Create a new assignment statment and make\n-   it the first statement in the function FN\n-   tree.\n-   PARM1 is the lhs of the assignment and\n-   VAL is the rhs. */\n+/* Create a new assignment statement and make it the first statement in the\n+   function.  PARM1 is the lhs of the assignment and VAL is the rhs. */\n static void\n constant_val_insert (tree parm1, tree val)\n {\n@@ -462,40 +356,38 @@ constant_val_insert (tree parm1, tree val)\n     }\n }\n \n-/* build INTEGER_CST tree with type TREE_TYPE and \n-   value according to CVALUE. Return the tree.   */\n+/* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n+   Return the tree.  */\n static tree\n-build_const_val (tree cvalue, enum ipa_lattice_type type, tree tree_type)\n+build_const_val (struct ipcp_lattice *lat, tree tree_type)\n {\n   tree const_val = NULL;\n \n-  gcc_assert (ipcp_type_is_const (type));\n-  const_val = fold_convert (tree_type, cvalue);\n+  gcc_assert (ipcp_lat_is_const (lat));\n+  const_val = fold_convert (tree_type, lat->constant);\n   return const_val;\n }\n \n-/* Build the tree representing the constant and call \n-   constant_val_insert().  */\n+/* Build the tree representing the constant and call constant_val_insert().  */\n static void\n-ipcp_propagate_const (struct cgraph_node *mt, int param,\n-\t\t      tree cvalue, enum ipa_lattice_type type)\n+ipcp_propagate_one_const (struct cgraph_node *node, int param,\n+\t\t\t  struct ipcp_lattice *lat)\n {\n   tree const_val;\n   tree parm_tree;\n \n   if (dump_file)\n-    fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (mt));\n-  parm_tree = ipa_get_ith_param (IPA_NODE_REF (mt), param);\n-  const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n+    fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (node));\n+  parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), param);\n+  const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n   constant_val_insert (parm_tree, const_val);\n }\n \n-/* Compute the proper scale for NODE.  It is the ratio between \n-   the number of direct calls (represented on the incoming \n-   cgraph_edges) and sum of all invocations of NODE (represented \n-   as count in cgraph_node). */\n+/* Compute the proper scale for NODE.  It is the ratio between the number of\n+   direct calls (represented on the incoming cgraph_edges) and sum of all\n+   invocations of NODE (represented as count in cgraph_node).  */\n static void\n-ipcp_method_compute_scale (struct cgraph_node *node)\n+ipcp_compute_node_scale (struct cgraph_node *node)\n {\n   gcov_type sum;\n   struct cgraph_edge *cs;\n@@ -505,15 +397,14 @@ ipcp_method_compute_scale (struct cgraph_node *node)\n   for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n     sum += cs->count;\n   if (node->count == 0)\n-    ipcp_method_set_scale (node, 0);\n+    ipcp_set_node_scale (node, 0);\n   else\n-    ipcp_method_set_scale (node, sum * REG_BR_PROB_BASE / node->count);\n+    ipcp_set_node_scale (node, sum * REG_BR_PROB_BASE / node->count);\n }\n \n-/* Initialization and computation of IPCP data structures. \n-   It is an intraprocedural\n-   analysis of methods, which gathers information to be propagated\n-   later on.  */\n+/* Initialization and computation of IPCP data structures.  This is the initial\n+   intraprocedural analysis of functions, which gathers information to be\n+   propagated later on.  */\n static void\n ipcp_init_stage (void)\n {\n@@ -524,9 +415,9 @@ ipcp_init_stage (void)\n     {\n       ipa_count_formal_params (node);\n       ipa_create_param_decls_array (node);\n-      ipcp_method_cval_init (node);\n+      ipcp_initialize_node_lattices (node);\n       ipa_detect_param_modifications (node);\n-      ipcp_method_compute_scale (node);\n+      ipcp_compute_node_scale (node);\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -547,10 +438,11 @@ ipcp_init_stage (void)\n     }\n }\n \n-/* Return true if there are some formal parameters whose value is IPA_TOP.\n-   Change their values to IPA_BOTTOM, since they weren't determined.  */\n+/* Return true if there are some formal parameters whose value is IPA_TOP (in\n+   the whole compilation unit).  Change their values to IPA_BOTTOM, since they\n+   most probably get their values from outside of this compilation unit.  */\n static bool\n-ipcp_after_propagate (void)\n+ipcp_change_tops_to_bottom (void)\n {\n   int i, count;\n   struct cgraph_node *node;\n@@ -559,56 +451,62 @@ ipcp_after_propagate (void)\n   prop_again = false;\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      count = ipa_get_param_count (IPA_NODE_REF (node));\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n+      count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n-\tif (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) == IPA_TOP)\n-\t  {\n-\t    prop_again = true;\n-\t    ipcp_method_cval_set_cvalue_type (node, i, IPA_BOTTOM);\n-\t  }\n+\t{\n+\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  if (lat->type == IPA_TOP)\n+\t    {\n+\t      prop_again = true;\n+\t      lat->type = IPA_BOTTOM;\n+\t    }\n+\t}\n     }\n   return prop_again;\n }\n \n-/* Interprocedural analysis. The algorithm propagates constants from\n-   the caller's parameters to the callee's arguments.  */\n+/* Interprocedural analysis. The algorithm propagates constants from the\n+   caller's parameters to the callee's arguments.  */\n static void\n ipcp_propagate_stage (void)\n {\n   int i;\n-  struct ipcp_lattice cval1 = { IPA_BOTTOM, NULL }, cval = { IPA_BOTTOM, NULL };\n-  struct ipcp_lattice *cval2;\n-  struct cgraph_node *mt, *callee;\n+  struct ipcp_lattice inc_lat = { IPA_BOTTOM, NULL };\n+  struct ipcp_lattice new_lat = { IPA_BOTTOM, NULL };\n+  struct ipcp_lattice *dest_lat;\n   struct cgraph_edge *cs;\n   struct ipa_jump_func *jump_func;\n-  enum jump_func_type type;\n-  union jump_func_value *jf_value;\n   struct ipa_func_list *wl;\n   int count;\n \n   /* Initialize worklist to contain all functions.  */\n   wl = ipa_init_func_list ();\n   while (wl)\n     {\n-      mt = ipa_pop_func_from_list (&wl);\n-      for (cs = mt->callees; cs; cs = cs->next_callee)\n+      struct cgraph_node *node = ipa_pop_func_from_list (&wl);\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n+\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n \t{\n-\t  callee = cs->callee;\n-\t  if (ipa_is_called_with_var_arguments (IPA_NODE_REF (callee)))\n+\t  struct ipa_node_params *callee_info = IPA_NODE_REF (cs->callee);\n+\t  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+\n+\t  if (ipa_is_called_with_var_arguments (callee_info))\n \t    continue;\n-\t  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+\n+\t  count = ipa_get_cs_argument_count (args);\n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t      type = jump_func->type;\n-\t      jf_value = &jump_func->value;\n-\t      ipcp_cval_compute (&cval1, mt, type, jf_value);\n-\t      cval2 = ipcp_method_cval (callee, i);\n-\t      ipcp_cval_meet (&cval, &cval1, cval2);\n-\t      if (ipcp_cval_changed (&cval, cval2))\n+\t      jump_func = ipa_get_ith_jump_func (args, i);\n+\t      ipcp_lattice_from_jfunc (info, &inc_lat, jump_func);\n+\t      dest_lat = ipcp_get_ith_lattice (callee_info, i);\n+\t      ipa_lattice_meet (&new_lat, &inc_lat, dest_lat);\n+\t      if (ipcp_lattice_changed (&new_lat, dest_lat))\n \t\t{\n-\t\t  ipcp_method_cval_set (callee, i, &cval);\n-\t\t  ipa_push_func_to_list (&wl, callee);\n+\t\t  dest_lat->type = new_lat.type;\n+\t\t  dest_lat->constant = new_lat.constant;\n+\t\t  ipa_push_func_to_list (&wl, cs->callee);\n \t\t}\n \t    }\n \t}\n@@ -621,25 +519,26 @@ static void\n ipcp_iterate_stage (void)\n {\n   ipcp_propagate_stage ();\n-  if (ipcp_after_propagate ())\n-    /* Some cvals have changed from IPA_TOP to IPA_BOTTOM.\n+  if (ipcp_change_tops_to_bottom ())\n+    /* Some lattices have changed from IPA_TOP to IPA_BOTTOM.\n        This change should be propagated.  */\n     ipcp_propagate_stage ();\n }\n \n-/* Check conditions to forbid constant insertion to MT.  */\n-static bool\n-ipcp_method_dont_insert_const (struct cgraph_node *mt)\n+/* Check conditions to forbid constant insertion to function described by\n+   NODE.  */\n+static inline bool\n+ipcp_node_not_modifiable_p (struct cgraph_node *node)\n {\n   /* ??? Handle pending sizes case.  */\n-  if (DECL_UNINLINABLE (mt->decl))\n+  if (DECL_UNINLINABLE (node->decl))\n     return true;\n   return false;\n }\n \n /* Print ipa_jump_func data structures to F.  */\n static void\n-ipcp_callsite_param_print (FILE * f)\n+ipcp_print_all_jump_functions (FILE * f)\n {\n   struct cgraph_node *node;\n   int i, count;\n@@ -687,35 +586,35 @@ ipcp_callsite_param_print (FILE * f)\n \n /* Print count scale data structures.  */\n static void\n-ipcp_method_scale_print (FILE * f)\n+ipcp_function_scale_print (FILE * f)\n {\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       fprintf (f, \"printing scale for %s: \", cgraph_node_name (node));\n       fprintf (f, \"value is  \" HOST_WIDE_INT_PRINT_DEC\n-\t       \"  \\n\", (HOST_WIDE_INT) ipcp_method_get_scale (node));\n+\t       \"  \\n\", (HOST_WIDE_INT) ipcp_get_node_scale (node));\n     }\n }\n \n /* Print counts of all cgraph nodes.  */\n static void\n-ipcp_profile_mt_count_print (FILE * f)\n+ipcp_print_func_profile_counts (FILE * f)\n {\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"method %s: \", cgraph_node_name (node));\n+      fprintf (f, \"function %s: \", cgraph_node_name (node));\n       fprintf (f, \"count is  \" HOST_WIDE_INT_PRINT_DEC\n \t       \"  \\n\", (HOST_WIDE_INT) node->count);\n     }\n }\n \n /* Print counts of all cgraph edges.  */\n static void\n-ipcp_profile_cs_count_print (FILE * f)\n+ipcp_print_call_profile_counts (FILE * f)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *cs;\n@@ -732,9 +631,9 @@ ipcp_profile_cs_count_print (FILE * f)\n     }\n }\n \n-/* Print all counts and probabilities of cfg edges of all methods.  */\n+/* Print all counts and probabilities of cfg edges of all functions.  */\n static void\n-ipcp_profile_edge_print (FILE * f)\n+ipcp_print_edge_profiles (FILE * f)\n {\n   struct cgraph_node *node;\n   basic_block bb;\n@@ -743,7 +642,7 @@ ipcp_profile_edge_print (FILE * f)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"method %s: \\n\", cgraph_node_name (node));\n+      fprintf (f, \"function %s: \\n\", cgraph_node_name (node));\n       if (DECL_SAVED_TREE (node->decl))\n \t{\n \t  bb =\n@@ -787,16 +686,16 @@ ipcp_profile_edge_print (FILE * f)\n     }\n }\n \n-/* Print counts and frequencies for all basic blocks of all methods.  */\n+/* Print counts and frequencies for all basic blocks of all functions.  */\n static void\n-ipcp_profile_bb_print (FILE * f)\n+ipcp_print_bb_profiles (FILE * f)\n {\n   basic_block bb;\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"method %s: \\n\", cgraph_node_name (node));\n+      fprintf (f, \"function %s: \\n\", cgraph_node_name (node));\n       if (node->analyzed)\n \t{\n \t  bb =\n@@ -826,49 +725,50 @@ ipcp_profile_bb_print (FILE * f)\n \n /* Print all IPCP data structures to F.  */\n static void\n-ipcp_structures_print (FILE * f)\n+ipcp_print_all_structures (FILE * f)\n {\n-  ipcp_method_cval_print (f);\n-  ipcp_method_scale_print (f);\n+  ipcp_print_all_lattices (f);\n+  ipcp_function_scale_print (f);\n   ipa_print_all_tree_maps (f);\n   ipa_print_all_params_modified (f);\n-  ipcp_callsite_param_print (f);\n+  ipcp_print_all_jump_functions (f);\n }\n \n-/* Print profile info for all methods.  */\n+/* Print profile info for all functions.  */\n static void\n-ipcp_profile_print (FILE * f)\n+ipcp_print_profile_data (FILE * f)\n {\n   fprintf (f, \"\\nNODE COUNTS :\\n\");\n-  ipcp_profile_mt_count_print (f);\n+  ipcp_print_func_profile_counts (f);\n   fprintf (f, \"\\nCS COUNTS stage:\\n\");\n-  ipcp_profile_cs_count_print (f);\n+  ipcp_print_call_profile_counts (f);\n   fprintf (f, \"\\nBB COUNTS and FREQUENCIES :\\n\");\n-  ipcp_profile_bb_print (f);\n+  ipcp_print_bb_profiles (f);\n   fprintf (f, \"\\nCFG EDGES COUNTS and PROBABILITIES :\\n\");\n-  ipcp_profile_edge_print (f);\n+  ipcp_print_edge_profiles (f);\n }\n \n-/* Build and initialize ipa_replace_map struct\n-   according to TYPE. This struct is read by versioning, which\n-   operates according to the flags sent.  PARM_TREE is the \n-   formal's tree found to be constant.  CVALUE represents the constant.  */\n+/* Build and initialize ipa_replace_map struct according to LAT. This struct is\n+   processed by versioning, which operates according to the flags set.\n+   PARM_TREE is the formal parameter found to be constant.  LAT represents the\n+   constant.  */\n static struct ipa_replace_map *\n-ipcp_replace_map_create (struct function *func, enum ipa_lattice_type type,\n-\t\t\t tree parm_tree, tree cvalue)\n+ipcp_create_replace_map (struct function *func, tree parm_tree,\n+\t\t\t struct ipcp_lattice *lat)\n {\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n-  gcc_assert (ipcp_type_is_const (type));\n-  if (type != IPA_CONST_VALUE_REF\n+  gcc_assert (ipcp_lat_is_const (lat));\n+  if (lat->type != IPA_CONST_VALUE_REF\n       && is_gimple_reg (parm_tree) && gimple_default_def (func, parm_tree)\n-\t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func, parm_tree)))\n+\t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func,\n+\t\t\t\t\t\t\t\t parm_tree)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"replacing param with const\\n\");\n-      const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n+      const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n       replace_map->old_tree =gimple_default_def (func, parm_tree);\n       replace_map->new_tree = const_val;\n       replace_map->replace_p = true;\n@@ -885,38 +785,32 @@ ipcp_replace_map_create (struct function *func, enum ipa_lattice_type type,\n   return replace_map;\n }\n \n-/* Return true if this callsite should be redirected to\n-   the orig callee (instead of the cloned one).  */\n+/* Return true if this callsite should be redirected to the original callee\n+   (instead of the cloned one).  */\n static bool\n-ipcp_redirect (struct cgraph_edge *cs)\n+ipcp_need_redirect_p (struct cgraph_edge *cs)\n {\n-  struct cgraph_node *caller, *callee, *orig_callee;\n+  struct ipa_node_params *orig_callee_info;\n   int i, count;\n   struct ipa_jump_func *jump_func;\n-  enum jump_func_type type;\n-  enum ipa_lattice_type lattice_type;\n \n-  caller = cs->caller;\n-  callee = cs->callee;\n-  orig_callee = ipcp_method_orig_node (callee);\n-  count = ipa_get_param_count (IPA_NODE_REF (orig_callee));\n+  orig_callee_info = IPA_NODE_REF (ipcp_get_orig_node (cs->callee));\n+  count = ipa_get_param_count (orig_callee_info);\n   for (i = 0; i < count; i++)\n     {\n-      lattice_type =\n-\tipcp_cval_get_cvalue_type (ipcp_method_cval (orig_callee, i));\n-      if (ipcp_type_is_const (lattice_type))\n+      struct ipcp_lattice *lat = ipcp_get_ith_lattice (orig_callee_info, i);\n+      if (ipcp_lat_is_const (lat))\n \t{\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  type = jump_func->type;\n-\t  if (type != IPA_CONST && type != IPA_CONST_REF)\n+\t  if (!ipcp_lat_is_const (lat))\n \t    return true;\n \t}\n     }\n \n   return false;\n }\n \n-/* Fix the callsites and the callgraph after function cloning was done.  */\n+/* Fix the callsites and the call graph after function cloning was done.  */\n static void\n ipcp_update_callgraph (void)\n {\n@@ -926,14 +820,14 @@ ipcp_update_callgraph (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       /* want to fix only original nodes  */\n-      if (ipcp_method_is_cloned (node))\n+      if (ipcp_node_is_clone (node))\n \tcontinue;\n       for (cs = node->callees; cs; cs = cs->next_callee)\n-\tif (ipcp_method_is_cloned (cs->callee))\n+\tif (ipcp_node_is_clone (cs->callee))\n \t  {\n \t    /* Callee is a cloned node  */\n-\t    orig_callee = ipcp_method_orig_node (cs->callee);\n-\t    if (ipcp_redirect (cs))\n+\t    orig_callee = ipcp_get_orig_node (cs->callee);\n+\t    if (ipcp_need_redirect_p (cs))\n \t      {\n \t\tcgraph_redirect_edge_callee (cs, orig_callee);\n \t\tTREE_OPERAND (CALL_EXPR_FN (get_call_expr_in (cs->call_stmt)),\n@@ -967,8 +861,8 @@ ipcp_update_edges_counts (struct cgraph_node *node, gcov_type scale)\n     e->count = e->count * scale / REG_BR_PROB_BASE;\n }\n \n-/* Update profiling info for versioned methods and the\n-   methods they were versioned from.  */\n+/* Update profiling info for versioned functions and the functions they were\n+   versioned from.  */\n static void\n ipcp_update_profiling (void)\n {\n@@ -978,10 +872,10 @@ ipcp_update_profiling (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      if (ipcp_method_is_cloned (node))\n+      if (ipcp_node_is_clone (node))\n \t{\n-\t  orig_node = ipcp_method_orig_node (node);\n-\t  scale = ipcp_method_get_scale (orig_node);\n+\t  orig_node = ipcp_get_orig_node (node);\n+\t  scale = ipcp_get_node_scale (orig_node);\n \t  node->count = orig_node->count * scale / REG_BR_PROB_BASE;\n \t  scale_complement = REG_BR_PROB_BASE - scale;\n \t  orig_node->count =\n@@ -1005,43 +899,41 @@ ipcp_insert_stage (void)\n {\n   struct cgraph_node *node, *node1 = NULL;\n   int i, const_param;\n-  tree cvalue;\n   VEC (cgraph_edge_p, heap) * redirect_callers;\n   varray_type replace_trees;\n   struct cgraph_edge *cs;\n   int node_callers, count;\n   tree parm_tree;\n-  enum ipa_lattice_type type;\n   struct ipa_replace_map *replace_param;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n       /* Propagation of the constant is forbidden in \n          certain conditions.  */\n-      if (!node->analyzed || ipcp_method_dont_insert_const (node)\n-          || ipa_is_called_with_var_arguments (IPA_NODE_REF (node)))\n+      if (!node->analyzed || ipcp_node_not_modifiable_p (node)\n+\t  || ipa_is_called_with_var_arguments (info))\n \tcontinue;\n       const_param = 0;\n-      count = ipa_get_param_count (IPA_NODE_REF (node));\n+      count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n-\t  if (ipcp_type_is_const (type))\n+\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  if (ipcp_lat_is_const (lat))\n \t    const_param++;\n \t}\n       if (const_param == 0)\n \tcontinue;\n       VARRAY_GENERIC_PTR_INIT (replace_trees, const_param, \"replace_trees\");\n       for (i = 0; i < count; i++)\n \t{\n-\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n-\t  if (ipcp_type_is_const (type))\n+\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  if (ipcp_lat_is_const (lat))\n \t    {\n-\t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t      parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), i);\n+\t      parm_tree = ipa_get_ith_param (info, i);\n \t      replace_param =\n-\t\tipcp_replace_map_create (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t\t\t\t type, parm_tree, cvalue);\n+\t\tipcp_create_replace_map (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t\t parm_tree, lat);\n \t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n \t    }\n \t}\n@@ -1063,7 +955,7 @@ ipcp_insert_stage (void)\n       if (dump_file)\n \tfprintf (dump_file, \"versioned function %s\\n\",\n \t\t cgraph_node_name (node));\n-      ipcp_cloned_create (node, node1);\n+      ipcp_init_cloned_node (node, node1);\n       if (const_param > 0)\n \t{\n \t  push_cfun (DECL_STRUCT_FUNCTION (node1->decl));\n@@ -1072,13 +964,13 @@ ipcp_insert_stage (void)\n \n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n-\t      if (ipcp_type_is_const (type))\n+\t      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t      if (ipcp_lat_is_const (lat))\n \t\t{\n-\t\t  cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t\t  parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), i);\n-\t\t  if (type != IPA_CONST_VALUE_REF && !is_gimple_reg (parm_tree))\n-\t\t    ipcp_propagate_const (node1, i, cvalue, type);\n+\t\t  parm_tree = ipa_get_ith_param (info, i);\n+\t\t  if (lat->type != IPA_CONST_VALUE_REF\n+\t\t      && !is_gimple_reg (parm_tree))\n+\t\t    ipcp_propagate_one_const (node1, i, lat);\n \t\t}\n \t    }\n \t  if (gimple_in_ssa_p (cfun))\n@@ -1114,23 +1006,23 @@ ipcp_driver (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n-      ipcp_structures_print (dump_file);\n+      ipcp_print_all_structures (dump_file);\n     }\n   /* 2. Do the interprocedural propagation.  */\n   ipcp_iterate_stage ();\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIPA structures after propagation:\\n\");\n-      ipcp_structures_print (dump_file);\n+      ipcp_print_all_structures (dump_file);\n       fprintf (dump_file, \"\\nProfiling info before insert stage:\\n\");\n-      ipcp_profile_print (dump_file);\n+      ipcp_print_profile_data (dump_file);\n     }\n   /* 3. Insert the constants found to the functions.  */\n   ipcp_insert_stage ();\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nProfiling info after insert stage:\\n\");\n-      ipcp_profile_print (dump_file);\n+      ipcp_print_profile_data (dump_file);\n     }\n   /* Free all IPCP structures.  */\n   ipa_free_all_node_params ();"}]}