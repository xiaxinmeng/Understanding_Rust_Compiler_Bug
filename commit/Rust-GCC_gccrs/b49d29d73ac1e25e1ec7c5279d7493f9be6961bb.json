{"sha": "b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5ZDI5ZDczYWMxZTI1ZTFlYzdjNTI3OWQ3NDkzZjliZTY5NjFiYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-28T14:44:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-28T14:44:08Z"}, "message": "Fix profile adjusments while cloning\n\nThis patch fixes profile updates while cloning.  When new clone is produced\nits global profile is subtracted from the original function.  If the original\nfunction profile drops to 0 we want to switch from global profiles to global0\nprofiles which is implemented by combine_with_ipa_count_within.\n\nHowever this is done on all edges independnetly and it may happen that we end\nup combining global and globa0 profiles in one functions which is not a good\nidea.\n\nThis implements profile_count::combine_with_ipa_count_within which is able\nto take into account that the counter is inside function with a given count.\n\n\t* profile-count.h (profile_count::combine_with_ipa_count_within):\n\tDeclare.\n\t* profile-count.c (profile_count::combine_with_ipa_count_within):\n\tNew.\n\t* cgraphclones.c (cgraph_edge::clone, cgraph_node::create_clone): Use\n\tit.\n\nFrom-SVN: r278810", "tree": {"sha": "226f1a5e36253ed76580b40f21d20e56fd1212ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/226f1a5e36253ed76580b40f21d20e56fd1212ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/comments", "author": null, "committer": null, "parents": [{"sha": "eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb081fd0e2cb852c3cf0ef09da497ed3fee77029"}], "stats": {"total": 149, "additions": 141, "deletions": 8}, "files": [{"sha": "064dd8ef83e25bdbffba826a26dea94801504973", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "patch": "@@ -1,3 +1,12 @@\n+2019-11-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* profile-count.h (profile_count::combine_with_ipa_count_within):\n+\tDeclare.\n+\t* profile-count.c (profile_count::combine_with_ipa_count_within):\n+\tNew.\n+\t* cgraphclones.c (cgraph_edge::clone, cgraph_node::create_clone): Use\n+\tit.\n+\n 2019-11-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.c (ipa_merge_profiles): Be sure that all type transtions"}, {"sha": "64ff1c0654bb4c64809ddfe6187e59bb330efa60", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "patch": "@@ -80,6 +80,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"dumpfile.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"tree-vrp.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-fnsummary.h\"\n \n /* Create clone of edge in the node N represented by CALL_EXPR\n    the callgraph.  */\n@@ -136,8 +141,9 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \n   /* Update IPA profile.  Local profiles need no updating in original.  */\n   if (update_original)\n-    count = count.combine_with_ipa_count (count.ipa () \n-\t\t\t\t\t  - new_edge->count.ipa ());\n+    count = count.combine_with_ipa_count_within (count.ipa () \n+\t\t\t\t\t\t - new_edge->count.ipa (),\n+\t\t\t\t\t\t caller->count);\n   symtab->call_edge_duplication_hooks (this, new_edge);\n   return new_edge;\n }\n@@ -268,6 +274,8 @@ cgraph_node::expand_all_artificial_thunks ()\n \t    thunk->thunk.thunk_p = false;\n \t    thunk->analyze ();\n \t  }\n+\tipa_analyze_node (thunk);\n+\tinline_analyze_function (thunk);\n \tthunk->expand_all_artificial_thunks ();\n       }\n     else\n@@ -341,7 +349,14 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n \n   /* Update IPA profile.  Local profiles need no updating in original.  */\n   if (update_original)\n-    count = count.combine_with_ipa_count (count.ipa () - prof_count.ipa ());\n+    {\n+      if (inlined_to)\n+        count = count.combine_with_ipa_count_within (count.ipa ()\n+\t\t\t\t\t\t     - prof_count.ipa (),\n+\t\t\t\t\t\t     inlined_to->count);\n+      else\n+        count = count.combine_with_ipa_count (count.ipa () - prof_count.ipa ());\n+    }\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n   new_node->origin = origin;"}, {"sha": "d0800b29d70515bb257848c5024aa80b71b94f85", "filename": "gcc/profile-count.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"wide-int.h\"\n #include \"sreal.h\"\n+#include \"selftest.h\"\n \n /* Names from profile_quality enum values.  */\n \n@@ -291,6 +292,7 @@ profile_count::to_cgraph_frequency (profile_count entry_bb_count) const\n     return 0;\n   gcc_checking_assert (entry_bb_count.initialized_p ());\n   uint64_t scale;\n+  gcc_checking_assert (compatible_p (entry_bb_count));\n   if (!safe_scale_64bit (!entry_bb_count.m_val ? m_val + 1 : m_val,\n \t\t\t CGRAPH_FREQ_BASE, MAX (1, entry_bb_count.m_val), &scale))\n     return CGRAPH_FREQ_MAX;\n@@ -328,6 +330,7 @@ profile_count::to_sreal_scale (profile_count in, bool *known) const\n     return 0;\n   if (m_val == in.m_val)\n     return 1;\n+  gcc_checking_assert (compatible_p (in));\n \n   if (!in.m_val)\n     {\n@@ -373,6 +376,8 @@ profile_count::adjust_for_ipa_scaling (profile_count *num,\n profile_count\n profile_count::combine_with_ipa_count (profile_count ipa)\n {\n+  if (!initialized_p ())\n+    return *this;\n   ipa = ipa.ipa ();\n   if (ipa.nonzero_p ())\n     return ipa;\n@@ -383,6 +388,23 @@ profile_count::combine_with_ipa_count (profile_count ipa)\n   return this->global0adjusted ();\n }\n \n+/* Sae as profile_count::combine_with_ipa_count but within function with count\n+   IPA2.  */\n+profile_count\n+profile_count::combine_with_ipa_count_within (profile_count ipa,\n+\t\t\t\t\t      profile_count ipa2)\n+{\n+  profile_count ret;\n+  if (!initialized_p ())\n+    return *this;\n+  if (ipa2.ipa () == ipa2 && ipa.initialized_p ())\n+    ret = ipa;\n+  else\n+    ret = combine_with_ipa_count (ipa);\n+  gcc_checking_assert (ret.compatible_p (ipa2));\n+  return ret;\n+}\n+\n /* The profiling runtime uses gcov_type, which is usually 64bit integer.\n    Conversions back and forth are used to read the coverage and get it\n    into internal representation.  */\n@@ -425,3 +447,65 @@ profile_probability::combine_with_count (profile_count count1,\n   else\n     return *this * even () + other * even ();\n }\n+\n+#if CHECKING_P\n+namespace selftest {\n+\n+/* Verify non-trivial type conversions for IPA scaling.  This happens often\n+   during inlining.  */\n+\n+static void\n+profile_count_verify_ipa_scaling (void)\n+{\n+  profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n+  profile_count cnt2 = profile_count::from_gcov_type (2);\n+  profile_count cnt3 = profile_count::from_gcov_type (8);\n+  profile_count cnt4 = cnt3.apply_scale (cnt1, cnt2);\n+\n+  /* Result should be 16 with GUESSED_GLOBAL0.  */\n+  ASSERT_EQ (cnt4.ipa (), profile_count::zero ());\n+  ASSERT_EQ (cnt4.to_gcov_type (), 16);\n+\n+  cnt1 = profile_count::from_gcov_type (4).global0adjusted ();\n+  cnt4 = cnt3.apply_scale (cnt1, cnt2);\n+  /* Result should be 16 with GUESSED_GLOBAL0_ADJUSTED.  */\n+  ASSERT_EQ (cnt4.ipa (), profile_count::adjusted_zero ());\n+  ASSERT_EQ (cnt4.to_gcov_type (), 16);\n+}\n+\n+/* Verify non-trivial cases of sreal scale calculations.  */\n+\n+static void\n+profile_count_verify_to_sreal_scale (void)\n+{\n+  profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n+  profile_count cnt2 = profile_count::from_gcov_type (8);\n+\n+  /* If count is globally 0 it should have 0 scale in non-zero global count.  */\n+  ASSERT_EQ (cnt1.to_sreal_scale (cnt2), 0);\n+}\n+\n+/* Verify non-trivial cases of probability_in calculations.  */\n+\n+static void\n+profile_count_verify_probability_in (void)\n+{\n+  /*profile_count cnt1 = profile_count::from_gcov_type (4).global0 ();\n+  profile_count cnt2 = profile_count::from_gcov_type (8);*/\n+\n+  /* If count is globally 0 it should have 0 probability in non-zero global\n+     count.  */\n+  /*ASSERT_EQ (cnt1.probability_in (cnt2), profile_probability::never ());*/\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void profile_count_c_tests (void)\n+{\n+  profile_count_verify_ipa_scaling ();\n+  profile_count_verify_to_sreal_scale ();\n+  profile_count_verify_probability_in ();\n+}\n+\n+}\n+#endif"}, {"sha": "9af8d606bc49f7ec2bb62c0489e1278c78925261", "filename": "gcc/profile-count.h", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d29d73ac1e25e1ec7c5279d7493f9be6961bb/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=b49d29d73ac1e25e1ec7c5279d7493f9be6961bb", "patch": "@@ -700,6 +700,7 @@ struct GTY(()) profile_count\n   uint64_t UINT64_BIT_FIELD_ALIGN m_val : n_bits;\n #undef UINT64_BIT_FIELD_ALIGN\n   enum profile_quality m_quality : 3;\n+public:\n \n   /* Return true if both values can meaningfully appear in single function\n      body.  We have either all counters in function local or global, otherwise\n@@ -711,9 +712,18 @@ struct GTY(()) profile_count\n       if (*this == zero ()\n \t  || other == zero ())\n \treturn true;\n+      /* Do not allow nonzero global profile together with local guesses\n+\t that are globally0.  */\n+      if (ipa ().nonzero_p ()\n+\t  && !(other.ipa () == other))\n+\treturn false;\n+      if (other.ipa ().nonzero_p ()\n+\t  && !(ipa () == *this))\n+\treturn false;\n+\t\n       return ipa_p () == other.ipa_p ();\n     }\n-public:\n+\n   /* Used for counters which are expected to be never executed.  */\n   static profile_count zero ()\n     {\n@@ -992,6 +1002,14 @@ struct GTY(()) profile_count\n \n   profile_count max (profile_count other) const\n     {\n+      profile_count val = *this;\n+\n+      /* Always prefer nonzero IPA counts over local counts.  */\n+      if (ipa ().nonzero_p () || other.ipa ().nonzero_p ())\n+\t{\n+\t  val = ipa ();\n+\t  other = other.ipa ();\n+\t}\n       if (!initialized_p ())\n \treturn other;\n       if (!other.initialized_p ())\n@@ -1001,8 +1019,8 @@ struct GTY(()) profile_count\n       if (other == zero ())\n \treturn *this;\n       gcc_checking_assert (compatible_p (other));\n-      if (m_val < other.m_val || (m_val == other.m_val\n-\t\t\t\t  && m_quality < other.m_quality))\n+      if (val.m_val < other.m_val || (m_val == other.m_val\n+\t\t\t\t      && val.m_quality < other.m_quality))\n \treturn other;\n       return *this;\n     }\n@@ -1061,6 +1079,7 @@ struct GTY(()) profile_count\n     {\n       if (*this == zero ())\n \treturn *this;\n+\n       if (num == zero ())\n \treturn num;\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n@@ -1075,7 +1094,9 @@ struct GTY(()) profile_count\n       ret.m_val = MIN (val, max_count);\n       ret.m_quality = MIN (MIN (MIN (m_quality, ADJUSTED),\n \t\t\t        num.m_quality), den.m_quality);\n-      if (num.ipa_p () && !ret.ipa_p ())\n+      /* Be sure that ret is not local or global0 type \n+\t if num is global.  */\n+      if (num.ipa_p () && (!ret.ipa_p () || !(ret.ipa () == ret)))\n \tret.m_quality = MIN (num.m_quality, GUESSED);\n       return ret;\n     }\n@@ -1153,8 +1174,8 @@ struct GTY(()) profile_count\n       if (*this == overall && m_quality == PRECISE)\n \treturn profile_probability::always ();\n       profile_probability ret;\n-      gcc_checking_assert (compatible_p (overall));\n \n+      gcc_checking_assert (compatible_p (overall));\n       if (overall.m_val < m_val)\n \t{\n \t  ret.m_val = profile_probability::max_probability;\n@@ -1194,6 +1215,10 @@ struct GTY(()) profile_count\n      global0.  */\n   profile_count combine_with_ipa_count (profile_count ipa);\n \n+  /* Same as combine_with_ipa_count but inside function with count IPA2.  */\n+  profile_count combine_with_ipa_count_within\n+\t\t (profile_count ipa, profile_count ipa2);\n+\n   /* The profiling runtime uses gcov_type, which is usually 64bit integer.\n      Conversions back and forth are used to read the coverage and get it\n      into internal representation.  */"}]}