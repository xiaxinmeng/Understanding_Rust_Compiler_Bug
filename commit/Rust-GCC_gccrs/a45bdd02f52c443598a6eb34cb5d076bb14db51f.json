{"sha": "a45bdd02f52c443598a6eb34cb5d076bb14db51f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1YmRkMDJmNTJjNDQzNTk4YTZlYjM0Y2I1ZDA3NmJiMTRkYjUxZg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-09T14:05:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-09T14:05:13Z"}, "message": "calls.c (compute_argument_addresses): New function.\n\n        * calls.c (compute_argument_addresses): New function.\n        (rtx_for_function_call): New function.\n        (expand_call): Use them.\n\nFrom-SVN: r25653", "tree": {"sha": "26dcdf114cd5c4ff7201c7253fe1a5cec9970f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26dcdf114cd5c4ff7201c7253fe1a5cec9970f48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a45bdd02f52c443598a6eb34cb5d076bb14db51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45bdd02f52c443598a6eb34cb5d076bb14db51f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45bdd02f52c443598a6eb34cb5d076bb14db51f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45bdd02f52c443598a6eb34cb5d076bb14db51f/comments", "author": null, "committer": null, "parents": [{"sha": "91e1a7f5aaa8b2172c09642ed7944024c86c69c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e1a7f5aaa8b2172c09642ed7944024c86c69c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e1a7f5aaa8b2172c09642ed7944024c86c69c8"}], "stats": {"total": 181, "additions": 110, "deletions": 71}, "files": [{"sha": "296814ebe03aca74e668f59635818b365d565926", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45bdd02f52c443598a6eb34cb5d076bb14db51f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45bdd02f52c443598a6eb34cb5d076bb14db51f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a45bdd02f52c443598a6eb34cb5d076bb14db51f", "patch": "@@ -11,6 +11,10 @@ Tue Mar  9 09:33:16 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Tue Mar  9 02:08:17 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (compute_argument_addresses): New function.\n+\t(rtx_for_function_call): New function.\n+\t(expand_call): Use them.\n+\n \t* i386.md (zero_extendhisi2): Split into an expander and anonymous\n \tpattern.  Add new anonymous pattern for use when optimizing for\n \tsize or for the PPro."}, {"sha": "a30bde9e37cb5cbe43841973d8b97b3d4f06ed62", "filename": "gcc/calls.c", "status": "modified", "additions": 106, "deletions": 71, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45bdd02f52c443598a6eb34cb5d076bb14db51f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45bdd02f52c443598a6eb34cb5d076bb14db51f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a45bdd02f52c443598a6eb34cb5d076bb14db51f", "patch": "@@ -152,7 +152,10 @@ static void initialize_argument_information\tPROTO ((int,\n \t\t\t\t\t\t\tCUMULATIVE_ARGS *,\n \t\t\t\t\t\t\tint, rtx *, int *,\n \t\t\t\t\t\t\tint *, int *));\n-\n+static void compute_argument_addresses\t\tPROTO ((struct arg_data *,\n+\t\t\t\t\t\t\trtx, int));\n+static rtx rtx_for_function_call\t\tPROTO ((tree, tree));\n+\t\t\t\t\t\t\t\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n static void restore_fixed_argument_area\tPROTO ((rtx, rtx, int, int));\n@@ -1313,6 +1316,106 @@ finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n   return must_preallocate;\n }\n \n+/* If we preallocated stack space, compute the address of each argument\n+   and store it into the ARGS array.\n+\n+   We need not ensure it is a valid memory address here; it will be \n+   validized when it is used.\n+\n+   ARGBLOCK is an rtx for the address of the outgoing arguments.  */\n+\n+static void\n+compute_argument_addresses (args, argblock, num_actuals)\n+     struct arg_data *args;\n+     rtx argblock;\n+     int num_actuals;\n+{\n+  if (argblock)\n+    {\n+      rtx arg_reg = argblock;\n+      int i, arg_offset = 0;\n+\n+      if (GET_CODE (argblock) == PLUS)\n+\targ_reg = XEXP (argblock, 0), arg_offset = INTVAL (XEXP (argblock, 1));\n+\n+      for (i = 0; i < num_actuals; i++)\n+\t{\n+\t  rtx offset = ARGS_SIZE_RTX (args[i].offset);\n+\t  rtx slot_offset = ARGS_SIZE_RTX (args[i].slot_offset);\n+\t  rtx addr;\n+\n+\t  /* Skip this parm if it will not be passed on the stack.  */\n+\t  if (! args[i].pass_on_stack && args[i].reg != 0)\n+\t    continue;\n+\n+\t  if (GET_CODE (offset) == CONST_INT)\n+\t    addr = plus_constant (arg_reg, INTVAL (offset));\n+\t  else\n+\t    addr = gen_rtx_PLUS (Pmode, arg_reg, offset);\n+\n+\t  addr = plus_constant (addr, arg_offset);\n+\t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n+\t  MEM_SET_IN_STRUCT_P \n+\t    (args[i].stack,\n+\t     AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value)));\n+\n+\t  if (GET_CODE (slot_offset) == CONST_INT)\n+\t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n+\t  else\n+\t    addr = gen_rtx_PLUS (Pmode, arg_reg, slot_offset);\n+\n+\t  addr = plus_constant (addr, arg_offset);\n+\t  args[i].stack_slot = gen_rtx_MEM (args[i].mode, addr);\n+\t}\n+    }\n+}\n+\t\t\t\t\t       \n+/* Given a FNDECL and EXP, return an rtx suitable for use as a target address\n+   in a call instruction.\n+\n+   FNDECL is the tree node for the target function.  For an indirect call\n+   FNDECL will be NULL_TREE.\n+\n+   EXP is the CALL_EXPR for this call.  */\n+\n+static rtx\n+rtx_for_function_call (fndecl, exp)\n+     tree fndecl;\n+     tree exp;\n+{\n+  rtx funexp;\n+\n+  /* Get the function to call, in the form of RTL.  */\n+  if (fndecl)\n+    {\n+      /* If this is the first use of the function, see if we need to\n+\t make an external definition for it.  */\n+      if (! TREE_USED (fndecl))\n+\t{\n+\t  assemble_external (fndecl);\n+\t  TREE_USED (fndecl) = 1;\n+\t}\n+\n+      /* Get a SYMBOL_REF rtx for the function address.  */\n+      funexp = XEXP (DECL_RTL (fndecl), 0);\n+    }\n+  else\n+    /* Generate an rtx (probably a pseudo-register) for the address.  */\n+    {\n+      push_temp_slots ();\n+      funexp = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+      pop_temp_slots ();\t/* FUNEXP can't be BLKmode */\n+\n+      /* Check the function is executable.  */\n+      if (current_function_check_memory_usage)\n+\temit_library_call (chkr_check_exec_libfunc, 1,\n+\t\t\t   VOIDmode, 1,\n+\t\t\t   funexp, ptr_mode);\n+      emit_queue ();\n+    }\n+  return funexp;\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1971,49 +2074,8 @@ expand_call (exp, target, ignore)\n       }\n #endif\n \n+  compute_argument_addresses (args, argblock, num_actuals);\n \n-  /* If we preallocated stack space, compute the address of each argument.\n-     We need not ensure it is a valid memory address here; it will be \n-     validized when it is used.  */\n-  if (argblock)\n-    {\n-      rtx arg_reg = argblock;\n-      int arg_offset = 0;\n-\n-      if (GET_CODE (argblock) == PLUS)\n-\targ_reg = XEXP (argblock, 0), arg_offset = INTVAL (XEXP (argblock, 1));\n-\n-      for (i = 0; i < num_actuals; i++)\n-\t{\n-\t  rtx offset = ARGS_SIZE_RTX (args[i].offset);\n-\t  rtx slot_offset = ARGS_SIZE_RTX (args[i].slot_offset);\n-\t  rtx addr;\n-\n-\t  /* Skip this parm if it will not be passed on the stack.  */\n-\t  if (! args[i].pass_on_stack && args[i].reg != 0)\n-\t    continue;\n-\n-\t  if (GET_CODE (offset) == CONST_INT)\n-\t    addr = plus_constant (arg_reg, INTVAL (offset));\n-\t  else\n-\t    addr = gen_rtx_PLUS (Pmode, arg_reg, offset);\n-\n-\t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n-\t  MEM_SET_IN_STRUCT_P \n-\t    (args[i].stack,\n-\t     AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value)));\n-\n-\t  if (GET_CODE (slot_offset) == CONST_INT)\n-\t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n-\t  else\n-\t    addr = gen_rtx_PLUS (Pmode, arg_reg, slot_offset);\n-\n-\t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack_slot = gen_rtx_MEM (args[i].mode, addr);\n-\t}\n-    }\n-\t\t\t\t\t       \n #ifdef PUSH_ARGS_REVERSED\n #ifdef PREFERRED_STACK_BOUNDARY\n   /* If we push args individually in reverse order, perform stack alignment\n@@ -2028,34 +2090,7 @@ expand_call (exp, target, ignore)\n   if (argblock)\n     NO_DEFER_POP;\n \n-  /* Get the function to call, in the form of RTL.  */\n-  if (fndecl)\n-    {\n-      /* If this is the first use of the function, see if we need to\n-\t make an external definition for it.  */\n-      if (! TREE_USED (fndecl))\n-\t{\n-\t  assemble_external (fndecl);\n-\t  TREE_USED (fndecl) = 1;\n-\t}\n-\n-      /* Get a SYMBOL_REF rtx for the function address.  */\n-      funexp = XEXP (DECL_RTL (fndecl), 0);\n-    }\n-  else\n-    /* Generate an rtx (probably a pseudo-register) for the address.  */\n-    {\n-      push_temp_slots ();\n-      funexp = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n-      pop_temp_slots ();\t/* FUNEXP can't be BLKmode */\n-\n-      /* Check the function is executable.  */\n-      if (current_function_check_memory_usage)\n-\temit_library_call (chkr_check_exec_libfunc, 1,\n-\t\t\t   VOIDmode, 1,\n-\t\t\t   funexp, ptr_mode);\n-      emit_queue ();\n-    }\n+  funexp = rtx_for_function_call (fndecl, exp);\n \n   /* Figure out the register where the value, if any, will come back.  */\n   valreg = 0;"}]}