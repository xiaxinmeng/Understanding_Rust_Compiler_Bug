{"sha": "ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0Zjc5NjhiNWFiZTc1YmE2YzIwZWFhMGRlNmZjODg4MDZkZWFlZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-06-02T21:09:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-02T21:09:54Z"}, "message": "loop.c (emit_prefetch_instructions): Properly place the address computation.\n\n\n\n\t* loop.c (emit_prefetch_instructions): Properly place the address computation.\n\n\n\t* basic-block.h (basic_block_for_insn, BLOCK_FOR_INSN): Kill.\n\t(set_block_for_insn): Turn into macro.\n\t* cfgbuild.c (find_basic_block): Do not clear basic_block_for_insn.\n\t* cfglayout.c (insn_scopes): Kill.\n\t(scope_to_insns_initialize): Do not use insn_scopes.\n\t(scope_to_insns_finalize): Likewise.\n\t(duplicate_insn_chain): Likewise.\n\t(cfg_layout_initialize, cfg_layout_finalize): Do not turn scopes to notes.\n\t* cfgrtl.c (basic_block_for_insn): Kill.\n\t(delete_insn_and_edges, delete_insn_chain_and_edges): Simplify.\n\t(create_basic_block_structure): Use reorder_insns.\n\t(compute_bb_for_insn): Do not use basic_block_for_insn.\n\t(merge_blocks_nomove): Likewise.\n\t(update_bb_for_insn): Likewise.\n\t(verify_flow_info): Likewise.\n\t(set_block_for_insn): Kill.\n\t* combine.c (try_combine): Update gen_rtx_INSN call.\n\t* emit-rtl.c (gen_label_rtx): Update gen_rtx_CODE_LABEL call.\n\t(mark_insn_raw, make_jump_insn_raw, make_call_insn_raw): Clear\n\tscopes and BBs.\n\t(add_insn_after, add_insn_before, remove_insn, reorder_insns): Simplify.\n\t(emit_note_before, emit_note_after, emit_line_note_after, emit_note):\n\tClear BB.\n\t(emit_insns_after): Simplify.\n\t(emit_copy_of_insn_after): Copy scope.\n\t* final.c (final_start_function): Lower scopes.\n\t* flow.c (check_function_return_warnings): Do not rely on deleted insn.\n\t* integrate.c (copy_insn_list): Cope scopes.\n\t* jump.c (duplicate_loop_exit_test): LIkewise; simplify.\n\t* loop.c (loop_optimize): Do not care block notes.\n\t* print-rtl.c (print_rtx): Print BB.\n\t* recog.c (apply_change_group): Simplify.\n\t* rtl.c (copy_rtx): Handle 'B'.\n\t* rtl.def (INSN, CALL_INSN, JUMP_INSN, NOTE): Add extra fields.\n\t* rtl.h (Field accessors): Update indexes.\n\t* sched-ebb.c (schedule_ebbs): Do not lower notes.\n\t* sched-rgn.c (schedule_insns): Likewise.\n\t* toplev.c (rest_of_compilation): Lower notes.\n\t* unroll.c (unroll_loop): Do not care scoping notes.\n\t(copy_loop_body): Copy scopes.\n\nFrom-SVN: r54188", "tree": {"sha": "cefa93bd4b55c17cc93db52e0412035b33082f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cefa93bd4b55c17cc93db52e0412035b33082f45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/comments", "author": null, "committer": null, "parents": [{"sha": "537fc532be12254466f5d19fbaf40dc5016d6f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537fc532be12254466f5d19fbaf40dc5016d6f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537fc532be12254466f5d19fbaf40dc5016d6f81"}], "stats": {"total": 395, "additions": 169, "deletions": 226}, "files": [{"sha": "5243079f11f76a278660c4762974e8c9920fd902", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -1,3 +1,50 @@\n+Sun Jun  2 23:02:11 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (emit_prefetch_instructions): Properly place the address computation.\n+\n+Sun Jun  2 22:56:48 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (basic_block_for_insn, BLOCK_FOR_INSN): Kill.\n+\t(set_block_for_insn): Turn into macro.\n+\t* cfgbuild.c (find_basic_block): Do not clear basic_block_for_insn.\n+\t* cfglayout.c (insn_scopes): Kill.\n+\t(scope_to_insns_initialize): Do not use insn_scopes.\n+\t(scope_to_insns_finalize): Likewise.\n+\t(duplicate_insn_chain): Likewise.\n+\t(cfg_layout_initialize, cfg_layout_finalize): Do not turn scopes to notes.\n+\t* cfgrtl.c (basic_block_for_insn): Kill.\n+\t(delete_insn_and_edges, delete_insn_chain_and_edges): Simplify.\n+\t(create_basic_block_structure): Use reorder_insns.\n+\t(compute_bb_for_insn): Do not use basic_block_for_insn.\n+\t(merge_blocks_nomove): Likewise.\n+\t(update_bb_for_insn): Likewise.\n+\t(verify_flow_info): Likewise.\n+\t(set_block_for_insn): Kill.\n+\t* combine.c (try_combine): Update gen_rtx_INSN call.\n+\t* emit-rtl.c (gen_label_rtx): Update gen_rtx_CODE_LABEL call.\n+\t(mark_insn_raw, make_jump_insn_raw, make_call_insn_raw): Clear\n+\tscopes and BBs.\n+\t(add_insn_after, add_insn_before, remove_insn, reorder_insns): Simplify.\n+\t(emit_note_before, emit_note_after, emit_line_note_after, emit_note):\n+\tClear BB.\n+\t(emit_insns_after): Simplify.\n+\t(emit_copy_of_insn_after): Copy scope.\n+\t* final.c (final_start_function): Lower scopes.\n+\t* flow.c (check_function_return_warnings): Do not rely on deleted insn.\n+\t* integrate.c (copy_insn_list): Cope scopes.\n+\t* jump.c (duplicate_loop_exit_test): LIkewise; simplify.\n+\t* loop.c (loop_optimize): Do not care block notes.\n+\t* print-rtl.c (print_rtx): Print BB.\n+\t* recog.c (apply_change_group): Simplify.\n+\t* rtl.c (copy_rtx): Handle 'B'.\n+\t* rtl.def (INSN, CALL_INSN, JUMP_INSN, NOTE): Add extra fields.\n+\t* rtl.h (Field accessors): Update indexes.\n+\t* sched-ebb.c (schedule_ebbs): Do not lower notes.\n+\t* sched-rgn.c (schedule_insns): Likewise.\n+\t* toplev.c (rest_of_compilation): Lower notes.\n+\t* unroll.c (unroll_loop): Do not care scoping notes.\n+\t(copy_loop_body): Copy scopes.\n+\n 2002-06-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n config/h8300:"}, {"sha": "3f015a83434b40fbdb2ccfd3c12cbeac906e9dde", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -303,14 +303,12 @@ extern struct basic_block_def entry_exit_blocks[2];\n #define ENTRY_BLOCK_PTR\t(&entry_exit_blocks[0])\n #define EXIT_BLOCK_PTR\t(&entry_exit_blocks[1])\n \n-extern varray_type basic_block_for_insn;\n-#define BLOCK_FOR_INSN(INSN)  VARRAY_BB (basic_block_for_insn, INSN_UID (INSN))\n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n+#define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)\n \n extern void compute_bb_for_insn\t\tPARAMS ((int));\n extern void free_bb_for_insn\t\tPARAMS ((void));\n extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n-extern void set_block_for_insn\t\tPARAMS ((rtx, basic_block));\n \n extern void free_basic_block_vars\tPARAMS ((int));\n "}, {"sha": "0352fbe52a039c227b46e655ed8c32c8b6348d27", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -617,8 +617,6 @@ find_basic_blocks (f, nregs, file)\n \n   timevar_push (TV_CFG);\n \n-  basic_block_for_insn = 0;\n-\n   /* Flush out existing data.  */\n   if (basic_block_info != NULL)\n     {"}, {"sha": "0c648b65f676ad3256dc013027670e47ac0a489b", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -50,9 +50,6 @@ static void cleanup_unconditional_jumps\tPARAMS ((void));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n static rtx unlink_insn_chain PARAMS ((rtx, rtx));\n static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n-\n-/* Map insn uid to lexical block.  */\n-static varray_type insn_scopes;\n \f\n static rtx\n unlink_insn_chain (first, last)\n@@ -219,16 +216,14 @@ scope_to_insns_initialize ()\n   tree block = NULL;\n   rtx insn, next;\n \n-  VARRAY_TREE_INIT (insn_scopes, get_max_uid (), \"insn scopes\");\n-\n   for (insn = get_insns (); insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n \n       if (active_insn_p (insn)\n \t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n-\tVARRAY_TREE (insn_scopes, INSN_UID (insn)) = block;\n+        INSN_SCOPE (insn) = block;\n       else if (GET_CODE (insn) == NOTE)\n \t{\n \t  switch (NOTE_LINE_NUMBER (insn))\n@@ -324,13 +319,14 @@ scope_to_insns_finalize ()\n      the common parent easily.  */\n   set_block_levels (cur_block, 0);\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  insn = get_insns ();\n+  if (!active_insn_p (insn))\n+    insn = next_active_insn (insn);\n+  for (; insn; insn = next_active_insn (insn))\n     {\n       tree this_block;\n \n-      if ((size_t) INSN_UID (insn) >= insn_scopes->num_elements)\n-\tcontinue;\n-      this_block = VARRAY_TREE (insn_scopes, INSN_UID (insn));\n+      this_block = INSN_SCOPE (insn);\n       if (! this_block)\n \tcontinue;\n \n@@ -341,8 +337,6 @@ scope_to_insns_finalize ()\n \t}\n     }\n \n-  VARRAY_FREE (insn_scopes);\n-\n   /* change_scope emits before the insn, not after.  */\n   note = emit_note (NULL, NOTE_INSN_DELETED);\n   change_scope (note, cur_block, DECL_INITIAL (cfun->decl));\n@@ -742,10 +736,6 @@ duplicate_insn_chain (from, to)\n \t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    break;\n \t  new = emit_copy_of_insn_after (insn, get_last_insn ());\n-\t  /* Record the INSN_SCOPE.  */\n-\t  VARRAY_GROW (insn_scopes, INSN_UID (new) + 1);\n-\t  VARRAY_TREE (insn_scopes, INSN_UID (new))\n-\t    = VARRAY_TREE (insn_scopes, INSN_UID (insn));\n \t  break;\n \n \tcase CODE_LABEL:\n@@ -958,8 +948,6 @@ cfg_layout_initialize ()\n \n   cleanup_unconditional_jumps ();\n \n-  scope_to_insns_initialize ();\n-\n   record_effective_endpoints ();\n }\n \n@@ -976,8 +964,6 @@ cfg_layout_finalize ()\n   verify_insn_chain ();\n #endif\n \n-  scope_to_insns_finalize ();\n-\n   free_aux_for_blocks ();\n \n #ifdef ENABLE_CHECKING"}, {"sha": "e40ecf23dea485daf1abb29b378a1b401f600277", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 14, "deletions": 57, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -64,9 +64,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define gen_return() NULL_RTX\n #endif\n \n-/* The basic block structure for every insn, indexed by uid.  */\n-varray_type basic_block_for_insn;\n-\n /* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n /* ??? Should probably be using LABEL_NUSES instead.  It would take a\n    bit of surgery to be able to use or co-opt the routines in jump.  */\n@@ -187,9 +184,7 @@ delete_insn_and_edges (insn)\n   rtx x;\n   bool purge = false;\n \n-  if (basic_block_for_insn\n-      && INSN_P (insn)\n-      && (unsigned int)INSN_UID (insn) < basic_block_for_insn->num_elements\n+  if (INSN_P (insn)\n       && BLOCK_FOR_INSN (insn)\n       && BLOCK_FOR_INSN (insn)->end == insn)\n     purge = true;\n@@ -232,9 +227,7 @@ delete_insn_chain_and_edges (first, last)\n {\n   bool purge = false;\n \n-  if (basic_block_for_insn\n-      && INSN_P (last)\n-      && (unsigned int)INSN_UID (last) < basic_block_for_insn->num_elements\n+  if (INSN_P (last)\n       && BLOCK_FOR_INSN (last)\n       && BLOCK_FOR_INSN (last)->end == last)\n     purge = true;\n@@ -277,7 +270,7 @@ create_basic_block_structure (index, head, end, bb_note, after)\n \t}\n \n       if (after != bb_note && NEXT_INSN (after) != bb_note)\n-\treorder_insns (bb_note, bb_note, after);\n+\treorder_insns_nobb (bb_note, bb_note, after);\n     }\n   else\n     {\n@@ -315,8 +308,7 @@ create_basic_block_structure (index, head, end, bb_note, after)\n   bb->flags = BB_NEW;\n   link_block (bb, after);\n   BASIC_BLOCK (index) = bb;\n-  if (basic_block_for_insn)\n-    update_bb_for_insn (bb);\n+  update_bb_for_insn (bb);\n \n   /* Tag the block so that we know it has been used when considering\n      other basic block notes.  */\n@@ -440,21 +432,14 @@ compute_bb_for_insn (max)\n {\n   basic_block bb;\n \n-  if (basic_block_for_insn)\n-    VARRAY_FREE (basic_block_for_insn);\n-\n-  VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n-\n   FOR_EACH_BB (bb)\n     {\n       rtx end = bb->end;\n       rtx insn;\n \n       for (insn = bb->head; ; insn = NEXT_INSN (insn))\n \t{\n-\t  if (INSN_UID (insn) < max)\n-\t    VARRAY_BB (basic_block_for_insn, INSN_UID (insn)) = bb;\n-\n+\t  BLOCK_FOR_INSN (insn) = bb;\n \t  if (insn == end)\n \t    break;\n \t}\n@@ -466,10 +451,10 @@ compute_bb_for_insn (max)\n void\n free_bb_for_insn ()\n {\n-  if (basic_block_for_insn)\n-    VARRAY_FREE (basic_block_for_insn);\n-\n-  basic_block_for_insn = 0;\n+  rtx insn;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) != BARRIER)\n+      BLOCK_FOR_INSN (insn) = NULL;\n }\n \n /* Update insns block within BB.  */\n@@ -480,36 +465,13 @@ update_bb_for_insn (bb)\n {\n   rtx insn;\n \n-  if (! basic_block_for_insn)\n-    return;\n-\n   for (insn = bb->head; ; insn = NEXT_INSN (insn))\n     {\n       set_block_for_insn (insn, bb);\n       if (insn == bb->end)\n \tbreak;\n     }\n }\n-\n-/* Record INSN's block as BB.  */\n-\n-void\n-set_block_for_insn (insn, bb)\n-     rtx insn;\n-     basic_block bb;\n-{\n-  size_t uid = INSN_UID (insn);\n-\n-  if (uid >= basic_block_for_insn->num_elements)\n-    {\n-      /* Add one-eighth the size so we don't keep calling xrealloc.  */\n-      size_t new_size = uid + (uid + 7) / 8;\n-\n-      VARRAY_GROW (basic_block_for_insn, new_size);\n-    }\n-\n-  VARRAY_BB (basic_block_for_insn, uid) = bb;\n-}\n \f\n /* Split a block BB after insn INSN creating a new fallthru edge.\n    Return the new edge.  Note that to keep other parts of the compiler happy,\n@@ -668,15 +630,12 @@ merge_blocks_nomove (a, b)\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n-      if (basic_block_for_insn)\n-\t{\n-\t  rtx x;\n+      rtx x;\n \n-\t  for (x = a_end; x != b_end; x = NEXT_INSN (x))\n-\t    set_block_for_insn (x, a);\n+      for (x = a_end; x != b_end; x = NEXT_INSN (x))\n+\tset_block_for_insn (x, a);\n \n-\t  set_block_for_insn (b_end, a);\n-\t}\n+      set_block_for_insn (b_end, a);\n \n       a_end = b_end;\n     }\n@@ -697,8 +656,6 @@ block_label (block)\n   if (GET_CODE (block->head) != CODE_LABEL)\n     {\n       block->head = emit_label_before (gen_label_rtx (), block->head);\n-      if (basic_block_for_insn)\n-\tset_block_for_insn (block->head, block);\n     }\n \n   return block->head;\n@@ -1972,7 +1929,7 @@ verify_flow_info ()\n \t}\n \n       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n-\tif (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n+\tif (BLOCK_FOR_INSN (x) != bb)\n \t  {\n \t    debug_rtx (x);\n \t    if (! BLOCK_FOR_INSN (x))"}, {"sha": "fe247ea7dc2ae3fdcc2dde2713e9cb976eb53e58", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -1755,6 +1755,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \n \t  subst_prev_insn = i1\n \t    = gen_rtx_INSN (VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n+\t\t\t    BLOCK_FOR_INSN (i2), INSN_SCOPE (i2),\n \t\t\t    XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX,\n \t\t\t    NULL_RTX);\n "}, {"sha": "237f23d8642bfec0e6262ee1012f67195176407f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -2175,8 +2175,8 @@ gen_label_rtx ()\n {\n   rtx label;\n \n-  label = gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n-\t\t\t      NULL_RTX, label_num++, NULL, NULL);\n+  label = gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX, NULL_RTX,\n+\t\t  \t      NULL, label_num++, NULL, NULL);\n \n   LABEL_NUSES (label) = 0;\n   LABEL_ALTERNATE_NAME (label) = NULL;\n@@ -3253,6 +3253,8 @@ make_insn_raw (pattern)\n   INSN_CODE (insn) = -1;\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n+  INSN_SCOPE (insn) = NULL;\n+  BLOCK_FOR_INSN (insn) = NULL;\n \n #ifdef ENABLE_RTL_CHECKING\n   if (insn\n@@ -3285,6 +3287,8 @@ make_jump_insn_raw (pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   JUMP_LABEL (insn) = NULL;\n+  INSN_SCOPE (insn) = NULL;\n+  BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n }\n@@ -3305,6 +3309,8 @@ make_call_insn_raw (pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   CALL_INSN_FUNCTION_USAGE (insn) = NULL;\n+  INSN_SCOPE (insn) = NULL;\n+  BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n }\n@@ -3369,8 +3375,8 @@ add_insn_after (insn, after)\n \tabort ();\n     }\n \n-  if (basic_block_for_insn\n-      && (unsigned int) INSN_UID (after) < basic_block_for_insn->num_elements\n+  if (GET_CODE (after) != BARRIER\n+      && GET_CODE (insn) != BARRIER\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       set_block_for_insn (insn, bb);\n@@ -3438,8 +3444,8 @@ add_insn_before (insn, before)\n \tabort ();\n     }\n \n-  if (basic_block_for_insn\n-      && (unsigned int) INSN_UID (before) < basic_block_for_insn->num_elements\n+  if (GET_CODE (before) != BARRIER\n+      && GET_CODE (insn) != BARRIER\n       && (bb = BLOCK_FOR_INSN (before)))\n     {\n       set_block_for_insn (insn, bb);\n@@ -3518,8 +3524,7 @@ remove_insn (insn)\n       if (stack == 0)\n \tabort ();\n     }\n-  if (basic_block_for_insn\n-      && (unsigned int) INSN_UID (insn) < basic_block_for_insn->num_elements\n+  if (GET_CODE (insn) != BARRIER\n       && (bb = BLOCK_FOR_INSN (insn)))\n     {\n       if (INSN_P (insn))\n@@ -3596,16 +3601,13 @@ reorder_insns (from, to, after)\n \n   reorder_insns_nobb (from, to, after);\n \n-  if (basic_block_for_insn\n-      && (unsigned int) INSN_UID (after) < basic_block_for_insn->num_elements\n+  if (GET_CODE (after) != BARRIER\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       rtx x;\n       bb->flags |= BB_DIRTY;\n \n-      if (basic_block_for_insn\n-\t  && ((unsigned int) INSN_UID (from)\n-\t      < basic_block_for_insn->num_elements)\n+      if (GET_CODE (from) != BARRIER\n \t  && (bb2 = BLOCK_FOR_INSN (from)))\n \t{\n \t  if (bb2->end == to)\n@@ -3913,6 +3915,7 @@ emit_note_before (subtype, before)\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = 0;\n   NOTE_LINE_NUMBER (note) = subtype;\n+  BLOCK_FOR_INSN (note) = NULL;\n \n   add_insn_before (note, before);\n   return note;\n@@ -4033,6 +4036,7 @@ emit_note_after (subtype, after)\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = 0;\n   NOTE_LINE_NUMBER (note) = subtype;\n+  BLOCK_FOR_INSN (note) = NULL;\n   add_insn_after (note, after);\n   return note;\n }\n@@ -4057,6 +4061,7 @@ emit_line_note_after (file, line, after)\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = file;\n   NOTE_LINE_NUMBER (note) = line;\n+  BLOCK_FOR_INSN (note) = NULL;\n   add_insn_after (note, after);\n   return note;\n }\n@@ -4152,14 +4157,15 @@ emit_insns_after (first, after)\n   if (!first)\n     return after;\n \n-  if (basic_block_for_insn\n-      && (unsigned int) INSN_UID (after) < basic_block_for_insn->num_elements\n+  if (GET_CODE (after) != BARRIER\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       bb->flags |= BB_DIRTY;\n       for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-\tset_block_for_insn (last, bb);\n-      set_block_for_insn (last, bb);\n+        if (GET_CODE (last) != BARRIER)\n+\t  set_block_for_insn (last, bb);\n+      if (GET_CODE (last) != BARRIER)\n+        set_block_for_insn (last, bb);\n       if (bb->end == after)\n \tbb->end = last;\n     }\n@@ -4295,6 +4301,7 @@ emit_note (file, line)\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = file;\n   NOTE_LINE_NUMBER (note) = line;\n+  BLOCK_FOR_INSN (note) = NULL;\n   add_insn (note);\n   return note;\n }\n@@ -5212,6 +5219,8 @@ emit_copy_of_insn_after (insn, after)\n   /* Update LABEL_NUSES.  */\n   mark_jump_label (PATTERN (new), new, 0);\n \n+  INSN_SCOPE (new) = INSN_SCOPE (insn);\n+\n   /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n      make them.  */\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))"}, {"sha": "f58190a69589c009c7f84311962aef7d7d5b33b5", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -69,6 +69,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"debug.h\"\n #include \"expr.h\"\n #include \"profile.h\"\n+#include \"cfglayout.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -1671,7 +1672,7 @@ final_start_function (first, file, optimize)\n   if (write_symbols)\n     {\n       remove_unnecessary_notes ();\n-      reorder_blocks ();\n+      scope_to_insns_finalize ();\n       number_blocks (current_function_decl);\n       /* We never actually put out begin/end notes for the top-level\n \t block in the function.  But, conceptually, that block is"}, {"sha": "6c81d48d08b89ddb7fa7d25b039988edbca9f48d", "filename": "gcc/flow.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -373,10 +373,14 @@ check_function_return_warnings ()\n \t is no longer in the chain.  */\n       if (INSN_UID (cfun->x_clobber_return_insn) < max_uid)\n \t{\n-\t  /* Recompute insn->block mapping, since the initial mapping is\n-\t     set before we delete unreachable blocks.  */\n-\t  if (BLOCK_FOR_INSN (cfun->x_clobber_return_insn) != NULL)\n-\t    warning (\"control reaches end of non-void function\");\n+\t  rtx insn;\n+\n+\t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t    if (insn == cfun->x_clobber_return_insn)\n+\t      {\n+\t        warning (\"control reaches end of non-void function\");\n+\t\tbreak;\n+\t      }\n \t}\n     }\n }"}, {"sha": "19d46b1877d3dfaacc168938a6fc0836421457ea", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -4541,10 +4541,10 @@ bypass_conditional_jumps ()\n \t      {\n \t\tif (setcc)\n \t\t  break;\n-\t\tif (GET_CODE (PATTERN (setcc)) != SET)\n+\t\tif (GET_CODE (PATTERN (insn)) != SET)\n \t\t  break;\n \n-\t\tdest = SET_DEST (PATTERN (setcc));\n+\t\tdest = SET_DEST (PATTERN (insn));\n \t\tif (REG_P (dest) || CC0_P (dest))\n \t\t  setcc = insn;\n \t\telse"}, {"sha": "6de4f22b7b524beaf1fdaf9763497a50365ed2e0", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -1334,6 +1334,7 @@ copy_insn_list (insns, map, static_chain_value)\n       switch (GET_CODE (insn))\n \t{\n \tcase INSN:\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \t  pattern = PATTERN (insn);\n \t  set = single_set (insn);\n \t  copy = 0;\n@@ -1507,6 +1508,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t  break;\n \n \tcase JUMP_INSN:\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \t  if (map->integrating && returnjump_p (insn))\n \t    {\n \t      if (map->local_return_label == 0)\n@@ -1553,6 +1555,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t  /* If this is a CALL_PLACEHOLDER insn then we need to copy the\n \t     three attached sequences: normal call, sibling call and tail\n \t     recursion.  */\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \t  if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t    {\n \t      rtx sequence[3];"}, {"sha": "0937336ba1ac994b929dc79082ed44ce1a39ad41", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -305,8 +305,6 @@ duplicate_loop_exit_test (loop_start)\n \t is a CODE_LABEL\n \t has a REG_RETVAL or REG_LIBCALL note (hard to adjust)\n \t is a NOTE_INSN_LOOP_BEG because this means we have a nested loop\n-\t is a NOTE_INSN_BLOCK_{BEG,END} because duplicating these notes\n-\t      is not valid.\n \n      We also do not do this if we find an insn with ASM_OPERANDS.  While\n      this restriction should not be necessary, copying an insn with\n@@ -326,18 +324,6 @@ duplicate_loop_exit_test (loop_start)\n \tcase CALL_INSN:\n \t  return 0;\n \tcase NOTE:\n-\t  /* We could be in front of the wrong NOTE_INSN_LOOP_END if there is\n-\t     a jump immediately after the loop start that branches outside\n-\t     the loop but within an outer loop, near the exit test.\n-\t     If we copied this exit test and created a phony\n-\t     NOTE_INSN_LOOP_VTOP, this could make instructions immediately\n-\t     before the exit test look like these could be safely moved\n-\t     out of the loop even if they actually may be never executed.\n-\t     This can be avoided by checking here for NOTE_INSN_LOOP_CONT.  */\n-\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n-\t    return 0;\n \n \t  if (optimize < 2\n \t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n@@ -423,6 +409,7 @@ duplicate_loop_exit_test (loop_start)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \n \t  mark_jump_label (PATTERN (copy), copy, 0);\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \n \t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n \t     make them.  */\n@@ -448,6 +435,7 @@ duplicate_loop_exit_test (loop_start)\n \tcase JUMP_INSN:\n \t  copy = emit_jump_insn_before (copy_insn (PATTERN (insn)),\n \t\t\t\t\tloop_start);\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \t  mark_jump_label (PATTERN (copy), copy, 0);"}, {"sha": "bc75f8ba3b858e7d8737e44e9b44f88d0d2de4c7", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -566,13 +566,6 @@ loop_optimize (f, dumpfile, flags)\n \tscan_loop (loop, flags);\n     }\n \n-  /* If there were lexical blocks inside the loop, they have been\n-     replicated.  We will now have more than one NOTE_INSN_BLOCK_BEG\n-     and NOTE_INSN_BLOCK_END for each such block.  We must duplicate\n-     the BLOCKs as well.  */\n-  if (write_symbols != NO_DEBUG)\n-    reorder_blocks ();\n-\n   end_alias_analysis ();\n \n   /* Clean up.  */\n@@ -4139,6 +4132,7 @@ emit_prefetch_instructions (loop)\n \t  int bytes_ahead = PREFETCH_BLOCK * (ahead + y);\n \t  rtx before_insn = info[i].giv->insn;\n \t  rtx prev_insn = PREV_INSN (info[i].giv->insn);\n+\t  rtx seq;\n \n \t  /* We can save some effort by offsetting the address on\n \t     architectures with offsettable memory references.  */\n@@ -4153,13 +4147,16 @@ emit_prefetch_instructions (loop)\n \t      loc = reg;\n \t    }\n \n+\t  start_sequence ();\n \t  /* Make sure the address operand is valid for prefetch.  */\n \t  if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n \t\t  (loc, insn_data[(int)CODE_FOR_prefetch].operand[0].mode))\n \t    loc = force_reg (Pmode, loc);\n-\t  emit_insn_before (gen_prefetch (loc, GEN_INT (info[i].write),\n-\t\t\t\t\t  GEN_INT (3)),\n-\t\t\t    before_insn);\n+\t  emit_insn (gen_prefetch (loc, GEN_INT (info[i].write),\n+\t\t\t\t   GEN_INT (3)));\n+\t  seq = gen_sequence ();\n+\t  end_sequence ();\n+\t  emit_insn_before (seq, before_insn);\n \n \t  /* Check all insns emitted and record the new GIV\n \t     information.  */"}, {"sha": "723fd0d3eb5e3945bbe342bc69cd25e82c26a8fd", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -475,6 +475,11 @@ print_rtx (in_rtx)\n \tsawclose = 0;\n \tbreak;\n \n+      case 'B':\n+\tif (XBBDEF (in_rtx, i))\n+\t  fprintf (outfile, \" %i\", XBBDEF (in_rtx, i)->index);\n+\tbreak;\n+\n       default:\n \tfprintf (stderr,\n \t\t \"switch format wrong in rtl.print_rtx(). format was: %c.\\n\","}, {"sha": "6ad82eeae1dfc6cdc652748a8845c6934c77b72f", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -397,9 +397,6 @@ apply_change_group ()\n       for (i = 0; i < num_changes; i++)\n \tif (changes[i].object\n \t    && INSN_P (changes[i].object)\n-\t    && basic_block_for_insn\n-\t    && ((unsigned int)INSN_UID (changes[i].object)\n-\t\t< basic_block_for_insn->num_elements)\n \t    && (bb = BLOCK_FOR_INSN (changes[i].object)))\n \t  bb->flags |= BB_DIRTY;\n "}, {"sha": "da753b58428cf37605567299da7f9068897ff971", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -369,6 +369,7 @@ copy_rtx (orig)\n \tcase 'S':\n \tcase 'T':\n \tcase 'u':\n+\tcase 'B':\n \tcase '0':\n \t  /* These are left unchanged.  */\n \t  break;"}, {"sha": "270f1a842ac6c902f8a13704f01aa1f8043746d4", "filename": "gcc/rtl.def", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -545,37 +545,37 @@ DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n    ---------------------------------------------------------------------- */\n \n /* An instruction that cannot jump.  */\n-DEF_RTL_EXPR(INSN, \"insn\", \"iuueiee\", 'i')\n+DEF_RTL_EXPR(INSN, \"insn\", \"iuuBteiee\", 'i')\n \n /* An instruction that can possibly jump.\n    Fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuueiee0\", 'i')\n+DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBteiee0\", 'i')\n \n /* An instruction that can possibly call a subroutine\n    but which will not change which instruction comes next\n    in the current function.\n-   Field ( rtx->fld[7] ) is CALL_INSN_FUNCTION_USAGE.\n+   Field ( rtx->fld[9] ) is CALL_INSN_FUNCTION_USAGE.\n    All other fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuueieee\", 'i')\n+DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBteieee\", 'i')\n \n /* A marker that indicates that control will not flow through.  */\n DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu\", 'x')\n \n /* Holds a label that is followed by instructions.\n    Operand:\n-   3: is used in jump.c for the use-count of the label.\n-   4: is used in flow.c to point to the chain of label_ref's to this label.\n-   5: is a number that is unique in the entire compilation.\n-   6: is the user-given name of the label, if any.\n-   7: is the alternate label name.  */\n-DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuu00iss\", 'x')\n+   4: is used in jump.c for the use-count of the label.\n+   5: is used in flow.c to point to the chain of label_ref's to this label.\n+   6: is a number that is unique in the entire compilation.\n+   7: is the user-given name of the label, if any.\n+   8: is the alternate label name.  */\n+DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00iss\", 'x')\n      \n /* Say where in the code a source line starts, for symbol table's sake.\n    Operand:\n-   3: filename, if line number > 0, note-specific data otherwise.\n-   4: line number if > 0, enum note_insn otherwise.\n-   5: unique number if line number == note_insn_deleted_label.  */\n-DEF_RTL_EXPR(NOTE, \"note\", \"iuu0ni\", 'x')\n+   4: filename, if line number > 0, note-specific data otherwise.\n+   5: line number if > 0, enum note_insn otherwise.\n+   6: unique number if line number == note_insn_deleted_label.  */\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", 'x')\n \n /* ----------------------------------------------------------------------\n    Top level constituents of INSN, JUMP_INSN and CALL_INSN."}, {"sha": "ff7f1c0d5aa3bafd5e9a0c9516ec57690d2f11a7", "filename": "gcc/rtl.h", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -506,19 +506,21 @@ do {\t\t\t\t\\\n #define PREV_INSN(INSN)\tXEXP (INSN, 1)\n #define NEXT_INSN(INSN)\tXEXP (INSN, 2)\n \n+#define BLOCK_FOR_INSN(INSN) XBBDEF (INSN, 3)\n+#define INSN_SCOPE(INSN) XTREE (INSN, 4)\n /* The body of an insn.  */\n-#define PATTERN(INSN)\tXEXP (INSN, 3)\n+#define PATTERN(INSN)\tXEXP (INSN, 5)\n \n /* Code number of instruction, from when it was recognized.\n    -1 means this instruction has not been recognized yet.  */\n-#define INSN_CODE(INSN) XINT (INSN, 4)\n+#define INSN_CODE(INSN) XINT (INSN, 6)\n \n /* Set up in flow.c; empty before then.\n    Holds a chain of INSN_LIST rtx's whose first operands point at\n    previous insns with direct data-flow connections to this one.\n    That means that those insns set variables whose next use is in this insn.\n    They are always in the same basic block as this insn.  */\n-#define LOG_LINKS(INSN)\tXEXP(INSN, 5)\n+#define LOG_LINKS(INSN)\tXEXP(INSN, 7)\n \n #define RTX_INTEGRATED_P(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK8(\"RTX_INTEGRATED_P\", (RTX), INSN, CALL_INSN,\t\t\\\n@@ -570,7 +572,7 @@ do {\t\t\t\t\\\n    The mode field of the EXPR_LIST contains not a real machine mode\n    but a value from enum reg_note.  */\n \n-#define REG_NOTES(INSN)\tXEXP(INSN, 6)\n+#define REG_NOTES(INSN)\tXEXP(INSN, 8)\n \n /* Don't forget to change reg_note_name in rtl.c.  */\n enum reg_note\n@@ -739,12 +741,12 @@ extern const char * const reg_note_name[];\n      CLOBBER expressions document the registers explicitly clobbered\n    by this CALL_INSN.\n      Pseudo registers can not be mentioned in this list.  */\n-#define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 7)\n+#define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 9)\n \n /* The label-number of a code-label.  The assembler label\n    is made from `L' and the label-number printed in decimal.\n    Label numbers are unique in a compilation.  */\n-#define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 5)\n+#define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 6)\n \n #define LINE_NUMBER NOTE\n \n@@ -755,27 +757,27 @@ extern const char * const reg_note_name[];\n    The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n    information as an rtx in the field.  */\n \n-#define NOTE_SOURCE_FILE(INSN) \tXCSTR (INSN, 3, NOTE)\n-#define NOTE_BLOCK(INSN)\tXCTREE (INSN, 3, NOTE)\n-#define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 3, NOTE)\n-#define NOTE_RANGE_INFO(INSN)  \tXCEXP (INSN, 3, NOTE)\n-#define NOTE_LIVE_INFO(INSN)   \tXCEXP (INSN, 3, NOTE)\n-#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 3, NOTE)\n-#define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 3, NOTE)\n-#define NOTE_PREDICTION(INSN)   XCINT (INSN, 3, NOTE)\n+#define NOTE_SOURCE_FILE(INSN) \tXCSTR (INSN, 4, NOTE)\n+#define NOTE_BLOCK(INSN)\tXCTREE (INSN, 4, NOTE)\n+#define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 4, NOTE)\n+#define NOTE_RANGE_INFO(INSN)  \tXCEXP (INSN, 4, NOTE)\n+#define NOTE_LIVE_INFO(INSN)   \tXCEXP (INSN, 4, NOTE)\n+#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 4, NOTE)\n+#define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 4, NOTE)\n+#define NOTE_PREDICTION(INSN)   XCINT (INSN, 4, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n-#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 4, NOTE)\n+#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 5, NOTE)\n \n /* Nonzero if INSN is a note marking the beginning of a basic block.  */\n #define NOTE_INSN_BASIC_BLOCK_P(INSN) \t\t\t\\\n   (GET_CODE (INSN) == NOTE\t\t\t\t\\\n    && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n /* Algorithm and flags for prediction.  */\n-#define NOTE_PREDICTION_ALG(INSN)   (XCINT(INSN, 3, NOTE)>>8)\n-#define NOTE_PREDICTION_FLAGS(INSN) (XCINT(INSN, 3, NOTE)&0xff)\n+#define NOTE_PREDICTION_ALG(INSN)   (XCINT(INSN, 4, NOTE)>>8)\n+#define NOTE_PREDICTION_FLAGS(INSN) (XCINT(INSN, 4, NOTE)&0xff)\n #define NOTE_PREDICT(ALG,FLAGS)     ((ALG<<8)+(FLAGS))\n \n /* Codes that appear in the NOTE_LINE_NUMBER field\n@@ -880,14 +882,14 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n-#define LABEL_NAME(RTX) XCSTR (RTX, 6, CODE_LABEL)\n+#define LABEL_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n-#define LABEL_NUSES(RTX) XCINT (RTX, 3, CODE_LABEL)\n+#define LABEL_NUSES(RTX) XCINT (RTX, 4, CODE_LABEL)\n \n /* Associate a name with a CODE_LABEL.  */\n-#define LABEL_ALTERNATE_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)\n+#define LABEL_ALTERNATE_NAME(RTX) XCSTR (RTX, 8, CODE_LABEL)\n \n /* The original regno this ADDRESSOF was built for.  */\n #define ADDRESSOF_REGNO(RTX) XCUINT (RTX, 1, ADDRESSOF)\n@@ -898,13 +900,13 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n    be decremented and possibly the label can be deleted.  */\n-#define JUMP_LABEL(INSN)   XCEXP (INSN, 7, JUMP_INSN)\n+#define JUMP_LABEL(INSN)   XCEXP (INSN, 9, JUMP_INSN)\n \n /* Once basic blocks are found in flow.c,\n    each CODE_LABEL starts a chain that goes through\n    all the LABEL_REFs that jump to that label.\n    The chain eventually winds up at the CODE_LABEL: it is circular.  */\n-#define LABEL_REFS(LABEL) XCEXP (LABEL, 4, CODE_LABEL)\n+#define LABEL_REFS(LABEL) XCEXP (LABEL, 5, CODE_LABEL)\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked."}, {"sha": "91bf88ec2b999ef5dfa35021b42164277cfb9b06", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -286,8 +286,6 @@ schedule_ebbs (dump_file)\n   if (n_basic_blocks == 0)\n     return;\n \n-  scope_to_insns_initialize ();\n-\n   sched_init (dump_file);\n \n   current_sched_info = &ebb_sched_info;\n@@ -355,7 +353,5 @@ schedule_ebbs (dump_file)\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n \n-  scope_to_insns_finalize ();\n-\n   sched_finish ();\n }"}, {"sha": "280f33089d6008d29200fa563c8f1dbf17595a4b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -2989,8 +2989,6 @@ schedule_insns (dump_file)\n   if (n_basic_blocks == 0)\n     return;\n \n-  scope_to_insns_initialize ();\n-\n   nr_inter = 0;\n   nr_spec = 0;\n \n@@ -3079,8 +3077,6 @@ schedule_insns (dump_file)\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n \n-  scope_to_insns_finalize ();\n-\n   if (sched_verbose)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)"}, {"sha": "6eecb966138274d133a822b86976e09e2093687e", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -2570,9 +2570,10 @@ rest_of_compilation (decl)\n \t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n \t  delete_insn (insn);\n     }\n-   close_dump_file (DFI_sibling, print_rtl, get_insns ());\n-   timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n+  timevar_pop (TV_JUMP);\n \n+  scope_to_insns_initialize ();\n   /* Complete generation of exception handling code.  */\n   find_exception_handler_labels ();\n   if (doing_eh (0))"}, {"sha": "26fcaf7223fc7a95b0277c5793285f22052f19c2", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4f7968b5abe75ba6c20eaa0de6fc88806deaef/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ba4f7968b5abe75ba6c20eaa0de6fc88806deaef", "patch": "@@ -268,53 +268,6 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n       return;\n     }\n \n-  /* When emitting debugger info, we can't unroll loops with unequal numbers\n-     of block_beg and block_end notes, because that would unbalance the block\n-     structure of the function.  This can happen as a result of the\n-     \"if (foo) bar; else break;\" optimization in jump.c.  */\n-  /* ??? Gcc has a general policy that -g is never supposed to change the code\n-     that the compiler emits, so we must disable this optimization always,\n-     even if debug info is not being output.  This is rare, so this should\n-     not be a significant performance problem.  */\n-\n-  if (1 /* write_symbols != NO_DEBUG */)\n-    {\n-      int block_begins = 0;\n-      int block_ends = 0;\n-\n-      for (insn = loop_start; insn != loop_end; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == NOTE)\n-\t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n-\t\tblock_begins++;\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t\tblock_ends++;\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t\t{\n-\t\t  /* Note, would be nice to add code to unroll EH\n-\t\t     regions, but until that time, we punt (don't\n-\t\t     unroll).  For the proper way of doing it, see\n-\t\t     expand_inline_function.  */\n-\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream,\n-\t\t\t     \"Unrolling failure: cannot unroll EH regions.\\n\");\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (block_begins != block_ends)\n-\t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t\t     \"Unrolling failure: Unbalanced block notes.\\n\");\n-\t  return;\n-\t}\n-    }\n-\n   /* Determine type of unroll to perform.  Depends on the number of iterations\n      and the size of the loop.  */\n \n@@ -2046,6 +1999,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t      copy = emit_insn (pattern);\n \t    }\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \n #ifdef HAVE_cc0\n \t  /* If this insn is setting CC0, it may need to look at\n@@ -2092,6 +2046,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_jump_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \n \t  if (JUMP_LABEL (insn))\n \t    {\n@@ -2215,6 +2170,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_call_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n+\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n \t  SIBLING_CALL_P (copy) = SIBLING_CALL_P (insn);\n \n \t  /* Because the USAGE information potentially contains objects other"}]}