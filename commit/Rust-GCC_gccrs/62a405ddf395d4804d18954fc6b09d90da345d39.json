{"sha": "62a405ddf395d4804d18954fc6b09d90da345d39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhNDA1ZGRmMzk1ZDQ4MDRkMTg5NTRmYzZiMDlkOTBkYTM0NWQzOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-09-12T18:04:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-09-12T18:04:46Z"}, "message": "* call.c (convert_class_to_reference)\n\t(convert_class_to_reference_1): Remove.\n\t(reference_binding): Use build_user_type_conversion_1 instead.\n\nFrom-SVN: r178789", "tree": {"sha": "f40ab43f4e4356b49795fd8bf149f118cde02724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f40ab43f4e4356b49795fd8bf149f118cde02724"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62a405ddf395d4804d18954fc6b09d90da345d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a405ddf395d4804d18954fc6b09d90da345d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a405ddf395d4804d18954fc6b09d90da345d39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a405ddf395d4804d18954fc6b09d90da345d39/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e495f6b0c06db941cd213941fe659127eedb13b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e495f6b0c06db941cd213941fe659127eedb13b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e495f6b0c06db941cd213941fe659127eedb13b1"}], "stats": {"total": 178, "additions": 17, "deletions": 161}, "files": [{"sha": "772ba51b52a5cc6e4d1cd115330fce4a375b4892", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a405ddf395d4804d18954fc6b09d90da345d39/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a405ddf395d4804d18954fc6b09d90da345d39/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62a405ddf395d4804d18954fc6b09d90da345d39", "patch": "@@ -1,5 +1,9 @@\n 2011-09-12  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (convert_class_to_reference)\n+\t(convert_class_to_reference_1): Remove.\n+\t(reference_binding): Use build_user_type_conversion_1 instead.\n+\n \t* call.c (initialize_reference): Add flags parm.\n \t* decl.c (grok_reference_init): Likewise.\n \t(check_initializer): Pass it."}, {"sha": "d58ed135169c915ef348af052862b66349115b7e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 159, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a405ddf395d4804d18954fc6b09d90da345d39/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a405ddf395d4804d18954fc6b09d90da345d39/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=62a405ddf395d4804d18954fc6b09d90da345d39", "patch": "@@ -202,7 +202,6 @@ static struct z_candidate *add_candidate\n static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_compatible_p (tree, tree);\n-static conversion *convert_class_to_reference (tree, tree, tree, int);\n static conversion *direct_reference_binding (tree, conversion *);\n static bool promoted_arithmetic_type_p (tree);\n static conversion *conditional_conversion (tree, tree);\n@@ -1352,160 +1351,6 @@ reference_compatible_p (tree t1, tree t2)\n \t  && at_least_as_qualified_p (t1, t2));\n }\n \n-/* Determine whether or not the EXPR (of class type S) can be\n-   converted to T as in [over.match.ref].  */\n-\n-static conversion *\n-convert_class_to_reference_1 (tree reference_type, tree s, tree expr, int flags)\n-{\n-  tree conversions;\n-  tree first_arg;\n-  conversion *conv;\n-  tree t;\n-  struct z_candidate *candidates;\n-  struct z_candidate *cand;\n-  bool any_viable_p;\n-\n-  if (!expr)\n-    return NULL;\n-\n-  conversions = lookup_conversions (s);\n-  if (!conversions)\n-    return NULL;\n-\n-  /* [over.match.ref]\n-\n-     Assuming that \"cv1 T\" is the underlying type of the reference\n-     being initialized, and \"cv S\" is the type of the initializer\n-     expression, with S a class type, the candidate functions are\n-     selected as follows:\n-\n-     --The conversion functions of S and its base classes are\n-       considered.  Those that are not hidden within S and yield type\n-       \"reference to cv2 T2\", where \"cv1 T\" is reference-compatible\n-       (_dcl.init.ref_) with \"cv2 T2\", are candidate functions.\n-\n-     The argument list has one argument, which is the initializer\n-     expression.  */\n-\n-  candidates = 0;\n-\n-  /* Conceptually, we should take the address of EXPR and put it in\n-     the argument list.  Unfortunately, however, that can result in\n-     error messages, which we should not issue now because we are just\n-     trying to find a conversion operator.  Therefore, we use NULL,\n-     cast to the appropriate type.  */\n-  first_arg = build_int_cst (build_pointer_type (s), 0);\n-\n-  t = TREE_TYPE (reference_type);\n-\n-  /* We're performing a user-defined conversion to a desired type, so set\n-     this for the benefit of add_candidates.  */\n-  flags |= LOOKUP_NO_CONVERSION;\n-\n-  for (; conversions; conversions = TREE_CHAIN (conversions))\n-    {\n-      tree fns = TREE_VALUE (conversions);\n-      tree binfo = TREE_PURPOSE (conversions);\n-      struct z_candidate *old_candidates = candidates;;\n-\n-      add_candidates (fns, first_arg, NULL, reference_type,\n-\t\t      NULL_TREE, false,\n-\t\t      binfo, TYPE_BINFO (s),\n-\t\t      flags, &candidates);\n-\n-      for (cand = candidates; cand != old_candidates; cand = cand->next)\n-\t{\n-\t  /* Now, see if the conversion function really returns\n-\t     an lvalue of the appropriate type.  From the\n-\t     point of view of unification, simply returning an\n-\t     rvalue of the right type is good enough.  */\n-\t  tree f = cand->fn;\n-\t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n-\t  if (cand->viable == 0)\n-\t    /* Don't bother looking more closely.  */;\n-\t  else if (TREE_CODE (t2) != REFERENCE_TYPE\n-\t\t   || !reference_compatible_p (t, TREE_TYPE (t2)))\n-\t    {\n-\t      /* No need to set cand->reason here; this is most likely\n-\t\t an ambiguous match.  If it's not, either this candidate\n-\t\t will win, or we will have identified a reason for it\n-\t\t losing already.  */\n-\t      cand->viable = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      conversion *identity_conv;\n-\t      /* Build a standard conversion sequence indicating the\n-\t\t binding from the reference type returned by the\n-\t\t function to the desired REFERENCE_TYPE.  */\n-\t      identity_conv\n-\t\t= build_identity_conv (TREE_TYPE (TREE_TYPE\n-\t\t\t\t\t\t  (TREE_TYPE (cand->fn))),\n-\t\t\t\t       NULL_TREE);\n-\t      cand->second_conv\n-\t\t= (direct_reference_binding\n-\t\t   (reference_type, identity_conv));\n-\t      cand->second_conv->rvaluedness_matches_p\n-\t\t= TYPE_REF_IS_RVALUE (TREE_TYPE (TREE_TYPE (cand->fn)))\n-\t\t  == TYPE_REF_IS_RVALUE (reference_type);\n-\t      cand->second_conv->bad_p |= cand->convs[0]->bad_p;\n-\n-              /* Don't allow binding of lvalues to rvalue references.  */\n-              if (TYPE_REF_IS_RVALUE (reference_type)\n-                  /* Function lvalues are OK, though.  */\n-                  && TREE_CODE (TREE_TYPE (reference_type)) != FUNCTION_TYPE\n-                  && !TYPE_REF_IS_RVALUE (TREE_TYPE (TREE_TYPE (cand->fn))))\n-                cand->second_conv->bad_p = true;\n-\t    }\n-\t}\n-    }\n-\n-  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n-  /* If none of the conversion functions worked out, let our caller\n-     know.  */\n-  if (!any_viable_p)\n-    return NULL;\n-\n-  cand = tourney (candidates);\n-  if (!cand)\n-    return NULL;\n-\n-  /* Now that we know that this is the function we're going to use fix\n-     the dummy first argument.  */\n-  gcc_assert (cand->first_arg == NULL_TREE\n-\t      || integer_zerop (cand->first_arg));\n-  cand->first_arg = build_this (expr);\n-\n-  /* Build a user-defined conversion sequence representing the\n-     conversion.  */\n-  conv = build_conv (ck_user,\n-\t\t     TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t     build_identity_conv (TREE_TYPE (expr), expr));\n-  conv->cand = cand;\n-\n-  if (cand->viable == -1)\n-    conv->bad_p = true;\n-\n-  /* Merge it with the standard conversion sequence from the\n-     conversion function's return type to the desired type.  */\n-  cand->second_conv = merge_conversion_sequences (conv, cand->second_conv);\n-\n-  return cand->second_conv;\n-}\n-\n-/* Wrapper for above.  */\n-\n-static conversion *\n-convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n-{\n-  conversion *ret;\n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = convert_class_to_reference_1 (reference_type, s, expr, flags);\n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n-  return ret;\n-}\n-\n /* A reference of the indicated TYPE is being bound directly to the\n    expression represented by the implicit conversion sequence CONV.\n    Return a conversion sequence for this binding.  */\n@@ -1715,9 +1560,9 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n \tthe reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n-      conv = convert_class_to_reference (rto, from, expr, flags);\n-      if (conv)\n-\treturn conv;\n+      z_candidate *cand = build_user_type_conversion_1 (rto, expr, flags);\n+      if (cand)\n+\treturn cand->second_conv;\n     }\n \n   /* From this point on, we conceptually need temporaries, even if we\n@@ -3477,7 +3322,7 @@ add_list_candidates (tree fns, tree first_arg,\n /* Returns the best overload candidate to perform the requested\n    conversion.  This function is used for three the overloading situations\n    described in [over.match.copy], [over.match.conv], and [over.match.ref].\n-   If TOTYPE is a REFERENCE_TYPE, we're trying to find an lvalue binding as\n+   If TOTYPE is a REFERENCE_TYPE, we're trying to find a direct binding as\n    per [dcl.init.ref], so we ignore temporary bindings.  */\n \n static struct z_candidate *\n@@ -3636,6 +3481,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t\t yield type T or a type that can be converted to type T\n \t\t with a qualification conversion (4.4) are also candidate\n \t\t functions.  */\n+\t      /* 13.3.1.6 doesn't have a parallel restriction, but it should;\n+\t\t I've raised this issue with the committee. --jason 9/2011 */\n \t      cand->viable = -1;\n \t      cand->reason = explicit_conversion_rejection (rettype, totype);\n \t    }"}, {"sha": "8cd719cae2489a1aee2e461f98257733cb119117", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a405ddf395d4804d18954fc6b09d90da345d39/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a405ddf395d4804d18954fc6b09d90da345d39/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=62a405ddf395d4804d18954fc6b09d90da345d39", "patch": "@@ -1,3 +1,8 @@\n+2011-09-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* testsuite/20_util/is_constructible/value-2.cc: Adjust\n+\texpected values.\n+\n 2011-09-11  Daniel Krugler  <daniel.kruegler@googlemail.com>\n \n \tPR libstdc++/50159"}, {"sha": "24fde9389887b73b043667cb7c4b6d01125e4260", "filename": "libstdc++-v3/testsuite/20_util/is_constructible/value-2.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a405ddf395d4804d18954fc6b09d90da345d39/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a405ddf395d4804d18954fc6b09d90da345d39/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc?ref=62a405ddf395d4804d18954fc6b09d90da345d39", "patch": "@@ -236,8 +236,8 @@ static_assert(std::is_constructible<const int&,\n static_assert(std::is_constructible<const int&,\n \t      ExplicitTo<int&>>::value, \"Error\");\n \n-static_assert(std::is_constructible<B&&, ExplicitTo<D&&>>::value, \"Error\");\n-static_assert(std::is_constructible<B&&, ExplicitTo<D&&>&>::value, \"Error\");\n+static_assert(!std::is_constructible<B&&, ExplicitTo<D&&>>::value, \"Error\");\n+static_assert(!std::is_constructible<B&&, ExplicitTo<D&&>&>::value, \"Error\");\n \n static_assert(!std::is_constructible<B&, B&&>::value, \"Error\");\n static_assert(!std::is_constructible<D&, B&&>::value, \"Error\");"}]}