{"sha": "157891a301cf9b584167391d816d391c89b4399d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3ODkxYTMwMWNmOWI1ODQxNjczOTFkODE2ZDM5MWM4OWI0Mzk5ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-09-23T21:45:06Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-09-23T21:45:06Z"}, "message": "constraints.md: New file.\n\n\t* config/sparc/constraints.md: New file.\n\t* config/sparc/sparc.md: Include it.\n\t* config/sparc/sparc-protos.h (memory_ok_for_ldd): Declare.\n\t(sparc_extra_constraint_check): Delete.\n\t* config/sparc/sparc.c (register_ok_for_ldd): Minor tweaks.\n\t(memory_ok_for_ldd): New predicate.\n\t(sparc_extra_constraint_check): Delete.\n\t* config/sparc/sparc.h (REG_CLASS_FROM_LETTER): Likewise.\n\t(CONST_OK_FOR_LETTER_P): Likewise.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n\t(EXTRA_CONSTRAINT): Likewise.\n\nFrom-SVN: r140619", "tree": {"sha": "7c9515c40d04b8979995edbec31207e9049c5fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c9515c40d04b8979995edbec31207e9049c5fb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/157891a301cf9b584167391d816d391c89b4399d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157891a301cf9b584167391d816d391c89b4399d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157891a301cf9b584167391d816d391c89b4399d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157891a301cf9b584167391d816d391c89b4399d/comments", "author": null, "committer": null, "parents": [{"sha": "8179c2f253c4bd249f7c474628b29b1d73e9cd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8179c2f253c4bd249f7c474628b29b1d73e9cd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8179c2f253c4bd249f7c474628b29b1d73e9cd9f"}], "stats": {"total": 350, "additions": 193, "deletions": 157}, "files": [{"sha": "b0f8f525cfcb1855099f4e45f3d9096bbb53b172", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -1,3 +1,17 @@\n+2008-09-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/constraints.md: New file.\n+\t* config/sparc/sparc.md: Include it.\n+\t* config/sparc/sparc-protos.h (memory_ok_for_ldd): Declare.\n+\t(sparc_extra_constraint_check): Delete.\n+\t* config/sparc/sparc.c (register_ok_for_ldd): Minor tweaks.\n+\t(memory_ok_for_ldd): New predicate.\n+\t(sparc_extra_constraint_check): Delete.\n+\t* config/sparc/sparc.h (REG_CLASS_FROM_LETTER): Likewise.\n+\t(CONST_OK_FOR_LETTER_P): Likewise.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n+\t(EXTRA_CONSTRAINT): Likewise.\n+\n 2008-08-23  Steve Ellcey  <sje@cup.hp.com>\n \n \t* regrename.c (do_replace): Copy REG_POINTER value to new reg."}, {"sha": "6d505649c768524aeb7dce5bd27addae14aa7b8a", "filename": "gcc/config/sparc/constraints.md", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -0,0 +1,143 @@\n+;; Constraint definitions for SPARC.\n+;; Copyright (C) 2008 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;;; Unused letters:\n+;;;    ABCD           P         Z\n+;;;    a        jkl    q  tuvwxyz\n+\n+\n+;; Register constraints\n+\n+(define_register_constraint \"b\" \"(TARGET_V9 && TARGET_VIS ? EXTRA_FP_REGS : NO_REGS)\"\n+ \"Any floating-point register in VIS mode\")\n+\n+(define_register_constraint \"c\" \"FPCC_REGS\"\n+ \"Floating-point condition code register\")\n+\n+(define_register_constraint \"d\" \"(TARGET_V9 && TARGET_VIS ? FP_REGS : NO_REGS)\"\n+ \"Lower floating-point register in VIS mode\")\n+\n+;; In the non-V9 case, coerce V9 'e' class to 'f', so we can use 'e' in the\n+;; MD file for V8 and V9.\n+(define_register_constraint \"e\" \"TARGET_V9 ? EXTRA_FP_REGS : FP_REGS\"\n+ \"Any floating-point register\")\n+\n+(define_register_constraint \"f\" \"FP_REGS\"\n+ \"Lower floating-point register\")\n+ \n+(define_register_constraint \"h\" \"(TARGET_V9 && TARGET_V8PLUS ? I64_REGS : NO_REGS)\"\n+ \"64-bit global or out register in V8+ mode\")\n+\n+\n+;; Floating-point constant constraints\n+\n+(define_constraint \"G\"\n+ \"The floating-point zero constant\"\n+ (and (match_code \"const_double\")\n+      (match_test \"const_zero_operand (op, mode)\")))\n+\n+\n+;; Integer constant constraints\n+\n+(define_constraint \"H\"\n+ \"Valid operand of double arithmetic operation\"\n+ (and (match_code \"const_double\")\n+      (match_test \"arith_double_operand (op, DImode)\")))\n+\n+(define_constraint \"I\"\n+ \"Signed 13-bit integer constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SIMM13_P (ival)\")))\n+\n+(define_constraint \"J\"\n+ \"The integer zero constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == 0\")))\n+\n+(define_constraint \"K\"\n+ \"Signed 32-bit constant that can be loaded with a sethi instruction\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SETHI32_P (ival)\")))\n+\n+(define_constraint \"L\"\n+ \"Signed 11-bit integer constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SIMM11_P (ival)\")))\n+\n+(define_constraint \"M\"\n+ \"Signed 10-bit integer constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SIMM10_P (ival)\")))\n+\n+(define_constraint \"N\"\n+ \"Signed constant that can be loaded with a sethi instruction\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SETHI_P (ival)\")))\n+\n+(define_constraint \"O\"\n+ \"The 4096 constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == 4096\")))\n+\n+\n+;; Extra constraints\n+;; Our memory extra constraints have to emulate the behavior of 'm' and 'o',\n+;; i.e. accept pseudo-registers during reload.\n+\n+(define_constraint \"Q\"\n+ \"Floating-point constant that can be loaded with a sethi instruction\"\n+ (and (match_code \"const_double\")\n+      (match_test \"fp_sethi_p (op)\")))\n+\n+(define_constraint \"R\"\n+ \"Floating-point constant that can be loaded with a move instruction\"\n+ (and (match_code \"const_double\")\n+      (match_test \"fp_mov_p (op)\")))\n+\n+(define_constraint \"S\"\n+ \"Floating-point constant that can be loaded with a high/lo_sum sequence\"\n+ (and (match_code \"const_double\")\n+      (match_test \"fp_high_losum_p (op)\")))\n+\n+;; Not needed in 64-bit mode\n+(define_constraint \"T\"\n+ \"Memory reference whose address is aligned to 8-byte boundary\"\n+ (and (match_test \"TARGET_ARCH32\")\n+      (match_code \"mem,reg\")\n+      (match_test \"memory_ok_for_ldd (op)\")))\n+\n+;; Not needed in 64-bit mode\n+(define_constraint \"U\"\n+ \"Pseudo-register or hard even-numbered integer register\"\n+ (and (match_test \"TARGET_ARCH32\")\n+      (match_code \"reg\")\n+      (ior (match_test \"REGNO (op) < FIRST_PSEUDO_REGISTER\")\n+\t   (not (match_test \"reload_in_progress && reg_renumber [REGNO (op)] < 0\")))\n+      (match_test \"register_ok_for_ldd (op)\")))\n+\n+;; Equivalent to 'T' but available in 64-bit mode\n+(define_constraint \"W\"\n+ \"Memory reference for 'e' constraint floating-point register\"\n+ (and (match_code \"mem,reg\")\n+      (match_test \"memory_ok_for_ldd (op)\")))\n+\n+(define_constraint \"Y\"\n+ \"The vector zero constant\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"const_zero_operand (op, mode)\")))"}, {"sha": "9950bd8cce343eac3051c88703795a94416fdef1", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -107,13 +107,13 @@ extern int mem_min_alignment (rtx, int);\n extern int pic_address_needs_scratch (rtx);\n extern int reg_unused_after (rtx, rtx);\n extern int register_ok_for_ldd (rtx);\n+extern int memory_ok_for_ldd (rtx);\n extern int registers_ok_for_ldd_peep (rtx, rtx);\n extern int v9_regcmp_p (enum rtx_code);\n /* Function used for V8+ code generation.  Returns 1 if the high\n    32 bits of REG are 0 before INSN.  */   \n extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n-extern int sparc_extra_constraint_check (rtx, int, int);\n extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n #endif /* RTX_CODE */\n "}, {"sha": "c69f6182162b1131cbc0995dd26d7bdb53fbd125", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 33, "deletions": 67, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -6744,21 +6744,49 @@ mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n   return 1;\n }\n \n-/* Return 1 if reg is a pseudo, or is the first register in \n-   a hard register pair.  This makes it a candidate for use in\n+/* Return 1 if reg is a pseudo, or is the first register in\n+   a hard register pair.  This makes it suitable for use in\n    ldd and std insns.  */\n \n int\n register_ok_for_ldd (rtx reg)\n {\n   /* We might have been passed a SUBREG.  */\n-  if (GET_CODE (reg) != REG) \n+  if (!REG_P (reg))\n     return 0;\n \n   if (REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     return (REGNO (reg) % 2 == 0);\n-  else \n-    return 1;\n+\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a memory whose address is known to be\n+   aligned to 8-byte boundary, or a pseudo during reload.\n+   This makes it suitable for use in ldd and std insns.  */\n+\n+int\n+memory_ok_for_ldd (rtx op)\n+{\n+  if (MEM_P (op))\n+    {\n+      /* In 64-bit mode, we assume that the address is word-aligned.  */\n+      if (TARGET_ARCH32 && !mem_min_alignment (op, 8))\n+\treturn 0;\n+\n+      if ((reload_in_progress || reload_completed)\n+\t  && !strict_memory_address_p (Pmode, XEXP (op, 0)))\n+\treturn 0;\n+    }\n+  else if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!(reload_in_progress && reg_renumber [REGNO (op)] < 0))\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  return 1;\n }\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n@@ -8356,68 +8384,6 @@ sparc_fold_builtin (tree fndecl, tree arglist, bool ignore)\n   return NULL_TREE;\n }\n \f\n-int\n-sparc_extra_constraint_check (rtx op, int c, int strict)\n-{\n-  int reload_ok_mem;\n-\n-  if (TARGET_ARCH64\n-      && (c == 'T' || c == 'U'))\n-    return 0;\n-\n-  switch (c)\n-    {\n-    case 'Q':\n-      return fp_sethi_p (op);\n-\n-    case 'R':\n-      return fp_mov_p (op);\n-\n-    case 'S':\n-      return fp_high_losum_p (op);\n-\n-    case 'U':\n-      if (! strict\n-\t  || (GET_CODE (op) == REG\n-\t      && (REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t\t  || reg_renumber[REGNO (op)] >= 0)))\n-\treturn register_ok_for_ldd (op);\n-\n-      return 0;\n-\n-    case 'W':\n-    case 'T':\n-      break;\n-\n-    case 'Y':\n-      return const_zero_operand (op, GET_MODE (op));\n-\n-    default:\n-      return 0;\n-    }\n-\n-  /* Our memory extra constraints have to emulate the\n-     behavior of 'm' and 'o' in order for reload to work\n-     correctly.  */\n-  if (GET_CODE (op) == MEM)\n-    {\n-      reload_ok_mem = 0;\n-      if ((TARGET_ARCH64 || mem_min_alignment (op, 8))\n-\t  && (! strict\n-\t      || strict_memory_address_p (Pmode, XEXP (op, 0))))\n-\treload_ok_mem = 1;\n-    }\n-  else\n-    {\n-      reload_ok_mem = (reload_in_progress\n-\t\t       && GET_CODE (op) == REG\n-\t\t       && REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t\t       && reg_renumber [REGNO (op)] < 0);\n-    }\n-\n-  return reload_ok_mem;\n-}\n-\n /* ??? This duplicates information provided to the compiler by the\n    ??? scheduler description.  Some day, teach genautomata to output\n    ??? the latencies and then CSE will just use that.  */"}, {"sha": "51474945e3fd3c24f039c8c2d54ff25c9375187f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -1210,42 +1210,6 @@ extern char leaf_reg_remap[];\n /* Local macro to handle the two v9 classes of FP regs.  */\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n \n-/* Get reg_class from a letter such as appears in the machine description.\n-   In the not-v9 case, coerce v9's 'e' class to 'f', so we can use 'e' in the\n-   .md file for v8 and v9.\n-   'd' and 'b' are used for single and double precision VIS operations,\n-   if TARGET_VIS.\n-   'h' is used for V8+ 64 bit global and out registers.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\t\\\n-(TARGET_V9\t\t\t\t\t\\\n- ? ((C) == 'f' ? FP_REGS\t\t\t\\\n-    : (C) == 'e' ? EXTRA_FP_REGS \t\t\\\n-    : (C) == 'c' ? FPCC_REGS\t\t\t\\\n-    : ((C) == 'd' && TARGET_VIS) ? FP_REGS\\\n-    : ((C) == 'b' && TARGET_VIS) ? EXTRA_FP_REGS\\\n-    : ((C) == 'h' && TARGET_V8PLUS) ? I64_REGS\\\n-    : NO_REGS)\t\t\t\t\t\\\n- : ((C) == 'f' ? FP_REGS\t\t\t\\\n-    : (C) == 'e' ? FP_REGS\t\t\t\\\n-    : (C) == 'c' ? FPCC_REGS\t\t\t\\\n-    : NO_REGS))\n-\n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of CONST_INTs.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   `I' is used for the range of constants an insn can actually contain.\n-   `J' is used for the range which is just zero (since that is R0).\n-   `K' is used for constants which can be loaded with a single sethi insn.\n-   `L' is used for the range of constants supported by the movcc insns.\n-   `M' is used for the range of constants supported by the movrcc insns.\n-   `N' is like K, but for constants wider than 32 bits.\n-   `O' is used for the range which is just 4096.\n-   `P' is free.  */\n-\n /* Predicates for 10-bit, 11-bit and 13-bit signed constants.  */\n #define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x200 < 0x400)\n #define SPARC_SIMM11_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x400 < 0x800)\n@@ -1272,24 +1236,6 @@ extern char leaf_reg_remap[];\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? SPARC_SIMM13_P (VALUE)\t\t\t\\\n-   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n-   : (C) == 'K' ? SPARC_SETHI32_P (VALUE)\t\t\\\n-   : (C) == 'L' ? SPARC_SIMM11_P (VALUE)\t\t\\\n-   : (C) == 'M' ? SPARC_SIMM10_P (VALUE)\t\t\\\n-   : (C) == 'N' ? SPARC_SETHI_P (VALUE)\t\t\t\\\n-   : (C) == 'O' ? (VALUE) == 4096\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for CONST_DOUBLEs, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-  ((C) == 'G' ? const_zero_operand (VALUE, GET_MODE (VALUE))\t\\\n-   : (C) == 'H' ? arith_double_operand (VALUE, DImode)\t\t\\\n-   : 0)\n-\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -1888,28 +1834,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-/* Optional extra constraints for this machine.\n-\n-   'Q' handles floating point constants which can be moved into\n-       an integer register with a single sethi instruction.\n-\n-   'R' handles floating point constants which can be moved into\n-       an integer register with a single mov instruction.\n-\n-   'S' handles floating point constants which can be moved into\n-       an integer register using a high/lo_sum sequence.\n-\n-   'T' handles memory addresses where the alignment is known to\n-       be at least 8 bytes.\n-\n-   `U' handles all pseudo registers or a hard even numbered\n-       integer register, needed for ldd/std instructions.\n-\n-   'W' handles the memory operand when moving operands in/out\n-       of 'e' constraint floating point registers.\n-\n-   'Y' handles the zero vector constant.  */\n-\n #ifndef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index\n@@ -1923,25 +1847,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X)  REG_OK_FOR_INDEX_P (X)\n \n-/* 'T', 'U' are for aligned memory loads which aren't needed for arch64.\n-   'W' is like 'T' but is assumed true on arch64.\n-\n-   Remember to accept pseudo-registers for memory constraints if reload is\n-   in progress.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C) \\\n-\tsparc_extra_constraint_check(OP, C, 0)\n-\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-#define EXTRA_CONSTRAINT(OP, C) \\\n-\tsparc_extra_constraint_check(OP, C, 1)\n-\n #endif\n \f\n /* Should gcc use [%reg+%lo(xx)+offset] addresses?  */"}, {"sha": "dc6c3a31645be1757ebf9ac8fdf632fb1969e2cb", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157891a301cf9b584167391d816d391c89b4399d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=157891a301cf9b584167391d816d391c89b4399d", "patch": "@@ -320,9 +320,10 @@\n (include \"niagara2.md\")\n \n \n-;; Operand and operator predicates.\n+;; Operand and operator predicates and constraints\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \n \n ;; Compare instructions."}]}