{"sha": "15e934bf713f8a57abdd0d93d17deac3340e5158", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlOTM0YmY3MTNmOGE1N2FiZGQwZDkzZDE3ZGVhYzMzNDBlNTE1OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-09-10T14:54:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-09-10T14:54:41Z"}, "message": "[multiple changes]\n\n2013-09-10  Robert Dewar  <dewar@adacore.com>\n\n\t* aspects.ads (Delay_Type): New type (Aspect_Delay): New table.\n\t* einfo.adb (Has_Delayed_Rep_Aspects): New flag\n\t(May_Inherit_Delayed_Rep_Aspects): New flag (Rep_Clause): Removed\n\t(use Get_Attribute_Representation_Clause).\n\t* einfo.ads (Has_Delayed_Rep_Aspects): New flag\n\t(May_Inherit_Delayed_Rep_Aspects): New flag\n\t* freeze.adb: Minor reformatting\n\t* sem_ch13.adb (Analyze_Aspect_Speficifications): Redo\n\thandling of delayed evaluation, including optimizing some cases\n\tand avoiding delays.\n\t(Analyze_Aspects_At_Freeze_Point): Now\n\thandled inheriting delayed rep aspects for type derivation case.\n\t(Inherit_Delayed_Rep_Aspects): New procedure\n\t* sem_ch13.ads (Analyze_Aspects_At_Freeze_Point): Now handled\n\tinheriting delayed rep aspects for type derivation case.\n\t* sem_ch3.adb (Build_Derived_Type): Set\n\tMay_Inherit_Derived_Rep_Aspects if parent type flag\n\tHas_Delayed_Rep_Aspects is set\n\n2013-09-10  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.adb (Finalize): Don't delete real errors with specific\n\twarning control.\n\n2013-09-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Timed_Entry_Call,\n\tExpand_N_Conditional_Entry_Call, Expand_N_Asynchronous_Select):\n\tHandle properly a trigger that is  a call to a primitive operation\n\tof a type that implements a limited interface, if the type itself\n\tis not limited.\n\nFrom-SVN: r202456", "tree": {"sha": "20f2e2ec7f0d0e8cdceee063a7ca0931e90c5c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20f2e2ec7f0d0e8cdceee063a7ca0931e90c5c14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e934bf713f8a57abdd0d93d17deac3340e5158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e934bf713f8a57abdd0d93d17deac3340e5158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e934bf713f8a57abdd0d93d17deac3340e5158", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e934bf713f8a57abdd0d93d17deac3340e5158/comments", "author": null, "committer": null, "parents": [{"sha": "573e5dd6ace97bde5d1ab096ae2c4f8c02534a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573e5dd6ace97bde5d1ab096ae2c4f8c02534a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573e5dd6ace97bde5d1ab096ae2c4f8c02534a17"}], "stats": {"total": 806, "additions": 655, "deletions": 151}, "files": [{"sha": "21dadb2712769ea8912d22291f0dd29befef94b8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -1,3 +1,37 @@\n+2013-09-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* aspects.ads (Delay_Type): New type (Aspect_Delay): New table.\n+\t* einfo.adb (Has_Delayed_Rep_Aspects): New flag\n+\t(May_Inherit_Delayed_Rep_Aspects): New flag (Rep_Clause): Removed\n+\t(use Get_Attribute_Representation_Clause).\n+\t* einfo.ads (Has_Delayed_Rep_Aspects): New flag\n+\t(May_Inherit_Delayed_Rep_Aspects): New flag\n+\t* freeze.adb: Minor reformatting\n+\t* sem_ch13.adb (Analyze_Aspect_Speficifications): Redo\n+\thandling of delayed evaluation, including optimizing some cases\n+\tand avoiding delays.\n+\t(Analyze_Aspects_At_Freeze_Point): Now\n+\thandled inheriting delayed rep aspects for type derivation case.\n+\t(Inherit_Delayed_Rep_Aspects): New procedure\n+\t* sem_ch13.ads (Analyze_Aspects_At_Freeze_Point): Now handled\n+\tinheriting delayed rep aspects for type derivation case.\n+\t* sem_ch3.adb (Build_Derived_Type): Set\n+\tMay_Inherit_Derived_Rep_Aspects if parent type flag\n+\tHas_Delayed_Rep_Aspects is set\n+\n+2013-09-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.adb (Finalize): Don't delete real errors with specific\n+\twarning control.\n+\n+2013-09-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_N_Timed_Entry_Call,\n+\tExpand_N_Conditional_Entry_Call, Expand_N_Asynchronous_Select):\n+\tHandle properly a trigger that is  a call to a primitive operation\n+\tof a type that implements a limited interface, if the type itself\n+\tis not limited.\n+\n 2013-09-10  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sinfo.ads, exp_ch9.adb, sem_prag.adb, sem_ch12.adb,"}, {"sha": "a7429d79119d303d5404e0baf1fa86425f105cee", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -459,6 +459,203 @@ package Aspects is\n    --  Given an aspect specification, return the corresponding aspect_id value.\n    --  If the name does not match any aspect, return No_Aspect.\n \n+   ------------------------------------\n+   -- Delaying Evaluation of Aspects --\n+   ------------------------------------\n+\n+   --  The RM requires that all language defined aspects taking an expression\n+   --  delay evaluation of the expression till the freeze point of the entity\n+   --  to which the aspect applies. This allows forward references, and is of\n+   --  use for example in connection with preconditions and postconditions\n+   --  where the requirement of making all references in contracts to local\n+   --  functions be backwards references would be onerous.\n+\n+   --  For consistency, even attributes like Size are delayed, so we can do:\n+\n+   --    type A is range 1 .. 10\n+   --      with Size => Not_Defined_Yet;\n+   --    ..\n+   --    Not_Defined_Yet : constant := 64;\n+\n+   --  Resulting in A having a size of 64, which gets set when A is frozen.\n+   --  Furthermore, we can have a situation like\n+\n+   --    type A is range 1 .. 10\n+   --      with Size => Not_Defined_Yet;\n+   --    ..\n+   --    type B is new A;\n+   --    ..\n+   --    Not_Defined_Yet : constant := 64;\n+\n+   --  where the Size of A is considered to have been previously specified at\n+   --  the point of derivation, even though the actual value of the size is\n+   --  not known yet, and in this example B inherits the size value of 64.\n+\n+   --  Our normal implementation model (prior to Ada 2012) was simply to copy\n+   --  inheritable attributes at the point of derivation. Then any subsequent\n+   --  representation items apply either to the parent type, not affecting the\n+   --  derived type, or to the derived type, not affecting the parent type.\n+\n+   --  To deal with the delayed aspect case, we use two flags. The first is\n+   --  set on the parent type if it has delayed representation aspects. This\n+   --  flag Has_Delayed_Rep_Aspects indicates that if we derive from this type\n+   --  we have to worry about making sure we inherit any delayed types. The\n+   --  second flag is set on a derived type. May_Have_Inherited_Rep_Aspects\n+   --  is set if the parent type has Has_Delayed_Rep_Aspects set.\n+\n+   --  When we freeze a derived type, if the May_Have_Inherited_Rep_Aspects\n+   --  flag is set, then we call Freeze.Inherit_Delayed_Rep_Aspects when\n+   --  the derived type is frozen, which deals with the necessary copying of\n+   --  information from the parent type, which must be frozen at that point\n+   --  (since freezing the derived type first freezes the parent type).\n+\n+   --  The following shows which aspects are delayed. There are three cases:\n+\n+   type Delay_Type is\n+     (Always_Delay,\n+      --  This aspect is not a representation aspect that can be inherited and\n+      --  is always delayed, as required by the language definition.\n+\n+      Never_Delay,\n+      --  There are two cases. There are language defined attributes like\n+      --  Convention where the \"expression\" is simply an uninterprted\n+      --  identifier, and there is no issue of evaluating it and thus no\n+      --  issue of delaying the evaluation. The second case is implementation\n+      --  defined attributes where we have decided that we don't want to\n+      --  allow delays (and for our own attributes we can do what we like!)\n+\n+      Rep_Aspect);\n+      --  These are the cases of representation aspects that are in general\n+      --  delayed, and where there is a potential issue of derived types that\n+      --  inherit delayed representation values\n+\n+   --  Note: even if this table indicates that an aspect is delayed, we never\n+   --  delay Boolean aspects that have a missing expression (taken as True),\n+   --  or expressions for delayed rep items that consist of an integer literal\n+   --  (most cases of Size etc. in practice), since in these cases we know we\n+   --  can get the value of the expression without delay. Note that we still\n+   --  need to delay Boolean aspects that are specifically set to True:\n+\n+   --     type R is array (0 .. 31) of Boolean\n+   --       with Pack => True;\n+   --     True : constant Boolean := False;\n+\n+   --  This is nonsense, but we need to make it work and result in R not\n+   --  being packed, and if we have something like:\n+\n+   --     type R is array (0 .. 31) of Boolean\n+   --       with Pack => True;\n+   --     RR : R;\n+   --     True : constant Boolean := False;\n+\n+   --  This is illegal because the visibility of True changes after the freeze\n+   --  point, which is not allowed, and we need the delay mechanism to properly\n+   --  diagnose this error.\n+\n+   Aspect_Delay : constant array (Aspect_Id) of Delay_Type :=\n+     (No_Aspect                           => Always_Delay,\n+      Aspect_Address                      => Always_Delay,\n+      Aspect_All_Calls_Remote             => Always_Delay,\n+      Aspect_Asynchronous                 => Always_Delay,\n+      Aspect_Attach_Handler               => Always_Delay,\n+      Aspect_Compiler_Unit                => Always_Delay,\n+      Aspect_Constant_Indexing            => Always_Delay,\n+      Aspect_Contract_Cases               => Always_Delay,\n+      Aspect_CPU                          => Always_Delay,\n+      Aspect_Default_Iterator             => Always_Delay,\n+      Aspect_Default_Value                => Always_Delay,\n+      Aspect_Default_Component_Value      => Always_Delay,\n+      Aspect_Depends                      => Always_Delay,\n+      Aspect_Discard_Names                => Always_Delay,\n+      Aspect_Dispatching_Domain           => Always_Delay,\n+      Aspect_Dynamic_Predicate            => Always_Delay,\n+      Aspect_Elaborate_Body               => Always_Delay,\n+      Aspect_External_Name                => Always_Delay,\n+      Aspect_External_Tag                 => Always_Delay,\n+      Aspect_Export                       => Always_Delay,\n+      Aspect_Favor_Top_Level              => Always_Delay,\n+      Aspect_Global                       => Always_Delay,\n+      Aspect_Implicit_Dereference         => Always_Delay,\n+      Aspect_Import                       => Always_Delay,\n+      Aspect_Independent                  => Always_Delay,\n+      Aspect_Independent_Components       => Always_Delay,\n+      Aspect_Inline                       => Always_Delay,\n+      Aspect_Inline_Always                => Always_Delay,\n+      Aspect_Input                        => Always_Delay,\n+      Aspect_Interrupt_Handler            => Always_Delay,\n+      Aspect_Interrupt_Priority           => Always_Delay,\n+      Aspect_Invariant                    => Always_Delay,\n+      Aspect_Iterator_Element             => Always_Delay,\n+      Aspect_Link_Name                    => Always_Delay,\n+      Aspect_Lock_Free                    => Always_Delay,\n+      Aspect_No_Return                    => Always_Delay,\n+      Aspect_Output                       => Always_Delay,\n+      Aspect_Persistent_BSS               => Always_Delay,\n+      Aspect_Post                         => Always_Delay,\n+      Aspect_Postcondition                => Always_Delay,\n+      Aspect_Pre                          => Always_Delay,\n+      Aspect_Precondition                 => Always_Delay,\n+      Aspect_Predicate                    => Always_Delay,\n+      Aspect_Preelaborable_Initialization => Always_Delay,\n+      Aspect_Preelaborate                 => Always_Delay,\n+      Aspect_Preelaborate_05              => Always_Delay,\n+      Aspect_Priority                     => Always_Delay,\n+      Aspect_Pure                         => Always_Delay,\n+      Aspect_Pure_05                      => Always_Delay,\n+      Aspect_Pure_12                      => Always_Delay,\n+      Aspect_Pure_Function                => Always_Delay,\n+      Aspect_Read                         => Always_Delay,\n+      Aspect_Relative_Deadline            => Always_Delay,\n+      Aspect_Remote_Access_Type           => Always_Delay,\n+      Aspect_Remote_Call_Interface        => Always_Delay,\n+      Aspect_Remote_Types                 => Always_Delay,\n+      Aspect_Shared                       => Always_Delay,\n+      Aspect_Shared_Passive               => Always_Delay,\n+      Aspect_Simple_Storage_Pool          => Always_Delay,\n+      Aspect_Simple_Storage_Pool_Type     => Always_Delay,\n+      Aspect_Static_Predicate             => Always_Delay,\n+      Aspect_Storage_Pool                 => Always_Delay,\n+      Aspect_Stream_Size                  => Always_Delay,\n+      Aspect_Suppress                     => Always_Delay,\n+      Aspect_Suppress_Debug_Info          => Always_Delay,\n+      Aspect_Type_Invariant               => Always_Delay,\n+      Aspect_Unchecked_Union              => Always_Delay,\n+      Aspect_Universal_Aliasing           => Always_Delay,\n+      Aspect_Universal_Data               => Always_Delay,\n+      Aspect_Unmodified                   => Always_Delay,\n+      Aspect_Unreferenced                 => Always_Delay,\n+      Aspect_Unreferenced_Objects         => Always_Delay,\n+      Aspect_Unsuppress                   => Always_Delay,\n+      Aspect_Variable_Indexing            => Always_Delay,\n+      Aspect_Write                        => Always_Delay,\n+\n+      Aspect_Abstract_State               => Never_Delay,\n+      Aspect_Ada_2005                     => Never_Delay,\n+      Aspect_Ada_2012                     => Never_Delay,\n+      Aspect_Convention                   => Never_Delay,\n+      Aspect_Dimension                    => Never_Delay,\n+      Aspect_Dimension_System             => Never_Delay,\n+      Aspect_SPARK_Mode                   => Never_Delay,\n+      Aspect_Synchronization              => Never_Delay,\n+      Aspect_Test_Case                    => Never_Delay,\n+      Aspect_Warnings                     => Never_Delay,\n+\n+      Aspect_Alignment                    => Rep_Aspect,\n+      Aspect_Atomic                       => Rep_Aspect,\n+      Aspect_Atomic_Components            => Rep_Aspect,\n+      Aspect_Bit_Order                    => Rep_Aspect,\n+      Aspect_Component_Size               => Rep_Aspect,\n+      Aspect_Machine_Radix                => Rep_Aspect,\n+      Aspect_Object_Size                  => Rep_Aspect,\n+      Aspect_Pack                         => Rep_Aspect,\n+      Aspect_Scalar_Storage_Order         => Rep_Aspect,\n+      Aspect_Size                         => Rep_Aspect,\n+      Aspect_Small                        => Rep_Aspect,\n+      Aspect_Storage_Size                 => Rep_Aspect,\n+      Aspect_Value_Size                   => Rep_Aspect,\n+      Aspect_Volatile                     => Rep_Aspect,\n+      Aspect_Volatile_Components          => Rep_Aspect);\n+\n    ---------------------------------------------------\n    -- Handling of Aspect Specifications in the Tree --\n    ---------------------------------------------------"}, {"sha": "1da975d0a9e1a94ab8be87f01e42d2af89419ec5", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -548,8 +548,9 @@ package body Einfo is\n    --    Has_Static_Predicate_Aspect     Flag259\n    --    Has_Loop_Entry_Attributes       Flag260\n \n-   --    (unused)                        Flag261\n-   --    (unused)                        Flag262\n+   --    Has_Delayed_Rep_Aspects         Flag261\n+   --    May_Inherit_Delayed_Rep_Aspects Flag262\n+\n    --    (unused)                        Flag263\n    --    (unused)                        Flag264\n    --    (unused)                        Flag265\n@@ -589,10 +590,6 @@ package body Einfo is\n    --  Determine whether abstract state State has a particular property denoted\n    --  by the name Prop_Nam.\n \n-   function Rep_Clause (Id : E; Rep_Name : Name_Id) return N;\n-   --  Returns the attribute definition clause for Id whose name is Rep_Name.\n-   --  Returns Empty if no matching attribute definition clause found for Id.\n-\n    ---------------\n    -- Float_Rep --\n    ---------------\n@@ -638,28 +635,6 @@ package body Einfo is\n       return False;\n    end Has_Property;\n \n-   ----------------\n-   -- Rep_Clause --\n-   ----------------\n-\n-   function Rep_Clause (Id : E; Rep_Name : Name_Id) return N is\n-      Ritem : Node_Id;\n-\n-   begin\n-      Ritem := First_Rep_Item (Id);\n-      while Present (Ritem) loop\n-         if Nkind (Ritem) = N_Attribute_Definition_Clause\n-           and then Chars (Ritem) = Rep_Name\n-         then\n-            return Ritem;\n-         else\n-            Next_Rep_Item (Ritem);\n-         end if;\n-      end loop;\n-\n-      return Empty;\n-   end Rep_Clause;\n-\n    --------------------------------\n    -- Attribute Access Functions --\n    --------------------------------\n@@ -1380,6 +1355,12 @@ package body Einfo is\n       return Flag18 (Id);\n    end Has_Delayed_Freeze;\n \n+   function Has_Delayed_Rep_Aspects (Id : E) return B is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      return Flag261 (Id);\n+   end Has_Delayed_Rep_Aspects;\n+\n    function Has_Discriminants (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -2421,6 +2402,11 @@ package body Einfo is\n       return Flag168 (Id);\n    end Materialize_Entity;\n \n+   function May_Inherit_Delayed_Rep_Aspects (Id : E) return B is\n+   begin\n+      return Flag262 (Id);\n+   end May_Inherit_Delayed_Rep_Aspects;\n+\n    function Mechanism (Id : E) return M is\n    begin\n       pragma Assert (Ekind (Id) = E_Function or else Is_Formal (Id));\n@@ -3978,6 +3964,12 @@ package body Einfo is\n       Set_Flag18 (Id, V);\n    end Set_Has_Delayed_Freeze;\n \n+   procedure Set_Has_Delayed_Rep_Aspects (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      Set_Flag261 (Id, V);\n+   end Set_Has_Delayed_Rep_Aspects;\n+\n    procedure Set_Has_Discriminants (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -5063,6 +5055,11 @@ package body Einfo is\n       Set_Flag168 (Id, V);\n    end Set_Materialize_Entity;\n \n+   procedure Set_May_Inherit_Delayed_Rep_Aspects (Id : E; V : B := True) is\n+   begin\n+      Set_Flag262 (Id, V);\n+   end Set_May_Inherit_Delayed_Rep_Aspects;\n+\n    procedure Set_Mechanism (Id : E; V : M) is\n    begin\n       pragma Assert (Ekind (Id) = E_Function or else Is_Formal (Id));\n@@ -5969,7 +5966,7 @@ package body Einfo is\n \n    function Address_Clause (Id : E) return N is\n    begin\n-      return Rep_Clause (Id, Name_Address);\n+      return Get_Attribute_Definition_Clause (Id, Attribute_Address);\n    end Address_Clause;\n \n    ---------------\n@@ -5994,7 +5991,7 @@ package body Einfo is\n \n    function Alignment_Clause (Id : E) return N is\n    begin\n-      return Rep_Clause (Id, Name_Alignment);\n+      return Get_Attribute_Definition_Clause (Id, Attribute_Alignment);\n    end Alignment_Clause;\n \n    -------------------\n@@ -7627,7 +7624,7 @@ package body Einfo is\n \n    function Size_Clause (Id : E) return N is\n    begin\n-      return Rep_Clause (Id, Name_Size);\n+      return Get_Attribute_Definition_Clause (Id, Attribute_Size);\n    end Size_Clause;\n \n    ------------------------\n@@ -7636,7 +7633,7 @@ package body Einfo is\n \n    function Stream_Size_Clause (Id : E) return N is\n    begin\n-      return Rep_Clause (Id, Name_Stream_Size);\n+      return Get_Attribute_Definition_Clause (Id, Attribute_Stream_Size);\n    end Stream_Size_Clause;\n \n    ------------------\n@@ -7895,6 +7892,7 @@ package body Einfo is\n       W (\"Has_Default_Aspect\",              Flag39  (Id));\n       W (\"Has_Delayed_Aspects\",             Flag200 (Id));\n       W (\"Has_Delayed_Freeze\",              Flag18  (Id));\n+      W (\"Has_Delayed_Rep_Aspects\",         Flag261 (Id));\n       W (\"Has_Discriminants\",               Flag5   (Id));\n       W (\"Has_Dispatch_Table\",              Flag220 (Id));\n       W (\"Has_Dynamic_Predicate_Aspect\",    Flag258 (Id));\n@@ -8070,6 +8068,7 @@ package body Einfo is\n       W (\"Low_Bound_Tested\",                Flag205 (Id));\n       W (\"Machine_Radix_10\",                Flag84  (Id));\n       W (\"Materialize_Entity\",              Flag168 (Id));\n+      W (\"May_Inherit_Delayed_Rep_Aspects\", Flag262 (Id));\n       W (\"Must_Be_On_Byte_Boundary\",        Flag183 (Id));\n       W (\"Must_Have_Preelab_Init\",          Flag208 (Id));\n       W (\"Needs_Debug_Info\",                Flag147 (Id));"}, {"sha": "0449674d861763b71e09628c1813f49da7880dda", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -1473,6 +1473,15 @@ package Einfo is\n --       apsect. If this flag is set, then a corresponding aspect specification\n --       node will be present on the rep item chain for the entity.\n \n+--    Has_Delayed_Rep_Aspects (Flag261)\n+--       Defined in all type and subtypes. This flag is set if there is at\n+--       least one aspect for a representation characteristic that has to be\n+--       delayed and is one of the characteristics that may be inherited by\n+--       types derived from this type if not overridden. If this flag is set,\n+--       then types derived from this type have May_Inherit_Delayed_Rep_Aspects\n+--       set, signalling that Freeze.Inhert_Delayed_Rep_Aspects must be called\n+--       at the freeze point of the derived type.\n+\n --    Has_Discriminants (Flag5)\n --       Defined in all types and subtypes. For types that are allowed to have\n --       discriminants (record types and subtypes, task types and subtypes,\n@@ -1796,7 +1805,7 @@ package Einfo is\n \n --    Has_Size_Clause (Flag29)\n --       Defined in entities for types and objects. Set if a size clause is\n---       Defined for the entity. Used to prevent multiple Size clauses for a\n+--       defined for the entity. Used to prevent multiple Size clauses for a\n --       given entity. Note that it is always initially cleared for a derived\n --       type, even though the Size for such a type is inherited from a Size\n --       clause given for the parent type.\n@@ -1880,7 +1889,7 @@ package Einfo is\n --       Types can have unknown discriminants either from their declaration or\n --       through type derivation. The use of this flag exactly meets the spec\n --       in RM 3.7(26). Note that all class-wide types are considered to have\n---       unknown discriminants. Note that both Has_Discriminants and\n+--       unknown discriminants. Note that both flags Has_Discriminants and\n --       Has_Unknown_Discriminants may be true for a type. Class-wide types and\n --       their subtypes have unknown discriminants and can have declared ones\n --       as well. Private types declared with unknown discriminants may have a\n@@ -3073,6 +3082,14 @@ package Einfo is\n --       containing the renamed address should be allocated. This is needed so\n --       that the debugger can find the entity.\n \n+--    May_Inherit_Delayed_Rep_Aspects (Flag262)\n+--       Defined in all entities for types and subtypes. Set if the type is\n+--       derived from a type which has delayed rep aspects (marked by the flag\n+--       Has_Delayed_Rep_Aspects being set). In this case, at the freeze point\n+--       for the derived type we know that the parent type is frozen, and if\n+--       a given attribute has not been set for the derived type, we copy the\n+--       value from the parent type. See Freeze.Inherit_Delayed_Rep_Aspects.\n+\n --    Mechanism (Uint8) (returned as Mechanism_Type)\n --       Defined in functions and non-generic formal parameters. Indicates\n --       the mechanism to be used for the function return or for the formal\n@@ -5009,6 +5026,7 @@ package Einfo is\n    --    Has_Constrained_Partial_View        (Flag187)\n    --    Has_Controlled_Component            (Flag43)   (base type only)\n    --    Has_Default_Aspect                  (Flag39)   (base type only)\n+   --    Has_Delayed_Rep_Aspects             (Flag261)\n    --    Has_Discriminants                   (Flag5)\n    --    Has_Dynamic_Predicate_Aspect        (Flag258)\n    --    Has_Independent_Components          (Flag34)   (base type only)\n@@ -5048,6 +5066,7 @@ package Einfo is\n    --    Is_Volatile                         (Flag16)\n    --    Itype_Printed                       (Flag202)  (itypes only)\n    --    Known_To_Have_Preelab_Init          (Flag207)\n+   --    May_Inherit_Delayed_Rep_Aspects     (Flag262)\n    --    Must_Be_On_Byte_Boundary            (Flag183)\n    --    Must_Have_Preelab_Init              (Flag208)\n    --    Optimize_Alignment_Space            (Flag241)\n@@ -6286,6 +6305,7 @@ package Einfo is\n    function Has_Default_Aspect                  (Id : E) return B;\n    function Has_Delayed_Aspects                 (Id : E) return B;\n    function Has_Delayed_Freeze                  (Id : E) return B;\n+   function Has_Delayed_Rep_Aspects             (Id : E) return B;\n    function Has_Discriminants                   (Id : E) return B;\n    function Has_Dispatch_Table                  (Id : E) return B;\n    function Has_Dynamic_Predicate_Aspect        (Id : E) return B;\n@@ -6471,6 +6491,7 @@ package Einfo is\n    function Machine_Radix_10                    (Id : E) return B;\n    function Master_Id                           (Id : E) return E;\n    function Materialize_Entity                  (Id : E) return B;\n+   function May_Inherit_Delayed_Rep_Aspects     (Id : E) return B;\n    function Mechanism                           (Id : E) return M;\n    function Modulus                             (Id : E) return U;\n    function Must_Be_On_Byte_Boundary            (Id : E) return B;\n@@ -6896,6 +6917,7 @@ package Einfo is\n    procedure Set_Has_Default_Aspect              (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Aspects             (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n+   procedure Set_Has_Delayed_Rep_Aspects         (Id : E; V : B := True);\n    procedure Set_Has_Discriminants               (Id : E; V : B := True);\n    procedure Set_Has_Dispatch_Table              (Id : E; V : B := True);\n    procedure Set_Has_Dynamic_Predicate_Aspect    (Id : E; V : B := True);\n@@ -7086,6 +7108,7 @@ package Einfo is\n    procedure Set_Machine_Radix_10                (Id : E; V : B := True);\n    procedure Set_Master_Id                       (Id : E; V : E);\n    procedure Set_Materialize_Entity              (Id : E; V : B := True);\n+   procedure Set_May_Inherit_Delayed_Rep_Aspects (Id : E; V : B := True);\n    procedure Set_Mechanism                       (Id : E; V : M);\n    procedure Set_Modulus                         (Id : E; V : U);\n    procedure Set_Must_Be_On_Byte_Boundary        (Id : E; V : B := True);\n@@ -7603,6 +7626,7 @@ package Einfo is\n    pragma Inline (Has_Default_Aspect);\n    pragma Inline (Has_Delayed_Aspects);\n    pragma Inline (Has_Delayed_Freeze);\n+   pragma Inline (Has_Delayed_Rep_Aspects);\n    pragma Inline (Has_Discriminants);\n    pragma Inline (Has_Dispatch_Table);\n    pragma Inline (Has_Dynamic_Predicate_Aspect);\n@@ -7832,6 +7856,7 @@ package Einfo is\n    pragma Inline (Machine_Radix_10);\n    pragma Inline (Master_Id);\n    pragma Inline (Materialize_Entity);\n+   pragma Inline (May_Inherit_Delayed_Rep_Aspects);\n    pragma Inline (Mechanism);\n    pragma Inline (Modulus);\n    pragma Inline (Must_Be_On_Byte_Boundary);\n@@ -8061,6 +8086,7 @@ package Einfo is\n    pragma Inline (Set_Has_Default_Aspect);\n    pragma Inline (Set_Has_Delayed_Aspects);\n    pragma Inline (Set_Has_Delayed_Freeze);\n+   pragma Inline (Set_Has_Delayed_Rep_Aspects);\n    pragma Inline (Set_Has_Discriminants);\n    pragma Inline (Set_Has_Dispatch_Table);\n    pragma Inline (Set_Has_Dynamic_Predicate_Aspect);\n@@ -8250,6 +8276,7 @@ package Einfo is\n    pragma Inline (Set_Machine_Radix_10);\n    pragma Inline (Set_Master_Id);\n    pragma Inline (Set_Materialize_Entity);\n+   pragma Inline (Set_May_Inherit_Delayed_Rep_Aspects);\n    pragma Inline (Set_Mechanism);\n    pragma Inline (Set_Modulus);\n    pragma Inline (Set_Must_Be_On_Byte_Boundary);"}, {"sha": "b32f6a146f69209cbf450679a04eebcb0b044b3f", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -1302,7 +1302,7 @@ package body Errout is\n             CE : Error_Msg_Object renames Errors.Table (Cur);\n \n          begin\n-            if not CE.Deleted\n+            if (CE.Warn and not CE.Deleted)\n               and then\n                 (Warning_Specifically_Suppressed (CE.Sptr, CE.Text)\n                    or else"}, {"sha": "16e83091529be7a0d6aa41057fedd5b97b7fe018", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -136,6 +136,15 @@ package body Exp_Ch9 is\n    --  build record declaration. N is the type declaration, Ctyp is the\n    --  concurrent entity (task type or protected type).\n \n+   function Build_Dispatching_Tag_Check\n+     (K : Entity_Id;\n+      N : Node_Id) return Node_Id;\n+   --  Utility to create the tree to check whether the dispatching call in\n+   --  a timed entry call, a conditional entry call, or an asynchronous\n+   --  transfer of control is a call to a primitive of a non-synchronized type.\n+   --  K is the temporary that holds the tagged kind of the target object, and\n+   --  N is the enclosing construct.\n+\n    function Build_Entry_Count_Expression\n      (Concurrent_Type : Node_Id;\n       Component_List  : List_Id;\n@@ -1298,6 +1307,26 @@ package body Exp_Ch9 is\n               Limited_Present => True));\n    end Build_Corresponding_Record;\n \n+   ---------------------------------\n+   -- Build_Dispatching_Tag_Check --\n+   ---------------------------------\n+\n+   function Build_Dispatching_Tag_Check\n+     (K : Entity_Id;\n+      N : Node_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (N);\n+   begin\n+      return\n+         Make_Op_Or (Loc,\n+           Make_Op_Eq (Loc,\n+             Left_Opnd  => New_Reference_To (K, Loc),\n+             Right_Opnd => New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n+           Make_Op_Eq (Loc,\n+             Left_Opnd  => New_Reference_To (K, Loc),\n+             Right_Opnd => New_Reference_To (RTE (RE_TK_Tagged), Loc)));\n+   end Build_Dispatching_Tag_Check;\n+\n    ----------------------------------\n    -- Build_Entry_Count_Expression --\n    ----------------------------------\n@@ -6607,7 +6636,9 @@ package body Exp_Ch9 is\n    --       U   : Boolean;\n \n    --    begin\n-   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --       if K = Ada.Tags.TK_Limited_Tagged\n+   --         or else K = Ada.Tags.TK_Tagged\n+   --       then\n    --          <dispatching-call>;\n    --          <triggering-statements>;\n \n@@ -7206,26 +7237,19 @@ package body Exp_Ch9 is\n             Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (Ecall));\n \n             --  Generate:\n-            --    if K = Ada.Tags.TK_Limited_Tagged then\n+            --    if K = Ada.Tags.TK_Limited_Tagged\n+            --         or else K = Ada.Tags.TK_Tagged\n+            --       then\n             --       Lim_Typ_Stmts\n             --    else\n             --       Conc_Typ_Stmts\n             --    end if;\n \n             Append_To (Stmts,\n               Make_Implicit_If_Statement (N,\n-                Condition =>\n-                   Make_Op_Eq (Loc,\n-                     Left_Opnd  =>\n-                       New_Reference_To (K, Loc),\n-                     Right_Opnd =>\n-                       New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n-\n-                Then_Statements =>\n-                  Lim_Typ_Stmts,\n-\n-                Else_Statements =>\n-                  Conc_Typ_Stmts));\n+                Condition       => Build_Dispatching_Tag_Check (K, N),\n+                Then_Statements => Lim_Typ_Stmts,\n+                Else_Statements => Conc_Typ_Stmts));\n \n             Rewrite (N,\n               Make_Block_Statement (Loc,\n@@ -7665,7 +7689,9 @@ package body Exp_Ch9 is\n    --       S : Integer;\n \n    --    begin\n-   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --       if K = Ada.Tags.TK_Limited_Tagged\n+   --         or else K = Ada.Tags.TK_Tagged\n+   --       then\n    --          <dispatching-call>;\n    --          <triggering-statements>\n \n@@ -7891,26 +7917,19 @@ package body Exp_Ch9 is\n          Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (Blk));\n \n          --  Generate:\n-         --    if K = Ada.Tags.TK_Limited_Tagged then\n+         --    if K = Ada.Tags.TK_Limited_Tagged\n+         --         or else K = Ada.Tags.TK_Tagged\n+         --       then\n          --       Lim_Typ_Stmts\n          --    else\n          --       Conc_Typ_Stmts\n          --    end if;\n \n          Append_To (Stmts,\n            Make_Implicit_If_Statement (N,\n-             Condition =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd =>\n-                   New_Reference_To (K, Loc),\n-                 Right_Opnd =>\n-                   New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n-\n-             Then_Statements =>\n-               Lim_Typ_Stmts,\n-\n-             Else_Statements =>\n-               Conc_Typ_Stmts));\n+             Condition       => Build_Dispatching_Tag_Check (K, N),\n+             Then_Statements => Lim_Typ_Stmts,\n+             Else_Statements => Conc_Typ_Stmts));\n \n          Rewrite (N,\n            Make_Block_Statement (Loc,\n@@ -11951,7 +11970,9 @@ package body Exp_Ch9 is\n    --       S  : Integer;\n \n    --    begin\n-   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --       if K = Ada.Tags.TK_Limited_Tagged\n+   --         or else K = Ada.Tags.TK_Tagged\n+   --       then\n    --          <dispatching-call>;\n    --          <triggering-statements>\n \n@@ -12394,19 +12415,17 @@ package body Exp_Ch9 is\n          Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (E_Call));\n \n          --  Generate:\n-         --    if K = Ada.Tags.TK_Limited_Tagged then\n+         --    if K = Ada.Tags.TK_Limited_Tagged\n+         --         or else K = Ada.Tags.TK_Tagged\n+         --       then\n          --       Lim_Typ_Stmts\n          --    else\n          --       Conc_Typ_Stmts\n          --    end if;\n \n          Append_To (Stmts,\n            Make_Implicit_If_Statement (N,\n-             Condition       =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd  => New_Reference_To (K, Loc),\n-                 Right_Opnd =>\n-                   New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n+             Condition       => Build_Dispatching_Tag_Check (K, N),\n              Then_Statements => Lim_Typ_Stmts,\n              Else_Statements => Conc_Typ_Stmts));\n "}, {"sha": "58098be741db045467e255ce45af42f22fc861af", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -2463,12 +2463,14 @@ package body Freeze is\n                             or else (Chars (Comp) /= Name_uParent\n                                       and then Is_Controlled (Etype (Comp)))\n                             or else (Is_Protected_Type (Etype (Comp))\n-                                      and then Present\n-                                        (Corresponding_Record_Type\n-                                          (Etype (Comp)))\n-                                      and then Has_Controlled_Component\n-                                        (Corresponding_Record_Type\n-                                          (Etype (Comp)))))\n+                                      and then\n+                                        Present\n+                                          (Corresponding_Record_Type\n+                                             (Etype (Comp)))\n+                                      and then\n+                                        Has_Controlled_Component\n+                                          (Corresponding_Record_Type\n+                                             (Etype (Comp)))))\n                then\n                   Set_Has_Controlled_Component (Rec);\n                end if;\n@@ -2731,9 +2733,7 @@ package body Freeze is\n       --  Add checks to detect proper initialization of scalars that may appear\n       --  as subprogram parameters.\n \n-      if Is_Subprogram (E)\n-        and then Check_Validity_Of_Parameters\n-      then\n+      if Is_Subprogram (E) and then Check_Validity_Of_Parameters then\n          Apply_Parameter_Validity_Checks (E);\n       end if;\n \n@@ -3263,9 +3263,7 @@ package body Freeze is\n                --  then the only purpose of the Import pragma is to suppress\n                --  implicit initialization.\n \n-               if Is_Imported (E)\n-                 and then No (Address_Clause (E))\n-               then\n+               if Is_Imported (E) and then No (Address_Clause (E)) then\n                   Set_Is_Public (E);\n                end if;\n \n@@ -3275,7 +3273,7 @@ package body Freeze is\n                --  expects 8-bit sizes for these cases.\n \n                if (Convention (E) = Convention_C\n-                    or else\n+                     or else\n                    Convention (E) = Convention_CPP)\n                  and then Is_Enumeration_Type (Etype (E))\n                  and then not Is_Character_Type (Etype (E))\n@@ -3349,7 +3347,7 @@ package body Freeze is\n             --  enclosing statement sequence.\n \n             if Ekind_In (E, E_Constant, E_Variable)\n-                 and then not Has_Delayed_Freeze (E)\n+              and then not Has_Delayed_Freeze (E)\n             then\n                declare\n                   Init_Stmts : constant Node_Id :="}, {"sha": "03d635f95b97c222d45222221423904b07fb446e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 272, "deletions": 56, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -694,6 +694,29 @@ package body Sem_Ch13 is\n       --  This routine analyzes an Aspect_Default_[Component_]Value denoted by\n       --  the aspect specification node ASN.\n \n+      procedure Inherit_Delayed_Rep_Aspects (ASN : Node_Id);\n+      --  As discussed in the spec of Aspects (see Aspect_Delay declaration),\n+      --  a derived type can inherit aspects from its parent which have been\n+      --  specified at the time of the derivation using an aspect, as in:\n+      --\n+      --    type A is range 1 .. 10\n+      --      with Size => Not_Defined_Yet;\n+      --    ..\n+      --    type B is new A;\n+      --    ..\n+      --    Not_Defined_Yet : constant := 64;\n+      --\n+      --  In this example, the Size of A is considered to be specified prior\n+      --  to the derivation, and thus inherited, even though the value is not\n+      --  known at the time of derivation. To deal with this, we use two entity\n+      --  flags. The flag Has_Derived_Rep_Aspects is set in the parent type (A\n+      --  here), and then the flag May_Inherit_Delayed_Rep_Aspects is set in\n+      --  the derived type (B here). If this flag is set when the derived type\n+      --  is frozen, then this procedure is called to ensure proper inheritance\n+      --  of all delayed aspects from the paren type. The derived type is E,\n+      --  the argument to Analyze_Aspects_At_Freeze_Point. ASN is the first\n+      --  aspect specification node in the Rep_Item chain for the parent type.\n+\n       procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id);\n       --  Given an aspect specification node ASN whose expression is an\n       --  optional Boolean, this routines creates the corresponding pragma\n@@ -753,6 +776,181 @@ package body Sem_Ch13 is\n          end if;\n       end Analyze_Aspect_Default_Value;\n \n+      ---------------------------------\n+      -- Inherit_Delayed_Rep_Aspects --\n+      ---------------------------------\n+\n+      procedure Inherit_Delayed_Rep_Aspects (ASN : Node_Id) is\n+         P : constant Entity_Id := Entity (ASN);\n+         --  Entithy for parent type\n+\n+         N : Node_Id;\n+         --  Item from Rep_Item chain\n+\n+         A : Aspect_Id;\n+\n+      begin\n+         --  Loop through delayed aspects for the parent type\n+\n+         N := ASN;\n+         while Present (N) loop\n+            if Nkind (N) = N_Aspect_Specification then\n+               exit when Entity (N) /= P;\n+\n+               if Is_Delayed_Aspect (N) then\n+                  A := Get_Aspect_Id (Chars (Identifier (N)));\n+\n+                  --  Process delayed rep aspect. For Boolean attributes it is\n+                  --  not possible to cancel an attribute once set (the attempt\n+                  --  to use an aspect with xxx => False is an error) for a\n+                  --  derived type. So for those cases, we do not have to check\n+                  --  if a clause has been given for the derived type, since it\n+                  --  is harmless to set it again if it is already set.\n+\n+                  case A is\n+\n+                     --  Alignment\n+\n+                     when Aspect_Alignment =>\n+                        if not Has_Alignment_Clause (E) then\n+                           Set_Alignment (E, Alignment (P));\n+                        end if;\n+\n+                     --  Atomic\n+\n+                     when Aspect_Atomic =>\n+                        if Is_Atomic (P) then\n+                           Set_Is_Atomic (E);\n+                        end if;\n+\n+                     --  Atomic_Components\n+\n+                     when Aspect_Atomic_Components =>\n+                        if Has_Atomic_Components (P) then\n+                           Set_Has_Atomic_Components (Base_Type (E));\n+                        end if;\n+\n+                     --  Bit_Order\n+\n+                     when Aspect_Bit_Order =>\n+                        if Is_Record_Type (E)\n+                          and then No (Get_Attribute_Definition_Clause\n+                                         (E, Attribute_Bit_Order))\n+                          and then Reverse_Bit_Order (P)\n+                        then\n+                           Set_Reverse_Bit_Order (Base_Type (E));\n+                        end if;\n+\n+                     --  Component_Size\n+\n+                     when Aspect_Component_Size =>\n+                        if Is_Array_Type (E)\n+                          and then not Has_Component_Size_Clause (E)\n+                        then\n+                           Set_Component_Size\n+                             (Base_Type (E), Component_Size (P));\n+                        end if;\n+\n+                     --  Machine_Radix\n+\n+                     when Aspect_Machine_Radix =>\n+                        if Is_Decimal_Fixed_Point_Type (E)\n+                          and then not Has_Machine_Radix_Clause (E)\n+                        then\n+                           Set_Machine_Radix_10 (E, Machine_Radix_10 (P));\n+                        end if;\n+\n+                     --  Object_Size (also Size which also sets Object_Size)\n+\n+                     when Aspect_Object_Size | Aspect_Size =>\n+                        if not Has_Size_Clause (E)\n+                          and then\n+                            No (Get_Attribute_Definition_Clause\n+                                  (E, Attribute_Object_Size))\n+                        then\n+                           Set_Esize (E, Esize (P));\n+                        end if;\n+\n+                     --  Pack\n+\n+                     when Aspect_Pack =>\n+                        if not Is_Packed (E) then\n+                           Set_Is_Packed (Base_Type (E));\n+\n+                           if Is_Bit_Packed_Array (P) then\n+                              Set_Is_Bit_Packed_Array (Base_Type (E));\n+                              Set_Packed_Array_Type (E, Packed_Array_Type (P));\n+                           end if;\n+                        end if;\n+\n+                     --  Scalar_Storage_Order\n+\n+                     when Aspect_Scalar_Storage_Order =>\n+                        if (Is_Record_Type (E) or else Is_Array_Type (E))\n+                          and then No (Get_Attribute_Definition_Clause\n+                                       (E, Attribute_Scalar_Storage_Order))\n+                          and then Reverse_Storage_Order (P)\n+                        then\n+                           Set_Reverse_Storage_Order (Base_Type (E));\n+                        end if;\n+\n+                     --  Small\n+\n+                     when Aspect_Small =>\n+                        if Is_Fixed_Point_Type (E)\n+                          and then not Has_Small_Clause (E)\n+                        then\n+                           Set_Small_Value (E, Small_Value (P));\n+                        end if;\n+\n+                     --  Storage_Size\n+\n+                     when Aspect_Storage_Size =>\n+                        if (Is_Access_Type (E) or else Is_Task_Type (E))\n+                          and then not Has_Storage_Size_Clause (E)\n+                        then\n+                           Set_Storage_Size_Variable\n+                             (Base_Type (E), Storage_Size_Variable (P));\n+                        end if;\n+\n+                     --  Value_Size\n+\n+                     when Aspect_Value_Size =>\n+\n+                        --  Value_Size is never inherited, it is either set by\n+                        --  default, or it is explicitly set for the derived\n+                        --  type. So nothing to do here.\n+\n+                        null;\n+\n+                     --  Volatile\n+\n+                     when Aspect_Volatile =>\n+                        if Is_Volatile (P) then\n+                           Set_Is_Volatile (E);\n+                        end if;\n+\n+                     --  Volatile_Components\n+\n+                     when Aspect_Volatile_Components =>\n+                        if Has_Volatile_Components (P) then\n+                           Set_Has_Volatile_Components (Base_Type (E));\n+                        end if;\n+\n+                     --  That should be all the Rep Aspects\n+\n+                     when others =>\n+                        pragma Assert (Aspect_Delay (A_Id) /= Rep_Aspect);\n+                        null;\n+\n+                  end case;\n+               end if;\n+            end if;\n+\n+            N := Next_Rep_Item (N);\n+         end loop;\n+      end Inherit_Delayed_Rep_Aspects;\n+\n       -------------------------------------\n       -- Make_Pragma_From_Boolean_Aspect --\n       -------------------------------------\n@@ -831,15 +1029,18 @@ package body Sem_Ch13 is\n             --  Fall through means we are canceling an inherited aspect\n \n             Error_Msg_Name_1 := A_Name;\n-            Error_Msg_NE (\"derived type& inherits aspect%, cannot cancel\",\n-                          Expr,\n-                          E);\n+            Error_Msg_NE\n+              (\"derived type& inherits aspect%, cannot cancel\", Expr, E);\n \n          end Check_False_Aspect_For_Derived_Type;\n \n       --  Start of processing for Make_Pragma_From_Boolean_Aspect\n \n       begin\n+         --  Note that we know Expr is present, because for a missing Expr\n+         --  argument, we knew it was True and did not need to delay the\n+         --  evaluation to the freeze point.\n+\n          if Is_False (Static_Boolean (Expr)) then\n             Check_False_Aspect_For_Derived_Type;\n \n@@ -874,30 +1075,30 @@ package body Sem_Ch13 is\n \n       ASN := First_Rep_Item (E);\n       while Present (ASN) loop\n-         if Nkind (ASN) = N_Aspect_Specification\n-           and then Entity (ASN) = E\n-           and then Is_Delayed_Aspect (ASN)\n-         then\n-            A_Id := Get_Aspect_Id (ASN);\n+         if Nkind (ASN) = N_Aspect_Specification then\n+            exit when Entity (ASN) /= E;\n \n-            case A_Id is\n+            if Is_Delayed_Aspect (ASN) then\n+               A_Id := Get_Aspect_Id (ASN);\n+\n+               case A_Id is\n \n-               --  For aspects whose expression is an optional Boolean, make\n-               --  the corresponding pragma at the freezing point.\n+                  --  For aspects whose expression is an optional Boolean, make\n+                  --  the corresponding pragma at the freezing point.\n \n                when Boolean_Aspects      |\n                     Library_Unit_Aspects =>\n                   Make_Pragma_From_Boolean_Aspect (ASN);\n \n-               --  Special handling for aspects that don't correspond to\n-               --  pragmas/attributes.\n+                  --  Special handling for aspects that don't correspond to\n+                  --  pragmas/attributes.\n \n                when Aspect_Default_Value           |\n                     Aspect_Default_Component_Value =>\n                   Analyze_Aspect_Default_Value (ASN);\n \n-               --  Ditto for iterator aspects, because the corresponding\n-               --  attributes may not have been analyzed yet.\n+                  --  Ditto for iterator aspects, because the corresponding\n+                  --  attributes may not have been analyzed yet.\n \n                when Aspect_Constant_Indexing |\n                     Aspect_Variable_Indexing |\n@@ -907,17 +1108,27 @@ package body Sem_Ch13 is\n \n                when others =>\n                   null;\n-            end case;\n+               end case;\n \n-            Ritem := Aspect_Rep_Item (ASN);\n+               Ritem := Aspect_Rep_Item (ASN);\n \n-            if Present (Ritem) then\n-               Analyze (Ritem);\n+               if Present (Ritem) then\n+                  Analyze (Ritem);\n+               end if;\n             end if;\n          end if;\n \n          Next_Rep_Item (ASN);\n       end loop;\n+\n+      --  This is where we inherit delayed rep aspects from our parent. Note\n+      --  that if we fell out of the above loop with ASN non-empty, it means\n+      --  we hit an aspect for an entity other than E, and it must be the\n+      --  type from which we were derived.\n+\n+      if May_Inherit_Delayed_Rep_Aspects (E) then\n+         Inherit_Delayed_Rep_Aspects (ASN);\n+      end if;\n    end Analyze_Aspects_At_Freeze_Point;\n \n    -----------------------------------\n@@ -1046,7 +1257,7 @@ package body Sem_Ch13 is\n             A_Id : constant Aspect_Id  := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n \n-            Delay_Required : Boolean := True;\n+            Delay_Required : Boolean;\n             --  Set False if delay is not required\n \n             Eloc : Source_Ptr := No_Location;\n@@ -1279,6 +1490,31 @@ package body Sem_Ch13 is\n \n             Set_Entity (Id, New_Copy_Tree (Expr));\n \n+            --  Set Delay_Required as appropriate to aspect\n+\n+            case Aspect_Delay (A_Id) is\n+               when Always_Delay =>\n+                  Delay_Required := True;\n+\n+               when Never_Delay =>\n+                  Delay_Required := False;\n+\n+               when Rep_Aspect =>\n+\n+                  --  If expression has the form of an integer literal, then\n+                  --  do not delay, since we know the value cannot change.\n+                  --  This optimization catches most rep clause cases.\n+\n+               if (Present (Expr) and then Nkind (Expr) = N_Integer_Literal)\n+                 or else (A_Id in Boolean_Aspects and then No (Expr))\n+               then\n+                  Delay_Required := False;\n+               else\n+                  Delay_Required := True;\n+                  Set_Has_Delayed_Rep_Aspects (E);\n+               end if;\n+            end case;\n+\n             --  Processing based on specific aspect\n \n             case A_Id is\n@@ -1318,7 +1554,8 @@ package body Sem_Ch13 is\n                   --  Indexing aspects apply only to tagged type\n \n                   if (A_Id = Aspect_Constant_Indexing\n-                       or else A_Id = Aspect_Variable_Indexing)\n+                        or else\n+                      A_Id = Aspect_Variable_Indexing)\n                     and then not (Is_Type (E)\n                                    and then Is_Tagged_Type (E))\n                   then\n@@ -1378,12 +1615,6 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Implemented);\n \n-                  --  No delay is required since the only values are: By_Entry\n-                  --  | By_Protected_Procedure | By_Any | Optional which don't\n-                  --  get analyzed anyway.\n-\n-                  Delay_Required := False;\n-\n                --  Attach Handler\n \n                when Aspect_Attach_Handler =>\n@@ -1518,11 +1749,6 @@ package body Sem_Ch13 is\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => Arg_List,\n                         Pragma_Name                  => P_Name);\n-\n-                     --  Convention is a static name, and must be associated\n-                     --  with the entity at once.\n-\n-                     Delay_Required := False;\n                   end;\n \n                --  CPU, Interrupt_Priority, Priority\n@@ -1562,11 +1788,6 @@ package body Sem_Ch13 is\n                          Expression => New_Occurrence_Of (E, Loc))),\n                      Pragma_Name                  => Chars (Id));\n \n-                  --  We don't have to play the delay game here, since the only\n-                  --  values are ON/OFF which don't get analyzed anyway.\n-\n-                  Delay_Required := False;\n-\n                --  Case 2c: Aspects corresponding to pragmas with three\n                --  arguments.\n \n@@ -1620,7 +1841,6 @@ package body Sem_Ch13 is\n                        Make_Pragma_Argument_Association (Loc,\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Abstract_State);\n-                  Delay_Required := False;\n \n                --  Depends\n \n@@ -1666,7 +1886,6 @@ package body Sem_Ch13 is\n                        Make_Pragma_Argument_Association (Loc,\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n-                  Delay_Required := False;\n \n                --  Relative_Deadline\n \n@@ -1910,8 +2129,6 @@ package body Sem_Ch13 is\n                   Make_Aitem_Pragma\n                     (Pragma_Argument_Associations => Args,\n                      Pragma_Name                  => Nam);\n-\n-                  Delay_Required := False;\n                end Test_Case;\n \n                --  Contract_Cases\n@@ -1950,9 +2167,9 @@ package body Sem_Ch13 is\n \n                      else\n                         --  Set the Uses_Lock_Free flag to True if there is no\n-                        --  expression or if the expression is True. ??? The\n+                        --  expression or if the expression is True. The\n                         --  evaluation of this aspect should be delayed to the\n-                        --  freeze point.\n+                        --  freeze point (why???)\n \n                         if No (Expr)\n                           or else Is_True (Static_Boolean (Expr))\n@@ -1984,17 +2201,17 @@ package body Sem_Ch13 is\n                         if No (A) then\n                            Error_Msg_N\n                              (\"missing Convention aspect for Export/Import\",\n-                                 Aspect);\n+                              Aspect);\n                         end if;\n                      end;\n \n                      goto Continue;\n                   end if;\n \n-                  --  This requires special handling in the case of a package\n-                  --  declaration, the pragma needs to be inserted in the list\n-                  --  of declarations for the associated package. There is no\n-                  --  issue of visibility delay for these aspects.\n+                  --  Library unit aspects require special handling in the case\n+                  --  of a package declaration, the pragma needs to be inserted\n+                  --  in the list of declarations for the associated package.\n+                  --  There is no issue of visibility delay for these aspects.\n \n                   if A_Id in Library_Unit_Aspects\n                     and then\n@@ -2007,22 +2224,20 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n-                  --  Special handling when the aspect has no expression. In\n-                  --  this case the value is considered to be True. Thus, we\n-                  --  simply insert the pragma, no delay is required.\n+                  --  Cases where we do not delay, includes all cases where\n+                  --  the expression is missing other than the above cases.\n \n-                  if No (Expr) then\n+                  if not Delay_Required or else No (Expr) then\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Sloc (Ent),\n                             Expression => Ent)),\n                         Pragma_Name                  => Chars (Id));\n-\n                      Delay_Required := False;\n \n                   --  In general cases, the corresponding pragma/attribute\n                   --  definition clause will be inserted later at the freezing\n-                  --  point.\n+                  --  point, and we do not need to build it now\n \n                   else\n                      Aitem := Empty;\n@@ -2188,8 +2403,7 @@ package body Sem_Ch13 is\n \n             --  The evaluation of the aspect is delayed to the freezing point.\n             --  The pragma or attribute clause if there is one is then attached\n-            --  to the aspect specification which is placed in the rep item\n-            --  list.\n+            --  to the aspect specification which is put in the rep item list.\n \n             if Delay_Required then\n                if Present (Aitem) then\n@@ -7340,6 +7554,7 @@ package body Sem_Ch13 is\n \n          when Boolean_Aspects      |\n               Library_Unit_Aspects =>\n+\n             T := Standard_Boolean;\n \n          --  Aspects corresponding to attribute definition clauses\n@@ -8725,6 +8940,7 @@ package body Sem_Ch13 is\n    -------------------------------------\n \n    procedure Inherit_Aspects_At_Freeze_Point (Typ : Entity_Id) is\n+\n       function Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n         (Rep_Item : Node_Id) return Boolean;\n       --  This routine checks if Rep_Item is either a pragma or an aspect"}, {"sha": "0d95174c14a6f6f1baf8edad665f3ade65051bfd", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -305,10 +305,12 @@ package Sem_Ch13 is\n    --  in these two expressions are the same, by seeing if the two expressions\n    --  are fully conformant, and if not, issue appropriate error messages.\n \n-   --  Quite an awkward procedure, but this is an awkard requirement!\n+   --  Quite an awkward approach, but this is an awkard requirement!\n \n    procedure Analyze_Aspects_At_Freeze_Point (E : Entity_Id);\n-   --  Analyze all the delayed aspects for entity E at freezing point\n+   --  Analyze all the delayed aspects for entity E at freezing point. This\n+   --  includes dealing with inheriting delayed aspects from the parent type\n+   --  in the case where a derived type is frozen.\n \n    procedure Check_Aspect_At_Freeze_Point (ASN : Node_Id);\n    --  Performs the processing described above at the freeze point, ASN is the"}, {"sha": "36882bd8f04651567e86e2a2e823ff4fdf889cb2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e934bf713f8a57abdd0d93d17deac3340e5158/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=15e934bf713f8a57abdd0d93d17deac3340e5158", "patch": "@@ -169,15 +169,15 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Derived_Type : Entity_Id;\n       Derive_Subps : Boolean := True);\n-   --  Subsidiary procedure for Build_Derived_Type and\n-   --  Analyze_Private_Extension_Declaration used for tagged and untagged\n-   --  record types. All parameters are as in Build_Derived_Type except that\n-   --  N, in addition to being an N_Full_Type_Declaration node, can also be an\n+   --  Subsidiary procedure used for tagged and untagged record types\n+   --  by Build_Derived_Type and Analyze_Private_Extension_Declaration.\n+   --  All parameters are as in Build_Derived_Type except that N, in\n+   --  addition to being an N_Full_Type_Declaration node, can also be an\n    --  N_Private_Extension_Declaration node. See the definition of this routine\n-   --  for much more info. Derive_Subps indicates whether subprograms should\n-   --  be derived from the parent type. The only case where Derive_Subps is\n-   --  False is for an implicit derived full type for a type derived from a\n-   --  private type (see Build_Derived_Type).\n+   --  for much more info. Derive_Subps indicates whether subprograms should be\n+   --  derived from the parent type. The only case where Derive_Subps is False\n+   --  is for an implicit derived full type for a type derived from a private\n+   --  type (see Build_Derived_Type).\n \n    procedure Build_Discriminal (Discrim : Entity_Id);\n    --  Create the discriminal corresponding to discriminant Discrim, that is\n@@ -8184,6 +8184,15 @@ package body Sem_Ch3 is\n          Set_First_Rep_Item (Derived_Type, First_Rep_Item (Parent_Type));\n       end if;\n \n+      --  If the parent type has delayed rep aspects, then mark the derived\n+      --  type as possibly inheriting a delayed rep aspect.\n+\n+      if Has_Delayed_Rep_Aspects (Parent_Type) then\n+         Set_May_Inherit_Delayed_Rep_Aspects (Derived_Type);\n+      end if;\n+\n+      --  Type dependent processing\n+\n       case Ekind (Parent_Type) is\n          when Numeric_Kind =>\n             Build_Derived_Numeric_Type (N, Parent_Type, Derived_Type);\n@@ -8226,6 +8235,8 @@ package body Sem_Ch3 is\n             raise Program_Error;\n       end case;\n \n+      --  Nothing more to do if some error occurred\n+\n       if Etype (Derived_Type) = Any_Type then\n          return;\n       end if;\n@@ -8235,6 +8246,7 @@ package body Sem_Ch3 is\n       --  if necessary.\n \n       Set_Has_Delayed_Freeze (Derived_Type);\n+\n       if Derive_Subps then\n          Derive_Subprograms (Parent_Type, Derived_Type);\n       end if;"}]}