{"sha": "6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4N2MzMDZjNmE0NGY4ZGI4MWE5YTlmMmY1ZGU0ZDk0M2Q1ZTU3Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2016-02-16T14:42:59Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2016-02-16T14:42:59Z"}, "message": "Fix bswap optimization on big-endian (PR69714, 67781).\n\n\tPR tree-optimization/69714\n\t* tree-ssa-math-opts.c (find_bswap_or_nop): Revert previous change.\n\tReturn NULL if we have irrelevant high bytes on BIG_ENDIAN.\n\ntestsuite/\n\tPR tree-optimization/69714\n\t* gcc.dg/torture/pr69714.c: New test.\n\nFrom-SVN: r233452", "tree": {"sha": "dbf7d36597ac5ae73d49e21deb2e911e80dc3d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf7d36597ac5ae73d49e21deb2e911e80dc3d48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/comments", "author": null, "committer": null, "parents": [{"sha": "8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f3304d019bd1f9a8eb08b9dba3a430a59f52994"}], "stats": {"total": 215, "additions": 185, "deletions": 30}, "files": [{"sha": "741fbd095c60e70a1dde620eb74acd5503d4d4af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "patch": "@@ -1,3 +1,9 @@\n+2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR tree-optimization/69714\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop): Revert previous change.\n+\tReturn NULL if we have irrelevant high bytes on BIG_ENDIAN.\n+\n 2016-02-16  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc-modes.def (CC_FPU, CC_FPU_UNEQ): New modes."}, {"sha": "38751605e80af9bda9afa869b0c06246af1034f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "patch": "@@ -1,3 +1,8 @@\n+2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR tree-optimization/69714\n+\t* gcc.dg/torture/pr69714.c: New test.\n+\n 2016-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/69802\n@@ -152,7 +157,7 @@\n 2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR c/69522\n-\tgcc.dg/pr69522.c: New test.\n+\t* gcc.dg/pr69522.c: New test.\n \n 2016-02-12  Patrick Palka  <ppalka@gcc.gnu.org>\n "}, {"sha": "229b7ad58a11f045d90e6c9105553a9a3bc775f2", "filename": "gcc/testsuite/gcc.dg/torture/pr69714.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69714.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69714.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69714.c?ref=6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "patch": "@@ -0,0 +1,156 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-strict-aliasing\" } */\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#define av_le2ne32(x) (x)\n+#else\n+#define av_le2ne32(x) av_bswap32(x)\n+#endif\n+\n+static __attribute__((always_inline)) inline __attribute__((const)) uint32_t av_bswap32(uint32_t x)\n+{\n+    return ((((x) << 8 & 0xff00) | ((x) >> 8 & 0x00ff)) << 16 | ((((x) >> 16) << 8 & 0xff00) | (((x) >> 16) >> 8 & 0x00ff)));\n+}\n+\n+typedef uint32_t AVCRC;\n+\n+typedef enum {\n+    AV_CRC_8_ATM,\n+    AV_CRC_16_ANSI,\n+    AV_CRC_16_CCITT,\n+    AV_CRC_32_IEEE,\n+    AV_CRC_32_IEEE_LE,\n+    AV_CRC_16_ANSI_LE,\n+    AV_CRC_24_IEEE = 12,\n+    AV_CRC_MAX,\n+} AVCRCId;\n+\n+int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);\n+\n+\n+\n+\n+\n+\n+uint32_t av_crc(const AVCRC *ctx, uint32_t crc,\n+                const uint8_t *buffer, size_t length) __attribute__((pure));\n+static struct {\n+    uint8_t le;\n+    uint8_t bits;\n+    uint32_t poly;\n+} av_crc_table_params[AV_CRC_MAX] = {\n+    [AV_CRC_8_ATM] = { 0, 8, 0x07 },\n+    [AV_CRC_16_ANSI] = { 0, 16, 0x8005 },\n+    [AV_CRC_16_CCITT] = { 0, 16, 0x1021 },\n+    [AV_CRC_24_IEEE] = { 0, 24, 0x864CFB },\n+    [AV_CRC_32_IEEE] = { 0, 32, 0x04C11DB7 },\n+    [AV_CRC_32_IEEE_LE] = { 1, 32, 0xEDB88320 },\n+    [AV_CRC_16_ANSI_LE] = { 1, 16, 0xA001 },\n+};\n+static AVCRC av_crc_table[AV_CRC_MAX][1024];\n+\n+\n+int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size)\n+{\n+    unsigned i, j;\n+    uint32_t c;\n+\n+    if (bits < 8 || bits > 32 || poly >= (1LL << bits))\n+        return -1;\n+    if (ctx_size != sizeof(AVCRC) * 257 && ctx_size != sizeof(AVCRC) * 1024)\n+        return -1;\n+\n+    for (i = 0; i < 256; i++) {\n+        if (le) {\n+            for (c = i, j = 0; j < 8; j++)\n+                c = (c >> 1) ^ (poly & (-(c & 1)));\n+            ctx[i] = c;\n+        } else {\n+            for (c = i << 24, j = 0; j < 8; j++)\n+                c = (c << 1) ^ ((poly << (32 - bits)) & (((int32_t) c) >> 31));\n+            ctx[i] = av_bswap32(c);\n+        }\n+    }\n+    ctx[256] = 1;\n+\n+    if (ctx_size >= sizeof(AVCRC) * 1024)\n+        for (i = 0; i < 256; i++)\n+            for (j = 0; j < 3; j++)\n+                ctx[256 *(j + 1) + i] =\n+                    (ctx[256 * j + i] >> 8) ^ ctx[ctx[256 * j + i] & 0xFF];\n+\n+\n+    return 0;\n+}\n+\n+const AVCRC *av_crc_get_table(AVCRCId crc_id)\n+{\n+    if (!av_crc_table[crc_id][(sizeof(av_crc_table[crc_id]) / sizeof((av_crc_table[crc_id])[0])) - 1])\n+        if (av_crc_init(av_crc_table[crc_id],\n+                        av_crc_table_params[crc_id].le,\n+                        av_crc_table_params[crc_id].bits,\n+                        av_crc_table_params[crc_id].poly,\n+                        sizeof(av_crc_table[crc_id])) < 0)\n+            return ((void *)0);\n+\n+    return av_crc_table[crc_id];\n+}\n+\n+uint32_t av_crc(const AVCRC *ctx, uint32_t crc,\n+                const uint8_t *buffer, size_t length)\n+{\n+    const uint8_t *end = buffer + length;\n+\n+\n+    if (!ctx[256]) {\n+        while (((intptr_t) buffer & 3) && buffer < end)\n+            crc = ctx[((uint8_t) crc) ^ *buffer++] ^ (crc >> 8);\n+\n+        while (buffer < end - 3) {\n+            crc ^= av_le2ne32(*(const uint32_t *) buffer); buffer += 4;\n+            crc = ctx[3 * 256 + ( crc & 0xFF)] ^\n+                  ctx[2 * 256 + ((crc >> 8 ) & 0xFF)] ^\n+                  ctx[1 * 256 + ((crc >> 16) & 0xFF)] ^\n+                  ctx[0 * 256 + ((crc >> 24) )];\n+        }\n+    }\n+\n+    while (buffer < end)\n+        crc = ctx[((uint8_t) crc) ^ *buffer++] ^ (crc >> 8);\n+\n+    return crc;\n+}\n+\n+\n+int main(void)\n+{\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+    uint8_t buf[1999];\n+    int i;\n+    unsigned\n+      p[6][3] = { { AV_CRC_32_IEEE_LE, 0xEDB88320, 0x3D5CDD04 },\n+\t\t  { AV_CRC_32_IEEE , 0x04C11DB7, 0xE0BAF5C0 },\n+\t\t  { AV_CRC_24_IEEE , 0x864CFB , 0x326039 },\n+\t\t  { AV_CRC_16_ANSI_LE, 0xA001 , 0xBFD8 },\n+\t\t  { AV_CRC_16_ANSI , 0x8005 , 0xBB1F },\n+\t\t  { AV_CRC_8_ATM , 0x07 , 0xE3 }\n+    };\n+    const AVCRC *ctx;\n+\n+    for (i = 0; i < sizeof(buf); i++)\n+        buf[i] = i + i * i;\n+\n+    for (i = 0; i < 6; i++) {\n+        int id = p[i][0];\n+\tuint32_t result;\n+        ctx = av_crc_get_table (id);\n+\tresult = av_crc(ctx, 0, buf, sizeof(buf));\n+\tif (result != p[i][2])\n+\t  __builtin_abort ();\n+    }\n+#endif\n+    return 0;\n+}"}, {"sha": "2215b4dc709213730a92b533f8774464a36efaf4", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=6d87c306c6a44f8db81a9a9f2f5de4d943d5e57f", "patch": "@@ -2449,11 +2449,9 @@ find_bswap_or_nop_1 (gimple *stmt, struct symbolic_number *n, int limit)\n static gimple *\n find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n {\n-  unsigned rsize;\n-  uint64_t tmpn, mask;\n-/* The number which the find_bswap_or_nop_1 result should match in order\n-   to have a full byte swap.  The number is shifted to the right\n-   according to the size of the symbolic number before using it.  */\n+  /* The number which the find_bswap_or_nop_1 result should match in order\n+     to have a full byte swap.  The number is shifted to the right\n+     according to the size of the symbolic number before using it.  */\n   uint64_t cmpxchg = CMPXCHG;\n   uint64_t cmpnop = CMPNOP;\n \n@@ -2474,38 +2472,28 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n \n   /* Find real size of result (highest non-zero byte).  */\n   if (n->base_addr)\n-    for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);\n-  else\n-    rsize = n->range;\n+    {\n+      unsigned HOST_WIDE_INT rsize;\n+      uint64_t tmpn;\n \n-  /* Zero out the bits corresponding to untouched bytes in original gimple\n-     expression.  */\n+      for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);\n+      if (BYTES_BIG_ENDIAN && n->range != rsize)\n+\t/* This implies an offset, which is currently not handled by\n+\t   bswap_replace.  */\n+\treturn NULL;\n+      n->range = rsize;\n+    }\n+\n+  /* Zero out the extra bits of N and CMP*.  */\n   if (n->range < (int) sizeof (int64_t))\n     {\n+      uint64_t mask;\n+\n       mask = ((uint64_t) 1 << (n->range * BITS_PER_MARKER)) - 1;\n       cmpxchg >>= (64 / BITS_PER_MARKER - n->range) * BITS_PER_MARKER;\n       cmpnop &= mask;\n     }\n \n-  /* Zero out the bits corresponding to unused bytes in the result of the\n-     gimple expression.  */\n-  if (rsize < n->range)\n-    {\n-      if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;\n-\t  cmpxchg &= mask;\n-\t  cmpnop >>= (n->range - rsize) * BITS_PER_MARKER;\n-\t}\n-      else\n-\t{\n-\t  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;\n-\t  cmpxchg >>= (n->range - rsize) * BITS_PER_MARKER;\n-\t  cmpnop &= mask;\n-\t}\n-      n->range = rsize;\n-    }\n-\n   /* A complete byte swap should make the symbolic number to start with\n      the largest digit in the highest order byte. Unchanged symbolic\n      number indicates a read with same endianness as target architecture.  */"}]}