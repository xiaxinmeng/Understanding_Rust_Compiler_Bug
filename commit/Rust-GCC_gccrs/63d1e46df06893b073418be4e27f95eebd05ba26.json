{"sha": "63d1e46df06893b073418be4e27f95eebd05ba26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNkMWU0NmRmMDY4OTNiMDczNDE4YmU0ZTI3Zjk1ZWViZDA1YmEyNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-04-20T19:21:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-04-20T19:21:39Z"}, "message": "compiler, runtime: Add explicit checks for zero and overflow division.\n\n\t* lang.opt: Add -fgo-check-divide-zero and\n\t-fgo-check-divide-overflow.\n\t* gccgo.texi (Invoking gccgo): Document new options.\n\nFrom-SVN: r186637", "tree": {"sha": "c10e54920198d7e76b320d82626dc392302ee553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10e54920198d7e76b320d82626dc392302ee553"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63d1e46df06893b073418be4e27f95eebd05ba26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d1e46df06893b073418be4e27f95eebd05ba26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d1e46df06893b073418be4e27f95eebd05ba26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d1e46df06893b073418be4e27f95eebd05ba26/comments", "author": null, "committer": null, "parents": [{"sha": "0e27a180fd0f9270bcfacec0b4940283eaf6eb61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e27a180fd0f9270bcfacec0b4940283eaf6eb61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e27a180fd0f9270bcfacec0b4940283eaf6eb61"}], "stats": {"total": 190, "additions": 160, "deletions": 30}, "files": [{"sha": "efbb8b11ac486a87ad7d530b2e611eb6835fd35c", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -1,3 +1,9 @@\n+2012-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lang.opt: Add -fgo-check-divide-zero and\n+\t-fgo-check-divide-overflow.\n+\t* gccgo.texi (Invoking gccgo): Document new options.\n+\n 2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* go-gcc.cc (Gcc_backend::switch_statement): Build SWITCH_EXPR"}, {"sha": "5d0efb44fdba5128b1f73e122dd2a2fec02f6564", "filename": "gcc/go/gccgo.texi", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgccgo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgccgo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgccgo.texi?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -12,7 +12,7 @@\n @include gcc-common.texi\n \n @c Copyright years for this manual.\n-@set copyrights-go 2010\n+@set copyrights-go 2010, 2011, 2012\n \n @copying\n @c man begin COPYRIGHT\n@@ -174,6 +174,31 @@ By default @command{gccgo} will warn about functions which have one or\n more return parameters but lack an explicit @code{return} statement.\n This warning may be disabled using\n @option{-fno-require-return-statement}.\n+\n+@item -fgo-check-divide-zero\n+@cindex @option{-fgo-check-divide-zero}\n+@cindex @option{-fno-go-check-divide-zero}\n+Add explicit checks for division by zero.  In Go a division (or\n+modulos) by zero causes a panic.  On Unix systems this is detected in\n+the runtime by catching the @code{SIGFPE} signal.  Some processors,\n+such as PowerPC, do not generate a SIGFPE on division by zero.  Some\n+runtimes do not generate a signal that can be caught.  On those\n+systems, this option may be used.  Or the checks may be removed via\n+@option{-fno-go-check-divide-zero}.  This option is currently on by\n+default, but in the future may be off by default on systems that do\n+not require it.\n+\n+@item -fgo-check-divide-overflow\n+@cindex @option{-fgo-check-divide-overflow}\n+@cindex @option{-fno-go-check-divide-overflow}\n+Add explicit checks for division overflow.  For example, division\n+overflow occurs when computing @code{INT_MIN / -1}.  In Go this should\n+be wrapped, to produce @code{INT_MIN}.  Some processors, such as x86,\n+generate a trap on division overflow.  On those systems, this option\n+may be used.  Or the checks may be removed via\n+@option{-fno-go-check-divide-overflow}.  This option is currently on\n+by default, but in the future may be off by default on systems that do\n+not require it.\n @end table\n \n @c man end"}, {"sha": "cb94e4f8dd9d322bf7edc6d9ebe94bbf3d3dd9ed", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 109, "deletions": 27, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -5647,6 +5647,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n   enum tree_code code;\n   bool use_left_type = true;\n   bool is_shift_op = false;\n+  bool is_idiv_op = false;\n   switch (this->op_)\n     {\n     case OPERATOR_EQEQ:\n@@ -5689,11 +5690,15 @@ Binary_expression::do_get_tree(Translate_context* context)\n \tif (t->float_type() != NULL || t->complex_type() != NULL)\n \t  code = RDIV_EXPR;\n \telse\n-\t  code = TRUNC_DIV_EXPR;\n+\t  {\n+\t    code = TRUNC_DIV_EXPR;\n+\t    is_idiv_op = true;\n+\t  }\n       }\n       break;\n     case OPERATOR_MOD:\n       code = TRUNC_MOD_EXPR;\n+      is_idiv_op = true;\n       break;\n     case OPERATOR_LSHIFT:\n       code = LSHIFT_EXPR;\n@@ -5714,6 +5719,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n       go_unreachable();\n     }\n \n+  location_t gccloc = this->location().gcc_location();\n   tree type = use_left_type ? TREE_TYPE(left) : TREE_TYPE(right);\n \n   if (this->left_->type()->is_string_type())\n@@ -5741,28 +5747,27 @@ Binary_expression::do_get_tree(Translate_context* context)\n     }\n \n   tree eval_saved = NULL_TREE;\n-  if (is_shift_op)\n+  if (is_shift_op\n+      || (is_idiv_op && (go_check_divide_zero || go_check_divide_overflow)))\n     {\n       // Make sure the values are evaluated.\n-      if (!DECL_P(left) && TREE_SIDE_EFFECTS(left))\n+      if (!DECL_P(left))\n \t{\n \t  left = save_expr(left);\n \t  eval_saved = left;\n \t}\n-      if (!DECL_P(right) && TREE_SIDE_EFFECTS(right))\n+      if (!DECL_P(right))\n \t{\n \t  right = save_expr(right);\n \t  if (eval_saved == NULL_TREE)\n \t    eval_saved = right;\n \t  else\n-\t    eval_saved = fold_build2_loc(this->location().gcc_location(),\n-                                         COMPOUND_EXPR,\n+\t    eval_saved = fold_build2_loc(gccloc, COMPOUND_EXPR,\n \t\t\t\t\t void_type_node, eval_saved, right);\n \t}\n     }\n \n-  tree ret = fold_build2_loc(this->location().gcc_location(),\n-\t\t\t     code,\n+  tree ret = fold_build2_loc(gccloc, code,\n \t\t\t     compute_type != NULL_TREE ? compute_type : type,\n \t\t\t     left, right);\n \n@@ -5780,39 +5785,116 @@ Binary_expression::do_get_tree(Translate_context* context)\n       tree compare = fold_build2(LT_EXPR, boolean_type_node, right,\n \t\t\t\t build_int_cst_type(TREE_TYPE(right), bits));\n \n-      tree overflow_result = fold_convert_loc(this->location().gcc_location(),\n-\t\t\t\t\t      TREE_TYPE(left),\n+      tree overflow_result = fold_convert_loc(gccloc, TREE_TYPE(left),\n \t\t\t\t\t      integer_zero_node);\n       if (this->op_ == OPERATOR_RSHIFT\n \t  && !this->left_->type()->integer_type()->is_unsigned())\n \t{\n \t  tree neg =\n-            fold_build2_loc(this->location().gcc_location(), LT_EXPR,\n-                            boolean_type_node, left,\n-                            fold_convert_loc(this->location().gcc_location(),\n-                                             TREE_TYPE(left),\n+            fold_build2_loc(gccloc, LT_EXPR, boolean_type_node,\n+\t\t\t    left,\n+                            fold_convert_loc(gccloc, TREE_TYPE(left),\n                                              integer_zero_node));\n \t  tree neg_one =\n-            fold_build2_loc(this->location().gcc_location(),\n-                            MINUS_EXPR, TREE_TYPE(left),\n-                            fold_convert_loc(this->location().gcc_location(),\n-                                             TREE_TYPE(left),\n+            fold_build2_loc(gccloc, MINUS_EXPR, TREE_TYPE(left),\n+                            fold_convert_loc(gccloc, TREE_TYPE(left),\n                                              integer_zero_node),\n-                            fold_convert_loc(this->location().gcc_location(),\n-                                             TREE_TYPE(left),\n+                            fold_convert_loc(gccloc, TREE_TYPE(left),\n                                              integer_one_node));\n \t  overflow_result =\n-            fold_build3_loc(this->location().gcc_location(), COND_EXPR,\n-                            TREE_TYPE(left), neg, neg_one,\n-                            overflow_result);\n+            fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(left),\n+\t\t\t    neg, neg_one, overflow_result);\n+\t}\n+\n+      ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(left),\n+\t\t\t    compare, ret, overflow_result);\n+\n+      if (eval_saved != NULL_TREE)\n+\tret = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n+\t\t\t      eval_saved, ret);\n+    }\n+\n+  // Add checks for division by zero and division overflow as needed.\n+  if (is_idiv_op)\n+    {\n+      if (go_check_divide_zero)\n+\t{\n+\t  // right == 0\n+\t  tree check = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n+\t\t\t\t       right,\n+\t\t\t\t       fold_convert_loc(gccloc,\n+\t\t\t\t\t\t\tTREE_TYPE(right),\n+\t\t\t\t\t\t\tinteger_zero_node));\n+\n+\t  // __go_runtime_error(RUNTIME_ERROR_DIVISION_BY_ZERO), 0\n+\t  int errcode = RUNTIME_ERROR_DIVISION_BY_ZERO;\n+\t  tree panic = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n+\t\t\t\t       Gogo::runtime_error(errcode,\n+\t\t\t\t\t\t\t   this->location()),\n+\t\t\t\t       fold_convert_loc(gccloc, TREE_TYPE(ret),\n+\t\t\t\t\t\t\tinteger_zero_node));\n+\n+\t  // right == 0 ? (__go_runtime_error(...), 0) : ret\n+\t  ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n+\t\t\t\tcheck, panic, ret);\n \t}\n \n-      ret = fold_build3_loc(this->location().gcc_location(), COND_EXPR,\n-                            TREE_TYPE(left), compare, ret, overflow_result);\n+      if (go_check_divide_overflow)\n+\t{\n+\t  // right == -1\n+\t  // FIXME: It would be nice to say that this test is expected\n+\t  // to return false.\n+\t  tree m1 = integer_minus_one_node;\n+\t  tree check = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n+\t\t\t\t       right,\n+\t\t\t\t       fold_convert_loc(gccloc,\n+\t\t\t\t\t\t\tTREE_TYPE(right),\n+\t\t\t\t\t\t\tm1));\n+\n+\t  tree overflow;\n+\t  if (TYPE_UNSIGNED(TREE_TYPE(ret)))\n+\t    {\n+\t      // An unsigned -1 is the largest possible number, so\n+\t      // dividing is always 1 or 0.\n+\t      tree cmp = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n+\t\t\t\t\t left, right);\n+\t      if (this->op_ == OPERATOR_DIV)\n+\t\toverflow = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n+\t\t\t\t\t   cmp,\n+\t\t\t\t\t   fold_convert_loc(gccloc,\n+\t\t\t\t\t\t\t    TREE_TYPE(ret),\n+\t\t\t\t\t\t\t    integer_one_node),\n+\t\t\t\t\t   fold_convert_loc(gccloc,\n+\t\t\t\t\t\t\t    TREE_TYPE(ret),\n+\t\t\t\t\t\t\t    integer_zero_node));\n+\t      else\n+\t\toverflow = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n+\t\t\t\t\t   cmp,\n+\t\t\t\t\t   fold_convert_loc(gccloc,\n+\t\t\t\t\t\t\t    TREE_TYPE(ret),\n+\t\t\t\t\t\t\t    integer_zero_node),\n+\t\t\t\t\t   left);\n+\t    }\n+\t  else\n+\t    {\n+\t      // Computing left / -1 is the same as computing - left,\n+\t      // which does not overflow since Go sets -fwrapv.\n+\t      if (this->op_ == OPERATOR_DIV)\n+\t\toverflow = fold_build1_loc(gccloc, NEGATE_EXPR, TREE_TYPE(left),\n+\t\t\t\t\t   left);\n+\t      else\n+\t\toverflow = integer_zero_node;\n+\t    }\n+\t  overflow = fold_convert_loc(gccloc, TREE_TYPE(ret), overflow);\n+\n+\t  // right == -1 ? - left : ret\n+\t  ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n+\t\t\t\tcheck, overflow, ret);\n+\t}\n \n       if (eval_saved != NULL_TREE)\n-\tret = fold_build2_loc(this->location().gcc_location(), COMPOUND_EXPR,\n-\t\t\t      TREE_TYPE(ret), eval_saved, ret);\n+\tret = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n+\t\t\t      eval_saved, ret);\n     }\n \n   return ret;"}, {"sha": "9c5f8cb4a6bebe5c92b068e5b0140efeee73342c", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -2791,6 +2791,9 @@ static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n // Channel capacity out of bounds in make: negative or overflow.\n static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n \n+// Division by zero.\n+static const int RUNTIME_ERROR_DIVISION_BY_ZERO = 10;\n+\n // This is used by some of the langhooks.\n extern Gogo* go_get_gogo();\n "}, {"sha": "c14df9c6107ef574612aa450019e48cafdb404fa", "filename": "gcc/go/lang.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/gcc%2Fgo%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang.opt?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -1,6 +1,6 @@\n ; lang.opt -- Options for the gcc Go front end.\n \n-; Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n+; Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -37,6 +37,14 @@ Wall\n Go\n ; Documented in c.opt\n \n+fgo-check-divide-zero\n+Go Var(go_check_divide_zero) Init(1)\n+Add explicit checks for division by zero\n+\n+fgo-check-divide-overflow\n+Go Var(go_check_divide_overflow) Init(1)\n+Add explicit checks for division overflow in INT_MIN / -1\n+\n fgo-dump-\n Go Joined RejectNegative\n -fgo-dump-<type>\tDump Go frontend internal information"}, {"sha": "68db8acd8b171e095c648b07989469107afa1942", "filename": "libgo/runtime/go-runtime-error.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d1e46df06893b073418be4e27f95eebd05ba26/libgo%2Fruntime%2Fgo-runtime-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d1e46df06893b073418be4e27f95eebd05ba26/libgo%2Fruntime%2Fgo-runtime-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-runtime-error.c?ref=63d1e46df06893b073418be4e27f95eebd05ba26", "patch": "@@ -46,7 +46,10 @@ enum\n   MAKE_MAP_OUT_OF_BOUNDS = 8,\n \n   /* Channel capacity out of bounds in make: negative or overflow.  */\n-  MAKE_CHAN_OUT_OF_BOUNDS = 9\n+  MAKE_CHAN_OUT_OF_BOUNDS = 9,\n+\n+  /* Integer division by zero.  */\n+  DIVISION_BY_ZERO = 10\n };\n \n extern void __go_runtime_error () __attribute__ ((noreturn));\n@@ -78,6 +81,9 @@ __go_runtime_error (int i)\n     case MAKE_CHAN_OUT_OF_BOUNDS:\n       runtime_panicstring (\"make chan len out of range\");\n \n+    case DIVISION_BY_ZERO:\n+      runtime_panicstring (\"integer divide by zero\");\n+\n     default:\n       runtime_panicstring (\"unknown runtime error\");\n     }"}]}