{"sha": "1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "node_id": "C_kwDOANBUbNoAKDFhZThlZGY1ZjczY2E1YzNiZjEzMmNjNTI4MjVkYzFmNzA5NDk5ZGQ", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-11T14:05:35Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-12T00:42:39Z"}, "message": "libstdc++: Implement constexpr std::vector for C++20\n\nThis implements P1004R2 (\"Making std::vector constexpr\") for C++20.\n\nFor now, debug mode vectors are not supported in constant expressions.\nTo make that work we might need to disable all attaching/detaching of\nsafe iterators. That can be fixed later.\n\nCo-authored-by: Josh Marshall <joshua.r.marshall.1991@gmail.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/alloc_traits.h (_Destroy): Make constexpr for\n\tC++20 mode.\n\t* include/bits/allocator.h (__shrink_to_fit::_S_do_it):\n\tLikewise.\n\t* include/bits/stl_algobase.h (__fill_a1): Declare _Bit_iterator\n\toverload constexpr for C++20.\n\t* include/bits/stl_bvector.h (_Bit_type, _S_word_bit): Move out\n\tof inline namespace.\n\t(_Bit_reference, _Bit_iterator_base, _Bit_iterator)\n\t(_Bit_const_iterator, _Bvector_impl_data, _Bvector_base)\n\t(vector<bool, A>>): Add constexpr to every member function.\n\t(_Bvector_base::_M_allocate): Initialize storage during constant\n\tevaluation.\n\t(vector<bool, A>::_M_initialize_value): Use __fill_bvector_n\n\tinstead of memset.\n\t(__fill_bvector_n): New helper function to replace memset during\n\tconstant evaluation.\n\t* include/bits/stl_uninitialized.h (__uninitialized_copy<false>):\n\tMove logic to ...\n\t(__do_uninit_copy): New function.\n\t(__uninitialized_fill<false>): Move logic to ...\n\t(__do_uninit_fill): New function.\n\t(__uninitialized_fill_n<false>): Move logic to ...\n\t(__do_uninit_fill_n): New function.\n\t(__uninitialized_copy_a): Add constexpr. Use __do_uninit_copy.\n\t(__uninitialized_move_a, __uninitialized_move_if_noexcept_a):\n\tAdd constexpr.\n\t(__uninitialized_fill_a): Add constexpr. Use __do_uninit_fill.\n\t(__uninitialized_fill_n_a): Add constexpr. Use\n\t__do_uninit_fill_n.\n\t(__uninitialized_default_n, __uninitialized_default_n_a)\n\t(__relocate_a_1, __relocate_a): Add constexpr.\n\t* include/bits/stl_vector.h (_Vector_impl_data, _Vector_impl)\n\t(_Vector_base, vector): Add constexpr to every member function.\n\t(_Vector_impl::_S_adjust): Disable ASan annotation during\n\tconstant evaluation.\n\t(_Vector_base::_S_use_relocate): Disable bitwise-relocation\n\tduring constant evaluation.\n\t(vector::_Temporary_value): Use a union for storage.\n\t* include/bits/vector.tcc (vector, vector<bool>): Add constexpr\n\tto every member function.\n\t* include/std/vector (erase_if, erase): Add constexpr.\n\t* testsuite/23_containers/headers/vector/synopsis.cc: Add\n\tconstexpr for C++20 mode.\n\t* testsuite/23_containers/vector/bool/cmp_c++20.cc: Change to\n\tcompile-only test using constant expressions.\n\t* testsuite/23_containers/vector/bool/capacity/29134.cc: Adjust\n\tnamespace for _S_word_bit.\n\t* testsuite/23_containers/vector/bool/modifiers/insert/31370.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/cmp_c++20.cc: Likewise.\n\t* testsuite/23_containers/vector/cons/89164.cc: Adjust errors\n\tfor C++20 and move C++17 test to ...\n\t* testsuite/23_containers/vector/cons/89164_c++17.cc: ... here.\n\t* testsuite/23_containers/vector/bool/capacity/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/bool/cons/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/bool/element_access/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/bool/modifiers/assign/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/bool/modifiers/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/bool/modifiers/swap/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/capacity/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/cons/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/data_access/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/element_access/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/modifiers/assign/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/modifiers/constexpr.cc: New test.\n\t* testsuite/23_containers/vector/modifiers/swap/constexpr.cc: New test.", "tree": {"sha": "8bc8ecc241cb38121c561086139b9f08c44e022c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bc8ecc241cb38121c561086139b9f08c44e022c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b39265d4fe13e3e8ce5021642e5092e74effb643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39265d4fe13e3e8ce5021642e5092e74effb643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39265d4fe13e3e8ce5021642e5092e74effb643"}], "stats": {"total": 2808, "additions": 2606, "deletions": 202}, "files": [{"sha": "a0a95f37f66400214ec8a34f01ebb62d4cdcf214", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -833,6 +833,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   template<typename _ForwardIterator, typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n \t     _Allocator& __alloc)\n@@ -847,6 +848,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _ForwardIterator, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n     inline void\n     _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n \t     allocator<_Tp>&)"}, {"sha": "f83e6b87666b7f694b9e088adab2ce5a302b17a2", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -309,6 +309,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct __shrink_to_fit_aux<_Tp, true>\n     {\n+      _GLIBCXX20_CONSTEXPR\n       static bool\n       _S_do_it(_Tp& __c) noexcept\n       {"}, {"sha": "f441165714b92fda0feb2728d0becdcb3fcd6872", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -956,6 +956,7 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \t      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,\n \t      const _VTp&);\n \n+  _GLIBCXX20_CONSTEXPR\n   void\n   __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,\n \t    const bool&);"}, {"sha": "381c47b6132d1c13a58440678c0b411a29b2a765", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 199, "deletions": 52, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -64,29 +64,38 @@\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   typedef unsigned long _Bit_type;\n   enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };\n \n+  __attribute__((__nonnull__))\n+  _GLIBCXX20_CONSTEXPR\n+  void\n+  __fill_bvector_n(_Bit_type*, size_t, bool) _GLIBCXX_NOEXCEPT;\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n+\n   struct _Bit_reference\n   {\n     _Bit_type * _M_p;\n     _Bit_type _M_mask;\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_reference(_Bit_type * __x, _Bit_type __y)\n     : _M_p(__x), _M_mask(__y) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }\n \n #if __cplusplus >= 201103L\n     _Bit_reference(const _Bit_reference&) = default;\n #endif\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     operator bool() const _GLIBCXX_NOEXCEPT\n     { return !!(*_M_p & _M_mask); }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_reference&\n     operator=(bool __x) _GLIBCXX_NOEXCEPT\n     {\n@@ -97,26 +106,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_reference&\n     operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT\n     { return *this = bool(__x); }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     bool\n     operator==(const _Bit_reference& __x) const\n     { return bool(*this) == bool(__x); }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     bool\n     operator<(const _Bit_reference& __x) const\n     { return !bool(*this) && bool(__x); }\n \n+    _GLIBCXX20_CONSTEXPR\n     void\n     flip() _GLIBCXX_NOEXCEPT\n     { *_M_p ^= _M_mask; }\n   };\n \n #if __cplusplus >= 201103L\n+  _GLIBCXX20_CONSTEXPR\n   inline void\n   swap(_Bit_reference __x, _Bit_reference __y) noexcept\n   {\n@@ -125,6 +137,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     __y = __tmp;\n   }\n \n+  _GLIBCXX20_CONSTEXPR\n   inline void\n   swap(_Bit_reference __x, bool& __y) noexcept\n   {\n@@ -133,6 +146,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     __y = __tmp;\n   }\n \n+  _GLIBCXX20_CONSTEXPR\n   inline void\n   swap(bool& __x, _Bit_reference __y) noexcept\n   {\n@@ -148,9 +162,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     _Bit_type * _M_p;\n     unsigned int _M_offset;\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n     : _M_p(__x), _M_offset(__y) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     void\n     _M_bump_up()\n     {\n@@ -161,6 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     void\n     _M_bump_down()\n     {\n@@ -171,6 +188,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     void\n     _M_incr(ptrdiff_t __i)\n     {\n@@ -230,7 +248,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return !(__x < __y); }\n #endif // three-way comparison\n \n-    friend ptrdiff_t\n+    friend _GLIBCXX20_CONSTEXPR ptrdiff_t\n     operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n     {\n       return (int(_S_word_bit) * (__x._M_p - __y._M_p)\n@@ -248,27 +266,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n     typedef _Bit_iterator   iterator;\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_iterator() : _Bit_iterator_base(0, 0) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator\n     _M_const_cast() const\n     { return *this; }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     reference\n     operator*() const\n     { return reference(_M_p, 1UL << _M_offset); }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator&\n     operator++()\n     {\n       _M_bump_up();\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator\n     operator++(int)\n     {\n@@ -277,13 +300,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return __tmp;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator&\n     operator--()\n     {\n       _M_bump_down();\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator\n     operator--(int)\n     {\n@@ -292,27 +317,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return __tmp;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator&\n     operator+=(difference_type __i)\n     {\n       _M_incr(__i);\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     iterator&\n     operator-=(difference_type __i)\n     {\n       *this += -__i;\n       return *this;\n     }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     reference\n     operator[](difference_type __i) const\n     { return *(*this + __i); }\n \n     _GLIBCXX_NODISCARD\n-    friend iterator\n+    friend _GLIBCXX20_CONSTEXPR iterator\n     operator+(const iterator& __x, difference_type __n)\n     {\n       iterator __tmp = __x;\n@@ -321,12 +348,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n     _GLIBCXX_NODISCARD\n-    friend iterator\n+    friend _GLIBCXX20_CONSTEXPR iterator\n     operator+(difference_type __n, const iterator& __x)\n     { return __x + __n; }\n \n     _GLIBCXX_NODISCARD\n-    friend iterator\n+    friend _GLIBCXX20_CONSTEXPR iterator\n     operator-(const iterator& __x, difference_type __n)\n     {\n       iterator __tmp = __x;\n@@ -346,30 +373,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n     typedef _Bit_const_iterator  const_iterator;\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_const_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_const_iterator(const _Bit_iterator& __x)\n     : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n \n+    _GLIBCXX20_CONSTEXPR\n     _Bit_iterator\n     _M_const_cast() const\n     { return _Bit_iterator(_M_p, _M_offset); }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     const_reference\n     operator*() const\n     { return _Bit_reference(_M_p, 1UL << _M_offset); }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator&\n     operator++()\n     {\n       _M_bump_up();\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator\n     operator++(int)\n     {\n@@ -378,13 +411,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return __tmp;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator&\n     operator--()\n     {\n       _M_bump_down();\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator\n     operator--(int)\n     {\n@@ -393,27 +428,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return __tmp;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator&\n     operator+=(difference_type __i)\n     {\n       _M_incr(__i);\n       return *this;\n     }\n \n+    _GLIBCXX20_CONSTEXPR\n     const_iterator&\n     operator-=(difference_type __i)\n     {\n       *this += -__i;\n       return *this;\n     }\n \n-    _GLIBCXX_NODISCARD\n+    _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n     const_reference\n     operator[](difference_type __i) const\n     { return *(*this + __i); }\n \n     _GLIBCXX_NODISCARD\n-    friend const_iterator\n+    friend _GLIBCXX20_CONSTEXPR const_iterator\n     operator+(const const_iterator& __x, difference_type __n)\n     {\n       const_iterator __tmp = __x;\n@@ -422,7 +459,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n     _GLIBCXX_NODISCARD\n-    friend const_iterator\n+    friend _GLIBCXX20_CONSTEXPR const_iterator\n     operator-(const const_iterator& __x, difference_type __n)\n     {\n       const_iterator __tmp = __x;\n@@ -431,7 +468,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n     _GLIBCXX_NODISCARD\n-    friend const_iterator\n+    friend _GLIBCXX20_CONSTEXPR const_iterator\n     operator+(difference_type __n, const const_iterator& __x)\n     { return __x + __n; }\n   };\n@@ -454,25 +491,30 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tstruct {\n \t  _Bit_type* _M_p;\n \t  // Allow assignment from iterators (assume offset is zero):\n+\t  _GLIBCXX20_CONSTEXPR\n \t  void operator=(_Bit_iterator __it) { _M_p = __it._M_p; }\n \t} _M_start;\n #endif\n \t_Bit_iterator\t_M_finish;\n \t_Bit_pointer\t_M_end_of_storage;\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl_data() _GLIBCXX_NOEXCEPT\n \t: _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n \t_Bvector_impl_data(const _Bvector_impl_data&) = default;\n+\n \t_Bvector_impl_data&\n \toperator=(const _Bvector_impl_data&) = default;\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept\n \t: _Bvector_impl_data(__x)\n \t{ __x._M_reset(); }\n \n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_move_data(_Bvector_impl_data&& __x) noexcept\n \t{\n@@ -481,10 +523,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n #endif\n \n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_reset() _GLIBCXX_NOEXCEPT\n \t{ *this = _Bvector_impl_data(); }\n \n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_swap_data(_Bvector_impl_data& __x) _GLIBCXX_NOEXCEPT\n \t{\n@@ -497,27 +541,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       struct _Bvector_impl\n \t: public _Bit_alloc_type, public _Bvector_impl_data\n       {\n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl() _GLIBCXX_NOEXCEPT_IF(\n \t  is_nothrow_default_constructible<_Bit_alloc_type>::value)\n \t: _Bit_alloc_type()\n \t{ }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT\n \t: _Bit_alloc_type(__a)\n \t{ }\n \n #if __cplusplus >= 201103L\n \t// Not defaulted, to enforce noexcept(true) even when\n \t// !is_nothrow_move_constructible<_Bit_alloc_type>.\n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl(_Bvector_impl&& __x) noexcept\n \t: _Bit_alloc_type(std::move(__x)), _Bvector_impl_data(std::move(__x))\n \t{ }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept\n \t: _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x))\n \t{ }\n #endif\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Bit_type*\n \t_M_end_addr() const _GLIBCXX_NOEXCEPT\n \t{\n@@ -530,14 +579,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       typedef _Alloc allocator_type;\n \n+      _GLIBCXX20_CONSTEXPR\n       _Bit_alloc_type&\n       _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT\n       { return this->_M_impl; }\n \n+      _GLIBCXX20_CONSTEXPR\n       const _Bit_alloc_type&\n       _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT\n       { return this->_M_impl; }\n \n+      _GLIBCXX20_CONSTEXPR\n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Bit_allocator()); }\n@@ -548,27 +600,43 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Bvector_base() { }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       _Bvector_base(const allocator_type& __a)\n       : _M_impl(__a) { }\n \n #if __cplusplus >= 201103L\n       _Bvector_base(_Bvector_base&&) = default;\n \n+      _GLIBCXX20_CONSTEXPR\n       _Bvector_base(_Bvector_base&& __x, const allocator_type& __a) noexcept\n       : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl))\n       { }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       ~_Bvector_base()\n       { this->_M_deallocate(); }\n \n     protected:\n       _Bvector_impl _M_impl;\n \n+      _GLIBCXX20_CONSTEXPR\n       _Bit_pointer\n       _M_allocate(size_t __n)\n-      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }\n+      {\n+\t_Bit_pointer __p = _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n));\n+#if __has_builtin(__builtin_is_constant_evaluated)\n+\tif (__builtin_is_constant_evaluated())\n+\t{\n+\t  __n = _S_nword(__n);\n+\t  for (size_t __i = 0; __i < __n; ++__i)\n+\t    __p[__i] = 0ul;\n+\t}\n+#endif\n+\treturn __p;\n+      }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_deallocate()\n       {\n@@ -583,11 +651,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_move_data(_Bvector_base&& __x) noexcept\n       { _M_impl._M_move_data(std::move(__x._M_impl)); }\n #endif\n \n+      _GLIBCXX_CONSTEXPR\n       static size_t\n       _S_nword(size_t __n)\n       { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }\n@@ -637,6 +707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n       typedef _Alloc\t\t\t\t\tallocator_type;\n \n+      _GLIBCXX20_CONSTEXPR\n       allocator_type\n       get_allocator() const\n       { return _Base::get_allocator(); }\n@@ -654,16 +725,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       vector() { }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       explicit\n       vector(const allocator_type& __a)\n       : _Base(__a) { }\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       explicit\n       vector(size_type __n, const allocator_type& __a = allocator_type())\n       : vector(__n, false, __a)\n       { }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(size_type __n, const bool& __value,\n \t     const allocator_type& __a = allocator_type())\n #else\n@@ -677,6 +751,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t_M_initialize_value(__value);\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(const vector& __x)\n       : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n       {\n@@ -688,10 +763,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       vector(vector&&) = default;\n \n     private:\n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __x, const allocator_type& __a, true_type) noexcept\n       : _Base(std::move(__x), __a)\n       { }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __x, const allocator_type& __a, false_type)\n       : _Base(__a)\n       {\n@@ -706,19 +783,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n     public:\n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __x, const __type_identity_t<allocator_type>& __a)\n       noexcept(_Bit_alloc_traits::_S_always_equal())\n       : vector(std::move(__x), __a,\n \t       typename _Bit_alloc_traits::is_always_equal{})\n       { }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(const vector& __x, const __type_identity_t<allocator_type>& __a)\n       : _Base(__a)\n       {\n \t_M_initialize(__x.size());\n \t_M_copy_aligned(__x.begin(), __x.end(), begin());\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(initializer_list<bool> __l,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__a)\n@@ -731,6 +811,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \tvector(_InputIterator __first, _InputIterator __last,\n \t       const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n@@ -750,8 +831,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       ~vector() _GLIBCXX_NOEXCEPT { }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(const vector& __x)\n       {\n@@ -783,6 +866,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())\n       {\n@@ -808,6 +892,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \treturn *this;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(initializer_list<bool> __l)\n       {\n@@ -820,13 +905,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // versions: one that takes a count, and one that takes a range.\n       // The range version is a member template, so we dispatch on whether\n       // or not the type is an integer.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       assign(size_type __n, const bool& __x)\n       { _M_fill_assign(__n, __x); }\n \n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \tassign(_InputIterator __first, _InputIterator __last)\n \t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n@@ -842,79 +929,80 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       void\n       assign(initializer_list<bool> __l)\n       { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }\n #endif\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       iterator\n       begin() _GLIBCXX_NOEXCEPT\n       { return iterator(this->_M_impl._M_start._M_p, 0); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_iterator\n       begin() const _GLIBCXX_NOEXCEPT\n       { return const_iterator(this->_M_impl._M_start._M_p, 0); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       iterator\n       end() _GLIBCXX_NOEXCEPT\n       { return this->_M_impl._M_finish; }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_iterator\n       end() const _GLIBCXX_NOEXCEPT\n       { return this->_M_impl._M_finish; }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n       { return reverse_iterator(end()); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n       { return const_reverse_iterator(end()); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n       { return reverse_iterator(begin()); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n       { return const_reverse_iterator(begin()); }\n \n #if __cplusplus >= 201103L\n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_iterator\n       cbegin() const noexcept\n       { return const_iterator(this->_M_impl._M_start._M_p, 0); }\n \n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_iterator\n       cend() const noexcept\n       { return this->_M_impl._M_finish; }\n \n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       crbegin() const noexcept\n       { return const_reverse_iterator(end()); }\n \n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       crend() const noexcept\n       { return const_reverse_iterator(begin()); }\n #endif\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       size() const _GLIBCXX_NOEXCEPT\n       { return size_type(end() - begin()); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n       {\n@@ -927,27 +1015,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t? __asize * int(_S_word_bit) : __isize);\n       }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       capacity() const _GLIBCXX_NOEXCEPT\n       { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)\n \t\t\t - begin()); }\n \n-      _GLIBCXX_NODISCARD bool\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n+      bool\n       empty() const _GLIBCXX_NOEXCEPT\n       { return begin() == end(); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       operator[](size_type __n)\n       { return begin()[__n]; }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       operator[](size_type __n) const\n       { return begin()[__n]; }\n \n     protected:\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_range_check(size_type __n) const\n       {\n@@ -959,14 +1049,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n     public:\n+      _GLIBCXX20_CONSTEXPR\n       reference\n       at(size_type __n)\n-      { _M_range_check(__n); return (*this)[__n]; }\n+      {\n+\t_M_range_check(__n);\n+\treturn (*this)[__n];\n+      }\n \n+      _GLIBCXX20_CONSTEXPR\n       const_reference\n       at(size_type __n) const\n-      { _M_range_check(__n); return (*this)[__n]; }\n+      {\n+\t_M_range_check(__n);\n+\treturn (*this)[__n];\n+      }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       reserve(size_type __n)\n       {\n@@ -976,26 +1075,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  _M_reallocate(__n);\n       }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       front()\n       { return *begin(); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       front() const\n       { return *begin(); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       back()\n       { return *(end() - 1); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       back() const\n       { return *(end() - 1); }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       push_back(bool __x)\n       {\n@@ -1005,6 +1105,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  _M_insert_aux(end(), __x);\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       swap(vector& __x) _GLIBCXX_NOEXCEPT\n       {\n@@ -1018,6 +1119,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n       // [23.2.5]/1, third-to-last entry in synopsis listing\n+      _GLIBCXX20_CONSTEXPR\n       static void\n       swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT\n       {\n@@ -1026,6 +1128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t__y = __tmp;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n #if __cplusplus >= 201103L\n       insert(const_iterator __position, const bool& __x = bool())\n@@ -1045,6 +1148,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \titerator\n \tinsert(const_iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n@@ -1068,6 +1172,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __position, size_type __n, const bool& __x)\n       {\n@@ -1082,15 +1187,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __p, initializer_list<bool> __l)\n       { return this->insert(__p, __l.begin(), __l.end()); }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       pop_back()\n       { --this->_M_impl._M_finish; }\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n #if __cplusplus >= 201103L\n       erase(const_iterator __position)\n@@ -1099,6 +1207,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n       { return _M_erase(__position._M_const_cast()); }\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n #if __cplusplus >= 201103L\n       erase(const_iterator __first, const_iterator __last)\n@@ -1107,6 +1216,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n       { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       resize(size_type __new_size, bool __x = bool())\n       {\n@@ -1117,11 +1227,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       void\n       shrink_to_fit()\n       { _M_shrink_to_fit(); }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       flip() _GLIBCXX_NOEXCEPT\n       {\n@@ -1130,13 +1242,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  *__p = ~*__p;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       clear() _GLIBCXX_NOEXCEPT\n       { _M_erase_at_end(begin()); }\n \n #if __cplusplus >= 201103L\n       template<typename... _Args>\n #if __cplusplus > 201402L\n+\t_GLIBCXX20_CONSTEXPR\n \treference\n #else\n \tvoid\n@@ -1150,13 +1264,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n \n       template<typename... _Args>\n+\t_GLIBCXX20_CONSTEXPR\n \titerator\n \templace(const_iterator __pos, _Args&&... __args)\n \t{ return insert(__pos, bool(__args...)); }\n #endif\n \n     protected:\n       // Precondition: __first._M_offset == 0 && __result._M_offset == 0.\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_copy_aligned(const_iterator __first, const_iterator __last,\n \t\t      iterator __result)\n@@ -1166,6 +1282,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t iterator(__q, 0));\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_initialize(size_type __n)\n       {\n@@ -1179,19 +1296,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  }\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n-      _M_initialize_value(bool __x)\n+      _M_initialize_value(bool __x) _GLIBCXX_NOEXCEPT\n       {\n \tif (_Bit_type* __p = this->_M_impl._M_start._M_p)\n-\t  __builtin_memset(__p, __x ? ~0 : 0,\n-\t\t\t   (this->_M_impl._M_end_addr() - __p)\n-\t\t\t   * sizeof(_Bit_type));\n+\t  __fill_bvector_n(__p, this->_M_impl._M_end_addr() - __p, __x);\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_reallocate(size_type __n);\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       bool\n       _M_shrink_to_fit();\n #endif\n@@ -1216,6 +1334,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_initialize_range(_InputIterator __first, _InputIterator __last,\n \t\t\t    std::input_iterator_tag)\n@@ -1225,6 +1344,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n \n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t    std::forward_iterator_tag)\n@@ -1249,6 +1369,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_fill_assign(size_t __n, bool __x)\n       {\n@@ -1265,6 +1386,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t      std::input_iterator_tag)\n@@ -1279,6 +1401,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n \n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t      std::forward_iterator_tag)\n@@ -1313,10 +1436,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t  std::__iterator_category(__first)); }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_fill_insert(iterator __position, size_type __n, bool __x);\n \n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_insert_range(iterator __pos, _InputIterator __first,\n \t\t\t_InputIterator __last, std::input_iterator_tag)\n@@ -1329,13 +1454,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n \n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_insert_range(iterator __position, _ForwardIterator __first,\n \t\t\t_ForwardIterator __last, std::forward_iterator_tag);\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_insert_aux(iterator __position, bool __x);\n \n+      _GLIBCXX20_CONSTEXPR\n       size_type\n       _M_check_len(size_type __n, const char* __s) const\n       {\n@@ -1346,13 +1474,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \treturn (__len < size() || __len > max_size()) ? max_size() : __len;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_erase_at_end(iterator __pos)\n       { this->_M_impl._M_finish = __pos; }\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_erase(iterator __pos);\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_erase(iterator __first, iterator __last);\n \n@@ -1371,12 +1502,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n \n+  // Fill a partial word.\n+  _GLIBCXX20_CONSTEXPR\n   inline void\n-  __fill_bvector(_GLIBCXX_STD_C::_Bit_type * __v,\n-\t\t unsigned int __first, unsigned int __last, bool __x)\n+  __fill_bvector(_Bit_type* __v, unsigned int __first, unsigned int __last,\n+\t\t bool __x) _GLIBCXX_NOEXCEPT\n   {\n-    using _GLIBCXX_STD_C::_Bit_type;\n-    using _GLIBCXX_STD_C::_S_word_bit;\n     const _Bit_type __fmask = ~0ul << __first;\n     const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);\n     const _Bit_type __mask = __fmask & __lmask;\n@@ -1387,20 +1518,36 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       *__v &= ~__mask;\n   }\n \n+  // Fill N full words, as if using memset, but usable in constant expressions.\n+  __attribute__((__nonnull__))\n+  _GLIBCXX20_CONSTEXPR\n+  inline void\n+  __fill_bvector_n(_Bit_type* __p, size_t __n, bool __x) _GLIBCXX_NOEXCEPT\n+  {\n+#if __has_builtin(__builtin_is_constant_evaluated)\n+    if (__builtin_is_constant_evaluated())\n+    {\n+      for (size_t __i = 0; __i < __n; ++__i)\n+\t__p[__i] = __x ? ~0ul : 0ul;\n+      return;\n+    }\n+#endif\n+    __builtin_memset(__p, __x ? ~0 : 0, __n * sizeof(_Bit_type));\n+  }\n+\n+\n+  _GLIBCXX20_CONSTEXPR\n   inline void\n   __fill_a1(_GLIBCXX_STD_C::_Bit_iterator __first,\n \t    _GLIBCXX_STD_C::_Bit_iterator __last, const bool& __x)\n   {\n-    using _GLIBCXX_STD_C::_Bit_type;\n-    using _GLIBCXX_STD_C::_S_word_bit;\n     if (__first._M_p != __last._M_p)\n       {\n \t_Bit_type* __first_p = __first._M_p;\n \tif (__first._M_offset != 0)\n \t  __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);\n \n-\t__builtin_memset(__first_p, __x ? ~0 : 0,\n-\t\t\t (__last._M_p - __first_p) * sizeof(_Bit_type));\n+\t__fill_bvector_n(__first_p, __last._M_p - __first_p, __x);\n \n \tif (__last._M_offset != 0)\n \t  __fill_bvector(__last._M_p, 0, __last._M_offset, __x);"}, {"sha": "673f6a076752acc5035d1d9ebecec329551a29e2", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 105, "deletions": 53, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -107,27 +107,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     __is_trivial(T) && __is_assignable(T&, U)\n #endif\n \n+  template<typename _InputIterator, typename _ForwardIterator>\n+    _GLIBCXX20_CONSTEXPR\n+    _ForwardIterator\n+    __do_uninit_copy(_InputIterator __first, _InputIterator __last,\n+\t\t     _ForwardIterator __result)\n+    {\n+      _ForwardIterator __cur = __result;\n+      __try\n+\t{\n+\t  for (; __first != __last; ++__first, (void)++__cur)\n+\t    std::_Construct(std::__addressof(*__cur), *__first);\n+\t  return __cur;\n+\t}\n+      __catch(...)\n+\t{\n+\t  std::_Destroy(__result, __cur);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n   template<bool _TrivialValueTypes>\n     struct __uninitialized_copy\n     {\n       template<typename _InputIterator, typename _ForwardIterator>\n         static _ForwardIterator\n         __uninit_copy(_InputIterator __first, _InputIterator __last,\n \t\t      _ForwardIterator __result)\n-        {\n-\t  _ForwardIterator __cur = __result;\n-\t  __try\n-\t    {\n-\t      for (; __first != __last; ++__first, (void)++__cur)\n-\t\tstd::_Construct(std::__addressof(*__cur), *__first);\n-\t      return __cur;\n-\t    }\n-\t  __catch(...)\n-\t    {\n-\t      std::_Destroy(__result, __cur);\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n+\t{ return std::__do_uninit_copy(__first, __last, __result); }\n     };\n \n   template<>\n@@ -180,26 +187,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @cond undocumented\n \n+  template<typename _ForwardIterator, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR void\n+    __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t     const _Tp& __x)\n+    {\n+      _ForwardIterator __cur = __first;\n+      __try\n+\t{\n+\t  for (; __cur != __last; ++__cur)\n+\t    std::_Construct(std::__addressof(*__cur), __x);\n+\t}\n+      __catch(...)\n+\t{\n+\t  std::_Destroy(__first, __cur);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n   template<bool _TrivialValueType>\n     struct __uninitialized_fill\n     {\n       template<typename _ForwardIterator, typename _Tp>\n         static void\n         __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,\n \t\t      const _Tp& __x)\n-        {\n-\t  _ForwardIterator __cur = __first;\n-\t  __try\n-\t    {\n-\t      for (; __cur != __last; ++__cur)\n-\t\tstd::_Construct(std::__addressof(*__cur), __x);\n-\t    }\n-\t  __catch(...)\n-\t    {\n-\t      std::_Destroy(__first, __cur);\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n+\t{ std::__do_uninit_fill(__first, __last, __x); }\n     };\n \n   template<>\n@@ -242,34 +255,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @cond undocumented\n \n+  template<typename _ForwardIterator, typename _Size, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n+    _ForwardIterator\n+    __do_uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)\n+    {\n+      _ForwardIterator __cur = __first;\n+      __try\n+\t{\n+\t  for (; __n > 0; --__n, (void) ++__cur)\n+\t    std::_Construct(std::__addressof(*__cur), __x);\n+\t  return __cur;\n+\t}\n+      __catch(...)\n+\t{\n+\t  std::_Destroy(__first, __cur);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n   template<bool _TrivialValueType>\n     struct __uninitialized_fill_n\n     {\n       template<typename _ForwardIterator, typename _Size, typename _Tp>\n-        static _ForwardIterator\n+\tstatic _ForwardIterator\n         __uninit_fill_n(_ForwardIterator __first, _Size __n,\n \t\t\tconst _Tp& __x)\n-        {\n-\t  _ForwardIterator __cur = __first;\n-\t  __try\n-\t    {\n-\t      for (; __n > 0; --__n, (void) ++__cur)\n-\t\tstd::_Construct(std::__addressof(*__cur), __x);\n-\t      return __cur;\n-\t    }\n-\t  __catch(...)\n-\t    {\n-\t      std::_Destroy(__first, __cur);\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n+\t{ return std::__do_uninit_fill_n(__first, __n, __x); }\n     };\n \n   template<>\n     struct __uninitialized_fill_n<true>\n     {\n       template<typename _ForwardIterator, typename _Size, typename _Tp>\n-        static _ForwardIterator\n+\tstatic _ForwardIterator\n         __uninit_fill_n(_ForwardIterator __first, _Size __n,\n \t\t\tconst _Tp& __x)\n         { return std::fill_n(__first, __n, __x); }\n@@ -315,11 +334,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Extensions: versions of uninitialized_copy, uninitialized_fill,\n   //  and uninitialized_fill_n that take an allocator parameter.\n   //  We dispatch back to the standard versions when we're given the\n-  //  default allocator.  For nondefault allocators we do not use \n+  //  default allocator.  For nondefault allocators we do not use\n   //  any of the POD optimizations.\n \n   template<typename _InputIterator, typename _ForwardIterator,\n \t   typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     _ForwardIterator\n     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n \t\t\t   _ForwardIterator __result, _Allocator& __alloc)\n@@ -340,13 +360,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _InputIterator, typename _ForwardIterator, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n \t\t\t   _ForwardIterator __result, allocator<_Tp>&)\n-    { return std::uninitialized_copy(__first, __last, __result); }\n+    {\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn std::__do_uninit_copy(__first, __last, __result);\n+#endif\n+      return std::uninitialized_copy(__first, __last, __result);\n+    }\n \n   template<typename _InputIterator, typename _ForwardIterator,\n \t   typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __uninitialized_move_a(_InputIterator __first, _InputIterator __last,\n \t\t\t   _ForwardIterator __result, _Allocator& __alloc)\n@@ -358,6 +386,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _InputIterator, typename _ForwardIterator,\n \t   typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __uninitialized_move_if_noexcept_a(_InputIterator __first,\n \t\t\t\t       _InputIterator __last,\n@@ -370,6 +399,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _ForwardIterator, typename _Tp, typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t   const _Tp& __x, _Allocator& __alloc)\n@@ -389,15 +419,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _ForwardIterator, typename _Tp, typename _Tp2>\n+    _GLIBCXX20_CONSTEXPR\n     inline void\n     __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t   const _Tp& __x, allocator<_Tp2>&)\n-    { std::uninitialized_fill(__first, __last, __x); }\n+    {\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn std::__do_uninit_fill(__first, __last, __x);\n+#endif\n+      std::uninitialized_fill(__first, __last, __x);\n+    }\n \n   template<typename _ForwardIterator, typename _Size, typename _Tp,\n \t   typename _Allocator>\n+     _GLIBCXX20_CONSTEXPR\n     _ForwardIterator\n-    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, \n+    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,\n \t\t\t     const _Tp& __x, _Allocator& __alloc)\n     {\n       _ForwardIterator __cur = __first;\n@@ -417,10 +455,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _ForwardIterator, typename _Size, typename _Tp,\n \t   typename _Tp2>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n-    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, \n+    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,\n \t\t\t     const _Tp& __x, allocator<_Tp2>&)\n-    { return std::uninitialized_fill_n(__first, __n, __x); }\n+    {\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn std::__do_uninit_fill_n(__first, __n, __x);\n+#endif\n+      return std::uninitialized_fill_n(__first, __n, __x);\n+    }\n \n \n   // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,\n@@ -483,7 +528,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __throw_exception_again;\n \t}\n     }\n-  \n+\n   // __uninitialized_fill_move\n   // Fills [result, mid) with x, and moves [first, last) into\n   //  [mid, mid + (last - first)).\n@@ -582,6 +627,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __uninitialized_default_n_1\n     {\n       template<typename _ForwardIterator, typename _Size>\n+\t_GLIBCXX20_CONSTEXPR\n         static _ForwardIterator\n         __uninit_default_n(_ForwardIterator __first, _Size __n)\n         {\n@@ -604,6 +650,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __uninitialized_default_n_1<true>\n     {\n       template<typename _ForwardIterator, typename _Size>\n+\t_GLIBCXX20_CONSTEXPR\n         static _ForwardIterator\n         __uninit_default_n(_ForwardIterator __first, _Size __n)\n         {\n@@ -639,6 +686,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // __uninitialized_default_n\n   // Fills [first, first + n) with value-initialized value_types.\n   template<typename _ForwardIterator, typename _Size>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __uninitialized_default_n(_ForwardIterator __first, _Size __n)\n     {\n@@ -689,8 +737,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Fills [first, first + n) with value_types constructed by the allocator\n   // alloc, with no arguments passed to the construct call.\n   template<typename _ForwardIterator, typename _Size, typename _Allocator>\n-    _ForwardIterator\n-    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, \n+    _GLIBCXX20_CONSTEXPR _ForwardIterator\n+    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,\n \t\t\t\t_Allocator& __alloc)\n     {\n       _ForwardIterator __cur = __first;\n@@ -711,8 +759,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // __uninitialized_default_n_a specialization for std::allocator,\n   // which ignores the allocator and value-initializes the elements.\n   template<typename _ForwardIterator, typename _Size, typename _Tp>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n-    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, \n+    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,\n \t\t\t\tallocator<_Tp>&)\n     { return std::__uninitialized_default_n(__first, __n); }\n \n@@ -1022,6 +1071,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : is_trivial<_Tp> { };\n \n   template <typename _Tp, typename _Up>\n+    _GLIBCXX20_CONSTEXPR\n     inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>\n     __relocate_a_1(_Tp* __first, _Tp* __last,\n \t\t   _Tp* __result, allocator<_Up>&) noexcept\n@@ -1034,6 +1084,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template <typename _InputIterator, typename _ForwardIterator,\n \t    typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __relocate_a_1(_InputIterator __first, _InputIterator __last,\n \t\t   _ForwardIterator __result, _Allocator& __alloc)\n@@ -1056,6 +1107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template <typename _InputIterator, typename _ForwardIterator,\n \t    typename _Allocator>\n+    _GLIBCXX20_CONSTEXPR\n     inline _ForwardIterator\n     __relocate_a(_InputIterator __first, _InputIterator __last,\n \t\t _ForwardIterator __result, _Allocator& __alloc)"}, {"sha": "bd15b6bd8a8620ee50926f1ec2c0e3de64e5f8ff", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 164, "deletions": 45, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -94,17 +94,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tpointer _M_finish;\n \tpointer _M_end_of_storage;\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl_data() _GLIBCXX_NOEXCEPT\n \t: _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl_data(_Vector_impl_data&& __x) noexcept\n \t: _M_start(__x._M_start), _M_finish(__x._M_finish),\n \t  _M_end_of_storage(__x._M_end_of_storage)\n \t{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }\n #endif\n \n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT\n \t{\n@@ -113,6 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  _M_end_of_storage = __x._M_end_of_storage;\n \t}\n \n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT\n \t{\n@@ -128,26 +132,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       struct _Vector_impl\n \t: public _Tp_alloc_type, public _Vector_impl_data\n       {\n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl() _GLIBCXX_NOEXCEPT_IF(\n \t    is_nothrow_default_constructible<_Tp_alloc_type>::value)\n \t: _Tp_alloc_type()\n \t{ }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT\n \t: _Tp_alloc_type(__a)\n \t{ }\n \n #if __cplusplus >= 201103L\n \t// Not defaulted, to enforce noexcept(true) even when\n \t// !is_nothrow_move_constructible<_Tp_alloc_type>.\n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl(_Vector_impl&& __x) noexcept\n \t: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))\n \t{ }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl(_Tp_alloc_type&& __a) noexcept\n \t: _Tp_alloc_type(std::move(__a))\n \t{ }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept\n \t: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))\n \t{ }\n@@ -160,15 +169,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>\n \t      ::size_type size_type;\n \n-\t    static void _S_shrink(_Vector_impl&, size_type) { }\n-\t    static void _S_on_dealloc(_Vector_impl&) { }\n+\t    static _GLIBCXX20_CONSTEXPR void\n+\t    _S_shrink(_Vector_impl&, size_type) { }\n+\t    static _GLIBCXX20_CONSTEXPR void\n+\t    _S_on_dealloc(_Vector_impl&) { }\n \n \t    typedef _Vector_impl& _Reinit;\n \n \t    struct _Grow\n \t    {\n-\t      _Grow(_Vector_impl&, size_type) { }\n-\t      void _M_grew(size_type) { }\n+\t      _GLIBCXX20_CONSTEXPR _Grow(_Vector_impl&, size_type) { }\n+\t      _GLIBCXX20_CONSTEXPR void _M_grew(size_type) { }\n \t    };\n \t  };\n \n@@ -181,22 +192,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n \t    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to\n \t    // mark end of valid region as __curr instead of __prev.\n-\t    static void\n+\t    static _GLIBCXX20_CONSTEXPR void\n \t    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)\n \t    {\n+#if __has_builtin(__builtin_is_constant_evaluated)\n+\t      if (!__builtin_is_constant_evaluated())\n+#endif\n \t      __sanitizer_annotate_contiguous_container(__impl._M_start,\n \t\t  __impl._M_end_of_storage, __prev, __curr);\n \t    }\n \n-\t    static void\n+\t    static _GLIBCXX20_CONSTEXPR void\n \t    _S_grow(_Vector_impl& __impl, size_type __n)\n \t    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }\n \n-\t    static void\n+\t    static _GLIBCXX20_CONSTEXPR void\n \t    _S_shrink(_Vector_impl& __impl, size_type __n)\n \t    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }\n \n-\t    static void\n+\t    static _GLIBCXX20_CONSTEXPR void\n \t    _S_on_dealloc(_Vector_impl& __impl)\n \t    {\n \t      if (__impl._M_start)\n@@ -206,12 +220,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    // Used on reallocation to tell ASan unused capacity is invalid.\n \t    struct _Reinit\n \t    {\n-\t      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)\n+\t      explicit _GLIBCXX20_CONSTEXPR\n+\t      _Reinit(_Vector_impl& __impl) : _M_impl(__impl)\n \t      {\n \t\t// Mark unused capacity as valid again before deallocating it.\n \t\t_S_on_dealloc(_M_impl);\n \t      }\n \n+\t      _GLIBCXX20_CONSTEXPR\n \t      ~_Reinit()\n \t      {\n \t\t// Mark unused capacity as invalid after reallocation.\n@@ -231,12 +247,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    // Tell ASan when unused capacity is initialized to be valid.\n \t    struct _Grow\n \t    {\n+\t      _GLIBCXX20_CONSTEXPR\n \t      _Grow(_Vector_impl& __impl, size_type __n)\n \t      : _M_impl(__impl), _M_n(__n)\n \t      { _S_grow(_M_impl, __n); }\n \n+\t      _GLIBCXX20_CONSTEXPR\n \t      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }\n \n+\t      _GLIBCXX20_CONSTEXPR\n \t      void _M_grew(size_type __n) { _M_n -= __n; }\n \n #if __cplusplus >= 201103L\n@@ -272,14 +291,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       typedef _Alloc allocator_type;\n \n+      _GLIBCXX20_CONSTEXPR\n       _Tp_alloc_type&\n       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT\n       { return this->_M_impl; }\n \n+      _GLIBCXX20_CONSTEXPR\n       const _Tp_alloc_type&\n       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT\n       { return this->_M_impl; }\n \n+      _GLIBCXX20_CONSTEXPR\n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Tp_allocator()); }\n@@ -290,16 +312,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Vector_base() { }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT\n       : _M_impl(__a) { }\n \n       // Kept for ABI compatibility.\n #if !_GLIBCXX_INLINE_VERSION\n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(size_t __n)\n       : _M_impl()\n       { _M_create_storage(__n); }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _M_impl(__a)\n       { _M_create_storage(__n); }\n@@ -309,9 +334,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Kept for ABI compatibility.\n # if !_GLIBCXX_INLINE_VERSION\n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(_Tp_alloc_type&& __a) noexcept\n       : _M_impl(std::move(__a)) { }\n \n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(_Vector_base&& __x, const allocator_type& __a)\n       : _M_impl(__a)\n       {\n@@ -325,11 +352,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n # endif\n \n+      _GLIBCXX20_CONSTEXPR\n       _Vector_base(const allocator_type& __a, _Vector_base&& __x)\n       : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))\n       { }\n #endif\n \n+      _GLIBCXX20_CONSTEXPR\n       ~_Vector_base() _GLIBCXX_NOEXCEPT\n       {\n \t_M_deallocate(_M_impl._M_start,\n@@ -339,13 +368,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       _Vector_impl _M_impl;\n \n+      _GLIBCXX20_CONSTEXPR\n       pointer\n       _M_allocate(size_t __n)\n       {\n \ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n \treturn __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_deallocate(pointer __p, size_t __n)\n       {\n@@ -355,6 +386,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n     protected:\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_create_storage(size_t __n)\n       {\n@@ -443,25 +475,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       static constexpr bool\n       _S_use_relocate()\n       {\n+#if __cplusplus >= 202002L && __has_builtin(__builtin_is_constant_evaluated)\n+\tif (__builtin_is_constant_evaluated())\n+\t  return false; // Cannot use memcpy in constant evaluation contexts.\n+#endif\n \t// Instantiating std::__relocate_a might cause an error outside the\n \t// immediate context (in __relocate_object_a's noexcept-specifier),\n \t// so only do it if we know the type can be move-inserted into *this.\n \treturn _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});\n       }\n \n-      static pointer\n+      static _GLIBCXX20_CONSTEXPR pointer\n       _S_do_relocate(pointer __first, pointer __last, pointer __result,\n \t\t     _Tp_alloc_type& __alloc, true_type) noexcept\n       {\n \treturn std::__relocate_a(__first, __last, __result, __alloc);\n       }\n \n-      static pointer\n+      static _GLIBCXX20_CONSTEXPR pointer\n       _S_do_relocate(pointer, pointer, pointer __result,\n \t\t     _Tp_alloc_type&, false_type) noexcept\n       { return __result; }\n \n-      static pointer\n+      static _GLIBCXX20_CONSTEXPR pointer\n       _S_relocate(pointer __first, pointer __last, pointer __result,\n \t\t  _Tp_alloc_type& __alloc) noexcept\n       {\n@@ -494,6 +530,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @param  __a  An allocator object.\n        */\n       explicit\n+      _GLIBCXX20_CONSTEXPR\n       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT\n       : _Base(__a) { }\n \n@@ -507,6 +544,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  constructed elements.\n        */\n       explicit\n+      _GLIBCXX20_CONSTEXPR\n       vector(size_type __n, const allocator_type& __a = allocator_type())\n       : _Base(_S_check_init_len(__n, __a), __a)\n       { _M_default_initialize(__n); }\n@@ -519,6 +557,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  This constructor fills the %vector with @a __n copies of @a __value.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(_S_check_init_len(__n, __a), __a)\n@@ -550,6 +589,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  The newly-created %vector uses a copy of the allocator object used\n        *  by @a __x (unless the allocator traits dictate a different object).\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector(const vector& __x)\n       : _Base(__x.size(),\n \t_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))\n@@ -572,6 +612,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       vector(vector&&) noexcept = default;\n \n       /// Copy constructor with alternative allocator\n+      _GLIBCXX20_CONSTEXPR\n       vector(const vector& __x, const __type_identity_t<allocator_type>& __a)\n       : _Base(__x.size(), __a)\n       {\n@@ -582,10 +623,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n     private:\n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __rv, const allocator_type& __m, true_type) noexcept\n       : _Base(__m, std::move(__rv))\n       { }\n \n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __rv, const allocator_type& __m, false_type)\n       : _Base(__m)\n       {\n@@ -604,6 +647,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     public:\n       /// Move constructor with alternative allocator\n+      _GLIBCXX20_CONSTEXPR\n       vector(vector&& __rv, const __type_identity_t<allocator_type>& __m)\n       noexcept( noexcept(\n \tvector(std::declval<vector&&>(), std::declval<const allocator_type&>(),\n@@ -622,6 +666,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  This will call the element type's copy constructor N times\n        *  (where N is @a __l.size()) and do no memory reallocation.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector(initializer_list<value_type> __l,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__a)\n@@ -650,6 +695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \tvector(_InputIterator __first, _InputIterator __last,\n \t       const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n@@ -675,6 +721,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  not touched in any way.  Managing the pointer is the user's\n        *  responsibility.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       ~vector() _GLIBCXX_NOEXCEPT\n       {\n \tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n@@ -691,6 +738,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  Whether the allocator is copied depends on the allocator traits.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(const vector& __x);\n \n@@ -705,6 +753,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  Whether the allocator is moved depends on the allocator traits.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n@@ -726,6 +775,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  that the resulting %vector's size is the same as the number\n        *  of elements assigned.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       vector&\n       operator=(initializer_list<value_type> __l)\n       {\n@@ -745,6 +795,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %vector and that the resulting %vector's size is the same as\n        *  the number of elements assigned.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       assign(size_type __n, const value_type& __val)\n       { _M_fill_assign(__n, __val); }\n@@ -764,6 +815,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \tassign(_InputIterator __first, _InputIterator __last)\n \t{ _M_assign_dispatch(__first, __last, __false_type()); }\n@@ -790,6 +842,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  that the resulting %vector's size is the same as the number\n        *  of elements assigned.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       assign(initializer_list<value_type> __l)\n       {\n@@ -807,7 +860,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       iterator\n       begin() _GLIBCXX_NOEXCEPT\n       { return iterator(this->_M_impl._M_start); }\n@@ -817,7 +870,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_iterator\n       begin() const _GLIBCXX_NOEXCEPT\n       { return const_iterator(this->_M_impl._M_start); }\n@@ -827,7 +880,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       iterator\n       end() _GLIBCXX_NOEXCEPT\n       { return iterator(this->_M_impl._M_finish); }\n@@ -837,7 +890,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  the last element in the %vector.  Iteration is done in\n        *  ordinary element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_iterator\n       end() const _GLIBCXX_NOEXCEPT\n       { return const_iterator(this->_M_impl._M_finish); }\n@@ -847,7 +900,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  last element in the %vector.  Iteration is done in reverse\n        *  element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n       { return reverse_iterator(end()); }\n@@ -857,7 +910,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  to the last element in the %vector.  Iteration is done in\n        *  reverse element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n       { return const_reverse_iterator(end()); }\n@@ -867,7 +920,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  before the first element in the %vector.  Iteration is done\n        *  in reverse element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n       { return reverse_iterator(begin()); }\n@@ -877,7 +930,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  to one before the first element in the %vector.  Iteration\n        *  is done in reverse element order.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n       { return const_reverse_iterator(begin()); }\n@@ -888,7 +941,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_iterator\n       cbegin() const noexcept\n       { return const_iterator(this->_M_impl._M_start); }\n@@ -898,7 +951,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  the last element in the %vector.  Iteration is done in\n        *  ordinary element order.\n        */\n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_iterator\n       cend() const noexcept\n       { return const_iterator(this->_M_impl._M_finish); }\n@@ -908,7 +961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  to the last element in the %vector.  Iteration is done in\n        *  reverse element order.\n        */\n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       crbegin() const noexcept\n       { return const_reverse_iterator(end()); }\n@@ -918,21 +971,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  to one before the first element in the %vector.  Iteration\n        *  is done in reverse element order.\n        */\n-      [[__nodiscard__]]\n+      [[__nodiscard__]] _GLIBCXX20_CONSTEXPR\n       const_reverse_iterator\n       crend() const noexcept\n       { return const_reverse_iterator(begin()); }\n #endif\n \n       // [23.2.4.2] capacity\n       /**  Returns the number of elements in the %vector.  */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       size() const _GLIBCXX_NOEXCEPT\n       { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }\n \n       /**  Returns the size() of the largest possible %vector.  */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n       { return _S_max_size(_M_get_Tp_allocator()); }\n@@ -947,6 +1000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %vector's current size the %vector is truncated, otherwise\n        *  default constructed elements are appended.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       resize(size_type __new_size)\n       {\n@@ -967,6 +1021,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  the %vector is extended and new elements are populated with\n        *  given data.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       resize(size_type __new_size, const value_type& __x)\n       {\n@@ -987,6 +1042,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  the %vector is extended and new elements are populated with\n        *  given data.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       resize(size_type __new_size, value_type __x = value_type())\n       {\n@@ -999,6 +1055,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n       /**  A non-binding request to reduce capacity() to size().  */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       shrink_to_fit()\n       { _M_shrink_to_fit(); }\n@@ -1008,7 +1065,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns the total number of elements that the %vector can\n        *  hold before needing to allocate more memory.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       size_type\n       capacity() const _GLIBCXX_NOEXCEPT\n       { return size_type(this->_M_impl._M_end_of_storage\n@@ -1018,7 +1075,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns true if the %vector is empty.  (Thus begin() would\n        *  equal end().)\n        */\n-      _GLIBCXX_NODISCARD bool\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n+      bool\n       empty() const _GLIBCXX_NOEXCEPT\n       { return begin() == end(); }\n \n@@ -1039,6 +1097,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %advance, and thus prevent a possible reallocation of memory\n        *  and copying of %vector data.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       reserve(size_type __n);\n \n@@ -1054,7 +1113,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  out_of_range lookups are not defined. (For checked lookups\n        *  see at().)\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n       {\n@@ -1073,7 +1132,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  out_of_range lookups are not defined. (For checked lookups\n        *  see at().)\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n       {\n@@ -1083,6 +1142,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     protected:\n       /// Safety check used only from at().\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_range_check(size_type __n) const\n       {\n@@ -1105,6 +1165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  is first checked that it is in the range of the vector.  The\n        *  function throws out_of_range if the check fails.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       reference\n       at(size_type __n)\n       {\n@@ -1123,6 +1184,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  is first checked that it is in the range of the vector.  The\n        *  function throws out_of_range if the check fails.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       const_reference\n       at(size_type __n) const\n       {\n@@ -1134,7 +1196,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns a read/write reference to the data at the first\n        *  element of the %vector.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       front() _GLIBCXX_NOEXCEPT\n       {\n@@ -1146,7 +1208,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %vector.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       front() const _GLIBCXX_NOEXCEPT\n       {\n@@ -1158,7 +1220,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns a read/write reference to the data at the last\n        *  element of the %vector.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       reference\n       back() _GLIBCXX_NOEXCEPT\n       {\n@@ -1170,7 +1232,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Returns a read-only (constant) reference to the data at the\n        *  last element of the %vector.\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const_reference\n       back() const _GLIBCXX_NOEXCEPT\n       {\n@@ -1185,12 +1247,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *   Returns a pointer such that [data(), data() + size()) is a valid\n        *   range.  For a non-empty %vector, data() == &front().\n        */\n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       _Tp*\n       data() _GLIBCXX_NOEXCEPT\n       { return _M_data_ptr(this->_M_impl._M_start); }\n \n-      _GLIBCXX_NODISCARD\n+      _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR\n       const _Tp*\n       data() const _GLIBCXX_NOEXCEPT\n       { return _M_data_ptr(this->_M_impl._M_start); }\n@@ -1206,6 +1268,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  done in constant time if the %vector has preallocated space\n        *  available.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       push_back(const value_type& __x)\n       {\n@@ -1222,12 +1285,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n #if __cplusplus >= 201103L\n+      _GLIBCXX20_CONSTEXPR\n       void\n       push_back(value_type&& __x)\n       { emplace_back(std::move(__x)); }\n \n       template<typename... _Args>\n #if __cplusplus > 201402L\n+\t_GLIBCXX20_CONSTEXPR\n \treference\n #else\n \tvoid\n@@ -1244,6 +1309,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  data is needed, it should be retrieved before pop_back() is\n        *  called.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       pop_back() _GLIBCXX_NOEXCEPT\n       {\n@@ -1267,6 +1333,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  std::list.\n        */\n       template<typename... _Args>\n+\t_GLIBCXX20_CONSTEXPR\n \titerator\n \templace(const_iterator __position, _Args&&... __args)\n \t{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }\n@@ -1282,6 +1349,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  could be expensive for a %vector and if it is frequently\n        *  used the user should consider using std::list.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __position, const value_type& __x);\n #else\n@@ -1312,6 +1380,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  could be expensive for a %vector and if it is frequently\n        *  used the user should consider using std::list.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __position, value_type&& __x)\n       { return _M_insert_rval(__position, std::move(__x)); }\n@@ -1329,6 +1398,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %vector and if it is frequently used the user should\n        *  consider using std::list.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __position, initializer_list<value_type> __l)\n       {\n@@ -1354,6 +1424,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %vector and if it is frequently used the user should\n        *  consider using std::list.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       insert(const_iterator __position, size_type __n, const value_type& __x)\n       {\n@@ -1398,6 +1469,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n+\t_GLIBCXX20_CONSTEXPR\n \titerator\n \tinsert(const_iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n@@ -1448,6 +1520,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  the pointed-to memory is not touched in any way.  Managing\n        *  the pointer is the user's responsibility.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n #if __cplusplus >= 201103L\n       erase(const_iterator __position)\n@@ -1475,6 +1548,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  pointers, the pointed-to memory is not touched in any way.\n        *  Managing the pointer is the user's responsibility.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n #if __cplusplus >= 201103L\n       erase(const_iterator __first, const_iterator __last)\n@@ -1499,6 +1573,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  Whether the allocators are swapped depends on the allocator traits.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       swap(vector& __x) _GLIBCXX_NOEXCEPT\n       {\n@@ -1517,6 +1592,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  pointed-to memory is not touched in any way.  Managing the pointer is\n        *  the user's responsibility.\n        */\n+      _GLIBCXX20_CONSTEXPR\n       void\n       clear() _GLIBCXX_NOEXCEPT\n       { _M_erase_at_end(this->_M_impl._M_start); }\n@@ -1527,6 +1603,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  obtain @a n bytes of memory, and then copies [first,last) into it.\n        */\n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tpointer\n \t_M_allocate_and_copy(size_type __n,\n \t\t\t     _ForwardIterator __first, _ForwardIterator __last)\n@@ -1577,6 +1654,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by the second initialize_dispatch above\n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_range_initialize(_InputIterator __first, _InputIterator __last,\n \t\t\t    std::input_iterator_tag)\n@@ -1596,6 +1674,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by the second initialize_dispatch above\n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t    std::forward_iterator_tag)\n@@ -1612,6 +1691,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by the first initialize_dispatch above and by the\n       // vector(n,value,a) constructor.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_fill_initialize(size_type __n, const value_type& __value)\n       {\n@@ -1622,6 +1702,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n       // Called by the vector(n) constructor.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_default_initialize(size_type __n)\n       {\n@@ -1639,31 +1720,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n \t{ _M_fill_assign(__n, __val); }\n \n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type)\n \t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n \n       // Called by the second assign_dispatch above\n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t      std::input_iterator_tag);\n \n       // Called by the second assign_dispatch above\n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t      std::forward_iterator_tag);\n \n       // Called by assign(n,t), and the range assign when it turns out\n       // to be the same thing.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_fill_assign(size_type __n, const value_type& __val);\n \n@@ -1674,13 +1760,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n \t\t\t   __true_type)\n \t{ _M_fill_insert(__pos, __n, __val); }\n \n       // Called by the range insert to implement [23.1.1]/9\n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_insert_dispatch(iterator __pos, _InputIterator __first,\n \t\t\t   _InputIterator __last, __false_type)\n@@ -1691,26 +1779,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by the second insert_dispatch above\n       template<typename _InputIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_range_insert(iterator __pos, _InputIterator __first,\n \t\t\t_InputIterator __last, std::input_iterator_tag);\n \n       // Called by the second insert_dispatch above\n       template<typename _ForwardIterator>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_range_insert(iterator __pos, _ForwardIterator __first,\n \t\t\t_ForwardIterator __last, std::forward_iterator_tag);\n \n       // Called by insert(p,n,x), and the range insert when it turns out to be\n       // the same thing.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n \n #if __cplusplus >= 201103L\n       // Called by resize(n).\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_default_append(size_type __n);\n \n+      _GLIBCXX20_CONSTEXPR\n       bool\n       _M_shrink_to_fit();\n #endif\n@@ -1728,53 +1821,69 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       struct _Temporary_value\n       {\n \ttemplate<typename... _Args>\n-\t  explicit\n+\t  _GLIBCXX20_CONSTEXPR explicit\n \t  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)\n \t  {\n \t    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),\n \t\t\t\t     std::forward<_Args>(__args)...);\n \t  }\n \n+\t_GLIBCXX20_CONSTEXPR\n \t~_Temporary_value()\n \t{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }\n \n-\tvalue_type&\n-\t_M_val() { return *_M_ptr(); }\n+\t_GLIBCXX20_CONSTEXPR value_type&\n+\t_M_val() noexcept { return _M_storage._M_val; }\n \n       private:\n-\t_Tp*\n-\t_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }\n+\t_GLIBCXX20_CONSTEXPR _Tp*\n+\t_M_ptr() noexcept { return std::__addressof(_M_storage._M_val); }\n \n-\tvector* _M_this;\n-\ttypename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n+\tunion _Storage\n+\t{\n+\t  constexpr _Storage() : _M_byte() { }\n+\t  _GLIBCXX20_CONSTEXPR ~_Storage() { }\n+\t  _Storage& operator=(const _Storage&) = delete;\n+\t  unsigned char _M_byte;\n+\t  _Tp _M_val;\n+\t};\n+\n+\tvector*  _M_this;\n+\t_Storage _M_storage;\n       };\n \n       // Called by insert(p,x) and other functions when insertion needs to\n       // reallocate or move existing elements. _Arg is either _Tp& or _Tp.\n       template<typename _Arg>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_insert_aux(iterator __position, _Arg&& __arg);\n \n       template<typename... _Args>\n+\t_GLIBCXX20_CONSTEXPR\n \tvoid\n \t_M_realloc_insert(iterator __position, _Args&&... __args);\n \n       // Either move-construct at the end, or forward to _M_insert_aux.\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_insert_rval(const_iterator __position, value_type&& __v);\n \n       // Try to emplace at the end, otherwise forward to _M_insert_aux.\n       template<typename... _Args>\n+\t_GLIBCXX20_CONSTEXPR\n \titerator\n \t_M_emplace_aux(const_iterator __position, _Args&&... __args);\n \n       // Emplacing an rvalue of the correct type can use _M_insert_rval.\n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_emplace_aux(const_iterator __position, value_type&& __v)\n       { return _M_insert_rval(__position, std::move(__v)); }\n #endif\n \n       // Called by _M_fill_insert, _M_insert_aux etc.\n+      _GLIBCXX20_CONSTEXPR\n       size_type\n       _M_check_len(size_type __n, const char* __s) const\n       {\n@@ -1786,7 +1895,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n       // Called by constructors to check initial size.\n-      static size_type\n+      static _GLIBCXX20_CONSTEXPR size_type\n       _S_check_init_len(size_type __n, const allocator_type& __a)\n       {\n \tif (__n > _S_max_size(_Tp_alloc_type(__a)))\n@@ -1795,7 +1904,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \treturn __n;\n       }\n \n-      static size_type\n+      static _GLIBCXX20_CONSTEXPR size_type\n       _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT\n       {\n \t// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,\n@@ -1811,6 +1920,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,\n       // _M_assign_aux.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT\n       {\n@@ -1823,9 +1933,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  }\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_erase(iterator __position);\n \n+      _GLIBCXX20_CONSTEXPR\n       iterator\n       _M_erase(iterator __first, iterator __last);\n \n@@ -1834,6 +1946,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // Constant-time move assignment when source object's memory can be\n       // moved, either because the source's allocator will move too\n       // or because the allocators are equal.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_move_assign(vector&& __x, true_type) noexcept\n       {\n@@ -1845,6 +1958,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Do move assignment when it might not be possible to move source\n       // object's memory, resulting in a linear-time operation.\n+      _GLIBCXX20_CONSTEXPR\n       void\n       _M_move_assign(vector&& __x, false_type)\n       {\n@@ -1863,12 +1977,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n       template<typename _Up>\n+\t_GLIBCXX20_CONSTEXPR\n \t_Up*\n \t_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT\n \t{ return __ptr; }\n \n #if __cplusplus >= 201103L\n       template<typename _Ptr>\n+\t_GLIBCXX20_CONSTEXPR\n \ttypename std::pointer_traits<_Ptr>::element_type*\n \t_M_data_ptr(_Ptr __ptr) const\n \t{ return empty() ? nullptr : std::__to_address(__ptr); }\n@@ -1911,6 +2027,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  and if corresponding elements compare equal.\n   */\n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return (__x.size() == __y.size()\n@@ -1929,6 +2046,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  `<` and `>=` etc.\n   */\n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     inline __detail::__synth3way_t<_Tp>\n     operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     {\n@@ -1981,6 +2099,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   /// See std::vector::swap().\n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     inline void\n     swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n     _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))"}, {"sha": "7e3115cb7a63001d22cff0ed77d7efeb53db8630", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -62,6 +62,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<_Tp, _Alloc>::\n     reserve(size_type __n)\n@@ -102,6 +103,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n #if __cplusplus > 201402L\n+      _GLIBCXX20_CONSTEXPR\n       typename vector<_Tp, _Alloc>::reference\n #else\n       void\n@@ -126,6 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     typename vector<_Tp, _Alloc>::iterator\n     vector<_Tp, _Alloc>::\n #if __cplusplus >= 201103L\n@@ -167,6 +170,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     typename vector<_Tp, _Alloc>::iterator\n     vector<_Tp, _Alloc>::\n     _M_erase(iterator __position)\n@@ -180,6 +184,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     typename vector<_Tp, _Alloc>::iterator\n     vector<_Tp, _Alloc>::\n     _M_erase(iterator __first, iterator __last)\n@@ -194,6 +199,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     vector<_Tp, _Alloc>&\n     vector<_Tp, _Alloc>::\n     operator=(const vector<_Tp, _Alloc>& __x)\n@@ -253,6 +259,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<_Tp, _Alloc>::\n     _M_fill_assign(size_t __n, const value_type& __val)\n@@ -278,6 +285,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename _InputIterator>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_assign_aux(_InputIterator __first, _InputIterator __last,\n@@ -296,6 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename _ForwardIterator>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n@@ -336,6 +345,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     auto\n     vector<_Tp, _Alloc>::\n     _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator\n@@ -360,6 +370,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n+      _GLIBCXX20_CONSTEXPR\n       auto\n       vector<_Tp, _Alloc>::\n       _M_emplace_aux(const_iterator __position, _Args&&... __args)\n@@ -391,6 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename _Arg>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_insert_aux(iterator __position, _Arg&& __arg)\n@@ -422,6 +434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_realloc_insert(iterator __position, _Args&&... __args)\n@@ -505,6 +518,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<_Tp, _Alloc>::\n     _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n@@ -607,6 +621,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<_Tp, _Alloc>::\n     _M_default_append(size_type __n)\n@@ -683,6 +698,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Tp, typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     bool\n     vector<_Tp, _Alloc>::\n     _M_shrink_to_fit()\n@@ -696,6 +712,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename _InputIterator>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_range_insert(iterator __pos, _InputIterator __first,\n@@ -717,6 +734,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Tp, typename _Alloc>\n     template<typename _ForwardIterator>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<_Tp, _Alloc>::\n       _M_range_insert(iterator __position, _ForwardIterator __first,\n@@ -806,6 +824,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   // vector<bool>\n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<bool, _Alloc>::\n     _M_reallocate(size_type __n)\n@@ -820,6 +839,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<bool, _Alloc>::\n     _M_fill_insert(iterator __position, size_type __n, bool __x)\n@@ -852,6 +872,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   template<typename _Alloc>\n     template<typename _ForwardIterator>\n+      _GLIBCXX20_CONSTEXPR\n       void\n       vector<bool, _Alloc>::\n       _M_insert_range(iterator __position, _ForwardIterator __first, \n@@ -886,6 +907,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     void\n     vector<bool, _Alloc>::\n     _M_insert_aux(iterator __position, bool __x)\n@@ -914,6 +936,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     typename vector<bool, _Alloc>::iterator\n     vector<bool, _Alloc>::\n     _M_erase(iterator __position)\n@@ -925,6 +948,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     }\n \n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     typename vector<bool, _Alloc>::iterator\n     vector<bool, _Alloc>::\n     _M_erase(iterator __first, iterator __last)\n@@ -936,6 +960,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n   template<typename _Alloc>\n+    _GLIBCXX20_CONSTEXPR\n     bool\n     vector<bool, _Alloc>::\n     _M_shrink_to_fit()\n@@ -974,9 +999,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept\n     {\n       size_t __hash = 0;\n-      using _GLIBCXX_STD_C::_S_word_bit;\n-      using _GLIBCXX_STD_C::_Bit_type;\n-\n       const size_t __words = __b.size() / _S_word_bit;\n       if (__words)\n \t{"}, {"sha": "890b0ddb3ebe3a24aa000b4ccefb69e04e126446", "filename": "libstdc++-v3/include/std/vector", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -102,6 +102,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #define __cpp_lib_erase_if 202002L\n \n   template<typename _Tp, typename _Alloc, typename _Predicate>\n+    _GLIBCXX20_CONSTEXPR\n     inline typename vector<_Tp, _Alloc>::size_type\n     erase_if(vector<_Tp, _Alloc>& __cont, _Predicate __pred)\n     {\n@@ -115,6 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp, typename _Alloc, typename _Up>\n+    _GLIBCXX20_CONSTEXPR\n     inline typename vector<_Tp, _Alloc>::size_type\n     erase(vector<_Tp, _Alloc>& __cont, const _Up& __value)\n     {"}, {"sha": "f02659f99be4e0a0e812ea3f931d8ec034e76d2d", "filename": "libstdc++-v3/testsuite/23_containers/headers/vector/synopsis.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fvector%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fvector%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fvector%2Fsynopsis.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -27,13 +27,21 @@\n # define NOTHROW(X)\n #endif\n \n+#if __cplusplus >= 202002L\n+# define CONSTEXPR constexpr\n+#else\n+# define CONSTEXPR\n+#endif\n+\n namespace std {\n   template <class T, class Allocator> class vector;\n \n   template <class T, class Allocator>\n+    CONSTEXPR\n     bool operator==(const vector<T,Allocator>& x,\n                     const vector<T,Allocator>& y);\n \n+#if __cplusplus < 202002L\n   template <class T, class Allocator>\n     bool operator< (const vector<T,Allocator>& x,\n                     const vector<T,Allocator>& y);\n@@ -53,17 +61,21 @@ namespace std {\n   template <class T, class Allocator>\n     bool operator<=(const vector<T,Allocator>& x,\n                     const vector<T,Allocator>& y);\n+#endif\n \n   template <class T, class Allocator>\n+    CONSTEXPR\n     void swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n       NOTHROW(noexcept(x.swap(y)));\n \n   template <class Allocator> class vector<bool,Allocator>;\n \n   template <class Allocator>\n+    CONSTEXPR\n     bool operator==(const vector<bool,Allocator>& x,\n                     const vector<bool,Allocator>& y);\n \n+#if __cplusplus < 202002L\n   template <class Allocator>\n     bool operator< (const vector<bool,Allocator>& x,\n                     const vector<bool,Allocator>& y);\n@@ -83,7 +95,9 @@ namespace std {\n   template <class Allocator>\n     bool operator<=(const vector<bool,Allocator>& x,\n                     const vector<bool,Allocator>& y);\n+#endif\n \n   template <class Allocator>\n+    CONSTEXPR\n     void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);\n }"}, {"sha": "da5e6b420d236b45e5d97ed5ae53334f1ad1b95d", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/capacity/29134.cc", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2F29134.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2F29134.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2F29134.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -26,12 +26,7 @@ void test01()\n {\n   using std::vector;\n   using std::numeric_limits;\n-\n-#ifdef _GLIBCXX_DEBUG\n-  using std::_GLIBCXX_STD_C::_S_word_bit;\n-#else\n   using std::_S_word_bit;\n-#endif\n \n   // Actually, vector<bool> is special, see libstdc++/31370.\n   vector<bool> vb;"}, {"sha": "52b10b661204dcdbc1e0c70d71849e27151a1183", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/capacity/constexpr.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcapacity%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,115 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr std::size_t\n+capacity_for(std::size_t n)\n+{\n+  std::size_t N = std::vector<bool>(1).capacity();\n+  if (auto r = n % N)\n+    return n - r + N;\n+  return n;\n+}\n+\n+constexpr bool\n+test_empty()\n+{\n+  std::vector<bool> v;\n+  VERIFY( v.empty() );\n+  v = {1};\n+  VERIFY( !v.empty() );\n+\n+  return true;\n+}\n+\n+static_assert( test_empty() );\n+\n+constexpr bool\n+test_size()\n+{\n+  std::vector<bool> v;\n+  VERIFY( v.size() == 0 );\n+  v = {1};\n+  VERIFY( v.size() == 1 );\n+\n+  VERIFY( v.max_size() != 0 );\n+\n+  return true;\n+}\n+\n+static_assert( test_size() );\n+\n+constexpr bool\n+test_capacity()\n+{\n+  std::vector<bool> v;\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == v.size() );\n+  v = {false, false, false};\n+  VERIFY( v.size() == 3 );\n+  VERIFY( v.capacity() >= v.size() );\n+\n+  return true;\n+}\n+\n+static_assert( test_capacity() );\n+\n+constexpr bool\n+test_resize()\n+{\n+  std::vector<bool> v;\n+  v.reserve(9);\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == capacity_for(9) );\n+  v.resize(5);\n+  VERIFY( v.size() == 5 );\n+  VERIFY( v.capacity() == capacity_for(9) );\n+  v.resize(900, true);\n+  VERIFY( v.size() == 900 );\n+  VERIFY( v.capacity() == capacity_for(900) );\n+  VERIFY( v[10] == true );\n+\n+  return true;\n+}\n+\n+static_assert( test_resize() );\n+\n+constexpr bool\n+test_reserve()\n+{\n+  std::vector<bool> v;\n+  v.reserve(9);\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == capacity_for(9) );\n+  v.resize(2);\n+  VERIFY( v.size() == 2 );\n+  VERIFY( v.capacity() == capacity_for(9) );\n+  v.resize(300);\n+  v.resize(100);\n+  VERIFY( v.size() == 100 );\n+  VERIFY( v.capacity() == capacity_for(300) );\n+\n+  return true;\n+}\n+\n+static_assert( test_reserve() );\n+\n+constexpr bool\n+test_shrink_to_fit()\n+{\n+  std::vector<bool> v;\n+  v.reserve(9);\n+  v.shrink_to_fit();\n+  VERIFY( v.capacity() == 0 );\n+  v.reserve(9);\n+  v.resize(5);\n+  v.shrink_to_fit();\n+  VERIFY( v.capacity() == capacity_for(v.size()) );\n+\n+  return true;\n+}\n+\n+static_assert( test_shrink_to_fit() );"}, {"sha": "ae2bd03c2bae4e4f1d8b13ce28231cce36fd02e3", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/cmp_c++20.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -16,12 +16,13 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-options \"-std=gnu++2a\" }\n-// { dg-do run { target c++2a } }\n+// { dg-do compile { target c++2a } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n \n #include <vector>\n #include <testsuite_hooks.h>\n \n-void\n+constexpr bool\n test01()\n {\n   std::vector<bool> c1{ 1, 0, 1 }, c2{ 1, 0, 1, 0 }, c3{ 1, 1, 1 };\n@@ -38,9 +39,11 @@ test01()\n \n   static_assert( std::three_way_comparable<std::vector<bool>,\n \t\t\t\t\t   std::strong_ordering> );\n+\n+  return true;\n }\n \n-void\n+constexpr bool\n test05()\n {\n   // vector<bool> iterators are random access, so should support <=>\n@@ -63,11 +66,9 @@ test05()\n \n   static_assert( std::same_as<decltype(c.begin() <=> c.begin()),\n \t\t\t      std::strong_ordering> );\n-}\n \n-int\n-main()\n-{\n-  test01();\n-  test05();\n+  return true;\n }\n+\n+static_assert( test01() );\n+static_assert( test05() );"}, {"sha": "edd506081cc09fae56475e886a6f2adf51558717", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/cons/constexpr.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,280 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  constexpr Alloc select_on_container_copy_construction() const\n+  { return Alloc(-1); }\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+namespace default_constructor_global_scope\n+{\n+  constexpr std::vector<bool> v1;\n+  static_assert(v1.size() == 0);\n+  static_assert(v1.capacity() == 0);\n+\n+  constexpr std::allocator<bool> a;\n+  constexpr std::vector<bool> v2(a);\n+  static_assert(v2.size() == 0);\n+  static_assert(v2.capacity() == 0);\n+\n+  constexpr Alloc<bool> aa(10);\n+  constexpr std::vector<bool, Alloc<bool>> v3(aa);\n+  static_assert(v3.size() == 0);\n+  static_assert(v3.capacity() == 0);\n+  static_assert(v3.get_allocator() == aa);\n+}\n+\n+constexpr bool\n+default_constructor_function_scope()\n+{\n+  // vector()\n+\n+  std::vector<bool> v1;\n+  VERIFY(v1.size() == 0);\n+  VERIFY(v1.capacity() == 0);\n+\n+  // vector(const Allocator&)\n+\n+  const std::allocator<bool> a;\n+  std::vector<bool> v2(a);\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  const Alloc<bool> aa(10);\n+  std::vector<bool, Alloc<bool>> v3(aa);\n+  VERIFY(v3.size() == 0);\n+  VERIFY(v3.capacity() == 0);\n+  VERIFY(v3.get_allocator() == aa);\n+\n+  return true;\n+}\n+\n+static_assert( default_constructor_function_scope() );\n+\n+constexpr bool\n+sequence_constructors()\n+{\n+  // vector(size_type, const Allocator& = Allocator())\n+\n+  std::vector<bool> v0(0);\n+  VERIFY(v0.size() == 0);\n+\n+  std::vector<bool> v1(1);\n+  VERIFY(v1.size() == 1);\n+\n+  std::vector<bool> v2(2);\n+  VERIFY(v2.size() == 2);\n+\n+  std::vector<bool> v50(50);\n+  VERIFY(v50.size() == 50);\n+\n+  const std::allocator<bool> a;\n+  std::vector<bool> a0(0, a);\n+  VERIFY(a0.size() == 0);\n+\n+  std::vector<bool> a1(1, a);\n+  VERIFY(a1.size() == 1);\n+\n+  std::vector<bool> a2(2, a);\n+  VERIFY(a2.size() == 2);\n+\n+  std::vector<bool> a50(50, a);\n+  VERIFY(a50.size() == 50);\n+\n+  const Alloc<bool> la(10);\n+  std::vector<bool, Alloc<bool>> l0(0, la);\n+  VERIFY(l0.size() == 0);\n+  VERIFY(l0.get_allocator() == la);\n+\n+  std::vector<bool, Alloc<bool>> l1(1, la);\n+  VERIFY(l1.size() == 1);\n+  VERIFY(l1.get_allocator() == la);\n+\n+  std::vector<bool, Alloc<bool>> l2(2, la);\n+  VERIFY(l2.size() == 2);\n+  VERIFY(l2.get_allocator() == la);\n+\n+  std::vector<bool, Alloc<bool>> l50(50, la);\n+  VERIFY(l50.size() == 50);\n+  VERIFY(l50.get_allocator() == la);\n+\n+  // vector(size_type, const T&, const Allocator& = Allocator())\n+\n+  std::vector<bool> v3(3, true);\n+  VERIFY(v3.size() == 3);\n+  VERIFY(v3[0] == true && v3[2] == true);\n+\n+  std::vector<bool> a3(3, false, a);\n+  VERIFY(a3.size() == 3);\n+  VERIFY(a3[0] == false && a3[2] == false);\n+\n+  std::vector<bool, Alloc<bool>> l3(3, true, la);\n+  VERIFY(l3.size() == 3);\n+  VERIFY(l3[0] == true && l3[2] == true);\n+  VERIFY(l3.get_allocator() == la);\n+\n+  return true;\n+}\n+\n+static_assert(sequence_constructors());\n+\n+constexpr bool\n+iterator_range_constructor()\n+{\n+  // vector(InputIterator, InputIterator, const Allocator& = Allocator())\n+\n+  short range[3] = { true, false, true };\n+\n+  std::vector<bool> v0(std::begin(range), std::end(range));\n+  VERIFY(v0.size() == std::size(range));\n+  VERIFY(v0[0] == true && v0[1] == false && v0[2] == true);\n+\n+  const Alloc<bool> a(5);\n+  std::vector<bool, Alloc<bool>> l0(std::begin(range), std::end(range), a);\n+  VERIFY(l0.size() == std::size(range));\n+  VERIFY(l0.get_allocator() == a);\n+  VERIFY(l0[0] == true && l0[1] == false && l0[2] == true);\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = bool;\n+    using pointer = const bool*;\n+    using reference = bool;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr bool operator*() const { return val % 2; }\n+    constexpr const bool* operator->() const { return nullptr; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  std::vector<bool> v1(input_iterator(3), input_iterator());\n+  VERIFY(v1.size() == 3);\n+  VERIFY(v1[0] == true && v1[1] == false && v1[2] == true);\n+\n+  std::vector<bool, Alloc<bool>> l1(input_iterator(2), input_iterator(), a);\n+  VERIFY(l1.size() == 2);\n+  VERIFY(l1.get_allocator() == a);\n+  VERIFY(l1[0] == false && l1[1] == true);\n+\n+  return true;\n+}\n+\n+static_assert(iterator_range_constructor());\n+\n+constexpr bool\n+initializer_list_constructor()\n+{\n+  // vector(initializer_list<T>, const Allocator& = Allocator())\n+\n+  std::vector<bool> v0({ false, true, false });\n+  VERIFY(v0.size() == 3);\n+  VERIFY(v0[0] == false && v0[1] == true && v0[2] == false);\n+\n+  const Alloc<bool> a(5);\n+  std::vector<bool, Alloc<bool>> l0({ true, false, false }, a);\n+  VERIFY(l0.size() == 3);\n+  VERIFY(l0.get_allocator() == a);\n+  VERIFY(l0[0] == true && l0[1] == false && l0[2] == false);\n+\n+  return true;\n+}\n+\n+static_assert(initializer_list_constructor());\n+\n+constexpr bool\n+copy_constructor()\n+{\n+  const std::vector<bool> v0({ 1, 0, 0, 1, 0, 1, 1, 0 });\n+  const std::vector<bool, Alloc<bool>> l0({ 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 });\n+\n+  // vector(const vector&)\n+\n+  std::vector<bool> v1(v0);\n+  VERIFY( v1.size() == v0.size() );\n+  VERIFY( v1[0] == v0[0] && v1[1] == v0[1] && v1[2] == v0[2] );\n+  VERIFY( v1.get_allocator() == v0.get_allocator() );\n+\n+  const Alloc<bool> as(6);\n+  std::vector<bool, Alloc<bool>> s1(3, true, as);\n+  std::vector<bool, Alloc<bool>> s2(s1);\n+  VERIFY( s2.size() == s1.size() );\n+  VERIFY( s2.get_allocator().personality == -1 );\n+\n+  // vector(const vector&, const Allocator&)\n+\n+  const Alloc<bool> a(6);\n+  std::vector<bool, Alloc<bool>> l1(l0, a);\n+  VERIFY( l1.size() == l0.size() );\n+  VERIFY( l1[0] == l0[0] && l1[1] == l0[1] && l1[2] == l0[2] );\n+  VERIFY( l1.get_allocator() == a );\n+  VERIFY( l1.get_allocator() != l0.get_allocator() );\n+\n+  return true;\n+}\n+\n+static_assert(copy_constructor());\n+\n+constexpr bool\n+move_constructor()\n+{\n+  const std::vector<bool> v0({ 1, 0, 0, 1, 0, 1, 1, 0 });\n+  const std::vector<bool, Alloc<bool>> l0({ 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 });\n+\n+  // vector(const vector&)\n+\n+  std::vector<bool> v1(v0);\n+  std::vector<bool> v2(std::move(v1));\n+  VERIFY( v2.size() == v0.size() );\n+  VERIFY( v1.empty() );\n+  VERIFY( v2[0] == v0[0] && v2[1] == v0[1] && v2[2] == v0[2] );\n+  VERIFY( v2.get_allocator() == v0.get_allocator() );\n+\n+  // vector(const vector&, const Allocator&)\n+\n+  const Alloc<bool> a(6);\n+  std::vector<bool, Alloc<bool>> l1(l0);\n+  std::vector<bool, Alloc<bool>> l2(std::move(l1), a);\n+  VERIFY( l2.size() == l0.size() );\n+  VERIFY( l2[0] == l0[0] && l2[1] == l0[1] && l2[2] == l0[2] );\n+  VERIFY( l2.get_allocator() == a );\n+  VERIFY( l2.get_allocator() != l0.get_allocator() );\n+\n+  std::vector<bool, Alloc<bool>> l3(std::move(l2), a);\n+  VERIFY( l3.size() == l0.size() );\n+  VERIFY( l3[0] == l0[0] && l3[1] == l0[1] && l3[2] == l0[2] );\n+  VERIFY( l3.get_allocator() == a );\n+  VERIFY( l3.get_allocator() == l2.get_allocator() );\n+\n+  return true;\n+}\n+\n+static_assert(move_constructor());"}, {"sha": "6fa87588effa99335fb663887bbebd8b170d5ec9", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/element_access/constexpr.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,102 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_iterators()\n+{\n+  std::vector<bool> v;\n+  VERIFY( v.begin() == v.end() );\n+  v.reserve(1);\n+  VERIFY( v.begin() == v.end() );\n+  v.resize(2);\n+  VERIFY( v.begin() != v.end() );\n+  VERIFY( v.cbegin() == v.begin() );\n+  VERIFY( v.crbegin() == v.rbegin() );\n+  VERIFY( v.cend() == v.end() );\n+  VERIFY( v.crend() == v.rend() );\n+\n+  auto it = v.begin();\n+  VERIFY( *it == v.front() );\n+  VERIFY( it++ == v.begin() );\n+  VERIFY( ++it == v.end() );\n+  VERIFY( (it - 2) == v.begin() );\n+  it -= 2;\n+  it += 1;\n+  VERIFY( (it + 1) == v.end() );\n+\n+  auto rit = v.rbegin();\n+  VERIFY( *rit == v.back() );\n+  VERIFY( rit++ == v.rbegin() );\n+  VERIFY( ++rit == v.rend() );\n+  VERIFY( (rit - 2) == v.rbegin() );\n+  rit -= 2;\n+  rit += 1;\n+  VERIFY( (rit + 1) == v.rend() );\n+\n+  return true;\n+}\n+\n+static_assert(test_iterators());\n+\n+constexpr bool\n+test_access()\n+{\n+  std::vector<bool> v{1, 1, 0, 0, 1, 0, 1, 0, 1};\n+  std::vector<bool>::reference r1 = v.at(1);\n+  VERIFY( r1 );\n+  std::vector<bool>::reference r2 = v[2];\n+  VERIFY( ! r2 );\n+  r1 = r2;\n+  VERIFY( ! r1 );\n+  VERIFY( ! v[1] );\n+  r2 = true;\n+  VERIFY( r2 );\n+  VERIFY( v[2] );\n+\n+  const auto& vc = v;\n+  VERIFY( vc.at(1) == false );\n+  VERIFY( vc.at(1) == v.at(1) );\n+  VERIFY( vc.at(1) == vc[1] );\n+  VERIFY( vc.front() == vc[0] );\n+  VERIFY( vc.back() == vc[2] );\n+\n+  return true;\n+}\n+\n+static_assert(test_access());\n+\n+template<typename T = bool>\n+  constexpr std::false_type\n+  access_empty() { return {}; }\n+\n+template<typename T = bool>\n+  requires (std::bool_constant<(std::vector<T>().at(0), true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+template<typename T = bool>\n+  requires (std::bool_constant<(std::vector<T>().back(), true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+static_assert( ! access_empty() );\n+\n+template<typename T = bool>\n+  constexpr std::false_type\n+  access_empty_front() { return {}; }\n+\n+template<typename T = bool>\n+  requires (std::bool_constant<(std::vector<T>()[0], true)>::value)\n+  constexpr std::true_type\n+  access_empty_front() { return {}; }\n+\n+template<typename T = bool>\n+  requires (std::bool_constant<(std::vector<T>().front(), true)>::value)\n+  constexpr std::true_type\n+  access_empty_front() { return {}; }\n+\n+static_assert( ! access_empty_front() ); // { dg-error \"ambiguous\" \"PR 103191\" { target { ! debug-mode } } }"}, {"sha": "02faa02f954cbaab8780809e057bad3fe9e029cb", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/assign/constexpr.cc", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fassign%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fassign%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fassign%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,216 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  using propagate_on_container_move_assignment = std::false_type;\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+constexpr std::size_t\n+capacity_for(std::size_t n)\n+{\n+  std::size_t N = std::vector<bool>(1).capacity();\n+  if (auto r = n % N)\n+    return n - r + N;\n+  return n;\n+}\n+\n+constexpr bool\n+copy_assign()\n+{\n+  // vector::operator=(const vector&)\n+\n+  std::vector<bool> v1, v2;\n+  v1 = v1;\n+  v2 = v1;\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  for (int i = 0; i < 10; ++i)\n+    v1.push_back(i);\n+  v2 = v1;\n+  VERIFY(v2.size() == 10);\n+  v2.reserve(50);\n+  v1.push_back(1);\n+  v2 = v1;\n+  VERIFY(v2.size() == 11);\n+  VERIFY(v2.capacity() == capacity_for(50));\n+\n+  std::vector<bool, Alloc<bool>> va1(Alloc<bool>(1)), va2(Alloc<bool>(2));\n+  va2 = va1;\n+  VERIFY( va2.get_allocator().personality == 2 );\n+  va1.push_back(999);\n+  va2 = va1;\n+  VERIFY( va2.get_allocator().personality == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( copy_assign() );\n+\n+constexpr bool\n+move_assign()\n+{\n+  // vector::operator=(const vector&)\n+\n+  std::vector<bool> v1, v2;\n+  v1 = std::move(v1);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  for (int i = 0; i < 10; ++i)\n+    v1.push_back(i);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 10);\n+  v2.reserve(50);\n+  v1.push_back(1);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 1);\n+  VERIFY(v1.capacity() == 0);\n+  VERIFY(v2.capacity() == capacity_for(1));\n+\n+  std::vector<bool, Alloc<bool>> va1(Alloc<bool>(1)), va2(Alloc<bool>(2));\n+  va2 = std::move(va1);\n+  VERIFY( va2.get_allocator().personality == 2 );\n+  va1.push_back(9);\n+  va1.push_back(99);\n+  va1.push_back(999);\n+  va1.push_back(9999);\n+  va2 = std::move(va1);\n+  va2 = std::move(va1);\n+  VERIFY( va2.get_allocator().personality == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( move_assign() );\n+\n+constexpr bool\n+initializer_list_assign()\n+{\n+  std::vector<bool> v1;\n+  v1 = {1, 0, 1};\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1 = {1, 0};\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1 = {1, 1, 0, 1, 1, 1, 0, 1, 1};\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == capacity_for(9) );\n+\n+  std::vector<bool, Alloc<bool>> va1(Alloc<bool>(111));\n+  va1 = {1, 0, 0};\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( initializer_list_assign() );\n+\n+constexpr bool\n+assign_iterator_range()\n+{\n+  std::vector<bool> v;\n+\n+  int arr[] = { 1, 2, 3, 4 };\n+  v.assign(arr, arr+3);\n+  VERIFY( v.size() == 3 );\n+  v.reserve(5);\n+  v.assign(arr, arr+3);\n+  VERIFY( v.capacity() == capacity_for(5) );\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = bool;\n+    using pointer = const bool*;\n+    using reference = bool;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr bool operator*() const { return val % 2; }\n+    constexpr const bool* operator->() const { return nullptr; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  v.assign(input_iterator(9), input_iterator());\n+  VERIFY( v.size() == 9 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_iterator_range() );\n+\n+constexpr bool\n+assign_value()\n+{\n+  std::vector<bool> v1;\n+  v1.assign(3, 8);\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1.assign(2, 9);\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1.assign(9, 10);\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == capacity_for(9) );\n+\n+  std::vector<bool, Alloc<bool>> va1(Alloc<bool>(111));\n+  va1.assign(2, 9);\n+  VERIFY( va1.size() == 2 );\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_value() );\n+\n+constexpr bool\n+assign_initializer_list()\n+{\n+  std::vector<bool> v1;\n+  v1.assign({0, 1, 0});\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1.assign({1, 0});\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == capacity_for(3) );\n+  v1.assign({1, 0, 0, 1, 1, 0, 0, 1, 1});\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == capacity_for(9) );\n+\n+  std::vector<bool, Alloc<bool>> va1(Alloc<bool>(111));\n+  va1.assign({1, 1, 1});\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_initializer_list() );"}, {"sha": "b27df2b22270af10c573fbc4f1b03d6e4ec00399", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/constexpr.cc", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,248 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+constexpr bool\n+test_push_back()\n+{\n+  std::vector<bool> v;\n+  std::vector<bool>::reference r = v.emplace_back(\"\");\n+  VERIFY( r == true );\n+  v.emplace_back(r);\n+  VERIFY( v.back() == true );\n+  v.emplace_back(v.front());\n+  VERIFY( v.back() == true );\n+  v.resize(64);\n+  v.emplace_back(v.back());\n+  VERIFY( v.back() == false );\n+  VERIFY( v.size() == 65 );\n+  v.emplace_back(8);\n+  VERIFY( v.size() == 66 );\n+  VERIFY( v.back() == true );\n+  v.emplace_back();\n+  VERIFY( v.size() == 67 );\n+  VERIFY( v.back() == false );\n+\n+  v.pop_back();\n+  VERIFY( v.size() == 66 );\n+  VERIFY( v.back() == true );\n+  for (int i = 0, n = v.size(); i < n; ++i)\n+    v.pop_back();\n+  VERIFY( v.empty() );\n+\n+  v.push_back(true);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.push_back(v.front());\n+  VERIFY( v.capacity() > v.size() );\n+\n+  std::vector<bool, Alloc<bool>> va;\n+  va.push_back(true);\n+  va.push_back(va.front());\n+  VERIFY( va.size() == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( test_push_back() );\n+\n+template<typename T = bool>\n+constexpr std::false_type\n+pop_back_empty() { return {}; }\n+\n+template<typename T = bool>\n+requires (std::bool_constant<(std::vector<T>().pop_back(), true)>::value)\n+constexpr std::true_type\n+pop_back_empty() { return {}; }\n+\n+static_assert( ! pop_back_empty() );\n+\n+constexpr bool\n+test_insert_erase()\n+{\n+  std::vector<bool> v;\n+\n+  // vector::emplace(const_iterator, Args&&...)\n+  auto p = v.emplace(v.begin());\n+  VERIFY( p == v.begin() );\n+  p = v.emplace(v.end(), '7');\n+  VERIFY( p == --v.end() );\n+\n+  // vector::insert(const_iterator, const T&)\n+  p = v.insert(v.begin(), *p);\n+  VERIFY( p == v.begin() );\n+  VERIFY( *p );\n+  // vector::insert(const_iterator, T&&)\n+  p = v.insert(v.end(), 1);\n+  VERIFY( p == --v.end() );\n+  v.insert(p, v.front());\n+  v.insert(v.end(), v.back());\n+  VERIFY( v.size() == 6 );\n+  v.insert(v.end(), true);\n+  VERIFY( v.size() == 7 );\n+  VERIFY( v.back() == true );\n+\n+  // vector::insert(const_iterator, size_type, const T&)\n+  v.insert(v.begin(), 2, v.front());\n+  v.insert(v.end(), 3, 99);\n+  VERIFY( v.size() == 12 );\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = bool;\n+    using pointer = const bool*;\n+    using reference = bool;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr bool operator*() const { return val % 2; }\n+    constexpr const bool* operator->() const { return nullptr; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  // vector::insert(const_iterator, Iter, Iter);\n+  v.insert(v.begin() + 2, input_iterator(), input_iterator());\n+  VERIFY( v.size() == 12 );\n+  v.insert(v.end() - 9, input_iterator(18), input_iterator());\n+  VERIFY( v.size() == 30 );\n+  short a[] = { false, true };\n+  v.insert(v.end(), a, a + 2);\n+  VERIFY( v.size() == 32 );\n+\n+  // vector::insert(const_iterator, initializer_list<T>)\n+  v.insert(v.begin(), {1,1,1});\n+  VERIFY( v.size() == 35 );\n+\n+  // vector::erase(const_iterator)\n+  v.erase(v.end() - 1);\n+  VERIFY( v.size() == 34 );\n+  VERIFY( v.back() == false );\n+  v.erase(v.begin());\n+  v.erase(v.begin() + 1);\n+  v.erase(v.end() - 1);\n+  VERIFY( v.size() == 31 );\n+\n+  // vector::erase(const_iterator, const_iterator)\n+  v.erase(v.begin(), v.begin());\n+  v.erase(v.end(), v.end());\n+  v.erase(v.begin(), v.begin() + 1);\n+  VERIFY( v.size() == 30 );\n+  v.erase(v.begin() + 2, v.end() - 2);\n+  VERIFY( v.size() == 4 );\n+  v.erase(v.begin(), v.end());\n+  VERIFY( v.empty() );\n+  v.erase( v.begin(), v.begin() );\n+  VERIFY( v.empty() );\n+\n+  v.insert(v.end(), 99);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.insert(v.end() - 1, v.front());\n+  VERIFY( v.capacity() > v.size() );\n+  v.insert(v.end(), 999);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.insert(v.begin(), v.front());\n+\n+  std::vector<bool, Alloc<bool>> va;\n+  va.insert(va.begin(), 99);\n+  va.insert(va.begin(), va.front());\n+  VERIFY( va.size() == 2 );\n+  va.erase(va.begin());\n+\n+  return true;\n+}\n+\n+static_assert( test_insert_erase() );\n+\n+constexpr std::size_t\n+capacity_for(std::size_t n)\n+{\n+  std::size_t N = std::vector<bool>(1).capacity();\n+  if (auto r = n % N)\n+    return n - r + N;\n+  return n;\n+}\n+\n+constexpr bool\n+test_clear()\n+{\n+  std::vector<bool> v0;\n+  v0.clear();\n+  VERIFY( v0.size() == 0 );\n+  VERIFY( v0.capacity() == 0 );\n+\n+  std::vector<bool> v{1, 0, 0};\n+  v.clear();\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == capacity_for(3) );\n+\n+  std::vector<bool, Alloc<bool>> va;\n+  va.clear();\n+  va.push_back(1);\n+  va.clear();\n+  va.clear();\n+\n+  return true;\n+}\n+\n+static_assert( test_clear() );\n+\n+constexpr bool\n+test_flip()\n+{\n+  std::vector<bool> v{1, 0, 0, 1, 0, 1, 1, 0};\n+  v.flip();\n+  VERIFY( !v[0] && v[1] && v[2] && !v[3] && v[4] && !v[5] && !v[6] && v[7] );\n+  v[2].flip();\n+  VERIFY( !v[2] );\n+  v[2].flip();\n+  VERIFY( v[2] );\n+\n+  return true;\n+}\n+\n+static_assert( test_flip() );\n+\n+constexpr bool\n+test_erasure()\n+{\n+  std::vector<bool> e{true,true,true,false,true,false};\n+\n+  auto n = std::erase(e, false);\n+  VERIFY( n == 2 );\n+  VERIFY( e.size() == 4 );\n+  e[2] = false;\n+  n = std::erase_if(e, [](std::vector<bool>::reference val) { return !val; });\n+  VERIFY( n == 1 );\n+  VERIFY( e.size() == 3 );\n+\n+  return true;\n+}\n+\n+static_assert( test_erasure() );"}, {"sha": "c67944663cfb21edc013e272f0c21a4da5876c47", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/insert/31370.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Finsert%2F31370.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Finsert%2F31370.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Finsert%2F31370.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -24,11 +24,7 @@\n #include <stdexcept>\n #include <testsuite_hooks.h>\n \n-#ifdef _GLIBCXX_DEBUG\n-  using std::_GLIBCXX_STD_C::_S_word_bit;\n-#else\n-  using std::_S_word_bit;\n-#endif\n+using std::_S_word_bit;\n \n inline void\n check_cap_ge_size(const std::vector<bool>& x)"}, {"sha": "ba444d04ee90c1f3beedeb961886fe17dd10f7aa", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/modifiers/swap/constexpr.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fmodifiers%2Fswap%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_std_swap()\n+{\n+  std::vector<bool> v1 = {true, false, true};\n+  std::vector<bool> v2 = {false, true};\n+\n+  std::swap(v1, v2);\n+\n+  VERIFY(v1.size() == 2);\n+  VERIFY(v1.at(0) == false);\n+  VERIFY(v1.at(1) == true);\n+\n+  VERIFY(v2.size() == 3);\n+  VERIFY(v2[0]);\n+  VERIFY(!v2[1]);\n+  VERIFY(v2[2]);\n+\n+  return true;\n+}\n+\n+static_assert(test_std_swap());\n+\n+constexpr bool\n+test_member_swap()\n+{\n+  std::vector<bool> v1 = {true, false, true};\n+  std::vector<bool> v2 = {false, true};\n+\n+  v1.swap(v2);\n+\n+  VERIFY(v1.size() == 2);\n+  VERIFY(v1.at(0) == false);\n+  VERIFY(v1.at(1) == true);\n+\n+  VERIFY(v2.size() == 3);\n+  VERIFY(v2[0]);\n+  VERIFY(!v2[1]);\n+  VERIFY(v2[2]);\n+\n+  return true;\n+}\n+\n+static_assert(test_member_swap());\n+\n+constexpr bool\n+test_reference_swap()\n+{\n+  std::vector<bool> v1 = {true, false, true};\n+  std::vector<bool>::swap(v1[0], v1[1]);\n+\n+  VERIFY(v1[0] == false);\n+  VERIFY(v1[1] == true);\n+  VERIFY(v1[2] == true);\n+\n+  return true;\n+}\n+\n+static_assert(test_reference_swap());"}, {"sha": "de9d0b03790e3b78c6d2e340f29c5f3c02b4fe7b", "filename": "libstdc++-v3/testsuite/23_containers/vector/capacity/constexpr.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_empty()\n+{\n+  std::vector<int> v;\n+  VERIFY( v.empty() );\n+  v = {1};\n+  VERIFY( !v.empty() );\n+\n+  return true;\n+}\n+\n+static_assert( test_empty() );\n+\n+constexpr bool\n+test_size()\n+{\n+  std::vector<int> v;\n+  VERIFY( v.size() == 0 );\n+  v = {1};\n+  VERIFY( v.size() == 1 );\n+\n+  VERIFY( v.max_size() != 0 );\n+\n+  return true;\n+}\n+\n+static_assert( test_size() );\n+\n+constexpr bool\n+test_capacity()\n+{\n+  std::vector<int> v;\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == v.size() );\n+  v = {1, 2, 3};\n+  VERIFY( v.size() == 3 );\n+  VERIFY( v.capacity() == v.size() );\n+\n+  return true;\n+}\n+\n+static_assert( test_capacity() );\n+\n+constexpr bool\n+test_resize()\n+{\n+  std::vector<int> v;\n+  v.reserve(9);\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == 9 );\n+  v.resize(5);\n+  VERIFY( v.size() == 5 );\n+  VERIFY( v.capacity() == 9 );\n+  v.resize(15, 6);\n+  VERIFY( v.size() == 15 );\n+  VERIFY( v[10] == 6 );\n+\n+  return true;\n+}\n+\n+static_assert( test_resize() );\n+\n+constexpr bool\n+test_reserve()\n+{\n+  std::vector<int> v;\n+  v.reserve(9);\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == 9 );\n+  v.resize(2);\n+  VERIFY( v.size() == 2 );\n+  VERIFY( v.capacity() == 9 );\n+\n+  return true;\n+}\n+\n+static_assert( test_reserve() );\n+\n+constexpr bool\n+test_shrink_to_fit()\n+{\n+  std::vector<int> v;\n+  v.reserve(9);\n+  v.shrink_to_fit();\n+  VERIFY( v.capacity() == 0 );\n+  v.reserve(9);\n+  v.resize(5);\n+  v.shrink_to_fit();\n+  VERIFY( v.capacity() == v.size() );\n+\n+  return true;\n+}\n+\n+static_assert( test_shrink_to_fit() );"}, {"sha": "8f4a2645e91c4c229bc7671fe9e56dd074607fc3", "filename": "libstdc++-v3/testsuite/23_containers/vector/cmp_c++20.cc", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -16,12 +16,13 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-options \"-std=gnu++2a\" }\n-// { dg-do run { target c++2a } }\n+// { dg-do compile { target c++2a } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n \n #include <vector>\n #include <testsuite_hooks.h>\n \n-void\n+constexpr bool\n test01()\n {\n   std::vector<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n@@ -47,24 +48,26 @@ test01()\n \n   struct E\n   {\n-    bool operator==(E) { return true; }\n+    constexpr bool operator==(E) const { return true; }\n   };\n   static_assert( ! std::totally_ordered<std::vector<E>> );\n   static_assert( ! std::three_way_comparable<E> );\n   static_assert( ! std::three_way_comparable<std::vector<E>> );\n+\n+  return true;\n }\n \n-void\n+constexpr bool\n test02()\n {\n   struct W\n   {\n     int value = 0;\n \n-    bool operator==(W rhs) const noexcept\n+    constexpr bool operator==(W rhs) const noexcept\n     { return (value | 1) == (rhs.value | 1); }\n \n-    std::weak_ordering\n+    constexpr std::weak_ordering\n     operator<=>(W rhs) const noexcept\n     { return (value | 1) <=> (rhs.value | 1); }\n   };\n@@ -75,23 +78,25 @@ test02()\n   static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n   VERIFY( c1 == c2 );\n   VERIFY( std::is_eq(c1 <=> c2) );\n+\n+  return true;\n }\n \n-void\n+constexpr bool\n test03()\n {\n   struct P\n   {\n     int value = 0;\n \n-    bool operator==(P rhs) const noexcept\n+    constexpr bool operator==(P rhs) const noexcept\n     {\n       if (value < 0 || rhs.value < 0)\n \treturn false;\n       return value == rhs.value;\n     }\n \n-    std::partial_ordering\n+    constexpr std::partial_ordering\n     operator<=>(P rhs) const noexcept\n     {\n       if (value < 0 || rhs.value < 0)\n@@ -106,26 +111,30 @@ test03()\n   static_assert( std::three_way_comparable<P> );\n   static_assert( std::same_as<decltype(c <=> c), std::partial_ordering> );\n   VERIFY( (c <=> c) == std::partial_ordering::unordered );\n+\n+  return true;\n }\n \n-void\n+constexpr bool\n test04()\n {\n   struct L\n   {\n     int value = 0;\n \n-    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+    constexpr bool operator<(L rhs) const noexcept { return value < rhs.value; }\n   };\n \n   static_assert( std::totally_ordered<std::vector<L>> );\n \n   std::vector<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n   static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n   VERIFY( std::is_lt(c <=> d) );\n+\n+  return true;\n }\n \n-void\n+constexpr bool\n test05()\n {\n   // vector iterators are random access, so should support <=>\n@@ -148,14 +157,12 @@ test05()\n \n   static_assert( std::same_as<decltype(c.begin() <=> c.begin()),\n \t\t\t      std::strong_ordering> );\n-}\n \n-int\n-main()\n-{\n-  test01();\n-  test02();\n-  test03();\n-  test04();\n-  test05();\n+  return true;\n }\n+\n+static_assert( test01() );\n+static_assert( test02() );\n+static_assert( test03() );\n+static_assert( test04() );\n+static_assert( test05() );"}, {"sha": "4f8396fba6d721052fa4d2cb13fc35e5cd6fd1fa", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/89164.cc", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -31,20 +31,18 @@ void test01()\n {\n   X x[1];\n   // Should not be able to create vector using uninitialized_copy:\n-  std::vector<X> v1{x, x+1};\t// { dg-error \"here\" }\n-\n-  // Should not be able to create vector using uninitialized_fill_n:\n-  std::vector<X> v2{2u, X{}};\t// { dg-error \"here\" }\n+  std::vector<X> v1{x, x+1};\t// { dg-error \"here\" \"\" { target c++17_down } }\n+  // { dg-error \"deleted function 'X::X\" \"\" { target c++20 } 0 }\n }\n \n void test02()\n {\n-#if __cplusplus >= 201703L\n   struct Y : X { };\n-  // Can create initializer_list<Y> with C++17 guaranteed copy elision,\n-  // but shouldn't be able to copy from it with uninitialized_copy:\n-  std::vector<Y> v3{Y{}, Y{}, Y{}};   // { dg-error \"here\" \"\" { target c++17 } }\n-#endif\n+\n+  // Should not be able to create vector using uninitialized_fill_n:\n+  std::vector<Y> v2{2u, Y{}};\t// { dg-error \"here\" \"\" { target c++17_down } }\n+  // { dg-error \"deleted function .*Y::Y\" \"\" { target c++20 } 0 }\n }\n \n // { dg-error \"must be constructible from input type\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"construct_at\" }"}, {"sha": "24ade4e0800a00bbba2bfe09edc869970e531989", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/89164_c++17.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++17 } }\n+\n+#include <vector>\n+\n+// PR libstdc++/89164\n+\n+struct X\n+{\n+  X() = default;\n+  X(const X&) = delete;\n+};\n+\n+void test03()\n+{\n+  // Can create initializer_list<Y> with C++17 guaranteed copy elision,\n+  // but shouldn't be able to copy from it with uninitialized_copy:\n+  std::vector<X> v3{X{}, X{}, X{}};   // { dg-error \"here\" \"\" { target c++17_only } }\n+  // { dg-error \"deleted function .*X::X\" \"\" { target c++20 } 0 }\n+}\n+\n+// { dg-error \"must be constructible from input type\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"construct_at\" }"}, {"sha": "f02b39aefad6cdf1b0e9f5b0e3d475efb1fa530f", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/constexpr.cc", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,279 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  constexpr Alloc select_on_container_copy_construction() const\n+  { return Alloc(-1); }\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+namespace default_constructor_global_scope\n+{\n+  constexpr std::vector<int> v1;\n+  static_assert(v1.size() == 0);\n+  static_assert(v1.capacity() == 0);\n+\n+  constexpr std::allocator<int> a;\n+  constexpr std::vector<int> v2(a);\n+  static_assert(v2.size() == 0);\n+  static_assert(v2.capacity() == 0);\n+\n+  constexpr Alloc<int> aa(10);\n+  constexpr std::vector<int, Alloc<int>> v3(aa);\n+  static_assert(v3.size() == 0);\n+  static_assert(v3.capacity() == 0);\n+  static_assert(v3.get_allocator() == aa);\n+}\n+\n+constexpr bool\n+default_constructor_function_scope()\n+{\n+  // vector()\n+\n+  std::vector<int> v1;\n+  VERIFY(v1.size() == 0);\n+  VERIFY(v1.capacity() == 0);\n+\n+  // vector(const Allocator&)\n+\n+  const std::allocator<int> a;\n+  std::vector<int> v2(a);\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  const Alloc<long> aa(10);\n+  std::vector<long, Alloc<long>> v3(aa);\n+  VERIFY(v3.size() == 0);\n+  VERIFY(v3.capacity() == 0);\n+  VERIFY(v3.get_allocator() == aa);\n+\n+  return true;\n+}\n+\n+static_assert( default_constructor_function_scope() );\n+\n+constexpr bool\n+sequence_constructors()\n+{\n+  // vector(size_type, const Allocator& = Allocator())\n+\n+  std::vector<int> v0(0);\n+  VERIFY(v0.size() == 0);\n+\n+  std::vector<int> v1(1);\n+  VERIFY(v1.size() == 1);\n+\n+  std::vector<int> v2(2);\n+  VERIFY(v2.size() == 2);\n+\n+  std::vector<int> v50(50);\n+  VERIFY(v50.size() == 50);\n+\n+  const std::allocator<int> a;\n+  std::vector<int> a0(0, a);\n+  VERIFY(a0.size() == 0);\n+\n+  std::vector<int> a1(1, a);\n+  VERIFY(a1.size() == 1);\n+\n+  std::vector<int> a2(2, a);\n+  VERIFY(a2.size() == 2);\n+\n+  std::vector<int> a50(50, a);\n+  VERIFY(a50.size() == 50);\n+\n+  const Alloc<long> la(10);\n+  std::vector<long, Alloc<long>> l0(0, la);\n+  VERIFY(l0.size() == 0);\n+  VERIFY(l0.get_allocator() == la);\n+\n+  std::vector<long, Alloc<long>> l1(1, la);\n+  VERIFY(l1.size() == 1);\n+  VERIFY(l1.get_allocator() == la);\n+\n+  std::vector<long, Alloc<long>> l2(2, la);\n+  VERIFY(l2.size() == 2);\n+  VERIFY(l2.get_allocator() == la);\n+\n+  std::vector<long, Alloc<long>> l50(50, la);\n+  VERIFY(l50.size() == 50);\n+  VERIFY(l50.get_allocator() == la);\n+\n+  // vector(size_type, const T&, const Allocator& = Allocator())\n+\n+  std::vector<int> v3(3, 4);\n+  VERIFY(v3.size() == 3);\n+  VERIFY(v3[0] == 4 && v3[2] == 4);\n+\n+  std::vector<int> a3(3, 5, a);\n+  VERIFY(a3.size() == 3);\n+  VERIFY(a3[0] == 5 && a3[2] == 5);\n+\n+  std::vector<long, Alloc<long>> l3(3, 6, la);\n+  VERIFY(l3.size() == 3);\n+  VERIFY(l3[0] == 6 && l3[2] == 6);\n+  VERIFY(l3.get_allocator() == la);\n+\n+  return true;\n+}\n+\n+static_assert(sequence_constructors());\n+\n+constexpr bool\n+iterator_range_constructor()\n+{\n+  // vector(InputIterator, InputIterator, const Allocator& = Allocator())\n+\n+  short range[3] = { 1, 2, 3 };\n+\n+  std::vector<int> v0(std::begin(range), std::end(range));\n+  VERIFY(v0.size() == std::size(range));\n+  VERIFY(v0[0] == 1 && v0[1] == 2 && v0[2] == 3);\n+\n+  const Alloc<long> a(5);\n+  std::vector<long, Alloc<long>> l0(std::begin(range), std::end(range), a);\n+  VERIFY(l0.size() == std::size(range));\n+  VERIFY(l0.get_allocator() == a);\n+  VERIFY(l0[0] == 1 && l0[1] == 2 && l0[2] == 3);\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = int;\n+    using pointer = const int*;\n+    using reference = int;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr int operator*() const { return val; }\n+    constexpr const int* operator->() const { return &val; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  std::vector<int> v1(input_iterator(3), input_iterator());\n+  VERIFY(v1.size() == 3);\n+  VERIFY(v1[0] == 3 && v1[1] == 2 && v1[2] == 1);\n+\n+  std::vector<long, Alloc<long>> l1(input_iterator(2), input_iterator(), a);\n+  VERIFY(l1.size() == 2);\n+  VERIFY(l1.get_allocator() == a);\n+  VERIFY(l1[0] == 2 && l1[1] == 1);\n+\n+  return true;\n+}\n+\n+static_assert(iterator_range_constructor());\n+\n+constexpr bool\n+initializer_list_constructor()\n+{\n+  // vector(initializer_list<T>, const Allocator& = Allocator())\n+\n+  std::vector<int> v0({ 1, 2, 3 });\n+  VERIFY(v0.size() == 3);\n+  VERIFY(v0[0] == 1 && v0[1] == 2 && v0[2] == 3);\n+\n+  const Alloc<long> a(5);\n+  std::vector<long, Alloc<long>> l0({ 1, 2, 3 }, a);\n+  VERIFY(l0.size() == 3);\n+  VERIFY(l0.get_allocator() == a);\n+\n+  return true;\n+}\n+\n+static_assert(initializer_list_constructor());\n+\n+constexpr bool\n+copy_constructor()\n+{\n+  const std::vector<int> v0({ 1, 2, 3 });\n+  const std::vector<long, Alloc<long>> l0({ 4, 5, 6 });\n+\n+  // vector(const vector&)\n+\n+  std::vector<int> v1(v0);\n+  VERIFY( v1.size() == v0.size() );\n+  VERIFY( v1[0] == v0[0] && v1[1] == v0[1] && v1[2] == v0[2] );\n+  VERIFY( v1.get_allocator() == v0.get_allocator() );\n+\n+  const Alloc<short> as(6);\n+  std::vector<short, Alloc<short>> s1(3, short(2), as);\n+  std::vector<short, Alloc<short>> s2(s1);\n+  VERIFY( s2.size() == s1.size() );\n+  VERIFY( s2.get_allocator().personality == -1 );\n+\n+  // vector(const vector&, const Allocator&)\n+\n+  const Alloc<long> a(6);\n+  std::vector<long, Alloc<long>> l1(l0, a);\n+  VERIFY( l1.size() == l0.size() );\n+  VERIFY( l1[0] == l0[0] && l1[1] == l0[1] && l1[2] == l0[2] );\n+  VERIFY( l1.get_allocator() == a );\n+  VERIFY( l1.get_allocator() != l0.get_allocator() );\n+\n+  return true;\n+}\n+\n+static_assert(copy_constructor());\n+\n+constexpr bool\n+move_constructor()\n+{\n+  const std::vector<int> v0({ 1, 2, 3 });\n+  const std::vector<long, Alloc<long>> l0({ 4, 5, 6 });\n+\n+  // vector(const vector&)\n+\n+  std::vector<int> v1(v0);\n+  std::vector<int> v2(std::move(v1));\n+  VERIFY( v2.size() == v0.size() );\n+  VERIFY( v1.empty() );\n+  VERIFY( v2[0] == v0[0] && v2[1] == v0[1] && v2[2] == v0[2] );\n+  VERIFY( v2.get_allocator() == v0.get_allocator() );\n+\n+  // vector(const vector&, const Allocator&)\n+\n+  const Alloc<long> a(6);\n+  std::vector<long, Alloc<long>> l1(l0);\n+  std::vector<long, Alloc<long>> l2(std::move(l1), a);\n+  VERIFY( l2.size() == l0.size() );\n+  VERIFY( l2[0] == l0[0] && l2[1] == l0[1] && l2[2] == l0[2] );\n+  VERIFY( l2.get_allocator() == a );\n+  VERIFY( l2.get_allocator() != l0.get_allocator() );\n+\n+  std::vector<long, Alloc<long>> l3(std::move(l2), a);\n+  VERIFY( l3.size() == l0.size() );\n+  VERIFY( l3[0] == l0[0] && l3[1] == l0[1] && l3[2] == l0[2] );\n+  VERIFY( l3.get_allocator() == a );\n+  VERIFY( l3.get_allocator() == l2.get_allocator() );\n+\n+  return true;\n+}\n+\n+static_assert(move_constructor());"}, {"sha": "45b3167eab086536a5cfb2199f803b96078b1f35", "filename": "libstdc++-v3/testsuite/23_containers/vector/data_access/constexpr.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdata_access%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdata_access%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdata_access%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_data()\n+{\n+  std::vector<int> v;\n+  VERIFY( v.data() == nullptr );\n+  v.reserve(1);\n+  VERIFY( v.data() != nullptr );\n+  const std::vector<int> v2{1,3,5,9};\n+  VERIFY( v.data() != v2.data() );\n+  VERIFY( v2.data()[2] == 5 );\n+\n+  v = v2;\n+  VERIFY( v.data() != v2.data() );\n+  VERIFY( v.data()[1] == 3 );\n+\n+  return true;\n+}\n+\n+static_assert(test_data());"}, {"sha": "9b3b7f634d77ff4d61c95564b9687ab673b7d16b", "filename": "libstdc++-v3/testsuite/23_containers/vector/element_access/constexpr.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Felement_access%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Felement_access%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Felement_access%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,91 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_iterators()\n+{\n+  std::vector<int> v;\n+  VERIFY( v.begin() == v.end() );\n+  v.reserve(1);\n+  VERIFY( v.begin() == v.end() );\n+  v.resize(2);\n+  VERIFY( v.begin() != v.end() );\n+  VERIFY( v.cbegin() == v.begin() );\n+  VERIFY( v.crbegin() == v.rbegin() );\n+  VERIFY( v.cend() == v.end() );\n+  VERIFY( v.crend() == v.rend() );\n+\n+  auto it = v.begin();\n+  VERIFY( &*it == &v.front() );\n+  VERIFY( it++ == v.begin() );\n+  VERIFY( ++it == v.end() );\n+  VERIFY( (it - 2) == v.begin() );\n+  it -= 2;\n+  it += 1;\n+  VERIFY( (it + 1) == v.end() );\n+\n+  auto rit = v.rbegin();\n+  VERIFY( &*rit == &v.back() );\n+  VERIFY( rit++ == v.rbegin() );\n+  VERIFY( ++rit == v.rend() );\n+  VERIFY( (rit - 2) == v.rbegin() );\n+  rit -= 2;\n+  rit += 1;\n+  VERIFY( (rit + 1) == v.rend() );\n+\n+  return true;\n+}\n+\n+static_assert(test_iterators());\n+\n+constexpr bool\n+test_access()\n+{\n+  std::vector<int> v{1, 2, 3};\n+  VERIFY( v.at(1) == 2 );\n+  VERIFY( v[2] == 3 );\n+  VERIFY( &v[2] == &v.at(2) );\n+  VERIFY( &v.front() == &v[0] );\n+  VERIFY( &v.back() == &v[2] );\n+\n+  const auto& vc = v;\n+  VERIFY( vc.at(1) == 2 );\n+  VERIFY( &vc.at(1) == &v.at(1) );\n+  VERIFY( &vc.at(1) == &vc[1] );\n+  VERIFY( &vc.front() == &vc[0] );\n+  VERIFY( &vc.back() == &vc[2] );\n+\n+  return true;\n+}\n+\n+static_assert(test_access());\n+\n+template<typename T = int>\n+  constexpr std::false_type\n+  access_empty() { return {}; }\n+\n+template<typename T = int>\n+  requires (std::bool_constant<(std::vector<T>().at(0), true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+template<typename T = int>\n+  requires (std::bool_constant<(std::vector<T>()[0], true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+template<typename T = int>\n+  requires (std::bool_constant<(std::vector<T>().front(), true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+template<typename T = int>\n+  requires (std::bool_constant<(std::vector<T>().back(), true)>::value)\n+  constexpr std::true_type\n+  access_empty() { return {}; }\n+\n+static_assert( ! access_empty() );"}, {"sha": "638cffe9822bd1264fbfd1ca1c3c9fcfb26bf50b", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/assign/constexpr.cc", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fassign%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fassign%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fassign%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,207 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  using propagate_on_container_move_assignment = std::false_type;\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+constexpr bool\n+copy_assign()\n+{\n+  // vector::operator=(const vector&)\n+\n+  std::vector<int> v1, v2;\n+  v1 = v1;\n+  v2 = v1;\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  for (int i = 0; i < 10; ++i)\n+    v1.push_back(i);\n+  v2 = v1;\n+  VERIFY(v2.size() == 10);\n+  v2.reserve(50);\n+  v1.push_back(1);\n+  v2 = v1;\n+  VERIFY(v2.size() == 11);\n+  VERIFY(v2.capacity() == 50);\n+\n+  std::vector<int, Alloc<int>> va1(Alloc<int>(1)), va2(Alloc<int>(2));\n+  va2 = va1;\n+  VERIFY( va2.get_allocator().personality == 2 );\n+  va1.push_back(999);\n+  va2 = va1;\n+  VERIFY( va2.get_allocator().personality == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( copy_assign() );\n+\n+constexpr bool\n+move_assign()\n+{\n+  // vector::operator=(const vector&)\n+\n+  std::vector<int> v1, v2;\n+  v1 = std::move(v1);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 0);\n+  VERIFY(v2.capacity() == 0);\n+\n+  for (int i = 0; i < 10; ++i)\n+    v1.push_back(i);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 10);\n+  v2.reserve(50);\n+  v1.push_back(1);\n+  v2 = std::move(v1);\n+  VERIFY(v2.size() == 1);\n+  VERIFY(v1.capacity() == 0);\n+  VERIFY(v2.capacity() == 1);\n+\n+  std::vector<int, Alloc<int>> va1(Alloc<int>(1)), va2(Alloc<int>(2));\n+  va2 = std::move(va1);\n+  VERIFY( va2.get_allocator().personality == 2 );\n+  va1.push_back(9);\n+  va1.push_back(99);\n+  va1.push_back(999);\n+  va1.push_back(9999);\n+  va2 = std::move(va1);\n+  va2 = std::move(va1);\n+  VERIFY( va2.get_allocator().personality == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( move_assign() );\n+\n+constexpr bool\n+initializer_list_assign()\n+{\n+  std::vector<int> v1;\n+  v1 = {1, 2, 3};\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1 = {1, 2};\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == 9 );\n+\n+  std::vector<int, Alloc<int>> va1(Alloc<int>(111));\n+  va1 = {1, 2, 3};\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( initializer_list_assign() );\n+\n+constexpr bool\n+assign_iterator_range()\n+{\n+  std::vector<int> v;\n+\n+  int arr[] = { 1, 2, 3, 4 };\n+  v.assign(arr, arr+3);\n+  VERIFY( v.size() == 3 );\n+  v.reserve(5);\n+  v.assign(arr, arr+3);\n+  VERIFY( v.capacity() == 5 );\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = int;\n+    using pointer = const int*;\n+    using reference = int;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr int operator*() const { return val; }\n+    constexpr const int* operator->() const { return &val; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  v.assign(input_iterator(9), input_iterator());\n+  VERIFY( v.size() == 9 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_iterator_range() );\n+\n+constexpr bool\n+assign_value()\n+{\n+  std::vector<int> v1;\n+  v1.assign(3, 8);\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1.assign(2, 9);\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1.assign(9, 10);\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == 9 );\n+\n+  std::vector<int, Alloc<int>> va1(Alloc<int>(111));\n+  va1.assign(2, 9);\n+  VERIFY( va1.size() == 2 );\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_value() );\n+\n+constexpr bool\n+assign_initializer_list()\n+{\n+  std::vector<int> v1;\n+  v1.assign({1, 2, 3});\n+  VERIFY( v1.size() == 3 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1.assign({1, 2});\n+  VERIFY( v1.size() == 2 );\n+  VERIFY( v1.capacity() == 3 );\n+  v1.assign({1, 2, 3, 4, 5, 6, 7, 8, 9});\n+  VERIFY( v1.size() == 9 );\n+  VERIFY( v1.capacity() == 9 );\n+\n+  std::vector<int, Alloc<int>> va1(Alloc<int>(111));\n+  va1.assign({1, 2, 3});\n+  VERIFY( va1.get_allocator().personality == 111 );\n+\n+  return true;\n+}\n+\n+static_assert( assign_initializer_list() );"}, {"sha": "36efecf5807d1ffd4849e7b41e99e27402633a10", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/constexpr.cc", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,226 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  using std::allocator<T>::allocator;\n+\n+  constexpr explicit Alloc(int p) : personality(p) { }\n+\n+  template<typename U>\n+    constexpr Alloc(const Alloc<U>& a) : personality(a.personality) { }\n+\n+  int personality = 0;\n+\n+  constexpr bool operator==(const Alloc& a) const noexcept\n+  { return personality == a.personality; }\n+};\n+\n+constexpr bool\n+test_push_back()\n+{\n+  std::vector<int> v;\n+  int& r = v.emplace_back(7);\n+  VERIFY( r == 7 );\n+  VERIFY( &r == &v.front() );\n+  v.emplace_back(r);\n+  v.emplace_back(v.front());\n+  v.emplace_back(v.back());\n+  VERIFY( v.size() == 4 );\n+  v.emplace_back(8);\n+  VERIFY( v.size() == 5 );\n+  VERIFY( v.back() == 8 );\n+\n+  v.pop_back();\n+  VERIFY( v.size() == 4 );\n+  VERIFY( v.back() == 7 );\n+  v.pop_back();\n+  v.pop_back();\n+  v.pop_back();\n+  v.pop_back();\n+  VERIFY( v.empty() );\n+\n+  v.push_back(99);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.push_back(v.front());\n+  VERIFY( v.capacity() > v.size() );\n+\n+  std::vector<int, Alloc<int>> va;\n+  va.push_back(99);\n+  va.push_back(va.front());\n+  VERIFY( va.size() == 2 );\n+\n+  return true;\n+}\n+\n+static_assert( test_push_back() );\n+\n+template<typename T = int>\n+constexpr std::false_type\n+pop_back_empty() { return {}; }\n+\n+template<typename T = int>\n+requires (std::bool_constant<(std::vector<T>().pop_back(), true)>::value)\n+constexpr std::true_type\n+pop_back_empty() { return {}; }\n+\n+static_assert( ! pop_back_empty() );\n+\n+constexpr bool\n+test_insert_erase()\n+{\n+  std::vector<int> v;\n+\n+  // vector::emplace(const_iterator, Args&&...)\n+  auto p = v.emplace(v.begin());\n+  VERIFY( p == v.begin() );\n+  p = v.emplace(v.end(), 7);\n+  VERIFY( p == --v.end() );\n+\n+  // vector::insert(const_iterator, const T&)\n+  p = v.insert(v.begin(), *p);\n+  VERIFY( p == v.begin() );\n+  VERIFY( *p == 7 );\n+  VERIFY( &*p == &v.front() );\n+  // vector::insert(const_iterator, T&&)\n+  p = v.insert(v.end(), 1);\n+  VERIFY( p == --v.end() );\n+  v.insert(p, v.front());\n+  v.insert(v.end(), v.back());\n+  VERIFY( v.size() == 6 );\n+  v.insert(v.end(), 8);\n+  VERIFY( v.size() == 7 );\n+  VERIFY( v.back() == 8 );\n+\n+  // vector::insert(const_iterator, size_type, const T&)\n+  v.insert(v.begin(), 2, v.front());\n+  v.insert(v.end(), 3, 99);\n+  VERIFY( v.size() == 12 );\n+\n+  struct input_iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = int;\n+    using pointer = const int*;\n+    using reference = int;\n+    using difference_type = int;\n+\n+    constexpr input_iterator() : val(0) { }\n+    constexpr input_iterator(int i) : val(i) { }\n+\n+    constexpr input_iterator& operator++() { --val; return *this; }\n+    constexpr input_iterator operator++(int) { return {val--}; }\n+\n+    constexpr int operator*() const { return val; }\n+    constexpr const int* operator->() const { return &val; }\n+\n+    constexpr bool operator==(const input_iterator&) const = default;\n+\n+    int val;\n+  };\n+\n+  // vector::insert(const_iterator, Iter, Iter);\n+  v.insert(v.begin() + 2, input_iterator(), input_iterator());\n+  VERIFY( v.size() == 12 );\n+  v.reserve(13);\n+  auto n = v.capacity() - v.size();\n+  v.insert(v.end() - 9, input_iterator(n), input_iterator()); // no reallocation\n+  VERIFY( v.size() == (12 + n) );\n+  short a[] = { 84, 85 };\n+  v.insert(v.end() - 1, a, a + 2); // reallocation needed\n+  VERIFY( v.size() == (12 + n + 2) );\n+  v.resize(32);\n+\n+  // vector::insert(const_iterator, initializer_list<T>)\n+  v.insert(v.begin(), {1,2,3});\n+  VERIFY( v.size() == 35 );\n+\n+  v.rbegin()[0] = 999;\n+  v.rbegin()[1] = 888;\n+\n+  // vector::erase(const_iterator)\n+  v.erase(v.end() - 1);\n+  VERIFY( v.size() == 34 );\n+  VERIFY( v.back() == 888 );\n+  v.erase(v.begin());\n+  v.erase(v.begin() + 1);\n+  v.erase(v.end() - 1);\n+  VERIFY( v.size() == 31 );\n+\n+  // vector::erase(const_iterator, const_iterator)\n+  v.erase(v.begin(), v.begin());\n+  v.erase(v.end(), v.end());\n+  v.erase(v.begin(), v.begin() + 1);\n+  VERIFY( v.size() == 30 );\n+  v.erase(v.begin() + 2, v.end() - 2);\n+  VERIFY( v.size() == 4 );\n+  v.erase(v.begin(), v.end());\n+  VERIFY( v.empty() );\n+  v.erase( v.begin(), v.begin() );\n+  VERIFY( v.empty() );\n+\n+  v.insert(v.end(), 99);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.insert(v.end() - 1, v.front());\n+  VERIFY( v.capacity() > v.size() );\n+  v.insert(v.end(), 999);\n+  for (std::size_t i = 0, c = v.capacity(); i <= c; ++i)\n+    v.insert(v.begin(), v.front());\n+\n+  std::vector<int, Alloc<int>> va;\n+  va.insert(va.begin(), 99);\n+  va.insert(va.begin(), va.front());\n+  VERIFY( va.size() == 2 );\n+  va.erase(va.begin());\n+\n+  return true;\n+}\n+\n+static_assert( test_insert_erase() );\n+\n+constexpr bool\n+test_clear()\n+{\n+  std::vector<int> v0;\n+  v0.clear();\n+  VERIFY( v0.size() == 0 );\n+  VERIFY( v0.capacity() == 0 );\n+\n+  std::vector<int> v{1, 10, 100};\n+  v.clear();\n+  VERIFY( v.size() == 0 );\n+  VERIFY( v.capacity() == 3 );\n+\n+  std::vector<int, Alloc<int>> va;\n+  va.clear();\n+  va.push_back(1);\n+  va.clear();\n+  va.clear();\n+\n+  return true;\n+}\n+\n+static_assert( test_clear() );\n+\n+constexpr bool\n+test_erasure()\n+{\n+  const char* names[] = { \"Vince\", \"Clarke\", \"Andy\", \"Bell\" };\n+  std::vector<const char*> e(std::begin(names), std::end(names));\n+\n+  auto n = std::erase(e, names[0]);\n+  VERIFY( n == 1 );\n+  VERIFY( e.size() == 3 );\n+  n = std::erase_if(e, [](auto name) { return name[4] == '\\0'; });\n+  VERIFY( n == 2 );\n+  VERIFY( e.size() == 1 );\n+\n+  return true;\n+}\n+\n+static_assert( test_erasure() );"}, {"sha": "4d06558b47b305d0c8b478c8eb0057df7937d511", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/swap/constexpr.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae8edf5f73ca5c3bf132cc52825dc1f709499dd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2Fconstexpr.cc?ref=1ae8edf5f73ca5c3bf132cc52825dc1f709499dd", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-xfail-if \"not supported\" { debug-mode } }\n+\n+#include <vector>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_std_swap()\n+{\n+  std::vector<int> v1 = {1, 2, 3};\n+  std::vector<int> v2 = {0, 1};\n+\n+  std::swap(v1, v2);\n+\n+  VERIFY(v1.size() == 2);\n+  VERIFY(v1.at(0) == 0);\n+  VERIFY(v1.at(1) == 1);\n+\n+  VERIFY(v2.size() == 3);\n+  VERIFY(v2[0] == 1);\n+  VERIFY(v2[1] == 2);\n+  VERIFY(v2[2] == 3);\n+\n+  return true;\n+}\n+\n+static_assert(test_std_swap());\n+\n+constexpr bool\n+test_member_swap()\n+{\n+  std::vector<int> v1 = {1, 2, 3};\n+  std::vector<int> v2 = {0, 1};\n+\n+  v1.swap(v2);\n+\n+  VERIFY(v1.size() == 2);\n+  VERIFY(v1.at(0) == 0);\n+  VERIFY(v1.at(1) == 1);\n+\n+  VERIFY(v2.size() == 3);\n+  VERIFY(v2[0] == 1);\n+  VERIFY(v2[1] == 2);\n+  VERIFY(v2[2] == 3);\n+\n+  return true;\n+}\n+\n+static_assert(test_member_swap());"}]}