{"sha": "4452a7660b224ff310d246bc7f8c612669c8cd98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ1MmE3NjYwYjIyNGZmMzEwZDI0NmJjN2Y4YzYxMjY2OWM4Y2Q5OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-23T11:29:40Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-23T11:29:40Z"}, "message": "vect: Fix epilogue loop handling of partial vectors\n\nThis patch fixes the fallout that Kewen reported on Power after\nthe recent change to avoid unnecessary use of partial vectors.\nAs Kewen said, the problem is that vect_analyze_loop_2 doesn't\nknow how many epilogue iterations there will be, and so it\ncannot make a final decision about whether the number of\niterations forces an epilogue loop to use partial vectors.\n\nThis is similar to the current situation for peeling: we don't know\nduring initial analysis whether an epilogue loop will itself require\npeeling.  Instead we decide that during vect_do_peeling, where the\nfinal number of epilogue loop iterations is known.\n\nThe patch takes a similar approach for the decision about whether\nto use partial vectors.  As the comments in the patch say, the\nidea is that vect_analyze_loop_2 should make peeling and partial-\nvector decisions based on the assumption that the loop_vinfo will\nbe used as the main loop, while vect_do_peeling should make them\nin the knowledge that the loop_vinfo will be used as an epilogue loop.\n\nThis allows the same analysis to be used for both cases, which we\nrely on for implementing VECT_COMPARE_COSTS; see the big comment\nin vect_analyze_loop for details.\n\nI hope the patch makes the (mostly preexisting) structure a bit\nmore obvious.  It isn't what anyone would design from scratch,\nbut that's the nature of working with a mature vector framework.\n\nArranging things this way means that vect_verify_full_masking\nand vect_verify_loop_lens now become part of the \u201ccan\u201d rather\nthan \u201cwill\u201d test for partial vectors.\n\nAlso, while splitting out the logic that handles epilogues with\nconstant iterations, I added a check to make sure that we don't\ntry to use partial vectors to vectorise a single-scalar loop.\nThis required some changes to the Power tests.\n\ngcc/\n\t* tree-vectorizer.h (determine_peel_for_niter): Delete in favor of...\n\t(vect_determine_partial_vectors_and_peeling): ...this new function.\n\t* tree-vect-loop-manip.c (vect_update_epilogue_niters): New function.\n\tReject using vector epilogue loops for single iterations.  Install\n\tthe constant number of epilogue loop iterations in the associated\n\tloop_vinfo.  Rely on vect_determine_partial_vectors_and_peeling\n\tto do the main part of the test.\n\t(vect_do_peeling): Use vect_update_epilogue_niters to handle\n\tepilogue loops with a known number of iterations.  Skip recomputing\n\tthe number of iterations later in that case.  Otherwise, use\n\tvect_determine_partial_vectors_and_peeling to decide whether the\n\tepilogue loop needs to use partial vectors or peeling.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Set the\n\tdefault can_use_partial_vectors_p to false if partial-vector-usage=0.\n\t(determine_peel_for_niter): Remove in favor of...\n\t(vect_determine_partial_vectors_and_peeling): ...this new function,\n\tsplit out from...\n\t(vect_analyze_loop_2): ...here.  Reflect the vect_verify_full_masking\n\tand vect_verify_loop_lens results in CAN_USE_PARTIAL_VECTORS_P\n\trather than USING_PARTIAL_VECTORS_P.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/p9-vec-length-epil-1.c: Do not expect the\n\tsingle-iteration epilogues of the 64-bit loops to be vectorized.\n\t* gcc.target/powerpc/p9-vec-length-epil-7.c: Likewise.\n\t* gcc.target/powerpc/p9-vec-length-epil-8.c: Likewise.", "tree": {"sha": "eecf6ab863ceca04f5a7f854c470e2828f6eb38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eecf6ab863ceca04f5a7f854c470e2828f6eb38b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4452a7660b224ff310d246bc7f8c612669c8cd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4452a7660b224ff310d246bc7f8c612669c8cd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4452a7660b224ff310d246bc7f8c612669c8cd98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4452a7660b224ff310d246bc7f8c612669c8cd98/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b5377b3766804059b7824330d33d0e1cef2e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b5377b3766804059b7824330d33d0e1cef2e5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02b5377b3766804059b7824330d33d0e1cef2e5b"}], "stats": {"total": 292, "additions": 192, "deletions": 100}, "files": [{"sha": "d248f091b52accdc76105e57c559c0a8ede20ea4", "filename": "gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-1.c?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -10,6 +10,6 @@\n \n /* { dg-final { scan-assembler-times {\\mlxvx?\\M} 20 } } */\n /* { dg-final { scan-assembler-times {\\mstxvx?\\M} 10 } } */\n-/* { dg-final { scan-assembler-times {\\mlxvl\\M} 20 } } */\n-/* { dg-final { scan-assembler-times {\\mstxvl\\M} 10 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvl\\M} 14 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvl\\M} 7 } } */\n "}, {"sha": "a27ee347ca1d6fd22b2fa2efa32ce0a66ba23652", "filename": "gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-7.c?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -8,4 +8,4 @@\n \n #include \"p9-vec-length-7.h\"\n \n-/* { dg-final { scan-assembler-times {\\mstxvl\\M} 10 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvl\\M} 7 } } */"}, {"sha": "961df0d56469f4a0607db60fe1f627805fe92cfb", "filename": "gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-vec-length-epil-8.c?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -8,5 +8,5 @@\n \n #include \"p9-vec-length-8.h\"\n \n-/* { dg-final { scan-assembler-times {\\mlxvl\\M} 30 } } */\n-/* { dg-final { scan-assembler-times {\\mstxvl\\M} 10 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvl\\M} 21 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvl\\M} 7 } } */"}, {"sha": "7cf00e6eed4eedd2458bb62b3c972b5f5ecafcf3", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -2386,6 +2386,34 @@ slpeel_update_phi_nodes_for_lcssa (class loop *epilog)\n     rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi.phi (), e));\n }\n \n+/* EPILOGUE_VINFO is an epilogue loop that we now know would need to\n+   iterate exactly CONST_NITERS times.  Make a final decision about\n+   whether the epilogue loop should be used, returning true if so.  */\n+\n+static bool\n+vect_update_epilogue_niters (loop_vec_info epilogue_vinfo,\n+\t\t\t     unsigned HOST_WIDE_INT const_niters)\n+{\n+  /* Avoid wrap-around when computing const_niters - 1.  Also reject\n+     using an epilogue loop for a single scalar iteration, even if\n+     we could in principle implement that using partial vectors.  */\n+  unsigned int gap_niters = LOOP_VINFO_PEELING_FOR_GAPS (epilogue_vinfo);\n+  if (const_niters <= gap_niters + 1)\n+    return false;\n+\n+  /* Install the number of iterations.  */\n+  tree niters_type = TREE_TYPE (LOOP_VINFO_NITERS (epilogue_vinfo));\n+  tree niters_tree = build_int_cst (niters_type, const_niters);\n+  tree nitersm1_tree = build_int_cst (niters_type, const_niters - 1);\n+\n+  LOOP_VINFO_NITERS (epilogue_vinfo) = niters_tree;\n+  LOOP_VINFO_NITERSM1 (epilogue_vinfo) = nitersm1_tree;\n+\n+  /* Decide what to do if the number of epilogue iterations is not\n+     a multiple of the epilogue loop's vectorization factor.  */\n+  return vect_determine_partial_vectors_and_peeling (epilogue_vinfo, true);\n+}\n+\n /* Function vect_do_peeling.\n \n    Input:\n@@ -2493,6 +2521,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   int estimated_vf;\n   int prolog_peeling = 0;\n   bool vect_epilogues = loop_vinfo->epilogue_vinfos.length () > 0;\n+  bool vect_epilogues_updated_niters = false;\n   /* We currently do not support prolog peeling if the target alignment is not\n      known at compile time.  'vect_gen_prolog_loop_niters' depends on the\n      target alignment being constant.  */\n@@ -2601,8 +2630,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   if (vect_epilogues\n       && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && prolog_peeling >= 0\n-      && known_eq (vf, lowest_vf)\n-      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (epilogue_vinfo))\n+      && known_eq (vf, lowest_vf))\n     {\n       unsigned HOST_WIDE_INT eiters\n \t= (LOOP_VINFO_INT_NITERS (loop_vinfo)\n@@ -2612,13 +2640,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       eiters\n \t= eiters % lowest_vf + LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo);\n \n-      unsigned int ratio;\n-      unsigned int epilogue_gaps\n-\t= LOOP_VINFO_PEELING_FOR_GAPS (epilogue_vinfo);\n-      while (!(constant_multiple_p\n-\t       (GET_MODE_SIZE (loop_vinfo->vector_mode),\n-\t\tGET_MODE_SIZE (epilogue_vinfo->vector_mode), &ratio)\n-\t       && eiters >= lowest_vf / ratio + epilogue_gaps))\n+      while (!vect_update_epilogue_niters (epilogue_vinfo, eiters))\n \t{\n \t  delete epilogue_vinfo;\n \t  epilogue_vinfo = NULL;\n@@ -2629,8 +2651,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t    }\n \t  epilogue_vinfo = loop_vinfo->epilogue_vinfos[0];\n \t  loop_vinfo->epilogue_vinfos.ordered_remove (0);\n-\t  epilogue_gaps = LOOP_VINFO_PEELING_FOR_GAPS (epilogue_vinfo);\n \t}\n+      vect_epilogues_updated_niters = true;\n     }\n   /* Prolog loop may be skipped.  */\n   bool skip_prolog = (prolog_peeling != 0);\n@@ -2928,7 +2950,9 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t skip_e edge.  */\n       if (skip_vector)\n \t{\n-\t  gcc_assert (update_e != NULL && skip_e != NULL);\n+\t  gcc_assert (update_e != NULL\n+\t\t      && skip_e != NULL\n+\t\t      && !vect_epilogues_updated_niters);\n \t  gphi *new_phi = create_phi_node (make_ssa_name (TREE_TYPE (niters)),\n \t\t\t\t\t   update_e->dest);\n \t  tree new_ssa = make_ssa_name (TREE_TYPE (niters));\n@@ -2953,25 +2977,32 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  niters = PHI_RESULT (new_phi);\n \t}\n \n-      /* Subtract the number of iterations performed by the vectorized loop\n-\t from the number of total iterations.  */\n-      tree epilogue_niters = fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n-\t\t\t\t\t  before_loop_niters,\n-\t\t\t\t\t  niters);\n-\n-      LOOP_VINFO_NITERS (epilogue_vinfo) = epilogue_niters;\n-      LOOP_VINFO_NITERSM1 (epilogue_vinfo)\n-\t= fold_build2 (MINUS_EXPR, TREE_TYPE (epilogue_niters),\n-\t\t       epilogue_niters,\n-\t\t       build_one_cst (TREE_TYPE (epilogue_niters)));\n-\n       /* Set ADVANCE to the number of iterations performed by the previous\n \t loop and its prologue.  */\n       *advance = niters;\n \n-      /* Redo the peeling for niter analysis as the NITERs and alignment\n-\t may have been updated to take the main loop into account.  */\n-      determine_peel_for_niter (epilogue_vinfo);\n+      if (!vect_epilogues_updated_niters)\n+\t{\n+\t  /* Subtract the number of iterations performed by the vectorized loop\n+\t     from the number of total iterations.  */\n+\t  tree epilogue_niters = fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n+\t\t\t\t\t      before_loop_niters,\n+\t\t\t\t\t      niters);\n+\n+\t  LOOP_VINFO_NITERS (epilogue_vinfo) = epilogue_niters;\n+\t  LOOP_VINFO_NITERSM1 (epilogue_vinfo)\n+\t    = fold_build2 (MINUS_EXPR, TREE_TYPE (epilogue_niters),\n+\t\t\t   epilogue_niters,\n+\t\t\t   build_one_cst (TREE_TYPE (epilogue_niters)));\n+\n+\t  /* Decide what to do if the number of epilogue iterations is not\n+\t     a multiple of the epilogue loop's vectorization factor.\n+\t     We should have rejected the loop during the analysis phase\n+\t     if this fails.  */\n+\t  if (!vect_determine_partial_vectors_and_peeling (epilogue_vinfo,\n+\t\t\t\t\t\t\t   true))\n+\t    gcc_unreachable ();\n+\t}\n     }\n \n   adjust_vec.release ();"}, {"sha": "f1d6bdde4123b975703a1674da9fb594d0b9f0b3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 128, "deletions": 68, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -814,7 +814,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     vec_outside_cost (0),\n     vec_inside_cost (0),\n     vectorizable (false),\n-    can_use_partial_vectors_p (true),\n+    can_use_partial_vectors_p (param_vect_partial_vector_usage != 0),\n     using_partial_vectors_p (false),\n     epil_using_partial_vectors_p (false),\n     peeling_for_gaps (false),\n@@ -2003,22 +2003,123 @@ vect_dissolve_slp_only_groups (loop_vec_info loop_vinfo)\n     }\n }\n \n+/* Determine if operating on full vectors for LOOP_VINFO might leave\n+   some scalar iterations still to do.  If so, decide how we should\n+   handle those scalar iterations.  The possibilities are:\n \n-/* Decides whether we need to create an epilogue loop to handle\n-   remaining scalar iterations and sets PEELING_FOR_NITERS accordingly.  */\n+   (1) Make LOOP_VINFO operate on partial vectors instead of full vectors.\n+       In this case:\n \n-void\n-determine_peel_for_niter (loop_vec_info loop_vinfo)\n+\t LOOP_VINFO_USING_PARTIAL_VECTORS_P == true\n+\t LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P == false\n+\t LOOP_VINFO_PEELING_FOR_NITER == false\n+\n+   (2) Make LOOP_VINFO operate on full vectors and use an epilogue loop\n+       to handle the remaining scalar iterations.  In this case:\n+\n+\t LOOP_VINFO_USING_PARTIAL_VECTORS_P == false\n+\t LOOP_VINFO_PEELING_FOR_NITER == true\n+\n+       There are two choices:\n+\n+       (2a) Consider vectorizing the epilogue loop at the same VF as the\n+\t    main loop, but using partial vectors instead of full vectors.\n+\t    In this case:\n+\n+\t      LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P == true\n+\n+       (2b) Consider vectorizing the epilogue loop at lower VFs only.\n+\t    In this case:\n+\n+\t      LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P == false\n+\n+   When FOR_EPILOGUE_P is true, make this determination based on the\n+   assumption that LOOP_VINFO is an epilogue loop, otherwise make it\n+   based on the assumption that LOOP_VINFO is the main loop.  The caller\n+   has made sure that the number of iterations is set appropriately for\n+   this value of FOR_EPILOGUE_P.  */\n+\n+opt_result\n+vect_determine_partial_vectors_and_peeling (loop_vec_info loop_vinfo,\n+\t\t\t\t\t    bool for_epilogue_p)\n {\n-  LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n+  /* Determine whether there would be any scalar iterations left over.  */\n+  bool need_peeling_or_partial_vectors_p\n+    = vect_need_peeling_or_partial_vectors_p (loop_vinfo);\n \n-  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n-    /* The main loop handles all iterations.  */\n-    LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n-  else if (vect_need_peeling_or_partial_vectors_p (loop_vinfo))\n-    LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n-}\n+  /* Decide whether to vectorize the loop with partial vectors.  */\n+  LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+  LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+  if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+      && need_peeling_or_partial_vectors_p)\n+    {\n+      /* For partial-vector-usage=1, try to push the handling of partial\n+\t vectors to the epilogue, with the main loop continuing to operate\n+\t on full vectors.\n+\n+\t ??? We could then end up failing to use partial vectors if we\n+\t decide to peel iterations into a prologue, and if the main loop\n+\t then ends up processing fewer than VF iterations.  */\n+      if (param_vect_partial_vector_usage == 1\n+\t  && !LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n+\t  && !vect_known_niters_smaller_than_vf (loop_vinfo))\n+\tLOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n+      else\n+\tLOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"operating on partial vectors%s.\\n\",\n+\t\t\t for_epilogue_p ? \" for epilogue loop\" : \"\");\n+      else\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"operating only on full vectors%s.\\n\",\n+\t\t\t for_epilogue_p ? \" for epilogue loop\" : \"\");\n+    }\n \n+  if (for_epilogue_p)\n+    {\n+      loop_vec_info orig_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo);\n+      gcc_assert (orig_loop_vinfo);\n+      if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n+\tgcc_assert (known_lt (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t\t      LOOP_VINFO_VECT_FACTOR (orig_loop_vinfo)));\n+    }\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n+    {\n+      /* Check that the loop processes at least one full vector.  */\n+      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      tree scalar_niters = LOOP_VINFO_NITERS (loop_vinfo);\n+      if (known_lt (wi::to_widest (scalar_niters), vf))\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"loop does not have enough iterations\"\n+\t\t\t\t       \" to support vectorization.\\n\");\n+\n+      /* If we need to peel an extra epilogue iteration to handle data\n+\t accesses with gaps, check that there are enough scalar iterations\n+\t available.\n+\n+\t The check above is redundant with this one when peeling for gaps,\n+\t but the distinction is useful for diagnostics.  */\n+      tree scalar_nitersm1 = LOOP_VINFO_NITERSM1 (loop_vinfo);\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n+\t  && known_lt (wi::to_widest (scalar_nitersm1), vf))\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"loop does not have enough iterations\"\n+\t\t\t\t       \" to support peeling for gaps.\\n\");\n+    }\n+\n+  LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n+    = (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n+       && need_peeling_or_partial_vectors_p);\n+\n+  return opt_result::success ();\n+}\n \n /* Function vect_analyze_loop_2.\n \n@@ -2272,72 +2373,32 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n     }\n \n-  /* Decide whether to vectorize a loop with partial vectors for\n-     this vectorization factor.  */\n-  if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n-    {\n-      /* Don't use partial vectors if we don't need to peel the loop.  */\n-      if (param_vect_partial_vector_usage == 0\n-\t  || !vect_need_peeling_or_partial_vectors_p (loop_vinfo))\n-\tLOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n-      else if (vect_verify_full_masking (loop_vinfo)\n-\t       || vect_verify_loop_lens (loop_vinfo))\n-\t{\n-\t  /* The epilogue and other known niters less than VF\n-\t    cases can still use vector access with length fully.  */\n-\t  if (param_vect_partial_vector_usage == 1\n-\t      && !LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n-\t      && !vect_known_niters_smaller_than_vf (loop_vinfo))\n-\t    {\n-\t      LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n-\t      LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n-\t    }\n-\t  else\n-\t    LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n-\t}\n-      else\n-\tLOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n-    }\n-  else\n-    LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n-\n-  if (dump_enabled_p ())\n-    {\n-      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"operating on partial vectors.\\n\");\n-      else\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"operating only on full vectors.\\n\");\n-    }\n-\n-  /* If epilog loop is required because of data accesses with gaps,\n-     one additional iteration needs to be peeled.  Check if there is\n-     enough iterations for vectorization.  */\n-  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n-      && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n-    {\n-      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-      tree scalar_niters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n-\n-      if (known_lt (wi::to_widest (scalar_niters), vf))\n-\treturn opt_result::failure_at (vect_location,\n-\t\t\t\t       \"loop has no enough iterations to\"\n-\t\t\t\t       \" support peeling for gaps.\\n\");\n-    }\n+  /* If we still have the option of using partial vectors,\n+     check whether we can generate the necessary loop controls.  */\n+  if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+      && !vect_verify_full_masking (loop_vinfo)\n+      && !vect_verify_loop_lens (loop_vinfo))\n+    LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \n   /* If we're vectorizing an epilogue loop, the vectorized loop either needs\n      to be able to handle fewer than VF scalars, or needs to have a lower VF\n      than the main loop.  */\n   if (LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n-      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n+      && !LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n       && maybe_ge (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n \t\t   LOOP_VINFO_VECT_FACTOR (orig_loop_vinfo)))\n     return opt_result::failure_at (vect_location,\n \t\t\t\t   \"Vectorization factor too high for\"\n \t\t\t\t   \" epilogue loop.\\n\");\n \n+  /* Decide whether this loop_vinfo should use partial vectors or peeling,\n+     assuming that the loop will be used as a main loop.  We will redo\n+     this analysis later if we instead decide to use the loop as an\n+     epilogue loop.  */\n+  ok = vect_determine_partial_vectors_and_peeling (loop_vinfo, false);\n+  if (!ok)\n+    return ok;\n+\n   /* Check the costings of the loop make vectorizing worthwhile.  */\n   res = vect_analyze_loop_costing (loop_vinfo);\n   if (res < 0)\n@@ -2350,7 +2411,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n     return opt_result::failure_at (vect_location,\n \t\t\t\t   \"Loop costings not worthwhile.\\n\");\n \n-  determine_peel_for_niter (loop_vinfo);\n   /* If an epilogue loop is required make sure we can create one.  */\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n       || LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo))"}, {"sha": "b7fa6bc8d2ff775653cdbff168700789b5822ac9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4452a7660b224ff310d246bc7f8c612669c8cd98/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4452a7660b224ff310d246bc7f8c612669c8cd98", "patch": "@@ -1967,7 +1967,8 @@ extern tree vect_create_addr_base_for_vector_ref (vec_info *,\n extern widest_int vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo);\n bool vect_rgroup_iv_might_wrap_p (loop_vec_info, rgroup_controls *);\n /* Used in tree-vect-loop-manip.c */\n-extern void determine_peel_for_niter (loop_vec_info);\n+extern opt_result vect_determine_partial_vectors_and_peeling (loop_vec_info,\n+\t\t\t\t\t\t\t      bool);\n /* Used in gimple-loop-interchange.c and tree-parloops.c.  */\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);"}]}