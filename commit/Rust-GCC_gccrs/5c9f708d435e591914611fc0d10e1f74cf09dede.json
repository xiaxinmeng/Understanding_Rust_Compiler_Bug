{"sha": "5c9f708d435e591914611fc0d10e1f74cf09dede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM5ZjcwOGQ0MzVlNTkxOTE0NjExZmMwZDEwZTFmNzRjZjA5ZGVkZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-15T03:42:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-15T03:42:26Z"}, "message": "Makefile.in (USER_H): Remove va-foo.h.\n\n        * Makefile.in (USER_H): Remove va-foo.h.\n\n        * ginclude/{va-alpha.h,va-arc.h,va-c4x.h,va-clipper.h,va-h8300.h,\n        va-i860.h,va-i960.h,va-m32r.h,va-m88k.h,va-mips.h,va-mn10200.h,\n        va-mn10300.h,va-pa.h,va-ppc.h,va-pyr.h,va-sh.h,va-sparc.h,\n        va-spur.h,va-v850.h}: Remove.\n\nFrom-SVN: r29424", "tree": {"sha": "f4b09ab2f99b63b2636007007f7e9d3e3c807859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4b09ab2f99b63b2636007007f7e9d3e3c807859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c9f708d435e591914611fc0d10e1f74cf09dede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9f708d435e591914611fc0d10e1f74cf09dede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9f708d435e591914611fc0d10e1f74cf09dede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9f708d435e591914611fc0d10e1f74cf09dede/comments", "author": null, "committer": null, "parents": [{"sha": "5126c35a6212e443cc7050199eb18411c56fe874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5126c35a6212e443cc7050199eb18411c56fe874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5126c35a6212e443cc7050199eb18411c56fe874"}], "stats": {"total": 2141, "additions": 2, "deletions": 2139}, "files": [{"sha": "dd4fa3dc6cddf25518d61143f24ceb59723d5c5f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c9f708d435e591914611fc0d10e1f74cf09dede/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c9f708d435e591914611fc0d10e1f74cf09dede/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5c9f708d435e591914611fc0d10e1f74cf09dede", "patch": "@@ -146,18 +146,8 @@ INSTALL_HEADERS_DIR = @build_install_headers_dir@\n # Header files that are made available under the same name\n # to programs compiled with GCC.\n USER_H = $(srcdir)/ginclude/stdarg.h $(srcdir)/ginclude/stddef.h \\\n-    $(srcdir)/ginclude/varargs.h $(srcdir)/ginclude/va-alpha.h \\\n-    $(srcdir)/ginclude/va-h8300.h $(srcdir)/ginclude/va-i860.h \\\n-    $(srcdir)/ginclude/va-i960.h $(srcdir)/ginclude/va-mips.h \\\n-    $(srcdir)/ginclude/va-m88k.h $(srcdir)/ginclude/va-mn10200.h \\\n-    $(srcdir)/ginclude/va-mn10300.h $(srcdir)/ginclude/va-pa.h \\\n-    $(srcdir)/ginclude/va-pyr.h $(srcdir)/ginclude/va-sparc.h \\\n-    $(srcdir)/ginclude/va-clipper.h $(srcdir)/ginclude/va-spur.h \\\n-    $(srcdir)/ginclude/va-m32r.h $(srcdir)/ginclude/va-sh.h \\\n-    $(srcdir)/ginclude/va-v850.h $(srcdir)/ginclude/va-arc.h \\\n-    $(srcdir)/ginclude/iso646.h $(srcdir)/ginclude/va-ppc.h \\\n-    $(srcdir)/ginclude/va-c4x.h $(EXTRA_HEADERS) $(LANG_EXTRA_HEADERS) \\\n-    $(srcdir)/ginclude/proto.h $(srcdir)/ginclude/stdbool.h\n+    $(srcdir)/ginclude/varargs.h $(srcdir)/ginclude/proto.h \\\n+    $(srcdir)/ginclude/stdbool.h $(EXTRA_HEADERS) $(LANG_EXTRA_HEADERS)\n \n # Target to use whe installing assert.h.  Some systems may\n # want to set this empty."}, {"sha": "2528a712ada2c5f89646db2c835302a5733df661", "filename": "gcc/ginclude/va-alpha.h", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-alpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-alpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-alpha.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,128 +0,0 @@\n-/* GNU C varargs and stdargs support for the DEC Alpha.  */\n-\n-/* Note:  We must use the name __builtin_savregs.  GCC attaches special\n-   significance to that name.  In particular, regardless of where in a\n-   function __builtin_saveregs is called, GCC moves the call up to the\n-   very start of the function.  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-/* In VMS, __gnuc_va_list is simply char *; on OSF, it's a structure.  */\n-\n-#ifdef __VMS__\n-typedef char *__gnuc_va_list;\n-#else\n-\n-typedef struct {\n-  char *__base;\t\t\t/* Pointer to first integer register. */\n-  int __offset;\t\t\t/* Byte offset of args so far. */\n-} __gnuc_va_list;\n-#endif\n-\n-#endif /* __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-\n-#if !defined(__GNUC_VA_LIST_1) && (defined (_STDARG_H) || defined (_VARARGS_H))\n-#define __GNUC_VA_LIST_1\n-\n-#define _VA_LIST\n-#define _VA_LIST_\n-\n-typedef __gnuc_va_list va_list;\n-\n-#if !defined(_STDARG_H)\n-\n-/* varargs support */\n-#define va_alist __builtin_va_alist\n-#define va_dcl\t int __builtin_va_alist;...\n-#ifdef __VMS__\n-#define va_start(pvar) ((pvar) = __builtin_saveregs ())\n-#else\n-#define va_start(pvar) ((pvar) = * (__gnuc_va_list *) __builtin_saveregs ())\n-#endif\n-\n-#else /* STDARG.H */\n-\n-/* ANSI alternative.  */\n-\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that firstarg is correct.  */\n-\n-#ifdef __VMS__\n-#define va_start(pvar, firstarg)\t\t\t\t\\\n-  (__builtin_next_arg (firstarg),\t\t\t\t\\\n-   (pvar) = __builtin_saveregs ())\n-#else\n-#define va_start(pvar, firstarg)\t\t\t\t\\\n-  (__builtin_next_arg (firstarg),\t\t\t\t\\\n-   (pvar) = *(__gnuc_va_list *) __builtin_saveregs ())\n-#endif\n-\n-#endif /* _STDARG_H */\n-\n-#define va_end(__va)\t((void) 0)\n-\n-/* Values returned by __builtin_classify_type.  */\n-\n-enum {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-/* Note that parameters are always aligned at least to a word boundary\n-   (when passed) regardless of what GCC's __alignof__ operator says.  */\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-/* Get the size of a type in bytes, rounded up to an integral number\n-   of words.  */\n-\n-#define __va_tsize(__type)  \\\n-  (((sizeof (__type) + __extension__ sizeof (long long) - 1)   \\\n-    / __extension__ sizeof (long long)) * __extension__ sizeof (long long))\n-\n-#ifdef __VMS__\n-#define va_arg(__va, __type)\t\t\t\t\t\t\\\n-(*(((__va) += __va_tsize (__type)),\t\t\t\t\t\\\n-   (__type *)(void *)((__va) - __va_tsize (__type))))\n-\n-#else\n-\n-#define va_arg(__va, __type)\t\t\t\t\t\t\\\n-(*(((__va).__offset += __va_tsize (__type)),\t\t\t\t\\\n-   (__type *)(void *)((__va).__base + (__va).__offset\t\t\t\\\n-\t      - (((__builtin_classify_type (* (__type *) 0)\t\t\\\n-\t\t   == __real_type_class) && (__va).__offset <= (6 * 8))\t\\\n-\t\t ? (6 * 8) + 8 : __va_tsize (__type)))))\n-#endif\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* __GNUC_VA_LIST_1 */"}, {"sha": "a718ad6245d63a102dcc398c0b866a16213486ac", "filename": "gcc/ginclude/va-arc.h", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-arc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-arc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-arc.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,111 +0,0 @@\n-/* stdarg/varargs support for the ARC */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void * __gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-/* See arc_setup_incoming_varargs for reasons for the oddity in va_start.  */\n-#ifdef _STDARG_H\n-#define va_start(AP, LASTARG) \\\n-(AP = (__gnuc_va_list) ((int *) __builtin_next_arg (LASTARG) \\\n-\t\t\t+ (__builtin_args_info (0) < 8 \\\n-\t\t\t   ? (__builtin_args_info (0) & 1) \\\n-\t\t\t   : 0)))\n-#else\n-#define va_alist  __builtin_va_alist\n-#define va_dcl    int __builtin_va_alist; __va_ellipsis\n-#define va_start(AP) \\\n-(AP = (__gnuc_va_list) ((int *) &__builtin_va_alist \\\n-\t\t\t+ (__builtin_args_info (0) < 8 \\\n-\t\t\t   ? (__builtin_args_info (0) & 1) \\\n-\t\t\t   : 0)))\n-#endif\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-\n-/* Values returned by __builtin_classify_type.  */\n-\n-enum __va_type_classes {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-#endif\n-#define va_end(AP)\t((void)0)\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-/* All aggregates are passed by reference.  All scalar types larger than 8\n-   bytes are passed by reference.  */\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.\n-   The casts to char * avoid warnings about invalid pointer arithmetic.  */\n-\n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-\n-#ifdef __big_endian__\n-#define va_arg(AP,TYPE) \\\n-__extension__\t\t\t\t\t\t\t\\\n-(*({((__builtin_classify_type (*(TYPE*) 0) >= __record_type_class \\\n-      || __va_rounded_size (TYPE) > 8)\t\t\t\t\\\n-     ? ((AP) = (char *)(AP) + __va_rounded_size (TYPE *),\t\\\n-\t*(TYPE **) (void *) ((char *)(AP) - __va_rounded_size (TYPE *))) \\\n-     : ((TYPE *) (void *)\t\t\t\t\t\\\n-\t(AP = (void *) ((__alignof__ (TYPE) > 4\t\t\t\\\n-\t\t\t ? ((int) AP + 8 - 1) & -8\t\t\\\n-\t\t\t : (int) AP)\t\t\t\t\\\n-\t\t\t + __va_rounded_size (TYPE))) - 1));}))\n-#else\n-#define va_arg(AP,TYPE) \\\n-__extension__\t\t\t\t\t\t\t\\\n-(*({((__builtin_classify_type (*(TYPE*) 0) >= __record_type_class \\\n-      || __va_rounded_size (TYPE) > 8)\t\t\t\t\\\n-     ? ((AP) = (char *)(AP) + __va_rounded_size (TYPE *),\t\\\n-\t*(TYPE **) (void *) ((char *)(AP) - __va_rounded_size (TYPE *))) \\\n-     : ((AP = (void *) ((__alignof__ (TYPE) > 4\t\t\t\\\n-\t\t\t? ((int) AP + 8 - 1) & -8\t\t\\\n-\t\t\t: (int) AP)\t\t\t\t\\\n-\t\t       + __va_rounded_size (TYPE))),\t\t\\\n-\t(TYPE *) (void *) (AP - __va_rounded_size (TYPE))));}))\n-#endif\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "c73c6d592bdcff510ddc81f96db02ba3d4c0fc37", "filename": "gcc/ginclude/va-c4x.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-c4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-c4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-c4x.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,34 +0,0 @@\n-/* GNU C varargs support for the TMS320C[34]x  */\n-\n-/* C[34]x arguments grow in weird ways (downwards) that the standard\n-   varargs stuff can't handle. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef void *__gnuc_va_list;\n-\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifdef _STDARG_H /* stdarg.h support */\n-\n-#define va_start(AP,LASTARG) AP=(__gnuc_va_list) __builtin_next_arg (LASTARG)\n-\n-#else /* varargs.h support */\n-\n-#define\t__va_ellipsis\t...\n-#define\tva_alist\t__builtin_va_alist\n-#define\tva_dcl\t\tint __builtin_va_alist; __va_ellipsis\n-#define va_start(AP)\tAP=(__gnuc_va_list) ((int *)&__builtin_va_alist +  1)\n-\n-#endif /* _STDARG_H */\n-\n-#define va_end(AP)\t((void) 0)\n-#define va_arg(AP,TYPE)\t(AP = (__gnuc_va_list) ((char *) (AP) - sizeof(TYPE)), \\\n-\t\t\t *((TYPE *) ((char *) (AP))))\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "213afca93f020b212c69d5feb7d290b93bc9857b", "filename": "gcc/ginclude/va-clipper.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-clipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-clipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-clipper.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,60 +0,0 @@\n-/* GNU C varargs and stdargs support for Clipper.  */\n-\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef struct\n-{\n-  int __va_ap;\t\t\t\t/* pointer to stack args */\n-  void *__va_reg[4];\t\t\t/* pointer to r0,f0,r1,f1 */\n-  int __va_num;\t\t\t\t/* number of args processed */\n-} __gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-typedef __gnuc_va_list va_list;\n-#define __va_list __gnuc_va_list\t/* acc compatibility */\n-\n-#define _VA_LIST\n-#define _VA_LIST_\n-#define _SYS_INT_STDARG_H\t\t/* acc compatibility */\n-\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that LASTARG is correct.  */\n-#ifdef _STDARG_H\n-#define va_start(AP,LASTARG)\t\t\t\\\n-  (__builtin_next_arg (LASTARG),\t\t\\\n-   (AP) = *(va_list *)__builtin_saveregs(),\t\\\n-   (AP).__va_num = __builtin_args_info (0),\t\\\n-   (AP).__va_ap += __builtin_args_info (1))\n-#else\n-#define va_alist  __builtin_va_alist\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl    va_list __builtin_va_alist; ...\n-#define va_start(AP)\t\t\t\t\\\n-  ((AP) = *(va_list *)__builtin_saveregs(),\t\\\n-   (AP).__va_num = __builtin_args_info (0))\n-#endif /* _STDARG_H */\n-\n-/* round to alignment of `type' but keep a least integer alignment */\n-#define __va_round(AP,TYPE)\t\t\t\t\t\\\n-  ((AP).__va_ap = ((AP).__va_ap + __alignof__ (TYPE) - 1 ) &\t\\\n-   ~(__alignof__ (TYPE) - 1),\t\t\t\t\t\\\n-  ((AP).__va_ap = ((AP).__va_ap + sizeof (int) - 1) & ~(sizeof (int) - 1)))\n-\n-#define va_arg(AP, TYPE) \\\n-  (*((AP).__va_num < 2 && __builtin_classify_type (* (TYPE *)0) < 12\t\\\n-   ? (__builtin_classify_type (* (TYPE *)0) == 8\t\t\t\\\n-      ? ((TYPE *)(AP).__va_reg[2 * (AP).__va_num++ + 1])\t\t\\\n-      : ((TYPE *)(AP).__va_reg[2 * (AP).__va_num++ ]))\t\t\t\\\n-   : ((AP).__va_num++, __va_round (AP,TYPE), ((TYPE *)((AP).__va_ap))++)))\n-\n-#define va_end(AP)\t((void) 0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "9565696e9ad66a40a409560d9b933d74d8f02a37", "filename": "gcc/ginclude/va-h8300.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-h8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-h8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-h8300.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,56 +0,0 @@\n-/* stdarg/vararg support for the Hitachi h8/300 and h8/300h */\n-\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void *__gnuc_va_list;\n-#endif\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-#ifdef __H8300__\n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#else\n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (long) - 1) / sizeof (long)) * sizeof (long))\n-#endif\n-\n-#ifdef _STDARG_H\n-\n-#define va_start(AP,LASTARG) \\\n-  (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n-\n-#else /* _VARARGS_H */\n-\n-#define va_alist  __builtin_va_alist\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl    int __builtin_va_alist; __va_ellipsis\n-#define va_start(AP)  AP = (void *) &__builtin_va_alist\n-\n-#endif /* _VARARGS_H */\n-\n-#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n- (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n-  *((TYPE *) (void *) ((char *) (AP)\t\t\t\t\t\\\n-\t\t       - ((sizeof (TYPE) < __va_rounded_size (int)\t\\\n-\t\t\t  ? sizeof (TYPE) : __va_rounded_size (TYPE))))))\n-\n-#define va_end(AP)\t((void) 0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "56d2c7fe1d3b7b2452cf56a40ab2f81b2c92b6a0", "filename": "gcc/ginclude/va-i860.h", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-i860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-i860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-i860.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,214 +0,0 @@\n-/* Note:  We must use the name __builtin_savregs.  GCC attaches special\n-   significance to that name.  In particular, regardless of where in a\n-   function __builtin_saveregs is called, GCC moves the call up to the\n-   very start of the function.  */\n-\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef union {\n-  float\t\t__freg[8];\n-  double\t__dreg[4];\n-} __f_regs;\n-\n-typedef struct {\n-#if defined (__SVR4__) || defined (__svr4__) || defined (__alliant__) || defined (__PARAGON__)\n-  __f_regs __float_regs; long __ireg[12];\n-#else /* pre-SVR4 */\n-  long __ireg[12]; __f_regs __float_regs;\n-#endif\n-} __va_saved_regs;\n-\n-typedef struct {\n-#if defined(__SVR4__) || defined(__svr4__) || defined(__alliant__) || defined (__PARAGON__)\n-  unsigned\t__ireg_used;\t/* How many int regs consumed 'til now? */\n-  unsigned\t__freg_used;\t/* How many flt regs consumed 'til now? */\n-  long\t\t*__reg_base;\t/* Address of where we stored the regs. */\n-  long *\t__mem_ptr;\t/* Address of memory overflow args area. */\n-#else /* pre-SVR4 */\n-  long\t\t*__reg_base;\t/* Address of where we stored the regs. */\n-  long *\t__mem_ptr;\t/* Address of memory overflow args area. */\n-  unsigned\t__ireg_used;\t/* How many int regs consumed 'til now? */\n-  unsigned\t__freg_used;\t/* How many flt regs consumed 'til now? */\n-#endif\n-} __gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#if !defined(_STDARG_H)\n-\n-/* varargs support */\n-#define va_alist __builtin_va_alist\n-#if defined (__PARAGON__)\n-#define va_dcl int va_alist;\n-#else\t/* __PARAGON__ */\n-#define va_dcl\n-#endif\t/* __PARAGON__ */\n-#define va_start(pvar) ((pvar) = * (__gnuc_va_list *) __builtin_saveregs ())\n-\n-#else /* STDARG.H */\n-\n-/* ANSI alternative.  */\n-/* Note that CUMULATIVE_ARGS elements are measured in bytes on the i860,\n-   so we divide by 4 to get # of registers.  */\n-#define va_start(pvar, firstarg) \\\n- ((pvar) = *(__gnuc_va_list *) __builtin_saveregs (),\t\t\t\\\n-  (pvar).__ireg_used = __builtin_args_info (0) / 4,\t\t\\\n-  (pvar).__freg_used = __builtin_args_info (1) / 4,\t\t\\\n-  (pvar).__mem_ptr = __builtin_next_arg (firstarg))\n-\n-#endif /* _STDARG_H */\n-\n-/* Values returned by __builtin_classify_type.  */\n-\n-#ifndef va_end\n-enum {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#endif\n-#define va_end(__va)\t((void) 0)\n-\n-#define __NUM_PARM_FREGS\t8\n-#define __NUM_PARM_IREGS\t12\n-\n-#define __savereg(__va) ((__va_saved_regs *) ((__va).__reg_base))\n-\n-/* This macro works both for SVR4 and pre-SVR4 environments.  */\n-\n-/* Note that parameters are always aligned at least to a word boundary\n-   (when passed) regardless of what GCC's __alignof__ operator says.  */\n-\n-/* Make allowances here for adding 128-bit (long double) floats someday.  */\n-\n-#if 0 /* What was this for? */\n-#ifndef __GNU_VA_LIST\n-#define __ireg_used ireg_used\n-#define __freg_used freg_used\n-#define __mem_ptr mem_ptr\n-#define __reg_base reg_base\n-#endif\n-#endif /* 0 */\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-#define va_arg(__va, __type)\t\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-(* (__type *)\t\t\t\t\t\t\t\t\\\n-({\t\t\t\t\t\t\t\t\t\\\n-  register void *__rv;  /* result value */\t\t\t\t\\\n-  register unsigned __align;\t\t\t\t\t\t\\\n-  switch (__builtin_classify_type (* (__type *) 0))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case __real_type_class:\t\t\t\t\t\t\\\n-      switch (sizeof (__type))\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  case sizeof (float):\t\t\t\t\t\t\\\n-\t  case sizeof (double):\t\t\t\t\t\t\\\n-\t    if ((__va).__freg_used < __NUM_PARM_FREGS - 1)\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t        if (((__va).__freg_used & 1) != 0)\t\t\t\\\n-\t          (__va).__freg_used++;\t/* skip odd */\t\t\t\\\n-\t        __rv = &__savereg((__va))->__float_regs.__freg[(__va).__freg_used];\\\n-\t\t(__va).__freg_used += 2;\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t        if ((((unsigned) (__va).__mem_ptr) & (sizeof(double)-1)) != 0) \\\n-\t          (__va).__mem_ptr++;\t/* skip odd */\t\t\t\\\n-\t        __rv = (__va).__mem_ptr;\t\t\t\t\\\n-\t        (__va).__mem_ptr += 2;\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    if (sizeof (__type) == sizeof (float))\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t        *((float *) __rv) = *((double *) __rv);\t\t\t\\\n-\t\t*(((long *) __rv) + 1) = 0xfff00001;\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t  default:\t\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case __void_type_class:\t\t\t\t\t\t\\\n-    case __integer_type_class:\t\t\t\t\t\t\\\n-    case __char_type_class:\t\t\t\t\t\t\\\n-    case __enumeral_type_class:\t\t\t\t\t\t\\\n-    case __boolean_type_class:\t\t\t\t\t\t\\\n-    case __pointer_type_class:\t\t\t\t\t\t\\\n-    case __reference_type_class:\t\t\t\t\t\\\n-    case __offset_type_class:\t\t\t\t\t\t\\\n-      if (sizeof (__type) <= 4)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-          __rv = ((__va).__ireg_used < __NUM_PARM_IREGS\t\t\t\\\n-\t          ? (&__savereg((__va))->__ireg[(__va).__ireg_used++])\t\\\n-\t          : (__va).__mem_ptr++);\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if ((__va).__ireg_used + sizeof (__type) / 4 <= __NUM_PARM_IREGS) \\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  __rv = &__savereg((__va))->__ireg[(__va).__ireg_used];\t\\\n-\t  (__va).__ireg_used += sizeof (__type) / 4;\t\t\t\\\n-          break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      /* Fall through to fetch from memory.  */\t\t\t\t\\\n-    case __record_type_class:\t\t\t\t\t\t\\\n-    case __union_type_class:\t\t\t\t\t\t\\\n-      __align = (__alignof__ (__type) < sizeof (long)\t\t\t\\\n-\t\t ? sizeof (long)\t\t\t\t\t\\\n-\t\t : __alignof__ (__type));\t\t\t\t\\\n-      (__va).__mem_ptr\t\t\t\t\t\t\t\\\n-\t= (long *)\t\t\t\t\t\t\t\\\n-\t  ((((unsigned) (__va).__mem_ptr) + (__align-1)) & ~(__align-1)); \\\n-      __rv = (__va).__mem_ptr;\t\t\t\t\t\t\\\n-      (__va).__mem_ptr\t\t\t\t\t\t\t\\\n-\t+= ((sizeof (__type) + sizeof (long) - 1) / sizeof (long));\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case __complex_type_class:\t\t\t\t\t\t\\\n-    case __function_type_class:\t\t\t\t\t\t\\\n-    case __method_type_class:\t\t\t\t\t\t\\\n-    case __array_type_class:\t\t\t\t\t\t\\\n-    case __string_type_class:\t\t\t\t\t\t\\\n-    case __set_type_class:\t\t\t\t\t\t\\\n-    case __file_type_class:\t\t\t\t\t\t\\\n-    case __lang_type_class:\t\t\t\t\t\t\\\n-    case __no_type_class:\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  __rv;\t\t\t\t\t\t\t\t\t\\\n-}))\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-"}, {"sha": "5588d411291789c165e45556abb7586bee5d3656", "filename": "gcc/ginclude/va-i960.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-i960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-i960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-i960.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,79 +0,0 @@\n-/* GNU C varargs support for the Intel 80960.  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-/* The first element is the address of the first argument.\n-   The second element is the number of bytes skipped past so far.  */\n-typedef unsigned __gnuc_va_list[2];\t\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-/* The stack size of the type t.  */\n-#define __vsiz(T)   (((sizeof (T) + 3) / 4) * 4)\n-/* The stack alignment of the type t.  */\n-#define __vali(T)   (__alignof__ (T) >= 4 ? __alignof__ (T) : 4)\n-/* The offset of the next stack argument after one of type t at offset i.  */\n-#define __vpad(I, T) ((((I) + __vali (T) - 1) / __vali (T)) \\\n-\t\t       * __vali (T) + __vsiz (T))\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-#ifdef _STDARG_H\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that firstarg is correct.  */\n-#define va_start(AP, LASTARG)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\\\n-({ __builtin_next_arg (LASTARG);\t\t\t\\\n-   __asm__ (\"st\tg14,%0\" : \"=m\" (*(AP)));\t\t\\\n-   (AP)[1] = (__builtin_args_info (0) + __builtin_args_info (1)) * 4; })\n-\n-#else\n-\n-#define\tva_alist __builtin_va_alist\n-#define\tva_dcl\t char *__builtin_va_alist; __va_ellipsis\n-#define\tva_start(AP) \\\n-__extension__\t\t\t\t\t\t\\\n-({ __asm__ (\"st\tg14,%0\" : \"=m\" (*(AP)));\t\t\\\n-   (AP)[1] = (__builtin_args_info (0) + __builtin_args_info (1)) * 4; })\n-#endif\n-\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-#define\tva_arg(AP, T)\t\t\t\t\t\t\t\\\n-(\t\t\t\t\t\t\t\t\t\\\n-  (\t\t\t\t\t\t\t\t\t\\\n-    ((AP)[1] <= 48 && (__vpad ((AP)[1], T) > 48 || __vsiz (T) > 16))\t\\\n-      ? ((AP)[1] = 48 + __vsiz (T))\t\t\t\t\t\\\n-      : ((AP)[1] = __vpad ((AP)[1], T))\t\t\t\t\t\\\n-  ),\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  *((T *) (void *) ((char *) *(AP) + (AP)[1] - __vsiz (T)))\t\t\\\n-)\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#endif\n-#define\tva_end(AP)\t((void) 0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-"}, {"sha": "4ef0ad8267a8e382a0f66fc21cc2b8b3bae2cbec", "filename": "gcc/ginclude/va-m32r.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-m32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-m32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-m32r.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,86 +0,0 @@\n-/* GNU C stdarg/varargs support for the M32R */\n-\n-/* Define __gnuc_va_list.  */\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* Common code for va_start for both varargs and stdarg.  */\n-\n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-\n-#ifdef _STDARG_H /* stdarg.h support */\n-\n-/* Calling __builtin_next_arg gives the proper error message if LASTARG is\n-   not indeed the last argument.  */\n-#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n- (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n-\n-#else /* varargs.h support */\n-\n-#define va_alist  __builtin_va_alist\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl    int __builtin_va_alist; ...\n-#define va_start(AP)  AP=(char *) &__builtin_va_alist\n-\n-#endif /* _STDARG_H */\n-\n-/* Nothing needs to be done to end varargs/stdarg processing */\n-#define va_end(AP) ((void) 0)\n-\n-/* Values returned by __builtin_classify_type.  */\n-enum __type_class\n-{\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-/* Return whether a type is passed by reference.  */\n-#define __va_by_reference_p(TYPE) (sizeof (TYPE) > 8)\n-\n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\t\\\n-__extension__ (*({\t\t\t\t\t\t\t\\\n-  register TYPE *__ptr;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (__va_by_reference_p (TYPE))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = *(TYPE **)(void *) (AP);\t\t\t\t\t\\\n-      (AP) = (__gnuc_va_list) ((char *) (AP) + sizeof (void *));\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = (TYPE *)(void *)\t\t\t\t\t\t\\\n-        ((char *) (AP) + (sizeof (TYPE) < __va_rounded_size (char)\t\\\n-\t\t\t  ? __va_rounded_size (TYPE) - sizeof (TYPE)\t\\\n-\t\t\t  : 0));\t\t\t\t\t\\\n-      (AP) = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)); \\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  __ptr;\t\t\t\t\t\t\t\t\\\n-}))\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "0a20d84501ce7926ac239b4bb801516b03a211a6", "filename": "gcc/ginclude/va-m88k.h", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-m88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-m88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-m88k.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,87 +0,0 @@\n-/* GNU C varargs support for the Motorola 88100  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef struct\n-{\n-  int  __va_arg;\t\t/* argument number */\n-  int *__va_stk;\t\t/* start of args passed on stack */\n-  int *__va_reg;\t\t/* start of args passed in regs */\n-} __gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifdef _STDARG_H /* stdarg.h support */\n-\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that LASTARG is correct.  */\n-#if __GNUC__ > 1 /* GCC 2.0 and beyond */\n-#define va_start(AP,LASTARG)\t\t\t\t\\\n- (__builtin_next_arg (LASTARG),\t\t\t\t\\\n-  (AP) = *(__gnuc_va_list *)__builtin_saveregs())\n-#else\n-#define va_start(AP,LASTARG) \\\n-  ( (AP).__va_reg = (int *) __builtin_saveregs2(0), \\\n-    (AP).__va_stk = (int *) __builtin_argptr(), \\\n-    (AP).__va_arg = (int) (__builtin_argsize() + 3) / 4 )\n-#endif\n-\n-#else /* varargs.h support */\n-\n-#if __GNUC__ > 1 /* GCC 2.0 and beyond */\n-#define va_start(AP) ((AP) = *(__gnuc_va_list *)__builtin_saveregs())\n-#else\n-#define va_start(AP) \\\n-  ( (AP).__va_reg = (int *) __builtin_saveregs2(1), \\\n-    (AP).__va_stk = (int *) __builtin_argptr(), \\\n-    (AP).__va_arg = (int) (__builtin_argsize() - 4 + 3) / 4 )\n-#endif\n-#define va_alist __va_1st_arg\n-#define va_dcl register int va_alist;...\n-\n-#endif /* _STDARG_H */\n-\n-/* Avoid trouble between this file and _int_varargs.h under DG/UX.  This file\n-   can be included by <stdio.h> and others and provides definitions of\n-   __va_size and __va_reg_p and  a va_list typedef.  Avoid defining va_list\n-   again with _VA_LIST.  */\n-#ifdef __INT_VARARGS_H\n-#undef __va_size\n-#undef __va_reg_p\n-#define __gnuc_va_list va_list\n-#define _VA_LIST\n-#define _VA_LIST_\n-#else\n-/* Similarly, if this gets included first, do nothing in _int_varargs.h.  */\n-#define __INT_VARARGS_H\n-#endif\n-\n-#define __va_reg_p(TYPE) \\\n-  (__builtin_classify_type(*(TYPE *)0) < 12 \\\n-   ? sizeof(TYPE) <= 8 : sizeof(TYPE) == 4 && __alignof__(TYPE) == 4)\n-\n-#define\t__va_size(TYPE) ((sizeof(TYPE) + 3) >> 2)\n-\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\t   \\\n-  ( (AP).__va_arg = (((AP).__va_arg + (1 << (__alignof__(TYPE) >> 3)) - 1) \\\n-\t\t     & ~((1 << (__alignof__(TYPE) >> 3)) - 1))\t\t   \\\n-    + __va_size(TYPE),\t\t\t\t\t\t\t   \\\n-    *((TYPE *) (void *) ((__va_reg_p(TYPE)\t\t\t\t   \\\n-\t\t\t  && (AP).__va_arg < 8 + __va_size(TYPE)\t   \\\n-\t\t\t  ? (AP).__va_reg : (AP).__va_stk)\t\t   \\\n-\t\t\t + ((AP).__va_arg - __va_size(TYPE)))))\n-\n-#define va_end(AP)\t((void)0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "96db5b466cc346385eaad655fce8ee00a150bf7e", "filename": "gcc/ginclude/va-mips.h", "status": "removed", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mips.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,277 +0,0 @@\n-/* ---------------------------------------- */\n-/*           VARARGS  for MIPS/GNU CC       */\n-/*                                          */\n-/*                                          */\n-/*                                          */\n-/*                                          */\n-/* ---------------------------------------- */\n-\n-\n-/* These macros implement varargs for GNU C--either traditional or ANSI.  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-#if defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)\n-\n-typedef struct {\n-  /* Pointer to FP regs.  */\n-  char *__fp_regs;\n-  /* Number of FP regs remaining.  */\n-  int __fp_left;\n-  /* Pointer to GP regs followed by stack parameters.  */\n-  char *__gp_regs;\n-} __gnuc_va_list;\n-\n-#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-\n-typedef char * __gnuc_va_list;\n-\n-#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifndef _VA_MIPS_H_ENUM\n-#define _VA_MIPS_H_ENUM\n-enum {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-#endif\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-#ifdef __mips64\n-#define __va_rounded_size(__TYPE)  \\\n-  (((sizeof (__TYPE) + 8 - 1) / 8) * 8)\n-#else\n-#define __va_rounded_size(__TYPE)  \\\n-  (((sizeof (__TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#endif\n-\n-#ifdef __mips64\n-#define __va_reg_size 8\n-#else\n-#define __va_reg_size 4\n-#endif\n-\n-/* Get definitions for _MIPS_SIM_ABI64 etc.  */\n-#ifdef _MIPS_SIM\n-#include <sgidefs.h>\n-#endif\n-\n-#ifdef _STDARG_H\n-#if defined (__mips_eabi)\n-#if ! defined (__mips_soft_float) && ! defined (__mips_single_float)\n-#ifdef __mips64\n-#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: 0)),\t\t\t\t\t\t\\\n-   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n-#else /* ! defined (__mips64) */\n-#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: 0)),\t\t\t\t\t\t\\\n-   __AP.__fp_left = (8 - __builtin_args_info (3)) / 2,\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * 8,\t\t\\\n-   __AP.__fp_regs = (char *) ((int) __AP.__fp_regs & -8))\n-#endif /* ! defined (__mips64) */\n-#else /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float) ) */\n-#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n-  (__AP = ((__gnuc_va_list) __builtin_next_arg (__LASTARG)\t\t\\\n-\t   - (__builtin_args_info (2) >= 8 ? 0\t\t\t\t\\\n-\t      : (8 - __builtin_args_info (2)) * __va_reg_size)))\n-#endif /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float) ) */\n-#else /* ! defined (__mips_eabi) */\n-#define va_start(__AP, __LASTARG) \\\n-  (__AP = (__gnuc_va_list) __builtin_next_arg (__LASTARG))\n-#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-#else /* ! _STDARG_H */\n-#define va_alist  __builtin_va_alist\n-#ifdef __mips64\n-/* This assumes that `long long int' is always a 64 bit type.  */\n-#define va_dcl    long long int __builtin_va_alist; __va_ellipsis\n-#else\n-#define va_dcl    int __builtin_va_alist; __va_ellipsis\n-#endif\n-#if defined (__mips_eabi)\n-#if ! defined (__mips_soft_float) && ! defined (__mips_single_float)\n-#ifdef __mips64\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg ()\t\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: __va_reg_size)),\t\t\t\t\\\n-   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n-#else /* ! defined (__mips64) */\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg ()\t\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: __va_reg_size)),\t\t\t\t\\\n-   __AP.__fp_left = (8 - __builtin_args_info (3)) / 2,\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * 8,\t\t\\\n-   __AP.__fp_regs = (char *) ((int) __AP.__fp_regs & -8))\n-#endif /* ! defined (__mips64) */\n-#else /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP = ((__gnuc_va_list) __builtin_next_arg ()\t\t\t\\\n-\t   - (__builtin_args_info (2) >= 8 ? __va_reg_size\t\t\\\n-\t      : (8 - __builtin_args_info (2)) * __va_reg_size)))\n-#endif /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-/* Need alternate code for _MIPS_SIM_ABI64.  */\n-#elif defined(_MIPS_SIM) && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP = (__gnuc_va_list) __builtin_next_arg ()\t\t\t\\\n-   + (__builtin_args_info (2) >= 8 ? -8 : 0))\n-#else\n-#define va_start(__AP)  __AP = (char *) &__builtin_va_alist\n-#endif\n-#endif /* ! _STDARG_H */\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#endif\n-#define va_end(__AP)\t((void)0)\n-\n-#if defined (__mips_eabi)\n-\n-#if ! defined (__mips_soft_float) && ! defined (__mips_single_float)\n-#ifdef __mips64\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n-    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n-   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n-   : (__AP.__gp_regs += __va_reg_size) - __va_reg_size)\n-#else\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n-    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n-   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n-   : (((__builtin_classify_type (* (__type *) 0) < __record_type_class\t\\\n-\t&& __alignof__ (__type) > 4)\t\t\t\t\t\\\n-       ? __AP.__gp_regs = (char *) (((int) __AP.__gp_regs + 8 - 1) & -8) \\\n-       : (char *) 0),\t\t\t\t\t\t\t\\\n-      (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n-       ? (__AP.__gp_regs += __va_reg_size) - __va_reg_size\t\t\\\n-       : ((__AP.__gp_regs += __va_rounded_size (__type))\t\t\\\n-\t  - __va_rounded_size (__type)))))\n-#endif\n-#else /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-#ifdef __mips64\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  ((__AP += __va_reg_size) - __va_reg_size)\n-#else\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  (((__builtin_classify_type (* (__type *) 0) < __record_type_class\t\\\n-     && __alignof__ (__type) > 4)\t\t\t\t\t\\\n-    ? __AP = (char *) (((__PTRDIFF_TYPE__) __AP + 8 - 1) & -8)\t\t\\\n-    : (char *) 0),\t\t\t\t\t\t\t\\\n-   (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n-    ? (__AP += __va_reg_size) - __va_reg_size\t\t\t\t\\\n-    : ((__AP += __va_rounded_size (__type))\t\t\t\t\\\n-       - __va_rounded_size (__type))))\n-#endif\n-#endif /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */\n-\n-#ifdef __MIPSEB__\n-#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n-  ((__va_rounded_size (__type) <= __va_reg_size)\t\t\t\\\n-   ? *(__type *) (void *) (__va_next_addr (__AP, __type)\t\t\\\n-\t\t\t   + __va_reg_size\t\t\t\t\\\n-\t\t\t   - sizeof (__type))\t\t\t\t\\\n-   : (__builtin_classify_type (*(__type *) 0) >= __record_type_class\t\\\n-      ? **(__type **) (void *) (__va_next_addr (__AP, __type)\t\t\\\n-\t\t\t\t+ __va_reg_size\t\t\t\t\\\n-\t\t\t\t- sizeof (char *))\t\t\t\\\n-      : *(__type *) (void *) __va_next_addr (__AP, __type)))\n-#else\n-#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n-  ((__va_rounded_size (__type) <= __va_reg_size)\t\t\t\\\n-   ? *(__type *) (void *) __va_next_addr (__AP, __type)\t\t\\\n-   : (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n-      ? **(__type **) (void *) __va_next_addr (__AP, __type)\t\t\\\n-      : *(__type *) (void *) __va_next_addr (__AP, __type)))\n-#endif\n-\n-#else /* ! defined (__mips_eabi) */\n-\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-/* The __mips64 cases are reversed from the 32 bit cases, because the standard\n-   32 bit calling convention left-aligns all parameters smaller than a word,\n-   whereas the __mips64 calling convention does not (and hence they are\n-   right aligned).  */\n-#ifdef __mips64\n-#ifdef __MIPSEB__\n-#define va_arg(__AP, __type)                                    \\\n-  ((__type *) (void *) (__AP = (char *)                         \\\n-                       ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8) \\\n-\t\t\t   + __va_rounded_size (__type))))[-1]\n-#else\n-#define va_arg(__AP, __type)                                    \\\n-  ((__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8)\t\\\n-\t\t     + __va_rounded_size (__type))),\t\t\\\n-   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n-#endif\n-\n-#else /* not __mips64 */\n-\n-#ifdef __MIPSEB__\n-/* For big-endian machines.  */\n-#define va_arg(__AP, __type)\t\t\t\t\t\\\n-  ((__AP = (char *) ((__alignof__ (__type) > 4\t\t\t\\\n-\t\t      ? ((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8\t\\\n-\t\t      : ((__PTRDIFF_TYPE__)__AP + 4 - 1) & -4)\t\\\n-\t\t     + __va_rounded_size (__type))),\t\t\\\n-   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n-#else\n-/* For little-endian machines.  */\n-#define va_arg(__AP, __type)\t\t\t\t\t\t    \\\n-  ((__type *) (void *) (__AP = (char *) ((__alignof__(__type) > 4\t    \\\n-\t\t\t\t? ((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8\t    \\\n-\t\t\t\t: ((__PTRDIFF_TYPE__)__AP + 4 - 1) & -4)    \\\n-\t\t\t\t\t + __va_rounded_size(__type))))[-1]\n-#endif\n-#endif\n-#endif /* ! defined (__mips_eabi)  */\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "5069a5907ed63e47e1ac1df4a2a720591da9c0c7", "filename": "gcc/ginclude/va-mn10200.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mn10200.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,34 +0,0 @@\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-#define __va_ellipsis ...\n-\n-#ifdef _STDARG_H\n-#define va_start(AP, LASTARG) \\\n- (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n-#else\n-#define va_alist __builtin_va_alist\n-#define va_dcl int __builtin_va_alist; __va_ellipsis\n-#define va_start(AP)  AP=(char *) &__builtin_va_alist\n-#endif\n-\n-/* Now stuff common to both varargs & stdarg implementations.  */\n-#define __va_rounded_size(TYPE)\t\t\t\t\t\t\\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#undef va_end\n-void va_end (__gnuc_va_list);\n-#define va_end(AP) ((void)0)\n-#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n- (sizeof (TYPE) > 8\t\t\t\t\t\t\t\\\n-  ? (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (char *)),\\\n-    **((TYPE **) (void *) ((char *) (AP) - __va_rounded_size (char *))))\\\n-  : (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n-    *((TYPE *) (void *) ((char *) (AP) - __va_rounded_size (TYPE)))))\n-#endif"}, {"sha": "e156ccf5939b02c008612e106ace49a91cc77101", "filename": "gcc/ginclude/va-mn10300.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-mn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mn10300.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,35 +0,0 @@\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-#define __gnuc_va_start(AP) (AP = (__gnuc_va_list)__builtin_saveregs())\n-#define __va_ellipsis ...\n-\n-#ifdef _STDARG_H\n-#define va_start(AP, LASTARG) \\\n-  (__builtin_next_arg (LASTARG), __gnuc_va_start (AP))\n-#else\n-#define va_alist __builtin_va_alist\n-#define va_dcl int __builtin_va_alist; __va_ellipsis\n-#define va_start(AP)  AP=(char *) &__builtin_va_alist\n-#endif\n-\n-/* Now stuff common to both varargs & stdarg implementations.  */\n-#define __va_rounded_size(TYPE)\t\t\t\t\t\t\\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#undef va_end\n-void va_end (__gnuc_va_list);\n-#define va_end(AP) ((void)0)\n-#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n- (sizeof (TYPE) > 8\t\t\t\t\t\t\t\\\n-  ? (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (char *)),\\\n-    **((TYPE **) (void *) ((char *) (AP) - __va_rounded_size (char *))))\\\n-  : (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n-    *((TYPE *) (void *) ((char *) (AP) - __va_rounded_size (TYPE)))))\n-#endif"}, {"sha": "4865f6bfac08f4a29575aa2b57d901c2ad40a4f3", "filename": "gcc/ginclude/va-pa.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-pa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-pa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-pa.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,52 +0,0 @@\n-\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef void *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#define __gnuc_va_start(AP) ((AP) = (va_list)__builtin_saveregs())\n-#else\n-#define va_alist __va_a__, __va_b__, __va_c__, __va_d__\n-#define __va_ellipsis \n-#define __gnuc_va_start(AP)\\\n-  (AP) = (double *) &__va_a__, &__va_b__, &__va_c__, &__va_d__, \\\n-  (AP) = (double *)((char *)(AP) + 4)\n-#endif /* __GNUC__ > 1 */\n-\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that LASTARG is correct.  */\n-#ifdef _STDARG_H\n-#define va_start(AP,LASTARG) \\\n-  (__builtin_next_arg (LASTARG), __gnuc_va_start (AP))\n-#else\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl long va_alist; __va_ellipsis\n-#define va_start(AP) __gnuc_va_start (AP)\n-#endif\n-\n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\\\n-  (*(sizeof(TYPE) > 8 ?\t\t\t\t\t\t\\\n-   ((AP = (__gnuc_va_list) ((char *)AP - sizeof (int))),\t\\\n-    (((TYPE *) (void *) (*((int *) (AP))))))\t\t\t\\\n-   :((AP =\t\t\t\t\t\t\t\\\n-      (__gnuc_va_list) ((long)((char *)AP - sizeof (TYPE))\t\\\n-\t\t\t& (sizeof(TYPE) > 4 ? ~0x7 : ~0x3))),\t\\\n-     (((TYPE *) (void *) ((char *)AP + ((8 - sizeof(TYPE)) % 4)))))))\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#endif\n-#define va_end(AP)\t((void)0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "0c79d5fe20626a1b3802986cb527c07e17b922fa", "filename": "gcc/ginclude/va-ppc.h", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-ppc.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,252 +0,0 @@\n-/* GNU C varargs support for the PowerPC with either the V.4 or Windows NT calling sequences */\n-\n-#ifndef _WIN32\n-/* System V.4 support */\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-#ifndef _SYS_VA_LIST_H\n-#define _SYS_VA_LIST_H\t\t/* Solaris sys/va_list.h */\n-\n-/* Solaris decided to rename overflow_arg_area to input_arg_area,\n-   so handle it via a macro.  */\n-#define __va_overflow(AP) (AP)->overflow_arg_area\n-\n-/* Note that the names in this structure are in the user's namespace, but\n-   that the V.4 abi explicitly states that these names should be used.  */\n-typedef struct __va_list_tag {\n-  unsigned char gpr;\t\t/* index into the array of 8 GPRs stored in the\n-\t\t\t\t   register save area gpr=0 corresponds to r3,\n-\t\t\t\t   gpr=1 to r4, etc. */\n-  unsigned char fpr;\t\t/* index into the array of 8 FPRs stored in the\n-\t\t\t\t   register save area fpr=0 corresponds to f1,\n-\t\t\t\t   fpr=1 to f2, etc. */\n-  char *overflow_arg_area;\t/* location on stack that holds the next\n-\t\t\t\t   overflow argument */\n-  char *reg_save_area;\t\t/* where r3:r10 and f1:f8, if saved are stored */\n-} __va_list[1], __gnuc_va_list[1];\n-\n-#else /* _SYS_VA_LIST */\n-\n-typedef __va_list __gnuc_va_list;\n-#define __va_overflow(AP) (AP)->input_arg_area\n-\n-#endif /* not _SYS_VA_LIST */\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* Register save area located below the frame pointer */\n-#ifndef __VA_PPC_H__\n-#define __VA_PPC_H__\n-typedef struct {\n-  long   __gp_save[8];\t\t/* save area for GP registers */\n-  double __fp_save[8];\t\t/* save area for FP registers */\n-} __va_regsave_t;\n-\n-/* Macros to access the register save area */\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-#define __VA_FP_REGSAVE(AP,OFS,TYPE)\t\t\t\t\t\\\n-  ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n-\t\t\t (AP)->reg_save_area)->__fp_save[OFS])))\n-\n-#define __VA_GP_REGSAVE(AP,OFS,TYPE)\t\t\t\t\t\\\n-  ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n-\t\t\t (AP)->reg_save_area)->__gp_save[OFS])))\n-\n-/* Common code for va_start for both varargs and stdarg.  We allow all\n-   the work to be done by __builtin_saveregs.  It returns a pointer to\n-   a va_list that was constructed on the stack; we must simply copy it\n-   to the user's variable.  */\n-\n-#define __va_start_common(AP, FAKE) \\\n-  __builtin_memcpy ((AP), __builtin_saveregs (), sizeof(__gnuc_va_list))\n-\n-#ifdef _STDARG_H /* stdarg.h support */\n-\n-/* Calling __builtin_next_arg gives the proper error message if LASTARG is\n-   not indeed the last argument.  */\n-#define va_start(AP,LASTARG) \\\n-  (__builtin_next_arg (LASTARG), __va_start_common (AP, 0))\n-\n-#else /* varargs.h support */\n-\n-#define va_start(AP) __va_start_common (AP, 1)\n-#define va_alist __va_1st_arg\n-#define va_dcl register int va_alist; ...\n-\n-#endif /* _STDARG_H */\n-\n-#ifdef _SOFT_FLOAT\n-#define __va_float_p(TYPE)\t0\n-#else\n-#define __va_float_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) == 8)\n-#endif\n-\n-#define __va_aggregate_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) >= 12)\n-#define __va_size(TYPE)\t\t((sizeof(TYPE) + sizeof (long) - 1) / sizeof (long))\n-\n-/* This symbol isn't defined.  It is used to flag type promotion violations\n-   at link time.  We can only do this when optimizing.  Use __builtin_trap\n-   instead of abort so that we don't require a prototype for abort.  */\n-\n-#ifdef __OPTIMIZE__\n-extern void __va_arg_type_violation(void) __attribute__((__noreturn__));\n-#else\n-#define __va_arg_type_violation() __builtin_trap()\n-#endif\n-\n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\t   \\\n-__extension__ (*({\t\t\t\t\t\t\t   \\\n-  register TYPE *__ptr;\t\t\t\t\t\t\t   \\\n-\t\t\t\t\t\t\t\t\t   \\\n-  if (__va_float_p (TYPE) && sizeof (TYPE) < 16)\t\t\t   \\\n-    {\t\t\t\t\t\t\t\t\t   \\\n-      unsigned char __fpr = (AP)->fpr;\t\t\t\t\t   \\\n-      if (__fpr < 8)\t\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  __ptr = __VA_FP_REGSAVE (AP, __fpr, TYPE);\t\t\t   \\\n-\t  (AP)->fpr = __fpr + 1;\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      else if (sizeof (TYPE) == 8)\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  unsigned long __addr = (unsigned long) (__va_overflow (AP));\t   \\\n-\t  __ptr = (TYPE *)((__addr + 7) & -8);\t\t\t\t   \\\n-\t  __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      else\t\t\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  /* float is promoted to double.  */\t\t\t\t   \\\n-\t  __va_arg_type_violation ();\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-    }\t\t\t\t\t\t\t\t\t   \\\n-\t\t\t\t\t\t\t\t\t   \\\n-  /* Aggregates and long doubles are passed by reference.  */\t\t   \\\n-  else if (__va_aggregate_p (TYPE) || __va_float_p (TYPE))\t\t   \\\n-    {\t\t\t\t\t\t\t\t\t   \\\n-      unsigned char __gpr = (AP)->gpr;\t\t\t\t\t   \\\n-      if (__gpr < 8)\t\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  __ptr = * __VA_GP_REGSAVE (AP, __gpr, TYPE *);\t\t   \\\n-\t  (AP)->gpr = __gpr + 1;\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      else\t\t\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  TYPE **__pptr = (TYPE **) (__va_overflow (AP));\t\t   \\\n-\t  __ptr = * __pptr;\t\t\t\t\t\t   \\\n-\t  __va_overflow (AP) = (char *) (__pptr + 1);\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-    }\t\t\t\t\t\t\t\t\t   \\\n-\t\t\t\t\t\t\t\t\t   \\\n-  /* Only integrals remaining.  */\t\t\t\t\t   \\\n-  else\t\t\t\t\t\t\t\t\t   \\\n-    {\t\t\t\t\t\t\t\t\t   \\\n-      /* longlong is aligned.  */\t\t\t\t\t   \\\n-      if (sizeof (TYPE) == 8)\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  unsigned char __gpr = (AP)->gpr;\t\t\t\t   \\\n-\t  if (__gpr < 7)\t\t\t\t\t\t   \\\n-\t    {\t\t\t\t\t\t\t\t   \\\n-\t      __gpr += __gpr & 1;\t\t\t\t\t   \\\n-\t      __ptr = __VA_GP_REGSAVE (AP, __gpr, TYPE);\t\t   \\\n-\t      (AP)->gpr = __gpr + 2;\t\t\t\t\t   \\\n-\t    }\t\t\t\t\t\t\t\t   \\\n-\t  else\t\t\t\t\t\t\t\t   \\\n-\t    {\t\t\t\t\t\t\t\t   \\\n-\t      unsigned long __addr = (unsigned long) (__va_overflow (AP)); \\\n-\t      __ptr = (TYPE *)((__addr + 7) & -8);\t\t\t   \\\n-\t      (AP)->gpr = 8;\t\t\t\t\t\t   \\\n-\t      __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n-\t    }\t\t\t\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      else if (sizeof (TYPE) == 4)\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  unsigned char __gpr = (AP)->gpr;\t\t\t\t   \\\n-\t  if (__gpr < 8)\t\t\t\t\t\t   \\\n-\t    {\t\t\t\t\t\t\t\t   \\\n-\t      __ptr = __VA_GP_REGSAVE (AP, __gpr, TYPE);\t\t   \\\n-\t      (AP)->gpr = __gpr + 1;\t\t\t\t\t   \\\n-\t    }\t\t\t\t\t\t\t\t   \\\n-\t  else\t\t\t\t\t\t\t\t   \\\n-\t    {\t\t\t\t\t\t\t\t   \\\n-\t      __ptr = (TYPE *) __va_overflow (AP);\t\t\t   \\\n-\t      __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n-\t    }\t\t\t\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      else\t\t\t\t\t\t\t\t   \\\n-\t{\t\t\t\t\t\t\t\t   \\\n-\t  /* Everything else was promoted to int.  */\t\t\t   \\\n-\t  __va_arg_type_violation ();\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-    }\t\t\t\t\t\t\t\t\t   \\\n-  __ptr;\t\t\t\t\t\t\t\t   \\\n-}))\n-\n-#define va_end(AP)\t((void)0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) *(dest) = *(src)\n-\n-#endif /* __VA_PPC_H__ */\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-\n-\f\n-#else\n-/* Windows NT */\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef char *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#define __va_start_common(AP, LASTARG, FAKE)\t\t\t\t\\\n-  ((__builtin_saveregs ()), ((AP) = ((char *) &LASTARG) + __va_rounded_size (AP)), 0)\n-\n-#ifdef _STDARG_H /* stdarg.h support */\n-\n-/* Calling __builtin_next_arg gives the proper error message if LASTARG is\n-   not indeed the last argument.  */\n-#define va_start(AP,LASTARG)\t\t\t\t\t\t\\\n-  (__builtin_saveregs (),\t\t\t\t\t\t\\\n-   (AP) = __builtin_next_arg (LASTARG),\t\t\t\t\t\\\n-   0)\n-\n-#else /* varargs.h support */\n-\n-#define va_start(AP)\t\t\t\t\t\t\t\\\n-  (__builtin_saveregs (),\t\t\t\t\t\t\\\n-   (AP) = __builtin_next_arg (__va_1st_arg) - sizeof (int),\t\t\\\n-   0)\n-\n-#define va_alist __va_1st_arg\n-#define va_dcl register int __va_1st_arg; ...\n-\n-#endif /* _STDARG_H */\n-\n-#define __va_rounded_size(TYPE) ((sizeof (TYPE) + 3) & ~3)\n-#define __va_align(AP, TYPE)\t\t\t\t\t\t\\\n-     ((((unsigned long)(AP)) + ((sizeof (TYPE) >= 8) ? 7 : 3))\t\t\\\n-      & ~((sizeof (TYPE) >= 8) ? 7 : 3))\n-\n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\t\\\n-( *(TYPE *)((AP = (char *) (__va_align(AP, TYPE)\t\t\t\\\n-\t\t\t    + __va_rounded_size(TYPE)))\t\t\t\\\n-\t    - __va_rounded_size(TYPE)))\n-\n-#define va_end(AP)\t((void)0)\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-#endif /* Windows NT */"}, {"sha": "5ad4ba9d763ef56e246b4024d87e0058c829e58f", "filename": "gcc/ginclude/va-pyr.h", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-pyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-pyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-pyr.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,130 +0,0 @@\n-/**\n- *\n- * \tVarargs for PYR/GNU CC\n- *\n- * WARNING -- WARNING -- DANGER\n- *\n- * The code in this file implements varargs for gcc on a pyr in\n- * a way that is compatible with code compiled by the Pyramid Technology\n- * C compiler.\n- * As such, it depends strongly on the Pyramid conventions for\n- * parameter passing.ct and independent implementation. \n- * These (somewhat bizarre) parameter-passing conventions are described\n- * in the ``OSx Operating System Porting Guide''.\n- * \n- * A quick summary is useful:\n- * 12 of the 48 register-windowed regs available for\n- * parameter passing.  Parameters of a function call that are eligible\n- * to be passed in registers are assigned registers from TR0/PR0 onwards;\n- * all other arguments are passed on the stack.\n- * Structure and union parameters are *never* passed in registers,\n- * even if they are small enough to fit.  They are always passed on\n- * the stack.\n- *\n- * Double-sized parameters cannot be passed in TR11, because\n- * TR12 is not used for passing parameters.  If, in the absence of this\n- * rule, a double-sized param would have been passed in TR11,\n- * that parameter is passed on the stack and no parameters are\n- * passed in TR11.\n- * \n- * It is only known to work for passing 32-bit integer quantities\n- * (ie chars, shorts, ints/enums, longs), doubles, or pointers. \n- * Passing structures on a Pyramid via varargs is a loser.\n- * Passing an object larger than 8 bytes on a pyramid via varargs may\n- * also be a loser.\n- * \n- */\n-\n-\f\n-/*\n- *  pointer to next stack parameter in __va_buf[0]\n- *  pointer to next parameter register in __va_buf[1]\n- *  Count of registers seen at __va_buf[2]\n- *  saved pr0..pr11 in __va_buf[3..14]\n- *  # of calls to va_arg (debugging) at __va_buf[15]\n- */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-typedef void *__voidptr;\n-#if 1\n-\n-typedef struct __va_regs {\n-      __voidptr __stackp,__regp,__count;\n-      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;\n-  } __va_regs;\n-\n-typedef __va_regs __va_buf;\n-#else\n-\n-/* __va_buf[0] = address of next arg passed on the stack\n-   __va_buf[1] = address of next arg passed in a register\n-   __va_buf[2] = register-# of next arg passed in a register\n- */\n-typedef __voidptr(*__va_buf);\n-\n-#endif\n-\n-typedef __va_buf __gnuc_va_list;\n-\n-#endif /* not __GNUC_VA_LIST */\n-\f\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-#define va_alist \\\n-  __va0,__va1,__va2,__va3,__va4,__va5,__va6,__va7,__va8,__va9,__va10,__va11, \\\n- __builtin_va_alist\n-\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl __voidptr va_alist; __va_ellipsis\n-\n-\n-/* __asm (\"rcsp %0\" : \"=r\" ( _AP [0]));*/\n-\n-#define va_start(_AP)  \\\n-  _AP =  ((struct __va_regs) {\t\t\t\t\t\t\\\n-   &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,\t\t\t\\\n-        __va0,__va1,__va2,__va3,__va4,__va5,\t\t\t\t\\\n-\t__va6,__va7,__va8,__va9,__va10,__va11})\n-\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-#define va_arg(_AP, _MODE)\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-(*({__voidptr *__ap = (__voidptr*)&_AP;\t\t\t\t\t\\\n-  register int __size = sizeof (_MODE);\t\t\t\t\t\\\n-  register int __onstack =\t\t\t\t\t\t\\\n-\t  (__size > 8 || ( (int)(__ap[2]) > 11) ||\t\t\t\\\n-\t    (__size==8 && (int)(__ap[2])==11));\t\t\t\t\\\n-  register int* __param_addr =  ((int*)((__ap) [__onstack]));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  ((void *)__ap[__onstack])+=__size;\t\t\t\t\t\\\n-    if (__onstack==0 || (int)(__ap[2])==11)\t\t\t\t\\\n-      __ap[2]+= (__size >> 2);\t\t\t\t\t\t\\\n-  (( _MODE *) (void *) __param_addr);\t\t\t\t\t\\\n-}))\n-\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#define va_end(_X)\t((void)0)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "dc4e3ae8079f5eabd8f31141b7fff79e561f8df9", "filename": "gcc/ginclude/va-sh.h", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sh.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,229 +0,0 @@\n-/* The ! __SH3E_VARG case is similar to the default gvarargs.h .  */\n-\n-#if (defined (__SH3E__) || defined (__SH4_SINGLE__) || defined (__SH4__) || defined (__SH4_SINGLE_ONLY__)) && ! defined (__HITACHI__)\n-#define __SH3E_VARG\n-#endif\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-\n-#ifdef __SH3E_VARG\n-\n-typedef long __va_greg;\n-typedef float __va_freg;\n-\n-typedef struct {\n-  __va_greg * __va_next_o;\t\t/* next available register */\n-  __va_greg * __va_next_o_limit;\t/* past last available register */\n-  __va_freg * __va_next_fp;\t\t/* next available fp register */\n-  __va_freg * __va_next_fp_limit;\t/* last available fp register */\n-  __va_greg * __va_next_stack;\t\t/* next extended word on stack */\n-} __gnuc_va_list;\n-\n-#else /* ! SH3E */\n-\n-typedef void *__gnuc_va_list;\n-\n-#endif /* ! SH3E */\n-\n-#endif /* __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifdef _STDARG_H\n-\n-#ifdef __SH3E_VARG\n-\n-#define va_start(AP, LASTARG) \\\n-__extension__ \\\n-  ({ \\\n-     (AP).__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n-     (AP).__va_next_fp_limit = ((AP).__va_next_fp + \\\n-\t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n-     (AP).__va_next_o = (__va_greg *) (AP).__va_next_fp_limit; \\\n-     (AP).__va_next_o_limit = ((AP).__va_next_o + \\\n-\t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n-     (AP).__va_next_stack = (__va_greg *) __builtin_next_arg (LASTARG); \\\n-  })\n-\n-#else /* ! SH3E */\n-\n-#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n- ((AP) = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n-\n-#endif /* ! SH3E */\n-\n-#else /* _VARARGS_H */\n-\n-#define va_alist  __builtin_va_alist\n-#define va_dcl    int __builtin_va_alist;...\n-\n-#ifdef __SH3E_VARG\n-\n-#define va_start(AP) \\\n-__extension__ \\\n-  ({ \\\n-     (AP).__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n-     (AP).__va_next_fp_limit = ((AP).__va_next_fp + \\\n-\t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n-     (AP).__va_next_o = (__va_greg *) (AP).__va_next_fp_limit; \\\n-     (AP).__va_next_o_limit = ((AP).__va_next_o + \\\n-\t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n-     (AP).__va_next_stack \\\n-       = ((__va_greg *) __builtin_next_arg (__builtin_va_alist) \\\n-\t  - (__builtin_args_info (0) >= 4 || __builtin_args_info (1) >= 8 \\\n-\t     ? 1 : 0)); \\\n-  })\n-\n-#else /* ! SH3E */\n-\n-#define va_start(AP)  ((AP) = (char *) &__builtin_va_alist)\n-\n-#endif /* ! SH3E */\n-\n-#endif /* _STDARG */\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-\n-/* Values returned by __builtin_classify_type.  */\n-\n-enum __va_type_classes {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-#endif\n-#define va_end(pvar)\t((void)0)\n-\n-#ifdef __LITTLE_ENDIAN__\n-#define __LITTLE_ENDIAN_P 1\n-#else\n-#define __LITTLE_ENDIAN_P 0\n-#endif\n-\n-#define __SCALAR_TYPE(TYPE)\t\t\t\t\t\\\n-  ((TYPE) == __integer_type_class\t\t\t\t\\\n-   || (TYPE) == __char_type_class\t\t\t\t\\\n-   || (TYPE) == __enumeral_type_class)\n-\n-/* RECORD_TYPE args passed using the C calling convention are\n-   passed by invisible reference.  ??? RECORD_TYPE args passed\n-   in the stack are made to be word-aligned; for an aggregate that is\n-   not word-aligned, we advance the pointer to the first non-reg slot.  */\n-\n-  /* When this is a smaller-than-int integer, using\n-     auto-increment in the promoted (SImode) is fastest;\n-     however, there is no way to express that is C.  Therefore,\n-     we use an asm.\n-     We want the MEM_IN_STRUCT_P bit set in the emitted RTL, therefore we\n-     use unions even when it would otherwise be unnecessary.  */\n-\n-/* gcc has an extension that allows to use a casted lvalue as an lvalue,\n-   But it doesn't work in C++ with -pedantic - even in the presence of\n-   __extension__ .  We work around this problem by using a reference type.  */\n-#ifdef __cplusplus\n-#define __VA_REF &\n-#else\n-#define __VA_REF\n-#endif\n-\n-#define __va_arg_sh1(AP, TYPE) __extension__ \t\t\t\t\\\n-({(sizeof (TYPE) == 1\t\t\t\t\t\t\t\\\n-   ? ({union {TYPE t; char c;} __t;\t\t\t\t\t\\\n-       __asm(\"\"\t\t\t\t\t\t\t\t\\\n-\t     : \"=r\" (__t.c)\t\t\t\t\t\t\\\n-\t     : \"0\" ((((union { int i, j; } *__VA_REF) (AP))++)->i));\t\\\n-       __t.t;})\t\t\t\t\t\t\t\t\\\n-   : sizeof (TYPE) == 2\t\t\t\t\t\t\t\\\n-   ? ({union {TYPE t; short s;} __t;\t\t\t\t\t\\\n-       __asm(\"\"\t\t\t\t\t\t\t\t\\\n-\t     : \"=r\" (__t.s)\t\t\t\t\t\t\\\n-\t     : \"0\" ((((union { int i, j; } *__VA_REF) (AP))++)->i));\t\\\n-       __t.t;})\t\t\t\t\t\t\t\t\\\n-   : sizeof (TYPE) >= 4 || __LITTLE_ENDIAN_P\t\t\t\t\\\n-   ? (((union { TYPE t; int i;} *__VA_REF) (AP))++)->t\t\t\t\\\n-   : ((union {TYPE t;TYPE u;}*) ((char *)++(int *__VA_REF)(AP) - sizeof (TYPE)))->t);})\n-\n-#ifdef __SH3E_VARG\n-\n-#define __PASS_AS_FLOAT(TYPE_CLASS,SIZE) \\\n-  (TYPE_CLASS == __real_type_class && SIZE == 4)\n-\n-#define __TARGET_SH4_P 0\n-\n-#if defined(__SH4__) || defined(__SH4_SINGLE__)\n-#undef __PASS_AS_FLOAT\n-#define __PASS_AS_FLOAT(TYPE_CLASS,SIZE) \\\n-  (TYPE_CLASS == __real_type_class && SIZE <= 8 \\\n-   || TYPE_CLASS == __complex_type_class && SIZE <= 16)\n-#undef __TARGET_SH4_P\n-#define __TARGET_SH4_P 1\n-#endif\n-\n-#define va_arg(pvar,TYPE)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\\\n-({int __type = __builtin_classify_type (* (TYPE *) 0);\t\t\\\n-  void * __result_p;\t\t\t\t\t\t\\\n-  if (__PASS_AS_FLOAT (__type, sizeof(TYPE)))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((pvar).__va_next_fp < (pvar).__va_next_fp_limit)\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  if (((__type == __real_type_class && sizeof (TYPE) > 4)\\\n-\t       || sizeof (TYPE) > 8)\t\t\t\t\\\n-\t      && (((int) (pvar).__va_next_fp ^ (int) (pvar).__va_next_fp_limit)\\\n-\t\t  & 4))\t\t\t\t\t\t\\\n-\t    (pvar).__va_next_fp++;\t\t\t\t\\\n-\t  __result_p = &(pvar).__va_next_fp;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t__result_p = &(pvar).__va_next_stack;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((pvar).__va_next_o + ((sizeof (TYPE) + 3) / 4)\t\\\n-\t  <= (pvar).__va_next_o_limit) \t\t\t\t\\\n-\t__result_p = &(pvar).__va_next_o;\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  if (sizeof (TYPE) > 4)\t\t\t\t\\\n-\t   if (! __TARGET_SH4_P)\t\t\t\t\\\n-\t    (pvar).__va_next_o = (pvar).__va_next_o_limit;\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t  __result_p = &(pvar).__va_next_stack;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    } \t\t\t\t\t\t\t\t\\\n-  __va_arg_sh1(*(void **)__result_p, TYPE);})\n-\n-#else /* ! SH3E */\n-\n-#define va_arg(AP, TYPE) __va_arg_sh1((AP), TYPE)\n-\n-#endif /* SH3E */\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) ((dest) = (src))\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "73c9de1cd9a0bed1b75775d28b8ad0ba9f89bb34", "filename": "gcc/ginclude/va-sparc.h", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-sparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-sparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sparc.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,165 +0,0 @@\n-/* This is just like the default gvarargs.h\n-   except for differences described below.  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-#if ! defined (__svr4__) && ! defined (__linux__) && ! defined (__arch64__)\n-/* This has to be a char * to be compatible with Sun.\n-   i.e., we have to pass a `va_list' to vsprintf.  */\n-typedef char * __gnuc_va_list;\n-#else\n-/* This has to be a void * to be compatible with Sun svr4.\n-   i.e., we have to pass a `va_list' to vsprintf.  */\n-typedef void * __gnuc_va_list;\n-#endif\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifdef _STDARG_H\n-\n-/* Call __builtin_next_arg even though we aren't using its value, so that\n-   we can verify that LASTARG is correct.  */\n-#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)\n-#define va_start(AP, LASTARG) \\\n-  (__builtin_next_arg (LASTARG), AP = (char *) __builtin_saveregs ())\n-#else\n-#define va_start(AP, LASTARG)\t\t\t\t\t\\\n-  (__builtin_saveregs (), AP = ((char *) __builtin_next_arg (LASTARG)))\n-#endif\n-\n-#else\n-\n-#define va_alist  __builtin_va_alist\n-#define va_dcl    int __builtin_va_alist;...\n-\n-#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)\n-#define va_start(AP)\t((AP) = (char *) __builtin_saveregs ())\n-#else\n-#define va_start(AP) \\\n-  (__builtin_saveregs (), (AP) = ((char *) &__builtin_va_alist))\n-#endif\n-\n-#endif\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-\n-/* Values returned by __builtin_classify_type.  */\n-\n-enum __va_type_classes {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-#endif\n-#define va_end(pvar)\t((void)0)\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-/* RECORD_TYPE args passed using the C calling convention are\n-   passed by invisible reference.  ??? RECORD_TYPE args passed\n-   in the stack are made to be word-aligned; for an aggregate that is\n-   not word-aligned, we advance the pointer to the first non-reg slot.  */\n-\n-#ifdef __arch64__\n-\n-typedef unsigned int __ptrint __attribute__ ((__mode__ (__DI__)));\n-\n-/* ??? TODO: little endian support */\n-\n-#define va_arg(pvar, TYPE) \\\n-__extension__\t\t\t\t\t\t\t\\\n-(*({int __type = __builtin_classify_type (* (TYPE *) 0);\t\\\n-  char * __result;\t\t\t\t\t\t\\\n-  if (__type == __real_type_class)\t\t/* float? */\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (__alignof__ (TYPE) == 16)\t\t\t\t\\\n-\t(pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);\t\\\n-      __result = (pvar);\t\t\t\t\t\\\n-      (pvar) = (char *) (pvar) + sizeof (TYPE);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (__type < __record_type_class)\t/* integer? */\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      (pvar) = (char *) (pvar) + 8;\t\t\t\t\\\n-      __result = (char *) (pvar) - sizeof (TYPE);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else /* aggregate object */\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (sizeof (TYPE) <= 8)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  __result = (pvar);\t\t\t\t\t\\\n-\t  (pvar) = (char *) (pvar) + 8;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else if (sizeof (TYPE) <= 16)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  if (__alignof__ (TYPE) == 16)\t\t\t\t\\\n-\t    (pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);\t\\\n-\t  __result = (pvar);\t\t\t\t\t\\\n-\t  (pvar) = (char *) (pvar) + 16;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  __result = * (void **) (pvar);\t\t\t\\\n-\t  (pvar) = (char *) (pvar) + 8;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  (TYPE *) __result;}))\n-\n-#else /* not __arch64__ */\n-\n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-\n-/* We don't declare the union member `d' to have type TYPE\n-   because that would lose in C++ if TYPE has a constructor.  */\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.\n-   The casts to char * avoid warnings about invalid pointer arithmetic.  */\n-#define va_arg(pvar,TYPE)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\\\n-(*({((__builtin_classify_type (*(TYPE*) 0) >= __record_type_class \\\n-      || (__builtin_classify_type (*(TYPE*) 0) == __real_type_class \\\n-\t  && sizeof (TYPE) == 16))\t\t\t\t\\\n-    ? ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE *),\t\\\n-       *(TYPE **) (void *) ((char *)(pvar) - __va_rounded_size (TYPE *))) \\\n-    : __va_rounded_size (TYPE) == 8\t\t\t\t\\\n-    ? ({ union {char __d[sizeof (TYPE)]; int __i[2];} __u;\t\\\n-\t __u.__i[0] = ((int *) (void *) (pvar))[0];\t\t\\\n-\t __u.__i[1] = ((int *) (void *) (pvar))[1];\t\t\\\n-\t (pvar) = (char *)(pvar) + 8;\t\t\t\t\\\n-\t (TYPE *) (void *) __u.__d; })\t\t\t\t\\\n-    : ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE),\t\\\n-       ((TYPE *) (void *) ((char *)(pvar) - __va_rounded_size (TYPE)))));}))\n-\n-#endif /* not __arch64__ */\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}, {"sha": "7457ceb9fcdbe24255801072e1ef61a6f368bb19", "filename": "gcc/ginclude/va-spur.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-spur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-spur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-spur.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,64 +0,0 @@\n-/*  varargs.h for SPUR */\n-\n-/* NB.  This is NOT the definition needed for the new ANSI proposed\n-   standard */\n- \n-\n-struct __va_struct { char __regs[20]; };\n-\n-#define va_alist __va_regs, __va_stack\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl struct __va_struct __va_regs; int __va_stack; \n-\n-typedef struct {\n-    int __pnt;\n-    char *__regs;\n-    char *__stack;\n-} va_list;\n-\n-#define va_start(pvar) \\\n-     ((pvar).__pnt = 0, (pvar).__regs = __va_regs.__regs, \\\n-      (pvar).__stack = (char *) &__va_stack)\n-#define va_end(pvar)\t((void)0)\n-\n-/* Avoid errors if compiling GCC v2 with GCC v1.  */\n-#if __GNUC__ == 1\n-#define __extension__\n-#endif\n-\n-#define va_arg(pvar,type)  \\\n-__extension__ \\\n-    (*({  type *__va_result; \\\n-        if ((pvar).__pnt >= 20) { \\\n-           __va_result = ( (type *) ((pvar).__stack + (pvar).__pnt - 20)); \\\n-\t   (pvar).__pnt += (sizeof(type) + 7) & ~7; \\\n-\t} \\\n-\telse if ((pvar).__pnt + sizeof(type) > 20) { \\\n-\t   __va_result = (type *) (pvar).__stack; \\\n-\t   (pvar).__pnt = 20 + ( (sizeof(type) + 7) & ~7); \\\n-\t} \\\n-\telse if (sizeof(type) == 8) { \\\n-\t   union {double d; int i[2];} __u; \\\n-\t   __u.i[0] = *(int *) ((pvar).__regs + (pvar).__pnt); \\\n-\t   __u.i[1] = *(int *) ((pvar).__regs + (pvar).__pnt + 4); \\\n-\t   __va_result = (type *) &__u; \\\n-\t   (pvar).__pnt += 8; \\\n-\t} \\\n-\telse { \\\n-\t   __va_result = (type *) ((pvar).__regs + (pvar).__pnt); \\\n-\t   (pvar).__pnt += (sizeof(type) + 3) & ~3; \\\n-\t} \\\n-\t__va_result; }))\n-\n-/* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)"}, {"sha": "96da6d5a3dea4bbbae20f8ce1b9c5ed4ef5aa050", "filename": "gcc/ginclude/va-v850.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-v850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126c35a6212e443cc7050199eb18411c56fe874/gcc%2Fginclude%2Fva-v850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-v850.h?ref=5126c35a6212e443cc7050199eb18411c56fe874", "patch": "@@ -1,34 +0,0 @@\n-/* Define __gnuc_va_list. */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-typedef void *__gnuc_va_list;\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-#ifdef _STDARG_H\n-#define va_start(AP, LASTARG)\t\t\t\t\t\t\\\n-  (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n-#else\n-#define __va_ellipsis ...\n-#define va_alist __builtin_va_alist\n-#define va_dcl int __builtin_va_alist; __va_ellipsis\n-#define va_start(AP) AP=(char *) &__builtin_va_alist\n-#endif\n-\n-/* Now stuff common to both varargs & stdarg implementations.  */\n-#define __va_rounded_size(TYPE)\t\t\t\t\t\t\\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#undef va_end\n-void va_end (__gnuc_va_list);\n-#define va_end(AP) ((void)0)\n-#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n- (sizeof (TYPE) > 8\t\t\t\t\t\t\t\\\n-  ? (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (char *)),\\\n-    **((TYPE **) (void *) ((char *) (AP) - __va_rounded_size (char *))))\\\n-  : (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n-    *((TYPE *) (void *) ((char *) (AP) - __va_rounded_size (TYPE)))))\n-#endif"}]}