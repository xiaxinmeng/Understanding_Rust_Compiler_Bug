{"sha": "718fe40625fa164d5a51f9367acc79098bf70f95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4ZmU0MDYyNWZhMTY0ZDVhNTFmOTM2N2FjYzc5MDk4YmY3MGY5NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-14T14:34:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-14T14:34:52Z"}, "message": "* cse.c: Fix formatting.\n\nFrom-SVN: r35676", "tree": {"sha": "6178485e9b79f7d0291ab9d77066dd177b352a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6178485e9b79f7d0291ab9d77066dd177b352a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/718fe40625fa164d5a51f9367acc79098bf70f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718fe40625fa164d5a51f9367acc79098bf70f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/718fe40625fa164d5a51f9367acc79098bf70f95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718fe40625fa164d5a51f9367acc79098bf70f95/comments", "author": null, "committer": null, "parents": [{"sha": "ddc356e89a920b622c6c11c3fb0b3521d9373b30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc356e89a920b622c6c11c3fb0b3521d9373b30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc356e89a920b622c6c11c3fb0b3521d9373b30"}], "stats": {"total": 289, "additions": 143, "deletions": 146}, "files": [{"sha": "5b668968a4b8688e038713e90df3d60cf65efe50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718fe40625fa164d5a51f9367acc79098bf70f95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718fe40625fa164d5a51f9367acc79098bf70f95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=718fe40625fa164d5a51f9367acc79098bf70f95", "patch": "@@ -1,5 +1,7 @@\n 2000-08-13  Kazu Hirata  <kazu@hxi.com>\n \n+\t* function.c: Fix formatting.\n+\n \t* cse.c: Fix formatting.\n \n 2000-08-13  Geoff Keating  <geoffk@cygnus.com>"}, {"sha": "183e508e7eab098cca4cdacc9fa5b42271e8dc9f", "filename": "gcc/function.c", "status": "modified", "additions": 141, "deletions": 146, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718fe40625fa164d5a51f9367acc79098bf70f95/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718fe40625fa164d5a51f9367acc79098bf70f95/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=718fe40625fa164d5a51f9367acc79098bf70f95", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file handles the generation of rtl code from tree structure\n    at the level of the function as a whole.\n    It creates the rtl expressions for parameters and auto variables\n@@ -108,7 +107,7 @@ Boston, MA 02111-1307, USA.  */\n /* Nonzero if function being compiled doesn't contain any calls\n    (ignoring the prologue and epilogue).  This is set prior to\n    local register allocation and is valid for the remaining\n-   compiler passes. */\n+   compiler passes.  */\n int current_function_is_leaf;\n \n /* Nonzero if function being compiled doesn't contain any instructions\n@@ -118,7 +117,7 @@ int current_function_nothrow;\n \n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n-   life_analysis has run. */\n+   life_analysis has run.  */\n int current_function_sp_is_unchanging;\n \n /* Nonzero if the function being compiled is a leaf function which only\n@@ -190,7 +189,7 @@ struct temp_slot\n   /* The rtx used to represent the address if not the address of the\n      slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n   rtx address;\n-  /* The alignment (in bits) of the slot. */\n+  /* The alignment (in bits) of the slot.  */\n   int align;\n   /* The size, in units, of the slot.  */\n   HOST_WIDE_INT size;\n@@ -234,7 +233,7 @@ struct fixup_replacement\n   rtx new;\n   struct fixup_replacement *next;\n };\n-   \n+\n struct insns_for_mem_entry {\n   /* The KEY in HE will be a MEM.  */\n   struct hash_entry he;\n@@ -256,7 +255,7 @@ static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n static void schedule_fixup_var_refs PARAMS ((struct function *, rtx, tree,\n \t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t     struct hash_table *));\n-static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int, \n+static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int,\n \t\t\t\t\t struct hash_table *));\n static struct fixup_replacement\n   *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n@@ -293,7 +292,7 @@ static int contains\t\tPARAMS ((rtx, varray_type));\n static void emit_return_into_block PARAMS ((basic_block, rtx));\n #endif\n static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n-static boolean purge_addressof_1 PARAMS ((rtx *, rtx, int, int, \n+static boolean purge_addressof_1 PARAMS ((rtx *, rtx, int, int,\n \t\t\t\t\t  struct hash_table *));\n static int is_addressof\t\tPARAMS ((rtx *, void *));\n static struct hash_entry *insns_for_mem_newfunc PARAMS ((struct hash_entry *,\n@@ -492,7 +491,6 @@ free_after_compilation (f)\n   f->inl_last_parm_insn = NULL;\n   f->epilogue_delay_list = NULL;\n }\n-\n \f\n /* Allocate fixed slots in the stack frame of the current function.  */\n \n@@ -523,7 +521,7 @@ get_frame_size ()\n \n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n    with machine mode MODE.\n-   \n+\n    ALIGN controls the amount of alignment for the address of the slot:\n    0 means according to MODE,\n    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,\n@@ -557,7 +555,7 @@ assign_stack_local_1 (mode, size, align, function)\n       if (mode == BLKmode)\n \talignment = BIGGEST_ALIGNMENT;\n       else\n-        alignment = GET_MODE_ALIGNMENT (mode);\n+\talignment = GET_MODE_ALIGNMENT (mode);\n \n       /* Allow the target to (possibly) increase the alignment of this\n \t stack slot.  */\n@@ -652,7 +650,7 @@ assign_stack_local (mode, size, align)\n    with this flag.  KEEP is 2 if we allocate a longer term temporary,\n    whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3\n    if we are to allocate something at an inner level to be treated as\n-   a variable in the block (e.g., a SAVE_EXPR).  \n+   a variable in the block (e.g., a SAVE_EXPR).\n \n    TYPE is the type that will be used for the stack slot.  */\n \n@@ -677,7 +675,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n      alias set for the memory.  */\n   if (type)\n     alias_set = get_alias_set (type);\n-  else \n+  else\n     alias_set = 0;\n \n   if (mode == BLKmode)\n@@ -748,7 +746,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \n       p = best_p;\n     }\n-\t      \n+\n   /* If we still didn't find one, make a new temporary.  */\n   if (p == 0)\n     {\n@@ -913,7 +911,7 @@ combine_temp_slots ()\n   if (flag_strict_aliasing)\n     return;\n \n-  /* If there are a lot of temp slots, don't do anything unless \n+  /* If there are a lot of temp slots, don't do anything unless\n      high levels of optimizaton.  */\n   if (! flag_expensive_optimizations)\n     for (p = temp_slots, num_slots = 0; p; p = p->next, num_slots++)\n@@ -1008,7 +1006,7 @@ find_temp_slot_from_address (x)\n \n   return 0;\n }\n-      \n+\n /* Indicate that NEW is an alternate way of referring to the temp slot\n    that previously was known by OLD.  */\n \n@@ -1054,7 +1052,7 @@ update_temp_slot_address (old, new)\n       return;\n     }\n \n-  /* Otherwise add an alias for the temp's address. */\n+  /* Otherwise add an alias for the temp's address.  */\n   else if (p->address == 0)\n     p->address = new;\n   else\n@@ -1449,7 +1447,7 @@ put_var_into_stack (decl)\n     }\n   else\n     return;\n-  \n+\n   if (current_function_check_memory_usage)\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       XEXP (reg, 0), Pmode,\n@@ -1556,7 +1554,7 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n   rtx insn;\n \n   /* Must scan all insns for stack-refs that exceed the limit.  */\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn, \n+  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn,\n \t\t\tstack == 0, ht);\n   /* If there's a hash table, it must record all uses of VAR.  */\n   if (ht)\n@@ -1581,16 +1579,14 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n       if (seq != const0_rtx && seq != 0)\n \t{\n \t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0,\n-\t\t\t\t0);\n+\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0, 0);\n \t  end_sequence ();\n \t}\n     }\n \n   /* Scan the catch clauses for exception handling too.  */\n   push_to_full_sequence (catch_clauses, catch_clauses_last);\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, catch_clauses,\n-\t\t\t0, 0);\n+  fixup_var_refs_insns (var, promoted_mode, unsignedp, catch_clauses, 0, 0);\n   end_full_sequence (&catch_clauses, &catch_clauses_last);\n \n   /* Scan sequences saved in CALL_PLACEHOLDERS too.  */\n@@ -1666,7 +1662,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n      to walk the entire instruction chain.  */\n   if (ht)\n     {\n-      insn_list = ((struct insns_for_mem_entry *) \n+      insn_list = ((struct insns_for_mem_entry *)\n \t\t   hash_lookup (ht, var, /*create=*/0, /*copy=*/0))->insns;\n       insn = insn_list ? XEXP (insn_list, 0) : NULL_RTX;\n       insn_list = XEXP (insn_list, 1);\n@@ -1687,7 +1683,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \n \t     If it has a REG_LIBCALL note, delete the REG_LIBCALL\n \t     and REG_RETVAL notes too.  */\n- \t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n \t      && (XEXP (PATTERN (insn), 0) == var\n \t\t  || (GET_CODE (XEXP (PATTERN (insn), 0)) == CONCAT\n \t\t      && (XEXP (XEXP (PATTERN (insn), 0), 0) == var\n@@ -1765,7 +1761,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \t\t      PATTERN (insn) = replace_rtx (PATTERN (insn),\n \t\t\t\t\t\t    call_dest, temp);\n \t\t    }\n-\t      \n+\n \t\t  if (GET_CODE (insn) == CALL_INSN\n \t\t      && GET_CODE (PATTERN (insn)) == SET)\n \t\t    call_dest = SET_DEST (PATTERN (insn));\n@@ -1784,7 +1780,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \t\t a list of struct fixup_replacements.  If fixup_var_refs_1\n \t\t needs to allocate pseudos or replacement MEMs (for SUBREGs),\n \t\t it will record them in this list.\n-\t\t \n+\n \t\t If it allocated a pseudo for any replacement, we copy into\n \t\t it here.  */\n \n@@ -1846,7 +1842,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \t      if (GET_CODE (note) != INSN_LIST)\n \t\tXEXP (note, 0)\n \t\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n-\t       note = XEXP (note, 1);\n+\t      note = XEXP (note, 1);\n \t    }\n \t}\n \n@@ -1863,7 +1859,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n }\n \f\n /* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.\n-   See if the rtx expression at *LOC in INSN needs to be changed.  \n+   See if the rtx expression at *LOC in INSN needs to be changed.\n \n    REPLACEMENTS is a pointer to a list head that starts out zero, but may\n    contain a list of original rtx's and replacements. If we find that we need\n@@ -1941,7 +1937,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n     case MEM:\n       if (var == x)\n \t{\n-\t  /* If we already have a replacement, use it.  Otherwise, \n+\t  /* If we already have a replacement, use it.  Otherwise,\n \t     try to fix up this address in case it is invalid.  */\n \n \t  replacement = find_fixup_replacement (replacements, var);\n@@ -1955,7 +1951,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t  /* Unless we are forcing memory to register or we changed the mode,\n \t     we can leave things the way they are if the insn is valid.  */\n-\t     \n+\n \t  INSN_CODE (insn) = -1;\n \t  if (! flag_force_mem && GET_MODE (x) == promoted_mode\n \t      && recog_memoized (insn) >= 0)\n@@ -2093,7 +2089,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t  return;\n \t}\n       break;\n-\t      \n+\n     case SUBREG:\n       if (SUBREG_REG (x) == var)\n \t{\n@@ -2110,7 +2106,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    }\n \n \t  /* If this SUBREG makes VAR wider, it has become a paradoxical\n-\t     SUBREG with VAR in memory, but these aren't allowed at this \n+\t     SUBREG with VAR in memory, but these aren't allowed at this\n \t     stage of the compilation.  So load VAR into a pseudo and take\n \t     a SUBREG of that pseudo.  */\n \t  if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (var)))\n@@ -2132,7 +2128,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t      *loc = replacement->new;\n \t      return;\n \t    }\n-\t  \n+\n \t  replacement->new = *loc = fixup_memory_subreg (x, insn, 0);\n \n \t  INSN_CODE (insn) = -1;\n@@ -2182,7 +2178,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t\t   insn);\n \t  break;\n \t}\n-\t  \n+\n       {\n \trtx dest = SET_DEST (x);\n \trtx src = SET_SRC (x);\n@@ -2201,7 +2197,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t/* If VAR does not appear at the top level of the SET\n \t   just scan the lower levels of the tree.  */\n \n-        if (src != var && dest != var)\n+\tif (src != var && dest != var)\n \t  break;\n \n \t/* We will need to rerecognize this insn.  */\n@@ -2265,10 +2261,10 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t    INSN_CODE (insn) = -1;\n \t\t    XEXP (outerdest, 0) = newmem;\n \t\t    XEXP (outerdest, 2) = GEN_INT (pos);\n-\t\t    \n+\n \t\t    if (recog_memoized (insn) >= 0)\n \t\t      return;\n-\t\t    \n+\n \t\t    /* Otherwise, restore old position.  XEXP (x, 0) will be\n \t\t       restored later.  */\n \t\t    XEXP (outerdest, 2) = old_pos;\n@@ -2333,7 +2329,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t       copy SET_SRC (x) to SET_DEST (x) in some way.  So\n \t       we generate the move and see whether it requires more\n \t       than one insn.  If it does, we emit those insns and\n-\t       delete INSN.  Otherwise, we an just replace the pattern \n+\t       delete INSN.  Otherwise, we an just replace the pattern\n \t       of INSN; we have already verified above that INSN has\n \t       no other function that to do X.  */\n \n@@ -2485,7 +2481,7 @@ fixup_memory_subreg (x, insn, uncritical)\n    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.\n    Otherwise return X, with its contents possibly altered.\n \n-   If any insns must be emitted to compute NEWADDR, put them before INSN. \n+   If any insns must be emitted to compute NEWADDR, put them before INSN.\n \n    UNCRITICAL is as in fixup_memory_subreg.  */\n \n@@ -2777,7 +2773,7 @@ static int cfa_offset;\n /* The bottom of the stack points to the actual arguments.  If\n    REG_PARM_STACK_SPACE is defined, this includes the space for the register\n    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,\n-   stack space for register parameters is not pushed by the caller, but \n+   stack space for register parameters is not pushed by the caller, but\n    rather part of the fixed stack areas and hence not included in\n    `current_function_outgoing_args_size'.  Nevertheless, we must allow\n    for it when allocating stack dynamic objects.  */\n@@ -2801,7 +2797,6 @@ static int cfa_offset;\n #define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n #endif\n \n-\n /* Build up a (MEM (ADDRESSOF (REG))) rtx for a register REG that just had\n    its address taken.  DECL is the decl for the object stored in the\n    register, for later use if we do need to force REG into the stack.\n@@ -2899,7 +2894,7 @@ static rtx purge_bitfield_addressof_replacements;\n    corresponding (ADDRESSOF (REG ...)) and value is a substitution for\n    the all pattern.  List PURGE_BITFIELD_ADDRESSOF_REPLACEMENTS is not\n    enough in complex cases, e.g. when some field values can be\n-   extracted by usage MEM with narrower mode. */\n+   extracted by usage MEM with narrower mode.  */\n static rtx purge_addressof_replacements;\n \n /* Helper function for purge_addressof.  See if the rtx expression at *LOC\n@@ -2949,7 +2944,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n       if (validate_change (insn, loc, sub, 0)\n \t  || validate_replace_rtx (x, sub, insn))\n \treturn true;\n-  \n+\n       start_sequence ();\n       sub = force_operand (sub, NULL_RTX);\n       if (! validate_change (insn, loc, sub, 0)\n@@ -2996,7 +2991,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t    return true;\n \t\t  }\n \n-\t      /* See comment for purge_addressof_replacements. */\n+\t      /* See comment for purge_addressof_replacements.  */\n \t      for (tem = purge_addressof_replacements;\n \t\t   tem != NULL_RTX;\n \t\t   tem = XEXP (XEXP (tem, 1), 1))\n@@ -3012,17 +3007,17 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t    /* It can happen that the note may speak of things\n \t\t       in a wider (or just different) mode than the\n \t\t       code did.  This is especially true of\n-\t\t       REG_RETVAL. */\n+\t\t       REG_RETVAL.  */\n \n \t\t    if (GET_CODE (z) == SUBREG && SUBREG_WORD (z) == 0)\n \t\t      z = SUBREG_REG (z);\n-\t\t    \n+\n \t\t    if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n \t\t\t&& (GET_MODE_SIZE (GET_MODE (x))\n \t\t\t    > GET_MODE_SIZE (GET_MODE (z))))\n \t\t      {\n \t\t\t/* This can occur as a result in invalid\n-\t\t\t   pointer casts, e.g. float f; ... \n+\t\t\t   pointer casts, e.g. float f; ...\n \t\t\t   *(long long int *)&f.\n \t\t\t   ??? We could emit a warning here, but\n \t\t\t   without a line number that wouldn't be\n@@ -3075,9 +3070,9 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, insn);\n-\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (), \n+\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n \t\t\t\t\t insn, ht);\n-\t      \n+\n \t\t  start_sequence ();\n \t\t  store_bit_field (sub, size_x, 0, GET_MODE (x),\n \t\t\t\t   val, GET_MODE_SIZE (GET_MODE (sub)),\n@@ -3091,7 +3086,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t  end_sequence ();\n \t\t  p = emit_insn_after (seq, insn);\n \t\t  if (NEXT_INSN (insn))\n-\t\t    compute_insns_for_mem (NEXT_INSN (insn), \n+\t\t    compute_insns_for_mem (NEXT_INSN (insn),\n \t\t\t\t\t   p ? NEXT_INSN (p) : NULL_RTX,\n \t\t\t\t\t   ht);\n \t\t}\n@@ -3173,7 +3168,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n       return result;\n     }\n \n-  /* Scan all subexpressions. */\n+  /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n@@ -3249,7 +3244,7 @@ insns_for_mem_walk (r, data)\n      rtx *r;\n      void *data;\n {\n-  struct insns_for_mem_walk_info *ifmwi \n+  struct insns_for_mem_walk_info *ifmwi\n     = (struct insns_for_mem_walk_info *) data;\n \n   if (ifmwi->pass == 0 && *r && GET_CODE (*r) == ADDRESSOF\n@@ -3258,7 +3253,7 @@ insns_for_mem_walk (r, data)\n   else if (ifmwi->pass == 1 && *r && GET_CODE (*r) == REG)\n     {\n       /* Lookup this MEM in the hashtable, creating it if necessary.  */\n-      struct insns_for_mem_entry *ifme \n+      struct insns_for_mem_entry *ifme\n \t= (struct insns_for_mem_entry *) hash_lookup (ifmwi->ht,\n \t\t\t\t\t\t      *r,\n \t\t\t\t\t\t      /*create=*/0,\n@@ -3273,7 +3268,7 @@ insns_for_mem_walk (r, data)\n \t     the hash table since this memory will not be used once\n \t     the hash table is deallocated.  */\n \t  push_obstacks (&ifmwi->ht->memory, &ifmwi->ht->memory);\n-\t  ifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn, \n+\t  ifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn,\n \t\t\t\t\t   ifme->insns);\n \t  pop_obstacks ();\n \t}\n@@ -3308,10 +3303,10 @@ compute_insns_for_mem (insns, last_insn, ht)\n    Returns true iff the rtl is an ADDRESSOF.  */\n static int\n is_addressof (rtl, data)\n-     rtx * rtl;\n-     void * data ATTRIBUTE_UNUSED;\n+     rtx *rtl;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  return GET_CODE (* rtl) == ADDRESSOF;\n+  return GET_CODE (*rtl) == ADDRESSOF;\n }\n \n /* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining\n@@ -3324,15 +3319,15 @@ purge_addressof (insns)\n {\n   rtx insn;\n   struct hash_table ht;\n-  \n+\n   /* When we actually purge ADDRESSOFs, we turn REGs into MEMs.  That\n      requires a fixup pass over the instruction stream to correct\n      INSNs that depended on the REG being a REG, and not a MEM.  But,\n      these fixup passes are slow.  Furthermore, most MEMs are not\n      mentioned in very many instructions.  So, we speed up the process\n      by pre-calculating which REGs occur in which INSNs; that allows\n      us to perform the fixup passes much more quickly.  */\n-  hash_table_init (&ht, \n+  hash_table_init (&ht,\n \t\t   insns_for_mem_newfunc,\n \t\t   insns_for_mem_hash,\n \t\t   insns_for_mem_comp);\n@@ -3347,7 +3342,7 @@ purge_addressof (insns)\n \t  /* If we could not replace the ADDRESSOFs in the insn,\n \t     something is wrong.  */\n \t  abort ();\n-\t\n+\n \tif (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht))\n \t  {\n \t    /* If we could not replace the ADDRESSOFs in the insn's notes,\n@@ -3362,7 +3357,7 @@ purge_addressof (insns)\n \t\t   safe to delete the notes here, and instead we abort.  */\n \t\tif (REG_NOTE_KIND (note) == REG_RETVAL)\n \t\t  abort ();\n-\t\tif (for_each_rtx (& note, is_addressof, NULL))\n+\t\tif (for_each_rtx (&note, is_addressof, NULL))\n \t\t  remove_note (insn, note);\n \t      }\n \t  }\n@@ -3465,7 +3460,7 @@ instantiate_decls (fndecl, valid_only)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));\n \n-      instantiate_decl (DECL_RTL (decl), size, valid_only);\t\n+      instantiate_decl (DECL_RTL (decl), size, valid_only);\n \n       /* If the parameter was promoted, then the incoming RTL mode may be\n \t larger than the declared type size.  We must use the larger of\n@@ -3581,7 +3576,7 @@ instantiate_decl (x, size, valid_only)\n    is not valid.\n \n    Return 1 if we either had nothing to do or if we were able to do the\n-   needed replacement.  Return 0 otherwise; we only return zero if \n+   needed replacement.  Return 0 otherwise; we only return zero if\n    EXTRA_INSNS is zero.\n \n    We first try some simple transformations to avoid the creation of extra\n@@ -3633,15 +3628,15 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t appropriate offset.  This is used, for example, in the handling\n \t of non-local gotos.  */\n       if (SET_DEST (x) == virtual_incoming_args_rtx)\n-\tnew = arg_pointer_rtx, offset = - in_arg_offset;\n+\tnew = arg_pointer_rtx, offset = -in_arg_offset;\n       else if (SET_DEST (x) == virtual_stack_vars_rtx)\n-\tnew = frame_pointer_rtx, offset = - var_offset;\n+\tnew = frame_pointer_rtx, offset = -var_offset;\n       else if (SET_DEST (x) == virtual_stack_dynamic_rtx)\n-\tnew = stack_pointer_rtx, offset = - dynamic_offset;\n+\tnew = stack_pointer_rtx, offset = -dynamic_offset;\n       else if (SET_DEST (x) == virtual_outgoing_args_rtx)\n-\tnew = stack_pointer_rtx, offset = - out_arg_offset;\n+\tnew = stack_pointer_rtx, offset = -out_arg_offset;\n       else if (SET_DEST (x) == virtual_cfa_rtx)\n-\tnew = arg_pointer_rtx, offset = - cfa_offset;\n+\tnew = arg_pointer_rtx, offset = -cfa_offset;\n \n       if (new)\n \t{\n@@ -3697,7 +3692,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t      else if (inner == virtual_outgoing_args_rtx)\n \t\tnew = stack_pointer_rtx, offset = out_arg_offset;\n \t      else if (inner == virtual_cfa_rtx)\n-\t        new = arg_pointer_rtx, offset = cfa_offset;\n+\t\tnew = arg_pointer_rtx, offset = cfa_offset;\n \t      else\n \t\t{\n \t\t  loc = &XEXP (x, 0);\n@@ -3717,8 +3712,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t    new = stack_pointer_rtx, offset = dynamic_offset;\n \t  else if (XEXP (x, 0) == virtual_outgoing_args_rtx)\n \t    new = stack_pointer_rtx, offset = out_arg_offset;\n-          else if (XEXP (x, 0) == virtual_cfa_rtx)\n-            new = arg_pointer_rtx, offset = cfa_offset;\n+\t  else if (XEXP (x, 0) == virtual_cfa_rtx)\n+\t    new = arg_pointer_rtx, offset = cfa_offset;\n \t  else\n \t    {\n \t      /* We know the second operand is a constant.  Unless the\n@@ -3811,12 +3806,12 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n       /* Most cases of MEM that convert to valid addresses have already been\n \t handled by our scan of decls.  The only special handling we\n \t need here is to make a copy of the rtx to ensure it isn't being\n-\t shared if we have to change it to a pseudo. \n+\t shared if we have to change it to a pseudo.\n \n \t If the rtx is a simple reference to an address via a virtual register,\n \t it can potentially be shared.  In such cases, first try to make it\n \t a valid address, which can also be shared.  Otherwise, copy it and\n-\t proceed normally. \n+\t proceed normally.\n \n \t First check for common cases that need no processing.  These are\n \t usually due to instantiation already being done on a previous instance\n@@ -3902,7 +3897,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n     case CLOBBER:\n       /* If the operand is a MEM, see if the change is a valid MEM.  If not,\n \t go ahead and make the invalid one, but do it to a copy.  For a REG,\n-\t just make the recursive call, since there's no chance of a problem. */\n+\t just make the recursive call, since there's no chance of a problem.  */\n \n       if ((GET_CODE (XEXP (x, 0)) == MEM\n \t   && instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 0), XEXP (x, 0),\n@@ -3927,7 +3922,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n       else if (x == virtual_outgoing_args_rtx)\n \tnew = stack_pointer_rtx, offset = out_arg_offset;\n       else if (x == virtual_cfa_rtx)\n-        new = arg_pointer_rtx, offset = cfa_offset;\n+\tnew = arg_pointer_rtx, offset = cfa_offset;\n \n       if (new)\n \t{\n@@ -3964,7 +3959,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t  return 1;\n \t}\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -4136,7 +4131,7 @@ assign_parms (fndecl)\n   tree fnargs = DECL_ARGUMENTS (fndecl);\n   /* This is used for the arg pointer when referring to stack args.  */\n   rtx internal_arg_pointer;\n-  /* This is a dummy PARM_DECL that we used for the function result if \n+  /* This is a dummy PARM_DECL that we used for the function result if\n      the function returns a structure.  */\n   tree function_result_decl = 0;\n #ifdef SETUP_INCOMING_VARARGS\n@@ -4197,7 +4192,7 @@ assign_parms (fndecl)\n       TREE_CHAIN (function_result_decl) = fnargs;\n       fnargs = function_result_decl;\n     }\n-\t\t\t       \n+\n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n   parm_reg_stack_loc = (rtx *) xcalloc (max_parm_reg, sizeof (rtx));\n \n@@ -4357,7 +4352,7 @@ assign_parms (fndecl)\n #endif\n #endif\n \t\t\t   fndecl, &stack_args_size, &stack_offset, &arg_size,\n-                           &alignment_pad);\n+\t\t\t   &alignment_pad);\n \n       {\n \trtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n@@ -4405,7 +4400,7 @@ assign_parms (fndecl)\n \t\temit_group_store (validize_mem (stack_parm), entry_parm,\n \t\t\t\t  int_size_in_bytes (TREE_TYPE (parm)),\n \t\t\t\t  TYPE_ALIGN (TREE_TYPE (parm)));\n-\t\t\t\t  \n+\n \t      else\n \t\tmove_block_from_reg (REGNO (entry_parm),\n \t\t\t\t     validize_mem (stack_parm), nregs,\n@@ -4579,7 +4574,7 @@ assign_parms (fndecl)\n \t    {\n \t      int save_tree_used;\n \t      /* ENTRY_PARM has been converted to PROMOTED_MODE, its\n-\t\t mode, by the caller.  We now have to convert it to \n+\t\t mode, by the caller.  We now have to convert it to\n \t\t NOMINAL_MODE, if different.  However, PARMREG may be in\n \t\t a different mode than NOMINAL_MODE if it is being stored\n \t\t promoted.\n@@ -4692,7 +4687,7 @@ assign_parms (fndecl)\n #endif /* FUNCTION_ARG_CALLEE_COPIES */\n \n \t  /* In any case, record the parm's desired stack location\n-\t     in case we later discover it must live in the stack. \n+\t     in case we later discover it must live in the stack.\n \n \t     If it is a COMPLEX value, store the stack location for both\n \t     halves.  */\n@@ -4781,7 +4776,7 @@ assign_parms (fndecl)\n \t\t  }\n \t      else if ((set = single_set (linsn)) != 0\n \t\t       && SET_DEST (set) == parmreg)\n-\t        REG_NOTES (linsn)\n+\t\tREG_NOTES (linsn)\n \t\t  = gen_rtx_EXPR_LIST (REG_EQUIV,\n \t\t\t\t       stack_parm, REG_NOTES (linsn));\n \t    }\n@@ -4845,7 +4840,7 @@ assign_parms (fndecl)\n \t      push_to_sequence (conversion_insns);\n \t      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t\t XEXP (stack_parm, 0), Pmode,\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (GET_MODE \n+\t\t\t\t GEN_INT (GET_MODE_SIZE (GET_MODE\n \t\t\t\t\t\t\t (entry_parm))),\n \t\t\t\t TYPE_MODE (sizetype),\n \t\t\t\t GEN_INT (MEMORY_USE_RW),\n@@ -4856,7 +4851,7 @@ assign_parms (fndecl)\n \t    }\n \t  DECL_RTL (parm) = stack_parm;\n \t}\n-      \n+\n       /* If this \"parameter\" was the place where we are receiving the\n \t function's incoming structure pointer, set up the result.  */\n       if (parm == function_result_decl)\n@@ -4894,13 +4889,13 @@ assign_parms (fndecl)\n   current_function_args_size\n     = ((current_function_args_size + STACK_BYTES - 1)\n        / STACK_BYTES) * STACK_BYTES;\n-#endif  \n+#endif\n \n #ifdef ARGS_GROW_DOWNWARD\n   current_function_arg_offset_rtx\n     = (stack_args_size.var == 0 ? GEN_INT (-stack_args_size.constant)\n-       : expand_expr (size_diffop (stack_args_size.var,\t\n-\t\t\t\t   size_int (-stack_args_size.constant)),   \n+       : expand_expr (size_diffop (stack_args_size.var,\n+\t\t\t\t   size_int (-stack_args_size.constant)),\n \t\t      NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD));\n #else\n   current_function_arg_offset_rtx = ARGS_SIZE_RTX (stack_args_size);\n@@ -4990,15 +4985,15 @@ promoted_input_arg (regno, pmode, punsignedp)\n    initial offset is not affected by this rounding, while the size always\n    is and the starting offset may be.  */\n \n-/*  offset_ptr will be negative for ARGS_GROW_DOWNWARD case; \n+/*  offset_ptr will be negative for ARGS_GROW_DOWNWARD case;\n     initial_offset_ptr is positive because locate_and_pad_parm's\n     callers pass in the total size of args so far as\n     initial_offset_ptr. arg_size_ptr is always positive.*/\n \n void\n locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \t\t     initial_offset_ptr, offset_ptr, arg_size_ptr,\n-                     alignment_pad)\n+\t\t     alignment_pad)\n      enum machine_mode passed_mode;\n      tree type;\n      int in_regs ATTRIBUTE_UNUSED;\n@@ -5053,7 +5048,7 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n     }\n   else\n     {\n-      offset_ptr->constant = - initial_offset_ptr->constant;\n+      offset_ptr->constant = -initial_offset_ptr->constant;\n       offset_ptr->var = 0;\n     }\n   if (where_pad != none\n@@ -5071,8 +5066,8 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \t\t\t\t    offset_ptr->var);\n \n   else\n-    arg_size_ptr->constant = (- initial_offset_ptr->constant\n-\t\t\t      - offset_ptr->constant); \n+    arg_size_ptr->constant = (-initial_offset_ptr->constant\n+\t\t\t      - offset_ptr->constant);\n \n #else /* !ARGS_GROW_DOWNWARD */\n   pad_to_arg_alignment (initial_offset_ptr, boundary, alignment_pad);\n@@ -5113,7 +5108,7 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n   HOST_WIDE_INT save_constant = 0;\n \n   int boundary_in_bytes = boundary / BITS_PER_UNIT;\n-  \n+\n   if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n     {\n       save_var = offset_ptr->var;\n@@ -5127,9 +5122,9 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n     {\n       if (offset_ptr->var)\n \t{\n-\t  offset_ptr->var  =\n+\t  offset_ptr->var =\n #ifdef ARGS_GROW_DOWNWARD\n-\t    round_down \n+\t    round_down\n #else\n \t    round_up\n #endif\n@@ -5141,16 +5136,16 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n \t\t\t\t\t     save_var);\n \t}\n       else\n-        {\n+\t{\n \t  offset_ptr->constant =\n #ifdef ARGS_GROW_DOWNWARD\n \t    FLOOR_ROUND (offset_ptr->constant, boundary_in_bytes);\n #else\n \t    CEIL_ROUND (offset_ptr->constant, boundary_in_bytes);\n #endif\n-          if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n-            alignment_pad->constant = offset_ptr->constant - save_constant;\n-        }\n+\t    if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n+\t      alignment_pad->constant = offset_ptr->constant - save_constant;\n+\t}\n     }\n }\n \n@@ -5240,7 +5235,8 @@ setjmp_args_warning ()\n     if (DECL_RTL (decl) != 0\n \t&& GET_CODE (DECL_RTL (decl)) == REG\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-      warning_with_decl (decl, \"argument `%s' might be clobbered by `longjmp' or `vfork'\");\n+      warning_with_decl (decl,\n+\t\t\t \"argument `%s' might be clobbered by `longjmp' or `vfork'\");\n }\n \n /* If this function call setjmp, put all vars into the stack\n@@ -5520,7 +5516,7 @@ round_trampoline_addr (tramp)\n \t\t       GEN_INT (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1),\n \t\t       temp, 0, OPTAB_LIB_WIDEN);\n   tramp = expand_binop (Pmode, and_optab, temp,\n-\t\t\tGEN_INT (- TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\tGEN_INT (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT),\n \t\t\ttemp, 0, OPTAB_LIB_WIDEN);\n #endif\n   return tramp;\n@@ -5549,9 +5545,9 @@ identify_blocks ()\n   block_vector = get_block_vector (block, &n_blocks);\n   block_stack = (tree *) xmalloc (n_blocks * sizeof (tree));\n \n-  last_block_vector = identify_blocks_1 (get_insns (), \n+  last_block_vector = identify_blocks_1 (get_insns (),\n \t\t\t\t\t block_vector + 1,\n-\t\t\t\t\t block_vector + n_blocks, \n+\t\t\t\t\t block_vector + n_blocks,\n \t\t\t\t\t block_stack);\n \n   /* If we didn't use all of the subblocks, we've misplaced block notes.  */\n@@ -5605,14 +5601,14 @@ identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n \n \t      NOTE_BLOCK (insn) = *--block_stack;\n \t    }\n-        }\n+\t}\n       else if (GET_CODE (insn) == CALL_INSN\n \t       && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t{\n \t  rtx cp = PATTERN (insn);\n \n-\t  block_vector = identify_blocks_1 (XEXP (cp, 0), block_vector, \n-\t\t\t\t            end_block_vector, block_stack);\n+\t  block_vector = identify_blocks_1 (XEXP (cp, 0), block_vector,\n+\t\t\t\t\t    end_block_vector, block_stack);\n \t  if (XEXP (cp, 1))\n \t    block_vector = identify_blocks_1 (XEXP (cp, 1), block_vector,\n \t\t\t\t\t      end_block_vector, block_stack);\n@@ -5631,7 +5627,7 @@ identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n }\n \n /* Identify BLOCKs referenced by more than one\n-   NOTE_INSN_BLOCK_{BEG,END}, and create duplicate blocks. */\n+   NOTE_INSN_BLOCK_{BEG,END}, and create duplicate blocks.  */\n \n void\n reorder_blocks ()\n@@ -5650,8 +5646,7 @@ reorder_blocks ()\n \n   reorder_blocks_1 (get_insns (), block, &block_stack);\n \n-  BLOCK_SUBBLOCKS (block)\n-    = blocks_nreverse (BLOCK_SUBBLOCKS (block));\n+  BLOCK_SUBBLOCKS (block) = blocks_nreverse (BLOCK_SUBBLOCKS (block));\n \n   VARRAY_FREE (block_stack);\n }\n@@ -5682,7 +5677,7 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n \t\t}\n \t      BLOCK_SUBBLOCKS (block) = 0;\n \t      TREE_ASM_WRITTEN (block) = 1;\n-\t      BLOCK_SUPERCONTEXT (block) = current_block; \n+\t      BLOCK_SUPERCONTEXT (block) = current_block;\n \t      BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n \t      BLOCK_SUBBLOCKS (current_block) = block;\n \t      current_block = block;\n@@ -5748,7 +5743,7 @@ all_blocks (block, vector)\n \tvector[n_blocks] = block;\n \n       ++n_blocks;\n-      \n+\n       /* Record the subblocks, and their subblocks...  */\n       n_blocks += all_blocks (BLOCK_SUBBLOCKS (block),\n \t\t\t      vector ? vector + n_blocks : 0);\n@@ -5762,7 +5757,7 @@ all_blocks (block, vector)\n    number of elements in the vector is stored in N_BLOCKS_P.  The\n    vector is dynamically allocated; it is the caller's responsibility\n    to call `free' on the pointer returned.  */\n-  \n+\n static tree *\n get_block_vector (block, n_blocks_p)\n      tree block;\n@@ -5808,7 +5803,6 @@ number_blocks (fn)\n \n   return;\n }\n-\n \f\n /* Allocate a function structure and reset its contents to the defaults.  */\n static void\n@@ -5851,7 +5845,7 @@ prepare_function_start ()\n   /* Initialize the queue of pending postincrement and postdecrements,\n      and some other info in expr.c.  */\n   init_expr ();\n-  \n+\n   /* We haven't done register allocation yet.  */\n   reg_renumber = 0;\n \n@@ -5860,7 +5854,7 @@ prepare_function_start ()\n   /* Clear out data used for inlining.  */\n   cfun->inlinable = 0;\n   cfun->original_decl_initial = 0;\n-  cfun->original_arg_vector = 0;  \n+  cfun->original_arg_vector = 0;\n \n #ifdef STACK_BOUNDARY\n   cfun->stack_alignment_needed = STACK_BOUNDARY;\n@@ -5962,7 +5956,7 @@ init_function_start (subr, filename, line)\n   /* Remember this function for later.  */\n   cfun->next_global = all_functions;\n   all_functions = cfun;\n-  \n+\n   current_function_name = (*decl_printable_name) (subr, 2);\n   cfun->decl = subr;\n \n@@ -5977,7 +5971,7 @@ init_function_start (subr, filename, line)\n \n   /* Prevent ever trying to delete the first instruction of a function.\n      Also tell final how to output a linenum before the function prologue.\n-     Note linenums could be missing, e.g. when compiling a Java .class file. */\n+     Note linenums could be missing, e.g. when compiling a Java .class file.  */\n   if (line > 0)\n     emit_line_note (filename, line);\n \n@@ -6085,7 +6079,7 @@ expand_function_start (subr, parms_have_cleanups)\n \t conflicts with regs used for parameters.  */\n       if (! SMALL_REGISTER_CLASSES\n \t  || GET_CODE (static_chain_incoming_rtx) == REG)\n-        emit_move_insn (last_ptr, static_chain_incoming_rtx);\n+\temit_move_insn (last_ptr, static_chain_incoming_rtx);\n     }\n \n   /* If the parameters of this function need cleaning up, get a label\n@@ -6237,7 +6231,7 @@ expand_function_start (subr, parms_have_cleanups)\n \t  /* Chain thru stack frames, assuming pointer to next lexical frame\n \t     is found at the place we always store it.  */\n #ifdef FRAME_GROWS_DOWNWARD\n-\t  last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n+\t  last_ptr = plus_constant (last_ptr, -GET_MODE_SIZE (Pmode));\n #endif\n \t  last_ptr = gen_rtx_MEM (Pmode, memory_address (Pmode, last_ptr));\n \t  MEM_ALIAS_SET (last_ptr) = get_frame_alias_set ();\n@@ -6317,7 +6311,7 @@ diddle_return_value (doit, arg)\n     return;\n \n   pcc = (current_function_returns_struct\n-         || current_function_returns_pcc_struct);\n+\t || current_function_returns_pcc_struct);\n \n   if ((GET_CODE (outgoing) == REG\n        && REGNO (outgoing) >= FIRST_PSEUDO_REGISTER)\n@@ -6388,7 +6382,7 @@ use_return_register ()\n }\n \n /* Generate RTL for the end of the current function.\n-   FILENAME and LINE are the current position in the source file. \n+   FILENAME and LINE are the current position in the source file.\n \n    It is up to language-specific callers to do cleanups for parameters--\n    or else, supply 1 for END_BINDINGS and we will call expand_end_bindings.  */\n@@ -6498,7 +6492,7 @@ expand_function_end (filename, line, end_bindings)\n   /* Warn about unused parms if extra warnings were specified.  */\n   /* Either ``-W -Wunused'' or ``-Wunused-parameter'' enables this\n      warning.  WARN_UNUSED_PARAMETER is negative when set by\n-     -Wunused. */\n+     -Wunused.  */\n   if (warn_unused_parameter > 0\n       || (warn_unused_parameter < 0 && extra_warnings))\n     {\n@@ -6658,7 +6652,8 @@ expand_function_end (filename, line, end_bindings)\n   if (current_function_returns_struct\n       || current_function_returns_pcc_struct)\n     {\n-      rtx value_address = XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n+      rtx value_address =\n+\tXEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n #ifdef FUNCTION_OUTGOING_VALUE\n       rtx outgoing\n@@ -6683,7 +6678,7 @@ expand_function_end (filename, line, end_bindings)\n      instead of using the general framework.  */\n   use_return_register ();\n \n-  /* If this is an implementation of __throw, do what's necessary to \n+  /* If this is an implementation of __throw, do what's necessary to\n      communicate between __builtin_eh_return and the epilogue.  */\n   expand_eh_return ();\n \n@@ -6778,7 +6773,7 @@ prologue_epilogue_contains (insn)\n \n int\n sibcall_epilogue_contains (insn)\n-      rtx insn;\n+     rtx insn;\n {\n   if (sibcall_epilogue)\n     return contains (insn, sibcall_epilogue);\n@@ -6796,7 +6791,7 @@ emit_return_into_block (bb, line_note)\n {\n   rtx p, end;\n \n-  p = NEXT_INSN (bb->end); \n+  p = NEXT_INSN (bb->end);\n   end = emit_jump_insn_after (gen_return (), bb->end);\n   if (line_note)\n     emit_line_note_after (NOTE_SOURCE_FILE (line_note),\n@@ -6835,7 +6830,7 @@ thread_prologue_and_epilogue_insns (f)\n   if (HAVE_prologue)\n     {\n       start_sequence ();\n-      seq = gen_prologue();\n+      seq = gen_prologue ();\n       emit_insn (seq);\n \n       /* Retain a map of the prologue insns.  */\n@@ -6865,7 +6860,7 @@ thread_prologue_and_epilogue_insns (f)\n \n   /* If the exit block has no non-fake predecessors, we don't need\n      an epilogue.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     if ((e->flags & EDGE_FAKE) == 0)\n       break;\n   if (e == NULL)\n@@ -6876,15 +6871,15 @@ thread_prologue_and_epilogue_insns (f)\n     {\n       /* If we're allowed to generate a simple return instruction,\n \t then by definition we don't need a full epilogue.  Examine\n-\t the block that falls through to EXIT.   If it does not \n-\t contain any code, examine its predecessors and try to \n+\t the block that falls through to EXIT.   If it does not\n+\t contain any code, examine its predecessors and try to\n \t emit (conditional) return instructions.  */\n \n       basic_block last;\n       edge e_next;\n       rtx label;\n \n-      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n       if (e == NULL)\n@@ -6902,7 +6897,7 @@ thread_prologue_and_epilogue_insns (f)\n \n       if (last->head == label && GET_CODE (label) == CODE_LABEL)\n \t{\n-          rtx epilogue_line_note = NULL_RTX;\n+\t  rtx epilogue_line_note = NULL_RTX;\n \n \t  /* Locate the line number associated with the closing brace,\n \t     if we can find one.  */\n@@ -6915,7 +6910,7 @@ thread_prologue_and_epilogue_insns (f)\n \t\tbreak;\n \t      }\n \n-\t  for (e = last->pred; e ; e = e_next)\n+\t  for (e = last->pred; e; e = e_next)\n \t    {\n \t      basic_block bb = e->src;\n \t      rtx jump;\n@@ -6953,12 +6948,12 @@ thread_prologue_and_epilogue_insns (f)\n \t\t    continue;\n \t\t  if (JUMP_LABEL (jump))\n \t\t    LABEL_NUSES (JUMP_LABEL (jump))--;\n-\t\t\t\t  \n+\n \t\t  /* If this block has only one successor, it both jumps\n \t\t     and falls through to the fallthru block, so we can't\n \t\t     delete the edge.  */\n-   \t\t  if (bb->succ->succ_next == NULL)\n-\t     \t    continue;\n+\t\t  if (bb->succ->succ_next == NULL)\n+\t\t    continue;\n \t\t}\n \t      else\n \t\tcontinue;\n@@ -6973,7 +6968,7 @@ thread_prologue_and_epilogue_insns (f)\n \t  emit_barrier_after (last->end);\n \t  emit_return_into_block (last, epilogue_line_note);\n \t  epilogue_end = last->end;\n-          goto epilogue_done;\n+\t  goto epilogue_done;\n \t}\n     }\n #endif\n@@ -6985,7 +6980,7 @@ thread_prologue_and_epilogue_insns (f)\n \t There really shouldn't be a mixture -- either all should have\n \t been converted or none, however...  */\n \n-      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n       if (e == NULL)\n@@ -7003,7 +6998,7 @@ thread_prologue_and_epilogue_insns (f)\n       record_insns (seq, &epilogue);\n \n       seq = gen_sequence ();\n-      end_sequence();\n+      end_sequence ();\n \n       insert_insn_on_edge (seq, e);\n       inserted = 1;\n@@ -7016,7 +7011,7 @@ thread_prologue_and_epilogue_insns (f)\n \n #ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     {\n       basic_block bb = e->src;\n       rtx insn = bb->end;\n@@ -7057,7 +7052,7 @@ thread_prologue_and_epilogue_insns (f)\n \t note before the end of the first basic block, if there isn't\n \t one already there.  */\n \n-      for (insn = prologue_end; insn ; insn = prev)\n+      for (insn = prologue_end; insn; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n \t  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n@@ -7103,7 +7098,7 @@ thread_prologue_and_epilogue_insns (f)\n       /* Similarly, move any line notes that appear after the epilogue.\n          There is no need, however, to be quite so anal about the existance\n \t of such a note.  */\n-      for (insn = epilogue_end; insn ; insn = next)\n+      for (insn = epilogue_end; insn; insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n \t  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n@@ -7152,7 +7147,7 @@ reposition_prologue_and_epilogue_notes (f)\n \n \t      next = NEXT_INSN (note);\n \n-\t      /* Whether or not we can depend on BLOCK_HEAD, \n+\t      /* Whether or not we can depend on BLOCK_HEAD,\n \t\t attempt to keep it up-to-date.  */\n \t      if (BLOCK_HEAD (0) == note)\n \t\tBLOCK_HEAD (0) = next;\n@@ -7189,7 +7184,7 @@ reposition_prologue_and_epilogue_notes (f)\n \t\t      break;\n \t\t}\n \n-\t      /* Whether or not we can depend on BLOCK_HEAD, \n+\t      /* Whether or not we can depend on BLOCK_HEAD,\n \t\t attempt to keep it up-to-date.  */\n \t      if (n_basic_blocks\n \t\t  && BLOCK_HEAD (n_basic_blocks-1) == insn)\n@@ -7207,7 +7202,7 @@ reposition_prologue_and_epilogue_notes (f)\n \n static void\n mark_temp_slot (t)\n-  struct temp_slot *t;\n+     struct temp_slot *t;\n {\n   while (t)\n     {"}]}