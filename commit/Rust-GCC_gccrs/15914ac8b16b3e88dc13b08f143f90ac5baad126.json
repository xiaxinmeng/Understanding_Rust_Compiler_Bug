{"sha": "15914ac8b16b3e88dc13b08f143f90ac5baad126", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5MTRhYzhiMTZiM2U4OGRjMTNiMDhmMTQzZjkwYWM1YmFhZDEyNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-03-29T19:51:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-03-29T19:51:29Z"}, "message": "parser.c (cp_parser_decltype_expr): Split out...\n\n\t* parser.c (cp_parser_decltype_expr): Split out...\n\t(cp_parser_decltype): ...from here.\n\nFrom-SVN: r197247", "tree": {"sha": "d369d76d2b78fa2141b46e945de7dc701314c1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d369d76d2b78fa2141b46e945de7dc701314c1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15914ac8b16b3e88dc13b08f143f90ac5baad126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15914ac8b16b3e88dc13b08f143f90ac5baad126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15914ac8b16b3e88dc13b08f143f90ac5baad126", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15914ac8b16b3e88dc13b08f143f90ac5baad126/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4185fb7350876f0012455c3dd159f80494081686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4185fb7350876f0012455c3dd159f80494081686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4185fb7350876f0012455c3dd159f80494081686"}], "stats": {"total": 135, "additions": 75, "deletions": 60}, "files": [{"sha": "577740963c9f092be335d86f921c726349823a68", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15914ac8b16b3e88dc13b08f143f90ac5baad126/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15914ac8b16b3e88dc13b08f143f90ac5baad126/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=15914ac8b16b3e88dc13b08f143f90ac5baad126", "patch": "@@ -1,5 +1,8 @@\n 2013-03-29  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.c (cp_parser_decltype_expr): Split out...\n+\t(cp_parser_decltype): ...from here.\n+\n \tPR c++/56774\n \tPR c++/35722\n \t* pt.c (unify_pack_expansion): Fix indexing."}, {"sha": "d36c984d9d57cb9c775cabac405815d5c8b0a5f0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15914ac8b16b3e88dc13b08f143f90ac5baad126/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15914ac8b16b3e88dc13b08f143f90ac5baad126/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=15914ac8b16b3e88dc13b08f143f90ac5baad126", "patch": "@@ -11286,59 +11286,15 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n   finish_static_assert (condition, message, saved_loc, member_p);\n }\n \n-/* Parse a `decltype' type. Returns the type. \n-\n-   simple-type-specifier:\n-     decltype ( expression )  */\n+/* Parse the expression in decltype ( expression ).  */\n \n static tree\n-cp_parser_decltype (cp_parser *parser)\n+cp_parser_decltype_expr (cp_parser *parser,\n+\t\t\t bool &id_expression_or_member_access_p)\n {\n-  tree expr;\n-  bool id_expression_or_member_access_p = false;\n-  const char *saved_message;\n-  bool saved_integral_constant_expression_p;\n-  bool saved_non_integral_constant_expression_p;\n   cp_token *id_expr_start_token;\n-  cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n-\n-  if (start_token->type == CPP_DECLTYPE)\n-    {\n-      /* Already parsed.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      return start_token->u.value;\n-    }\n-\n-  /* Look for the `decltype' token.  */\n-  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, RT_DECLTYPE))\n-    return error_mark_node;\n-\n-  /* Types cannot be defined in a `decltype' expression.  Save away the\n-     old message.  */\n-  saved_message = parser->type_definition_forbidden_message;\n-\n-  /* And create the new one.  */\n-  parser->type_definition_forbidden_message\n-    = G_(\"types may not be defined in %<decltype%> expressions\");\n-\n-  /* The restrictions on constant-expressions do not apply inside\n-     decltype expressions.  */\n-  saved_integral_constant_expression_p\n-    = parser->integral_constant_expression_p;\n-  saved_non_integral_constant_expression_p\n-    = parser->non_integral_constant_expression_p;\n-  parser->integral_constant_expression_p = false;\n-\n-  /* Do not actually evaluate the expression.  */\n-  ++cp_unevaluated_operand;\n-\n-  /* Do not warn about problems with the expression.  */\n-  ++c_inhibit_evaluation_warnings;\n+  tree expr;\n \n-  /* Parse the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n-    return error_mark_node;\n-  \n   /* First, try parsing an id-expression.  */\n   id_expr_start_token = cp_lexer_peek_token (parser->lexer);\n   cp_parser_parse_tentatively (parser);\n@@ -11428,32 +11384,88 @@ cp_parser_decltype (cp_parser *parser)\n     cp_parser_parse_definitely (parser);\n   else\n     {\n-      bool saved_greater_than_is_operator_p;\n-\n       /* Abort our attempt to parse an id-expression or member access\n          expression.  */\n       cp_parser_abort_tentative_parse (parser);\n \n-      /* Within a parenthesized expression, a `>' token is always\n-\t the greater-than operator.  */\n-      saved_greater_than_is_operator_p\n-\t= parser->greater_than_is_operator_p;\n-      parser->greater_than_is_operator_p = true;\n-\n       /* Parse a full expression.  */\n       expr = cp_parser_expression (parser, /*cast_p=*/false,\n \t\t\t\t   /*decltype*/true, NULL);\n+    }\n+\n+  return expr;\n+}\n+\n+/* Parse a `decltype' type. Returns the type.\n+\n+   simple-type-specifier:\n+     decltype ( expression )  */\n \n-      /* The `>' token might be the end of a template-id or\n-\t template-parameter-list now.  */\n-      parser->greater_than_is_operator_p\n-\t= saved_greater_than_is_operator_p;\n+static tree\n+cp_parser_decltype (cp_parser *parser)\n+{\n+  tree expr;\n+  bool id_expression_or_member_access_p = false;\n+  const char *saved_message;\n+  bool saved_integral_constant_expression_p;\n+  bool saved_non_integral_constant_expression_p;\n+  bool saved_greater_than_is_operator_p;\n+  cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (start_token->type == CPP_DECLTYPE)\n+    {\n+      /* Already parsed.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      return start_token->u.value;\n     }\n \n+  /* Look for the `decltype' token.  */\n+  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, RT_DECLTYPE))\n+    return error_mark_node;\n+\n+  /* Parse the opening `('.  */\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return error_mark_node;\n+\n+  /* Types cannot be defined in a `decltype' expression.  Save away the\n+     old message.  */\n+  saved_message = parser->type_definition_forbidden_message;\n+\n+  /* And create the new one.  */\n+  parser->type_definition_forbidden_message\n+    = G_(\"types may not be defined in %<decltype%> expressions\");\n+\n+  /* The restrictions on constant-expressions do not apply inside\n+     decltype expressions.  */\n+  saved_integral_constant_expression_p\n+    = parser->integral_constant_expression_p;\n+  saved_non_integral_constant_expression_p\n+    = parser->non_integral_constant_expression_p;\n+  parser->integral_constant_expression_p = false;\n+\n+  /* Within a parenthesized expression, a `>' token is always\n+     the greater-than operator.  */\n+  saved_greater_than_is_operator_p\n+    = parser->greater_than_is_operator_p;\n+  parser->greater_than_is_operator_p = true;\n+\n+  /* Do not actually evaluate the expression.  */\n+  ++cp_unevaluated_operand;\n+\n+  /* Do not warn about problems with the expression.  */\n+  ++c_inhibit_evaluation_warnings;\n+\n+  expr = cp_parser_decltype_expr (parser, id_expression_or_member_access_p);\n+\n   /* Go back to evaluating expressions.  */\n   --cp_unevaluated_operand;\n   --c_inhibit_evaluation_warnings;\n \n+  /* The `>' token might be the end of a template-id or\n+     template-parameter-list now.  */\n+  parser->greater_than_is_operator_p\n+    = saved_greater_than_is_operator_p;\n+\n   /* Restore the old message and the integral constant expression\n      flags.  */\n   parser->type_definition_forbidden_message = saved_message;"}]}