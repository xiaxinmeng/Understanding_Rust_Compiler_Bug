{"sha": "4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "node_id": "C_kwDOANBUbNoAKDRmMTMxNGY1NDdmNjlkM2EyYjFmMTZjZTMwMTI2N2UzYmZiNGU0Mjc", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2023-01-01T17:00:28Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2023-01-01T17:00:28Z"}, "message": "Add post-reload splitter for extendditi2 on x86_64.\n\nThis is another step towards a possible solution for PR 105137.\nThis patch introduces a define_insn for extendditi2 that allows\nDImode to TImode sign-extension to be represented in the early\nRTL optimizers, before being split post-reload into the exact\nsame idiom as currently produced by RTL expansion.\n\nTypically this produces the identical code, so the first new\ntest case:\n__int128 foo(long long x) { return (__int128)x; }\n\ncontinues to generate:\nfoo:\tmovq    %rdi, %rax\n        cqto\n        ret\n\nThe \"magic\" is that this representation allows combine and the\nother RTL optimizers to do a better job.  Hence, the second\ntest case:\n\n__int128 foo(__int128 a, long long b) {\n    a += ((__int128)b) << 70;\n    return a;\n}\n\nwhich mainline with -O2 currently generates as:\n\nfoo:\tmovq    %rsi, %rax\n        movq    %rdx, %rcx\n        movq    %rdi, %rsi\n        salq    $6, %rcx\n        movq    %rax, %rdi\n        xorl    %eax, %eax\n        movq    %rcx, %rdx\n        addq    %rsi, %rax\n        adcq    %rdi, %rdx\n        ret\n\nwith this patch now becomes:\nfoo:    movl    $0, %eax\n        salq    $6, %rdx\n        addq    %rdi, %rax\n        adcq    %rsi, %rdx\n        ret\n\ni.e. the same code for the signed and unsigned extension variants.\n\n2023-01-01  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog\n\t* config/i386/i386.md (extendditi2): New define_insn.\n\t(define_split): Use DWIH mode iterator to treat new extendditi2\n\tidentically to existing extendsidi2_1.\n\t(define_peephole2): Likewise.\n\t(define_peephole2): Likewise.\n\t(define_Split): Likewise.\n\ngcc/testsuite/ChangeLog\n\t* gcc.target/i386/extendditi2-1.c: New test case.\n\t* gcc.target/i386/extendditi2-2.c: Likewise.", "tree": {"sha": "cd81f61942e259e4949991d71322753d0f895857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd81f61942e259e4949991d71322753d0f895857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d64f877906111645af0217d4d54993a7b2ecbd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f877906111645af0217d4d54993a7b2ecbd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64f877906111645af0217d4d54993a7b2ecbd2e"}], "stats": {"total": 91, "additions": 66, "deletions": 25}, "files": [{"sha": "890c4c839dc66fb86e344b8aeedd28c75d0322aa", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "patch": "@@ -4548,17 +4548,27 @@\n   \"!TARGET_64BIT\"\n   \"#\")\n \n+(define_insn \"extendditi2\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=*A,r,?r,?*o\")\n+\t(sign_extend:TI (match_operand:DI 1 \"register_operand\" \"0,0,r,r\")))\n+   (clobber (reg:CC FLAGS_REG))\n+   (clobber (match_scratch:DI 2 \"=X,X,X,&r\"))]\n+  \"TARGET_64BIT\"\n+  \"#\")\n+\n ;; Split the memory case.  If the source register doesn't die, it will stay\n ;; this way, if it does die, following peephole2s take care of it.\n (define_split\n-  [(set (match_operand:DI 0 \"memory_operand\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\")))\n+  [(set (match_operand:<DWI> 0 \"memory_operand\")\n+\t(sign_extend:<DWI> (match_operand:DWIH 1 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))\n-   (clobber (match_operand:SI 2 \"register_operand\"))]\n+   (clobber (match_operand:DWIH 2 \"register_operand\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\n+  rtx bits = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n+\n+  split_double_mode (<DWI>mode, &operands[0], 1, &operands[3], &operands[4]);\n \n   emit_move_insn (operands[3], operands[1]);\n \n@@ -4567,12 +4577,12 @@\n       && REGNO (operands[1]) == AX_REG\n       && REGNO (operands[2]) == DX_REG)\n     {\n-      emit_insn (gen_ashrsi3_cvt (operands[2], operands[1], GEN_INT (31)));\n+      emit_insn (gen_ashr<mode>3_cvt (operands[2], operands[1], bits));\n     }\n   else\n     {\n       emit_move_insn (operands[2], operands[1]);\n-      emit_insn (gen_ashrsi3_cvt (operands[2], operands[2], GEN_INT (31)));\n+      emit_insn (gen_ashr<mode>3_cvt (operands[2], operands[2], bits));\n     }\n   emit_move_insn (operands[4], operands[2]);\n   DONE;\n@@ -4581,69 +4591,79 @@\n ;; Peepholes for the case where the source register does die, after\n ;; being split with the above splitter.\n (define_peephole2\n-  [(set (match_operand:SI 0 \"memory_operand\")\n-\t(match_operand:SI 1 \"general_reg_operand\"))\n-   (set (match_operand:SI 2 \"general_reg_operand\") (match_dup 1))\n+  [(set (match_operand:DWIH 0 \"memory_operand\")\n+\t(match_operand:DWIH 1 \"general_reg_operand\"))\n+   (set (match_operand:DWIH 2 \"general_reg_operand\") (match_dup 1))\n    (parallel [(set (match_dup 2)\n-\t\t   (ashiftrt:SI (match_dup 2) (const_int 31)))\n+\t\t   (ashiftrt:DWIH (match_dup 2)\n+\t\t\t\t  (match_operand 4 \"const_int_operand\")))\n \t       (clobber (reg:CC FLAGS_REG))])\n-   (set (match_operand:SI 3 \"memory_operand\") (match_dup 2))]\n+   (set (match_operand:DWIH 3 \"memory_operand\") (match_dup 2))]\n   \"REGNO (operands[1]) != REGNO (operands[2])\n+   && INTVAL (operands[4]) == (<MODE_SIZE> * BITS_PER_UNIT - 1)\n    && peep2_reg_dead_p (2, operands[1])\n    && peep2_reg_dead_p (4, operands[2])\n    && !reg_mentioned_p (operands[2], operands[3])\"\n   [(set (match_dup 0) (match_dup 1))\n-   (parallel [(set (match_dup 1) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+   (parallel [(set (match_dup 1) (ashiftrt:DWIH (match_dup 1) (match_dup 4)))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (set (match_dup 3) (match_dup 1))])\n \n (define_peephole2\n-  [(set (match_operand:SI 0 \"memory_operand\")\n-\t(match_operand:SI 1 \"general_reg_operand\"))\n-   (parallel [(set (match_operand:SI 2 \"general_reg_operand\")\n-\t\t   (ashiftrt:SI (match_dup 1) (const_int 31)))\n+  [(set (match_operand:DWIH 0 \"memory_operand\")\n+\t(match_operand:DWIH 1 \"general_reg_operand\"))\n+   (parallel [(set (match_operand:DWIH 2 \"general_reg_operand\")\n+\t\t   (ashiftrt:DWIH (match_dup 1)\n+\t\t\t\t  (match_operand 4 \"const_int_operand\")))\n \t       (clobber (reg:CC FLAGS_REG))])\n-   (set (match_operand:SI 3 \"memory_operand\") (match_dup 2))]\n+   (set (match_operand:DWIH 3 \"memory_operand\") (match_dup 2))]\n   \"/* cltd is shorter than sarl $31, %eax */\n    !optimize_function_for_size_p (cfun)\n    && REGNO (operands[1]) == AX_REG\n    && REGNO (operands[2]) == DX_REG\n+   && INTVAL (operands[4]) == (<MODE_SIZE> * BITS_PER_UNIT - 1)\n    && peep2_reg_dead_p (2, operands[1])\n    && peep2_reg_dead_p (3, operands[2])\n    && !reg_mentioned_p (operands[2], operands[3])\"\n   [(set (match_dup 0) (match_dup 1))\n-   (parallel [(set (match_dup 1) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+   (parallel [(set (match_dup 1) (ashiftrt:DWIH (match_dup 1) (match_dup 4)))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (set (match_dup 3) (match_dup 1))])\n \n ;; Extend to register case.  Optimize case where source and destination\n ;; registers match and cases where we can use cltd.\n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\")))\n+  [(set (match_operand:<DWI> 0 \"register_operand\")\n+\t(sign_extend:<DWI> (match_operand:DWIH 1 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))\n-   (clobber (match_scratch:SI 2))]\n+   (clobber (match_scratch:DWIH 2))]\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\n+  rtx bits = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n+\n+  split_double_mode (<DWI>mode, &operands[0], 1, &operands[3], &operands[4]);\n \n   if (REGNO (operands[3]) != REGNO (operands[1]))\n     emit_move_insn (operands[3], operands[1]);\n \n+  rtx src = operands[1];\n+  if (REGNO (operands[3]) == AX_REG)\n+    src = operands[3];\n+\n   /* Generate a cltd if possible and doing so it profitable.  */\n   if ((optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n-      && REGNO (operands[3]) == AX_REG\n+      && REGNO (src) == AX_REG\n       && REGNO (operands[4]) == DX_REG)\n     {\n-      emit_insn (gen_ashrsi3_cvt (operands[4], operands[3], GEN_INT (31)));\n+      emit_insn (gen_ashr<mode>3_cvt (operands[4], src, bits));\n       DONE;\n     }\n \n   if (REGNO (operands[4]) != REGNO (operands[1]))\n     emit_move_insn (operands[4], operands[1]);\n \n-  emit_insn (gen_ashrsi3_cvt (operands[4], operands[4], GEN_INT (31)));\n+  emit_insn (gen_ashr<mode>3_cvt (operands[4], operands[4], bits));\n   DONE;\n })\n "}, {"sha": "efbad0e92b3de1bcd76e271490a9aab58c1b337c", "filename": "gcc/testsuite/gcc.target/i386/extendditi2-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-1.c?ref=4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2\" } */\n+\n+__int128 foo(long long x)\n+{\n+  return (__int128)x;\n+}\n+/* { dg-final { scan-assembler \"cqt?o\" } } */"}, {"sha": "dbfa6fb90b6eb24d7de0181c7de58385ed89d667", "filename": "gcc/testsuite/gcc.target/i386/extendditi2-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1314f547f69d3a2b1f16ce301267e3bfb4e427/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fextendditi2-2.c?ref=4f1314f547f69d3a2b1f16ce301267e3bfb4e427", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2\" } */\n+\n+__int128 foo(__int128 a, long long b) {\n+    a += ((__int128)b) << 70;\n+    return a;\n+}\n+\n+__int128 bar(__int128 a, unsigned long long b) {\n+    a += ((__int128)b) << 70;\n+    return a;\n+}\n+/* { dg-final { scan-assembler-not \"movq\" } } */"}]}