{"sha": "27a6aa72db18e4db31d278e2c215f2e97003fed9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhNmFhNzJkYjE4ZTRkYjMxZDI3OGUyYzIxNWYyZTk3MDAzZmVkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-01-25T11:08:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-01-25T11:08:38Z"}, "message": "builtins.c (fold_trunc_transparent_mathfn): New function.\n\n\t* builtins.c (fold_trunc_transparent_mathfn): New function.\n\t(fold_builtin): Use it.\n\t* convert.c (convert_to_real): Re-enable code to convert\n\tmath functions; add support for floor familly functions.\n\nFrom-SVN: r61764", "tree": {"sha": "bc0779caa5e2de92be82d96a6cc20c3feba386ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc0779caa5e2de92be82d96a6cc20c3feba386ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27a6aa72db18e4db31d278e2c215f2e97003fed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a6aa72db18e4db31d278e2c215f2e97003fed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a6aa72db18e4db31d278e2c215f2e97003fed9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a6aa72db18e4db31d278e2c215f2e97003fed9/comments", "author": null, "committer": null, "parents": [{"sha": "cd68f4e4c2a39e5cf91a91cde8fddfda4be456b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd68f4e4c2a39e5cf91a91cde8fddfda4be456b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd68f4e4c2a39e5cf91a91cde8fddfda4be456b3"}], "stats": {"total": 143, "additions": 88, "deletions": 55}, "files": [{"sha": "118b147fc760c33aec6ed789745a6ad132856ac0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27a6aa72db18e4db31d278e2c215f2e97003fed9", "patch": "@@ -1,3 +1,10 @@\n+Sat Jan 25 12:05:17 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* builtins.c (fold_trunc_transparent_mathfn): New function.\n+\t(fold_builtin): Use it.\n+\t* convert.c (convert_to_real): Re-enable code to convert\n+\tmath functions; add support for floor familly functions.\n+\n 2003-01-25  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* Makefile.in (cfgloop.o, cfgloopanal.o, cfgloopmanip.o): Add"}, {"sha": "d544410cf0c93bef22ecf562d0c66255eff3ed40", "filename": "gcc/builtins.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=27a6aa72db18e4db31d278e2c215f2e97003fed9", "patch": "@@ -157,6 +157,7 @@ static tree fold_builtin_classify_type\tPARAMS ((tree));\n static tree fold_builtin_inf\t\tPARAMS ((tree, int));\n static tree fold_builtin_nan\t\tPARAMS ((tree, tree, int));\n static int validate_arglist\t\tPARAMS ((tree, ...));\n+static tree fold_trunc_transparent_mathfn PARAMS ((tree));\n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n@@ -4423,6 +4424,36 @@ fold_builtin_nan (arglist, type, quiet)\n   return build_real (type, real);\n }\n \n+/* EXP is assumed to me builtin call where truncation can be propagated\n+   across (for instance floor((double)f) == (double)floorf (f).\n+   Do the transformation.  */\n+static tree\n+fold_trunc_transparent_mathfn (exp)\n+     tree exp;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  if (optimize && validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    {\n+      tree arg0 = strip_float_extensions (TREE_VALUE (arglist));\n+      tree ftype = TREE_TYPE (exp);\n+      tree newtype = TREE_TYPE (arg0);\n+      tree decl;\n+\n+      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (ftype)\n+\t  && (decl = mathfn_built_in (newtype, fcode)))\n+\t{\n+\t  arglist =\n+\t    build_tree_list (NULL_TREE, fold (convert (newtype, arg0)));\n+\t  return convert (ftype,\n+\t\t\t  build_function_call_expr (decl, arglist));\n+\t}\n+    }\n+  return 0;\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -4574,6 +4605,23 @@ fold_builtin (exp)\n     case BUILT_IN_NANSL:\n       return fold_builtin_nan (arglist, TREE_TYPE (TREE_TYPE (fndecl)), false);\n \n+    case BUILT_IN_FLOOR:\n+    case BUILT_IN_FLOORF:\n+    case BUILT_IN_FLOORL:\n+    case BUILT_IN_CEIL:\n+    case BUILT_IN_CEILF:\n+    case BUILT_IN_CEILL:\n+    case BUILT_IN_TRUNC:\n+    case BUILT_IN_TRUNCF:\n+    case BUILT_IN_TRUNCL:\n+    case BUILT_IN_ROUND:\n+    case BUILT_IN_ROUNDF:\n+    case BUILT_IN_ROUNDL:\n+    case BUILT_IN_NEARBYINT:\n+    case BUILT_IN_NEARBYINTF:\n+    case BUILT_IN_NEARBYINTL:\n+      return fold_trunc_transparent_mathfn (exp);\n+\n     default:\n       break;\n     }"}, {"sha": "73db933b97e27b201f23e5b4cba60480a6c2a83a", "filename": "gcc/convert.c", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a6aa72db18e4db31d278e2c215f2e97003fed9/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=27a6aa72db18e4db31d278e2c215f2e97003fed9", "patch": "@@ -127,13 +127,11 @@ tree\n convert_to_real (type, expr)\n      tree type, expr;\n {\n+  enum built_in_function fcode = builtin_mathfn_code (expr);\n   tree itype = TREE_TYPE (expr);\n \n   /* Disable until we figure out how to decide whether the functions are\n      present in runtime.  */\n-#if 0\n-  enum built_in_function fcode = builtin_mathfn_code (expr);\n-\n   /* Convert (float)sqrt((double)x) where x is float into sqrtf(x) */\n   if ((fcode == BUILT_IN_SQRT\n        || fcode == BUILT_IN_SQRTL\n@@ -155,72 +153,52 @@ convert_to_real (type, expr)\n       if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))\n \tnewtype = TREE_TYPE (arg0);\n \n-      /* Be careful about integer to fp conversions.\n+      /* Be curefull about integer to fp conversions.\n \t These may overflow still.  */\n       if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t  && TYPE_PRECISION (newtype) <= TYPE_PRECISION (itype)\n+\t  && TYPE_PRECISION (newtype) < TYPE_PRECISION (itype)\n \t  && (TYPE_MODE (newtype) == TYPE_MODE (double_type_node)\n \t      || TYPE_MODE (newtype) == TYPE_MODE (float_type_node)))\n \t{\n \t  tree arglist;\n-\t  if (TYPE_MODE (type) == TYPE_MODE (float_type_node))\n-\t    switch (fcode)\n-\t      {\n-\t      case BUILT_IN_SQRT:\n-\t      case BUILT_IN_SQRTL:\n-\t\tfcode = BUILT_IN_SQRTF;\n-\t\tbreak;\n-\t      case BUILT_IN_SIN:\n-\t      case BUILT_IN_SINL:\n-\t\tfcode = BUILT_IN_SINF;\n-\t\tbreak;\n-\t      case BUILT_IN_COS:\n-\t      case BUILT_IN_COSL:\n-\t\tfcode = BUILT_IN_COSF;\n-\t\tbreak;\n-\t      case BUILT_IN_EXP:\n-\t      case BUILT_IN_EXPL:\n-\t\tfcode = BUILT_IN_EXPF;\n-\t\tbreak;\n-\t      default:\n-\t\tabort ();\n-\t      }\n-\t  else\n-\t    switch (fcode)\n-\t      {\n-\t      case BUILT_IN_SQRT:\n-\t      case BUILT_IN_SQRTL:\n-\t\tfcode = BUILT_IN_SQRT;\n-\t\tbreak;\n-\t      case BUILT_IN_SIN:\n-\t      case BUILT_IN_SINL:\n-\t\tfcode = BUILT_IN_SIN;\n-\t\tbreak;\n-\t      case BUILT_IN_COS:\n-\t      case BUILT_IN_COSL:\n-\t\tfcode = BUILT_IN_COS;\n-\t\tbreak;\n-\t      case BUILT_IN_EXP:\n-\t      case BUILT_IN_EXPL:\n-\t\tfcode = BUILT_IN_EXP;\n-\t\tbreak;\n-\t      default:\n-\t\tabort ();\n-\t      }\n+\t  tree fn = mathfn_built_in (newtype, fcode);\n \n-\t  /* ??? Fortran frontend does not initialize built_in_decls.\n-\t     For some reason creating the decl using builtin_function does not\n-\t     work as it should.  */\n-\t  if (built_in_decls [fcode])\n+\t  if (fn)\n \t    {\n \t      arglist = build_tree_list (NULL_TREE, fold (convert_to_real (newtype, arg0)));\n-\t      expr = build_function_call_expr (built_in_decls [fcode], arglist);\n+\t      expr = build_function_call_expr (fn, arglist);\n \t      if (newtype == type)\n \t\treturn expr;\n \t    }\n \t}\n     }\n-#endif\n+  if (optimize\n+      && (((fcode == BUILT_IN_FLOORL\n+\t   || fcode == BUILT_IN_CEILL\n+\t   || fcode == BUILT_IN_ROUND\n+\t   || fcode == BUILT_IN_TRUNC\n+\t   || fcode == BUILT_IN_NEARBYINT)\n+\t  && (TYPE_MODE (type) == TYPE_MODE (double_type_node)\n+\t      || TYPE_MODE (type) == TYPE_MODE (float_type_node)))\n+\t  || ((fcode == BUILT_IN_FLOOR\n+\t       || fcode == BUILT_IN_CEIL\n+\t       || fcode == BUILT_IN_ROUND\n+\t       || fcode == BUILT_IN_TRUNC\n+\t       || fcode == BUILT_IN_NEARBYINT)\n+\t      && (TYPE_MODE (type) == TYPE_MODE (float_type_node)))))\n+    {\n+      tree fn = mathfn_built_in (type, fcode);\n+\n+      if (fn)\n+\t{\n+\t  tree arg0 = strip_float_extensions (TREE_VALUE (TREE_OPERAND (expr,\n+\t\t\t\t\t  \t\t\t\t1)));\n+\t  tree arglist = build_tree_list (NULL_TREE,\n+\t\t\t  \t\t  fold (convert_to_real (type, arg0)));\n+\n+\t  return build_function_call_expr (fn, arglist);\n+\t}\n+    }\n \n   /* Propagate the cast into the operation.  */\n   if (itype != type && FLOAT_TYPE_P (type))"}]}