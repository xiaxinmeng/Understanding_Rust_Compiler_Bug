{"sha": "4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjMWQ0NjIwMTNjNWZjYWE4MmIwYWQ4MmI0MjMyYmMxMjQ5YjMxYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-08-04T09:07:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-08-04T09:07:51Z"}, "message": "cp-tree.h (empty_except_spec): New global var.\n\n\t* cp-tree.h (empty_except_spec): New global var.\n\t(compexcepttypes): Remove prototype.\n\t(comp_except_specs): Prototype new global function.\n\t(add_exception_specifier): Prototype new global function.\n\t* decl.c (empty_except_spec): Define new global var.\n\t(duplicate_decls): Use comp_except_specs, reword error message.\n\t(init_decl_processing): Initialize empty_except_spec.\n\tAdjust build_exception_variant calls.\n\t* parse.y (exception_specification_opt): Use empty_except_spec.\n\t(ansi_raise_identifier): Call check_for_new_type.\n\t(ansi_raise_identifiers): Use add_exception_specifier.\n\t* pt.c (tsubst): Use add_exception_specifier to build exception\n\tspecifier.\n\t* search.c (check_final_overrider): New static function, broken\n\tout of get_matching_virtual. Check throw specifiers, reword\n\tdiagnostics.\n\t(get_matching_virtual): Use check_final_overrider.\n\t* tree.c (build_exception_variant): Use comp_except_specs.\n\t* typeck.c (compexcepttypes): Remove.\n\t(comp_except_types): New static function, helper for\n\tcomp_except_specs. Compare two types as exception specifiers.\n\t(comp_except_specs): New global function, compare two exception\n\tspecifiers.\n\t(comptypes): Adjust for comp_except_specs.\n\t* typeck2.c (add_exception_specifier): New global function.\n\n\t* class.c (check_for_override): Reword error message.\n\nFrom-SVN: r28494", "tree": {"sha": "eed4f20cf661ebad7e1110d70a77ace73ecd7837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eed4f20cf661ebad7e1110d70a77ace73ecd7837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc3c01c50781c5306a57c974c84e767479e59f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3c01c50781c5306a57c974c84e767479e59f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3c01c50781c5306a57c974c84e767479e59f73"}], "stats": {"total": 360, "additions": 284, "deletions": 76}, "files": [{"sha": "3617a86eb47893ce63343ba300fd092a72caa9ed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -1,3 +1,33 @@\n+1999-08-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (empty_except_spec): New global var.\n+\t(compexcepttypes): Remove prototype.\n+\t(comp_except_specs): Prototype new global function.\n+\t(add_exception_specifier): Prototype new global function.\n+\t* decl.c (empty_except_spec): Define new global var.\n+\t(duplicate_decls): Use comp_except_specs, reword error message.\n+\t(init_decl_processing): Initialize empty_except_spec.\n+\tAdjust build_exception_variant calls.\n+\t* parse.y (exception_specification_opt): Use empty_except_spec.\n+\t(ansi_raise_identifier): Call check_for_new_type.\n+\t(ansi_raise_identifiers): Use add_exception_specifier.\n+\t* pt.c (tsubst): Use add_exception_specifier to build exception\n+\tspecifier.\n+\t* search.c (check_final_overrider): New static function, broken\n+\tout of get_matching_virtual. Check throw specifiers, reword\n+\tdiagnostics.\n+\t(get_matching_virtual): Use check_final_overrider.\n+\t* tree.c (build_exception_variant): Use comp_except_specs.\n+\t* typeck.c (compexcepttypes): Remove.\n+\t(comp_except_types): New static function, helper for\n+\tcomp_except_specs. Compare two types as exception specifiers.\n+\t(comp_except_specs): New global function, compare two exception\n+\tspecifiers.\n+\t(comptypes): Adjust for comp_except_specs.\n+\t* typeck2.c (add_exception_specifier): New global function.\n+\t\n+\t* class.c (check_for_override): Reword error message.\n+\n 1999-08-03  Nathan Sidwell  <nathan@acm.org>\n \n \t* call.c (convert_arg_to_ellipsis): Use pod_type_p."}, {"sha": "4f7172bc2be51283ee9b4a60a50ec5156c65bcb3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -2977,9 +2977,8 @@ check_for_override (decl, ctype)\n \t\t path to its virtual baseclass.  */\n \t      if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n \t\t{\n-\t\t  cp_error_at (\"method `%D' may not be declared static\",\n-\t\t\t       decl);\n-\t\t  cp_error_at (\"(since `%D' declared virtual in base class.)\",\n+\t\t  cp_error_at (\"`static %#D' cannot be declared\", decl);\n+\t\t  cp_error_at (\"  since `virtual %#D' declared in base class\",\n \t\t\t       tmp);\n \t\t  break;\n \t\t}"}, {"sha": "5c7f73736537a56cc708a660402acc525bd8b07e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -2288,6 +2288,7 @@ extern tree delta2_identifier;\n extern tree pfn_or_delta2_identifier;\n extern tree tag_identifier;\n extern tree vt_off_identifier;\n+extern tree empty_except_spec;\n \n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n@@ -3533,7 +3534,7 @@ extern int fntype_p\t\t\t\tPROTO((tree));\n extern tree commonparms\t\t\t\tPROTO((tree, tree));\n extern tree original_type\t\t\tPROTO((tree));\n extern tree common_type\t\t\t\tPROTO((tree, tree));\n-extern int compexcepttypes\t\t\tPROTO((tree, tree));\n+extern int comp_except_specs\t\t\tPROTO((tree, tree, int));\n extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern int compparms\t\t\t\tPROTO((tree, tree));\n@@ -3618,6 +3619,7 @@ extern tree build_functional_cast\t\tPROTO((tree, tree));\n extern char *enum_name_string\t\t\tPROTO((tree, tree));\n extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n extern void check_for_new_type\t\t\tPROTO((const char *, flagged_type_tree));\n+extern tree add_exception_specifier             PROTO((tree, tree, int));\n \n /* in xref.c */\n extern void GNU_xref_begin\t\t\tPROTO((const char *));"}, {"sha": "6702f2c5edbe3f5f8cd607a7f9312415a8afb5c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -336,6 +336,9 @@ tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n tree pfn_or_delta2_identifier, tag_identifier;\n tree vt_off_identifier;\n \n+/* Exception specifier used for throw().  */\n+tree empty_except_spec;\n+\n struct named_label_list\n {\n   struct binding_level *binding_level;\n@@ -3478,11 +3481,12 @@ duplicate_decls (newdecl, olddecl)\n \t  if ((pedantic || ! DECL_IN_SYSTEM_HEADER (olddecl))\n \t      && DECL_SOURCE_LINE (olddecl) != 0\n \t      && flag_exceptions\n-\t      && ! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n+\t      && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl)),\n+\t                             TYPE_RAISES_EXCEPTIONS (TREE_TYPE (olddecl)), 1))\n \t    {\n-\t      cp_pedwarn (\"declaration of `%D' throws different exceptions\",\n+\t      cp_error (\"declaration of `%F' throws different exceptions\",\n \t\t\tnewdecl);\n-\t      cp_pedwarn_at (\"previous declaration here\", olddecl);\n+\t      cp_error_at (\"to previous declaration `%F'\", olddecl);\n \t    }\n \t}\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n@@ -6361,6 +6365,7 @@ init_decl_processing ()\n   const_string_type_node\n     = build_pointer_type (build_qualified_type (char_type_node, \n \t\t\t\t\t\tTYPE_QUAL_CONST));\n+  empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n #endif\n@@ -6400,8 +6405,7 @@ init_decl_processing ()\n   c_common_nodes_and_builtins (1, flag_no_builtin, flag_no_nonansi_builtin);\n \n   void_ftype_ptr\n-    = build_exception_variant (void_ftype_ptr,\n-\t\t\t       tree_cons (NULL_TREE, NULL_TREE, NULL_TREE));\n+    = build_exception_variant (void_ftype_ptr, empty_except_spec);\n \n   /* C++ extensions */\n \n@@ -6547,9 +6551,8 @@ init_decl_processing ()\n     if (flag_honor_std)\n       pop_namespace ();\n     newtype = build_exception_variant\n-      (ptr_ftype_sizetype, build_tree_list (NULL_TREE, bad_alloc_type_node));\n-    deltype = build_exception_variant\n-      (void_ftype_ptr, build_tree_list (NULL_TREE, NULL_TREE));\n+      (ptr_ftype_sizetype, add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1));\n+    deltype = build_exception_variant (void_ftype_ptr, empty_except_spec);\n     auto_function (ansi_opname[(int) NEW_EXPR], newtype, NOT_BUILT_IN);\n     auto_function (ansi_opname[(int) VEC_NEW_EXPR], newtype, NOT_BUILT_IN);\n     global_delete_fndecl"}, {"sha": "1fd3c5a1bf048be28263e7c1dbfc9a513fad9222", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -3685,21 +3685,22 @@ exception_specification_opt:\n \t| THROW '(' ansi_raise_identifiers  ')'  %prec EMPTY\n \t\t{ $$ = $3; }\n \t| THROW LEFT_RIGHT  %prec EMPTY\n-\t\t{ $$ = build_decl_list (NULL_TREE, NULL_TREE); }\n+\t\t{ $$ = empty_except_spec; }\n \t;\n \n ansi_raise_identifier:\n \t  type_id\n-\t\t{ $$ = build_decl_list (NULL_TREE, groktypename($1.t)); }\n+\t\t{\n+\t\t  check_for_new_type (\"exception specifier\", $1);\n+\t\t  $$ = groktypename ($1.t);\n+\t\t}\n \t;\n \n ansi_raise_identifiers:\n \t  ansi_raise_identifier\n+\t\t{ $$ = add_exception_specifier (NULL_TREE, $1, 1); }\n \t| ansi_raise_identifiers ',' ansi_raise_identifier\n-\t\t{\n-\t\t  TREE_CHAIN ($3) = $$;\n-\t\t  $$ = $3;\n-\t\t}\n+\t\t{ $$ = add_exception_specifier ($1, $3, 1); }\n \t;\n \n conversion_declarator:"}, {"sha": "b516cb9981f30f580eb9922d9a0fd35a70445689", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -3937,6 +3937,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  type_decl = build_decl (TYPE_DECL, DECL_NAME (template), t);\n \t  SET_DECL_ARTIFICIAL (type_decl);\n \t  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n+\t  \n \t  DECL_SOURCE_FILE (type_decl) \n \t    = DECL_SOURCE_FILE (TYPE_STUB_DECL (template_type));\n \t  DECL_SOURCE_LINE (type_decl) \n@@ -6499,10 +6500,21 @@ tsubst (t, args, complain, in_decl)\n \traises = TYPE_RAISES_EXCEPTIONS (t);\n \tif (raises)\n \t  {\n-\t    raises = tsubst (raises, args, complain, in_decl);\n-\t    if (raises == error_mark_node)\n-\t      return raises;\n-\t    fntype = build_exception_variant (fntype, raises);\n+\t    tree   list = NULL_TREE;\n+\t    \n+\t    if (! TREE_VALUE (raises))\n+\t      list = raises;\n+\t    else\n+\t      for (; raises != NULL_TREE; raises = TREE_CHAIN (raises))\n+\t        {\n+\t          tree spec = TREE_VALUE (raises);\n+\t          \n+\t          spec = tsubst (spec, args, complain, in_decl);\n+\t          if (spec == error_mark_node)\n+\t            return spec;\n+\t          list = add_exception_specifier (list, spec, complain);\n+\t        }\n+\t    fntype = build_exception_variant (fntype, list);\n \t  }\n \treturn fntype;\n       }"}, {"sha": "14e1ce9db4e7fc758ec05158697a37f4ac313494", "filename": "gcc/cp/search.c", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -117,6 +117,7 @@ static tree get_virtuals_named_this PROTO((tree, tree));\n static tree get_virtual_destructor PROTO((tree, void *));\n static tree tree_has_any_destructor_p PROTO((tree, void *));\n static int covariant_return_p PROTO((tree, tree));\n+static int check_final_overrider PROTO((tree, tree));\n static struct search_level *push_search_level\n \tPROTO((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n@@ -1884,6 +1885,63 @@ covariant_return_p (brettype, drettype)\n   return 1;\n }\n \n+/* Check that virtual overrider OVERRIDER is acceptable for base function\n+   BASEFN. Issue diagnostic, and return zero, if unacceptable.  */\n+\n+int\n+check_final_overrider (overrider, basefn)\n+     tree overrider, basefn;\n+{\n+  tree over_type = TREE_TYPE (overrider);\n+  tree base_type = TREE_TYPE (basefn);\n+  tree over_return = TREE_TYPE (over_type);\n+  tree base_return = TREE_TYPE (base_type);\n+  tree over_throw = TYPE_RAISES_EXCEPTIONS (over_type);\n+  tree base_throw = TYPE_RAISES_EXCEPTIONS (base_type);\n+  int i;\n+  \n+  if (same_type_p (base_return, over_return))\n+    /* OK */;\n+  else if ((i = covariant_return_p (base_return, over_return)))\n+    {\n+      if (i == 2)\n+\tsorry (\"adjusting pointers for covariant returns\");\n+\n+      if (pedantic && i == -1)\n+\t{\n+\t  cp_pedwarn_at (\"invalid covariant return type for `virtual %#D'\", overrider);\n+\t  cp_pedwarn_at (\"  overriding `virtual %#D' (must be pointer or reference to class)\", basefn);\n+\t}\n+    }\n+  else if (IS_AGGR_TYPE_2 (base_return, over_return)\n+\t   && same_or_base_type_p (base_return, over_return))\n+    {\n+      cp_error_at (\"invalid covariant return type for `virtual %#D'\", overrider);\n+      cp_error_at (\"  overriding `virtual %#D' (must use pointer or reference)\", basefn);\n+      return 0;\n+    }\n+  else if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (overrider)) == NULL_TREE)\n+    {\n+      cp_error_at (\"conflicting return type specified for `virtual %#D'\", overrider);\n+      cp_error_at (\"  overriding `virtual %#D'\", basefn);\n+      SET_IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (overrider),\n+                                  DECL_CLASS_CONTEXT (overrider));\n+      return 0;\n+    }\n+  \n+  /* Check throw specifier is subset.  */\n+  /* XXX At the moment, punt on an overriding artificial function. We\n+     don't generate its exception specifier, so can't check it properly.  */\n+  if (! DECL_ARTIFICIAL (overrider)\n+      && !comp_except_specs (base_throw, over_throw, 0))\n+    {\n+      cp_error_at (\"looser throw specifier for `virtual %#F'\", overrider);\n+      cp_error_at (\"  overriding `virtual %#F'\", basefn);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n /* Given a class type TYPE, and a function decl FNDECL, look for a\n    virtual function in TYPE's hierarchy which FNDECL could match as a\n    virtual function.  It doesn't matter which one we find.\n@@ -1897,7 +1955,6 @@ get_matching_virtual (binfo, fndecl, dtorp)\n      int dtorp;\n {\n   tree tmp = NULL_TREE;\n-  int i;\n \n   if (TREE_CODE (fndecl) == TEMPLATE_DECL)\n     /* In [temp.mem] we have:\n@@ -1914,9 +1971,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n   else\n     {\n       tree drettype, dtypes, btypes, instptr_type;\n-      tree basetype = DECL_CLASS_CONTEXT (fndecl);\n       tree baselink, best = NULL_TREE;\n-      tree name = DECL_ASSEMBLER_NAME (fndecl);\n       tree declarator = DECL_NAME (fndecl);\n       if (IDENTIFIER_VIRTUAL_P (declarator) == 0)\n \treturn NULL_TREE;\n@@ -1958,33 +2013,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t   == TYPE_QUALS (instptr_type))\n \t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n \t\t{\n-\t\t  tree brettype = TREE_TYPE (TREE_TYPE (tmp));\n-\t\t  if (same_type_p (brettype, drettype))\n-\t\t    /* OK */;\n-\t\t  else if ((i = covariant_return_p (brettype, drettype)))\n-\t\t    {\n-\t\t      if (i == 2)\n-\t\t\tsorry (\"adjusting pointers for covariant returns\");\n-\n-\t\t      if (pedantic && i == -1)\n-\t\t\t{\n-\t\t\t  cp_pedwarn_at (\"invalid covariant return type for `%#D' (must be pointer or reference to class)\", fndecl);\n-\t\t\t  cp_pedwarn_at (\"  overriding `%#D'\", tmp);\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (IS_AGGR_TYPE_2 (brettype, drettype)\n-\t\t\t   && same_or_base_type_p (brettype, drettype))\n-\t\t    {\n-\t\t      error (\"invalid covariant return type (must use pointer or reference)\");\n-\t\t      cp_error_at (\"  overriding `%#D'\", tmp);\n-\t\t      cp_error_at (\"  with `%#D'\", fndecl);\n-\t\t    }\n-\t\t  else if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE)\n-\t\t    {\n-\t\t      cp_error_at (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n-\t\t      cp_error_at (\"  overriding definition as `%#D'\", tmp);\n-\t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n-\t\t    }\n+\t          check_final_overrider (fndecl, tmp);\n \n \t\t  /* FNDECL overrides this function.  We continue to\n \t\t     check all the other functions in order to catch"}, {"sha": "f40632afc330c082e8dd01ee735ec882138f5f44", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -1484,25 +1484,9 @@ build_exception_variant (type, raises)\n   int type_quals = TYPE_QUALS (type);\n \n   for (; v; v = TYPE_NEXT_VARIANT (v))\n-    {\n-      tree t;\n-      tree u;\n-\n-      if (TYPE_QUALS (v) != type_quals)\n-\tcontinue;\n-\n-      for (t = TYPE_RAISES_EXCEPTIONS (v), u = raises;\n-\t   t != NULL_TREE && u != NULL_TREE;\n-\t   t = TREE_CHAIN (t), u = TREE_CHAIN (u))\n-\tif (((TREE_VALUE (t) != NULL_TREE) \n-\t     != (TREE_VALUE (u) != NULL_TREE))\n-\t    || !same_type_p (TREE_VALUE (t), TREE_VALUE (u)))\n-\t  break;\n-\n-      if (!t && !u)\n-\t/* There's a memory leak here; RAISES is not freed.  */\n-\treturn v;\n-    }\n+    if (TYPE_QUALS (v) == type_quals\n+        && comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), 1))\n+      return v;\n \n   /* Need to build a new variant.  */\n   v = build_type_copy (type);"}, {"sha": "03bc2c09f0c418f23a99ef2a33333964f4fd3806", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 100, "deletions": 5, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -48,6 +48,7 @@ static int comp_target_parms PROTO((tree, tree, int));\n static int comp_ptr_ttypes_real PROTO((tree, tree, int));\n static int comp_ptr_ttypes_const PROTO((tree, tree));\n static int comp_ptr_ttypes_reinterpret PROTO((tree, tree));\n+static int comp_except_types PROTO((tree, tree, int));\n static int comp_array_types PROTO((int (*) (tree, tree, int), tree,\n \t\t\t\t   tree, int));\n static tree common_base_type PROTO((tree, tree));\n@@ -853,13 +854,102 @@ common_type (t1, t2)\n     }\n }\n \f\n-/* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */\n+/* Compare two exception specifier types for exactness or subsetness, if\n+   allowed. Returns 0 for mismatch, 1 for same, 2 if B is allowed by A.\n+ \n+   [except.spec] \"If a class X ... objects of class X or any class publicly\n+   and unambigously derrived from X. Similarly, if a pointer type Y * ...\n+   exceptions of type Y * or that are pointers to any type publicly and\n+   unambigously derrived from Y. Otherwise a function only allows exceptions\n+   that have the same type ...\"\n+   This does not mention cv qualifiers and is different to what throw\n+   [except.throw] and catch [except.catch] will do. They will ignore the\n+   top level cv qualifiers, and allow qualifiers in the pointer to class\n+   example.\n+   \n+   We implement the letter of the standard.  */\n+\n+static int\n+comp_except_types (a, b, exact)\n+     tree a, b;\n+     int exact;\n+{\n+  if (same_type_p (a, b))\n+    return 1;\n+  else if (!exact)\n+    {\n+      if (CP_TYPE_QUALS (a) || CP_TYPE_QUALS (b))\n+        return 0;\n+      \n+      if (TREE_CODE (a) == POINTER_TYPE\n+          && TREE_CODE (b) == POINTER_TYPE)\n+        {\n+          a = TREE_TYPE (a);\n+          b = TREE_TYPE (b);\n+          if (CP_TYPE_QUALS (a) || CP_TYPE_QUALS (b))\n+            return 0;\n+        }\n+      \n+      if (TREE_CODE (a) != RECORD_TYPE\n+          || TREE_CODE (b) != RECORD_TYPE)\n+        return 0;\n+      \n+      if (ACCESSIBLY_UNIQUELY_DERIVED_P (a, b))\n+        return 2;\n+    }\n+  return 0;\n+}\n+\n+/* Return 1 if TYPE1 and TYPE2 are equivalent exception specifiers.\n+   If EXACT is 0, T2 can be a subset of T1 (according to 15.4/7),\n+   otherwise it must be exact. Exception lists are unordered, but\n+   we've already filtered out duplicates. Most lists will be in order,\n+   we should try to make use of that.  */\n \n int\n-compexcepttypes (t1, t2)\n+comp_except_specs (t1, t2, exact)\n      tree t1, t2;\n+     int exact;\n {\n-  return TYPE_RAISES_EXCEPTIONS (t1) == TYPE_RAISES_EXCEPTIONS (t2);\n+  tree probe;\n+  tree base;\n+  int  length = 0;\n+\n+  if (t1 == t2)\n+    return 1;\n+  \n+  if (t1 == NULL_TREE)              /* T1 is ... */\n+    return t2 == NULL_TREE || !exact;\n+  if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n+    return t2 != NULL_TREE && !TREE_VALUE (t2);\n+  if (t2 == NULL_TREE)              /* T2 is ... */\n+    return 0;\n+  if (TREE_VALUE(t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n+    return !exact;\n+  \n+  /* Neither set is ... or EMPTY, make sure each part of T2 is in T1.\n+     Count how many we find, to determine exactness. For exact matching and\n+     ordered T1, T2, this is an O(n) operation, otherwise its worst case is\n+     O(nm).  */\n+  for (base = t1; t2 != NULL_TREE; t2 = TREE_CHAIN (t2))\n+    {\n+      for (probe = base; probe != NULL_TREE; probe = TREE_CHAIN (probe))\n+        {\n+          tree a = TREE_VALUE (probe);\n+          tree b = TREE_VALUE (t2);\n+          \n+          if (comp_except_types (a, b, exact))\n+            {\n+              if (probe == base && exact)\n+                base = TREE_CHAIN (probe);\n+              length++;\n+              break;\n+            }\n+        }\n+      if (probe == NULL_TREE)\n+        return 0;\n+    }\n+  return !exact || base == NULL_TREE || length == list_length (t1);\n }\n \n /* Compare the array types T1 and T2, using CMP as the type comparison\n@@ -1031,7 +1121,8 @@ comptypes (t1, t2, strict)\n       break;\n \n     case METHOD_TYPE:\n-      if (! compexcepttypes (t1, t2))\n+      if (! comp_except_specs (TYPE_RAISES_EXCEPTIONS (t1),\n+                             TYPE_RAISES_EXCEPTIONS (t2), 1))\n \treturn 0;\n \n       /* This case is anti-symmetrical!\n@@ -1058,7 +1149,8 @@ comptypes (t1, t2, strict)\n       break;\n \n     case FUNCTION_TYPE:\n-      if (! compexcepttypes (t1, t2))\n+      if (! comp_except_specs (TYPE_RAISES_EXCEPTIONS (t1),\n+                             TYPE_RAISES_EXCEPTIONS (t2), 1))\n \treturn 0;\n \n       val = ((TREE_TYPE (t1) == TREE_TYPE (t2)\n@@ -2175,6 +2267,9 @@ build_component_ref (datum, component, basetype_path, protect)\n       tree name = component;\n       if (TREE_CODE (component) == VAR_DECL)\n \tname = DECL_NAME (component);\n+      if (TREE_CODE (component) == NAMESPACE_DECL)\n+        /* Source is in error, but produce a sensible diagnostic.  */\n+        name = DECL_NAME (component);\n       if (basetype_path == NULL_TREE)\n \tbasetype_path = TYPE_BINFO (basetype);\n       field = lookup_field (basetype_path, name,"}, {"sha": "cce836cfbbf2ba3451248702fe5fe72a12e2dc95", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc1d462013c5fcaa82b0ad82b4232bc1249b31c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4cc1d462013c5fcaa82b0ad82b4232bc1249b31c", "patch": "@@ -1520,3 +1520,56 @@ check_for_new_type (string, inptree)\n       && (pedantic || strcmp (string, \"cast\") != 0))\n     pedwarn (\"ANSI C++ forbids defining types within %s\",string);\n }\n+\n+/* Add new exception specifier SPEC, to the LIST we currently have.\n+   If it's already in LIST then do nothing.\n+   Moan if it's bad and we're allowed to. COMPLAIN < 0 means we\n+   know what we're doing.  */\n+\n+tree\n+add_exception_specifier (list, spec, complain)\n+     tree list, spec;\n+     int complain;\n+{\n+  int ok;\n+  tree core = spec;\n+  int is_ptr;\n+  \n+  if (spec == error_mark_node)\n+    return list;\n+  \n+  my_friendly_assert (spec && (!list || TREE_VALUE (list)), 19990317);\n+  \n+  /* [except.spec] 1, type in an exception specifier shall not be\n+     incomplete, or pointer or ref to incomplete other than pointer\n+     to cv void.  */\n+  is_ptr = TREE_CODE (core) == POINTER_TYPE;\n+  if (is_ptr || TREE_CODE (core) == REFERENCE_TYPE)\n+    core = TREE_TYPE (core);\n+  if (complain < 0)\n+    ok = 1;\n+  else if (TYPE_MAIN_VARIANT (core) == void_type_node)\n+    ok = is_ptr;\n+  else if (TREE_CODE (core) == TEMPLATE_TYPE_PARM)\n+    ok = 1;\n+  else\n+    ok = TYPE_SIZE (core) != NULL_TREE;\n+  \n+  if (ok)\n+    {\n+      tree probe;\n+      \n+      for (probe = list; probe; probe = TREE_CHAIN (probe))\n+        if (same_type_p (TREE_VALUE (probe), spec))\n+          break;\n+      if (!probe)\n+        {\n+          spec = build_decl_list (NULL_TREE, spec);\n+          TREE_CHAIN (spec) = list;\n+          list = spec;\n+        }\n+    }\n+  else if (complain)\n+    incomplete_type_error (NULL_TREE, core);\n+  return list;\n+}"}]}