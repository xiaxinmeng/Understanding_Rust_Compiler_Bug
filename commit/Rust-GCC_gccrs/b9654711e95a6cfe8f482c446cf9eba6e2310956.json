{"sha": "b9654711e95a6cfe8f482c446cf9eba6e2310956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk2NTQ3MTFlOTVhNmNmZThmNDgyYzQ0NmNmOWViYTZlMjMxMDk1Ng==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-06-29T00:10:35Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-06-29T00:10:35Z"}, "message": "Major rework.\n\nFrom-SVN: r4792", "tree": {"sha": "051d2ef2171bba98f82bdc7c800edced39953ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051d2ef2171bba98f82bdc7c800edced39953ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9654711e95a6cfe8f482c446cf9eba6e2310956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9654711e95a6cfe8f482c446cf9eba6e2310956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9654711e95a6cfe8f482c446cf9eba6e2310956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9654711e95a6cfe8f482c446cf9eba6e2310956/comments", "author": null, "committer": null, "parents": [{"sha": "75d98655110e239222148fca99ead13e82185b24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d98655110e239222148fca99ead13e82185b24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d98655110e239222148fca99ead13e82185b24"}], "stats": {"total": 2124, "additions": 1335, "deletions": 789}, "files": [{"sha": "ca8f8f029d446fe8b91269c2bf58e5a8c9f14b3c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 837, "deletions": 469, "changes": 1306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b9654711e95a6cfe8f482c446cf9eba6e2310956", "patch": "@@ -39,10 +39,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n static int add_constant ();\n-static int dump_constants ();\n+int dump_constants ();\n \n int current_function_anonymous_args;\n extern int current_function_pretend_args_size;\n+extern char *version_string;\n+extern int flag_traditional;\n+\n+\n+enum attr_cpu sh_cpu;\t\t/* target cpu */\n \n /* Global variables for machine-dependent things. */\n \n@@ -80,6 +85,8 @@ enum reg_class reg_class_from_letter[] =\n };\n \n \n+\n+\n /* Local label counter, used for constants in the pool and inside\n    pattern branches.  */\n \n@@ -92,197 +99,83 @@ static int pc;\n #define MUST_DUMP_LEVEL 1000\n static int dumpnext;\n \f\n-/* Functions for generating procedure prologue and epilogue code */\n \n-/* Adjust the stack and return the number of bytes taken to do it */\n-\n-static int\n-output_stack_adjust (file, direction, size)\n-     FILE *file;\n-     int direction;\n-     int size;\n+void\n+push (rn)\n {\n-  int code_size;\n-\n-  if (size > 127)\n-    {\n-      fprintf (file, \"\\tmov.l\tLK%d,r13\\n\",\n-\t       add_constant (GEN_INT (size * direction), SImode));\n-\n-      fprintf (file, \"\\tadd\tr13,r15\\n\");\n-      code_size += 4;\n-    }\n-  else if (size)\n-    {\n-      fprintf (file, \"\\tadd\t#%d,r15\\n\", direction * size);\n-      code_size += 2;\n-    }\n-  return code_size;\n+  emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n }\n \n-/* Generate code to push the regs specified in the mask, and return\n-   the number of bytes the insns take. */\n-\n-static int\n-push_regs (f, mask)\n-     FILE *f;\n-     int mask;\n+void\n+pop (rn)\n {\n-  int i;\n-  int size = 0;\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (mask & (1 << i))\n-\t{\n-\t  fprintf (f, \"\\tmov.l\tr%d,@-r15\\n\", i);\n-\t  size += 2;\n-\t}\n-    }\n-  return size;\n+  emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n }\n \n \n-/* Working out the right code to use for an epilogue can get quite\n-   hairy, since there are only certain insns which can go in the delay\n-   slot, and there may or may not be a delay insn provided already.\n-\n-   We generate a canonical list of the instructions to use to perform\n-   the exit, massage that and output from that list */\n-\n-\n-/* The structure of a canonical element. */\n+/* Adjust the stack and return the number of bytes taken to do it */\n \n-typedef struct\n+static void\n+output_stack_adjust (direction, size)\n+     int direction;\n+     int size;\n {\n-  enum epi_type\n+  if (size)\n     {\n-      STACK_ADJUST,\t\t/* add i to stack pointer \t*/\n-      POP,\t\t\t/* pop into register i \t\t*/\n-      RTS,\t\t\t/* rts instruction \t\t*/\n-      DELAY,\t\t\t/* delay slot instruction \t*/\n-      NOP,\t\t\t/* a nop \t\t\t*/\n-      DELETED,\n-    } type;\n-  int i;\n-}\n+      rtx val = GEN_INT (size);\n+      rtx insn;\n \n-epilogue_insn;\n+      if (size > 120)\n+\t{\n+\t  rtx nval = gen_rtx (REG, SImode, 13);\n+\t  emit_insn (gen_movsi (nval, val));\n+\t  val = nval;\n+\t}\n \n-static epilogue_insn epilogue_vec[20];\n-static int epilogue_vec_len;\n+      if (direction > 0)\n+\tinsn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n+      else\n+\tinsn = gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n \n-static void\n-set_epilogue_insn (type, l)\n-     enum epi_type type;\n-     int l;\n-{\n-  epilogue_vec[epilogue_vec_len].type = type;\n-  epilogue_vec[epilogue_vec_len].i = l;\n-  epilogue_vec_len++;\n+      emit_insn (insn);\n+    }\n }\n \n-/* Delete an insn from the epilogue list. */\n \n-static void\n-delete_epilogue_insn (n)\n-     int n;\n-{\n-  int j;\n-\n-  for (j = n; j < epilogue_vec_len; j++)\n-    epilogue_vec[j] = epilogue_vec[j + 1];\n-\n-  epilogue_vec_len--;\n-}\n \n-/* Run through the epilogue list and optimize it. */\n+/* Generate code to push the regs specified in the mask, and return\n+   the number of bytes the insns take. */\n \n static void\n-optimize_epilogue_vec ()\n+push_regs (mask)\n+     int mask;\n {\n   int i;\n+  int size = 0;\n \n-  /* Turn two adds in a row into one add and kill empty adds */\n-  for (i = 0; i < epilogue_vec_len - 1; i++)\n-    {\n-      if (epilogue_vec[i].type == STACK_ADJUST\n-\t  && epilogue_vec[i + 1].type == STACK_ADJUST)\n-\t{\n-\t  epilogue_vec[i].i += epilogue_vec[i + 1].i;\n-\t  delete_epilogue_insn (i + 1);\n-\t}\n-      if (epilogue_vec[i].type == STACK_ADJUST\n-\t  && epilogue_vec[i].i == 0)\n-\tdelete_epilogue_insn (i);\n-    }\n-\n-  /* If the instruction after the RTS is a nop, see if it can be\n-     changed */\n-\n-  for (i = 1; i < epilogue_vec_len - 1; i++)\n-    {\n-      if (epilogue_vec[i].type == RTS\n-\t  && epilogue_vec[i + 1].type == NOP)\n-\t{\n-\t  epilogue_vec[i + 1] = epilogue_vec[i - 1];\n-\t  delete_epilogue_insn (i - 1);\n-\t}\n-    }\n-\n-  /* Delete all the instructions after the rts's delay slot */\n-  for (i = 0; i < epilogue_vec_len; i++)\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      if (epilogue_vec[i].type == RTS)\n+      if (mask & (1 << i))\n \t{\n-\t  int j;\n-\n-\t  for (j = i + 2; j < epilogue_vec_len; j++)\n-\t    epilogue_vec[j].type = DELETED;\n-\t  return;\n+\t  push (i);\n \t}\n     }\n }\n \n-/* Dump out the insns in epilogue vector. */\n-\n-static void\n-output_epilogue_vec ()\n-{\n-  int i;\n-\n-  for (i = 0; i < epilogue_vec_len; i++)\n-    {\n-      switch (epilogue_vec[i].type)\n-\t{\n-\tcase STACK_ADJUST:\n-\t  fprintf (asm_out_file, \"\\tadd\t#%d,r15\\n\", epilogue_vec[i].i);\n-\t  break;\n-\n-\tcase NOP:\n-\t  fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n-\t  break;\n-\n-\tcase DELAY:\n-\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t\t   asm_out_file, 1, 0, 1);\n-\t  break;\n \n-\tcase DELETED:\n-\t  fprintf (asm_out_file, \"\\t!delete_epilogue_insnd\\n\");\n-\t  break;\n+/*\n+  Print an instruction which would have gone into a delay slot\n+  after an instructiuon, but couldn't because the instruction expanded\n+  into a sequence where putting the slot insn at the end wouldn't work.\n+  */\n \n-\tcase RTS:\n-\t  fprintf (asm_out_file, \"\\trts\\n\");\n-\t  break;\n+void\n+print_slot (insn)\n+     rtx insn;\n+{\n+  final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file, optimize, 0, 1);\n \n-\tcase POP:\n-\t  fprintf (asm_out_file, \"\\tmov.l\t@r15+,r%d\\n\",\n-\t\t   epilogue_vec[i].i);\n-\t  break;\n-\t}\n-    }\n-  epilogue_vec_len = 0;\n+  INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n }\n \n /* Number of bytes pushed for anonymous args */\n@@ -310,162 +203,17 @@ calc_live_regs (count)\n     }\n   return live_regs_mask;\n }\n-\n-/* Generate a procedure prologue.  */\n-\n-void\n-output_prologue (f, frame_size)\n-     FILE *f;\n-     int frame_size;\n-{\n-  int live_regs_mask;\n-  int d;\n-\n-  pc = 0;\n-\n-  /* This only happens when an arg has been split, part in\n-     registers, part in memory.  Allocate the stack space so there is\n-     somewhere to put the value */\n-\n-  output_stack_adjust (f, -1, current_function_pretend_args_size);\n-\n-  live_regs_mask = calc_live_regs (&d);\n-\n-  extra_push = 0;\n-\n-  if (current_function_anonymous_args)\n-    {\n-      /* Push arg regs as if they'd been provided by caller in stack */\n-      int i;\n-      for (i = 0; i < NPARM_REGS; i++)\n-\t{\n-\t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n-\t  if (i > NPARM_REGS - current_function_args_info)\n-\t    break;\n-\t  fprintf (f, \"\\tmov.l\tr%d,@-r15\\n\", rn);\n-\t  extra_push += 4;\n-\t  pc += 2;\n-\t}\n-    }\n-\n-  if (frame_pointer_needed)\n-    {\n-      /* Don't need to push the fp with the rest of the registers. */\n-      live_regs_mask &= ~(1 << FRAME_POINTER_REGNUM);\n-      pc += push_regs (f, live_regs_mask);\n-      if (regs_ever_live[PR_REG])\n-\t{\n-\n-\t  fprintf (f, \"\\tsts.l\tpr,@-r15\\n\");\n-\t  pc += 2;\n-\t}\n-\n-      fprintf (f, \"\\tmov.l\tr14,@-r15\\n\");\n-      fprintf (f, \"\\tmov\tr15,r14\\n\");\n-      pc += 4;\n-      pc += output_stack_adjust (f, -1, frame_size);\n-    }\n-  else\n-    {\n-      pc += push_regs (f, live_regs_mask);\n-\n-      if (regs_ever_live[PR_REG])\n-\t{\n-\n-\t  fprintf (f, \"\\tsts.l\tpr,@-r15\\n\");\n-\t  pc += 2;\n-\t}\n-      pc += output_stack_adjust (f, -1, frame_size);\n-    }\n-}\n+\f\n \n \n-/* Generate a procedure epilogue. */\n \n-void\n-output_epilogue (f, frame_size)\n-     FILE *f;\n-     int frame_size;\n+static int\n+need_slot (insn)\n+     rtx insn;\n {\n-  int live_regs_mask = 0;\n-  int d;\n-  int i;\n-  rtx delay_insn;\n-  \n-  live_regs_mask = calc_live_regs (&d);\n-\n-\n-  /* See if the delay insn is really ok for the slot. */\n-  if (current_function_epilogue_delay_list) {\n-    delay_insn = PATTERN (XEXP (current_function_epilogue_delay_list, 0));\n-\n-  if (GET_CODE (delay_insn) == SET\n-      && SET_DEST (delay_insn) == stack_pointer_rtx)\n-    {\n-      /* Can not use this instruction in the delay slot because\n-\t it changes the stack pointer, so emit it now.  */\n-      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t       asm_out_file, 1, 0, 1);\n-      current_function_epilogue_delay_list = 0;\n-    }\n-  }\n-  \n-\n-  /* Reclaim the room for the automatics. */\n-\n-  output_stack_adjust (f, 1, frame_size);\n-\n-  /* Make the frame pointer. */\n-\n-  if (frame_pointer_needed)\n-    {\n-      fprintf (f, \"\\tmov\tr14,r15\\n\");\n-      fprintf (f, \"\\tmov.l\t@r15+,r14\\n\");\n-      live_regs_mask &= ~(1 << FRAME_POINTER_REGNUM);\n-    }\n-\n-  /* Get the PR register if it was clobbered in the function. */\n-\n-  if (regs_ever_live[PR_REG])\n-    fprintf (f, \"\\tlds.l\t@r15+,pr\\n\");\n-\n-  /* Pop all the registers */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n-      if (live_regs_mask & (1 << j))\n-\t{\n-\t  set_epilogue_insn (POP, j);\n-\t}\n-    }\n-\n-  /* Need to adjust the stack by some amount of bytes since we've pushed\n-     some of the args which normally come in registers */\n-\n-  set_epilogue_insn (STACK_ADJUST, extra_push);\n-\n-  /* Need to adjust the stack by some amount of bytes if there\n-     an arg has been split part register and part stack */\n-\n-  set_epilogue_insn (STACK_ADJUST, current_function_pretend_args_size);\n-\n-  set_epilogue_insn (RTS, 0);\n-\n-  /* Got here without dumping a register pop into the delay slot */\n-  if (current_function_epilogue_delay_list)\n-    {\n-      set_epilogue_insn (DELAY, 0);\n-    }\n-  set_epilogue_insn (NOP, 0);\n-\n-  optimize_epilogue_vec ();\n-\n-  output_epilogue_vec ();\n-\n-  dump_constants (0);\n-  current_function_anonymous_args = 0;\n+  return (insn && !INSN_ANNULLED_BRANCH_P (XVECEXP (insn, 0, 0)));\n }\n-\f\n+\n /* Print the operand address in x to the stream */\n \n void\n@@ -478,7 +226,6 @@ print_operand_address (stream, x)\n     case REG:\n       fprintf (stream, \"@%s\", reg_names[REGNO (x)]);\n       break;\n-\n     case PLUS:\n       {\n \trtx base = XEXP (x, 0);\n@@ -501,12 +248,14 @@ print_operand_address (stream, x)\n \t    break;\n \n \t  case REG:\n-\t    fprintf (stream, \"@(%s,%s)\",\n-\t\t     reg_names[REGNO (base)],\n-\t\t     reg_names[REGNO (index)]);\n+\t    fprintf (stream, \"@(r0,%s)\",\n+\t\t     reg_names[MAX (REGNO (base), REGNO (index))]);\n+\n \t    break;\n \n \t  default:\n+\t    debug_rtx (x);\n+\n \t    abort ();\n \t  }\n       }\n@@ -529,13 +278,16 @@ print_operand_address (stream, x)\n /* Print operand x (an rtx) in assembler syntax to file stream\n    according to modifier code.\n \n- '*'  print a local label\n- '^'  increment the local label number\n- '!'  dump the constant table\n- '#'  output a nop if there is nothing to put in the delay slot\n- 'R'  print the next register or memory location along, ie the lsw in\n-      a double word value\n- 'I'  put something into the constant pool and print its label */\n+   '.'  print a .s if insn needs delay slot\n+   '*'  print a local label\n+   '^'  increment the local label number\n+   '!'  dump the constant table\n+   '#'  output a nop if there is nothing to put in the delay slot\n+   'R'  print the next register or memory location along, ie the lsw in\n+   a double word value\n+   'O'  print a constant without the #\n+   'M'  print a constant as its negative\n+   'I'  put something into the constant pool and print its label */\n \n void\n print_operand (stream, x, code)\n@@ -545,6 +297,12 @@ print_operand (stream, x, code)\n {\n   switch (code)\n     {\n+\n+\n+    case '.':\n+      if (need_slot (final_sequence))\n+\tfprintf (stream, \".s\");\n+      break;\n     case '*':\n       fprintf (stream, \"LF%d\", lf);\n       break;\n@@ -562,11 +320,18 @@ print_operand (stream, x, code)\n \t  fprintf (stream, \"\\n\\tor\tr0,r0\\t!wasted slot\");\n \t}\n       break;\n+    case 'O':\n+      fprintf (asm_out_file, \"%d\", INTVAL (x));\n+      break;\n \n     case 'I':\n       fprintf (asm_out_file, \"LK%d\", add_constant (x, SImode));\n       break;\n \n+    case 'M':\n+      fprintf (asm_out_file, \"#%d\", -INTVAL (x));\n+      break;\n+\n     case 'R':\n       /* Next location along in memory or register*/\n       switch (GET_CODE (x))\n@@ -599,18 +364,18 @@ print_operand (stream, x, code)\n       break;\n     }\n }\n-\n \f\n \n-/* Define the offset between two registers, one to be eliminated, and \n+\n+/* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n \n int\n initial_elimination_offset (from, to)\n {\n   int regs_saved;\n   int d = calc_live_regs (&regs_saved);\n-  int total_saved_regs_space = (regs_saved + regs_ever_live[PR_REG]) * 4;\n+  int total_saved_regs_space = (regs_saved) * 4;\n   int total_auto_space = get_frame_size ();\n \n \n@@ -630,34 +395,46 @@ initial_elimination_offset (from, to)\n     }\n }\n \n-delay_slots_for_epilogue ()\n-{\n-  /* We need to find something to fill the epilogue if there won't be\n-     any instructions to make the stack or pop registers which can be\n-     moved into the slot */\n-\n-  int d;\n-  calc_live_regs (&d);\n-  return !(get_frame_size () + d);\n-}\n-\f\n \n /* Prepare operands for a move define_expand; specifically, one of the\n-   operands must be in a register */\n+   operands must be in a register.  Take this chance to remove\n+   addressing modes which can't be coped with very well. */\n \n-void\n+int\n prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n   /* One of the operands has to be a register */\n   if ((!register_operand (operands[0], mode)\n        && !register_operand (operands[1], mode))\n-      || GET_CODE(operands[1]) == PLUS)\n+      || GET_CODE (operands[1]) == PLUS)\n     {\n       /* copy the source to a register */\n       operands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n+\n+  /* If we've got a negative index, break it down */\n+\n+  if (GET_CODE (operands[0]) == MEM && !reload_in_progress)\n+    {\n+\n+      rtx inside = XEXP (operands[0], 0);\n+      if (GET_CODE (inside) == PLUS)\n+\t{\n+\t  rtx inside1 = XEXP (inside, 1);\n+\t  if (GET_CODE (inside1) == CONST_INT\n+\t      && INTVAL (inside1) < 0)\n+\t    {\n+\t      /* Catch this now and break it into bits, it will only cause\n+\t\t problems later */\n+\n+\t      rtx sub = copy_to_mode_reg (SImode, inside);\n+\t      XEXP (operands[0], 0) = sub;\n+\t    }\n+\t}\n+    }\n+  return 0;\n }\n \n \n@@ -666,93 +443,164 @@ prepare_move_operands (operands, mode)\n rtx\n prepare_scc_operands (code)\n {\n-  if (GET_CODE(sh_compare_op0) != REG \n-      || REGNO(sh_compare_op0) != T_REG)\n+  if (GET_CODE (sh_compare_op0) != REG\n+      || REGNO (sh_compare_op0) != T_REG)\n     {\n       /* First need a compare insn */\n-      emit_insn (gen_rtx (SET, SImode, \n+      emit_insn (gen_rtx (SET, SImode,\n \t\t\t  gen_rtx (REG, SImode, T_REG),\n \t\t\t  gen_rtx (code, SImode, sh_compare_op0,\n \t\t\t\t   sh_compare_op1)));\n     }\n-  return gen_rtx(REG, SImode, T_REG);\n+  return gen_rtx (REG, SImode, T_REG);\n }\n \f\n+\n /* Functions to output assembly */\n \n-/* Return a sequence of instructions to perform DI move, taking into\n-   account overlapping source and dest registers */\n+/* Return a sequence of instructions to perform DI or DF move.\n \n+   Since the SH cannot move a DI or DF in one instruction, we have\n+   to take care when we see overlapping source and dest registers.\n+\n+ */\n char *\n output_movedouble (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  if (register_operand (operands[0], mode)\n-      && register_operand (operands[1], mode))\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  int lowfirst;\n+\n+  if (register_operand (dst, mode)\n+      && register_operand (src, mode))\n     {\n-      if (REGNO (operands[1]) == MACH_REG)\n+      if (REGNO (src) == MACH_REG)\n \treturn \"sts\tmach,%0\\n\\tsts\tmacl,%R0\";\n-      if (REGNO (operands[1]) > REGNO (operands[0])) \n-\t{\n-\t  return \"mov\t%1,%0\\n\\tmov\t%R1,%R0\";\n-\t}\n-      else \n-\t{\n-\t  return \"mov\t%R1,%R0\\n\\tmov\t%1,%0\";\n-\t}\n-    }\n \n-  if (GET_CODE (operands[1]) == CONST_INT)\n+      /*\n+\twhen mov.d r1,r2 do r2->r3 then r1->r2\n+\twhen mov.d r1,r0 do r1->r0 then r2->r1\n+\t*/\n+\n+      if (REGNO (src) + 1 == REGNO (dst))\n+\treturn \"mov\t%1,%0\\n\\tmov\t%R1,%R0 ! cr\";\n+      else\n+\treturn \"mov\t%R1,%R0\\n\\tmov\t%1,%0 \";\n+\n+    }\n+  else if (GET_CODE (src) == CONST_INT)\n     {\n-      if (INTVAL (operands[1]) < 0)\n+      if (INTVAL (src) < 0)\n \treturn \"mov\t#-1,%0\\n\\tmov\t%1,%R0\";\n       else\n \treturn \"mov\t#0,%0\\n\\tmov\t%1,%R0\";\n     }\n \n-  if (GET_CODE (operands[1]) == MEM)\n+  else if (GET_CODE (src) == MEM)\n     {\n-      int idxreg = -1;\n-      rtx inside = XEXP (operands[1], 0);\n+      int ptrreg1 = -1;\n+      int ptrreg2 = -1;\n+      int dreg = REGNO (dst);\n+      rtx inside = XEXP (src, 0);\n \n       if (GET_CODE (inside) == REG)\n-\tidxreg = REGNO (inside);\n+\t{\n+\t  ptrreg1 = REGNO (inside);\n+\t}\n       else if (GET_CODE (inside) == PLUS)\n \t{\n \t  rtx lhs = XEXP (inside, 0);\n \t  rtx rhs = XEXP (inside, 1);\n \t  if (GET_CODE (lhs) == REG)\n-\t    idxreg = REGNO (lhs);\n-\t  else if (GET_CODE (rhs) == REG)\n-\t    idxreg = REGNO (rhs);\n-\t  else\n-\t    abort ();\n+\t    ptrreg1 = REGNO (lhs);\n+\t  if (GET_CODE (rhs) == REG)\n+\t    ptrreg2 = REGNO (rhs);\n \t}\n       else\n \tabort ();\n \n-      if (REGNO (operands[0]) != idxreg)\n+\n+      if ((ptrreg1 >= 0 && ptrreg2 >= 0)\n+\t  && (dreg == ptrreg1\n+\t      || dreg == ptrreg2\n+\t      || dreg + 1 == ptrreg1\n+\t      || dreg + 1 == ptrreg2))\n+\t{\n+\t  /* This move clobbers both index registers,\n+\t     calculate the sum in one register.  */\n+\t  fprintf (asm_out_file, \"\tadd\t%s,%s ! special fix\\n\",\n+\t\t   reg_names[ptrreg2], reg_names[ptrreg1]);\n+\n+\t  if (dreg == ptrreg1)\n+\t    {\n+\t      /* Copy into dreg+1 first.  */\n+\t      fprintf (asm_out_file, \"\tmov.l\t@(4,%s),%s\\n\",\n+\t\t       reg_names[ptrreg1],\n+\t\t       reg_names[dreg + 1]);\n+\n+\t      fprintf (asm_out_file, \"\tmov.l\t@(%s),%s\\n\",\n+\t\t       reg_names[ptrreg1],\n+\t\t       reg_names[dreg]);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Copy into dreg first. */\n+\t      fprintf (asm_out_file, \"\tmov.l\t@(%s),%s\\n\",\n+\t\t       reg_names[ptrreg1],\n+\t\t       reg_names[dreg]);\n+\n+\t      fprintf (asm_out_file, \"\tmov.l\t@(4,%s),%s\\n\",\n+\t\t       reg_names[ptrreg1],\n+\t\t       reg_names[dreg + 1]);\n+\n+\t    }\n+\t  warning (\"generated complex amode\");\n+\t  return \"\";\n+\t}\n+\n+      /* Work out the safe way to copy */\n+      if (dreg == ptrreg1)\n \t{\n-\t  /* The dest register is mentioned in the addressing mode,\n-\t     so print them the other way around */\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%R1,%R0 ! one way\";\n+\t  /* Copy into the second half first */\n+\t  return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0 ! cr\";\n \t}\n-      return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0 ! other way\";\n     }\n \n-  return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0\";\n+  return \"mov.l\t%1,%0\\n\\tmov.l\t%R1,%R0\";\n }\n \n /* Emit assembly to shift reg by k bits */\n \n char *\n-output_shift (string, reg, k)\n+output_shift (string, reg, k, code)\n      char *string;\n      rtx reg;\n      rtx k;\n+     int code;\n+\n {\n   int s = INTVAL (k);\n+\n+  if (code == ASHIFT && s == 31)\n+    {\n+      /* Shift left by 31 moving into the t bit, clearing and rotating the other way */\n+\n+      fprintf (asm_out_file, \"\\trotr\tr%d\\n\", REGNO (reg));\n+      fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", REGNO (reg));\n+      fprintf (asm_out_file, \"\\trotcr\tr%d\\n\", REGNO (reg));\n+      s = 0;\n+    }\n+\n+  if (code == LSHIFTRT && s == 31)\n+    {\n+      fprintf (asm_out_file, \"\\trotl\tr%d\\n\", REGNO (reg));\n+      fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", REGNO (reg));\n+      fprintf (asm_out_file, \"\\trotcl\tr%d\\n\", REGNO (reg));\n+      s = 0;\n+    }\n+\n   while (s)\n     {\n       char *out;\n@@ -785,51 +633,171 @@ output_shift (string, reg, k)\n }\n \n /* Return the text of the branch instruction which matches its length\n-   attribute.  */\n+   attribute.\n+\n+   This gets tricky if we have an insn in the delay slot of a branch\n+   and the branch needs more than 1 insn to complete.*/\n+\n+\n \n char *\n output_branch (logic, insn)\n      int logic;\n-     rtx *insn;\n+     rtx insn;\n {\n   extern rtx recog_operand[];\n   int label = lf++;\n-  \n+  int rn = -1;\n+  int need_save;\n+\n   switch (get_attr_length (insn))\n     {\n     case 2:\n       /* Simple branch in range -200..+200 bytes */\n-      return logic ? \"bt\t%l0\" : \"bf\t%l0\";\n+      return logic ? \"bt%.\t%l0\" : \"bf%.\t%l0\";\n \n     case 6:\n       /* Branch in range -4000..+4000 bytes */\n-      fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n-      output_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n-      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n-      label = dump_constants (label);\n-      fprintf (asm_out_file, \"LF%d:\\n\", label);\n+      {\n+\trtx oldop = recog_operand[0];\n+\n+\n+\tif (need_slot (final_sequence))\n+\t  {\n+\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n+\t\t     label);\n+\n+\t    print_slot (final_sequence);\n+\t  }\n+\n+\telse\n+\t  {\n+\t    fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't',\n+\t\t     label);\n+\t  }\n+\trecog_operand[0] = oldop;\n+\n+\toutput_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n+\tfprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\tlabel = dump_constants (label);\n+\tfprintf (asm_out_file, \"LF%d:\\n\", label);\n+      }\n+\n       return \"\";\n \n     case 8:\n       /* Branches a long way away */\n-\t\n-      fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n-      output_asm_insn (\"mov.l\t%I0,r13\", recog_operand);\n-      fprintf (asm_out_file, \"\\tjmp\t@r13\t! 32 cond \\n\");\n-      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n-      fprintf (asm_out_file, \"LF%d:\\n\", label);\n-      return \"\";\n+      {\n+\n+\trtx oldop = recog_operand[0];\n+\n+\tif (need_slot (final_sequence))\n+\t  {\n+\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't', label);\n+\t    print_slot (final_sequence);\n+\n+\t  }\n+\telse\n+\t  {\n+\t    fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n+\t  }\n+\n+\trecog_operand[0] = oldop;\n+\n+\t/* We use r13 as a scratch */\n+\tneed_save = 0;\n+\trn = 13;\n+\n+\tif (need_save)\n+\t  fprintf (asm_out_file, \"\\tpush  r%d\\n\", rn);\n+\tfprintf (asm_out_file, \"\\tmov.l\tLK%d,r%d\\n\", add_constant (oldop, SImode), rn);\n+\tfprintf (asm_out_file, \"\\tjmp\t@r%d\t! 32 cond \\n\", rn);\n+\tif (need_save)\n+\t  fprintf (asm_out_file, \"\\tpop  r%d\\n\", rn);\n+\telse\n+\t  fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\tfprintf (asm_out_file, \"LF%d:\\n\", label);\n+\treturn \"\";\n+      }\n     }\n   return \"bad\";\n-\n }\n \f\n+\n /* Predicates used by the templates */\n \n+/* Non zero if op is an immediate ok for a byte index */\n+\n+int \n+byte_index_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= 0 && INTVAL (op) <= 15);\n+}\n+\n+/* Non zero if OP is a pop operand */\n+\n+int\n+pop_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != POST_INC)\n+    return 0;\n+\n+  return XEXP (op, 0) == stack_pointer_rtx;\n+}\n+\n+/* Non zero if OP is an immediate which can be made from two insns. */\n+\n+int\n+painful_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      int i = INTVAL (op);\n+\n+      if (i > 127 && i < 255)\n+\treturn 1;\t\t/* two adds */\n+    }\n+  return 0;\n+}\n+\n+\n+/* Non zero if OP can be source of a simple move operation. */\n+\n+int\n+general_movsrc_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG\n+      || GET_CODE (op) == SUBREG\n+      || (GET_CODE (op) == CONST_INT &&\n+\t  CONST_OK_FOR_I (INTVAL (op)))\n+      || GET_CODE (op) == MEM)\n+    return general_operand (op, mode);\n+  return 0;\n+}\n+\n+\n+\n /* Nonzero if OP is a normal arithmetic register. */\n \n int\n-arith_reg_operand(op, mode)\n+arith_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n@@ -842,7 +810,7 @@ arith_reg_operand(op, mode)\n   return 0;\n }\n \n-  \n+\n /* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n \n int\n@@ -897,7 +865,7 @@ ok_shift_value (p)\n \t  return 1;\n \tdefault:\n \t  if (TARGET_FASTCODE)\n-\t    return INTVAL(p) >= 0;\n+\t    return INTVAL (p) >= 0;\n \t}\n     }\n   return 0;\n@@ -1025,7 +993,7 @@ add_constant (x, mode)\n       if (rtx_equal_p (x, pool_vector[i].value))\n \treturn pool_vector[i].number;\n     }\n-  \n+\n \n   pool_vector[pool_size].value = x;\n   pool_vector[pool_size].mode = mode;\n@@ -1078,107 +1046,132 @@ int target_insn_smallest_size;\n int target_pc;\n int target_insn_range;\n int current_pc;\n-int table_size;\n+int pool_bytes;\n+\n+int last_uid;\n+int last_pc;\n \n void\n adjust_insn_length (insn, insn_lengths)\n      rtx insn;\n      short *insn_lengths;\n {\n   int uid = INSN_UID (insn);\n+  rtx body = PATTERN (insn);\n \n   current_pc += insn_lengths[uid];\n \n-  if (has_constant_table (insn)) \n+\n+  if (GET_CODE (body) == SEQUENCE)\n     {\n-      if (current_pc >= target_insn_range)\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (body, 0); i++)\n \t{\n-\t  /* This instruction is further away from the referencing\n-\t     instruction than it can reach, so we'll stop accumulating\n-\t     from that one and start fresh. */\n-\t  target_pc = current_pc;\n-\t  target_insn_range = current_pc + MAYBE_DUMP_LEVEL;\n+\t  adjust_insn_length (XVECEXP (body, 0, i), insn_lengths);\n \t}\n-      else\n+    }\n+  else\n+    {\n+      if (has_constant_table (insn))\n \t{\n-\t  /* This instruction is within the reach of the target,\n-\t     remove the constant table from the target by adjusting\n-\t     downwards, and increase the size of this one to\n-\t     compensate.  */\n+\t  if (current_pc >= target_insn_range)\n+\t    {\n+\t      /* This instruction is further away from the referencing\n+\t       instruction than it can reach, so we'll stop accumulating\n+\t       from that one and start fresh. */\n+\t      target_pc = current_pc;\n+\t      target_insn_range = current_pc + MAYBE_DUMP_LEVEL;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This instruction is within the reach of the target,\n+\t       remove the constant table from the target by adjusting\n+\t       downwards, and increase the size of this one to\n+\t       compensate.  */\n \n \n-\t  /* Add the stuff from this insn to what will go in the\n-\t     growing table. */\n+\t      /* Add the stuff from this insn to what will go in the\n+\t       growing table. */\n \n-\t  table_size += get_attr_constantsize (insn);\n+\t      pool_bytes += get_attr_constantsize (insn);\n \n-\t  /* The target shinks to its smallest natural size */\n-\t  insn_lengths[target_insn_uid] = target_insn_smallest_size;\n+\t      /* The target shinks to its smallest natural size */\n+\t      insn_lengths[target_insn_uid] = target_insn_smallest_size;\n \n-\t  /* The current insn grows to be its larger size plust the\n-\t     table size. */\n+\t      /* The current insn grows to be its larger size plust the\n+\t       table size. */\n \n-\t  insn_lengths[uid] = get_attr_largestsize (insn) + table_size;\n+\t      insn_lengths[uid] = get_attr_largestsize (insn) + pool_bytes;\n \n-\t}\n-      /* Current insn becomes the target.  */\n-      target_insn_uid = uid;\n-      target_insn_smallest_size = get_attr_smallestsize (insn);\n+\t    }\n+\t  /* Current insn becomes the target.  */\n+\t  target_insn_uid = uid;\n+\t  target_insn_smallest_size = get_attr_smallestsize (insn);\n \n+\t}\n     }\n-\n }\n \n \n-/* Dump out the pending constant pool. \n-   If label provided then insert an branch in the middle of the table \n-  */\n \n-static int\n+/* Dump out the pending constant pool.\n+   If label provided then insert an branch in the middle of the table\n+   */\n+\n+int\n dump_constants (label)\n {\n   int i;\n   int rlabel = label;\n   int size = 0;\n-  \n-  for (i = 0; i < pool_size; i++)\n+\n+  if (pool_size)\n     {\n-      pool_node *p = pool_vector + i;\n       fprintf (asm_out_file, \"\\n\\t! constants - waited %d\\n\", pc - first_pc);\n       fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n-      fprintf (asm_out_file, \"LK%d:\", p->number);\n-      size += GET_MODE_SIZE (p->mode);\n-      \n-      switch (GET_MODE_CLASS (p->mode))\n-\t{\n-\tcase MODE_INT:\n-\tcase MODE_PARTIAL_INT:\n-\t  assemble_integer (p->value, GET_MODE_SIZE (p->mode), 1);\n-\t  break;\n-\tcase MODE_FLOAT:\n-\t  {\n-\t    union real_extract u;\n-\t    bcopy (&CONST_DOUBLE_LOW (p->value), &u, sizeof u);\n-\t    assemble_real (u.d, p->mode);\n-\t  }\n-\t}\n-      \n-      /* After 200 bytes of table, stick in another branch */\n-      if (label && size > 200) \n+\n+      for (i = 0; i < pool_size; i++)\n \t{\n-\t  rlabel = lf ++;\n-\t  fprintf (asm_out_file,\"LF%d:\\tbra\tLF%d\\n\", label, rlabel);\n-\t  fprintf (asm_out_file,\"\\tor\tr0,r0\\n\");\n-\t  label = 0;\n+\t  pool_node *p = pool_vector + i;\n+\n+\t  fprintf (asm_out_file, \"LK%d:\", p->number);\n+\t  size += GET_MODE_SIZE (p->mode);\n+\n+\t  switch (GET_MODE_CLASS (p->mode))\n+\t    {\n+\t    case MODE_INT:\n+\t    case MODE_PARTIAL_INT:\n+\t      assemble_integer (p->value, GET_MODE_SIZE (p->mode), 1);\n+\t      break;\n+\t    case MODE_FLOAT:\n+\t      {\n+\t\tunion real_extract u;\n+\t\tbcopy (&CONST_DOUBLE_LOW (p->value), &u, sizeof u);\n+\t\tassemble_real (u.d, p->mode);\n+\t      }\n+\t    }\n+\n+\t  /* After 200 bytes of table, stick in another branch */\n+\t  if (label && size > 200)\n+\t    {\n+\t      rlabel = lf++;\n+\t      fprintf (asm_out_file, \"LF%d:\\tbra\tLF%d\\n\", label, rlabel);\n+\t      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\t      label = 0;\n+\t    }\n+\n \t}\n-      \n-      fprintf (asm_out_file, \"\\n\");\n     }\n+\n   pool_size = 0;\n   current_pc = 0;\n+  pc = 0;\n+  pool_bytes = 0;\n+\n   target_insn_range = 0;\n   return rlabel;\n-  \n+\n }\n \n \n@@ -1196,17 +1189,27 @@ output_movepcrel (insn, operands, mode)\n   fprintf (asm_out_file, \"\\tmov.l\tLK%d,r%d\\n\",\n \t   add_constant (operands[1], mode), rn);\n \n-  if (GET_MODE_SIZE(mode) > 4) \n+  if (GET_MODE_SIZE (mode) > 4)\n     {\n       fprintf (asm_out_file,\n \t       \"\\tmov.l\tLK%d+4,r%d\\n\",\n \t       add_constant (operands[1], mode),\n \t       rn + 1);\n \n-    } \n-  /* If this instruction is as small as it can be, there can be no \n+    }\n+\n+  /* This may have been the last move in the function, so nothing\n+     took its constant table, we may be able to move it past the end\n+     of the function (after the rts) if we are careful */\n+\n+  if (target_insn_uid == INSN_UID (insn)\n+      && current_pc < target_insn_range)\n+    return \"\";\n+\n+\n+  /* If this instruction is as small as it can be, there can be no\n      constant table attached to it.  */\n-  if (get_attr_length (insn) !=  get_attr_smallestsize (insn))\n+  if (get_attr_length (insn) != get_attr_smallestsize (insn))\n     {\n       /* This needs a constant table */\n       fprintf (asm_out_file, \"\\t!constant table start\\n\");\n@@ -1222,7 +1225,7 @@ output_movepcrel (insn, operands, mode)\n \n /* Dump out interesting debug info */\n \n-void\n+rtx\n final_prescan_insn (insn, opvec, noperands)\n      rtx insn;\n      rtx *opvec;\n@@ -1245,25 +1248,390 @@ final_prescan_insn (insn, opvec, noperands)\n \n \n     }\n-  \n-  pc += get_attr_length (insn);\n \n+  pc += get_attr_length (insn);\n   if (pool_size && pc - first_pc > MUST_DUMP_LEVEL)\n     {\n-      /* For some reason we have not dumped out a constant table, and \n-      we have emitted a lot of code.  This can happen if the think\n-      which wants the table is a long conditional branch (which has no\n-      room for a constant table), and there has not been a move\n-      constant anywhere. */\n+      /* For some reason we have not dumped out a constant table, and\n+\t we have emitted a lot of code.  This can happen if the think\n+\t which wants the table is a long conditional branch (which has no\n+\t room for a constant table), and there has not been a move\n+\t constant anywhere. */\n       int label = lf++;\n-      fprintf (asm_out_file, \"\\t!forced constant table\\n\");      \n+      fprintf (asm_out_file, \"\\t!forced constant table\\n\");\n       fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", label);\n       fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n       label = dump_constants (label);\n       fprintf (asm_out_file, \"LF%d:\\n\", label);\n       fprintf (asm_out_file, \"\\t!constant table end\\n\");\n     }\n-  \n }\n \n \n+\n+/* Block move stuff stolen from m88k*/\n+\n+/* Emit code to perform a block move.  Choose the best method.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the alignment safe to use.  */\n+\n+/* Emit code to perform a block move with an offset sequence of ld/st\n+   instructions (..., ld 0, st 1, ld 1, st 0, ...).  SIZE and ALIGN are\n+   known constants.  DEST and SRC are registers.  OFFSET is the known\n+   starting point for the output pattern.  */\n+\n+static enum machine_mode mode_from_align[] =\n+{VOIDmode, QImode, HImode, VOIDmode, SImode,\n+ VOIDmode, VOIDmode, VOIDmode, DImode};\n+static void\n+\n+block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n+     rtx dest, dest_mem;\n+     rtx src, src_mem;\n+     int size;\n+     int align;\n+     int offset;\n+{\n+  rtx temp[2];\n+  enum machine_mode mode[2];\n+  int amount[2];\n+  int active[2];\n+  int phase = 0;\n+  int next;\n+  int offset_ld = offset;\n+  int offset_st = offset;\n+\n+  active[0] = active[1] = FALSE;\n+\n+  /* Establish parameters for the first load and for the second load if\n+     it is known to be the same mode as the first.  */\n+  amount[0] = amount[1] = align;\n+\n+\n+  mode[0] = mode_from_align[align];\n+\n+  temp[0] = gen_reg_rtx (mode[0]);\n+  if (size >= 2 * align)\n+    {\n+      mode[1] = mode[0];\n+      temp[1] = gen_reg_rtx (mode[1]);\n+    }\n+\n+  do\n+    {\n+      rtx srcp, dstp;\n+      next = phase;\n+      phase = !phase;\n+\n+      if (size > 0)\n+\t{\n+\t  /* Change modes as the sequence tails off.  */\n+\t  if (size < amount[next])\n+\t    {\n+\t      amount[next] = (size >= 4 ? 4 : (size >= 2 ? 2 : 1));\n+\t      mode[next] = mode_from_align[amount[next]];\n+\t      temp[next] = gen_reg_rtx (mode[next]);\n+\t    }\n+\t  size -= amount[next];\n+\t  srcp = gen_rtx (MEM,\n+\t\t\t  MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n+\t\t\t  gen_rtx (PLUS, Pmode, src,\n+\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_ld)));\n+\t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n+\t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n+\t  MEM_IN_STRUCT_P (srcp) = 1;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n+\t  offset_ld += amount[next];\n+\t  active[next] = TRUE;\n+\t}\n+\n+      if (active[phase])\n+\t{\n+\t  active[phase] = FALSE;\n+\t  dstp = gen_rtx (MEM,\n+\t\t\t  MEM_IN_STRUCT_P (dest_mem) ? mode[phase] : BLKmode,\n+\t\t\t  gen_rtx (PLUS, Pmode, dest,\n+\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_st)));\n+\t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n+\t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dest_mem);\n+\t  MEM_IN_STRUCT_P (dstp) = 1;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n+\t  offset_st += amount[phase];\n+\t}\n+    }\n+  while (active[next]);\n+}\n+\n+void\n+expand_block_move (dest_mem, src_mem, operands)\n+     rtx dest_mem;\n+     rtx src_mem;\n+     rtx *operands;\n+{\n+  int align = INTVAL (operands[3]);\n+  int constp = (GET_CODE (operands[2]) == CONST_INT);\n+  int bytes = (constp ? INTVAL (operands[2]) : 0);\n+\n+#if 0\n+  if (constp && bytes <= 0)\n+    return;\n+\n+  if (align > 4)\n+    align = 4;\n+\n+  if (constp && bytes <= 3 * align)\n+    block_move_sequence (operands[0], dest_mem, operands[1], src_mem,\n+\t\t\t bytes, align, 0);\n+\n+#if 0\n+  else if (constp && bytes <= best_from_align[target][align])\n+    block_move_no_loop (operands[0], dest_mem, operands[1], src_mem,\n+\t\t\tbytes, align);\n+\n+  else if (constp && align == 4 && TARGET_88100)\n+    block_move_loop (operands[0], dest_mem, operands[1], src_mem,\n+\t\t     bytes, align);\n+#endif\n+  else\n+#endif\n+    {\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t operands[0], Pmode,\n+\t\t\t operands[1], Pmode,\n+\t\t\t operands[2], SImode);\n+    }\n+}\n+\n+\n+override_options ()\n+{\n+  sh_cpu = CPU_SH0;\n+  if (TARGET_SH1)\n+    sh_cpu = CPU_SH1;\n+  if (TARGET_SH2)\n+    sh_cpu = CPU_SH2;\n+  if (TARGET_SH3)\n+    sh_cpu = CPU_SH3;\n+}\n+\f\n+\n+/* Stuff taken from m88k.c */\n+\n+/* Output to FILE the start of the assembler file.  */\n+\n+struct option\n+{\n+  char *string;\n+  int *variable;\n+  int on_value;\n+};\n+\n+static int\n+output_option (file, sep, type, name, indent, pos, max)\n+     FILE *file;\n+     char *sep;\n+     char *type;\n+     char *name;\n+     char *indent;\n+     int pos;\n+     int max;\n+{\n+  if (strlen (sep) + strlen (type) + strlen (name) + pos > max)\n+    {\n+      fprintf (file, indent);\n+      return fprintf (file, \"%s%s\", type, name);\n+    }\n+  return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n+}\n+\n+static struct\n+  {\n+    char *name;\n+    int value;\n+  }\n+\n+m_options[] = TARGET_SWITCHES;\n+\n+static void\n+output_options (file, f_options, f_len, W_options, W_len,\n+\t\tpos, max, sep, indent, term)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n+     int pos;\n+     int max;\n+     char *sep;\n+     char *indent;\n+     char *term;\n+{\n+  register int j;\n+\n+\n+  if (optimize)\n+    pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n+  if (write_symbols != NO_DEBUG)\n+    pos = output_option (file, sep, \"-g\", \"\", indent, pos, max);\n+  if (flag_traditional)\n+    pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n+  if (profile_flag)\n+    pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n+  if (profile_block_flag)\n+    pos = output_option (file, sep, \"-a\", \"\", indent, pos, max);\n+\n+  for (j = 0; j < f_len; j++)\n+    if (*f_options[j].variable == f_options[j].on_value)\n+      pos = output_option (file, sep, \"-f\", f_options[j].string,\n+\t\t\t   indent, pos, max);\n+\n+  for (j = 0; j < W_len; j++)\n+    if (*W_options[j].variable == W_options[j].on_value)\n+      pos = output_option (file, sep, \"-W\", W_options[j].string,\n+\t\t\t   indent, pos, max);\n+\n+  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+    if (m_options[j].name[0] != '\\0'\n+\t&& m_options[j].value > 0\n+\t&& ((m_options[j].value & target_flags)\n+\t    == m_options[j].value))\n+      pos = output_option (file, sep, \"-m\", m_options[j].name,\n+\t\t\t   indent, pos, max);\n+\n+\n+  fprintf (file, term);\n+}\n+\n+void\n+output_file_start (file, f_options, f_len, W_options, W_len)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n+{\n+  register int pos;\n+\n+  output_file_directive (file, main_input_filename);\n+\n+  /* Switch to the data section so that the coffsem symbol and the\n+     gcc2_compiled. symbol aren't in the text section.  */\n+  data_section ();\n+\n+\n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n+  output_options (file, f_options, f_len, W_options, W_len,\n+\t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n+}\n+\f\n+\n+/* Code to generate prologue and epilogue sequences */\n+\n+void\n+sh_expand_prologue ()\n+{\n+  int live_regs_mask;\n+  int d;\n+\n+  live_regs_mask = calc_live_regs (&d);\n+\n+  output_stack_adjust (-1, current_function_pretend_args_size);\n+\n+  if (current_function_anonymous_args)\n+    {\n+      /* Push arg regs as if they'd been provided by caller in stack */\n+      int i;\n+      for (i = 0; i < NPARM_REGS; i++)\n+\t{\n+\t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n+\t  if (i > NPARM_REGS - current_function_args_info)\n+\t    break;\n+\t  push (rn);\n+\n+\t  extra_push += 4;\n+\t}\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      push_regs (live_regs_mask);\n+      emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+    }\n+  else\n+    {\n+      push_regs (live_regs_mask);\n+    }\n+\n+  output_stack_adjust (-1, get_frame_size ());\n+}\n+\n+void\n+sh_expand_epilogue ()\n+{\n+  int live_regs_mask;\n+  int d;\n+  int i;\n+\n+  live_regs_mask = calc_live_regs (&d);\n+\n+  if (frame_pointer_needed)\n+    {\n+      emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+    }\n+  else\n+    {\n+      output_stack_adjust (1, get_frame_size ());\n+    }\n+\n+\n+  /* Pop all the registers */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n+      if (live_regs_mask & (1 << j))\n+\t{\n+\t  pop (j);\n+\t}\n+    }\n+  output_stack_adjust (1, extra_push +\n+\t\t       current_function_pretend_args_size);\n+\n+  extra_push = 0;\n+\n+  current_function_anonymous_args = 0;\n+}\n+\n+\n+/* Return the cost of a shift */\n+\n+int\n+shiftcosts (RTX)\n+     rtx RTX;\n+{\n+  /* If shift by a non constant, then this will be expensive. */\n+  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n+    return 20;\n+\n+  /* otherwise, it will be very cheap if by one of the constants\n+     we can cope with. */\n+  if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\n+    return 1;\n+\n+  /* otherwise it will be several insns. */\n+  return 4;\n+}\n+\n+/* Return the cost of a multiply */\n+int\n+multcosts (RTX)\n+     rtx RTX;\n+{\n+  /* If we we're aiming at small code, then just count the number of\n+     insns in a multiply call sequence, otherwise, count all the insnsn\n+     inside the call. */\n+  if (TARGET_SMALLCODE)\n+    return 3;\n+  return 30;\n+}"}, {"sha": "c889bb09e83d517b32b629d3dde2a78fe5ab1913", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 229, "deletions": 119, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=b9654711e95a6cfe8f482c446cf9eba6e2310956", "patch": "@@ -49,18 +49,37 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n extern int target_flags;\n #define ISIZE_BIT  1\n #define FAST_BIT   2\n-#define MULSI3_BIT 4\n+\n #define MAC_BIT    8\n #define RTL_BIT    16\n #define DT_BIT     32\n #define DALIGN_BIT 64\n+#define SH0_BIT\t128\n+#define SH1_BIT\t256\n+#define SH2_BIT\t512\n+#define SH3_BIT\t1024\n+#define C_BIT\t2048\n+#define R_BIT     (1<<12)\n+#define SPACE_BIT (1<<13)\n+\n+/* Nonzero if we should generate code using type 0 insns */\n+#define TARGET_SH0 (target_flags & SH0_BIT)\n+\n+/* Nonzero if we should generate code using type 1 insns */\n+#define TARGET_SH1 (target_flags & SH1_BIT)\n+\n+/* Nonzero if we should generate code using type 2 insns */\n+#define TARGET_SH2 (target_flags & SH2_BIT)\n \n-/* Nonzero if we should generate code using muls.l insn */\n-#define TARGET_HAS_MULSI3 (target_flags & MULSI3_BIT)\n+/* Nonzero if we should generate code using type 3 insns */\n+#define TARGET_SH3 (target_flags & SH3_BIT)\n \n /* Nonzero if we should generate faster code rather than smaller code */\n #define TARGET_FASTCODE   (target_flags & FAST_BIT)\n \n+/* Nonzero if we should generate faster code rather than smaller code */\n+#define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n+\n /* Nonzero if we should dump out instruction size info */\n #define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n \n@@ -70,27 +89,42 @@ extern int target_flags;\n /* Nonzero if we should dump the rtl in the assembly file. */\n #define TARGET_DUMP_RTL\t  (target_flags & RTL_BIT)\n \n-/* Nonzero if the target has a decrement and test instruction .*/\n-#define TARGET_HAS_DT     (target_flags & DT_BIT)\n+/* Nonzero if we should dump the rtl somewher else. */\n+#define TARGET_DUMP_R\t  (target_flags & R_BIT)\n \n /* Nonzero to align doubles on 64 bit boundaries */\n #define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n \n+\n+/* Nonzero if Combine dumping wanted */\n+#define TARGET_CDUMP (target_flags & C_BIT)\n+\n #define TARGET_SWITCHES  \t\\\n { {\"isize\", \t( ISIZE_BIT)  },\\\n-  {\"space\", \t(-FAST_BIT)   },\\\n-  {\"hasmulsi\",  ( MULSI3_BIT) },\\\n-  {\"hasdt\", \t( DT_BIT)     },\\\n+  {\"space\", \t( SPACE_BIT)   },\\\n+  {\"0\",\t        ( SH0_BIT) },\\\n+  {\"1\",\t        ( SH1_BIT) },\\\n+  {\"2\",\t        ( SH2_BIT) },\\\n+  {\"3\",\t        ( SH3_BIT) },\\\n   {\"ac\",  \t( MAC_BIT)    },\\\n   {\"dalign\",  \t( DALIGN_BIT) },\\\n+  {\"c\",  \t( C_BIT) },\\\n+  {\"r\",  \t( RTL_BIT) },\\\n+  {\"R\",  \t( R_BIT) },\\\n   {\"\",   \tTARGET_DEFAULT} \\\n }\n \n #define TARGET_DEFAULT  FAST_BIT\n \n+#define OVERRIDE_OPTIONS override_options();\n+\n \f\n /* Target machine storage Layout.  */\n \n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN  0\n@@ -163,8 +197,7 @@ extern int target_flags;\n \n \tr0-r3\t\tscratch\n \tr4-r7\t\targs in and out\n-\tr8-r11\t\tcall saved\n-\tr12\t\t\n+\tr8-r12\t\tcall saved\n \tr13\t\tassembler temp\n \tr14\t\tframe pointer\n \tr15\t\tstack pointer\n@@ -195,11 +228,9 @@ extern int target_flags;\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n- /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 \n-     r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh   ml */\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh   ml */\n #define FIXED_REGISTERS  \\\n-   { 0,  0,  0,  0,  0,  0,  0,  0,  0, \t\t\\\n-     0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1, 1,   1}\n+   { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1, 1,   1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -208,11 +239,9 @@ extern int target_flags;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n- /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 \n-     r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh  ml */\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh  ml */\n #define CALL_USED_REGISTERS \\\n-   { 1,  1,  1,  1,  1,  1,  1,  1,  0, \\\n-     0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1, 1, 1}\n+   { 1,  1,  1,  1,  1,  1,  1,  1,  0, 0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1, 1, 1}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -252,7 +281,9 @@ extern int target_flags;\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n    via the stack pointer) in functions that seem suitable.  */\n-#define FRAME_POINTER_REQUIRED\t0\n+\n+\n+#define FRAME_POINTER_REQUIRED\t(get_frame_size() > 1000)\n \n /* Definitions for register eliminations.\n \n@@ -288,12 +319,10 @@ extern int target_flags;\n /* Register in which the static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM\t13\n \n-/* If the structure value address is not passed in a register, define\n-   this as an expression returning an RTX for the place\n-   where the address is passed.  If it returns 0, the address is\n-   passed as an \"invisible\" first argument. */\n+/* The register in which a struct value address is passed */\n+\n+#define STRUCT_VALUE_REGNUM 3\n \n-#define STRUCT_VALUE 0\n \n \f\n /* Define the classes of registers for register constraints in the\n@@ -372,7 +401,7 @@ extern int regno_reg_class[];\n \n /* The order in which register should be allocated.  */\n #define REG_ALLOC_ORDER  \\\n-  { 1,2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}\n+  { 1,2,3,7,4,5,6,0,8,9,10,11,12,13,14,15,16,17,18,19,20,21}\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  R0_REGS\n@@ -392,13 +421,13 @@ extern enum reg_class reg_class_from_letter[];\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \tI: arithmetic operand -127..128, as used in add, sub, etc\n-\tL: logical operand 0..255, as used in add, or, etc.\n+\tL: logical operand 0..255, as used in and, or, etc.\n \tM: constant 1\n \tK: shift operand 1,2,8 or 16 */\n \n \n-#define CONST_OK_FOR_I(VALUE) ((VALUE)>= -128 && (VALUE) <= 127)\n-#define CONST_OK_FOR_L(VALUE) ((VALUE)>= 0 && (VALUE) <= 255)\n+#define CONST_OK_FOR_I(VALUE) (((int)(VALUE))>= -128 && ((int)(VALUE)) <= 127)\n+#define CONST_OK_FOR_L(VALUE) (((int)(VALUE))>=    0 && ((int)(VALUE)) <= 255)\n #define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n #define CONST_OK_FOR_K(VALUE) ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n \n@@ -422,7 +451,7 @@ extern enum reg_class reg_class_from_letter[];\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)  CLASS\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n@@ -605,19 +634,13 @@ extern int current_function_anonymous_args;\n   current_function_anonymous_args = 1;\n \n \n-/* Generate assembly output for the start of a function.  */\n-\n-#define FUNCTION_PROLOGUE(STREAM, SIZE)  \\\n-  output_prologue ((STREAM), (SIZE))\n-\n /* Call the function profiler with a given profile label. */\n \n-#define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\\\n-{\t\t\t\t\t\t\t\\\n-    fprintf(STREAM, \"\\tsts.l\tpr,@-r15\\n\");\t\t\\\n-    fprintf(STREAM, \"\\tjsr\\tmcount\\n\");\t\t\t\\\n-    fprintf(STREAM, \"\\tor\tr0,r0\\n\");\t\t\\\n-    fprintf(STREAM, \"\\t.long\\tLP%d\\n\", (LABELNO));\t\\\n+#define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+\tfprintf(STREAM, \"\ttrapa\t#5\\n\");\t\t\t\\\n+ \tfprintf(STREAM, \"\t.align\t2\\n\");\t\t\t\\\n+\tfprintf(STREAM, \"\t.long\tLP%d\\n\", (LABELNO));\t\\\n }\n \n \n@@ -628,16 +651,11 @@ extern int current_function_anonymous_args;\n \n #define EXIT_IGNORE_STACK 0\n \n-/* Generate the assembly code for function exit. */\n+/* Generate the assembly code for function exit \n+   Just dump out any accumulated constant table.*/\n \n #define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n-  output_epilogue ((STREAM), (SIZE))\n-\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N) \\\n-  (get_attr_in_delay_slot(INSN) == IN_DELAY_SLOT_YES)  \n-\n-#define DELAY_SLOTS_FOR_EPILOGUE \\\n-  delay_slots_for_epilogue();\n+  dump_constants(0);  \n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n@@ -703,27 +721,19 @@ extern int current_function_anonymous_args;\n /* Maximum number of registers that can appear in a valid memory \n    address. */\n \n-#define MAX_REGS_PER_ADDRESS 1\n+#define MAX_REGS_PER_ADDRESS 4\n \n /* Recognize any constant value that is a valid address.  */\n \n #define CONSTANT_ADDRESS_P(X) \t\\\n   (GET_CODE (X) == LABEL_REF)\n-#if 0\n-\n-   || GET_CODE (X) == SYMBOL_REF\t\\\n-   || GET_CODE (X) == CONST_INT \t\\\n-   || GET_CODE (X) == CONST)\n-\n-#endif\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n \n-   On the SH, allow any thing but a double */\n+   On the SH, allow anything but a double */\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode)\n+#define LEGITIMATE_CONSTANT_P(X)  (GET_CODE(X) != CONST_DOUBLE)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -733,24 +743,32 @@ extern int current_function_anonymous_args;\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n \n #ifndef REG_OK_STRICT\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO(X) <= 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+    \t(REGNO (X) <= 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-    (REGNO(X)==0||REGNO(X)>=FIRST_PSEUDO_REGISTER)\n-#define REG_OK_FOR_PRE_POST_P(X) (REGNO(X) <= 16)\n+    \t(REGNO (X) == 0 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REG_OK_FOR_PRE_POST_P(X) \\\n+  \t(REGNO (X) <= 16)\n+\n #else\n \n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_BASE_P(X)\t\\\n+\tREGNO_OK_FOR_BASE_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X) \t\\\n+  \tREGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n #define REG_OK_FOR_PRE_POST_P(X)  \\\n-\t (REGNO (X) <= 16 || (unsigned) reg_renumber[REGNO (X)] <=16)\n+\t(REGNO (X) <= 16 || (unsigned) reg_renumber[REGNO (X)] <=16)\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -759,6 +777,7 @@ extern int current_function_anonymous_args;\n    that wants to use this address.\n \n    The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+\n #define BASE_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n \n@@ -777,14 +796,20 @@ extern int current_function_anonymous_args;\n \t  --REG\n */\n \n-/* A legitimate index for a QI or HI is 0, SI and above can be any \n-   number 0..64 */\n+/* The SH allows a displacement in a QI or HI amode, but only when the \n+   other operand is R0. GCC doesn't handle this very well, so we forgo\n+   all of that.\n+\n+   A legitimate index for a QI or HI is 0, SI and above can be any \n+   number 0..63 */\n \n #define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \\\n   do {\t\t\t\t\t\t\t\\\n     if (GET_CODE (OP) == CONST_INT) \t\t\t\\\n       {\t\t\t\t\t\t\t\\\n-\tif (GET_MODE_SIZE (MODE) < 4 && INTVAL(OP) == 0)\\\n+\tif (0&&GET_MODE_SIZE (MODE) == 2 && ((unsigned)INTVAL(OP)) <=30)\\\n+\t  goto LABEL;\t\t\t\t\t\\\n+\tif (0&&GET_MODE_SIZE (MODE) == 1 && ((unsigned)INTVAL(OP)) <=15)\\\n \t  goto LABEL;\t\t\t\t\t\\\n \tif (GET_MODE_SIZE (MODE) >=4 \t\t\t\\\n \t    && ((unsigned)INTVAL(OP)) < 64)\t\t\\\n@@ -793,32 +818,37 @@ extern int current_function_anonymous_args;\n   } while(0)\n \n \n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xop0 = XEXP(X,0);\t\t\t\t\t\t\\\n-      rtx xop1 = XEXP(X,1);\t\t\t\t\t\t\\\n-      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n-      else if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t\\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)                  \\\n+{ \t\t\t\t\t\t\t\t  \\\n+  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t  \\\n+    goto LABEL;\t\t\t\t\t\t\t  \\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)  \\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n+    goto LABEL;\t\t\t\t\t\t\t  \\\n+  else if (GET_CODE (X) == PLUS || GET_CODE(X) == LO_SUM) \t  \\\n+    {\t\t\t\t\t\t\t\t  \\\n+      rtx xop0 = XEXP(X,0);\t\t\t\t\t  \\\n+      rtx xop1 = XEXP(X,1);\t\t\t\t\t  \\\n+      if (GET_MODE_SIZE(MODE) >= 4 && BASE_REGISTER_RTX_P (xop0)) \\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n+      if (GET_MODE_SIZE(MODE) >= 4 && BASE_REGISTER_RTX_P (xop1)) \\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL); \\\n+      if (GET_MODE_SIZE(MODE)<=4) {\t\t\t\t  \\\n+\tif(BASE_REGISTER_RTX_P(xop1) &&\t\t\t \t  \\\n+\t   INDEX_REGISTER_RTX_P(xop0)) goto LABEL;\t\t  \\\n+\tif(INDEX_REGISTER_RTX_P(xop1) &&\t\t\t  \\\n+\t   BASE_REGISTER_RTX_P(xop0)) goto LABEL;\t\t  \\\n+      }\t\t\t\t\t\t\t \t  \\\n+    }\t\t\t\t\t\t\t\t  \\\n+  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)  \\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n+    goto LABEL;                                                   \\\n+}\t\t\t\t\t\t\t\t   \n+\t\t\t\t\t\t\t\t   \n+\f\t\t\t\t\t\t\t\t   \n+/* Try machine-dependent ways of modifying an illegitimate address \n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n \n@@ -926,17 +956,21 @@ extern int current_function_anonymous_args;\n     if (CONST_OK_FOR_I (INTVAL(RTX)))           \\\n       return 1;\t\t\t\t\t\\\n     else\t\t\t\t\t\\\n-      return 5;\t\t\t\t\t\\\n+      return 8;\t\t\t\t\t\\\n   case CONST: \t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\\\n-    return 6;\t\t\t\t\t\\\n+    return 5;\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\\\n       return 10;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (TARGET_HAS_MULSI3 ? 2 : 20); \t\\\n+    return COSTS_N_INSNS (multcosts (X));\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\\\n+  case LSHIFT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (shiftcosts (X)) ;\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -954,14 +988,18 @@ extern int current_function_anonymous_args;\n */\n \n #define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS)  \\\n-    ((DSTCLASS ==T_REGS) ? 10 : 2)\n+\t((DSTCLASS == T_REGS) ? 10 : 1)\n \f\n /* Assembler output control */\n \n /* The text to go at the start of the assembler file */\n-#define ASM_FILE_START(STREAM) \\\n-  fprintf (STREAM,\"! GCC for the Hitachi Super-H\\n\");  \t\\\n-  output_file_directive (STREAM, main_input_filename);\n+#define ASM_FILE_START(STREAM) \t\t\t\t\t\t\t\\\n+  output_file_start (STREAM, f_options, sizeof f_options / sizeof f_options[0], \\\n+\t\t     W_options, sizeof W_options / sizeof W_options[0]); \t\n+\n+\n+#define ASM_FILE_END(STREAM) \\\n+  dump_constants(0);  \n \n #define ASM_APP_ON  \"\"\n #define ASM_APP_OFF  \"\"\n@@ -971,9 +1009,78 @@ extern int current_function_anonymous_args;\n \n \n /* Switch to the text or data segment.  */\n-#define TEXT_SECTION_ASM_OP  \".text\"\n-#define DATA_SECTION_ASM_OP  \".data\"\n+#define TEXT_SECTION_ASM_OP  \"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \"\\t.data\"\n+#define CTORS_SECTION_ASM_OP \"\\t.section\\t.ctors\\n\"\n+#define DTORS_SECTION_ASM_OP \"\\t.section\\t.dtors\\n\"\n+\n+#define EXTRA_SECTIONS in_ctors, in_dtors\n+#define EXTRA_SECTION_FUNCTIONS                              \\\n+void\t\t\t\t\t\t\t     \\\n+ctors_section() \t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t     \\\n+  if (in_section != in_ctors)\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t     \\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);  \\\n+      in_section = in_ctors;\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t     \\\n+}\t\t\t\t\t\t\t     \\\n+void\t\t\t\t\t\t\t     \\\n+dtors_section() \t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t     \\\n+  if (in_section != in_dtors)\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t     \\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);  \\\n+      in_section = in_dtors;\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t     \\\n+}\t\t\t\t\t\t\t      \n+\n+#define ASM_OUTPUT_SECTION(file, nam) \\\n+   do { fprintf (file, \"\\t.section\\t%s\\n\", nam); } while(0) \n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+   do { ctors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n+\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n+   do {  dtors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n+\n+\n+#undef DO_GLOBAL_CTORS_BODY                     \n+#define DO_GLOBAL_CTORS_BODY\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  typedef (*pfunc)();\t\t\t\t\\\n+  extern pfunc __ctors[];\t\t\t\\\n+  extern pfunc __ctors_end[];\t\t\t\\\n+  pfunc *p;\t\t\t\t\t\\\n+  for (p = __ctors; p < __ctors_end; p++)\t\\\n+    {\t\t\t\t\t\t\\\n+      (*p)();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\n+\n+#undef DO_GLOBAL_DTORS_BODY\t\t\t \n+#define DO_GLOBAL_DTORS_BODY                    \\\n+{\t\t\t\t\t\t\\\n+  typedef (*pfunc)();\t\t\t\t\\\n+  extern pfunc __dtors[];\t\t\t\\\n+  extern pfunc __dtors_end[];\t\t\t\\\n+  pfunc *p;\t\t\t\t\t\\\n+  for (p = __dtors; p < __dtors_end; p++)\t\\\n+    {\t\t\t\t\t\t\\\n+      (*p)();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t \n+\n+\n+\n+#define ASM_OUTPUT_REG_PUSH(file, v) \\\n+  fprintf (file, \"\\tmov.l\tr%s,-@r15\\n\", v);\n \n+#define ASM_OUTPUT_REG_POP(file, v) \\\n+  fprintf (file, \"\\tmov.l\t@r15+,r%s\\n\", v);\n+\n+\n+  \n /* The assembler's names for the registers.  RFP need not always be used as\n    the Real framepointer; it can also be used as a normal general register.\n    Note that the name `fp' is horribly misleading since `fp' is in fact only\n@@ -1048,22 +1155,20 @@ extern int current_function_anonymous_args;\n \n /* This is how to output an assembler line defining a `double' */\n \n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tlong t[2];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n-\tfprintf (FILE, \"\\t.long\\t0x%lx\\n\\t.long\\t0x%lx\\n\",\t\t\\\n-\t\t  t[0], t[1]);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n \n /* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n+   } while (0)\n \n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-\tlong t;\t\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n-\tfprintf (FILE, \"\\t.long\\t0x%lx\\n\", t);\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n   (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n@@ -1123,7 +1228,7 @@ extern int current_function_anonymous_args;\n /* Only perform branch elimination (by making instructions conditional) if\n    we're optimising.  Otherwise it's of no use anyway.  */\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n-    final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+     final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n@@ -1136,7 +1241,7 @@ extern int current_function_anonymous_args;\n #define PRINT_OPERAND_ADDRESS(STREAM,X)  print_operand_address (STREAM, X)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n+  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n \n \f\n /* Define the information needed to generate branch insns.  This is stored\n@@ -1147,7 +1252,7 @@ extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n extern struct rtx_def *prepare_scc_operands();\n \n-\n+extern enum attr_cpu sh_cpu;\t/* target cpu */\n \n /* Declare functions defined in sh.c and used in templates. */\n \n@@ -1159,3 +1264,8 @@ extern char *output_movepcrel();\n \n #define ADJUST_INSN_LENGTH(insn, length) \\\n   adjust_insn_length (insn, insn_lengths)\n+\n+\n+\n+\n+"}, {"sha": "5ba25734a1d895392f696526c16dee9f14eb5571", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 261, "deletions": 188, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b9654711e95a6cfe8f482c446cf9eba6e2310956", "patch": "@@ -26,7 +26,12 @@\n ;; Attributes\n ;; -------------------------------------------------------------------------\n \n-(define_attr \"type\" \"cbranch,ctable,jump,arith,other\"\n+; Target CPU.\n+\n+(define_attr \"cpu\" \"sh0,sh1,sh2,sh3\"\n+  (const (symbol_ref \"sh_cpu\")))\n+\n+(define_attr \"type\" \"cbranch,ctable,jump,arith,other,load,store,move,smpy,dmpy,return,pload\"\n   (const_string \"other\"))\n \n ; If a conditional branch destination is within -100..100 bytes away \n@@ -62,12 +67,24 @@\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 6))\n \t ] (const_int 2)))\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \t\t\t\t      \n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 1 0)\n+(define_function_unit \"mpy\"    1 1 (eq_attr \"type\" \"smpy\") 3 0)\n+(define_function_unit \"mpy\"    1 1 (eq_attr \"type\" \"dmpy\") 5 0)\n \n (define_attr \"needs_delay_slot\" \"yes,no\"\n-  (cond [(eq_attr \"type\" \"jump\") (const_string \"yes\")]\n+  (cond [(eq_attr \"type\" \"jump\") (const_string \"yes\")\n+\t (eq_attr \"type\" \"return\") (const_string \"yes\")]\n \t(const_string \"no\")))\n \n+(define_delay \n+  (eq_attr \"needs_delay_slot\" \"yes\") \n+  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n+\n+\n (define_attr \"dump\" \"yes,no,must\" (const_string \"no\"))\n (define_attr \"constneed\" \"yes,no\" (const_string \"no\"))\n (define_attr \"smallestsize\" \"\" (const_int 2))\n@@ -77,15 +94,13 @@\n (define_attr \"in_delay_slot\" \"maybe,yes,no\" \n   (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n \t (eq_attr \"type\" \"jump\") (const_string \"no\")\n+\t (eq_attr \"type\" \"pload\") (const_string \"no\")\n+\t (eq_attr \"type\" \"return\") (const_string \"no\")\n \t (eq_attr \"length\" \"2\") (const_string \"yes\")\n \t (eq_attr \"length\" \"4,6,8,10,12\") (const_string \"no\")\n \t ] (const_string \"yes\")))\n \n \n-(define_delay (eq_attr \"needs_delay_slot\" \"yes\")\n-  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n-\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -137,7 +152,7 @@\n \n (define_insn \"cmplesi_t\"\n   [(set (reg:SI 18) (le (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+\t\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"\"\n   \"cmp/ge\t%0,%1\")\n \n@@ -233,11 +248,13 @@\n    (set_attr \"type\" \"arith\")])\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n   \"\"\n-  \"sub\t%2,%0\"\n+  \"@\n+\tsub\t%2,%0\n+\tadd\t%M2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n \f\n@@ -253,7 +270,8 @@\n \t\t (zero_extend:SI\n \t\t  (match_operand:HI 2 \"arith_reg_operand\" \"r\"))))]\n   \"\"\n-  \"mulu\t%2,%1\")\n+  \"mulu\t%2,%1\"\n+  [(set_attr \"type\" \"smpy\")])\n \n (define_insn \"\"\n   [(set (reg:SI 21)\n@@ -262,7 +280,8 @@\n \t\t (sign_extend:SI\n \t\t  (match_operand:HI 2 \"arith_reg_operand\" \"r\"))))]\n   \"\"\n-  \"muls\t%2,%1\")\n+  \"muls\t%2,%1\"\n+  [(set_attr \"type\" \"smpy\")])\n \n (define_expand \"mulhisi3\"\n   [(set (reg:SI 21)\n@@ -286,61 +305,6 @@\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (reg:SI 21)\n-\t(mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"muls.l\t%2,%1\")\n-\n-(define_expand \"mulsi3\"\n-  [(set (reg:SI 21)\n-\t(mult:SI  (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))\n-   (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(reg:SI 20))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (sign_extend:DI\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t (sign_extend:DI\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"dmuls.l\t%2,%1\")\n-\n-(define_expand \"mulsidi3\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (sign_extend:DI\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t (sign_extend:DI\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n-   (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(reg:DI 20))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (zero_extend:DI\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t (zero_extend:DI\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"dmulu.l\t%2,%1\")\n-\n-(define_expand \"umulsidi3\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (zero_extend:DI\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t (zero_extend:DI\n-\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n-   (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(reg:DI 20))]\n-  \"TARGET_HAS_MULSI3\"\n-  \"\")\n \f\n ;; -------------------------------------------------------------------------\n ;; Logical operations\n@@ -374,35 +338,71 @@\n ;; Shifts and rotates\n ;; -------------------------------------------------------------------------\n \n+(define_insn \"rotlsi3_k\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (const_int 1)))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"rotl\t%0\")\n+\n+(define_expand \"rotlsi3\"\n+  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t  (rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t     (match_operand:SI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n+  \"\"\n+  \"{ if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) != 1) FAIL;}\")\n+\n+(define_insn \"rotrsi3_k\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"rotr\t%0\")\n+\n+(define_expand \"rotrsi3\"\n+  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t   (rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"immediate_operand\" \"\")))\n+\t      (clobber (reg:SI 18))])]\n+  \"\"\n+  \"{ if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) != 1) FAIL;}\")\n+\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"L,n\")))]\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"K,n\")))\n+   (clobber (reg:SI 18))]\n   \"\"\n-  \"*return output_shift(\\\"shll\\\", operands[0], operands[2]);\"\n+  \"*return output_shift(\\\"shll\\\", operands[0], operands[2], ASHIFT);\"\n   [(set_attr \"length\" \"2,12\")\n    (set_attr \"in_delay_slot\" \"yes,no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t  (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t     (match_operand:SI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"if (!ok_shift_value(operands[2])) FAIL;\")\n+  \"if (!ok_shift_value(operands[2], ASHIFT)) FAIL;\")\n \n (define_insn \"ashrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (const_int 1)))]\n+\t\t     (const_int 1)))\n+   (clobber (reg:SI 18))]\n   \"\"\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n (define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"M\")))]\n+  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t\t  (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"M\")))\n+\t     (clobber (reg:SI 18))])]\n   \"\"\n   \"\n {\n@@ -412,19 +412,21 @@\n \")\n \n (define_insn \"lshrsi3_k\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"L\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"K,n\")))\n+   (clobber (reg:SI 18))]\n   \"\"\n-  \"* return output_shift (\\\"shlr\\\", operands[0], operands[2]);\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"in_delay_slot\" \"no\")\n+  \"* return output_shift (\\\"shlr\\\", operands[0], operands[2], LSHIFTRT);\"\n+  [(set_attr \"length\" \"2,12\")\n+   (set_attr \"in_delay_slot\" \"yes,no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t  (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n   \"\"\n   \"if (!ok_shift_value (operands[2])) FAIL; \")\n \n@@ -449,9 +451,9 @@\n \n (define_insn \"lshrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t\t   (lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t\t      (match_operand:DI 2 \"immediate_operand\" \"I\")))\n-      (clobber (reg:SI 18))]\n+\t(lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (match_operand:DI 2 \"immediate_operand\" \"I\")))\n+   (clobber (reg:SI 18))]\n   \"\"\n   \"shlr\t%0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")])\n@@ -574,55 +576,99 @@\n ;; -------------------------------------------------------------------------\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-\t(match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n-   \"\"\n-   \"mov.l\t%1,%0\")\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:SI 1 \"arith_reg_operand\" \"r,l\"))]\n+  \"\"\n+  \"@\n+\tmov.l\t%1,%0\n+\tsts.l\tpr,%0\"\n+  [(set_attr \"type\" \"store\")])\n \n-(define_insn \"movsi_pcrel\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:SI 1 \"hard_immediate_operand\" \"i\"))]\n+(define_insn \"\"\n+  [(set\t(match_operand:SI 0 \"arith_reg_operand\" \"=r,l\")\n+\t(match_operand:SI 1 \"pop_operand\" \"=>,>\"))]\n   \"\"\n-  \"* return output_movepcrel (insn, operands, SImode);\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")])\n-\t\t\n+  \"@\n+\tmov.l\t%1,%0\n+\tlds.l\t%1,pr\"\n+  [(set_attr \"type\" \"load,pload\")])\n+\n+(define_insn \"push\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI 15)))\n+\t(match_operand:SI 0 \"register_operand\" \"r,l\"))]\n+  \"\"\n+  \"@\n+\tmov.l\t%0,@-r15\n+\tsts.l\tpr,@-r15\")\n+\n+(define_insn \"pop\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,l\")\n+\t(mem:SI (post_inc:SI (reg:SI 15))))]\n+  \"\"\n+  \"@\n+\tmov.l\t@r15+,%0\n+\tlds.l\t@r15+,pr\"\n+  [(set_attr \"type\" \"load,pload\")])\n+\n+; some constants are easier to generate with alu operations\n+; rather than loading from memory\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"painful_immediate_operand\" \"i\"))]\n+  \"\"\n+  [(set (match_dup 0) (const_int 127))\n+   (set (match_dup 0) (plus:SI (match_dup 0)\n+\t\t\t       (match_dup 2)))]\n+  \"operands[2] = GEN_INT (INTVAL(operands[1]) - 127);\" )\n+\n (define_insn \"movsi_i\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m,l,r,r,r,t\")\n-\t(match_operand:SI 1 \"general_operand\"  \"r,I,m,r,r,l,t,x,r\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m,l,r,r,r,t,x\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\"  \"r,I,m,r,r,l,t,x,r,r\"))]\n   \"\"\n   \"@\n \tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n \tmov.l\t%1,%0\n-\tmov\t%1,%0\n-\tmov\t%1,%0\n+\tlds\t%1,%0\n+\tsts\t%1,%0\n         movt\t%0\n \tsts\t%1,%0\n-\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\"\n-\t[(set_attr \"length\" \"2,2,2,2,2,2,2,2,10\")])\n+\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\n+\tlds\t%1,%0\"\n+  [(set_attr \"length\" \"2,2,2,2,2,2,2,2,10,2\")\n+   (set_attr \"type\" \"move,move,load,pload,move,move,move,move,move,move\")])\n+\n+(define_insn \"movsi_pcrel\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(match_operand:SI 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel (insn, operands, SImode);\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"2\")\n+   (set_attr \"largestsize\" \"8\")\n+   (set_attr \"type\" \"load\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"{ prepare_move_operands(operands, SImode); } \")\n+  \"{ if(prepare_move_operands(operands, SImode)) DONE; } \")\n \n (define_insn \"movqi_i\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,z,m,r,m,r,r\")\n-\t(match_operand:QI 1 \"general_operand\"  \"r,n,m,z,m,r,x,t\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,m,r,m,r,r\")\n+\t(match_operand:QI 1 \"general_operand\"  \"r,n,m,r,m,r,x,t\"))]\n   \"\"\n   \"@\n \tmov\t%1,%0\n \tmov\t%1,%0\n-\tmov.b\t%1,%0 !4\n-\tmov.b\t%1,%0 !5\n-\tmov.b\t%1,%0 !6\n-\tmov.b\t%1,%0 ! 7\n+\tmov.b\t%1,%0 \n+\tmov.b\t%1,%0 \n+\tmov.b\t%1,%0 \n+\tmov.b\t%1,%0 \n \tsts\t%1,%0\n \tmovt\t%0\")\n \n@@ -641,7 +687,8 @@\n    (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"constneed\" \"yes\")\n    (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")])\n+   (set_attr \"largestsize\" \"8\")\n+   (set_attr \"type\" \"load\")])\n \n (define_insn \"movhi_i\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m,z,m,r,r\")\n@@ -654,7 +701,8 @@\n \tmov.w\t%1,%0\n \tmov.w\t%1,%0\n \tsts\t%1,%0\n-\tmovt\t%0\")\n+\tmovt\t%0\"\n+  [(set_attr \"type\" \"move,load,store,load,store,move,move\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -667,7 +715,8 @@\n \t(match_operand:DI 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n    \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n-   [(set_attr \"length\" \"4\")])\n+   [(set_attr \"length\" \"4\")\n+    (set_attr \"type\" \"store\")])\n \n (define_insn \"movdi_pcrel\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -679,14 +728,17 @@\n    (set_attr \"constneed\" \"yes\")\n    (set_attr \"smallestsize\" \"4\")\n    (set_attr \"constantsize\" \"8\")\n-   (set_attr \"largestsize\" \"18\")])\n+   (set_attr \"largestsize\" \"18\")\n+   (set_attr \"type\" \"load\")])\n \n (define_insn \"movdi_k\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=r,r,m,r,r,m,r\")\n \t(match_operand:DI 1 \"general_operand\" \"r,m,r,I,m,r,x\"))]\n   \"\"\n   \"* return output_movedouble(operands, DImode);\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"move,load,store,move,load,store,load\")])\n+\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -699,7 +751,8 @@\n \t(match_operand:DF 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n    \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n-   [(set_attr \"length\" \"4\")])\n+   [(set_attr \"length\" \"4\")\n+    (set_attr \"type\" \"store\")])\n \n (define_insn \"movdf_pcrel\"\n   [(set (match_operand:DF 0 \"arith_reg_operand\" \"=r\")\n@@ -711,14 +764,16 @@\n    (set_attr \"constneed\" \"yes\")\n    (set_attr \"smallestsize\" \"4\")\n    (set_attr \"constantsize\" \"8\")\n-   (set_attr \"largestsize\" \"18\")])\n+   (set_attr \"largestsize\" \"18\")\n+   (set_attr \"type\" \"load\")])\n \n (define_insn \"movdf_k\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=r,r,m\")\n \t(match_operand:DF 1 \"general_operand\" \"r,m,r\"))]\n   \"\"\n   \"* return output_movedouble(operands, DFmode);\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"move,load,store\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -730,7 +785,8 @@\n   [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n \t(match_operand:SF 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n-   \"mov.l\t%1,%0\")\n+   \"mov.l\t%1,%0\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"movsf_pcrel\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=r\")\n@@ -741,7 +797,8 @@\n    (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"constneed\" \"yes\")\n    (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")])\n+   (set_attr \"largestsize\" \"8\")\n+   (set_attr \"type\" \"load\")])\n \t\t\n (define_insn \"movsf_i\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=r,r,r,m,l,r,m,r\")\n@@ -752,10 +809,11 @@\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n \tmov.l\t%1,%0\n+\tlds\t%1,%0\n+\tsts\t%1,%0\n \tmov\t%1,%0\n-\tmov\t%1,%0\n-\tmov\t%1,%0\n-\tmov\t%1,%0\")\n+\tmov\t%1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store,move,move,move,move\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -1037,7 +1095,7 @@\n   [(set (pc)\n \t(match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n   \"\"\n-  \"jmp\t@%0\"\n+  \"jmp\t@%0%#\"\n   [(set_attr \"needs_delay_slot\" \"yes\")\n    (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"length\" \"4\")])\n@@ -1064,6 +1122,31 @@\n    (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"jump\")\n    (set_attr \"dump\" \"no\")])\n+\n+(define_insn \"return\"\n+ [(return)]\n+ \"reload_completed\"\n+ \"rts\t%#\"\n+ [(set_attr \"type\" \"return\")\n+  (set_attr \"needs_delay_slot\" \"yes\")\n+  (set_attr \"dump\" \"yes\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"sh_expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"sh_expand_epilogue ();\")\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n \f\n ;; ------------------------------------------------------------------------\n ;; Scc instructions\n@@ -1136,6 +1219,9 @@\n   \"\"\n   \"operands[1] = prepare_scc_operands (EQ);\")\n \n+; these patterns give better code then gcc invents if\n+; left to its own devices\n+\n (define_insn \"anddi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(and:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n@@ -1174,63 +1260,13 @@\n   \"\"\n   \"\n {\n-  rtx src_ptr = copy_to_mode_reg(Pmode,XEXP(operands[1], 0));\n-  rtx dst_ptr = copy_to_mode_reg(Pmode,XEXP(operands[0], 0));\n-  int maxsize = GET_CODE (operands[2]) == CONST_INT\t\n-\t? MAX (INTVAL (operands[2]), INTVAL (operands[3])) : 1;\n-  enum machine_mode mode = \n-     (maxsize >= 4) ? SImode :\n-\t(maxsize >= 2) ? HImode :\n-\t  QImode;\n-\n-  rtx tmpreg = gen_reg_rtx(mode);\n-  rtx increment =  GEN_INT(GET_MODE_SIZE(mode));\n-  rtx length = operands[2];\n-  rtx label = gen_label_rtx();\n-  rtx end_src_ptr = gen_reg_rtx(Pmode);\n-\n-  /* If done first rtl emmiting stage we can't generate a loop */\n-  /*  if    (!rtx_equal_function_value_matters)\n-      FAIL;*/\n-  \n-  if (GET_CODE (length) != CONST_INT)\n-    length = convert_to_mode (Pmode, length, 1);\n-\n-  if (!arith_operand (length, SImode))\n-\tlength = force_reg (SImode, length);\n-\t\n-  emit_insn(gen_rtx(SET,\n-\t\t    VOIDmode, \n-\t\t    end_src_ptr,\n-\t\t    gen_rtx(PLUS, Pmode, src_ptr, length)));\n-\n-\n-  emit_label(label);\n-  emit_move_insn(tmpreg, gen_rtx(MEM, mode, src_ptr));\n-\n-\n-  emit_insn(gen_rtx(SET,\n-\t\t    VOIDmode,\n-\t\t    src_ptr,\n-\t\t    gen_rtx(PLUS, Pmode, src_ptr, increment)));\n-\n-  emit_move_insn(gen_rtx(MEM, mode, dst_ptr), tmpreg);\n-\n-  emit_insn(gen_rtx(SET, \n-\t\t    VOIDmode,\n-\t\t    dst_ptr,\n-\t\t    gen_rtx(PLUS, Pmode, dst_ptr, increment)));\n-\n-  sh_compare_op0 = src_ptr;\n-  sh_compare_op1 = end_src_ptr;\n-  \n-  emit_insn(gen_cmpeqsi_t(src_ptr, end_src_ptr));\n-  emit_jump_insn(gen_bne(label));\n-  emit_insn(gen_rtx(SET, VOIDmode, dst_ptr, dst_ptr));\n-  \n-  DONE;\t\n-}\n-\")\n+  rtx dest_mem = operands[0];\n+  rtx src_mem = operands[1];\n+  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  expand_block_move (dest_mem, src_mem, operands);\n+  DONE;\n+}\")\n \n \n \n@@ -1262,4 +1298,41 @@\n   \"REGNO(operands[1]) != REGNO(operands[0])\"\n   \"mov.l\t@%1+,%0\")\n \n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_dup 0)))]\n+  \"REGNO(operands[0]) == REGNO(operands[2])\"\n+  \"mov.b\t%1,%0\")\n+\n+(define_peephole \n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_dup 0)))]\n+  \"REGNO(operands[0]) != REGNO(operands[2]) \n+   && dead_or_set_p (insn, operands[0])\"\n+  \"mov.b\t%1,%2\")\n+\n+; notice when a mov.b could be done with a displacement\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 1 \"byte_index_operand\" \"i\")))\n+   (set (mem:QI (match_dup 0))\t(reg:QI 0))]\n+  \"dead_or_set_p(insn, operands[0])\"\n+  \"mov.b\tr0,@(%O1,%0)\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 1 \"byte_index_operand\" \"i\")))\n+   (set (reg:QI 0) (mem:QI (match_dup 0)))]\n+  \"dead_or_set_p(insn, operands[0])\"\n+  \"mov.b\t@(%O1,%0),r0\")\n+  \n+\n+\n "}, {"sha": "468ad98afcd7709d151cbaab20af90396b4dbbd4", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=b9654711e95a6cfe8f482c446cf9eba6e2310956", "patch": "@@ -1,15 +1,5 @@\n LIBGCC1 = libgcc1.null\n-T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP  -Dinhibit_libc\n-LIBGCC2_CFLAGS=-g -fno-omit-frame-pointer -O2 $(GCC_CFLAGS) \n-\n-# These are really part of libgcc1, but this will cause them to be\n-# built correctly, so... [taken from t-ose68k]\n-LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP  -Dinhibit_libc \n+LIBGCC2_CFLAGS=-g -O5 $(GCC_CFLAGS) \n \n "}, {"sha": "148ff57267a950e99610d0aac71dd9486027c13f", "filename": "gcc/config/sh/xm-sh.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fxm-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9654711e95a6cfe8f482c446cf9eba6e2310956/gcc%2Fconfig%2Fsh%2Fxm-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fxm-sh.h?ref=b9654711e95a6cfe8f482c446cf9eba6e2310956", "patch": "@@ -1,6 +1,6 @@\n /* Configuration for GNU C-compiler for Hitachi SH.\n    Copyright (C) 1993 Free Software Foundation, Inc.\n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -26,6 +26,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define HOST_BITS_PER_INT 32\n #define HOST_BITS_PER_LONG 32\n \n+/* If compiled with GNU C, use the built-in alloca.  */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif\n+\n /* target machine dependencies.\n    tm.h is a symbolic link to the actual target specific file.  */\n #include \"tm.h\""}]}