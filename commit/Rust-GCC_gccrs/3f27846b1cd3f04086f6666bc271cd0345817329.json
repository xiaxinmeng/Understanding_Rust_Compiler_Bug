{"sha": "3f27846b1cd3f04086f6666bc271cd0345817329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyNzg0NmIxY2QzZjA0MDg2ZjY2NjZiYzI3MWNkMDM0NTgxNzMyOQ==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2005-09-30T18:09:56Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-09-30T18:09:56Z"}, "message": "reload1.c (merge_assigned_reloads): Do not change any RELOAD_FOR_OUTPUT_ADDRESS reloads.\n\n\t* reload1.c (merge_assigned_reloads): Do not change any\n\tRELOAD_FOR_OUTPUT_ADDRESS reloads.\n\nFrom-SVN: r104827", "tree": {"sha": "c800022dbcbe625bd5923ca8f78b11ed3a2aa448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c800022dbcbe625bd5923ca8f78b11ed3a2aa448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f27846b1cd3f04086f6666bc271cd0345817329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f27846b1cd3f04086f6666bc271cd0345817329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f27846b1cd3f04086f6666bc271cd0345817329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f27846b1cd3f04086f6666bc271cd0345817329/comments", "author": null, "committer": null, "parents": [{"sha": "f46876f99ca558a311cf215f9eec26a4db4097e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46876f99ca558a311cf215f9eec26a4db4097e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46876f99ca558a311cf215f9eec26a4db4097e0"}], "stats": {"total": 16, "additions": 12, "deletions": 4}, "files": [{"sha": "e6fc8a8338d78f62f33818977d92f234b143d2a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27846b1cd3f04086f6666bc271cd0345817329/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27846b1cd3f04086f6666bc271cd0345817329/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f27846b1cd3f04086f6666bc271cd0345817329", "patch": "@@ -1,3 +1,8 @@\n+2005-09-30  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* reload1.c (merge_assigned_reloads): Do not change any\n+\tRELOAD_FOR_OUTPUT_ADDRESS reloads.\n+\n 2005-09-30  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/t-slibgcc-darwin (libgcc_s_%.dylib): Remove old symlinks"}, {"sha": "d8eeb2a5e71ac9ed9c76b0afa8926ddac13a1b29", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27846b1cd3f04086f6666bc271cd0345817329/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27846b1cd3f04086f6666bc271cd0345817329/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3f27846b1cd3f04086f6666bc271cd0345817329", "patch": "@@ -6083,6 +6083,8 @@ merge_assigned_reloads (rtx insn)\n       if (j == n_reloads\n \t  && max_input_address_opnum <= min_conflicting_input_opnum)\n \t{\n+\t  gcc_assert (rld[i].when_needed != RELOAD_FOR_OUTPUT);\n+\n \t  for (j = 0; j < n_reloads; j++)\n \t    if (i != j && rld[j].reg_rtx != 0\n \t\t&& rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)\n@@ -6101,16 +6103,17 @@ merge_assigned_reloads (rtx insn)\n \t     if they were for inputs, RELOAD_OTHER for outputs.  Note that\n \t     this test is equivalent to looking for reloads for this operand\n \t     number.  */\n-\t  /* We must take special care when there are two or more reloads to\n-\t     be merged and a RELOAD_FOR_OUTPUT_ADDRESS reload that loads the\n-\t     same value or a part of it; we must not change its type if there\n-\t     is a conflicting input.  */\n+\t  /* We must take special care with RELOAD_FOR_OUTPUT_ADDRESS; it may\n+\t     share registers with a RELOAD_FOR_INPUT, so we can not change it\n+\t     to RELOAD_FOR_OTHER_ADDRESS.  We should never need to, since we\n+\t     do not modify RELOAD_FOR_OUTPUT.  */\n \n \t  if (rld[i].when_needed == RELOAD_OTHER)\n \t    for (j = 0; j < n_reloads; j++)\n \t      if (rld[j].in != 0\n \t\t  && rld[j].when_needed != RELOAD_OTHER\n \t\t  && rld[j].when_needed != RELOAD_FOR_OTHER_ADDRESS\n+\t\t  && rld[j].when_needed != RELOAD_FOR_OUTPUT_ADDRESS\n \t\t  && (! conflicting_input\n \t\t      || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n \t\t      || rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)"}]}