{"sha": "6532e8a053ffec70ea1637fdf50e3838db0d122a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzMmU4YTA1M2ZmZWM3MGVhMTYzN2ZkZjUwZTM4MzhkYjBkMTIyYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-10T12:09:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-10T12:09:46Z"}, "message": "trans.c (gigi): Don't set 'pure' flag on SJLJ routines.\n\n\t* gcc-interface/trans.c (gigi): Don't set 'pure' flag on SJLJ routines.\n\t* gcc-interface/utils2.c (compare_arrays): Add LOC parameter.  Set it\n\tdirectly on all the comparison expressions.\n\t(build_binary_op): Pass input_location to compare_arrays.\n\nFrom-SVN: r166533", "tree": {"sha": "ed099f59133841c5f14bdfda0f424c72d4bd3d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed099f59133841c5f14bdfda0f424c72d4bd3d46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6532e8a053ffec70ea1637fdf50e3838db0d122a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6532e8a053ffec70ea1637fdf50e3838db0d122a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6532e8a053ffec70ea1637fdf50e3838db0d122a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6532e8a053ffec70ea1637fdf50e3838db0d122a/comments", "author": null, "committer": null, "parents": [{"sha": "054d6b836f08882538082f76547c4414cb52e0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054d6b836f08882538082f76547c4414cb52e0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054d6b836f08882538082f76547c4414cb52e0ba"}], "stats": {"total": 56, "additions": 26, "deletions": 30}, "files": [{"sha": "ca0ffe92c31c4c8779021ad43e3334cb685f19de", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6532e8a053ffec70ea1637fdf50e3838db0d122a", "patch": "@@ -1,3 +1,10 @@\n+2010-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gigi): Don't set 'pure' flag on SJLJ routines.\n+\t* gcc-interface/utils2.c (compare_arrays): Add LOC parameter.  Set it\n+\tdirectly on all the comparison expressions.\n+\t(build_binary_op): Pass input_location to compare_arrays.\n+\n 2010-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (lvalue_required_p) <N_Type_Conversion>): Look"}, {"sha": "1ab0b15e927c3b8f37f467abd75d39b752bfb44d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6532e8a053ffec70ea1637fdf50e3838db0d122a", "patch": "@@ -399,8 +399,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n      NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n      NULL_TREE, false, true, true, NULL, Empty);\n-  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n-  DECL_PURE_P (get_jmpbuf_decl) = 1;\n   DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n \n   set_jmpbuf_decl\n@@ -502,8 +500,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      NULL_TREE,\n      build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n      NULL_TREE, false, true, true, NULL, Empty);\n-  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n-  DECL_PURE_P (get_excptr_decl) = 1;\n \n   raise_nodefer_decl\n     = create_subprog_decl"}, {"sha": "43599fac5a9e294e911369663a9e48b22ea8f4d3", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6532e8a053ffec70ea1637fdf50e3838db0d122a/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=6532e8a053ffec70ea1637fdf50e3838db0d122a", "patch": "@@ -235,7 +235,7 @@ find_common_type (tree t1, tree t2)\n    tests in as efficient a manner as possible.  */\n \n static tree\n-compare_arrays (tree result_type, tree a1, tree a2)\n+compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n {\n   tree result = convert (result_type, boolean_true_node);\n   tree a1_is_null = convert (result_type, boolean_false_node);\n@@ -296,10 +296,10 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \n-\t  comparison = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n+\t  comparison = fold_build2_loc (loc, LT_EXPR, result_type, ub1, lb1);\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n-\t    SET_EXPR_LOCATION (comparison, input_location);\n+\t    SET_EXPR_LOCATION (comparison, loc);\n \n \t  this_a1_is_null = comparison;\n \t  this_a2_is_null = convert (result_type, boolean_true_node);\n@@ -321,16 +321,15 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  bt = get_base_type (TREE_TYPE (ub1));\n \n \t  comparison\n-\t    = build_binary_op (EQ_EXPR, result_type,\n+\t    = fold_build2_loc (loc, EQ_EXPR, result_type,\n \t\t\t       build_binary_op (MINUS_EXPR, bt, ub1, lb1),\n \t\t\t       build_binary_op (MINUS_EXPR, bt, ub2, lb2));\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n-\t    SET_EXPR_LOCATION (comparison, input_location);\n+\t    SET_EXPR_LOCATION (comparison, loc);\n \n-\t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n-\t  if (EXPR_P (this_a1_is_null))\n-\t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n+\t  this_a1_is_null\n+\t    = fold_build2_loc (loc, LT_EXPR, result_type, ub1, lb1);\n \n \t  this_a2_is_null = convert (result_type, boolean_false_node);\n \t}\n@@ -342,31 +341,27 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  length2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length2, a2);\n \n \t  comparison\n-\t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n-\t  if (EXPR_P (comparison))\n-\t    SET_EXPR_LOCATION (comparison, input_location);\n+\t    = fold_build2_loc (loc, EQ_EXPR, result_type, length1, length2);\n \n \t  /* If the length expression is of the form (cond ? val : 0), assume\n \t     that cond is equivalent to (length != 0).  That's guaranteed by\n \t     construction of the array types in gnat_to_gnu_entity.  */\n \t  if (TREE_CODE (length1) == COND_EXPR\n \t      && integer_zerop (TREE_OPERAND (length1, 2)))\n-\t    this_a1_is_null = invert_truthvalue (TREE_OPERAND (length1, 0));\n+\t    this_a1_is_null\n+\t      = invert_truthvalue_loc (loc, TREE_OPERAND (length1, 0));\n \t  else\n-\t    this_a1_is_null = build_binary_op (EQ_EXPR, result_type, length1,\n-\t\t\t\t\t       size_zero_node);\n-          if (EXPR_P (this_a1_is_null))\n-\t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n+\t    this_a1_is_null = fold_build2_loc (loc, EQ_EXPR, result_type,\n+\t\t\t\t\t       length1, size_zero_node);\n \n \t  /* Likewise for the second array.  */\n \t  if (TREE_CODE (length2) == COND_EXPR\n \t      && integer_zerop (TREE_OPERAND (length2, 2)))\n-\t    this_a2_is_null = invert_truthvalue (TREE_OPERAND (length2, 0));\n+\t    this_a2_is_null\n+\t      = invert_truthvalue_loc (loc, TREE_OPERAND (length2, 0));\n \t  else\n-\t    this_a2_is_null = build_binary_op (EQ_EXPR, result_type, length2,\n-\t\t\t\t\t       size_zero_node);\n-          if (EXPR_P (this_a2_is_null))\n-\t    SET_EXPR_LOCATION (this_a2_is_null, input_location);\n+\t    this_a2_is_null = fold_build2_loc (loc, EQ_EXPR, result_type,\n+\t\t\t\t\t       length2, size_zero_node);\n \t}\n \n       /* Append expressions for this dimension to the final expressions.  */\n@@ -396,9 +391,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  a2 = convert (type, a2);\n \t}\n \n-      comparison = fold_build2 (EQ_EXPR, result_type, a1, a2);\n-      if (EXPR_P (comparison))\n-\tSET_EXPR_LOCATION (comparison, input_location);\n+      comparison = fold_build2_loc (loc, EQ_EXPR, result_type, a1, a2);\n \n       result\n \t= build_binary_op (TRUTH_ANDIF_EXPR, result_type, result, comparison);\n@@ -784,8 +777,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t      || (TREE_CODE (right_type) == INTEGER_TYPE\n \t\t  && TYPE_HAS_ACTUAL_BOUNDS_P (right_type))))\n \t{\n-\t  result = compare_arrays (result_type, left_operand, right_operand);\n-\n+\t  result = compare_arrays (input_location,\n+\t\t\t\t   result_type, left_operand, right_operand);\n \t  if (op_code == NE_EXPR)\n \t    result = invert_truthvalue_loc (EXPR_LOCATION (result), result);\n \t  else"}]}