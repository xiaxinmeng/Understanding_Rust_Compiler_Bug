{"sha": "e6de53356769e13178975c18b4ce019a800ea946", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkZTUzMzU2NzY5ZTEzMTc4OTc1YzE4YjRjZTAxOWE4MDBlYTk0Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-07-17T09:19:27Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-07-17T09:19:27Z"}, "message": "Clean up of new format of -falign-FOO.\n\n2018-07-17  Martin Liska  <mliska@suse.cz>\n\n\t* align.h: New file.\n\t* config/alpha/alpha.c (alpha_align_insns_1): Use align_functions directly.\n\t* config/i386/i386.c (ix86_avoid_jump_mispredicts): Use new return type\n\talign_flags of label_to_alignment.\n\t* config/m32r/m32r.h (LOOP_ALIGN): Wrap returned values into align_flags\n\tclass.\n\t* config/m68k/m68k.c: Do not use removed align_labels_value and\n\talign_loops_value.\n\t* config/nds32/nds32.h (JUMP_ALIGN): Wrap result into align_flags class.\n\t(LOOP_ALIGN): Likewise.\n\t(LABEL_ALIGN): Likewise.\n\t* config/powerpcspe/powerpcspe.c (TARGET_ASM_LOOP_ALIGN_MAX_SKIP):\n\tRemove not used macro.\n\t(rs6000_loop_align): Change return type to align_flags.\n\t(rs6000_loop_align_max_skip): Remove.\n\t* config/rs6000/rs6000-protos.h (rs6000_loop_align):\n\tChange return type to align_flags.\n\t* config/rs6000/rs6000.c (TARGET_ASM_LOOP_ALIGN_MAX_SKIP):\n\tRemove not used macro.\n\t(rs6000_loop_align):  Change return type to align_flags.\n\t(rs6000_loop_align_max_skip): Remove.\n\t* config/rx/rx.h (JUMP_ALIGN): Wrap integer values\n\t* config/rx/rx-protos.h (rx_align_for_label): Make it\n        static function.\n\t* config/rx/rx.c (rx_align_for_label): Change return type\n        to align_flags.\n\t(rx_max_skip_for_label): Remove TARGET_ASM_*_ALIGN_MAX_SKIP\n        macro definitions.\n\tinto align_flags class.\n\t(LABEL_ALIGN): Likewise.\n\t(LOOP_ALIGN): Likewise.\n\t* config/s390/s390.c (s390_label_align): Use align_flags\n\tclass member.\n\t(s390_asm_output_function_label): Likewise.\n\t* config/sh/sh.c (sh_override_options_after_change):\n\tUse align_flags class directly without macros.\n\t(find_barrier): Likewise.\n\t(barrier_align): Likewise.\n\t(sh_loop_align): Likewise.\n\t* config/spu/spu.c (spu_option_override):\n\tUse align_flags_tuple::get_value instead of removed macros.\n\t(spu_sched_init): Likewise.\n\t* config/spu/spu.h (GTY): Likewise.\n\t* config/visium/visium.c (visium_option_override):\n\tSet \"8\" as default secondary alignment.\n\t* config/visium/visium.h (SUBALIGN_LOG): Define to 3\n\tin order to guarantee secondary alignment of 8.\n\t* coretypes.h: Include align.h header file.\n\t* doc/tm.texi: Remove TARGET_ASM_JUMP_ALIGN_MAX_SKIP,\n\tTARGET_ASM_LOOP_ALIGN_MAX_SKIP, TARGET_ASM_LABEL_ALIGN_MAX_SKIP\n        and TARGET_ASM_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP macros.\n\t* doc/tm.texi.in: Likewise.\n\t* final.c (struct label_alignment): Remove not used structure.\n\t(LABEL_ALIGN): Change type to align_flags.\n\t(LOOP_ALIGN): Likewise.\n\t(JUMP_ALIGN): Likewise.\n\t(default_loop_align_max_skip): Remove.\n\t(default_label_align_max_skip): Likewise.\n\t(default_jump_align_max_skip): Likewise.\n\t(default_label_align_after_barrier_max_skip):\n\t(LABEL_TO_ALIGNMENT): Change to access label_align vector.\n\t(LABEL_TO_MAX_SKIP): Remove.\n\t(label_to_alignment): Return align_flags type instead of integer.\n\t(label_to_max_skip): Remove.\n\t(align_fuzz): Use align_flags type.\n\t(compute_alignments): Use align_flags type and use align_flags::max\n\tto combine multiple alignments.\n\t(grow_label_align): Grow vec instead of C array.\n\t(update_alignments): Assign just LABEL_TO_ALIGNMENT.\n\t(shorten_branches):  Use align_flags type and use align_flags::max\n\tto combine multiple alignments.\n\t(final_scan_insn_1): Remove usage of secondary alignment that comes\n\tfrom label alignment, but instead use proper secondary alignment\n\twhich is computed in grow_label_align.\n\t* flags.h (struct align_flags_tuple): Move to align.h.\n\t(struct align_flags): Likewise.\n\t(state_align_loops): Rename to align_loops.\n\t(state_align_jumps): Rename to align_jumps.\n\t(state_align_labels): Rename to align_labels.\n\t(state_align_functions): Rename to align_functions.\n\t(align_loops_log): Remove.\n\t(align_jumps_log): Remove.\n\t(align_labels_log): Remove.\n\t(align_functions_log): Remove.\n\t(align_loops_max_skip): Remove.\n\t(align_jumps_max_skip): Remove.\n\t(align_labels_max_skip): Remove.\n\t(align_functions_max_skip): Remove.\n\t(align_loops_value): Remove.\n\t(align_jumps_value): Remove.\n\t(align_labels_value): Remove.\n\t(align_functions_value): Remove.\n\t* output.h (label_to_alignment): Change return type to align_flags.\n\t(label_to_max_skip): Remove.\n\t* target.def: Remove loop_align_max_skip, label_align_max_skip,\n\tjump_align_max_skip macros.\n\t* targhooks.h (default_loop_align_max_skip): Remove.\n\t(default_label_align_max_skip): Likewise.\n\t(default_jump_align_max_skip): Likewise.\n\t(default_label_align_after_barrier_max_skip): Remove.\n\t* toplev.c (read_log_maxskip): Use ::normalize function.\n\t(parse_N_M): Remove not used argument and also call ::normalize.\n\t(parse_alignment_opts): Do not pass unused arguments.\n\t* varasm.c (assemble_start_function): Use directly align_functions\n\tinstead of removed macros.\n\t* system.h: Do not poison removed macros.\n2018-07-17  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.target/powerpc/loop_align.c: Update scanned pattern.\n\nFrom-SVN: r262804", "tree": {"sha": "76fa6fbb2e76fcb986efcbb0143316749fbf1e29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76fa6fbb2e76fcb986efcbb0143316749fbf1e29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6de53356769e13178975c18b4ce019a800ea946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6de53356769e13178975c18b4ce019a800ea946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6de53356769e13178975c18b4ce019a800ea946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6de53356769e13178975c18b4ce019a800ea946/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "118f2d8bc3e6804996ca2953b86454ec950054bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118f2d8bc3e6804996ca2953b86454ec950054bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118f2d8bc3e6804996ca2953b86454ec950054bf"}], "stats": {"total": 748, "additions": 358, "deletions": 390}, "files": [{"sha": "80512556ecc907874465fb21f6393c16b3056807", "filename": "gcc/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1,3 +1,112 @@\n+2018-07-17  Martin Liska  <mliska@suse.cz>\n+\n+\t* align.h: New file.\n+\t* config/alpha/alpha.c (alpha_align_insns_1): Use align_functions directly.\n+\t* config/i386/i386.c (ix86_avoid_jump_mispredicts): Use new return type\n+\talign_flags of label_to_alignment.\n+\t* config/m32r/m32r.h (LOOP_ALIGN): Wrap returned values into align_flags\n+\tclass.\n+\t* config/m68k/m68k.c: Do not use removed align_labels_value and\n+\talign_loops_value.\n+\t* config/nds32/nds32.h (JUMP_ALIGN): Wrap result into align_flags class.\n+\t(LOOP_ALIGN): Likewise.\n+\t(LABEL_ALIGN): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (TARGET_ASM_LOOP_ALIGN_MAX_SKIP):\n+\tRemove not used macro.\n+\t(rs6000_loop_align): Change return type to align_flags.\n+\t(rs6000_loop_align_max_skip): Remove.\n+\t* config/rs6000/rs6000-protos.h (rs6000_loop_align):\n+\tChange return type to align_flags.\n+\t* config/rs6000/rs6000.c (TARGET_ASM_LOOP_ALIGN_MAX_SKIP):\n+\tRemove not used macro.\n+\t(rs6000_loop_align):  Change return type to align_flags.\n+\t(rs6000_loop_align_max_skip): Remove.\n+\t* config/rx/rx.h (JUMP_ALIGN): Wrap integer values\n+\t* config/rx/rx-protos.h (rx_align_for_label): Make it\n+        static function.\n+\t* config/rx/rx.c (rx_align_for_label): Change return type\n+        to align_flags.\n+\t(rx_max_skip_for_label): Remove TARGET_ASM_*_ALIGN_MAX_SKIP\n+        macro definitions.\n+\tinto align_flags class.\n+\t(LABEL_ALIGN): Likewise.\n+\t(LOOP_ALIGN): Likewise.\n+\t* config/s390/s390.c (s390_label_align): Use align_flags\n+\tclass member.\n+\t(s390_asm_output_function_label): Likewise.\n+\t* config/sh/sh.c (sh_override_options_after_change):\n+\tUse align_flags class directly without macros.\n+\t(find_barrier): Likewise.\n+\t(barrier_align): Likewise.\n+\t(sh_loop_align): Likewise.\n+\t* config/spu/spu.c (spu_option_override):\n+\tUse align_flags_tuple::get_value instead of removed macros.\n+\t(spu_sched_init): Likewise.\n+\t* config/spu/spu.h (GTY): Likewise.\n+\t* config/visium/visium.c (visium_option_override):\n+\tSet \"8\" as default secondary alignment.\n+\t* config/visium/visium.h (SUBALIGN_LOG): Define to 3\n+\tin order to guarantee secondary alignment of 8.\n+\t* coretypes.h: Include align.h header file.\n+\t* doc/tm.texi: Remove TARGET_ASM_JUMP_ALIGN_MAX_SKIP,\n+\tTARGET_ASM_LOOP_ALIGN_MAX_SKIP, TARGET_ASM_LABEL_ALIGN_MAX_SKIP\n+        and TARGET_ASM_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP macros.\n+\t* doc/tm.texi.in: Likewise.\n+\t* final.c (struct label_alignment): Remove not used structure.\n+\t(LABEL_ALIGN): Change type to align_flags.\n+\t(LOOP_ALIGN): Likewise.\n+\t(JUMP_ALIGN): Likewise.\n+\t(default_loop_align_max_skip): Remove.\n+\t(default_label_align_max_skip): Likewise.\n+\t(default_jump_align_max_skip): Likewise.\n+\t(default_label_align_after_barrier_max_skip):\n+\t(LABEL_TO_ALIGNMENT): Change to access label_align vector.\n+\t(LABEL_TO_MAX_SKIP): Remove.\n+\t(label_to_alignment): Return align_flags type instead of integer.\n+\t(label_to_max_skip): Remove.\n+\t(align_fuzz): Use align_flags type.\n+\t(compute_alignments): Use align_flags type and use align_flags::max\n+\tto combine multiple alignments.\n+\t(grow_label_align): Grow vec instead of C array.\n+\t(update_alignments): Assign just LABEL_TO_ALIGNMENT.\n+\t(shorten_branches):  Use align_flags type and use align_flags::max\n+\tto combine multiple alignments.\n+\t(final_scan_insn_1): Remove usage of secondary alignment that comes\n+\tfrom label alignment, but instead use proper secondary alignment\n+\twhich is computed in grow_label_align.\n+\t* flags.h (struct align_flags_tuple): Move to align.h.\n+\t(struct align_flags): Likewise.\n+\t(state_align_loops): Rename to align_loops.\n+\t(state_align_jumps): Rename to align_jumps.\n+\t(state_align_labels): Rename to align_labels.\n+\t(state_align_functions): Rename to align_functions.\n+\t(align_loops_log): Remove.\n+\t(align_jumps_log): Remove.\n+\t(align_labels_log): Remove.\n+\t(align_functions_log): Remove.\n+\t(align_loops_max_skip): Remove.\n+\t(align_jumps_max_skip): Remove.\n+\t(align_labels_max_skip): Remove.\n+\t(align_functions_max_skip): Remove.\n+\t(align_loops_value): Remove.\n+\t(align_jumps_value): Remove.\n+\t(align_labels_value): Remove.\n+\t(align_functions_value): Remove.\n+\t* output.h (label_to_alignment): Change return type to align_flags.\n+\t(label_to_max_skip): Remove.\n+\t* target.def: Remove loop_align_max_skip, label_align_max_skip,\n+\tjump_align_max_skip macros.\n+\t* targhooks.h (default_loop_align_max_skip): Remove.\n+\t(default_label_align_max_skip): Likewise.\n+\t(default_jump_align_max_skip): Likewise.\n+\t(default_label_align_after_barrier_max_skip): Remove.\n+\t* toplev.c (read_log_maxskip): Use ::normalize function.\n+\t(parse_N_M): Remove not used argument and also call ::normalize.\n+\t(parse_alignment_opts): Do not pass unused arguments.\n+\t* varasm.c (assemble_start_function): Use directly align_functions\n+\tinstead of removed macros.\n+\t* system.h: Do not poison removed macros.\n+\n 2018-07-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/86539"}, {"sha": "5a5d6c752a325394b1e5c8dcdb384319a0efd685", "filename": "gcc/align.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Falign.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Falign.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falign.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -0,0 +1,76 @@\n+/* Alignment-related classes.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Align flags tuple with alignment in log form and with a maximum skip.  */\n+\n+struct align_flags_tuple\n+{\n+  /* Values of the -falign-* flags: how much to align labels in code.\n+     log is \"align to 2^log\" (so 0 means no alignment).\n+     maxskip is the maximum allowed amount of padding to insert.  */\n+  int log;\n+  int maxskip;\n+\n+  /* Normalize filled values so that maxskip is not bigger than 1 << log.  */\n+  void normalize ()\n+  {\n+    int n = (1 << log);\n+    if (maxskip > n)\n+      maxskip = n - 1;\n+  }\n+\n+  /* Return original value of an alignment flag.  */\n+  int get_value ()\n+  {\n+    return maxskip + 1;\n+  }\n+};\n+\n+/* Alignment flags is structure used as value of -align-* options.\n+   It's used in target-dependant code.  */\n+\n+struct align_flags\n+{\n+  /* Default constructor.  */\n+  align_flags (int log0 = 0, int maxskip0 = 0, int log1 = 0, int maxskip1 = 0)\n+  {\n+    levels[0] = {log0, maxskip0};\n+    levels[1] = {log1, maxskip1};\n+    normalize ();\n+  }\n+\n+  /* Normalize both components of align_flags.  */\n+  void normalize ()\n+  {\n+    for (unsigned i = 0; i < 2; i++)\n+      levels[i].normalize ();\n+  }\n+\n+  /* Get alignment that is common bigger alignment of alignments F0 and F1.  */\n+  static align_flags max (const align_flags f0, const align_flags f1)\n+    {\n+      int log0 = MAX (f0.levels[0].log, f1.levels[0].log);\n+      int maxskip0 = MAX (f0.levels[0].maxskip, f1.levels[0].maxskip);\n+      int log1 = MAX (f0.levels[1].log, f1.levels[1].log);\n+      int maxskip1 = MAX (f0.levels[1].maxskip, f1.levels[1].maxskip);\n+      return align_flags (log0, maxskip0, log1, maxskip1);\n+    }\n+\n+  align_flags_tuple levels[2];\n+};"}, {"sha": "993d2324464bd1cebc75354d1dd517ff65421091", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -9269,7 +9269,7 @@ alpha_align_insns_1 (unsigned int max_align,\n   /* Let shorten branches care for assigning alignments to code labels.  */\n   shorten_branches (get_insns ());\n \n-  unsigned int option_alignment = align_functions_max_skip + 1;\n+  unsigned int option_alignment = align_functions.levels[0].get_value ();\n   if (option_alignment < 4)\n     align = 4;\n   else if ((unsigned int) option_alignment < max_align)\n@@ -9291,7 +9291,8 @@ alpha_align_insns_1 (unsigned int max_align,\n       /* When we see a label, resync alignment etc.  */\n       if (LABEL_P (i))\n \t{\n-\t  unsigned int new_align = 1 << label_to_alignment (i);\n+\t  unsigned int new_align\n+\t    = label_to_alignment (i).levels[0].get_value ();\n \n \t  if (new_align >= align)\n \t    {"}, {"sha": "2b7e9489ed8b2cbdcdc4dbbf78cb5423701b5567", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -41927,8 +41927,9 @@ ix86_avoid_jump_mispredicts (void)\n \n       if (LABEL_P (insn))\n \t{\n-\t  int align = label_to_alignment (insn);\n-\t  int max_skip = label_to_max_skip (insn);\n+\t  align_flags alignment = label_to_alignment (insn);\n+\t  int align = alignment.levels[0].log;\n+\t  int max_skip = alignment.levels[0].maxskip;\n \n \t  if (max_skip > 15)\n \t    max_skip = 15;"}, {"sha": "4eb15a7ba60910b998df5e70de7638082971eef4", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -866,7 +866,8 @@ L2:     .word STATIC\n    of a loop.  */\n /* On the M32R, align loops to 32 byte boundaries (cache line size)\n    if -malign-loops.  */\n-#define LOOP_ALIGN(LABEL) (TARGET_ALIGN_LOOPS ? 5 : 0)\n+#define LOOP_ALIGN(LABEL) ((TARGET_ALIGN_LOOPS \\\n+\t\t\t    ? align_flags (5) : align_flags ()))\n \n /* Define this to be the maximum number of insns to move around when moving\n    a loop test from the top of a loop to the bottom"}, {"sha": "ef8604ebe3d7e582c4c5e35356ac17dde54477b8", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -653,15 +653,17 @@ m68k_option_override (void)\n \n #ifndef ASM_OUTPUT_ALIGN_WITH_NOP\n   parse_alignment_opts ();\n-  if (align_labels_value > 2)\n+  int label_alignment = align_labels.levels[0].get_value ();\n+  if (label_alignment > 2)\n     {\n-      warning (0, \"-falign-labels=%d is not supported\", align_labels_value);\n+      warning (0, \"-falign-labels=%d is not supported\", label_alignment);\n       str_align_labels = \"1\";\n     }\n \n-  if (align_loops_value > 2)\n+  int loop_alignment = align_loops.levels[0].get_value ();\n+  if (loop_alignment > 2)\n     {\n-      warning (0, \"-falign-loops=%d is not supported\", align_loops_value);\n+      warning (0, \"-falign-loops=%d is not supported\", loop_alignment);\n       str_align_loops = \"1\";\n     }\n #endif"}, {"sha": "3aac6a21bb87e5b87e4f31d2a9e84ae39ee1836a", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1630,13 +1630,16 @@ enum reg_class\n #define DWARF2_UNWIND_INFO 1\n \n #define JUMP_ALIGN(x) \\\n-  (align_jumps_log ? align_jumps_log : nds32_target_alignment (x))\n+  (align_jumps.levels[0].log \\\n+   ? align_jumps : align_flags (nds32_target_alignment (x)))\n \n #define LOOP_ALIGN(x) \\\n-  (align_loops_log ? align_loops_log : nds32_target_alignment (x))\n+  (align_loops.levels[0].log \\\n+   ? align_loops : align_flags (nds32_target_alignment (x)))\n \n #define LABEL_ALIGN(x) \\\n-  (align_labels_log ? align_labels_log : nds32_target_alignment (x))\n+  (align_labels.levels[0].log \\\n+   ? align_labels : align_flags (nds32_target_alignment (x)))\n \n #define ASM_OUTPUT_ALIGN(stream, power) \\\n   fprintf (stream, \"\\t.align\\t%d\\n\", power)"}, {"sha": "7dd24e47641ce82fa532aa4ea50cff265c51446d", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1829,9 +1829,6 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n #define TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN invalid_arg_for_unprototyped_fn\n \n-#undef TARGET_ASM_LOOP_ALIGN_MAX_SKIP\n-#define TARGET_ASM_LOOP_ALIGN_MAX_SKIP rs6000_loop_align_max_skip\n-\n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST rs6000_md_asm_adjust\n \n@@ -5723,15 +5720,15 @@ rs6000_builtin_mask_for_load (void)\n }\n \n /* Implement LOOP_ALIGN. */\n-int\n+align_flags\n rs6000_loop_align (rtx label)\n {\n   basic_block bb;\n   int ninsns;\n \n   /* Don't override loop alignment if -falign-loops was specified. */\n   if (!can_override_loop_align)\n-    return align_loops_log;\n+    return align_loops;\n \n   bb = BLOCK_FOR_INSN (label);\n   ninsns = num_loop_insns(bb->loop_father);\n@@ -5744,16 +5741,9 @@ rs6000_loop_align (rtx label)\n \t  || rs6000_cpu == PROCESSOR_POWER7\n \t  || rs6000_cpu == PROCESSOR_POWER8\n \t  || rs6000_cpu == PROCESSOR_POWER9))\n-    return 5;\n+    return align_flags (5);\n   else\n-    return align_loops_log;\n-}\n-\n-/* Implement TARGET_LOOP_ALIGN_MAX_SKIP. */\n-static int\n-rs6000_loop_align_max_skip (rtx_insn *label)\n-{\n-  return (1 << rs6000_loop_align (label)) - 1;\n+    return align_loops;\n }\n \n /* Return true iff, data reference of TYPE can reach vector alignment (16)"}, {"sha": "714b8a8f43a201d0bc968387a65823cc822dea19", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -156,7 +156,7 @@ extern rtx rs6000_machopic_legitimize_pic_address (rtx, machine_mode,\n \t\t\t\t\t\t   rtx);\n extern rtx rs6000_address_for_fpconvert (rtx);\n extern rtx rs6000_allocate_stack_temp (machine_mode, bool, bool);\n-extern int rs6000_loop_align (rtx);\n+extern align_flags rs6000_loop_align (rtx);\n extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool);\n #endif /* RTX_CODE */\n "}, {"sha": "caa35e01787afcf783f3f8a2ab6f1fc39bd0ac67", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1817,9 +1817,6 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n #define TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN invalid_arg_for_unprototyped_fn\n \n-#undef TARGET_ASM_LOOP_ALIGN_MAX_SKIP\n-#define TARGET_ASM_LOOP_ALIGN_MAX_SKIP rs6000_loop_align_max_skip\n-\n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST rs6000_md_asm_adjust\n \n@@ -5275,15 +5272,15 @@ rs6000_builtin_mask_for_load (void)\n }\n \n /* Implement LOOP_ALIGN. */\n-int\n+align_flags\n rs6000_loop_align (rtx label)\n {\n   basic_block bb;\n   int ninsns;\n \n   /* Don't override loop alignment if -falign-loops was specified. */\n   if (!can_override_loop_align)\n-    return align_loops_log;\n+    return align_loops;\n \n   bb = BLOCK_FOR_INSN (label);\n   ninsns = num_loop_insns(bb->loop_father);\n@@ -5295,16 +5292,9 @@ rs6000_loop_align (rtx label)\n \t  || rs6000_tune == PROCESSOR_POWER6\n \t  || rs6000_tune == PROCESSOR_POWER7\n \t  || rs6000_tune == PROCESSOR_POWER8))\n-    return 5;\n+    return align_flags (5);\n   else\n-    return align_loops_log;\n-}\n-\n-/* Implement TARGET_LOOP_ALIGN_MAX_SKIP. */\n-static int\n-rs6000_loop_align_max_skip (rtx_insn *label)\n-{\n-  return (1 << rs6000_loop_align (label)) - 1;\n+    return align_loops;\n }\n \n /* Return true iff, data reference of TYPE can reach vector alignment (16)"}, {"sha": "7e9817cfaf7bf7f7974a2223ff8aa95a25ee2ea2", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -50,7 +50,7 @@ class rx_atomic_sequence\n \n #ifdef RTX_CODE\n extern int\t\trx_adjust_insn_length (rtx_insn *, int);\n-extern int \t\trx_align_for_label (rtx, int);\n+extern align_flags\trx_align_for_label (rtx_insn *, int);\n extern void             rx_emit_stack_popm (rtx *, bool);\n extern void             rx_emit_stack_pushm (rtx *);\n extern char *\t\trx_gen_move_template (rtx *, bool);"}, {"sha": "c2669edc62cbeb5a26bcb8dc5db062218f5f897d", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -3308,23 +3308,6 @@ rx_match_ccmode (rtx insn, machine_mode cc_mode)\n   return true;\n }\n \f\n-int\n-rx_align_for_label (rtx lab, int uses_threshold)\n-{\n-  /* This is a simple heuristic to guess when an alignment would not be useful\n-     because the delay due to the inserted NOPs would be greater than the delay\n-     due to the misaligned branch.  If uses_threshold is zero then the alignment\n-     is always useful.  */\n-  if (LABEL_P (lab) && LABEL_NUSES (lab) < uses_threshold)\n-    return 0;\n-\n-  if (optimize_size)\n-    return 0;\n-  /* These values are log, not bytes.  */\n-  if (rx_cpu_type == RX100 || rx_cpu_type == RX200)\n-    return 2; /* 4 bytes */\n-  return 3;   /* 8 bytes */\n-}\n \n static int\n rx_max_skip_for_label (rtx_insn *lab)\n@@ -3350,10 +3333,41 @@ rx_max_skip_for_label (rtx_insn *lab)\n \n   opsize = get_attr_length (op);\n   if (opsize >= 0 && opsize < 8)\n-    return opsize - 1;\n+    return MAX (0, opsize - 1);\n   return 0;\n }\n \n+static int\n+rx_align_log_for_label (rtx_insn *lab, int uses_threshold)\n+{\n+  /* This is a simple heuristic to guess when an alignment would not be useful\n+     because the delay due to the inserted NOPs would be greater than the delay\n+     due to the misaligned branch.  If uses_threshold is zero then the alignment\n+     is always useful.  */\n+  if (LABEL_P (lab) && LABEL_NUSES (lab) < uses_threshold)\n+    return 0;\n+\n+  if (optimize_size)\n+    return 0;\n+\n+  /* Return zero if max_skip not a positive number.  */\n+  int max_skip = rx_max_skip_for_label (lab);\n+  if (max_skip <= 0)\n+    return 0;\n+\n+  /* These values are log, not bytes.  */\n+  if (rx_cpu_type == RX100 || rx_cpu_type == RX200)\n+    return 2; /* 4 bytes */\n+  return 3;   /* 8 bytes */\n+}\n+\n+align_flags\n+rx_align_for_label (rtx_insn *lab, int uses_threshold)\n+{\n+  return align_flags (rx_align_log_for_label (lab, uses_threshold),\n+\t\t      rx_max_skip_for_label (lab));\n+}\n+\n /* Compute the real length of the extending load-and-op instructions.  */\n \n int\n@@ -3633,15 +3647,6 @@ rx_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n #undef  TARGET_CAN_INLINE_P\n #define TARGET_CAN_INLINE_P\t\t\trx_ok_to_inline\n \n-#undef  TARGET_ASM_JUMP_ALIGN_MAX_SKIP\n-#define TARGET_ASM_JUMP_ALIGN_MAX_SKIP\t\t\trx_max_skip_for_label\n-#undef  TARGET_ASM_LOOP_ALIGN_MAX_SKIP\n-#define TARGET_ASM_LOOP_ALIGN_MAX_SKIP\t\t\trx_max_skip_for_label\n-#undef  TARGET_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n-#define TARGET_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\trx_max_skip_for_label\n-#undef  TARGET_ASM_LABEL_ALIGN_MAX_SKIP\n-#define TARGET_ASM_LABEL_ALIGN_MAX_SKIP\t\t\trx_max_skip_for_label\n-\n #undef  TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE\t\trx_function_value\n "}, {"sha": "c87bb96b2f1df6054c097083f87afed52c8f6d46", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -417,9 +417,9 @@ typedef unsigned int CUMULATIVE_ARGS;\n /* Compute the alignment needed for label X in various situations.\n    If the user has specified an alignment then honour that, otherwise\n    use rx_align_for_label.  */\n-#define JUMP_ALIGN(x)\t\t\t\t(align_jumps_log > 0 ? align_jumps_log : rx_align_for_label (x, 0))\n-#define LABEL_ALIGN(x)\t\t\t\t(align_labels_log > 0 ? align_labels_log : rx_align_for_label (x, 3))\n-#define LOOP_ALIGN(x)\t\t\t\t(align_loops_log > 0 ? align_loops_log : rx_align_for_label (x, 2))\n+#define JUMP_ALIGN(x)\t\t\t\t(align_jumps.levels[0].log > 0 ? align_jumps : align_flags (rx_align_for_label (x, 0)))\n+#define LABEL_ALIGN(x)\t\t\t\t(align_labels.levels[0].log > 0 ? align_labels : align_flags (rx_align_for_label (x, 3)))\n+#define LOOP_ALIGN(x)\t\t\t\t(align_loops.levels[0].log > 0 ? align_loops : align_flags (rx_align_for_label (x, 2)))\n #define LABEL_ALIGN_AFTER_BARRIER(x)\t\trx_align_for_label (x, 0)\n \n #define ASM_OUTPUT_MAX_SKIP_ALIGN(STREAM, LOG, MAX_SKIP)\t\\"}, {"sha": "cb89694479758165b081d7f99c4ade005fea2a4f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1233,7 +1233,7 @@ s390_label_align (rtx_insn *label)\n     return 0;\n \n  old:\n-  return align_labels_log;\n+  return align_labels.levels[0].log;\n }\n \n static GTY(()) rtx got_symbol;\n@@ -7542,10 +7542,11 @@ s390_asm_output_function_label (FILE *asm_out_file, const char *fname,\n \t NOPs.  */\n       function_alignment = MAX (8, DECL_ALIGN (decl) / BITS_PER_UNIT);\n       if (! DECL_USER_ALIGN (decl))\n-\tfunction_alignment = MAX (function_alignment,\n-\t\t\t\t  (unsigned int) align_functions_max_skip + 1);\n+\tfunction_alignment\n+\t  = MAX (function_alignment,\n+\t\t (unsigned int) align_functions.levels[0].get_value ());\n       fputs (\"\\t# alignment for hotpatch\\n\", asm_out_file);\n-      ASM_OUTPUT_ALIGN (asm_out_file, align_functions_log);\n+      ASM_OUTPUT_ALIGN (asm_out_file, align_functions.levels[0].log);\n     }\n \n   if (S390_USE_TARGET_ATTRIBUTE && TARGET_DEBUG_ARG)"}, {"sha": "4a0d5bae57bfa77875648533fef86bd67dd4a524", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1015,7 +1015,7 @@ sh_override_options_after_change (void)\n   parse_alignment_opts ();\n   if (flag_align_jumps && !str_align_jumps)\n     str_align_jumps = \"2\";\n-  else if (align_jumps_value < 2)\n+  else if (align_jumps.levels[0].get_value () < 2)\n     str_align_jumps = \"2\";\n \n   if (flag_align_functions && !str_align_functions)\n@@ -1028,12 +1028,13 @@ sh_override_options_after_change (void)\n     {\n       /* Parse values so that we can compare for current value.  */\n       parse_alignment_opts ();\n-      int min_align = MAX (align_loops_value, align_jumps_value);\n+      int min_align = MAX (align_loops.levels[0].get_value (),\n+\t\t\t   align_jumps.levels[0].get_value ());\n \n       /* Also take possible .long constants / mova tables into account.\t*/\n       if (min_align < 4)\n \tmin_align = 4;\n-      if (align_functions_value < min_align)\n+      if (align_functions.levels[0].get_value () < min_align)\n \t{\n \t  char *r = XNEWVEC (char, 16);\n \t  sprintf (r, \"%d\", min_align);\n@@ -4986,7 +4987,7 @@ find_barrier (int num_mova, rtx_insn *mova, rtx_insn *from)\n \t  && CODE_LABEL_NUMBER (from) <= max_labelno_before_reorg)\n \t{\n \t  if (optimize)\n-\t    new_align = 1 << label_to_alignment (from);\n+\t    new_align = 1 << label_to_alignment (from).levels[0].log;\n \t  else if (BARRIER_P (prev_nonnote_insn (from)))\n \t    new_align = 1 << barrier_align (from);\n \t  else\n@@ -5118,7 +5119,7 @@ find_barrier (int num_mova, rtx_insn *mova, rtx_insn *from)\n \t\t  && (prev_nonnote_insn (from)\n \t\t      == XEXP (MOVA_LABELREF (mova), 0))))\n \t    num_mova--;\n-\t  if (barrier_align (next_real_insn (from)) == align_jumps_log)\n+\t  if (barrier_align (next_real_insn (from)) == align_jumps.levels[0].log)\n \t    {\n \t      /* We have just passed the barrier in front of the\n \t\t ADDR_DIFF_VEC, which is stored in found_barrier.  Since\n@@ -5752,7 +5753,7 @@ barrier_align (rtx_insn *barrier_or_label)\n       return ((optimize_size\n \t       || ((unsigned) XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n \t\t   <= (unsigned) 1 << (CACHE_LOG - 2)))\n-\t      ? 1 : align_jumps_log);\n+\t      ? 1 : align_jumps.levels[0].log);\n     }\n \n   rtx_insn *next = next_active_insn (barrier_or_label);\n@@ -5770,7 +5771,7 @@ barrier_align (rtx_insn *barrier_or_label)\n     return 0;\n \n   if (! TARGET_SH2 || ! optimize)\n-    return align_jumps_log;\n+    return align_jumps.levels[0].log;\n \n   /* When fixing up pcloads, a constant table might be inserted just before\n      the basic block that ends with the barrier.  Thus, we can't trust the\n@@ -5848,7 +5849,7 @@ barrier_align (rtx_insn *barrier_or_label)\n \t}\n     }\n \n-  return align_jumps_log;\n+  return align_jumps.levels[0].log;\n }\n \n /* If we are inside a phony loop, almost any kind of label can turn up as the\n@@ -5874,7 +5875,7 @@ sh_loop_align (rtx_insn *label)\n       || recog_memoized (next) == CODE_FOR_consttable_2)\n     return 0;\n \n-  return align_loops_log;\n+  return align_loops.levels[0].log;\n }\n \n /* Do a final pass over the function, just before delayed branch"}, {"sha": "e2f45ddb72abc7849458373c53674921ccabc5cd", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -241,7 +241,7 @@ spu_option_override (void)\n \n   /* Functions must be 8 byte aligned so we correctly handle dual issue */\n   parse_alignment_opts ();\n-  if (align_functions_value < 8)\n+  if (align_functions.levels[0].get_value () < 8)\n     str_align_functions = \"8\";\n \n   spu_hint_dist = 8*4 - spu_max_nops*4;\n@@ -2772,7 +2772,9 @@ static void\n spu_sched_init (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n \t\tint max_ready ATTRIBUTE_UNUSED)\n {\n-  if (align_labels_value > 4 || align_loops_value > 4 || align_jumps_value > 4)\n+  if (align_labels.levels[0].get_value () > 4\n+      || align_loops.levels[0].get_value () > 4\n+      || align_jumps.levels[0].get_value () > 4)\n     {\n       /* When any block might be at least 8-byte aligned, assume they\n          will all be at least 8-byte aligned to make sure dual issue"}, {"sha": "99e2d4dd507568b875d7dfcebc4d424157e31fed", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -107,7 +107,7 @@ extern GTY(()) int spu_tune;\n \t(GET_CODE (X) == SYMBOL_REF \\\n           && (SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN1) == 0 \\\n \t  && (! SYMBOL_REF_FUNCTION_P (X) \\\n-\t      || align_functions_value >= 16))\n+\t      || align_functions.levels[0].get_value () >= 16))\n \n #define PCC_BITFIELD_TYPE_MATTERS 1\n "}, {"sha": "2b402d11f76fb50338b0f92ea21b443bdc998eb5", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -466,7 +466,7 @@ visium_option_override (void)\n       else\n \t{\n \t  /* But not if they are too far away from a 256-byte boundary.  */\n-\t  str_align_loops = \"256:32\";\n+\t  str_align_loops = \"256:32:8\";\n \t}\n     }\n "}, {"sha": "edfe3fc499eda68d68fb0ee8d9650909a9bf3da7", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1450,6 +1450,10 @@ do\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_CASE_END(STREAM, NUM, TABLE) \\\n   asm_fprintf (STREAM, \"\\t.long   0\\n\")\n \n+/* Support subalignment values.  */\n+\n+#define SUBALIGN_LOG 3\n+\n /* Assembler Commands for Alignment\n \n    This describes commands for alignment.\n@@ -1495,15 +1499,8 @@ do\t\t\t\t\t\t\t\t\t\\\n   if ((LOG) != 0) {\t\t\t\t\t\t\t\\\n     if ((MAX_SKIP) == 0 || (MAX_SKIP) >= (1<<(LOG))-1)\t\t\t\\\n       fprintf ((STREAM), \"\\t.p2align %d\\n\", (LOG));\t\t\t\\\n-    else {\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n       fprintf ((STREAM), \"\\t.p2align %d,,%d\\n\", (LOG), (MAX_SKIP));\t\\\n-      /* Make sure that we have at least 8-byte alignment if > 8-byte\t\\\n-\t alignment is preferred.  */\t\t\t\t\t\\\n-      if ((LOG) > 3\t\t\t\t\t\t\t\\\n-\t  && (1 << (LOG)) > ((MAX_SKIP) + 1)\t\t\t\t\\\n-\t  && (MAX_SKIP) >= 7)\t\t\t\t\t\t\\\n-\tfputs (\"\\t.p2align 3\\n\", (STREAM));\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n   }\n \n /* Controlling Debugging Information Format"}, {"sha": "09d2270e188d9bebce5968cc48b7e9d156eec1aa", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -416,6 +416,7 @@ typedef unsigned char uchar;\n #include \"insn-modes-inline.h\"\n #include \"machmode.h\"\n #include \"double-int.h\"\n+#include \"align.h\"\n /* Most host source files will require the following headers.  */\n #if !defined (GENERATOR_FILE)\n #include \"real.h\""}, {"sha": "0ddcd1aa2ac8bcfb07290e5dc90e98fc72505f52", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -9560,12 +9560,6 @@ to set the variable @var{align_jumps} in the target's\n selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_ASM_JUMP_ALIGN_MAX_SKIP (rtx_insn *@var{label})\n-The maximum number of bytes to skip before @var{label} when applying\n-@code{JUMP_ALIGN}.  This works only if\n-@code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.\n-@end deftypefn\n-\n @defmac LABEL_ALIGN_AFTER_BARRIER (@var{label})\n The alignment (log base 2) to put in front of @var{label}, which follows\n a @code{BARRIER}.\n@@ -9575,12 +9569,6 @@ to be done at such a time.  Most machine descriptions do not currently\n define the macro.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_ASM_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (rtx_insn *@var{label})\n-The maximum number of bytes to skip before @var{label} when applying\n-@code{LABEL_ALIGN_AFTER_BARRIER}.  This works only if\n-@code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.\n-@end deftypefn\n-\n @defmac LOOP_ALIGN (@var{label})\n The alignment (log base 2) to put in front of @var{label} that heads\n a frequently executed basic block (usually the header of a loop).\n@@ -9595,12 +9583,6 @@ to set the variable @code{align_loops} in the target's\n selection in @code{align_loops} in a @code{LOOP_ALIGN} implementation.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_ASM_LOOP_ALIGN_MAX_SKIP (rtx_insn *@var{label})\n-The maximum number of bytes to skip when applying @code{LOOP_ALIGN} to\n-@var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN} is\n-defined.\n-@end deftypefn\n-\n @defmac LABEL_ALIGN (@var{label})\n The alignment (log base 2) to put in front of @var{label}.\n If @code{LABEL_ALIGN_AFTER_BARRIER} / @code{LOOP_ALIGN} specify a different alignment,\n@@ -9612,12 +9594,6 @@ to set the variable @code{align_labels} in the target's\n selection in @code{align_labels} in a @code{LABEL_ALIGN} implementation.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_ASM_LABEL_ALIGN_MAX_SKIP (rtx_insn *@var{label})\n-The maximum number of bytes to skip when applying @code{LABEL_ALIGN}\n-to @var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN}\n-is defined.\n-@end deftypefn\n-\n @defmac ASM_OUTPUT_SKIP (@var{stream}, @var{nbytes})\n A C statement to output to the stdio stream @var{stream} an assembler\n instruction to advance the location counter by @var{nbytes} bytes."}, {"sha": "e275aca0eec91511473168732343f245ba1bd0d8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -6524,8 +6524,6 @@ to set the variable @var{align_jumps} in the target's\n selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.\n @end defmac\n \n-@hook TARGET_ASM_JUMP_ALIGN_MAX_SKIP\n-\n @defmac LABEL_ALIGN_AFTER_BARRIER (@var{label})\n The alignment (log base 2) to put in front of @var{label}, which follows\n a @code{BARRIER}.\n@@ -6535,8 +6533,6 @@ to be done at such a time.  Most machine descriptions do not currently\n define the macro.\n @end defmac\n \n-@hook TARGET_ASM_LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n-\n @defmac LOOP_ALIGN (@var{label})\n The alignment (log base 2) to put in front of @var{label} that heads\n a frequently executed basic block (usually the header of a loop).\n@@ -6551,8 +6547,6 @@ to set the variable @code{align_loops} in the target's\n selection in @code{align_loops} in a @code{LOOP_ALIGN} implementation.\n @end defmac\n \n-@hook TARGET_ASM_LOOP_ALIGN_MAX_SKIP\n-\n @defmac LABEL_ALIGN (@var{label})\n The alignment (log base 2) to put in front of @var{label}.\n If @code{LABEL_ALIGN_AFTER_BARRIER} / @code{LOOP_ALIGN} specify a different alignment,\n@@ -6564,8 +6558,6 @@ to set the variable @code{align_labels} in the target's\n selection in @code{align_labels} in a @code{LABEL_ALIGN} implementation.\n @end defmac\n \n-@hook TARGET_ASM_LABEL_ALIGN_MAX_SKIP\n-\n @defmac ASM_OUTPUT_SKIP (@var{stream}, @var{nbytes})\n A C statement to output to the stdio stream @var{stream} an assembler\n instruction to advance the location counter by @var{nbytes} bytes."}, {"sha": "59eb75c3d63327e61c43e5e7b78dafa90b77e084", "filename": "gcc/final.c", "status": "modified", "additions": 51, "deletions": 137, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -327,15 +327,9 @@ int insn_current_align;\n    for each insn we'll call the alignment chain of this insn in the following\n    comments.  */\n \n-struct label_alignment\n-{\n-  short alignment;\n-  short max_skip;\n-};\n-\n static rtx *uid_align;\n static int *uid_shuid;\n-static struct label_alignment *label_align;\n+static vec<align_flags> label_align;\n \n /* Indicate that branch shortening hasn't yet been done.  */\n \n@@ -473,45 +467,21 @@ get_attr_min_length (rtx_insn *insn)\n    address mod X to one mod Y, which is Y - X.  */\n \n #ifndef LABEL_ALIGN\n-#define LABEL_ALIGN(LABEL) align_labels_log\n+#define LABEL_ALIGN(LABEL) align_labels\n #endif\n \n #ifndef LOOP_ALIGN\n-#define LOOP_ALIGN(LABEL) align_loops_log\n+#define LOOP_ALIGN(LABEL) align_loops\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER\n #define LABEL_ALIGN_AFTER_BARRIER(LABEL) 0\n #endif\n \n #ifndef JUMP_ALIGN\n-#define JUMP_ALIGN(LABEL) align_jumps_log\n+#define JUMP_ALIGN(LABEL) align_jumps\n #endif\n \n-int\n-default_label_align_after_barrier_max_skip (rtx_insn *insn ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n-int\n-default_loop_align_max_skip (rtx_insn *insn ATTRIBUTE_UNUSED)\n-{\n-  return align_loops_max_skip;\n-}\n-\n-int\n-default_label_align_max_skip (rtx_insn *insn ATTRIBUTE_UNUSED)\n-{\n-  return align_labels_max_skip;\n-}\n-\n-int\n-default_jump_align_max_skip (rtx_insn *insn ATTRIBUTE_UNUSED)\n-{\n-  return align_jumps_max_skip;\n-}\n-\n #ifndef ADDR_VEC_ALIGN\n static int\n final_addr_vec_align (rtx_jump_table_data *addr_vec)\n@@ -536,27 +506,16 @@ final_addr_vec_align (rtx_jump_table_data *addr_vec)\n static int min_labelno, max_labelno;\n \n #define LABEL_TO_ALIGNMENT(LABEL) \\\n-  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].alignment)\n-\n-#define LABEL_TO_MAX_SKIP(LABEL) \\\n-  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].max_skip)\n+  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n \n /* For the benefit of port specific code do this also as a function.  */\n \n-int\n+align_flags\n label_to_alignment (rtx label)\n {\n   if (CODE_LABEL_NUMBER (label) <= max_labelno)\n     return LABEL_TO_ALIGNMENT (label);\n-  return 0;\n-}\n-\n-int\n-label_to_max_skip (rtx label)\n-{\n-  if (CODE_LABEL_NUMBER (label) <= max_labelno)\n-    return LABEL_TO_MAX_SKIP (label);\n-  return 0;\n+  return align_flags ();\n }\n \n /* The differences in addresses\n@@ -604,8 +563,8 @@ align_fuzz (rtx start, rtx end, int known_align_log, unsigned int growth)\n       align_addr = INSN_ADDRESSES (uid) - insn_lengths[uid];\n       if (uid_shuid[uid] > end_shuid)\n \tbreak;\n-      known_align_log = LABEL_TO_ALIGNMENT (align_label);\n-      new_align = 1 << known_align_log;\n+      align_flags alignment = LABEL_TO_ALIGNMENT (align_label);\n+      new_align = 1 << alignment.levels[0].log;\n       if (new_align < known_align)\n \tcontinue;\n       fuzz += (-align_addr ^ growth) & (new_align - known_align);\n@@ -667,18 +626,14 @@ insn_current_reference_address (rtx_insn *branch)\n unsigned int\n compute_alignments (void)\n {\n-  int log, max_skip, max_log;\n   basic_block bb;\n+  align_flags max_alignment;\n \n-  if (label_align)\n-    {\n-      free (label_align);\n-      label_align = 0;\n-    }\n+  label_align.truncate (0);\n \n   max_labelno = max_label_num ();\n   min_labelno = get_first_label_num ();\n-  label_align = XCNEWVEC (struct label_alignment, max_labelno - min_labelno + 1);\n+  label_align.safe_grow_cleared (max_labelno - min_labelno + 1);\n \n   /* If not optimizing or optimizing for size, don't assign any alignments.  */\n   if (! optimize || optimize_function_for_size_p (cfun))\n@@ -718,8 +673,7 @@ compute_alignments (void)\n \t\t     bb_loop_depth (bb));\n \t  continue;\n \t}\n-      max_log = LABEL_ALIGN (label);\n-      max_skip = targetm.asm_out.label_align_max_skip (label);\n+      max_alignment = LABEL_ALIGN (label);\n       profile_count fallthru_count = profile_count::zero ();\n       profile_count branch_count = profile_count::zero ();\n \n@@ -765,14 +719,10 @@ compute_alignments (void)\n \t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t   ->count.apply_scale (1, 2)))))\n \t{\n-\t  log = JUMP_ALIGN (label);\n+\t  align_flags alignment = JUMP_ALIGN (label);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  jump alignment added.\\n\");\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = targetm.asm_out.jump_align_max_skip (label);\n-\t    }\n+\t  max_alignment = align_flags::max (max_alignment, alignment);\n \t}\n       /* In case block is frequent and reached mostly by non-fallthru edge,\n \t align it.  It is most likely a first block of loop.  */\n@@ -785,17 +735,12 @@ compute_alignments (void)\n \t      > fallthru_count.apply_scale\n \t\t    (PARAM_VALUE (PARAM_ALIGN_LOOP_ITERATIONS), 1)))\n \t{\n-\t  log = LOOP_ALIGN (label);\n+\t  align_flags alignment = LOOP_ALIGN (label);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  internal loop alignment added.\\n\");\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = targetm.asm_out.loop_align_max_skip (label);\n-\t    }\n+\t  max_alignment = align_flags::max (max_alignment, alignment);\n \t}\n-      LABEL_TO_ALIGNMENT (label) = max_log;\n-      LABEL_TO_MAX_SKIP (label) = max_skip;\n+      LABEL_TO_ALIGNMENT (label) = max_alignment;\n     }\n \n   loop_optimizer_finalize ();\n@@ -817,14 +762,11 @@ grow_label_align (void)\n   n_labels = max_labelno - min_labelno + 1;\n   n_old_labels = old - min_labelno + 1;\n \n-  label_align = XRESIZEVEC (struct label_alignment, label_align, n_labels);\n+  label_align.safe_grow_cleared (n_labels);\n \n   /* Range of labels grows monotonically in the function.  Failing here\n      means that the initialization of array got lost.  */\n   gcc_assert (n_old_labels <= n_labels);\n-\n-  memset (label_align + n_old_labels, 0,\n-          (n_labels - n_old_labels) * sizeof (struct label_alignment));\n }\n \n /* Update the already computed alignment information.  LABEL_PAIRS is a vector\n@@ -842,10 +784,7 @@ update_alignments (vec<rtx> &label_pairs)\n \n   FOR_EACH_VEC_ELT (label_pairs, i, iter)\n     if (i & 1)\n-      {\n-\tLABEL_TO_ALIGNMENT (label) = LABEL_TO_ALIGNMENT (iter);\n-\tLABEL_TO_MAX_SKIP (label) = LABEL_TO_MAX_SKIP (iter);\n-      }\n+      LABEL_TO_ALIGNMENT (label) = LABEL_TO_ALIGNMENT (iter);\n     else\n       label = iter;\n }\n@@ -903,8 +842,6 @@ shorten_branches (rtx_insn *first)\n   rtx_insn *insn;\n   int max_uid;\n   int i;\n-  int max_log;\n-  int max_skip;\n #define MAX_CODE_ALIGN 16\n   rtx_insn *seq;\n   int something_changed = 1;\n@@ -926,58 +863,41 @@ shorten_branches (rtx_insn *first)\n \n   /* Initialize label_align and set up uid_shuid to be strictly\n      monotonically rising with insn order.  */\n-  /* We use max_log here to keep track of the maximum alignment we want to\n+  /* We use alignment here to keep track of the maximum alignment we want to\n      impose on the next CODE_LABEL (or the current one if we are processing\n      the CODE_LABEL itself).  */\n \n-  max_log = 0;\n-  max_skip = 0;\n+  align_flags max_alignment;\n \n   for (insn = get_insns (), i = 1; insn; insn = NEXT_INSN (insn))\n     {\n-      int log;\n-\n       INSN_SHUID (insn) = i++;\n       if (INSN_P (insn))\n \tcontinue;\n \n       if (rtx_code_label *label = dyn_cast <rtx_code_label *> (insn))\n \t{\n \t  /* Merge in alignments computed by compute_alignments.  */\n-\t  log = LABEL_TO_ALIGNMENT (label);\n-\t  if (max_log < log)\n-\t    {\n-\t      max_log = log;\n-\t      max_skip = LABEL_TO_MAX_SKIP (label);\n-\t    }\n+\t  align_flags alignment = LABEL_TO_ALIGNMENT (label);\n+\t  max_alignment = align_flags::max (max_alignment, alignment);\n \n \t  rtx_jump_table_data *table = jump_table_for_label (label);\n \t  if (!table)\n \t    {\n-\t      log = LABEL_ALIGN (label);\n-\t      if (max_log < log)\n-\t\t{\n-\t\t  max_log = log;\n-\t\t  max_skip = targetm.asm_out.label_align_max_skip (label);\n-\t\t}\n+\t      align_flags alignment = LABEL_ALIGN (label);\n+\t      max_alignment = align_flags::max (max_alignment, alignment);\n \t    }\n \t  /* ADDR_VECs only take room if read-only data goes into the text\n \t     section.  */\n \t  if ((JUMP_TABLES_IN_TEXT_SECTION\n \t       || readonly_data_section == text_section)\n \t      && table)\n \t    {\n-\t      log = ADDR_VEC_ALIGN (table);\n-\t      if (max_log < log)\n-\t\t{\n-\t\t  max_log = log;\n-\t\t  max_skip = targetm.asm_out.label_align_max_skip (label);\n-\t\t}\n+\t      align_flags alignment = align_flags (ADDR_VEC_ALIGN (table));\n+\t      max_alignment = align_flags::max (max_alignment, alignment);\n \t    }\n-\t  LABEL_TO_ALIGNMENT (label) = max_log;\n-\t  LABEL_TO_MAX_SKIP (label) = max_skip;\n-\t  max_log = 0;\n-\t  max_skip = 0;\n+\t  LABEL_TO_ALIGNMENT (label) = max_alignment;\n+\t  max_alignment = align_flags ();\n \t}\n       else if (BARRIER_P (insn))\n \t{\n@@ -987,12 +907,9 @@ shorten_branches (rtx_insn *first)\n \t       label = NEXT_INSN (label))\n \t    if (LABEL_P (label))\n \t      {\n-\t\tlog = LABEL_ALIGN_AFTER_BARRIER (insn);\n-\t\tif (max_log < log)\n-\t\t  {\n-\t\t    max_log = log;\n-\t\t    max_skip = targetm.asm_out.label_align_after_barrier_max_skip (label);\n-\t\t  }\n+\t\talign_flags alignment\n+\t\t  = align_flags (LABEL_ALIGN_AFTER_BARRIER (insn));\n+\t\tmax_alignment = align_flags::max (max_alignment, alignment);\n \t\tbreak;\n \t      }\n \t}\n@@ -1023,11 +940,12 @@ shorten_branches (rtx_insn *first)\n     {\n       int uid = INSN_UID (seq);\n       int log;\n-      log = (LABEL_P (seq) ? LABEL_TO_ALIGNMENT (seq) : 0);\n+      log = (LABEL_P (seq) ? LABEL_TO_ALIGNMENT (seq).levels[0].log : 0);\n       uid_align[uid] = align_tab[0];\n       if (log)\n \t{\n \t  /* Found an alignment label.  */\n+\t  gcc_checking_assert (log < MAX_CODE_ALIGN + 1);\n \t  uid_align[uid] = align_tab[log];\n \t  for (i = log - 1; i >= 0; i--)\n \t    align_tab[i] = seq;\n@@ -1078,8 +996,10 @@ shorten_branches (rtx_insn *first)\n \t\t  max = shuid;\n \t\t  max_lab = lab;\n \t\t}\n-\t      if (min_align > LABEL_TO_ALIGNMENT (lab))\n-\t\tmin_align = LABEL_TO_ALIGNMENT (lab);\n+\n+\t      int label_alignment = LABEL_TO_ALIGNMENT (lab).levels[0].log;\n+\t      if (min_align > label_alignment)\n+\t\tmin_align = label_alignment;\n \t    }\n \t  XEXP (pat, 2) = gen_rtx_LABEL_REF (Pmode, min_lab);\n \t  XEXP (pat, 3) = gen_rtx_LABEL_REF (Pmode, max_lab);\n@@ -1113,7 +1033,7 @@ shorten_branches (rtx_insn *first)\n \n       if (LABEL_P (insn))\n \t{\n-\t  int log = LABEL_TO_ALIGNMENT (insn);\n+\t  int log = LABEL_TO_ALIGNMENT (insn).levels[0].log;\n \t  if (log)\n \t    {\n \t      int align = 1 << log;\n@@ -1221,7 +1141,7 @@ shorten_branches (rtx_insn *first)\n \n \t  if (rtx_code_label *label = dyn_cast <rtx_code_label *> (insn))\n \t    {\n-\t      int log = LABEL_TO_ALIGNMENT (label);\n+\t      int log = LABEL_TO_ALIGNMENT (label).levels[0].log;\n \n #ifdef CASE_VECTOR_SHORTEN_MODE\n \t      /* If the mode of a following jump table was changed, we\n@@ -1296,7 +1216,7 @@ shorten_branches (rtx_insn *first)\n \t\t   prev = PREV_INSN (prev))\n \t\tif (varying_length[INSN_UID (prev)] & 2)\n \t\t  {\n-\t\t    rel_align = LABEL_TO_ALIGNMENT (prev);\n+\t\t    rel_align = LABEL_TO_ALIGNMENT (prev).levels[0].log;\n \t\t    break;\n \t\t  }\n \n@@ -2519,26 +2439,20 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t some insn, e.g. sh.c output_branchy_insn.  */\n       if (CODE_LABEL_NUMBER (insn) <= max_labelno)\n \t{\n-\t  int align = LABEL_TO_ALIGNMENT (insn);\n-#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n-\t  int max_skip = LABEL_TO_MAX_SKIP (insn);\n-#endif\n-\n-\t  if (align && NEXT_INSN (insn))\n+\t  align_flags alignment = LABEL_TO_ALIGNMENT (insn);\n+\t  if (alignment.levels[0].log && NEXT_INSN (insn))\n \t    {\n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n-\t      ASM_OUTPUT_MAX_SKIP_ALIGN (file, align, max_skip);\n-\t      /* Above, we don't know whether a label, jump or loop\n-\t\t alignment was used.  Conservatively apply\n-\t\t label subalignment, not jump or loop\n-\t\t subalignment (they are almost always larger).  */\n-\t      ASM_OUTPUT_MAX_SKIP_ALIGN (file, state_align_labels.levels[1].log,\n-\t\t\t\t\t state_align_labels.levels[1].maxskip);\n+\t      /* Output both primary and secondary alignment.  */\n+\t      ASM_OUTPUT_MAX_SKIP_ALIGN (file, alignment.levels[0].log,\n+\t\t\t\t\t alignment.levels[0].maxskip);\n+\t      ASM_OUTPUT_MAX_SKIP_ALIGN (file, alignment.levels[1].log,\n+\t\t\t\t\t alignment.levels[1].maxskip);\n #else\n #ifdef ASM_OUTPUT_ALIGN_WITH_NOP\n-              ASM_OUTPUT_ALIGN_WITH_NOP (file, align);\n+              ASM_OUTPUT_ALIGN_WITH_NOP (file, alignment.levels[0].log);\n #else\n-\t      ASM_OUTPUT_ALIGN (file, align);\n+\t      ASM_OUTPUT_ALIGN (file, alignment.levels[0].log);\n #endif\n #endif\n \t    }"}, {"sha": "f025efb4b8e9883a3e44ea78d692ee7ec10ee1f5", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -42,24 +42,6 @@ extern bool final_insns_dump_p;\n \f\n /* Other basic status info about current function.  */\n \n-/* Align flags tuple with alignment in log form and with a maximum skip.  */\n-\n-struct align_flags_tuple\n-{\n-  /* Values of the -falign-* flags: how much to align labels in code.\n-     log is \"align to 2^log\" (so 0 means no alignment).\n-     maxskip is the maximum allowed amount of padding to insert.  */\n-  int log;\n-  int maxskip;\n-};\n-\n-/* Target-dependent global state.  */\n-\n-struct align_flags\n-{\n-  align_flags_tuple levels[2];\n-};\n-\n struct target_flag_state\n {\n   /* Each falign-foo can generate up to two levels of alignment:\n@@ -80,22 +62,10 @@ extern struct target_flag_state *this_target_flag_state;\n #define this_target_flag_state (&default_target_flag_state)\n #endif\n \n-#define state_align_loops\t (this_target_flag_state->x_align_loops)\n-#define state_align_jumps\t (this_target_flag_state->x_align_jumps)\n-#define state_align_labels\t (this_target_flag_state->x_align_labels)\n-#define state_align_functions\t (this_target_flag_state->x_align_functions)\n-#define align_loops_log\t\t (state_align_loops.levels[0].log)\n-#define align_jumps_log\t\t (state_align_jumps.levels[0].log)\n-#define align_labels_log\t (state_align_labels.levels[0].log)\n-#define align_functions_log      (state_align_functions.levels[0].log)\n-#define align_loops_max_skip     (state_align_loops.levels[0].maxskip)\n-#define align_jumps_max_skip     (state_align_jumps.levels[0].maxskip)\n-#define align_labels_max_skip    (state_align_labels.levels[0].maxskip)\n-#define align_functions_max_skip (state_align_functions.levels[0].maxskip)\n-#define align_loops_value\t (align_loops_max_skip + 1)\n-#define align_jumps_value\t (align_jumps_max_skip + 1)\n-#define align_labels_value\t (align_labels_max_skip + 1)\n-#define align_functions_value\t (align_functions_max_skip + 1)\n+#define align_loops\t (this_target_flag_state->x_align_loops)\n+#define align_jumps\t (this_target_flag_state->x_align_jumps)\n+#define align_labels\t (this_target_flag_state->x_align_labels)\n+#define align_functions\t (this_target_flag_state->x_align_functions)\n \n /* String representaions of the above options are available in\n    const char *str_align_foo.  NULL if not set.  */"}, {"sha": "333389e484ce18f5484ab87693d9e98567858970", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -96,11 +96,7 @@ extern int insn_current_reference_address (rtx_insn *);\n \n /* Find the alignment associated with a CODE_LABEL.\n    Defined in final.c.  */\n-extern int label_to_alignment (rtx);\n-\n-/* Find the alignment maximum skip associated with a CODE_LABEL.\n-   Defined in final.c.  */\n-extern int label_to_max_skip (rtx);\n+extern align_flags label_to_alignment (rtx);\n \n /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n extern void output_asm_label (rtx);"}, {"sha": "f87fbaae69efcce254eacbb1f4418d2b6de29254", "filename": "gcc/system.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -918,8 +918,6 @@ extern void fancy_abort (const char *, int, const char *)\n \tRETURN_POPS_ARGS UNITS_PER_SIMD_WORD OVERRIDE_OPTIONS\t\t\\\n \tOPTIMIZATION_OPTIONS CLASS_LIKELY_SPILLED_P\t\t\t\\\n \tUSING_SJLJ_EXCEPTIONS TARGET_UNWIND_INFO\t\t\t\\\n-\tLABEL_ALIGN_MAX_SKIP LOOP_ALIGN_MAX_SKIP\t\t\t\\\n-\tLABEL_ALIGN_AFTER_BARRIER_MAX_SKIP JUMP_ALIGN_MAX_SKIP \t\t\\\n \tCAN_DEBUG_WITHOUT_FP UNLIKELY_EXECUTED_TEXT_SECTION_NAME\t\\\n \tHOT_TEXT_SECTION_NAME LEGITIMATE_CONSTANT_P ALWAYS_STRIP_DOTDOT\t\\\n \tOUTPUT_ADDR_CONST_EXTRA SMALL_REGISTER_CLASSES ASM_OUTPUT_IDENT\t\\"}, {"sha": "2598d3c7783fdd72ea20d40475857ba182c190d8", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -65,46 +65,6 @@ the string should contain a tab, a pseudo-op, and then another tab.\",\n DEFHOOKPOD (aligned_op, \"*\", struct asm_int_op, TARGET_ASM_ALIGNED_INT_OP)\n DEFHOOKPOD (unaligned_op, \"*\", struct asm_int_op, TARGET_ASM_UNALIGNED_INT_OP)\n \n-/* The maximum number of bytes to skip when applying\n-   LABEL_ALIGN_AFTER_BARRIER.  */\n-DEFHOOK\n-(label_align_after_barrier_max_skip,\n- \"The maximum number of bytes to skip before @var{label} when applying\\n\\\n-@code{LABEL_ALIGN_AFTER_BARRIER}.  This works only if\\n\\\n-@code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.\",\n- int, (rtx_insn *label),\n- default_label_align_after_barrier_max_skip)\n-\n-/* The maximum number of bytes to skip when applying\n-   LOOP_ALIGN.  */\n-DEFHOOK\n-(loop_align_max_skip,\n- \"The maximum number of bytes to skip when applying @code{LOOP_ALIGN} to\\n\\\n-@var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN} is\\n\\\n-defined.\",\n- int, (rtx_insn *label),\n- default_loop_align_max_skip)\n-\n-/* The maximum number of bytes to skip when applying\n-   LABEL_ALIGN.  */\n-DEFHOOK\n-(label_align_max_skip,\n- \"The maximum number of bytes to skip when applying @code{LABEL_ALIGN}\\n\\\n-to @var{label}.  This works only if @code{ASM_OUTPUT_MAX_SKIP_ALIGN}\\n\\\n-is defined.\",\n- int, (rtx_insn *label),\n- default_label_align_max_skip)\n-\n-/* The maximum number of bytes to skip when applying\n-   JUMP_ALIGN.  */\n-DEFHOOK\n-(jump_align_max_skip,\n- \"The maximum number of bytes to skip before @var{label} when applying\\n\\\n-@code{JUMP_ALIGN}.  This works only if\\n\\\n-@code{ASM_OUTPUT_MAX_SKIP_ALIGN} is defined.\",\n- int, (rtx_insn *label),\n- default_jump_align_max_skip)\n-\n /* Try to output the assembler code for an integer object whose\n    value is given by X.  SIZE is the size of the object in bytes and\n    ALIGNED_P indicates whether it is aligned.  Return true if"}, {"sha": "76fcec835706413ef715a1e5f59bdb4f3d34b8fe", "filename": "gcc/targhooks.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -236,10 +236,6 @@ extern enum unwind_info_type default_debug_unwind_info (void);\n \n extern void default_canonicalize_comparison (int *, rtx *, rtx *, bool);\n \n-extern int default_label_align_after_barrier_max_skip (rtx_insn *);\n-extern int default_loop_align_max_skip (rtx_insn *);\n-extern int default_label_align_max_skip (rtx_insn *);\n-extern int default_jump_align_max_skip (rtx_insn *);\n extern section * default_function_section(tree decl, enum node_frequency freq,\n \t\t\t\t\t  bool startup, bool exit);\n extern unsigned int default_dwarf_poly_indeterminate_value (unsigned int,"}, {"sha": "a17d60fb17d0652093a632fa8676fedefe77bd9c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1,3 +1,7 @@\n+2018-07-17  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.target/powerpc/loop_align.c: Update scanned pattern.\n+\n 2018-07-17  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/generic_call_cw.adb, gnat.dg/generic_call_iface.adb: New"}, {"sha": "44d989b041e745f5765bcc337d631f4183c4df7d", "filename": "gcc/testsuite/gcc.target/powerpc/loop_align.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Floop_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Floop_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Floop_align.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -2,7 +2,7 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* powerpc-ibm-aix* } } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-O2 -mcpu=power7 -falign-functions=16\" } */\n-/* { dg-final { scan-assembler \".p2align 5,,31\" } } */\n+/* { dg-final { scan-assembler \".p2align 5\" } } */\n \n void f(double *a, double *b, double *c, unsigned long n) {\n   unsigned long i;"}, {"sha": "1fb8fcc1c8b5fb81c02173bca362b0239df62ada", "filename": "gcc/toplev.c", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1207,24 +1207,26 @@ read_log_maxskip (auto_vec<unsigned> &values, align_flags_tuple *a)\n   unsigned n = values.pop ();\n   if (n != 0)\n     a->log = floor_log2 (n * 2 - 1);\n+\n   if (values.is_empty ())\n     a->maxskip = n ? n - 1 : 0;\n   else\n     {\n       unsigned m = values.pop ();\n-      if (m > n)\n-\tm = n;\n       /* -falign-foo=N:M means M-1 max bytes of padding, not M.  */\n       if (m > 0)\n \tm--;\n       a->maxskip = m;\n     }\n+\n+  /* Normalize the tuple.  */\n+  a->normalize ();\n }\n \n /* Parse \"N[:M[:N2[:M2]]]\" string FLAG into a pair of struct align_flags.  */\n \n static void\n-parse_N_M (const char *flag, align_flags &a, unsigned int min_align_log)\n+parse_N_M (const char *flag, align_flags &a)\n {\n   if (flag)\n     {\n@@ -1269,48 +1271,28 @@ parse_N_M (const char *flag, align_flags &a, unsigned int min_align_log)\n \t    {\n \t      /* Set N2 unless subalign can never have any effect.  */\n \t      if (align > a.levels[0].maxskip + 1)\n-\t\ta.levels[1].log = SUBALIGN_LOG;\n+\t\t{\n+\t\t  a.levels[1].log = SUBALIGN_LOG;\n+\t\t  a.levels[1].normalize ();\n+\t\t}\n \t    }\n \t}\n #endif\n \n       /* Cache seen value.  */\n       cache.put (flag, a);\n     }\n-  else\n-    {\n-      /* Reset values to zero.  */\n-      for (unsigned i = 0; i < 2; i++)\n-\t{\n-\t  a.levels[i].log = 0;\n-\t  a.levels[i].maxskip = 0;\n-\t}\n-    }\n-\n-  if ((unsigned int)a.levels[0].log < min_align_log)\n-    {\n-      a.levels[0].log = min_align_log;\n-      a.levels[0].maxskip = (1 << min_align_log) - 1;\n-    }\n }\n \n-/* Minimum alignment requirements, if arch has them.  */\n-\n-unsigned int min_align_loops_log = 0;\n-unsigned int min_align_jumps_log = 0;\n-unsigned int min_align_labels_log = 0;\n-unsigned int min_align_functions_log = 0;\n-\n /* Process -falign-foo=N[:M[:N2[:M2]]] options.  */\n \n void\n parse_alignment_opts (void)\n {\n-  parse_N_M (str_align_loops, state_align_loops, min_align_loops_log);\n-  parse_N_M (str_align_jumps, state_align_jumps, min_align_jumps_log);\n-  parse_N_M (str_align_labels, state_align_labels, min_align_labels_log);\n-  parse_N_M (str_align_functions, state_align_functions,\n-\t     min_align_functions_log);\n+  parse_N_M (str_align_loops, align_loops);\n+  parse_N_M (str_align_jumps, align_jumps);\n+  parse_N_M (str_align_labels, align_labels);\n+  parse_N_M (str_align_functions, align_functions);\n }\n \n /* Process the options that have been parsed.  */"}, {"sha": "0d3609e2807ce2217cbaa00fe2e99520475ec386", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6de53356769e13178975c18b4ce019a800ea946/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e6de53356769e13178975c18b4ce019a800ea946", "patch": "@@ -1801,25 +1801,25 @@ assemble_start_function (tree decl, const char *fnname)\n      Note that we still need to align to DECL_ALIGN, as above,\n      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */\n   if (! DECL_USER_ALIGN (decl)\n-      && align_functions_log > align\n+      && align_functions.levels[0].log > align\n       && optimize_function_for_speed_p (cfun))\n     {\n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n-      int align_log = state_align_functions.levels[0].log;\n+      int align_log = align_functions.levels[0].log;\n #endif\n-      int max_skip = state_align_functions.levels[0].maxskip;\n+      int max_skip = align_functions.levels[0].maxskip;\n       if (flag_limit_function_alignment && crtl->max_insn_address > 0\n \t  && max_skip >= crtl->max_insn_address)\n \tmax_skip = crtl->max_insn_address - 1;\n \n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n       ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file, align_log, max_skip);\n-      if (max_skip == state_align_functions.levels[0].maxskip)\n+      if (max_skip == align_functions.levels[0].maxskip)\n \tASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,\n-\t\t\t\t   state_align_functions.levels[1].log,\n-\t\t\t\t   state_align_functions.levels[1].maxskip);\n+\t\t\t\t   align_functions.levels[1].log,\n+\t\t\t\t   align_functions.levels[1].maxskip);\n #else\n-      ASM_OUTPUT_ALIGN (asm_out_file, state_align_functions.levels[0].log);\n+      ASM_OUTPUT_ALIGN (asm_out_file, align_functions.levels[0].log);\n #endif\n     }\n "}]}