{"sha": "44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRkMGRlOGQ3MDFhYjNiNzQ1MmRlMGVjNWQyOWU1ODc4ZmFkNGIxMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-05-04T15:05:11Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-05-04T15:05:11Z"}, "message": "i386.h (TARGET_SUPPORTS_WIDE_INT): New define.\n\n\t* config/i386/i386.h (TARGET_SUPPORTS_WIDE_INT): New define.\n\t* config/i386/i386.c (ix86_legitimate_constant_p): Handle TImode\n\tas CONST_WIDE_INT, not CONST_DOUBLE.\n\t(ix86_cannot_force_const_mem): Handle CONST_WIDE_INT.\n\t(output_pic_addr_const): Do not handle VOIDmode CONST_DOUBLEs.\n\t(ix86_find_base_term): Do not check for CONST_DOUBLE.\n\t(ix86_print_operand): Do not handle non-FPmode CONST_DOUBLEs.\n\t(ix86_build_signbit_mask): Rewrite using wide ints.\n\t(ix86_split_to_parts) [HOST_BITS_PER_WIDE_INT < 64]: Remove.\n\t(ix86_rtx_costs): Handle CONST_WIDE_INT.\n\t(find_constant): Ditto.\n\t* config/i386/i386.md (bts, btr, btc peepholes): Rewrite\n\tusing gen_int_mode.\n\t* config/i386/predicates.md (x86_64_immediate_operand)\n\t<case CONST_INT>: Remove HOST_BITS_PER_WIDE_INT == 32 code.\n\t(x86_64_zext_immediate_operand): Remove CONST_DOUBLE handling.\n\t<case CONST_INT>: Remove HOST_BITS_PER_WIDE_INT == 32 code.\n\t(const0_operand): Also match const_wide_int.\n\t(constm1_operand): Ditto.\n\t(const1_operand): Ditto.\n\nFrom-SVN: r222767", "tree": {"sha": "97b9c92480587e403af8743e13403c9a1c046ff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97b9c92480587e403af8743e13403c9a1c046ff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a982bcf962c4b72371642a9369d6dea4ac05a979", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a982bcf962c4b72371642a9369d6dea4ac05a979", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a982bcf962c4b72371642a9369d6dea4ac05a979"}], "stats": {"total": 208, "additions": 73, "deletions": 135}, "files": [{"sha": "819d7681a5bd84fb4892df939f2e238b84b40ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "patch": "@@ -1,3 +1,26 @@\n+2015-05-04  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (TARGET_SUPPORTS_WIDE_INT): New define.\n+\t* config/i386/i386.c (ix86_legitimate_constant_p): Handle TImode\n+\tas CONST_WIDE_INT, not CONST_DOUBLE.\n+\t(ix86_cannot_force_const_mem): Handle CONST_WIDE_INT.\n+\t(output_pic_addr_const): Do not handle VOIDmode CONST_DOUBLEs.\n+\t(ix86_find_base_term): Do not check for CONST_DOUBLE.\n+\t(ix86_print_operand): Do not handle non-FPmode CONST_DOUBLEs.\n+\t(ix86_build_signbit_mask): Rewrite using wide ints.\n+\t(ix86_split_to_parts) [HOST_BITS_PER_WIDE_INT < 64]: Remove.\n+\t(ix86_rtx_costs): Handle CONST_WIDE_INT.\n+\t(find_constant): Ditto.\n+\t* config/i386/i386.md (bts, btr, btc peepholes): Rewrite\n+\tusing gen_int_mode.\n+\t* config/i386/predicates.md (x86_64_immediate_operand)\n+\t<case CONST_INT>: Remove HOST_BITS_PER_WIDE_INT == 32 code.\n+\t(x86_64_zext_immediate_operand): Remove CONST_DOUBLE handling.\n+\t<case CONST_INT>: Remove HOST_BITS_PER_WIDE_INT == 32 code.\n+\t(const0_operand): Also match const_wide_int.\n+\t(constm1_operand): Ditto.\n+\t(const1_operand): Ditto.\n+\n 2015-05-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/65965"}, {"sha": "461094f4e26908babded534170df07b4a437a519", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 81, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "patch": "@@ -13077,7 +13077,7 @@ ix86_legitimate_constant_p (machine_mode, rtx x)\n #endif\n       break;\n \n-    case CONST_DOUBLE:\n+    case CONST_WIDE_INT:\n       if (GET_MODE (x) == TImode\n \t  && x != CONST0_RTX (TImode)\n           && !TARGET_64BIT)\n@@ -13107,6 +13107,7 @@ ix86_cannot_force_const_mem (machine_mode mode, rtx x)\n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n+    case CONST_WIDE_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n       return false;\n@@ -13133,7 +13134,7 @@ is_imported_p (rtx x)\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and\n-   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+   that X satisfies CONSTANT_P.  */\n \n bool\n legitimate_pic_operand_p (rtx x)\n@@ -14589,20 +14590,9 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n       break;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE (x) == VOIDmode)\n-\t{\n-\t  /* We can use %d if the number is <32 bits and positive.  */\n-\t  if (CONST_DOUBLE_HIGH (x) || CONST_DOUBLE_LOW (x) < 0)\n-\t    fprintf (file, \"0x%lx%08lx\",\n-\t\t     (unsigned long) CONST_DOUBLE_HIGH (x),\n-\t\t     (unsigned long) CONST_DOUBLE_LOW (x));\n-\t  else\n-\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x));\n-\t}\n-      else\n-\t/* We can't handle floating point constants;\n-\t   TARGET_PRINT_OPERAND must handle them.  */\n-\toutput_operand_lossage (\"floating constant misused\");\n+      /* We can't handle floating point constants;\n+\t TARGET_PRINT_OPERAND must handle them.  */\n+      output_operand_lossage (\"floating constant misused\");\n       break;\n \n     case PLUS:\n@@ -14962,8 +14952,7 @@ ix86_find_base_term (rtx x)\n \treturn x;\n       term = XEXP (x, 0);\n       if (GET_CODE (term) == PLUS\n-\t  && (CONST_INT_P (XEXP (term, 1))\n-\t      || GET_CODE (XEXP (term, 1)) == CONST_DOUBLE))\n+\t  && CONST_INT_P (XEXP (term, 1)))\n \tterm = XEXP (term, 0);\n       if (GET_CODE (term) != UNSPEC\n \t  || (XINT (term, 1) != UNSPEC_GOTPCREL\n@@ -15967,7 +15956,7 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \n       if (code != 'P' && code != 'p')\n \t{\n-\t  if (CONST_INT_P (x) || GET_CODE (x) == CONST_DOUBLE)\n+\t  if (CONST_INT_P (x))\n \t    {\n \t      if (ASSEMBLER_DIALECT == ASM_ATT)\n \t\tputc ('$', file);\n@@ -19444,12 +19433,9 @@ rtx\n ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n {\n   machine_mode vec_mode, imode;\n-  HOST_WIDE_INT hi, lo;\n-  int shift = 63;\n-  rtx v;\n-  rtx mask;\n+  wide_int w;\n+  rtx mask, v;\n \n-  /* Find the sign bit, sign extended to 2*HWI.  */\n   switch (mode)\n     {\n     case V16SImode:\n@@ -19461,7 +19447,6 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n       vec_mode = mode;\n       mode = GET_MODE_INNER (mode);\n       imode = SImode;\n-      lo = 0x80000000, hi = lo < 0;\n       break;\n \n     case V8DImode:\n@@ -19473,54 +19458,25 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n       vec_mode = mode;\n       mode = GET_MODE_INNER (mode);\n       imode = DImode;\n-      if (HOST_BITS_PER_WIDE_INT >= 64)\n-\tlo = (HOST_WIDE_INT)1 << shift, hi = -1;\n-      else\n-\tlo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n       break;\n \n     case TImode:\n     case TFmode:\n       vec_mode = VOIDmode;\n-      if (HOST_BITS_PER_WIDE_INT >= 64)\n-\t{\n-\t  imode = TImode;\n-\t  lo = 0, hi = (HOST_WIDE_INT)1 << shift;\n-\t}\n-      else\n-\t{\n-\t  rtvec vec;\n-\n-\t  imode = DImode;\n-\t  lo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n-\n-\t  if (invert)\n-\t    {\n-\t      lo = ~lo, hi = ~hi;\n-\t      v = constm1_rtx;\n-\t    }\n-\t  else\n-\t    v = const0_rtx;\n-\n-\t  mask = immed_double_const (lo, hi, imode);\n-\n-\t  vec = gen_rtvec (2, v, mask);\n-\t  v = gen_rtx_CONST_VECTOR (V2DImode, vec);\n-\t  v = copy_to_mode_reg (mode, gen_lowpart (mode, v));\n-\n-\t  return v;\n-\t}\n-     break;\n+      imode = TImode;\n+      break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  w = wi::set_bit_in_zero (GET_MODE_BITSIZE (mode) - 1,\n+\t\t\t   GET_MODE_BITSIZE (mode));\n   if (invert)\n-    lo = ~lo, hi = ~hi;\n+    w = wi::bit_not (w);\n \n   /* Force this value into the low part of a fp vector constant.  */\n-  mask = immed_double_const (lo, hi, imode);\n+  mask = immed_wide_int_const (w, imode);\n   mask = gen_lowpart (mode, mask);\n \n   if (vec_mode == VOIDmode)\n@@ -22735,26 +22691,21 @@ ix86_split_to_parts (rtx operand, rtx *parts, machine_mode mode)\n \t      REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n \t      real_to_target (l, &r, mode);\n \n-\t      /* Do not use shift by 32 to avoid warning on 32bit systems.  */\n-\t      if (HOST_BITS_PER_WIDE_INT >= 64)\n-\t        parts[0]\n-\t\t  = gen_int_mode\n-\t\t      ((l[0] & (((HOST_WIDE_INT) 2 << 31) - 1))\n-\t\t       + ((((HOST_WIDE_INT) l[1]) << 31) << 1),\n-\t\t       DImode);\n-\t      else\n-\t        parts[0] = immed_double_const (l[0], l[1], DImode);\n+\t      /* real_to_target puts 32-bit pieces in each long.  */\n+\t      parts[0] =\n+\t\tgen_int_mode\n+\t\t  ((l[0] & (HOST_WIDE_INT) 0xffffffff)\n+\t\t   | ((l[1] & (HOST_WIDE_INT) 0xffffffff) << 32),\n+\t\t   DImode);\n \n \t      if (upper_mode == SImode)\n \t        parts[1] = gen_int_mode (l[2], SImode);\n-\t      else if (HOST_BITS_PER_WIDE_INT >= 64)\n-\t        parts[1]\n-\t\t  = gen_int_mode\n-\t\t      ((l[2] & (((HOST_WIDE_INT) 2 << 31) - 1))\n-\t\t       + ((((HOST_WIDE_INT) l[3]) << 31) << 1),\n-\t\t       DImode);\n \t      else\n-\t        parts[1] = immed_double_const (l[2], l[3], DImode);\n+\t        parts[1] =\n+\t\t  gen_int_mode\n+\t\t    ((l[2] & (HOST_WIDE_INT) 0xffffffff)\n+\t\t     | ((l[3] & (HOST_WIDE_INT) 0xffffffff) << 32),\n+\t\t     DImode);\n \t    }\n \t  else\n \t    gcc_unreachable ();\n@@ -42021,12 +41972,11 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t*total = 0;\n       return true;\n \n+    case CONST_WIDE_INT:\n+      *total = 0;\n+      return true;\n+\n     case CONST_DOUBLE:\n-      if (mode == VOIDmode)\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n       switch (standard_80387_constant_p (x))\n \t{\n \tcase 1: /* 0.0 */\n@@ -50654,6 +50604,7 @@ find_constant (rtx in_rtx, imm_info *imm_values)\n \t  break;\n \n \tcase CONST_DOUBLE:\n+\tcase CONST_WIDE_INT:\n \t  (imm_values->imm)++;\n \t  (imm_values->imm64)++;\n \t  break;"}, {"sha": "24ff911df9eea388b936780ce1ceb3b72c6671ea", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "patch": "@@ -2563,6 +2563,8 @@ extern void debug_dispatch_window (int);\n /* For switching between functions with different target attributes.  */\n #define SWITCHABLE_TARGET 1\n \n+#define TARGET_SUPPORTS_WIDE_INT 1\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "55c5d06f51e5580f42ac21e5da5b798107eb47c6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "patch": "@@ -10686,17 +10686,10 @@\n   \"TARGET_64BIT && !TARGET_USE_BT\"\n   [(const_int 0)]\n {\n-  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n-  rtx op1;\n+  int i = INTVAL (operands[1]);\n \n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else if (i < HOST_BITS_PER_WIDE_INT)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else\n-    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);\n \n-  op1 = immed_double_const (lo, hi, DImode);\n   if (i >= 31)\n     {\n       emit_move_insn (operands[2], op1);\n@@ -10718,17 +10711,10 @@\n   \"TARGET_64BIT && !TARGET_USE_BT\"\n   [(const_int 0)]\n {\n-  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n-  rtx op1;\n-\n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else if (i < HOST_BITS_PER_WIDE_INT)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else\n-    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+  int i = INTVAL (operands[1]);\n \n-  op1 = immed_double_const (~lo, ~hi, DImode);\n+  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);\n+ \n   if (i >= 32)\n     {\n       emit_move_insn (operands[2], op1);\n@@ -10751,17 +10737,10 @@\n   \"TARGET_64BIT && !TARGET_USE_BT\"\n   [(const_int 0)]\n {\n-  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n-  rtx op1;\n+  int i = INTVAL (operands[1]);\n \n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else if (i < HOST_BITS_PER_WIDE_INT)\n-    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n-  else\n-    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+  rtx op1 = gen_int_mode (HOST_WIDE_INT_1U << i, DImode);\n \n-  op1 = immed_double_const (lo, hi, DImode);\n   if (i >= 31)\n     {\n       emit_move_insn (operands[2], op1);"}, {"sha": "26dd3e1d7f8a38901c5c32d757339f119b6810f7", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d0de8d701ab3b7452de0ec5d29e5878fad4b13/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=44d0de8d701ab3b7452de0ec5d29e5878fad4b13", "patch": "@@ -135,18 +135,10 @@\n   switch (GET_CODE (op))\n     {\n     case CONST_INT:\n-      /* CONST_DOUBLES never match, since HOST_BITS_PER_WIDE_INT is known\n-         to be at least 32 and this all acceptable constants are\n-\t represented as CONST_INT.  */\n-      if (HOST_BITS_PER_WIDE_INT == 32)\n-\treturn true;\n-      else\n-\t{\n-\t  HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (op), DImode);\n-\t  return trunc_int_for_mode (val, SImode) == val;\n-\t}\n-      break;\n-\n+      {\n+        HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (op), DImode);\n+        return trunc_int_for_mode (val, SImode) == val;\n+      }\n     case SYMBOL_REF:\n       /* For certain code models, the symbolic references are known to fit.\n \t in CM_SMALL_PIC model we know it fits if it is local to the shared\n@@ -253,21 +245,12 @@\n \n ;; Return true if VALUE can be stored in the zero extended immediate field.\n (define_predicate \"x86_64_zext_immediate_operand\"\n-  (match_code \"const_double,const_int,symbol_ref,label_ref,const\")\n+  (match_code \"const_int,symbol_ref,label_ref,const\")\n {\n   switch (GET_CODE (op))\n     {\n-    case CONST_DOUBLE:\n-      if (HOST_BITS_PER_WIDE_INT == 32)\n-\treturn (GET_MODE (op) == VOIDmode && !CONST_DOUBLE_HIGH (op));\n-      else\n-\treturn false;\n-\n     case CONST_INT:\n-      if (HOST_BITS_PER_WIDE_INT == 32)\n-\treturn INTVAL (op) >= 0;\n-      else\n-\treturn !(INTVAL (op) & ~(HOST_WIDE_INT) 0xffffffff);\n+      return !(INTVAL (op) & ~(HOST_WIDE_INT) 0xffffffff);\n \n     case SYMBOL_REF:\n       /* For certain code models, the symbolic references are known to fit.  */\n@@ -625,7 +608,7 @@\n \n ;; Match exactly zero.\n (define_predicate \"const0_operand\"\n-  (match_code \"const_int,const_double,const_vector\")\n+  (match_code \"const_int,const_wide_int,const_double,const_vector\")\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -634,7 +617,7 @@\n \n ;; Match -1.\n (define_predicate \"constm1_operand\"\n-  (match_code \"const_int,const_double,const_vector\")\n+  (match_code \"const_int,const_wide_int,const_double,const_vector\")\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -643,7 +626,7 @@\n \n ;; Match one or vector filled with ones.\n (define_predicate \"const1_operand\"\n-  (match_code \"const_int,const_double,const_vector\")\n+  (match_code \"const_int,const_wide_int,const_double,const_vector\")\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);"}]}