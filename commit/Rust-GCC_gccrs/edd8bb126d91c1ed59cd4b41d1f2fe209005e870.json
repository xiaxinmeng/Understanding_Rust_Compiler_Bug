{"sha": "edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRkOGJiMTI2ZDkxYzFlZDU5Y2Q0YjQxZDFmMmZlMjA5MDA1ZTg3MA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-03-19T19:11:03Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-03-19T19:11:03Z"}, "message": "i386.c (get_thread_pointer): Add tp_mode argument.\n\n\t* config/i386/i386.c (get_thread_pointer): Add tp_mode argument.\n\tGenerate ZERO_EXTEND in place if GET_MODE (tp) != tp_mode.\n\t(legitimize_tls_address) <TLS_MODEL_INITIAL_EXEC>: Always generate\n\tDImode UNSPEC_GOTNTPOFF references on TARGET_64BIT.\n\t(ix86_decompose_address): Allow zero extended UNSPEC_TP references.\n\n\tRevert:\n\t2012-03-13  Uros Bizjak  <ubizjak@gmail.com>\n\n\t* config/i386/i386.h (TARGET_TLS_INDIRECT_SEG_REFS): New.\n\t* config/i386/i386.c (ix86_decompose_address): Use\n\tTARGET_TLS_INDIRECT_SEG_REFS to prevent %fs:(%reg) addresses.\n\t(legitimize_tls_address): Use TARGET_TLS_INDIRECT_SEG_REFS to load\n\tthread pointer to a register.\n\n\tRevert:\n\t2012-03-10  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (ix86_decompose_address): Disallow fs:(reg)\n\tif Pmode != word_mode.\n\t(legitimize_tls_address): Call gen_tls_initial_exec_x32 if\n\tPmode == SImode for TARGET_X32.\n\n\t* config/i386/i386.md (UNSPEC_TLS_IE_X32): New.\n\t(tls_initial_exec_x32): Likewise.\n\nFrom-SVN: r185536", "tree": {"sha": "025c7cecc98e0bcdb4fdfcb49dcd72b4e14003cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/025c7cecc98e0bcdb4fdfcb49dcd72b4e14003cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/comments", "author": null, "committer": null, "parents": [{"sha": "ae5a8549b5362781fee08085ce3c0a72247c4fbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5a8549b5362781fee08085ce3c0a72247c4fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5a8549b5362781fee08085ce3c0a72247c4fbb"}], "stats": {"total": 121, "additions": 61, "deletions": 60}, "files": [{"sha": "a2cad37479d41e8a7512cb302c06c74f73163097", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "patch": "@@ -1,3 +1,31 @@\n+2012-03-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (get_thread_pointer): Add tp_mode argument.\n+\tGenerate ZERO_EXTEND in place if GET_MODE (tp) != tp_mode.\n+\t(legitimize_tls_address) <TLS_MODEL_INITIAL_EXEC>: Always generate\n+\tDImode UNSPEC_GOTNTPOFF references on TARGET_64BIT.\n+\t(ix86_decompose_address): Allow zero extended UNSPEC_TP references.\n+\n+\tRevert:\n+\t2012-03-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (TARGET_TLS_INDIRECT_SEG_REFS): New.\n+\t* config/i386/i386.c (ix86_decompose_address): Use\n+\tTARGET_TLS_INDIRECT_SEG_REFS to prevent %fs:(%reg) addresses.\n+\t(legitimize_tls_address): Use TARGET_TLS_INDIRECT_SEG_REFS to load\n+\tthread pointer to a register.\n+\n+\tRevert:\n+\t2012-03-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Disallow fs:(reg)\n+\tif Pmode != word_mode.\n+\t(legitimize_tls_address): Call gen_tls_initial_exec_x32 if\n+\tPmode == SImode for TARGET_X32.\n+\n+\t* config/i386/i386.md (UNSPEC_TLS_IE_X32): New.\n+\t(tls_initial_exec_x32): Likewise.\n+\n 2012-03-19  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/50751\n@@ -6,7 +34,7 @@\n \t* config/sh/sh.c (sh_address_cost): Add SH2A special case.\n \t(sh_legitimate_index_p): Allow QImode displacements for non-SH2A.\n \t(sh_legitimize_address): Add QImode displacement handling.\n-\t(sh_cannot_change_mode_class): Disallow GENERAL_REGS for SFmode \n+\t(sh_cannot_change_mode_class): Disallow GENERAL_REGS for SFmode\n \tvector subregs.\n \t(sh_secondary_reload): Add QImode displacement handling.\n \t* config/sh/predicates.md (movsrc_no_disp_mem_operand): New predicate."}, {"sha": "28d32216d35cd0800319aa52c26dc646717be7c3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "patch": "@@ -11514,6 +11514,10 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t      scale = 1 << scale;\n \t      break;\n \n+\t    case ZERO_EXTEND:\n+\t      op = XEXP (op, 0);\n+\t      /* FALLTHRU */\n+\n \t    case UNSPEC:\n \t      if (XINT (op, 1) == UNSPEC_TP\n \t          && TARGET_TLS_DIRECT_SEG_REFS\n@@ -12483,15 +12487,20 @@ legitimize_pic_address (rtx orig, rtx reg)\n /* Load the thread pointer.  If TO_REG is true, force it into a register.  */\n \n static rtx\n-get_thread_pointer (bool to_reg)\n+get_thread_pointer (enum machine_mode tp_mode, bool to_reg)\n {\n   rtx tp = gen_rtx_UNSPEC (ptr_mode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n \n-  if (GET_MODE (tp) != Pmode)\n-    tp = convert_to_mode (Pmode, tp, 1);\n+  if (GET_MODE (tp) != tp_mode)\n+    {\n+      gcc_assert (GET_MODE (tp) == SImode);\n+      gcc_assert (tp_mode == DImode);\n+\n+      tp = gen_rtx_ZERO_EXTEND (tp_mode, tp);\n+    }\n \n   if (to_reg)\n-    tp = copy_addr_to_reg (tp);\n+    tp = copy_to_mode_reg (tp_mode, tp);\n \n   return tp;\n }\n@@ -12543,6 +12552,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n {\n   rtx dest, base, off;\n   rtx pic = NULL_RTX, tp = NULL_RTX;\n+  enum machine_mode tp_mode = Pmode;\n   int type;\n \n   switch (model)\n@@ -12568,7 +12578,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \t  else\n \t    emit_insn (gen_tls_dynamic_gnu2_32 (dest, x, pic));\n \n-\t  tp = get_thread_pointer (true);\n+\t  tp = get_thread_pointer (Pmode, true);\n \t  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));\n \n \t  set_unique_reg_note (get_last_insn (), REG_EQUAL, x);\n@@ -12618,7 +12628,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \t  else\n \t    emit_insn (gen_tls_dynamic_gnu2_32 (base, tmp, pic));\n \n-\t  tp = get_thread_pointer (true);\n+\t  tp = get_thread_pointer (Pmode, true);\n \t  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n \t\t\t       gen_rtx_MINUS (Pmode, tmp, tp));\n \t}\n@@ -12674,18 +12684,10 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \t      emit_insn (gen_tls_initial_exec_64_sun (dest, x));\n \t      return dest;\n \t    }\n-\t  else if (Pmode == SImode)\n-\t    {\n-\t      /* Always generate\n-\t\t\tmovl %fs:0, %reg32\n-\t\t\taddl xgottpoff(%rip), %reg32\n-\t\t to support linker IE->LE optimization and avoid\n-\t\t fs:(%reg32) as memory operand.  */\n-\t      dest = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_tls_initial_exec_x32 (dest, x));\n-\t      return dest;\n-\t    }\n \n+\t  /* Generate DImode references to avoid %fs:(%reg32)\n+\t     problems and linker IE->LE relaxation bug.  */\n+\t  tp_mode = DImode;\n \t  pic = NULL;\n \t  type = UNSPEC_GOTNTPOFF;\n \t}\n@@ -12708,24 +12710,23 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \t  type = UNSPEC_INDNTPOFF;\n \t}\n \n-      off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), type);\n-      off = gen_rtx_CONST (Pmode, off);\n+      off = gen_rtx_UNSPEC (tp_mode, gen_rtvec (1, x), type);\n+      off = gen_rtx_CONST (tp_mode, off);\n       if (pic)\n-\toff = gen_rtx_PLUS (Pmode, pic, off);\n-      off = gen_const_mem (Pmode, off);\n+\toff = gen_rtx_PLUS (tp_mode, pic, off);\n+      off = gen_const_mem (tp_mode, off);\n       set_mem_alias_set (off, ix86_GOT_alias_set ());\n \n       if (TARGET_64BIT || TARGET_ANY_GNU_TLS)\n \t{\n-          base = get_thread_pointer (for_mov\n-\t\t\t\t     || !(TARGET_TLS_DIRECT_SEG_REFS\n-\t\t\t\t\t  && TARGET_TLS_INDIRECT_SEG_REFS));\n-\t  off = force_reg (Pmode, off);\n-\t  return gen_rtx_PLUS (Pmode, base, off);\n+\t  base = get_thread_pointer (tp_mode,\n+\t\t\t\t     for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n+\t  off = force_reg (tp_mode, off);\n+\t  return gen_rtx_PLUS (tp_mode, base, off);\n \t}\n       else\n \t{\n-\t  base = get_thread_pointer (true);\n+\t  base = get_thread_pointer (Pmode, true);\n \t  dest = gen_reg_rtx (Pmode);\n \t  emit_insn (ix86_gen_sub3 (dest, base, off));\n \t}\n@@ -12739,14 +12740,13 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \n       if (TARGET_64BIT || TARGET_ANY_GNU_TLS)\n \t{\n-\t  base = get_thread_pointer (for_mov\n-\t\t\t\t     || !(TARGET_TLS_DIRECT_SEG_REFS\n-\t\t\t\t\t  && TARGET_TLS_INDIRECT_SEG_REFS));\n+\t  base = get_thread_pointer (Pmode,\n+\t\t\t\t     for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n \t  return gen_rtx_PLUS (Pmode, base, off);\n \t}\n       else\n \t{\n-\t  base = get_thread_pointer (true);\n+\t  base = get_thread_pointer (Pmode, true);\n \t  dest = gen_reg_rtx (Pmode);\n \t  emit_insn (ix86_gen_sub3 (dest, base, off));\n \t}\n@@ -13274,8 +13274,7 @@ ix86_delegitimize_tls_address (rtx orig_x)\n   rtx x = orig_x, unspec;\n   struct ix86_address addr;\n \n-  if (!(TARGET_TLS_DIRECT_SEG_REFS\n-\t&& TARGET_TLS_INDIRECT_SEG_REFS))\n+  if (!TARGET_TLS_DIRECT_SEG_REFS)\n     return orig_x;\n   if (MEM_P (x))\n     x = XEXP (x, 0);"}, {"sha": "3fcd2093e362d23b89eef30108d3a3a3cc0d9b7c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "patch": "@@ -467,9 +467,6 @@ extern int x86_prefetch_sse;\n #define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT 0\n #endif\n \n-/* Address override works only on the (%reg) part of %fs:(%reg).  */\n-#define TARGET_TLS_INDIRECT_SEG_REFS (Pmode == word_mode)\n-\n /* Fence to use after loop using storent.  */\n \n extern tree x86_mfence;"}, {"sha": "8e8eb7fda703446eb5060823c7e2fe313091ddd9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd8bb126d91c1ed59cd4b41d1f2fe209005e870/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=edd8bb126d91c1ed59cd4b41d1f2fe209005e870", "patch": "@@ -96,7 +96,6 @@\n   UNSPEC_TLS_LD_BASE\n   UNSPEC_TLSDESC\n   UNSPEC_TLS_IE_SUN\n-  UNSPEC_TLS_IE_X32\n \n   ;; Other random patterns\n   UNSPEC_SCAS\n@@ -12836,28 +12835,6 @@\n }\n   [(set_attr \"type\" \"multi\")])\n \n-;; When Pmode == SImode, there may be no REX prefix for ADD.  Avoid\n-;; any instructions between MOV and ADD, which may interfere linker\n-;; IE->LE optimization, since the last byte of the previous instruction\n-;; before ADD may look like a REX prefix.  This also avoids\n-;;\tmovl x@gottpoff(%rip), %reg32\n-;;\tmovl $fs:(%reg32), %reg32\n-;; Since address override works only on the (reg32) part in fs:(reg32),\n-;; we can't use it as memory operand.\n-(define_insn \"tls_initial_exec_x32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI\n-\t [(match_operand 1 \"tls_symbolic_operand\")]\n-\t UNSPEC_TLS_IE_X32))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_X32\"\n-{\n-  output_asm_insn\n-    (\"mov{l}\\t{%%fs:0, %0|%0, DWORD PTR fs:0}\", operands);\n-  return \"add{l}\\t{%a1@gottpoff(%%rip), %0|%0, %a1@gottpoff[rip]}\";\n-}\n-  [(set_attr \"type\" \"multi\")])\n-\n ;; GNU2 TLS patterns can be split.\n \n (define_expand \"tls_dynamic_gnu2_32\""}]}