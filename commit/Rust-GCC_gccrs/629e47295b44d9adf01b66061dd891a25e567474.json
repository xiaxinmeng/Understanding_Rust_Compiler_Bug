{"sha": "629e47295b44d9adf01b66061dd891a25e567474", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI5ZTQ3Mjk1YjQ0ZDlhZGYwMWI2NjA2MWRkODkxYTI1ZTU2NzQ3NA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-13T12:40:34Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-13T12:40:34Z"}, "message": "libitm: Fix privatization safety interaction with serial mode.\n\nFrom-SVN: r232322", "tree": {"sha": "0f4bfc83fa01d0a035d86c869e199905d89075cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f4bfc83fa01d0a035d86c869e199905d89075cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/629e47295b44d9adf01b66061dd891a25e567474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629e47295b44d9adf01b66061dd891a25e567474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/629e47295b44d9adf01b66061dd891a25e567474", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629e47295b44d9adf01b66061dd891a25e567474/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bc47ae2a784685f79dca8d7d04135c939a49452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc47ae2a784685f79dca8d7d04135c939a49452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc47ae2a784685f79dca8d7d04135c939a49452"}], "stats": {"total": 114, "additions": 109, "deletions": 5}, "files": [{"sha": "03624d4a4ed0d89ca9d937d91170f1decf65e502", "filename": "libitm/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -1,3 +1,15 @@\n+2016-01-13  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (gtm_thread::trycommit): Fix privatization safety.\n+\t* config/linux/rwlock.cc (gtm_rwlock::write_lock_generic): Likewise.\n+\t* config/posix/rwlock.cc (gtm_rwlock::write_lock_generic): Likewise.\n+\t* dispatch.h (abi_dispatch::snapshot_most_recent): New.\n+\t* method-gl.cc (gl_wt_dispatch::snapshot_most_recent): New.\n+\t* method-ml.cc (ml_wt_dispatch::snapshot_most_recent): New.\n+\t* method-serial.cc (serial_dispatch::snapshot_most_recent): New.\n+\t(serialirr_dispatch::snapshot_most_recent): New.\n+\t(serialirr_onwrite_dispatch::snapshot_most_recent): New.\n+\n 2016-01-12  Torvald Riegel  <triegel@redhat.com>\n \n \t* libitm_i.h (gtm_mask_stack): Remove."}, {"sha": "85fb4f13ed5b787fdda9627d5cd505b817795c80", "filename": "libitm/beginend.cc", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -568,8 +568,9 @@ GTM::gtm_thread::trycommit ()\n   gtm_word priv_time = 0;\n   if (abi_disp()->trycommit (priv_time))\n     {\n-      // The transaction is now inactive. Everything that we still have to do\n-      // will not synchronize with other transactions anymore.\n+      // The transaction is now finished but we will still access some shared\n+      // data if we have to ensure privatization safety.\n+      bool do_read_unlock = false;\n       if (state & gtm_thread::STATE_SERIAL)\n         {\n           gtm_thread::serial_lock.write_unlock ();\n@@ -578,7 +579,27 @@ GTM::gtm_thread::trycommit ()\n           priv_time = 0;\n         }\n       else\n-\tgtm_thread::serial_lock.read_unlock (this);\n+\t{\n+\t  // If we have to ensure privatization safety, we must not yet\n+\t  // release the read lock and become inactive because (1) we still\n+\t  // have to go through the list of all transactions, which can be\n+\t  // modified by serial mode threads, and (2) we interpret each\n+\t  // transactions' shared_state in the context of what we believe to\n+\t  // be the current method group (and serial mode transactions can\n+\t  // change the method group).  Therefore, if we have to ensure\n+\t  // privatization safety, delay becoming inactive but set a maximum\n+\t  // snapshot time (we have committed and thus have an empty snapshot,\n+\t  // so it will always be most recent).  Use release MO so that this\n+\t  // synchronizes with other threads observing our snapshot time.\n+\t  if (priv_time)\n+\t    {\n+\t      do_read_unlock = true;\n+\t      shared_state.store((~(typeof gtm_thread::shared_state)0) - 1,\n+\t\t  memory_order_release);\n+\t    }\n+\t  else\n+\t    gtm_thread::serial_lock.read_unlock (this);\n+\t}\n       state = 0;\n \n       // We can commit the undo log after dispatch-specific commit and after\n@@ -618,8 +639,11 @@ GTM::gtm_thread::trycommit ()\n \t    }\n \t}\n \n-      // After ensuring privatization safety, we execute potentially\n-      // privatizing actions (e.g., calling free()). User actions are first.\n+      // After ensuring privatization safety, we are now truly inactive and\n+      // thus can release the read lock.  We will also execute potentially\n+      // privatizing actions (e.g., calling free()).  User actions are first.\n+      if (do_read_unlock)\n+\tgtm_thread::serial_lock.read_unlock (this);\n       commit_user_actions ();\n       commit_allocations (false, 0);\n "}, {"sha": "381a553171eb55811267a00aa1aee678b2de955b", "filename": "libitm/config/linux/rwlock.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fconfig%2Flinux%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fconfig%2Flinux%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -158,6 +158,19 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n       while (it->shared_state.load (memory_order_relaxed)\n           != ~(typeof it->shared_state)0)\n \t{\n+\t  // If this is an upgrade, we have to break deadlocks with\n+\t  // privatization safety.  This may fail on our side, in which\n+\t  // case we need to cancel our attempt to upgrade.  Also, we do not\n+\t  // block but just spin so that we never have to be woken.\n+\t  if (tx != 0)\n+\t    {\n+\t      if (!abi_disp()->snapshot_most_recent ())\n+\t\t{\n+\t\t  write_unlock ();\n+\t\t  return false;\n+\t\t}\n+\t      continue;\n+\t    }\n \t  // An active reader. Wait until it has finished. To avoid lost\n \t  // wake-ups, we need to use Dekker-like synchronization.\n \t  // Note that we can reset writer_readers to zero when we see after"}, {"sha": "1e1eea820f290539ebfbee1fa46b7f5f1aefe894", "filename": "libitm/config/posix/rwlock.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fconfig%2Fposix%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fconfig%2Fposix%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -200,6 +200,26 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n       if (readers == 0)\n \tbreak;\n \n+      // If this is an upgrade, we have to break deadlocks with\n+      // privatization safety.  This may fail on our side, in which\n+      // case we need to cancel our attempt to upgrade.  Also, we do not\n+      // block using the convdar but just spin so that we never have to be\n+      // woken.\n+      // FIXME This is horribly inefficient -- but so is not being able\n+      // to use futexes in this case.\n+      if (tx != 0)\n+\t{\n+\t  pthread_mutex_unlock (&this->mutex);\n+\t  if (!abi_disp ()->snapshot_most_recent ())\n+\t    {\n+\t      write_unlock ();\n+\t      return false;\n+\t    }\n+\t  pthread_mutex_lock (&this->mutex);\n+\t  continue;\n+\t}\n+\n+\n       // We've seen a number of readers, so we publish this number and wait.\n       this->a_readers = readers;\n       pthread_cond_wait (&this->c_confirmed_writers, &this->mutex);"}, {"sha": "4ec5631582937a5c50fd51c1290a4822d9e5e8d7", "filename": "libitm/dispatch.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fdispatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fdispatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fdispatch.h?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -291,6 +291,10 @@ struct abi_dispatch\n   // Rolls back a transaction. Called on abort or after trycommit() returned\n   // false.\n   virtual void rollback(gtm_transaction_cp *cp = 0) = 0;\n+  // Returns true iff the snapshot is most recent, which will be the case if\n+  // this transaction cannot be the reason why other transactions cannot\n+  // ensure privatization safety.\n+  virtual bool snapshot_most_recent() = 0;\n \n   // Return an alternative method that is compatible with the current\n   // method but supports closed nesting. Return zero if there is none."}, {"sha": "b2e2bcad71e6ca133206fb5b8ea5e53babfbb9ce", "filename": "libitm/method-gl.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-gl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-gl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-gl.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -338,6 +338,15 @@ class gl_wt_dispatch : public abi_dispatch\n \n   }\n \n+  virtual bool snapshot_most_recent()\n+  {\n+    // This is the same check as in validate() except that we do not restart\n+    // on failure but simply return the result.\n+    return o_gl_mg.orec.load(memory_order_relaxed)\n+\t== gtm_thr()->shared_state.load(memory_order_relaxed);\n+  }\n+\n+\n   CREATE_DISPATCH_METHODS(virtual, )\n   CREATE_DISPATCH_METHODS_MEM()\n "}, {"sha": "723643ab97cdcf51b8affb641fadbe2f70721290", "filename": "libitm/method-ml.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-ml.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-ml.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-ml.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -604,6 +604,24 @@ class ml_wt_dispatch : public abi_dispatch\n     tx->readlog.clear();\n   }\n \n+  virtual bool snapshot_most_recent()\n+  {\n+    // This is the same code as in extend() except that we do not restart\n+    // on failure but simply return the result, and that we don't validate\n+    // if our snapshot is already most recent.\n+    gtm_thread* tx = gtm_thr();\n+    gtm_word snapshot = o_ml_mg.time.load(memory_order_acquire);\n+    if (snapshot == tx->shared_state.load(memory_order_relaxed))\n+      return true;\n+    if (!validate(tx))\n+      return false;\n+\n+    // Update our public snapshot time.  Necessary so that we do not prevent\n+    // other transactions from ensuring privatization safety.\n+    tx->shared_state.store(snapshot, memory_order_release);\n+    return true;\n+  }\n+\n   virtual bool supports(unsigned number_of_threads)\n   {\n     // Each txn can commit and fail and rollback once before checking for"}, {"sha": "1123e34d56ba1cb42a117285e5fd2e78120fa210", "filename": "libitm/method-serial.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-serial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629e47295b44d9adf01b66061dd891a25e567474/libitm%2Fmethod-serial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-serial.cc?ref=629e47295b44d9adf01b66061dd891a25e567474", "patch": "@@ -95,6 +95,7 @@ class serialirr_dispatch : public abi_dispatch\n   virtual gtm_restart_reason begin_or_restart() { return NO_RESTART; }\n   virtual bool trycommit(gtm_word& priv_time) { return true; }\n   virtual void rollback(gtm_transaction_cp *cp) { abort(); }\n+  virtual bool snapshot_most_recent() { return true; }\n \n   virtual abi_dispatch* closed_nesting_alternative()\n   {\n@@ -149,6 +150,7 @@ class serial_dispatch : public abi_dispatch\n   // Local undo will handle this.\n   // trydropreference() need not be changed either.\n   virtual void rollback(gtm_transaction_cp *cp) { }\n+  virtual bool snapshot_most_recent() { return true; }\n \n   CREATE_DISPATCH_METHODS(virtual, )\n   CREATE_DISPATCH_METHODS_MEM()\n@@ -210,6 +212,8 @@ class serialirr_onwrite_dispatch : public serialirr_dispatch\n     if (tx->state & gtm_thread::STATE_IRREVOCABLE)\n       abort();\n   }\n+\n+  virtual bool snapshot_most_recent() { return true; }\n };\n \n // This group is pure HTM with serial mode as a fallback.  There is no"}]}