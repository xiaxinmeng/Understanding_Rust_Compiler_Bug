{"sha": "1098d3a5510e41a94ce96feaa087f608112ea01b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA5OGQzYTU1MTBlNDFhOTRjZTk2ZmVhYTA4N2Y2MDgxMTJlYTAxYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-09-08T09:25:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-09-08T09:25:47Z"}, "message": "re PR rtl-optimization/41239 (Scheduler reorders division by zero before a call that might not return)\n\n\tPR rtl-optimization/41239\n\t* sched-int.h (struct deps): Add last_function_call_may_noreturn field.\n\t* sched-rgn.c (deps_join): Join also last_function_call_may_noreturn\n\tlists.\n\t* sched-deps.c (sched_analyze_insn): Prevent moving trapping insns\n\tacross calls, as the calls might not always return normally.\n\t(call_may_noreturn_p): New function.\n\t(deps_analyze_insn): Update last_function_call_may_noreturn list.\n\t(init_deps): Initialize it.\n\t(remove_from_deps): Also remove calls from\n\tlast_function_call_may_noreturn list.\n\n\t* gcc.c-torture/execute/pr41239.c: New test.\n\nFrom-SVN: r151500", "tree": {"sha": "46fd118f8f43c998742ad489596528e4cc25da80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46fd118f8f43c998742ad489596528e4cc25da80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1098d3a5510e41a94ce96feaa087f608112ea01b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1098d3a5510e41a94ce96feaa087f608112ea01b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1098d3a5510e41a94ce96feaa087f608112ea01b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1098d3a5510e41a94ce96feaa087f608112ea01b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c673a2c7b495c12e5d332838494523f5c62c85da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c673a2c7b495c12e5d332838494523f5c62c85da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c673a2c7b495c12e5d332838494523f5c62c85da"}], "stats": {"total": 188, "additions": 186, "deletions": 2}, "files": [{"sha": "bb965df4b390a0113279db4573c5d44544ef9065", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -1,3 +1,17 @@\n+2009-09-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/41239\n+\t* sched-int.h (struct deps): Add last_function_call_may_noreturn field.\n+\t* sched-rgn.c (deps_join): Join also last_function_call_may_noreturn\n+\tlists.\n+\t* sched-deps.c (sched_analyze_insn): Prevent moving trapping insns\n+\tacross calls, as the calls might not always return normally.\n+\t(call_may_noreturn_p): New function.\n+\t(deps_analyze_insn): Update last_function_call_may_noreturn list.\n+\t(init_deps): Initialize it.\n+\t(remove_from_deps): Also remove calls from\n+\tlast_function_call_may_noreturn list.\n+\n 2009-09-07  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.md (UNSPEC_VOLATILE_STALL): New constant."}, {"sha": "cef383a1d0eb864f50220359441812d73573b90b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -2598,6 +2598,12 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n   can_start_lhs_rhs_p = (NONJUMP_INSN_P (insn)\n \t\t\t && code == SET);\n \n+  if (may_trap_p (x))\n+    /* Avoid moving trapping instructions accross function calls that might\n+       not always return.  */\n+    add_dependence_list (insn, deps->last_function_call_may_noreturn,\n+\t\t\t 1, REG_DEP_ANTI);\n+\n   if (code == COND_EXEC)\n     {\n       sched_analyze_2 (deps, COND_EXEC_TEST (x), insn);\n@@ -3114,6 +3120,73 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n     }\n }\n \n+/* Return TRUE if INSN might not always return normally (e.g. call exit,\n+   longjmp, loop forever, ...).  */\n+static bool\n+call_may_noreturn_p (rtx insn)\n+{\n+  rtx call;\n+\n+  /* const or pure calls that aren't looping will always return.  */\n+  if (RTL_CONST_OR_PURE_CALL_P (insn)\n+      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))\n+    return false;\n+\n+  call = PATTERN (insn);\n+  if (GET_CODE (call) == PARALLEL)\n+    call = XVECEXP (call, 0, 0);\n+  if (GET_CODE (call) == SET)\n+    call = SET_SRC (call);\n+  if (GET_CODE (call) == CALL\n+      && MEM_P (XEXP (call, 0))\n+      && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n+    {\n+      rtx symbol = XEXP (XEXP (call, 0), 0);\n+      if (SYMBOL_REF_DECL (symbol)\n+\t  && TREE_CODE (SYMBOL_REF_DECL (symbol)) == FUNCTION_DECL)\n+\t{\n+\t  if (DECL_BUILT_IN_CLASS (SYMBOL_REF_DECL (symbol))\n+\t      == BUILT_IN_NORMAL)\n+\t    switch (DECL_FUNCTION_CODE (SYMBOL_REF_DECL (symbol)))\n+\t      {\n+\t      case BUILT_IN_BCMP:\n+\t      case BUILT_IN_BCOPY:\n+\t      case BUILT_IN_BZERO:\n+\t      case BUILT_IN_INDEX:\n+\t      case BUILT_IN_MEMCHR:\n+\t      case BUILT_IN_MEMCMP:\n+\t      case BUILT_IN_MEMCPY:\n+\t      case BUILT_IN_MEMMOVE:\n+\t      case BUILT_IN_MEMPCPY:\n+\t      case BUILT_IN_MEMSET:\n+\t      case BUILT_IN_RINDEX:\n+\t      case BUILT_IN_STPCPY:\n+\t      case BUILT_IN_STPNCPY:\n+\t      case BUILT_IN_STRCAT:\n+\t      case BUILT_IN_STRCHR:\n+\t      case BUILT_IN_STRCMP:\n+\t      case BUILT_IN_STRCPY:\n+\t      case BUILT_IN_STRCSPN:\n+\t      case BUILT_IN_STRLEN:\n+\t      case BUILT_IN_STRNCAT:\n+\t      case BUILT_IN_STRNCMP:\n+\t      case BUILT_IN_STRNCPY:\n+\t      case BUILT_IN_STRPBRK:\n+\t      case BUILT_IN_STRRCHR:\n+\t      case BUILT_IN_STRSPN:\n+\t      case BUILT_IN_STRSTR:\n+\t\t/* Assume certain string/memory builtins always return.  */\n+\t\treturn false;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  /* For all other calls assume that they might not always return.  */\n+  return true;\n+}\n+\n /* Analyze INSN with DEPS as a context.  */\n void\n deps_analyze_insn (struct deps *deps, rtx insn)\n@@ -3212,7 +3285,16 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n           /* Remember the last function call for limiting lifetimes.  */\n           free_INSN_LIST_list (&deps->last_function_call);\n           deps->last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n-          \n+\n+\t  if (call_may_noreturn_p (insn))\n+\t    {\n+\t      /* Remember the last function call that might not always return\n+\t\t normally for limiting moves of trapping insns.  */\n+\t      free_INSN_LIST_list (&deps->last_function_call_may_noreturn);\n+\t      deps->last_function_call_may_noreturn\n+\t\t= alloc_INSN_LIST (insn, NULL_RTX);\n+\t    }\n+\n           /* Before reload, begin a post-call group, so as to keep the\n              lifetimes of hard registers correct.  */\n           if (! reload_completed)\n@@ -3366,6 +3448,7 @@ init_deps (struct deps *deps)\n   deps->pending_flush_length = 0;\n   deps->last_pending_memory_flush = 0;\n   deps->last_function_call = 0;\n+  deps->last_function_call_may_noreturn = 0;\n   deps->sched_before_next_call = 0;\n   deps->in_post_call_group_p = not_post_call;\n   deps->last_debug_insn = 0;\n@@ -3446,7 +3529,11 @@ remove_from_deps (struct deps *deps, rtx insn)\n     }\n \n   if (CALL_P (insn))\n-    remove_from_dependence_list (insn, &deps->last_function_call);\n+    {\n+      remove_from_dependence_list (insn, &deps->last_function_call);\n+      remove_from_dependence_list (insn, \n+\t\t\t\t   &deps->last_function_call_may_noreturn);\n+    }\n   remove_from_dependence_list (insn, &deps->sched_before_next_call);\n }\n "}, {"sha": "4d60ece28c9db7ff48868a5b9d6029bd30b235f6", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -502,6 +502,12 @@ struct deps\n      Used to prevent register lifetimes from expanding unnecessarily.  */\n   rtx last_function_call;\n \n+  /* A list of the last function calls that may not return normally\n+     we have seen.  We use a list to represent last function calls from\n+     multiple predecessor blocks.  Used to prevent moving trapping insns\n+     across such calls.  */\n+  rtx last_function_call_may_noreturn;\n+\n   /* A list of insns which use a pseudo register that does not already\n      cross a call.  We create dependencies between each of those insn\n      and the next call insn, to ensure that they won't cross a call after"}, {"sha": "de2dd0acd1d32d69e2e59a41bbc150853bd6a535", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -2645,6 +2645,11 @@ deps_join (struct deps *succ_deps, struct deps *pred_deps)\n     = concat_INSN_LIST (pred_deps->last_function_call,\n                         succ_deps->last_function_call);\n \n+  /* last_function_call_may_noreturn is inherited by successor.  */\n+  succ_deps->last_function_call_may_noreturn\n+    = concat_INSN_LIST (pred_deps->last_function_call_may_noreturn,\n+                        succ_deps->last_function_call_may_noreturn);\n+\n   /* sched_before_next_call is inherited by successor.  */\n   succ_deps->sched_before_next_call\n     = concat_INSN_LIST (pred_deps->sched_before_next_call,"}, {"sha": "026f8a95d5873bda720f4d65d6fd4516b052672a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -1,3 +1,8 @@\n+2009-09-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/41239\n+\t* gcc.c-torture/execute/pr41239.c: New test.\n+\n 2009-09-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/41192"}, {"sha": "9966b867c3b472777649b910b40d77c8da7a7b2d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr41239.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41239.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1098d3a5510e41a94ce96feaa087f608112ea01b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41239.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41239.c?ref=1098d3a5510e41a94ce96feaa087f608112ea01b", "patch": "@@ -0,0 +1,67 @@\n+/* PR rtl-optimization/41239 */\n+\n+struct S\n+{\n+  short nargs;\n+  unsigned long arg[2];\n+};\n+\n+extern void abort (void);\n+extern void exit (int);\n+extern char fn1 (int, const char *, int, const char *, const char *);\n+extern void fn2 (int, ...);\n+extern int fn3 (int);\n+extern int fn4 (const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));\n+\n+unsigned long\n+test (struct S *x)\n+{\n+  signed int arg1 = x->arg[0];\n+  long int arg2 = x->arg[1];\n+\n+  if (arg2 == 0)\n+    (fn1 (20, \"foo\", 924, __func__, ((void *) 0))\n+     ? (fn2 (fn3 (0x2040082), fn4 (\"division by zero\")))\n+     : (void) 0);\n+\n+  return (long int) arg1 / arg2;\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s = { 2, { 5, 0 } };\n+  test (&s);\n+  abort ();\n+}\n+\n+__attribute__((noinline)) char\n+fn1 (int x, const char *y, int z, const char *w, const char *v)\n+{\n+  asm volatile (\"\" : : \"r\" (w), \"r\" (v) : \"memory\");\n+  asm volatile (\"\" : \"+r\" (x) : \"r\" (y), \"r\" (z) : \"memory\");\n+  return x;\n+}\n+\n+__attribute__((noinline)) int\n+fn3 (int x)\n+{\n+  asm volatile (\"\" : \"+r\" (x) : : \"memory\");\n+  return x;\n+}\n+\n+__attribute__((noinline)) int\n+fn4 (const char *x, ...)\n+{\n+  asm volatile (\"\" : \"+r\" (x) : : \"memory\");\n+  return *x;\n+}\n+\n+__attribute__((noinline)) void\n+fn2 (int x, ...)\n+{\n+  asm volatile (\"\" : \"+r\" (x) : : \"memory\");\n+  if (x)\n+    /* Could be a longjmp or throw too.  */\n+    exit (0);\n+}"}]}