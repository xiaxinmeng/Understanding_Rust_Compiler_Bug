{"sha": "a47850552a0a25db7793a4eaf4859d43368a8b65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ3ODUwNTUyYTBhMjVkYjc3OTNhNGVhZjQ4NTlkNDMzNjhhOGI2NQ==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:31:49Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:39:09Z"}, "message": "libsanitizer:  Add tests\n\nOnly interesting thing here is that we have to make sure the tagging mechanism\nis deterministic to avoid flaky tests.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/ubsan/sanitize-recover-7.c: Update error message format.\n\t* lib/asan-dg.exp (asan_link_flags): Implement as a helper\n\tfunction asan_link_flags_1 which asan_link_flags and\n\thwasan_link_flags use.\n\t(asan_link_flags_1): Parametrised version of asan_link_flags.\n\t* c-c++-common/hwasan/aligned-alloc.c: New test.\n\t* c-c++-common/hwasan/alloca-array-accessible.c: New test.\n\t* c-c++-common/hwasan/alloca-base-init.c: New test.\n\t* c-c++-common/hwasan/alloca-gets-different-tag.c: New test.\n\t* c-c++-common/hwasan/alloca-outside-caught.c: New test.\n\t* c-c++-common/hwasan/arguments-1.c: New test.\n\t* c-c++-common/hwasan/arguments-2.c: New test.\n\t* c-c++-common/hwasan/arguments-3.c: New test.\n\t* c-c++-common/hwasan/arguments.c: New test.\n\t* c-c++-common/hwasan/asan-pr63316.c: New test.\n\t* c-c++-common/hwasan/asan-pr70541.c: New test.\n\t* c-c++-common/hwasan/asan-pr78106.c: New test.\n\t* c-c++-common/hwasan/asan-pr79944.c: New test.\n\t* c-c++-common/hwasan/asan-rlimit-mmap-test-1.c: New test.\n\t* c-c++-common/hwasan/bitfield-1.c: New test.\n\t* c-c++-common/hwasan/bitfield-2.c: New test.\n\t* c-c++-common/hwasan/builtin-special-handling.c: New test.\n\t* c-c++-common/hwasan/check-interface.c: New test.\n\t* c-c++-common/hwasan/halt_on_error-1.c: New test.\n\t* c-c++-common/hwasan/handles-poly_int-marked-vars.c: New test.\n\t* c-c++-common/hwasan/heap-overflow.c: New test.\n\t* c-c++-common/hwasan/hwasan-poison-optimisation.c: New test.\n\t* c-c++-common/hwasan/hwasan-thread-access-parent.c: New test.\n\t* c-c++-common/hwasan/hwasan-thread-basic-failure.c: New test.\n\t* c-c++-common/hwasan/hwasan-thread-clears-stack.c: New test.\n\t* c-c++-common/hwasan/hwasan-thread-success.c: New test.\n\t* c-c++-common/hwasan/kernel-defaults.c: New test.\n\t* c-c++-common/hwasan/large-aligned-0.c: New test.\n\t* c-c++-common/hwasan/large-aligned-1.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-0.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-1.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-2.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-3.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-4.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-5.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-6.c: New test.\n\t* c-c++-common/hwasan/large-aligned-untagging-7.c: New test.\n\t* c-c++-common/hwasan/macro-definition.c: New test.\n\t* c-c++-common/hwasan/no-sanitize-attribute.c: New test.\n\t* c-c++-common/hwasan/param-instrument-mem-intrinsics.c: New test.\n\t* c-c++-common/hwasan/param-instrument-reads-and-writes.c: New test.\n\t* c-c++-common/hwasan/param-instrument-reads.c: New test.\n\t* c-c++-common/hwasan/param-instrument-writes.c: New test.\n\t* c-c++-common/hwasan/random-frame-tag.c: New test.\n\t* c-c++-common/hwasan/sanity-check-pure-c.c: New test.\n\t* c-c++-common/hwasan/setjmp-longjmp-0.c: New test.\n\t* c-c++-common/hwasan/setjmp-longjmp-1.c: New test.\n\t* c-c++-common/hwasan/stack-tagging-basic-0.c: New test.\n\t* c-c++-common/hwasan/stack-tagging-basic-1.c: New test.\n\t* c-c++-common/hwasan/stack-tagging-disable.c: New test.\n\t* c-c++-common/hwasan/unprotected-allocas-0.c: New test.\n\t* c-c++-common/hwasan/unprotected-allocas-1.c: New test.\n\t* c-c++-common/hwasan/use-after-free.c: New test.\n\t* c-c++-common/hwasan/vararray-outside-caught.c: New test.\n\t* c-c++-common/hwasan/vararray-stack-restore-correct.c: New test.\n\t* c-c++-common/hwasan/very-large-objects.c: New test.\n\t* g++.dg/hwasan/hwasan.exp: New test.\n\t* g++.dg/hwasan/rvo-handled.C: New test.\n\t* gcc.dg/hwasan/hwasan.exp: New test.\n\t* gcc.dg/hwasan/nested-functions-0.c: New test.\n\t* gcc.dg/hwasan/nested-functions-1.c: New test.\n\t* gcc.dg/hwasan/nested-functions-2.c: New test.\n\t* lib/hwasan-dg.exp: New file.", "tree": {"sha": "ebbd855db061d8df99250353a99db288e881a50a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbd855db061d8df99250353a99db288e881a50a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a47850552a0a25db7793a4eaf4859d43368a8b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47850552a0a25db7793a4eaf4859d43368a8b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47850552a0a25db7793a4eaf4859d43368a8b65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47850552a0a25db7793a4eaf4859d43368a8b65/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93a732514865f3607cc01f5c5b078f63580ef4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a732514865f3607cc01f5c5b078f63580ef4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a732514865f3607cc01f5c5b078f63580ef4b1"}], "stats": {"total": 1937, "additions": 1924, "deletions": 13}, "files": [{"sha": "d38b1f3f62d97dc3f5c3882137c370700fd4f9a0", "filename": "gcc/testsuite/c-c++-common/hwasan/aligned-alloc.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Faligned-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Faligned-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Faligned-alloc.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* This program fails at runtime in the libhwasan library.\n+   The allocator can't handle the requested invalid alignment.  */\n+\n+int\n+main ()\n+{\n+  void *p = __builtin_aligned_alloc (17, 100);\n+  if (((unsigned long long)p & 0x10) == 0)\n+    return 0;\n+  return 1;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: invalid alignment requested in aligned_alloc: 17\" } */"}, {"sha": "5e4c168f77efac5c9335768fb5b76fb3752783e9", "filename": "gcc/testsuite/c-c++-common/hwasan/alloca-array-accessible.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-array-accessible.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-array-accessible.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-array-accessible.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+#define alloca __builtin_alloca\n+\n+int __attribute__ ((noinline))\n+using_alloca (int num)\n+{\n+  int retval = 0;\n+  int *big_array = (int*)alloca (num * sizeof (int));\n+  for (int i = 0; i < num; ++i) {\n+      retval += big_array[i];\n+  }\n+  return retval;\n+}\n+\n+int __attribute__ ((noinline))\n+using_vararray (int num)\n+{\n+  int retval = 0;\n+  int big_array[num];\n+  for (int i = 0; i < num; ++i) {\n+      retval += big_array[i];\n+  }\n+  return retval;\n+}\n+\n+int main()\n+{\n+  using_alloca (16);\n+  using_vararray (12);\n+  return 0;\n+}"}, {"sha": "3ebeaa0b9e258982e773e2e58742f24b59ad80cd", "filename": "gcc/testsuite/c-c++-common/hwasan/alloca-base-init.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-base-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-base-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-base-init.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-additional-options \"--param hwasan-random-frame-tag=1\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */\n+#include <alloca.h>\n+\n+/* This testcase checks that `alloca` calls ensure the `__hwasan_generate_tag`\n+   function is called to initialize the base tag.  `alloca` calls are treated\n+   differently to standard variables.  The prologue/epilogue sequence is\n+   generated mainly based on normal stack-allocated objects.\n+\n+   We want to ensure that though the `alloca` call is not poisoned/unpoisoned\n+   by the prologue and epilogue, the use of them in a given function still\n+   triggers the prologue sequence to emit a call to __hwasan_generate_tag (and\n+   hence that any call to __hwasan_generate_tag is emitted in the unconditional\n+   part of the function code).  */\n+\n+int choice = 0;\n+int record = 1;\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+__attribute__ ((noinline))\n+unsigned char\n+__hwasan_generate_tag ()\n+{\n+  record = 0;\n+  return 3;\n+}\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+__attribute__ ((noinline))\n+int\n+generate_tag_was_missed (void)\n+{\n+  return record;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+foo (char *a)\n+{\n+  int i, j = 0;\n+  asm volatile (\"\" : \"+r\" (a) : : \"memory\");\n+  for (i = 0; i < 12; i++)\n+    j += a[i];\n+  return j;\n+}\n+\n+int\n+main ()\n+{\n+  if (choice)\n+  {\n+        char *x = (char *)alloca(100);\n+        foo(x);\n+  }\n+  else\n+  {\n+        char *y = (char *)alloca(20);\n+        foo(y);\n+  }\n+  return generate_tag_was_missed ();\n+}"}, {"sha": "e83734f4b79c2d35a49039797cba6b2506febbe5", "filename": "gcc/testsuite/c-c++-common/hwasan/alloca-gets-different-tag.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-gets-different-tag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-gets-different-tag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-gets-different-tag.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+/* Alloca is given a different tag to other variables.\n+   vararray should behave in the same way.  */\n+\n+#define alloca __builtin_alloca\n+#define assert(x) if (!(x)) __builtin_abort ()\n+\n+struct two_values {\n+    int left;\n+    int right;\n+};\n+\n+/* Require default hwasan tag ABI.\n+   Know we're using AArch64 since that's the only architecture we run hwasan\n+   tests on.  */\n+char tag_of (void * x) { return ((unsigned long long)x) >> 56; }\n+\n+int __attribute__ ((noinline))\n+alloca_different_tag (int num)\n+{\n+  struct two_values tmp_object = {\n+      .left = 100,\n+      .right = num,\n+  };\n+  int *big_array = (int *)alloca (num * sizeof (int));\n+  int other_array[100];\n+  \n+  char first_tag = tag_of (&tmp_object);\n+  char second_tag = tag_of (big_array);\n+  char other_tag = tag_of (other_array);\n+  assert (first_tag != second_tag);\n+  assert (second_tag != other_tag);\n+  assert (first_tag != other_tag);\n+  return 0;\n+}\n+\n+int __attribute__ ((noinline))\n+vararray_different_tag (int num)\n+{\n+  struct two_values tmp_object = {\n+      .left = 100,\n+      .right = num,\n+  };\n+  int big_array[num];\n+  int other_array[100];\n+  \n+  char first_tag = tag_of (&tmp_object);\n+  char second_tag = tag_of (big_array);\n+  char other_tag = tag_of (other_array);\n+  assert (first_tag != second_tag);\n+  assert (second_tag != other_tag);\n+  assert (first_tag != other_tag);\n+  return 0;\n+}\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  alloca_different_tag (10);\n+  vararray_different_tag (8);\n+  return 0;\n+}\n+"}, {"sha": "60d7a9a874f90e2c5c461a33f144dcb431dea838", "filename": "gcc/testsuite/c-c++-common/hwasan/alloca-outside-caught.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-outside-caught.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-outside-caught.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Falloca-outside-caught.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#define alloca __builtin_alloca\n+\n+int __attribute__ ((noinline))\n+check_alloca (int num)\n+{\n+  volatile int *allocd_array = (int*)alloca (num * sizeof(int));\n+  int other_array[10];\n+  return allocd_array[12];\n+}\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  check_alloca (3);\n+  return 1;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "435dad3cf159f565e56406467c41d97506f45d8f", "filename": "gcc/testsuite/c-c++-common/hwasan/arguments-1.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fsanitize=kernel-hwaddress\" } */\n+/* { dg-error \".*'-fsanitize=hwaddress' is incompatible with '-fsanitize=kernel-hwaddress'.*\" \"\" { target *-*-* } 0 } */"}, {"sha": "fafde99a05a31e1564c452a988654e2020c4d174", "filename": "gcc/testsuite/c-c++-common/hwasan/arguments-2.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-2.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fsanitize=kernel-address\" } */\n+/* { dg-error \".*'-fsanitize=hwaddress' is incompatible with '-fsanitize=kernel-address'.*\" \"\" { target *-*-* } 0 } */"}, {"sha": "6e907b46b3bb98066746f4619ff8b47e145c4911", "filename": "gcc/testsuite/c-c++-common/hwasan/arguments-3.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments-3.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fsanitize=thread\" } */\n+/* { dg-error \".*'-fsanitize=thread' is incompatible with '-fsanitize=hwaddress'.*\" \"\" { target *-*-* } 0 } */"}, {"sha": "7c113149179d7e86dcaabe8c85a308e48989b6e5", "filename": "gcc/testsuite/c-c++-common/hwasan/arguments.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Farguments.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fsanitize=address\" } */\n+/* { dg-error \".*'-fsanitize=hwaddress' is incompatible with '-fsanitize=address'.*\" \"\" { target *-*-* } 0 } */"}, {"sha": "dd3b3dbf22505f12063f088821fecd4be44817d0", "filename": "gcc/testsuite/c-c++-common/hwasan/asan-pr63316.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr63316.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr63316.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr63316.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,24 @@\n+/* PR sanitizer/63316 */\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O2\" } } */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern void *malloc (__SIZE_TYPE__);\n+extern void free (void *);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+  int *p = (int *) malloc (sizeof (int));\n+  *p = 3;\n+  asm volatile (\"\" : : \"r\" (p) : \"memory\");\n+  free (p);\n+  return 0;\n+}\n+"}, {"sha": "ba2ed496e6ee81b13270ce05831ff01eca98edde", "filename": "gcc/testsuite/c-c++-common/hwasan/asan-pr70541.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr70541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr70541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr70541.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-options \"-fno-builtin-malloc -fno-builtin-free\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#include <stdio.h>\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern void *malloc (__SIZE_TYPE__);\n+extern void free (void *);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+struct Simple {\n+  int value;\n+};\n+\n+int f(struct Simple simple) {\n+  return simple.value;\n+}\n+\n+int main() {\n+  struct Simple *psimple = (struct Simple *) malloc(sizeof(struct Simple));\n+  psimple->value = 42;\n+  free(psimple);\n+  printf(\"%d\\n\", f(*psimple));\n+  return 0;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"freed by thread T0 here:.*\" } */\n+/* { dg-output \"previously allocated here:\" } */"}, {"sha": "3f53ad17693cc4fbb246bc0d3f6a1d02fc3222d0", "filename": "gcc/testsuite/c-c++-common/hwasan/asan-pr78106.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr78106.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr78106.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr78106.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,31 @@\n+/* PR sanitizer/78106 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=hwaddress -fdump-tree-sanopt-details -ffat-lto-objects\" } */\n+\n+int *variable;\n+\n+void __attribute__((used)) release()\n+{\n+  __builtin_free (variable);\n+}\n+\n+int main2(int argc)\n+{\n+  *variable = 2;\n+\n+  if (argc <= 5)\n+    asm volatile (\"call release\");\n+\n+  *variable = 2;\n+  __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+  variable = (int *)__builtin_malloc (sizeof(int));\n+  return main2(argc);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Optimizing out(\\n|\\r\\n|\\r)  HWASAN_CHECK \\\\(7, variable.*\" \"sanopt\" } } */"}, {"sha": "7d54f54701bac6b8337d62ec9f6fbbb69f921a37", "filename": "gcc/testsuite/c-c++-common/hwasan/asan-pr79944.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr79944.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr79944.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-pr79944.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,19 @@\n+/* PR sanitizer/79944 */\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+struct S { int i; char p[1024]; };\n+\n+int\n+main ()\n+{\n+  struct S *p = (struct S *) __builtin_malloc (__builtin_offsetof (struct S, p) + 64);\n+  p->i = 5;\n+  asm volatile (\"\" : \"+r\" (p) : : \"memory\");\n+  __atomic_fetch_add ((int *) p, 5, __ATOMIC_RELAXED);\n+  asm volatile (\"\" : \"+r\" (p) : : \"memory\");\n+  if (p->i != 10)\n+    __builtin_abort ();\n+  __builtin_free (p);\n+  return 0;\n+}"}, {"sha": "5426b8ab430df1813be4e1cbf0930cfa4d817c48", "filename": "gcc/testsuite/c-c++-common/hwasan/asan-rlimit-mmap-test-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-rlimit-mmap-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-rlimit-mmap-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fasan-rlimit-mmap-test-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,24 @@\n+/* Check that we properly report mmap failure. */\n+\n+/* { dg-do run { target setrlimit } } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+/* { dg-require-effective-target hw } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+\n+static volatile void *x;\n+\n+int main(int argc, char **argv) {\n+  struct rlimit mmap_resource_limit = { 0, 0 };\n+  if (setrlimit(RLIMIT_AS, &mmap_resource_limit)) return 1;\n+  x = malloc(10000000);\n+  return 0;\n+}\n+\n+/* { dg-output \"ERROR: Failed to mmap\" } */\n+"}, {"sha": "0c3479eacc477fa4d4aaa15846bb73a40a5fbb48", "filename": "gcc/testsuite/c-c++-common/hwasan/bitfield-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+struct bitmapped_struct {\n+    unsigned one : 1;\n+    unsigned two : 1;\n+    unsigned three : 1;\n+    unsigned four : 1;\n+    unsigned five : 1;\n+    unsigned six : 1;\n+    unsigned seven : 1;\n+    unsigned eight : 1;\n+};\n+\n+/* Check that hwasan allows valid bitfield accesses. */\n+int __attribute__ ((noinline))\n+handle_unaligned_access (struct bitmapped_struct *foo)\n+{\n+  if (foo->three)\n+    return foo->four;\n+\n+  foo->five = 1;\n+  return 1;\n+}\n+\n+int main()\n+{\n+  struct bitmapped_struct myvar = {0};\n+  handle_unaligned_access (&myvar);\n+  return 0;\n+}"}, {"sha": "0b3f3aaaf2d899eb3f946e8f230601e16d491d4c", "filename": "gcc/testsuite/c-c++-common/hwasan/bitfield-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbitfield-2.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+/* Ensure that hwasan instruments bitfield accesses.  */\n+struct A\n+{\n+  /* Ensure the offset from the start of this struct to the bitfield we access\n+     is large enough to be in a different tag.  */\n+  char base[16];\n+  int : 4;\n+  long x : 7;\n+};\n+\n+int __attribute__ ((noinline, noclone))\n+f (void *p) {\n+  return ((struct A *)p)->x;\n+}\n+\n+int\n+main ()\n+{\n+  char a = 0;\n+  return f (&a);\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 2 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "a7a6d91693ae48c20f33ab28f28d27b01af4722c", "filename": "gcc/testsuite/c-c++-common/hwasan/builtin-special-handling.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbuiltin-special-handling.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbuiltin-special-handling.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fbuiltin-special-handling.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-asan\" } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-O0\" } { \"\" } } */\n+/* Only skip the -flto tests without the -flto-partition=none.\n+   With -flto-partition=none we still get a asan1 dump file, without that\n+   parameter we only get the lto dump files (which means scan-tree-dump-times\n+   doesn't work.  */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"-flto-partition=none\" } } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+/* Functions to observe that HWASAN instruments memory builtins in the expected\n+   manner.  */\n+void * __attribute__((noinline))\n+memset_builtin (void *dest, int value, size_t len)\n+{\n+  return __builtin_memset (dest, value, len);\n+}\n+\n+/* HWASAN avoids strlen because it doesn't know the size of the memory access\n+   until *after* the function call.  */\n+size_t __attribute__ ((noinline))\n+strlen_builtin (char *element)\n+{\n+  return __builtin_strlen (element);\n+}\n+\n+/* First test ensures that the HWASAN_CHECK was emitted before the\n+   memset.  Second test ensures there was only HWASAN_CHECK (which demonstrates\n+   that strlen was not instrumented).  */\n+/* { dg-final { scan-tree-dump-times \"HWASAN_CHECK.*memset\" 1 \"asan1\" } } */\n+/* { dg-final { scan-tree-dump-times \"HWASAN_CHECK\" 1 \"asan1\" } } */"}, {"sha": "90f52cac884dd67b1dab18d4037fe64dfc19eefc", "filename": "gcc/testsuite/c-c++-common/hwasan/check-interface.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fcheck-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fcheck-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fcheck-interface.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/*\n+   Test taken from LLVM\n+    compiler-rt/test/hwasan/TestCases/check-interface.cpp\n+ */\n+// Utilizes all flavors of __hwasan_load/store interface functions to verify\n+// that the instrumentation and the interface provided by HWASan do match.\n+// In case of a discrepancy, this test fails to link.\n+\n+typedef __UINT8_TYPE__ uint8_t;\n+typedef __UINT16_TYPE__ uint16_t;\n+typedef __UINT32_TYPE__ uint32_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+#define F(T) void f_##T(T *a, T *b) { *a = *b; }\n+\n+F(uint8_t)\n+F(uint16_t)\n+F(uint32_t)\n+F(uint64_t)\n+\n+typedef unsigned V32 __attribute__((__vector_size__(32)));\n+F(V32)\n+\n+int main() {}"}, {"sha": "90ca856874dfbdd8266981a26503f1e5b88cf039", "filename": "gcc/testsuite/c-c++-common/hwasan/halt_on_error-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhalt_on_error-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhalt_on_error-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhalt_on_error-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,24 @@\n+/* Test recovery mode.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-options \"-fsanitize-recover=hwaddress\" } */\n+/* { dg-set-target-env-var HWASAN_OPTIONS \"halt_on_error=false\" } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+volatile int sixteen = 16;\n+\n+int main() {\n+  char x[16];\n+  __builtin_memset(x, 0, sixteen + 1);\n+  asm volatile (\"\" : : : \"memory\");\n+  volatile int res = x[sixteen];\n+  x[sixteen] = res + 3;\n+  res = x[sixteen];\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 17 at 0x\\[0-9a-f\\]+.*\" } */\n+/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+.*\" } */\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+.*\" } */\n+/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+.*\" } */\n+"}, {"sha": "685b780389814e203b6b12db34fb77261147398a", "filename": "gcc/testsuite/c-c++-common/hwasan/handles-poly_int-marked-vars.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhandles-poly_int-marked-vars.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhandles-poly_int-marked-vars.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhandles-poly_int-marked-vars.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target aarch64-*-* } } */\n+/* { dg-additional-options \"-march=armv8.6-a+sve -fsanitize-address-use-after-scope\" } */\n+\n+#include <arm_sve.h>\n+\n+__attribute__((noinline, noclone)) int\n+foo (char *a)\n+{\n+  int i, j = 0;\n+  asm volatile (\"\" : \"+r\" (a) : : \"memory\");\n+  for (i = 0; i < 12; i++)\n+    j += a[i];\n+  return j;\n+}\n+\n+int\n+main ()\n+{\n+  int i, j = 0;\n+  for (i = 0; i < 4; i++)\n+    {\n+      char a[12];\n+      __SVInt8_t freq;\n+      /* Just do something with that `freq` variable so that the compiler\n+\t doesn't optimise its use away.  */\n+      if (__builtin_bcmp (&freq, a, 10))\n+\tj += 1;\n+      __builtin_memset (a, 0, sizeof (a));\n+      j += foo (a);\n+    }\n+  return j;\n+}\n+\n+/* Just ensure this compiles without giving an ICE.\n+   This is the equivalent of PR 97696 but for HWASAN.  HWASAN can handle\n+   poly_int sized variables, and this testcase ensures that we don't ICE when\n+   given them.  */"}, {"sha": "137466800de6be972f68fccc6a5aee4481cab892", "filename": "gcc/testsuite/c-c++-common/hwasan/heap-overflow.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fheap-overflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fheap-overflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fheap-overflow.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-options \"-fno-builtin-malloc -fno-builtin-free -fno-builtin-memset\" } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+void *memset (void *, int, __SIZE_TYPE__);\n+void *malloc (__SIZE_TYPE__);\n+void free (void *);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+volatile int ten = 10;\n+int main(int argc, char **argv) {\n+  char *x = (char*)malloc(10);\n+  memset(x, 0, 10);\n+  int res = x[ten];  /* BOOOM */\n+  free(x);\n+  return res;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"located 0 bytes to the right of 10-byte region.*\" } */\n+/* { dg-output \"allocated here:.*\" } */\n+/* { dg-output \"#1 0x\\[0-9a-f\\]+ +in _*main \\[^\\n\\r]*heap-overflow.c:18\" } */"}, {"sha": "2d6bab4c578ed73529b3f0023528914e7ec983a1", "filename": "gcc/testsuite/c-c++-common/hwasan/hwasan-poison-optimisation.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-poison-optimisation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-poison-optimisation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-poison-optimisation.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-O0\" } { \"\" } } */\n+/* { dg-additional-options \"-fdump-tree-asan1 -save-temps\" } */\n+\n+/* Here to check that the ASAN_POISON stuff works just fine.\n+   This mechanism isn't very often used, but I should at least go through the\n+   code-path once in my testfile.  */\n+int\n+main ()\n+{\n+  int *ptr = 0;\n+\n+  {\n+    int a;\n+    ptr = &a;\n+    *ptr = 12345;\n+  }\n+\n+  return *ptr;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ASAN_POISON\" 1 \"asan1\" }  } */\n+/* { dg-final { scan-assembler-times \"bl\\\\s*__hwasan_tag_mismatch4\" 1 } } */\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "828909d3b3bc6ad98fdb243cb6a06e78bcff4280", "filename": "gcc/testsuite/c-c++-common/hwasan/hwasan-thread-access-parent.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-access-parent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-access-parent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-access-parent.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"-lpthread\" } */\n+\n+#include <pthread.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern int printf (char const *, ...);\n+#ifdef __cplusplus\n+}\n+#endif\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+/* Test that tags are checked across different threads.\n+   i.e. if this thread tries to access a different threads memory with the\n+   incorrect tag, then this thread fails.  */\n+void *\n+failing_thread_function (void *argument)\n+{\n+    void * other = (void *)((uint64_t)argument & 0xffffffffffffffULL);\n+    int *num = (int*)argument;\n+    printf (\"(should succeed): first number = %d\\n\", num[0]);\n+    printf (\"(now should fail):\\n\");\n+\n+    int *othernum = (int*)other;\n+    printf (\" second number = %d\\n\", othernum[0]);\n+    return (void *)1;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+    int argument[100] = {0};\n+    argument[1] = 10;\n+    pthread_t thread_index;\n+    pthread_create (&thread_index, NULL, failing_thread_function, (void*)argument);\n+\n+    void *retval;\n+    pthread_join (thread_index, &retval);\n+\n+    return (uintptr_t)retval;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: 00/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T1.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "6a07521e1155de5bdbc95fad00d1305b2f33548e", "filename": "gcc/testsuite/c-c++-common/hwasan/hwasan-thread-basic-failure.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-basic-failure.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-basic-failure.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-basic-failure.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"-lpthread\" } */\n+\n+/* Ensure the failure mode for hwasan under pthreads looks sane.\n+   (Looks sane means that the same error message is printed out rather than an\n+   opaque message due to mishandling).  */\n+\n+#include <pthread.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern int printf (char const *, ...);\n+#ifdef __cplusplus\n+}\n+#endif\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+void *\n+failing_from_stack (void * argument)\n+{\n+    int internal_array[16] = {0};\n+    printf (\"(now should fail):\");\n+    printf (\" problem number is %d\\n\", internal_array[17]);\n+    return (void *)1;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+    int argument[100] = {0};\n+    argument[1] = 10;\n+    pthread_t thread_index;\n+    pthread_create (&thread_index, NULL, failing_from_stack, (void*)argument);\n+\n+    void *retval;\n+    pthread_join (thread_index, &retval);\n+\n+    return (uintptr_t)retval;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T1.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T1.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "09c72a56f0f50a8c301d89217aa8c7df70087e6c", "filename": "gcc/testsuite/c-c++-common/hwasan/hwasan-thread-clears-stack.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-clears-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-clears-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-clears-stack.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"-lpthread\" } */\n+\n+/* This checks the interceptor ABI pthread hooks.\n+   The stack of the thread that is finishing must be cleared of shadow tags\n+   when that thread exits.  */\n+\n+#include <pthread.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern int printf (char const *, ...);\n+#ifdef __cplusplus\n+}\n+#endif\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+__attribute__ ((noinline))\n+void * Ident (void * argument)\n+{\n+\treturn argument;\n+}\n+\n+void *\n+pthread_stack_is_cleared (void *argument)\n+{\n+   (void)argument;\n+   int internal_array[16] = {0};\n+   return Ident((void*)internal_array);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+    int argument[100] = {0};\n+    argument[1] = 10;\n+    pthread_t thread_index;\n+    pthread_create (&thread_index, NULL, pthread_stack_is_cleared, (void*)argument);\n+\n+    void *retval;\n+    pthread_join (thread_index, &retval);\n+\n+    printf (\"(should fail): \");\n+    printf (\"value left in stack is: %d\\n\", ((int *)retval)[0]);\n+\n+    return (uintptr_t)retval;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"HWAddressSanitizer can not describe address in more detail\\..*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "b0281f7b389f141f17c08fdb76db8848d0e7c429", "filename": "gcc/testsuite/c-c++-common/hwasan/hwasan-thread-success.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-success.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-success.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fhwasan-thread-success.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-additional-options \"-lpthread\" } */\n+\n+/* Just ensure that a basic threaded program works while running with hwasan.\n+   */\n+\n+#include <pthread.h>\n+\n+extern int printf (const char *, ...);\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+void *\n+successful_thread_function (void * argument)\n+{\n+    int *deref = (int *)argument;\n+    if (deref[0] == 100)\n+      deref[1] = 10;\n+    return (void *)0;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+    int argument[100] = {0};\n+    argument[1] = 10;\n+    pthread_t thread_index;\n+    pthread_create (&thread_index, NULL, successful_thread_function, (void*)argument);\n+\n+    void *retval;\n+    pthread_join (thread_index, &retval);\n+\n+    return (uintptr_t)retval;\n+}"}, {"sha": "abfe735e6e1fab712ae8f0bd1517a14a4d5eb178", "filename": "gcc/testsuite/c-c++-common/hwasan/kernel-defaults.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fkernel-defaults.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fkernel-defaults.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fkernel-defaults.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-sanitize=hwaddress -fsanitize=kernel-hwaddress\" } */\n+\n+\n+/* Defaults to check for kernel-hwaddress.\n+   1) No stack tagging => no calls to __hwasan_tag_memory.\n+   2) No block scope tagging (same again).\n+   3) Use sanitize-recover by default (everything ends in noabort). */\n+int __attribute__ ((noinline))\n+accessing_pointers (int *left, int *right)\n+{\n+  int x = right[2];\n+  left[3] = right[1];\n+  return right[1] + left[2];\n+}\n+\n+int __attribute__ ((noinline))\n+using_stack (int num)\n+{\n+  int big_array[10];\n+  int other_array[20];\n+  accessing_pointers(other_array, big_array);\n+  return big_array[num];\n+}\n+\n+#ifndef ARG\n+#define ARG 0\n+#endif\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  using_stack (ARG);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__hwasan_tag_memory\" } } */\n+/* { dg-final { scan-assembler-not \"__hwasan_(load|store)\\\\d(?!_noabort)\" } } */"}, {"sha": "5b0071af2beccc36246ddf9406c087dde4b52f80", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-0.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+/* Handling large aligned variables.\n+   Large aligned variables take a different code-path through expand_stack_vars\n+   in cfgexpand.c.  This testcase is just to exercise that code-path.\n+\n+   The alternate code-path produces a second base-pointer through some\n+   instructions emitted in the prologue.\n+   \n+   Test cases are:\n+   0) Valid access works without complaint.\n+   1) Invalid access is caught.  */\n+int __attribute__ ((noinline))\n+handle_large_alignment (int num)\n+{\n+  int other_array[10];\n+  int big_array[100] __attribute__ ((aligned (32)));\n+  return big_array[num] + other_array[num];\n+}\n+\n+#ifndef ARG\n+#define ARG 1\n+#endif\n+\n+int global;\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  global += handle_large_alignment (ARG);\n+  return 0;\n+}"}, {"sha": "1aa130323960225c2201067d29f83231f1cec5d7", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#define ARG 12\n+#include \"large-aligned-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "11f422fc4fa68f5c136821fdfa0a8e949fe266a3", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-0.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* Don't really need this option since there are no vararray/alloca objects in\n+   the interesting function, however it never hurts to make doubly sure and\n+   make it explicit that we're checking the alternate approach to deallocation.\n+   */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+/* Handling large aligned variables.\n+   Large aligned variables take a different code-path through expand_stack_vars\n+   in cfgexpand.c.  This testcase is just to exercise that code-path.\n+\n+   The alternate code-path produces a second base-pointer through some\n+   instructions emitted in the prologue.\n+\n+   This eventually follows a different code path for untagging when not tagging\n+   allocas. The untagging needs to work at the top of the frame, and this\n+   should account for this different base when large aligned variables are\n+   around.  */\n+__attribute__ ((noinline))\n+void * Ident (void * argument)\n+{\n+  return argument;\n+}\n+\n+#ifndef ALIGNMENT\n+#define ALIGNMENT\n+#endif\n+void __attribute__ ((noinline))\n+large_alignment_untagging (int num, int *retval, int **big, int **other)\n+{\n+  int other_array[100] ALIGNMENT;\n+  int big_array[100] __attribute__ ((aligned (32)));\n+  *retval = big_array[num] + other_array[num];\n+  *big = (int*)Ident(big_array);\n+  *other = (int*)Ident(other_array);\n+}\n+\n+#ifndef ARG\n+#define ARG 0\n+#endif\n+\n+int global;\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  int retval;\n+  int *big, *other;\n+  large_alignment_untagging (0, &retval, &big, &other);\n+  /* Want to test that both ends of both variables are untagged.  */\n+  switch (ARG) {\n+    case 0:\n+      global += big[0];\n+      break;\n+    case 1:\n+      global += big[99];\n+      break;\n+    case 2:\n+      global += other[0];\n+      break;\n+    case 3:\n+      global += other[99];\n+      break;\n+  }\n+  return 0;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "b2fc522f3c99d2c31667c7a077087b3d30fff971", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 1\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "ebc46482fea2e810462badc8f0b7288a3ec64d63", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-2.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 2\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "d3a226a5db0c74865fe37299a30bd5f29d43650b", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-3.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 3\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "cdd122b5f6130d6f7219fd6d4a7f7c37f71d57c7", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-4.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 0\n+#define ALIGNMENT __attribute__ ((aligned (32)))\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "7c4cb5cb218067beb7a37361c36b10f1674b2234", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-5.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 1\n+#define ALIGNMENT __attribute__ ((aligned (32)))\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "f429ed21106d2d814505e49b4e999927fe2793b4", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-6.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 2\n+#define ALIGNMENT __attribute__ ((aligned (32)))\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "56f16eb169dafb108fba6d77e38e80d36bfaa9dc", "filename": "gcc/testsuite/c-c++-common/hwasan/large-aligned-untagging-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Flarge-aligned-untagging-7.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0\" } */\n+\n+#define ARG 3\n+#define ALIGNMENT __attribute__ ((aligned (32)))\n+#include \"large-aligned-untagging-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* NOTE: This assumes the current tagging mechanism (one at a time from the\n+   base and large aligned variables being handled first).  */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "5f654f557821f2dbe060e9976fbca7e5770f274c", "filename": "gcc/testsuite/c-c++-common/hwasan/macro-definition.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fmacro-definition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fmacro-definition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fmacro-definition.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+extern void testfunc(int);\n+int foo()\n+{\n+#ifndef __SANITIZE_HWADDRESS__\n+  testfunc(1);\n+#endif\n+  return 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"testfunc\" } } */"}, {"sha": "c0a254dc83a4e662212e337f217c7480fce7eb00", "filename": "gcc/testsuite/c-c++-common/hwasan/no-sanitize-attribute.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fno-sanitize-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fno-sanitize-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fno-sanitize-attribute.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+__attribute__((no_sanitize(\"hwaddress\"))) int\n+f (int *p, int *q)\n+{\n+  *p = 42;\n+  return *q;\n+}\n+\n+/* Only have one instance of __hwasan, it is __hwasan_init (the module\n+ * constructor) there is no instrumentation in the function.  */\n+/* { dg-final { scan-assembler-times \"__hwasan\" 1 } } */"}, {"sha": "f1e6dc8a8d32f5d2253e6a18fa59315fb8512e25", "filename": "gcc/testsuite/c-c++-common/hwasan/param-instrument-mem-intrinsics.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-mem-intrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-mem-intrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-mem-intrinsics.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-O0\" } { \"\" } } */\n+/* { dg-additional-options \"--param hwasan-instrument-mem-intrinsics=0\" } */\n+\n+#include \"builtin-special-handling.c\"\n+\n+/* With this flag there should be no checking of builtins.\n+   The above file only has builtins, and hence there should be no checking\n+   after compilation.  */\n+/* { dg-final { scan-assembler-not \"__hwasan_(load|store)\" } } */"}, {"sha": "1d565a2f5d959507fc7ba2418637489f7e14e6f0", "filename": "gcc/testsuite/c-c++-common/hwasan/param-instrument-reads-and-writes.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads-and-writes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads-and-writes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads-and-writes.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--param hwasan-instrument-writes=0\" } */\n+\n+#include \"param-instrument-reads.c\"\n+\n+/* { dg-final { scan-assembler \"__hwasan_load\" } } */\n+/* { dg-final { scan-assembler-not \"__hwasan_store\" } } */"}, {"sha": "9b8049a3cb94b166a2b27bbc97f8c26ac7efc6ac", "filename": "gcc/testsuite/c-c++-common/hwasan/param-instrument-reads.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-reads.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--param hwasan-instrument-reads=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+/* Particular code doesn't really matter, the requirement is that it has both\n+   loads and stores in it.  */\n+__attribute__ ((noinline))\n+int reader (int *array, size_t num)\n+{\n+  return array[num];\n+}\n+\n+int __attribute__ ((noinline))\n+writer (int *array, size_t num, int value)\n+{\n+  array[num] = value;\n+  return num + value;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__hwasan_load\" } } */\n+/* { dg-final { scan-assembler \"__hwasan_store\" } } */"}, {"sha": "0f04fad6496253f31d09e49b49b77decbefe0e60", "filename": "gcc/testsuite/c-c++-common/hwasan/param-instrument-writes.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-writes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-writes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fparam-instrument-writes.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--param hwasan-instrument-reads=0 --param hwasan-instrument-writes=0\" } */\n+\n+#include \"param-instrument-reads.c\"\n+\n+/* { dg-final { scan-assembler-not \"__hwasan_load\" } } */\n+/* { dg-final { scan-assembler-not \"__hwasan_store\" } } */"}, {"sha": "8e55b298470a49bf5563f26013569ee03487933c", "filename": "gcc/testsuite/c-c++-common/hwasan/random-frame-tag.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Frandom-frame-tag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Frandom-frame-tag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Frandom-frame-tag.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--param hwasan-random-frame-tag=1\" } */\n+\n+#include \"stack-tagging-basic-0.c\"\n+\n+/* Random frame tag => call to __hwasan_generate_tag.  */\n+/* { dg-final { scan-assembler \"__hwasan_generate_tag\" } } */"}, {"sha": "a42921bb44cf835696e00731849b33b4ef069b72", "filename": "gcc/testsuite/c-c++-common/hwasan/sanity-check-pure-c.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsanity-check-pure-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsanity-check-pure-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsanity-check-pure-c.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-options \"-fno-builtin-malloc -fno-builtin-free\" } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+void *malloc (__SIZE_TYPE__);\n+void free (void *);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int main() {\n+  char *x = (char*)malloc(10);\n+  free(x);\n+  return x[5];\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"located 5 bytes inside of 10-byte region.*\" } */\n+/* { dg-output \"freed by thread T0 here:.*\" } */\n+/* { dg-output \"previously allocated here:\" } */"}, {"sha": "019c4ea3f7467be61da52272b37a3fd5d1924df7", "filename": "gcc/testsuite/c-c++-common/hwasan/setjmp-longjmp-0.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+#include <setjmp.h>\n+#include <stdio.h>\n+\n+/*\n+   Testing longjmp/setjmp should test.\n+\n+   0) Nothing special happens with the jmp_buf.\n+   1) Accesses to scopes jmp'd over are caught.\n+ */\n+int __attribute__ ((noinline))\n+uses_longjmp (int **other_array, int num, jmp_buf env)\n+{\n+  int internal_array[100] = {0};\n+  *other_array = &internal_array[0];\n+  if (num % 2)\n+    longjmp (env, num);\n+  else\n+    return num % 8;\n+}\n+\n+int __attribute__ ((noinline))\n+uses_setjmp (int num)\n+{ \n+  int big_array[100];\n+  int *other_array = NULL;\n+  sigjmp_buf cur_env;\n+  int temp = 0;\n+  if ((temp = sigsetjmp (cur_env, 1)) != 0)\n+    { \n+      if (other_array != NULL)\n+        printf (\"Value pointed to in other_array[0]: %d\\n\",\n+                other_array[0]);\n+  \n+      printf (\"Longjmp returned %d.\\n\", temp);\n+      return 10;\n+    }\n+  else\n+    {\n+      return uses_longjmp (&other_array, num, cur_env);\n+    } \n+} \n+\n+#ifndef ARG\n+#define ARG 0\n+#endif\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  uses_setjmp (ARG);\n+  return 0;\n+}"}, {"sha": "6a4fceeb37acb156b0b92556453f6fc1bf49b876", "filename": "gcc/testsuite/c-c++-common/hwasan/setjmp-longjmp-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fsetjmp-longjmp-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+/*\n+   Testing longjmp/setjmp should test.\n+\n+   0) Nothing special happens with the jmp_buf.\n+   1) Accesses to scopes jmp'd over are caught.\n+ */\n+\n+#define ARG 1\n+#include \"setjmp-longjmp-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "114114165d97ef5b5c6c2fa83352cc7f071d3695", "filename": "gcc/testsuite/c-c++-common/hwasan/stack-tagging-basic-0.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+/* Basic tests for stack tagging.\n+\n+   0) Valid accesses work.\n+   1) Accesses outside of a variable crash.\n+*/\n+int __attribute__ ((noinline))\n+accessing_pointers (int *left, int *right)\n+{\n+  int x = right[2];\n+  left[3] = right[1];\n+  return right[1] + left[2];\n+}\n+\n+int __attribute__ ((noinline))\n+using_stack (int num)\n+{\n+  int big_array[10];\n+  int other_array[20];\n+  accessing_pointers(other_array, big_array);\n+  return big_array[num];\n+}\n+\n+#ifndef ARG\n+#define ARG 0\n+#endif\n+\n+int global;\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  global += using_stack (ARG);\n+  return 0;\n+}"}, {"sha": "90d5837254f8dddadfc2235fe5e7191c45e7887b", "filename": "gcc/testsuite/c-c++-common/hwasan/stack-tagging-basic-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-basic-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+/* Basic tests for stack tagging.\n+\n+   0) Accesses outside of a variable crash.\n+   1) Valid accesses work.\n+*/\n+\n+#define ARG 17\n+#include \"stack-tagging-basic-0.c\"\n+#undef ARG\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "9bcae1625002d09ddc40dbd8fe7214b466af7caa", "filename": "gcc/testsuite/c-c++-common/hwasan/stack-tagging-disable.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-disable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-disable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fstack-tagging-disable.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--param hwasan-instrument-stack=0\" } */\n+\n+\n+/* No stack tagging => no calls to __hwasan_tag_memory.  */\n+int __attribute__ ((noinline))\n+accessing_pointers (int *left, int *right)\n+{\n+  int x = right[2];\n+  left[3] = right[1];\n+  return right[1] + left[2];\n+}\n+\n+int __attribute__ ((noinline))\n+using_stack (int num)\n+{\n+  int big_array[10];\n+  int other_array[20];\n+  accessing_pointers(other_array, big_array);\n+  return big_array[num];\n+}\n+\n+#ifndef ARG\n+#define ARG 0\n+#endif\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  using_stack (ARG);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__hwasan_tag_memory\" } } */"}, {"sha": "88465155c6d0a72bfef1fdd31c59adaf4db549ce", "filename": "gcc/testsuite/c-c++-common/hwasan/unprotected-allocas-0.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0 -save-temps\" } */\n+/* Only run this test without optimisation.  When running with optimisation we\n+   use the unprotected-allocas-1.c file that also checks there are no memory\n+   tagging calls (since when optimised the only variable on the stack should be\n+   the vararray/alloca).  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O1\" \"-O2\" \"-O3\" } { \"\" } } */\n+\n+#define alloca __builtin_alloca\n+#define assert(x) if (!(x)) __builtin_abort ()\n+\n+char tag_of (void * x) { return ((unsigned long long)x) >> 56; }\n+\n+int __attribute__ ((noinline))\n+using_alloca (int num)\n+{\n+  int retval = 0;\n+  int *big_array = (int*)alloca (num * sizeof (int));\n+  char alloca_tag = tag_of (big_array);\n+  assert (alloca_tag == 0);\n+  for (int i = 0; i < num; ++i) {\n+      retval += big_array[i];\n+  }\n+  return retval;\n+}\n+\n+int __attribute__ ((noinline))\n+using_vararray (int num)\n+{\n+  int retval = 0;\n+  int big_array[num];\n+  char vararray_tag = tag_of (big_array);\n+  assert (vararray_tag == 0);\n+  for (int i = 0; i < num; ++i) {\n+      retval += big_array[i];\n+  }\n+  return retval;\n+}\n+\n+int main()\n+{\n+  using_alloca (16);\n+  using_vararray (12);\n+  return 0;\n+}"}, {"sha": "752edc1d3ea366af771936d7680902bad7c1878c", "filename": "gcc/testsuite/c-c++-common/hwasan/unprotected-allocas-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Funprotected-allocas-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-additional-options \"--param hwasan-instrument-allocas=0 -save-temps\" } */\n+/* Only test there's no tagging done when not at -O0.  Without optimisation\n+   the compiler creates a bunch of other variables on the stack other than the\n+   vararray/alloca object.\n+   We also avoid checking when using -flto, since with LTO the compiler can\n+   recognise the vararray is only used with one size and that size is known at\n+   compile time -- when the compiler recognises that it instead creates a\n+   static array, which gets tagged as is expected but not as the test expects.\n+   */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-flto\" } { \"\" } } */\n+\n+#include \"unprotected-allocas-0.c\"\n+\n+/* { dg-final { scan-assembler-not \"__hwasan_tag_memory\" } } */"}, {"sha": "41a356999aadd65e794437608d97523566558ab4", "filename": "gcc/testsuite/c-c++-common/hwasan/use-after-free.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fuse-after-free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fuse-after-free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fuse-after-free.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-options \"-fno-builtin-malloc -fno-builtin-free\" } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+void *malloc (__SIZE_TYPE__);\n+void free (void *);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int main() {\n+  char *x = (char*)malloc(10);\n+  free(x);\n+  return x[5];\n+}\n+\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/\\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\] \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"is located 5 bytes inside of 10-byte region.*\" } */\n+/* { dg-output \"freed by thread T0 here:.*\" } */\n+/* { dg-output \"#1\\[^\\n\\r]*main\\[^\\n\\r]*use-after-free.c:17.*\" } */\n+/* { dg-output \"previously allocated here:.*\" } */\n+/* { dg-output \"#1\\[^\\n\\r]*main\\[^\\n\\r]*use-after-free.c:16\" } */"}, {"sha": "35a344def424e41dc9e810fdf0e804294efa75df", "filename": "gcc/testsuite/c-c++-common/hwasan/vararray-outside-caught.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-outside-caught.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-outside-caught.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-outside-caught.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+int __attribute__ ((noinline))\n+check_vararray (int num)\n+{\n+  int var_array[num];\n+  int other_array[10];\n+  return var_array[12];\n+}\n+\n+int __attribute__ ((noinline))\n+main ()\n+{\n+  return check_vararray (3);\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"READ of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "f4e1f57bdd2e92c9adf1158e60096ab5a72f38e8", "filename": "gcc/testsuite/c-c++-common/hwasan/vararray-stack-restore-correct.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-stack-restore-correct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-stack-restore-correct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvararray-stack-restore-correct.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+#include <stdio.h>\n+\n+/* Testing that a function with outgoing arguments correctly decrements the\n+   stack pointer when a vararray goes out of scope.  */\n+\n+const char *\n+other (int argc, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l)\n+{\n+  const char ** other;\n+    {\n+      const char * test_array[argc];\n+      test_array[0] = \"test string\";\n+      test_array[argc - 1] = \"hello\";\n+      /* To prevent optimisation.  */\n+      printf(\"While the value stored in our test_array is: %s\\n\",\n+\t     test_array[argc - 1]);\n+      other = test_array;\n+    }\n+  /* With the below function call (the one with many arguments), some of the\n+     arguments have to be put on the stack, which means we have to reserve some\n+     space on the stack for these arguments and that the VLA is stored at a\n+     position that is not the stack pointer. */\n+  printf(\"Hello there!\\nOur numbers today are: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\\n\",\n+\t a, b, c, d, e, f, g, h, i, j, k, l);\n+  /* This should fail due to a bad read access.  */\n+  return other[0];\n+}\n+\n+int\n+main ()\n+{\n+  int a, b, c, d, e, f, g, h, i, j, k, l;\n+  const char * retval = other (1, a, b, c, d, e, f, g, h, i, j, k, l);\n+  /* Numbers don't matter here, just want to ensure the program is reading them\n+     so we know they won't be optimised out.  */\n+  if (retval)\n+    return 1;\n+  return 10;\n+}"}, {"sha": "55265353369540872e8fba4da99d9be92a7ad99b", "filename": "gcc/testsuite/c-c++-common/hwasan/very-large-objects.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvery-large-objects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvery-large-objects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fhwasan%2Fvery-large-objects.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile } */\n+\n+/* Ensure the sanitizer can handle very large offsets (i.e. that the hooks\n+   handle offsets too large for the relevant instructions).\n+   Just want to make sure this compiles without an ICE.  */\n+#ifndef ASIZE\n+# define ASIZE 0x10000000000UL\n+#endif\n+\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+#if __LONG_MAX__ < 8 * ASIZE\n+# undef ASIZE\n+# define ASIZE 4096\n+#endif\n+\n+extern void abort (void);\n+\n+int __attribute__((noinline))\n+foo (const char *s)\n+{\n+  if (!s)\n+    return 1;\n+  if (s[0] != 'a')\n+    abort ();\n+  s += ASIZE - 1;\n+  if (s[0] != 'b')\n+    abort ();\n+  return 0;\n+}\n+\n+int (*fn) (const char *) = foo;\n+\n+int __attribute__((noinline))\n+bar (void)\n+{\n+  char s[ASIZE];\n+  s[0] = 'a';\n+  s[ASIZE - 1] = 'b';\n+  foo (s);\n+  foo (s);\n+  return 0;\n+}\n+\n+int __attribute__((noinline))\n+baz (long i)\n+{\n+  if (i)\n+    return fn (0);\n+  else\n+    {\n+      char s[ASIZE];\n+      s[0] = 'a';\n+      s[ASIZE - 1] = 'b';\n+      foo (s);\n+      foo (s);\n+      return fn (0);\n+    }\n+}\n+\n+int __attribute__((noinline))\n+very_large_offset (int *p)\n+{\n+  char init_array[(uint64_t)0xfefefef];\n+  char other_array[(uint64_t)0xfefefef];\n+  return (int)init_array[p[1]] + (int)other_array[p[0]];\n+}\n+"}, {"sha": "55db0c0b865ac93d0525f0cc0775f4080fc3d4b1", "filename": "gcc/testsuite/c-c++-common/ubsan/sanitize-recover-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsanitize-recover-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsanitize-recover-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fsanitize-recover-7.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -3,4 +3,4 @@\n \n int i;\n \n-/* { dg-error \".-fsanitize=thread. is incompatible with .-fsanitize=address|kernel-address.\" \"\" { target *-*-* } 0 } */\n+/* { dg-error \".-fsanitize=thread. is incompatible with .-fsanitize=address.\" \"\" { target *-*-* } 0 } */"}, {"sha": "559cf066f18cc82601661a751bf702303c66c888", "filename": "gcc/testsuite/g++.dg/hwasan/hwasan.exp", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Fhwasan.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Fhwasan.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Fhwasan.exp?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,34 @@\n+# Copyright (C) 2012-2019 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+load_lib hwasan-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+hwasan_init\n+\n+# Main loop.\n+if [check_effective_target_fsanitize_hwaddress] {\n+  gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C $srcdir/c-c++-common/hwasan/*.c]] \"\" \"\"\n+}\n+\n+# All done.\n+hwasan_finish\n+dg-finish"}, {"sha": "0e30ff054fc65610996b7cdf3e5dcd6dbeeffe6c", "filename": "gcc/testsuite/g++.dg/hwasan/rvo-handled.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Frvo-handled.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Frvo-handled.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fhwasan%2Frvo-handled.C?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-O0\" } { \"\" } } */\n+\n+#define assert(x) if (!(x)) __builtin_abort ()\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+void *untagged (void *ptr)\n+{\n+  /* Untag by removing the top byte.  */\n+  return (void*)((uintptr_t)ptr & 0xffffffffffffff);\n+}\n+\n+struct big_struct {\n+    int left;\n+    int right;\n+    void *ptr;\n+    int big_array[100];\n+};\n+\n+/*\n+   Tests for RVO (basically, checking -fsanitize=hwaddress has not broken RVO\n+   in any way).\n+\n+   0) The value is accessible in both functions without a hwasan complaint.\n+   1) RVO does happen.\n+ */\n+\n+struct big_struct __attribute__ ((noinline))\n+return_on_stack()\n+{\n+  struct big_struct x;\n+  x.left = 100;\n+  x.right = 20;\n+  x.big_array[10] = 30;\n+  x.ptr = untagged(&x);\n+  return x;\n+}\n+\n+int main()\n+{\n+  struct big_struct x;\n+  x = return_on_stack();\n+  /* Check that RVO happens by checking the address that the callee saw.  */\n+  assert (x.ptr == untagged(&x));\n+  return 0;\n+}"}, {"sha": "5c040aec24a222e4024a548e055c52cee4afe8f8", "filename": "gcc/testsuite/gcc.dg/hwasan/hwasan.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fhwasan.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fhwasan.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fhwasan.exp?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,36 @@\n+# Copyright (C) 2012-2019 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib hwasan-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+hwasan_init\n+\n+# Main loop.\n+if [check_effective_target_fsanitize_hwaddress] {\n+  gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c $srcdir/c-c++-common/hwasan/*.c]] \"\" \"\"\n+}\n+\n+# All done.\n+hwasan_finish\n+dg-finish"}, {"sha": "0afcc100508cd2a5467698e901e32fa2292a32c9", "filename": "gcc/testsuite/gcc.dg/hwasan/nested-functions-0.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-0.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+\n+/*\n+   Tests of nested funtions are:\n+    0) Accessing closed over variables works.\n+    1) Accesses outside of variables is caught.\n+    2) Accessing variable out of scope is caught.\n+\n+    Here we test that accessing closed over variables works.\n+ */\n+\n+/* We need a second layer of indirection so that GCC doesn't notice we're\n+   returning the address of a local variable and put 0 in it's place.  */\n+__attribute__((noinline))\n+int *Ident(void *x) {\n+  return x;\n+}\n+\n+int __attribute__ ((noinline))\n+intermediate (void (*f) (int, char),\n+\t      char num)\n+{\n+  if (num == 1)\n+    /* NOTE: We need to overrun by an amount greater than the \"extra data\" in a\n+       nonlocal goto structure.  The entire structure is allocated on the stack\n+       with a single tag, which means hwasan can't tell if a closed-over buffer\n+       was overrun by an amount small enough that the access was still to some\n+       data in that nonlocal goto structure.  */\n+    f (100, 100);\n+  else\n+    f (3, 100);\n+  /* Just return something ... */\n+  return num % 3;\n+}\n+\n+int* __attribute__ ((noinline))\n+nested_function (char num)\n+{\n+  int big_array[16];\n+  int other_array[16];\n+  void store (int index, char value)\n+    { big_array[index] = value; }\n+  return Ident(&other_array[intermediate (store, num)]);\n+}\n+\n+#ifndef MAIN\n+int main ()\n+{\n+  nested_function (0);\n+  return 0;\n+}\n+#endif"}, {"sha": "016128101e23c6405d943f4a2a4729f7c48ff95a", "filename": "gcc/testsuite/gcc.dg/hwasan/nested-functions-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-1.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+/*\n+   Tests of nested funtions are:\n+    0) Accessing closed over variables works.\n+    1) Accesses outside of variables is caught.\n+    2) Accessing variable out of scope is caught.\n+\n+    Here we test option 1.\n+ */\n+\n+#define MAIN 0\n+#include \"nested-functions-0.c\"\n+#undef MAIN\n+\n+int main ()\n+{\n+  nested_function (1);\n+  return 0;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"WRITE of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "b1a033fdb365cf53882fc1d8294b32bbad16ea8a", "filename": "gcc/testsuite/gcc.dg/hwasan/nested-functions-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhwasan%2Fnested-functions-2.c?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target hwaddress_exec } */\n+/* { dg-shouldfail \"hwasan\" } */\n+\n+/*\n+   Tests of nested funtions are:\n+    0) Accessing closed over variables works.\n+    1) Accesses outside of variables is caught.\n+    2) Accessing variable out of scope is caught.\n+\n+    Here we test option 2.\n+ */\n+\n+#define MAIN 0\n+#include \"nested-functions-0.c\"\n+#undef MAIN\n+\n+int main ()\n+{\n+  int *retval = nested_function (2);\n+  *retval = 100;\n+  return 0;\n+}\n+\n+/* { dg-output \"HWAddressSanitizer: tag-mismatch on address 0x\\[0-9a-f\\]*.*\" } */\n+/* { dg-output \"WRITE of size 4 at 0x\\[0-9a-f\\]* tags: \\[\\[:xdigit:\\]\\]\\[\\[:xdigit:\\]\\]/00 \\\\(ptr/mem\\\\) in thread T0.*\" } */\n+/* { dg-output \"Address 0x\\[0-9a-f\\]* is located in stack of thread T0.*\" } */\n+/* { dg-output \"SUMMARY: HWAddressSanitizer: tag-mismatch \\[^\\n\\]*.*\" } */"}, {"sha": "8f96751bfacf9364bfd18ea4ded3d545b3caa774", "filename": "gcc/testsuite/lib/asan-dg.exp", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fasan-dg.exp?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -16,6 +16,9 @@\n \n # Return 1 if compilation with -fsanitize=address is error-free for trivial\n # code, 0 otherwise.\n+#\n+# NOTE: This should only be used between calls to asan_init and asan_finish.\n+# It is therefore defined here rather than in target-supports.exp.\n \n proc check_effective_target_fsanitize_address {} {\n     if ![check_no_compiler_messages fsanitize_address executable {\n@@ -58,33 +61,33 @@ proc asan_include_flags {} {\n # (originally from g++.exp)\n #\n \n-proc asan_link_flags { paths } {\n+proc asan_link_flags_1 { paths lib } {\n     global srcdir\n     global ld_library_path\n     global shlib_ext\n-    global asan_saved_library_path\n+    global ${lib}_saved_library_path\n \n     set gccpath ${paths}\n     set flags \"\"\n \n     set shlib_ext [get_shlib_extension]\n-    set asan_saved_library_path $ld_library_path\n+    set ${lib}_saved_library_path $ld_library_path\n \n     if { $gccpath != \"\" } {\n-      if { [file exists \"${gccpath}/libsanitizer/asan/.libs/libasan.a\"]\n-\t   || [file exists \"${gccpath}/libsanitizer/asan/.libs/libasan.${shlib_ext}\"] } {\n+      if { [file exists \"${gccpath}/libsanitizer/${lib}/.libs/lib${lib}.a\"]\n+\t   || [file exists \"${gccpath}/libsanitizer/${lib}/.libs/lib${lib}.${shlib_ext}\"] } {\n \t  append flags \" -B${gccpath}/libsanitizer/ \"\n-\t  append flags \" -B${gccpath}/libsanitizer/asan/ \"\n-\t  append flags \" -L${gccpath}/libsanitizer/asan/.libs \"\n-\t  append ld_library_path \":${gccpath}/libsanitizer/asan/.libs\"\n+\t  append flags \" -B${gccpath}/libsanitizer/${lib}/ \"\n+\t  append flags \" -L${gccpath}/libsanitizer/${lib}/.libs \"\n+\t  append ld_library_path \":${gccpath}/libsanitizer/${lib}/.libs\"\n       }\n     } else {\n       global tool_root_dir\n \n-      set libasan [lookfor_file ${tool_root_dir} libasan]\n-      if { $libasan != \"\" } {\n-\t  append flags \"-L${libasan} \"\n-\t  append ld_library_path \":${libasan}\"\n+      set libdir [lookfor_file ${tool_root_dir} lib${lib}]\n+      if { $libdir != \"\" } {\n+\t  append flags \"-L${libdir} \"\n+\t  append ld_library_path \":${libdir}\"\n       }\n     }\n \n@@ -93,6 +96,10 @@ proc asan_link_flags { paths } {\n     return \"$flags\"\n }\n \n+proc asan_link_flags { paths } {\n+    return [asan_link_flags_1 $paths asan]\n+}\n+\n #\n # asan_init -- called at the start of each subdir of tests\n #"}, {"sha": "892f2bab43325e830b5d9243377c70e074cdfe40", "filename": "gcc/testsuite/lib/hwasan-dg.exp", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Flib%2Fhwasan-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47850552a0a25db7793a4eaf4859d43368a8b65/gcc%2Ftestsuite%2Flib%2Fhwasan-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fhwasan-dg.exp?ref=a47850552a0a25db7793a4eaf4859d43368a8b65", "patch": "@@ -0,0 +1,150 @@\n+# Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib asan-dg.exp\n+\n+# Return 1 if target can compile a binary for hardware address\n+# sanitization, 0 otherwise.\n+#\n+# NOTE: This should only be used between calls to hwasan_init and\n+# hwasan_finish.  It is therefore defined here rather than in\n+# target-supports.exp.\n+\n+proc check_effective_target_fsanitize_hwaddress {} {\n+    if ![check_no_compiler_messages fsanitize_hwaddress executable {\n+\tint main (void) { return 0; }\n+    }] {\n+\treturn 0;\n+    }\n+    return 1;\n+}\n+\n+# Return 1 if target can compile and run a binary for hardware address\n+# sanitization, 0 otherwise.\n+#\n+# NOTE: This should only be used between calls to hwasan_init and\n+# hwasan_finish.  It is therefore defined here rather than in\n+# target-supports.exp.\n+\n+proc check_effective_target_hwaddress_exec {} {\n+    if ![check_runtime hwaddress_exec {\n+\tint main (void) { return 0; }\n+    }] {\n+\treturn 0;\n+    }\n+    return 1;\n+}\n+\n+proc hwasan_include_flags {} {\n+    global srcdir\n+    global TESTING_IN_BUILD_TREE\n+\n+    set flags \"\"\n+\n+    if { [is_remote host] || ! [info exists TESTING_IN_BUILD_TREE] } {\n+      return \"${flags}\"\n+    }\n+\n+    set flags \"-I$srcdir/../../libsanitizer/include\"\n+\n+    return \"$flags\"\n+}\n+\n+#\n+# hwasan_link_flags -- compute library path and flags to find libhwasan.\n+# (implementation in asan-dg.exp)\n+#\n+\n+proc hwasan_link_flags { paths } {\n+    return [asan_link_flags_1 $paths hwasan]\n+}\n+\n+#\n+# hwasan_init -- called at the start of each subdir of tests\n+#\n+\n+proc hwasan_init { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global ALWAYS_CXXFLAGS\n+    global TOOL_OPTIONS\n+    global hwasan_saved_TEST_ALWAYS_FLAGS\n+    global hwasan_saved_ALWAYS_CXXFLAGS\n+\n+    setenv HWASAN_OPTIONS \"random_tags=0\"\n+\n+    set link_flags \"\"\n+    if ![is_remote host] {\n+\tif [info exists TOOL_OPTIONS] {\n+\t    set link_flags \"[hwasan_link_flags [get_multilibs ${TOOL_OPTIONS}]]\"\n+\t} else {\n+\t    set link_flags \"[hwasan_link_flags [get_multilibs]]\"\n+\t}\n+    }\n+\n+    set include_flags \"[hwasan_include_flags]\"\n+\n+    if [info exists TEST_ALWAYS_FLAGS] {\n+\tset hwasan_saved_TEST_ALWAYS_FLAGS $TEST_ALWAYS_FLAGS\n+    }\n+    if [info exists ALWAYS_CXXFLAGS] {\n+\tset hwasan_saved_ALWAYS_CXXFLAGS $ALWAYS_CXXFLAGS\n+\tset ALWAYS_CXXFLAGS [concat \"{ldflags=$link_flags}\" $ALWAYS_CXXFLAGS]\n+\tset ALWAYS_CXXFLAGS [concat \"{additional_flags=-fsanitize=hwaddress --param hwasan-random-frame-tag=0 -g $include_flags}\" $ALWAYS_CXXFLAGS]\n+    } else {\n+\tif [info exists TEST_ALWAYS_FLAGS] {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags -fsanitize=hwaddress --param hwasan-random-frame-tag=0 -g $include_flags $TEST_ALWAYS_FLAGS\"\n+\t} else {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags -fsanitize=hwaddress --param hwasan-random-frame-tag=0 -g $include_flags\"\n+\t}\n+    }\n+}\n+\n+#\n+# hwasan_finish -- called at the start of each subdir of tests\n+#\n+\n+proc hwasan_finish { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global hwasan_saved_TEST_ALWAYS_FLAGS\n+    global hwasan_saved_ALWAYS_CXXFLAGS\n+    global hwasan_saved_library_path\n+    global ld_library_path\n+\n+    unsetenv HWASAN_OPTIONS\n+\n+    if [info exists hwasan_saved_ALWAYS_CXXFLAGS ] {\n+\tset ALWAYS_CXXFLAGS $hwasan_saved_ALWAYS_CXXFLAGS\n+    } else {\n+\tif [info exists hwasan_saved_TEST_ALWAYS_FLAGS] {\n+\t    set TEST_ALWAYS_FLAGS $hwasan_saved_TEST_ALWAYS_FLAGS\n+\t} else {\n+\t    unset TEST_ALWAYS_FLAGS\n+\t}\n+    }\n+    if [info exists hwasan_saved_library_path] {\n+\tset ld_library_path $hwasan_saved_library_path\n+\tset_ld_library_path_env_vars\n+    }\n+    clear_effective_target_cache\n+}\n+\n+# Utility for running gtest hwasan emulation under dejagnu, invoked via dg-final.\n+# Call pass if variable has the desired value, otherwise fail.\n+#\n+# Argument 0 handles expected failures and the like\n+proc hwasan-gtest { args } {\n+    asan-gtest {*}$args\n+}"}]}