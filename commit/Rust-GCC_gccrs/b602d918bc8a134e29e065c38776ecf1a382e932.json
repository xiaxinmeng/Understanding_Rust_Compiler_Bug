{"sha": "b602d918bc8a134e29e065c38776ecf1a382e932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwMmQ5MThiYzhhMTM0ZTI5ZTA2NWMzODc3NmVjZjFhMzgyZTkzMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-14T12:47:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-14T12:47:16Z"}, "message": "tree-vectorizer.h (vect_strided_store_supported): Add a HOST_WIDE_INT argument.\n\ngcc/\n\t* tree-vectorizer.h (vect_strided_store_supported): Add a\n\tHOST_WIDE_INT argument.\n\t(vect_strided_load_supported): Likewise.\n\t(vect_permute_store_chain): Return void.\n\t(vect_transform_strided_load): Likewise.\n\t(vect_permute_load_chain): Delete.\n\t* tree-vect-data-refs.c (vect_strided_store_supported): Take a\n\tcount argument.  Check that the count is a power of two.\n\t(vect_strided_load_supported): Likewise.\n\t(vect_permute_store_chain): Return void.  Update after above changes.\n\tAssert that the access is supported.\n\t(vect_permute_load_chain): Likewise.\n\t(vect_transform_strided_load): Return void.\n\t* tree-vect-stmts.c (vectorizable_store): Update calls after\n\tabove interface changes.\n\t(vectorizable_load): Likewise.\n\t(vect_analyze_stmt): Don't check for strided powers of two here.\n\nFrom-SVN: r172428", "tree": {"sha": "5dac161f5fefc61980e3e2bf80127b1f5faa4daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dac161f5fefc61980e3e2bf80127b1f5faa4daa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b602d918bc8a134e29e065c38776ecf1a382e932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b602d918bc8a134e29e065c38776ecf1a382e932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b602d918bc8a134e29e065c38776ecf1a382e932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b602d918bc8a134e29e065c38776ecf1a382e932/comments", "author": null, "committer": null, "parents": [{"sha": "ab4472fa10153d18b16704086d28599adae30e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab4472fa10153d18b16704086d28599adae30e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab4472fa10153d18b16704086d28599adae30e28"}], "stats": {"total": 135, "additions": 66, "deletions": 69}, "files": [{"sha": "38bff669124f7d6de98b1796195d19c952afdbab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b602d918bc8a134e29e065c38776ecf1a382e932", "patch": "@@ -1,3 +1,23 @@\n+2011-04-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_strided_store_supported): Add a\n+\tHOST_WIDE_INT argument.\n+\t(vect_strided_load_supported): Likewise.\n+\t(vect_permute_store_chain): Return void.\n+\t(vect_transform_strided_load): Likewise.\n+\t(vect_permute_load_chain): Delete.\n+\t* tree-vect-data-refs.c (vect_strided_store_supported): Take a\n+\tcount argument.  Check that the count is a power of two.\n+\t(vect_strided_load_supported): Likewise.\n+\t(vect_permute_store_chain): Return void.  Update after above changes.\n+\tAssert that the access is supported.\n+\t(vect_permute_load_chain): Likewise.\n+\t(vect_transform_strided_load): Return void.\n+\t* tree-vect-stmts.c (vectorizable_store): Update calls after\n+\tabove interface changes.\n+\t(vectorizable_load): Likewise.\n+\t(vect_analyze_stmt): Don't check for strided powers of two here.\n+\n 2011-04-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48590"}, {"sha": "d7d174fbba2fb84be1d3e2c03274e242931dfd86", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b602d918bc8a134e29e065c38776ecf1a382e932", "patch": "@@ -2196,19 +2196,6 @@ vect_analyze_group_access (struct data_reference *dr)\n           return false;\n         }\n \n-      /* FORNOW: we handle only interleaving that is a power of 2.\n-         We don't fail here if it may be still possible to vectorize the\n-         group using SLP.  If not, the size of the group will be checked in\n-         vect_analyze_operations, and the vectorization will fail.  */\n-      if (exact_log2 (stride) == -1)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"interleaving is not a power of 2\");\n-\n-\t  if (slp_impossible)\n-\t    return false;\n-\t}\n-\n       if (stride == 0)\n         stride = count;\n \n@@ -3349,13 +3336,22 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n    and FALSE otherwise.  */\n \n bool\n-vect_strided_store_supported (tree vectype)\n+vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n   optab interleave_high_optab, interleave_low_optab;\n   enum machine_mode mode;\n \n   mode = TYPE_MODE (vectype);\n \n+  /* vect_permute_store_chain requires the group size to be a power of two.  */\n+  if (exact_log2 (count) == -1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"the size of the group of strided accesses\"\n+\t\t \" is not a power of 2\");\n+      return false;\n+    }\n+\n   /* Check that the operation is supported.  */\n   interleave_high_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR,\n \t\t\t\t\t       vectype, optab_default);\n@@ -3441,7 +3437,7 @@ vect_strided_store_supported (tree vectype)\n    I3:  4 12 20 28  5 13 21 30\n    I4:  6 14 22 30  7 15 23 31.  */\n \n-bool\n+void\n vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t\t\t  unsigned int length,\n \t\t\t  gimple stmt,\n@@ -3455,9 +3451,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n   unsigned int j;\n   enum tree_code high_code, low_code;\n \n-  /* Check that the operation is supported.  */\n-  if (!vect_strided_store_supported (vectype))\n-    return false;\n+  gcc_assert (vect_strided_store_supported (vectype, length));\n \n   *result_chain = VEC_copy (tree, heap, dr_chain);\n \n@@ -3510,7 +3504,6 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t}\n       dr_chain = VEC_copy (tree, heap, *result_chain);\n     }\n-  return true;\n }\n \n /* Function vect_setup_realignment\n@@ -3787,13 +3780,22 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n    and FALSE otherwise.  */\n \n bool\n-vect_strided_load_supported (tree vectype)\n+vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n   optab perm_even_optab, perm_odd_optab;\n   enum machine_mode mode;\n \n   mode = TYPE_MODE (vectype);\n \n+  /* vect_permute_load_chain requires the group size to be a power of two.  */\n+  if (exact_log2 (count) == -1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"the size of the group of strided accesses\"\n+\t\t \" is not a power of 2\");\n+      return false;\n+    }\n+\n   perm_even_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR, vectype,\n \t\t\t\t\t optab_default);\n   if (!perm_even_optab)\n@@ -3905,7 +3907,7 @@ vect_strided_load_supported (tree vectype)\n    3rd vec (E2):  2 6 10 14 18 22 26 30\n    4th vec (E4):  3 7 11 15 19 23 27 31.  */\n \n-bool\n+static void\n vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t\t\t unsigned int length,\n \t\t\t gimple stmt,\n@@ -3918,9 +3920,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n   int i;\n   unsigned int j;\n \n-  /* Check that the operation is supported.  */\n-  if (!vect_strided_load_supported (vectype))\n-    return false;\n+  gcc_assert (vect_strided_load_supported (vectype, length));\n \n   *result_chain = VEC_copy (tree, heap, dr_chain);\n   for (i = 0; i < exact_log2 (length); i++)\n@@ -3963,7 +3963,6 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t}\n       dr_chain = VEC_copy (tree, heap, *result_chain);\n     }\n-  return true;\n }\n \n \n@@ -3974,7 +3973,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n    the scalar statements.\n */\n \n-bool\n+void\n vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n@@ -3990,8 +3989,7 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n      vectors, that are ready for vector computation.  */\n   result_chain = VEC_alloc (tree, heap, size);\n   /* Permute.  */\n-  if (!vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain))\n-    return false;\n+  vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain);\n \n   /* Put a permuted data-ref in the VECTORIZED_STMT field.\n      Since we scan the chain starting from it's first node, their order\n@@ -4055,7 +4053,6 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n     }\n \n   VEC_free (tree, heap, result_chain);\n-  return true;\n }\n \n /* Function vect_force_dr_alignment_p."}, {"sha": "20ca7a451b465799fba4e25cc27b077929f65d58", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b602d918bc8a134e29e065c38776ecf1a382e932", "patch": "@@ -3410,9 +3410,12 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       strided_store = true;\n       first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n-      if (!vect_strided_store_supported (vectype)\n-\t  && !PURE_SLP_STMT (stmt_info) && !slp)\n-\treturn false;\n+      if (!slp && !PURE_SLP_STMT (stmt_info))\n+\t{\n+\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  if (!vect_strided_store_supported (vectype, group_size))\n+\t    return false;\n+\t}\n \n       if (first_stmt == stmt)\n \t{\n@@ -3612,9 +3615,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  result_chain = VEC_alloc (tree, heap, group_size);\n \t  /* Permute.  */\n-\t  if (!vect_permute_store_chain (dr_chain, group_size, stmt, gsi,\n-\t\t\t\t\t &result_chain))\n-\t    return false;\n+\t  vect_permute_store_chain (dr_chain, group_size, stmt, gsi,\n+\t\t\t\t    &result_chain);\n \t}\n \n       next_stmt = first_stmt;\n@@ -3902,10 +3904,13 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       /* FORNOW */\n       gcc_assert (! nested_in_vect_loop);\n \n-      /* Check if interleaving is supported.  */\n-      if (!vect_strided_load_supported (vectype)\n-\t  && !PURE_SLP_STMT (stmt_info) && !slp)\n-\treturn false;\n+      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      if (!slp && !PURE_SLP_STMT (stmt_info))\n+\t{\n+\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  if (!vect_strided_load_supported (vectype, group_size))\n+\t    return false;\n+\t}\n     }\n \n   if (negative)\n@@ -4322,9 +4327,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n         {\n           if (strided_load)\n   \t    {\n-\t      if (!vect_transform_strided_load (stmt, dr_chain, group_size, gsi))\n-\t        return false;\n-\n+\t      vect_transform_strided_load (stmt, dr_chain, group_size, gsi);\n \t      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t    }\n           else\n@@ -4743,27 +4746,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n        return false;\n     }\n \n-  if (!PURE_SLP_STMT (stmt_info))\n-    {\n-      /* Groups of strided accesses whose size is not a power of 2 are not\n-         vectorizable yet using loop-vectorization.  Therefore, if this stmt\n-\t feeds non-SLP-able stmts (i.e., this stmt has to be both SLPed and\n-\t loop-based vectorized), the loop cannot be vectorized.  */\n-      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-          && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n-                                        DR_GROUP_FIRST_DR (stmt_info)))) == -1)\n-        {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"not vectorized: the size of group \"\n-                                  \"of strided accesses is not a power of 2\");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-            }\n-\n-          return false;\n-        }\n-    }\n-\n   return true;\n }\n "}, {"sha": "6e63afcc716790eb1bd0dd58c4610f1d49576c3f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b602d918bc8a134e29e065c38776ecf1a382e932/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b602d918bc8a134e29e065c38776ecf1a382e932", "patch": "@@ -828,16 +828,14 @@ extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,\n \t\t\t\t      gimple *, bool, bool *);\n extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);\n extern tree vect_create_destination_var (tree, tree);\n-extern bool vect_strided_store_supported (tree);\n-extern bool vect_strided_load_supported (tree);\n-extern bool vect_permute_store_chain (VEC(tree,heap) *,unsigned int, gimple,\n+extern bool vect_strided_store_supported (tree, unsigned HOST_WIDE_INT);\n+extern bool vect_strided_load_supported (tree, unsigned HOST_WIDE_INT);\n+extern void vect_permute_store_chain (VEC(tree,heap) *,unsigned int, gimple,\n                                     gimple_stmt_iterator *, VEC(tree,heap) **);\n extern tree vect_setup_realignment (gimple, gimple_stmt_iterator *, tree *,\n                                     enum dr_alignment_support, tree,\n                                     struct loop **);\n-extern bool vect_permute_load_chain (VEC(tree,heap) *,unsigned int, gimple,\n-                                    gimple_stmt_iterator *, VEC(tree,heap) **);\n-extern bool vect_transform_strided_load (gimple, VEC(tree,heap) *, int,\n+extern void vect_transform_strided_load (gimple, VEC(tree,heap) *, int,\n                                          gimple_stmt_iterator *);\n extern int vect_get_place_in_interleaving_chain (gimple, gimple);\n extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);"}]}