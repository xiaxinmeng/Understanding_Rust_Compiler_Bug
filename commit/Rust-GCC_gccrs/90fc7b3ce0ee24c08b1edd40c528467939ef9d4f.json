{"sha": "90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBmYzdiM2NlMGVlMjRjMDhiMWVkZDQwYzUyODQ2NzkzOWVmOWQ0Zg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-12T17:30:57Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-13T20:20:49Z"}, "message": "libstdc++: Move some ranges algos to a new header <bits/ranges_algobase.h>\n\nThis roughly mirrors the existing split between <bits/stl_algo.h> and\n<bits/stl_algobase.h>.  The ranges [specialized.algorithms] will use this new\nheader to avoid including all of of <bits/ranges_algo.h>.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add bits/ranges_algobase.h\n\t* include/Makefile.in: Regenerate.\n\t* bits/ranges_algo.h: Include <bits/ranges_algobase.h> and refactor\n\texisting #includes.\n\t(__detail::__is_normal_iterator, __detail::is_reverse_iterator,\n\t__detail::__is_move_iterator, copy_result, move_result,\n\t__equal, equal, copy_result, move_result, move_backward_result,\n\tcopy_backward_result, __copy_or_move_backward, __copy_or_move, copy,\n\tmove, copy_backward, move_backward, copy_n_result, copy_n, fill_n,\n\tfill): Split out into ...\n\t* bits/range_algobase.h: ... this new header.", "tree": {"sha": "eeaaaa33f70aef896b04d90a131b529b706fd97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeaaaa33f70aef896b04d90a131b529b706fd97d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/comments", "author": null, "committer": null, "parents": [{"sha": "bacdd5e978dad84e9c547b0d5c7fed14b8d75157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacdd5e978dad84e9c547b0d5c7fed14b8d75157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bacdd5e978dad84e9c547b0d5c7fed14b8d75157"}], "stats": {"total": 1080, "additions": 573, "deletions": 507}, "files": [{"sha": "8715e50daba4b7f97dc2bf3dcbcf6b17f7b3780d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "patch": "@@ -1,3 +1,17 @@\n+2020-02-13  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* include/Makefile.am: Add bits/ranges_algobase.h\n+\t* include/Makefile.in: Regenerate.\n+\t* bits/ranges_algo.h: Include <bits/ranges_algobase.h> and refactor\n+\texisting #includes.\n+\t(__detail::__is_normal_iterator, __detail::is_reverse_iterator,\n+\t__detail::__is_move_iterator, copy_result, move_result,\n+\t__equal, equal, copy_result, move_result, move_backward_result,\n+\tcopy_backward_result, __copy_or_move_backward, __copy_or_move, copy,\n+\tmove, copy_backward, move_backward, copy_n_result, copy_n, fill_n,\n+\tfill): Split out into ...\n+\t* bits/range_algobase.h: ... this new header.\n+\n 2020-02-12  Patrick Palka  <ppalka@redhat.com>\n \n \tLWG 3389 and LWG 3390"}, {"sha": "614222db400b7a557702ccae76b9d71b8f28aed3", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "patch": "@@ -157,6 +157,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/range_cmp.h \\\n+\t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\"}, {"sha": "7ee6a1e3f61abd526a6a72064454aa4cbf26d05a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "patch": "@@ -502,6 +502,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/range_cmp.h \\\n+\t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\"}, {"sha": "84a02cabb80d031c7cc5058709428d1fca7b5f27", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 1, "deletions": 507, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "patch": "@@ -32,13 +32,7 @@\n \n #if __cplusplus > 201703L\n \n-#include <compare>\n-#include <cmath>\n-#include <iterator>\n-// #include <bits/range_concepts.h>\n-#include <ranges>\n-#include <bits/invoke.h>\n-#include <bits/cpp_type_traits.h> // __is_byte\n+#include <bits/ranges_algobase.h>\n #include <bits/random.h> // concept uniform_random_bit_generator\n \n #if __cpp_lib_concepts\n@@ -49,28 +43,6 @@ namespace ranges\n {\n   namespace __detail\n   {\n-    template<typename _Tp>\n-      constexpr inline bool __is_normal_iterator = false;\n-\n-    template<typename _Iterator, typename _Container>\n-      constexpr inline bool\n-\t__is_normal_iterator<__gnu_cxx::__normal_iterator<_Iterator,\n-\t\t\t\t\t\t\t  _Container>> = true;\n-\n-    template<typename _Tp>\n-      constexpr inline bool __is_reverse_iterator = false;\n-\n-    template<typename _Iterator>\n-      constexpr inline bool\n-\t__is_reverse_iterator<reverse_iterator<_Iterator>> = true;\n-\n-    template<typename _Tp>\n-      constexpr inline bool __is_move_iterator = false;\n-\n-    template<typename _Iterator>\n-      constexpr inline bool\n-\t__is_move_iterator<move_iterator<_Iterator>> = true;\n-\n     template<typename _Comp, typename _Proj>\n       constexpr auto\n       __make_comp_proj(_Comp& __comp, _Proj& __proj)\n@@ -741,420 +713,6 @@ namespace ranges\n \t\t\t\t    std::move(__proj1), std::move(__proj2));\n     }\n \n-  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred, typename _Proj1, typename _Proj2>\n-    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    __equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n-\t    _Pred __pred, _Proj1 __proj1, _Proj2 __proj2)\n-    {\n-      // TODO: implement more specializations to at least have parity with\n-      // std::equal.\n-      constexpr bool __sized_iters\n-\t= (sized_sentinel_for<_Sent1, _Iter1>\n-\t   && sized_sentinel_for<_Sent2, _Iter2>);\n-      if constexpr (__sized_iters)\n-\t{\n-\t  auto __d1 = ranges::distance(__first1, __last1);\n-\t  auto __d2 = ranges::distance(__first2, __last2);\n-\t  if (__d1 != __d2)\n-\t    return false;\n-\n-\t  using _ValueType1 = iter_value_t<_Iter1>;\n-\t  using _ValueType2 = iter_value_t<_Iter2>;\n-\t  constexpr bool __use_memcmp\n-\t    = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)\n-\t       && is_same_v<_ValueType1, _ValueType2>\n-\t       && is_pointer_v<_Iter1>\n-\t       && is_pointer_v<_Iter2>\n-\t       && is_same_v<_Pred, ranges::equal_to>\n-\t       && is_same_v<_Proj1, identity>\n-\t       && is_same_v<_Proj2, identity>);\n-\t  if constexpr (__use_memcmp)\n-\t    {\n-\t      if (const size_t __len = (__last1 - __first1))\n-\t\treturn !std::__memcmp(__first1, __first2, __len);\n-\t      return true;\n-\t    }\n-\t  else\n-\t    {\n-\t      for (; __first1 != __last1; ++__first1, (void)++__first2)\n-\t\tif (!(bool)std::__invoke(__pred,\n-\t\t\t\t\t std::__invoke(__proj1, *__first1),\n-\t\t\t\t\t std::__invoke(__proj2, *__first2)))\n-\t\t  return false;\n-\t      return true;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (; __first1 != __last1 && __first2 != __last2;\n-\t       ++__first1, (void)++__first2)\n-\t    if (!(bool)std::__invoke(__pred,\n-\t\t\t\t     std::__invoke(__proj1, *__first1),\n-\t\t\t\t     std::__invoke(__proj2, *__first2)))\n-\t      return false;\n-\t  return __first1 == __last1 && __first2 == __last2;\n-\t}\n-    }\n-\n-  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n-\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      return ranges::__equal(std::__niter_base(std::move(__first1)),\n-\t\t\t     std::__niter_base(std::move(__last1)),\n-\t\t\t     std::__niter_base(std::move(__first2)),\n-\t\t\t     std::__niter_base(std::move(__last2)),\n-\t\t\t     std::move(__pred),\n-\t\t\t     std::move(__proj1), std::move(__proj2));\n-    }\n-\n-  template<input_range _Range1, input_range _Range2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n-\t\t\t\t   _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    equal(_Range1&& __r1, _Range2&& __r2,\n-\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      return ranges::equal(ranges::begin(__r1), ranges::end(__r1),\n-\t\t\t   ranges::begin(__r2), ranges::end(__r2),\n-\t\t\t   std::move(__pred),\n-\t\t\t   std::move(__proj1), std::move(__proj2));\n-    }\n-\n-  template<typename _Iter, typename _Out>\n-    struct copy_result\n-    {\n-      [[no_unique_address]] _Iter in;\n-      [[no_unique_address]] _Out out;\n-\n-      template<typename _Iter2, typename _Out2>\n-\trequires convertible_to<const _Iter&, _Iter2>\n-\t  && convertible_to<const _Out&, _Out2>\n-\toperator copy_result<_Iter2, _Out2>() const &\n-\t{ return {in, out}; }\n-\n-      template<typename _Iter2, typename _Out2>\n-\trequires convertible_to<_Iter, _Iter2>\n-\t  && convertible_to<_Out, _Out2>\n-\toperator copy_result<_Iter2, _Out2>() &&\n-\t{ return {std::move(in), std::move(out)}; }\n-    };\n-\n-  template<typename _Iter, typename _Out>\n-    using move_result = copy_result<_Iter, _Out>;\n-\n-  template<typename _Iter1, typename _Iter2>\n-    using move_backward_result = copy_result<_Iter1, _Iter2>;\n-\n-  template<typename _Iter1, typename _Iter2>\n-    using copy_backward_result = copy_result<_Iter1, _Iter2>;\n-\n-  template<bool _IsMove,\n-\t   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   bidirectional_iterator _Out>\n-    requires (_IsMove\n-\t      ? indirectly_movable<_Iter, _Out>\n-\t      : indirectly_copyable<_Iter, _Out>)\n-    constexpr conditional_t<_IsMove,\n-\t\t\t    move_backward_result<_Iter, _Out>,\n-\t\t\t    copy_backward_result<_Iter, _Out>>\n-    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result);\n-\n-  template<bool _IsMove,\n-\t   input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   weakly_incrementable _Out>\n-    requires (_IsMove\n-\t      ? indirectly_movable<_Iter, _Out>\n-\t      : indirectly_copyable<_Iter, _Out>)\n-    constexpr conditional_t<_IsMove,\n-\t\t\t    move_result<_Iter, _Out>,\n-\t\t\t    copy_result<_Iter, _Out>>\n-    __copy_or_move(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::copy/std::move.\n-      constexpr bool __normal_iterator_p\n-\t= (__detail::__is_normal_iterator<_Iter>\n-\t   || __detail::__is_normal_iterator<_Out>);\n-      constexpr bool __reverse_p\n-\t= (__detail::__is_reverse_iterator<_Iter>\n-\t   && __detail::__is_reverse_iterator<_Out>);\n-      constexpr bool __move_iterator_p = __detail::__is_move_iterator<_Iter>;\n-      if constexpr (__move_iterator_p)\n-\t{\n-\t  auto [__in, __out]\n-\t    = ranges::__copy_or_move<true>(std::move(__first).base(),\n-\t\t\t\t\t   std::move(__last).base(),\n-\t\t\t\t\t   std::move(__result));\n-\t  return {move_iterator{std::move(__in)}, std::move(__out)};\n-\t}\n-      else if constexpr (__reverse_p)\n-\t{\n-\t  auto [__in,__out]\n-\t    = ranges::__copy_or_move_backward<_IsMove>(__last.base(),\n-\t\t\t\t\t\t       __first.base(),\n-\t\t\t\t\t\t       __result.base());\n-\t  return {reverse_iterator{std::move(__in)},\n-\t\t  reverse_iterator{std::move(__out)}};\n-\t}\n-      else if constexpr (__normal_iterator_p)\n-\t{\n-\t  auto [__in,__out]\n-\t    = ranges::__copy_or_move<_IsMove>(std::__niter_base(__first),\n-\t\t\t\t\t      std::__niter_base(__last),\n-\t\t\t\t\t      std::__niter_base(__result));\n-\t  return {std::__niter_wrap(__first, std::move(__in)),\n-\t\t  std::__niter_wrap(__result, std::move(__out))};\n-\t}\n-      else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n-\t{\n-\t  using _ValueTypeI = iter_value_t<_Iter>;\n-\t  using _ValueTypeO = iter_value_t<_Out>;\n-\t  constexpr bool __use_memmove\n-\t    = (is_trivially_copyable_v<_ValueTypeI>\n-\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n-\t       && is_pointer_v<_Iter>\n-\t       && is_pointer_v<_Out>);\n-\n-\t  if constexpr (__use_memmove)\n-\t    {\n-\t      static_assert(_IsMove\n-\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n-\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n-\t      auto __num = __last - __first;\n-\t      if (__num)\n-\t\tstd::__memmove<_IsMove>(__result, __first, __num);\n-\t      return {__first + __num, __result + __num};\n-\t    }\n-\t  else\n-\t    {\n-\t      for (auto __n = __last - __first; __n > 0; --__n)\n-\t\t{\n-\t\t  if constexpr (_IsMove)\n-\t\t    *__result = std::move(*__first);\n-\t\t  else\n-\t\t    *__result = *__first;\n-\t\t  ++__first;\n-\t\t  ++__result;\n-\t\t}\n-\t      return {std::move(__first), std::move(__result)};\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  while (__first != __last)\n-\t    {\n-\t      if constexpr (_IsMove)\n-\t\t*__result = std::move(*__first);\n-\t      else\n-\t\t*__result = *__first;\n-\t      ++__first;\n-\t      ++__result;\n-\t    }\n-\t  return {std::move(__first), std::move(__result)};\n-\t}\n-    }\n-\n-  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   weakly_incrementable _Out>\n-    requires indirectly_copyable<_Iter, _Out>\n-    constexpr copy_result<_Iter, _Out>\n-    copy(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      return ranges::__copy_or_move<false>(std::move(__first),\n-\t\t\t\t\t   std::move(__last),\n-\t\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<input_range _Range, weakly_incrementable _Out>\n-    requires indirectly_copyable<iterator_t<_Range>, _Out>\n-    constexpr copy_result<safe_iterator_t<_Range>, _Out>\n-    copy(_Range&& __r, _Out __result)\n-    {\n-      return ranges::copy(ranges::begin(__r), ranges::end(__r),\n-\t\t\t  std::move(__result));\n-    }\n-\n-  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   weakly_incrementable _Out>\n-    requires indirectly_movable<_Iter, _Out>\n-    constexpr move_result<_Iter, _Out>\n-    move(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      return ranges::__copy_or_move<true>(std::move(__first),\n-\t\t\t\t\t  std::move(__last),\n-\t\t\t\t\t  std::move(__result));\n-    }\n-\n-  template<input_range _Range, weakly_incrementable _Out>\n-    requires indirectly_movable<iterator_t<_Range>, _Out>\n-    constexpr move_result<safe_iterator_t<_Range>, _Out>\n-    move(_Range&& __r, _Out __result)\n-    {\n-      return ranges::move(ranges::begin(__r), ranges::end(__r),\n-\t\t\t  std::move(__result));\n-    }\n-\n-  template<bool _IsMove,\n-\t   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   bidirectional_iterator _Out>\n-    requires (_IsMove\n-\t      ? indirectly_movable<_Iter, _Out>\n-\t      : indirectly_copyable<_Iter, _Out>)\n-    constexpr conditional_t<_IsMove,\n-\t\t\t    move_backward_result<_Iter, _Out>,\n-\t\t\t    copy_backward_result<_Iter, _Out>>\n-    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::copy_backward/std::move_backward.\n-      constexpr bool __normal_iterator_p\n-\t= (__detail::__is_normal_iterator<_Iter>\n-\t   || __detail::__is_normal_iterator<_Out>);\n-      constexpr bool __reverse_p\n-\t= (__detail::__is_reverse_iterator<_Iter>\n-\t   && __detail::__is_reverse_iterator<_Out>);\n-      if constexpr (__reverse_p)\n-\t{\n-\t  auto [__in,__out]\n-\t    = ranges::__copy_or_move<_IsMove>(__last.base(),\n-\t\t\t\t\t      __first.base(),\n-\t\t\t\t\t      __result.base());\n-\t  return {reverse_iterator{std::move(__in)},\n-\t\t  reverse_iterator{std::move(__out)}};\n-\t}\n-      else if constexpr (__normal_iterator_p)\n-\t{\n-\t  auto [__in,__out]\n-\t    = ranges::__copy_or_move_backward<_IsMove>\n-\t      (std::__niter_base(__first),\n-\t       std::__niter_base(__last),\n-\t       std::__niter_base(__result));\n-\t  return {std::__niter_wrap(__first, std::move(__in)),\n-\t\t  std::__niter_wrap(__result, std::move(__out))};\n-\t}\n-      else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n-\t{\n-\t  using _ValueTypeI = iter_value_t<_Iter>;\n-\t  using _ValueTypeO = iter_value_t<_Out>;\n-\t  constexpr bool __use_memmove\n-\t    = (is_trivially_copyable_v<_ValueTypeI>\n-\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n-\t       && is_pointer_v<_Iter>\n-\t       && is_pointer_v<_Out>);\n-\t  if constexpr (__use_memmove)\n-\t    {\n-\t      static_assert(_IsMove\n-\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n-\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n-\t      auto __num = __last - __first;\n-\t      if (__num)\n-\t\tstd::__memmove<_IsMove>(__result - __num, __first, __num);\n-\t      return {__first + __num, __result - __num};\n-\t    }\n-\t  else\n-\t    {\n-\t      auto __lasti = ranges::next(__first, __last);\n-\t      auto __tail = __lasti;\n-\n-\t      for (auto __n = __last - __first; __n > 0; --__n)\n-\t\t{\n-\t\t  --__tail;\n-\t\t  --__result;\n-\t\t  if constexpr (_IsMove)\n-\t\t    *__result = std::move(*__tail);\n-\t\t  else\n-\t\t    *__result = *__tail;\n-\t\t}\n-\t      return {std::move(__lasti), std::move(__result)};\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  auto __lasti = ranges::next(__first, __last);\n-\t  auto __tail = __lasti;\n-\n-\t  while (__first != __tail)\n-\t    {\n-\t      --__tail;\n-\t      --__result;\n-\t      if constexpr (_IsMove)\n-\t\t*__result = std::move(*__tail);\n-\t      else\n-\t\t*__result = *__tail;\n-\t    }\n-\t  return {std::move(__lasti), std::move(__result)};\n-\t}\n-    }\n-\n-  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   bidirectional_iterator _Iter2>\n-    requires indirectly_copyable<_Iter1, _Iter2>\n-    constexpr copy_backward_result<_Iter1, _Iter2>\n-    copy_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n-    {\n-      return ranges::__copy_or_move_backward<false>(std::move(__first),\n-\t\t\t\t\t\t    std::move(__last),\n-\t\t\t\t\t\t    std::move(__result));\n-    }\n-\n-  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n-    requires indirectly_copyable<iterator_t<_Range>, _Iter>\n-    constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>\n-    copy_backward(_Range&& __r, _Iter __result)\n-    {\n-      return ranges::copy_backward(ranges::begin(__r), ranges::end(__r),\n-\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   bidirectional_iterator _Iter2>\n-    requires indirectly_movable<_Iter1, _Iter2>\n-    constexpr move_backward_result<_Iter1, _Iter2>\n-    move_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n-    {\n-      return ranges::__copy_or_move_backward<true>(std::move(__first),\n-\t\t\t\t\t\t   std::move(__last),\n-\t\t\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n-    requires indirectly_movable<iterator_t<_Range>, _Iter>\n-    constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>\n-    move_backward(_Range&& __r, _Iter __result)\n-    {\n-      return ranges::move_backward(ranges::begin(__r), ranges::end(__r),\n-\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<typename _Iter, typename _Out>\n-    using copy_n_result = copy_result<_Iter, _Out>;\n-\n-  template<input_iterator _Iter, weakly_incrementable _Out>\n-    requires indirectly_copyable<_Iter, _Out>\n-    constexpr copy_n_result<_Iter, _Out>\n-    copy_n(_Iter __first, iter_difference_t<_Iter> __n, _Out __result)\n-    {\n-      if constexpr (random_access_iterator<_Iter>)\n-\treturn ranges::copy(__first, __first + __n, std::move(__result));\n-      else\n-\t{\n-\t  for (; __n > 0; --__n, (void)++__result, (void)++__first)\n-\t    *__result = *__first;\n-\t  return {std::move(__first), std::move(__result)};\n-\t}\n-    }\n-\n   template<typename _Iter, typename _Out>\n     using copy_if_result = copy_result<_Iter, _Out>;\n \n@@ -1434,70 +992,6 @@ namespace ranges\n \t\t\t\t     __new_value, std::move(__proj));\n     }\n \n-  template<typename _Tp, output_iterator<const _Tp&> _Out>\n-    constexpr _Out\n-    fill_n(_Out __first, iter_difference_t<_Out> __n, const _Tp& __value)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::fill_n\n-      if (__n <= 0)\n-\treturn __first;\n-\n-      // TODO: is __is_byte the best condition?\n-      if constexpr (is_pointer_v<_Out> && __is_byte<_Tp>::__value)\n-\t{\n-\t  __builtin_memset(__first, static_cast<unsigned char>(__value), __n);\n-\t  return __first + __n;\n-\t}\n-      else if constexpr (is_scalar_v<_Tp>)\n-\t{\n-\t  const auto __tmp = __value;\n-\t  for (; __n > 0; --__n, (void)++__first)\n-\t    *__first = __tmp;\n-\t  return __first;\n-\t}\n-      else\n-\t{\n-\t  for (; __n > 0; --__n, (void)++__first)\n-\t    *__first = __value;\n-\t  return __first;\n-\t}\n-    }\n-\n-  template<typename _Tp,\n-\t   output_iterator<const _Tp&> _Out, sentinel_for<_Out> _Sent>\n-    constexpr _Out\n-    fill(_Out __first, _Sent __last, const _Tp& __value)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::fill\n-      if constexpr (sized_sentinel_for<_Sent, _Out>)\n-\t{\n-\t  const auto __len = __last - __first;\n-\t  return ranges::fill_n(__first, __len, __value);\n-\t}\n-      else if constexpr (is_scalar_v<_Tp>)\n-\t{\n-\t  const auto __tmp = __value;\n-\t  for (; __first != __last; ++__first)\n-\t    *__first = __tmp;\n-\t  return __first;\n-\t}\n-      else\n-\t{\n-\t  for (; __first != __last; ++__first)\n-\t    *__first = __value;\n-\t  return __first;\n-\t}\n-    }\n-\n-  template<typename _Tp, output_range<const _Tp&> _Range>\n-    constexpr safe_iterator_t<_Range>\n-    fill(_Range&& __r, const _Tp& __value)\n-    {\n-      return ranges::fill(ranges::begin(__r), ranges::end(__r), __value);\n-    }\n-\n   template<input_or_output_iterator _Out, copy_constructible _Fp>\n     requires invocable<_Fp&>\n       && indirectly_writable<_Out, invoke_result_t<_Fp&>>"}, {"sha": "f63c032cf0bb937ede7dc5b87dda18d5a0c07127", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "patch": "@@ -0,0 +1,556 @@\n+// Core algorithmic facilities -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/ranges_algobase.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{algorithm}\n+ */\n+\n+#ifndef _RANGES_ALGOBASE_H\n+#define _RANGES_ALGOBASE_H 1\n+\n+#if __cplusplus > 201703L\n+\n+#include <cmath>\n+#include <compare>\n+#include <iterator>\n+// #include <bits/range_concepts.h>\n+#include <ranges>\n+#include <bits/invoke.h>\n+#include <bits/cpp_type_traits.h> // __is_byte\n+\n+#if __cpp_lib_concepts\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges\n+{\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      constexpr inline bool __is_normal_iterator = false;\n+\n+    template<typename _Iterator, typename _Container>\n+      constexpr inline bool\n+\t__is_normal_iterator<__gnu_cxx::__normal_iterator<_Iterator,\n+\t\t\t\t\t\t\t  _Container>> = true;\n+\n+    template<typename _Tp>\n+      constexpr inline bool __is_reverse_iterator = false;\n+\n+    template<typename _Iterator>\n+      constexpr inline bool\n+\t__is_reverse_iterator<reverse_iterator<_Iterator>> = true;\n+\n+    template<typename _Tp>\n+      constexpr inline bool __is_move_iterator = false;\n+\n+    template<typename _Iterator>\n+      constexpr inline bool\n+\t__is_move_iterator<move_iterator<_Iterator>> = true;\n+  } // namespace __detail\n+\n+  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t   typename _Pred, typename _Proj1, typename _Proj2>\n+    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+    constexpr bool\n+    __equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n+\t    _Pred __pred, _Proj1 __proj1, _Proj2 __proj2)\n+    {\n+      // TODO: implement more specializations to at least have parity with\n+      // std::equal.\n+      constexpr bool __sized_iters\n+\t= (sized_sentinel_for<_Sent1, _Iter1>\n+\t   && sized_sentinel_for<_Sent2, _Iter2>);\n+      if constexpr (__sized_iters)\n+\t{\n+\t  auto __d1 = ranges::distance(__first1, __last1);\n+\t  auto __d2 = ranges::distance(__first2, __last2);\n+\t  if (__d1 != __d2)\n+\t    return false;\n+\n+\t  using _ValueType1 = iter_value_t<_Iter1>;\n+\t  using _ValueType2 = iter_value_t<_Iter2>;\n+\t  constexpr bool __use_memcmp\n+\t    = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)\n+\t       && is_same_v<_ValueType1, _ValueType2>\n+\t       && is_pointer_v<_Iter1>\n+\t       && is_pointer_v<_Iter2>\n+\t       && is_same_v<_Pred, ranges::equal_to>\n+\t       && is_same_v<_Proj1, identity>\n+\t       && is_same_v<_Proj2, identity>);\n+\t  if constexpr (__use_memcmp)\n+\t    {\n+\t      if (const size_t __len = (__last1 - __first1))\n+\t\treturn !std::__memcmp(__first1, __first2, __len);\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      for (; __first1 != __last1; ++__first1, (void)++__first2)\n+\t\tif (!(bool)std::__invoke(__pred,\n+\t\t\t\t\t std::__invoke(__proj1, *__first1),\n+\t\t\t\t\t std::__invoke(__proj2, *__first2)))\n+\t\t  return false;\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (; __first1 != __last1 && __first2 != __last2;\n+\t       ++__first1, (void)++__first2)\n+\t    if (!(bool)std::__invoke(__pred,\n+\t\t\t\t     std::__invoke(__proj1, *__first1),\n+\t\t\t\t     std::__invoke(__proj2, *__first2)))\n+\t      return false;\n+\t  return __first1 == __last1 && __first2 == __last2;\n+\t}\n+    }\n+\n+  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t   typename _Pred = ranges::equal_to,\n+\t   typename _Proj1 = identity, typename _Proj2 = identity>\n+    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+    constexpr bool\n+    equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n+\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n+    {\n+      return ranges::__equal(std::__niter_base(std::move(__first1)),\n+\t\t\t     std::__niter_base(std::move(__last1)),\n+\t\t\t     std::__niter_base(std::move(__first2)),\n+\t\t\t     std::__niter_base(std::move(__last2)),\n+\t\t\t     std::move(__pred),\n+\t\t\t     std::move(__proj1), std::move(__proj2));\n+    }\n+\n+  template<input_range _Range1, input_range _Range2,\n+\t   typename _Pred = ranges::equal_to,\n+\t   typename _Proj1 = identity, typename _Proj2 = identity>\n+    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n+\t\t\t\t   _Pred, _Proj1, _Proj2>\n+    constexpr bool\n+    equal(_Range1&& __r1, _Range2&& __r2,\n+\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n+    {\n+      return ranges::equal(ranges::begin(__r1), ranges::end(__r1),\n+\t\t\t   ranges::begin(__r2), ranges::end(__r2),\n+\t\t\t   std::move(__pred),\n+\t\t\t   std::move(__proj1), std::move(__proj2));\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    struct copy_result\n+    {\n+      [[no_unique_address]] _Iter in;\n+      [[no_unique_address]] _Out out;\n+\n+      template<typename _Iter2, typename _Out2>\n+\trequires convertible_to<const _Iter&, _Iter2>\n+\t  && convertible_to<const _Out&, _Out2>\n+\toperator copy_result<_Iter2, _Out2>() const &\n+\t{ return {in, out}; }\n+\n+      template<typename _Iter2, typename _Out2>\n+\trequires convertible_to<_Iter, _Iter2>\n+\t  && convertible_to<_Out, _Out2>\n+\toperator copy_result<_Iter2, _Out2>() &&\n+\t{ return {std::move(in), std::move(out)}; }\n+    };\n+\n+  template<typename _Iter, typename _Out>\n+    using move_result = copy_result<_Iter, _Out>;\n+\n+  template<typename _Iter1, typename _Iter2>\n+    using move_backward_result = copy_result<_Iter1, _Iter2>;\n+\n+  template<typename _Iter1, typename _Iter2>\n+    using copy_backward_result = copy_result<_Iter1, _Iter2>;\n+\n+  template<bool _IsMove,\n+\t   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t   bidirectional_iterator _Out>\n+    requires (_IsMove\n+\t      ? indirectly_movable<_Iter, _Out>\n+\t      : indirectly_copyable<_Iter, _Out>)\n+    constexpr conditional_t<_IsMove,\n+\t\t\t    move_backward_result<_Iter, _Out>,\n+\t\t\t    copy_backward_result<_Iter, _Out>>\n+    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result);\n+\n+  template<bool _IsMove,\n+\t   input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t   weakly_incrementable _Out>\n+    requires (_IsMove\n+\t      ? indirectly_movable<_Iter, _Out>\n+\t      : indirectly_copyable<_Iter, _Out>)\n+    constexpr conditional_t<_IsMove,\n+\t\t\t    move_result<_Iter, _Out>,\n+\t\t\t    copy_result<_Iter, _Out>>\n+    __copy_or_move(_Iter __first, _Sent __last, _Out __result)\n+    {\n+      // TODO: implement more specializations to be at least on par with\n+      // std::copy/std::move.\n+      constexpr bool __normal_iterator_p\n+\t= (__detail::__is_normal_iterator<_Iter>\n+\t   || __detail::__is_normal_iterator<_Out>);\n+      constexpr bool __reverse_p\n+\t= (__detail::__is_reverse_iterator<_Iter>\n+\t   && __detail::__is_reverse_iterator<_Out>);\n+      constexpr bool __move_iterator_p = __detail::__is_move_iterator<_Iter>;\n+      if constexpr (__move_iterator_p)\n+\t{\n+\t  auto [__in, __out]\n+\t    = ranges::__copy_or_move<true>(std::move(__first).base(),\n+\t\t\t\t\t   std::move(__last).base(),\n+\t\t\t\t\t   std::move(__result));\n+\t  return {move_iterator{std::move(__in)}, std::move(__out)};\n+\t}\n+      else if constexpr (__reverse_p)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move_backward<_IsMove>(__last.base(),\n+\t\t\t\t\t\t       __first.base(),\n+\t\t\t\t\t\t       __result.base());\n+\t  return {reverse_iterator{std::move(__in)},\n+\t\t  reverse_iterator{std::move(__out)}};\n+\t}\n+      else if constexpr (__normal_iterator_p)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move<_IsMove>(std::__niter_base(__first),\n+\t\t\t\t\t      std::__niter_base(__last),\n+\t\t\t\t\t      std::__niter_base(__result));\n+\t  return {std::__niter_wrap(__first, std::move(__in)),\n+\t\t  std::__niter_wrap(__result, std::move(__out))};\n+\t}\n+      else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n+\t{\n+\t  using _ValueTypeI = iter_value_t<_Iter>;\n+\t  using _ValueTypeO = iter_value_t<_Out>;\n+\t  constexpr bool __use_memmove\n+\t    = (is_trivially_copyable_v<_ValueTypeI>\n+\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n+\t       && is_pointer_v<_Iter>\n+\t       && is_pointer_v<_Out>);\n+\n+\t  if constexpr (__use_memmove)\n+\t    {\n+\t      static_assert(_IsMove\n+\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n+\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n+\t      auto __num = __last - __first;\n+\t      if (__num)\n+\t\tstd::__memmove<_IsMove>(__result, __first, __num);\n+\t      return {__first + __num, __result + __num};\n+\t    }\n+\t  else\n+\t    {\n+\t      for (auto __n = __last - __first; __n > 0; --__n)\n+\t\t{\n+\t\t  if constexpr (_IsMove)\n+\t\t    *__result = std::move(*__first);\n+\t\t  else\n+\t\t    *__result = *__first;\n+\t\t  ++__first;\n+\t\t  ++__result;\n+\t\t}\n+\t      return {std::move(__first), std::move(__result)};\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  while (__first != __last)\n+\t    {\n+\t      if constexpr (_IsMove)\n+\t\t*__result = std::move(*__first);\n+\t      else\n+\t\t*__result = *__first;\n+\t      ++__first;\n+\t      ++__result;\n+\t    }\n+\t  return {std::move(__first), std::move(__result)};\n+\t}\n+    }\n+\n+  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t   weakly_incrementable _Out>\n+    requires indirectly_copyable<_Iter, _Out>\n+    constexpr copy_result<_Iter, _Out>\n+    copy(_Iter __first, _Sent __last, _Out __result)\n+    {\n+      return ranges::__copy_or_move<false>(std::move(__first),\n+\t\t\t\t\t   std::move(__last),\n+\t\t\t\t\t   std::move(__result));\n+    }\n+\n+  template<input_range _Range, weakly_incrementable _Out>\n+    requires indirectly_copyable<iterator_t<_Range>, _Out>\n+    constexpr copy_result<safe_iterator_t<_Range>, _Out>\n+    copy(_Range&& __r, _Out __result)\n+    {\n+      return ranges::copy(ranges::begin(__r), ranges::end(__r),\n+\t\t\t  std::move(__result));\n+    }\n+\n+  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t   weakly_incrementable _Out>\n+    requires indirectly_movable<_Iter, _Out>\n+    constexpr move_result<_Iter, _Out>\n+    move(_Iter __first, _Sent __last, _Out __result)\n+    {\n+      return ranges::__copy_or_move<true>(std::move(__first),\n+\t\t\t\t\t  std::move(__last),\n+\t\t\t\t\t  std::move(__result));\n+    }\n+\n+  template<input_range _Range, weakly_incrementable _Out>\n+    requires indirectly_movable<iterator_t<_Range>, _Out>\n+    constexpr move_result<safe_iterator_t<_Range>, _Out>\n+    move(_Range&& __r, _Out __result)\n+    {\n+      return ranges::move(ranges::begin(__r), ranges::end(__r),\n+\t\t\t  std::move(__result));\n+    }\n+\n+  template<bool _IsMove,\n+\t   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t   bidirectional_iterator _Out>\n+    requires (_IsMove\n+\t      ? indirectly_movable<_Iter, _Out>\n+\t      : indirectly_copyable<_Iter, _Out>)\n+    constexpr conditional_t<_IsMove,\n+\t\t\t    move_backward_result<_Iter, _Out>,\n+\t\t\t    copy_backward_result<_Iter, _Out>>\n+    __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result)\n+    {\n+      // TODO: implement more specializations to be at least on par with\n+      // std::copy_backward/std::move_backward.\n+      constexpr bool __normal_iterator_p\n+\t= (__detail::__is_normal_iterator<_Iter>\n+\t   || __detail::__is_normal_iterator<_Out>);\n+      constexpr bool __reverse_p\n+\t= (__detail::__is_reverse_iterator<_Iter>\n+\t   && __detail::__is_reverse_iterator<_Out>);\n+      if constexpr (__reverse_p)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move<_IsMove>(__last.base(),\n+\t\t\t\t\t      __first.base(),\n+\t\t\t\t\t      __result.base());\n+\t  return {reverse_iterator{std::move(__in)},\n+\t\t  reverse_iterator{std::move(__out)}};\n+\t}\n+      else if constexpr (__normal_iterator_p)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move_backward<_IsMove>\n+\t      (std::__niter_base(__first),\n+\t       std::__niter_base(__last),\n+\t       std::__niter_base(__result));\n+\t  return {std::__niter_wrap(__first, std::move(__in)),\n+\t\t  std::__niter_wrap(__result, std::move(__out))};\n+\t}\n+      else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n+\t{\n+\t  using _ValueTypeI = iter_value_t<_Iter>;\n+\t  using _ValueTypeO = iter_value_t<_Out>;\n+\t  constexpr bool __use_memmove\n+\t    = (is_trivially_copyable_v<_ValueTypeI>\n+\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n+\t       && is_pointer_v<_Iter>\n+\t       && is_pointer_v<_Out>);\n+\t  if constexpr (__use_memmove)\n+\t    {\n+\t      static_assert(_IsMove\n+\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n+\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n+\t      auto __num = __last - __first;\n+\t      if (__num)\n+\t\tstd::__memmove<_IsMove>(__result - __num, __first, __num);\n+\t      return {__first + __num, __result - __num};\n+\t    }\n+\t  else\n+\t    {\n+\t      auto __lasti = ranges::next(__first, __last);\n+\t      auto __tail = __lasti;\n+\n+\t      for (auto __n = __last - __first; __n > 0; --__n)\n+\t\t{\n+\t\t  --__tail;\n+\t\t  --__result;\n+\t\t  if constexpr (_IsMove)\n+\t\t    *__result = std::move(*__tail);\n+\t\t  else\n+\t\t    *__result = *__tail;\n+\t\t}\n+\t      return {std::move(__lasti), std::move(__result)};\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  auto __lasti = ranges::next(__first, __last);\n+\t  auto __tail = __lasti;\n+\n+\t  while (__first != __tail)\n+\t    {\n+\t      --__tail;\n+\t      --__result;\n+\t      if constexpr (_IsMove)\n+\t\t*__result = std::move(*__tail);\n+\t      else\n+\t\t*__result = *__tail;\n+\t    }\n+\t  return {std::move(__lasti), std::move(__result)};\n+\t}\n+    }\n+\n+  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t   bidirectional_iterator _Iter2>\n+    requires indirectly_copyable<_Iter1, _Iter2>\n+    constexpr copy_backward_result<_Iter1, _Iter2>\n+    copy_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n+    {\n+      return ranges::__copy_or_move_backward<false>(std::move(__first),\n+\t\t\t\t\t\t    std::move(__last),\n+\t\t\t\t\t\t    std::move(__result));\n+    }\n+\n+  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n+    requires indirectly_copyable<iterator_t<_Range>, _Iter>\n+    constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>\n+    copy_backward(_Range&& __r, _Iter __result)\n+    {\n+      return ranges::copy_backward(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t   std::move(__result));\n+    }\n+\n+  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t   bidirectional_iterator _Iter2>\n+    requires indirectly_movable<_Iter1, _Iter2>\n+    constexpr move_backward_result<_Iter1, _Iter2>\n+    move_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n+    {\n+      return ranges::__copy_or_move_backward<true>(std::move(__first),\n+\t\t\t\t\t\t   std::move(__last),\n+\t\t\t\t\t\t   std::move(__result));\n+    }\n+\n+  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n+    requires indirectly_movable<iterator_t<_Range>, _Iter>\n+    constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>\n+    move_backward(_Range&& __r, _Iter __result)\n+    {\n+      return ranges::move_backward(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t   std::move(__result));\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    using copy_n_result = copy_result<_Iter, _Out>;\n+\n+  template<input_iterator _Iter, weakly_incrementable _Out>\n+    requires indirectly_copyable<_Iter, _Out>\n+    constexpr copy_n_result<_Iter, _Out>\n+    copy_n(_Iter __first, iter_difference_t<_Iter> __n, _Out __result)\n+    {\n+      if constexpr (random_access_iterator<_Iter>)\n+\treturn ranges::copy(__first, __first + __n, std::move(__result));\n+      else\n+\t{\n+\t  for (; __n > 0; --__n, (void)++__result, (void)++__first)\n+\t    *__result = *__first;\n+\t  return {std::move(__first), std::move(__result)};\n+\t}\n+    }\n+\n+  template<typename _Tp, output_iterator<const _Tp&> _Out>\n+    constexpr _Out\n+    fill_n(_Out __first, iter_difference_t<_Out> __n, const _Tp& __value)\n+    {\n+      // TODO: implement more specializations to be at least on par with\n+      // std::fill_n\n+      if (__n <= 0)\n+\treturn __first;\n+\n+      // TODO: is __is_byte the best condition?\n+      if constexpr (is_pointer_v<_Out> && __is_byte<_Tp>::__value)\n+\t{\n+\t  __builtin_memset(__first, static_cast<unsigned char>(__value), __n);\n+\t  return __first + __n;\n+\t}\n+      else if constexpr (is_scalar_v<_Tp>)\n+\t{\n+\t  const auto __tmp = __value;\n+\t  for (; __n > 0; --__n, (void)++__first)\n+\t    *__first = __tmp;\n+\t  return __first;\n+\t}\n+      else\n+\t{\n+\t  for (; __n > 0; --__n, (void)++__first)\n+\t    *__first = __value;\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<typename _Tp,\n+\t   output_iterator<const _Tp&> _Out, sentinel_for<_Out> _Sent>\n+    constexpr _Out\n+    fill(_Out __first, _Sent __last, const _Tp& __value)\n+    {\n+      // TODO: implement more specializations to be at least on par with\n+      // std::fill\n+      if constexpr (sized_sentinel_for<_Sent, _Out>)\n+\t{\n+\t  const auto __len = __last - __first;\n+\t  return ranges::fill_n(__first, __len, __value);\n+\t}\n+      else if constexpr (is_scalar_v<_Tp>)\n+\t{\n+\t  const auto __tmp = __value;\n+\t  for (; __first != __last; ++__first)\n+\t    *__first = __tmp;\n+\t  return __first;\n+\t}\n+      else\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    *__first = __value;\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<typename _Tp, output_range<const _Tp&> _Range>\n+    constexpr safe_iterator_t<_Range>\n+    fill(_Range&& __r, const _Tp& __value)\n+    {\n+      return ranges::fill(ranges::begin(__r), ranges::end(__r), __value);\n+    }\n+}\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // concepts\n+#endif // C++20\n+#endif // _RANGES_ALGOBASE_H"}]}