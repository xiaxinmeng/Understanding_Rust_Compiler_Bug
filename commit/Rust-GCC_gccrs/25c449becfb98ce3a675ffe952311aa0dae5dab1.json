{"sha": "25c449becfb98ce3a675ffe952311aa0dae5dab1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVjNDQ5YmVjZmI5OGNlM2E2NzVmZmU5NTIzMTFhYTBkYWU1ZGFiMQ==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-02-04T22:00:36Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-02-04T22:00:36Z"}, "message": "Makefile.am: Added MPN.java and BigInteger.java.\n\n\t* Makefile.am: Added MPN.java and BigInteger.java.\n\t* Makefile.in: Rebuilt.\n\t* gnu/gcj/math/MPN.java: New file.\n\t* java/math/BigInteger.java: New file.\n\nFrom-SVN: r31794", "tree": {"sha": "32dc44df4a2e1888445ef6a33f348ad21fb02700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32dc44df4a2e1888445ef6a33f348ad21fb02700"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25c449becfb98ce3a675ffe952311aa0dae5dab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c449becfb98ce3a675ffe952311aa0dae5dab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c449becfb98ce3a675ffe952311aa0dae5dab1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c449becfb98ce3a675ffe952311aa0dae5dab1/comments", "author": null, "committer": null, "parents": [{"sha": "bff0dc38c2f7a20945942c52039866a82572e5ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bff0dc38c2f7a20945942c52039866a82572e5ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bff0dc38c2f7a20945942c52039866a82572e5ef"}], "stats": {"total": 2444, "additions": 2437, "deletions": 7}, "files": [{"sha": "6d9da1ba0227f6b9c8147ac296a6164e415a1b60", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=25c449becfb98ce3a675ffe952311aa0dae5dab1", "patch": "@@ -1,3 +1,10 @@\n+2000-02-04  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* Makefile.am: Added MPN.java and BigInteger.java.\n+\t* Makefile.in: Rebuilt.\n+\t* gnu/gcj/math/MPN.java: New file.\n+\t* java/math/BigInteger.java: New file.\n+\n 2000-02-04  Tom Tromey  <tromey@cygnus.com>\n \n \t* defineclass.cc (handleMethodsBegin): Allocate _Jv_MethodBase"}, {"sha": "4abbeab42782f17bfee258719ab22fd3dd2f1e71", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=25c449becfb98ce3a675ffe952311aa0dae5dab1", "patch": "@@ -521,6 +521,7 @@ gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n+gnu/gcj/math/MPN.java \\\n gnu/gcj/protocol/file/Connection.java \\\n gnu/gcj/protocol/file/Handler.java \\\n gnu/gcj/protocol/http/Connection.java \\\n@@ -661,6 +662,7 @@ java/lang/reflect/InvocationTargetException.java \\\n java/lang/reflect/Member.java \\\n java/lang/reflect/Method.java \\\n java/lang/reflect/Modifier.java\t\\\n+java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\"}, {"sha": "bf0ffec020314babb4696f7b97f5de2bce8066da", "filename": "libjava/Makefile.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=25c449becfb98ce3a675ffe952311aa0dae5dab1", "patch": "@@ -335,6 +335,7 @@ gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n+gnu/gcj/math/MPN.java \\\n gnu/gcj/protocol/file/Connection.java \\\n gnu/gcj/protocol/file/Handler.java \\\n gnu/gcj/protocol/http/Connection.java \\\n@@ -475,6 +476,7 @@ java/lang/reflect/InvocationTargetException.java \\\n java/lang/reflect/Member.java \\\n java/lang/reflect/Method.java \\\n java/lang/reflect/Modifier.java\t\\\n+java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n@@ -750,7 +752,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/convert/Output_JavaSrc.P \\\n .deps/gnu/gcj/convert/Output_SJIS.P .deps/gnu/gcj/convert/Output_UTF8.P \\\n .deps/gnu/gcj/convert/Output_iconv.P \\\n-.deps/gnu/gcj/convert/UnicodeToBytes.P \\\n+.deps/gnu/gcj/convert/UnicodeToBytes.P .deps/gnu/gcj/math/MPN.P \\\n .deps/gnu/gcj/protocol/file/Connection.P \\\n .deps/gnu/gcj/protocol/file/Handler.P \\\n .deps/gnu/gcj/protocol/http/Connection.P \\\n@@ -869,12 +871,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/w_exp.P .deps/java/lang/w_fmod.P \\\n .deps/java/lang/w_log.P .deps/java/lang/w_pow.P \\\n .deps/java/lang/w_remainder.P .deps/java/lang/w_sqrt.P \\\n-.deps/java/net/BindException.P .deps/java/net/ConnectException.P \\\n-.deps/java/net/ContentHandler.P .deps/java/net/ContentHandlerFactory.P \\\n-.deps/java/net/DatagramPacket.P .deps/java/net/DatagramSocket.P \\\n-.deps/java/net/DatagramSocketImpl.P .deps/java/net/FileNameMap.P \\\n-.deps/java/net/HttpURLConnection.P .deps/java/net/InetAddress.P \\\n-.deps/java/net/JarURLConnection.P \\\n+.deps/java/math/BigInteger.P .deps/java/net/BindException.P \\\n+.deps/java/net/ConnectException.P .deps/java/net/ContentHandler.P \\\n+.deps/java/net/ContentHandlerFactory.P .deps/java/net/DatagramPacket.P \\\n+.deps/java/net/DatagramSocket.P .deps/java/net/DatagramSocketImpl.P \\\n+.deps/java/net/FileNameMap.P .deps/java/net/HttpURLConnection.P \\\n+.deps/java/net/InetAddress.P .deps/java/net/JarURLConnection.P \\\n .deps/java/net/MalformedURLException.P .deps/java/net/MulticastSocket.P \\\n .deps/java/net/NoRouteToHostException.P \\\n .deps/java/net/PlainDatagramSocketImpl.P \\"}, {"sha": "5bbabfdc3fedf6d3956388294ed9aa6f4b2aae99", "filename": "libjava/gnu/gcj/math/MPN.java", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java?ref=25c449becfb98ce3a675ffe952311aa0dae5dab1", "patch": "@@ -0,0 +1,736 @@\n+/* Copyright (C) 1999, 2000  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Included from Kawa 1.6.62 with permission of the author,\n+// Per Bothner <per@bothner.com>.\n+\n+package gnu.gcj.math;\n+\n+/** This contains various low-level routines for unsigned bigints.\n+ * The interfaces match the mpn interfaces in gmp,\n+ * so it should be easy to replace them with fast native functions\n+ * that are trivial wrappers around the mpn_ functions in gmp\n+ * (at least on platforms that use 32-bit \"limbs\").\n+ */\n+\n+public class MPN\n+{\n+  /** Add x[0:size-1] and y, and write the size least\n+   * significant words of the result to dest.\n+   * Return carry, either 0 or 1.\n+   * All values are unsigned.\n+   * This is basically the same as gmp's mpn_add_1. */\n+  public static int add_1 (int[] dest, int[] x, int size, int y)\n+  {\n+    long carry = (long) y & 0xffffffffL;\n+    for (int i = 0;  i < size;  i++)\n+      {\n+\tcarry += ((long) x[i] & 0xffffffffL);\n+\tdest[i] = (int) carry;\n+\tcarry >>= 32;\n+      }\n+    return (int) carry;\n+  }\n+\n+  /** Add x[0:len-1] and y[0:len-1] and write the len least\n+   * significant words of the result to dest[0:len-1].\n+   * All words are treated as unsigned.\n+   * @return the carry, either 0 or 1\n+   * This function is basically the same as gmp's mpn_add_n.\n+   */\n+  public static int add_n (int dest[], int[] x, int[] y, int len)\n+  {\n+    long carry = 0;\n+    for (int i = 0; i < len;  i++)\n+      {\n+\tcarry += ((long) x[i] & 0xffffffffL)\n+\t  + ((long) y[i] & 0xffffffffL);\n+\tdest[i] = (int) carry;\n+\tcarry >>>= 32;\n+      }\n+    return (int) carry;\n+  }\n+\n+  /** Subtract Y[0:size-1] from X[0:size-1], and write\n+   * the size least significant words of the result to dest[0:size-1].\n+   * Return borrow, either 0 or 1.\n+   * This is basically the same as gmp's mpn_sub_n function.\n+   */\n+\n+  public static int sub_n (int[] dest, int[] X, int[] Y, int size)\n+  {\n+    int cy = 0;\n+    for (int i = 0;  i < size;  i++)\n+      {\n+\tint y = Y[i];\n+\tint x = X[i];\n+\ty += cy;\t/* add previous carry to subtrahend */\n+\t// Invert the high-order bit, because: (unsigned) X > (unsigned) Y\n+\t// iff: (int) (X^0x80000000) > (int) (Y^0x80000000).\n+\tcy = (y^0x80000000) < (cy^0x80000000) ? 1 : 0;\n+\ty = x - y;\n+\tcy += (y^0x80000000) > (x ^ 0x80000000) ? 1 : 0;\n+\tdest[i] = y;\n+      }\n+    return cy;\n+  }\n+\n+  /** Multiply x[0:len-1] by y, and write the len least\n+   * significant words of the product to dest[0:len-1].\n+   * Return the most significant word of the product.\n+   * All values are treated as if they were unsigned\n+   * (i.e. masked with 0xffffffffL).\n+   * OK if dest==x (not sure if this is guaranteed for mpn_mul_1).\n+   * This function is basically the same as gmp's mpn_mul_1.\n+   */\n+\n+  public static int mul_1 (int[] dest, int[] x, int len, int y)\n+  {\n+    long yword = (long) y & 0xffffffffL;\n+    long carry = 0;\n+    for (int j = 0;  j < len; j++)\n+      {\n+        carry += ((long) x[j] & 0xffffffffL) * yword;\n+        dest[j] = (int) carry;\n+        carry >>>= 32;\n+      }\n+    return (int) carry;\n+  }\n+\n+  /**\n+   * Multiply x[0:xlen-1] and y[0:ylen-1], and\n+   * write the result to dest[0:xlen+ylen-1].\n+   * The destination has to have space for xlen+ylen words,\n+   * even if the result might be one limb smaller.\n+   * This function requires that xlen >= ylen.\n+   * The destination must be distinct from either input operands.\n+   * All operands are unsigned.\n+   * This function is basically the same gmp's mpn_mul. */\n+\n+  public static void mul (int[] dest,\n+\t\t\t  int[] x, int xlen,\n+\t\t\t  int[] y, int ylen)\n+  {\n+    dest[xlen] = MPN.mul_1 (dest, x, xlen, y[0]);\n+\n+    for (int i = 1;  i < ylen; i++)\n+      {\n+\tlong yword = (long) y[i] & 0xffffffffL;\n+\tlong carry = 0;\n+\tfor (int j = 0;  j < xlen; j++)\n+\t  {\n+\t    carry += ((long) x[j] & 0xffffffffL) * yword\n+\t      + ((long) dest[i+j] & 0xffffffffL);\n+\t    dest[i+j] = (int) carry;\n+\t    carry >>>= 32;\n+\t  }\n+\tdest[i+xlen] = (int) carry;\n+      }\n+  }\n+\n+  /* Divide (unsigned long) N by (unsigned int) D.\n+   * Returns (remainder << 32)+(unsigned int)(quotient).\n+   * Assumes (unsigned int)(N>>32) < (unsigned int)D.\n+   * Code transcribed from gmp-2.0's mpn_udiv_w_sdiv function.\n+   */\n+  public static long udiv_qrnnd (long N, int D)\n+  {\n+    long q, r;\n+    long a1 = N >>> 32;\n+    long a0 = N & 0xffffffffL;\n+    if (D >= 0)\n+      {\n+\tif (a1 < ((D - a1 - (a0 >>> 31)) & 0xffffffffL))\n+\t  {\n+\t    /* dividend, divisor, and quotient are nonnegative */\n+\t    q = N / D;\n+\t    r = N % D;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */\n+\t    long c = N - ((long) D << 31);\n+\t    /* Divide (c1*2^32 + c0) by d */\n+\t    q = c / D;\n+\t    r = c % D;\n+\t    /* Add 2^31 to quotient */\n+\t    q += 1 << 31;\n+\t  }\n+      }\n+    else\n+      {\n+\tlong b1 = D >>> 1;\t/* d/2, between 2^30 and 2^31 - 1 */\n+\t//long c1 = (a1 >> 1); /* A/2 */\n+\t//int c0 = (a1 << 31) + (a0 >> 1);\n+\tlong c = N >>> 1;\n+\tif (a1 < b1 || (a1 >> 1) < b1)\n+\t  {\n+\t    if (a1 < b1)\n+\t      {\n+\t\tq = c / b1;\n+\t\tr = c % b1;\n+\t      }\n+\t    else /* c1 < b1, so 2^31 <= (A/2)/b1 < 2^32 */\n+\t      {\n+\t\tc = ~(c - (b1 << 32));\n+\t\tq = c / b1;  /* (A/2) / (d/2) */\n+\t\tr = c % b1;\n+\t\tq = (~q) & 0xffffffffL;    /* (A/2)/b1 */\n+\t\tr = (b1 - 1) - r; /* r < b1 => new r >= 0 */\n+\t      }\n+\t    r = 2 * r + (a0 & 1);\n+\t    if ((D & 1) != 0)\n+\t      {\n+\t\tif (r >= q) {\n+\t\t        r = r - q;\n+\t\t} else if (q - r <= ((long) D & 0xffffffffL)) {\n+                       r = r - q + D;\n+        \t\tq -= 1;\n+\t\t} else {\n+                       r = r - q + D + D;\n+        \t\tq -= 2;\n+\t\t}\n+\t      }\n+\t  }\n+\telse\t\t\t\t/* Implies c1 = b1 */\n+\t  {\t\t\t\t/* Hence a1 = d - 1 = 2*b1 - 1 */\n+\t    if (a0 >= ((long)(-D) & 0xffffffffL))\n+\t      {\n+\t\tq = -1;\n+\t        r = a0 + D;\n+ \t      }\n+\t    else\n+\t      {\n+\t\tq = -2;\n+\t        r = a0 + D + D;\n+\t      }\n+\t  }\n+      }\n+\n+    return (r << 32) | (q & 0xFFFFFFFFl);\n+  }\n+\n+    /** Divide divident[0:len-1] by (unsigned int)divisor.\n+     * Write result into quotient[0:len-1.\n+     * Return the one-word (unsigned) remainder.\n+     * OK for quotient==dividend.\n+     */\n+\n+  public static int divmod_1 (int[] quotient, int[] dividend,\n+\t\t\t      int len, int divisor)\n+  {\n+    int i = len - 1;\n+    long r = dividend[i];\n+    if ((r & 0xffffffffL) >= ((long)divisor & 0xffffffffL))\n+      r = 0;\n+    else\n+      {\n+\tquotient[i--] = 0;\n+\tr <<= 32;\n+      }\n+\n+    for (;  i >= 0;  i--)\n+      {\n+\tint n0 = dividend[i];\n+\tr = (r & ~0xffffffffL) | (n0 & 0xffffffffL);\n+\tr = udiv_qrnnd (r, divisor);\n+\tquotient[i] = (int) r;\n+      }\n+    return (int)(r >> 32);\n+  }\n+\n+  /* Subtract x[0:len-1]*y from dest[offset:offset+len-1].\n+   * All values are treated as if unsigned.\n+   * @return the most significant word of\n+   * the product, minus borrow-out from the subtraction.\n+   */\n+  public static int submul_1 (int[] dest, int offset, int[] x, int len, int y)\n+  {\n+    long yl = (long) y & 0xffffffffL;\n+    int carry = 0;\n+    int j = 0;\n+    do\n+      {\n+\tlong prod = ((long) x[j] & 0xffffffffL) * yl;\n+\tint prod_low = (int) prod;\n+\tint prod_high = (int) (prod >> 32);\n+\tprod_low += carry;\n+\t// Invert the high-order bit, because: (unsigned) X > (unsigned) Y\n+\t// iff: (int) (X^0x80000000) > (int) (Y^0x80000000).\n+\tcarry = ((prod_low ^ 0x80000000) < (carry ^ 0x80000000) ? 1 : 0)\n+\t  + prod_high;\n+\tint x_j = dest[offset+j];\n+\tprod_low = x_j - prod_low;\n+\tif ((prod_low ^ 0x80000000) > (x_j ^ 0x80000000))\n+\t  carry++;\n+\tdest[offset+j] = prod_low;\n+      }\n+    while (++j < len);\n+    return carry;\n+  }\n+\n+  /** Divide zds[0:nx] by y[0:ny-1].\n+   * The remainder ends up in zds[0:ny-1].\n+   * The quotient ends up in zds[ny:nx].\n+   * Assumes:  nx>ny.\n+   * (int)y[ny-1] < 0  (i.e. most significant bit set)\n+   */\n+\n+  public static void divide (int[] zds, int nx, int[] y, int ny)\n+  {\n+    // This is basically Knuth's formulation of the classical algorithm,\n+    // but translated from in scm_divbigbig in Jaffar's SCM implementation.\n+\n+    // Correspondance with Knuth's notation:\n+    // Knuth's u[0:m+n] == zds[nx:0].\n+    // Knuth's v[1:n] == y[ny-1:0]\n+    // Knuth's n == ny.\n+    // Knuth's m == nx-ny.\n+    // Our nx == Knuth's m+n.\n+\n+    // Could be re-implemented using gmp's mpn_divrem:\n+    // zds[nx] = mpn_divrem (&zds[ny], 0, zds, nx, y, ny).\n+\n+    int j = nx;\n+    do\n+      {                          // loop over digits of quotient\n+\t// Knuth's j == our nx-j.\n+\t// Knuth's u[j:j+n] == our zds[j:j-ny].\n+\tint qhat;  // treated as unsigned\n+\tif (zds[j]==y[ny-1])\n+\t  qhat = -1;  // 0xffffffff\n+\telse\n+\t  {\n+\t    long w = (((long)(zds[j])) << 32) + ((long)zds[j-1] & 0xffffffffL);\n+\t    qhat = (int) udiv_qrnnd (w, y[ny-1]);\n+\t  }\n+\tif (qhat != 0)\n+\t  {\n+\t    int borrow = submul_1 (zds, j - ny, y, ny, qhat);\n+\t    int save = zds[j];\n+\t    long num = ((long)save&0xffffffffL) - ((long)borrow&0xffffffffL);\n+            while (num != 0)\n+\t      {\n+\t\tqhat--;\n+\t\tlong carry = 0;\n+\t\tfor (int i = 0;  i < ny; i++)\n+\t\t  {\n+\t\t    carry += ((long) zds[j-ny+i] & 0xffffffffL)\n+\t\t      + ((long) y[i] & 0xffffffffL);\n+\t\t    zds[j-ny+i] = (int) carry;\n+\t\t    carry >>>= 32;\n+\t\t  }\n+\t\tzds[j] += carry;\n+\t\tnum = carry - 1;\n+\t      }\n+\t  }\n+\tzds[j] = qhat;\n+      } while (--j >= ny);\n+  }\n+\n+  /** Number of digits in the conversion base that always fits in a word.\n+   * For example, for base 10 this is 9, since 10**9 is the\n+   * largest number that fits into a words (assuming 32-bit words).\n+   * This is the same as gmp's __mp_bases[radix].chars_per_limb.\n+   * @param radix the base\n+   * @return number of digits */\n+  public static int chars_per_word (int radix)\n+  {\n+    if (radix < 10)\n+      {\n+\tif (radix < 8)\n+\t  {\n+\t    if (radix <= 2)\n+\t      return 32;\n+\t    else if (radix == 3)\n+\t      return 20;\n+\t    else if (radix == 4)\n+\t      return 16;\n+\t    else\n+\t      return 18 - radix;\n+\t  }\n+\telse\n+\t  return 10;\n+      }\n+    else if (radix < 12)\n+      return 9;\n+    else if (radix <= 16)\n+      return 8;\n+    else if (radix <= 23)\n+      return 7;\n+    else if (radix <= 40)\n+      return 6;\n+    // The following are conservative, but we don't care.\n+    else if (radix <= 256)\n+      return 4;\n+    else\n+      return 1;\n+  }\n+\n+  /** Count the number of leading zero bits in an int. */\n+  public static int count_leading_zeros (int i)\n+  {\n+    if (i == 0)\n+      return 32;\n+    int count = 0;\n+    for (int k = 16;  k > 0;  k = k >> 1) {\n+      int j = i >>> k;\n+      if (j == 0)\n+\tcount += k;\n+      else\n+\ti = j;\n+    }\n+    return count;\n+  }\n+\n+  public static int set_str (int dest[], byte[] str, int str_len, int base)\n+  {\n+    int size = 0;\n+    if ((base & (base - 1)) == 0)\n+      {\n+\t// The base is a power of 2.  Read the input string from\n+\t// least to most significant character/digit.  */\n+\n+\tint next_bitpos = 0;\n+\tint bits_per_indigit = 0;\n+\tfor (int i = base; (i >>= 1) != 0; ) bits_per_indigit++;\n+\tint res_digit = 0;\n+\n+\tfor (int i = str_len;  --i >= 0; )\n+\t  {\n+\t    int inp_digit = str[i];\n+\t    res_digit |= inp_digit << next_bitpos;\n+\t    next_bitpos += bits_per_indigit;\n+\t    if (next_bitpos >= 32)\n+\t      {\n+\t\tdest[size++] = res_digit;\n+\t\tnext_bitpos -= 32;\n+\t\tres_digit = inp_digit >> (bits_per_indigit - next_bitpos);\n+\t      }\n+\t  }\n+\n+\tif (res_digit != 0)\n+\t  dest[size++] = res_digit;\n+      }\n+    else\n+      {\n+\t// General case.  The base is not a power of 2.\n+\tint indigits_per_limb = MPN.chars_per_word (base);\n+\tint str_pos = 0;\n+\n+\twhile (str_pos < str_len)\n+\t  {\n+\t    int chunk = str_len - str_pos;\n+\t    if (chunk > indigits_per_limb)\n+\t      chunk = indigits_per_limb;\n+\t    int res_digit = str[str_pos++];\n+\t    int big_base = base;\n+\n+\t    while (--chunk > 0)\n+\t      {\n+\t\tres_digit = res_digit * base + str[str_pos++];\n+\t\tbig_base *= base;\n+\t      }\n+\n+\t    int cy_limb;\n+\t    if (size == 0)\n+\t      cy_limb = res_digit;\n+\t    else\n+\t      {\n+\t\tcy_limb = MPN.mul_1 (dest, dest, size, big_base);\n+\t\tcy_limb += MPN.add_1 (dest, dest, size, res_digit);\n+\t      }\n+\t    if (cy_limb != 0)\n+\t      dest[size++] = cy_limb;\n+\t  }\n+       }\n+    return size;\n+  }\n+\n+  /** Compare x[0:size-1] with y[0:size-1], treating them as unsigned integers.\n+   * @result -1, 0, or 1 depending on if x<y, x==y, or x>y.\n+   * This is basically the same as gmp's mpn_cmp function.\n+   */\n+  public static int cmp (int[] x, int[] y, int size)\n+  {\n+    while (--size >= 0)\n+      {\n+\tint x_word = x[size];\n+\tint y_word = y[size];\n+\tif (x_word != y_word)\n+\t  {\n+\t    // Invert the high-order bit, because:\n+\t    // (unsigned) X > (unsigned) Y iff\n+\t    // (int) (X^0x80000000) > (int) (Y^0x80000000).\n+\t    return (x_word ^ 0x80000000) > (y_word ^0x80000000) ? 1 : -1;\n+\t  }\n+      }\n+    return 0;\n+  }\n+\n+  /** Compare x[0:xlen-1] with y[0:ylen-1], treating them as unsigned integers.\n+   * @result -1, 0, or 1 depending on if x<y, x==y, or x>y.\n+   */\n+  public static int cmp (int[] x, int xlen, int[] y, int ylen)\n+  {\n+    return xlen > ylen ? 1 : xlen < ylen ? -1 : cmp (x, y, xlen);\n+  }\n+\n+  /* Shift x[x_start:x_start+len-1]count bits to the \"right\"\n+   * (i.e. divide by 2**count).\n+   * Store the len least significant words of the result at dest.\n+   * The bits shifted out to the right are returned.\n+   * OK if dest==x.\n+   * Assumes: 0 < count < 32\n+   */\n+\n+  public static int rshift (int[] dest, int[] x, int x_start,\n+\t\t\t    int len, int count)\n+  {\n+    int count_2 = 32 - count;\n+    int low_word = x[x_start];\n+    int retval = low_word << count_2;\n+    int i = 1;\n+    for (; i < len;  i++)\n+      {\n+\tint high_word = x[x_start+i];\n+\tdest[i-1] = (low_word >>> count) | (high_word << count_2);\n+\tlow_word = high_word;\n+      }\n+    dest[i-1] = low_word >>> count;\n+    return retval;\n+  }\n+\n+  /** Return the long-truncated value of right shifting.\n+  * @param x a two's-complement \"bignum\"\n+  * @param len the number of significant words in x\n+  * @param count the shift count\n+  * @return (long)(x[0..len-1] >> count).\n+  */\n+  public static long rshift_long (int[] x, int len, int count)\n+  {\n+    int wordno = count >> 5;\n+    count &= 31;\n+    int sign = x[len-1] < 0 ? -1 : 0;\n+    int w0 = wordno >= len ? sign : x[wordno];\n+    wordno++;\n+    int w1 = wordno >= len ? sign : x[wordno];\n+    if (count != 0)\n+      {\n+\twordno++;\n+\tint w2 = wordno >= len ? sign : x[wordno];\n+\tw0 = (w0 >>> count) | (w1 << (32-count));\n+\tw1 = (w1 >>> count) | (w2 << (32-count));\n+      }\n+    return ((long)w1 << 32) | ((long)w0 & 0xffffffffL);\n+  }\n+\n+  /* Shift x[0:len-1]count bits to the \"right\" (i.e. divide by 2**count).\n+   * Store the len least significant words of the result at dest.\n+   * OK if dest==x.\n+   * OK if count > 32 (but must be >= 0).\n+   */\n+  public static void rshift (int[] dest, int[] x, int len, int count)\n+  {\n+    int word_count = count >> 5;\n+    count &= 31;\n+    rshift (dest, x, word_count, len, count);\n+    while (word_count < len)\n+      dest[word_count++] = 0;\n+  }\n+\n+  /* Shift x[0:len-1] left by count bits, and store the len least\n+   * significant words of the result in dest[d_offset:d_offset+len-1].\n+   * Return the bits shifted out from the most significant digit.\n+   * Assumes 0 < count < 32.\n+   * OK if dest==x.\n+   */\n+\n+  public static int lshift (int[] dest, int d_offset,\n+\t\t\t    int[] x, int len, int count)\n+  {\n+    int count_2 = 32 - count;\n+    int i = len - 1;\n+    int high_word = x[i];\n+    int retval = high_word >>> count_2;\n+    d_offset++;\n+    while (--i >= 0)\n+      {\n+\tint low_word = x[i];\n+\tdest[d_offset+i] = (high_word << count) | (low_word >>> count_2);\n+\thigh_word = low_word;\n+      }\n+    dest[d_offset+i] = high_word << count;\n+    return retval;\n+  }\n+\n+  /** Return least i such that word&(1<<i). Assumes word!=0. */\n+\n+  static int findLowestBit (int word)\n+  {\n+    int i = 0;\n+    while ((word & 0xF) == 0)\n+      {\n+\tword >>= 4;\n+\ti += 4;\n+      }\n+    if ((word & 3) == 0)\n+      {\n+\tword >>= 2;\n+\ti += 2;\n+      }\n+    if ((word & 1) == 0)\n+      i += 1;\n+    return i;\n+  }\n+\n+  /** Return least i such that words & (1<<i). Assumes there is such an i. */\n+\n+  static int findLowestBit (int[] words)\n+  {\n+    for (int i = 0;  ; i++)\n+      {\n+\tif (words[i] != 0)\n+\t  return 32 * i + findLowestBit (words[i]);\n+      }\n+  }\n+\n+  /** Calculate Greatest Common Divisior of x[0:len-1] and y[0:len-1].\n+    * Assumes both arguments are non-zero.\n+    * Leaves result in x, and returns len of result.\n+    * Also destroys y (actually sets it to a copy of the result). */\n+\n+  public static int gcd (int[] x, int[] y, int len)\n+  {\n+    int i, word;\n+    // Find sh such that both x and y are divisible by 2**sh.\n+    for (i = 0; ; i++)\n+      {\n+\tword = x[i] | y[i];\n+\tif (word != 0)\n+\t  {\n+\t    // Must terminate, since x and y are non-zero.\n+\t    break;\n+\t  }\n+      }\n+    int initShiftWords = i;\n+    int initShiftBits = findLowestBit (word);\n+    // Logically: sh = initShiftWords * 32 + initShiftBits\n+\n+    // Temporarily devide both x and y by 2**sh.\n+    len -= initShiftWords;\n+    MPN.rshift (x, x, initShiftWords, len, initShiftBits);\n+    MPN.rshift (y, y, initShiftWords, len, initShiftBits);\n+\n+    int[] odd_arg; /* One of x or y which is odd. */\n+    int[] other_arg; /* The other one can be even or odd. */\n+    if ((x[0] & 1) != 0)\n+      {\n+\todd_arg = x;\n+\tother_arg = y;\n+      }\n+    else\n+      {\n+\todd_arg = y;\n+\tother_arg = x;\n+      }\n+\n+    for (;;)\n+      {\n+\t// Shift other_arg until it is odd; this doesn't\n+\t// affect the gcd, since we divide by 2**k, which does not\n+\t// divide odd_arg.\n+\tfor (i = 0; other_arg[i] == 0; ) i++;\n+\tif (i > 0)\n+\t  {\n+\t    int j;\n+\t    for (j = 0; j < len-i; j++)\n+\t\tother_arg[j] = other_arg[j+i];\n+\t    for ( ; j < len; j++)\n+\t      other_arg[j] = 0;\n+\t  }\n+\ti = findLowestBit(other_arg[0]);\n+\tif (i > 0)\n+\t  MPN.rshift (other_arg, other_arg, 0, len, i);\n+\n+\t// Now both odd_arg and other_arg are odd.\n+\n+\t// Subtract the smaller from the larger.\n+\t// This does not change the result, since gcd(a-b,b)==gcd(a,b).\n+\ti = MPN.cmp(odd_arg, other_arg, len);\n+\tif (i == 0)\n+\t    break;\n+\tif (i > 0)\n+\t  { // odd_arg > other_arg\n+\t    MPN.sub_n (odd_arg, odd_arg, other_arg, len);\n+\t    // Now odd_arg is even, so swap with other_arg;\n+\t    int[] tmp = odd_arg; odd_arg = other_arg; other_arg = tmp;\n+\t  }\n+\telse\n+\t  { // other_arg > odd_arg\n+\t    MPN.sub_n (other_arg, other_arg, odd_arg, len);\n+\t}\n+\twhile (odd_arg[len-1] == 0 && other_arg[len-1] == 0)\n+\t  len--;\n+    }\n+    if (initShiftWords + initShiftBits > 0)\n+      {\n+\tif (initShiftBits > 0)\n+\t  {\n+\t    int sh_out = MPN.lshift (x, initShiftWords, x, len, initShiftBits);\n+\t    if (sh_out != 0)\n+\t      x[(len++)+initShiftWords] = sh_out;\n+\t  }\n+\telse\n+\t  {\n+\t    for (i = len; --i >= 0;)\n+\t      x[i+initShiftWords] = x[i];\n+\t  }\n+\tfor (i = initShiftWords;  --i >= 0; )\n+\t  x[i] = 0;\n+\tlen += initShiftWords;\n+      }\n+    return len;\n+  }\n+\n+  public static int intLength (int i)\n+  {\n+    return 32 - count_leading_zeros (i < 0 ? ~i : i);\n+  }\n+\n+  /** Calcaulte the Common Lisp \"integer-length\" function.\n+   * Assumes input is canonicalized:  len==IntNum.wordsNeeded(words,len) */\n+  public static int intLength (int[] words, int len)\n+  {\n+    len--;\n+    return intLength (words[len]) + 32 * len;\n+  }\n+\n+  /* DEBUGGING:\n+  public static void dprint (IntNum x)\n+  {\n+    if (x.words == null)\n+      System.err.print(Long.toString((long) x.ival & 0xffffffffL, 16));\n+    else\n+      dprint (System.err, x.words, x.ival);\n+  }\n+  public static void dprint (int[] x) { dprint (System.err, x, x.length); }\n+  public static void dprint (int[] x, int len) { dprint (System.err, x, len); }\n+  public static void dprint (java.io.PrintStream ps, int[] x, int len)\n+  {\n+    ps.print('(');\n+    for (int i = 0;  i < len; i++)\n+      {\n+\tif (i > 0)\n+\t  ps.print (' ');\n+\tps.print (\"#x\" + Long.toString ((long) x[i] & 0xffffffffL, 16));\n+      }\n+    ps.print(')');\n+  }\n+  */\n+}"}, {"sha": "c634ebb5365ec0d683c8f1d19d18c4ccea6b255b", "filename": "libjava/java/math/BigInteger.java", "status": "added", "additions": 1683, "deletions": 0, "changes": 1683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2Fjava%2Fmath%2FBigInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c449becfb98ce3a675ffe952311aa0dae5dab1/libjava%2Fjava%2Fmath%2FBigInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigInteger.java?ref=25c449becfb98ce3a675ffe952311aa0dae5dab1", "patch": "@@ -0,0 +1,1683 @@\n+// BigInteger.java -- an arbitrary-precision integer\n+\n+/* Copyright (C) 1999, 2000  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.math;\n+import gnu.gcj.math.*;\n+import java.util.Random;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date December 20, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * \n+ * Based primarily on IntNum.java by Per Bothner <per@bothner.com>\n+ * (found in Kawa 1.6.62).\n+ *\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class BigInteger extends Number implements Comparable\n+{\n+  /** All integers are stored in 2's-complement form.\n+   * If words == null, the ival is the value of this BigInteger.\n+   * Otherwise, the first ival elements of words make the value\n+   * of this BigInteger, stored in little-endian order, 2's-complement form. */\n+  public int ival;\n+  public int[] words;\n+\n+\n+  /** We pre-allocate integers in the range minFixNum..maxFixNum. */\n+  private static final int minFixNum = -100;\n+  private static final int maxFixNum = 1024;\n+  private static final int numFixNum = maxFixNum-minFixNum+1;\n+  private static final BigInteger[] smallFixNums = new BigInteger[numFixNum];\n+\n+  static {\n+    for (int i = numFixNum;  --i >= 0; )\n+      smallFixNums[i] = new BigInteger(i + minFixNum);\n+  }\n+\n+  // JDK1.2\n+  public static final BigInteger ZERO = smallFixNums[-minFixNum];\n+\n+  // JDK1.2\n+  public static final BigInteger ONE = smallFixNums[1 - minFixNum];\n+\n+  /* Rounding modes: */\n+  private static final int FLOOR = 1;\n+  private static final int CEILING = 2;\n+  private static final int TRUNCATE = 3;\n+  private static final int ROUND = 4;\n+\n+  private BigInteger()\n+  {\n+  }\n+\n+  /* Create a new (non-shared) BigInteger, and initialize to an int. */\n+  private BigInteger(int value)\n+  {\n+    ival = value;\n+  }\n+\n+  /* Create a new (non-shared) BigInteger, and initialize from a byte array. */\n+  public BigInteger(byte[] val)\n+  {\n+    if (val == null || val.length < 1)\n+      throw new NumberFormatException();\n+\n+    words = byteArrayToIntArray(val, val[0] < 0 ? -1 : 0);\n+    BigInteger result = make(words, words.length);\n+    this.ival = result.ival;\n+    this.words = result.words;\n+  }\n+\n+  public BigInteger(int signum, byte[] magnitude)\n+  {\n+    if (magnitude == null || signum > 1 || signum < -1)\n+      throw new NumberFormatException();\n+\n+    if (signum == 0)\n+      {\n+\tint i;\n+\tfor (i = magnitude.length - 1; i >= 0 && magnitude[i] == 0; --i)\n+\t  ;\n+\tif (i >= 0)\n+\t  throw new NumberFormatException();\n+        return;\n+      }\n+\n+    // Magnitude is always positive, so don't ever pass a sign of -1.\n+    words = byteArrayToIntArray(magnitude, 0);\n+    BigInteger result = make(words, words.length);\n+    this.ival = result.ival;\n+    this.words = result.words;\n+\n+    if (signum < 0)\n+      setNegative();\n+  }\n+\n+  public BigInteger(int numBits, Random rnd)\n+  {\n+    if (numBits < 0)\n+      throw new IllegalArgumentException();\n+\n+    // Result is always positive so tack on an extra zero word, it will be\n+    // canonicalized out later if necessary.\n+    int nwords = numBits / 32 + 2;\n+    words = new int[nwords];\n+    words[--nwords] = 0;\n+    words[--nwords] = rnd.nextInt() >>> (numBits % 32);\n+    while (--nwords >= 0)\n+      words[nwords] = rnd.nextInt();\n+\n+    BigInteger result = make(words, words.length);\n+    this.ival = result.ival;\n+    this.words = result.words;\n+  }\n+\n+\n+  /** Return a (possibly-shared) BigInteger with a given long value. */\n+  private static BigInteger make(long value)\n+  {\n+    if (value >= minFixNum && value <= maxFixNum)\n+      return smallFixNums[(int)value - minFixNum];\n+    int i = (int) value;\n+    if ((long)i == value)\n+      return new BigInteger(i);\n+    BigInteger result = alloc(2);\n+    result.ival = 2;\n+    result.words[0] = i;\n+    result.words[1] = (int) (value >> 32);\n+    return result;\n+  }\n+\n+  // FIXME: Could simply rename 'make' method above as valueOf while\n+  // changing all instances of 'make'.  Don't do this until this class\n+  // is done as the Kawa class this is based on has 'make' methods\n+  // with other parameters; wait to see if they are used in BigInteger.\n+  public static BigInteger valueOf(long val)\n+  {\n+    return make(val);\n+  }\n+\n+  /** Make a canonicalized BigInteger from an array of words.\n+   * The array may be reused (without copying). */\n+  private static BigInteger make(int[] words, int len)\n+  {\n+    if (words == null)\n+      return make(len);\n+    len = BigInteger.wordsNeeded(words, len);\n+    if (len <= 1)\n+      return len == 0 ? ZERO : make(words[0]);\n+    BigInteger num = new BigInteger();\n+    num.words = words;\n+    num.ival = len;\n+    return num;\n+  }\n+\n+  /** Convert a big-endian byte array to a little-endian array of words. */\n+  private static int[] byteArrayToIntArray(byte[] bytes, int sign)\n+  {\n+    // Determine number of words needed.\n+    int[] words = new int[(bytes.length + 3) / 4 + 1];\n+    int nwords = words.length;\n+\n+    // For simplicity, tack on an extra word of sign at the front,\n+    // it will be canonicalized out later. */\n+    words[--nwords] = sign;\n+\n+    // Create a int out of modulo 4 high order bytes.\n+    int bptr = 0;\n+    int word = sign;\n+    for (int i = bytes.length % 4; i > 0; --i, bptr++)\n+      word = (word << 8) | (((int) bytes[bptr]) & 0xff);\n+    words[--nwords] = word;\n+\n+    // Elements remaining in byte[] is a  multiple of 4.\n+    while (nwords > 0)\n+      words[--nwords] = bytes[bptr++] << 24 |\n+\t\t\t(((int) bytes[bptr++]) & 0xff) << 16 |\n+\t\t\t(((int) bytes[bptr++]) & 0xff) << 8 |\n+\t\t\t(((int) bytes[bptr++]) & 0xff);\n+    return words;\n+  }\n+\n+  /** Allocate a new non-shared BigInteger.\n+   * @param nwords number of words to allocate\n+   */\n+  private static BigInteger alloc(int nwords)\n+  {\n+    if (nwords <= 1)\n+      return new BigInteger();\n+    BigInteger result = new BigInteger();\n+    result.words = new int[nwords];\n+    return result;\n+  }\n+\n+  /** Change words.length to nwords.\n+   * We allow words.length to be upto nwords+2 without reallocating.\n+   */\n+  private void realloc(int nwords)\n+  {\n+    if (nwords == 0)\n+      {\n+\tif (words != null)\n+\t  {\n+\t    if (ival > 0)\n+\t      ival = words[0];\n+\t    words = null;\n+\t  }\n+      }\n+    else if (words == null\n+\t     || words.length < nwords\n+\t     || words.length > nwords + 2)\n+      {\n+\tint[] new_words = new int [nwords];\n+\tif (words == null)\n+\t  {\n+\t    new_words[0] = ival;\n+\t    ival = 1;\n+\t  }\n+\telse\n+\t  {\n+\t    if (nwords < ival)\n+\t      ival = nwords;\n+\t    System.arraycopy(words, 0, new_words, 0, ival);\n+\t  }\n+\twords = new_words;\n+      }\n+  }\n+\n+  private final boolean isNegative()\n+  {\n+    return (words == null ? ival : words[ival - 1]) < 0;\n+  }\n+\n+  public int signum()\n+  {\n+    int top = words == null ? ival : words[ival-1];\n+    return top > 0 ? 1 : top < 0 ? -1 : 0;\n+  }\n+\n+  private static int compareTo(BigInteger x, BigInteger y)\n+  {\n+    if (x.words == null && y.words == null)\n+      return x.ival < y.ival ? -1 : x.ival > y.ival ? 1 : 0;\n+    boolean x_negative = x.isNegative();\n+    boolean y_negative = y.isNegative();\n+    if (x_negative != y_negative)\n+      return x_negative ? -1 : 1;\n+    int x_len = x.words == null ? 1 : x.ival;\n+    int y_len = y.words == null ? 1 : y.ival;\n+    if (x_len != y_len)\n+      return (x_len > y_len) != x_negative ? 1 : -1;\n+    return MPN.cmp(x.words, y.words, x_len);\n+  }\n+\n+  // JDK1.2\n+  public int compareTo(Object obj)\n+  {\n+    if (obj instanceof BigInteger)\n+      return compareTo(this, (BigInteger) obj);\n+    throw new ClassCastException();\n+  }\n+\n+  public int compareTo(BigInteger val)\n+  {\n+    return compareTo(this, val);\n+  }\n+\n+  private final boolean isOdd()\n+  {\n+    int low = words == null ? ival : words[0];\n+    return (low & 1) != 0;\n+  }\n+\n+  private final boolean isZero()\n+  {\n+    return words == null && ival == 0;\n+  }\n+\n+  private final boolean isOne()\n+  {\n+    return words == null && ival == 1;\n+  }\n+\n+  private final boolean isMinusOne()\n+  {\n+    return words == null && ival == -1;\n+  }\n+\n+  /** Calculate how many words are significant in words[0:len-1].\n+   * Returns the least value x such that x>0 && words[0:x-1]==words[0:len-1],\n+   * when words is viewed as a 2's complement integer.\n+   */\n+  private static int wordsNeeded(int[] words, int len)\n+  {\n+    int i = len;\n+    if (i > 0)\n+      {\n+\tint word = words[--i];\n+\tif (word == -1)\n+\t  {\n+\t    while (i > 0 && (word = words[i - 1]) < 0)\n+\t      {\n+\t\ti--;\n+\t\tif (word != -1) break;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    while (word == 0 && i > 0 && (word = words[i - 1]) >= 0)  i--;\n+\t  }\n+      }\n+    return i + 1;\n+  }\n+\n+  private BigInteger canonicalize()\n+  {\n+    if (words != null\n+\t&& (ival = BigInteger.wordsNeeded(words, ival)) <= 1)\n+      {\n+\tif (ival == 1)\n+\t  ival = words[0];\n+\twords = null;\n+      }\n+    if (words == null && ival >= minFixNum && ival <= maxFixNum)\n+      return smallFixNums[(int) ival - minFixNum];\n+    return this;\n+  }\n+\n+  /** Add two ints, yielding an BigInteger. */\n+  private static final BigInteger add(int x, int y)\n+  {\n+    return BigInteger.make((long) x + (long) y);\n+  }\n+\n+  /** Add an BigInteger and an int, yielding a new BigInteger. */\n+  private static BigInteger add(BigInteger x, int y)\n+  {\n+    if (x.words == null)\n+      return BigInteger.add(x.ival, y);\n+    BigInteger result = new BigInteger(0);\n+    result.setAdd(x, y);\n+    return result.canonicalize();\n+  }\n+\n+  /** Set this to the sum of x and y.\n+   * OK if x==this. */\n+  private void setAdd(BigInteger x, int y)\n+  {\n+    if (x.words == null)\n+      {\n+\tset((long) x.ival + (long) y);\n+\treturn;\n+      }\n+    int len = x.ival;\n+    realloc(len + 1);\n+    long carry = y;\n+    for (int i = 0;  i < len;  i++)\n+      {\n+\tcarry += ((long) x.words[i] & 0xffffffffL);\n+\twords[i] = (int) carry;\n+\tcarry >>= 32;\n+      }\n+    if (x.words[len - 1] < 0)\n+      carry--;\n+    words[len] = (int) carry;\n+    ival = wordsNeeded(words, len + 1);\n+  }\n+\n+  /** Destructively add an int to this. */\n+  private final void setAdd(int y)\n+  {\n+    setAdd(this, y);\n+  }\n+\n+  /** Destructively set the value of this to a long. */\n+  private final void set(long y)\n+  {\n+    int i = (int) y;\n+    if ((long) i == y)\n+      {\n+\tival = i;\n+\twords = null;\n+      }\n+    else\n+      {\n+\trealloc(2);\n+\twords[0] = i;\n+\twords[1] = (int) (y >> 32);\n+\tival = 2;\n+      }\n+  }\n+\n+  /** Destructively set the value of this to the given words.\n+  * The words array is reused, not copied. */\n+  private final void set(int[] words, int length)\n+  {\n+    this.ival = length;\n+    this.words = words;\n+  }\n+\n+  /** Destructively set the value of this to that of y. */\n+  private final void set(BigInteger y)\n+  {\n+    if (y.words == null)\n+      set(y.ival);\n+    else if (this != y)\n+      {\n+\trealloc(y.ival);\n+\tSystem.arraycopy(y.words, 0, words, 0, y.ival);\n+\tival = y.ival;\n+      }\n+  }\n+\n+  /** Add two BigIntegers, yielding their sum as another BigInteger. */\n+  private static BigInteger add(BigInteger x, BigInteger y, int k)\n+  {\n+    if (x.words == null && y.words == null)\n+      return BigInteger.make((long) k * (long) y.ival + (long) x.ival);\n+    if (k != 1)\n+      {\n+\tif (k == -1)\n+\t  y = BigInteger.neg(y);\n+\telse\n+\t  y = BigInteger.times(y, BigInteger.make(k));\n+      }\n+    if (x.words == null)\n+      return BigInteger.add(y, x.ival);\n+    if (y.words == null)\n+      return BigInteger.add(x, y.ival);\n+    // Both are big\n+    int len;\n+    if (y.ival > x.ival)\n+      { // Swap so x is longer then y.\n+\tBigInteger tmp = x;  x = y;  y = tmp;\n+      }\n+    BigInteger result = alloc(x.ival + 1);\n+    int i = y.ival;\n+    long carry = MPN.add_n(result.words, x.words, y.words, i);\n+    long y_ext = y.words[i - 1] < 0 ? 0xffffffffL : 0;\n+    for (; i < x.ival;  i++)\n+      {\n+\tcarry += ((long) x.words[i] & 0xffffffffL) + y_ext;;\n+\tresult.words[i] = (int) carry;\n+\tcarry >>>= 32;\n+      }\n+    if (x.words[i - 1] < 0)\n+      y_ext--;\n+    result.words[i] = (int) (carry + y_ext);\n+    result.ival = i+1;\n+    return result.canonicalize();\n+  }\n+\n+  public BigInteger add(BigInteger val)\n+  {\n+    return add(this, val, 1);\n+  }\n+\n+  public BigInteger subtract(BigInteger val)\n+  {\n+    return add(this, val, -1);\n+  }\n+\n+  private static final BigInteger times(BigInteger x, int y)\n+  {\n+    if (y == 0)\n+      return ZERO;\n+    if (y == 1)\n+      return x;\n+    int[] xwords = x.words;\n+    int xlen = x.ival;\n+    if (xwords == null)\n+      return BigInteger.make((long) xlen * (long) y);\n+    boolean negative;\n+    BigInteger result = BigInteger.alloc(xlen + 1);\n+    if (xwords[xlen - 1] < 0)\n+      {\n+\tnegative = true;\n+\tnegate(result.words, xwords, xlen);\n+\txwords = result.words;\n+      }\n+    else\n+      negative = false;\n+    if (y < 0)\n+      {\n+\tnegative = !negative;\n+\ty = -y;\n+      }\n+    result.words[xlen] = MPN.mul_1(result.words, xwords, xlen, y);\n+    result.ival = xlen + 1;\n+    if (negative)\n+      result.setNegative();\n+    return result.canonicalize();\n+  }\n+\n+  private static final BigInteger times(BigInteger x, BigInteger y)\n+  {\n+    if (y.words == null)\n+      return times(x, y.ival);\n+    if (x.words == null)\n+      return times(y, x.ival);\n+    boolean negative = false;\n+    int[] xwords;\n+    int[] ywords;\n+    int xlen = x.ival;\n+    int ylen = y.ival;\n+    if (x.isNegative())\n+      {\n+\tnegative = true;\n+\txwords = new int[xlen];\n+\tnegate(xwords, x.words, xlen);\n+      }\n+    else\n+      {\n+\tnegative = false;\n+\txwords = x.words;\n+      }\n+    if (y.isNegative())\n+      {\n+\tnegative = !negative;\n+\tywords = new int[ylen];\n+\tnegate(ywords, y.words, ylen);\n+      }\n+    else\n+      ywords = y.words;\n+    // Swap if x is shorter then y.\n+    if (xlen < ylen)\n+      {\n+\tint[] twords = xwords;  xwords = ywords;  ywords = twords;\n+\tint tlen = xlen;  xlen = ylen;  ylen = tlen;\n+      }\n+    BigInteger result = BigInteger.alloc(xlen+ylen);\n+    MPN.mul(result.words, xwords, xlen, ywords, ylen);\n+    result.ival = xlen+ylen;\n+    if (negative)\n+      result.setNegative();\n+    return result.canonicalize();\n+  }\n+\n+  public BigInteger multiply(BigInteger y)\n+  {\n+    return times(this, y);\n+  }\n+\n+  private static void divide(long x, long y,\n+\t\t\t     BigInteger quotient, BigInteger remainder,\n+\t\t\t     int rounding_mode)\n+  {\n+    boolean xNegative, yNegative;\n+    if (x < 0)\n+      {\n+\txNegative = true;\n+\tif (x == Long.MIN_VALUE)\n+\t  {\n+\t    divide(BigInteger.make(x), BigInteger.make(y),\n+\t\t   quotient, remainder, rounding_mode);\n+\t    return;\n+\t  }\n+\tx = -x;\n+      }\n+    else\n+      xNegative = false;\n+\n+    if (y < 0)\n+      {\n+\tyNegative = true;\n+\tif (y == Long.MIN_VALUE)\n+\t  {\n+\t    if (rounding_mode == TRUNCATE)\n+\t      { // x != Long.Min_VALUE implies abs(x) < abs(y)\n+\t\tif (quotient != null)\n+\t\t  quotient.set(0);\n+\t\tif (remainder != null)\n+\t\t  remainder.set(x);\n+\t      }\n+\t    else\n+\t      divide(BigInteger.make(x), BigInteger.make(y),\n+\t\t      quotient, remainder, rounding_mode);\n+\t    return;\n+\t  }\n+\ty = -y;\n+      }\n+    else\n+      yNegative = false;\n+\n+    long q = x / y;\n+    long r = x % y;\n+    boolean qNegative = xNegative ^ yNegative;\n+\n+    boolean add_one = false;\n+    if (r != 0)\n+      {\n+\tswitch (rounding_mode)\n+\t  {\n+\t  case TRUNCATE:\n+\t    break;\n+\t  case CEILING:\n+\t  case FLOOR:\n+\t    if (qNegative == (rounding_mode == FLOOR))\n+\t      add_one = true;\n+\t    break;\n+\t  case ROUND:\n+\t    add_one = r > ((y - (q & 1)) >> 1);\n+\t    break;\n+\t  }\n+      }\n+    if (quotient != null)\n+      {\n+\tif (add_one)\n+\t  q++;\n+\tif (qNegative)\n+\t  q = -q;\n+\tquotient.set(q);\n+      }\n+    if (remainder != null)\n+      {\n+\t// The remainder is by definition: X-Q*Y\n+\tif (add_one)\n+\t  {\n+\t    // Subtract the remainder from Y.\n+\t    r = y - r;\n+\t    // In this case, abs(Q*Y) > abs(X).\n+\t    // So sign(remainder) = -sign(X).\n+\t    xNegative = ! xNegative;\n+\t  }\n+\telse\n+\t  {\n+\t    // If !add_one, then: abs(Q*Y) <= abs(X).\n+\t    // So sign(remainder) = sign(X).\n+\t  }\n+\tif (xNegative)\n+\t  r = -r;\n+\tremainder.set(r);\n+      }\n+  }\n+\n+  /** Divide two integers, yielding quotient and remainder.\n+   * @param x the numerator in the division\n+   * @param y the denominator in the division\n+   * @param quotient is set to the quotient of the result (iff quotient!=null)\n+   * @param remainder is set to the remainder of the result\n+   *  (iff remainder!=null)\n+   * @param rounding_mode one of FLOOR, CEILING, TRUNCATE, or ROUND.\n+   */\n+  private static void divide(BigInteger x, BigInteger y,\n+\t\t\t     BigInteger quotient, BigInteger remainder,\n+\t\t\t     int rounding_mode)\n+  {\n+    if ((x.words == null || x.ival <= 2)\n+\t&& (y.words == null || y.ival <= 2))\n+      {\n+\tlong x_l = x.longValue();\n+\tlong y_l = y.longValue();\n+\tif (x_l != Long.MIN_VALUE && y_l != Long.MIN_VALUE)\n+\t  {\n+\t    divide(x_l, y_l, quotient, remainder, rounding_mode);\n+\t    return;\n+\t  }\n+      }\n+\n+    boolean xNegative = x.isNegative();\n+    boolean yNegative = y.isNegative();\n+    boolean qNegative = xNegative ^ yNegative;\n+\n+    int ylen = y.words == null ? 1 : y.ival;\n+    int[] ywords = new int[ylen];\n+    y.getAbsolute(ywords);\n+    while (ylen > 1 && ywords[ylen - 1] == 0)  ylen--;\n+\n+    int xlen = x.words == null ? 1 : x.ival;\n+    int[] xwords = new int[xlen+2];\n+    x.getAbsolute(xwords);\n+    while (xlen > 1 && xwords[xlen-1] == 0)  xlen--;\n+\n+    int qlen, rlen;\n+\n+    int cmpval = MPN.cmp(xwords, xlen, ywords, ylen);\n+    if (cmpval < 0)  // abs(x) < abs(y)\n+      { // quotient = 0;  remainder = num.\n+\tint[] rwords = xwords;  xwords = ywords;  ywords = rwords;\n+\trlen = xlen;  qlen = 1;  xwords[0] = 0;\n+      }\n+    else if (cmpval == 0)  // abs(x) == abs(y)\n+      {\n+\txwords[0] = 1;  qlen = 1;  // quotient = 1\n+\tywords[0] = 0;  rlen = 1;  // remainder = 0;\n+      }\n+    else if (ylen == 1)\n+      {\n+\tqlen = xlen;\n+\trlen = 1;\n+\tywords[0] = MPN.divmod_1(xwords, xwords, xlen, ywords[0]);\n+      }\n+    else  // abs(x) > abs(y)\n+      {\n+\t// Normalize the denominator, i.e. make its most significant bit set by\n+\t// shifting it normalization_steps bits to the left.  Also shift the\n+\t// numerator the same number of steps (to keep the quotient the same!).\n+\n+\tint nshift = MPN.count_leading_zeros(ywords[ylen - 1]);\n+\tif (nshift != 0)\n+\t  {\n+\t    // Shift up the denominator setting the most significant bit of\n+\t    // the most significant word.\n+\t    MPN.lshift(ywords, 0, ywords, ylen, nshift);\n+\n+\t    // Shift up the numerator, possibly introducing a new most\n+\t    // significant word.\n+\t    int x_high = MPN.lshift(xwords, 0, xwords, xlen, nshift);\n+\t    xwords[xlen++] = x_high;\n+\t}\n+\n+\tif (xlen == ylen)\n+\t  xwords[xlen++] = 0;\n+\tMPN.divide(xwords, xlen, ywords, ylen);\n+\trlen = ylen;\n+\tif (remainder != null || rounding_mode != TRUNCATE)\n+\t  {\n+\t    if (nshift == 0)\n+\t      System.arraycopy(xwords, 0, ywords, 0, rlen);\n+\t    else\n+\t      MPN.rshift(ywords, xwords, 0, rlen, nshift);\n+\t  }\n+\n+\tqlen = xlen + 1 - ylen;\n+\tif (quotient != null)\n+\t  {\n+\t    for (int i = 0;  i < qlen;  i++)\n+\t      xwords[i] = xwords[i+ylen];\n+\t  }\n+      }\n+\n+    // Now the quotient is in xwords, and the remainder is in ywords.\n+\n+    boolean add_one = false;\n+    if (rlen > 1 || ywords[0] != 0)\n+      { // Non-zero remainder i.e. in-exact quotient.\n+\tswitch (rounding_mode)\n+\t  {\n+\t  case TRUNCATE:\n+\t    break;\n+\t  case CEILING:\n+\t  case FLOOR:\n+\t    if (qNegative == (rounding_mode == FLOOR))\n+\t      add_one = true;\n+\t    break;\n+\t  case ROUND:\n+\t    // int cmp = compareTo(remainder<<1, abs(y));\n+\t    BigInteger tmp = remainder == null ? new BigInteger() : remainder;\n+\t    tmp.set(ywords, rlen);\n+\t    tmp = shift(tmp, 1);\n+\t    if (yNegative)\n+\t      tmp.setNegative();\n+\t    int cmp = compareTo(tmp, y);\n+\t    // Now cmp == compareTo(sign(y)*(remainder<<1), y)\n+\t    if (yNegative)\n+\t      cmp = -cmp;\n+\t    add_one = (cmp == 1) || (cmp == 0 && (xwords[0]&1) != 0);\n+\t  }\n+      }\n+    if (quotient != null)\n+      {\n+\tquotient.set(xwords, qlen);\n+\tif (qNegative)\n+\t  {\n+\t    if (add_one)  // -(quotient + 1) == ~(quotient)\n+\t      quotient.setInvert();\n+\t    else\n+\t      quotient.setNegative();\n+\t  }\n+\telse if (add_one)\n+\t  quotient.setAdd(1);\n+      }\n+    if (remainder != null)\n+      {\n+\t// The remainder is by definition: X-Q*Y\n+\tremainder.set(ywords, rlen);\n+\tif (add_one)\n+\t  {\n+\t    // Subtract the remainder from Y:\n+\t    // abs(R) = abs(Y) - abs(orig_rem) = -(abs(orig_rem) - abs(Y)).\n+\t    BigInteger tmp;\n+\t    if (y.words == null)\n+\t      {\n+\t\ttmp = remainder;\n+\t\ttmp.set(yNegative ? ywords[0] + y.ival : ywords[0] - y.ival);\n+\t      }\n+\t    else\n+\t      tmp = BigInteger.add(remainder, y, yNegative ? 1 : -1);\n+\t    // Now tmp <= 0.\n+\t    // In this case, abs(Q) = 1 + floor(abs(X)/abs(Y)).\n+\t    // Hence, abs(Q*Y) > abs(X).\n+\t    // So sign(remainder) = -sign(X).\n+\t    if (xNegative)\n+\t      remainder.setNegative(tmp);\n+\t    else\n+\t      remainder.set(tmp);\n+\t  }\n+\telse\n+\t  {\n+\t    // If !add_one, then: abs(Q*Y) <= abs(X).\n+\t    // So sign(remainder) = sign(X).\n+\t    if (xNegative)\n+\t      remainder.setNegative();\n+\t  }\n+      }\n+  }\n+\n+  public BigInteger divide(BigInteger val)\n+  {\n+    if (val.isZero())\n+      throw new ArithmeticException(\"divisor is zero\");\n+\n+    BigInteger quot = new BigInteger();\n+    divide(this, val, quot, null, TRUNCATE);\n+    return quot.canonicalize();\n+  }\n+\n+  public BigInteger remainder(BigInteger val)\n+  {\n+    if (val.isZero())\n+      throw new ArithmeticException(\"divisor is zero\");\n+\n+    BigInteger rem = new BigInteger();\n+    divide(this, val, null, rem, TRUNCATE);\n+    return rem.canonicalize();\n+  }\n+\n+  public BigInteger[] divideAndRemainder(BigInteger val)\n+  {\n+    if (val.isZero())\n+      throw new ArithmeticException(\"divisor is zero\");\n+\n+    BigInteger[] result = new BigInteger[2];\n+    result[0] = new BigInteger();\n+    result[1] = new BigInteger();\n+    divide(this, val, result[0], result[1], TRUNCATE);\n+    result[0].canonicalize();\n+    result[1].canonicalize();\n+    return result;\n+  }\n+\n+  public BigInteger mod(BigInteger m)\n+  {\n+    if (m.isNegative() || m.isZero())\n+      throw new ArithmeticException(\"non-positive modulus\");\n+\n+    BigInteger rem = new BigInteger();\n+    divide(this, m, null, rem, FLOOR);\n+    return rem.canonicalize();\n+  }\n+\n+  /** Calculate power for BigInteger exponents.\n+   * @param y exponent assumed to be non-negative. */\n+  private BigInteger pow(BigInteger y)\n+  {\n+    if (isOne())\n+      return this;\n+    if (isMinusOne())\n+      return y.isOdd () ? this : ONE;\n+    if (y.words == null && y.ival >= 0)\n+      return pow(y.ival);\n+\n+    // Assume exponent is non-negative.\n+    if (isZero())\n+      return this;\n+\n+    // Implemented by repeated squaring and multiplication.\n+    BigInteger pow2 = this;\n+    BigInteger r = null;\n+    for (;;)  // for (i = 0;  ; i++)\n+      {\n+        // pow2 == x**(2**i)\n+        // prod = x**(sum(j=0..i-1, (y>>j)&1))\n+        if (y.isOdd())\n+          r = r == null ? pow2 : times(r, pow2);  // r *= pow2\n+        y = BigInteger.shift(y, -1);\n+        if (y.isZero())\n+          break;\n+        // pow2 *= pow2;\n+        pow2 = times(pow2, pow2);\n+      }\n+    return r == null ? ONE : r;\n+  }\n+\n+  /** Calculate the integral power of a BigInteger.\n+   * @param exponent the exponent (must be non-negative)\n+   */\n+  public BigInteger pow(int exponent)\n+  {\n+    if (exponent <= 0)\n+      {\n+\tif (exponent == 0)\n+\t  return ONE;\n+\telse\n+\t  throw new ArithmeticException(\"negative exponent\");\n+      }\n+    if (isZero())\n+      return this;\n+    int plen = words == null ? 1 : ival;  // Length of pow2.\n+    int blen = ((bitLength() * exponent) >> 5) + 2 * plen;\n+    boolean negative = isNegative() && (exponent & 1) != 0;\n+    int[] pow2 = new int [blen];\n+    int[] rwords = new int [blen];\n+    int[] work = new int [blen];\n+    getAbsolute(pow2);\t// pow2 = abs(this);\n+    int rlen = 1;\n+    rwords[0] = 1; // rwords = 1;\n+    for (;;)  // for (i = 0;  ; i++)\n+      {\n+\t// pow2 == this**(2**i)\n+\t// prod = this**(sum(j=0..i-1, (exponent>>j)&1))\n+\tif ((exponent & 1) != 0)\n+\t  { // r *= pow2\n+\t    MPN.mul(work, pow2, plen, rwords, rlen);\n+\t    int[] temp = work;  work = rwords;  rwords = temp;\n+\t    rlen += plen;\n+\t    while (rwords[rlen - 1] == 0)  rlen--;\n+\t  }\n+\texponent >>= 1;\n+\tif (exponent == 0)\n+\t  break;\n+\t// pow2 *= pow2;\n+\tMPN.mul(work, pow2, plen, pow2, plen);\n+\tint[] temp = work;  work = pow2;  pow2 = temp;  // swap to avoid a copy\n+\tplen *= 2;\n+\twhile (pow2[plen - 1] == 0)  plen--;\n+      }\n+    if (rwords[rlen - 1] < 0)\n+      rlen++;\n+    if (negative)\n+      negate(rwords, rwords, rlen);\n+    return BigInteger.make(rwords, rlen);\n+  }\n+\n+  private static final int[] euclidInv(int a, int b, int prevDiv)\n+  {\n+    // Storage for return values, plus one slot for a temp int (see below).\n+    int[] xy;\n+\n+    if (b == 0)\n+      throw new ArithmeticException(\"not invertible\");\n+    else if (b == 1)\n+      {\n+\t// Success:  values are indeed invertible!\n+\t// Bottom of the recursion reached; start unwinding.\n+        xy = new int[3];\n+\txy[0] = -prevDiv;\n+\txy[1] = 1;\n+\treturn xy;\n+      }\n+\n+    xy = euclidInv(b, a % b, a / b);\t// Recursion happens here.\n+\n+    // xy[2] is just temp storage for intermediate results in the following\n+    // calculation.  This saves us a bit of space over having an int\n+    // allocated at every level of this recursive method.\n+    xy[2] = xy[0];\n+    xy[0] = xy[2] * -prevDiv + xy[1];\n+    xy[1] = xy[2];\n+    return xy;\n+  }\n+\n+  private static final BigInteger[]\n+    euclidInv(BigInteger a, BigInteger b, BigInteger prevDiv)\n+  {\n+    // FIXME: This method could be more efficient memory-wise and should be\n+    // modified as such since it is recursive.\n+\n+    // Storage for return values, plus one slot for a temp int (see below).\n+    BigInteger[] xy;\n+\n+    if (b.isZero())\n+      throw new ArithmeticException(\"not invertible\");\n+    else if (b.isOne())\n+      {\n+\t// Success:  values are indeed invertible!\n+\t// Bottom of the recursion reached; start unwinding.\n+        xy = new BigInteger[3];\n+\txy[0] = neg(prevDiv);\n+\txy[1] = ONE;\n+\treturn xy;\n+      }\n+\n+    // Recursion happens in the following conditional!\n+\n+    // If a just contains an int, then use integer math for the rest.\n+    if (a.words == null)\n+      {\n+        int[] xyInt = euclidInv(b.ival, a.ival % b.ival, a.ival / b.ival);\n+        xy = new BigInteger[3];\n+\txy[0] = new BigInteger(xyInt[0]);\n+\txy[1] = new BigInteger(xyInt[1]);\n+      }\n+    else\n+      {\n+\tBigInteger rem = new BigInteger();\n+\tBigInteger quot = new BigInteger();\n+\tdivide(a, b, quot, rem, FLOOR);\n+        xy = euclidInv(b, rem, quot);\n+      }\n+\n+    // xy[2] is just temp storage for intermediate results in the following\n+    // calculation.  This saves us a bit of space over having a BigInteger\n+    // allocated at every level of this recursive method.\n+    xy[2] = xy[0];\n+    xy[0] = add(xy[1], times(xy[2], prevDiv), -1);\n+    xy[1] = xy[2];\n+    return xy;\n+  }\n+\n+  public BigInteger modInverse(BigInteger y)\n+  {\n+    if (y.isNegative() || y.isZero())\n+      throw new ArithmeticException(\"non-positive modulo\");\n+\n+    // Degenerate cases.\n+    if (y.isOne())\n+      return ZERO;\n+    else if (isOne())\n+      return ONE;\n+\n+    // Use Euclid's algorithm as in gcd() but do this recursively\n+    // rather than in a loop so we can use the intermediate results as we\n+    // unwind from the recursion.\n+    // Used http://www.math.nmsu.edu/~crypto/EuclideanAlgo.html as reference.\n+    BigInteger result = new BigInteger();\n+    int xval = ival;\n+    int yval = y.ival;\n+    boolean swapped = false;\n+\n+    if (y.words == null)\n+      {\n+\t// The result is guaranteed to be less than the modulus, y (which is\n+\t// an int), so simplify this by working with the int result of this\n+\t// modulo y.  Also, if this is negative, make it positive via modulo\n+\t// math.  Note that BigInteger.mod() must be used even if this is\n+\t// already an int as the % operator would provide a negative result if\n+\t// this is negative, BigInteger.mod() never returns negative values.\n+\tif (words != null || isNegative())\n+\t  xval = mod(y).ival;\n+\n+\t// Swap values so x > y.\n+\tif (yval > xval)\n+\t  {\n+\t    int tmp = xval; xval = yval; yval = tmp;\n+\t    swapped = true;\n+\t  }\n+\t// Normally, the result is in the 2nd element of the array, but\n+\t// if originally x < y, then x and y were swapped and the result\n+\t// is in the 1st element of the array.\n+\tresult.ival =\n+\t  euclidInv(yval, xval % yval, xval / yval)[swapped ? 0 : 1];\n+\n+\t// Result can't be negative, so make it positive by adding the\n+\t// original modulus, y.ival (not the possibly \"swapped\" yval).\n+\tif (result.ival < 0)\n+\t  result.ival += y.ival;\n+      }\n+    else\n+      {\n+\tBigInteger x = this;\n+\n+\t// As above, force this to be a positive value via modulo math.\n+\tif (isNegative())\n+\t  x = mod(y);\n+\n+\t// Swap values so x > y.\n+\tif (x.compareTo(y) < 0)\n+\t  {\n+\t    BigInteger tmp = x; x = y; y = tmp;\n+\t    swapped = true;\n+\t  }\n+\t// As above (for ints), result will be in the 2nd element unless\n+\t// the original x and y were swapped.\n+\tBigInteger rem = new BigInteger();\n+\tBigInteger quot = new BigInteger();\n+\tdivide(x, y, quot, rem, FLOOR);\n+\tresult = euclidInv(y, rem, quot)[swapped ? 0 : 1];\n+\n+\t// Result can't be negative, so make it positive by adding the\n+\t// original modulus, y (which is now x if they were swapped).\n+\tif (result.isNegative())\n+\t  result = add(result, swapped ? x : y, 1);\n+      }\n+    \n+    return result;\n+  }\n+\n+  public BigInteger modPow(BigInteger exponent, BigInteger m)\n+  {\n+    if (m.isNegative() || m.isZero())\n+      throw new ArithmeticException(\"non-positive modulo\");\n+\n+    if (exponent.isNegative())\n+      return modInverse(m);\n+    if (exponent.isOne())\n+      return mod(m);\n+\n+    return pow(exponent).mod(m);\n+  }\n+\n+  /** Calculate Greatest Common Divisor for non-negative ints. */\n+  private static final int gcd(int a, int b)\n+  {\n+    // Euclid's algorithm, copied from libg++.\n+    if (b > a)\n+      {\n+\tint tmp = a; a = b; b = tmp;\n+      }\n+    for(;;)\n+      {\n+\tif (b == 0)\n+\t  return a;\n+\telse if (b == 1)\n+\t  return b;\n+\telse\n+\t  {\n+\t    int tmp = b;\n+\t    b = a % b;\n+\t    a = tmp;\n+\t  }\n+      }\n+  }\n+\n+  public BigInteger gcd(BigInteger y)\n+  {\n+    int xval = ival;\n+    int yval = y.ival;\n+    if (words == null)\n+      {\n+\tif (xval == 0)\n+\t  return BigInteger.abs(y);\n+\tif (y.words == null\n+\t    && xval != Integer.MIN_VALUE && yval != Integer.MIN_VALUE)\n+\t  {\n+\t    if (xval < 0)\n+\t      xval = -xval;\n+\t    if (yval < 0)\n+\t      yval = -yval;\n+\t    return BigInteger.make(BigInteger.gcd(xval, yval));\n+\t  }\n+\txval = 1;\n+      }\n+    if (y.words == null)\n+      {\n+\tif (yval == 0)\n+\t  return BigInteger.abs(this);\n+\tyval = 1;\n+      }\n+    int len = (xval > yval ? xval : yval) + 1;\n+    int[] xwords = new int[len];\n+    int[] ywords = new int[len];\n+    getAbsolute(xwords);\n+    y.getAbsolute(ywords);\n+    len = MPN.gcd(xwords, ywords, len);\n+    BigInteger result = new BigInteger(0);\n+    result.ival = len;\n+    result.words = xwords;\n+    return result.canonicalize();\n+  }\n+\n+  private void setInvert()\n+  {\n+    if (words == null)\n+      ival = ~ival;\n+    else\n+      {\n+\tfor (int i = ival;  --i >= 0; )\n+\t  words[i] = ~words[i];\n+      }\n+  }\n+\n+  public BigInteger not()\n+  {\n+    BigInteger result = new BigInteger();\n+    result.ival = ival;\n+    result.words = words;\n+    result.setInvert();\n+    return result;\n+  }\n+\n+  private void setShiftLeft(BigInteger x, int count)\n+  {\n+    int[] xwords;\n+    int xlen;\n+    if (x.words == null)\n+      {\n+\tif (count < 32)\n+\t  {\n+\t    set((long) x.ival << count);\n+\t    return;\n+\t  }\n+\txwords = new int[1];\n+\txwords[0] = x.ival;\n+\txlen = 1;\n+      }\n+    else\n+      {\n+\txwords = x.words;\n+\txlen = x.ival;\n+      }\n+    int word_count = count >> 5;\n+    count &= 31;\n+    int new_len = xlen + word_count;\n+    if (count == 0)\n+      {\n+\trealloc(new_len);\n+\tfor (int i = xlen;  --i >= 0; )\n+\t  words[i+word_count] = xwords[i];\n+      }\n+    else\n+      {\n+\tnew_len++;\n+\trealloc(new_len);\n+\tint shift_out = MPN.lshift(words, word_count, xwords, xlen, count);\n+\tcount = 32 - count;\n+\twords[new_len-1] = (shift_out << count) >> count;  // sign-extend.\n+      }\n+    ival = new_len;\n+    for (int i = word_count;  --i >= 0; )\n+      words[i] = 0;\n+  }\n+\n+  private void setShiftRight(BigInteger x, int count)\n+  {\n+    if (x.words == null)\n+      set(count < 32 ? x.ival >> count : x.ival < 0 ? -1 : 0);\n+    else if (count == 0)\n+      set(x);\n+    else\n+      {\n+\tboolean neg = x.isNegative();\n+\tint word_count = count >> 5;\n+\tcount &= 31;\n+\tint d_len = x.ival - word_count;\n+\tif (d_len <= 0)\n+\t  set(neg ? -1 : 0);\n+\telse\n+\t  {\n+\t    if (words == null || words.length < d_len)\n+\t      realloc(d_len);\n+\t    MPN.rshift(words, x.words, word_count, d_len, count);\n+\t    ival = d_len;\n+\t    if (neg)\n+\t      words[ival-1] |= -1 << (32 - count);\n+\t  }\n+      }\n+  }\n+\n+  private void setShift(BigInteger x, int count)\n+  {\n+    if (count > 0)\n+      setShiftLeft(x, count);\n+    else\n+      setShiftRight(x, -count);\n+  }\n+\n+  private static BigInteger shift(BigInteger x, int count)\n+  {\n+    if (x.words == null)\n+      {\n+\tif (count <= 0)\n+\t  return make(count > -32 ? x.ival >> (-count) : x.ival < 0 ? -1 : 0);\n+\tif (count < 32)\n+\t  return make((long) x.ival << count);\n+      }\n+    if (count == 0)\n+      return x;\n+    BigInteger result = new BigInteger(0);\n+    result.setShift(x, count);\n+    return result.canonicalize();\n+  }\n+\n+  public BigInteger shiftLeft(int n)\n+  {\n+    return shift(this, n);\n+  }\n+\n+  public BigInteger shiftRight(int n)\n+  {\n+    return shift(this, -n);\n+  }\n+\n+  private void format(int radix, StringBuffer buffer)\n+  {\n+    if (words == null)\n+      buffer.append(Integer.toString(ival, radix));\n+    else if (ival <= 2)\n+      buffer.append(Long.toString(longValue(), radix));\n+    else\n+      {\n+\tboolean neg = isNegative();\n+\tint[] work;\n+\tif (neg || radix != 16)\n+\t  {\n+\t    work = new int[ival];\n+\t    getAbsolute(work);\n+\t  }\n+\telse\n+\t  work = words;\n+\tint len = ival;\n+\n+\tint buf_size = len * (MPN.chars_per_word(radix) + 1);\n+\tif (radix == 16)\n+\t  {\n+\t    if (neg)\n+\t      buffer.append('-');\n+\t    int buf_start = buffer.length();\n+\t    for (int i = len;  --i >= 0; )\n+\t      {\n+\t\tint word = work[i];\n+\t\tfor (int j = 8;  --j >= 0; )\n+\t\t  {\n+\t\t    int hex_digit = (word >> (4 * j)) & 0xF;\n+\t\t    // Suppress leading zeros:\n+\t\t    if (hex_digit > 0 || buffer.length() > buf_start)\n+\t\t      buffer.append(Character.forDigit(hex_digit, 16));\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    int i = buffer.length();\n+\t    for (;;)\n+\t      {\n+\t\tint digit = MPN.divmod_1(work, work, len, radix);\n+\t\tbuffer.append(Character.forDigit(digit, radix));\n+\t\twhile (len > 0 && work[len-1] == 0) len--;\n+\t\tif (len == 0)\n+\t\t  break;\n+\t      }\n+\t    if (neg)\n+\t      buffer.append('-');\n+\t    /* Reverse buffer. */\n+\t    int j = buffer.length() - 1;\n+\t    while (i < j)\n+\t      {\n+\t\tchar tmp = buffer.charAt(i);\n+\t\tbuffer.setCharAt(i, buffer.charAt(j));\n+\t\tbuffer.setCharAt(j, tmp);\n+\t\ti++;  j--;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  public String toString()\n+  {\n+    return toString(10);\n+  }\n+\n+  public String toString(int radix)\n+  {\n+    if (words == null)\n+      return Integer.toString(ival, radix);\n+    else if (ival <= 2)\n+      return Long.toString(longValue(), radix);\n+    int buf_size = ival * (MPN.chars_per_word(radix) + 1);\n+    StringBuffer buffer = new StringBuffer(buf_size);\n+    format(radix, buffer);\n+    return buffer.toString();\n+  }\n+\n+  public int intValue()\n+  {\n+    if (words == null)\n+      return ival;\n+    return words[0];\n+  }\n+\n+  public long longValue()\n+  {\n+    if (words == null)\n+      return ival;\n+    if (ival == 1)\n+      return words[0];\n+    return ((long)words[1] << 32) + ((long)words[0] & 0xffffffffL);\n+  }\n+\n+  public int hashCode()\n+  {\n+    // FIXME: May not match hashcode of JDK.\n+    return words == null ? ival : (words[0] + words[ival - 1]);\n+  }\n+\n+  /* Assumes x and y are both canonicalized. */\n+  private static boolean equals(BigInteger x, BigInteger y)\n+  {\n+    if (x.words == null && y.words == null)\n+      return x.ival == y.ival;\n+    if (x.words == null || y.words == null || x.ival != y.ival)\n+      return false;\n+    for (int i = x.ival; --i >= 0; )\n+      {\n+\tif (x.words[i] != y.words[i])\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n+  /* Assumes this and obj are both canonicalized. */\n+  public boolean equals(Object obj)\n+  {\n+    if (obj == null || ! (obj instanceof BigInteger))\n+      return false;\n+    return BigInteger.equals(this, (BigInteger) obj);\n+  }\n+\n+  public double doubleValue()\n+  {\n+    if (words == null)\n+      return (double) ival;\n+    if (ival <= 2)\n+      return (double) longValue();\n+    if (isNegative())\n+      return BigInteger.neg(this).roundToDouble(0, true, false);\n+    else\n+      return roundToDouble(0, false, false);\n+  }\n+\n+  public float floatValue()\n+  {\n+    return (float) doubleValue();\n+  }\n+\n+  /** Return true if any of the lowest n bits are one.\n+   * (false if n is negative).  */\n+  private boolean checkBits(int n)\n+  {\n+    if (n <= 0)\n+      return false;\n+    if (words == null)\n+      return n > 31 || ((ival & ((1 << n) - 1)) != 0);\n+    int i;\n+    for (i = 0; i < (n >> 5) ; i++)\n+      if (words[i] != 0)\n+\treturn true;\n+    return (n & 31) != 0 && (words[i] & ((1 << (n & 31)) - 1)) != 0;\n+  }\n+\n+  /** Convert a semi-processed BigInteger to double.\n+   * Number must be non-negative.  Multiplies by a power of two, applies sign,\n+   * and converts to double, with the usual java rounding.\n+   * @param exp power of two, positive or negative, by which to multiply\n+   * @param neg true if negative\n+   * @param remainder true if the BigInteger is the result of a truncating\n+   * division that had non-zero remainder.  To ensure proper rounding in\n+   * this case, the BigInteger must have at least 54 bits.  */\n+  private double roundToDouble(int exp, boolean neg, boolean remainder)\n+  {\n+    // Compute length.\n+    int il = bitLength();\n+\n+    // Exponent when normalized to have decimal point directly after\n+    // leading one.  This is stored excess 1023 in the exponent bit field.\n+    exp += il - 1;\n+\n+    // Gross underflow.  If exp == -1075, we let the rounding\n+    // computation determine whether it is minval or 0 (which are just\n+    // 0x0000 0000 0000 0001 and 0x0000 0000 0000 0000 as bit\n+    // patterns).\n+    if (exp < -1075)\n+      return neg ? -0.0 : 0.0;\n+\n+    // gross overflow\n+    if (exp > 1023)\n+      return neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+\n+    // number of bits in mantissa, including the leading one.\n+    // 53 unless it's denormalized\n+    int ml = (exp >= -1022 ? 53 : 53 + exp + 1022);\n+\n+    // Get top ml + 1 bits.  The extra one is for rounding.\n+    long m;\n+    int excess_bits = il - (ml + 1);\n+    if (excess_bits > 0)\n+      m = ((words == null) ? ival >> excess_bits\n+\t   : MPN.rshift_long(words, ival, excess_bits));\n+    else\n+      m = longValue() << (- excess_bits);\n+\n+    // Special rounding for maxval.  If the number exceeds maxval by\n+    // any amount, even if it's less than half a step, it overflows.\n+    if (exp == 1023 && ((m >> 1) == (1L << 53) - 1))\n+      {\n+\tif (remainder || checkBits(il - ml))\n+\t  return neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+\telse\n+\t  return neg ? - Double.MAX_VALUE : Double.MAX_VALUE;\n+      }\n+\n+    // Normal round-to-even rule: round up if the bit dropped is a one, and\n+    // the bit above it or any of the bits below it is a one.\n+    if ((m & 1) == 1\n+\t&& ((m & 2) == 2 || remainder || checkBits(excess_bits)))\n+      {\n+\tm += 2;\n+\t// Check if we overflowed the mantissa\n+\tif ((m & (1L << 54)) != 0)\n+\t  {\n+\t    exp++;\n+\t    // renormalize\n+\t    m >>= 1;\n+\t  }\n+\t// Check if a denormalized mantissa was just rounded up to a\n+\t// normalized one.\n+\telse if (ml == 52 && (m & (1L << 53)) != 0)\n+\t  exp++;\n+      }\n+\t\n+    // Discard the rounding bit\n+    m >>= 1;\n+\n+    long bits_sign = neg ? (1L << 63) : 0;\n+    exp += 1023;\n+    long bits_exp = (exp <= 0) ? 0 : ((long)exp) << 52;\n+    long bits_mant = m & ~(1L << 52);\n+    return Double.longBitsToDouble(bits_sign | bits_exp | bits_mant);\n+  }\n+\n+  /** Copy the abolute value of this into an array of words.\n+   * Assumes words.length >= (this.words == null ? 1 : this.ival).\n+   * Result is zero-extended, but need not be a valid 2's complement number.\n+   */\n+    \n+  private void getAbsolute(int[] words)\n+  {\n+    int len;\n+    if (this.words == null)\n+      {\n+\tlen = 1;\n+\twords[0] = this.ival;\n+      }\n+    else\n+      {\n+\tlen = this.ival;\n+\tfor (int i = len;  --i >= 0; )\n+\t  words[i] = this.words[i];\n+      }\n+    if (words[len - 1] < 0)\n+      negate(words, words, len);\n+    for (int i = words.length;  --i > len; )\n+      words[i] = 0;\n+  }\n+\n+  /** Set dest[0:len-1] to the negation of src[0:len-1].\n+   * Return true if overflow (i.e. if src is -2**(32*len-1)).\n+   * Ok for src==dest. */\n+  private static boolean negate(int[] dest, int[] src, int len)\n+  {\n+    long carry = 1;\n+    boolean negative = src[len-1] < 0;\n+    for (int i = 0;  i < len;  i++)\n+      {\n+        carry += ((long) (~src[i]) & 0xffffffffL);\n+        dest[i] = (int) carry;\n+        carry >>= 32;\n+      }\n+    return (negative && dest[len-1] < 0);\n+  }\n+\n+  /** Destructively set this to the negative of x.\n+   * It is OK if x==this.*/\n+  private void setNegative(BigInteger x)\n+  {\n+    int len = x.ival;\n+    if (x.words == null)\n+      {\n+\tif (len == Integer.MIN_VALUE)\n+\t  set(- (long) len);\n+\telse\n+\t  set(-len);\n+\treturn;\n+      }\n+    realloc(len + 1);\n+    if (BigInteger.negate(words, x.words, len))\n+      words[len++] = 0;\n+    ival = len;\n+  }\n+\n+  /** Destructively negate this. */\n+  private final void setNegative()\n+  {\n+    setNegative(this);\n+  }\n+\n+  private static BigInteger abs(BigInteger x)\n+  {\n+    return x.isNegative() ? neg(x) : x;\n+  }\n+\n+  public BigInteger abs()\n+  {\n+    return abs(this);\n+  }\n+\n+  public static BigInteger neg(BigInteger x)\n+  {\n+    if (x.words == null && x.ival != Integer.MIN_VALUE)\n+      return make(- x.ival);\n+    BigInteger result = new BigInteger(0);\n+    result.setNegative(x);\n+    return result.canonicalize();\n+  }\n+\n+  public BigInteger negate()\n+  {\n+    return BigInteger.neg(this);\n+  }\n+\n+  /** Calculates ceiling(log2(this < 0 ? -this : this+1))\n+   * See Common Lisp: the Language, 2nd ed, p. 361.\n+   */\n+  public int bitLength()\n+  {\n+    if (words == null)\n+      return MPN.intLength(ival);\n+    else\n+      return MPN.intLength(words, ival);\n+  }\n+\n+/* TODO:\n+\n+  public BigInteger(String val, int radix)\n+\n+  public BigInteger(String val)\n+\n+  public BigInteger(int bitLength, int certainty, Random rnd)\n+\n+  public BigInteger and(BigInteger val)\n+\n+  public BigInteger or(BigInteger val)\n+\n+  public BigInteger xor(BigInteger val\n+\n+  public BigInteger andNot(BigInteger val)\n+\n+  public BigInteger clearBit(int n)\n+  {\n+    if (n < 0)\n+      throw new ArithmeticException();\n+\n+    return and(ONE.shiftLeft(n).not());\n+  }\n+\n+  public BigInteger setBit(int n)\n+  {\n+    if (n < 0)\n+      throw new ArithmeticException();\n+\n+    return or(ONE.shiftLeft(n));\n+  }\n+\n+  public boolean testBit(int n)\n+\n+  public BigInteger flipBit(int n)\n+\n+  public int getLowestSetBit()\n+\n+  public int bitCount()\n+\n+  public boolean isProbablePrime(int certainty)\n+\n+  public BigInteger min(BigInteger val)\n+\n+  public BigInteger max(BigInteger val)\n+\n+  public byte[] toByteArray()\n+*/\n+}"}]}