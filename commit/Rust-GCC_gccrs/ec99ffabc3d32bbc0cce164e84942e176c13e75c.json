{"sha": "ec99ffabc3d32bbc0cce164e84942e176c13e75c", "node_id": "C_kwDOANBUbNoAKGVjOTlmZmFiYzNkMzJiYmMwY2NlMTY0ZTg0OTQyZTE3NmMxM2U3NWM", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-02-24T15:18:02Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-03-05T08:59:57Z"}, "message": "RISC-V: Add scalar move support and fix VSETVL bugs\n\ngcc/ChangeLog:\n\n\t* config/riscv/constraints.md (Wb1): New constraint.\n\t* config/riscv/predicates.md\n\t(vector_least_significant_set_mask_operand): New predicate.\n\t(vector_broadcast_mask_operand): Ditto.\n\t* config/riscv/riscv-protos.h (enum vlmul_type): Adjust.\n\t(gen_scalar_move_mask): New function.\n\t* config/riscv/riscv-v.cc (gen_scalar_move_mask): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.cc (class vmv): New class.\n\t(class vmv_s): Ditto.\n\t(BASE): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-functions.def (vmv_x): Ditto.\n\t(vmv_s): Ditto.\n\t(vfmv_f): Ditto.\n\t(vfmv_s): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.cc (struct scalar_move_def): Ditto.\n\t(SHAPE): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n\t* config/riscv/riscv-vector-builtins.cc (function_expander::mask_mode): Ditto.\n\t(function_expander::use_exact_insn): New function.\n\t(function_expander::use_contiguous_load_insn): New function.\n\t(function_expander::use_contiguous_store_insn): New function.\n\t(function_expander::use_ternop_insn): New function.\n\t(function_expander::use_widen_ternop_insn): New function.\n\t(function_expander::use_scalar_move_insn): New function.\n\t* config/riscv/riscv-vector-builtins.def (s): New operand suffix.\n\t* config/riscv/riscv-vector-builtins.h\n\t(function_expander::add_scalar_move_mask_operand): New class.\n\t* config/riscv/riscv-vsetvl.cc (ignore_vlmul_insn_p): New function.\n\t(scalar_move_insn_p): Ditto.\n\t(has_vsetvl_killed_avl_p): Ditto.\n\t(anticipatable_occurrence_p): Ditto.\n\t(insert_vsetvl): Ditto.\n\t(get_vl_vtype_info): Ditto.\n\t(calculate_sew): Ditto.\n\t(calculate_vlmul): Ditto.\n\t(incompatible_avl_p): Ditto.\n\t(different_sew_p): Ditto.\n\t(different_lmul_p): Ditto.\n\t(different_ratio_p): Ditto.\n\t(different_tail_policy_p): Ditto.\n\t(different_mask_policy_p): Ditto.\n\t(possible_zero_avl_p): Ditto.\n\t(first_ratio_invalid_for_second_sew_p): Ditto.\n\t(first_ratio_invalid_for_second_lmul_p): Ditto.\n\t(second_ratio_invalid_for_first_sew_p): Ditto.\n\t(second_ratio_invalid_for_first_lmul_p): Ditto.\n\t(second_sew_less_than_first_sew_p): Ditto.\n\t(first_sew_less_than_second_sew_p): Ditto.\n\t(compare_lmul): Ditto.\n\t(second_lmul_less_than_first_lmul_p): Ditto.\n\t(first_lmul_less_than_second_lmul_p): Ditto.\n\t(first_ratio_less_than_second_ratio_p): Ditto.\n\t(second_ratio_less_than_first_ratio_p): Ditto.\n\t(DEF_INCOMPATIBLE_COND): Ditto.\n\t(greatest_sew): Ditto.\n\t(first_sew): Ditto.\n\t(second_sew): Ditto.\n\t(first_vlmul): Ditto.\n\t(second_vlmul): Ditto.\n\t(first_ratio): Ditto.\n\t(second_ratio): Ditto.\n\t(vlmul_for_first_sew_second_ratio): Ditto.\n\t(ratio_for_second_sew_first_vlmul): Ditto.\n\t(DEF_SEW_LMUL_FUSE_RULE): Ditto.\n\t(always_unavailable): Ditto.\n\t(avl_unavailable_p): Ditto.\n\t(sew_unavailable_p): Ditto.\n\t(lmul_unavailable_p): Ditto.\n\t(ge_sew_unavailable_p): Ditto.\n\t(ge_sew_lmul_unavailable_p): Ditto.\n\t(ge_sew_ratio_unavailable_p): Ditto.\n\t(DEF_UNAVAILABLE_COND): Ditto.\n\t(same_sew_lmul_demand_p): Ditto.\n\t(propagate_avl_across_demands_p): Ditto.\n\t(reg_available_p): Ditto.\n\t(avl_info::has_non_zero_avl): Ditto.\n\t(vl_vtype_info::has_non_zero_avl): Ditto.\n\t(vector_insn_info::operator>=): Refactor.\n\t(vector_insn_info::parse_insn): Adjust for scalar move.\n\t(vector_insn_info::demand_vl_vtype): Remove.\n\t(vector_insn_info::compatible_p): New function.\n\t(vector_insn_info::compatible_avl_p): Ditto.\n\t(vector_insn_info::compatible_vtype_p): Ditto.\n\t(vector_insn_info::available_p): Ditto.\n\t(vector_insn_info::merge): Ditto.\n\t(vector_insn_info::fuse_avl): Ditto.\n\t(vector_insn_info::fuse_sew_lmul): Ditto.\n\t(vector_insn_info::fuse_tail_policy): Ditto.\n\t(vector_insn_info::fuse_mask_policy): Ditto.\n\t(vector_insn_info::dump): Ditto.\n\t(vector_infos_manager::release): Ditto.\n\t(pass_vsetvl::compute_local_backward_infos): Adjust for scalar move support.\n\t(pass_vsetvl::get_backward_fusion_type): Adjust for scalar move support.\n\t(pass_vsetvl::hard_empty_block_p): Ditto.\n\t(pass_vsetvl::backward_demand_fusion): Ditto.\n\t(pass_vsetvl::forward_demand_fusion): Ditto.\n\t(pass_vsetvl::refine_vsetvls): Ditto.\n\t(pass_vsetvl::cleanup_vsetvls): Ditto.\n\t(pass_vsetvl::commit_vsetvls): Ditto.\n\t(pass_vsetvl::propagate_avl): Ditto.\n\t* config/riscv/riscv-vsetvl.h (enum demand_status): New class.\n\t(struct demands_pair): Ditto.\n\t(struct demands_cond): Ditto.\n\t(struct demands_fuse_rule): Ditto.\n\t* config/riscv/vector-iterators.md: New iterator.\n\t* config/riscv/vector.md (@pred_broadcast<mode>): New pattern.\n\t(*pred_broadcast<mode>): Ditto.\n\t(*pred_broadcast<mode>_extended_scalar): Ditto.\n\t(@pred_extract_first<mode>): Ditto.\n\t(*pred_extract_first<mode>): Ditto.\n\t(@pred_extract_first_trunc<mode>): Ditto.\n\t* config/riscv/riscv-vsetvl.def: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-10.c: Adjust test.\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-11.c: Ditto.\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-12.c: Ditto.\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-15.c: Ditto.\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-18.c: Ditto.\n\t* gcc.target/riscv/rvv/vsetvl/vsetvlmax-9.c: Ditto.", "tree": {"sha": "f161a932d78bf5d9cd49291d0bd52b5918be7b61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f161a932d78bf5d9cd49291d0bd52b5918be7b61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec99ffabc3d32bbc0cce164e84942e176c13e75c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec99ffabc3d32bbc0cce164e84942e176c13e75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec99ffabc3d32bbc0cce164e84942e176c13e75c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec99ffabc3d32bbc0cce164e84942e176c13e75c/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602cfc746e9e0447221896a3d93608c6db3a89e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602cfc746e9e0447221896a3d93608c6db3a89e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602cfc746e9e0447221896a3d93608c6db3a89e5"}], "stats": {"total": 2213, "additions": 1911, "deletions": 302}, "files": [{"sha": "9d7ca487db737a5a7b461a562d799a089e1f780e", "filename": "gcc/config/riscv/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fconstraints.md?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -162,6 +162,12 @@\n  (and (match_code \"const_vector\")\n       (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n+(define_constraint \"Wb1\"\n+  \"@internal\n+ A constraint that matches a BOOL vector of {...,0,...0,1}\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"rtx_equal_p (op, riscv_vector::gen_scalar_move_mask (GET_MODE (op)))\")))\n+\n (define_memory_constraint \"Wdm\"\n   \"Vector duplicate memory operand\"\n   (and (match_code \"mem\")"}, {"sha": "06a51325537c4ebc93d68024079bc3c1a00df162", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -284,13 +284,22 @@\n \t\t|| satisfies_constraint_Wc0 (op)\"))))\n \n (define_predicate \"vector_all_trues_mask_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n+  (and (match_code \"const_vector\")\n        (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n+(define_predicate \"vector_least_significant_set_mask_operand\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"rtx_equal_p (op, riscv_vector::gen_scalar_move_mask (GET_MODE (op)))\")))\n+\n (define_predicate \"vector_mask_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"vector_all_trues_mask_operand\")))\n \n+(define_predicate \"vector_broadcast_mask_operand\"\n+  (ior (match_operand 0 \"vector_least_significant_set_mask_operand\")\n+    (ior (match_operand 0 \"register_operand\")\n+         (match_operand 0 \"vector_all_trues_mask_operand\"))))\n+\n (define_predicate \"vector_undef_operand\"\n   (match_test \"rtx_equal_p (op, RVV_VUNDEF (GET_MODE (op)))\"))\n \n@@ -340,10 +349,13 @@\n ;; The scalar operand can be directly broadcast by RVV instructions.\n (define_predicate \"direct_broadcast_operand\"\n   (and (match_test \"!(reload_completed && !FLOAT_MODE_P (GET_MODE (op))\n-\t\t&& register_operand (op, GET_MODE (op))\n+\t\t&& (register_operand (op, GET_MODE (op)) || CONST_INT_P (op)\n+\t\t|| rtx_equal_p (op, CONST0_RTX (GET_MODE (op))))\n \t\t&& maybe_gt (GET_MODE_BITSIZE (GET_MODE (op)), GET_MODE_BITSIZE (Pmode)))\")\n-    (ior (match_operand 0 \"register_operand\")\n-         (match_test \"satisfies_constraint_Wdm (op)\"))))\n+    (ior (match_test \"rtx_equal_p (op, CONST0_RTX (GET_MODE (op)))\")\n+         (ior (match_operand 0 \"const_int_operand\")\n+              (ior (match_operand 0 \"register_operand\")\n+                   (match_test \"satisfies_constraint_Wdm (op)\"))))))\n \n ;; A CONST_INT operand that has exactly two bits cleared.\n (define_predicate \"const_nottwobits_operand\""}, {"sha": "9e017b49c19568a63b476df1610372c5fa01fb23", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -133,6 +133,7 @@ enum vlmul_type\n   LMUL_F8 = 5,\n   LMUL_F4 = 6,\n   LMUL_F2 = 7,\n+  NUM_LMUL = 8\n };\n \n enum avl_type\n@@ -183,6 +184,7 @@ bool has_vi_variant_p (rtx_code, rtx);\n #endif\n bool sew64_scalar_helper (rtx *, rtx *, rtx, machine_mode, machine_mode,\n \t\t\t  bool, void (*)(rtx *, rtx));\n+rtx gen_scalar_move_mask (machine_mode);\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "c22099908825ac2974337c04ad09d57623e028ef", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -42,6 +42,7 @@\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"tm-constrs.h\"\n+#include \"rtx-vector-builder.h\"\n \n using namespace riscv_vector;\n \n@@ -484,4 +485,14 @@ sew64_scalar_helper (rtx *operands, rtx *scalar_op, rtx vl,\n   return true;\n }\n \n+/* Get { ... ,0, 0, 0, ..., 0, 0, 0, 1 } mask.  */\n+rtx\n+gen_scalar_move_mask (machine_mode mode)\n+{\n+  rtx_vector_builder builder (mode, 1, 2);\n+  builder.quick_push (const1_rtx);\n+  builder.quick_push (const0_rtx);\n+  return builder.build ();\n+}\n+\n } // namespace riscv_vector"}, {"sha": "7b27cc31fc767caedf2a94fbb9023ff4a6488231", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -1341,6 +1341,32 @@ class widen_freducop : public function_base\n   }\n };\n \n+/* Implements vmv/vfmv instructions.  */\n+class vmv : public function_base\n+{\n+public:\n+  bool apply_vl_p () const override { return false; }\n+  bool apply_tail_policy_p () const override { return false; }\n+  bool apply_mask_policy_p () const override { return false; }\n+  bool use_mask_predication_p () const override { return false; }\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_extract_first (e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vmv.s.x/vfmv.s.f.  */\n+class vmv_s : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_scalar_move_insn (code_for_pred_broadcast (e.vector_mode ()));\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -1530,6 +1556,10 @@ static CONSTEXPR const reducop<SMAX> vfredmax_obj;\n static CONSTEXPR const reducop<SMIN> vfredmin_obj;\n static CONSTEXPR const widen_freducop<UNSPEC_UNORDERED> vfwredusum_obj;\n static CONSTEXPR const widen_freducop<UNSPEC_ORDERED> vfwredosum_obj;\n+static CONSTEXPR const vmv vmv_x_obj;\n+static CONSTEXPR const vmv_s vmv_s_obj;\n+static CONSTEXPR const vmv vfmv_f_obj;\n+static CONSTEXPR const vmv_s vfmv_s_obj;\n \n /* Declare the function base NAME, pointing it to an instance\n    of class <NAME>_obj.  */\n@@ -1725,5 +1755,9 @@ BASE (vfredmax)\n BASE (vfredmin)\n BASE (vfwredosum)\n BASE (vfwredusum)\n+BASE (vmv_x)\n+BASE (vmv_s)\n+BASE (vfmv_f)\n+BASE (vfmv_s)\n \n } // end namespace riscv_vector"}, {"sha": "ad1ee207d2fd63a92e31916237df45064cace876", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -219,6 +219,10 @@ extern const function_base *const vfredmax;\n extern const function_base *const vfredmin;\n extern const function_base *const vfwredosum;\n extern const function_base *const vfwredusum;\n+extern const function_base *const vmv_x;\n+extern const function_base *const vmv_s;\n+extern const function_base *const vfmv_f;\n+extern const function_base *const vfmv_s;\n }\n \n } // end namespace riscv_vector"}, {"sha": "cad98f6230d55cb8a460a5f46eaa3fcad34991b4", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -464,6 +464,22 @@ DEF_RVV_FUNCTION (viota, mask_alu, full_preds, u_vm_ops)\n // 15.9. Vector Element Index Instruction\n DEF_RVV_FUNCTION (vid, alu, full_preds, u_v_ops)\n \n-/* TODO: 16. Vector Permutation Instructions.  */\n+/* 16. Vector Permutation Instructions.  */\n+\n+// 16.1. Integer Scalar Move Instructions\n+DEF_RVV_FUNCTION (vmv_x, scalar_move, none_preds, iu_x_s_ops)\n+DEF_RVV_FUNCTION (vmv_s, move, none_tu_preds, iu_s_x_ops)\n+\n+// 16.2. Floating-Point Scalar Move Instructions\n+DEF_RVV_FUNCTION (vfmv_f, scalar_move, none_preds, f_f_s_ops)\n+DEF_RVV_FUNCTION (vfmv_s, move, none_tu_preds, f_s_f_ops)\n+\n+// 16.3. Vector Slide Instructions\n+\n+// 16.4. Vector Register Gather Instructions\n+\n+// 16.5. Vector Compress Instruction\n+\n+// 16.6. Whole Vector Register Move\n \n #undef DEF_RVV_FUNCTION"}, {"sha": "d08a96c076494e9f69363b67bb1516d254ff3f6b", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -402,6 +402,22 @@ struct reduc_alu_def : public build_base\n   }\n };\n \n+/* scalar_move_def class.  */\n+struct scalar_move_def : public build_base\n+{\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    b.append_base_name (instance.base_name);\n+    if (overloaded_p)\n+      return b.finish_name ();\n+    b.append_name (operand_suffixes[instance.op_info->op]);\n+    b.append_name (type_suffixes[instance.type.index].vector);\n+    b.append_name (type_suffixes[instance.type.index].scalar);\n+    return b.finish_name ();\n+  }\n+};\n+\n SHAPE(vsetvl, vsetvl)\n SHAPE(vsetvl, vsetvlmax)\n SHAPE(loadstore, loadstore)\n@@ -414,5 +430,6 @@ SHAPE(narrow_alu, narrow_alu)\n SHAPE(move, move)\n SHAPE(mask_alu, mask_alu)\n SHAPE(reduc_alu, reduc_alu)\n+SHAPE(scalar_move, scalar_move)\n \n } // end namespace riscv_vector"}, {"sha": "a192b941fd8be935ee04bfd04954bcb544fc484b", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -36,6 +36,7 @@ extern const function_shape *const narrow_alu;\n extern const function_shape *const move;\n extern const function_shape *const mask_alu;\n extern const function_shape *const reduc_alu;\n+extern const function_shape *const scalar_move;\n }\n \n } // end namespace riscv_vector"}, {"sha": "a430104f1e7504643618feb8c21d954e31e9803f", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -1106,6 +1106,22 @@ static CONSTEXPR const rvv_op_info iu_v_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      v_args /* Args */};\n \n+/* A static operand information for scalar_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_x_s_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_s,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_scalar), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for scalar_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_f_s_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_s,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_scalar), /* Return type */\n+     v_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info iu_vs_ops\n@@ -1291,6 +1307,14 @@ static CONSTEXPR const rvv_op_info iu_x_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      x_args /* Args */};\n \n+/* A static operand information for vector_type func (scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info iu_s_x_ops\n+  = {iu_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_x,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_args /* Args */};\n+\n /* A static operand information for vector_type func (scalar_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info f_f_ops\n@@ -1299,6 +1323,14 @@ static CONSTEXPR const rvv_op_info f_f_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      x_args /* Args */};\n \n+/* A static operand information for vector_type func (scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_s_f_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_f,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_args /* Args */};\n+\n /* A static operand information for vector_type func (double demote type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info i_vf2_ops\n@@ -2448,14 +2480,19 @@ function_expander::add_mem_operand (machine_mode mode, unsigned argno)\n   add_fixed_operand (mem);\n }\n \n+/* Return the machine_mode of the corresponding mask type.  */\n+machine_mode\n+function_expander::mask_mode (void) const\n+{\n+  return TYPE_MODE (builtin_types[mask_types[type.index]].vector);\n+}\n+\n /* Implement the call using instruction ICODE, with a 1:1 mapping between\n    arguments and input operands.  */\n rtx\n function_expander::use_exact_insn (insn_code icode)\n {\n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-  tree mask_type = builtin_types[mask_types[type.index]].vector;\n-  machine_mode mask_mode = TYPE_MODE (mask_type);\n \n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n@@ -2465,7 +2502,7 @@ function_expander::use_exact_insn (insn_code icode)\n       if (use_real_mask_p (pred))\n \tadd_input_operand (arg_offset++);\n       else\n-\tadd_all_one_mask_operand (mask_mode);\n+\tadd_all_one_mask_operand (mask_mode ());\n     }\n \n   /* Store operation doesn't have merge operand.  */\n@@ -2485,7 +2522,8 @@ function_expander::use_exact_insn (insn_code icode)\n   if (base->apply_mask_policy_p ())\n     add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n \n-  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  if (base->apply_vl_p ())\n+    add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n   return generate_insn (icode);\n }\n \n@@ -2495,16 +2533,14 @@ function_expander::use_contiguous_load_insn (insn_code icode)\n {\n   gcc_assert (call_expr_nargs (exp) > 0);\n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-  tree mask_type = builtin_types[mask_types[type.index]].vector;\n-  machine_mode mask_mode = TYPE_MODE (mask_type);\n \n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n \n   if (use_real_mask_p (pred))\n     add_input_operand (arg_offset++);\n   else\n-    add_all_one_mask_operand (mask_mode);\n+    add_all_one_mask_operand (mask_mode ());\n \n   if (use_real_merge_p (pred))\n     add_input_operand (arg_offset++);\n@@ -2534,8 +2570,6 @@ function_expander::use_contiguous_store_insn (insn_code icode)\n {\n   gcc_assert (call_expr_nargs (exp) > 0);\n   machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n-  tree mask_type = builtin_types[mask_types[type.index]].vector;\n-  machine_mode mask_mode = TYPE_MODE (mask_type);\n \n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n@@ -2545,7 +2579,7 @@ function_expander::use_contiguous_store_insn (insn_code icode)\n   if (use_real_mask_p (pred))\n     add_input_operand (arg_offset++);\n   else\n-    add_all_one_mask_operand (mask_mode);\n+    add_all_one_mask_operand (mask_mode ());\n \n   arg_offset++;\n   for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n@@ -2601,16 +2635,14 @@ rtx\n function_expander::use_ternop_insn (bool vd_accum_p, insn_code icode)\n {\n   machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n-  tree mask_type = builtin_types[mask_types[type.index]].vector;\n-  machine_mode mask_mode = TYPE_MODE (mask_type);\n \n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n \n   if (use_real_mask_p (pred))\n     add_input_operand (arg_offset++);\n   else\n-    add_all_one_mask_operand (mask_mode);\n+    add_all_one_mask_operand (mask_mode ());\n \n   rtx vd = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n   rtx vs1 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n@@ -2668,16 +2700,14 @@ rtx\n function_expander::use_widen_ternop_insn (insn_code icode)\n {\n   machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n-  tree mask_type = builtin_types[mask_types[type.index]].vector;\n-  machine_mode mask_mode = TYPE_MODE (mask_type);\n \n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n \n   if (use_real_mask_p (pred))\n     add_input_operand (arg_offset++);\n   else\n-    add_all_one_mask_operand (mask_mode);\n+    add_all_one_mask_operand (mask_mode ());\n \n   rtx merge = RVV_VUNDEF (mode);\n   if (use_real_merge_p (pred))\n@@ -2706,6 +2736,31 @@ function_expander::use_widen_ternop_insn (insn_code icode)\n   return m_ops[0].value;\n }\n \n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_scalar_move_insn (insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+  add_scalar_move_mask_operand (mask_mode ());\n+\n+  if (use_real_merge_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_vundef_operand (mode);\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  return generate_insn (icode);\n+}\n+\n /* Generate instruction ICODE, given that its operands have already\n    been added to M_OPS.  Return the value of the first operand.  */\n rtx"}, {"sha": "5094f041f66e1eb31cd9ecb633f6d2dc6729c836", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -293,6 +293,7 @@ DEF_RVV_OP_TYPE (f_v)\n DEF_RVV_OP_TYPE (xu_v)\n DEF_RVV_OP_TYPE (f_w)\n DEF_RVV_OP_TYPE (xu_w)\n+DEF_RVV_OP_TYPE (s)\n \n DEF_RVV_PRED_TYPE (ta)\n DEF_RVV_PRED_TYPE (tu)"}, {"sha": "8707f7366d9e0d95e66d7fd4bf5a38a02de47209", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -342,6 +342,7 @@ class function_expander : public function_call_info\n   void add_input_operand (unsigned);\n   void add_output_operand (machine_mode, rtx);\n   void add_all_one_mask_operand (machine_mode);\n+  void add_scalar_move_mask_operand (machine_mode);\n   void add_vundef_operand (machine_mode);\n   void add_fixed_operand (rtx);\n   void add_integer_operand (rtx);\n@@ -350,13 +351,15 @@ class function_expander : public function_call_info\n   machine_mode vector_mode (void) const;\n   machine_mode index_mode (void) const;\n   machine_mode arg_mode (int) const;\n+  machine_mode mask_mode (void) const;\n \n   rtx use_exact_insn (insn_code);\n   rtx use_contiguous_load_insn (insn_code);\n   rtx use_contiguous_store_insn (insn_code);\n   rtx use_compare_insn (rtx_code, insn_code);\n   rtx use_ternop_insn (bool, insn_code);\n   rtx use_widen_ternop_insn (insn_code);\n+  rtx use_scalar_move_insn (insn_code);\n   rtx generate_insn (insn_code);\n \n   /* The function call expression.  */\n@@ -470,6 +473,13 @@ function_expander::add_all_one_mask_operand (machine_mode mode)\n   add_input_operand (mode, CONSTM1_RTX (mode));\n }\n \n+/* Add mask operand for scalar move instruction.  */\n+inline void\n+function_expander::add_scalar_move_mask_operand (machine_mode mode)\n+{\n+  add_input_operand (mode, gen_scalar_move_mask (mode));\n+}\n+\n /* Add an operand that must be X.  The only way of legitimizing an\n    invalid X is to reload the address of a MEM.  */\n inline void"}, {"sha": "9e25102a4f2fa28925a08930be83ae57c2613f59", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 713, "deletions": 218, "changes": 931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -63,7 +63,16 @@ along with GCC; see the file COPYING3.  If not see\n \n     -  The subroutine of optimize > 0 is lazy_vsetvl.\n        This function optimize vsetvl insertion process by\n-       lazy code motion (LCM) layering on RTL_SSA.  */\n+       lazy code motion (LCM) layering on RTL_SSA.\n+\n+    -  get_avl (), get_insn (), get_avl_source ():\n+\n+\t1. get_insn () is the current instruction, find_access (get_insn\n+   ())->def is the same as get_avl_source () if get_insn () demand VL.\n+\t2. If get_avl () is non-VLMAX REG, get_avl () == get_avl_source\n+   ()->regno ().\n+\t3. get_avl_source ()->regno () is the REGNO that we backward propagate.\n+ */\n \n #define IN_TARGET_CODE 1\n #define INCLUDE_ALGORITHM\n@@ -94,6 +103,12 @@ along with GCC; see the file COPYING3.  If not see\n using namespace rtl_ssa;\n using namespace riscv_vector;\n \n+static CONSTEXPR const unsigned ALL_SEW[] = {8, 16, 32, 64};\n+static CONSTEXPR const vlmul_type ALL_LMUL[]\n+  = {LMUL_1, LMUL_2, LMUL_4, LMUL_8, LMUL_F8, LMUL_F4, LMUL_F2};\n+static CONSTEXPR const demand_type SEW_LMUL_RELATED_DEMAND[]\n+  = {DEMAND_SEW, DEMAND_LMUL, DEMAND_RATIO, DEMAND_GE_SEW};\n+\n DEBUG_FUNCTION void\n debug (const vector_insn_info *info)\n {\n@@ -165,6 +180,24 @@ valid_sew_p (size_t sew)\n   return exact_log2 (sew) && sew >= 8 && sew <= 64;\n }\n \n+/* Return true if the instruction ignores VLMUL field of VTYPE.  */\n+static bool\n+ignore_vlmul_insn_p (rtx_insn *rinsn)\n+{\n+  return get_attr_type (rinsn) == TYPE_VIMOVVX\n+\t || get_attr_type (rinsn) == TYPE_VFMOVVF\n+\t || get_attr_type (rinsn) == TYPE_VIMOVXV\n+\t || get_attr_type (rinsn) == TYPE_VFMOVFV;\n+}\n+\n+/* Return true if the instruction is scalar move instruction.  */\n+static bool\n+scalar_move_insn_p (rtx_insn *rinsn)\n+{\n+  return get_attr_type (rinsn) == TYPE_VIMOVXV\n+\t || get_attr_type (rinsn) == TYPE_VFMOVFV;\n+}\n+\n /* Return true if it is a vsetvl instruction.  */\n static bool\n vector_config_insn_p (rtx_insn *rinsn)\n@@ -234,8 +267,7 @@ has_vsetvl_killed_avl_p (const bb_info *bb, const vector_insn_info &info)\n     {\n       rtx avl = info.get_avl ();\n       if (vlmax_avl_p (avl))\n-\treturn find_reg_killed_by (bb, get_vl (info.get_insn ()->rtl ()))\n-\t       != nullptr;\n+\treturn find_reg_killed_by (bb, info.get_avl_reg_rtx ()) != nullptr;\n       for (const insn_info *insn : bb->reverse_real_nondebug_insns ())\n \t{\n \t  def_info *def = find_access (insn->defs (), REGNO (avl));\n@@ -288,8 +320,7 @@ anticipatable_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n       /* rs1 (avl) are not modified in the basic block prior to the VSETVL.  */\n       if (!vlmax_avl_p (dem.get_avl ()))\n \t{\n-\t  set_info *set\n-\t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n+\t  set_info *set = dem.get_avl_source ();\n \t  /* If it's undefined, it's not anticipatable conservatively.  */\n \t  if (!set)\n \t    return false;\n@@ -748,7 +779,7 @@ insert_vsetvl (enum emit_type emit_type, rtx_insn *rinsn,\n   if (vlmax_avl_p (info.get_avl ()))\n     {\n       gcc_assert (has_vtype_op (rinsn) || vsetvl_insn_p (rinsn));\n-      rtx vl_op = get_vl (rinsn);\n+      rtx vl_op = info.get_avl_reg_rtx ();\n       gcc_assert (!vlmax_avl_p (vl_op));\n       emit_vsetvl_insn (VSETVL_NORMAL, emit_type, info, vl_op, rinsn);\n       return;\n@@ -890,8 +921,16 @@ get_vl_vtype_info (const insn_info *insn)\n {\n   set_info *set = nullptr;\n   rtx avl = ::get_avl (insn->rtl ());\n-  if (avl && REG_P (avl) && !vlmax_avl_p (avl))\n-    set = find_access (insn->uses (), REGNO (avl))->def ();\n+  if (avl && REG_P (avl))\n+    {\n+      if (vlmax_avl_p (avl) && has_vl_op (insn->rtl ()))\n+\tset\n+\t  = find_access (insn->uses (), REGNO (get_vl (insn->rtl ())))->def ();\n+      else if (!vlmax_avl_p (avl))\n+\tset = find_access (insn->uses (), REGNO (avl))->def ();\n+      else\n+\tset = nullptr;\n+    }\n \n   uint8_t sew = get_sew (insn->rtl ());\n   enum vlmul_type vlmul = get_vlmul (insn->rtl ());\n@@ -1113,6 +1152,391 @@ extract_single_source (set_info *set)\n   return first_insn;\n }\n \n+static unsigned\n+calculate_sew (vlmul_type vlmul, unsigned int ratio)\n+{\n+  for (const unsigned sew : ALL_SEW)\n+    if (calculate_ratio (sew, vlmul) == ratio)\n+      return sew;\n+  return 0;\n+}\n+\n+static vlmul_type\n+calculate_vlmul (unsigned int sew, unsigned int ratio)\n+{\n+  for (const vlmul_type vlmul : ALL_LMUL)\n+    if (calculate_ratio (sew, vlmul) == ratio)\n+      return vlmul;\n+  return LMUL_RESERVED;\n+}\n+\n+static bool\n+incompatible_avl_p (const vector_insn_info &info1,\n+\t\t    const vector_insn_info &info2)\n+{\n+  return !info1.compatible_avl_p (info2) && !info2.compatible_avl_p (info1);\n+}\n+\n+static bool\n+different_sew_p (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  return info1.get_sew () != info2.get_sew ();\n+}\n+\n+static bool\n+different_lmul_p (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  return info1.get_vlmul () != info2.get_vlmul ();\n+}\n+\n+static bool\n+different_ratio_p (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  return info1.get_ratio () != info2.get_ratio ();\n+}\n+\n+static bool\n+different_tail_policy_p (const vector_insn_info &info1,\n+\t\t\t const vector_insn_info &info2)\n+{\n+  return info1.get_ta () != info2.get_ta ();\n+}\n+\n+static bool\n+different_mask_policy_p (const vector_insn_info &info1,\n+\t\t\t const vector_insn_info &info2)\n+{\n+  return info1.get_ma () != info2.get_ma ();\n+}\n+\n+static bool\n+possible_zero_avl_p (const vector_insn_info &info1,\n+\t\t     const vector_insn_info &info2)\n+{\n+  return !info1.has_non_zero_avl () || !info2.has_non_zero_avl ();\n+}\n+\n+static bool\n+first_ratio_invalid_for_second_sew_p (const vector_insn_info &info1,\n+\t\t\t\t      const vector_insn_info &info2)\n+{\n+  return calculate_vlmul (info2.get_sew (), info1.get_ratio ())\n+\t == LMUL_RESERVED;\n+}\n+\n+static bool\n+first_ratio_invalid_for_second_lmul_p (const vector_insn_info &info1,\n+\t\t\t\t       const vector_insn_info &info2)\n+{\n+  return calculate_sew (info2.get_vlmul (), info1.get_ratio ()) == 0;\n+}\n+\n+static bool\n+second_ratio_invalid_for_first_sew_p (const vector_insn_info &info1,\n+\t\t\t\t      const vector_insn_info &info2)\n+{\n+  return calculate_vlmul (info1.get_sew (), info2.get_ratio ())\n+\t == LMUL_RESERVED;\n+}\n+\n+static bool\n+second_ratio_invalid_for_first_lmul_p (const vector_insn_info &info1,\n+\t\t\t\t       const vector_insn_info &info2)\n+{\n+  return calculate_sew (info1.get_vlmul (), info2.get_ratio ()) == 0;\n+}\n+\n+static bool\n+second_sew_less_than_first_sew_p (const vector_insn_info &info1,\n+\t\t\t\t  const vector_insn_info &info2)\n+{\n+  return info2.get_sew () < info1.get_sew ();\n+}\n+\n+static bool\n+first_sew_less_than_second_sew_p (const vector_insn_info &info1,\n+\t\t\t\t  const vector_insn_info &info2)\n+{\n+  return info1.get_sew () < info2.get_sew ();\n+}\n+\n+/* return 0 if LMUL1 == LMUL2.\n+   return -1 if LMUL1 < LMUL2.\n+   return 1 if LMUL1 > LMUL2.  */\n+static int\n+compare_lmul (vlmul_type vlmul1, vlmul_type vlmul2)\n+{\n+  if (vlmul1 == vlmul2)\n+    return 0;\n+\n+  switch (vlmul1)\n+    {\n+    case LMUL_1:\n+      if (vlmul2 == LMUL_2 || vlmul2 == LMUL_4 || vlmul2 == LMUL_8)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    case LMUL_2:\n+      if (vlmul2 == LMUL_4 || vlmul2 == LMUL_8)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    case LMUL_4:\n+      if (vlmul2 == LMUL_8)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    case LMUL_8:\n+      return -1;\n+    case LMUL_F2:\n+      if (vlmul2 == LMUL_1 || vlmul2 == LMUL_2 || vlmul2 == LMUL_4\n+\t  || vlmul2 == LMUL_8)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    case LMUL_F4:\n+      if (vlmul2 == LMUL_F2 || vlmul2 == LMUL_1 || vlmul2 == LMUL_2\n+\t  || vlmul2 == LMUL_4 || vlmul2 == LMUL_8)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    case LMUL_F8:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static bool\n+second_lmul_less_than_first_lmul_p (const vector_insn_info &info1,\n+\t\t\t\t    const vector_insn_info &info2)\n+{\n+  return compare_lmul (info2.get_vlmul (), info1.get_vlmul ()) == -1;\n+}\n+\n+static bool\n+first_lmul_less_than_second_lmul_p (const vector_insn_info &info1,\n+\t\t\t\t    const vector_insn_info &info2)\n+{\n+  return compare_lmul (info1.get_vlmul (), info2.get_vlmul ()) == -1;\n+}\n+\n+static bool\n+first_ratio_less_than_second_ratio_p (const vector_insn_info &info1,\n+\t\t\t\t      const vector_insn_info &info2)\n+{\n+  return info1.get_ratio () < info2.get_ratio ();\n+}\n+\n+static bool\n+second_ratio_less_than_first_ratio_p (const vector_insn_info &info1,\n+\t\t\t\t      const vector_insn_info &info2)\n+{\n+  return info2.get_ratio () < info1.get_ratio ();\n+}\n+\n+static CONSTEXPR const demands_cond incompatible_conds[] = {\n+#define DEF_INCOMPATIBLE_COND(AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1,         \\\n+\t\t\t      GE_SEW1, TAIL_POLICTY1, MASK_POLICY1, AVL2,      \\\n+\t\t\t      SEW2, LMUL2, RATIO2, NONZERO_AVL2, GE_SEW2,      \\\n+\t\t\t      TAIL_POLICTY2, MASK_POLICY2, COND)               \\\n+  {{{AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1, GE_SEW1, TAIL_POLICTY1,          \\\n+     MASK_POLICY1},                                                            \\\n+    {AVL2, SEW2, LMUL2, RATIO2, NONZERO_AVL2, GE_SEW2, TAIL_POLICTY2,          \\\n+     MASK_POLICY2}},                                                           \\\n+   COND},\n+#include \"riscv-vsetvl.def\"\n+};\n+\n+static unsigned\n+greatest_sew (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  return std::max (info1.get_sew (), info2.get_sew ());\n+}\n+\n+static unsigned\n+first_sew (const vector_insn_info &info1, const vector_insn_info &)\n+{\n+  return info1.get_sew ();\n+}\n+\n+static unsigned\n+second_sew (const vector_insn_info &, const vector_insn_info &info2)\n+{\n+  return info2.get_sew ();\n+}\n+\n+static vlmul_type\n+first_vlmul (const vector_insn_info &info1, const vector_insn_info &)\n+{\n+  return info1.get_vlmul ();\n+}\n+\n+static vlmul_type\n+second_vlmul (const vector_insn_info &, const vector_insn_info &info2)\n+{\n+  return info2.get_vlmul ();\n+}\n+\n+static unsigned\n+first_ratio (const vector_insn_info &info1, const vector_insn_info &)\n+{\n+  return info1.get_ratio ();\n+}\n+\n+static unsigned\n+second_ratio (const vector_insn_info &, const vector_insn_info &info2)\n+{\n+  return info2.get_ratio ();\n+}\n+\n+static vlmul_type\n+vlmul_for_first_sew_second_ratio (const vector_insn_info &info1,\n+\t\t\t\t  const vector_insn_info &info2)\n+{\n+  return calculate_vlmul (info1.get_sew (), info2.get_ratio ());\n+}\n+\n+static unsigned\n+ratio_for_second_sew_first_vlmul (const vector_insn_info &info1,\n+\t\t\t\t  const vector_insn_info &info2)\n+{\n+  return calculate_ratio (info2.get_sew (), info1.get_vlmul ());\n+}\n+\n+static CONSTEXPR const demands_fuse_rule fuse_rules[] = {\n+#define DEF_SEW_LMUL_FUSE_RULE(DEMAND_SEW1, DEMAND_LMUL1, DEMAND_RATIO1,       \\\n+\t\t\t       DEMAND_GE_SEW1, DEMAND_SEW2, DEMAND_LMUL2,      \\\n+\t\t\t       DEMAND_RATIO2, DEMAND_GE_SEW2, NEW_DEMAND_SEW,  \\\n+\t\t\t       NEW_DEMAND_LMUL, NEW_DEMAND_RATIO,              \\\n+\t\t\t       NEW_DEMAND_GE_SEW, NEW_SEW, NEW_VLMUL,          \\\n+\t\t\t       NEW_RATIO)                                      \\\n+  {{{DEMAND_ANY, DEMAND_SEW1, DEMAND_LMUL1, DEMAND_RATIO1, DEMAND_ANY,         \\\n+     DEMAND_GE_SEW1, DEMAND_ANY, DEMAND_ANY},                                  \\\n+    {DEMAND_ANY, DEMAND_SEW2, DEMAND_LMUL2, DEMAND_RATIO2, DEMAND_ANY,         \\\n+     DEMAND_GE_SEW2, DEMAND_ANY, DEMAND_ANY}},                                 \\\n+   NEW_DEMAND_SEW,                                                             \\\n+   NEW_DEMAND_LMUL,                                                            \\\n+   NEW_DEMAND_RATIO,                                                           \\\n+   NEW_DEMAND_GE_SEW,                                                          \\\n+   NEW_SEW,                                                                    \\\n+   NEW_VLMUL,                                                                  \\\n+   NEW_RATIO},\n+#include \"riscv-vsetvl.def\"\n+};\n+\n+static bool\n+always_unavailable (const vector_insn_info &, const vector_insn_info &)\n+{\n+  return true;\n+}\n+\n+static bool\n+avl_unavailable_p (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  return !info2.compatible_avl_p (info1.get_avl_info ());\n+}\n+\n+static bool\n+sew_unavailable_p (const vector_insn_info &info1, const vector_insn_info &info2)\n+{\n+  if (!info2.demand_p (DEMAND_LMUL) && !info2.demand_p (DEMAND_RATIO))\n+    {\n+      if (info2.demand_p (DEMAND_GE_SEW))\n+\treturn info1.get_sew () < info2.get_sew ();\n+      return info1.get_sew () != info2.get_sew ();\n+    }\n+  return true;\n+}\n+\n+static bool\n+lmul_unavailable_p (const vector_insn_info &info1,\n+\t\t    const vector_insn_info &info2)\n+{\n+  if (info1.get_vlmul () == info2.get_vlmul () && !info2.demand_p (DEMAND_SEW)\n+      && !info2.demand_p (DEMAND_RATIO))\n+    return false;\n+  return true;\n+}\n+\n+static bool\n+ge_sew_unavailable_p (const vector_insn_info &info1,\n+\t\t      const vector_insn_info &info2)\n+{\n+  if (!info2.demand_p (DEMAND_LMUL) && !info2.demand_p (DEMAND_RATIO)\n+      && info2.demand_p (DEMAND_GE_SEW))\n+    return info1.get_sew () < info2.get_sew ();\n+  return true;\n+}\n+\n+static bool\n+ge_sew_lmul_unavailable_p (const vector_insn_info &info1,\n+\t\t\t   const vector_insn_info &info2)\n+{\n+  if (!info2.demand_p (DEMAND_RATIO) && info2.demand_p (DEMAND_GE_SEW))\n+    return info1.get_sew () < info2.get_sew ();\n+  return true;\n+}\n+\n+static bool\n+ge_sew_ratio_unavailable_p (const vector_insn_info &info1,\n+\t\t\t    const vector_insn_info &info2)\n+{\n+  if (!info2.demand_p (DEMAND_LMUL) && info2.demand_p (DEMAND_GE_SEW))\n+    return info1.get_sew () < info2.get_sew ();\n+  return true;\n+}\n+\n+static CONSTEXPR const demands_cond unavailable_conds[] = {\n+#define DEF_UNAVAILABLE_COND(AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1, GE_SEW1, \\\n+\t\t\t     TAIL_POLICTY1, MASK_POLICY1, AVL2, SEW2, LMUL2,   \\\n+\t\t\t     RATIO2, NONZERO_AVL2, GE_SEW2, TAIL_POLICTY2,     \\\n+\t\t\t     MASK_POLICY2, COND)                               \\\n+  {{{AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1, GE_SEW1, TAIL_POLICTY1,          \\\n+     MASK_POLICY1},                                                            \\\n+    {AVL2, SEW2, LMUL2, RATIO2, NONZERO_AVL2, GE_SEW2, TAIL_POLICTY2,          \\\n+     MASK_POLICY2}},                                                           \\\n+   COND},\n+#include \"riscv-vsetvl.def\"\n+};\n+\n+static bool\n+same_sew_lmul_demand_p (const bool *dems1, const bool *dems2)\n+{\n+  return dems1[DEMAND_SEW] == dems2[DEMAND_SEW]\n+\t && dems1[DEMAND_LMUL] == dems2[DEMAND_LMUL]\n+\t && dems1[DEMAND_RATIO] == dems2[DEMAND_RATIO] && !dems1[DEMAND_GE_SEW]\n+\t && !dems2[DEMAND_GE_SEW];\n+}\n+\n+static bool\n+propagate_avl_across_demands_p (const vector_insn_info &info1,\n+\t\t\t\tconst vector_insn_info &info2)\n+{\n+  if (info2.demand_p (DEMAND_AVL))\n+    {\n+      if (info2.demand_p (DEMAND_NONZERO_AVL))\n+\treturn info1.demand_p (DEMAND_AVL)\n+\t       && !info1.demand_p (DEMAND_NONZERO_AVL) && info1.has_avl_reg ();\n+    }\n+  else\n+    return info1.demand_p (DEMAND_AVL) && info1.has_avl_reg ();\n+  return false;\n+}\n+\n+static bool\n+reg_available_p (const bb_info *bb, const vector_insn_info &info)\n+{\n+  if (!info.get_avl_source ())\n+    return true;\n+  insn_info *insn = info.get_avl_source ()->insn ();\n+  if (insn->bb () == bb)\n+    return before_p (insn, info.get_insn ());\n+  else\n+    return dominated_by_p (CDI_DOMINATORS, bb->cfg_bb (),\n+\t\t\t   insn->bb ()->cfg_bb ());\n+}\n+\n avl_info::avl_info (const avl_info &other)\n {\n   m_value = other.get_value ();\n@@ -1251,6 +1675,16 @@ avl_info::operator!= (const avl_info &other) const\n   return !(*this == other);\n }\n \n+bool\n+avl_info::has_non_zero_avl () const\n+{\n+  if (has_avl_imm ())\n+    return INTVAL (get_value ()) > 0;\n+  if (has_avl_reg ())\n+    return vlmax_avl_p (get_value ());\n+  return false;\n+}\n+\n /* Initialize VL/VTYPE information.  */\n vl_vtype_info::vl_vtype_info (avl_info avl_in, uint8_t sew_in,\n \t\t\t      enum vlmul_type vlmul_in, uint8_t ratio_in,\n@@ -1275,16 +1709,6 @@ vl_vtype_info::operator!= (const vl_vtype_info &other) const\n   return !(*this == other);\n }\n \n-bool\n-vl_vtype_info::has_non_zero_avl () const\n-{\n-  if (has_avl_imm ())\n-    return INTVAL (get_avl ()) > 0;\n-  if (has_avl_reg ())\n-    return vlmax_avl_p (get_avl ());\n-  return false;\n-}\n-\n bool\n vl_vtype_info::same_avl_p (const vl_vtype_info &other) const\n {\n@@ -1335,28 +1759,10 @@ vector_insn_info::operator>= (const vector_insn_info &other) const\n   if (!compatible_p (other))\n     return false;\n \n-  if (!demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n-    return false;\n-\n-  if (same_vlmax_p (other))\n-    {\n-      if (demand_p (DEMAND_RATIO) && !other.demand_p (DEMAND_RATIO)\n-\t  && (get_sew () != other.get_sew ()\n-\t      || get_vlmul () != other.get_vlmul ()))\n-\treturn false;\n-\n-      if (get_sew () == other.get_sew () && get_vlmul () == other.get_vlmul ())\n-\t{\n-\t  if (demand_p (DEMAND_RATIO) && !other.demand_p (DEMAND_RATIO))\n-\t    return false;\n-\t}\n-    }\n-\n-  if (!demand_p (DEMAND_TAIL_POLICY) && other.demand_p (DEMAND_TAIL_POLICY))\n-    return false;\n-\n-  if (!demand_p (DEMAND_MASK_POLICY) && other.demand_p (DEMAND_MASK_POLICY))\n-    return false;\n+  for (const auto &cond : unavailable_conds)\n+    if (cond.pair.match_cond_p (this->get_demands (), other.get_demands ())\n+\t&& cond.incompatible_p (*this, other))\n+      return false;\n \n   return true;\n }\n@@ -1467,7 +1873,8 @@ vector_insn_info::parse_insn (insn_info *insn)\n \t demand SEW && LMUL both. Some instructions may demand SEW\n \t only and ignore LMUL, will fix it later.  */\n       m_demands[DEMAND_SEW] = true;\n-      m_demands[DEMAND_LMUL] = true;\n+      if (!ignore_vlmul_insn_p (insn->rtl ()))\n+\tm_demands[DEMAND_LMUL] = true;\n     }\n \n   if (get_attr_ta (insn->rtl ()) != INVALID_ATTRIBUTE)\n@@ -1478,32 +1885,34 @@ vector_insn_info::parse_insn (insn_info *insn)\n   if (vector_config_insn_p (insn->rtl ()))\n     return;\n \n-  if (!has_avl_reg () || !m_avl.get_source ()\n-      || !m_avl.get_source ()->insn ()->is_phi ())\n+  if (scalar_move_insn_p (insn->rtl ()))\n+    {\n+      if (m_avl.has_non_zero_avl ())\n+\tm_demands[DEMAND_NONZERO_AVL] = true;\n+      if (m_ta)\n+\tm_demands[DEMAND_GE_SEW] = true;\n+    }\n+\n+  if (!m_avl.has_avl_reg () || vlmax_avl_p (get_avl ()) || !m_avl.get_source ())\n+    return;\n+  if (!m_avl.get_source ()->insn ()->is_real ()\n+      && !m_avl.get_source ()->insn ()->is_phi ())\n     return;\n \n   insn_info *def_insn = extract_single_source (m_avl.get_source ());\n-  if (def_insn)\n-    {\n-      vector_insn_info new_info;\n-      new_info.parse_insn (def_insn);\n-      if (!same_vlmax_p (new_info))\n-\treturn;\n-      /* TODO: Currently, we don't forward AVL for non-VLMAX vsetvl.  */\n-      if (vlmax_avl_p (new_info.get_avl ()))\n-\tset_avl_info (new_info.get_avl_info ());\n-    }\n-}\n+  if (!def_insn || !vsetvl_insn_p (def_insn->rtl ()))\n+    return;\n \n-void\n-vector_insn_info::demand_vl_vtype ()\n-{\n-  m_state = VALID;\n-  m_demands[DEMAND_AVL] = true;\n-  m_demands[DEMAND_SEW] = true;\n-  m_demands[DEMAND_LMUL] = true;\n-  m_demands[DEMAND_TAIL_POLICY] = true;\n-  m_demands[DEMAND_MASK_POLICY] = true;\n+  vector_insn_info new_info;\n+  new_info.parse_insn (def_insn);\n+  if (!same_vlmax_p (new_info) && !scalar_move_insn_p (insn->rtl ()))\n+    return;\n+  /* TODO: Currently, we don't forward AVL for non-VLMAX vsetvl.  */\n+  if (vlmax_avl_p (new_info.get_avl ()))\n+    set_avl_info (avl_info (new_info.get_avl (), get_avl_source ()));\n+\n+  if (scalar_move_insn_p (insn->rtl ()) && m_avl.has_non_zero_avl ())\n+    m_demands[DEMAND_NONZERO_AVL] = true;\n }\n \n bool\n@@ -1512,37 +1921,10 @@ vector_insn_info::compatible_p (const vector_insn_info &other) const\n   gcc_assert (valid_or_dirty_p () && other.valid_or_dirty_p ()\n \t      && \"Can't compare invalid demanded infos\");\n \n-  /* Check SEW.  */\n-  if (demand_p (DEMAND_SEW) && other.demand_p (DEMAND_SEW)\n-      && get_sew () != other.get_sew ())\n-    return false;\n-\n-  /* Check LMUL.  */\n-  if (demand_p (DEMAND_LMUL) && other.demand_p (DEMAND_LMUL)\n-      && get_vlmul () != other.get_vlmul ())\n-    return false;\n-\n-  /* Check RATIO.  */\n-  if (demand_p (DEMAND_RATIO) && other.demand_p (DEMAND_RATIO)\n-      && get_ratio () != other.get_ratio ())\n-    return false;\n-  if (demand_p (DEMAND_RATIO) && (other.get_sew () || other.get_vlmul ())\n-      && get_ratio () != other.get_ratio ())\n-    return false;\n-  if (other.demand_p (DEMAND_RATIO) && (get_sew () || get_vlmul ())\n-      && get_ratio () != other.get_ratio ())\n-    return false;\n-\n-  if (demand_p (DEMAND_TAIL_POLICY) && other.demand_p (DEMAND_TAIL_POLICY)\n-      && get_ta () != other.get_ta ())\n-    return false;\n-  if (demand_p (DEMAND_MASK_POLICY) && other.demand_p (DEMAND_MASK_POLICY)\n-      && get_ma () != other.get_ma ())\n-    return false;\n-\n-  if (demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n-    return compatible_avl_p (other);\n-\n+  for (const auto &cond : incompatible_conds)\n+    if (cond.pair.match_cond_p (this->get_demands (), other.get_demands ())\n+\t&& cond.incompatible_p (*this, other))\n+      return false;\n   return true;\n }\n \n@@ -1553,6 +1935,8 @@ vector_insn_info::compatible_avl_p (const vl_vtype_info &other) const\n   gcc_assert (!unknown_p () && \"Can't compare AVL in unknown state\");\n   if (!demand_p (DEMAND_AVL))\n     return true;\n+  if (demand_p (DEMAND_NONZERO_AVL) && other.has_non_zero_avl ())\n+    return true;\n   return get_avl_info () == other.get_avl_info ();\n }\n \n@@ -1562,6 +1946,10 @@ vector_insn_info::compatible_avl_p (const avl_info &other) const\n   gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n   gcc_assert (!unknown_p () && \"Can't compare AVL in unknown state\");\n   gcc_assert (demand_p (DEMAND_AVL) && \"Can't compare AVL undemand state\");\n+  if (!demand_p (DEMAND_AVL))\n+    return true;\n+  if (demand_p (DEMAND_NONZERO_AVL) && other.has_non_zero_avl ())\n+    return true;\n   return get_avl_info () == other;\n }\n \n@@ -1570,8 +1958,13 @@ vector_insn_info::compatible_vtype_p (const vl_vtype_info &other) const\n {\n   gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n   gcc_assert (!unknown_p () && \"Can't compare VTYPE in unknown state\");\n-  if (demand_p (DEMAND_SEW) && m_sew != other.get_sew ())\n-    return false;\n+  if (demand_p (DEMAND_SEW))\n+    {\n+      if (!demand_p (DEMAND_GE_SEW) && m_sew != other.get_sew ())\n+\treturn false;\n+      if (demand_p (DEMAND_GE_SEW) && m_sew > other.get_sew ())\n+\treturn false;\n+    }\n   if (demand_p (DEMAND_LMUL) && m_vlmul != other.get_vlmul ())\n     return false;\n   if (demand_p (DEMAND_RATIO) && m_ratio != other.get_ratio ())\n@@ -1609,114 +2002,155 @@ vector_insn_info::compatible_p (const vl_vtype_info &curr_info) const\n bool\n vector_insn_info::available_p (const vector_insn_info &other) const\n {\n-  if (*this >= other)\n-    return true;\n-  return false;\n+  return *this >= other;\n }\n \n-vector_insn_info\n-vector_insn_info::merge (const vector_insn_info &merge_info,\n-\t\t\t enum merge_type type = LOCAL_MERGE) const\n+void\n+vector_insn_info::fuse_avl (const vector_insn_info &info1,\n+\t\t\t    const vector_insn_info &info2)\n {\n-  if (!vsetvl_insn_p (get_insn ()->rtl ()))\n-    gcc_assert (this->compatible_p (merge_info)\n-\t\t&& \"Can't merge incompatible demanded infos\");\n+  set_insn (info1.get_insn ());\n+  if (info1.demand_p (DEMAND_AVL))\n+    {\n+      if (info1.demand_p (DEMAND_NONZERO_AVL))\n+\t{\n+\t  if (info2.demand_p (DEMAND_AVL)\n+\t      && !info2.demand_p (DEMAND_NONZERO_AVL))\n+\t    {\n+\t      set_avl_info (info2.get_avl_info ());\n+\t      set_demand (DEMAND_AVL, true);\n+\t      set_demand (DEMAND_NONZERO_AVL, false);\n+\t      return;\n+\t    }\n+\t}\n+      set_avl_info (info1.get_avl_info ());\n+      set_demand (DEMAND_NONZERO_AVL, info1.demand_p (DEMAND_NONZERO_AVL));\n+    }\n+  else\n+    {\n+      set_avl_info (info2.get_avl_info ());\n+      set_demand (DEMAND_NONZERO_AVL, info2.demand_p (DEMAND_NONZERO_AVL));\n+    }\n+  set_demand (DEMAND_AVL,\n+\t      info1.demand_p (DEMAND_AVL) || info2.demand_p (DEMAND_AVL));\n+}\n \n-  vector_insn_info new_info;\n-  new_info.demand_vl_vtype ();\n+void\n+vector_insn_info::fuse_sew_lmul (const vector_insn_info &info1,\n+\t\t\t\t const vector_insn_info &info2)\n+{\n+  /* We need to fuse sew && lmul according to demand info:\n \n-  if (type == LOCAL_MERGE)\n+     1. GE_SEW.\n+     2. SEW.\n+     3. LMUL.\n+     4. RATIO.  */\n+  if (same_sew_lmul_demand_p (info1.get_demands (), info2.get_demands ()))\n     {\n-      /* For local backward data flow, we always update INSN && AVL as the\n-\t latest INSN and AVL so that we can keep track status of each INSN.*/\n-      new_info.set_insn (merge_info.get_insn ());\n-      if (merge_info.demand_p (DEMAND_AVL))\n-\tnew_info.set_avl_info (merge_info.get_avl_info ());\n-      else if (demand_p (DEMAND_AVL))\n-\tnew_info.set_avl_info (get_avl_info ());\n+      set_demand (DEMAND_SEW, info2.demand_p (DEMAND_SEW));\n+      set_demand (DEMAND_LMUL, info2.demand_p (DEMAND_LMUL));\n+      set_demand (DEMAND_RATIO, info2.demand_p (DEMAND_RATIO));\n+      set_demand (DEMAND_GE_SEW, info2.demand_p (DEMAND_GE_SEW));\n+      set_sew (info2.get_sew ());\n+      set_vlmul (info2.get_vlmul ());\n+      set_ratio (info2.get_ratio ());\n+      return;\n     }\n-  else\n+  for (const auto &rule : fuse_rules)\n     {\n-      /* For global data flow, we should keep original INSN and AVL if they\n-\t valid since we should keep the life information of each block.\n-\n-\t For example:\n-\t   bb 0 -> bb 1.\n-\t We should keep INSN && AVL of bb 1 since we will eventually emit\n-\t vsetvl instruction according to INSN and AVL of bb 1.  */\n-      new_info.set_insn (get_insn ());\n-      if (demand_p (DEMAND_AVL))\n-\tnew_info.set_avl_info (get_avl_info ());\n-      else if (merge_info.demand_p (DEMAND_AVL))\n-\tnew_info.set_avl_info (merge_info.get_avl_info ());\n-    }\n-\n-  if (!demand_p (DEMAND_AVL) && !merge_info.demand_p (DEMAND_AVL))\n-    new_info.undemand (DEMAND_AVL);\n-  if (!demand_p (DEMAND_SEW) && !merge_info.demand_p (DEMAND_SEW))\n-    new_info.undemand (DEMAND_SEW);\n-  if (!demand_p (DEMAND_LMUL) && !merge_info.demand_p (DEMAND_LMUL))\n-    new_info.undemand (DEMAND_LMUL);\n-\n-  if (!demand_p (DEMAND_TAIL_POLICY)\n-      && !merge_info.demand_p (DEMAND_TAIL_POLICY))\n-    new_info.undemand (DEMAND_TAIL_POLICY);\n-  if (!demand_p (DEMAND_MASK_POLICY)\n-      && !merge_info.demand_p (DEMAND_MASK_POLICY))\n-    new_info.undemand (DEMAND_MASK_POLICY);\n-\n-  if (merge_info.demand_p (DEMAND_SEW))\n-    new_info.set_sew (merge_info.get_sew ());\n-  else if (demand_p (DEMAND_SEW))\n-    new_info.set_sew (get_sew ());\n-\n-  if (merge_info.demand_p (DEMAND_LMUL))\n-    new_info.set_vlmul (merge_info.get_vlmul ());\n-  else if (demand_p (DEMAND_LMUL))\n-    new_info.set_vlmul (get_vlmul ());\n-\n-  if (!new_info.demand_p (DEMAND_SEW) && !new_info.demand_p (DEMAND_LMUL))\n-    {\n-      if (demand_p (DEMAND_RATIO) || merge_info.demand_p (DEMAND_RATIO))\n-\tnew_info.demand (DEMAND_RATIO);\n-      /* Even though we don't demand_p SEW && VLMUL in this case, we still\n-       * need them.  */\n-      if (merge_info.demand_p (DEMAND_RATIO))\n+      if (rule.pair.match_cond_p (info1.get_demands (), info2.get_demands ()))\n \t{\n-\t  new_info.set_sew (merge_info.get_sew ());\n-\t  new_info.set_vlmul (merge_info.get_vlmul ());\n-\t  new_info.set_ratio (merge_info.get_ratio ());\n+\t  set_demand (DEMAND_SEW, rule.demand_sew_p);\n+\t  set_demand (DEMAND_LMUL, rule.demand_lmul_p);\n+\t  set_demand (DEMAND_RATIO, rule.demand_ratio_p);\n+\t  set_demand (DEMAND_GE_SEW, rule.demand_ge_sew_p);\n+\t  set_sew (rule.new_sew (info1, info2));\n+\t  set_vlmul (rule.new_vlmul (info1, info2));\n+\t  set_ratio (rule.new_ratio (info1, info2));\n+\t  return;\n \t}\n-      else if (demand_p (DEMAND_RATIO))\n+      if (rule.pair.match_cond_p (info2.get_demands (), info1.get_demands ()))\n \t{\n-\t  new_info.set_sew (get_sew ());\n-\t  new_info.set_vlmul (get_vlmul ());\n-\t  new_info.set_ratio (get_ratio ());\n+\t  set_demand (DEMAND_SEW, rule.demand_sew_p);\n+\t  set_demand (DEMAND_LMUL, rule.demand_lmul_p);\n+\t  set_demand (DEMAND_RATIO, rule.demand_ratio_p);\n+\t  set_demand (DEMAND_GE_SEW, rule.demand_ge_sew_p);\n+\t  set_sew (rule.new_sew (info2, info1));\n+\t  set_vlmul (rule.new_vlmul (info2, info1));\n+\t  set_ratio (rule.new_ratio (info2, info1));\n+\t  return;\n \t}\n     }\n-  else\n+  gcc_unreachable ();\n+}\n+\n+void\n+vector_insn_info::fuse_tail_policy (const vector_insn_info &info1,\n+\t\t\t\t    const vector_insn_info &info2)\n+{\n+  if (info1.demand_p (DEMAND_TAIL_POLICY))\n+    {\n+      set_ta (info1.get_ta ());\n+      demand (DEMAND_TAIL_POLICY);\n+    }\n+  else if (info2.demand_p (DEMAND_TAIL_POLICY))\n     {\n-      /* when get_attr_ratio is invalid, this kind of instructions\n-\t doesn't care about ratio. However, we still need this value\n-\t in demand_p info backward analysis.  */\n-      new_info.set_ratio (\n-\tcalculate_ratio (new_info.get_sew (), new_info.get_vlmul ()));\n+      set_ta (info2.get_ta ());\n+      demand (DEMAND_TAIL_POLICY);\n     }\n+  else\n+    set_ta (get_default_ta ());\n+}\n \n-  if (merge_info.demand_p (DEMAND_TAIL_POLICY))\n-    new_info.set_ta (merge_info.get_ta ());\n-  else if (demand_p (DEMAND_TAIL_POLICY))\n-    new_info.set_ta (get_ta ());\n+void\n+vector_insn_info::fuse_mask_policy (const vector_insn_info &info1,\n+\t\t\t\t    const vector_insn_info &info2)\n+{\n+  if (info1.demand_p (DEMAND_MASK_POLICY))\n+    {\n+      set_ma (info1.get_ma ());\n+      demand (DEMAND_MASK_POLICY);\n+    }\n+  else if (info2.demand_p (DEMAND_MASK_POLICY))\n+    {\n+      set_ma (info2.get_ma ());\n+      demand (DEMAND_MASK_POLICY);\n+    }\n   else\n-    new_info.set_ta (get_default_ta ());\n+    set_ma (get_default_ma ());\n+}\n \n-  if (merge_info.demand_p (DEMAND_MASK_POLICY))\n-    new_info.set_ma (merge_info.get_ma ());\n-  else if (demand_p (DEMAND_MASK_POLICY))\n-    new_info.set_ma (get_ma ());\n+vector_insn_info\n+vector_insn_info::merge (const vector_insn_info &merge_info,\n+\t\t\t enum merge_type type = LOCAL_MERGE) const\n+{\n+  if (!vsetvl_insn_p (get_insn ()->rtl ()))\n+    gcc_assert (this->compatible_p (merge_info)\n+\t\t&& \"Can't merge incompatible demanded infos\");\n+\n+  vector_insn_info new_info;\n+  new_info.set_valid ();\n+  if (type == LOCAL_MERGE)\n+    {\n+      /* For local backward data flow, we always update INSN && AVL as the\n+\t latest INSN and AVL so that we can keep track status of each INSN.  */\n+      new_info.fuse_avl (merge_info, *this);\n+    }\n   else\n-    new_info.set_ma (get_default_ma ());\n+    {\n+      /* For global data flow, we should keep original INSN and AVL if they\n+      valid since we should keep the life information of each block.\n \n+      For example:\n+\tbb 0 -> bb 1.\n+      We should keep INSN && AVL of bb 1 since we will eventually emit\n+      vsetvl instruction according to INSN and AVL of bb 1.  */\n+      new_info.fuse_avl (*this, merge_info);\n+    }\n+\n+  new_info.fuse_sew_lmul (*this, merge_info);\n+  new_info.fuse_tail_policy (*this, merge_info);\n+  new_info.fuse_mask_policy (*this, merge_info);\n   return new_info;\n }\n \n@@ -1740,7 +2174,9 @@ vector_insn_info::dump (FILE *file) const\n     fprintf (file, \"DIRTY,\");\n \n   fprintf (file, \"Demand field={%d(VL),\", demand_p (DEMAND_AVL));\n+  fprintf (file, \"%d(DEMAND_NONZERO_AVL),\", demand_p (DEMAND_NONZERO_AVL));\n   fprintf (file, \"%d(SEW),\", demand_p (DEMAND_SEW));\n+  fprintf (file, \"%d(DEMAND_GE_SEW),\", demand_p (DEMAND_GE_SEW));\n   fprintf (file, \"%d(LMUL),\", demand_p (DEMAND_LMUL));\n   fprintf (file, \"%d(RATIO),\", demand_p (DEMAND_RATIO));\n   fprintf (file, \"%d(TAIL_POLICY),\", demand_p (DEMAND_TAIL_POLICY));\n@@ -1895,6 +2331,8 @@ vector_infos_manager::release (void)\n   if (!vector_exprs.is_empty ())\n     vector_exprs.release ();\n \n+  gcc_assert (to_refine_vsetvls.is_empty ());\n+  gcc_assert (to_delete_vsetvls.is_empty ());\n   if (optimize > 0)\n     free_bitmap_vectors ();\n }\n@@ -2167,8 +2605,13 @@ pass_vsetvl::compute_local_backward_infos (const bb_info *bb)\n       else\n \t{\n \t  gcc_assert (info.valid_p () && \"Unexpected Invalid demanded info\");\n-\t  if (change.valid_p () && change.compatible_p (info))\n-\t    info = change.merge (info);\n+\t  if (change.valid_p ())\n+\t    {\n+\t      if (!(propagate_avl_across_demands_p (info, change)\n+\t\t    && !reg_available_p (bb, info))\n+\t\t  && change.compatible_p (info))\n+\t\tinfo = change.merge (info);\n+\t    }\n \t  change = info;\n \t}\n     }\n@@ -2282,7 +2725,7 @@ pass_vsetvl::get_backward_fusion_type (const bb_info *bb,\n   rtx reg = NULL_RTX;\n \n   /* Case 1: Don't need VL. Just let it backward propagate.  */\n-  if (!has_vl_op (insn->rtl ()))\n+  if (!prop.demand_p (DEMAND_AVL))\n     return VALID_AVL_FUSION;\n   else\n     {\n@@ -2296,16 +2739,16 @@ pass_vsetvl::get_backward_fusion_type (const bb_info *bb,\n \t  gcc_assert (prop.has_avl_reg ());\n \t  if (vlmax_avl_p (prop.get_avl ()))\n \t    /* Check VL operand for vsetvl vl,zero.  */\n-\t    reg = get_vl (insn->rtl ());\n+\t    reg = prop.get_avl_reg_rtx ();\n \t  else\n \t    /* Check AVL operand for vsetvl zero,avl.  */\n-\t    reg = get_avl (insn->rtl ());\n+\t    reg = prop.get_avl ();\n \t}\n     }\n \n   gcc_assert (reg);\n-  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n-  if (!def->insn ()->is_phi () && def->insn ()->bb () == insn->bb ())\n+  if (!prop.get_avl_source ()->insn ()->is_phi ()\n+      && prop.get_avl_source ()->insn ()->bb () == insn->bb ())\n     return INVALID_FUSION;\n   hash_set<set_info *> sets\n     = get_all_sets (prop.get_avl_source (), true, true, true);\n@@ -2340,10 +2783,8 @@ pass_vsetvl::hard_empty_block_p (const bb_info *bb,\n \n   basic_block cfg_bb = bb->cfg_bb ();\n   sbitmap avin = m_vector_manager->vector_avin[cfg_bb->index];\n-  rtx avl = vlmax_avl_p (info.get_avl ()) ? get_vl (info.get_insn ()->rtl ())\n-\t\t\t\t\t  : get_avl (info.get_insn ()->rtl ());\n-  insn_info *insn = info.get_insn ();\n-  set_info *set = find_access (insn->uses (), REGNO (avl))->def ();\n+  set_info *set = info.get_avl_source ();\n+  rtx avl = gen_rtx_REG (Pmode, set->regno ());\n   hash_set<set_info *> sets = get_all_sets (set, true, false, false);\n   hash_set<basic_block> pred_cfg_bbs = get_all_predecessors (cfg_bb);\n \n@@ -2635,7 +3076,7 @@ pass_vsetvl::backward_demand_fusion (void)\n \n \t      if (block_info.reaching_out.compatible_p (prop))\n \t\t{\n-\t\t  if (block_info.reaching_out >= prop)\n+\t\t  if (block_info.reaching_out.available_p (prop))\n \t\t    continue;\n \t\t  new_info = block_info.reaching_out.merge (prop, GLOBAL_MERGE);\n \t\t  new_info.set_dirty (\n@@ -2659,6 +3100,14 @@ pass_vsetvl::backward_demand_fusion (void)\n \t\t    continue;\n \t\t}\n \n+\t      if (propagate_avl_across_demands_p (prop,\n+\t\t\t\t\t\t  block_info.reaching_out))\n+\t\t{\n+\t\t  rtx reg = new_info.get_avl_reg_rtx ();\n+\t\t  if (find_reg_killed_by (crtl->ssa->bb (e->src), reg))\n+\t\t    new_info.set_dirty (true);\n+\t\t}\n+\n \t      block_info.local_dem = new_info;\n \t      block_info.reaching_out = new_info;\n \t      changed_p = true;\n@@ -2683,13 +3132,11 @@ pass_vsetvl::backward_demand_fusion (void)\n \t\t  if (set->insn () != block_info.reaching_out.get_insn ())\n \t\t    continue;\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  if (!block_info.reaching_out.compatible_p (prop))\n-\t\t    continue;\n-\t\t  if (block_info.reaching_out >= prop)\n-\t\t    continue;\n-\t\t}\n+\n+\t      if (!block_info.reaching_out.compatible_p (prop))\n+\t\tcontinue;\n+\t      if (block_info.reaching_out.available_p (prop))\n+\t\tcontinue;\n \n \t      vector_insn_info be_merged = block_info.reaching_out;\n \t      if (block_info.local_dem == block_info.reaching_out)\n@@ -2699,6 +3146,10 @@ pass_vsetvl::backward_demand_fusion (void)\n \t      if (curr_block_info.probability > block_info.probability)\n \t\tblock_info.probability = curr_block_info.probability;\n \n+\t      if (propagate_avl_across_demands_p (prop, block_info.reaching_out)\n+\t\t  && !reg_available_p (crtl->ssa->bb (e->src), new_info))\n+\t\tcontinue;\n+\n \t      change_vsetvl_insn (new_info.get_insn (), new_info);\n \t      if (block_info.local_dem == block_info.reaching_out)\n \t\tblock_info.local_dem = new_info;\n@@ -2745,6 +3196,9 @@ pass_vsetvl::forward_demand_fusion (void)\n       if (cfg_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n+      if (vsetvl_insn_p (prop.get_insn ()->rtl ()))\n+\tcontinue;\n+\n       edge e;\n       edge_iterator ei;\n       /* Forward propagate to each successor.  */\n@@ -2767,10 +3221,12 @@ pass_vsetvl::forward_demand_fusion (void)\n \t  /* If there is nothing to propagate, just skip it.  */\n \t  if (!local_dem.valid_or_dirty_p ())\n \t    continue;\n-\t  if (local_dem >= prop)\n+\t  if (local_dem.available_p (prop))\n \t    continue;\n \t  if (!local_dem.compatible_p (prop))\n \t    continue;\n+\t  if (propagate_avl_across_demands_p (prop, local_dem))\n+\t    continue;\n \n \t  vector_insn_info new_info = local_dem.merge (prop, GLOBAL_MERGE);\n \t  new_info.set_insn (local_dem.get_insn ());\n@@ -3156,8 +3612,14 @@ pass_vsetvl::refine_vsetvls (void) const\n       if (!can_refine_vsetvl_p (cfg_bb, info))\n \tcontinue;\n \n-      if (!vector_config_insn_p (rinsn))\n-\trinsn = PREV_INSN (rinsn);\n+      /* We can't refine user vsetvl into vsetvl zero,zero since the dest\n+\t will be used by the following instructions.  */\n+      if (vector_config_insn_p (rinsn))\n+\t{\n+\t  m_vector_manager->to_refine_vsetvls.add (rinsn);\n+\t  continue;\n+\t}\n+      rinsn = PREV_INSN (rinsn);\n       rtx new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, info, NULL_RTX);\n       change_insn (rinsn, new_pat);\n     }\n@@ -3189,15 +3651,17 @@ pass_vsetvl::cleanup_vsetvls ()\n \t\t  insn_info *insn = dem.get_insn ();\n \t\t  gcc_assert (insn && insn->rtl ());\n \t\t  rtx_insn *rinsn;\n+\t\t  /* We can't eliminate user vsetvl since the dest will be used\n+\t\t   * by the following instructions.  */\n \t\t  if (vector_config_insn_p (insn->rtl ()))\n-\t\t    rinsn = insn->rtl ();\n-\t\t  else\n \t\t    {\n-\t\t      gcc_assert (has_vtype_op (insn->rtl ()));\n-\t\t      rinsn = PREV_INSN (insn->rtl ());\n-\t\t      gcc_assert (\n-\t\t\tvector_config_insn_p (PREV_INSN (insn->rtl ())));\n+\t\t      m_vector_manager->to_delete_vsetvls.add (insn->rtl ());\n+\t\t      continue;\n \t\t    }\n+\n+\t\t  gcc_assert (has_vtype_op (insn->rtl ()));\n+\t\t  rinsn = PREV_INSN (insn->rtl ());\n+\t\t  gcc_assert (vector_config_insn_p (PREV_INSN (insn->rtl ())));\n \t\t  eliminate_insn (rinsn);\n \t\t}\n \t    }\n@@ -3265,7 +3729,8 @@ pass_vsetvl::commit_vsetvls (void)\n \t  bool available_p = false;\n \t  EXECUTE_IF_SET_IN_BITMAP (avin, 0, bb_index, sbi)\n \t  {\n-\t    if (*m_vector_manager->vector_exprs[bb_index] >= reaching_out)\n+\t    if (m_vector_manager->vector_exprs[bb_index]->available_p (\n+\t\t  reaching_out))\n \t      {\n \t\tavailable_p = true;\n \t\tbreak;\n@@ -3276,12 +3741,18 @@ pass_vsetvl::commit_vsetvls (void)\n \t}\n \n       rtx new_pat;\n-      if (can_refine_vsetvl_p (cfg_bb, reaching_out))\n+      if (!reaching_out.demand_p (DEMAND_AVL))\n+\t{\n+\t  vl_vtype_info new_info = reaching_out;\n+\t  new_info.set_avl_info (avl_info (const0_rtx, nullptr));\n+\t  new_pat = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, new_info, NULL_RTX);\n+\t}\n+      else if (can_refine_vsetvl_p (cfg_bb, reaching_out))\n \tnew_pat\n \t  = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, reaching_out, NULL_RTX);\n       else if (vlmax_avl_p (reaching_out.get_avl ()))\n \tnew_pat = gen_vsetvl_pat (VSETVL_NORMAL, reaching_out,\n-\t\t\t\t  get_vl (reaching_out.get_insn ()->rtl ()));\n+\t\t\t\t  reaching_out.get_avl_reg_rtx ());\n       else\n \tnew_pat\n \t  = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, reaching_out, NULL_RTX);\n@@ -3459,12 +3930,36 @@ pass_vsetvl::propagate_avl (void) const\n \t    {\n \t      rtx vl = get_vl (insn->rtl ());\n \t      rtx avl = get_avl (insn->rtl ());\n-\t      if (vlmax_avl_p (avl))\n-\t\tcontinue;\n \t      def_info *def = find_access (insn->defs (), REGNO (vl));\n \t      set_info *set = safe_dyn_cast<set_info *> (def);\n+\t      vector_insn_info info;\n+\t      info.parse_insn (insn);\n \t      gcc_assert (set);\n-\t      const vl_vtype_info info = get_vl_vtype_info (insn);\n+\t      if (m_vector_manager->to_delete_vsetvls.contains (insn->rtl ()))\n+\t\t{\n+\t\t  m_vector_manager->to_delete_vsetvls.remove (insn->rtl ());\n+\t\t  if (m_vector_manager->to_refine_vsetvls.contains (\n+\t\t\tinsn->rtl ()))\n+\t\t    m_vector_manager->to_refine_vsetvls.remove (insn->rtl ());\n+\t\t  if (!set->has_nondebug_insn_uses ())\n+\t\t    {\n+\t\t      to_delete.add (insn->rtl ());\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      if (m_vector_manager->to_refine_vsetvls.contains (insn->rtl ()))\n+\t\t{\n+\t\t  m_vector_manager->to_refine_vsetvls.remove (insn->rtl ());\n+\t\t  if (!set->has_nondebug_insn_uses ())\n+\t\t    {\n+\t\t      rtx new_pat = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY,\n+\t\t\t\t\t\t    info, NULL_RTX);\n+\t\t      change_insn (insn->rtl (), new_pat);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      if (vlmax_avl_p (avl))\n+\t\tcontinue;\n \t      rtx new_pat\n \t\t= gen_vsetvl_pat (VSETVL_DISCARD_RESULT, info, NULL_RTX);\n \t      if (!set->has_nondebug_insn_uses ())"}, {"sha": "e3b494f99bedb84725a39849ea7e302f28ae3a31", "filename": "gcc/config/riscv/riscv-vsetvl.def", "status": "added", "additions": 684, "deletions": 0, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.def?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -0,0 +1,684 @@\n+/* VSETVL pass def for RISC-V 'V' Extension for GNU compiler.\n+   Copyright (C) 2023-2023 Free Software Foundation, Inc.\n+   Contributed by Juzhe Zhong (juzhe.zhong@rivai.ai), RiVAI Technologies Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or(at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY, WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef DEF_INCOMPATIBLE_COND\n+#define DEF_INCOMPATIBLE_COND(AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1,         \\\n+\t\t\t      GE_SEW1, TAIL_POLICTY1, MASK_POLICY1, AVL2,      \\\n+\t\t\t      SEW2, LMUL2, RATIO2, NONZERO_AVL2, GE_SEW2,      \\\n+\t\t\t      TAIL_POLICTY2, MASK_POLICY2, COND)\n+#endif\n+\n+#ifndef DEF_SEW_LMUL_FUSE_RULE\n+#define DEF_SEW_LMUL_FUSE_RULE(DEMAND_SEW1, DEMAND_LMUL1, DEMAND_RATIO1,       \\\n+\t\t\t       DEMAND_GE_SEW1, DEMAND_SEW2, DEMAND_LMUL2,      \\\n+\t\t\t       DEMAND_RATIO2, DEMAND_GE_SEW2, NEW_DEMAND_SEW,  \\\n+\t\t\t       NEW_DEMAND_LMUL, NEW_DEMAND_RATIO,              \\\n+\t\t\t       NEW_DEMAND_GE_SEW, NEW_SEW, NEW_VLMUL,          \\\n+\t\t\t       NEW_RATIO)\n+#endif\n+\n+#ifndef DEF_UNAVAILABLE_COND\n+#define DEF_UNAVAILABLE_COND(AVL1, SEW1, LMUL1, RATIO1, NONZERO_AVL1, GE_SEW1, \\\n+\t\t\t     TAIL_POLICTY1, MASK_POLICY1, AVL2, SEW2, LMUL2,   \\\n+\t\t\t     RATIO2, NONZERO_AVL2, GE_SEW2, TAIL_POLICTY2,     \\\n+\t\t\t     MASK_POLICY2, COND)\n+#endif\n+\n+/* Case 1: Demand compatible AVL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ incompatible_avl_p)\n+\n+/* Case 2: Demand same SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_sew_p)\n+\n+/* Case 3: Demand same LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+\n+/* Case 4: Demand same RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+\n+/* Case 5: Demand same TAIL_POLICY.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_TRUE, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_TRUE, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_tail_policy_p)\n+\n+/* Case 6: Demand same MASK_POLICY.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_TRUE,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_TRUE,\n+\t\t       /*COND*/ different_mask_policy_p)\n+\n+/* Case 7: Demand non zero AVL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ possible_zero_avl_p)\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ possible_zero_avl_p)\n+\n+/* Case 8: First SEW/LMUL/GE_SEW <-> Second RATIO/SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_ratio_invalid_for_first_sew_p)\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_ratio_invalid_for_first_lmul_p)\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_sew_less_than_first_sew_p)\n+\n+/* Case 9: Second SEW/LMUL/GE_SEW <-> First RATIO/SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_ratio_invalid_for_second_sew_p)\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_ratio_invalid_for_second_lmul_p)\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_sew_less_than_second_sew_p)\n+\n+/* Case 10: First (GE_SEW + LMUL) <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_ratio_less_than_first_ratio_p)\n+/* Case 11: First (SEW + LMUL) <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+/* Case 13: First (GE_SEW/SEW + RATIO) <-> Second LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+/* Case 14: First (LMUL + RATIO) <-> Second SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_sew_p)\n+/* Case 15: First (LMUL + RATIO) <-> Second GE_SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_sew_less_than_second_sew_p)\n+\n+/* Case 16: Second (GE_SEW + LMUL) <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_ratio_less_than_second_ratio_p)\n+/* Case 17: Second (SEW + LMUL) <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+/* Case 18: Second (GE_SEW/SEW + RATIO) <-> First LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+/* Case 19: Second (LMUL + RATIO) <-> First SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_sew_p)\n+/* Case 20: Second (LMUL + RATIO) <-> First GE_SEW.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_sew_less_than_first_sew_p)\n+\n+/* Case 18: First SEW + Second LMUL <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+/* Case 19: First SEW + Second LMUL <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_sew_p)\n+/* Case 20: Second SEW + First LMUL <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_sew_p)\n+/* Case 21: Second SEW + First LMUL <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+\n+/* Case 22: First SEW + Second RATIO <-> First LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+/* Case 23: Second SEW + First RATIO <-> Second LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+\n+/* Case 24: First GE_SEW + Second LMUL <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_lmul_less_than_first_lmul_p)\n+/* Case 25: First GE_SEW + Second LMUL <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_sew_less_than_first_sew_p)\n+/* Case 26: Second GE_SEW + First LMUL <-> First RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_sew_less_than_second_sew_p)\n+/* Case 27: Second GE_SEW + First LMUL <-> Second RATIO.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_lmul_less_than_second_lmul_p)\n+\n+/* Case 28: First GE_SEW + Second RATIO <-> First LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ second_ratio_less_than_first_ratio_p)\n+/* Case 29: Second GE_SEW + First RATIO <-> Second LMUL.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ first_ratio_less_than_second_ratio_p)\n+\n+/* Case 31: First GE_SEW + Second SEW + First LMUL + Second ratio.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+\n+/* Case 32: First GE_SEW + Second SEW + Second LMUL + First ratio.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+\n+/* Case 33: Second GE_SEW + First SEW + First LMUL + Second ratio.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_ratio_p)\n+\n+/* Case 34: Second GE_SEW + First SEW + Second LMUL + First ratio.  */\n+DEF_INCOMPATIBLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t       /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_TRUE,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t       /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t       /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t       /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t       /*COND*/ different_lmul_p)\n+\n+/* Merge rules.  */\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ false,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ true, greatest_sew, first_vlmul,\n+\t\t\tfirst_ratio)\n+\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_ANY,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*SEW*/ DEMAND_ANY, /*LMUL*/ DEMAND_ANY,\n+\t\t\t/*RATIO*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, first_sew,\n+\t\t\tvlmul_for_first_sew_second_ratio, second_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_ANY, /*LMUL*/ DEMAND_TRUE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_ANY,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_ANY,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, second_sew, first_vlmul,\n+\t\t\tratio_for_second_sew_first_vlmul)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_FALSE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ false,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ true, first_sew,\n+\t\t\tvlmul_for_first_sew_second_ratio, second_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ false,\n+\t\t\t/*NEW_DEMAND_RATIO*/ true,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ true, greatest_sew, first_vlmul,\n+\t\t\tsecond_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_FALSE, /*LMUL*/ DEMAND_TRUE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ true, first_sew, second_vlmul,\n+\t\t\tsecond_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_TRUE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, second_sew, second_vlmul,\n+\t\t\tsecond_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_TRUE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, greatest_sew, second_vlmul,\n+\t\t\tsecond_ratio)\n+\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ false,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, second_sew, second_vlmul,\n+\t\t\tsecond_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_TRUE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ true,\n+\t\t\t/*NEW_DEMAND_RATIO*/ false,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, second_sew, first_vlmul,\n+\t\t\tsecond_ratio)\n+DEF_SEW_LMUL_FUSE_RULE (/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_TRUE, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t\t/*SEW*/ DEMAND_TRUE, /*LMUL*/ DEMAND_FALSE,\n+\t\t\t/*RATIO*/ DEMAND_FALSE, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t\t/*NEW_DEMAND_SEW*/ true,\n+\t\t\t/*NEW_DEMAND_LMUL*/ false,\n+\t\t\t/*NEW_DEMAND_RATIO*/ true,\n+\t\t\t/*NEW_DEMAND_GE_SEW*/ false, second_sew, first_vlmul,\n+\t\t\tfirst_ratio)\n+\n+/* Define the unavailable cases for LCM.  */\n+\n+/* Case 1: Dem1 (Not demand AVL) is unavailable to Dem2 (Demand AVL).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_FALSE, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ always_unavailable)\n+/* Case 2: Dem1 (Demand AVL) is unavailable to Dem2 (Demand normal AVL).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_TRUE, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ avl_unavailable_p)\n+\n+/* Case 3: Dem1 (Not demand TAIL) is unavailable to Dem2 (Demand TAIL).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_FALSE, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_TRUE, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ always_unavailable)\n+\n+/* Case 4: Dem1 (Not demand MASK) is unavailable to Dem2 (Demand MASK).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_FALSE,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_TRUE,\n+\t\t      /*COND*/ always_unavailable)\n+\n+/* Case 5: Dem1 (Demand RATIO) is unavailable to Dem2 (Demand SEW/GE_SEW/LMUL).\n+ */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_FALSE,\n+\t\t      /*LMUL*/ DEMAND_FALSE, /*RATIO*/ DEMAND_TRUE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ always_unavailable)\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_FALSE,\n+\t\t      /*LMUL*/ DEMAND_FALSE, /*RATIO*/ DEMAND_TRUE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ always_unavailable)\n+\n+/* Case 6: Dem1 (Demand SEW).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t      /*LMUL*/ DEMAND_FALSE, /*RATIO*/ DEMAND_FALSE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ sew_unavailable_p)\n+\n+/* Case 7: Dem1 (Demand LMUL).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_FALSE,\n+\t\t      /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_FALSE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_FALSE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ lmul_unavailable_p)\n+\n+/* Case 8: Dem1 (Demand GE_SEW).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t      /*LMUL*/ DEMAND_FALSE, /*RATIO*/ DEMAND_FALSE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ ge_sew_unavailable_p)\n+\n+/* Case 9: Dem1 (Demand GE_SEW + LMUL).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t      /*LMUL*/ DEMAND_TRUE, /*RATIO*/ DEMAND_FALSE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ ge_sew_lmul_unavailable_p)\n+\n+/* Case 10: Dem1 (Demand GE_SEW + RATIO).  */\n+DEF_UNAVAILABLE_COND (/*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_TRUE,\n+\t\t      /*LMUL*/ DEMAND_FALSE, /*RATIO*/ DEMAND_TRUE,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_TRUE,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*AVL*/ DEMAND_ANY, /*SEW*/ DEMAND_ANY,\n+\t\t      /*LMUL*/ DEMAND_ANY, /*RATIO*/ DEMAND_ANY,\n+\t\t      /*NONZERO_AVL*/ DEMAND_ANY, /*GE_SEW*/ DEMAND_ANY,\n+\t\t      /*TAIL_POLICTY*/ DEMAND_ANY, /*MASK_POLICY*/ DEMAND_ANY,\n+\t\t      /*COND*/ ge_sew_ratio_unavailable_p)\n+\n+#undef DEF_INCOMPATIBLE_COND\n+#undef DEF_SEW_LMUL_FUSE_RULE\n+#undef DEF_UNAVAILABLE_COND"}, {"sha": "7b6fadf62694ce98e5c5b413f4ef6bde84bb4d49", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -47,11 +47,20 @@ enum demand_type\n   DEMAND_SEW,\n   DEMAND_LMUL,\n   DEMAND_RATIO,\n+  DEMAND_NONZERO_AVL,\n+  DEMAND_GE_SEW,\n   DEMAND_TAIL_POLICY,\n   DEMAND_MASK_POLICY,\n   NUM_DEMAND\n };\n \n+enum demand_status\n+{\n+  DEMAND_FALSE,\n+  DEMAND_TRUE,\n+  DEMAND_ANY,\n+};\n+\n enum fusion_type\n {\n   INVALID_FUSION,\n@@ -162,6 +171,14 @@ class avl_info\n   avl_info &operator= (const avl_info &);\n   bool operator== (const avl_info &) const;\n   bool operator!= (const avl_info &) const;\n+\n+  bool has_avl_imm () const\n+  {\n+    return get_value () && CONST_INT_P (get_value ());\n+  }\n+  bool has_avl_reg () const { return get_value () && REG_P (get_value ()); }\n+  bool has_avl_no_reg () const { return !get_value (); }\n+  bool has_non_zero_avl () const;\n };\n \n /* Basic structure to save VL/VTYPE information.  */\n@@ -197,10 +214,10 @@ struct vl_vtype_info\n   bool operator== (const vl_vtype_info &) const;\n   bool operator!= (const vl_vtype_info &) const;\n \n-  bool has_avl_imm () const { return get_avl () && CONST_INT_P (get_avl ()); }\n-  bool has_avl_reg () const { return get_avl () && REG_P (get_avl ()); }\n-  bool has_avl_no_reg () const { return !get_avl (); }\n-  bool has_non_zero_avl () const;\n+  bool has_avl_imm () const { return m_avl.has_avl_imm (); }\n+  bool has_avl_reg () const { return m_avl.has_avl_reg (); }\n+  bool has_avl_no_reg () const { return m_avl.has_avl_no_reg (); }\n+  bool has_non_zero_avl () const { return m_avl.has_non_zero_avl (); };\n \n   rtx get_avl () const { return m_avl.get_value (); }\n   const avl_info &get_avl_info () const { return m_avl; }\n@@ -353,8 +370,14 @@ class vector_insn_info : public vl_vtype_info\n \n   bool demand_p (enum demand_type type) const { return m_demands[type]; }\n   void demand (enum demand_type type) { m_demands[type] = true; }\n-  void demand_vl_vtype ();\n-  void undemand (enum demand_type type) { m_demands[type] = false; }\n+  void set_demand (enum demand_type type, bool value)\n+  {\n+    m_demands[type] = value;\n+  }\n+  void fuse_avl (const vector_insn_info &, const vector_insn_info &);\n+  void fuse_sew_lmul (const vector_insn_info &, const vector_insn_info &);\n+  void fuse_tail_policy (const vector_insn_info &, const vector_insn_info &);\n+  void fuse_mask_policy (const vector_insn_info &, const vector_insn_info &);\n \n   bool compatible_p (const vector_insn_info &) const;\n   bool compatible_avl_p (const vl_vtype_info &) const;\n@@ -364,6 +387,11 @@ class vector_insn_info : public vl_vtype_info\n   vector_insn_info merge (const vector_insn_info &, enum merge_type) const;\n \n   rtl_ssa::insn_info *get_insn () const { return m_insn; }\n+  const bool *get_demands (void) const { return m_demands; }\n+  rtx get_avl_reg_rtx (void) const\n+  {\n+    return gen_rtx_REG (Pmode, get_avl_source ()->regno ());\n+  }\n \n   void dump (FILE *) const;\n };\n@@ -388,6 +416,8 @@ class vector_infos_manager\n   auto_vec<vector_insn_info> vector_insn_infos;\n   auto_vec<vector_block_info> vector_block_infos;\n   auto_vec<vector_insn_info *> vector_exprs;\n+  hash_set<rtx_insn *> to_refine_vsetvls;\n+  hash_set<rtx_insn *> to_delete_vsetvls;\n \n   struct edge_list *vector_edge_list;\n   sbitmap *vector_kill;\n@@ -426,5 +456,49 @@ class vector_infos_manager\n   void dump (FILE *) const;\n };\n \n+struct demands_pair\n+{\n+  demand_status first[NUM_DEMAND];\n+  demand_status second[NUM_DEMAND];\n+  bool match_cond_p (const bool *dems1, const bool *dems2) const\n+  {\n+    for (unsigned i = 0; i < NUM_DEMAND; i++)\n+      {\n+\tif (first[i] != DEMAND_ANY && first[i] != dems1[i])\n+\t  return false;\n+\tif (second[i] != DEMAND_ANY && second[i] != dems2[i])\n+\t  return false;\n+      }\n+    return true;\n+  }\n+};\n+\n+struct demands_cond\n+{\n+  demands_pair pair;\n+  using CONDITION_TYPE\n+    = bool (*) (const vector_insn_info &, const vector_insn_info &);\n+  CONDITION_TYPE incompatible_p;\n+};\n+\n+struct demands_fuse_rule\n+{\n+  demands_pair pair;\n+  bool demand_sew_p;\n+  bool demand_lmul_p;\n+  bool demand_ratio_p;\n+  bool demand_ge_sew_p;\n+\n+  using NEW_SEW\n+    = unsigned (*) (const vector_insn_info &, const vector_insn_info &);\n+  using NEW_VLMUL\n+    = vlmul_type (*) (const vector_insn_info &, const vector_insn_info &);\n+  using NEW_RATIO\n+    = unsigned (*) (const vector_insn_info &, const vector_insn_info &);\n+  NEW_SEW new_sew;\n+  NEW_VLMUL new_vlmul;\n+  NEW_RATIO new_ratio;\n+};\n+\n } // namespace riscv_vector\n #endif"}, {"sha": "a4211c70e511c616814ecb087fbe9f11bc8fad8f", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -367,11 +367,11 @@\n ])\n \n (define_mode_attr VLMUL1 [\n-  (VNx1QI \"VNx8QI\") (VNx2QI \"VNx8QI\") (VNx4QI \"VNx8QI\") \n+  (VNx1QI \"VNx8QI\") (VNx2QI \"VNx8QI\") (VNx4QI \"VNx8QI\")\n   (VNx8QI \"VNx8QI\") (VNx16QI \"VNx8QI\") (VNx32QI \"VNx8QI\") (VNx64QI \"VNx8QI\")\n-  (VNx1HI \"VNx4HI\") (VNx2HI \"VNx4HI\") (VNx4HI \"VNx4HI\") \n+  (VNx1HI \"VNx4HI\") (VNx2HI \"VNx4HI\") (VNx4HI \"VNx4HI\")\n   (VNx8HI \"VNx4HI\") (VNx16HI \"VNx4HI\") (VNx32HI \"VNx4HI\")\n-  (VNx1SI \"VNx2SI\") (VNx2SI \"VNx2SI\") (VNx4SI \"VNx2SI\") \n+  (VNx1SI \"VNx2SI\") (VNx2SI \"VNx2SI\") (VNx4SI \"VNx2SI\")\n   (VNx8SI \"VNx2SI\") (VNx16SI \"VNx2SI\")\n   (VNx1DI \"VNx1DI\") (VNx2DI \"VNx1DI\")\n   (VNx4DI \"VNx1DI\") (VNx8DI \"VNx1DI\")\n@@ -382,40 +382,40 @@\n ])\n \n (define_mode_attr VLMUL1_ZVE32 [\n-  (VNx1QI \"VNx4QI\") (VNx2QI \"VNx4QI\") (VNx4QI \"VNx4QI\") \n+  (VNx1QI \"VNx4QI\") (VNx2QI \"VNx4QI\") (VNx4QI \"VNx4QI\")\n   (VNx8QI \"VNx4QI\") (VNx16QI \"VNx4QI\") (VNx32QI \"VNx4QI\")\n-  (VNx1HI \"VNx2HI\") (VNx2HI \"VNx2HI\") (VNx4HI \"VNx2HI\") \n+  (VNx1HI \"VNx2HI\") (VNx2HI \"VNx2HI\") (VNx4HI \"VNx2HI\")\n   (VNx8HI \"VNx2HI\") (VNx16HI \"VNx2HI\")\n-  (VNx1SI \"VNx1SI\") (VNx2SI \"VNx1SI\") (VNx4SI \"VNx1SI\") \n+  (VNx1SI \"VNx1SI\") (VNx2SI \"VNx1SI\") (VNx4SI \"VNx1SI\")\n   (VNx8SI \"VNx1SI\")\n   (VNx1SF \"VNx2SF\") (VNx2SF \"VNx2SF\")\n   (VNx4SF \"VNx2SF\") (VNx8SF \"VNx2SF\")\n ])\n \n (define_mode_attr VWLMUL1 [\n-  (VNx1QI \"VNx4HI\") (VNx2QI \"VNx4HI\") (VNx4QI \"VNx4HI\") \n+  (VNx1QI \"VNx4HI\") (VNx2QI \"VNx4HI\") (VNx4QI \"VNx4HI\")\n   (VNx8QI \"VNx4HI\") (VNx16QI \"VNx4HI\") (VNx32QI \"VNx4HI\") (VNx64QI \"VNx4HI\")\n-  (VNx1HI \"VNx2SI\") (VNx2HI \"VNx2SI\") (VNx4HI \"VNx2SI\") \n+  (VNx1HI \"VNx2SI\") (VNx2HI \"VNx2SI\") (VNx4HI \"VNx2SI\")\n   (VNx8HI \"VNx2SI\") (VNx16HI \"VNx2SI\") (VNx32HI \"VNx2SI\")\n-  (VNx1SI \"VNx1DI\") (VNx2SI \"VNx1DI\") (VNx4SI \"VNx1DI\") \n+  (VNx1SI \"VNx1DI\") (VNx2SI \"VNx1DI\") (VNx4SI \"VNx1DI\")\n   (VNx8SI \"VNx1DI\") (VNx16SI \"VNx1DI\")\n   (VNx1SF \"VNx1DF\") (VNx2SF \"VNx1DF\")\n   (VNx4SF \"VNx1DF\") (VNx8SF \"VNx1DF\") (VNx16SF \"VNx1DF\")\n ])\n \n (define_mode_attr VWLMUL1_ZVE32 [\n-  (VNx1QI \"VNx2HI\") (VNx2QI \"VNx2HI\") (VNx4QI \"VNx2HI\") \n+  (VNx1QI \"VNx2HI\") (VNx2QI \"VNx2HI\") (VNx4QI \"VNx2HI\")\n   (VNx8QI \"VNx2HI\") (VNx16QI \"VNx2HI\") (VNx32QI \"VNx2HI\")\n-  (VNx1HI \"VNx1SI\") (VNx2HI \"VNx1SI\") (VNx4HI \"VNx1SI\") \n+  (VNx1HI \"VNx1SI\") (VNx2HI \"VNx1SI\") (VNx4HI \"VNx1SI\")\n   (VNx8HI \"VNx1SI\") (VNx16HI \"VNx1SI\")\n ])\n \n (define_mode_attr vlmul1 [\n-  (VNx1QI \"vnx8qi\") (VNx2QI \"vnx8qi\") (VNx4QI \"vnx8qi\") \n+  (VNx1QI \"vnx8qi\") (VNx2QI \"vnx8qi\") (VNx4QI \"vnx8qi\")\n   (VNx8QI \"vnx8qi\") (VNx16QI \"vnx8qi\") (VNx32QI \"vnx8qi\") (VNx64QI \"vnx8qi\")\n-  (VNx1HI \"vnx4hi\") (VNx2HI \"vnx4hi\") (VNx4HI \"vnx4hi\") \n+  (VNx1HI \"vnx4hi\") (VNx2HI \"vnx4hi\") (VNx4HI \"vnx4hi\")\n   (VNx8HI \"vnx4hi\") (VNx16HI \"vnx4hi\") (VNx32HI \"vnx4hi\")\n-  (VNx1SI \"vnx2si\") (VNx2SI \"vnx2si\") (VNx4SI \"vnx2si\") \n+  (VNx1SI \"vnx2si\") (VNx2SI \"vnx2si\") (VNx4SI \"vnx2si\")\n   (VNx8SI \"vnx2si\") (VNx16SI \"vnx2si\")\n   (VNx1DI \"vnx1DI\") (VNx2DI \"vnx1DI\")\n   (VNx4DI \"vnx1DI\") (VNx8DI \"vnx1DI\")\n@@ -426,31 +426,31 @@\n ])\n \n (define_mode_attr vlmul1_zve32 [\n-  (VNx1QI \"vnx4qi\") (VNx2QI \"vnx4qi\") (VNx4QI \"vnx4qi\") \n+  (VNx1QI \"vnx4qi\") (VNx2QI \"vnx4qi\") (VNx4QI \"vnx4qi\")\n   (VNx8QI \"vnx4qi\") (VNx16QI \"vnx4qi\") (VNx32QI \"vnx4qi\")\n-  (VNx1HI \"vnx2hi\") (VNx2HI \"vnx2hi\") (VNx4HI \"vnx2hi\") \n+  (VNx1HI \"vnx2hi\") (VNx2HI \"vnx2hi\") (VNx4HI \"vnx2hi\")\n   (VNx8HI \"vnx2hi\") (VNx16HI \"vnx2hi\")\n-  (VNx1SI \"vnx1si\") (VNx2SI \"vnx1si\") (VNx4SI \"vnx1si\") \n+  (VNx1SI \"vnx1si\") (VNx2SI \"vnx1si\") (VNx4SI \"vnx1si\")\n   (VNx8SI \"vnx1si\")\n   (VNx1SF \"vnx1sf\") (VNx2SF \"vnx1sf\")\n   (VNx4SF \"vnx1sf\") (VNx8SF \"vnx1sf\")\n ])\n \n (define_mode_attr vwlmul1 [\n-  (VNx1QI \"vnx4hi\") (VNx2QI \"vnx4hi\") (VNx4QI \"vnx4hi\") \n+  (VNx1QI \"vnx4hi\") (VNx2QI \"vnx4hi\") (VNx4QI \"vnx4hi\")\n   (VNx8QI \"vnx4hi\") (VNx16QI \"vnx4hi\") (VNx32QI \"vnx4hi\") (VNx64QI \"vnx4hi\")\n-  (VNx1HI \"vnx2si\") (VNx2HI \"vnx2si\") (VNx4HI \"vnx2si\") \n+  (VNx1HI \"vnx2si\") (VNx2HI \"vnx2si\") (VNx4HI \"vnx2si\")\n   (VNx8HI \"vnx2si\") (VNx16HI \"vnx2si\") (VNx32HI \"vnx2SI\")\n-  (VNx1SI \"vnx2di\") (VNx2SI \"vnx2di\") (VNx4SI \"vnx2di\") \n+  (VNx1SI \"vnx2di\") (VNx2SI \"vnx2di\") (VNx4SI \"vnx2di\")\n   (VNx8SI \"vnx2di\") (VNx16SI \"vnx2di\")\n   (VNx1SF \"vnx1df\") (VNx2SF \"vnx1df\")\n   (VNx4SF \"vnx1df\") (VNx8SF \"vnx1df\") (VNx16SF \"vnx1df\")\n ])\n \n (define_mode_attr vwlmul1_zve32 [\n-  (VNx1QI \"vnx2hi\") (VNx2QI \"vnx2hi\") (VNx4QI \"vnx2hi\") \n+  (VNx1QI \"vnx2hi\") (VNx2QI \"vnx2hi\") (VNx4QI \"vnx2hi\")\n   (VNx8QI \"vnx2hi\") (VNx16QI \"vnx2hi\") (VNx32QI \"vnx2hi\")\n-  (VNx1HI \"vnx1si\") (VNx2HI \"vnx1si\") (VNx4HI \"vnx1si\") \n+  (VNx1HI \"vnx1si\") (VNx2HI \"vnx1si\") (VNx4HI \"vnx1si\")\n   (VNx8HI \"vnx1si\") (VNx16HI \"vnx1SI\")\n ])\n "}, {"sha": "4d5b7c6e8f2f04af8f29f0de7c15138ecaca1887", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 215, "deletions": 28, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -151,8 +151,9 @@\n \t\t\t  vfwalu,vfwmul,vfsqrt,vfrecp,vfsgnj,vfcmp,\\\n \t\t\t  vfmerge,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n \t\t\t  vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,\\\n-\t\t\t  vfncvtftof,vfmuladd,vfwmuladd,vfclass,vired,\n-\t\t\t  viwred,vfredu,vfredo,vfwredu,vfwredo\")\n+\t\t\t  vfncvtftof,vfmuladd,vfwmuladd,vfclass,vired,\\\n+\t\t\t  viwred,vfredu,vfredo,vfwredu,vfwredo,vimovvx,\\\n+\t\t\t  vimovxv,vfmovvf,vfmovfv\")\n \t   (const_int INVALID_ATTRIBUTE)\n \t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n \t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n@@ -208,7 +209,7 @@\n \t\t\t\tvmiota,vmidx,vfalu,vfmul,vfminmax,vfdiv,vfwalu,vfwmul,\\\n \t\t\t\tvfsqrt,vfrecp,vfsgnj,vfcmp,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n \t\t\t\tvfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,vfclass,\\\n-\t\t\t\tvired,viwred,vfredu,vfredo,vfwredu,vfwredo\")\n+\t\t\t\tvired,viwred,vfredu,vfredo,vfwredu,vfwredo,vimovxv,vfmovfv\")\n \t       (const_int 2)\n \n \t       (eq_attr \"type\" \"vimerge,vfmerge\")\n@@ -223,7 +224,7 @@\n   (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vmalu,vsts,vstux,\\\n \t\t\t  vstox,vext,vmsfs,vmiota,vfsqrt,vfrecp,vfcvtitof,\\\n \t\t\t  vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,vfncvtitof,\\\n-\t\t\t  vfncvtftoi,vfncvtftof,vfclass\")\n+\t\t\t  vfncvtftoi,vfncvtftof,vfclass,vimovxv,vfmovfv\")\n \t   (const_int 4)\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -250,7 +251,7 @@\n (define_attr \"ta\" \"\"\n   (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vext,vmiota,vfsqrt,vfrecp,\\\n \t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,\\\n-\t\t\t  vfncvtitof,vfncvtftoi,vfncvtftof,vfclass\")\n+\t\t\t  vfncvtitof,vfncvtftoi,vfncvtftof,vfclass,vimovxv,vfmovfv\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -306,7 +307,8 @@\n   (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vext,vimerge,\\\n \t\t\t  vfsqrt,vfrecp,vfmerge,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n \t\t\t  vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n-\t\t\t  vfclass,vired,viwred,vfredu,vfredo,vfwredu,vfwredo\")\n+\t\t\t  vfclass,vired,viwred,vfredu,vfredo,vfwredu,vfwredo,\\\n+\t\t\t  vimovxv,vfmovfv\")\n \t   (symbol_ref \"INTVAL (operands[7])\")\n \t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n \t   (symbol_ref \"INTVAL (operands[5])\")\n@@ -985,6 +987,8 @@\n ;; - 7.5. Vector Strided Instructions (zero stride)\n ;; - 11.16 Vector Integer Move Instructions (vmv.v.x)\n ;; - 13.16 Vector Floating-Point Move Instruction (vfmv.v.f)\n+;; - 16.1 Integer Scalar Move Instructions (vmv.s.x)\n+;; - 16.2 Floating-Point Scalar Move Instructions (vfmv.s.f)\n ;; -------------------------------------------------------------------------------\n \n ;; According to RVV ISA, vector-scalar instruction doesn't support\n@@ -995,25 +999,70 @@\n ;; expand --> LICM (Loop invariant) --> split.\n ;; To use LICM optimization, we postpone generation of vlse.v to split stage since\n ;; a memory access instruction can not be optimized by LICM (Loop invariant).\n-(define_insn_and_split \"@pred_broadcast<mode>\"\n-  [(set (match_operand:VI 0 \"register_operand\"                \"=vr,   vr,  vr\")\n+(define_expand \"@pred_broadcast<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\")\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_broadcast_mask_operand\")\n+\t     (match_operand 4 \"vector_length_operand\")\n+\t     (match_operand 5 \"const_int_operand\")\n+\t     (match_operand 6 \"const_int_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (vec_duplicate:V\n+\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"))\n+\t  (match_operand:V 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  /* Handle vmv.s.x instruction which has memory scalar.  */\n+  if (satisfies_constraint_Wdm (operands[3]) || riscv_vector::simm5_p (operands[3])\n+      || rtx_equal_p (operands[3], CONST0_RTX (<VEL>mode)))\n+    {\n+      if (satisfies_constraint_Wb1 (operands[1]))\n+        {\n+          // Case 1: vmv.s.x (TA) ==> vlse.v (TA)\n+          if (satisfies_constraint_vu (operands[2]))\n+            operands[1] = CONSTM1_RTX (<VM>mode);\n+          else if (GET_MODE_BITSIZE (<VEL>mode) > GET_MODE_BITSIZE (Pmode))\n+            {\n+\t      // Case 2: vmv.s.x (TU) ==> andi vl + vlse.v (TU) in RV32 system.\n+\t      rtx tmp = gen_reg_rtx (Pmode);\n+              emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (Pmode, operands[4], const1_rtx)));\n+\t      operands[4] = tmp;\n+\t      operands[1] = CONSTM1_RTX (<VM>mode);\n+\t    }\n+          else\n+            operands[3] = force_reg (<VEL>mode, operands[3]);\n+\t}\n+    }\n+  else if (GET_MODE_BITSIZE (<VEL>mode) > GET_MODE_BITSIZE (Pmode)\n+           && immediate_operand (operands[3], Pmode))\n+    operands[3] = gen_rtx_SIGN_EXTEND (<VEL>mode, force_reg (Pmode, operands[3]));\n+  else\n+    operands[3] = force_reg (<VEL>mode, operands[3]);\n+})\n+\n+(define_insn_and_split \"*pred_broadcast<mode>\"\n+  [(set (match_operand:VI 0 \"register_operand\"                     \"=vr,   vd,  vr,  vr\")\n \t(if_then_else:VI\n \t  (unspec:<VM>\n-\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" Wc1,  vm, Wc1\")\n-\t     (match_operand 4 \"vector_length_operand\"         \" rK,   rK,  rK\")\n-\t     (match_operand 5 \"const_int_operand\"             \"  i,    i,   i\")\n-\t     (match_operand 6 \"const_int_operand\"             \"  i,    i,   i\")\n-\t     (match_operand 7 \"const_int_operand\"             \"  i,    i,   i\")\n+\t    [(match_operand:<VM> 1 \"vector_broadcast_mask_operand\" \" Wc1,  vm, Wc1, Wb1\")\n+\t     (match_operand 4 \"vector_length_operand\"              \" rK,   rK,  rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (vec_duplicate:VI\n-\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"  \"  r, Wdm, Wdm\"))\n-\t  (match_operand:VI 2 \"vector_merge_operand\"           \"0vu, 0vu, 0vu\")))]\n+\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"       \"  r, Wdm, Wdm,   r\"))\n+\t  (match_operand:VI 2 \"vector_merge_operand\"                \"0vu, 0vu, 0vu, 0vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vmv.v.x\\t%0,%3\n    vlse<sew>.v\\t%0,%3,zero,%1.t\n-   vlse<sew>.v\\t%0,%3,zero\"\n+   vlse<sew>.v\\t%0,%3,zero\n+   vmv.s.x\\t%0,%3\"\n   \"register_operand (operands[3], <VEL>mode)\n   && GET_MODE_BITSIZE (<VEL>mode) > GET_MODE_BITSIZE (Pmode)\"\n   [(set (match_dup 0)\n@@ -1030,30 +1079,65 @@\n     emit_move_insn (m, operands[3]);\n     m = gen_rtx_MEM (<VEL>mode, force_reg (Pmode, XEXP (m, 0)));\n     operands[3] = m;\n+\n+    /* For SEW = 64 in RV32 system, we expand vmv.s.x:\n+       andi a2,a2,1\n+       vsetvl zero,a2,e64\n+       vlse64.v  */\n+    if (satisfies_constraint_Wb1 (operands[1]))\n+      {\n+\trtx tmp = gen_reg_rtx (Pmode);\n+        emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (Pmode, operands[4], const1_rtx)));\n+        operands[4] = tmp;\n+\toperands[1] = CONSTM1_RTX (<VM>mode);\n+      }\n   }\n-  [(set_attr \"type\" \"vimov,vlds,vlds\")\n+  [(set_attr \"type\" \"vimov,vlds,vlds,vimovxv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"@pred_broadcast<mode>\"\n-  [(set (match_operand:VF 0 \"register_operand\"                \"=vr,   vr,  vr\")\n+(define_insn \"*pred_broadcast<mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"                     \"=vr,   vr,  vr,  vr\")\n \t(if_then_else:VF\n \t  (unspec:<VM>\n-\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" Wc1,  vm, Wc1\")\n-\t     (match_operand 4 \"vector_length_operand\"         \" rK,   rK,  rK\")\n-\t     (match_operand 5 \"const_int_operand\"             \"  i,    i,   i\")\n-\t     (match_operand 6 \"const_int_operand\"             \"  i,    i,   i\")\n-\t     (match_operand 7 \"const_int_operand\"             \"  i,    i,   i\")\n+\t    [(match_operand:<VM> 1 \"vector_broadcast_mask_operand\" \" Wc1,  vm, Wc1, Wb1\")\n+\t     (match_operand 4 \"vector_length_operand\"              \" rK,   rK,  rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"  i,    i,   i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (vec_duplicate:VF\n-\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"  \"  f, Wdm, Wdm\"))\n-\t  (match_operand:VF 2 \"vector_merge_operand\"           \"0vu, 0vu, 0vu\")))]\n+\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"       \"  f, Wdm, Wdm,   f\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"                \"0vu, 0vu, 0vu, 0vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vfmv.v.f\\t%0,%3\n    vlse<sew>.v\\t%0,%3,zero,%1.t\n-   vlse<sew>.v\\t%0,%3,zero\"\n-  [(set_attr \"type\" \"vfmov\")\n+   vlse<sew>.v\\t%0,%3,zero\n+   vfmv.s.f\\t%0,%3\"\n+  [(set_attr \"type\" \"vfmov,vlds,vlds,vfmovfv\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_broadcast<mode>_extended_scalar\"\n+  [(set (match_operand:VI_D 0 \"register_operand\"                     \"=vr,   vr\")\n+\t(if_then_else:VI_D\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_broadcast_mask_operand\" \" Wc1, Wb1\")\n+\t     (match_operand 4 \"vector_length_operand\"              \" rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"                  \"  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (vec_duplicate:VI_D\n+\t    (sign_extend:<VEL>\n+\t      (match_operand:<VSUBEL> 3 \"register_operand\"          \"  r,   r\")))\n+\t  (match_operand:VI_D 2 \"vector_merge_operand\"              \"0vu, 0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vmv.v.x\\t%0,%3\n+   vmv.s.x\\t%0,%3\"\n+  [(set_attr \"type\" \"vimov,vimovxv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; -------------------------------------------------------------------------------\n@@ -6390,3 +6474,106 @@\n   \"vfwred<order>sum.vs\\t%0,%3,%4%p1\"\n   [(set_attr \"type\" \"vfwred<order>\")\n    (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated permutation operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 16.1 Integer Scalar Move Instructions\n+;; - 16.2 Floating-Point Scalar Move Instructions\n+;; - 16.3 Vector Slide Instructions\n+;; - 16.4 Vector Register Gather Instructions\n+;; - 16.5 Vector Compress Instruction\n+;; -------------------------------------------------------------------------------\n+\n+(define_expand \"@pred_extract_first<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\")\n+\t(unspec:<VEL>\n+\t  [(vec_select:<VEL>\n+\t     (match_operand:VI 1 \"reg_or_mem_operand\")\n+\t     (parallel [(const_int 0)]))\n+\t   (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE))]\n+  \"TARGET_VECTOR\"\n+{\n+  if (MEM_P (operands[1]))\n+    {\n+      /* Combine vle.v + vmv.x.s ==> lw.  */\n+      emit_move_insn (operands[0], gen_rtx_MEM (<VEL>mode, XEXP (operands[1], 0)));\n+      DONE;\n+    }\n+})\n+\n+(define_insn_and_split \"*pred_extract_first<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\"   \"=r\")\n+\t(unspec:<VEL>\n+\t  [(vec_select:<VEL>\n+\t     (match_operand:VI 1 \"register_operand\" \"vr\")\n+\t     (parallel [(const_int 0)]))\n+\t   (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE))]\n+  \"TARGET_VECTOR\"\n+  \"vmv.x.s\\t%0,%1\"\n+  \"known_gt (GET_MODE_BITSIZE (<VEL>mode), GET_MODE_BITSIZE (Pmode))\"\n+  [(const_int 0)]\n+{\n+  /* In rv32 system, we can't use vmv.x.s directly.\n+     Instead, we should generate this following code sequence:\n+       vsrl.vx v16,v8,a0\n+       vmv.x.s a1,v16\n+       vmv.x.s a0,v8  */\n+  rtx nbits = force_reg (Pmode, gen_int_mode (GET_MODE_BITSIZE (Pmode), Pmode));\n+  rtx high_bits = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_pred_scalar (LSHIFTRT, <MODE>mode, high_bits, CONSTM1_RTX (<VM>mode),\n+  \t\t\tRVV_VUNDEF (<MODE>mode), operands[1], nbits, /* vl */ const1_rtx,\n+\t\t\tgen_int_mode (riscv_vector::TAIL_ANY, Pmode),\n+\t\t\tgen_int_mode (riscv_vector::MASK_ANY, Pmode),\n+\t\t\tgen_int_mode (riscv_vector::NONVLMAX, Pmode)));\n+  emit_insn (gen_pred_extract_first_trunc (<MODE>mode,\n+  \t\t\tgen_highpart (SImode, operands[0]), high_bits));\n+  emit_insn (gen_pred_extract_first_trunc (<MODE>mode,\n+  \t\t\tgen_lowpart (SImode, operands[0]), operands[1]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vimovvx\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_extract_first_trunc<mode>\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n+        (truncate:SI\n+\t  (unspec:<VEL>\n+\t    [(vec_select:<VEL>\n+\t       (match_operand:VI_D 1 \"register_operand\" \"vr\")\n+\t       (parallel [(const_int 0)]))\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)))]\n+  \"TARGET_VECTOR\"\n+  \"vmv.x.s\\t%0,%1\"\n+  [(set_attr \"type\" \"vimovvx\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_extract_first<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\")\n+\t(unspec:<VEL>\n+\t  [(vec_select:<VEL>\n+\t     (match_operand:VF 1 \"reg_or_mem_operand\")\n+\t     (parallel [(const_int 0)]))\n+\t   (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE))]\n+  \"TARGET_VECTOR\"\n+{\n+  if (MEM_P (operands[1]))\n+    {\n+      /* Combine vle.v + vmv.f.s ==> flw.  */\n+      emit_move_insn (operands[0], gen_rtx_MEM (<VEL>mode, XEXP (operands[1], 0)));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*pred_extract_first<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\"   \"=f\")\n+\t(unspec:<VEL>\n+\t  [(vec_select:<VEL>\n+\t     (match_operand:VF 1 \"register_operand\" \"vr\")\n+\t     (parallel [(const_int 0)]))\n+\t   (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE))]\n+  \"TARGET_VECTOR\"\n+  \"vfmv.f.s\\t%0,%1\"\n+  [(set_attr \"type\" \"vfmovvf\")\n+   (set_attr \"mode\" \"<MODE>\")])"}, {"sha": "1204f83e6bd11d6f2134b504793522764807ab07", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-10.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -19,5 +19,5 @@ void foo(int32_t *in1, int32_t *in2, int32_t *in3, int32_t *out, size_t n, int c\n }\n \n /* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*[a-x0-9]+,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n /* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}, {"sha": "637b0a52295514b7ea85e8b725fc43f7c6314911", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-11.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -19,5 +19,5 @@ void foo(int32_t *in1, int32_t *in2, int32_t *in3, int32_t *out, size_t n, int c\n }\n \n /* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*[a-x0-9]+,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n /* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}, {"sha": "e32994e5212f621503cf39ea04ad76503220ae7b", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-12.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -22,5 +22,5 @@ void foo(int32_t *in1, int32_t *in2, int32_t *in3, int32_t *out, size_t n, int c\n }\n \n /* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*[a-x0-9]+,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n /* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}, {"sha": "79a6f271997e8cf119a3d6836a81bd4f6170ce0e", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-15.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-15.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -18,6 +18,6 @@ void foo(int32_t *in1, int32_t *in2, int32_t *in3, int32_t *out, size_t n, int c\n   }\n }\n \n-/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n /* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n-/* { dg-final { scan-assembler-times {slli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*5} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n\\ No newline at end of file\n+/* { dg-final { scan-assembler-times {slli\\s+[a-x0-9]+,\\s*[a-x0-9]+,\\s*5} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}, {"sha": "8baedb0fef75eb13fdc7a0ec3210a63d02e14066", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-18.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-18.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -16,4 +16,4 @@ void f(int8_t *base, int8_t *out, size_t vl, size_t m, size_t n) {\n   }\n }\n \n-/* { dg-final { scan-assembler-times {vsetvli} 4 { target { no-opts \"-O0\" no-opts \"-Os\" no-opts \"-Oz\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli} 3 { target { no-opts \"-O0\" no-opts \"-O1\" no-opts \"-Os\" no-opts \"-Oz\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}, {"sha": "1204f83e6bd11d6f2134b504793522764807ab07", "filename": "gcc/testsuite/gcc.target/riscv/rvv/vsetvl/vsetvlmax-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec99ffabc3d32bbc0cce164e84942e176c13e75c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fvsetvl%2Fvsetvlmax-9.c?ref=ec99ffabc3d32bbc0cce164e84942e176c13e75c", "patch": "@@ -19,5 +19,5 @@ void foo(int32_t *in1, int32_t *in2, int32_t *in3, int32_t *out, size_t n, int c\n }\n \n /* { dg-final { scan-assembler-times {vsetvli\\s+zero,\\s*[a-x0-9]+,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n-/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*tu,\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n+/* { dg-final { scan-assembler-times {vsetvli\\s+[a-x0-9]+,\\s*zero,\\s*e32,\\s*m1,\\s*t[au],\\s*m[au]} 1 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */\n /* { dg-final { scan-assembler-times {vsetvli} 2 { target { no-opts \"-O0\" no-opts \"-g\" no-opts \"-funroll-loops\" } } } } */"}]}