{"sha": "f24ea9120d7b97d0b6b047de94865f7f190e6daa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0ZWE5MTIwZDdiOTdkMGI2YjA0N2RlOTQ4NjVmN2YxOTBlNmRhYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:00:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:00:24Z"}, "message": "[multiple changes]\n\n2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Is_Predicate_Static): An inherited predicate\n\tcan be static only if it applies to a scalar type.\n\n2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Adjust_Result_Type): Convert operand to base\n\ttype to prevent spurious constraint checks on subtypes of Boolean.\n\n2016-06-22  Bob Duff  <duff@adacore.com>\n\n\t* debug.adb: Document debug switch -gnatd.o.\n\t* sem_elab.adb (Check_Internal_Call): Debug switch -gnatd.o\n\tnow causes a more conservative treatment of indirect calls,\n\ttreating P'Access as a call to P in more cases. We Can't make\n\tthis the default, because it breaks common idioms, for example\n\tthe soft links.\n\t* sem_util.adb: Add an Assert.\n\n2016-06-22  Bob Duff  <duff@adacore.com>\n\n\t* a-cuprqu.ads, a-cuprqu.adb: Completely rewrite this package. Use\n\tred-black trees, which gives O(lg N) worst-case performance on\n\tEnqueue and Dequeue. The previous version had O(N) Enqueue in\n\tthe worst case.\n\n2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_warn.adb: minor style fix in comment.\n\t* spark_xrefs.ads (Scope_Num): type refined to positive integers.\n\t* lib-xref-spark_specific.adb (Detect_And_Add_SPARK_Scope):\n\tmoved into scope of Collect_SPARK_Xrefs.\n\t(Add_SPARK_Scope): moved into scope of Collect_SPARK_Xrefs;\n\tnow uses Dspec and Scope_Id from Collect_SPARK_Xrefs.\n\t(Collect_SPARK_Xrefs): refactored to avoid retraversing the list\n\tof scopes.\n\t* sem_ch3.adb (Build_Discriminal): Set Parent of the discriminal.\n\nFrom-SVN: r237687", "tree": {"sha": "898dcd616c3f4dc1766f5a5d7ddd8d029294e830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/898dcd616c3f4dc1766f5a5d7ddd8d029294e830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f24ea9120d7b97d0b6b047de94865f7f190e6daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24ea9120d7b97d0b6b047de94865f7f190e6daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24ea9120d7b97d0b6b047de94865f7f190e6daa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24ea9120d7b97d0b6b047de94865f7f190e6daa/comments", "author": null, "committer": null, "parents": [{"sha": "3ae6c64384e49b9d60fb622f88ab50a42c4c1d5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae6c64384e49b9d60fb622f88ab50a42c4c1d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ae6c64384e49b9d60fb622f88ab50a42c4c1d5c"}], "stats": {"total": 412, "additions": 128, "deletions": 284}, "files": [{"sha": "0302b488863cee9bcdfb3b26d94a4af7c89f1179", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -1,3 +1,42 @@\n+2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Is_Predicate_Static): An inherited predicate\n+\tcan be static only if it applies to a scalar type.\n+\n+2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Adjust_Result_Type): Convert operand to base\n+\ttype to prevent spurious constraint checks on subtypes of Boolean.\n+\n+2016-06-22  Bob Duff  <duff@adacore.com>\n+\n+\t* debug.adb: Document debug switch -gnatd.o.\n+\t* sem_elab.adb (Check_Internal_Call): Debug switch -gnatd.o\n+\tnow causes a more conservative treatment of indirect calls,\n+\ttreating P'Access as a call to P in more cases. We Can't make\n+\tthis the default, because it breaks common idioms, for example\n+\tthe soft links.\n+\t* sem_util.adb: Add an Assert.\n+\n+2016-06-22  Bob Duff  <duff@adacore.com>\n+\n+\t* a-cuprqu.ads, a-cuprqu.adb: Completely rewrite this package. Use\n+\tred-black trees, which gives O(lg N) worst-case performance on\n+\tEnqueue and Dequeue. The previous version had O(N) Enqueue in\n+\tthe worst case.\n+\n+2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_warn.adb: minor style fix in comment.\n+\t* spark_xrefs.ads (Scope_Num): type refined to positive integers.\n+\t* lib-xref-spark_specific.adb (Detect_And_Add_SPARK_Scope):\n+\tmoved into scope of Collect_SPARK_Xrefs.\n+\t(Add_SPARK_Scope): moved into scope of Collect_SPARK_Xrefs;\n+\tnow uses Dspec and Scope_Id from Collect_SPARK_Xrefs.\n+\t(Collect_SPARK_Xrefs): refactored to avoid retraversing the list\n+\tof scopes.\n+\t* sem_ch3.adb (Build_Discriminal): Set Parent of the discriminal.\n+\n 2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n \n \t* lib-xref-spark_specific.adb (Generate_Dereference): Assignment to not"}, {"sha": "5d1bbacfc63c6df92f1674656892ae634cf26851", "filename": "gcc/ada/a-cuprqu.adb", "status": "modified", "additions": 30, "deletions": 224, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fa-cuprqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fa-cuprqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2011-2015, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2011-2016, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,225 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Unchecked_Deallocation;\n-\n package body Ada.Containers.Unbounded_Priority_Queues is\n \n-   package body Implementation is\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      function Before_Or_Equal (X, Y : Queue_Priority) return Boolean;\n-      --  True if X is before or equal to Y. Equal means both Before(X,Y) and\n-      --  Before(Y,X) are False.\n-\n-      procedure Free is\n-        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n-      ---------------------\n-      -- Before_Or_Equal --\n-      ---------------------\n-\n-      function Before_Or_Equal (X, Y : Queue_Priority) return Boolean is\n-      begin\n-         return (if Before (X, Y) then True else not Before (Y, X));\n-      end Before_Or_Equal;\n-\n-      -------------\n-      -- Dequeue --\n-      -------------\n-\n-      procedure Dequeue\n-        (List    : in out List_Type;\n-         Element : out Queue_Interfaces.Element_Type)\n-      is\n-         H : constant Node_Access := List.Header'Unchecked_Access;\n-         pragma Assert (List.Length /= 0);\n-         pragma Assert (List.Header.Next /= H);\n-         --  List can't be empty; see the barrier\n-\n-         pragma Assert\n-           (List.Header.Next.Next = H or else\n-            Before_Or_Equal (Get_Priority (List.Header.Next.Element),\n-                             Get_Priority (List.Header.Next.Next.Element)));\n-         --  The first item is before-or-equal to the second\n-\n-         pragma Assert\n-           (List.Header.Next.Next_Unequal = H or else\n-            Before (Get_Priority (List.Header.Next.Element),\n-                    Get_Priority (List.Header.Next.Next_Unequal.Element)));\n-         --  The first item is before its Next_Unequal item\n-\n-         --  The highest-priority item is always first; just remove it and\n-         --  return that element.\n-\n-         X : Node_Access := List.Header.Next;\n-\n-      --  Start of processing for Dequeue\n-\n-      begin\n-         Element := X.Element;\n-         X.Next.Prev := H;\n-         List.Header.Next := X.Next;\n-         List.Header.Next_Unequal := X.Next;\n-         List.Length := List.Length - 1;\n-         Free (X);\n-      end Dequeue;\n-\n-      procedure Dequeue\n-        (List     : in out List_Type;\n-         At_Least : Queue_Priority;\n-         Element  : in out Queue_Interfaces.Element_Type;\n-         Success  : out Boolean)\n-      is\n-      begin\n-         --  This operation dequeues a high priority item if it exists in the\n-         --  queue. By \"high priority\" we mean an item whose priority is equal\n-         --  or greater than the value At_Least. The generic formal operation\n-         --  Before has the meaning \"has higher priority than\". To dequeue an\n-         --  item (meaning that we return True as our Success value), we need\n-         --  as our predicate the equivalent of \"has equal or higher priority\n-         --  than\", but we cannot say that directly, so we require some logical\n-         --  gymnastics to make it so.\n-\n-         --  If E is the element at the head of the queue, and symbol \">\"\n-         --  refers to the \"is higher priority than\" function Before, then we\n-         --  derive our predicate as follows:\n-         --    original: P(E) >= At_Least\n-         --    same as:  not (P(E) < At_Least)\n-         --    same as:  not (At_Least > P(E))\n-         --    same as:  not Before (At_Least, P(E))\n-\n-         --  But that predicate needs to be true in order to successfully\n-         --  dequeue an item. If it's false, it means no item is dequeued, and\n-         --  we return False as the Success value.\n-\n-         Success := List.Length > 0\n-           and then\n-             not Before (At_Least, Get_Priority (List.Header.Next.Element));\n-\n-         if Success then\n-            List.Dequeue (Element);\n-         end if;\n-      end Dequeue;\n-\n-      -------------\n-      -- Enqueue --\n-      -------------\n-\n-      procedure Enqueue\n-        (List     : in out List_Type;\n-         New_Item : Queue_Interfaces.Element_Type)\n-      is\n-         P : constant Queue_Priority := Get_Priority (New_Item);\n-         H : constant Node_Access := List.Header'Unchecked_Access;\n-\n-         function Next return Node_Access;\n-         --  The node before which we wish to insert the new node\n-\n-         ----------\n-         -- Next --\n-         ----------\n-\n-         function Next return Node_Access is\n-         begin\n-            return Result : Node_Access := H.Next_Unequal do\n-               while Result /= H\n-                 and then not Before (P, Get_Priority (Result.Element))\n-               loop\n-                  Result := Result.Next_Unequal;\n-               end loop;\n-            end return;\n-         end Next;\n-\n-         --  Local varaibles\n-\n-         Prev : constant Node_Access := Next.Prev;\n-         --  The node after which we wish to insert the new node. So Prev must\n-         --  be the header, or be higher or equal priority to the new item.\n-         --  Prev.Next must be the header, or be lower priority than the\n-         --  new item.\n-\n-         pragma Assert\n-           (Prev = H or else Before_Or_Equal (Get_Priority (Prev.Element), P));\n-         pragma Assert\n-           (Prev.Next = H\n-              or else Before (P, Get_Priority (Prev.Next.Element)));\n-         pragma Assert (Prev.Next = Prev.Next_Unequal);\n-\n-         Node : constant Node_Access :=\n-                  new Node_Type'(New_Item,\n-                                 Prev         => Prev,\n-                                 Next         => Prev.Next,\n-                                 Next_Unequal => Prev.Next);\n-\n-      --  Start of processing for Enqueue\n-\n-      begin\n-         Prev.Next.Prev := Node;\n-         Prev.Next := Node;\n-\n-         if Prev = H then\n-\n-            --  Make sure Next_Unequal of the Header always points to the first\n-            --  \"real\" node. Here, we've inserted a new first \"real\" node, so\n-            --  must update.\n-\n-            List.Header.Next_Unequal := Node;\n-\n-         elsif Before (Get_Priority (Prev.Element), P) then\n-\n-            --  If the new item inserted has a unique priority in queue (not\n-            --  same priority as precedent), set Next_Unequal of precedent\n-            --  element to the new element instead of old next element, since\n-            --  Before (P, Get_Priority (Next.Element) or Next = H).\n-\n-            Prev.Next_Unequal := Node;\n-         end if;\n-\n-         pragma Assert (List.Header.Next_Unequal = List.Header.Next);\n-\n-         List.Length := List.Length + 1;\n-\n-         if List.Length > List.Max_Length then\n-            List.Max_Length := List.Length;\n-         end if;\n-      end Enqueue;\n-\n-      --------------\n-      -- Finalize --\n-      --------------\n-\n-      procedure Finalize (List : in out List_Type) is\n-         Ignore : Queue_Interfaces.Element_Type;\n-      begin\n-         while List.Length > 0 loop\n-            List.Dequeue (Ignore);\n-         end loop;\n-      end Finalize;\n-\n-      ------------\n-      -- Length --\n-      ------------\n-\n-      function Length (List : List_Type) return Count_Type is\n-      begin\n-         return List.Length;\n-      end Length;\n-\n-      ----------------\n-      -- Max_Length --\n-      ----------------\n-\n-      function Max_Length (List : List_Type) return Count_Type is\n-      begin\n-         return List.Max_Length;\n-      end Max_Length;\n-\n-   end Implementation;\n-\n    protected body Queue is\n \n       -----------------\n@@ -254,18 +37,22 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n \n       function Current_Use return Count_Type is\n       begin\n-         return List.Length;\n+         return Q_Elems.Length;\n       end Current_Use;\n \n       -------------\n       -- Dequeue --\n       -------------\n \n       entry Dequeue (Element : out Queue_Interfaces.Element_Type)\n-        when List.Length > 0\n+        when Q_Elems.Length > 0\n       is\n+         --  Grab the first item of the set, and remove it from the set\n+\n+         C : constant Cursor := First (Q_Elems);\n       begin\n-         List.Dequeue (Element);\n+         Element := Sets.Element (C).Item;\n+         Delete_First (Q_Elems);\n       end Dequeue;\n \n       --------------------------------\n@@ -277,8 +64,19 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n          Element  : in out Queue_Interfaces.Element_Type;\n          Success  : out Boolean)\n       is\n+         --  Grab the first item. If it exists and has appropriate priority,\n+         --  set Success to True, and remove that item. Otherwise, set Success\n+         --  to False.\n+\n+         C : constant Cursor := First (Q_Elems);\n       begin\n-         List.Dequeue (At_Least, Element, Success);\n+         Success := Has_Element (C) and then\n+            not Before (At_Least, Get_Priority (Sets.Element (C).Item));\n+\n+         if Success then\n+            Element := Sets.Element (C).Item;\n+            Delete_First (Q_Elems);\n+         end if;\n       end Dequeue_Only_High_Priority;\n \n       -------------\n@@ -287,7 +85,15 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n \n       entry Enqueue (New_Item : Queue_Interfaces.Element_Type) when True is\n       begin\n-         List.Enqueue (New_Item);\n+         Insert (Q_Elems, (Next_Sequence_Number, New_Item));\n+         Next_Sequence_Number := Next_Sequence_Number + 1;\n+\n+         --  If we reached a new high-water mark, increase Max_Length\n+\n+         if Q_Elems.Length > Max_Length then\n+            pragma Assert (Max_Length + 1 = Q_Elems.Length);\n+            Max_Length := Q_Elems.Length;\n+         end if;\n       end Enqueue;\n \n       --------------\n@@ -296,7 +102,7 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n \n       function Peak_Use return Count_Type is\n       begin\n-         return List.Max_Length;\n+         return Max_Length;\n       end Peak_Use;\n \n    end Queue;"}, {"sha": "44735e0bed08102dfd186c5afa05767c5a8ee79f", "filename": "gcc/ada/a-cuprqu.ads", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fa-cuprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fa-cuprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.ads?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -32,8 +32,8 @@\n ------------------------------------------------------------------------------\n \n with System;\n+with Ada.Containers.Ordered_Sets;\n with Ada.Containers.Synchronized_Queue_Interfaces;\n-with Ada.Finalization;\n \n generic\n    with package Queue_Interfaces is\n@@ -59,63 +59,44 @@ package Ada.Containers.Unbounded_Priority_Queues is\n \n       pragma Implementation_Defined;\n \n-      type List_Type is tagged limited private;\n-\n-      procedure Enqueue\n-        (List     : in out List_Type;\n-         New_Item : Queue_Interfaces.Element_Type);\n-\n-      procedure Dequeue\n-        (List    : in out List_Type;\n-         Element : out Queue_Interfaces.Element_Type);\n-\n-      procedure Dequeue\n-        (List     : in out List_Type;\n-         At_Least : Queue_Priority;\n-         Element  : in out Queue_Interfaces.Element_Type;\n-         Success  : out Boolean);\n-\n-      function Length (List : List_Type) return Count_Type;\n+      --  We use an ordered set to hold the queue elements. This gives O(lg N)\n+      --  performance in the worst case for Enqueue and Dequeue.\n+      --  Sequence_Number is used to distinguish equivalent items. Each Enqueue\n+      --  uses a higher Sequence_Number, so that a new item is placed after\n+      --  already-enqueued equivalent items.\n+      --\n+      --  At any time, the first set element is the one to be dequeued next (if\n+      --  the queue is not empty).\n \n-      function Max_Length (List : List_Type) return Count_Type;\n+      type Set_Elem is record\n+         Sequence_Number : Count_Type;\n+         Item : Queue_Interfaces.Element_Type;\n+      end record;\n \n-   private\n+      function \"=\" (X, Y : Queue_Interfaces.Element_Type) return Boolean is\n+         (not Before (Get_Priority (X), Get_Priority (Y))\n+            and then not Before (Get_Priority (Y), Get_Priority (X)));\n+      --  Elements are equal if neither is Before the other\n \n-      --  List_Type is implemented as a circular doubly-linked list with a\n-      --  dummy header node; Prev and Next are the links. The list is in\n-      --  decreasing priority order, so the highest-priority item is always\n-      --  first. (If there are multiple items with the highest priority, the\n-      --  oldest one is first.) Header.Element is undefined and not used.\n-      --\n-      --  In addition, Next_Unequal points to the next item with a different\n-      --  (i.e. strictly lower) priority. This is used to speed up the search\n-      --  for the next lower-priority item, in cases where there are many items\n-      --  with the same priority.\n-      --\n-      --  An empty list has Header.Prev, Header.Next, and Header.Next_Unequal\n-      --  all pointing to Header. A nonempty list has Header.Next_Unequal\n-      --  pointing to the first \"real\" item, and the last item has Next_Unequal\n-      --  pointing back to Header.\n-\n-      type Node_Type;\n-      type Node_Access is access all Node_Type;\n-\n-      type Node_Type is limited record\n-         Element      : Queue_Interfaces.Element_Type;\n-         Prev, Next   : Node_Access := Node_Type'Unchecked_Access;\n-         Next_Unequal : Node_Access := Node_Type'Unchecked_Access;\n-      end record;\n+      function \"=\" (X, Y : Set_Elem) return Boolean is\n+         (X.Sequence_Number = Y.Sequence_Number and then X.Item = Y.Item);\n+      --  Set_Elems are equal if the elements are equal, and the\n+      --  Sequence_Numbers are equal. This is passed to Ordered_Sets.\n \n-      type List_Type is new Ada.Finalization.Limited_Controlled with record\n-         Header     : aliased Node_Type;\n-         Length     : Count_Type := 0;\n-         Max_Length : Count_Type := 0;\n-      end record;\n+      function \"<\" (X, Y : Set_Elem) return Boolean is\n+         (if X.Item = Y.Item\n+            then X.Sequence_Number < Y.Sequence_Number\n+            else Before (Get_Priority (X.Item), Get_Priority (Y.Item)));\n+      --  If the items are equal, Sequence_Number breaks the tie. Otherwise,\n+      --  use Before. This is passed to Ordered_Sets.\n \n-      overriding procedure Finalize (List : in out List_Type);\n+      pragma Suppress (Container_Checks);\n+      package Sets is new Ada.Containers.Ordered_Sets (Set_Elem);\n \n    end Implementation;\n \n+   use Implementation, Implementation.Sets;\n+\n    protected type Queue (Ceiling : System.Any_Priority := Default_Ceiling)\n    with\n      Priority => Ceiling\n@@ -142,7 +123,15 @@ package Ada.Containers.Unbounded_Priority_Queues is\n       overriding function Peak_Use return Count_Type;\n \n    private\n-      List : Implementation.List_Type;\n+      Q_Elems              : Set;\n+      --  Elements of the queue\n+\n+      Max_Length           : Count_Type := 0;\n+      --  The current length of the queue is the Length of Q_Elems. This is the\n+      --  maximum value of that, so far. Updated by Enqueue.\n+\n+      Next_Sequence_Number : Count_Type := 0;\n+      --  Steadily increasing counter\n    end Queue;\n \n end Ada.Containers.Unbounded_Priority_Queues;"}, {"sha": "e3c53dda462007c88fec0cf0524d7d6a1a8fbd36", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -105,7 +105,7 @@ package body Debug is\n    --  d.l  Use Ada 95 semantics for limited function returns\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n-   --  d.o\n+   --  d.o  Conservative elaboration order for indirect calls\n    --  d.p\n    --  d.q\n    --  d.r  Enable OK_To_Reorder_Components in non-variant records\n@@ -556,6 +556,9 @@ package body Debug is\n    --       compiler has a bug -- these are the files that need to be included\n    --       in a bug report.\n \n+   --  d.o  Conservative elaboration order for indirect calls. This causes\n+   --       P'Access to be treated as a call in more cases.\n+\n    --  d.r  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have no discriminants.\n "}, {"sha": "b52fcccbdb428e7e919fc9a28e40317144a6432b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -355,12 +355,15 @@ package body Exp_Util is\n                return;\n \n             --  Otherwise we perform a conversion from the current type, which\n-            --  must be Standard.Boolean, to the desired type.\n+            --  must be Standard.Boolean, to the desired type. Use the base\n+            --  type to prevent spurious constraint checks that are extraneous\n+            --  to the transformation. The type and its base have the same\n+            --  representation, standard or otherwise.\n \n             else\n                Set_Analyzed (N);\n-               Rewrite (N, Convert_To (T, N));\n-               Analyze_And_Resolve (N, T);\n+               Rewrite (N, Convert_To (Base_Type (T), N));\n+               Analyze_And_Resolve (N, Base_Type (T));\n             end if;\n          end;\n       end if;"}, {"sha": "599ce451c1e58855157e95d11a2bdeafb5a29797", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -8552,8 +8552,7 @@ package body Sem_Ch13 is\n                         Expression => Expr))));\n \n             --  If declaration has not been analyzed yet, Insert declaration\n-            --  before freeze node.\n-            --  Insert body after freeze node.\n+            --  before freeze node.  Insert body itself after freeze node.\n \n             if not Analyzed (FDecl) then\n                Insert_Before_And_Analyze (N, FDecl);\n@@ -11644,9 +11643,11 @@ package body Sem_Ch13 is\n       --  to specify a static predicate for a subtype which is inheriting a\n       --  dynamic predicate, so the static predicate validation here ignores\n       --  the inherited predicate even if it is dynamic.\n+      --  In all cases, a static predicate can only apply to a scalar type.\n \n       elsif Nkind (Expr) = N_Function_Call\n         and then Is_Predicate_Function (Entity (Name (Expr)))\n+        and then Is_Scalar_Type (Etype (First_Entity (Entity (Name (Expr)))))\n       then\n          return True;\n "}, {"sha": "d34db0210d226eab17d9e00b7146b5dab8f6c861", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -9182,6 +9182,7 @@ package body Sem_Ch3 is\n       Set_Mechanism (D_Minal, Default_Mechanism);\n       Set_Etype     (D_Minal, Etype (Discrim));\n       Set_Scope     (D_Minal, Current_Scope);\n+      Set_Parent    (D_Minal, Parent (Discrim));\n \n       Set_Discriminal (Discrim, D_Minal);\n       Set_Discriminal_Link (D_Minal, Discrim);"}, {"sha": "1b3015aaf42fe6f16a9aba1b184ea474591611b3", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -2139,7 +2139,8 @@ package body Sem_Elab is\n       --  node comes from source.\n \n       if Nkind (N) = N_Attribute_Reference\n-        and then (not Warn_On_Elab_Access or else not Comes_From_Source (N))\n+        and then ((not Warn_On_Elab_Access and then not Debug_Flag_Dot_O)\n+                    or else not Comes_From_Source (N))\n       then\n          return;\n "}, {"sha": "de0f987d4a38a3a89e579be929918bdca63fe73d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -6314,6 +6314,7 @@ package body Sem_Util is\n          Encl_Unit := Library_Unit (Encl_Unit);\n       end loop;\n \n+      pragma Assert (Nkind (Encl_Unit) = N_Compilation_Unit);\n       return Encl_Unit;\n    end Enclosing_Lib_Unit_Node;\n "}, {"sha": "cb0a09293aa773edc711e38f045c16c1a808ee6a", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24ea9120d7b97d0b6b047de94865f7f190e6daa/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=f24ea9120d7b97d0b6b047de94865f7f190e6daa", "patch": "@@ -3367,7 +3367,7 @@ package body Sem_Warn is\n          P := Parent (C);\n          loop\n             --  If tree is not attached, do not issue warning (this is very\n-            --  peculiar, and probably arises from some other error condition)\n+            --  peculiar, and probably arises from some other error condition).\n \n             if No (P) then\n                return;"}]}