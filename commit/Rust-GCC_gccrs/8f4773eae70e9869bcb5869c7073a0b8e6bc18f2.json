{"sha": "8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0NzczZWFlNzBlOTg2OWJjYjU4NjljNzA3M2EwYjhlNmJjMThmMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-29T07:52:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-29T07:52:26Z"}, "message": "longlong.h [__alpha] (count_leading_zeros): New.\n\n        * longlong.h [__alpha] (count_leading_zeros): New.\n        (count_trailing_zeros): New.\n        (COUNT_LEADING_ZEROS_0): New.\n\n        * config/alpha/alpha.c (alpha_zero_comparison_operator): New.\n        (alpha_split_conditional_move): New.\n        * config/alpha/alpha-protos.h: Prototype them.\n        * config/alpha/alpha.h (PREDICATE_CODES): Update.\n        (CPP_CPU_DEFAULT_SPEC): Fix typo for EV67.\n        * config/alpha/alpha.md: Update ffs cix commentary.\n        (*ze_and_ne): New.\n        (*nabssf2, *nabsdf2): New.\n        (*mov[qhsd]icc_internal): Use add_operand.\n        (if_then_else constant splitters): New.\n        (*cmp_sadd_di, *cmp_sadd_si, *cmp_sadd_sidi): New.\n        (*cmp_ssub_di, *cmp_ssub_si, *cmp_ssub_sidi): New.\n\nFrom-SVN: r34250", "tree": {"sha": "f08d81eea8a5d69bcef8e82015e7cf308d5b8a7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f08d81eea8a5d69bcef8e82015e7cf308d5b8a7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/comments", "author": null, "committer": null, "parents": [{"sha": "e2c7a29e977e9a8153565435ba058ae66f521cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c7a29e977e9a8153565435ba058ae66f521cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c7a29e977e9a8153565435ba058ae66f521cb9"}], "stats": {"total": 416, "additions": 399, "deletions": 17}, "files": [{"sha": "220fa68d8bbddbe04b14647a5500ed1285d1aeeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -1,3 +1,22 @@\n+2000-05-29  Richard Henderson  <rth@cygnus.com>\n+\n+\t* longlong.h [__alpha] (count_leading_zeros): New.\n+\t(count_trailing_zeros): New.\n+\t(COUNT_LEADING_ZEROS_0): New.\n+\n+\t* config/alpha/alpha.c (alpha_zero_comparison_operator): New.\n+\t(alpha_split_conditional_move): New.\n+\t* config/alpha/alpha-protos.h: Prototype them.\n+\t* config/alpha/alpha.h (PREDICATE_CODES): Update.\n+\t(CPP_CPU_DEFAULT_SPEC): Fix typo for EV67.\n+\t* config/alpha/alpha.md: Update ffs cix commentary.\n+\t(*ze_and_ne): New.\n+\t(*nabssf2, *nabsdf2): New.\n+\t(*mov[qhsd]icc_internal): Use add_operand.\n+\t(if_then_else constant splitters): New.\n+\t(*cmp_sadd_di, *cmp_sadd_si, *cmp_sadd_sidi): New.\n+\t(*cmp_ssub_di, *cmp_ssub_si, *cmp_ssub_sidi): New.\n+\n 2000-05-29  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (force_to_mode) [MINUS]: Convert subtraction from"}, {"sha": "9bdf142ad5503d47577ddffc552600585eff5476", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -57,6 +57,7 @@ extern int input_operand PARAMS ((rtx, enum machine_mode));\n extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int alpha_zero_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_swapped_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int signed_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_fp_comparison_operator PARAMS ((rtx, enum machine_mode));\n@@ -83,6 +84,8 @@ extern rtx alpha_emit_set_long_const PARAMS ((rtx, HOST_WIDE_INT,\n extern void alpha_emit_floatuns PARAMS ((rtx[]));\n extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n extern rtx alpha_emit_conditional_move PARAMS ((rtx, enum machine_mode));\n+extern int alpha_split_conditional_move PARAMS ((enum rtx_code, rtx, rtx,\n+\t\t\t\t\t\t rtx, rtx));\n extern void alpha_emit_xfloating_arith PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_emit_xfloating_cvt PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_split_tfmode_pair PARAMS ((rtx[]));"}, {"sha": "68eedb071a839c58472cfd2a7a5e66796095de76", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -735,6 +735,23 @@ alpha_comparison_operator (op, mode)\n \t  || code == LEU || code == LTU);\n }\n \n+/* Return 1 if OP is a valid Alpha comparison operator against zero. \n+   Here we know which comparisons are valid in which insn.  */\n+\n+int\n+alpha_zero_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  return (code == EQ || code == NE || code == LE || code == LT\n+\t  || code == LEU || code == LTU);\n+}\n+\n /* Return 1 if OP is a valid Alpha swapped comparison operator.  */\n \n int\n@@ -1834,6 +1851,90 @@ alpha_emit_conditional_move (cmp, mode)\n   emit_move_insn (tem, gen_rtx_fmt_ee (code, cmp_op_mode, op0, op1));\n   return gen_rtx_fmt_ee (cmov_code, cmov_mode, tem, CONST0_RTX (cmp_op_mode));\n }\n+\n+/* Simplify a conditional move of two constants into a setcc with\n+   arithmetic.  This is done with a splitter since combine would\n+   just undo the work if done during code generation.  It also catches\n+   cases we wouldn't have before cse.  */\n+\n+int\n+alpha_split_conditional_move (code, dest, cond, t_rtx, f_rtx)\n+     enum rtx_code code;\n+     rtx dest, cond, t_rtx, f_rtx;\n+{\n+  HOST_WIDE_INT t, f, diff;\n+  enum machine_mode mode;\n+  rtx target, subtarget, tmp;\n+\n+  mode = GET_MODE (dest);\n+  t = INTVAL (t_rtx);\n+  f = INTVAL (f_rtx);\n+  diff = t - f;\n+\n+  if (((code == NE || code == EQ) && diff < 0)\n+      || (code == GE || code == GT))\n+    {\n+      code = reverse_condition (code);\n+      diff = t, t = f, f = diff;\n+      diff = t - f;\n+    }\n+\n+  subtarget = target = dest;\n+  if (mode != DImode)\n+    {\n+      target = gen_lowpart (DImode, dest);\n+      if (! no_new_pseudos)\n+        subtarget = gen_reg_rtx (DImode);\n+      else\n+\tsubtarget = target;\n+    }\n+\n+  if (f == 0 && exact_log2 (diff) > 0\n+      /* On EV6, we've got enough shifters to make non-arithmatic shifts\n+\t viable over a longer latency cmove.  On EV5, the E0 slot is a\n+\t scarce resource, and on EV4 shift has the same latency as a cmove. */\n+      && (diff <= 8 || alpha_cpu == PROCESSOR_EV6))\n+    {\n+      tmp = gen_rtx_fmt_ee (code, DImode, cond, const0_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, subtarget, tmp));\n+\n+      tmp = gen_rtx_ASHIFT (DImode, subtarget, GEN_INT (exact_log2 (t)));\n+      emit_insn (gen_rtx_SET (VOIDmode, target, tmp));\n+    }\n+  else if (f == 0 && t == -1)\n+    {\n+      tmp = gen_rtx_fmt_ee (code, DImode, cond, const0_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, subtarget, tmp));\n+\n+      emit_insn (gen_negdi2 (target, subtarget));\n+    }\n+  else if (diff == 1 || diff == 4 || diff == 8)\n+    {\n+      rtx add_op;\n+\n+      tmp = gen_rtx_fmt_ee (code, DImode, cond, const0_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, subtarget, tmp));\n+\n+      if (diff == 1)\n+\temit_insn (gen_adddi3 (target, subtarget, GEN_INT (f)));\n+      else\n+\t{\n+\t  add_op = GEN_INT (f);\n+\t  if (sext_add_operand (add_op, mode))\n+\t    {\n+\t      tmp = gen_rtx_MULT (DImode, subtarget, GEN_INT (diff));\n+\t      tmp = gen_rtx_PLUS (DImode, tmp, add_op);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, target, tmp));\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+    }\n+  else\n+    return 0;\n+\n+  return 1;\n+}\n \f\n /* Look up the function X_floating library function name for the\n    given operation.  */"}, {"sha": "45ebbd83f3fd50d0502169e746263ddcfaa96118", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -290,7 +290,7 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n \n #ifndef CPP_CPU_DEFAULT_SPEC\n # if TARGET_CPU_DEFAULT & MASK_CPU_EV6\n-#  if TARGET_CPU_DEFAULT & MAX_CIX\n+#  if TARGET_CPU_DEFAULT & MASK_CIX\n #    define CPP_CPU_DEFAULT_SPEC\tCPP_CPU_EV67_SPEC\n #  else\n #    define CPP_CPU_DEFAULT_SPEC\tCPP_CPU_EV6_SPEC\n@@ -2333,6 +2333,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"mode_width_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"reg_or_fp0_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n   {\"alpha_comparison_operator\", {EQ, LE, LT, LEU, LTU}},\t\t\\\n+  {\"alpha_zero_comparison_operator\", {EQ, NE, LE, LT, LEU, LTU}},\t\\\n   {\"alpha_swapped_comparison_operator\", {EQ, GE, GT, GEU, GTU}},\t\\\n   {\"signed_comparison_operator\", {EQ, NE, LE, LT, GE, GT}},\t\t\\\n   {\"alpha_fp_comparison_operator\", {EQ, LE, LT, UNORDERED}},\t\t\\"}, {"sha": "cc3c06c8aa14bd3b8ace73c6187c96488f844ed9", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 241, "deletions": 16, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -1177,14 +1177,6 @@\n   [(set_attr \"type\" \"ilog\")])\n \f\n ;; Handle the FFS insn iff we support CIX. \n-;;\n-;; These didn't make it into EV6 pass 2 as planned.  Instead they\n-;; cropped cttz/ctlz/ctpop from the old CIX and renamed it FIX for\n-;; \"Square Root and Floating Point Convert Extension\".\n-;;\n-;; I'm assured that these insns will make it into EV67 (first pass\n-;; due Summer 1999), presumably with a new AMASK bit, and presumably\n-;; will still be named CIX.\n \n (define_expand \"ffsdi2\"\n   [(set (match_dup 2)\n@@ -1756,6 +1748,22 @@\n   \"\"\n   \"msk%M2h %1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n+\n+;; Prefer AND + NE over LSHIFTRT + AND.\n+\n+(define_insn_and_split \"*ze_and_ne\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 2 \"const_int_operand\" \"I\")))]\n+  \"(unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 8\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 0)\n+\t(and:DI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(ne:DI (match_dup 0) (const_int 0)))]\n+  \"operands[3] = GEN_INT (1 << INTVAL (operands[2]));\")\n \f\n ;; Floating-point operations.  All the double-precision insns can extend\n ;; from single, so indicate that.  The exception are the ones that simply\n@@ -1768,13 +1776,27 @@\n   \"cpys $f31,%R1,%0\"\n   [(set_attr \"type\" \"fcpys\")])\n \n+(define_insn \"*nabssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (abs:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\"))))]\n+  \"TARGET_FP\"\n+  \"cpysn $f31,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n (define_insn \"absdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP\"\n   \"cpys $f31,%R1,%0\"\n   [(set_attr \"type\" \"fcpys\")])\n \n+(define_insn \"*nabsdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (abs:DF (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\"))))]\n+  \"TARGET_FP\"\n+  \"cpysn $f31,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n (define_expand \"abstf2\"\n   [(parallel [(set (match_operand:TF 0 \"register_operand\" \"\")\n \t\t   (neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n@@ -2532,15 +2554,19 @@\n \n ;; The mode folding trick can't be used with const_int operands, since\n ;; reload needs to know the proper mode.\n+;;\n+;; Use add_operand instead of the more seemingly natural reg_or_8bit_operand\n+;; in order to create more pairs of constants.  As long as we're allowing\n+;; two constants at the same time, and will have to reload one of them...\n \n (define_insn \"*movqicc_internal\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r\")\n \t(if_then_else:QI\n \t (match_operator 2 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DI 3 \"reg_or_0_operand\" \"rJ,rJ,J,J\")\n \t\t\t  (match_operand:DI 4 \"reg_or_0_operand\" \"J,J,rJ,rJ\")])\n-\t (match_operand:QI 1 \"reg_or_8bit_operand\" \"rI,0,rI,0\")\n-\t (match_operand:QI 5 \"reg_or_8bit_operand\" \"0,rI,0,rI\")))]\n+\t (match_operand:QI 1 \"add_operand\" \"rI,0,rI,0\")\n+\t (match_operand:QI 5 \"add_operand\" \"0,rI,0,rI\")))]\n   \"(operands[3] == const0_rtx || operands[4] == const0_rtx)\"\n   \"@\n    cmov%C2 %r3,%1,%0\n@@ -2555,8 +2581,8 @@\n \t (match_operator 2 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DI 3 \"reg_or_0_operand\" \"rJ,rJ,J,J\")\n \t\t\t  (match_operand:DI 4 \"reg_or_0_operand\" \"J,J,rJ,rJ\")])\n-\t (match_operand:HI 1 \"reg_or_8bit_operand\" \"rI,0,rI,0\")\n-\t (match_operand:HI 5 \"reg_or_8bit_operand\" \"0,rI,0,rI\")))]\n+\t (match_operand:HI 1 \"add_operand\" \"rI,0,rI,0\")\n+\t (match_operand:HI 5 \"add_operand\" \"0,rI,0,rI\")))]\n   \"(operands[3] == const0_rtx || operands[4] == const0_rtx)\"\n   \"@\n    cmov%C2 %r3,%1,%0\n@@ -2571,8 +2597,8 @@\n \t (match_operator 2 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DI 3 \"reg_or_0_operand\" \"rJ,rJ,J,J\")\n \t\t\t  (match_operand:DI 4 \"reg_or_0_operand\" \"J,J,rJ,rJ\")])\n-\t (match_operand:SI 1 \"reg_or_8bit_operand\" \"rI,0,rI,0\")\n-\t (match_operand:SI 5 \"reg_or_8bit_operand\" \"0,rI,0,rI\")))]\n+\t (match_operand:SI 1 \"add_operand\" \"rI,0,rI,0\")\n+\t (match_operand:SI 5 \"add_operand\" \"0,rI,0,rI\")))]\n   \"(operands[3] == const0_rtx || operands[4] == const0_rtx)\"\n   \"@\n    cmov%C2 %r3,%1,%0\n@@ -2587,8 +2613,8 @@\n \t (match_operator 2 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DI 3 \"reg_or_0_operand\" \"rJ,rJ,J,J\")\n \t\t\t  (match_operand:DI 4 \"reg_or_0_operand\" \"J,J,rJ,rJ\")])\n-\t (match_operand:DI 1 \"reg_or_8bit_operand\" \"rI,0,rI,0\")\n-\t (match_operand:DI 5 \"reg_or_8bit_operand\" \"0,rI,0,rI\")))]\n+\t (match_operand:DI 1 \"add_operand\" \"rI,0,rI,0\")\n+\t (match_operand:DI 5 \"add_operand\" \"0,rI,0,rI\")))]\n   \"(operands[3] == const0_rtx || operands[4] == const0_rtx)\"\n   \"@\n    cmov%C2 %r3,%1,%0\n@@ -3824,6 +3850,205 @@\n \t\t\t\t ? NE : EQ),\n \t\t\t\tDImode, operands[4], const0_rtx);\n }\")\n+\n+;; Prefer to use cmp and arithmetic when possible instead of a cmove.\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"signed_comparison_operator\"\n+\t\t\t   [(match_operand:DI 2 \"reg_or_0_operand\" \"\")\n+\t\t\t    (const_int 0)])\n+\t  (match_operand 3 \"const_int_operand\" \"\")\n+\t  (match_operand 4 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  if (alpha_split_conditional_move (GET_CODE (operands[1]), operands[0],\n+\t\t\t\t    operands[2], operands[3], operands[4]))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+;; ??? Why combine is allowed to create such non-canonical rtl, I don't know.\n+;; Oh well, we match it in movcc, so it must be partially our fault.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"signed_comparison_operator\"\n+\t\t\t   [(const_int 0)\n+\t\t\t    (match_operand:DI 2 \"reg_or_0_operand\" \"\")])\n+\t  (match_operand 3 \"const_int_operand\" \"\")\n+\t  (match_operand 4 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  if (alpha_split_conditional_move (swap_condition (GET_CODE (operands[1])),\n+\t\t\t\t    operands[0], operands[2], operands[3],\n+\t\t\t\t    operands[4]))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn_and_split \"*cmp_sadd_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (if_then_else:DI\n+\t\t   (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t     [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t      (const_int 0)])\n+\t\t   (match_operand:DI 3 \"const48_operand\" \"I\")\n+\t\t   (const_int 0))\n+\t         (match_operand:DI 4 \"sext_add_operand\" \"rIO\")))\n+   (clobber (match_scratch:DI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(plus:DI (mult:DI (match_dup 5) (match_dup 3))\n+\t\t (match_dup 4)))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n+\n+(define_insn_and_split \"*cmp_sadd_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (if_then_else:SI\n+\t\t   (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t     [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t      (const_int 0)])\n+\t\t   (match_operand:SI 3 \"const48_operand\" \"I\")\n+\t\t   (const_int 0))\n+\t         (match_operand:SI 4 \"sext_add_operand\" \"rIO\")))\n+   (clobber (match_scratch:SI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(plus:SI (mult:SI (match_dup 5) (match_dup 3))\n+\t\t (match_dup 4)))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n+\n+(define_insn_and_split \"*cmp_sadd_sidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t  (plus:SI (if_then_else:SI\n+\t\t     (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t       [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t        (const_int 0)])\n+\t\t     (match_operand:SI 3 \"const48_operand\" \"I\")\n+\t\t     (const_int 0))\n+\t           (match_operand:SI 4 \"sext_add_operand\" \"rIO\"))))\n+   (clobber (match_scratch:SI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(sign_extend:DI (plus:SI (mult:SI (match_dup 5) (match_dup 3))\n+\t\t\t\t (match_dup 4))))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n+\n+(define_insn_and_split \"*cmp_ssub_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (if_then_else:DI\n+\t\t    (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t      [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t       (const_int 0)])\n+\t\t    (match_operand:DI 3 \"const48_operand\" \"I\")\n+\t\t    (const_int 0))\n+\t          (match_operand:DI 4 \"reg_or_8bit_operand\" \"rI\")))\n+   (clobber (match_scratch:DI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(minus:DI (mult:DI (match_dup 5) (match_dup 3))\n+\t\t  (match_dup 4)))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n+\n+(define_insn_and_split \"*cmp_ssub_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (if_then_else:SI\n+\t\t    (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t      [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t       (const_int 0)])\n+\t\t    (match_operand:SI 3 \"const48_operand\" \"I\")\n+\t\t    (const_int 0))\n+\t          (match_operand:SI 4 \"reg_or_8bit_operand\" \"rI\")))\n+   (clobber (match_scratch:SI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(minus:SI (mult:SI (match_dup 5) (match_dup 3))\n+\t\t (match_dup 4)))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n+\n+(define_insn_and_split \"*cmp_ssub_sidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t  (minus:SI (if_then_else:SI\n+\t\t      (match_operator 1 \"alpha_zero_comparison_operator\"\n+\t\t        [(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t         (const_int 0)])\n+\t\t      (match_operand:SI 3 \"const48_operand\" \"I\")\n+\t\t      (const_int 0))\n+\t            (match_operand:SI 4 \"reg_or_8bit_operand\" \"rI\"))))\n+   (clobber (match_scratch:SI 5 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"! no_new_pseudos || reload_completed\"\n+  [(set (match_dup 5)\n+\t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n+   (set (match_dup 0)\n+\t(sign_extend:DI (minus:SI (mult:SI (match_dup 5) (match_dup 3))\n+\t\t\t\t  (match_dup 4))))]\n+  \"\n+{\n+  if (! no_new_pseudos)\n+    operands[5] = gen_reg_rtx (DImode);\n+  else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n+    operands[5] = operands[0];\n+}\")\n \f\n ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n ;; work differently, so we have different patterns for each."}, {"sha": "1c1456974cb8242e9113acc06038779fd06c017a", "filename": "gcc/longlong.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4773eae70e9869bcb5869c7073a0b8e6bc18f2/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=8f4773eae70e9869bcb5869c7073a0b8e6bc18f2", "patch": "@@ -169,6 +169,39 @@\n extern UDItype __udiv_qrnnd PARAMS ((UDItype *, UDItype, UDItype, UDItype));\n #define UDIV_TIME 220\n #endif /* LONGLONG_STANDALONE */\n+#ifdef __alpha_cix__\n+#define count_leading_zeros(COUNT,X) \\\n+  __asm__(\"ctlz %1,%0\" : \"=r\"(COUNT) : \"r\"(X))\n+#define count_trailing_zeros(COUNT,X) \\\n+  __asm__(\"cttz %1,%0\" : \"=r\"(COUNT) : \"r\"(X))\n+#define COUNT_LEADING_ZEROS_0 64\n+#else\n+extern const UQItype __clz_tab[];\n+#define count_leading_zeros(COUNT,X) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n+    __asm__(\"cmpbge %1,%2,%0\" : \"=r\"(__t) : \"r\"(~__xr), \"r\"(-1));\t\\\n+    __a = __clz_tab[__t ^ 0xff] - 1;\t\t\t\t\t\\\n+    __asm__(\"extbl %1,%2,%0\" : \"=r\"(__t) : \"r\"(__xr), \"r\"(__a));\t\\\n+    (COUNT) = 64 - (__clz_tab[__t] + __a*8);\t\t\t\t\\\n+  } while (0)\n+#define count_trailing_zeros(COUNT,X) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n+    __asm__(\"cmpbge %1,%2,%0\" : \"=r\"(__t) : \"r\"(~__xr), \"r\"(-1));\t\\\n+    __t = ~__t & -~__t;\t\t\t\t\t\t\t\\\n+    __a = ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n+    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n+    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n+    __asm__(\"extbl %1,%2,%0\" : \"=r\"(__t) : \"r\"(__xr), \"r\"(__a));\t\\\n+    __a <<= 3;\t\t\t\t\t\t\t\t\\\n+    __t &= -__t;\t\t\t\t\t\t\t\\\n+    __a += ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n+    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n+    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n+    (COUNT) = __a;\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif /* __alpha_cix__ */\n #endif /* __alpha */\n \n #if defined (__arc__) && W_TYPE_SIZE == 32"}]}