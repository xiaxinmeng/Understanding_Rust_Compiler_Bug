{"sha": "e6e436615854954b26faac2618f8b209cd6770c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlNDM2NjE1ODU0OTU0YjI2ZmFhYzI2MThmOGIyMDljZDY3NzBjOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-10T10:50:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-10T10:50:02Z"}, "message": "(FUNCTION_EPILOGUE): Restore stack before freeing local vars.\n\n(DEFAULT_SIGNED_CHAR): Now 1.\n(DATA_SECTION_ASM_OP): Use pseudo-op for read-only data (later copied).\n(JUMP_TABLES_IN_TEXT_SECTION): Define.\n(ASM_OUTPUT_ASCII): Split into multiple lines if long.\n(ASM_OUTPUT_{CHAR,SHORT,INT,LONG_INT}): Split up.\n(ASM_OUTPUT_COMMON): Call check_section.\n\nFrom-SVN: r9154", "tree": {"sha": "786feccc64e5505a53d6b5db6bedfd3c56c09ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/786feccc64e5505a53d6b5db6bedfd3c56c09ab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6e436615854954b26faac2618f8b209cd6770c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e436615854954b26faac2618f8b209cd6770c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e436615854954b26faac2618f8b209cd6770c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e436615854954b26faac2618f8b209cd6770c8/comments", "author": null, "committer": null, "parents": [{"sha": "aa526ccd424ca564102df5398d782d14ba8ff113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa526ccd424ca564102df5398d782d14ba8ff113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa526ccd424ca564102df5398d782d14ba8ff113"}], "stats": {"total": 135, "additions": 84, "deletions": 51}, "files": [{"sha": "8e6fbb98fa788c835ab3d04a8178f6e6d14a0965", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 84, "deletions": 51, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e436615854954b26faac2618f8b209cd6770c8/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e436615854954b26faac2618f8b209cd6770c8/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=e6e436615854954b26faac2618f8b209cd6770c8", "patch": "@@ -588,11 +588,11 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    before returning. */\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) {\t\t\t\\\n+  fprintf(FILE,\"\\tlr\\tr15,r14 ; set stack ptr to frame ptr\\n\");\t\\\n+  fprintf(FILE,\"\\tpopm\\tr14,r14 ; restore previous frame ptr\\n\");\t\\\n   if (SIZE > 0)\t\t\t\t\t\t\t\\\n     fprintf(FILE,\"\\t%s\\tr14,%d ; free up local-var space\\n\",\t\\\n \t\t\t (SIZE <= 16 ? \"aisp\" : \"aim\"),SIZE);\t\\\n-  fprintf(FILE,\"\\tlr\\tr15,r14 ; set stack to return addr\\n\");\t\\\n-  fprintf(FILE,\"\\tpopm\\tr14,r14 ; restore prev. frame ptr\\n\");\t\\\n   fprintf(FILE,\"\\turs\\tr15\\n\"); }\n \n /* If the memory address ADDR is relative to the frame pointer,\n@@ -789,7 +789,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define EASY_DIV_EXPR TRUNC_DIV_EXPR\n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n+#define DEFAULT_SIGNED_CHAR 1\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n@@ -932,30 +932,30 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define EXTRA_SECTIONS  in_readonly_data\n \n #define EXTRA_SECTION_FUNCTIONS\t\t\\\n-    void const_section()\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-\tfprintf(asm_out_file,\"\\tkonst\\n\");\t\t\\\n-\tcurrent_section = Konst;\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-    check_section(sect)\t\t\t\\\n-        enum section sect;\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-        if (current_section != sect) {\t\t\t\\\n+    void const_section()\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+\tfprintf(asm_out_file,\"\\tkonst\\n\");\t\t\t\\\n+\tcurrent_section = Konst;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+    check_section(sect)\t\t\t\t\t\t\\\n+\t enum section sect;\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+        if (current_section != sect) {\t\t\t\t\\\n \t    fprintf(asm_out_file,\"\\t%s\\n\",sectname[(int)sect]); \\\n-\t    current_section = sect;\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-\tswitch (sect) {\t\t\t\t\t\\\n-\t  case Init:\t\t\t\t\t\\\n-\t  case Normal:\t\t\t\t\t\\\n-\t    in_section = in_text;\t\t\t\\\n-\t    break;\t\t\t\t\t\\\n-\t  case Static:\t\t\t\t\t\\\n-\t    in_section = in_data;\t\t\t\\\n-\t    break;\t\t\t\t\t\\\n-\t  case Konst:\t\t\t\t\t\\\n-\t    in_section = in_readonly_data;\t\t\\\n-\t    break;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n+\t    current_section = sect;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\tswitch (sect) {\t\t\t\t\t\t\\\n+\t  case Init:\t\t\t\t\t\t\\\n+\t  case Normal:\t\t\t\t\t\t\\\n+\t    in_section = in_text;\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t  case Static:\t\t\t\t\t\t\\\n+\t    in_section = in_data;\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t  case Konst:\t\t\t\t\t\t\\\n+\t    in_section = in_readonly_data;\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n     }\n \n \t\t\n@@ -968,8 +968,11 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Output before program text section */\n #define TEXT_SECTION_ASM_OP \"\\n\\tnormal   ; text_section\\n\"\n \n-/* Output before writable data.  */\n-#define DATA_SECTION_ASM_OP \"\\n\\tstatic   ; data_section\\n\"\n+/* Output before writable data.\n+   1750 Note: This is actually read-only data. The copying from read-only\n+   to writable memory is done elsewhere (in ASM_FILE_END.)\n+ */\n+#define DATA_SECTION_ASM_OP \"\\n\\tkonst    ; data_section\\n\"\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n@@ -1069,6 +1072,24 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n \t  sprintf (LABEL, \"%s%d\", PREFIX, NUM)\n \n+/* Output at the end of a jump table.\n+   1750: To be uncommented when we can put jump tables in Konst.  \n+   #define ASM_OUTPUT_CASE_END(FILE,NUM,INSN)      \\\n+\tfprintf (FILE, \"\\tnormal\\t; case_end\\n\")\n+ */\n+\n+/* Currently, it is not possible to put jump tables in section Konst.\n+   This is because there is a one-to-one relation between sections Konst\n+   and Static (i.e., all Konst data are copied to Static, and the order\n+   of data is the same between the two sections.) However, jump tables are\n+   not copied to Static, which destroys the equivalence between Konst and\n+   Static. When a more intelligent Konst-to-Static copying mechanism is\n+   implemented (i.e. one that excludes the copying of jumptables), then\n+   ASM_OUTPUT_CASE_END shall be defined, and JUMP_LABELS_IN_TEXT_SECTION\n+   shall be undefined.   */\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n /* This is how to output an assembler line defining a 1750A `float'\n    constant.  */\n \n@@ -1107,49 +1128,60 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \t   label_pending = 0;\t\t\t\t\t\t\\\n \t   datalbl[datalbl_ndx].size = LEN;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\tfor (i = 0; i < LEN; i++)\t\t\t\t\t\\\n+\tfor (i = 0; i < LEN; i++) {\t\t\t\t\t\\\n+\t  if ((i % 15) == 0) {\t\t\t\t\t\t\\\n+\t    if (i != 0)\t\t\t\t\t\t\t\\\n+\t      fprintf(FILE,\"\\n\");\t\t\t\t\t\\\n+\t    fprintf(FILE,\"\\tdata\\t\");\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf(FILE,\",\");\t\t\t\t\t\t\\\n \t  if (PTR[i] >= 32 && PTR[i] < 127)\t\t\t\t\\\n-\t    fprintf(FILE,\"\\tdata\\t%d\\t; '%c'\\n\",PTR[i],PTR[i]);\t\t\\\n+\t    fprintf(FILE,\"'%c'\",PTR[i]);\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf(FILE,\"\\tdata\\t%d\\t; (ascii)\\n\",PTR[i]);\t\t\\\n+\t    fprintf(FILE,\"%d\",PTR[i]);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tfprintf(FILE,\"\\n\");\t\t\t\t\t\t\\\n   } while (0)\n \n-/* This is how to output an assembler line defining an `int' constant.  */\n+/* This is how to output an assembler line defining a `char', `short', or\n+  `int' constant.\n+   1750 NOTE: The reason why this macro also outputs `short' and `int'\n+   constants is that for the 1750, BITS_PER_UNIT is 16 (as opposed to the\n+   usual 8.) This behavior is different from the usual, where\n+   ASM_OUTPUT_CHAR only outputs character constants. The name\n+   of this macro should perhaps be `ASM_OUTPUT_QUARTER_INT' or so.\n+ */\n \n-#define ASM_OUTPUT_INT(FILE,VALUE)  do {\t  \\\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  do {\t  \\\n \tif (! label_pending) \t\t\t\t\t\t\\\n-\t   fprintf(FILE,\";in ASM_OUTPUT_INT without label_pending\\n\");\t\\\n+\t   fprintf(FILE,\";in ASM_OUTPUT_CHAR without label_pending\\n\");\t\\\n \telse {\t\t\t\t\t\t\t\t\\\n \t   label_pending = 0;\t\t\t\t\t\t\\\n \t   datalbl[datalbl_ndx].size = 1;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \tfprintf(FILE, \"\\tdata\\t\"); output_addr_const(FILE,VALUE);\t\\\n \tfprintf(FILE, \"\\n\"); } while (0)\n \n-/* This is how to output an assembler line defining a `long int' constant. */\n+/* This is how to output an assembler line defining a `long int' constant.\n+   1750 NOTE: The reason why this macro outputs `long' instead of `short'\n+   constants is that for the 1750, BITS_PER_UNIT is 16 (as opposed to the\n+   usual 8.) The name of this macro should perhaps be `ASM_OUTPUT_HALF_INT'.\n+ */\n \n-#define ASM_OUTPUT_LONG_INT(FILE,VALUE) do {\t  \\\n+#define ASM_OUTPUT_SHORT(FILE,VALUE) do {\t  \\\n \tif (! label_pending)\t\t\t\t\t\t\\\n-\t   fprintf(FILE,\";in ASM_OUTPUT_LONG_INT without label_pending\\n\");\\\n+\t   fprintf(FILE,\";in ASM_OUTPUT_SHORT without label_pending\\n\");\\\n \telse {\t\t\t\t\t\t\t\t\\\n \t   label_pending = 0;\t\t\t\t\t\t\\\n \t   datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tdatal\\t\"); output_addr_const(FILE,VALUE);\t\\\n-\tfprintf(FILE, \"\\n\"); } while (0)\n-\n-/* Likewise for `short' and `char' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  ASM_OUTPUT_INT(FILE,VALUE)\n-\n-/* For 1750, we treat char same as word. Tektronix 1750\n-   Assembler does a better (packing) job with strings.  */\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)   ASM_OUTPUT_INT(FILE,VALUE)\n+\tfprintf(FILE, \"\\tdatal\\t%d\\n\",INTVAL(VALUE));\t\t\t\\\n+  } while (0)\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n-/* 1750: For the time being, treating this same as word. Tektronix 1750\n-   Assembler does a better (packing) job with strings.  */\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  ASM_OUTPUT_INT(FILE,VALUE)\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  ASM_OUTPUT_CHAR(FILE,VALUE)\n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n@@ -1187,7 +1219,8 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    to define a global common symbol.  */\n \n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  do {\t\\\n-\tfprintf (FILE, \"\\tcommon  %s,%d\\n\", NAME, SIZE);\t\\\n+\tcheck_section(Static);\t\t\t\t\t  \\\n+\tfprintf (FILE, \"\\tcommon  %s,%d\\n\", NAME, SIZE);\t  \\\n      } while (0)\n \n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)  do {\t\t\\"}]}