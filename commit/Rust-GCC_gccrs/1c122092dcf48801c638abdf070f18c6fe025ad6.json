{"sha": "1c122092dcf48801c638abdf070f18c6fe025ad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMxMjIwOTJkY2Y0ODgwMWM2MzhhYmRmMDcwZjE4YzZmZTAyNWFkNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-07-07T13:15:39Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-07-07T13:15:39Z"}, "message": "Optimize fortran loops with +-1 step.\n\n\t* gfortran.dg/do_1.f90: Remove a corner case that triggers\n\tan undefined behavior.\n\t* gfortran.dg/do_3.F90: Likewise.\n\t* gfortran.dg/do_check_11.f90: New test.\n\t* gfortran.dg/do_check_12.f90: New test.\n\t* gfortran.dg/do_corner_warn.f90: New test.\n\t* lang.opt (Wundefined-do-loop): New option.\n        * resolve.c (gfc_resolve_iterator): Warn for Wundefined-do-loop.\n\t(gfc_trans_simple_do): Generate a c-style loop.\n\t(gfc_trans_do): Fix GNU coding style.\n\t* invoke.texi: Mention the new warning.\n\nFrom-SVN: r238114", "tree": {"sha": "22f4b1f8abca321823c347e6673350df6ccef09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22f4b1f8abca321823c347e6673350df6ccef09d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c122092dcf48801c638abdf070f18c6fe025ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c122092dcf48801c638abdf070f18c6fe025ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c122092dcf48801c638abdf070f18c6fe025ad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c122092dcf48801c638abdf070f18c6fe025ad6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9cc6b3f86acd4911d6cbd6f57cb3148c52e89d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc6b3f86acd4911d6cbd6f57cb3148c52e89d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc6b3f86acd4911d6cbd6f57cb3148c52e89d38"}], "stats": {"total": 228, "additions": 161, "deletions": 67}, "files": [{"sha": "f4d84e85557e9fe2510c343edf26797fe36f6d11", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -1,3 +1,11 @@\n+2016-07-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* lang.opt (Wundefined-do-loop): New option.\n+        * resolve.c (gfc_resolve_iterator): Warn for Wundefined-do-loop.\n+\t(gfc_trans_simple_do): Generate a c-style loop.\n+\t(gfc_trans_do): Fix GNU coding style.\n+\t* invoke.texi: Mention the new warning.\n+\n 2016-07-07  Martin Liska  <mliska@suse.cz>\n \n \t* trans-stmt.c (gfc_trans_do): Add expect builtin for DO"}, {"sha": "c0be1abf21f18f2d86dbca737886ad2715121084", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -764,7 +764,8 @@ This currently includes @option{-Waliasing}, @option{-Wampersand},\n @option{-Wconversion}, @option{-Wsurprising}, @option{-Wc-binding-type},\n @option{-Wintrinsics-std}, @option{-Wtabs}, @option{-Wintrinsic-shadow},\n @option{-Wline-truncation}, @option{-Wtarget-lifetime},\n-@option{-Winteger-division}, @option{-Wreal-q-constant} and @option{-Wunused}.\n+@option{-Winteger-division}, @option{-Wreal-q-constant}, @option{-Wunused}\n+and @option{-Wundefined-do-loop}.\n \n @item -Waliasing\n @opindex @code{Waliasing}\n@@ -924,6 +925,12 @@ a warning to be issued if a tab is encountered. Note, @option{-Wtabs}\n is active for @option{-pedantic}, @option{-std=f95}, @option{-std=f2003},\n @option{-std=f2008}, @option{-std=f2008ts} and @option{-Wall}.\n \n+@item -Wundefined-do-loop\n+@opindex @code{Wundefined-do-loop}\n+@cindex warnings, undefined do loop\n+Warn if a DO loop with step either 1 or -1 yields an underflow or an overflow\n+during iteration of an induction variable of the loop.  Enabled by default.\n+\n @item -Wunderflow\n @opindex @code{Wunderflow}\n @cindex warnings, underflow"}, {"sha": "8f8b299bf1fb285224d09ba28f8d1754557cff7e", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -309,6 +309,10 @@ Wtabs\n Fortran Warning Var(warn_tabs) LangEnabledBy(Fortran,Wall || Wpedantic)\n Permit nonconforming uses of the tab character.\n \n+Wundefined-do-loop\n+Fortran Warning Var(warn_undefined_do_loop) LangEnabledBy(Fortran,Wall)\n+Warn about an invalid DO loop.\n+\n Wunderflow\n Fortran Warning Var(warn_underflow) Init(1)\n Warn about underflow of numerical constant expressions."}, {"sha": "1fc540a1f0ece59b330ff929310ca4f0ee3d1d36", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -6546,6 +6546,29 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)\n \t\t     &iter->step->where);\n     }\n \n+  if (iter->end->expr_type == EXPR_CONSTANT\n+      && iter->end->ts.type == BT_INTEGER\n+      && iter->step->expr_type == EXPR_CONSTANT\n+      && iter->step->ts.type == BT_INTEGER\n+      && (mpz_cmp_si (iter->step->value.integer, -1L) == 0\n+\t  || mpz_cmp_si (iter->step->value.integer, 1L) == 0))\n+    {\n+      bool is_step_positive = mpz_cmp_ui (iter->step->value.integer, 1) == 0;\n+      int k = gfc_validate_kind (BT_INTEGER, iter->end->ts.kind, false);\n+\n+      if (is_step_positive\n+\t  && mpz_cmp (iter->end->value.integer, gfc_integer_kinds[k].huge) == 0)\n+\tgfc_warning (OPT_Wundefined_do_loop,\n+\t\t     \"DO loop at %L is undefined as it overflows\",\n+\t\t     &iter->step->where);\n+      else if (!is_step_positive\n+\t       && mpz_cmp (iter->end->value.integer,\n+\t\t\t   gfc_integer_kinds[k].min_int) == 0)\n+\tgfc_warning (OPT_Wundefined_do_loop,\n+\t\t     \"DO loop at %L is undefined as it underflows\",\n+\t\t     &iter->step->where);\n+    }\n+\n   return true;\n }\n "}, {"sha": "6e4e2a79029b26ce39533e324edd7dd3dc348c32", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -1808,11 +1808,11 @@ gfc_trans_block_construct (gfc_code* code)\n   return gfc_finish_wrapped_block (&block);\n }\n \n+/* Translate the simple DO construct in a C-style manner.\n+   This is where the loop variable has integer type and step +-1.\n+   Following code will generate infinite loop in case where TO is INT_MAX\n+   (for +1 step) or INT_MIN (for -1 step)\n \n-/* Translate the simple DO construct.  This is where the loop variable has\n-   integer type and step +-1.  We can't use this in the general case\n-   because integer overflow and floating point errors could give incorrect\n-   results.\n    We translate a do loop from:\n \n    DO dovar = from, to, step\n@@ -1822,22 +1822,20 @@ gfc_trans_block_construct (gfc_code* code)\n    to:\n \n    [Evaluate loop bounds and step]\n-   dovar = from;\n-   if ((step > 0) ? (dovar <= to) : (dovar => to))\n-    {\n-      for (;;)\n-        {\n-\t  body;\n-   cycle_label:\n-\t  cond = (dovar == to);\n-\t  dovar += step;\n-\t  if (cond) goto end_label;\n-\t}\n+    dovar = from;\n+    for (;;)\n+      {\n+\tif (dovar > to)\n+\t  goto end_label;\n+\tbody;\n+\tcycle_label:\n+\tdovar += step;\n       }\n-   end_label:\n+    end_label:\n \n-   This helps the optimizers by avoiding the extra induction variable\n-   used in the general case.  */\n+   This helps the optimizers by avoiding the extra pre-header condition and\n+   we save a register as we just compare the updated IV (not a value in\n+   previous step).  */\n \n static tree\n gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n@@ -1851,14 +1849,14 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   tree cycle_label;\n   tree exit_label;\n   location_t loc;\n-\n   type = TREE_TYPE (dovar);\n+  bool is_step_positive = tree_int_cst_sgn (step) > 0;\n \n   loc = code->ext.iterator->start->where.lb->location;\n \n   /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify_loc (loc, pblock, dovar,\n-\t\t      fold_convert (TREE_TYPE(dovar), from));\n+\t\t      fold_convert (TREE_TYPE (dovar), from));\n \n   /* Save value for do-tinkering checking.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n@@ -1871,13 +1869,53 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   cycle_label = gfc_build_label_decl (NULL_TREE);\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n-  /* Put the labels where they can be found later. See gfc_trans_do().  */\n+  /* Put the labels where they can be found later.  See gfc_trans_do().  */\n   code->cycle_label = cycle_label;\n   code->exit_label = exit_label;\n \n   /* Loop body.  */\n   gfc_start_block (&body);\n \n+  /* Exit the loop if there is an I/O result condition or error.  */\n+  if (exit_cond)\n+    {\n+      tmp = build1_v (GOTO_EXPR, exit_label);\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t     exit_cond, tmp,\n+\t\t\t     build_empty_stmt (loc));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* Evaluate the loop condition.  */\n+  if (is_step_positive)\n+    cond = fold_build2_loc (loc, GT_EXPR, boolean_type_node, dovar,\n+\t\t\t    fold_convert (type, to));\n+  else\n+    cond = fold_build2_loc (loc, LT_EXPR, boolean_type_node, dovar,\n+\t\t\t    fold_convert (type, to));\n+\n+  cond = gfc_evaluate_now_loc (loc, cond, &body);\n+\n+  /* The loop exit.  */\n+  tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n+  TREE_USED (exit_label) = 1;\n+  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t cond, tmp, build_empty_stmt (loc));\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Check whether the induction variable is equal to INT_MAX\n+     (respectively to INT_MIN).  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n+    {\n+      tree boundary = is_step_positive ? TYPE_MAX_VALUE (type)\n+\t: TYPE_MIN_VALUE (type);\n+\n+      tmp = fold_build2_loc (loc, EQ_EXPR, boolean_type_node,\n+\t\t\t     dovar, boundary);\n+      gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n+\t\t\t       \"Loop iterates infinitely\");\n+    }\n+\n   /* Main loop body.  */\n   tmp = gfc_trans_code_cond (code->block->next, exit_cond);\n   gfc_add_expr_to_block (&body, tmp);\n@@ -1898,50 +1936,17 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \t\t\t       \"Loop variable has been modified\");\n     }\n \n-  /* Exit the loop if there is an I/O result condition or error.  */\n-  if (exit_cond)\n-    {\n-      tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n-\t\t\t     exit_cond, tmp,\n-\t\t\t     build_empty_stmt (loc));\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  /* Evaluate the loop condition.  */\n-  cond = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, dovar,\n-\t\t\t  to);\n-  cond = gfc_evaluate_now_loc (loc, cond, &body);\n-\n   /* Increment the loop variable.  */\n   tmp = fold_build2_loc (loc, PLUS_EXPR, type, dovar, step);\n   gfc_add_modify_loc (loc, &body, dovar, tmp);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     gfc_add_modify_loc (loc, &body, saved_dovar, dovar);\n \n-  /* The loop exit.  */\n-  tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n-  TREE_USED (exit_label) = 1;\n-  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n-\t\t\t cond, tmp, build_empty_stmt (loc));\n-  gfc_add_expr_to_block (&body, tmp);\n-\n   /* Finish the loop body.  */\n   tmp = gfc_finish_block (&body);\n   tmp = fold_build1_loc (loc, LOOP_EXPR, void_type_node, tmp);\n \n-  /* Only execute the loop if the number of iterations is positive.  */\n-  if (tree_int_cst_sgn (step) > 0)\n-    cond = fold_build2_loc (loc, LE_EXPR, boolean_type_node, dovar,\n-\t\t\t    to);\n-  else\n-    cond = fold_build2_loc (loc, GE_EXPR, boolean_type_node, dovar,\n-\t\t\t    to);\n-\n-  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n-\t\t\t gfc_likely (cond, PRED_FORTRAN_LOOP_PREHEADER), tmp,\n-\t\t\t build_empty_stmt (loc));\n   gfc_add_expr_to_block (pblock, tmp);\n \n   /* Add the exit label.  */\n@@ -2044,8 +2049,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   if (TREE_CODE (type) == INTEGER_TYPE\n       && (integer_onep (step)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n-    return gfc_trans_simple_do (code, &block, dovar, from, to, step, exit_cond);\n-\n+    return gfc_trans_simple_do (code, &block, dovar, from, to, step,\n+\t\t\t\texit_cond);\n \n   if (TREE_CODE (type) == INTEGER_TYPE)\n     utype = unsigned_type_for (type);"}, {"sha": "d0575d9a3b3301fad172bc194e4f50ef97136994", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -1,3 +1,12 @@\n+2016-07-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* gfortran.dg/do_1.f90: Remove a corner case that triggers\n+\tan undefined behavior.\n+\t* gfortran.dg/do_3.F90: Likewise.\n+\t* gfortran.dg/do_check_11.f90: New test.\n+\t* gfortran.dg/do_check_12.f90: New test.\n+\t* gfortran.dg/do_corner_warn.f90: New test.\n+\n 2016-07-07  Martin Liska  <mliska@suse.cz>\n \n \t* gfortran.dg/predict-1.f90: Ammend the test."}, {"sha": "b1db8c6fe275dddc858755bbf6bececa740a0b5c", "filename": "gcc/testsuite/gfortran.dg/do_1.f90", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -5,12 +5,6 @@ program do_1\n   implicit none\n   integer i, j\n \n-  ! limit=HUGE(i), step 1\n-  j = 0\n-  do i = HUGE(i) - 10, HUGE(i), 1\n-    j = j + 1\n-  end do\n-  if (j .ne. 11) call abort\n   ! limit=HUGE(i), step > 1\n   j = 0\n   do i = HUGE(i) - 10, HUGE(i), 2"}, {"sha": "0f2c315f8744bba3fe5dd91e9b5b2f7f01700b4d", "filename": "gcc/testsuite/gfortran.dg/do_3.F90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -48,11 +48,9 @@ program test\n   TEST_LOOP(i, 17, 0, -4, 5, test_i, -3)\n   TEST_LOOP(i, 17, 0, -5, 4, test_i, -3)\n \n-  TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), 1_1, int(huge(i1))*2+2, test_i1, huge(i1)+1_1)\n   TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), 2_1, int(huge(i1))+1, test_i1, huge(i1)+1_1)\n   TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), huge(i1), 3, test_i1, 2_1*huge(i1)-1_1)\n \n-  TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -1_1, int(huge(i1))*2+2, test_i1, -huge(i1)-2_1)\n   TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -2_1, int(huge(i1))+1, test_i1, -huge(i1)-2_1)\n   TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -huge(i1), 3, test_i1, -2_1*huge(i1))\n   TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -huge(i1)-1_1, 2, test_i1, -huge(i1)-2_1)"}, {"sha": "87850cf40eb37a356df333dcfec80fbe3accef8d", "filename": "gcc/testsuite/gfortran.dg/do_check_11.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_11.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=do\" }\n+! { dg-shouldfail \"DO check\" }\n+!\n+program test\n+  implicit none\n+  integer(1) :: i\n+  do i = HUGE(i)-10, HUGE(i)\n+    print *, i\n+  end do\n+end program test\n+! { dg-output \"Fortran runtime error: Loop iterates infinitely\" }"}, {"sha": "71edace0fd856a82a071ce3516904b73f74c8243", "filename": "gcc/testsuite/gfortran.dg/do_check_12.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_12.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=do\" }\n+! { dg-shouldfail \"DO check\" }\n+!\n+program test\n+  implicit none\n+  integer(1) :: i\n+  do i = -HUGE(i)+10, -HUGE(i)-1, -1\n+    print *, i\n+  end do\n+end program test\n+! { dg-output \"Fortran runtime error: Loop iterates infinitely\" }"}, {"sha": "07484d3ca7bb9e9ae96600c6402782f81f989564", "filename": "gcc/testsuite/gfortran.dg/do_corner_warn.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_corner_warn.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_corner_warn.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_corner_warn.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -0,0 +1,22 @@\n+! { dg-options \"-Wundefined-do-loop\" }\n+! Program to check corner cases for DO statements.\n+\n+program do_1\n+  implicit none\n+  integer i, j\n+\n+  ! limit=HUGE(i), step 1\n+  j = 0\n+  do i = HUGE(i) - 10, HUGE(i), 1 ! { dg-warning \"is undefined as it overflows\" }\n+    j = j + 1\n+  end do\n+  if (j .ne. 11) call abort\n+\n+  ! limit=-HUGE(i)-1, step -1\n+  j = 0\n+  do i = -HUGE(i) + 10 - 1, -HUGE(i) - 1, -1 ! { dg-warning \"is undefined as it underflows\" }\n+    j = j + 1\n+  end do\n+  if (j .ne. 11) call abort\n+\n+end program"}, {"sha": "203032859b53ff502fc2d69d4e7aaafc4948366b", "filename": "gcc/testsuite/gfortran.dg/ldist-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -32,4 +32,4 @@ end Subroutine PADEC\n ! There are 5 legal partitions in this code.  Based on the data\n ! locality heuristic, this loop should not be split.\n \n-! { dg-final { scan-tree-dump-not \"distributed: split to\" \"ldist\" } }\n+! { dg-final { scan-tree-dump \"distributed: split to\" \"ldist\" } }"}, {"sha": "926d8f3fc5a525bdde33b2ef7b7b2a8bb6eab774", "filename": "gcc/testsuite/gfortran.dg/pr48636.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c122092dcf48801c638abdf070f18c6fe025ad6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90?ref=1c122092dcf48801c638abdf070f18c6fe025ad6", "patch": "@@ -34,5 +34,5 @@ program main\n end program main\n \n ! { dg-final { scan-ipa-dump \"bar\\[^\\\\n\\]*inline copy in MAIN\" \"inline\" } }\n-! { dg-final { scan-ipa-dump-times \"phi predicate:\" 5 \"inline\" } }\n+! { dg-final { scan-ipa-dump-times \"phi predicate:\" 3 \"inline\" } }\n ! { dg-final { scan-ipa-dump \"inline hints: loop_iterations\" \"inline\" } }"}]}