{"sha": "5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1MWQwMDY2MTBkNWQ3NGJkYThmM2YzNWVhYmE3Y2U4YzBlOTBmMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-20T01:55:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-20T01:55:17Z"}, "message": "tree-ssa-threadedge.c (thread_across_edge): After threading through a joiner...\n\n\t* tree-ssa-threadedge.c (thread_across_edge): After threading\n\tthrough a joiner, allow threading a normal block requiring\n\tduplication.\n\n\t* tree-ssa-threadupdate.c (thread_block_1): Improve code to detect\n\tjump threading requests that would muck up the loop structures.\n\nFrom-SVN: r205074", "tree": {"sha": "0201b6c20a42aa103d18e98486e543f4c3d753fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0201b6c20a42aa103d18e98486e543f4c3d753fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/comments", "author": null, "committer": null, "parents": [{"sha": "2ed4d7ee3cc50b3ff1fd80eee9152450c0a37711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed4d7ee3cc50b3ff1fd80eee9152450c0a37711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed4d7ee3cc50b3ff1fd80eee9152450c0a37711"}], "stats": {"total": 90, "additions": 62, "deletions": 28}, "files": [{"sha": "7688983f5ca83834edffaaa16004b623e4123514", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "patch": "@@ -1,5 +1,12 @@\n 2013-11-19  Jeff Law  <law@redhat.com>\n-\t\n+\n+\t* tree-ssa-threadedge.c (thread_across_edge): After threading\n+\tthrough a joiner, allow threading a normal block requiring\n+\tduplication.\n+\n+\t* tree-ssa-threadupdate.c (thread_block_1): Improve code to detect\n+\tjump threading requests that would muck up the loop structures.\n+\n \t* tree-ssa-threadupdate.c: Fix trailing whitespace.\n \t* tree-ssa-threadupdate.h: Likewise.\n "}, {"sha": "7bb8829e5cc79b3dfab9845184cfe1193f73728e", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "patch": "@@ -1098,6 +1098,14 @@ thread_across_edge (gimple dummy_cond,\n \t\t\t\t\t      path,\n \t\t\t\t\t      &backedge_seen);\n \n+\tif (!found\n+\t    && (!backedge_seen\n+\t\t|| ! cond_arg_set_in_bb (path->last ()->e, e->dest)))\n+\t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n+\t\t\t\t\t       handle_dominating_asserts,\n+\t\t\t\t\t       stack, simplify, path, visited,\n+\t\t\t\t\t       &backedge_seen);\n+\n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */\n \tif (found)"}, {"sha": "777fe41033b65bbe0b55041e87b8f981c359a5e4", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5f51d006610d5d74bda8f3f35eaba7ce8c0e90f1", "patch": "@@ -328,7 +328,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n \t to the list of incoming edges associated with E.  */\n       if (insert)\n \t{\n-          struct el *el = XNEW (struct el);\n+\t  struct el *el = XNEW (struct el);\n \t  el->next = elt->incoming_edges;\n \t  el->e = e;\n \t  elt->incoming_edges = el;\n@@ -496,11 +496,11 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t      e2 = redirect_edge_and_branch (victim, path->last ()->e->dest);\n \t      e2->count = path->last ()->e->count;\n \t      /* If we redirected the edge, then we need to copy PHI arguments\n-\t         at the target.  If the edge already existed (e2 != victim\n+\t\t at the target.  If the edge already existed (e2 != victim\n \t\t case), then the PHIs in the target already have the correct\n \t\t arguments.  */\n \t      if (e2 == victim)\n-\t        copy_phi_args (e2->dest, path->last ()->e, e2);\n+\t\tcopy_phi_args (e2->dest, path->last ()->e, e2);\n \t    }\n \t  else\n \t    {\n@@ -550,7 +550,7 @@ ssa_create_duplicates (struct redirection_data **slot,\n \n   /* The second duplicated block in a jump threading path is specific\n      to the path.  So it gets stored in RD rather than in LOCAL_DATA.\n-\t\n+\n      Each time we're called, we have to look through the path and see\n      if a second block needs to be duplicated.\n \n@@ -672,7 +672,7 @@ ssa_redirect_edges (struct redirection_data **slot,\n \t}\n \n       /* Go ahead and clear E->aux.  It's not needed anymore and failure\n-         to clear it will cause all kinds of unpleasant problems later.  */\n+\t to clear it will cause all kinds of unpleasant problems later.  */\n       delete_jump_thread_path (path);\n       e->aux = NULL;\n \n@@ -697,9 +697,9 @@ redirection_block_p (basic_block bb)\n   /* Advance to the first executable statement.  */\n   gsi = gsi_start_bb (bb);\n   while (!gsi_end_p (gsi)\n-         && (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL\n+\t && (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL\n \t     || is_gimple_debug (gsi_stmt (gsi))\n-             || gimple_nop_p (gsi_stmt (gsi))))\n+\t     || gimple_nop_p (gsi_stmt (gsi))))\n     gsi_next (&gsi);\n \n   /* Check if this is an empty block.  */\n@@ -708,9 +708,9 @@ redirection_block_p (basic_block bb)\n \n   /* Test that we've reached the terminating control statement.  */\n   return gsi_stmt (gsi)\n-         && (gimple_code (gsi_stmt (gsi)) == GIMPLE_COND\n-             || gimple_code (gsi_stmt (gsi)) == GIMPLE_GOTO\n-             || gimple_code (gsi_stmt (gsi)) == GIMPLE_SWITCH);\n+\t && (gimple_code (gsi_stmt (gsi)) == GIMPLE_COND\n+\t     || gimple_code (gsi_stmt (gsi)) == GIMPLE_GOTO\n+\t     || gimple_code (gsi_stmt (gsi)) == GIMPLE_SWITCH);\n }\n \n /* BB is a block which ends with a COND_EXPR or SWITCH_EXPR and when BB\n@@ -795,22 +795,12 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n       if (!e2 || noloop_only)\n \t{\n \t  /* If NOLOOP_ONLY is true, we only allow threading through the\n-\t     header of a loop to exit edges.\n-\n-\t     There are two cases to consider.  The first when BB is the\n-\t     loop header.  We will attempt to thread this elsewhere, so\n-\t     we can just continue here.  */\n-\n-\t  if (bb == bb->loop_father->header\n-\t      && (!loop_exit_edge_p (bb->loop_father, e2)\n-\t\t  || (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK))\n-\t    continue;\n-\n+\t     header of a loop to exit edges.  */\n \n-\t  /* The second occurs when there was loop header buried in a jump\n-\t     threading path.  We do not try and thread this elsewhere, so\n-\t     just cancel the jump threading request by clearing the AUX\n-\t     field now.  */\n+\t  /* One case occurs when there was loop header buried in a jump\n+\t     threading path that crosses loop boundaries.  We do not try\n+\t     and thread this elsewhere, so just cancel the jump threading\n+\t     request by clearing the AUX field now.  */\n \t  if ((bb->loop_father != e2->src->loop_father\n \t       && !loop_exit_edge_p (e2->src->loop_father, e2))\n \t      || (e2->src->loop_father != e2->dest->loop_father\n@@ -823,11 +813,40 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \t      e->aux = NULL;\n \t      continue;\n \t    }\n+\n+\t  /* Another case occurs when trying to thread through our\n+\t     own loop header, possibly from inside the loop.\n+\n+\t     If our loop header is buried in the path, then go ahead\n+\t     and cancel the jump threading request here.  This likely\n+\t     will need updating for the FSA/FSM coremark case.\n+\n+\t     Other cases (BB is the loop header) are handled elsewhere.  */\n+\t  unsigned int i;\n+\t  for (i = 1; i < path->length (); i++)\n+\t    {\n+\t      if ((*path)[i]->e->src == bb->loop_father->header\n+\t\t  && (!loop_exit_edge_p (bb->loop_father, e2)\n+\t\t      || (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK))\n+\t\t{\n+\t\t  /* If i != 1, then it's a buried header that will not\n+\t\t     be handled elsehwere.  */\n+\t\t  if (i != 1)\n+\t\t    {\n+\t\t      delete_jump_thread_path (path);\n+\t\t      e->aux = NULL;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (i != path->length ())\n+\t    continue;\n \t}\n \n       if (e->dest == e2->src)\n \tupdate_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t         e->count, (*THREAD_PATH (e))[1]->e);\n+\t\t\t\t\t e->count, (*THREAD_PATH (e))[1]->e);\n \n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n@@ -1242,7 +1261,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n       unsigned nblocks, i;\n \n       /* First handle the case latch edge is redirected.  We are copying\n-         the loop header but not creating a multiple entry loop.  Make the\n+\t the loop header but not creating a multiple entry loop.  Make the\n \t cfg manipulation code aware of that fact.  */\n       set_loop_copy (loop, loop);\n       loop->latch = thread_single_edge (latch);"}]}