{"sha": "996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2YWUwYjBhZWI5ZTA3YTRkN2Q3ZmYyOTI2NjI1ZmQwYTU4MzQ5ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:52:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:52:00Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45959", "tree": {"sha": "2e58881ac983eb14cefbc37dcb02b8fd6e9f6990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e58881ac983eb14cefbc37dcb02b8fd6e9f6990"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/comments", "author": null, "committer": null, "parents": [{"sha": "2b3d3db68da14b782f8d69ccebc18af04c61ce15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3d3db68da14b782f8d69ccebc18af04c61ce15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3d3db68da14b782f8d69ccebc18af04c61ce15"}], "stats": {"total": 129948, "additions": 129948, "deletions": 0}, "files": [{"sha": "327f3aa1b58e8707d7d5ba931a99ce3eeca71b0b", "filename": "gcc/ada/scans.adb", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscans.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscans.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,76 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                S C A N S                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Scans is\n+\n+   ------------------------\n+   -- Restore_Scan_State --\n+   ------------------------\n+\n+   procedure Restore_Scan_State (Saved_State : in Saved_Scan_State) is\n+   begin\n+      Scan_Ptr                 := Saved_State.Save_Scan_Ptr;\n+      Token                    := Saved_State.Save_Token;\n+      Token_Ptr                := Saved_State.Save_Token_Ptr;\n+      Current_Line_Start       := Saved_State.Save_Current_Line_Start;\n+      Start_Column             := Saved_State.Save_Start_Column;\n+      Checksum                 := Saved_State.Save_Checksum;\n+      First_Non_Blank_Location := Saved_State.Save_First_Non_Blank_Location;\n+      Token_Node               := Saved_State.Save_Token_Node;\n+      Token_Name               := Saved_State.Save_Token_Name;\n+      Prev_Token               := Saved_State.Save_Prev_Token;\n+      Prev_Token_Ptr           := Saved_State.Save_Prev_Token_Ptr;\n+   end Restore_Scan_State;\n+\n+   ---------------------\n+   -- Save_Scan_State --\n+   ---------------------\n+\n+   procedure Save_Scan_State (Saved_State : out Saved_Scan_State) is\n+   begin\n+      Saved_State.Save_Scan_Ptr                 := Scan_Ptr;\n+      Saved_State.Save_Token                    := Token;\n+      Saved_State.Save_Token_Ptr                := Token_Ptr;\n+      Saved_State.Save_Current_Line_Start       := Current_Line_Start;\n+      Saved_State.Save_Start_Column             := Start_Column;\n+      Saved_State.Save_Checksum                 := Checksum;\n+      Saved_State.Save_First_Non_Blank_Location := First_Non_Blank_Location;\n+      Saved_State.Save_Token_Node               := Token_Node;\n+      Saved_State.Save_Token_Name               := Token_Name;\n+      Saved_State.Save_Prev_Token               := Prev_Token;\n+      Saved_State.Save_Prev_Token_Ptr           := Prev_Token_Ptr;\n+   end Save_Scan_State;\n+\n+end Scans;"}, {"sha": "b9d89e1f0efbeb142591b862dc7e871b2f514e12", "filename": "gcc/ada/scans.ads", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,418 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                S C A N S                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.32 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Scans is\n+\n+--  The scanner maintains a current state in the global variables defined\n+--  in this package. The call to the Scan routine advances this state to\n+--  the next token. The state is initialized by the call to one of the\n+--  initialization routines in Sinput.\n+\n+   --  The following type is used to identify token types returned by Scan.\n+   --  The class column in this table indicates the token classes which\n+   --  apply to the token, as defined by subsquent subtype declarations.\n+\n+   --  Note: the coding in SCN depends on the fact that the first entry in\n+   --  this type declaration is *not* for a reserved word. For details on\n+   --  why there is this requirement, see Scn.Initialize_Scanner.\n+\n+   type Token_Type is (\n+\n+      --  Token name          Token type   Class(es)\n+\n+      Tok_Integer_Literal, -- numeric lit  Literal, Lit_Or_Name\n+\n+      Tok_Real_Literal,    -- numeric lit  Literal, Lit_Or_Name\n+\n+      Tok_String_Literal,  -- string lit   Literal. Lit_Or_Name\n+\n+      Tok_Char_Literal,    -- char lit     Name, Literal. Lit_Or_Name\n+\n+      Tok_Operator_Symbol, -- op symbol    Name, Literal, Lit_Or_Name, Desig\n+\n+      Tok_Identifier,      -- identifer    Name, Lit_Or_Name, Desig\n+\n+      Tok_Double_Asterisk, -- **\n+\n+      Tok_Ampersand,       -- &            Binary_Addop\n+      Tok_Minus,           -- -            Binary_Addop, Unary_Addop\n+      Tok_Plus,            -- +            Binary_Addop, Unary_Addop\n+\n+      Tok_Asterisk,        -- *            Mulop\n+      Tok_Mod,             -- MOD          Mulop\n+      Tok_Rem,             -- REM          Mulop\n+      Tok_Slash,           -- /            Mulop\n+\n+      Tok_New,             -- NEW\n+\n+      Tok_Abs,             -- ABS\n+      Tok_Others,          -- OTHERS\n+      Tok_Null,            -- NULL\n+\n+      Tok_Dot,             -- .            Namext\n+      Tok_Apostrophe,      -- '            Namext\n+\n+      Tok_Left_Paren,      -- (            Namext, Consk\n+\n+      Tok_Delta,           -- DELTA        Atkwd, Sterm, Consk\n+      Tok_Digits,          -- DIGITS       Atkwd, Sterm, Consk\n+      Tok_Range,           -- RANGE        Atkwd, Sterm, Consk\n+\n+      Tok_Right_Paren,     -- )            Sterm\n+      Tok_Comma,           -- ,            Sterm\n+\n+      Tok_And,             -- AND          Logop, Sterm\n+      Tok_Or,              -- OR           Logop, Sterm\n+      Tok_Xor,             -- XOR          Logop, Sterm\n+\n+      Tok_Less,            -- <            Relop, Sterm\n+      Tok_Equal,           -- =            Relop, Sterm\n+      Tok_Greater,         -- >            Relop, Sterm\n+      Tok_Not_Equal,       -- /=           Relop, Sterm\n+      Tok_Greater_Equal,   -- >=           Relop, Sterm\n+      Tok_Less_Equal,      -- <=           Relop, Sterm\n+\n+      Tok_In,              -- IN           Relop, Sterm\n+      Tok_Not,             -- NOT          Relop, Sterm\n+\n+      Tok_Box,             -- <>           Relop, Eterm, Sterm\n+      Tok_Colon_Equal,     -- :=           Eterm, Sterm\n+      Tok_Colon,           -- :            Eterm, Sterm\n+      Tok_Greater_Greater, -- >>           Eterm, Sterm\n+\n+      Tok_Abstract,        -- ABSTRACT     Eterm, Sterm\n+      Tok_Access,          -- ACCESS       Eterm, Sterm\n+      Tok_Aliased,         -- ALIASED      Eterm, Sterm\n+      Tok_All,             -- ALL          Eterm, Sterm\n+      Tok_Array,           -- ARRAY        Eterm, Sterm\n+      Tok_At,              -- AT           Eterm, Sterm\n+      Tok_Body,            -- BODY         Eterm, Sterm\n+      Tok_Constant,        -- CONSTANT     Eterm, Sterm\n+      Tok_Do,              -- DO           Eterm, Sterm\n+      Tok_Is,              -- IS           Eterm, Sterm\n+      Tok_Limited,         -- LIMITED      Eterm, Sterm\n+      Tok_Of,              -- OF           Eterm, Sterm\n+      Tok_Out,             -- OUT          Eterm, Sterm\n+      Tok_Record,          -- RECORD       Eterm, Sterm\n+      Tok_Renames,         -- RENAMES      Eterm, Sterm\n+      Tok_Reverse,         -- REVERSE      Eterm, Sterm\n+      Tok_Tagged,          -- TAGGED       Eterm, Sterm\n+      Tok_Then,            -- THEN         Eterm, Sterm\n+\n+      Tok_Less_Less,       -- <<           Eterm, Sterm, After_SM\n+\n+      Tok_Abort,           -- ABORT        Eterm, Sterm, After_SM\n+      Tok_Accept,          -- ACCEPT       Eterm, Sterm, After_SM\n+      Tok_Case,            -- CASE         Eterm, Sterm, After_SM\n+      Tok_Delay,           -- DELAY        Eterm, Sterm, After_SM\n+      Tok_Else,            -- ELSE         Eterm, Sterm, After_SM\n+      Tok_Elsif,           -- ELSIF        Eterm, Sterm, After_SM\n+      Tok_End,             -- END          Eterm, Sterm, After_SM\n+      Tok_Exception,       -- EXCEPTION    Eterm, Sterm, After_SM\n+      Tok_Exit,            -- EXIT         Eterm, Sterm, After_SM\n+      Tok_Goto,            -- GOTO         Eterm, Sterm, After_SM\n+      Tok_If,              -- IF           Eterm, Sterm, After_SM\n+      Tok_Pragma,          -- PRAGMA       Eterm, Sterm, After_SM\n+      Tok_Raise,           -- RAISE        Eterm, Sterm, After_SM\n+      Tok_Requeue,         -- REQUEUE      Eterm, Sterm, After_SM\n+      Tok_Return,          -- RETURN       Eterm, Sterm, After_SM\n+      Tok_Select,          -- SELECT       Eterm, Sterm, After_SM\n+      Tok_Terminate,       -- TERMINATE    Eterm, Sterm, After_SM\n+      Tok_Until,           -- UNTIL        Eterm, Sterm, After_SM\n+      Tok_When,            -- WHEN         Eterm, Sterm, After_SM\n+\n+      Tok_Begin,           -- BEGIN        Eterm, Sterm, After_SM, Labeled_Stmt\n+      Tok_Declare,         -- DECLARE      Eterm, Sterm, After_SM, Labeled_Stmt\n+      Tok_For,             -- FOR          Eterm, Sterm, After_SM, Labeled_Stmt\n+      Tok_Loop,            -- LOOP         Eterm, Sterm, After_SM, Labeled_Stmt\n+      Tok_While,           -- WHILE        Eterm, Sterm, After_SM, Labeled_Stmt\n+\n+      Tok_Entry,           -- ENTRY        Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Protected,       -- PROTECTED    Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Task,            -- TASK         Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Type,            -- TYPE         Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Subtype,         -- SUBTYPE      Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Use,             -- USE          Eterm, Sterm, Declk, Deckn, After_SM\n+\n+      Tok_Function,        -- FUNCTION     Eterm, Sterm, Cunit, Declk, After_SM\n+      Tok_Generic,         -- GENERIC      Eterm, Sterm, Cunit, Declk, After_SM\n+      Tok_Package,         -- PACKAGE      Eterm, Sterm, Cunit, Declk, After_SM\n+      Tok_Procedure,       -- PROCEDURE    Eterm, Sterm, Cunit, Declk, After_SM\n+\n+      Tok_Private,         -- PRIVATE      Eterm, Sterm, Cunit, After_SM\n+      Tok_With,            -- WITH         Eterm, Sterm, Cunit, After_SM\n+      Tok_Separate,        -- SEPARATE     Eterm, Sterm, Cunit, After_SM\n+\n+      Tok_EOF,             -- End of file  Eterm, Sterm, Cterm, After_SM\n+\n+      Tok_Semicolon,       -- ;            Eterm, Sterm, Cterm\n+\n+      Tok_Arrow,           -- =>           Sterm, Cterm, Chtok\n+\n+      Tok_Vertical_Bar,    -- |            Cterm, Sterm, Chtok\n+\n+      Tok_Dot_Dot,         -- ..           Sterm, Chtok\n+\n+      --  The following three entries are used only when scanning\n+      --  project files.\n+\n+      Tok_Project,\n+      Tok_Modifying,\n+      Tok_External,\n+\n+      No_Token);\n+      --  No_Token is used for initializing Token values to indicate that\n+      --  no value has been set yet.\n+\n+   --  Note: in the RM, operator symbol is a special case of string literal.\n+   --  We distinguish at the lexical level in this compiler, since there are\n+   --  many syntactic situations in which only an operator symbol is allowed.\n+\n+   --  The following subtype declarations group the token types into classes.\n+   --  These are used for class tests in the parser.\n+\n+      subtype Token_Class_Numeric_Literal is\n+        Token_Type range Tok_Integer_Literal .. Tok_Real_Literal;\n+      --  Numeric literal\n+\n+      subtype Token_Class_Literal is\n+        Token_Type range Tok_Integer_Literal .. Tok_Operator_Symbol;\n+      --  Literal\n+\n+      subtype Token_Class_Lit_Or_Name is\n+        Token_Type range Tok_Integer_Literal .. Tok_Identifier;\n+\n+      subtype Token_Class_Binary_Addop is\n+        Token_Type range Tok_Ampersand .. Tok_Plus;\n+      --  Binary adding operator (& + -)\n+\n+      subtype Token_Class_Unary_Addop is\n+        Token_Type range Tok_Minus .. Tok_Plus;\n+      --  Unary adding operator (+ -)\n+\n+      subtype Token_Class_Mulop is\n+        Token_Type range Tok_Asterisk .. Tok_Slash;\n+      --  Multiplying operator\n+\n+      subtype Token_Class_Logop is\n+        Token_Type range Tok_And .. Tok_Xor;\n+      --  Logical operator (and, or, xor)\n+\n+      subtype Token_Class_Relop is\n+        Token_Type range Tok_Less .. Tok_Box;\n+      --  Relational operator (= /= < <= > >= not, in plus <> to catch misuse\n+      --  of Pascal style not equal operator).\n+\n+      subtype Token_Class_Name is\n+        Token_Type range Tok_Char_Literal .. Tok_Identifier;\n+      --  First token of name (4.1),\n+      --    (identifier, char literal, operator symbol)\n+\n+      subtype Token_Class_Desig is\n+        Token_Type range Tok_Operator_Symbol .. Tok_Identifier;\n+      --  Token which can be a Designator (identifier, operator symbol)\n+\n+      subtype Token_Class_Namext is\n+        Token_Type range Tok_Dot .. Tok_Left_Paren;\n+      --  Name extension tokens. These are tokens which can appear immediately\n+      --  after a name to extend it recursively (period, quote, left paren)\n+\n+      subtype Token_Class_Consk is\n+        Token_Type range Tok_Left_Paren .. Tok_Range;\n+      --  Keywords which can start constraint\n+      --    (left paren, delta, digits, range)\n+\n+      subtype Token_Class_Eterm is\n+        Token_Type range Tok_Colon_Equal .. Tok_Semicolon;\n+      --  Expression terminators. These tokens can never appear within a simple\n+      --  expression. This is used for error recovery purposes (if we encounter\n+      --  an error in an expression, we simply scan to the next Eterm token).\n+\n+      subtype Token_Class_Sterm is\n+        Token_Type range Tok_Delta .. Tok_Dot_Dot;\n+      --  Simple_Expression terminators. A Simple_Expression must be followed\n+      --  by a token in this class, or an error message is issued complaining\n+      --  about a missing binary operator.\n+\n+      subtype Token_Class_Atkwd is\n+        Token_Type range Tok_Delta .. Tok_Range;\n+      --  Attribute keywords. This class includes keywords which can be used\n+      --  as an Attribute_Designator, namely DELTA, DIGITS and RANGE\n+\n+      subtype Token_Class_Cterm is\n+        Token_Type range Tok_EOF .. Tok_Vertical_Bar;\n+      --  Choice terminators. These tokens terminate a choice. This is used for\n+      --  error recovery purposes (if we encounter an error in a Choice, we\n+      --  simply scan to the next Cterm token).\n+\n+      subtype Token_Class_Chtok is\n+        Token_Type range Tok_Arrow .. Tok_Dot_Dot;\n+      --  Choice tokens. These tokens signal a choice when used in an Aggregate\n+\n+      subtype Token_Class_Cunit is\n+        Token_Type range Tok_Function .. Tok_Separate;\n+      --  Tokens which can begin a compilation unit\n+\n+      subtype Token_Class_Declk is\n+        Token_Type range Tok_Entry .. Tok_Procedure;\n+      --  Keywords which start a declaration\n+\n+      subtype Token_Class_Deckn is\n+        Token_Type range Tok_Entry .. Tok_Use;\n+      --  Keywords which start a declaration but can't start a compilation unit\n+\n+      subtype Token_Class_After_SM is\n+        Token_Type range Tok_Less_Less .. Tok_EOF;\n+      --  Tokens which always, or almost always, appear after a semicolon. Used\n+      --  in the Resync_Past_Semicolon routine to avoid gobbling up stuff when\n+      --  a semicolon is missing. Of significance only for error recovery.\n+\n+      subtype Token_Class_Labeled_Stmt is\n+        Token_Type range Tok_Begin .. Tok_While;\n+      --  Tokens which start labeled statements\n+\n+      type Token_Flag_Array is array (Token_Type) of Boolean;\n+      Is_Reserved_Keyword : constant Token_Flag_Array := Token_Flag_Array'(\n+         Tok_Mod      .. Tok_Rem      => True,\n+         Tok_New      .. Tok_Null     => True,\n+         Tok_Delta    .. Tok_Range    => True,\n+         Tok_And      .. Tok_Xor      => True,\n+         Tok_In       .. Tok_Not      => True,\n+         Tok_Abstract .. Tok_Then     => True,\n+         Tok_Abort    .. Tok_Separate => True,\n+         others                       => False);\n+      --  Flag array used to test for reserved word\n+\n+   --------------------------\n+   -- Scan State Variables --\n+   --------------------------\n+\n+   --  Note: these variables can only be referenced during the parsing of a\n+   --  file. Reference to any of them from Sem or the expander is wrong.\n+\n+   Scan_Ptr : Source_Ptr;\n+   --  Current scan pointer location. After a call to Scan, this points\n+   --  just past the end of the token just scanned.\n+\n+   Token : Token_Type;\n+   --  Type of current token\n+\n+   Token_Ptr : Source_Ptr;\n+   --  Pointer to first character of current token\n+\n+   Current_Line_Start : Source_Ptr;\n+   --  Pointer to first character of line containing current token\n+\n+   Start_Column : Column_Number;\n+   --  Starting column number (zero origin) of the first non-blank character\n+   --  on the line containing the current token. This is used for error\n+   --  recovery circuits which depend on looking at the column line up.\n+\n+   Checksum : Word;\n+   --  Used to accumulate a checksum representing the tokens in the source\n+   --  file being compiled. This checksum includes only program tokens, and\n+   --  excludes comments.\n+\n+   First_Non_Blank_Location : Source_Ptr;\n+   --  Location of first non-blank character on the line containing the\n+   --  current token (i.e. the location of the character whose column number\n+   --  is stored in Start_Column).\n+\n+   Token_Node : Node_Id := Empty;\n+   --  Node table Id for the current token. This is set only if the current\n+   --  token is one for which the scanner constructs a node (i.e. it is an\n+   --  identifier, operator symbol, or literal. For other token types,\n+   --  Token_Node is undefined.\n+\n+   Token_Name : Name_Id := No_Name;\n+   --  For identifiers, this is set to the Name_Id of the identifier scanned.\n+   --  For all other tokens, Token_Name is set to Error_Name. Note that it\n+   --  would be possible for the caller to extract this information from\n+   --  Token_Node. We set Token_Name separately for two reasons. First it\n+   --  allows a quicker test for a specific identifier. Second, it allows\n+   --  a version of the parser to be built that does not build tree nodes,\n+   --  usable as a syntax checker.\n+\n+   Prev_Token : Token_Type := No_Token;\n+   --  Type of previous token\n+\n+   Prev_Token_Ptr : Source_Ptr;\n+   --  Pointer to first character of previous token\n+\n+   Version_To_Be_Found : Boolean;\n+   --  This flag is True if the scanner is still looking for an RCS version\n+   --  number in a comment. Normally it is initialized to False so that this\n+   --  circuit is not activated. If the -dv switch is set, then this flag is\n+   --  initialized to True, and then reset when the version number is found.\n+   --  We do things this way to minimize the impact on comment scanning.\n+\n+   --------------------------------------------------------\n+   -- Procedures for Saving and Restoring the Scan State --\n+   --------------------------------------------------------\n+\n+   --  The following procedures can be used to save and restore the entire\n+   --  scan state. They are used in cases where it is necessary to backup\n+   --  the scan during the parse.\n+\n+   type Saved_Scan_State is private;\n+   --  Used for saving and restoring the scan state\n+\n+   procedure Save_Scan_State (Saved_State : out Saved_Scan_State);\n+   pragma Inline (Save_Scan_State);\n+   --  Saves the current scan state for possible later restoration. Note that\n+   --  there is no harm in saving the state and then never restoring it.\n+\n+   procedure Restore_Scan_State (Saved_State : in Saved_Scan_State);\n+   pragma Inline (Restore_Scan_State);\n+   --  Restores a scan state saved by a call to Save_Scan_State.\n+   --  The saved scan state must refer to the current source file.\n+\n+private\n+   type Saved_Scan_State is record\n+      Save_Scan_Ptr                 : Source_Ptr;\n+      Save_Token                    : Token_Type;\n+      Save_Token_Ptr                : Source_Ptr;\n+      Save_Current_Line_Start       : Source_Ptr;\n+      Save_Start_Column             : Column_Number;\n+      Save_Checksum                 : Word;\n+      Save_First_Non_Blank_Location : Source_Ptr;\n+      Save_Token_Node               : Node_Id;\n+      Save_Token_Name               : Name_Id;\n+      Save_Prev_Token               : Token_Type;\n+      Save_Prev_Token_Ptr           : Source_Ptr;\n+   end record;\n+\n+end Scans;"}, {"sha": "f027ba25b3a7e3f96134f41bbfcba4b38349890c", "filename": "gcc/ada/scn-nlit.adb", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn-nlit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn-nlit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn-nlit.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,371 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S C N . N L I T                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.32 $                             --\n+--                                                                          --\n+--   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Uintp;  use Uintp;\n+with Urealp; use Urealp;\n+\n+separate (Scn)\n+procedure Nlit is\n+\n+   C : Character;\n+   --  Current source program character\n+\n+   Base_Char : Character;\n+   --  Either # or : (character at start of based number)\n+\n+   Base : Int;\n+   --  Value of base\n+\n+   UI_Base : Uint;\n+   --  Value of base in Uint format\n+\n+   UI_Int_Value : Uint;\n+   --  Value of integer scanned by Scan_Integer in Uint format\n+\n+   UI_Num_Value : Uint;\n+   --  Value of integer in numeric value being scanned\n+\n+   Scale : Int;\n+   --  Scale value for real literal\n+\n+   UI_Scale : Uint;\n+   --  Scale in Uint format\n+\n+   Exponent_Is_Negative : Boolean;\n+   --  Set true for negative exponent\n+\n+   Extended_Digit_Value : Int;\n+   --  Extended digit value\n+\n+   Point_Scanned : Boolean;\n+   --  Flag for decimal point scanned in numeric literal\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Error_Digit_Expected;\n+   --  Signal error of bad digit, Scan_Ptr points to the location at which\n+   --  the digit was expected on input, and is unchanged on return.\n+\n+   procedure Scan_Integer;\n+   --  Procedure to scan integer literal. On entry, Scan_Ptr points to a\n+   --  digit, on exit Scan_Ptr points past the last character of the integer.\n+   --  For each digit encountered, UI_Int_Value is multiplied by 10, and the\n+   --  value of the digit added to the result. In addition, the value in\n+   --  Scale is decremented by one for each actual digit scanned.\n+\n+   --------------------------\n+   -- Error_Digit_Expected --\n+   --------------------------\n+\n+   procedure Error_Digit_Expected is\n+   begin\n+      Error_Msg_S (\"digit expected\");\n+   end Error_Digit_Expected;\n+\n+   -------------------\n+   --  Scan_Integer --\n+   -------------------\n+\n+   procedure Scan_Integer is\n+      C : Character;\n+      --  Next character scanned\n+\n+   begin\n+      C := Source (Scan_Ptr);\n+\n+      --  Loop through digits (allowing underlines)\n+\n+      loop\n+         Accumulate_Checksum (C);\n+         UI_Int_Value :=\n+           UI_Int_Value * 10 + (Character'Pos (C) - Character'Pos ('0'));\n+         Scan_Ptr := Scan_Ptr + 1;\n+         Scale := Scale - 1;\n+         C := Source (Scan_Ptr);\n+\n+         if C = '_' then\n+            Accumulate_Checksum ('_');\n+\n+            loop\n+               Scan_Ptr := Scan_Ptr + 1;\n+               C := Source (Scan_Ptr);\n+               exit when C /= '_';\n+               Error_No_Double_Underline;\n+            end loop;\n+\n+            if C not in '0' .. '9' then\n+               Error_Digit_Expected;\n+               exit;\n+            end if;\n+\n+         else\n+            exit when C not in '0' .. '9';\n+         end if;\n+      end loop;\n+\n+   end Scan_Integer;\n+\n+----------------------------------\n+-- Start of Processing for Nlit --\n+----------------------------------\n+\n+begin\n+   Base := 10;\n+   UI_Base := Uint_10;\n+   UI_Int_Value := Uint_0;\n+   Scale := 0;\n+   Scan_Integer;\n+   Scale := 0;\n+   Point_Scanned := False;\n+   UI_Num_Value := UI_Int_Value;\n+\n+   --  Various possibilities now for continuing the literal are\n+   --  period, E/e (for exponent), or :/# (for based literal).\n+\n+   Scale := 0;\n+   C := Source (Scan_Ptr);\n+\n+   if C = '.' then\n+\n+      --  Scan out point, but do not scan past .. which is a range sequence,\n+      --  and must not be eaten up scanning a numeric literal.\n+\n+      while C = '.' and then Source (Scan_Ptr + 1) /= '.' loop\n+         Accumulate_Checksum ('.');\n+\n+         if Point_Scanned then\n+            Error_Msg_S (\"duplicate point ignored\");\n+         end if;\n+\n+         Point_Scanned := True;\n+         Scan_Ptr := Scan_Ptr + 1;\n+         C := Source (Scan_Ptr);\n+\n+         if C not in '0' .. '9' then\n+            Error_Msg (\"real literal cannot end with point\", Scan_Ptr - 1);\n+         else\n+            Scan_Integer;\n+            UI_Num_Value := UI_Int_Value;\n+         end if;\n+      end loop;\n+\n+   --  Based literal case. The base is the value we already scanned.\n+   --  In the case of colon, we insist that the following character\n+   --  is indeed an extended digit or a period. This catches a number\n+   --  of common errors, as well as catching the well known tricky\n+   --  bug otherwise arising from \"x : integer range 1 .. 10:= 6;\"\n+\n+   elsif C = '#'\n+     or else (C = ':' and then\n+                        (Source (Scan_Ptr + 1) = '.'\n+                           or else\n+                         Source (Scan_Ptr + 1) in '0' .. '9'\n+                           or else\n+                         Source (Scan_Ptr + 1) in 'A' .. 'Z'\n+                           or else\n+                         Source (Scan_Ptr + 1) in 'a' .. 'z'))\n+   then\n+      Accumulate_Checksum (C);\n+      Base_Char := C;\n+      UI_Base := UI_Int_Value;\n+\n+      if UI_Base < 2 or else UI_Base > 16 then\n+         Error_Msg_SC (\"base not 2-16\");\n+         UI_Base := Uint_16;\n+      end if;\n+\n+      Base := UI_To_Int (UI_Base);\n+      Scan_Ptr := Scan_Ptr + 1;\n+\n+      --  Scan out extended integer [. integer]\n+\n+      C := Source (Scan_Ptr);\n+      UI_Int_Value := Uint_0;\n+      Scale := 0;\n+\n+      loop\n+         if C in '0' .. '9' then\n+            Accumulate_Checksum (C);\n+            Extended_Digit_Value :=\n+              Int'(Character'Pos (C)) - Int'(Character'Pos ('0'));\n+\n+         elsif C in 'A' .. 'F' then\n+            Accumulate_Checksum (Character'Val (Character'Pos (C) + 32));\n+            Extended_Digit_Value :=\n+              Int'(Character'Pos (C)) - Int'(Character'Pos ('A')) + 10;\n+\n+         elsif C in 'a' .. 'f' then\n+            Accumulate_Checksum (C);\n+            Extended_Digit_Value :=\n+              Int'(Character'Pos (C)) - Int'(Character'Pos ('a')) + 10;\n+\n+         else\n+            Error_Msg_S (\"extended digit expected\");\n+            exit;\n+         end if;\n+\n+         if Extended_Digit_Value >= Base then\n+            Error_Msg_S (\"digit >= base\");\n+         end if;\n+\n+         UI_Int_Value := UI_Int_Value * UI_Base + Extended_Digit_Value;\n+         Scale := Scale - 1;\n+         Scan_Ptr := Scan_Ptr + 1;\n+         C := Source (Scan_Ptr);\n+\n+         if C = '_' then\n+            loop\n+               Accumulate_Checksum ('_');\n+               Scan_Ptr := Scan_Ptr + 1;\n+               C := Source (Scan_Ptr);\n+               exit when C /= '_';\n+               Error_No_Double_Underline;\n+            end loop;\n+\n+         elsif C = '.' then\n+            Accumulate_Checksum ('.');\n+\n+            if Point_Scanned then\n+               Error_Msg_S (\"duplicate point ignored\");\n+            end if;\n+\n+            Scan_Ptr := Scan_Ptr + 1;\n+            C := Source (Scan_Ptr);\n+            Point_Scanned := True;\n+            Scale := 0;\n+\n+         elsif C = Base_Char then\n+            Accumulate_Checksum (C);\n+            Scan_Ptr := Scan_Ptr + 1;\n+            exit;\n+\n+         elsif C = '#' or else C = ':' then\n+            Error_Msg_S (\"based number delimiters must match\");\n+            Scan_Ptr := Scan_Ptr + 1;\n+            exit;\n+\n+         elsif not Identifier_Char (C) then\n+            if Base_Char = '#' then\n+               Error_Msg_S (\"missing '#\");\n+            else\n+               Error_Msg_S (\"missing ':\");\n+            end if;\n+\n+            exit;\n+         end if;\n+\n+      end loop;\n+\n+      UI_Num_Value := UI_Int_Value;\n+   end if;\n+\n+   --  Scan out exponent\n+\n+   if not Point_Scanned then\n+      Scale := 0;\n+      UI_Scale := Uint_0;\n+   else\n+      UI_Scale := UI_From_Int (Scale);\n+   end if;\n+\n+   if Source (Scan_Ptr) = 'e' or else Source (Scan_Ptr) = 'E' then\n+      Accumulate_Checksum ('e');\n+      Scan_Ptr := Scan_Ptr + 1;\n+      Exponent_Is_Negative := False;\n+\n+      if Source (Scan_Ptr) = '+' then\n+         Accumulate_Checksum ('+');\n+         Scan_Ptr := Scan_Ptr + 1;\n+\n+      elsif Source (Scan_Ptr) = '-' then\n+         Accumulate_Checksum ('-');\n+\n+         if not Point_Scanned then\n+            Error_Msg_S (\"negative exponent not allowed for integer literal\");\n+         else\n+            Exponent_Is_Negative := True;\n+         end if;\n+\n+         Scan_Ptr := Scan_Ptr + 1;\n+      end if;\n+\n+      UI_Int_Value := Uint_0;\n+\n+      if Source (Scan_Ptr) in '0' .. '9' then\n+         Scan_Integer;\n+      else\n+         Error_Digit_Expected;\n+      end if;\n+\n+      if Exponent_Is_Negative then\n+         UI_Scale := UI_Scale - UI_Int_Value;\n+      else\n+         UI_Scale := UI_Scale + UI_Int_Value;\n+      end if;\n+   end if;\n+\n+   --  Case of real literal to be returned\n+\n+   if Point_Scanned then\n+      Token := Tok_Real_Literal;\n+      Token_Node := New_Node (N_Real_Literal, Token_Ptr);\n+      Set_Realval (Token_Node,\n+        UR_From_Components (\n+          Num   => UI_Num_Value,\n+          Den   => -UI_Scale,\n+          Rbase => Base));\n+\n+   --  Case of integer literal to be returned\n+\n+   else\n+      Token := Tok_Integer_Literal;\n+      Token_Node := New_Node (N_Integer_Literal, Token_Ptr);\n+\n+      if UI_Scale = 0 then\n+         Set_Intval (Token_Node, UI_Num_Value);\n+\n+      --  Avoid doing possibly expensive calculations in cases like\n+      --  parsing 163E800_000# when semantics will not be done anyway.\n+      --  This is especially useful when parsing garbled input.\n+\n+      elsif Operating_Mode /= Check_Syntax\n+        and then (Errors_Detected = 0 or else Try_Semantics)\n+      then\n+         Set_Intval (Token_Node, UI_Num_Value * UI_Base ** UI_Scale);\n+\n+      else\n+         Set_Intval (Token_Node, No_Uint);\n+      end if;\n+\n+   end if;\n+\n+   return;\n+\n+end Nlit;"}, {"sha": "508d5c225ac2add655885cb80fae0c0dc6b789a2", "filename": "gcc/ada/scn-slit.adb", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn-slit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn-slit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn-slit.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,373 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S C N . S L I T                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.29 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Stringt; use Stringt;\n+\n+separate (Scn)\n+procedure Slit is\n+\n+   Delimiter : Character;\n+   --  Delimiter (first character of string)\n+\n+   C : Character;\n+   --  Current source program character\n+\n+   Code : Char_Code;\n+   --  Current character code value\n+\n+   Err : Boolean;\n+   --  Error flag for Scan_Wide call\n+\n+   String_Literal_Id : String_Id;\n+   --  Id for currently scanned string value\n+\n+   Wide_Character_Found : Boolean := False;\n+   --  Set True if wide character found\n+\n+   procedure Error_Bad_String_Char;\n+   --  Signal bad character in string/character literal. On entry Scan_Ptr\n+   --  points to the improper character encountered during the scan. Scan_Ptr\n+   --  is not modified, so it still points to the bad character on return.\n+\n+   procedure Error_Unterminated_String;\n+   --  Procedure called if a line terminator character is encountered during\n+   --  scanning a string, meaning that the string is not properly terminated.\n+\n+   procedure Set_String;\n+   --  Procedure used to distinguish between string and operator symbol.\n+   --  On entry the string has been scanned out, and its characters start\n+   --  at Token_Ptr and end one character before Scan_Ptr. On exit Token\n+   --  is set to Tok_String_Literal or Tok_Operator_Symbol as appropriate,\n+   --  and Token_Node is appropriately initialized. In addition, in the\n+   --  operator symbol case, Token_Name is appropriately set.\n+\n+   ---------------------------\n+   -- Error_Bad_String_Char --\n+   ---------------------------\n+\n+   procedure Error_Bad_String_Char is\n+      C : constant Character := Source (Scan_Ptr);\n+\n+   begin\n+      if C = HT then\n+         Error_Msg_S (\"horizontal tab not allowed in string\");\n+\n+      elsif C = VT or else C = FF then\n+         Error_Msg_S (\"format effector not allowed in string\");\n+\n+      elsif C in Upper_Half_Character then\n+         Error_Msg_S (\"(Ada 83) upper half character not allowed\");\n+\n+      else\n+         Error_Msg_S (\"control character not allowed in string\");\n+      end if;\n+   end Error_Bad_String_Char;\n+\n+   -------------------------------\n+   -- Error_Unterminated_String --\n+   -------------------------------\n+\n+   procedure Error_Unterminated_String is\n+   begin\n+      --  An interesting little refinement. Consider the following examples:\n+\n+      --     A := \"this is an unterminated string;\n+      --     A := \"this is an unterminated string &\n+      --     P(A, \"this is a parameter that didn't get terminated);\n+\n+      --  We fiddle a little to do slightly better placement in these cases\n+      --  also if there is white space at the end of the line we place the\n+      --  flag at the start of this white space, not at the end. Note that\n+      --  we only have to test for blanks, since tabs aren't allowed in\n+      --  strings in the first place and would have caused an error message.\n+\n+      --  Two more cases that we treat specially are:\n+\n+      --     A := \"this string uses the wrong terminator'\n+      --     A := \"this string uses the wrong terminator' &\n+\n+      --  In these cases we give a different error message as well\n+\n+      --  We actually reposition the scan pointer to the point where we\n+      --  place the flag in these cases, since it seems a better bet on\n+      --  the original intention.\n+\n+      while Source (Scan_Ptr - 1) = ' '\n+        or else Source (Scan_Ptr - 1) = '&'\n+      loop\n+         Scan_Ptr := Scan_Ptr - 1;\n+         Unstore_String_Char;\n+      end loop;\n+\n+      --  Check for case of incorrect string terminator, but single quote is\n+      --  not considered incorrect if the opening terminator misused a single\n+      --  quote (error message already given).\n+\n+      if Delimiter /= '''\n+        and then Source (Scan_Ptr - 1) = '''\n+      then\n+         Unstore_String_Char;\n+         Error_Msg (\"incorrect string terminator character\", Scan_Ptr - 1);\n+         return;\n+      end if;\n+\n+      if Source (Scan_Ptr - 1) = ';' then\n+         Scan_Ptr := Scan_Ptr - 1;\n+         Unstore_String_Char;\n+\n+         if Source (Scan_Ptr - 1) = ')' then\n+            Scan_Ptr := Scan_Ptr - 1;\n+            Unstore_String_Char;\n+         end if;\n+      end if;\n+\n+      Error_Msg_S (\"missing string quote\");\n+   end Error_Unterminated_String;\n+\n+   ----------------\n+   -- Set_String --\n+   ----------------\n+\n+   procedure Set_String is\n+      Slen : Int := Int (Scan_Ptr - Token_Ptr - 2);\n+      C1   : Character;\n+      C2   : Character;\n+      C3   : Character;\n+\n+   begin\n+      --  Token_Name is currently set to Error_Name. The following section of\n+      --  code resets Token_Name to the proper Name_Op_xx value if the string\n+      --  is a valid operator symbol, otherwise it is left set to Error_Name.\n+\n+      if Slen = 1 then\n+         C1 := Source (Token_Ptr + 1);\n+\n+         case C1 is\n+            when '=' =>\n+               Token_Name := Name_Op_Eq;\n+\n+            when '>' =>\n+               Token_Name := Name_Op_Gt;\n+\n+            when '<' =>\n+               Token_Name := Name_Op_Lt;\n+\n+            when '+' =>\n+               Token_Name := Name_Op_Add;\n+\n+            when '-' =>\n+               Token_Name := Name_Op_Subtract;\n+\n+            when '&' =>\n+               Token_Name := Name_Op_Concat;\n+\n+            when '*' =>\n+               Token_Name := Name_Op_Multiply;\n+\n+            when '/' =>\n+               Token_Name := Name_Op_Divide;\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+      elsif Slen = 2 then\n+         C1 := Source (Token_Ptr + 1);\n+         C2 := Source (Token_Ptr + 2);\n+\n+         if C1 = '*' and then C2 = '*' then\n+            Token_Name := Name_Op_Expon;\n+\n+         elsif C2 = '=' then\n+\n+            if C1 = '/' then\n+               Token_Name := Name_Op_Ne;\n+            elsif C1 = '<' then\n+               Token_Name := Name_Op_Le;\n+            elsif C1 = '>' then\n+               Token_Name := Name_Op_Ge;\n+            end if;\n+\n+         elsif (C1 = 'O' or else C1 = 'o') and then    -- OR\n+               (C2 = 'R' or else C2 = 'r')\n+         then\n+            Token_Name := Name_Op_Or;\n+         end if;\n+\n+      elsif Slen = 3 then\n+         C1 := Source (Token_Ptr + 1);\n+         C2 := Source (Token_Ptr + 2);\n+         C3 := Source (Token_Ptr + 3);\n+\n+         if (C1 = 'A' or else C1 = 'a') and then       -- AND\n+            (C2 = 'N' or else C2 = 'n') and then\n+            (C3 = 'D' or else C3 = 'd')\n+         then\n+            Token_Name := Name_Op_And;\n+\n+         elsif (C1 = 'A' or else C1 = 'a') and then    -- ABS\n+               (C2 = 'B' or else C2 = 'b') and then\n+               (C3 = 'S' or else C3 = 's')\n+         then\n+            Token_Name := Name_Op_Abs;\n+\n+         elsif (C1 = 'M' or else C1 = 'm') and then    -- MOD\n+               (C2 = 'O' or else C2 = 'o') and then\n+               (C3 = 'D' or else C3 = 'd')\n+         then\n+            Token_Name := Name_Op_Mod;\n+\n+         elsif (C1 = 'N' or else C1 = 'n') and then    -- NOT\n+               (C2 = 'O' or else C2 = 'o') and then\n+               (C3 = 'T' or else C3 = 't')\n+         then\n+            Token_Name := Name_Op_Not;\n+\n+         elsif (C1 = 'R' or else C1 = 'r') and then    -- REM\n+               (C2 = 'E' or else C2 = 'e') and then\n+               (C3 = 'M' or else C3 = 'm')\n+         then\n+            Token_Name := Name_Op_Rem;\n+\n+         elsif (C1 = 'X' or else C1 = 'x') and then    -- XOR\n+               (C2 = 'O' or else C2 = 'o') and then\n+               (C3 = 'R' or else C3 = 'r')\n+         then\n+            Token_Name := Name_Op_Xor;\n+         end if;\n+\n+      end if;\n+\n+      --  If it is an operator symbol, then Token_Name is set. If it is some\n+      --  other string value, then Token_Name still contains Error_Name.\n+\n+      if Token_Name = Error_Name then\n+         Token := Tok_String_Literal;\n+         Token_Node := New_Node (N_String_Literal, Token_Ptr);\n+         Set_Has_Wide_Character (Token_Node, Wide_Character_Found);\n+\n+      else\n+         Token := Tok_Operator_Symbol;\n+         Token_Node := New_Node (N_Operator_Symbol, Token_Ptr);\n+         Set_Chars (Token_Node, Token_Name);\n+      end if;\n+\n+      Set_Strval (Token_Node, String_Literal_Id);\n+\n+   end Set_String;\n+\n+----------\n+-- Slit --\n+----------\n+\n+begin\n+   --  On entry, Scan_Ptr points to the opening character of the string which\n+   --  is either a percent, double quote, or apostrophe (single quote). The\n+   --  latter case is an error detected by the character literal circuit.\n+\n+   Delimiter := Source (Scan_Ptr);\n+   Accumulate_Checksum (Delimiter);\n+   Start_String;\n+   Scan_Ptr := Scan_Ptr + 1;\n+\n+   --  Loop to scan out characters of string literal\n+\n+   loop\n+      C := Source (Scan_Ptr);\n+\n+      if C = Delimiter then\n+         Accumulate_Checksum (C);\n+         Scan_Ptr := Scan_Ptr + 1;\n+         exit when Source (Scan_Ptr) /= Delimiter;\n+         Code := Get_Char_Code (C);\n+         Accumulate_Checksum (C);\n+         Scan_Ptr := Scan_Ptr + 1;\n+\n+      else\n+         if C = '\"' and then Delimiter = '%' then\n+            Error_Msg_S (\"quote not allowed in percent delimited string\");\n+            Code := Get_Char_Code (C);\n+            Scan_Ptr := Scan_Ptr + 1;\n+\n+         elsif (C = ESC\n+                 and then\n+                Wide_Character_Encoding_Method in WC_ESC_Encoding_Method)\n+           or else\n+               (C in Upper_Half_Character\n+                 and then\n+                Upper_Half_Encoding)\n+           or else\n+               (C = '['\n+                 and then\n+                Source (Scan_Ptr + 1) = '\"'\n+                 and then\n+                Identifier_Char (Source (Scan_Ptr + 2)))\n+         then\n+            Scan_Wide (Source, Scan_Ptr, Code, Err);\n+            Accumulate_Checksum (Code);\n+\n+            if Err then\n+               Error_Illegal_Wide_Character;\n+               Code := Get_Char_Code (' ');\n+            end if;\n+\n+         else\n+            Accumulate_Checksum (C);\n+\n+            if C not in Graphic_Character then\n+               if C in Line_Terminator then\n+                  Error_Unterminated_String;\n+                  exit;\n+\n+               elsif C in Upper_Half_Character then\n+                  if Ada_83 then\n+                     Error_Bad_String_Char;\n+                  end if;\n+\n+               else\n+                  Error_Bad_String_Char;\n+               end if;\n+            end if;\n+\n+            Code := Get_Char_Code (C);\n+            Scan_Ptr := Scan_Ptr + 1;\n+         end if;\n+      end if;\n+\n+      Store_String_Char (Code);\n+\n+      if not In_Character_Range (Code) then\n+         Wide_Character_Found := True;\n+      end if;\n+   end loop;\n+\n+   String_Literal_Id := End_String;\n+   Set_String;\n+   return;\n+\n+end Slit;"}, {"sha": "146314db11758c2681c4a5c3cad3e7230ffea32b", "filename": "gcc/ada/scn.adb", "status": "added", "additions": 1570, "deletions": 0, "changes": 1570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1570 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  S C N                                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.111 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Csets;    use Csets;\n+with Errout;   use Errout;\n+with Hostparm; use Hostparm;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Scans;    use Scans;\n+with Sinput;   use Sinput;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Style;\n+with Widechar; use Widechar;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body Scn is\n+\n+   use ASCII;\n+   --  Make control characters visible\n+\n+   Used_As_Identifier : array (Token_Type) of Boolean;\n+   --  Flags set True if a given keyword is used as an identifier (used to\n+   --  make sure that we only post an error message for incorrect use of a\n+   --  keyword as an identifier once for a given keyword).\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Accumulate_Checksum (C : Character);\n+   pragma Inline (Accumulate_Checksum);\n+   --  This routine accumulates the checksum given character C. During the\n+   --  scanning of a source file, this routine is called with every character\n+   --  in the source, excluding blanks, and all control characters (except\n+   --  that ESC is included in the checksum). Upper case letters not in string\n+   --  literals are folded by the caller. See Sinput spec for the documentation\n+   --  of the checksum algorithm. Note: checksum values are only used if we\n+   --  generate code, so it is not necessary to worry about making the right\n+   --  sequence of calls in any error situation.\n+\n+   procedure Accumulate_Checksum (C : Char_Code);\n+   pragma Inline (Accumulate_Checksum);\n+   --  This version is identical, except that the argument, C, is a character\n+   --  code value instead of a character. This is used when wide characters\n+   --  are scanned. We use the character code rather than the ASCII characters\n+   --  so that the checksum is independent of wide character encoding method.\n+\n+   procedure Check_End_Of_Line;\n+   --  Called when end of line encountered. Checks that line is not\n+   --  too long, and that other style checks for the end of line are met.\n+\n+   function Determine_License return License_Type;\n+   --  Scan header of file and check that it has an appropriate GNAT-style\n+   --  header with a proper license statement. Returns GPL, Unrestricted,\n+   --  or Modified_GPL depending on header. If none of these, returns Unknown.\n+\n+   function Double_Char_Token (C : Character) return Boolean;\n+   --  This function is used for double character tokens like := or <>. It\n+   --  checks if the character following Source (Scan_Ptr) is C, and if so\n+   --  bumps Scan_Ptr past the pair of characters and returns True. A space\n+   --  between the two characters is also recognized with an appropriate\n+   --  error message being issued. If C is not present, False is returned.\n+   --  Note that Double_Char_Token can only be used for tokens defined in\n+   --  the Ada syntax (it's use for error cases like && is not appropriate\n+   --  since we do not want a junk message for a case like &-space-&).\n+\n+   procedure Error_Illegal_Character;\n+   --  Give illegal character error, Scan_Ptr points to character. On return,\n+   --  Scan_Ptr is bumped past the illegal character.\n+\n+   procedure Error_Illegal_Wide_Character;\n+   --  Give illegal wide character message. On return, Scan_Ptr is bumped\n+   --  past the illegal character, which may still leave us pointing to\n+   --  junk, not much we can do if the escape sequence is messed up!\n+\n+   procedure Error_Long_Line;\n+   --  Signal error of excessively long line\n+\n+   procedure Error_No_Double_Underline;\n+   --  Signal error of double underline character\n+\n+   procedure Nlit;\n+   --  This is the procedure for scanning out numeric literals. On entry,\n+   --  Scan_Ptr points to the digit that starts the numeric literal (the\n+   --  checksum for this character has not been accumulated yet). On return\n+   --  Scan_Ptr points past the last character of the numeric literal, Token\n+   --  and Token_Node are set appropriately, and the checksum is updated.\n+\n+   function Set_Start_Column return Column_Number;\n+   --  This routine is called with Scan_Ptr pointing to the first character\n+   --  of a line. On exit, Scan_Ptr is advanced to the first non-blank\n+   --  character of this line (or to the terminating format effector if the\n+   --  line contains no non-blank characters), and the returned result is the\n+   --  column number of this non-blank character (zero origin), which is the\n+   --  value to be stored in the Start_Column scan variable.\n+\n+   procedure Slit;\n+   --  This is the procedure for scanning out string literals. On entry,\n+   --  Scan_Ptr points to the opening string quote (the checksum for this\n+   --  character has not been accumulated yet). On return Scan_Ptr points\n+   --  past the closing quote of the string literal, Token and Token_Node\n+   --  are set appropriately, and the checksum is upated.\n+\n+   -------------------------\n+   -- Accumulate_Checksum --\n+   -------------------------\n+\n+   procedure Accumulate_Checksum (C : Character) is\n+   begin\n+      Checksum := Checksum + Checksum + Character'Pos (C);\n+\n+      if Checksum > 16#8000_0000# then\n+         Checksum := (Checksum + 1) and 16#7FFF_FFFF#;\n+      end if;\n+   end Accumulate_Checksum;\n+\n+   procedure Accumulate_Checksum (C : Char_Code) is\n+   begin\n+      Checksum := Checksum + Checksum + Char_Code'Pos (C);\n+\n+      if Checksum > 16#8000_0000# then\n+         Checksum := (Checksum + 1) and 16#7FFF_FFFF#;\n+      end if;\n+   end Accumulate_Checksum;\n+\n+   -----------------------\n+   -- Check_End_Of_Line --\n+   -----------------------\n+\n+   procedure Check_End_Of_Line is\n+      Len : constant Int := Int (Scan_Ptr) - Int (Current_Line_Start);\n+\n+   begin\n+      if Len > Hostparm.Max_Line_Length then\n+         Error_Long_Line;\n+\n+      elsif Style_Check then\n+         Style.Check_Line_Terminator (Len);\n+      end if;\n+   end Check_End_Of_Line;\n+\n+   -----------------------\n+   -- Determine_License --\n+   -----------------------\n+\n+   function Determine_License return License_Type is\n+      GPL_Found : Boolean := False;\n+\n+      function Contains (S : String) return Boolean;\n+      --  See if current comment contains successive non-blank characters\n+      --  matching the contents of S. If so leave Scan_Ptr unchanged and\n+      --  return True, otherwise leave Scan_Ptr unchanged and return False.\n+\n+      procedure Skip_EOL;\n+      --  Skip to line terminator character\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (S : String) return Boolean is\n+         CP : Natural;\n+         SP : Source_Ptr;\n+         SS : Source_Ptr;\n+\n+      begin\n+         SP := Scan_Ptr;\n+         while Source (SP) /= CR and then Source (SP) /= LF loop\n+            if Source (SP) = S (S'First) then\n+               SS := SP;\n+               CP := S'First;\n+\n+               loop\n+                  SS := SS + 1;\n+                  CP := CP + 1;\n+\n+                  if CP > S'Last then\n+                     return True;\n+                  end if;\n+\n+                  while Source (SS) = ' ' loop\n+                     SS := SS + 1;\n+                  end loop;\n+\n+                  exit when Source (SS) /= S (CP);\n+               end loop;\n+            end if;\n+\n+            SP := SP + 1;\n+         end loop;\n+\n+         return False;\n+      end Contains;\n+\n+      --------------\n+      -- Skip_EOL --\n+      --------------\n+\n+      procedure Skip_EOL is\n+      begin\n+         while Source (Scan_Ptr) /= CR\n+           and then Source (Scan_Ptr) /= LF\n+         loop\n+            Scan_Ptr := Scan_Ptr + 1;\n+         end loop;\n+      end Skip_EOL;\n+\n+   --  Start of processing for Determine_License\n+\n+   begin\n+      loop\n+         if Source (Scan_Ptr) /= '-'\n+           or else Source (Scan_Ptr + 1) /= '-'\n+         then\n+            if GPL_Found then\n+               return GPL;\n+            else\n+               return Unknown;\n+            end if;\n+\n+         elsif Contains (\"Asaspecialexception\") then\n+            if GPL_Found then\n+               return Modified_GPL;\n+            end if;\n+\n+         elsif Contains (\"GNUGeneralPublicLicense\") then\n+            GPL_Found := True;\n+\n+         elsif\n+             Contains\n+               (\"ThisspecificationisadaptedfromtheAdaSemanticInterface\")\n+           or else\n+             Contains\n+              (\"ThisspecificationisderivedfromtheAdaReferenceManual\")\n+         then\n+            return Unrestricted;\n+         end if;\n+\n+         Skip_EOL;\n+\n+         Check_End_Of_Line;\n+\n+         declare\n+            Physical : Boolean;\n+\n+         begin\n+            Skip_Line_Terminators (Scan_Ptr, Physical);\n+\n+            --  If we are at start of physical line, update scan pointers\n+            --  to reflect the start of the new line.\n+\n+            if Physical then\n+               Current_Line_Start       := Scan_Ptr;\n+               Start_Column             := Set_Start_Column;\n+               First_Non_Blank_Location := Scan_Ptr;\n+            end if;\n+         end;\n+      end loop;\n+   end Determine_License;\n+\n+   ----------------------------\n+   -- Determine_Token_Casing --\n+   ----------------------------\n+\n+   function Determine_Token_Casing return Casing_Type is\n+   begin\n+      return Determine_Casing (Source (Token_Ptr .. Scan_Ptr - 1));\n+   end Determine_Token_Casing;\n+\n+   -----------------------\n+   -- Double_Char_Token --\n+   -----------------------\n+\n+   function Double_Char_Token (C : Character) return Boolean is\n+   begin\n+      if Source (Scan_Ptr + 1) = C then\n+         Accumulate_Checksum (C);\n+         Scan_Ptr := Scan_Ptr + 2;\n+         return True;\n+\n+      elsif Source (Scan_Ptr + 1) = ' '\n+        and then Source (Scan_Ptr + 2) = C\n+      then\n+         Scan_Ptr := Scan_Ptr + 1;\n+         Error_Msg_S (\"no space allowed here\");\n+         Scan_Ptr := Scan_Ptr + 2;\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+   end Double_Char_Token;\n+\n+   -----------------------------\n+   -- Error_Illegal_Character --\n+   -----------------------------\n+\n+   procedure Error_Illegal_Character is\n+   begin\n+      Error_Msg_S (\"illegal character\");\n+      Scan_Ptr := Scan_Ptr + 1;\n+   end Error_Illegal_Character;\n+\n+   ----------------------------------\n+   -- Error_Illegal_Wide_Character --\n+   ----------------------------------\n+\n+   procedure Error_Illegal_Wide_Character is\n+   begin\n+      if OpenVMS then\n+         Error_Msg_S\n+           (\"illegal wide character, check \" &\n+            \"'/'W'I'D'E'_'C'H'A'R'A'C'T'E'R'_'E'N'C'O'D'I'N'G qualifer\");\n+      else\n+         Error_Msg_S\n+           (\"illegal wide character, check -gnatW switch\");\n+      end if;\n+\n+      Scan_Ptr := Scan_Ptr + 1;\n+   end Error_Illegal_Wide_Character;\n+\n+   ---------------------\n+   -- Error_Long_Line --\n+   ---------------------\n+\n+   procedure Error_Long_Line is\n+   begin\n+      Error_Msg\n+        (\"this line is too long\",\n+         Current_Line_Start + Hostparm.Max_Line_Length);\n+   end Error_Long_Line;\n+\n+   -------------------------------\n+   -- Error_No_Double_Underline --\n+   -------------------------------\n+\n+   procedure Error_No_Double_Underline is\n+   begin\n+      Error_Msg_S (\"two consecutive underlines not permitted\");\n+   end Error_No_Double_Underline;\n+\n+   ------------------------\n+   -- Initialize_Scanner --\n+   ------------------------\n+\n+   procedure Initialize_Scanner\n+     (Unit  : Unit_Number_Type;\n+      Index : Source_File_Index)\n+   is\n+      GNAT_Hedr : constant Text_Buffer (1 .. 78) := (others => '-');\n+\n+   begin\n+      --  Set up Token_Type values in Names Table entries for reserved keywords\n+      --  We use the Pos value of the Token_Type value. Note we are relying on\n+      --  the fact that Token_Type'Val (0) is not a reserved word!\n+\n+      Set_Name_Table_Byte (Name_Abort,      Token_Type'Pos (Tok_Abort));\n+      Set_Name_Table_Byte (Name_Abs,        Token_Type'Pos (Tok_Abs));\n+      Set_Name_Table_Byte (Name_Abstract,   Token_Type'Pos (Tok_Abstract));\n+      Set_Name_Table_Byte (Name_Accept,     Token_Type'Pos (Tok_Accept));\n+      Set_Name_Table_Byte (Name_Access,     Token_Type'Pos (Tok_Access));\n+      Set_Name_Table_Byte (Name_And,        Token_Type'Pos (Tok_And));\n+      Set_Name_Table_Byte (Name_Aliased,    Token_Type'Pos (Tok_Aliased));\n+      Set_Name_Table_Byte (Name_All,        Token_Type'Pos (Tok_All));\n+      Set_Name_Table_Byte (Name_Array,      Token_Type'Pos (Tok_Array));\n+      Set_Name_Table_Byte (Name_At,         Token_Type'Pos (Tok_At));\n+      Set_Name_Table_Byte (Name_Begin,      Token_Type'Pos (Tok_Begin));\n+      Set_Name_Table_Byte (Name_Body,       Token_Type'Pos (Tok_Body));\n+      Set_Name_Table_Byte (Name_Case,       Token_Type'Pos (Tok_Case));\n+      Set_Name_Table_Byte (Name_Constant,   Token_Type'Pos (Tok_Constant));\n+      Set_Name_Table_Byte (Name_Declare,    Token_Type'Pos (Tok_Declare));\n+      Set_Name_Table_Byte (Name_Delay,      Token_Type'Pos (Tok_Delay));\n+      Set_Name_Table_Byte (Name_Delta,      Token_Type'Pos (Tok_Delta));\n+      Set_Name_Table_Byte (Name_Digits,     Token_Type'Pos (Tok_Digits));\n+      Set_Name_Table_Byte (Name_Do,         Token_Type'Pos (Tok_Do));\n+      Set_Name_Table_Byte (Name_Else,       Token_Type'Pos (Tok_Else));\n+      Set_Name_Table_Byte (Name_Elsif,      Token_Type'Pos (Tok_Elsif));\n+      Set_Name_Table_Byte (Name_End,        Token_Type'Pos (Tok_End));\n+      Set_Name_Table_Byte (Name_Entry,      Token_Type'Pos (Tok_Entry));\n+      Set_Name_Table_Byte (Name_Exception,  Token_Type'Pos (Tok_Exception));\n+      Set_Name_Table_Byte (Name_Exit,       Token_Type'Pos (Tok_Exit));\n+      Set_Name_Table_Byte (Name_For,        Token_Type'Pos (Tok_For));\n+      Set_Name_Table_Byte (Name_Function,   Token_Type'Pos (Tok_Function));\n+      Set_Name_Table_Byte (Name_Generic,    Token_Type'Pos (Tok_Generic));\n+      Set_Name_Table_Byte (Name_Goto,       Token_Type'Pos (Tok_Goto));\n+      Set_Name_Table_Byte (Name_If,         Token_Type'Pos (Tok_If));\n+      Set_Name_Table_Byte (Name_In,         Token_Type'Pos (Tok_In));\n+      Set_Name_Table_Byte (Name_Is,         Token_Type'Pos (Tok_Is));\n+      Set_Name_Table_Byte (Name_Limited,    Token_Type'Pos (Tok_Limited));\n+      Set_Name_Table_Byte (Name_Loop,       Token_Type'Pos (Tok_Loop));\n+      Set_Name_Table_Byte (Name_Mod,        Token_Type'Pos (Tok_Mod));\n+      Set_Name_Table_Byte (Name_New,        Token_Type'Pos (Tok_New));\n+      Set_Name_Table_Byte (Name_Not,        Token_Type'Pos (Tok_Not));\n+      Set_Name_Table_Byte (Name_Null,       Token_Type'Pos (Tok_Null));\n+      Set_Name_Table_Byte (Name_Of,         Token_Type'Pos (Tok_Of));\n+      Set_Name_Table_Byte (Name_Or,         Token_Type'Pos (Tok_Or));\n+      Set_Name_Table_Byte (Name_Others,     Token_Type'Pos (Tok_Others));\n+      Set_Name_Table_Byte (Name_Out,        Token_Type'Pos (Tok_Out));\n+      Set_Name_Table_Byte (Name_Package,    Token_Type'Pos (Tok_Package));\n+      Set_Name_Table_Byte (Name_Pragma,     Token_Type'Pos (Tok_Pragma));\n+      Set_Name_Table_Byte (Name_Private,    Token_Type'Pos (Tok_Private));\n+      Set_Name_Table_Byte (Name_Procedure,  Token_Type'Pos (Tok_Procedure));\n+      Set_Name_Table_Byte (Name_Protected,  Token_Type'Pos (Tok_Protected));\n+      Set_Name_Table_Byte (Name_Raise,      Token_Type'Pos (Tok_Raise));\n+      Set_Name_Table_Byte (Name_Range,      Token_Type'Pos (Tok_Range));\n+      Set_Name_Table_Byte (Name_Record,     Token_Type'Pos (Tok_Record));\n+      Set_Name_Table_Byte (Name_Rem,        Token_Type'Pos (Tok_Rem));\n+      Set_Name_Table_Byte (Name_Renames,    Token_Type'Pos (Tok_Renames));\n+      Set_Name_Table_Byte (Name_Requeue,    Token_Type'Pos (Tok_Requeue));\n+      Set_Name_Table_Byte (Name_Return,     Token_Type'Pos (Tok_Return));\n+      Set_Name_Table_Byte (Name_Reverse,    Token_Type'Pos (Tok_Reverse));\n+      Set_Name_Table_Byte (Name_Select,     Token_Type'Pos (Tok_Select));\n+      Set_Name_Table_Byte (Name_Separate,   Token_Type'Pos (Tok_Separate));\n+      Set_Name_Table_Byte (Name_Subtype,    Token_Type'Pos (Tok_Subtype));\n+      Set_Name_Table_Byte (Name_Tagged,     Token_Type'Pos (Tok_Tagged));\n+      Set_Name_Table_Byte (Name_Task,       Token_Type'Pos (Tok_Task));\n+      Set_Name_Table_Byte (Name_Terminate,  Token_Type'Pos (Tok_Terminate));\n+      Set_Name_Table_Byte (Name_Then,       Token_Type'Pos (Tok_Then));\n+      Set_Name_Table_Byte (Name_Type,       Token_Type'Pos (Tok_Type));\n+      Set_Name_Table_Byte (Name_Until,      Token_Type'Pos (Tok_Until));\n+      Set_Name_Table_Byte (Name_Use,        Token_Type'Pos (Tok_Use));\n+      Set_Name_Table_Byte (Name_When,       Token_Type'Pos (Tok_When));\n+      Set_Name_Table_Byte (Name_While,      Token_Type'Pos (Tok_While));\n+      Set_Name_Table_Byte (Name_With,       Token_Type'Pos (Tok_With));\n+      Set_Name_Table_Byte (Name_Xor,        Token_Type'Pos (Tok_Xor));\n+\n+      --  Initialize scan control variables\n+\n+      Current_Source_File       := Index;\n+      Source                    := Source_Text (Current_Source_File);\n+      Current_Source_Unit       := Unit;\n+      Scan_Ptr                  := Source_First (Current_Source_File);\n+      Token                     := No_Token;\n+      Token_Ptr                 := Scan_Ptr;\n+      Current_Line_Start        := Scan_Ptr;\n+      Token_Node                := Empty;\n+      Token_Name                := No_Name;\n+      Start_Column              := Set_Start_Column;\n+      First_Non_Blank_Location  := Scan_Ptr;\n+      Checksum                  := 0;\n+\n+      --  Set default for Comes_From_Source. All nodes built now until we\n+      --  reenter the analyzer will have Comes_From_Source set to True\n+\n+      Set_Comes_From_Source_Default (True);\n+\n+      --  Check license if GNAT type header possibly present\n+\n+      if Source_Last (Index) - Scan_Ptr > 80\n+        and then Source (Scan_Ptr .. Scan_Ptr + 77) = GNAT_Hedr\n+      then\n+         Set_License (Current_Source_File, Determine_License);\n+      end if;\n+\n+      --  Scan initial token (note this initializes Prev_Token, Prev_Token_Ptr)\n+\n+      Scan;\n+\n+      --  Clear flags for reserved words used as indentifiers\n+\n+      for J in Token_Type loop\n+         Used_As_Identifier (J) := False;\n+      end loop;\n+\n+   end Initialize_Scanner;\n+\n+   ----------\n+   -- Nlit --\n+   ----------\n+\n+   procedure Nlit is separate;\n+\n+   ----------\n+   -- Scan --\n+   ----------\n+\n+   procedure Scan is\n+   begin\n+      Prev_Token := Token;\n+      Prev_Token_Ptr := Token_Ptr;\n+      Token_Name := Error_Name;\n+\n+      --  The following loop runs more than once only if a format effector\n+      --  (tab, vertical tab, form  feed, line feed, carriage return) is\n+      --  encountered and skipped, or some error situation, such as an\n+      --  illegal character, is encountered.\n+\n+      loop\n+         --  Skip past blanks, loop is opened up for speed\n+\n+         while Source (Scan_Ptr) = ' ' loop\n+\n+            if Source (Scan_Ptr + 1) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 1;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 2) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 2;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 3) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 3;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 4) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 4;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 5) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 5;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 6) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 6;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 7) /= ' ' then\n+               Scan_Ptr := Scan_Ptr + 7;\n+               exit;\n+            end if;\n+\n+            Scan_Ptr := Scan_Ptr + 8;\n+         end loop;\n+\n+         --  We are now at a non-blank character, which is the first character\n+         --  of the token we will scan, and hence the value of Token_Ptr.\n+\n+         Token_Ptr := Scan_Ptr;\n+\n+         --  Here begins the main case statement which transfers control on\n+         --  the basis of the non-blank character we have encountered.\n+\n+         case Source (Scan_Ptr) is\n+\n+         --  Line terminator characters\n+\n+         when CR | LF | FF | VT => Line_Terminator_Case : begin\n+\n+            --  Check line too long\n+\n+            Check_End_Of_Line;\n+\n+            declare\n+               Physical : Boolean;\n+\n+            begin\n+               Skip_Line_Terminators (Scan_Ptr, Physical);\n+\n+               --  If we are at start of physical line, update scan pointers\n+               --  to reflect the start of the new line.\n+\n+               if Physical then\n+                  Current_Line_Start       := Scan_Ptr;\n+                  Start_Column             := Set_Start_Column;\n+                  First_Non_Blank_Location := Scan_Ptr;\n+               end if;\n+            end;\n+         end Line_Terminator_Case;\n+\n+         --  Horizontal tab, just skip past it\n+\n+         when HT =>\n+            if Style_Check then Style.Check_HT; end if;\n+            Scan_Ptr := Scan_Ptr + 1;\n+\n+         --  End of file character, treated as an end of file only if it\n+         --  is the last character in the buffer, otherwise it is ignored.\n+\n+         when EOF =>\n+            if Scan_Ptr = Source_Last (Current_Source_File) then\n+               Check_End_Of_Line;\n+               Token := Tok_EOF;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+            end if;\n+\n+         --  Ampersand\n+\n+         when '&' =>\n+            Accumulate_Checksum ('&');\n+\n+            if Source (Scan_Ptr + 1) = '&' then\n+               Error_Msg_S (\"'&'& should be `AND THEN`\");\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Token := Tok_And;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Ampersand;\n+               return;\n+            end if;\n+\n+         --  Asterisk (can be multiplication operator or double asterisk\n+         --  which is the exponentiation compound delimtier).\n+\n+         when '*' =>\n+            Accumulate_Checksum ('*');\n+\n+            if Source (Scan_Ptr + 1) = '*' then\n+               Accumulate_Checksum ('*');\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Token := Tok_Double_Asterisk;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Asterisk;\n+               return;\n+            end if;\n+\n+         --  Colon, which can either be an isolated colon, or part of an\n+         --  assignment compound delimiter.\n+\n+         when ':' =>\n+            Accumulate_Checksum (':');\n+\n+            if Double_Char_Token ('=') then\n+               Token := Tok_Colon_Equal;\n+               if Style_Check then Style.Check_Colon_Equal; end if;\n+               return;\n+\n+            elsif Source (Scan_Ptr + 1) = '-'\n+              and then Source (Scan_Ptr + 2) /= '-'\n+            then\n+               Token := Tok_Colon_Equal;\n+               Error_Msg (\":- should be :=\", Scan_Ptr);\n+               Scan_Ptr := Scan_Ptr + 2;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Colon;\n+               if Style_Check then Style.Check_Colon; end if;\n+               return;\n+            end if;\n+\n+         --  Left parenthesis\n+\n+         when '(' =>\n+            Accumulate_Checksum ('(');\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Left_Paren;\n+            if Style_Check then Style.Check_Left_Paren; end if;\n+            return;\n+\n+         --  Left bracket\n+\n+         when '[' =>\n+            if Source (Scan_Ptr + 1) = '\"' then\n+               Name_Len := 0;\n+               goto Scan_Identifier;\n+\n+            else\n+               Error_Msg_S (\"illegal character, replaced by \"\"(\"\"\");\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Left_Paren;\n+               return;\n+            end if;\n+\n+         --  Left brace\n+\n+         when '{' =>\n+            Error_Msg_S (\"illegal character, replaced by \"\"(\"\"\");\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Left_Paren;\n+            return;\n+\n+         --  Comma\n+\n+         when ',' =>\n+            Accumulate_Checksum (',');\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Comma;\n+            if Style_Check then Style.Check_Comma; end if;\n+            return;\n+\n+         --  Dot, which is either an isolated period, or part of a double\n+         --  dot compound delimiter sequence. We also check for the case of\n+         --  a digit following the period, to give a better error message.\n+\n+         when '.' =>\n+            Accumulate_Checksum ('.');\n+\n+            if Double_Char_Token ('.') then\n+               Token := Tok_Dot_Dot;\n+               if Style_Check then Style.Check_Dot_Dot; end if;\n+               return;\n+\n+            elsif Source (Scan_Ptr + 1) in '0' .. '9' then\n+               Error_Msg_S (\"numeric literal cannot start with point\");\n+               Scan_Ptr := Scan_Ptr + 1;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Dot;\n+               return;\n+            end if;\n+\n+         --  Equal, which can either be an equality operator, or part of the\n+         --  arrow (=>) compound delimiter.\n+\n+         when '=' =>\n+            Accumulate_Checksum ('=');\n+\n+            if Double_Char_Token ('>') then\n+               Token := Tok_Arrow;\n+               if Style_Check then Style.Check_Arrow; end if;\n+               return;\n+\n+            elsif Source (Scan_Ptr + 1) = '=' then\n+               Error_Msg_S (\"== should be =\");\n+               Scan_Ptr := Scan_Ptr + 1;\n+            end if;\n+\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Equal;\n+            return;\n+\n+         --  Greater than, which can be a greater than operator, greater than\n+         --  or equal operator, or first character of a right label bracket.\n+\n+         when '>' =>\n+            Accumulate_Checksum ('>');\n+\n+            if Double_Char_Token ('=') then\n+               Token := Tok_Greater_Equal;\n+               return;\n+\n+            elsif Double_Char_Token ('>') then\n+               Token := Tok_Greater_Greater;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Greater;\n+               return;\n+            end if;\n+\n+         --  Less than, which can be a less than operator, less than or equal\n+         --  operator, or the first character of a left label bracket, or the\n+         --  first character of a box (<>) compound delimiter.\n+\n+         when '<' =>\n+            Accumulate_Checksum ('<');\n+\n+            if Double_Char_Token ('=') then\n+               Token := Tok_Less_Equal;\n+               return;\n+\n+            elsif Double_Char_Token ('>') then\n+               Token := Tok_Box;\n+               if Style_Check then Style.Check_Box; end if;\n+               return;\n+\n+            elsif Double_Char_Token ('<') then\n+               Token := Tok_Less_Less;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Less;\n+               return;\n+            end if;\n+\n+         --  Minus, which is either a subtraction operator, or the first\n+         --  character of double minus starting a comment\n+\n+         when '-' => Minus_Case : begin\n+            if Source (Scan_Ptr + 1) = '>' then\n+               Error_Msg_S (\"invalid token\");\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Token := Tok_Arrow;\n+               return;\n+\n+            elsif Source (Scan_Ptr + 1) /= '-' then\n+               Accumulate_Checksum ('-');\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Minus;\n+               return;\n+\n+            --  Comment\n+\n+            else -- Source (Scan_Ptr + 1) = '-' then\n+               if Style_Check then Style.Check_Comment; end if;\n+               Scan_Ptr := Scan_Ptr + 2;\n+\n+               --  Loop to scan comment (this loop runs more than once only if\n+               --  a horizontal tab or other non-graphic character is scanned)\n+\n+               loop\n+                  --  Scan to non graphic character (opened up for speed)\n+\n+                  loop\n+                     exit when Source (Scan_Ptr) not in Graphic_Character;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                     exit when Source (Scan_Ptr) not in Graphic_Character;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                     exit when Source (Scan_Ptr) not in Graphic_Character;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                     exit when Source (Scan_Ptr) not in Graphic_Character;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                     exit when Source (Scan_Ptr) not in Graphic_Character;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                  end loop;\n+\n+                  --  Keep going if horizontal tab\n+\n+                  if Source (Scan_Ptr) = HT then\n+                     if Style_Check then Style.Check_HT; end if;\n+                     Scan_Ptr := Scan_Ptr + 1;\n+\n+                  --  Terminate scan of comment if line terminator\n+\n+                  elsif Source (Scan_Ptr) in Line_Terminator then\n+                     exit;\n+\n+                  --  Terminate scan of comment if end of file encountered\n+                  --  (embedded EOF character or real last character in file)\n+\n+                  elsif Source (Scan_Ptr) = EOF then\n+                     exit;\n+\n+                  --  Keep going if character in 80-FF range, or is ESC. These\n+                  --  characters are allowed in comments by RM-2.1(1), 2.7(2).\n+                  --  They are allowed even in Ada 83 mode according to the\n+                  --  approved AI. ESC was added to the AI in June 93.\n+\n+                  elsif Source (Scan_Ptr) in Upper_Half_Character\n+                    or else Source (Scan_Ptr) = ESC\n+                  then\n+                     Scan_Ptr := Scan_Ptr + 1;\n+\n+                  --  Otherwise we have an illegal comment character\n+\n+                  else\n+                     Error_Illegal_Character;\n+                  end if;\n+\n+               end loop;\n+\n+               --  Note that we do NOT execute a return here, instead we fall\n+               --  through to reexecute the scan loop to look for a token.\n+\n+            end if;\n+         end Minus_Case;\n+\n+         --  Double quote or percent starting a string literal\n+\n+         when '\"' | '%' =>\n+            Slit;\n+            return;\n+\n+         --  Apostrophe. This can either be the start of a character literal,\n+         --  or an isolated apostrophe used in a qualified expression or an\n+         --  attribute. We treat it as a character literal if it does not\n+         --  follow a right parenthesis, identifier, the keyword ALL or\n+         --  a literal. This means that we correctly treat constructs like:\n+\n+         --    A := CHARACTER'('A');\n+\n+         --  Note that RM-2.2(7) does not require a separator between\n+         --  \"CHARACTER\" and \"'\" in the above.\n+\n+         when ''' => Char_Literal_Case : declare\n+            Code : Char_Code;\n+            Err  : Boolean;\n+\n+         begin\n+            Accumulate_Checksum (''');\n+            Scan_Ptr := Scan_Ptr + 1;\n+\n+            --  Here is where we make the test to distinguish the cases. Treat\n+            --  as apostrophe if previous token is an identifier, right paren\n+            --  or the reserved word \"all\" (latter case as in A.all'Address)\n+            --  Also treat it as apostrophe after a literal (this catches\n+            --  some legitimate cases, like A.\"abs\"'Address, and also gives\n+            --  better error behavior for impossible cases like 123'xxx).\n+\n+            if Prev_Token = Tok_Identifier\n+               or else Prev_Token = Tok_Right_Paren\n+               or else Prev_Token = Tok_All\n+               or else Prev_Token in Token_Class_Literal\n+            then\n+               Token := Tok_Apostrophe;\n+               return;\n+\n+            --  Otherwise the apostrophe starts a character literal\n+\n+            else\n+               --  Case of wide character literal with ESC or [ encoding\n+\n+               if (Source (Scan_Ptr) = ESC\n+                     and then\n+                    Wide_Character_Encoding_Method in WC_ESC_Encoding_Method)\n+                 or else\n+                   (Source (Scan_Ptr) in Upper_Half_Character\n+                     and then\n+                    Upper_Half_Encoding)\n+                 or else\n+                   (Source (Scan_Ptr) = '['\n+                     and then\n+                    Source (Scan_Ptr + 1) = '\"')\n+               then\n+                  Scan_Wide (Source, Scan_Ptr, Code, Err);\n+                  Accumulate_Checksum (Code);\n+\n+                  if Err then\n+                     Error_Illegal_Wide_Character;\n+                  end if;\n+\n+                  if Source (Scan_Ptr) /= ''' then\n+                     Error_Msg_S (\"missing apostrophe\");\n+                  else\n+                     Scan_Ptr := Scan_Ptr + 1;\n+                  end if;\n+\n+               --  If we do not find a closing quote in the expected place then\n+               --  assume that we have a misguided attempt at a string literal.\n+\n+               --  However, if previous token is RANGE, then we return an\n+               --  apostrophe instead since this gives better error recovery\n+\n+               elsif Source (Scan_Ptr + 1) /= ''' then\n+\n+                  if Prev_Token = Tok_Range then\n+                     Token := Tok_Apostrophe;\n+                     return;\n+\n+                  else\n+                     Scan_Ptr := Scan_Ptr - 1;\n+                     Error_Msg_S\n+                       (\"strings are delimited by double quote character\");\n+                     Scn.Slit;\n+                     return;\n+                  end if;\n+\n+               --  Otherwise we have a (non-wide) character literal\n+\n+               else\n+                  Accumulate_Checksum (Source (Scan_Ptr));\n+\n+                  if Source (Scan_Ptr) not in Graphic_Character then\n+                     if Source (Scan_Ptr) in Upper_Half_Character then\n+                        if Ada_83 then\n+                           Error_Illegal_Character;\n+                        end if;\n+\n+                     else\n+                        Error_Illegal_Character;\n+                     end if;\n+                  end if;\n+\n+                  Code := Get_Char_Code (Source (Scan_Ptr));\n+                  Scan_Ptr := Scan_Ptr + 2;\n+               end if;\n+\n+               --  Fall through here with Scan_Ptr updated past the closing\n+               --  quote, and Code set to the Char_Code value for the literal\n+\n+               Accumulate_Checksum (''');\n+               Token := Tok_Char_Literal;\n+               Token_Node := New_Node (N_Character_Literal, Token_Ptr);\n+               Set_Char_Literal_Value (Token_Node, Code);\n+               Set_Character_Literal_Name (Code);\n+               Token_Name := Name_Find;\n+               Set_Chars (Token_Node, Token_Name);\n+               return;\n+            end if;\n+         end Char_Literal_Case;\n+\n+         --  Right parenthesis\n+\n+         when ')' =>\n+            Accumulate_Checksum (')');\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Right_Paren;\n+            if Style_Check then Style.Check_Right_Paren; end if;\n+            return;\n+\n+         --  Right bracket or right brace, treated as right paren\n+\n+         when ']' | '}' =>\n+            Error_Msg_S (\"illegal character, replaced by \"\")\"\"\");\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Right_Paren;\n+            return;\n+\n+         --  Slash (can be division operator or first character of not equal)\n+\n+         when '/' =>\n+            Accumulate_Checksum ('/');\n+\n+            if Double_Char_Token ('=') then\n+               Token := Tok_Not_Equal;\n+               return;\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Slash;\n+               return;\n+            end if;\n+\n+         --  Semicolon\n+\n+         when ';' =>\n+            Accumulate_Checksum (';');\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Semicolon;\n+            if Style_Check then Style.Check_Semicolon; end if;\n+            return;\n+\n+         --  Vertical bar\n+\n+         when '|' => Vertical_Bar_Case : begin\n+            Accumulate_Checksum ('|');\n+\n+            --  Special check for || to give nice message\n+\n+            if Source (Scan_Ptr + 1) = '|' then\n+               Error_Msg_S (\"\"\"||\"\" should be `OR ELSE`\");\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Token := Tok_Or;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Vertical_Bar;\n+               if Style_Check then Style.Check_Vertical_Bar; end if;\n+               return;\n+            end if;\n+         end Vertical_Bar_Case;\n+\n+         --  Exclamation, replacement character for vertical bar\n+\n+         when '!' => Exclamation_Case : begin\n+            Accumulate_Checksum ('!');\n+\n+            if Source (Scan_Ptr + 1) = '=' then\n+               Error_Msg_S (\"'!= should be /=\");\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Token := Tok_Not_Equal;\n+               return;\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Vertical_Bar;\n+               return;\n+            end if;\n+\n+         end Exclamation_Case;\n+\n+         --  Plus\n+\n+         when '+' => Plus_Case : begin\n+            Accumulate_Checksum ('+');\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Token := Tok_Plus;\n+            return;\n+         end Plus_Case;\n+\n+         --  Digits starting a numeric literal\n+\n+         when '0' .. '9' =>\n+            Nlit;\n+\n+            if Identifier_Char (Source (Scan_Ptr)) then\n+               Error_Msg_S\n+                 (\"delimiter required between literal and identifier\");\n+            end if;\n+\n+            return;\n+\n+         --  Lower case letters\n+\n+         when 'a' .. 'z' =>\n+            Name_Len := 1;\n+            Name_Buffer (1) := Source (Scan_Ptr);\n+            Accumulate_Checksum (Name_Buffer (1));\n+            Scan_Ptr := Scan_Ptr + 1;\n+            goto Scan_Identifier;\n+\n+         --  Upper case letters\n+\n+         when 'A' .. 'Z' =>\n+            Name_Len := 1;\n+            Name_Buffer (1) :=\n+              Character'Val (Character'Pos (Source (Scan_Ptr)) + 32);\n+            Accumulate_Checksum (Name_Buffer (1));\n+            Scan_Ptr := Scan_Ptr + 1;\n+            goto Scan_Identifier;\n+\n+         --  Underline character\n+\n+         when '_' =>\n+            Error_Msg_S (\"identifier cannot start with underline\");\n+            Name_Len := 1;\n+            Name_Buffer (1) := '_';\n+            Scan_Ptr := Scan_Ptr + 1;\n+            goto Scan_Identifier;\n+\n+         --  Space (not possible, because we scanned past blanks)\n+\n+         when ' ' =>\n+            raise Program_Error;\n+\n+         --  Characters in top half of ASCII 8-bit chart\n+\n+         when Upper_Half_Character =>\n+\n+            --  Wide character case. Note that Scan_Identifier will issue\n+            --  an appropriate message if wide characters are not allowed\n+            --  in identifiers.\n+\n+            if Upper_Half_Encoding then\n+               Name_Len := 0;\n+               goto Scan_Identifier;\n+\n+            --  Otherwise we have OK Latin-1 character\n+\n+            else\n+               --  Upper half characters may possibly be identifier letters\n+               --  but can never be digits, so Identifier_Character can be\n+               --  used to test for a valid start of identifier character.\n+\n+               if Identifier_Char (Source (Scan_Ptr)) then\n+                  Name_Len := 0;\n+                  goto Scan_Identifier;\n+               else\n+                  Error_Illegal_Character;\n+               end if;\n+            end if;\n+\n+         when ESC =>\n+\n+            --  ESC character, possible start of identifier if wide characters\n+            --  using ESC encoding are allowed in identifiers, which we can\n+            --  tell by looking at the Identifier_Char flag for ESC, which is\n+            --  only true if these conditions are met.\n+\n+            if Identifier_Char (ESC) then\n+               Name_Len := 0;\n+               goto Scan_Identifier;\n+            else\n+               Error_Illegal_Wide_Character;\n+            end if;\n+\n+         --  Invalid control characters\n+\n+         when NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS  | SO  |\n+              SI  | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN |\n+              EM  | FS  | GS  | RS  | US  | DEL\n+         =>\n+            Error_Illegal_Character;\n+\n+         --  Invalid graphic characters\n+\n+         when '#' | '$' | '?' | '@' | '`' | '\\' | '^' | '~' =>\n+            Error_Illegal_Character;\n+\n+         --  End switch on non-blank character\n+\n+         end case;\n+\n+      --  End loop past format effectors. The exit from this loop is by\n+      --  executing a return statement following completion of token scan\n+      --  (control never falls out of this loop to the code which follows)\n+\n+      end loop;\n+\n+      --  Identifier scanning routine. On entry, some initial characters\n+      --  of the identifier may have already been stored in Name_Buffer.\n+      --  If so, Name_Len has the number of characters stored. otherwise\n+      --  Name_Len is set to zero on entry.\n+\n+      <<Scan_Identifier>>\n+\n+         --  This loop scans as fast as possible past lower half letters\n+         --  and digits, which we expect to be the most common characters.\n+\n+         loop\n+            if Source (Scan_Ptr) in 'a' .. 'z'\n+              or else Source (Scan_Ptr) in '0' .. '9'\n+            then\n+               Name_Buffer (Name_Len + 1) := Source (Scan_Ptr);\n+               Accumulate_Checksum (Source (Scan_Ptr));\n+\n+            elsif Source (Scan_Ptr) in 'A' .. 'Z' then\n+               Name_Buffer (Name_Len + 1) :=\n+                 Character'Val (Character'Pos (Source (Scan_Ptr)) + 32);\n+               Accumulate_Checksum (Name_Buffer (Name_Len + 1));\n+            else\n+               exit;\n+            end if;\n+\n+            --  Open out the loop a couple of times for speed\n+\n+            if Source (Scan_Ptr + 1) in 'a' .. 'z'\n+              or else Source (Scan_Ptr + 1) in '0' .. '9'\n+            then\n+               Name_Buffer (Name_Len + 2) := Source (Scan_Ptr + 1);\n+               Accumulate_Checksum (Source (Scan_Ptr + 1));\n+\n+            elsif Source (Scan_Ptr + 1) in 'A' .. 'Z' then\n+               Name_Buffer (Name_Len + 2) :=\n+                 Character'Val (Character'Pos (Source (Scan_Ptr + 1)) + 32);\n+               Accumulate_Checksum (Name_Buffer (Name_Len + 2));\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Name_Len := Name_Len + 1;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 2) in 'a' .. 'z'\n+              or else Source (Scan_Ptr + 2) in '0' .. '9'\n+            then\n+               Name_Buffer (Name_Len + 3) := Source (Scan_Ptr + 2);\n+               Accumulate_Checksum (Source (Scan_Ptr + 2));\n+\n+            elsif Source (Scan_Ptr + 2) in 'A' .. 'Z' then\n+               Name_Buffer (Name_Len + 3) :=\n+                 Character'Val (Character'Pos (Source (Scan_Ptr + 2)) + 32);\n+               Accumulate_Checksum (Name_Buffer (Name_Len + 3));\n+            else\n+               Scan_Ptr := Scan_Ptr + 2;\n+               Name_Len := Name_Len + 2;\n+               exit;\n+            end if;\n+\n+            if Source (Scan_Ptr + 3) in 'a' .. 'z'\n+              or else Source (Scan_Ptr + 3) in '0' .. '9'\n+            then\n+               Name_Buffer (Name_Len + 4) := Source (Scan_Ptr + 3);\n+               Accumulate_Checksum (Source (Scan_Ptr + 3));\n+\n+            elsif Source (Scan_Ptr + 3) in 'A' .. 'Z' then\n+               Name_Buffer (Name_Len + 4) :=\n+                 Character'Val (Character'Pos (Source (Scan_Ptr + 3)) + 32);\n+               Accumulate_Checksum (Name_Buffer (Name_Len + 4));\n+\n+            else\n+               Scan_Ptr := Scan_Ptr + 3;\n+               Name_Len := Name_Len + 3;\n+               exit;\n+            end if;\n+\n+            Scan_Ptr := Scan_Ptr + 4;\n+            Name_Len := Name_Len + 4;\n+         end loop;\n+\n+         --  If we fall through, then we have encountered either an underline\n+         --  character, or an extended identifier character (i.e. one from the\n+         --  upper half), or a wide character, or an identifier terminator.\n+         --  The initial test speeds us up in the most common case where we\n+         --  have an identifier terminator. Note that ESC is an identifier\n+         --  character only if a wide character encoding method that uses\n+         --  ESC encoding is active, so if we find an ESC character we know\n+         --  that we have a wide character.\n+\n+         if Identifier_Char (Source (Scan_Ptr)) then\n+\n+            --  Case of underline, check for error cases of double underline,\n+            --  and for a trailing underline character\n+\n+            if Source (Scan_Ptr) = '_' then\n+               Accumulate_Checksum ('_');\n+               Name_Len := Name_Len + 1;\n+               Name_Buffer (Name_Len) := '_';\n+\n+               if Identifier_Char (Source (Scan_Ptr + 1)) then\n+                  Scan_Ptr := Scan_Ptr + 1;\n+\n+                  if Source (Scan_Ptr) = '_' then\n+                     Error_No_Double_Underline;\n+                  end if;\n+\n+               else\n+                  Error_Msg_S (\"identifier cannot end with underline\");\n+                  Scan_Ptr := Scan_Ptr + 1;\n+               end if;\n+\n+               goto Scan_Identifier;\n+\n+            --  Upper half character\n+\n+            elsif Source (Scan_Ptr) in Upper_Half_Character\n+              and then not Upper_Half_Encoding\n+            then\n+               Accumulate_Checksum (Source (Scan_Ptr));\n+               Store_Encoded_Character\n+                 (Get_Char_Code (Fold_Lower (Source (Scan_Ptr))));\n+               Scan_Ptr := Scan_Ptr + 1;\n+               goto Scan_Identifier;\n+\n+            --  Left bracket not followed by a quote terminates an identifier.\n+            --  This is an error, but we don't want to give a junk error msg\n+            --  about wide characters in this case!\n+\n+            elsif Source (Scan_Ptr) = '['\n+              and then Source (Scan_Ptr + 1) /= '\"'\n+            then\n+               null;\n+\n+            --  We know we have a wide character encoding here (the current\n+            --  character is either ESC, left bracket, or an upper half\n+            --  character depending on the encoding method).\n+\n+            else\n+               --  Scan out the wide character and insert the appropriate\n+               --  encoding into the name table entry for the identifier.\n+\n+               declare\n+                  Sptr : constant Source_Ptr := Scan_Ptr;\n+                  Code : Char_Code;\n+                  Err  : Boolean;\n+\n+               begin\n+                  Scan_Wide (Source, Scan_Ptr, Code, Err);\n+                  Accumulate_Checksum (Code);\n+\n+                  if Err then\n+                     Error_Illegal_Wide_Character;\n+                  else\n+                     Store_Encoded_Character (Code);\n+                  end if;\n+\n+                  --  Make sure we are allowing wide characters in identifiers.\n+                  --  Note that we allow wide character notation for an OK\n+                  --  identifier character. This in particular allows bracket\n+                  --  or other notation to be used for upper half letters.\n+\n+                  if Identifier_Character_Set /= 'w'\n+                    and then\n+                      (not In_Character_Range (Code)\n+                         or else\n+                       not Identifier_Char (Get_Character (Code)))\n+                  then\n+                     Error_Msg\n+                       (\"wide character not allowed in identifier\", Sptr);\n+                  end if;\n+               end;\n+\n+               goto Scan_Identifier;\n+            end if;\n+         end if;\n+\n+         --  Scan of identifier is complete. The identifier is stored in\n+         --  Name_Buffer, and Scan_Ptr points past the last character.\n+\n+         Token_Name := Name_Find;\n+\n+         --  Here is where we check if it was a keyword\n+\n+         if Get_Name_Table_Byte (Token_Name) /= 0\n+           and then (Ada_95 or else Token_Name not in Ada_95_Reserved_Words)\n+         then\n+            Token := Token_Type'Val (Get_Name_Table_Byte (Token_Name));\n+\n+            --  Deal with possible style check for non-lower case keyword,\n+            --  but we don't treat ACCESS, DELTA, DIGITS, RANGE as keywords\n+            --  for this purpose if they appear as attribute designators.\n+            --  Actually we only check the first character for speed.\n+\n+            if Style_Check\n+              and then Source (Token_Ptr) <= 'Z'\n+              and then (Prev_Token /= Tok_Apostrophe\n+                          or else\n+                            (Token /= Tok_Access\n+                               and then Token /= Tok_Delta\n+                               and then Token /= Tok_Digits\n+                               and then Token /= Tok_Range))\n+            then\n+               Style.Non_Lower_Case_Keyword;\n+            end if;\n+\n+            --  We must reset Token_Name since this is not an identifier\n+            --  and if we leave Token_Name set, the parser gets confused\n+            --  because it thinks it is dealing with an identifier instead\n+            --  of the corresponding keyword.\n+\n+            Token_Name := No_Name;\n+            return;\n+\n+         --  It is an identifier after all\n+\n+         else\n+            Token_Node := New_Node (N_Identifier, Token_Ptr);\n+            Set_Chars (Token_Node, Token_Name);\n+            Token := Tok_Identifier;\n+            return;\n+         end if;\n+   end Scan;\n+\n+   ---------------------\n+   -- Scan_First_Char --\n+   ---------------------\n+\n+   function Scan_First_Char return Source_Ptr is\n+      Ptr : Source_Ptr := Current_Line_Start;\n+\n+   begin\n+      loop\n+         if Source (Ptr) = ' ' then\n+            Ptr := Ptr + 1;\n+\n+         elsif Source (Ptr) = HT then\n+            if Style_Check then Style.Check_HT; end if;\n+            Ptr := Ptr + 1;\n+\n+         else\n+            return Ptr;\n+         end if;\n+      end loop;\n+   end Scan_First_Char;\n+\n+   ------------------------------\n+   -- Scan_Reserved_Identifier --\n+   ------------------------------\n+\n+   procedure Scan_Reserved_Identifier (Force_Msg : Boolean) is\n+      Token_Chars : constant String := Token_Type'Image (Token);\n+\n+   begin\n+      --  We have in Token_Chars the image of the Token name, i.e. Tok_xxx.\n+      --  This code extracts the xxx and makes an identifier out of it.\n+\n+      Name_Len := 0;\n+\n+      for J in 5 .. Token_Chars'Length loop\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := Fold_Lower (Token_Chars (J));\n+      end loop;\n+\n+      Token_Name := Name_Find;\n+\n+      if not Used_As_Identifier (Token) or else Force_Msg then\n+         Error_Msg_Name_1 := Token_Name;\n+         Error_Msg_SC (\"reserved word* cannot be used as identifier!\");\n+         Used_As_Identifier (Token) := True;\n+      end if;\n+\n+      Token := Tok_Identifier;\n+      Token_Node := New_Node (N_Identifier, Token_Ptr);\n+      Set_Chars (Token_Node, Token_Name);\n+   end Scan_Reserved_Identifier;\n+\n+   ----------------------\n+   -- Set_Start_Column --\n+   ----------------------\n+\n+   --  Note: it seems at first glance a little expensive to compute this value\n+   --  for every source line (since it is certainly not used for all source\n+   --  lines). On the other hand, it doesn't take much more work to skip past\n+   --  the initial white space on the line counting the columns than it would\n+   --  to scan past the white space using the standard scanning circuits.\n+\n+   function Set_Start_Column return Column_Number is\n+      Start_Column : Column_Number := 0;\n+\n+   begin\n+      --  Outer loop scans past horizontal tab characters\n+\n+      Tabs_Loop : loop\n+\n+         --  Inner loop scans past blanks as fast as possible, bumping Scan_Ptr\n+         --  past the blanks and adjusting Start_Column to account for them.\n+\n+         Blanks_Loop : loop\n+            if Source (Scan_Ptr) = ' ' then\n+               if Source (Scan_Ptr + 1) = ' ' then\n+                  if Source (Scan_Ptr + 2) = ' ' then\n+                     if Source (Scan_Ptr + 3) = ' ' then\n+                        if Source (Scan_Ptr + 4) = ' ' then\n+                           if Source (Scan_Ptr + 5) = ' ' then\n+                              if Source (Scan_Ptr + 6) = ' ' then\n+                                 Scan_Ptr := Scan_Ptr + 7;\n+                                 Start_Column := Start_Column + 7;\n+                              else\n+                                 Scan_Ptr := Scan_Ptr + 6;\n+                                 Start_Column := Start_Column + 6;\n+                                 exit Blanks_Loop;\n+                              end if;\n+                           else\n+                              Scan_Ptr := Scan_Ptr + 5;\n+                              Start_Column := Start_Column + 5;\n+                              exit Blanks_Loop;\n+                           end if;\n+                        else\n+                           Scan_Ptr := Scan_Ptr + 4;\n+                           Start_Column := Start_Column + 4;\n+                           exit Blanks_Loop;\n+                        end if;\n+                     else\n+                        Scan_Ptr := Scan_Ptr + 3;\n+                        Start_Column := Start_Column + 3;\n+                        exit Blanks_Loop;\n+                     end if;\n+                  else\n+                     Scan_Ptr := Scan_Ptr + 2;\n+                     Start_Column := Start_Column + 2;\n+                     exit Blanks_Loop;\n+                  end if;\n+               else\n+                  Scan_Ptr := Scan_Ptr + 1;\n+                  Start_Column := Start_Column + 1;\n+                  exit Blanks_Loop;\n+               end if;\n+            else\n+               exit Blanks_Loop;\n+            end if;\n+         end loop Blanks_Loop;\n+\n+         --  Outer loop keeps going only if a horizontal tab follows\n+\n+         if Source (Scan_Ptr) = HT then\n+            if Style_Check then Style.Check_HT; end if;\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Start_Column := (Start_Column / 8) * 8 + 8;\n+         else\n+            exit Tabs_Loop;\n+         end if;\n+\n+      end loop Tabs_Loop;\n+\n+      return Start_Column;\n+   end Set_Start_Column;\n+\n+   ----------\n+   -- Slit --\n+   ----------\n+\n+   procedure Slit is separate;\n+\n+end Scn;"}, {"sha": "1fc5441f87af0a46789746e5187f678432b00cc4", "filename": "gcc/ada/scn.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fscn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  S C N                                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the lexical analyzer routines. This is used both\n+--  for scanning Ada source files and also for scanning Ada project files.\n+\n+with Casing; use Casing;\n+with Types;  use Types;\n+\n+package Scn is\n+\n+   procedure Initialize_Scanner\n+     (Unit  : Unit_Number_Type;\n+      Index : Source_File_Index);\n+   --  Initialize lexical scanner for scanning a new file. The caller has\n+   --  completed the construction of the Units.Table entry for the specified\n+   --  Unit and Index references the corresponding source file. A special\n+   --  case is when Unit = No_Unit_Number, and Index corresponds to the\n+   --  source index for reading the configuration pragma file.\n+\n+   procedure Scan;\n+   --  Scan scans out the next token, and advances the scan state accordingly\n+   --  (see package Scan_State for details). If the scan encounters an illegal\n+   --  token, then an error message is issued pointing to the bad character,\n+   --  and Scan returns a reasonable substitute token of some kind.\n+\n+   function Scan_First_Char return Source_Ptr;\n+   --  This routine returns the position in Source of the first non-blank\n+   --  character on the current line, used for certain error recovery actions.\n+\n+   procedure Scan_Reserved_Identifier (Force_Msg : Boolean);\n+   --  This procedure is called to convert the current token, which the caller\n+   --  has checked is for a reserved word, to an equivalent identifier. This is\n+   --  of course only used in error situations where the parser can detect that\n+   --  a reserved word is being used as an identifier. An appropriate error\n+   --  message, pointing to the token, is also issued if either this is the\n+   --  first occurrence of misuse of this identifier, or if Force_Msg is True.\n+\n+   function Determine_Token_Casing return Casing_Type;\n+   pragma Inline (Determine_Token_Casing);\n+   --  Determines the casing style of the current token, which is\n+   --  either a keyword or an identifier. See also package Casing.\n+\n+end Scn;"}, {"sha": "7d4cbc167184c36c7f1c9f37e25e8c7c22ee1d21", "filename": "gcc/ada/sdefault.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsdefault.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsdefault.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsdefault.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S D E F A U L T                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sdefault is\n+\n+   --  This package contains functions that return the default values for\n+   --  the include and object file directories, target name, and the default\n+   --  library subdirectory (libsubdir) prefix.\n+\n+   function Include_Dir_Default_Name return String_Ptr;\n+   function Object_Dir_Default_Name return String_Ptr;\n+   function Target_Name return String_Ptr;\n+   function Search_Dir_Prefix return String_Ptr;\n+end Sdefault;"}, {"sha": "1eb315d481e2ebd4b239de14069f6b2a7409d4d3", "filename": "gcc/ada/sem.adb", "status": "added", "additions": 1184, "deletions": 0, "changes": 1184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1184 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  S E M                                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.290 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Debug_A;  use Debug_A;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Expander; use Expander;\n+with Fname;    use Fname;\n+with HLO;      use HLO;\n+with Lib;      use Lib;\n+with Lib.Load; use Lib.Load;\n+with Nlists;   use Nlists;\n+with Opt;      use Opt;\n+with Sem_Attr; use Sem_Attr;\n+with Sem_Ch2;  use Sem_Ch2;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch4;  use Sem_Ch4;\n+with Sem_Ch5;  use Sem_Ch5;\n+with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Ch7;  use Sem_Ch7;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch9;  use Sem_Ch9;\n+with Sem_Ch10; use Sem_Ch10;\n+with Sem_Ch11; use Sem_Ch11;\n+with Sem_Ch12; use Sem_Ch12;\n+with Sem_Ch13; use Sem_Ch13;\n+with Sem_Prag; use Sem_Prag;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n+with Uintp;    use Uintp;\n+\n+pragma Warnings (Off, Sem_Util);\n+--  Suppress warnings of unused with for Sem_Util (used only in asserts)\n+\n+package body Sem is\n+\n+   Outer_Generic_Scope : Entity_Id := Empty;\n+   --  Global reference to the outer scope that is generic. In a non\n+   --  generic context, it is empty. At the moment, it is only used\n+   --  for avoiding freezing of external references in generics.\n+\n+   -------------\n+   -- Analyze --\n+   -------------\n+\n+   procedure Analyze (N : Node_Id) is\n+   begin\n+      Debug_A_Entry (\"analyzing  \", N);\n+\n+      --  Immediate return if already analyzed\n+\n+      if Analyzed (N) then\n+         Debug_A_Exit (\"analyzing  \", N, \"  (done, analyzed already)\");\n+         return;\n+      end if;\n+\n+      Current_Error_Node := N;\n+\n+      --  Otherwise processing depends on the node kind\n+\n+      case Nkind (N) is\n+\n+         when N_Abort_Statement =>\n+            Analyze_Abort_Statement (N);\n+\n+         when N_Abstract_Subprogram_Declaration =>\n+            Analyze_Abstract_Subprogram_Declaration (N);\n+\n+         when N_Accept_Alternative =>\n+            Analyze_Accept_Alternative (N);\n+\n+         when N_Accept_Statement =>\n+            Analyze_Accept_Statement (N);\n+\n+         when N_Aggregate =>\n+            Analyze_Aggregate (N);\n+\n+         when N_Allocator =>\n+            Analyze_Allocator (N);\n+\n+         when N_And_Then =>\n+            Analyze_Short_Circuit (N);\n+\n+         when N_Assignment_Statement =>\n+            Analyze_Assignment (N);\n+\n+         when N_Asynchronous_Select =>\n+            Analyze_Asynchronous_Select (N);\n+\n+         when N_At_Clause =>\n+            Analyze_At_Clause (N);\n+\n+         when N_Attribute_Reference =>\n+            Analyze_Attribute (N);\n+\n+         when N_Attribute_Definition_Clause   =>\n+            Analyze_Attribute_Definition_Clause (N);\n+\n+         when N_Block_Statement =>\n+            Analyze_Block_Statement (N);\n+\n+         when N_Case_Statement =>\n+            Analyze_Case_Statement (N);\n+\n+         when N_Character_Literal =>\n+            Analyze_Character_Literal (N);\n+\n+         when N_Code_Statement =>\n+            Analyze_Code_Statement (N);\n+\n+         when N_Compilation_Unit =>\n+            Analyze_Compilation_Unit (N);\n+\n+         when N_Component_Declaration =>\n+            Analyze_Component_Declaration (N);\n+\n+         when N_Conditional_Expression =>\n+            Analyze_Conditional_Expression (N);\n+\n+         when N_Conditional_Entry_Call =>\n+            Analyze_Conditional_Entry_Call (N);\n+\n+         when N_Delay_Alternative =>\n+            Analyze_Delay_Alternative (N);\n+\n+         when N_Delay_Relative_Statement =>\n+            Analyze_Delay_Relative (N);\n+\n+         when N_Delay_Until_Statement =>\n+            Analyze_Delay_Until (N);\n+\n+         when N_Entry_Body =>\n+            Analyze_Entry_Body (N);\n+\n+         when N_Entry_Body_Formal_Part =>\n+            Analyze_Entry_Body_Formal_Part (N);\n+\n+         when N_Entry_Call_Alternative =>\n+            Analyze_Entry_Call_Alternative (N);\n+\n+         when N_Entry_Declaration =>\n+            Analyze_Entry_Declaration (N);\n+\n+         when N_Entry_Index_Specification     =>\n+            Analyze_Entry_Index_Specification (N);\n+\n+         when N_Enumeration_Representation_Clause =>\n+            Analyze_Enumeration_Representation_Clause (N);\n+\n+         when N_Exception_Declaration =>\n+            Analyze_Exception_Declaration (N);\n+\n+         when N_Exception_Renaming_Declaration =>\n+            Analyze_Exception_Renaming (N);\n+\n+         when N_Exit_Statement =>\n+            Analyze_Exit_Statement (N);\n+\n+         when N_Expanded_Name =>\n+            Analyze_Expanded_Name (N);\n+\n+         when N_Explicit_Dereference =>\n+            Analyze_Explicit_Dereference (N);\n+\n+         when N_Extension_Aggregate =>\n+            Analyze_Aggregate (N);\n+\n+         when N_Formal_Object_Declaration =>\n+            Analyze_Formal_Object_Declaration (N);\n+\n+         when N_Formal_Package_Declaration =>\n+            Analyze_Formal_Package (N);\n+\n+         when N_Formal_Subprogram_Declaration =>\n+            Analyze_Formal_Subprogram (N);\n+\n+         when N_Formal_Type_Declaration =>\n+            Analyze_Formal_Type_Declaration (N);\n+\n+         when N_Free_Statement =>\n+            Analyze_Free_Statement (N);\n+\n+         when N_Freeze_Entity =>\n+            null;  -- no semantic processing required\n+\n+         when N_Full_Type_Declaration =>\n+            Analyze_Type_Declaration (N);\n+\n+         when N_Function_Call =>\n+            Analyze_Function_Call (N);\n+\n+         when N_Function_Instantiation =>\n+            Analyze_Function_Instantiation (N);\n+\n+         when N_Generic_Function_Renaming_Declaration =>\n+            Analyze_Generic_Function_Renaming (N);\n+\n+         when N_Generic_Package_Declaration =>\n+            Analyze_Generic_Package_Declaration (N);\n+\n+         when N_Generic_Package_Renaming_Declaration =>\n+            Analyze_Generic_Package_Renaming (N);\n+\n+         when N_Generic_Procedure_Renaming_Declaration =>\n+            Analyze_Generic_Procedure_Renaming (N);\n+\n+         when N_Generic_Subprogram_Declaration =>\n+            Analyze_Generic_Subprogram_Declaration (N);\n+\n+         when N_Goto_Statement =>\n+            Analyze_Goto_Statement (N);\n+\n+         when N_Handled_Sequence_Of_Statements =>\n+            Analyze_Handled_Statements (N);\n+\n+         when N_Identifier =>\n+            Analyze_Identifier (N);\n+\n+         when N_If_Statement =>\n+            Analyze_If_Statement (N);\n+\n+         when N_Implicit_Label_Declaration =>\n+            Analyze_Implicit_Label_Declaration (N);\n+\n+         when N_In =>\n+            Analyze_Membership_Op (N);\n+\n+         when N_Incomplete_Type_Declaration =>\n+            Analyze_Incomplete_Type_Decl (N);\n+\n+         when N_Indexed_Component =>\n+            Analyze_Indexed_Component_Form (N);\n+\n+         when N_Integer_Literal =>\n+            Analyze_Integer_Literal (N);\n+\n+         when N_Itype_Reference =>\n+            Analyze_Itype_Reference (N);\n+\n+         when N_Label =>\n+            Analyze_Label (N);\n+\n+         when N_Loop_Statement =>\n+            Analyze_Loop_Statement (N);\n+\n+         when N_Not_In =>\n+            Analyze_Membership_Op (N);\n+\n+         when N_Null =>\n+            Analyze_Null (N);\n+\n+         when N_Null_Statement =>\n+            Analyze_Null_Statement (N);\n+\n+         when N_Number_Declaration =>\n+            Analyze_Number_Declaration (N);\n+\n+         when N_Object_Declaration =>\n+            Analyze_Object_Declaration (N);\n+\n+         when N_Object_Renaming_Declaration  =>\n+            Analyze_Object_Renaming (N);\n+\n+         when N_Operator_Symbol =>\n+            Analyze_Operator_Symbol (N);\n+\n+         when N_Op_Abs =>\n+            Analyze_Unary_Op (N);\n+\n+         when N_Op_Add =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_And =>\n+            Analyze_Logical_Op (N);\n+\n+         when N_Op_Concat =>\n+            Analyze_Concatenation (N);\n+\n+         when N_Op_Divide =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Eq =>\n+            Analyze_Equality_Op (N);\n+\n+         when N_Op_Expon =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Ge =>\n+            Analyze_Comparison_Op (N);\n+\n+         when N_Op_Gt =>\n+            Analyze_Comparison_Op (N);\n+\n+         when N_Op_Le =>\n+            Analyze_Comparison_Op (N);\n+\n+         when N_Op_Lt =>\n+            Analyze_Comparison_Op (N);\n+\n+         when N_Op_Minus =>\n+            Analyze_Unary_Op (N);\n+\n+         when N_Op_Mod =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Multiply =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Ne =>\n+            Analyze_Equality_Op (N);\n+\n+         when N_Op_Not =>\n+            Analyze_Negation (N);\n+\n+         when N_Op_Or =>\n+            Analyze_Logical_Op (N);\n+\n+         when N_Op_Plus =>\n+            Analyze_Unary_Op (N);\n+\n+         when N_Op_Rem =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Rotate_Left =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Rotate_Right =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Shift_Left =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Shift_Right =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Shift_Right_Arithmetic =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Subtract =>\n+            Analyze_Arithmetic_Op (N);\n+\n+         when N_Op_Xor =>\n+            Analyze_Logical_Op (N);\n+\n+         when N_Or_Else =>\n+            Analyze_Short_Circuit (N);\n+\n+         when N_Others_Choice =>\n+            Analyze_Others_Choice (N);\n+\n+         when N_Package_Body =>\n+            Analyze_Package_Body (N);\n+\n+         when N_Package_Body_Stub =>\n+            Analyze_Package_Body_Stub (N);\n+\n+         when N_Package_Declaration =>\n+            Analyze_Package_Declaration (N);\n+\n+         when N_Package_Instantiation =>\n+            Analyze_Package_Instantiation (N);\n+\n+         when N_Package_Renaming_Declaration =>\n+            Analyze_Package_Renaming (N);\n+\n+         when N_Package_Specification =>\n+            Analyze_Package_Specification (N);\n+\n+         when N_Parameter_Association =>\n+            Analyze_Parameter_Association (N);\n+\n+         when N_Pragma =>\n+            Analyze_Pragma (N);\n+\n+         when N_Private_Extension_Declaration =>\n+            Analyze_Private_Extension_Declaration (N);\n+\n+         when N_Private_Type_Declaration =>\n+            Analyze_Private_Type_Declaration (N);\n+\n+         when N_Procedure_Call_Statement =>\n+            Analyze_Procedure_Call (N);\n+\n+         when N_Procedure_Instantiation =>\n+            Analyze_Procedure_Instantiation (N);\n+\n+         when N_Protected_Body =>\n+            Analyze_Protected_Body (N);\n+\n+         when N_Protected_Body_Stub =>\n+            Analyze_Protected_Body_Stub (N);\n+\n+         when N_Protected_Definition =>\n+            Analyze_Protected_Definition (N);\n+\n+         when N_Protected_Type_Declaration =>\n+            Analyze_Protected_Type (N);\n+\n+         when N_Qualified_Expression =>\n+            Analyze_Qualified_Expression (N);\n+\n+         when N_Raise_Statement =>\n+            Analyze_Raise_Statement (N);\n+\n+         when N_Raise_xxx_Error =>\n+            Analyze_Raise_xxx_Error (N);\n+\n+         when N_Range =>\n+            Analyze_Range (N);\n+\n+         when N_Range_Constraint =>\n+            Analyze_Range (Range_Expression (N));\n+\n+         when N_Real_Literal =>\n+            Analyze_Real_Literal (N);\n+\n+         when N_Record_Representation_Clause =>\n+            Analyze_Record_Representation_Clause (N);\n+\n+         when N_Reference =>\n+            Analyze_Reference (N);\n+\n+         when N_Requeue_Statement =>\n+            Analyze_Requeue (N);\n+\n+         when N_Return_Statement =>\n+            Analyze_Return_Statement (N);\n+\n+         when N_Selected_Component =>\n+            Find_Selected_Component (N);\n+            --  ??? why not Analyze_Selected_Component, needs comments\n+\n+         when N_Selective_Accept =>\n+            Analyze_Selective_Accept (N);\n+\n+         when N_Single_Protected_Declaration =>\n+            Analyze_Single_Protected (N);\n+\n+         when N_Single_Task_Declaration =>\n+            Analyze_Single_Task (N);\n+\n+         when N_Slice =>\n+            Analyze_Slice (N);\n+\n+         when N_String_Literal =>\n+            Analyze_String_Literal (N);\n+\n+         when N_Subprogram_Body =>\n+            Analyze_Subprogram_Body (N);\n+\n+         when N_Subprogram_Body_Stub =>\n+            Analyze_Subprogram_Body_Stub (N);\n+\n+         when N_Subprogram_Declaration =>\n+            Analyze_Subprogram_Declaration (N);\n+\n+         when N_Subprogram_Info =>\n+            Analyze_Subprogram_Info (N);\n+\n+         when N_Subprogram_Renaming_Declaration =>\n+            Analyze_Subprogram_Renaming (N);\n+\n+         when N_Subtype_Declaration =>\n+            Analyze_Subtype_Declaration (N);\n+\n+         when N_Subtype_Indication =>\n+            Analyze_Subtype_Indication (N);\n+\n+         when N_Subunit =>\n+            Analyze_Subunit (N);\n+\n+         when N_Task_Body =>\n+            Analyze_Task_Body (N);\n+\n+         when N_Task_Body_Stub =>\n+            Analyze_Task_Body_Stub (N);\n+\n+         when N_Task_Definition =>\n+            Analyze_Task_Definition (N);\n+\n+         when N_Task_Type_Declaration =>\n+            Analyze_Task_Type (N);\n+\n+         when N_Terminate_Alternative =>\n+            Analyze_Terminate_Alternative (N);\n+\n+         when N_Timed_Entry_Call =>\n+            Analyze_Timed_Entry_Call (N);\n+\n+         when N_Triggering_Alternative =>\n+            Analyze_Triggering_Alternative (N);\n+\n+         when N_Type_Conversion =>\n+            Analyze_Type_Conversion (N);\n+\n+         when N_Unchecked_Expression =>\n+            Analyze_Unchecked_Expression (N);\n+\n+         when N_Unchecked_Type_Conversion =>\n+            Analyze_Unchecked_Type_Conversion (N);\n+\n+         when N_Use_Package_Clause =>\n+            Analyze_Use_Package (N);\n+\n+         when N_Use_Type_Clause =>\n+            Analyze_Use_Type (N);\n+\n+         when N_Validate_Unchecked_Conversion =>\n+            null;\n+\n+         when N_Variant_Part =>\n+            Analyze_Variant_Part (N);\n+\n+         when N_With_Clause =>\n+            Analyze_With_Clause (N);\n+\n+         when N_With_Type_Clause =>\n+            Analyze_With_Type_Clause (N);\n+\n+         --  A call to analyze the Empty node is an error, but most likely\n+         --  it is an error caused by an attempt to analyze a malformed\n+         --  piece of tree caused by some other error, so if there have\n+         --  been any other errors, we just ignore it, otherwise it is\n+         --  a real internal error which we complain about.\n+\n+         when N_Empty =>\n+            pragma Assert (Errors_Detected /= 0);\n+            null;\n+\n+         --  A call to analyze the error node is simply ignored, to avoid\n+         --  causing cascaded errors (happens of course only in error cases)\n+\n+         when N_Error =>\n+            null;\n+\n+         --  For the remaining node types, we generate compiler abort, because\n+         --  these nodes are always analyzed within the Sem_Chn routines and\n+         --  there should never be a case of making a call to the main Analyze\n+         --  routine for these node kinds. For example, an N_Access_Definition\n+         --  node appears only in the context of a type declaration, and is\n+         --  processed by the analyze routine for type declarations.\n+\n+         when\n+           N_Abortable_Part                         |\n+           N_Access_Definition                      |\n+           N_Access_Function_Definition             |\n+           N_Access_Procedure_Definition            |\n+           N_Access_To_Object_Definition            |\n+           N_Case_Statement_Alternative             |\n+           N_Compilation_Unit_Aux                   |\n+           N_Component_Association                  |\n+           N_Component_Clause                       |\n+           N_Component_List                         |\n+           N_Constrained_Array_Definition           |\n+           N_Decimal_Fixed_Point_Definition         |\n+           N_Defining_Character_Literal             |\n+           N_Defining_Identifier                    |\n+           N_Defining_Operator_Symbol               |\n+           N_Defining_Program_Unit_Name             |\n+           N_Delta_Constraint                       |\n+           N_Derived_Type_Definition                |\n+           N_Designator                             |\n+           N_Digits_Constraint                      |\n+           N_Discriminant_Association               |\n+           N_Discriminant_Specification             |\n+           N_Elsif_Part                             |\n+           N_Entry_Call_Statement                   |\n+           N_Enumeration_Type_Definition            |\n+           N_Exception_Handler                      |\n+           N_Floating_Point_Definition              |\n+           N_Formal_Decimal_Fixed_Point_Definition  |\n+           N_Formal_Derived_Type_Definition         |\n+           N_Formal_Discrete_Type_Definition        |\n+           N_Formal_Floating_Point_Definition       |\n+           N_Formal_Modular_Type_Definition         |\n+           N_Formal_Ordinary_Fixed_Point_Definition |\n+           N_Formal_Private_Type_Definition         |\n+           N_Formal_Signed_Integer_Type_Definition  |\n+           N_Function_Specification                 |\n+           N_Generic_Association                    |\n+           N_Index_Or_Discriminant_Constraint       |\n+           N_Iteration_Scheme                       |\n+           N_Loop_Parameter_Specification           |\n+           N_Mod_Clause                             |\n+           N_Modular_Type_Definition                |\n+           N_Ordinary_Fixed_Point_Definition        |\n+           N_Parameter_Specification                |\n+           N_Pragma_Argument_Association            |\n+           N_Procedure_Specification                |\n+           N_Real_Range_Specification               |\n+           N_Record_Definition                      |\n+           N_Signed_Integer_Type_Definition         |\n+           N_Unconstrained_Array_Definition         |\n+           N_Unused_At_Start                        |\n+           N_Unused_At_End                          |\n+           N_Variant                                =>\n+\n+            raise Program_Error;\n+      end case;\n+\n+      Debug_A_Exit (\"analyzing  \", N, \"  (done)\");\n+\n+      --  Now that we have analyzed the node, we call the expander to\n+      --  perform possible expansion. This is done only for nodes that\n+      --  are not subexpressions, because in the case of subexpressions,\n+      --  we don't have the type yet, and the expander will need to know\n+      --  the type before it can do its job. For subexpression nodes, the\n+      --  call to the expander happens in the Sem_Res.Resolve.\n+\n+      --  The Analyzed flag is also set at this point for non-subexpression\n+      --  nodes (in the case of subexpression nodes, we can't set the flag\n+      --  yet, since resolution and expansion have not yet been completed)\n+\n+      if Nkind (N) not in N_Subexpr then\n+         Expand (N);\n+      end if;\n+\n+   end Analyze;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Analyze (N : Node_Id; Suppress : Check_Id) is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Analyze (N);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Analyze (N);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Analyze;\n+\n+   ------------------\n+   -- Analyze_List --\n+   ------------------\n+\n+   procedure Analyze_List (L : List_Id) is\n+      Node : Node_Id;\n+\n+   begin\n+      Node := First (L);\n+      while Present (Node) loop\n+         Analyze (Node);\n+         Next (Node);\n+      end loop;\n+   end Analyze_List;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Analyze_List (L : List_Id; Suppress : Check_Id) is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Analyze_List (L);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Analyze_List (L);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Analyze_List;\n+\n+   -------------------------\n+   -- Enter_Generic_Scope --\n+   -------------------------\n+\n+   procedure Enter_Generic_Scope (S : Entity_Id) is\n+   begin\n+      if No (Outer_Generic_Scope) then\n+         Outer_Generic_Scope := S;\n+      end if;\n+   end Enter_Generic_Scope;\n+\n+   ------------------------\n+   -- Exit_Generic_Scope --\n+   ------------------------\n+\n+   procedure Exit_Generic_Scope  (S : Entity_Id) is\n+   begin\n+      if S = Outer_Generic_Scope then\n+         Outer_Generic_Scope := Empty;\n+      end if;\n+   end  Exit_Generic_Scope;\n+\n+   -----------------------------\n+   -- External_Ref_In_Generic --\n+   -----------------------------\n+\n+   function External_Ref_In_Generic (E : Entity_Id) return Boolean is\n+   begin\n+\n+      --  Entity is global if defined outside of current outer_generic_scope:\n+      --  Either the entity has a smaller depth that the outer generic, or it\n+      --  is in a different compilation unit.\n+\n+      return Present (Outer_Generic_Scope)\n+        and then (Scope_Depth (Scope (E)) < Scope_Depth (Outer_Generic_Scope)\n+                   or else not In_Same_Source_Unit (E, Outer_Generic_Scope));\n+   end External_Ref_In_Generic;\n+\n+   ------------------------\n+   -- Get_Scope_Suppress --\n+   ------------------------\n+\n+   function Get_Scope_Suppress (C : Check_Id) return Boolean is\n+      S : Suppress_Record renames Scope_Suppress;\n+\n+   begin\n+      case C is\n+         when Access_Check        => return S.Access_Checks;\n+         when Accessibility_Check => return S.Accessibility_Checks;\n+         when Discriminant_Check  => return S.Discriminant_Checks;\n+         when Division_Check      => return S.Division_Checks;\n+         when Elaboration_Check   => return S.Discriminant_Checks;\n+         when Index_Check         => return S.Elaboration_Checks;\n+         when Length_Check        => return S.Discriminant_Checks;\n+         when Overflow_Check      => return S.Overflow_Checks;\n+         when Range_Check         => return S.Range_Checks;\n+         when Storage_Check       => return S.Storage_Checks;\n+         when Tag_Check           => return S.Tag_Checks;\n+         when All_Checks =>\n+            raise Program_Error;\n+      end case;\n+   end Get_Scope_Suppress;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Entity_Suppress.Init;\n+      Scope_Stack.Init;\n+      Unloaded_Subunits := False;\n+   end Initialize;\n+\n+   ------------------------------\n+   -- Insert_After_And_Analyze --\n+   ------------------------------\n+\n+   procedure Insert_After_And_Analyze (N : Node_Id; M : Node_Id) is\n+      Node : Node_Id;\n+\n+   begin\n+      if Present (M) then\n+\n+         --  If we are not at the end of the list, then the easiest\n+         --  coding is simply to insert before our successor\n+\n+         if Present (Next (N)) then\n+            Insert_Before_And_Analyze (Next (N), M);\n+\n+         --  Case of inserting at the end of the list\n+\n+         else\n+            --  Capture the Node_Id of the node to be inserted. This Node_Id\n+            --  will still be the same after the insert operation.\n+\n+            Node := M;\n+            Insert_After (N, M);\n+\n+            --  Now just analyze from the inserted node to the end of\n+            --  the new list (note that this properly handles the case\n+            --  where any of the analyze calls result in the insertion of\n+            --  nodes after the analyzed node, expecting analysis).\n+\n+            while Present (Node) loop\n+               Analyze (Node);\n+               Mark_Rewrite_Insertion (Node);\n+               Next (Node);\n+            end loop;\n+         end if;\n+      end if;\n+\n+   end Insert_After_And_Analyze;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Insert_After_And_Analyze\n+     (N : Node_Id; M : Node_Id; Suppress : Check_Id)\n+   is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Insert_After_And_Analyze (N, M);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Insert_After_And_Analyze (N, M);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Insert_After_And_Analyze;\n+\n+   -------------------------------\n+   -- Insert_Before_And_Analyze --\n+   -------------------------------\n+\n+   procedure Insert_Before_And_Analyze (N : Node_Id; M : Node_Id) is\n+      Node : Node_Id;\n+\n+   begin\n+      if Present (M) then\n+\n+         --  Capture the Node_Id of the first list node to be inserted.\n+         --  This will still be the first node after the insert operation,\n+         --  since Insert_List_After does not modify the Node_Id values.\n+\n+         Node := M;\n+         Insert_Before (N, M);\n+\n+         --  The insertion does not change the Id's of any of the nodes in\n+         --  the list, and they are still linked, so we can simply loop from\n+         --  the original first node until we meet the node before which the\n+         --  insertion is occurring. Note that this properly handles the case\n+         --  where any of the analyzed nodes insert nodes after themselves,\n+         --  expecting them to get analyzed.\n+\n+         while Node /= N loop\n+            Analyze (Node);\n+            Mark_Rewrite_Insertion (Node);\n+            Next (Node);\n+         end loop;\n+      end if;\n+\n+   end Insert_Before_And_Analyze;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Insert_Before_And_Analyze\n+     (N : Node_Id; M : Node_Id; Suppress : Check_Id)\n+   is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Insert_Before_And_Analyze (N, M);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Insert_Before_And_Analyze (N, M);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Insert_Before_And_Analyze;\n+\n+   -----------------------------------\n+   -- Insert_List_After_And_Analyze --\n+   -----------------------------------\n+\n+   procedure Insert_List_After_And_Analyze (N : Node_Id; L : List_Id) is\n+      After : constant Node_Id := Next (N);\n+      Node  : Node_Id;\n+\n+   begin\n+      if Is_Non_Empty_List (L) then\n+\n+         --  Capture the Node_Id of the first list node to be inserted.\n+         --  This will still be the first node after the insert operation,\n+         --  since Insert_List_After does not modify the Node_Id values.\n+\n+         Node := First (L);\n+         Insert_List_After (N, L);\n+\n+         --  Now just analyze from the original first node until we get to\n+         --  the successor of the original insertion point (which may be\n+         --  Empty if the insertion point was at the end of the list). Note\n+         --  that this properly handles the case where any of the analyze\n+         --  calls result in the insertion of nodes after the analyzed\n+         --  node (possibly calling this routine recursively).\n+\n+         while Node /= After loop\n+            Analyze (Node);\n+            Mark_Rewrite_Insertion (Node);\n+            Next (Node);\n+         end loop;\n+      end if;\n+\n+   end Insert_List_After_And_Analyze;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Insert_List_After_And_Analyze\n+     (N : Node_Id; L : List_Id; Suppress : Check_Id)\n+   is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Insert_List_After_And_Analyze (N, L);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Insert_List_After_And_Analyze (N, L);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Insert_List_After_And_Analyze;\n+\n+   ------------------------------------\n+   -- Insert_List_Before_And_Analyze --\n+   ------------------------------------\n+\n+   procedure Insert_List_Before_And_Analyze (N : Node_Id; L : List_Id) is\n+      Node : Node_Id;\n+\n+   begin\n+      if Is_Non_Empty_List (L) then\n+\n+         --  Capture the Node_Id of the first list node to be inserted.\n+         --  This will still be the first node after the insert operation,\n+         --  since Insert_List_After does not modify the Node_Id values.\n+\n+         Node := First (L);\n+         Insert_List_Before (N, L);\n+\n+         --  The insertion does not change the Id's of any of the nodes in\n+         --  the list, and they are still linked, so we can simply loop from\n+         --  the original first node until we meet the node before which the\n+         --  insertion is occurring. Note that this properly handles the case\n+         --  where any of the analyzed nodes insert nodes after themselves,\n+         --  expecting them to get analyzed.\n+\n+         while Node /= N loop\n+            Analyze (Node);\n+            Mark_Rewrite_Insertion (Node);\n+            Next (Node);\n+         end loop;\n+      end if;\n+\n+   end Insert_List_Before_And_Analyze;\n+\n+   --  Version with check(s) suppressed\n+\n+   procedure Insert_List_Before_And_Analyze\n+     (N : Node_Id; L : List_Id; Suppress : Check_Id)\n+   is\n+   begin\n+      if Suppress = All_Checks then\n+         declare\n+            Svg : constant Suppress_Record := Scope_Suppress;\n+\n+         begin\n+            Scope_Suppress := (others => True);\n+            Insert_List_Before_And_Analyze (N, L);\n+            Scope_Suppress := Svg;\n+         end;\n+\n+      else\n+         declare\n+            Svg : constant Boolean := Get_Scope_Suppress (Suppress);\n+\n+         begin\n+            Set_Scope_Suppress (Suppress, True);\n+            Insert_List_Before_And_Analyze (N, L);\n+            Set_Scope_Suppress (Suppress, Svg);\n+         end;\n+      end if;\n+   end Insert_List_Before_And_Analyze;\n+\n+   ----------\n+   -- Lock --\n+   ----------\n+\n+   procedure Lock is\n+   begin\n+      Entity_Suppress.Locked := True;\n+      Scope_Stack.Locked := True;\n+      Entity_Suppress.Release;\n+      Scope_Stack.Release;\n+   end Lock;\n+\n+   ---------------\n+   -- Semantics --\n+   ---------------\n+\n+   procedure Semantics (Comp_Unit : Node_Id) is\n+\n+      --  The following locations save the corresponding global flags and\n+      --  variables so that they can be restored on completion. This is\n+      --  needed so that calls to Rtsfind start with the proper default\n+      --  values for these variables, and also that such calls do not\n+      --  disturb the settings for units being analyzed at a higher level.\n+\n+      S_Full_Analysis    : constant Boolean          := Full_Analysis;\n+      S_In_Default_Expr  : constant Boolean          := In_Default_Expression;\n+      S_Inside_A_Generic : constant Boolean          := Inside_A_Generic;\n+      S_New_Nodes_OK     : constant Int              := New_Nodes_OK;\n+      S_Outer_Gen_Scope  : constant Entity_Id        := Outer_Generic_Scope;\n+      S_Sem_Unit         : constant Unit_Number_Type := Current_Sem_Unit;\n+\n+      Save_Config_Switches : Config_Switches_Type;\n+      --  Variable used to save values of config switches while we analyze\n+      --  the new unit, to be restored on exit for proper recursive behavior.\n+\n+      procedure Do_Analyze;\n+      --  Procedure to analyze the compilation unit. This is called more\n+      --  than once when the high level optimizer is activated.\n+\n+      procedure Do_Analyze is\n+      begin\n+         Save_Scope_Stack;\n+         New_Scope (Standard_Standard);\n+         Scope_Suppress := Suppress_Options;\n+         Scope_Stack.Table\n+           (Scope_Stack.Last).Component_Alignment_Default := Calign_Default;\n+         Scope_Stack.Table\n+           (Scope_Stack.Last).Is_Active_Stack_Base := True;\n+         Outer_Generic_Scope := Empty;\n+\n+         --  Now analyze the top level compilation unit node\n+\n+         Analyze (Comp_Unit);\n+\n+         --  Check for scope mismatch on exit from compilation\n+\n+         pragma Assert (Current_Scope = Standard_Standard\n+                          or else Comp_Unit = Cunit (Main_Unit));\n+\n+         --  Then pop entry for Standard, and pop implicit types\n+\n+         Pop_Scope;\n+         Restore_Scope_Stack;\n+      end Do_Analyze;\n+\n+   --  Start of processing for Sem\n+\n+   begin\n+      Compiler_State        := Analyzing;\n+      Current_Sem_Unit      := Get_Cunit_Unit_Number (Comp_Unit);\n+\n+      Expander_Mode_Save_And_Set\n+        (Operating_Mode = Generate_Code or Debug_Flag_X);\n+\n+      Full_Analysis         := True;\n+      Inside_A_Generic      := False;\n+      In_Default_Expression := False;\n+\n+      Set_Comes_From_Source_Default (False);\n+      Save_Opt_Config_Switches (Save_Config_Switches);\n+      Set_Opt_Config_Switches\n+        (Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit)));\n+\n+      --  Only do analysis of unit that has not already been analyzed\n+\n+      if not Analyzed (Comp_Unit) then\n+         Initialize_Version (Current_Sem_Unit);\n+         if HLO_Active then\n+            Expander_Mode_Save_And_Set (False);\n+            New_Nodes_OK := 1;\n+            Do_Analyze;\n+            Reset_Analyzed_Flags (Comp_Unit);\n+            Expander_Mode_Restore;\n+            High_Level_Optimize (Comp_Unit);\n+            New_Nodes_OK := 0;\n+         end if;\n+\n+         Do_Analyze;\n+      end if;\n+\n+      --  Save indication of dynamic elaboration checks for ALI file\n+\n+      Set_Dynamic_Elab (Current_Sem_Unit, Dynamic_Elaboration_Checks);\n+\n+      --  Restore settings of saved switches to entry values\n+\n+      Current_Sem_Unit       := S_Sem_Unit;\n+      Full_Analysis          := S_Full_Analysis;\n+      In_Default_Expression  := S_In_Default_Expr;\n+      Inside_A_Generic       := S_Inside_A_Generic;\n+      New_Nodes_OK           := S_New_Nodes_OK;\n+      Outer_Generic_Scope    := S_Outer_Gen_Scope;\n+\n+      Restore_Opt_Config_Switches (Save_Config_Switches);\n+      Expander_Mode_Restore;\n+\n+   end Semantics;\n+\n+   ------------------------\n+   -- Set_Scope_Suppress --\n+   ------------------------\n+\n+   procedure Set_Scope_Suppress (C : Check_Id; B : Boolean) is\n+      S : Suppress_Record renames Scope_Suppress;\n+\n+   begin\n+      case C is\n+         when Access_Check        => S.Access_Checks        := B;\n+         when Accessibility_Check => S.Accessibility_Checks := B;\n+         when Discriminant_Check  => S.Discriminant_Checks  := B;\n+         when Division_Check      => S.Division_Checks      := B;\n+         when Elaboration_Check   => S.Discriminant_Checks  := B;\n+         when Index_Check         => S.Elaboration_Checks   := B;\n+         when Length_Check        => S.Discriminant_Checks  := B;\n+         when Overflow_Check      => S.Overflow_Checks      := B;\n+         when Range_Check         => S.Range_Checks         := B;\n+         when Storage_Check       => S.Storage_Checks       := B;\n+         when Tag_Check           => S.Tag_Checks           := B;\n+         when All_Checks =>\n+            raise Program_Error;\n+      end case;\n+   end Set_Scope_Suppress;\n+\n+end Sem;"}, {"sha": "a88761627fe801c907d178c0895a667b694927fc", "filename": "gcc/ada/sem.ads", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,492 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  S E M                                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.101 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--------------------------------------\n+-- Semantic Analysis: General Model --\n+--------------------------------------\n+\n+--  Semantic processing involves 3 phases which are highly interwined\n+--  (ie mutually recursive):\n+--\n+--    Analysis     implements the bulk of semantic analysis such as\n+--                 name analysis and type resolution for declarations,\n+--                 instructions and expressions.  The main routine\n+--                 driving this process is procedure Analyze given below.\n+--                 This analysis phase is really a bottom up pass that is\n+--                 achieved during the recursive traversal performed by the\n+--                 Analyze_... procedures implemented in the sem_* packages.\n+--                 For expressions this phase determines unambiguous types\n+--                 and collects sets of possible types where the\n+--                 interpretation is potentially ambiguous.\n+--\n+--    Resolution   is carried out only for expressions to finish type\n+--                 resolution that was initiated but not necessarily\n+--                 completed during analysis (because of overloading\n+--                 ambiguities). Specifically, after completing the bottom\n+--                 up pass carried out during analysis for expressions, the\n+--                 Resolve routine (see the spec of sem_res for more info)\n+--                 is called to perform a top down resolution with\n+--                 recursive calls to itself to resolve operands.\n+--\n+--    Expansion    if we are not generating code this phase is a no-op.\n+--                 otherwise this phase expands, ie transforms, original\n+--                 declaration, expressions or instructions into simpler\n+--                 structures that can be handled by the back-end. This\n+--                 phase is also in charge of generating code which is\n+--                 implicit in the original source (for instance for\n+--                 default initializations, controlled types, etc.)\n+--                 There are two separate instances where expansion is\n+--                 invoked. For declarations and instructions, expansion is\n+--                 invoked just after analysis since no resolution needs\n+--                 to be performed. For expressions, expansion is done just\n+--                 after resolution. In both cases expansion is done from the\n+--                 bottom up just before the end of Analyze for instructions\n+--                 and declarations or the call to Resolve for expressions.\n+--                 The main routine driving expansion is Expand.\n+--                 See the spec of Expander for more details.\n+--\n+--  To summarize, in normal code generation mode we recursively traverse the\n+--  abstract syntax tree top-down performing semantic analysis bottom\n+--  up. For instructions and declarations, before the call to the Analyze\n+--  routine completes we perform expansion since at that point we have all\n+--  semantic information needed. For expression nodes, after the call to\n+--  Analysis terminates we invoke the Resolve routine to transmit top-down\n+--  the type that was gathered by Analyze which will resolve possible\n+--  ambiguities in the expression. Just before the call to Resolve\n+--  terminates, the expression can be expanded since all the semantic\n+--  information is available at that point.\n+--\n+--  If we are not generating code then the expansion phase is a no-op.\n+--\n+--  When generating code there are a number of exceptions to the basic\n+--  Analysis-Resolution-Expansion model for expressions. The most prominent\n+--  examples are the handling of default expressions and aggregates.\n+\n+-------------------------------------\n+-- Handling of Default Expressions --\n+-------------------------------------\n+\n+--  The default expressions in component declarations and in procedure\n+--  specifications (but not the ones in object declarations) are quite\n+--  tricky to handle. The problem is that some processing is required\n+--  at the point where the expression appears:\n+--\n+--    visibility analysis (including user defined operators)\n+--    freezing of static expressions\n+--\n+--  but other processing must be deferred until the enclosing entity\n+--  (record or procedure specification) is frozen:\n+--\n+--    freezing of any other types in the expression\n+--    expansion\n+--\n+--  Expansion has to be deferred since you can't generate code for\n+--  expressions that refernce types that have not been frozen yet. As an\n+--  example, consider the following:\n+--\n+--      type x is delta 0.5 range -10.0 .. +10.0;\n+--      ...\n+--      type q is record\n+--        xx : x := y * z;\n+--      end record;\n+--\n+--      for x'small use 0.25\n+--\n+--  The expander is in charge of dealing with fixed-point, and of course\n+--  the small declaration, which is not too late, since the declaration of\n+--  type q does *not* freeze type x, definitely affects the expanded code.\n+--\n+--  Generally our model is to combine analysis resolution and expansion, but\n+--  this is the one case where this model falls down. Here is how we patch\n+--  it up without causing too much distortion to our basic model.\n+--\n+--  A switch (sede below) is set to indicate that we are in the initial\n+--  occurence of a default expression. The analyzer is then called on this\n+--  expression with the switch set true. Analysis and resolution proceed\n+--  almost as usual, except that Freeze_Expression will not freeze\n+--  non-static expressions if this switch is set, and the call to Expand at\n+--  the end of resolution is skipped. This also skips the code that normally\n+--  sets the Analyzed flag to True). The result is that when we are done the\n+--  tree is still marked as unanalyzed, but all types for static expressions\n+--  are frozen as required, and all entities of variables have been\n+--  recorded.  We then turn off the switch, and later on reanalyze the\n+--  expression with the switch off. The effect is that this second analysis\n+--  freezes the rest of the types as required, and generates code but\n+--  visibility analysis is not repeated since all the entities are marked.\n+--\n+--  The second analysis (the one that generates code) is in the context\n+--  where the code is required. For a record field default, this is in\n+--  the initialization procedure for the record and for a subprogram\n+--  default parameter, it is at the point the subprogram is frozen.\n+\n+------------------\n+-- Pre-Analysis --\n+------------------\n+\n+--  For certain kind of expressions, such as aggregates, we need to defer\n+--  expansion of the aggregate and its inner expressions after the whole\n+--  set of expressions appearing inside the aggregate have been analyzed.\n+--  Consider, for instance the following example:\n+--\n+--     (1 .. 100 => new Thing (Function_Call))\n+--\n+--  The normal Analysis-Resolution-Expansion mechanism where expansion\n+--  of the children is performed before expansion of the parent does not\n+--  work if the code generated for the children by the expander needs\n+--  to be evaluated repeatdly (for instance in the above aggregate\n+--  \"new Thing (Function_Call)\" needs to be called 100 times.)\n+--  The reason why this mecanism does not work is that, the expanded code\n+--  for the children is typically inserted above the parent and thus\n+--  when the father gets expanded no re-evaluation takes place. For instance\n+--  in the case of aggregates if \"new Thing (Function_Call)\" is expanded\n+--  before of the aggregate the expanded code will be placed outside\n+--  of the aggregate and when expanding the aggregate the loop from 1 to 100\n+--  will not surround the expanded code for \"new Thing (Function_Call)\".\n+--\n+--  To remedy this situation we introduce a new flag which signals whether\n+--  we want a full analysis (ie expansion is enabled) or a pre-analysis\n+--  which performs Analysis and Resolution but no expansion.\n+--\n+--  After the complete pre-analysis of an expression has been carried out\n+--  we can transform the expression and then carry out the full\n+--  Analyze-Resolve-Expand cycle on the transformed expression top-down\n+--  so that the expansion of inner expressions happens inside the newly\n+--  generated node for the parent expression.\n+--\n+--  Note that the difference between processing of default expressions and\n+--  pre-analysis of other expressions is that we do carry out freezing in\n+--  the latter but not in the former (except for static scalar expressions).\n+--  The routine that performs pre-analysis is called Pre_Analyze_And_Resolve\n+--  and is in Sem_Res.\n+\n+with Alloc;\n+with Einfo;  use Einfo;\n+with Opt;    use Opt;\n+with Snames; use Snames;\n+with Table;\n+with Types;  use Types;\n+\n+package Sem is\n+\n+   New_Nodes_OK : Int := 1;\n+   --  Temporary flag for use in checking out HLO. Set non-zero if it is\n+   --  OK to generate new nodes.\n+\n+   -----------------------------\n+   -- Semantic Analysis Flags --\n+   -----------------------------\n+\n+   Full_Analysis : Boolean := True;\n+   --  Switch to indicate whether we are doing a full analysis or a\n+   --  pre-analysis. In normal analysis mode (Analysis-Expansion for\n+   --  instructions or declarations) or (Analysis-Resolution-Expansion for\n+   --  expressions) this flag is set. Note that if we are not generating\n+   --  code the expansion phase merely sets the Analyzed flag to True in\n+   --  this case. If we are in Pre-Analysis mode (see above) this flag is\n+   --  set to False then the expansion phase is skipped.\n+   --  When this flag is False the flag Expander_Active is also False\n+   --  (the Expander_Activer flag defined in the spec of package Expander\n+   --  tells you whether expansion is currently enabled).\n+   --  You should really regard this as a read only flag.\n+\n+   In_Default_Expression : Boolean := False;\n+   --  Switch to indicate that we are in a default expression, as described\n+   --  above. Note that this must be recursively saved on a Semantics call\n+   --  since it is possible for the analysis of an expression to result in\n+   --  a recursive call (e.g. to get the entity for System.Address as part\n+   --  of the processing of an Address attribute reference).\n+   --  When this switch is True then Full_Analysis above must be False.\n+   --  You should really regard this as a read only flag.\n+\n+   In_Inlined_Body : Boolean := False;\n+   --  Switch to indicate that we are analyzing and resolving an inlined\n+   --  body. Type checking is disabled in this context, because types are\n+   --  known to be compatible. This avoids problems with private types whose\n+   --  full view is derived from private types.\n+\n+   Inside_A_Generic : Boolean := False;\n+   --  This flag is set if we are processing a generic specification,\n+   --  generic definition, or generic body. When this flag is True the\n+   --  Expander_Active flag is False to disable any code expansion (see\n+   --  package Expander). Only the generic processing can modify the\n+   --  status of this flag, any other client should regard it as read-only.\n+\n+   Unloaded_Subunits : Boolean := False;\n+   --  This flag is set True if we have subunits that are not loaded. This\n+   --  occurs when the main unit is a subunit, and contains lower level\n+   --  subunits that are not loaded. We use this flag to suppress warnings\n+   --  about unused variables, since these warnings are unreliable in this\n+   --  case. We could perhaps do a more accurate job and retain some of the\n+   --  warnings, but it is quite a tricky job. See test 4323-002.\n+\n+   -----------------\n+   -- Scope Stack --\n+   -----------------\n+\n+   Scope_Suppress : Suppress_Record := Suppress_Options;\n+   --  This record contains the current scope based settings of the suppress\n+   --  switches. It is initialized from the options as shown, and then modified\n+   --  by pragma Suppress. On entry to each scope, the current setting is saved\n+   --  the scope stack, and then restored on exit from the scope.\n+\n+   --  The scope stack holds all entries of the scope table. As in the parser,\n+   --  we use Last as the stack pointer, so that we can always find the scope\n+   --  that is currently open in Scope_Stack.Table (Scope_Stack.Last). The\n+   --  oldest entry, at Scope_Stack (0) is Standard. The entries in the table\n+   --  include the entity for the referenced scope, together with information\n+   --  used to restore the proper setting of check suppressions on scope exit.\n+\n+   --  There are two kinds of suppress checks, scope based suppress checks\n+   --  (from initial command line arguments, or from Suppress pragmas not\n+   --  including an entity name). The scope based suppress checks are recorded\n+   --  in the Sem.Supress variable, and all that is necessary is to save the\n+   --  state of this variable on scope entry, and restore it on scope exit.\n+\n+   --  The other kind of suppress check is entity based suppress checks, from\n+   --  Suppress pragmas giving an Entity_Id. These checks are reflected by the\n+   --  appropriate bit being set in the corresponding entity, and restoring the\n+   --  setting of these bits is a little trickier. In particular a given pragma\n+   --  Suppress may or may not affect the current state. If it sets a check for\n+   --  an entity that is already checked, then it is important that this check\n+   --  not be restored on scope exit. The situation is made more complicated\n+   --  by the fact that a given suppress pragma can specify multiple entities\n+   --  (in the overloaded case), and multiple checks (by using All_Checks), so\n+   --  that it may be partially effective. On exit only checks that were in\n+   --  fact effective must be removed. Logically we could do this by saving\n+   --  the entire state of the entity flags on scope entry and restoring them\n+   --  on scope exit, but that would be ludicrous, so what we do instead is to\n+   --  maintain the following differential structure that shows what checks\n+   --  were installed for the current scope.\n+\n+   --  Note: Suppress pragmas that specify entities defined in a package\n+   --  spec do not make entries in this table, since such checks suppress\n+   --  requests are valid for the entire life of the entity.\n+\n+   type Entity_Check_Suppress_Record is record\n+      Entity : Entity_Id;\n+      --  Entity to which the check applies\n+\n+      Check : Check_Id;\n+      --  Check which is set (note this cannot be All_Checks, if the All_Checks\n+      --  case, a sequence of eentries appears for the individual checks.\n+   end record;\n+\n+   --  Entity_Suppress is a stack, to which new entries are added as they\n+   --  are processed (see pragma Suppress circuit in Sem_Prag). The scope\n+   --  stack entry simply saves the stack pointer on entry, and restores\n+   --  it on exit by reversing the checks one by one.\n+\n+   package Entity_Suppress is new Table.Table (\n+     Table_Component_Type => Entity_Check_Suppress_Record,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Entity_Suppress_Initial,\n+     Table_Increment      => Alloc.Entity_Suppress_Increment,\n+     Table_Name           => \"Entity_Suppress\");\n+\n+   --  Here is the scope stack itself\n+\n+   type Scope_Stack_Entry is record\n+      Entity : Entity_Id;\n+      --  Entity representing the scope\n+\n+      Last_Subprogram_Name : String_Ptr;\n+      --  Pointer to name of last subprogram body in this scope. Used for\n+      --  testing proper alpha ordering of subprogram bodies in scope.\n+\n+      Save_Scope_Suppress  : Suppress_Record;\n+      --  Save contents of Scope_Suppress on entry\n+\n+      Save_Entity_Suppress : Int;\n+      --  Save contents of Entity_Suppress.Last on entry\n+\n+      Is_Transient : Boolean;\n+      --  Marks Transient Scopes (See Exp_Ch7 body for details)\n+\n+      Previous_Visibility : Boolean;\n+      --  Used when installing the parent (s) of the current compilation\n+      --  unit. The parent may already be visible because of an ongoing\n+      --  compilation, and the proper visibility must be restored on exit.\n+\n+      Node_To_Be_Wrapped : Node_Id;\n+      --  Only used in transient scopes. Records the node which will\n+      --  be wrapped by the transient block.\n+\n+      Actions_To_Be_Wrapped_Before : List_Id;\n+      Actions_To_Be_Wrapped_After  : List_Id;\n+      --  Actions that have to be inserted at the start or at the end of a\n+      --  transient block. Used to temporarily hold these actions until the\n+      --  block is created, at which time the actions are moved to the\n+      --  block.\n+\n+      Pending_Freeze_Actions : List_Id;\n+      --  Used to collect freeze entity nodes and associated actions that\n+      --  are generated in a inner context but need to be analyzed outside,\n+      --  such as records and initialization procedures. On exit from the\n+      --  scope, this list of actions is inserted before the scope construct\n+      --  and analyzed to generate the corresponding freeze processing and\n+      --  elaboration of other associated actions.\n+\n+      First_Use_Clause : Node_Id;\n+      --  Head of list of Use_Clauses in current scope. The list is built\n+      --  when the declarations in the scope are processed. The list is\n+      --  traversed on scope exit to undo the effect of the use clauses.\n+\n+      Component_Alignment_Default : Component_Alignment_Kind;\n+      --  Component alignment to be applied to any record or array types\n+      --  that are declared for which a specific component alignment pragma\n+      --  does not set the alignment.\n+\n+      Is_Active_Stack_Base : Boolean;\n+      --  Set to true only when entering the scope for Standard_Standard from\n+      --  from within procedure Semantics. Indicates the base of the current\n+      --  active set of scopes. Needed by In_Open_Scopes to handle cases\n+      --  where Standard_Standard can be pushed in the middle of the active\n+      --  set of scopes (occurs for instantiations of generic child units).\n+   end record;\n+\n+   package Scope_Stack is new Table.Table (\n+     Table_Component_Type => Scope_Stack_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Scope_Stack_Initial,\n+     Table_Increment      => Alloc.Scope_Stack_Increment,\n+     Table_Name           => \"Sem.Scope_Stack\");\n+\n+   function Get_Scope_Suppress (C : Check_Id) return Boolean;\n+   --  Get suppress status of check C for the current scope\n+\n+   procedure Set_Scope_Suppress (C : Check_Id; B : Boolean);\n+   --  Set suppress status of check C for the current scope\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Initialize;\n+   --  Initialize internal tables\n+\n+   procedure Lock;\n+   --  Lock internal tables before calling back end\n+\n+   procedure Semantics (Comp_Unit : Node_Id);\n+   --  This procedure is called to perform semantic analysis on the specified\n+   --  node which is the N_Compilation_Unit node for the unit.\n+\n+   procedure Analyze (N : Node_Id);\n+   procedure Analyze (N : Node_Id; Suppress : Check_Id);\n+   --  This is the recursive procedure which is applied to individual nodes\n+   --  of the tree, starting at the top level node (compilation unit node)\n+   --  and then moving down the tree in a top down traversal. It calls\n+   --  individual routines with names Analyze_xxx to analyze node xxx. Each\n+   --  of these routines is responsible for calling Analyze on the components\n+   --  of the subtree.\n+   --\n+   --  Note: In the case of expression components (nodes whose Nkind is in\n+   --  N_Subexpr), the call to Analyze does not complete the semantic analysis\n+   --  of the node, since the type resolution cannot be completed until the\n+   --  complete context is analyzed. The completion of the type analysis occurs\n+   --  in the corresponding Resolve routine (see Sem_Res).\n+   --\n+   --  Note: for integer and real literals, the analyzer sets the flag to\n+   --  indicate that the result is a static expression. If the expander\n+   --  generates a literal that does NOT correspond to a static expression,\n+   --  e.g. by folding an expression whose value is known at compile-time,\n+   --  but is not technically static, then the caller should reset the\n+   --  Is_Static_Expression flag after analyzing but before resolving.\n+   --\n+   --  If the Suppress argument is present, then the analysis is done\n+   --  with the specified check suppressed (can be All_Checks to suppress\n+   --  all checks).\n+\n+   procedure Analyze_List (L : List_Id);\n+   procedure Analyze_List (L : List_Id; Suppress : Check_Id);\n+   --  Analyzes each element of a list. If the Suppress argument is present,\n+   --  then the analysis is done with the specified check suppressed (can\n+   --  be All_Checks to suppress all checks).\n+\n+   procedure Insert_List_After_And_Analyze\n+     (N : Node_Id; L : List_Id);\n+   procedure Insert_List_After_And_Analyze\n+     (N : Node_Id; L : List_Id; Suppress : Check_Id);\n+   --  Inserts list L after node N using Nlists.Insert_List_After, and then,\n+   --  after this insertion is complete, analyzes all the nodes in the list,\n+   --  including any additional nodes generated by this analysis. If the list\n+   --  is empty or be No_List, the call has no effect. If the Suppress\n+   --  argument is present, then the analysis is done with the specified\n+   --  check suppressed (can be All_Checks to suppress all checks).\n+\n+   procedure Insert_List_Before_And_Analyze\n+     (N : Node_Id; L : List_Id);\n+   procedure Insert_List_Before_And_Analyze\n+     (N : Node_Id; L : List_Id; Suppress : Check_Id);\n+   --  Inserts list L before node N using Nlists.Insert_List_Before, and then,\n+   --  after this insertion is complete, analyzes all the nodes in the list,\n+   --  including any additional nodes generated by this analysis. If the list\n+   --  is empty or be No_List, the call has no effect. If the Suppress\n+   --  argument is present, then the analysis is done with the specified\n+   --  check suppressed (can be All_Checks to suppress all checks).\n+\n+   procedure Insert_After_And_Analyze\n+     (N : Node_Id; M : Node_Id);\n+   procedure Insert_After_And_Analyze\n+     (N : Node_Id; M : Node_Id; Suppress : Check_Id);\n+   --  Inserts node M after node N and then after the insertion is complete,\n+   --  analyzes the inserted node and all nodes that are generated by\n+   --  this analysis. If the node is empty, the call has no effect. If the\n+   --  Suppress argument is present, then the analysis is done with the\n+   --  specified check suppressed (can be All_Checks to suppress all checks).\n+\n+   procedure Insert_Before_And_Analyze\n+     (N : Node_Id; M : Node_Id);\n+   procedure Insert_Before_And_Analyze\n+     (N : Node_Id; M : Node_Id; Suppress : Check_Id);\n+   --  Inserts node M before node N and then after the insertion is complete,\n+   --  analyzes the inserted node and all nodes that could be generated by\n+   --  this analysis. If the node is empty, the call has no effect. If the\n+   --  Suppress argument is present, then the analysis is done with the\n+   --  specified check suppressed (can be All_Checks to suppress all checks).\n+\n+   function External_Ref_In_Generic (E : Entity_Id) return Boolean;\n+   --  Return True if we are in the context of a generic and E is\n+   --  external (more global) to it.\n+\n+   procedure Enter_Generic_Scope (S : Entity_Id);\n+   --  Shall be called each time a Generic subprogram or package scope is\n+   --  entered.  S is the entity of the scope.\n+   --  ??? At the moment, only called for package specs because this mechanism\n+   --  is only used for avoiding freezing of external references in generics\n+   --  and this can only be an issue if the outer generic scope is a package\n+   --  spec (otherwise all external entities are already frozen)\n+\n+   procedure Exit_Generic_Scope  (S : Entity_Id);\n+   --  Shall be called each time a Generic subprogram or package scope is\n+   --  exited.  S is the entity of the scope.\n+   --  ??? At the moment, only called for package specs exit.\n+\n+end Sem;"}, {"sha": "29778ff49b08eecc65bbf23133314fc96021f835", "filename": "gcc/ada/sem_aggr.adb", "status": "added", "additions": 2848, "deletions": 0, "changes": 2848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "41a4bd759ab2271ea230ed1bca85dd280141e113", "filename": "gcc/ada/sem_aggr.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ A G G R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the resolution code for aggregates. It is logically\n+--  part of Sem_Res, but is split off since the aggregate code is so complex.\n+\n+with Types; use Types;\n+\n+package Sem_Aggr is\n+\n+   procedure Resolve_Aggregate           (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_Extension_Aggregate (N : Node_Id; Typ : Entity_Id);\n+\n+end Sem_Aggr;"}, {"sha": "4574315dbffcc66d3a972207449ff97137c4c8ef", "filename": "gcc/ada/sem_attr.adb", "status": "added", "additions": 6822, "deletions": 0, "changes": 6822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "ccbc3f49d4c0a94d1c25a151863e3e16a1422f80", "filename": "gcc/ada/sem_attr.ads", "status": "added", "additions": 595, "deletions": 0, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,595 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ A T T R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.26 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Attribute handling is isolated in a separate package to ease the addition\n+--  of implementation defined attributes. Logically this processing belongs\n+--  in chapter 4. See Sem_Ch4 for a description of the relation of the\n+--  Analyze and Resolve routines for expression components.\n+\n+--  This spec also documents all GNAT implementation defined pragmas\n+\n+with Snames; use Snames;\n+with Types;  use Types;\n+\n+package Sem_Attr is\n+\n+   type Attribute_Class_Array is array (Attribute_Id) of Boolean;\n+   --  Type used to build attribute classification flag arrays\n+\n+   -----------------------------------------\n+   -- Implementation Dependent Attributes --\n+   -----------------------------------------\n+\n+   --  This section describes the implementation dependent attributes\n+   --  provided in GNAT, as well as constructing an array of flags\n+   --  indicating which attributes these are.\n+\n+   Attribute_Impl_Def : Attribute_Class_Array := Attribute_Class_Array'(\n+\n+      ------------------\n+      -- Abort_Signal --\n+      ------------------\n+\n+      Attribute_Abort_Signal => True,\n+      --\n+      --  Standard'Abort_Signal (Standard is the only allowed prefix)\n+      --  provides the entity for the special exception used to signal\n+      --  task abort or asynchronous transfer of control. Normally this\n+      --  attribute should only be used in the tasking runtime (it is\n+      --  highly peculiar, and completely outside the normal semantics\n+      --  of Ada, for a user program to intercept the abort exception).\n+\n+      ------------------\n+      -- Address_Size --\n+      ------------------\n+\n+      Attribute_Address_Size => True,\n+      --\n+      --  Standard'Address_Size (Standard is the only allowed prefix) is\n+      --  a static constant giving the number of bits in an Address. It\n+      --  is used primarily for constructing the definition of Memory_Size\n+      --  in package Standard, but may be freely used in user programs.\n+      --  This is a static attribute.\n+\n+      ---------------\n+      -- Asm_Input --\n+      ---------------\n+\n+      Attribute_Asm_Input => True,\n+      --\n+      --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n+      --  in package Machine_Code to construct machine instructions. See\n+      --  documentation in package Machine_Code in file s-maccod.ads.\n+\n+      ----------------\n+      -- Asm_Output --\n+      ----------------\n+\n+      Attribute_Asm_Output => True,\n+      --\n+      --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n+      --  in package Machine_Code to construct machine instructions. See\n+      --  documentation in package Machine_Code in file s-maccod.ads.\n+\n+      ---------------\n+      -- AST_Entry --\n+      ---------------\n+\n+      Attribute_AST_Entry => True,\n+      --\n+      --  E'Ast_Entry, where E is a task entry, yields a value of the\n+      --  predefined type System.DEC.AST_Handler, that enables the given\n+      --  entry to be called when an AST occurs. If the name to which the\n+      --  attribute applies has not been specified with the pragma AST_Entry,\n+      --  the attribute returns the value No_Ast_Handler, and no AST occurs.\n+      --  If the entry is for a task that is not callable (T'Callable False),\n+      --  the exception program error is raised. If an AST occurs for an\n+      --  entry of a task that is terminated, the program is erroneous.\n+      --\n+      --  The attribute AST_Entry is supported only in OpenVMS versions\n+      --  of GNAT. It will be rejected as illegal in other GNAT versions.\n+\n+      ---------\n+      -- Bit --\n+      ---------\n+\n+      Attribute_Bit => True,\n+      --\n+      --  Obj'Bit, where Obj is any object, yields the bit offset within\n+      --  the storage unit (byte) that contains the first bit of storage\n+      --  allocated for the object. The value of this attribute is of the\n+      --  type Universal_Integer, and is always a non-negative number not\n+      --  exceeding the value of System.Storage_Unit.\n+      --\n+      --  For an object that is a variable or a constant allocated in a\n+      --  register, the value is zero. (The use of this attribute does not\n+      --  force the allocation of a variable to memory).\n+      --\n+      --  For an object that is a formal parameter, this attribute applies\n+      --  to either the matching actual parameter or to a copy of the\n+      --  matching actual parameter.\n+      --\n+      --  For an access object the value is zero. Note that Obj.all'Bit is\n+      --  subject to an Access_Check for the designated object. Similarly\n+      --  for a record component X.C'Bit is subject to a discriminant check\n+      --  and X(I).Bit and X(I1..I2)'Bit are subject to index checks.\n+      --\n+      --  This attribute is designed to be compatible with the DEC Ada\n+      --  definition and implementation of the Bit attribute.\n+\n+      ------------------\n+      -- Code_Address --\n+      ------------------\n+\n+      Attribute_Code_Address => True,\n+      --\n+      --  subp'Code_Address, where subp is a subprogram entity, gives the\n+      --  address of the first generated instruction for a subprogram. This\n+      --  is often, but not always the same as the 'Address value, which is\n+      --  the address to be used in a call. The differences occur in the case\n+      --  of a nested procedure (where Address yields the address of the\n+      --  trampoline code used to load the static link), and on some systems\n+      --  which use procedure descriptors (in which case Address yields the\n+      --  address of the descriptor).\n+\n+      -----------------------\n+      -- Default_Bit_Order --\n+      -----------------------\n+\n+      Attribute_Default_Bit_Order => True,\n+      --\n+      --  Standard'Default_Bit_Order (Standard is the only permissible prefix),\n+      --  provides the value System.Default_Bit_Order as a Pos value (0 for\n+      --  High_Order_First, 1 for Low_Order_First). This is used to construct\n+      --  the definition of Default_Bit_Order in package System. This is a\n+      --  static attribute.\n+\n+      ---------------\n+      -- Elab_Body --\n+      ---------------\n+\n+      Attribute_Elab_Body => True,\n+      --\n+      --  This attribute can only be applied to a program unit name. It\n+      --  returns the entity for the corresponding elaboration procedure\n+      --  for elaborating the body of the referenced unit. This is used\n+      --  in the main generated elaboration procedure by the binder, and\n+      --  is not normally used in any other context, but there may be\n+      --  specialized situations in which it is useful to be able to\n+      --  call this elaboration procedure from Ada code, e.g. if it\n+      --  is necessary to do selective reelaboration to fix some error.\n+\n+      ---------------\n+      -- Elab_Spec --\n+      ---------------\n+\n+      Attribute_Elab_Spec => True,\n+      --\n+      --  This attribute can only be applied to a program unit name. It\n+      --  returns the entity for the corresponding elaboration procedure\n+      --  for elaborating the spec of the referenced unit. This is used\n+      --  in the main generated elaboration procedure by the binder, and\n+      --  is not normally used in any other context, but there may be\n+      --  specialized situations in which it is useful to be able to\n+      --  call this elaboration procedure from Ada code, e.g. if it\n+      --  is necessary to do selective reelaboration to fix some error.\n+\n+      ----------------\n+      -- Elaborated --\n+      ----------------\n+\n+      Attribute_Elaborated => True,\n+      --\n+      --  Lunit'Elaborated, where Lunit is a library unit, yields a boolean\n+      --  value indicating whether or not the body of the designated library\n+      --  unit has been elaborated yet.\n+\n+\n+      --------------\n+      -- Enum_Rep --\n+      --------------\n+\n+      Attribute_Enum_Rep => True,\n+      --\n+      --  For every enumeration subtype S, S'Enum_Rep denotes a function\n+      --  with the following specification:\n+      --\n+      --    function S'Enum_Rep (Arg : S'Base) return universal_integer;\n+      --\n+      --  The function returns the representation value for the given\n+      --  enumeration value. This will be equal to the 'Pos value in the\n+      --  absence of an enumeration representation clause. This is a static\n+      --  attribute (i.e. the result is static if the argument is static).\n+\n+      -----------------\n+      -- Fixed_Value --\n+      -----------------\n+\n+      Attribute_Fixed_Value => True,\n+      --\n+      --  For every fixed-point type S, S'Fixed_Value denotes a function\n+      --  with the following specification:\n+      --\n+      --    function S'Fixed_Value (Arg : universal_integer) return S;\n+      --\n+      --  The value returned is the fixed-point value V such that\n+      --\n+      --    V = Arg * S'Small\n+      --\n+      --  The effect is thus equivalent to first converting the argument\n+      --  to the integer type used to represent S, and then doing an\n+      --  unchecked conversion to the fixed-point type. This attribute is\n+      --  primarily intended for use in implementation of the input-output\n+      --  functions for fixed-point values.\n+\n+      -----------------------\n+      -- Has_Discriminants --\n+      -----------------------\n+\n+      Attribute_Has_Discriminants => True,\n+      --\n+      --  Gtyp'Has_Discriminants, where Gtyp is a generic formal type, yields\n+      --  a Boolean value indicating whether or not the actual instantiation\n+      --  type has discriminants.\n+\n+      ---------\n+      -- Img --\n+      ---------\n+\n+      Attribute_Img => True,\n+      --\n+      --  The 'Img function is defined for any prefix, P, that denotes an\n+      --  object of scalar type T. P'Img is equivalent to T'Image (P). This\n+      --  is convenient for debugging. For example:\n+      --\n+      --     Put_Line (\"X = \" & X'Img);\n+      --\n+      --  has the same meaning as the more verbose:\n+      --\n+      --     Put_Line (\"X = \" & Temperature_Type'Image (X));\n+      --\n+      --  where Temperature_Type is the subtype of the object X.\n+\n+      -------------------\n+      -- Integer_Value --\n+      -------------------\n+\n+      Attribute_Integer_Value => True,\n+      --\n+      --  For every integer type S, S'Integer_Value denotes a function\n+      --  with the following specification:\n+      --\n+      --    function S'Integer_Value (Arg : universal_fixed) return S;\n+      --\n+      --  The value returned is the integer value V, such that\n+      --\n+      --    Arg = V * fixed-type'Small\n+      --\n+      --  The effect is thus equivalent to first doing an unchecked convert\n+      --  from the fixed-point type to its corresponding implementation type,\n+      --  and then converting the result to the target integer type. This\n+      --  attribute is primarily intended for use in implementation of the\n+      --  standard input-output functions for fixed-point values.\n+\n+      ------------------\n+      -- Machine_Size --\n+      ------------------\n+\n+      Attribute_Machine_Size => True,\n+      --\n+      --  This attribute is identical to the Object_Size attribute. It is\n+      --  provided for compatibility with the DEC attribute of this name.\n+\n+      ----------------------------\n+      -- Max_Interrupt_Priority --\n+      ----------------------------\n+\n+      Attribute_Max_Interrupt_Priority => True,\n+      --\n+      --  Standard'Max_Interrupt_Priority (Standard is the only permissible\n+      --  prefix), provides the value System.Max_Interrupt_Priority, and is\n+      --  intended primarily for constructing this definition in package\n+      --  System (see note above in Default_Bit_Order description}. This\n+      --  is a static attribute.\n+\n+      ------------------\n+      -- Max_Priority --\n+      ------------------\n+\n+      Attribute_Max_Priority => True,\n+      --\n+      --  Standard'Max_Priority (Standard is the only permissible prefix)\n+      --  provides the value System.Max_Priority, and is intended primarily\n+      --  for constructing this definition in package System (see note above\n+      --  in Default_Bit_Order description). This is a static attribute.\n+\n+      -----------------------\n+      -- Maximum_Alignment --\n+      -----------------------\n+\n+      Attribute_Maximum_Alignment => True,\n+      --\n+      --  Standard'Maximum_Alignment (Standard is the only permissible prefix)\n+      --  provides the maximum useful alignment value for the target. This\n+      --  is a static value that can be used to specify the alignment for an\n+      --  object, guaranteeing that it is properly aligned in all cases. The\n+      --  time this is useful is when an external object is imported and its\n+      --  alignment requirements are unknown. This is a static attribute.\n+\n+      --------------------\n+      -- Mechanism_Code --\n+      --------------------\n+\n+      Attribute_Mechanism_Code => True,\n+      --\n+      --  function'Mechanism_Code yeilds an integer code for the mechanism\n+      --  used for the result of function, and subprogram'Mechanism_Code (n)\n+      --  yields the mechanism used for formal parameter number n (a static\n+      --  integer value, 1 = first parameter). The code returned is:\n+      --\n+      --     1 = by copy (value)\n+      --     2 = by reference\n+      --     3 = by descriptor (default descriptor type)\n+      --     4 = by descriptor (UBS  unaligned bit string)\n+      --     5 = by descriptor (UBSB aligned bit string with arbitrary bounds)\n+      --     6 = by descriptor (UBA  unaligned bit array)\n+      --     7 = by descriptor (S    string, also scalar access type parameter)\n+      --     8 = by descriptor (SB   string with arbitrary bounds)\n+      --     9 = by descriptor (A    contiguous array)\n+      --    10 = by descriptor (NCA  non-contiguous array)\n+\n+      --------------------\n+      -- Null_Parameter --\n+      --------------------\n+\n+      Attribute_Null_Parameter => True,\n+      --\n+      --  A reference T'Null_Parameter denotes an (imaginary) object of\n+      --  type or subtype T allocated at (machine) address zero. The\n+      --  attribute is allowed only as the default expression of a formal\n+      --  parameter, or as an actual expression of a subporgram call. In\n+      --  either case, the subprogram must be imported.\n+      --\n+      --  The identity of the object is represented by the address zero\n+      --  in the argument list, independent of the passing mechanism\n+      --  (explicit or default).\n+      --\n+      --  The reason that this capability is needed is that for a record\n+      --  or other composite object passed by reference, there is no other\n+      --  way of specifying that a zero address should be passed.\n+\n+      -----------------\n+      -- Object_Size --\n+      -----------------\n+\n+      Attribute_Object_Size => True,\n+      --\n+      --  Type'Object_Size is the same as Type'Size for all types except\n+      --  fixed-point types and discrete types. For fixed-point types and\n+      --  discrete types, this attribute gives the size used for default\n+      --  allocation of objects and components of the size. See section\n+      --  in Einfo (\"Handling of type'Size values\") for further details.\n+\n+      -------------------------\n+      -- Passed_By_Reference --\n+      -------------------------\n+\n+      Attribute_Passed_By_Reference => True,\n+      --\n+      --  T'Passed_By_Reference for any subtype T returns a boolean value\n+      --  that is true if the type is normally passed by reference and\n+      --  false if the type is normally passed by copy in calls. For scalar\n+      --  types, the result is always False and is static. For non-scalar\n+      --  types, the result is non-static (since it is computed by Gigi).\n+\n+      ------------------\n+      -- Range_Length --\n+      ------------------\n+\n+      Attribute_Range_Length => True,\n+      --\n+      --  T'Range_Length for any discrete type T yields the number of\n+      --  values represented by the subtype (zero for a null range). The\n+      --  result is static for static subtypes. Note that Range_Length\n+      --  applied to the index subtype of a one dimensional array always\n+      --  gives the same result as Range applied to the array itself.\n+      --  The result is of type universal integer.\n+\n+      ------------------\n+      -- Storage_Unit --\n+      ------------------\n+\n+      Attribute_Storage_Unit => True,\n+      --\n+      --  Standard'Storage_Unit (Standard is the only permissible prefix)\n+      --  provides the value System.Storage_Unit, and is intended primarily\n+      --  for constructing this definition in package System (see note above\n+      --  in Default_Bit_Order description). The is a static attribute.\n+\n+      ----------\n+      -- Tick --\n+      ----------\n+\n+      Attribute_Tick => True,\n+      --\n+      --  Standard'Tick (Standard is the only permissible prefix) provides\n+      --  the value System.Tick, and is intended primarily for constructing\n+      --  this definition in package System (see note above in description\n+      --  of Default_Bit_Order). This is a static attribute.\n+\n+      ----------------\n+      -- To_Address --\n+      ----------------\n+\n+      Attribute_To_Address => True,\n+      --\n+      --  System'To_Address (Address is the only permissible prefix)\n+      --  is a function that takes any integer value, and converts it into\n+      --  an address value. The semantics is to first convert the integer\n+      --  value to type Integer_Address according to normal conversion\n+      --  rules, and then to convert this to an address using the same\n+      --  semantics as the System.Storage_Elements.To_Address function.\n+      --  The important difference is that this is a static attribute\n+      --  so it can be used in initializations in preealborate packages.\n+\n+      ----------------\n+      -- Type_Class --\n+      ----------------\n+\n+      Attribute_Type_Class => True,\n+      --\n+      --  T'Type_Class for any type or subtype T yields the value of the\n+      --  type class for the full type of T. If T is a generic formal type,\n+      --  then the value is the value for the corresponding actual subtype.\n+      --  The value of this attribute is of type System.Aux_DEC.Type_Class,\n+      --  which has the following definition:\n+      --\n+      --    type Type_Class is\n+      --      (Type_Class_Enumeration,\n+      --       Type_Class_Integer,\n+      --       Type_Class_Fixed_Point,\n+      --       Type_Class_Floating_Point,\n+      --       Type_Class_Array,\n+      --       Type_Class_Record,\n+      --       Type_Class_Access,\n+      --       Type_Class_Task,\n+      --       Type_Class_Address);\n+      --\n+      --  Protected types yield the value Type_Class_Task, which thus\n+      --  applies to all concurrent types. This attribute is designed to\n+      --  be compatible with the DEC Ada attribute of the same name.\n+      --\n+      --  Note: if pragma Extend_System is used to merge the definitions of\n+      --  Aux_DEC into System, then the type Type_Class can be referenced\n+      --  as an entity within System, as can its enumeration literals.\n+\n+      -----------------\n+      -- UET_Address --\n+      -----------------\n+\n+      Attribute_UET_Address => True,\n+      --\n+      --  Unit'UET_Address, where Unit is a program unit, yields the address\n+      --  of the unit exception table for the specified unit. This is only\n+      --  used in the internal implementation of exception handling. See the\n+      --  implementation of unit Ada.Exceptions for details on its use.\n+\n+      ------------------------------\n+      -- Universal_Literal_String --\n+      ------------------------------\n+\n+      Attribute_Universal_Literal_String => True,\n+      --\n+      --  The prefix of 'Universal_Literal_String must be a named number.\n+      --  The static result is the string consisting of the characters of\n+      --  the number as defined in the original source. This allows the\n+      --  user program to access the actual text of named numbers without\n+      --  intermediate conversions and without the need to enclose the\n+      --  strings in quotes (which would preclude their use as numbers).\n+      --  This is used internally for the construction of values of the\n+      --  floating-point attributes from the file ttypef.ads, but may\n+      --  also be used by user programs.\n+\n+      -------------------------\n+      -- Unrestricted_Access --\n+      -------------------------\n+\n+      Attribute_Unrestricted_Access => True,\n+      --\n+      --  The Unrestricted_Access attribute is similar to Access except that\n+      --  all accessibility and aliased view checks are omitted. This is very\n+      --  much a user-beware attribute. Basically its status is very similar\n+      --  to Address, for which it is a desirable replacement where the value\n+      --  desired is an access type. In other words, its effect is identical\n+      --  to first taking 'Address and then doing an unchecked conversion to\n+      --  a desired access type. Note that in GNAT, but not necessarily in\n+      --  other implementations, the use of static chains for inner level\n+      --  subprograms means that Unrestricted_Access applied to a subprogram\n+      --  yields a value that can be called as long as the subprogram is in\n+      --  scope (normal Ada 95 accessibility rules restrict this usage).\n+\n+      ---------------\n+      -- VADS_Size --\n+      ---------------\n+\n+      Attribute_VADS_Size => True,\n+      --\n+      --  Typ'VADS_Size yields the Size value typically yielded by some\n+      --  Ada 83 compilers. The differences between VADS_Size and Size\n+      --  is that for scalar types for which no Size has been specified,\n+      --  VADS_Size yields the Object_Size rather than the Value_Size.\n+      --  For example, while Natural'Size is typically 31, the value of\n+      --  Natural'VADS_Size is 32. For all other types, Size and VADS_Size\n+      --  yield the same value.\n+\n+      ----------------\n+      -- Value_Size --\n+      ----------------\n+\n+      Attribute_Value_Size => True,\n+      --\n+      --  Type'Value_Size is the number of bits required to represent a\n+      --  value of the given subtype. It is the same as Type'Size, but,\n+      --  unlike Size, may be set for non-first subtypes. See section\n+      --  in Einfo (\"Handling of type'Size values\") for further details.\n+\n+      ---------------\n+      -- Word_Size --\n+      ---------------\n+\n+      Attribute_Word_Size => True,\n+      --\n+      --  Standard'Word_Size (Standard is the only permissible prefix)\n+      --  provides the value System.Word_Size, and is intended primarily\n+      --  for constructing this definition in package System (see note above\n+      --  in Default_Bit_Order description). This is a static attribute.\n+\n+      others => False);\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Analyze_Attribute (N : Node_Id);\n+   --  Performs bottom up semantic analysis of an attribute. Note that the\n+   --  parser has already checked that type returning attributes appear only\n+   --  in appropriate contexts (i.e. in subtype marks, or as prefixes for\n+   --  other attributes).\n+\n+   procedure Resolve_Attribute (N : Node_Id; Typ : Entity_Id);\n+   --  Performs type resolution of attribute. If the attribute yields\n+   --  a universal value, mark its type as that of the context. On\n+   --  the other hand, if the context itself is universal (as in\n+   --  T'Val (T'Pos (X)), mark the type as being the largest type of\n+   --  that class that can be used at run-time. This is correct since\n+   --  either the value gets folded (in which case it doesn't matter\n+   --  what type of the class we give if, since the folding uses universal\n+   --  arithmetic anyway) or it doesn't get folded (in which case it is\n+   --  going to be dealt with at runtime, and the largest type is right).\n+\n+end Sem_Attr;"}, {"sha": "a9326c36384bdf87d7c1f8b3e586f35aa7a6e8b2", "filename": "gcc/ada/sem_case.adb", "status": "added", "additions": 681, "deletions": 0, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,681 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C A S E                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1996-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Sem;      use Sem;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sem_Type; use Sem_Type;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Sinfo;    use Sinfo;\n+with Uintp;    use Uintp;\n+\n+with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n+\n+package body Sem_Case is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   type Sort_Choice_Table_Type is array (Nat range <>) of Choice_Bounds;\n+   --  This new array type is used as the actual table type for sorting\n+   --  discrete choices. The reason for not using Choice_Table_Type, is that\n+   --  in Sort_Choice_Table_Type we reserve entry 0 for the sorting algortim\n+   --  (this is not absolutely necessary but it makes the code more\n+   --  efficient).\n+\n+   procedure Check_Choices\n+     (Choice_Table   : in out Sort_Choice_Table_Type;\n+      Bounds_Type    : Entity_Id;\n+      Others_Present : Boolean;\n+      Msg_Sloc       : Source_Ptr);\n+   --  This is the procedure which verifies that a set of case statement,\n+   --  array aggregate or record variant choices has no duplicates, and\n+   --  covers the range specified by Bounds_Type. Choice_Table contains the\n+   --  discrete choices to check. These must start at position 1.\n+   --  Furthermore Choice_Table (0) must exist. This element is used by\n+   --  the sorting algorithm as a temporary. Others_Present is a flag\n+   --  indicating whether or not an Others choice is present. Finally\n+   --  Msg_Sloc gives the source location of the construct containing the\n+   --  choices in the Choice_Table.\n+\n+   function Choice_Image (Value : Uint; Ctype : Entity_Id) return Name_Id;\n+   --  Given a Pos value of enumeration type Ctype, returns the name\n+   --  ID of an appropriate string to be used in error message output.\n+\n+   -------------------\n+   -- Check_Choices --\n+   -------------------\n+\n+   procedure Check_Choices\n+     (Choice_Table   : in out Sort_Choice_Table_Type;\n+      Bounds_Type    : Entity_Id;\n+      Others_Present : Boolean;\n+      Msg_Sloc       : Source_Ptr)\n+   is\n+\n+      function Lt_Choice (C1, C2 : Natural) return Boolean;\n+      --  Comparison routine for comparing Choice_Table entries.\n+      --  Use the lower bound of each Choice as the key.\n+\n+      procedure Move_Choice (From : Natural; To : Natural);\n+      --  Move routine for sorting the Choice_Table.\n+\n+      procedure Issue_Msg (Value1 : Node_Id; Value2 : Node_Id);\n+      procedure Issue_Msg (Value1 : Node_Id; Value2 : Uint);\n+      procedure Issue_Msg (Value1 : Uint;    Value2 : Node_Id);\n+      procedure Issue_Msg (Value1 : Uint;    Value2 : Uint);\n+      --  Issue an error message indicating that there are missing choices,\n+      --  followed by the image of the missing choices themselves which lie\n+      --  between Value1 and Value2 inclusive.\n+\n+      ---------------\n+      -- Issue_Msg --\n+      ---------------\n+\n+      procedure Issue_Msg (Value1 : Node_Id; Value2 : Node_Id) is\n+      begin\n+         Issue_Msg (Expr_Value (Value1), Expr_Value (Value2));\n+      end Issue_Msg;\n+\n+      procedure Issue_Msg (Value1 : Node_Id; Value2 : Uint) is\n+      begin\n+         Issue_Msg (Expr_Value (Value1), Value2);\n+      end Issue_Msg;\n+\n+      procedure Issue_Msg (Value1 : Uint; Value2 : Node_Id) is\n+      begin\n+         Issue_Msg (Value1, Expr_Value (Value2));\n+      end Issue_Msg;\n+\n+      procedure Issue_Msg (Value1 : Uint; Value2 : Uint) is\n+      begin\n+         --  In some situations, we call this with a null range, and\n+         --  obviously we don't want to complain in this case!\n+\n+         if Value1 > Value2 then\n+            return;\n+         end if;\n+\n+         --  Case of only one value that is missing\n+\n+         if Value1 = Value2 then\n+            if Is_Integer_Type (Bounds_Type) then\n+               Error_Msg_Uint_1 := Value1;\n+               Error_Msg (\"missing case value: ^!\", Msg_Sloc);\n+            else\n+               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n+               Error_Msg (\"missing case value: %!\", Msg_Sloc);\n+            end if;\n+\n+         --  More than one choice value, so print range of values\n+\n+         else\n+            if Is_Integer_Type (Bounds_Type) then\n+               Error_Msg_Uint_1 := Value1;\n+               Error_Msg_Uint_2 := Value2;\n+               Error_Msg (\"missing case values: ^ .. ^!\", Msg_Sloc);\n+            else\n+               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n+               Error_Msg_Name_2 := Choice_Image (Value2, Bounds_Type);\n+               Error_Msg (\"missing case values: % .. %!\", Msg_Sloc);\n+            end if;\n+         end if;\n+      end Issue_Msg;\n+\n+      ---------------\n+      -- Lt_Choice --\n+      ---------------\n+\n+      function Lt_Choice (C1, C2 : Natural) return Boolean is\n+      begin\n+         return\n+           Expr_Value (Choice_Table (Nat (C1)).Lo)\n+           <= Expr_Value (Choice_Table (Nat (C2)).Lo);\n+      end Lt_Choice;\n+\n+      -----------------\n+      -- Move_Choice --\n+      -----------------\n+\n+      procedure Move_Choice (From : Natural; To : Natural) is\n+      begin\n+         Choice_Table (Nat (To)) := Choice_Table (Nat (From));\n+      end Move_Choice;\n+\n+      --  Variables local to Check_Choices\n+\n+      Choice      : Node_Id;\n+      Bounds_Lo   : constant Node_Id := Type_Low_Bound (Bounds_Type);\n+      Bounds_Hi   : constant Node_Id := Type_High_Bound (Bounds_Type);\n+\n+      Prev_Choice : Node_Id;\n+\n+      Hi       : Uint;\n+      Lo       : Uint;\n+      Prev_Hi  : Uint;\n+\n+   --  Start processing for Check_Choices\n+\n+   begin\n+\n+      --  Choice_Table must start at 0 which is an unused location used\n+      --  by the sorting algorithm. However the first valid position for\n+      --  a discrete choice is 1.\n+\n+      pragma Assert (Choice_Table'First = 0);\n+\n+      if Choice_Table'Last = 0 then\n+         if not Others_Present then\n+            Issue_Msg (Bounds_Lo, Bounds_Hi);\n+         end if;\n+         return;\n+      end if;\n+\n+      Sort\n+        (Positive (Choice_Table'Last),\n+         Move_Choice'Unrestricted_Access,\n+         Lt_Choice'Unrestricted_Access);\n+\n+      Lo      := Expr_Value (Choice_Table (1).Lo);\n+      Hi      := Expr_Value (Choice_Table (1).Hi);\n+      Prev_Hi := Hi;\n+\n+      if not Others_Present and then Expr_Value (Bounds_Lo) < Lo then\n+         Issue_Msg (Bounds_Lo, Lo - 1);\n+      end if;\n+\n+      for J in 2 .. Choice_Table'Last loop\n+         Lo := Expr_Value (Choice_Table (J).Lo);\n+         Hi := Expr_Value (Choice_Table (J).Hi);\n+\n+         if Lo <= Prev_Hi then\n+            Prev_Choice := Choice_Table (J - 1).Node;\n+            Choice      := Choice_Table (J).Node;\n+\n+            if Sloc (Prev_Choice) <= Sloc (Choice) then\n+               Error_Msg_Sloc := Sloc (Prev_Choice);\n+               Error_Msg_N (\"duplication of choice value#\", Choice);\n+            else\n+               Error_Msg_Sloc := Sloc (Choice);\n+               Error_Msg_N (\"duplication of choice value#\", Prev_Choice);\n+            end if;\n+\n+         elsif not Others_Present and then Lo /= Prev_Hi + 1 then\n+            Issue_Msg (Prev_Hi + 1, Lo - 1);\n+         end if;\n+\n+         Prev_Hi := Hi;\n+      end loop;\n+\n+      if not Others_Present and then Expr_Value (Bounds_Hi) > Hi then\n+         Issue_Msg (Hi + 1, Bounds_Hi);\n+      end if;\n+   end Check_Choices;\n+\n+   ------------------\n+   -- Choice_Image --\n+   ------------------\n+\n+   function Choice_Image (Value : Uint; Ctype : Entity_Id) return Name_Id is\n+      Rtp : constant Entity_Id := Root_Type (Ctype);\n+      Lit : Entity_Id;\n+      C   : Int;\n+\n+   begin\n+      --  For character, or wide character. If we are in 7-bit ASCII graphic\n+      --  range, then build and return appropriate character literal name\n+\n+      if Rtp = Standard_Character\n+        or else Rtp = Standard_Wide_Character\n+      then\n+         C := UI_To_Int (Value);\n+\n+         if C in 16#20# .. 16#7E# then\n+            Name_Buffer (1) := ''';\n+            Name_Buffer (2) := Character'Val (C);\n+            Name_Buffer (3) := ''';\n+            Name_Len := 3;\n+            return Name_Find;\n+         end if;\n+\n+      --  For user defined enumeration type, find enum/char literal\n+\n+      else\n+         Lit := First_Literal (Rtp);\n+\n+         for J in 1 .. UI_To_Int (Value) loop\n+            Next_Literal (Lit);\n+         end loop;\n+\n+         --  If enumeration literal, just return its value\n+\n+         if Nkind (Lit) = N_Defining_Identifier then\n+            return Chars (Lit);\n+\n+         --  For character literal, get the name and use it if it is\n+         --  for a 7-bit ASCII graphic character in 16#20#..16#7E#.\n+\n+         else\n+            Get_Decoded_Name_String (Chars (Lit));\n+\n+            if Name_Len = 3\n+              and then Name_Buffer (2) in\n+                Character'Val (16#20#) .. Character'Val (16#7E#)\n+            then\n+               return Chars (Lit);\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  If we fall through, we have a character literal which is not in\n+      --  the 7-bit ASCII graphic set. For such cases, we construct the\n+      --  name \"type'val(nnn)\" where type is the choice type, and nnn is\n+      --  the pos value passed as an argument to Choice_Image.\n+\n+      Get_Name_String (Chars (First_Subtype (Ctype)));\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := ''';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := 'v';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := 'a';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := 'l';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := '(';\n+\n+      UI_Image (Value);\n+\n+      for J in 1 .. UI_Image_Length loop\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := UI_Image_Buffer (J);\n+      end loop;\n+\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := ')';\n+      return Name_Find;\n+   end Choice_Image;\n+\n+   -----------\n+   -- No_OP --\n+   -----------\n+\n+   procedure No_OP (C : Node_Id) is\n+   begin\n+      null;\n+   end No_OP;\n+\n+   --------------------------------\n+   -- Generic_Choices_Processing --\n+   --------------------------------\n+\n+   package body Generic_Choices_Processing is\n+\n+      ---------------------\n+      -- Analyze_Choices --\n+      ---------------------\n+\n+      procedure Analyze_Choices\n+        (N              : Node_Id;\n+         Subtyp         : Entity_Id;\n+         Choice_Table   : in out Choice_Table_Type;\n+         Last_Choice    : out Nat;\n+         Raises_CE      : out Boolean;\n+         Others_Present : out Boolean)\n+      is\n+\n+         Nb_Choices        : constant Nat := Choice_Table'Length;\n+         Sort_Choice_Table : Sort_Choice_Table_Type (0 .. Nb_Choices);\n+\n+         Choice_Type : constant Entity_Id := Base_Type (Subtyp);\n+         --  The actual type against which the discrete choices are\n+         --  resolved.  Note that this type is always the base type not the\n+         --  subtype of the ruling expression, index or discriminant.\n+\n+         Bounds_Type : Entity_Id;\n+         --  The type from which are derived the bounds of the values\n+         --  covered by th discrete choices (see 3.8.1 (4)). If a discrete\n+         --  choice specifies a value outside of these bounds we have an error.\n+\n+         Bounds_Lo   : Uint;\n+         Bounds_Hi   : Uint;\n+         --  The actual bounds of the above type.\n+\n+         Expected_Type : Entity_Id;\n+         --  The expected type of each choice. Equal to Choice_Type, except\n+         --  if the expression is universal,  in which case the choices can\n+         --  be of any integer type.\n+\n+         procedure Check (Choice : Node_Id; Lo, Hi : Node_Id);\n+         --  Checks the validity of the bounds of a choice.  When the bounds\n+         --  are static and no error occurred the bounds are entered into\n+         --  the choices table so that they can be sorted later on.\n+\n+         -----------\n+         -- Check --\n+         -----------\n+\n+         procedure Check (Choice : Node_Id; Lo, Hi : Node_Id) is\n+            Lo_Val : Uint;\n+            Hi_Val : Uint;\n+\n+         begin\n+            --  First check if an error was already detected on either bounds\n+\n+            if Etype (Lo) = Any_Type or else Etype (Hi) = Any_Type then\n+               return;\n+\n+            --  Do not insert non static choices in the table to be sorted\n+\n+            elsif not Is_Static_Expression (Lo)\n+              or else not Is_Static_Expression (Hi)\n+            then\n+               Process_Non_Static_Choice (Choice);\n+               return;\n+\n+            --  Ignore range which raise constraint error\n+\n+            elsif Raises_Constraint_Error (Lo)\n+              or else Raises_Constraint_Error (Hi)\n+            then\n+               Raises_CE := True;\n+               return;\n+\n+            --  Otherwise we have an OK static choice\n+\n+            else\n+               Lo_Val := Expr_Value (Lo);\n+               Hi_Val := Expr_Value (Hi);\n+\n+               --  Do not insert null ranges in the choices table\n+\n+               if Lo_Val > Hi_Val then\n+                  Process_Empty_Choice (Choice);\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  Check for bound out of range.\n+\n+            if Lo_Val < Bounds_Lo then\n+               if Is_Integer_Type (Bounds_Type) then\n+                  Error_Msg_Uint_1 := Bounds_Lo;\n+                  Error_Msg_N (\"minimum allowed choice value is^\", Lo);\n+               else\n+                  Error_Msg_Name_1 := Choice_Image (Bounds_Lo, Bounds_Type);\n+                  Error_Msg_N (\"minimum allowed choice value is%\", Lo);\n+               end if;\n+\n+            elsif Hi_Val > Bounds_Hi then\n+               if Is_Integer_Type (Bounds_Type) then\n+                  Error_Msg_Uint_1 := Bounds_Hi;\n+                  Error_Msg_N (\"maximum allowed choice value is^\", Hi);\n+               else\n+                  Error_Msg_Name_1 := Choice_Image (Bounds_Hi, Bounds_Type);\n+                  Error_Msg_N (\"maximum allowed choice value is%\", Hi);\n+               end if;\n+            end if;\n+\n+            --  We still store the bounds in the table, even if they are out\n+            --  of range, since this may prevent unnecessary cascaded errors\n+            --  for values that are covered by such an excessive range.\n+\n+            Last_Choice := Last_Choice + 1;\n+            Sort_Choice_Table (Last_Choice).Lo   := Lo;\n+            Sort_Choice_Table (Last_Choice).Hi   := Hi;\n+            Sort_Choice_Table (Last_Choice).Node := Choice;\n+         end Check;\n+\n+         --  Variables local to Analyze_Choices\n+\n+         Alt : Node_Id;\n+         --  A case statement alternative, an array aggregate component\n+         --  association or a variant in a record type declaration\n+\n+         Choice : Node_Id;\n+         Kind   : Node_Kind;\n+         --  The node kind of the current Choice.\n+\n+         E : Entity_Id;\n+\n+      --  Start of processing for Analyze_Choices\n+\n+      begin\n+         Last_Choice    := 0;\n+         Raises_CE      := False;\n+         Others_Present := False;\n+\n+         --  If Subtyp is not a static subtype Ada 95 requires then we use\n+         --  the bounds of its base type to determine the values covered by\n+         --  the discrete choices.\n+\n+         if Is_OK_Static_Subtype (Subtyp) then\n+            Bounds_Type := Subtyp;\n+         else\n+            Bounds_Type := Choice_Type;\n+         end if;\n+\n+         --  Obtain static bounds of type, unless this is a generic formal\n+         --  discrete type for which all choices will be non-static.\n+\n+         if not Is_Generic_Type (Root_Type (Bounds_Type))\n+           or else Ekind (Bounds_Type) /= E_Enumeration_Type\n+         then\n+            Bounds_Lo := Expr_Value (Type_Low_Bound (Bounds_Type));\n+            Bounds_Hi := Expr_Value (Type_High_Bound (Bounds_Type));\n+         end if;\n+\n+         if Choice_Type = Universal_Integer then\n+            Expected_Type := Any_Integer;\n+         else\n+            Expected_Type := Choice_Type;\n+         end if;\n+\n+         --  Now loop through the case statement alternatives or array\n+         --  aggregate component associations or record variants.\n+\n+         Alt := First (Get_Alternatives (N));\n+         while Present (Alt) loop\n+\n+            --  If pragma, just analyze it\n+\n+            if Nkind (Alt) = N_Pragma then\n+               Analyze (Alt);\n+\n+            --  Otherwise check each choice against its base type\n+\n+            else\n+               Choice := First (Get_Choices (Alt));\n+\n+               while Present (Choice) loop\n+                  Analyze (Choice);\n+                  Kind := Nkind (Choice);\n+\n+                  --  Choice is a Range\n+\n+                  if Kind = N_Range\n+                    or else (Kind = N_Attribute_Reference\n+                             and then Attribute_Name (Choice) = Name_Range)\n+                  then\n+                     Resolve (Choice, Expected_Type);\n+                     Check (Choice, Low_Bound (Choice), High_Bound (Choice));\n+\n+                  --  Choice is a subtype name\n+\n+                  elsif Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                  then\n+                     if not Covers (Expected_Type, Etype (Choice)) then\n+                        Wrong_Type (Choice, Choice_Type);\n+\n+                     else\n+                        E := Entity (Choice);\n+\n+                        if not Is_Static_Subtype (E) then\n+                           Process_Non_Static_Choice (Choice);\n+                        else\n+                           Check\n+                             (Choice, Type_Low_Bound (E), Type_High_Bound (E));\n+                        end if;\n+                     end if;\n+\n+                  --  Choice is a subtype indication\n+\n+                  elsif Kind = N_Subtype_Indication then\n+                     Resolve_Discrete_Subtype_Indication\n+                       (Choice, Expected_Type);\n+\n+                     if Etype (Choice) /= Any_Type then\n+                        declare\n+                           C : constant Node_Id := Constraint (Choice);\n+                           R : constant Node_Id := Range_Expression (C);\n+                           L : constant Node_Id := Low_Bound (R);\n+                           H : constant Node_Id := High_Bound (R);\n+\n+                        begin\n+                           E := Entity (Subtype_Mark (Choice));\n+\n+                           if not Is_Static_Subtype (E) then\n+                              Process_Non_Static_Choice (Choice);\n+\n+                           else\n+                              if Is_OK_Static_Expression (L)\n+                                and then Is_OK_Static_Expression (H)\n+                              then\n+                                 if Expr_Value (L) > Expr_Value (H) then\n+                                    Process_Empty_Choice (Choice);\n+                                 else\n+                                    if Is_Out_Of_Range (L, E) then\n+                                       Apply_Compile_Time_Constraint_Error\n+                                         (L, \"static value out of range\");\n+                                    end if;\n+\n+                                    if Is_Out_Of_Range (H, E) then\n+                                       Apply_Compile_Time_Constraint_Error\n+                                         (H, \"static value out of range\");\n+                                    end if;\n+                                 end if;\n+                              end if;\n+\n+                              Check (Choice, L, H);\n+                           end if;\n+                        end;\n+                     end if;\n+\n+                  --  The others choice is only allowed for the last\n+                  --  alternative and as its only choice.\n+\n+                  elsif Kind = N_Others_Choice then\n+                     if not (Choice = First (Get_Choices (Alt))\n+                             and then Choice = Last (Get_Choices (Alt))\n+                             and then Alt = Last (Get_Alternatives (N)))\n+                     then\n+                        Error_Msg_N\n+                          (\"the choice OTHERS must appear alone and last\",\n+                           Choice);\n+                        return;\n+                     end if;\n+\n+                     Others_Present := True;\n+\n+                  --  Only other possibility is an expression\n+\n+                  else\n+                     Resolve (Choice, Expected_Type);\n+                     Check (Choice, Choice, Choice);\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               Process_Associated_Node (Alt);\n+            end if;\n+\n+            Next (Alt);\n+         end loop;\n+\n+         Check_Choices\n+           (Sort_Choice_Table (0 .. Last_Choice),\n+            Bounds_Type,\n+            Others_Present or else (Choice_Type = Universal_Integer),\n+            Sloc (N));\n+\n+         --  Now copy the sorted discrete choices\n+\n+         for J in 1 .. Last_Choice loop\n+            Choice_Table (Choice_Table'First - 1 + J) := Sort_Choice_Table (J);\n+         end loop;\n+\n+      end Analyze_Choices;\n+\n+      -----------------------\n+      -- Number_Of_Choices --\n+      -----------------------\n+\n+      function Number_Of_Choices (N : Node_Id) return Nat is\n+         Alt : Node_Id;\n+         --  A case statement alternative, an array aggregate component\n+         --  association or a record variant.\n+\n+         Choice : Node_Id;\n+         Count  : Nat := 0;\n+\n+      begin\n+         if not Present (Get_Alternatives (N)) then\n+            return 0;\n+         end if;\n+\n+         Alt := First_Non_Pragma (Get_Alternatives (N));\n+         while Present (Alt) loop\n+\n+            Choice := First (Get_Choices (Alt));\n+            while Present (Choice) loop\n+               if Nkind (Choice) /= N_Others_Choice then\n+                  Count := Count + 1;\n+               end if;\n+\n+               Next (Choice);\n+            end loop;\n+\n+            Next_Non_Pragma (Alt);\n+         end loop;\n+\n+         return Count;\n+      end Number_Of_Choices;\n+\n+   end Generic_Choices_Processing;\n+\n+end Sem_Case;"}, {"sha": "192b6b1573ffc3dba676d8d6706d8e6434938d23", "filename": "gcc/ada/sem_case.ads", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_case.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_case.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,122 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C A S E                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+--            Copyright (C) 1996 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+--  Package containing all the routines to proces a list of discrete choices.\n+--  Such lists can occur in 3 different constructs: case statements, array\n+--  aggregates and record variants. We have factorized what used to be 3 very\n+--  similar sets of routines here. If you didn't figure it out already Choi\n+--  in the package name stands for Choices.\n+\n+package Sem_Case is\n+\n+   type Choice_Bounds is record\n+     Lo   : Node_Id;\n+     Hi   : Node_Id;\n+     Node : Node_Id;\n+   end record;\n+\n+   type Choice_Table_Type is array (Pos range <>) of Choice_Bounds;\n+   --  Table type used to sort the choices present in a case statement,\n+   --  array aggregate or record variant.\n+\n+   procedure No_OP (C : Node_Id);\n+   --  The no-operation routine. Does absolutely nothing. Can be used\n+   --  in the following generic for the parameter Proces_Empty_Choice.\n+\n+   generic\n+      with function Get_Alternatives (N : Node_Id) return List_Id;\n+      --  Function needed to get to the actual list of case statement\n+      --  alternatives, or array aggregate component associations or\n+      --  record variants from which we can then access the actual lists\n+      --  of discrete choices. N is the node for the original construct\n+      --  ie a case statement, an array aggregate or a record variant.\n+\n+      with function Get_Choices (A : Node_Id) return List_Id;\n+      --  Given a case statement alternative, array aggregate component\n+      --  association or record variant A we need different access functions\n+      --  to get to the actual list of discrete choices.\n+\n+      with procedure Process_Empty_Choice (Choice : Node_Id);\n+      --  Processing to carry out for an empty Choice.\n+\n+      with procedure Process_Non_Static_Choice (Choice : Node_Id);\n+      --  Processing to carry out for a non static Choice.\n+\n+      with procedure Process_Associated_Node (A : Node_Id);\n+      --  Associated to each case alternative, aggregate component\n+      --  association or record variant A there is a node or list of nodes\n+      --  that need semantic processing. This routine implements that\n+      --  processing.\n+\n+   package Generic_Choices_Processing is\n+\n+      function Number_Of_Choices (N : Node_Id) return Nat;\n+      --  Iterates through the choices of N, (N can be a case statement,\n+      --  array aggregate or record variant), counting all the Choice nodes\n+      --  except for the Others choice.\n+\n+      procedure Analyze_Choices\n+        (N              : Node_Id;\n+         Subtyp         : Entity_Id;\n+         Choice_Table   : in out Choice_Table_Type;\n+         Last_Choice    : out Nat;\n+         Raises_CE      : out Boolean;\n+         Others_Present : out Boolean);\n+      --  From a case statement, array aggregate or record variant N, this\n+      --  routine analyzes the corresponding list of discrete choices.\n+      --  Subtyp is the subtype of the discrete choices. The type against\n+      --  which the discrete choices must be resolved is its base type.\n+      --\n+      --  On entry Choice_Table must be big enough to contain all the\n+      --  discrete choices encountered.\n+      --\n+      --  On exit Choice_Table contains all the static and non empty\n+      --  discrete choices in sorted order. Last_Choice gives the position\n+      --  of the last valid choice in Choice_Table, Choice_Table'First\n+      --  contains the first. We can have Last_Choice < Choice_Table'Last\n+      --  for one (or several) of the following reasons:\n+      --\n+      --    (a) The list of choices contained a non static choice\n+      --\n+      --    (b) The list of choices contained an empty choice\n+      --        (something like \"1 .. 0 => \")\n+      --\n+      --    (c) One of the bounds of a discrete choice contains an\n+      --        error or raises constraint error.\n+      --\n+      --  In one of the bounds of a discrete choice raises a constraint\n+      --  error the flag Raise_CE is set.\n+      --\n+      --  Finally Others_Present is set to True if an Others choice is\n+      --  present in the list of choices.\n+\n+   end Generic_Choices_Processing;\n+\n+end Sem_Case;"}, {"sha": "29c48a5f1abe80791bed778c4eea7ce73e8eab3b", "filename": "gcc/ada/sem_cat.adb", "status": "added", "additions": 1804, "deletions": 0, "changes": 1804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1804 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C A T                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.57 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Exp_Tss;  use Exp_Tss;\n+with Fname;    use Fname;\n+with Lib;      use Lib;\n+with Nlists;   use Nlists;\n+with Sem;      use Sem;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+\n+package body Sem_Cat is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Check_Categorization_Dependencies\n+     (Unit_Entity     : Entity_Id;\n+      Depended_Entity : Entity_Id;\n+      Info_Node       : Node_Id;\n+      Is_Subunit      : Boolean);\n+   --  This procedure checks that the categorization of a lib unit and that\n+   --  of the depended unit satisfy dependency restrictions.\n+   --  The depended_entity can be the entity in a with_clause item, in which\n+   --  case Info_Node denotes that item. The depended_entity can also be the\n+   --  parent unit of a child unit, in which case Info_Node is the declaration\n+   --  of the child unit.  The error message is posted on Info_Node, and is\n+   --  specialized if Is_Subunit is true.\n+\n+   procedure Check_Non_Static_Default_Expr\n+     (Type_Def : Node_Id;\n+      Obj_Decl : Node_Id);\n+   --  Iterate through the component list of a record definition, check\n+   --  that no component is declared with a nonstatic default value.\n+   --  If a nonstatic default exists, report an error on Obj_Decl.\n+\n+   --  Iterate through the component list of a record definition, check\n+   --  that no component is declared with a non-static default value.\n+\n+   function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean;\n+   --  Return True if the entity or one of its subcomponent is an access\n+   --  type which does not have user-defined Read and Write attribute.\n+\n+   function In_RCI_Declaration (N : Node_Id) return Boolean;\n+   --  Determines if a declaration is  within the visible part of  a Remote\n+   --  Call Interface compilation unit, for semantic checking purposes only,\n+   --  (returns false within an instance and within the package body).\n+\n+   function In_RT_Declaration return Boolean;\n+   --  Determines if current scope is within a Remote Types compilation unit,\n+   --  for semantic checking purposes.\n+\n+   function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean;\n+   --  Returns true if the entity is a non-remote access type\n+\n+   function In_Shared_Passive_Unit return Boolean;\n+   --  Determines if current scope is within a Shared Passive compilation unit\n+\n+   function Static_Discriminant_Expr (L : List_Id) return Boolean;\n+   --  Iterate through the list of discriminants to check if any of them\n+   --  contains non-static default expression, which is a violation in\n+   --  a preelaborated library unit.\n+\n+   procedure Validate_Remote_Access_Object_Type_Declaration (T : Entity_Id);\n+   --  Check validity of declaration if RCI unit. It should not contain\n+   --  the declaration of an access-to-object type unless it is a\n+   --  general access type that designates a class-wide limited\n+   --  private type. There are also constraints about the primitive\n+   --  subprograms of the class-wide type. RM E.2 (9, 13, 14)\n+\n+   function Is_Recursively_Limited_Private (E : Entity_Id) return Boolean;\n+   --  Return True if E is a limited private type, or if E is a private\n+   --  extension of a type whose parent verifies this property (hence the\n+   --  recursive keyword).\n+\n+   ---------------------------------------\n+   -- Check_Categorization_Dependencies --\n+   ---------------------------------------\n+\n+   procedure Check_Categorization_Dependencies\n+     (Unit_Entity     : Entity_Id;\n+      Depended_Entity : Entity_Id;\n+      Info_Node       : Node_Id;\n+      Is_Subunit      : Boolean)\n+   is\n+      N                  : Node_Id := Info_Node;\n+\n+      type Categorization is\n+         (Pure, Shared_Passive, Remote_Types,\n+           Remote_Call_Interface, Pre_Elaborated, Normal);\n+\n+      Unit_Category : Categorization;\n+      With_Category : Categorization;\n+\n+      function Get_Categorization (E : Entity_Id) return Categorization;\n+      --  Check categorization flags from entity, and return in the form\n+      --  of a corresponding enumeration value.\n+\n+      function Get_Categorization (E : Entity_Id) return Categorization is\n+      begin\n+         if Is_Preelaborated (E) then\n+            return Pre_Elaborated;\n+         elsif Is_Pure (E) then\n+            return Pure;\n+         elsif Is_Shared_Passive (E) then\n+            return Shared_Passive;\n+         elsif Is_Remote_Types (E) then\n+            return Remote_Types;\n+         elsif Is_Remote_Call_Interface (E) then\n+            return Remote_Call_Interface;\n+         else\n+            return Normal;\n+         end if;\n+      end Get_Categorization;\n+\n+   --  Start of processing for Check_Categorization_Dependencies\n+\n+   begin\n+      --  Intrinsic subprograms are preelaborated, so do not impose any\n+      --  categorization dependencies.\n+\n+      if Is_Intrinsic_Subprogram (Depended_Entity) then\n+         return;\n+      end if;\n+\n+      Unit_Category := Get_Categorization (Unit_Entity);\n+      With_Category := Get_Categorization (Depended_Entity);\n+\n+      if With_Category > Unit_Category then\n+\n+         if (Unit_Category = Remote_Types\n+                 or else Unit_Category = Remote_Call_Interface)\n+           and then In_Package_Body (Unit_Entity)\n+         then\n+            null;\n+\n+         elsif Is_Subunit then\n+            Error_Msg_NE (\"subunit cannot depend on&\"\n+              & \" (parent has wrong categorization)\", N, Depended_Entity);\n+         else\n+            Error_Msg_NE (\"current unit cannot depend on&\"\n+              & \" (wrong categorization)\", N, Depended_Entity);\n+         end if;\n+      end if;\n+\n+   end Check_Categorization_Dependencies;\n+\n+   -----------------------------------\n+   -- Check_Non_Static_Default_Expr --\n+   -----------------------------------\n+\n+   procedure Check_Non_Static_Default_Expr\n+     (Type_Def : Node_Id;\n+      Obj_Decl : Node_Id)\n+   is\n+      Recdef         : Node_Id;\n+      Component_Decl : Node_Id;\n+\n+   begin\n+      if Nkind (Type_Def) = N_Derived_Type_Definition then\n+         Recdef := Record_Extension_Part (Type_Def);\n+\n+         if No (Recdef) then\n+            return;\n+         end if;\n+\n+      else\n+         Recdef := Type_Def;\n+      end if;\n+\n+      --  Check that component declarations do not involve:\n+\n+      --    a. a non-static default expression, where the object is\n+      --       declared to be default initialized.\n+\n+      --    b. a dynamic Itype (discriminants and constraints)\n+\n+      if Null_Present (Recdef) then\n+         return;\n+      else\n+         Component_Decl := First (Component_Items (Component_List (Recdef)));\n+      end if;\n+\n+      while Present (Component_Decl)\n+        and then Nkind (Component_Decl) = N_Component_Declaration\n+      loop\n+         if Present (Expression (Component_Decl))\n+           and then Nkind (Expression (Component_Decl)) /= N_Null\n+           and then not Is_Static_Expression (Expression (Component_Decl))\n+         then\n+            Error_Msg_Sloc := Sloc (Component_Decl);\n+            Error_Msg_N\n+              (\"object in preelaborated unit has nonstatic default#\",\n+               Obj_Decl);\n+\n+         --  Fix this later ???\n+\n+         --  elsif Has_Dynamic_Itype (Component_Decl) then\n+         --     Error_Msg_N\n+         --       (\"dynamic type discriminant,\" &\n+         --        \" constraint in preelaborated unit\",\n+         --        Component_Decl);\n+         end if;\n+\n+         Next (Component_Decl);\n+      end loop;\n+   end Check_Non_Static_Default_Expr;\n+\n+   ---------------------------\n+   -- In_Preelaborated_Unit --\n+   ---------------------------\n+\n+   function In_Preelaborated_Unit return Boolean is\n+      Unit_Entity : constant Entity_Id := Current_Scope;\n+      Unit_Kind   : constant Node_Kind :=\n+                      Nkind (Unit (Cunit (Current_Sem_Unit)));\n+\n+   begin\n+      --  There are no constraints on body of remote_call_interface or\n+      --  remote_types packages..\n+\n+      return (Unit_Entity /= Standard_Standard)\n+        and then (Is_Preelaborated (Unit_Entity)\n+                    or else Is_Pure (Unit_Entity)\n+                    or else Is_Shared_Passive (Unit_Entity)\n+                    or else\n+                      ((Is_Remote_Types (Unit_Entity)\n+                               or else Is_Remote_Call_Interface (Unit_Entity))\n+                         and then Ekind (Unit_Entity) = E_Package\n+                         and then Unit_Kind /= N_Package_Body\n+                         and then not In_Package_Body (Unit_Entity)\n+                         and then not In_Instance));\n+   end In_Preelaborated_Unit;\n+\n+   ------------------\n+   -- In_Pure_Unit --\n+   ------------------\n+\n+   function In_Pure_Unit return Boolean is\n+   begin\n+      return Is_Pure (Current_Scope);\n+   end In_Pure_Unit;\n+\n+   ------------------------\n+   -- In_RCI_Declaration --\n+   ------------------------\n+\n+   function In_RCI_Declaration (N : Node_Id) return Boolean is\n+      Unit_Entity : constant Entity_Id := Current_Scope;\n+      Unit_Kind   : constant Node_Kind :=\n+                      Nkind (Unit (Cunit (Current_Sem_Unit)));\n+\n+   begin\n+      --  There are no restrictions on the private part or body\n+      --  of an RCI unit.\n+\n+      return Is_Remote_Call_Interface (Unit_Entity)\n+        and then (Ekind (Unit_Entity) = E_Package\n+                  or else Ekind (Unit_Entity) = E_Generic_Package)\n+        and then Unit_Kind /= N_Package_Body\n+        and then List_Containing (N) =\n+                  Visible_Declarations\n+                    (Specification (Unit_Declaration_Node (Unit_Entity)))\n+        and then not In_Package_Body (Unit_Entity)\n+        and then not In_Instance;\n+   end In_RCI_Declaration;\n+\n+   -----------------------\n+   -- In_RT_Declaration --\n+   -----------------------\n+\n+   function In_RT_Declaration return Boolean is\n+      Unit_Entity : constant Entity_Id := Current_Scope;\n+      Unit_Kind   : constant Node_Kind :=\n+                      Nkind (Unit (Cunit (Current_Sem_Unit)));\n+\n+   begin\n+      --  There are no restrictions on the body of a Remote Types unit.\n+\n+      return Is_Remote_Types (Unit_Entity)\n+        and then (Ekind (Unit_Entity) = E_Package\n+                   or else Ekind (Unit_Entity) = E_Generic_Package)\n+        and then Unit_Kind /= N_Package_Body\n+        and then not In_Package_Body (Unit_Entity)\n+        and then not In_Instance;\n+   end In_RT_Declaration;\n+\n+   ----------------------------\n+   -- In_Shared_Passive_Unit --\n+   ----------------------------\n+\n+   function In_Shared_Passive_Unit return Boolean is\n+      Unit_Entity : constant Entity_Id := Current_Scope;\n+\n+   begin\n+      return Is_Shared_Passive (Unit_Entity);\n+   end In_Shared_Passive_Unit;\n+\n+   ---------------------------------------\n+   -- In_Subprogram_Task_Protected_Unit --\n+   ---------------------------------------\n+\n+   function In_Subprogram_Task_Protected_Unit return Boolean is\n+      E : Entity_Id;\n+      K : Entity_Kind;\n+\n+   begin\n+      --  The following is to verify that a declaration is inside\n+      --  subprogram, generic subprogram, task unit, protected unit.\n+      --  Used to validate if a lib. unit is Pure. RM 10.2.1(16).\n+\n+      --  Use scope chain to check successively outer scopes\n+\n+      E := Current_Scope;\n+      loop\n+         K := Ekind (E);\n+\n+         if        K = E_Procedure\n+           or else K = E_Function\n+           or else K = E_Generic_Procedure\n+           or else K = E_Generic_Function\n+           or else K = E_Task_Type\n+           or else K = E_Task_Subtype\n+           or else K = E_Protected_Type\n+           or else K = E_Protected_Subtype\n+         then\n+            return True;\n+\n+         elsif E = Standard_Standard then\n+            return False;\n+         end if;\n+\n+         E := Scope (E);\n+      end loop;\n+\n+   end In_Subprogram_Task_Protected_Unit;\n+\n+   -------------------------------\n+   -- Is_Non_Remote_Access_Type --\n+   -------------------------------\n+\n+   function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Access_Type (E)\n+        and then not Is_Remote_Access_To_Class_Wide_Type (E)\n+        and then not Is_Remote_Access_To_Subprogram_Type (E);\n+   end Is_Non_Remote_Access_Type;\n+\n+   ------------------------------------\n+   -- Is_Recursively_Limited_Private --\n+   ------------------------------------\n+\n+   function Is_Recursively_Limited_Private (E : Entity_Id) return Boolean is\n+      P : constant Node_Id := Parent (E);\n+\n+   begin\n+      if Nkind (P) = N_Private_Type_Declaration\n+        and then Is_Limited_Record (E)\n+      then\n+         return True;\n+      elsif Nkind (P) = N_Private_Extension_Declaration then\n+         return Is_Recursively_Limited_Private (Etype (E));\n+      elsif Nkind (P) = N_Formal_Type_Declaration\n+        and then Ekind (E) = E_Record_Type_With_Private\n+        and then Is_Generic_Type (E)\n+        and then Is_Limited_Record (E)\n+      then\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Is_Recursively_Limited_Private;\n+\n+   ----------------------------------\n+   -- Missing_Read_Write_Attribute --\n+   ----------------------------------\n+\n+   function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean is\n+      Component      : Entity_Id;\n+      Component_Type : Entity_Id;\n+\n+      function Has_Read_Write_Attributes (E : Entity_Id) return Boolean;\n+      --  Return True if entity has Read and Write attributes\n+\n+      -------------------------------\n+      -- Has_Read_Write_Attributes --\n+      -------------------------------\n+\n+      function Has_Read_Write_Attributes (E : Entity_Id) return Boolean is\n+         Rep_Item        : Node_Id := First_Rep_Item (E);\n+         Read_Attribute  : Boolean := False;\n+         Write_Attribute : Boolean := False;\n+\n+      begin\n+         --  We start from the declaration node and then loop until the end\n+         --  of the list until we find those two attribute definition clauses.\n+\n+         while Present (Rep_Item) loop\n+            if Chars (Rep_Item) = Name_Read then\n+               Read_Attribute := True;\n+            elsif Chars (Rep_Item) = Name_Write then\n+               Write_Attribute := True;\n+            end if;\n+\n+            if Read_Attribute and Write_Attribute then\n+               return True;\n+            end if;\n+\n+            Next_Rep_Item (Rep_Item);\n+         end loop;\n+\n+         return False;\n+      end Has_Read_Write_Attributes;\n+\n+   --  Start of processing for Missing_Read_Write_Attributes\n+\n+   begin\n+      if Has_Read_Write_Attributes (E) then\n+         return False;\n+      elsif Is_Non_Remote_Access_Type (E) then\n+         return True;\n+      end if;\n+\n+      if Is_Record_Type (E) then\n+         Component := First_Entity (E);\n+         while Present (Component) loop\n+            Component_Type := Etype (Component);\n+\n+            if (Is_Non_Remote_Access_Type (Component_Type)\n+                or else Is_Record_Type (Component_Type))\n+              and then Missing_Read_Write_Attributes (Component_Type)\n+            then\n+               return True;\n+            end if;\n+\n+            Next_Entity (Component);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Missing_Read_Write_Attributes;\n+\n+   -------------------------------------\n+   -- Set_Categorization_From_Pragmas --\n+   -------------------------------------\n+\n+   procedure Set_Categorization_From_Pragmas (N : Node_Id) is\n+      P   : constant Node_Id := Parent (N);\n+      S   : constant Entity_Id := Current_Scope;\n+\n+      procedure Set_Parents (Visibility : Boolean);\n+         --  If this is a child instance, the parents are not immediately\n+         --  visible during analysis. Make them momentarily visible so that\n+         --  the argument of the pragma can be resolved properly, and reset\n+         --  afterwards.\n+\n+      procedure Set_Parents (Visibility : Boolean) is\n+         Par : Entity_Id := Scope (S);\n+\n+      begin\n+         while Present (Par) and then Par /= Standard_Standard loop\n+            Set_Is_Immediately_Visible (Par, Visibility);\n+            Par := Scope (Par);\n+         end loop;\n+      end Set_Parents;\n+\n+   begin\n+      --  Deal with categorization pragmas in Pragmas of Compilation_Unit.\n+      --  The purpose is to set categorization flags before analyzing the\n+      --  unit itself, so as to diagnose violations of categorization as\n+      --  we process each declaration, even though the pragma appears after\n+      --  the unit.\n+\n+      if Nkind (P) /= N_Compilation_Unit then\n+         return;\n+      end if;\n+\n+      declare\n+         PN : Node_Id := First (Pragmas_After (Aux_Decls_Node (P)));\n+\n+      begin\n+\n+         if Is_Child_Unit (S)\n+           and then Is_Generic_Instance (S)\n+         then\n+            Set_Parents (True);\n+         end if;\n+\n+         while Present (PN) loop\n+\n+            --  Skip implicit types that may have been introduced by\n+            --  previous analysis.\n+\n+            if Nkind (PN) = N_Pragma then\n+\n+               case Get_Pragma_Id (Chars (PN)) is\n+                  when Pragma_All_Calls_Remote   |\n+                    Pragma_Preelaborate          |\n+                    Pragma_Pure                  |\n+                    Pragma_Remote_Call_Interface |\n+                    Pragma_Remote_Types          |\n+                    Pragma_Shared_Passive        => Analyze (PN);\n+                  when others                    => null;\n+               end case;\n+            end if;\n+\n+            Next (PN);\n+         end loop;\n+         if Is_Child_Unit (S)\n+           and then Is_Generic_Instance (S)\n+         then\n+            Set_Parents (False);\n+         end if;\n+\n+      end;\n+   end Set_Categorization_From_Pragmas;\n+\n+   ------------------------------\n+   -- Static_Discriminant_Expr --\n+   ------------------------------\n+\n+   function Static_Discriminant_Expr (L : List_Id) return Boolean is\n+      Discriminant_Spec : Node_Id;\n+\n+   begin\n+      Discriminant_Spec := First (L);\n+      while Present (Discriminant_Spec) loop\n+         if Present (Expression (Discriminant_Spec))\n+           and then not Is_Static_Expression (Expression (Discriminant_Spec))\n+         then\n+            return False;\n+         end if;\n+\n+         Next (Discriminant_Spec);\n+      end loop;\n+\n+      return True;\n+   end Static_Discriminant_Expr;\n+\n+   --------------------------------------\n+   -- Validate_Access_Type_Declaration --\n+   --------------------------------------\n+\n+   procedure Validate_Access_Type_Declaration (T : Entity_Id; N : Node_Id) is\n+      Def : constant Node_Id := Type_Definition (N);\n+\n+   begin\n+      case Nkind (Def) is\n+         when N_Access_To_Subprogram_Definition =>\n+\n+            --  A pure library_item must not contain the declaration of a\n+            --  named access type, except within a subprogram, generic\n+            --  subprogram, task unit, or protected unit (RM 10.2.1(16)).\n+\n+            if Comes_From_Source (T)\n+               and then In_Pure_Unit\n+               and then not In_Subprogram_Task_Protected_Unit\n+            then\n+               Error_Msg_N (\"named access type not allowed in pure unit\", T);\n+            end if;\n+\n+         when N_Access_To_Object_Definition =>\n+\n+            if Comes_From_Source (T)\n+              and then In_Pure_Unit\n+              and then not In_Subprogram_Task_Protected_Unit\n+            then\n+               Error_Msg_N\n+                 (\"named access type not allowed in pure unit\", T);\n+            end if;\n+\n+            --  Check for RCI unit type declaration. It should not contain\n+            --  the declaration of an access-to-object type unless it is a\n+            --  general access type that designates a class-wide limited\n+            --  private type. There are also constraints about the primitive\n+            --  subprograms of the class-wide type.\n+\n+            Validate_Remote_Access_Object_Type_Declaration (T);\n+\n+            --  Check for shared passive unit type declaration. It should\n+            --  not contain the declaration of access to class wide type,\n+            --  access to task type and access to protected type with entry.\n+\n+            Validate_SP_Access_Object_Type_Decl (T);\n+\n+         when others => null;\n+      end case;\n+\n+      --  Set Categorization flag of package on entity as well, to allow\n+      --  easy checks later on for required validations of RCI units. This\n+      --  is only done for entities that are in the original source.\n+\n+      if Comes_From_Source (T) then\n+         if Is_Remote_Call_Interface (Scope (T))\n+           and then not In_Package_Body (Scope (T))\n+         then\n+            Set_Is_Remote_Call_Interface (T);\n+         end if;\n+\n+         if Is_Remote_Types (Scope (T))\n+           and then not In_Package_Body (Scope (T))\n+         then\n+            Set_Is_Remote_Types (T);\n+         end if;\n+      end if;\n+   end Validate_Access_Type_Declaration;\n+\n+   ----------------------------\n+   -- Validate_Ancestor_Part --\n+   ----------------------------\n+\n+   procedure Validate_Ancestor_Part (N : Node_Id) is\n+      A : constant Node_Id := Ancestor_Part (N);\n+      T : Entity_Id        := Entity (A);\n+\n+   begin\n+      if In_Preelaborated_Unit\n+        and then not In_Subprogram_Or_Concurrent_Unit\n+        and then (not Inside_A_Generic\n+                   or else Present (Enclosing_Generic_Body (N)))\n+      then\n+         --  We relax the restriction of 10.2.1(9) within GNAT\n+         --  units to allow packages such as Ada.Strings.Unbounded\n+         --  to be implemented (i.p., Null_Unbounded_String).\n+         --  (There are ACVC tests that check that the restriction\n+         --  is enforced, but note that AI-161, once approved,\n+         --  will relax the restriction prohibiting default-\n+         --  initialized objects of private and controlled\n+         --  types.)\n+\n+         if Is_Private_Type (T)\n+           and then not Is_Internal_File_Name\n+                          (Unit_File_Name (Get_Source_Unit (N)))\n+         then\n+            Error_Msg_N\n+              (\"private ancestor type not allowed in preelaborated unit\", A);\n+\n+         elsif Is_Record_Type (T) then\n+            if Nkind (Parent (T)) = N_Full_Type_Declaration then\n+               Check_Non_Static_Default_Expr\n+                 (Type_Definition (Parent (T)), A);\n+            end if;\n+         end if;\n+      end if;\n+   end Validate_Ancestor_Part;\n+\n+   ----------------------------------------\n+   -- Validate_Categorization_Dependency --\n+   ----------------------------------------\n+\n+   procedure Validate_Categorization_Dependency\n+     (N : Node_Id;\n+      E : Entity_Id)\n+   is\n+      K          : constant Node_Kind := Nkind (N);\n+      P          : Node_Id            := Parent (N);\n+      U          : Entity_Id := E;\n+      Is_Subunit : constant Boolean := Nkind (P) = N_Subunit;\n+\n+   begin\n+      --  Only validate library units and subunits. For subunits, checks\n+      --  concerning withed units apply to the parent compilation unit.\n+\n+      if Is_Subunit then\n+         P := Parent (P);\n+         U := Scope (E);\n+\n+         while Present (U)\n+           and then not Is_Compilation_Unit (U)\n+           and then not Is_Child_Unit (U)\n+         loop\n+            U := Scope (U);\n+         end loop;\n+\n+      end if;\n+\n+      if Nkind (P) /= N_Compilation_Unit then\n+         return;\n+      end if;\n+\n+      --  Body of RCI unit does not need validation.\n+\n+      if Is_Remote_Call_Interface (E)\n+        and then (Nkind (N) = N_Package_Body\n+                   or else Nkind (N) = N_Subprogram_Body)\n+      then\n+         return;\n+      end if;\n+\n+      --  Process with clauses\n+\n+      declare\n+         Item             : Node_Id;\n+         Entity_Of_Withed : Entity_Id;\n+\n+      begin\n+         Item := First (Context_Items (P));\n+\n+         while Present (Item) loop\n+            if Nkind (Item) = N_With_Clause\n+              and then not Implicit_With (Item)\n+            then\n+               Entity_Of_Withed := Entity (Name (Item));\n+               Check_Categorization_Dependencies\n+                (U, Entity_Of_Withed, Item, Is_Subunit);\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n+      end;\n+\n+      --  Child depends on parent; therefore parent should also\n+      --  be categorized and satify the dependency hierarchy.\n+\n+      --  Check if N is a child spec.\n+\n+      if (K in N_Generic_Declaration              or else\n+          K in N_Generic_Instantiation            or else\n+          K in N_Generic_Renaming_Declaration     or else\n+          K =  N_Package_Declaration              or else\n+          K =  N_Package_Renaming_Declaration     or else\n+          K =  N_Subprogram_Declaration           or else\n+          K =  N_Subprogram_Renaming_Declaration)\n+        and then Present (Parent_Spec (N))\n+      then\n+         declare\n+            Parent_Lib_U  : constant Node_Id   := Parent_Spec (N);\n+            Parent_Kind   : constant Node_Kind :=\n+                              Nkind (Unit (Parent_Lib_U));\n+            Parent_Entity : Entity_Id;\n+\n+         begin\n+            if        Parent_Kind =  N_Package_Instantiation\n+              or else Parent_Kind =  N_Procedure_Instantiation\n+              or else Parent_Kind =  N_Function_Instantiation\n+              or else Parent_Kind =  N_Package_Renaming_Declaration\n+              or else Parent_Kind in N_Generic_Renaming_Declaration\n+            then\n+               Parent_Entity := Defining_Entity (Unit (Parent_Lib_U));\n+\n+            else\n+               Parent_Entity :=\n+                 Defining_Entity (Specification (Unit (Parent_Lib_U)));\n+            end if;\n+\n+            Check_Categorization_Dependencies (E, Parent_Entity, N, False);\n+\n+            --  Verify that public child of an RCI library unit\n+            --  must also be an RCI library unit (RM E.2.3(15)).\n+\n+            if Is_Remote_Call_Interface (Parent_Entity)\n+              and then not Private_Present (P)\n+              and then not Is_Remote_Call_Interface (E)\n+            then\n+               Error_Msg_N\n+                 (\"public child of rci unit must also be rci unit\", N);\n+               return;\n+            end if;\n+         end;\n+      end if;\n+\n+   end Validate_Categorization_Dependency;\n+\n+   --------------------------------\n+   -- Validate_Controlled_Object --\n+   --------------------------------\n+\n+   procedure Validate_Controlled_Object (E : Entity_Id) is\n+   begin\n+      --  For now, never apply this check for internal GNAT units, since we\n+      --  have a number of cases in the library where we are stuck with objects\n+      --  of this type, and the RM requires Preelaborate.\n+\n+      --  For similar reasons, we only do this check for source entities, since\n+      --  we generate entities of this type in some situations.\n+\n+      --  Note that the 10.2.1(9) restrictions are not relevant to us anyway.\n+      --  We have to enforce them for RM compatibility, but we have no trouble\n+      --  accepting these objects and doing the right thing. Note that there is\n+      --  no requirement that Preelaborate not actually generate any code!\n+\n+      if In_Preelaborated_Unit\n+        and then not Debug_Flag_PP\n+        and then Comes_From_Source (E)\n+        and then not\n+          Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (E)))\n+        and then (not Inside_A_Generic\n+                   or else Present (Enclosing_Generic_Body (E)))\n+        and then not Is_Protected_Type (Etype (E))\n+      then\n+         Error_Msg_N\n+           (\"library level controlled object not allowed in \" &\n+            \"preelaborated unit\", E);\n+      end if;\n+   end Validate_Controlled_Object;\n+\n+   --------------------------------------\n+   -- Validate_Null_Statement_Sequence --\n+   --------------------------------------\n+\n+   procedure Validate_Null_Statement_Sequence (N : Node_Id) is\n+      Item : Node_Id;\n+\n+   begin\n+      if In_Preelaborated_Unit then\n+         Item := First (Statements (Handled_Statement_Sequence (N)));\n+\n+         while Present (Item) loop\n+            if Nkind (Item) /= N_Label\n+              and then Nkind (Item) /= N_Null_Statement\n+            then\n+               Error_Msg_N\n+                 (\"statements not allowed in preelaborated unit\", Item);\n+               exit;\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n+      end if;\n+   end Validate_Null_Statement_Sequence;\n+\n+   ---------------------------------\n+   -- Validate_Object_Declaration --\n+   ---------------------------------\n+\n+   procedure Validate_Object_Declaration (N : Node_Id) is\n+      Id  : constant Entity_Id  := Defining_Identifier (N);\n+      E   : constant Node_Id    := Expression (N);\n+      Odf : constant Node_Id    := Object_Definition (N);\n+      T   : constant Entity_Id  := Etype (Id);\n+\n+   begin\n+      --  Verify that any access to subprogram object does not have in its\n+      --  subprogram profile access type parameters or limited parameters\n+      --  without Read and Write attributes (E.2.3(13)).\n+\n+      Validate_RCI_Subprogram_Declaration (N);\n+\n+      --  Check that if we are in preelaborated elaboration code, then we\n+      --  do not have an instance of a default initialized private, task or\n+      --  protected object declaration which would violate (RM 10.2.1(9)).\n+      --  Note that constants are never default initialized (and the test\n+      --  below also filters out deferred constants). A variable is default\n+      --  initialized if it does *not* have an initialization expression.\n+\n+      --  Filter out cases that are not declaration of a variable from source\n+\n+      if Nkind (N) /= N_Object_Declaration\n+        or else Constant_Present (N)\n+        or else not Comes_From_Source (Id)\n+      then\n+         return;\n+      end if;\n+\n+      --  Exclude generic specs from the checks (this will get rechecked\n+      --  on instantiations).\n+\n+      if Inside_A_Generic\n+        and then not Present (Enclosing_Generic_Body (Id))\n+      then\n+         return;\n+      end if;\n+\n+      --  Required checks for declaration that is in a preelaborated\n+      --  package and is not within some subprogram.\n+\n+      if In_Preelaborated_Unit\n+        and then not In_Subprogram_Or_Concurrent_Unit\n+      then\n+         --  Check for default initialized variable case. Note that in\n+         --  accordance with (RM B.1(24)) imported objects are not\n+         --  subject to default initialization.\n+\n+         if No (E) and then not Is_Imported (Id) then\n+            declare\n+               Ent : Entity_Id := T;\n+\n+            begin\n+               --  An array whose component type is a record with nonstatic\n+               --  default expressions is a violation, so we get the array's\n+               --  component type.\n+\n+               if Is_Array_Type (Ent) then\n+                  declare\n+                     Comp_Type : Entity_Id := Component_Type (Ent);\n+\n+                  begin\n+                     while Is_Array_Type (Comp_Type) loop\n+                        Comp_Type := Component_Type (Comp_Type);\n+                     end loop;\n+\n+                     Ent := Comp_Type;\n+                  end;\n+               end if;\n+\n+               --  Object decl. that is of record type and has no default expr.\n+               --  should check if there is any non-static default expression\n+               --  in component decl. of the record type decl.\n+\n+               if Is_Record_Type (Ent) then\n+                  if Nkind (Parent (Ent)) = N_Full_Type_Declaration then\n+                     Check_Non_Static_Default_Expr\n+                       (Type_Definition (Parent (Ent)), N);\n+\n+                  elsif Nkind (Odf) = N_Subtype_Indication\n+                    and then not Is_Array_Type (T)\n+                    and then not Is_Private_Type (T)\n+                  then\n+                     Check_Non_Static_Default_Expr (Type_Definition\n+                       (Parent (Entity (Subtype_Mark (Odf)))), N);\n+                  end if;\n+               end if;\n+\n+               --  We relax the restriction of 10.2.1(9) within GNAT\n+               --  units. (There are ACVC tests that check that the\n+               --  restriction is enforced, but note that AI-161,\n+               --  once approved, will relax the restriction prohibiting\n+               --  default-initialized objects of private types, and\n+               --  will recommend a pragma for marking private types.)\n+\n+               if (Is_Private_Type (Ent)\n+                    or else Depends_On_Private (Ent))\n+                 and then not Is_Internal_File_Name\n+                                (Unit_File_Name (Get_Source_Unit (N)))\n+               then\n+                  Error_Msg_N\n+                    (\"private object not allowed in preelaborated unit\", N);\n+                  return;\n+\n+               --  Access to Task or Protected type\n+\n+               elsif Is_Entity_Name (Odf)\n+                 and then Present (Etype (Odf))\n+                 and then Is_Access_Type (Etype (Odf))\n+               then\n+                  Ent := Designated_Type (Etype (Odf));\n+\n+               elsif Is_Entity_Name (Odf) then\n+                  Ent := Entity (Odf);\n+\n+               elsif Nkind (Odf) = N_Subtype_Indication then\n+                  Ent := Etype (Subtype_Mark (Odf));\n+\n+               elsif\n+                  Nkind (Odf) = N_Constrained_Array_Definition\n+               then\n+                  Ent := Component_Type (T);\n+\n+               --  else\n+               --     return;\n+               end if;\n+\n+               if Is_Task_Type (Ent)\n+                 or else (Is_Protected_Type (Ent) and then Has_Entries (Ent))\n+               then\n+                  Error_Msg_N\n+                    (\"concurrent object not allowed in preelaborated unit\",\n+                     N);\n+                  return;\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Non-static discriminant not allowed in preelaborayted unit\n+\n+         if Is_Record_Type (Etype (Id)) then\n+            declare\n+               ET  : constant Entity_Id := Etype (Id);\n+               EE  : constant Entity_Id := Etype (Etype (Id));\n+               PEE : Node_Id;\n+\n+            begin\n+               if Has_Discriminants (ET)\n+                 and then Present (EE)\n+               then\n+                  PEE := Parent (EE);\n+\n+                  if Nkind (PEE) = N_Full_Type_Declaration\n+                    and then not Static_Discriminant_Expr\n+                                  (Discriminant_Specifications (PEE))\n+                  then\n+                     Error_Msg_N\n+                       (\"non-static discriminant in preelaborated unit\",\n+                        PEE);\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+\n+      --  A pure library_item must not contain the declaration of any\n+      --  variable except within  a subprogram, generic subprogram, task\n+      --  unit or protected unit (RM 10.2.1(16)).\n+\n+      if In_Pure_Unit\n+        and then not In_Subprogram_Task_Protected_Unit\n+      then\n+         Error_Msg_N (\"declaration of variable not allowed in pure unit\", N);\n+\n+      --  The visible part of an RCI library unit must not contain the\n+      --  declaration of a variable (RM E.1.3(9))\n+\n+      elsif In_RCI_Declaration (N) then\n+         Error_Msg_N (\"declaration of variable not allowed in rci unit\", N);\n+\n+      --  The visible part of a Shared Passive library unit must not contain\n+      --  the declaration of a variable (RM E.2.2(7))\n+\n+      elsif In_RT_Declaration then\n+         Error_Msg_N\n+           (\"variable declaration not allowed in remote types unit\", N);\n+      end if;\n+\n+   end Validate_Object_Declaration;\n+\n+   --------------------------------\n+   --  Validate_RCI_Declarations --\n+   --------------------------------\n+\n+   procedure Validate_RCI_Declarations (P : Entity_Id) is\n+      E : Entity_Id;\n+\n+   begin\n+      E := First_Entity (P);\n+\n+      while Present (E) loop\n+         if Comes_From_Source (E) then\n+\n+            if Is_Limited_Type (E) then\n+               Error_Msg_N\n+                 (\"Limited type not allowed in rci unit\", Parent (E));\n+\n+            elsif Ekind (E) = E_Generic_Function\n+              or else Ekind (E) = E_Generic_Package\n+              or else Ekind (E) = E_Generic_Procedure\n+            then\n+               Error_Msg_N (\"generic declaration not allowed in rci unit\",\n+                 Parent (E));\n+\n+            elsif (Ekind (E) = E_Function\n+                    or else Ekind (E) = E_Procedure)\n+              and then Has_Pragma_Inline (E)\n+            then\n+               Error_Msg_N\n+                 (\"inlined subprogram not allowed in rci unit\", Parent (E));\n+\n+            --  Inner packages that are renamings need not be checked.\n+            --  Generic RCI packages are subject to the checks, but\n+            --  entities that come from formal packages are not part of the\n+            --  visible declarations of the package and are not checked.\n+\n+            elsif Ekind (E) = E_Package then\n+               if Present (Renamed_Entity (E)) then\n+                  null;\n+\n+               elsif Ekind (P) /= E_Generic_Package\n+                 or else List_Containing (Unit_Declaration_Node (E)) /=\n+                           Generic_Formal_Declarations\n+                             (Unit_Declaration_Node (P))\n+               then\n+                  Validate_RCI_Declarations (E);\n+               end if;\n+            end if;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+   end Validate_RCI_Declarations;\n+\n+   -----------------------------------------\n+   -- Validate_RCI_Subprogram_Declaration --\n+   -----------------------------------------\n+\n+   procedure Validate_RCI_Subprogram_Declaration (N : Node_Id) is\n+      K               : Node_Kind := Nkind (N);\n+      Profile         : List_Id;\n+      Id              : Node_Id;\n+      Param_Spec      : Node_Id;\n+      Param_Type      : Entity_Id;\n+      Base_Param_Type : Entity_Id;\n+      Type_Decl       : Node_Id;\n+      Error_Node      : Node_Id := N;\n+\n+   begin\n+      --  There are two possible cases in which this procedure is called:\n+\n+      --    1. called from Analyze_Subprogram_Declaration.\n+      --    2. called from Validate_Object_Declaration (access to subprogram).\n+\n+      if not In_RCI_Declaration (N) then\n+         return;\n+      end if;\n+\n+      if K = N_Subprogram_Declaration then\n+         Profile := Parameter_Specifications (Specification (N));\n+\n+      else pragma Assert (K = N_Object_Declaration);\n+         Id := Defining_Identifier (N);\n+\n+         if Nkind (Id) = N_Defining_Identifier\n+           and then Nkind (Parent (Etype (Id))) = N_Full_Type_Declaration\n+           and then Ekind (Etype (Id)) = E_Access_Subprogram_Type\n+         then\n+            Profile :=\n+              Parameter_Specifications (Type_Definition (Parent (Etype (Id))));\n+         else\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Iterate through the parameter specification list, checking that\n+      --  no access parameter and no limited type parameter in the list.\n+      --  RM E.2.3 (14)\n+\n+      if Present (Profile) then\n+         Param_Spec := First (Profile);\n+\n+         while Present (Param_Spec) loop\n+            Param_Type := Etype (Defining_Identifier (Param_Spec));\n+            Type_Decl  := Parent (Param_Type);\n+\n+            if Ekind (Param_Type) = E_Anonymous_Access_Type then\n+\n+               if K = N_Subprogram_Declaration then\n+                  Error_Node := Param_Spec;\n+               end if;\n+\n+               --  Report error only if declaration is in source program.\n+\n+               if Comes_From_Source\n+                 (Defining_Entity (Specification (N)))\n+               then\n+                  Error_Msg_N\n+                    (\"subprogram in rci unit cannot have access parameter\",\n+                      Error_Node);\n+               end if;\n+\n+            --  For limited private type parameter, we check only the\n+            --  private declaration and ignore full type declaration,\n+            --  unless this is the only declaration for the type, eg.\n+            --  as a limited record.\n+\n+            elsif Is_Limited_Type (Param_Type)\n+              and then (Nkind (Type_Decl) = N_Private_Type_Declaration\n+                         or else\n+                        (Nkind (Type_Decl) = N_Full_Type_Declaration\n+                          and then not (Has_Private_Declaration (Param_Type))\n+                          and then Comes_From_Source (N)))\n+            then\n+\n+               --  A limited parameter is legal only if user-specified\n+               --  Read and Write attributes exist for it.\n+               --  second part of RM E.2.3 (14)\n+\n+               if No (Full_View (Param_Type))\n+                 and then Ekind (Param_Type) /= E_Record_Type\n+               then\n+                  --  type does not have completion yet, so if declared in\n+                  --  in the current RCI scope it is illegal, and will be\n+                  --  flagged subsequently.\n+                  return;\n+               end if;\n+\n+               Base_Param_Type := Base_Type (Underlying_Type (Param_Type));\n+\n+               if No (TSS (Base_Param_Type, Name_uRead))\n+                 or else No (TSS (Base_Param_Type, Name_uWrite))\n+               then\n+\n+                  if K = N_Subprogram_Declaration then\n+                     Error_Node := Param_Spec;\n+                  end if;\n+\n+                  Error_Msg_N\n+                    (\"limited parameter in rci unit \"\n+                       & \"must have read/write attributes \", Error_Node);\n+               end if;\n+            end if;\n+\n+            Next (Param_Spec);\n+         end loop;\n+      end if;\n+   end Validate_RCI_Subprogram_Declaration;\n+\n+   ----------------------------------------------------\n+   -- Validate_Remote_Access_Object_Type_Declaration --\n+   ----------------------------------------------------\n+\n+   procedure Validate_Remote_Access_Object_Type_Declaration (T : Entity_Id) is\n+      Direct_Designated_Type : Entity_Id;\n+      Desig_Type             : Entity_Id;\n+      Primitive_Subprograms  : Elist_Id;\n+      Subprogram             : Elmt_Id;\n+      Subprogram_Node        : Node_Id;\n+      Profile                : List_Id;\n+      Param_Spec             : Node_Id;\n+      Param_Type             : Entity_Id;\n+      Limited_Type_Decl      : Node_Id;\n+\n+   begin\n+      --  We are called from Analyze_Type_Declaration, and the Nkind\n+      --  of the given node is N_Access_To_Object_Definition.\n+\n+      if not Comes_From_Source (T)\n+        or else (not In_RCI_Declaration (Parent (T))\n+                   and then not In_RT_Declaration)\n+      then\n+         return;\n+      end if;\n+\n+      --  An access definition in the private part of a Remote Types package\n+      --  may be legal if it has user-defined Read and Write attributes. This\n+      --  will be checked at the end of the package spec processing.\n+\n+      if In_RT_Declaration and then In_Private_Part (Scope (T)) then\n+         return;\n+      end if;\n+\n+      --  Check RCI unit type declaration. It should not contain the\n+      --  declaration of an access-to-object type unless it is a\n+      --  general access type that designates a class-wide limited\n+      --  private type. There are also constraints about the primitive\n+      --  subprograms of the class-wide type (RM E.2.3(14)).\n+\n+      if Ekind (T) /= E_General_Access_Type\n+        or else Ekind (Designated_Type (T)) /= E_Class_Wide_Type\n+      then\n+         if In_RCI_Declaration (Parent (T)) then\n+            Error_Msg_N\n+              (\"access type in Remote_Call_Interface unit must be \" &\n+               \"general access\", T);\n+         else\n+            Error_Msg_N (\"access type in Remote_Types unit must be \" &\n+              \"general access\", T);\n+         end if;\n+         Error_Msg_N (\"\\to class-wide type\", T);\n+         return;\n+      end if;\n+\n+      Direct_Designated_Type := Designated_Type (T);\n+\n+      Desig_Type := Etype (Direct_Designated_Type);\n+\n+      if not Is_Recursively_Limited_Private (Desig_Type) then\n+         Error_Msg_N\n+           (\"error in designated type of remote access to class-wide type\", T);\n+         Error_Msg_N\n+           (\"\\must be tagged limited private or private extension of type\", T);\n+         return;\n+      end if;\n+\n+      Primitive_Subprograms := Primitive_Operations (Desig_Type);\n+      Subprogram            := First_Elmt (Primitive_Subprograms);\n+\n+      while Subprogram /= No_Elmt loop\n+         Subprogram_Node := Node (Subprogram);\n+\n+         if not Comes_From_Source (Subprogram_Node) then\n+            goto Next_Subprogram;\n+         end if;\n+\n+         Profile := Parameter_Specifications (Parent (Subprogram_Node));\n+\n+         --  Profile must exist, otherwise not primitive operation\n+\n+         Param_Spec := First (Profile);\n+\n+         while Present (Param_Spec) loop\n+\n+            --  Now find out if this parameter is a controlling parameter\n+\n+            Param_Type := Parameter_Type (Param_Spec);\n+\n+            if (Nkind (Param_Type) = N_Access_Definition\n+                  and then Etype (Subtype_Mark (Param_Type)) = Desig_Type)\n+              or else (Nkind (Param_Type) /= N_Access_Definition\n+                        and then Etype (Param_Type) = Desig_Type)\n+            then\n+               --  It is a controlling parameter, so specific checks below\n+               --  do not apply.\n+\n+               null;\n+\n+            elsif\n+              Nkind (Param_Type) = N_Access_Definition\n+            then\n+               --  From RM E.2.2(14), no access parameter other than\n+               --  controlling ones may be used.\n+\n+               Error_Msg_N\n+                 (\"non-controlling access parameter\", Param_Spec);\n+\n+            elsif\n+              Is_Limited_Type (Etype (Defining_Identifier (Param_Spec)))\n+            then\n+               --  Not a controlling parameter, so type must have Read\n+               --  and Write attributes.\n+               --  ??? I suspect this to be dead code because any violation\n+               --  should be caught before in sem_attr.adb (with the message\n+               --  \"limited type ... used in ... has no stream attr.\").  ST\n+\n+               if Nkind (Param_Type) in N_Has_Etype\n+                 and then Nkind (Parent (Etype (Param_Type))) =\n+                          N_Private_Type_Declaration\n+               then\n+                  Param_Type := Etype (Param_Type);\n+                  Limited_Type_Decl := Parent (Param_Type);\n+\n+                  if No (TSS (Param_Type, Name_uRead))\n+                    or else No (TSS (Param_Type, Name_uWrite))\n+                  then\n+                     Error_Msg_N\n+                       (\"limited formal must have Read and Write attributes\",\n+                         Param_Spec);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Check next parameter in this subprogram\n+\n+            Next (Param_Spec);\n+         end loop;\n+\n+         <<Next_Subprogram>>\n+            Next_Elmt (Subprogram);\n+      end loop;\n+\n+      --  Now this is an RCI unit access-to-class-wide-limited-private type\n+      --  declaration. Set the type entity to be Is_Remote_Call_Interface to\n+      --  optimize later checks by avoiding tree traversal to find out if this\n+      --  entity is inside an RCI unit.\n+\n+      Set_Is_Remote_Call_Interface (T);\n+\n+   end Validate_Remote_Access_Object_Type_Declaration;\n+\n+   -----------------------------------------------\n+   -- Validate_Remote_Access_To_Class_Wide_Type --\n+   -----------------------------------------------\n+\n+   procedure Validate_Remote_Access_To_Class_Wide_Type (N : Node_Id) is\n+      K  : constant Node_Kind := Nkind (N);\n+      PK : constant Node_Kind := Nkind (Parent (N));\n+      E  : Entity_Id;\n+\n+   begin\n+      --  This subprogram enforces the checks in (RM E.2.2(8)) for\n+      --  certain uses of class-wide limited private types.\n+\n+      --    Storage_Pool and Storage_Size are not defined for such types\n+      --\n+      --    The expected type of allocator must not not be such a type.\n+\n+      --    The actual parameter of generic instantiation must not\n+      --    be such a type if the formal parameter is of an access type.\n+\n+      --  On entry, there are five cases\n+\n+      --    1. called from sem_attr Analyze_Attribute where attribute\n+      --       name is either Storage_Pool or Storage_Size.\n+\n+      --    2. called from exp_ch4 Expand_N_Allocator\n+\n+      --    3. called from sem_ch12 Analyze_Associations\n+\n+      --    4. called from sem_ch4 Analyze_Explicit_Dereference\n+\n+      --    5. called from sem_res Resolve_Actuals\n+\n+      if K = N_Attribute_Reference then\n+         E := Etype (Prefix (N));\n+\n+         if Is_Remote_Access_To_Class_Wide_Type (E) then\n+            Error_Msg_N (\"incorrect attribute of remote operand\", N);\n+            return;\n+         end if;\n+\n+      elsif K = N_Allocator then\n+         E := Etype (N);\n+\n+         if Is_Remote_Access_To_Class_Wide_Type (E) then\n+            Error_Msg_N (\"incorrect expected remote type of allocator\", N);\n+            return;\n+         end if;\n+\n+      elsif K in N_Has_Entity then\n+         E := Entity (N);\n+\n+         if Is_Remote_Access_To_Class_Wide_Type (E) then\n+            Error_Msg_N (\"incorrect remote type generic actual\", N);\n+            return;\n+         end if;\n+\n+      --  This subprogram also enforces the checks in E.2.2(13).\n+      --  A value of such type must not be dereferenced unless as a\n+      --  controlling operand of a dispatching call.\n+\n+      elsif K = N_Explicit_Dereference\n+        and then (Comes_From_Source (N)\n+                    or else (Nkind (Original_Node (N)) = N_Selected_Component\n+                               and then Comes_From_Source (Original_Node (N))))\n+      then\n+         E := Etype (Prefix (N));\n+\n+         --  If the class-wide type is not a remote one, the restrictions\n+         --  do not apply.\n+\n+         if not Is_Remote_Access_To_Class_Wide_Type (E) then\n+            return;\n+         end if;\n+\n+         --  If we have a true dereference that comes from source and that\n+         --  is a controlling argument for a dispatching call, accept it.\n+\n+         if K = N_Explicit_Dereference\n+           and then Is_Actual_Parameter (N)\n+           and then Is_Controlling_Actual (N)\n+         then\n+            return;\n+         end if;\n+\n+         --  If we are just within a procedure or function call and the\n+         --  dereference has not been analyzed, return because this\n+         --  procedure will be called again from sem_res Resolve_Actuals.\n+\n+         if Is_Actual_Parameter (N)\n+           and then not Analyzed (N)\n+         then\n+            return;\n+         end if;\n+\n+         --  The following is to let the compiler generated tags check\n+         --  pass through without error message. This is a bit kludgy\n+         --  isn't there some better way of making this exclusion ???\n+\n+         if (PK = N_Selected_Component\n+              and then Present (Parent (Parent (N)))\n+              and then Nkind (Parent (Parent (N))) = N_Op_Ne)\n+           or else (PK = N_Unchecked_Type_Conversion\n+                    and then Present (Parent (Parent (N)))\n+                    and then\n+                      Nkind (Parent (Parent (N))) = N_Selected_Component)\n+         then\n+            return;\n+         end if;\n+\n+         --  The following code is needed for expansion of RACW Write\n+         --  attribute, since such expressions can appear in the expanded\n+         --  code.\n+\n+         if not Comes_From_Source (N)\n+           and then\n+           (PK = N_In\n+            or else PK = N_Attribute_Reference\n+            or else\n+              (PK = N_Type_Conversion\n+               and then Present (Parent (N))\n+               and then Present (Parent (Parent (N)))\n+               and then\n+                 Nkind (Parent (Parent (N))) = N_Selected_Component))\n+         then\n+            return;\n+         end if;\n+\n+         Error_Msg_N (\"incorrect remote type dereference\", N);\n+      end if;\n+   end Validate_Remote_Access_To_Class_Wide_Type;\n+\n+   -----------------------------------------------\n+   -- Validate_Remote_Access_To_Subprogram_Type --\n+   -----------------------------------------------\n+\n+   procedure Validate_Remote_Access_To_Subprogram_Type (N : Node_Id) is\n+      Type_Def          : constant Node_Id := Type_Definition (N);\n+      Current_Parameter : Node_Id;\n+\n+   begin\n+      if Present (Parameter_Specifications (Type_Def)) then\n+         Current_Parameter := First (Parameter_Specifications (Type_Def));\n+         while Present (Current_Parameter) loop\n+            if Nkind (Parameter_Type (Current_Parameter)) =\n+                                                         N_Access_Definition\n+            then\n+               Error_Msg_N\n+                 (\"remote access to subprogram type declaration contains\",\n+                  Current_Parameter);\n+               Error_Msg_N\n+                 (\"\\parameter of an anonymous access type\", Current_Parameter);\n+            end if;\n+\n+            Current_Parameter := Next (Current_Parameter);\n+         end loop;\n+      end if;\n+   end Validate_Remote_Access_To_Subprogram_Type;\n+\n+   ------------------------------------------\n+   -- Validate_Remote_Type_Type_Conversion --\n+   ------------------------------------------\n+\n+   procedure Validate_Remote_Type_Type_Conversion (N : Node_Id) is\n+      S : constant Entity_Id := Etype (N);\n+      E : constant Entity_Id := Etype (Expression (N));\n+\n+   begin\n+      --  This test is required in the case where a conversion appears\n+      --  inside a normal package, it does not necessarily have to be\n+      --  inside an RCI, Remote_Types unit (RM E.2.2(9,12)).\n+\n+      if Is_Remote_Access_To_Subprogram_Type (E)\n+        and then not Is_Remote_Access_To_Subprogram_Type (S)\n+      then\n+         Error_Msg_N (\"incorrect conversion of remote operand\", N);\n+         return;\n+\n+      elsif Is_Remote_Access_To_Class_Wide_Type (E)\n+        and then not Is_Remote_Access_To_Class_Wide_Type (S)\n+      then\n+         Error_Msg_N (\"incorrect conversion of remote operand\", N);\n+         return;\n+      end if;\n+\n+      --  If a local access type is converted into a RACW type, then the\n+      --  current unit has a pointer that may now be exported to another\n+      --  partition.\n+\n+      if Is_Remote_Access_To_Class_Wide_Type (S)\n+        and then not Is_Remote_Access_To_Class_Wide_Type (E)\n+      then\n+         Set_Has_RACW (Current_Sem_Unit);\n+      end if;\n+   end Validate_Remote_Type_Type_Conversion;\n+\n+   -------------------------------\n+   -- Validate_RT_RAT_Component --\n+   -------------------------------\n+\n+   procedure Validate_RT_RAT_Component (N : Node_Id) is\n+      Spec            : constant Node_Id   := Specification (N);\n+      Name_U          : constant Entity_Id := Defining_Entity (Spec);\n+      Typ             : Entity_Id;\n+      First_Priv_Ent  : constant Entity_Id := First_Private_Entity (Name_U);\n+      In_Visible_Part : Boolean            := True;\n+\n+   begin\n+      if not Is_Remote_Types (Name_U) then\n+         return;\n+      end if;\n+\n+      Typ := First_Entity (Name_U);\n+      while Present (Typ) loop\n+         if In_Visible_Part and then Typ = First_Priv_Ent then\n+            In_Visible_Part := False;\n+         end if;\n+\n+         if Comes_From_Source (Typ)\n+           and then Is_Type (Typ)\n+           and then (In_Visible_Part or else Has_Private_Declaration (Typ))\n+         then\n+            if Missing_Read_Write_Attributes (Typ) then\n+               if Is_Non_Remote_Access_Type (Typ) then\n+                  Error_Msg_N\n+                    (\"non-remote access type without user-defined Read \" &\n+                     \"and Write attributes\", Typ);\n+               else\n+                  Error_Msg_N\n+                    (\"record type containing a component of a \" &\n+                     \"non-remote access\", Typ);\n+                  Error_Msg_N\n+                    (\"\\type without Read and Write attributes \" &\n+                     \"('R'M E.2.2(8))\", Typ);\n+               end if;\n+            end if;\n+         end if;\n+\n+         Next_Entity (Typ);\n+      end loop;\n+   end Validate_RT_RAT_Component;\n+\n+   -----------------------------------------\n+   -- Validate_SP_Access_Object_Type_Decl --\n+   -----------------------------------------\n+\n+   procedure Validate_SP_Access_Object_Type_Decl (T : Entity_Id) is\n+      Direct_Designated_Type : Entity_Id;\n+\n+      function Has_Entry_Declarations (E : Entity_Id) return Boolean;\n+      --  Return true if the protected type designated by T has\n+      --  entry declarations.\n+\n+      function Has_Entry_Declarations (E : Entity_Id) return Boolean is\n+         Ety : Entity_Id;\n+\n+      begin\n+         if Nkind (Parent (E)) = N_Protected_Type_Declaration then\n+            Ety := First_Entity (E);\n+            while Present (Ety) loop\n+               if Ekind (Ety) = E_Entry then\n+                  return True;\n+               end if;\n+\n+               Next_Entity (Ety);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Has_Entry_Declarations;\n+\n+   --  Start of processing for Validate_SP_Access_Object_Type_Decl\n+\n+   begin\n+      --  We are called from Sem_Ch3.Analyze_Type_Declaration, and the\n+      --  Nkind of the given entity is N_Access_To_Object_Definition.\n+\n+      if not Comes_From_Source (T)\n+        or else not In_Shared_Passive_Unit\n+        or else In_Subprogram_Task_Protected_Unit\n+      then\n+         return;\n+      end if;\n+\n+      --  Check Shared Passive unit. It should not contain the declaration\n+      --  of an access-to-object type whose designated type is a class-wide\n+      --  type, task type or protected type with entry (RM E.2.1(7)).\n+\n+      Direct_Designated_Type := Designated_Type (T);\n+\n+      if Ekind (Direct_Designated_Type) = E_Class_Wide_Type then\n+         Error_Msg_N\n+           (\"invalid access-to-class-wide type in shared passive unit\", T);\n+         return;\n+\n+      elsif Ekind (Direct_Designated_Type) in Task_Kind then\n+         Error_Msg_N\n+           (\"invalid access-to-task type in shared passive unit\", T);\n+         return;\n+\n+      elsif Ekind (Direct_Designated_Type) in Protected_Kind\n+        and then Has_Entry_Declarations (Direct_Designated_Type)\n+      then\n+         Error_Msg_N\n+           (\"invalid access-to-protected type in shared passive unit\", T);\n+         return;\n+      end if;\n+   end Validate_SP_Access_Object_Type_Decl;\n+\n+   ---------------------------------\n+   -- Validate_Static_Object_Name --\n+   ---------------------------------\n+\n+   procedure Validate_Static_Object_Name (N : Node_Id) is\n+      E : Entity_Id;\n+\n+      function Is_Primary (N : Node_Id) return Boolean;\n+      --  Determine whether node is syntactically a primary in an expression.\n+\n+      function Is_Primary (N : Node_Id) return Boolean is\n+         K : constant Node_Kind := Nkind (Parent (N));\n+\n+      begin\n+         case K is\n+\n+            when N_Op | N_In | N_Not_In =>\n+               return True;\n+\n+            when N_Aggregate\n+               | N_Component_Association\n+               | N_Index_Or_Discriminant_Constraint =>\n+               return True;\n+\n+            when N_Attribute_Reference =>\n+               return Attribute_Name (Parent (N)) /= Name_Address\n+                 and then Attribute_Name (Parent (N)) /= Name_Access\n+                 and then Attribute_Name (Parent (N)) /= Name_Unchecked_Access\n+                 and then\n+                   Attribute_Name (Parent (N)) /= Name_Unrestricted_Access;\n+\n+            when N_Indexed_Component =>\n+               return (N /= Prefix (Parent (N))\n+                 or else Is_Primary (Parent (N)));\n+\n+            when N_Qualified_Expression | N_Type_Conversion =>\n+               return Is_Primary (Parent (N));\n+\n+            when N_Assignment_Statement | N_Object_Declaration =>\n+               return (N = Expression (Parent (N)));\n+\n+            when N_Selected_Component =>\n+               return Is_Primary (Parent (N));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end Is_Primary;\n+\n+   --  Start of processing for Validate_Static_Object_Name\n+\n+   begin\n+      if not In_Preelaborated_Unit\n+        or else not Comes_From_Source (N)\n+        or else In_Subprogram_Or_Concurrent_Unit\n+        or else Ekind (Current_Scope) = E_Block\n+      then\n+         return;\n+\n+      --  Filter out cases where primary is default in a component\n+      --  declaration, discriminant specification, or actual in a record\n+      --  type initialization call.\n+\n+      --  Initialization call of internal types.\n+\n+      elsif Nkind (Parent (N)) = N_Procedure_Call_Statement then\n+\n+         if Present (Parent (Parent (N)))\n+           and then Nkind (Parent (Parent (N))) = N_Freeze_Entity\n+         then\n+            return;\n+         end if;\n+\n+         if Nkind (Name (Parent (N))) = N_Identifier\n+           and then not Comes_From_Source (Entity (Name (Parent (N))))\n+         then\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Error if the name is a primary in an expression. The parent must not\n+      --  be an operator, or a selected component or an indexed component that\n+      --  is itself a primary. Entities that are actuals do not need to be\n+      --  checked, because the call itself will be diagnosed.\n+\n+      if Is_Primary (N)\n+        and then (not Inside_A_Generic\n+                   or else Present (Enclosing_Generic_Body (N)))\n+      then\n+         if Ekind (Entity (N)) = E_Variable then\n+            Error_Msg_N (\"non-static object name in preelaborated unit\", N);\n+\n+         --  We take the view that a constant defined in another preelaborated\n+         --  unit is preelaborable, even though it may have a private type and\n+         --  thus appear non-static in a client. This must be the intent of\n+         --  the language, but currently is an RM gap.\n+\n+         elsif Ekind (Entity (N)) = E_Constant\n+           and then not Is_Static_Expression (N)\n+         then\n+            E := Entity (N);\n+\n+            if Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (N)))\n+              and then\n+                Enclosing_Lib_Unit_Node (N) /= Enclosing_Lib_Unit_Node (E)\n+              and then (Is_Preelaborated (Scope (E))\n+                          or else Is_Pure (Scope (E))\n+                          or else (Present (Renamed_Object (E))\n+                                     and then\n+                                       Is_Entity_Name (Renamed_Object (E))\n+                                     and then\n+                                       (Is_Preelaborated\n+                                         (Scope (Renamed_Object (E)))\n+                                            or else\n+                                              Is_Pure (Scope\n+                                                (Renamed_Object (E))))))\n+            then\n+               null;\n+            else\n+               Error_Msg_N (\"non-static constant in preelaborated unit\", N);\n+            end if;\n+         end if;\n+      end if;\n+   end Validate_Static_Object_Name;\n+\n+end Sem_Cat;"}, {"sha": "3591e746c73742327be604cc03d87a638195b4d2", "filename": "gcc/ada/sem_cat.ads", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_cat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_cat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,144 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C A T                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit contains the routines used for checking for conformance with\n+--  the semantic restrictions required for the categorization pragmas:\n+--\n+--    Preelaborate\n+--    Pure,\n+--    Remote_Call_Interface\n+--    Remote_Types\n+--    Shared_Passive\n+--\n+--  Note that we treat Preelaborate as a categorization pragma, even though\n+--  strictly, according to RM E.2(2,3), the term does not apply in this case.\n+\n+with Types; use Types;\n+\n+package Sem_Cat is\n+\n+   function In_Preelaborated_Unit return Boolean;\n+   --  Determines if the current scope is within a preelaborated compilation\n+   --  unit, that is one to which one of the pragmas Preelaborate, Pure,\n+   --  Shared_Passive, Remote_Types, or inside a unit other than a package\n+   --  body with pragma Remote_Call_Interface.\n+\n+   function In_Pure_Unit return Boolean;\n+   pragma Inline (In_Pure_Unit);\n+   --  Determines if the current scope is within pure compilation unit,\n+   --  that is, one to which the pragmas Pure is applied.\n+\n+   function In_Subprogram_Task_Protected_Unit return Boolean;\n+   --  Determines if the current scope is within a subprogram, task\n+   --  or protected unit. Used to validate if the library unit is Pure\n+   --  (RM 10.2.1(16)).\n+\n+   procedure Set_Categorization_From_Pragmas (N : Node_Id);\n+   --  Since validation of categorization dependency is done during analyze\n+   --  so categorization flags from following pragmas should be set before\n+   --  validation begin. N is the N_Compilation_Unit node.\n+\n+   procedure Validate_Access_Type_Declaration (T : Entity_Id; N : Node_Id);\n+   --  Validate all constraints against declaration of access types in\n+   --  categorized library units. Usually this is a violation in Pure unit,\n+   --  Shared_Passive unit. N is the declaration node.\n+\n+   procedure Validate_Ancestor_Part (N : Node_Id);\n+   --  Checks that a type given as the ancestor in an extension aggregate\n+   --  satisfies the restriction of 10.2.1(9).\n+\n+   procedure Validate_Categorization_Dependency (N : Node_Id; E : Entity_Id);\n+   --  There are restrictions on lib unit that semantically depends on other\n+   --  units (RM E.2(5), 10.2.1(11). This procedure checks the restrictions\n+   --  on categorizations. N is the current unit node, and E is the current\n+   --  library unit entity.\n+\n+   procedure Validate_Controlled_Object (E : Entity_Id);\n+   --  Given an entity for a library level controlled object, check that it is\n+   --  not in a preelaborated unit (prohibited by RM 10.2.1(9)).\n+\n+   procedure Validate_Null_Statement_Sequence (N : Node_Id);\n+   --  Given N, a package body node, check that a handled statement sequence\n+   --  in a preelaborable body contains no statements other than labels or\n+   --  null statements, as required by RM 10.2.1(6).\n+\n+   procedure Validate_Object_Declaration (N : Node_Id);\n+   --  Given N, an object declaration node, validates all the constraints in\n+   --  a preelaborable library unit, including creation of task objects etc.\n+   --  Note that this is called when the corresponding object is frozen since\n+   --  the checks cannot be made before knowing if the object is imported.\n+\n+   procedure Validate_RCI_Declarations (P : Entity_Id);\n+   --  Apply semantic checks given in  E2.3(10-14).\n+\n+   procedure Validate_RCI_Subprogram_Declaration (N : Node_Id);\n+   --  Check for RCI unit subprogram declarations with respect to\n+   --  in-lined subprogram and subprogram with access parameter or\n+   --  limited type parameter without Read and Write.\n+\n+   procedure Validate_Remote_Access_To_Class_Wide_Type (N : Node_Id);\n+   --  Checks that Storage_Pool and Storage_Size attribute references are\n+   --  not applied to remote access-to-class-wide types. And the expected\n+   --  type for an allocator shall not be a remote access-to-class-wide\n+   --  type. And a remote access-to-class-wide type shall not be an actual\n+   --  parameter for a generic formal access type. RM E.2.3(22).\n+\n+   procedure Validate_Remote_Access_To_Subprogram_Type (N : Node_Id);\n+   --  Checks that a remote access to subprogram type does not have a\n+   --  parameter of an access type. This is not strictly forbidden at this\n+   --  time, but this is useless, as such a RAS type will not be usable\n+   --  per E.2.2(12) and E.2.3(14).\n+\n+   procedure Validate_RT_RAT_Component (N : Node_Id);\n+   --  Given N, the package library unit declaration node, we should check\n+   --  against RM:9.95 E.2.2(8): the full view of a type declared in the\n+   --  visible part of a Remote Types unit has a part that is of a non-remote\n+   --  access type which has no read/write.\n+\n+   procedure Validate_Remote_Type_Type_Conversion (N : Node_Id);\n+   --  Check for remote-type type conversion constraints. First, a value of\n+   --  a remote access-to-subprogram type can be converted only to another\n+   --  type conformant remote access-to-subprogram type. Secondly, a value\n+   --  of a remote access-to-class-wide type can be converted only to another\n+   --  remote access-to-class-wide type (RM E.2.3(17,20)).\n+\n+   procedure Validate_SP_Access_Object_Type_Decl (T : Entity_Id);\n+   --  Check validity of declaration if shared passive unit. It should not\n+   --  contain the declaration of an access-to-object type whose designated\n+   --  type is a class-wide type ,task type or protected type. E.2.1(7).\n+   --  T is the entity of the declared type.\n+\n+   procedure Validate_Static_Object_Name (N : Node_Id);\n+   --  In the elaboration code of a preelaborated library unit, check\n+   --  that we do not have the evaluation of a primary that is a name of\n+   --  an object, unless the name is a static expression (RM 10.2.1(8)).\n+   --  Non-static constant and variable are the targets, generic parameters\n+   --  are not included because the generic declaration and body are\n+   --  preelaborable.\n+\n+end Sem_Cat;"}, {"sha": "2bbe0a50081651cd98bf9e12e333822991d3d5a8", "filename": "gcc/ada/sem_ch10.adb", "status": "added", "additions": 3072, "deletions": 0, "changes": 3072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "4ea1acca4cc4ed381f961859b82f70cc7bf0a7ff", "filename": "gcc/ada/sem_ch10.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C H 1 0                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sem_Ch10 is\n+   procedure Analyze_Compilation_Unit                   (N : Node_Id);\n+   procedure Analyze_With_Clause                        (N : Node_Id);\n+   procedure Analyze_With_Type_Clause                   (N : Node_Id);\n+   procedure Analyze_Subprogram_Body_Stub               (N : Node_Id);\n+   procedure Analyze_Package_Body_Stub                  (N : Node_Id);\n+   procedure Analyze_Task_Body_Stub                     (N : Node_Id);\n+   procedure Analyze_Protected_Body_Stub                (N : Node_Id);\n+   procedure Analyze_Subunit                            (N : Node_Id);\n+\n+   procedure Install_Context (N : Node_Id);\n+   --  Installs the entities from the context clause of the given compilation\n+   --  unit into the visibility chains. This is done before analyzing a unit.\n+   --  For a child unit, install context of parents as well.\n+\n+   procedure Remove_Context (N : Node_Id);\n+   --  Removes the entities from the context clause of the given compilation\n+   --  unit from the visibility chains. This is done on exit from a unit as\n+   --  part of cleaning up the visibility chains for the caller. A special\n+   --  case is that the call from the Main_Unit can be ignored, since at the\n+   --  end of the main unit the visibility table won't be needed in any case.\n+   --  For a child unit, remove parents and their context as well.\n+\n+   procedure Load_Needed_Body (N : Node_Id; OK : out Boolean);\n+   --  Load and analyze the body of a context unit that is generic, or\n+   --  that contains generic units or inlined units. The body becomes\n+   --  part of the semantic dependency set of the unit that needs it.\n+   --  The returned result in OK is True if the load is successful,\n+   --  and False if the requested file cannot be found.\n+\n+end Sem_Ch10;"}, {"sha": "2a3536b642a0bbbaa6ce51229ff56176edc874a9", "filename": "gcc/ada/sem_ch11.adb", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,387 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C H 1 1                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.96 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Lib;      use Lib;\n+with Lib.Xref; use Lib.Xref;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Ch5;  use Sem_Ch5;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n+with Uintp;    use Uintp;\n+\n+package body Sem_Ch11 is\n+\n+   -----------------------------------\n+   -- Analyze_Exception_Declaration --\n+   -----------------------------------\n+\n+   procedure Analyze_Exception_Declaration (N : Node_Id) is\n+      Id : constant Entity_Id := Defining_Identifier (N);\n+      PF : constant Boolean   := Is_Pure (Current_Scope);\n+\n+   begin\n+      Generate_Definition (Id);\n+      Enter_Name          (Id);\n+      Set_Ekind           (Id, E_Exception);\n+      Set_Exception_Code  (Id, Uint_0);\n+      Set_Etype           (Id, Standard_Exception_Type);\n+\n+      Set_Is_Statically_Allocated (Id);\n+      Set_Is_Pure (Id, PF);\n+\n+   end Analyze_Exception_Declaration;\n+\n+   --------------------------------\n+   -- Analyze_Exception_Handlers --\n+   --------------------------------\n+\n+   procedure Analyze_Exception_Handlers (L : List_Id) is\n+      Handler : Node_Id;\n+      Choice  : Entity_Id;\n+      Id      : Node_Id;\n+      H_Scope : Entity_Id := Empty;\n+\n+      procedure Check_Duplication (Id : Node_Id);\n+      --  Iterate through the identifiers in each handler to find duplicates\n+\n+      -----------------------\n+      -- Check_Duplication --\n+      -----------------------\n+\n+      procedure Check_Duplication (Id : Node_Id) is\n+         Handler : Node_Id;\n+         Id1     : Node_Id;\n+\n+      begin\n+         Handler := First_Non_Pragma (L);\n+         while Present (Handler) loop\n+            Id1 := First (Exception_Choices (Handler));\n+\n+            while Present (Id1) loop\n+\n+               --  Only check against the exception choices which precede\n+               --  Id in the handler, since the ones that follow Id have not\n+               --  been analyzed yet and will be checked in a subsequent call.\n+\n+               if Id = Id1 then\n+                  return;\n+\n+               elsif Nkind (Id1) /= N_Others_Choice\n+                 and then Entity (Id) = Entity (Id1)\n+               then\n+                  if Handler /= Parent (Id) then\n+                     Error_Msg_Sloc := Sloc (Id1);\n+                     Error_Msg_NE\n+                       (\"exception choice duplicates &#\", Id, Id1);\n+\n+                  else\n+                     if Ada_83 and then Comes_From_Source (Id) then\n+                        Error_Msg_N\n+                          (\"(Ada 83): duplicate exception choice&\", Id);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Next_Non_Pragma (Id1);\n+            end loop;\n+\n+            Next (Handler);\n+         end loop;\n+      end Check_Duplication;\n+\n+   --  Start processing for Analyze_Exception_Handlers\n+\n+   begin\n+      Handler := First (L);\n+      Check_Restriction (No_Exceptions, Handler);\n+      Check_Restriction (No_Exception_Handlers, Handler);\n+\n+      --  Loop through handlers (which can include pragmas)\n+\n+      while Present (Handler) loop\n+\n+         --  If pragma just analyze it\n+\n+         if Nkind (Handler) = N_Pragma then\n+            Analyze (Handler);\n+\n+         --  Otherwise we have a real exception handler\n+\n+         else\n+            --  Deal with choice parameter. The exception handler is\n+            --  a declarative part for it, so it constitutes a scope\n+            --  for visibility purposes. We create an entity to denote\n+            --  the whole exception part, and use it as the scope of all\n+            --  the choices, which may even have the same name without\n+            --  conflict. This scope plays no other role in expansion or\n+            --  or code generation.\n+\n+            Choice := Choice_Parameter (Handler);\n+\n+            if Present (Choice) then\n+\n+               if No (H_Scope) then\n+                  H_Scope := New_Internal_Entity\n+                    (E_Block, Current_Scope, Sloc (Choice), 'E');\n+               end if;\n+\n+               New_Scope (H_Scope);\n+               Set_Etype (H_Scope, Standard_Void_Type);\n+\n+               --  Set the Finalization Chain entity to Error means that it\n+               --  should not be used at that level but the parent one\n+               --  should be used instead.\n+\n+               --  ??? this usage needs documenting in Einfo/Exp_Ch7 ???\n+               --  ??? using Error for this non-error condition is nasty ???\n+\n+               Set_Finalization_Chain_Entity (H_Scope, Error);\n+\n+               Enter_Name (Choice);\n+               Set_Ekind (Choice, E_Variable);\n+               Set_Etype (Choice, RTE (RE_Exception_Occurrence));\n+               Generate_Definition (Choice);\n+            end if;\n+\n+            Id := First (Exception_Choices (Handler));\n+            while Present (Id) loop\n+               if Nkind (Id) = N_Others_Choice then\n+                  if Present (Next (Id))\n+                    or else Present (Next (Handler))\n+                    or else Present (Prev (Id))\n+                  then\n+                     Error_Msg_N (\"OTHERS must appear alone and last\", Id);\n+                  end if;\n+\n+               else\n+                  Analyze (Id);\n+\n+                  if not Is_Entity_Name (Id)\n+                    or else Ekind (Entity (Id)) /= E_Exception\n+                  then\n+                     Error_Msg_N (\"exception name expected\", Id);\n+\n+                  else\n+                     if Present (Renamed_Entity (Entity (Id))) then\n+                        Set_Entity (Id, Renamed_Entity (Entity (Id)));\n+                     end if;\n+\n+                     Check_Duplication (Id);\n+\n+                     --  Check for exception declared within generic formal\n+                     --  package (which is illegal, see RM 11.2(8))\n+\n+                     declare\n+                        Ent  : Entity_Id := Entity (Id);\n+                        Scop : Entity_Id := Scope (Ent);\n+\n+                     begin\n+                        while Scop /= Standard_Standard\n+                          and then Ekind (Scop) = E_Package\n+                        loop\n+                           --  If the exception is declared in an inner\n+                           --  instance, nothing else to check.\n+\n+                           if Is_Generic_Instance (Scop) then\n+                              exit;\n+\n+                           elsif Nkind (Declaration_Node (Scop)) =\n+                                           N_Package_Specification\n+                             and then\n+                               Nkind (Original_Node (Parent\n+                                 (Declaration_Node (Scop)))) =\n+                                           N_Formal_Package_Declaration\n+                           then\n+                              Error_Msg_NE\n+                                (\"exception& is declared in \"  &\n+                                 \"generic formal package\", Id, Ent);\n+                              Error_Msg_N\n+                                (\"\\and therefore cannot appear in \" &\n+                                 \"handler ('R'M 11.2(8))\", Id);\n+                              exit;\n+                           end if;\n+\n+                           Scop := Scope (Scop);\n+                        end loop;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               Next (Id);\n+            end loop;\n+\n+            Analyze_Statements (Statements (Handler));\n+\n+            if Present (Choice) then\n+               End_Scope;\n+            end if;\n+\n+         end if;\n+\n+         Next (Handler);\n+      end loop;\n+   end Analyze_Exception_Handlers;\n+\n+   --------------------------------\n+   -- Analyze_Handled_Statements --\n+   --------------------------------\n+\n+   procedure Analyze_Handled_Statements (N : Node_Id) is\n+      Handlers : constant List_Id := Exception_Handlers (N);\n+\n+   begin\n+      Analyze_Statements (Statements (N));\n+\n+      if Present (Handlers) then\n+         Analyze_Exception_Handlers (Handlers);\n+\n+      elsif Present (At_End_Proc (N)) then\n+         Analyze (At_End_Proc (N));\n+      end if;\n+   end Analyze_Handled_Statements;\n+\n+   -----------------------------\n+   -- Analyze_Raise_Statement --\n+   -----------------------------\n+\n+   procedure Analyze_Raise_Statement (N : Node_Id) is\n+      Exception_Id   : constant Node_Id := Name (N);\n+      Exception_Name : Entity_Id := Empty;\n+      P              : Node_Id;\n+      Nkind_P        : Node_Kind;\n+\n+   begin\n+      Check_Unreachable_Code (N);\n+\n+      --  Check exception restrictions on the original source\n+\n+      if Comes_From_Source (N) then\n+         Check_Restriction (No_Exceptions, N);\n+      end if;\n+\n+      --  Reraise statement\n+\n+      if No (Exception_Id) then\n+\n+         P := Parent (N);\n+         Nkind_P := Nkind (P);\n+\n+         while Nkind_P /= N_Exception_Handler\n+           and then Nkind_P /= N_Subprogram_Body\n+           and then Nkind_P /= N_Package_Body\n+           and then Nkind_P /= N_Task_Body\n+           and then Nkind_P /= N_Entry_Body\n+         loop\n+            P := Parent (P);\n+            Nkind_P := Nkind (P);\n+         end loop;\n+\n+         if Nkind (P) /= N_Exception_Handler then\n+            Error_Msg_N\n+              (\"reraise statement must appear directly in a handler\", N);\n+         end if;\n+\n+      --  Normal case with exception id present\n+\n+      else\n+         Analyze (Exception_Id);\n+\n+         if Is_Entity_Name (Exception_Id) then\n+            Exception_Name := Entity (Exception_Id);\n+\n+            if Present (Renamed_Object (Exception_Name)) then\n+               Set_Entity (Exception_Id, Renamed_Object (Exception_Name));\n+            end if;\n+         end if;\n+\n+         if No (Exception_Name)\n+           or else Ekind (Exception_Name) /= E_Exception\n+         then\n+            Error_Msg_N\n+              (\"exception name expected in raise statement\", Exception_Id);\n+         end if;\n+      end if;\n+   end Analyze_Raise_Statement;\n+\n+   -----------------------------\n+   -- Analyze_Raise_xxx_Error --\n+   -----------------------------\n+\n+   --  Normally, the Etype is already set (when this node is used within\n+   --  an expression, since it is copied from the node which it rewrites).\n+   --  If this node is used in a statement context, then we set the type\n+   --  Standard_Void_Type. This is used both by Gigi and by the front end\n+   --  to distinguish the statement use and the subexpression use.\n+\n+   --  The only other required processing is to take care of the Condition\n+   --  field if one is present.\n+\n+   procedure Analyze_Raise_xxx_Error (N : Node_Id) is\n+   begin\n+      if No (Etype (N)) then\n+         Set_Etype (N, Standard_Void_Type);\n+      end if;\n+\n+      if Present (Condition (N)) then\n+         Analyze_And_Resolve (Condition (N), Standard_Boolean);\n+      end if;\n+\n+      --  Deal with static cases in obvious manner\n+\n+      if Nkind (Condition (N)) = N_Identifier then\n+         if Entity (Condition (N)) = Standard_True then\n+            Set_Condition (N, Empty);\n+\n+         elsif Entity (Condition (N)) = Standard_False then\n+            Rewrite (N, Make_Null_Statement (Sloc (N)));\n+         end if;\n+      end if;\n+\n+   end Analyze_Raise_xxx_Error;\n+\n+   -----------------------------\n+   -- Analyze_Subprogram_Info --\n+   -----------------------------\n+\n+   procedure Analyze_Subprogram_Info (N : Node_Id) is\n+   begin\n+      Set_Etype (N, RTE (RE_Code_Loc));\n+   end Analyze_Subprogram_Info;\n+\n+end Sem_Ch11;"}, {"sha": "a56ddee2aa41a74612d2bcecf77afd32361fd312", "filename": "gcc/ada/sem_ch11.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C H 1 1                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sem_Ch11 is\n+   procedure Analyze_Exception_Declaration              (N : Node_Id);\n+   procedure Analyze_Handled_Statements                 (N : Node_Id);\n+   procedure Analyze_Raise_Statement                    (N : Node_Id);\n+   procedure Analyze_Raise_xxx_Error                    (N : Node_Id);\n+   procedure Analyze_Subprogram_Info                    (N : Node_Id);\n+\n+   procedure Analyze_Exception_Handlers (L : List_Id);\n+   --  Analyze list of exception handlers of a handled statement sequence\n+\n+end Sem_Ch11;"}, {"sha": "3f47a62627cb17d3d5362b32215e33ece04fe281", "filename": "gcc/ada/sem_ch12.adb", "status": "added", "additions": 8932, "deletions": 0, "changes": 8932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "80af1ae6dd0466a523bacb85001d6e00e189ae01", "filename": "gcc/ada/sem_ch12.ads", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,109 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C H 1 2                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Inline; use Inline;\n+with Types;  use Types;\n+\n+package Sem_Ch12 is\n+   procedure Analyze_Generic_Package_Declaration        (N : Node_Id);\n+   procedure Analyze_Generic_Subprogram_Declaration     (N : Node_Id);\n+   procedure Analyze_Package_Instantiation              (N : Node_Id);\n+   procedure Analyze_Procedure_Instantiation            (N : Node_Id);\n+   procedure Analyze_Function_Instantiation             (N : Node_Id);\n+   procedure Analyze_Formal_Object_Declaration          (N : Node_Id);\n+   procedure Analyze_Formal_Type_Declaration            (N : Node_Id);\n+   procedure Analyze_Formal_Subprogram                  (N : Node_Id);\n+   procedure Analyze_Formal_Package                     (N : Node_Id);\n+\n+   procedure Start_Generic;\n+   --  Must be invoked before starting to process a generic spec or body.\n+\n+   procedure End_Generic;\n+   --  Must be invoked just at the end of the end of the processing of a\n+   --  generic spec or body.\n+\n+   procedure Check_Generic_Child_Unit\n+     (Gen_Id           : Node_Id;\n+      Parent_Installed : in out Boolean);\n+   --  If the name of the generic unit in an instantiation or a renaming\n+   --  is a selected component, then the prefix may be an instance and the\n+   --  selector may  designate a child unit. Retrieve the parent generic\n+   --  and search for the child unit that must be declared within. Similarly,\n+   --  if this is the name of a generic child unit within an instantiation of\n+   --  its own parent, retrieve the parent generic.\n+\n+   function Copy_Generic_Node\n+     (N             : Node_Id;\n+      Parent_Id     : Node_Id;\n+      Instantiating : Boolean)\n+      return          Node_Id;\n+   --  Copy the tree for a generic unit or its body. The unit is copied\n+   --  repeatedly: once to produce a copy on which semantic analysis of\n+   --  the generic is performed, and once for each instantiation. The tree\n+   --  being copied is not semantically analyzed, except that references to\n+   --  global entities are marked on terminal nodes.\n+\n+   function Get_Instance_Of (A : Entity_Id) return Entity_Id;\n+   --  Retrieve actual associated with given generic parameter.\n+   --  If A is uninstantiated or not a generic parameter, return A.\n+\n+   procedure Instantiate_Package_Body\n+     (Body_Info : Pending_Body_Info);\n+   --  Called after semantic analysis, to complete the instantiation of\n+   --  package instances.\n+\n+   procedure Instantiate_Subprogram_Body\n+     (Body_Info : Pending_Body_Info);\n+   --  Called after semantic analysis, to complete the instantiation of\n+   --  function and procedure instances.\n+\n+   procedure Save_Global_References (N : Node_Id);\n+   --  Traverse the original generic unit, and capture all references to\n+   --  entities that are defined outside of the generic in the analyzed\n+   --  tree for the template. These references are copied into the original\n+   --  tree, so that they appear automatically in  every instantiation.\n+   --  A critical invariant in this approach is that if an id in the generic\n+   --  resolves to a local entity, the corresponding id in the instance\n+   --  will resolve to the homologous entity in the instance, even though\n+   --  the enclosing context for resolution is different, as long as the\n+   --  global references have been captured as described here.\n+\n+   --  Because instantiations can be nested, the environment of the instance,\n+   --  involving the actuals and other data-structures, must be saved and\n+   --  restored in stack-like fashion. Front-end inlining also uses these\n+   --  structures for the management of private/full views.\n+\n+   procedure Set_Copied_Sloc (N : Node_Id; E : Entity_Id);\n+\n+   procedure Save_Env\n+     (Gen_Unit : Entity_Id;\n+      Act_Unit : Entity_Id);\n+\n+   procedure Restore_Env;\n+\n+end Sem_Ch12;"}, {"sha": "ae674411d79f55e18900d094d35301a3b4c43f90", "filename": "gcc/ada/sem_ch13.adb", "status": "added", "additions": 3912, "deletions": 0, "changes": 3912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "5afe5adb2086109930e55df70e1faef1db48775d", "filename": "gcc/ada/sem_ch13.ads", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,171 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ C H 1 3                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.39 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Snames; use Snames;\n+with Types; use Types;\n+with Uintp; use Uintp;\n+\n+package Sem_Ch13 is\n+   procedure Analyze_At_Clause                          (N : Node_Id);\n+   procedure Analyze_Attribute_Definition_Clause        (N : Node_Id);\n+   procedure Analyze_Enumeration_Representation_Clause  (N : Node_Id);\n+   procedure Analyze_Free_Statement                     (N : Node_Id);\n+   procedure Analyze_Record_Representation_Clause       (N : Node_Id);\n+   procedure Analyze_Code_Statement                     (N : Node_Id);\n+\n+   procedure Initialize;\n+   --  Initialize internal tables for new compilation\n+\n+   procedure Set_Enum_Esize (T : Entity_Id);\n+   --  This routine sets the Esize field for an enumeration type T, based\n+   --  on the current representation information available for T. Note that\n+   --  the setting of the RM_Size field is not affected. This routine also\n+   --  initializes the alignment field to zero.\n+\n+   function Minimum_Size\n+     (T      : Entity_Id;\n+      Biased : Boolean := False)\n+      return   Nat;\n+   --  Given a primitive type, determines the minimum number of bits required\n+   --  to represent all values of the type. This function may not be called\n+   --  with any other types. If the flag Biased is set True, then the minimum\n+   --  size calculation that biased representation is used in the case of a\n+   --  discrete type, e.g. the range 7..8 gives a minimum size of 4 with\n+   --  Biased set to False, and 1 with Biased set to True. Note that the\n+   --  biased parameter only has an effect if the type is not biased, it\n+   --  causes Minimum_Size to indicate the minimum size of an object with\n+   --  the given type, of the size the type would have if it were biased. If\n+   --  the type is already biased, then Minimum_Size returns the biased size,\n+   --  regardless of the setting of Biased. Also, fixed-point types are never\n+   --  biased in the current implementation.\n+\n+   procedure Check_Size\n+     (N      : Node_Id;\n+      T      : Entity_Id;\n+      Siz    : Uint;\n+      Biased : out Boolean);\n+   --  Called when size Siz is specified for subtype T. This subprogram checks\n+   --  that the size is appropriate, posting errors on node N as required.\n+   --  For non-elementary types, a check is only made if an explicit size\n+   --  has been given for the type (and the specified size must match). The\n+   --  parameter Biased is set False if the size specified did not require\n+   --  the use of biased representation, and True if biased representation\n+   --  was required to meet the size requirement. Note that Biased is only\n+   --  set if the type is not currently biased, but biasing it is the only\n+   --  way to meet the requirement. If the type is currently biased, then\n+   --  this biased size is used in the initial check, and Biased is False.\n+\n+   function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance\n+   --  of a representation pragma with the given name Nam. If found then\n+   --  the value returned is the N_Pragma node, otherwise Empty is returned.\n+\n+   function Get_Attribute_Definition_Clause\n+     (E    : Entity_Id;\n+      Id   : Attribute_Id)\n+      return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance\n+   --  of an attribute definition clause with the given attibute Id Id. If\n+   --  found, the value returned is the N_Attribute_Definition_Clause node,\n+   --  otherwise Empty is returned.\n+\n+   procedure Record_Rep_Item (T : Entity_Id; N : Node_Id);\n+   --  N is the node for either a representation pragma or an attribute\n+   --  definition clause that applies to type T. This procedure links\n+   --  the node N onto the Rep_Item chain for the type T.\n+\n+   function Rep_Item_Too_Early\n+     (T     : Entity_Id;\n+      N     : Node_Id)\n+      return  Boolean;\n+   --  Called at the start of processing a representation clause or a\n+   --  representation pragma. Used to check that the representation item\n+   --  is not being applied to an incompleted type or to a generic formal\n+   --  type or a type derived from a generic formal type. Returns False if\n+   --  no such error occurs. If this error does occur, appropriate error\n+   --  messages are posted on node N, and True is returned.\n+\n+   function Rep_Item_Too_Late\n+     (T     : Entity_Id;\n+      N     : Node_Id;\n+      FOnly : Boolean := False)\n+      return  Boolean;\n+   --  Called at the start of processing a representation clause or a\n+   --  representation pragma. Used to check that a representation item\n+   --  for entity T does not appear too late (according to the rules in\n+   --  RM 13.1(9) and RM 13.1(10)). N is the associated node, which in\n+   --  the pragma case is the pragma or representation clause itself, used\n+   --  for placing error messages if the item is too late.\n+   --\n+   --  Fonly is a flag that causes only the freezing rule (para 9) to be\n+   --  applied, and the tests of para 10 are skipped. This is appropriate\n+   --  for both subtype related attributes (Alignment and Size) and for\n+   --  stream attributes, which, although certainly not subtype related\n+   --  attributes, clearly should not be subject to the para 10 restrictions\n+   --  (see AI95-00137). Similarly, we also skip the para 10 restrictions for\n+   --  the Storage_Size case where they also clearly do not apply.\n+   --\n+   --  If the rep item is too late, an appropriate message is output and\n+   --  True is returned, which is a signal that the caller should abandon\n+   --  processing for the item. If the item is not too late, then False\n+   --  is returned, and the caller can continue processing the item.\n+   --\n+   --  If no error is detected, this call also as a side effect links the\n+   --  representation item onto the head of the representation item chain\n+   --  (referenced by the First_Rep_Item field of the entity).\n+   --\n+   --  Note: Rep_Item_Too_Late must be called with the underlying type in\n+   --  the case of a private or incomplete type. The protocol is to first\n+   --  check for Rep_Item_Too_Early using the initial entity, then take the\n+   --  underlying type, then call Rep_Item_Too_Late on the result.\n+\n+   function Same_Representation (Typ1, Typ2 : Entity_Id) return Boolean;\n+   --  Given two types, where the two types are related by possible derivation,\n+   --  determines if the two types have the same representation, or different\n+   --  representations, requiring the special processing for representation\n+   --  change. A False result is possible only for array, enumeration or\n+   --  record types.\n+\n+   procedure Validate_Unchecked_Conversion\n+     (N        : Node_Id;\n+      Act_Unit : Entity_Id);\n+   --  Validate a call to unchecked conversion. N is the node for the actual\n+   --  instantiation, which is used only for error messages. Act_Unit is the\n+   --  entity for the instantiation, from which the actual types etc for this\n+   --  instantiation can be determined. This procedure makes an entry in a\n+   --  table and/or generates an N_Validate_Unchecked_Conversion node. The\n+   --  actual checking is done in Validate_Unchecked_Conversions or in the\n+   --  back end as required.\n+\n+   procedure Validate_Unchecked_Conversions;\n+   --  This routine is called after calling the backend to validate\n+   --  unchecked conversions for size and alignment appropriateness.\n+   --  The reason it is called that late is to take advantage of any\n+   --  back-annotation of size and alignment performed by the backend.\n+\n+end Sem_Ch13;"}, {"sha": "f8e85b3c02ad6a99d4791a4c473c1be2fe770b61", "filename": "gcc/ada/sem_ch2.adb", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 2                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n+\n+package body Sem_Ch2 is\n+\n+   -------------------------------\n+   -- Analyze_Character_Literal --\n+   -------------------------------\n+\n+   procedure Analyze_Character_Literal (N : Node_Id) is\n+   begin\n+\n+      --  The type is eventually inherited from the context. If expansion\n+      --  has already established the proper type, do not modify it.\n+\n+      if No (Etype (N)) then\n+         Set_Etype (N, Any_Character);\n+      end if;\n+\n+      Set_Is_Static_Expression (N);\n+\n+      if Comes_From_Source (N)\n+        and then not In_Character_Range (Char_Literal_Value (N))\n+      then\n+         Check_Restriction (No_Wide_Characters, N);\n+      end if;\n+   end Analyze_Character_Literal;\n+\n+   ------------------------\n+   -- Analyze_Identifier --\n+   ------------------------\n+\n+   procedure Analyze_Identifier (N : Node_Id) is\n+   begin\n+      Find_Direct_Name (N);\n+   end Analyze_Identifier;\n+\n+   -----------------------------\n+   -- Analyze_Integer_Literal --\n+   -----------------------------\n+\n+   procedure Analyze_Integer_Literal (N : Node_Id) is\n+   begin\n+      Set_Etype (N, Universal_Integer);\n+      Set_Is_Static_Expression (N);\n+   end Analyze_Integer_Literal;\n+\n+   --------------------------\n+   -- Analyze_Real_Literal --\n+   --------------------------\n+\n+   procedure Analyze_Real_Literal (N : Node_Id) is\n+   begin\n+      Set_Etype (N, Universal_Real);\n+      Set_Is_Static_Expression (N);\n+   end Analyze_Real_Literal;\n+\n+   ----------------------------\n+   -- Analyze_String_Literal --\n+   ----------------------------\n+\n+   procedure Analyze_String_Literal (N : Node_Id) is\n+   begin\n+\n+      --  The type is eventually inherited from the context. If expansion\n+      --  has already established the proper type, do not modify it.\n+\n+      if No (Etype (N)) then\n+         Set_Etype (N, Any_String);\n+      end if;\n+\n+      --  String literals are static in Ada 95. Note that if the subtype\n+      --  turns out to be non-static, then the Is_Static_Expression flag\n+      --  will be reset in Eval_String_Literal.\n+\n+      if Ada_95 then\n+         Set_Is_Static_Expression (N);\n+      end if;\n+\n+      if Comes_From_Source (N) and then Has_Wide_Character (N) then\n+         Check_Restriction (No_Wide_Characters, N);\n+      end if;\n+   end Analyze_String_Literal;\n+\n+end Sem_Ch2;"}, {"sha": "d85de7f8b056137d463152000e2cf6bcda3f71c5", "filename": "gcc/ada/sem_ch2.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 2                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Sem_Ch2 is\n+\n+   procedure Analyze_Character_Literal (N : Node_Id);\n+   procedure Analyze_Identifier        (N : Node_Id);\n+   procedure Analyze_Integer_Literal   (N : Node_Id);\n+   procedure Analyze_Real_Literal      (N : Node_Id);\n+   procedure Analyze_String_Literal    (N : Node_Id);\n+\n+private\n+   pragma Inline (Analyze_Character_Literal);\n+   pragma Inline (Analyze_Identifier);\n+   pragma Inline (Analyze_Integer_Literal);\n+   pragma Inline (Analyze_Real_Literal);\n+   pragma Inline (Analyze_String_Literal);\n+\n+end Sem_Ch2;"}, {"sha": "dd9b6b07e737185c3c17fe916a2ebcb4b9453ee6", "filename": "gcc/ada/sem_ch3.adb", "status": "added", "additions": 12122, "deletions": 0, "changes": 12122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "aefb310c647ff7c9412ebe750dc7a77252a582c7", "filename": "gcc/ada/sem_ch3.ads", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,224 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 3                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.57 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Nlists; use Nlists;\n+with Types;  use Types;\n+\n+package Sem_Ch3  is\n+   procedure Analyze_Component_Declaration              (N : Node_Id);\n+   procedure Analyze_Incomplete_Type_Decl               (N : Node_Id);\n+   procedure Analyze_Itype_Reference                    (N : Node_Id);\n+   procedure Analyze_Number_Declaration                 (N : Node_Id);\n+   procedure Analyze_Object_Declaration                 (N : Node_Id);\n+   procedure Analyze_Others_Choice                      (N : Node_Id);\n+   procedure Analyze_Private_Extension_Declaration      (N : Node_Id);\n+   procedure Analyze_Subtype_Declaration                (N : Node_Id);\n+   procedure Analyze_Subtype_Indication                 (N : Node_Id);\n+   procedure Analyze_Type_Declaration                   (N : Node_Id);\n+   procedure Analyze_Variant_Part                       (N : Node_Id);\n+\n+   function Access_Definition\n+     (Related_Nod : Node_Id;\n+      N           : Node_Id)\n+      return        Entity_Id;\n+   --  An access definition defines a general access type for a formal\n+   --  parameter.  The procedure is called when processing formals, when\n+   --  the current scope is the subprogram. The Implicit type is attached\n+   --  to the Related_Nod put into the enclosing scope, so that the only\n+   --  entities defined in the spec are the formals themselves.\n+\n+   procedure Access_Subprogram_Declaration\n+     (T_Name : Entity_Id;\n+      T_Def  : Node_Id);\n+   --  The subprogram specification yields the signature of an implicit\n+   --  type, whose Ekind is Access_Subprogram_Type. This implicit type is\n+   --  the designated type of the declared access type. In subprogram calls,\n+   --  the signature of the implicit type works like the profile of a regular\n+   --  subprogram.\n+\n+   procedure Analyze_Declarations (L : List_Id);\n+   --  Called to analyze a list of declarations (in what context ???). Also\n+   --  performs necessary freezing actions (more description needed ???)\n+\n+   procedure Analyze_Default_Expression (N : Node_Id; T : Entity_Id);\n+   --  Default expressions do not freeze their components, and must be\n+   --  analyzed and resolved accordingly, by calling the\n+   --  Pre_Analyze_And_Resolve routine and setting the global\n+   --  In_Default_Expression flag.\n+\n+   procedure Array_Type_Declaration (T : in out Entity_Id; Def : Node_Id);\n+   --  Process an array type declaration. If the array is constrained, we\n+   --  create an implicit parent array type, with the same index types and\n+   --  component type.\n+\n+   procedure Access_Type_Declaration (T : Entity_Id; Def : Node_Id);\n+   --  Process an access type declaration\n+\n+   procedure Check_Abstract_Overriding (T : Entity_Id);\n+   --  Check that all abstract subprograms inherited from T's parent type\n+   --  have been overridden as required, and that nonabstract subprograms\n+   --  have not been incorrectly overridden with an abstract subprogram.\n+\n+   procedure Check_Aliased_Component_Types (T : Entity_Id);\n+   --  Given an array type or record type T, check that if the type is\n+   --  nonlimited, then the nominal subtype of any components of T\n+   --  that have discriminants must be constrained.\n+\n+   procedure Check_Completion (Body_Id : Node_Id := Empty);\n+   --  At the end of a declarative part, verify that all entities that\n+   --  require completion have received one. If Body_Id is absent, the\n+   --  error indicating a missing completion is placed on the declaration\n+   --  that needs completion. If Body_Id is present, it is the defining\n+   --  identifier of a package body, and errors are posted on that node,\n+   --  rather than on the declarations that require completion in the package\n+   --  declaration.\n+\n+   procedure Derive_Subprogram\n+     (New_Subp       : in out Entity_Id;\n+      Parent_Subp    : Entity_Id;\n+      Derived_Type   : Entity_Id;\n+      Parent_Type    : Entity_Id;\n+      Actual_Subp    : Entity_Id := Empty);\n+   --  Derive the subprogram Parent_Subp from Parent_Type, and replace the\n+   --  subsidiary subtypes with the derived type to build the specification\n+   --  of the inherited subprogram (returned in New_Subp). For tagged types,\n+   --  the derived subprogram is aliased to that of the actual (in the\n+   --  case where Actual_Subp is nonempty) rather than to the corresponding\n+   --  subprogram of the parent type.\n+\n+   procedure Derive_Subprograms\n+     (Parent_Type    : Entity_Id;\n+      Derived_Type   : Entity_Id;\n+      Generic_Actual : Entity_Id := Empty);\n+   --  To complete type derivation, collect or retrieve the primitive\n+   --  operations of the parent type, and replace the subsidiary subtypes\n+   --  with the derived type, to build the specs of the inherited ops.\n+   --  For generic actuals, the mapping of the primitive operations to those\n+   --  of the parent type is also done by rederiving the operations within\n+   --  the instance. For tagged types, the derived subprograms are aliased to\n+   --  those of the actual, not those of the ancestor.\n+\n+   function Expand_To_Girder_Constraint\n+     (Typ        : Entity_Id;\n+      Constraint : Elist_Id)\n+      return       Elist_Id;\n+   --  Given a Constraint (ie a list of expressions) on the discriminants of\n+   --  Typ, expand it into a constraint on the girder discriminants and\n+   --  return the new list of expressions constraining the girder\n+   --  discriminants.\n+\n+   function Find_Type_Name (N : Node_Id) return Entity_Id;\n+   --  Enter the identifier in a type definition, or find the entity already\n+   --  declared, in the case of the full declaration of an incomplete or\n+   --  private type.\n+\n+   function Get_Discriminant_Value\n+     (Discriminant         : Entity_Id;\n+      Typ_For_Constraint   : Entity_Id;\n+      Constraint           : Elist_Id)\n+      return                 Node_Id;\n+   --  ??? MORE DOCUMENTATION\n+   --  Given a discriminant somewhere in the Typ_For_Constraint tree\n+   --  and a Constraint, return the value of that discriminant.\n+\n+   function Is_Visible_Component (C : Entity_Id) return Boolean;\n+   --  Determines if a record component C is visible in the present context.\n+   --  Note that even though component C could appear in the entity chain\n+   --  of a record type, C may not be visible in the current context. For\n+   --  instance, C may be a component inherited in the full view of a private\n+   --  extension which is not visible in the current context.\n+\n+   procedure Make_Index\n+     (I            : Node_Id;\n+      Related_Nod  : Node_Id;\n+      Related_Id   : Entity_Id := Empty;\n+      Suffix_Index : Nat := 1);\n+   --  Process an index that is given in an array declaration, an entry\n+   --  family declaration or a loop iteration. The index is given by an\n+   --  index declaration (a 'box'), or by a discrete range. The later can\n+   --  be the name of a discrete type, or a subtype indication.\n+   --  Related_Nod is the node where the potential generated implicit types\n+   --  will be inserted. The 2 last parameters are used for creating the name.\n+\n+   procedure Make_Class_Wide_Type (T : Entity_Id);\n+   --  A Class_Wide_Type is created for each tagged type definition. The\n+   --  attributes of a class wide type are inherited from those of the type\n+   --  T. If T is introduced by a private declaration, the corresponding\n+   --  class wide type is created at the same time, and therefore there is\n+   --  a private and a full declaration for the class wide type type as well.\n+\n+   procedure Process_Full_View (N : Node_Id; Full_T, Priv_T : Entity_Id);\n+   --  Process some semantic actions when the full view of a private type is\n+   --  encountered and analyzed. The first action is to create the full views\n+   --  of the dependant private subtypes. The second action is to recopy the\n+   --  primitive operations of the private view (in the tagged case).\n+   --  N is the N_Full_Type_Declaration node.\n+\n+   --    Full_T is the full view of the type whose full declaration is in N.\n+   --\n+   --    Priv_T is the private view of the type whose full declaration is in N.\n+\n+   procedure Process_Range_Expr_In_Decl\n+     (R           : Node_Id;\n+      T           : Entity_Id;\n+      Related_Nod : Node_Id;\n+      Check_List  : List_Id := Empty_List;\n+      R_Check_Off : Boolean := False);\n+   --  Process a range expression that appears in a declaration context. The\n+   --  range is analyzed and resolved with the base type of the given type,\n+   --  and an appropriate check for expressions in non-static contexts made\n+   --  on the bounds. R is analyzed and resolved using T, so the caller should\n+   --  if necessary link R into the tree before the call, and in particular in\n+   --  the case of a subtype declaration, it is appropriate to set the parent\n+   --  pointer of R so that the types get properly frozen. The Check_List\n+   --  parameter is used when the subprogram is called from\n+   --  Build_Record_Init_Proc and is used to return a set of constraint\n+   --  checking statements generated by the Checks package. R_Check_Off is\n+   --  set to True when the call to Range_Check is to be skipped.\n+\n+   function Process_Subtype\n+     (S           : Node_Id;\n+      Related_Nod : Node_Id;\n+      Related_Id  : Entity_Id := Empty;\n+      Suffix      : Character := ' ')\n+      return        Entity_Id;\n+   --  Process a subtype indication S and return corresponding entity.\n+   --  Related_Nod is the node where the potential generated implicit types\n+   --  will be inserted. The Related_Id and Suffix parameters are used to\n+   --  build the associated Implicit type name.\n+\n+   procedure Process_Discriminants (N : Node_Id);\n+   --  Process the discriminants contained in an N_Full_Type_Declaration or\n+   --  N_Incomplete_Type_Decl node N.\n+\n+   procedure Set_Girder_Constraint_From_Discriminant_Constraint\n+     (E : Entity_Id);\n+   --  E is some record type. This routine computes E's Girder_Constraint\n+   --  from its Discriminant_Constraint.\n+\n+end Sem_Ch3;"}, {"sha": "31f244d2795b7a0a716183c38addbfbc07c48312", "filename": "gcc/ada/sem_ch4.adb", "status": "added", "additions": 4272, "deletions": 0, "changes": 4272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "236785facc831d0ec5edf8848dddfe8f5542c9c9", "filename": "gcc/ada/sem_ch4.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,66 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 4                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.18 $                             --\n+--                                                                          --\n+--   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Sem_Ch4  is\n+   procedure Analyze_Aggregate                          (N : Node_Id);\n+   procedure Analyze_Allocator                          (N : Node_Id);\n+   procedure Analyze_Arithmetic_Op                      (N : Node_Id);\n+   procedure Analyze_Call                               (N : Node_Id);\n+   procedure Analyze_Comparison_Op                      (N : Node_Id);\n+   procedure Analyze_Concatenation                      (N : Node_Id);\n+   procedure Analyze_Conditional_Expression             (N : Node_Id);\n+   procedure Analyze_Equality_Op                        (N : Node_Id);\n+   procedure Analyze_Explicit_Dereference               (N : Node_Id);\n+   procedure Analyze_Logical_Op                         (N : Node_Id);\n+   procedure Analyze_Membership_Op                      (N : Node_Id);\n+   procedure Analyze_Negation                           (N : Node_Id);\n+   procedure Analyze_Null                               (N : Node_Id);\n+   procedure Analyze_Qualified_Expression               (N : Node_Id);\n+   procedure Analyze_Range                              (N : Node_Id);\n+   procedure Analyze_Reference                          (N : Node_Id);\n+   procedure Analyze_Selected_Component                 (N : Node_Id);\n+   procedure Analyze_Short_Circuit                      (N : Node_Id);\n+   procedure Analyze_Slice                              (N : Node_Id);\n+   procedure Analyze_Type_Conversion                    (N : Node_Id);\n+   procedure Analyze_Unary_Op                           (N : Node_Id);\n+   procedure Analyze_Unchecked_Expression               (N : Node_Id);\n+   procedure Analyze_Unchecked_Type_Conversion          (N : Node_Id);\n+\n+   procedure Analyze_Indexed_Component_Form (N : Node_Id);\n+   --  Prior to semantic analysis, an indexed component node can denote any\n+   --  of the following syntactic constructs:\n+   --    a) An indexed component of an array\n+   --    b) A function call\n+   --    c) A conversion\n+   --    d) A slice\n+   --  The resolution of the construct requires some semantic information\n+   --  on the prefix and the indices.\n+\n+end Sem_Ch4;"}, {"sha": "658a685ced77ac5b8a1a04cd98ecc8468573328b", "filename": "gcc/ada/sem_ch5.adb", "status": "added", "additions": 1256, "deletions": 0, "changes": 1256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1256 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 5                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.262 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Checks;   use Checks;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Expander; use Expander;\n+with Exp_Util; use Exp_Util;\n+with Freeze;   use Freeze;\n+with Lib.Xref; use Lib.Xref;\n+with Nlists;   use Nlists;\n+with Opt;      use Opt;\n+with Sem;      use Sem;\n+with Sem_Case; use Sem_Case;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Disp; use Sem_Disp;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n+with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n+with Stand;    use Stand;\n+with Sinfo;    use Sinfo;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+\n+package body Sem_Ch5 is\n+\n+   Unblocked_Exit_Count : Nat := 0;\n+   --  This variable is used when processing if statements or case\n+   --  statements, it counts the number of branches of the conditional\n+   --  that are not blocked by unconditional transfer instructions. At\n+   --  the end of processing, if the count is zero, it means that control\n+   --  cannot fall through the conditional statement. This is used for\n+   --  the generation of warning messages. This variable is recursively\n+   --  saved on entry to processing an if or case, and restored on exit.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Analyze_Iteration_Scheme (N : Node_Id);\n+\n+   ------------------------\n+   -- Analyze_Assignment --\n+   ------------------------\n+\n+   procedure Analyze_Assignment (N : Node_Id) is\n+      Lhs    : constant Node_Id := Name (N);\n+      Rhs    : constant Node_Id := Expression (N);\n+      T1, T2 : Entity_Id;\n+      Decl   : Node_Id;\n+\n+      procedure Diagnose_Non_Variable_Lhs (N : Node_Id);\n+      --  N is the node for the left hand side of an assignment, and it\n+      --  is not a variable. This routine issues an appropriate diagnostic.\n+\n+      procedure Set_Assignment_Type\n+        (Opnd      : Node_Id;\n+         Opnd_Type : in out Entity_Id);\n+      --  Opnd is either the Lhs or Rhs of the assignment, and Opnd_Type\n+      --  is the nominal subtype. This procedure is used to deal with cases\n+      --  where the nominal subtype must be replaced by the actual subtype.\n+\n+      -------------------------------\n+      -- Diagnose_Non_Variable_Lhs --\n+      -------------------------------\n+\n+      procedure Diagnose_Non_Variable_Lhs (N : Node_Id) is\n+      begin\n+         --  Not worth posting another error if left hand side already\n+         --  flagged as being illegal in some respect\n+\n+         if Error_Posted (N) then\n+            return;\n+\n+         --  Some special bad cases of entity names\n+\n+         elsif Is_Entity_Name (N) then\n+\n+            if Ekind (Entity (N)) = E_In_Parameter then\n+               Error_Msg_N\n+                 (\"assignment to IN mode parameter not allowed\", N);\n+               return;\n+\n+            --  Private declarations in a protected object are turned into\n+            --  constants when compiling a protected function.\n+\n+            elsif Present (Scope (Entity (N)))\n+              and then Is_Protected_Type (Scope (Entity (N)))\n+              and then\n+                (Ekind (Current_Scope) = E_Function\n+                  or else\n+                 Ekind (Enclosing_Dynamic_Scope (Current_Scope)) = E_Function)\n+            then\n+               Error_Msg_N\n+                 (\"protected function cannot modify protected object\", N);\n+               return;\n+\n+            elsif Ekind (Entity (N)) = E_Loop_Parameter then\n+               Error_Msg_N\n+                 (\"assignment to loop parameter not allowed\", N);\n+               return;\n+\n+            end if;\n+\n+         --  For indexed components, or selected components, test prefix\n+\n+         elsif Nkind (N) = N_Indexed_Component\n+           or else Nkind (N) = N_Selected_Component\n+         then\n+            Diagnose_Non_Variable_Lhs (Prefix (N));\n+            return;\n+         end if;\n+\n+         --  If we fall through, we have no special message to issue!\n+\n+         Error_Msg_N (\"left hand side of assignment must be a variable\", N);\n+\n+      end Diagnose_Non_Variable_Lhs;\n+\n+      -------------------------\n+      -- Set_Assignment_Type --\n+      -------------------------\n+\n+      procedure Set_Assignment_Type\n+        (Opnd      : Node_Id;\n+         Opnd_Type : in out Entity_Id)\n+      is\n+      begin\n+         --  If the assignment operand is an in-out or out parameter, then we\n+         --  get the actual subtype (needed for the unconstrained case).\n+\n+         if Is_Entity_Name (Opnd)\n+           and then (Ekind (Entity (Opnd)) = E_Out_Parameter\n+                      or else Ekind (Entity (Opnd)) =\n+                           E_In_Out_Parameter\n+                      or else Ekind (Entity (Opnd)) =\n+                           E_Generic_In_Out_Parameter)\n+         then\n+            Opnd_Type := Get_Actual_Subtype (Opnd);\n+\n+         --  If assignment operand is a component reference, then we get the\n+         --  actual subtype of the component for the unconstrained case.\n+\n+         elsif Nkind (Opnd) = N_Selected_Component\n+           or else Nkind (Opnd) = N_Explicit_Dereference\n+         then\n+            Decl := Build_Actual_Subtype_Of_Component (Opnd_Type, Opnd);\n+\n+            if Present (Decl) then\n+               Insert_Action (N, Decl);\n+               Mark_Rewrite_Insertion (Decl);\n+               Analyze (Decl);\n+               Opnd_Type := Defining_Identifier (Decl);\n+               Set_Etype (Opnd, Opnd_Type);\n+               Freeze_Itype (Opnd_Type, N);\n+\n+            elsif Is_Constrained (Etype (Opnd)) then\n+               Opnd_Type := Etype (Opnd);\n+            end if;\n+\n+         --  For slice, use the constrained subtype created for the slice\n+\n+         elsif Nkind (Opnd) = N_Slice then\n+            Opnd_Type := Etype (Opnd);\n+         end if;\n+      end Set_Assignment_Type;\n+\n+   --  Start of processing for Analyze_Assignment\n+\n+   begin\n+      Analyze (Rhs);\n+      Analyze (Lhs);\n+      T1 := Etype (Lhs);\n+\n+      --  In the most general case, both Lhs and Rhs can be overloaded, and we\n+      --  must compute the intersection of the possible types on each side.\n+\n+      if Is_Overloaded (Lhs) then\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+\n+         begin\n+            T1 := Any_Type;\n+            Get_First_Interp (Lhs, I, It);\n+\n+            while Present (It.Typ) loop\n+               if Has_Compatible_Type (Rhs, It.Typ) then\n+\n+                  if T1 /= Any_Type then\n+\n+                     --  An explicit dereference is overloaded if the prefix\n+                     --  is. Try to remove the ambiguity on the prefix, the\n+                     --  error will be posted there if the ambiguity is real.\n+\n+                     if Nkind (Lhs) = N_Explicit_Dereference then\n+                        declare\n+                           PI    : Interp_Index;\n+                           PI1   : Interp_Index := 0;\n+                           PIt   : Interp;\n+                           Found : Boolean;\n+\n+                        begin\n+                           Found := False;\n+                           Get_First_Interp (Prefix (Lhs), PI, PIt);\n+\n+                           while Present (PIt.Typ) loop\n+                              if Has_Compatible_Type (Rhs,\n+                                Designated_Type (PIt.Typ))\n+                              then\n+                                 if Found then\n+                                    PIt :=\n+                                      Disambiguate (Prefix (Lhs),\n+                                        PI1, PI, Any_Type);\n+\n+                                    if PIt = No_Interp then\n+                                       return;\n+                                    else\n+                                       Resolve (Prefix (Lhs), PIt.Typ);\n+                                    end if;\n+\n+                                    exit;\n+                                 else\n+                                    Found := True;\n+                                    PI1 := PI;\n+                                 end if;\n+                              end if;\n+\n+                              Get_Next_Interp (PI, PIt);\n+                           end loop;\n+                        end;\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"ambiguous left-hand side in assignment\", Lhs);\n+                        exit;\n+                     end if;\n+                  else\n+                     T1 := It.Typ;\n+                  end if;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end;\n+\n+         if T1 = Any_Type then\n+            Error_Msg_N\n+              (\"no valid types for left-hand side for assignment\", Lhs);\n+            return;\n+         end if;\n+      end if;\n+\n+      Resolve (Lhs, T1);\n+\n+      if not Is_Variable (Lhs) then\n+         Diagnose_Non_Variable_Lhs (Lhs);\n+         return;\n+\n+      elsif Is_Limited_Type (T1)\n+        and then not Assignment_OK (Lhs)\n+        and then not Assignment_OK (Original_Node (Lhs))\n+      then\n+         Error_Msg_N\n+           (\"left hand of assignment must not be limited type\", Lhs);\n+         return;\n+      end if;\n+\n+      --  Resolution may have updated the subtype, in case the left-hand\n+      --  side is a private protected component. Use the correct subtype\n+      --  to avoid scoping issues in the back-end.\n+\n+      T1 := Etype (Lhs);\n+      Set_Assignment_Type (Lhs, T1);\n+\n+      Resolve (Rhs, T1);\n+\n+      --  Remaining steps are skipped if Rhs was synatactically in error\n+\n+      if Rhs = Error then\n+         return;\n+      end if;\n+\n+      T2 := Etype (Rhs);\n+      Check_Unset_Reference (Rhs);\n+      Note_Possible_Modification (Lhs);\n+\n+      if Covers (T1, T2) then\n+         null;\n+      else\n+         Wrong_Type (Rhs, Etype (Lhs));\n+         return;\n+      end if;\n+\n+      Set_Assignment_Type (Rhs, T2);\n+\n+      if T1 = Any_Type or else T2 = Any_Type then\n+         return;\n+      end if;\n+\n+      if (Is_Class_Wide_Type (T2) or else Is_Dynamically_Tagged (Rhs))\n+        and then not Is_Class_Wide_Type (T1)\n+      then\n+         Error_Msg_N (\"dynamically tagged expression not allowed!\", Rhs);\n+\n+      elsif Is_Class_Wide_Type (T1)\n+        and then not Is_Class_Wide_Type (T2)\n+        and then not Is_Tag_Indeterminate (Rhs)\n+        and then not Is_Dynamically_Tagged (Rhs)\n+      then\n+         Error_Msg_N (\"dynamically tagged expression required!\", Rhs);\n+      end if;\n+\n+      --  Tag propagation is done only in semantics mode only. If expansion\n+      --  is on, the rhs tag indeterminate function call has been expanded\n+      --  and tag propagation would have happened too late, so the\n+      --  propagation take place in expand_call instead.\n+\n+      if not Expander_Active\n+        and then Is_Class_Wide_Type (T1)\n+        and then Is_Tag_Indeterminate (Rhs)\n+      then\n+         Propagate_Tag (Lhs, Rhs);\n+      end if;\n+\n+      if Is_Scalar_Type (T1) then\n+         Apply_Scalar_Range_Check (Rhs, Etype (Lhs));\n+\n+      elsif Is_Array_Type (T1) then\n+\n+         --  Assignment verifies that the length of the Lsh and Rhs are equal,\n+         --  but of course the indices do not have to match.\n+\n+         Apply_Length_Check (Rhs, Etype (Lhs));\n+\n+      else\n+         --  Discriminant checks are applied in the course of expansion.\n+         null;\n+      end if;\n+\n+      --  ??? a real accessibility check is needed when ???\n+\n+      --  Post warning for useless assignment\n+\n+      if Warn_On_Redundant_Constructs\n+\n+         --  We only warn for source constructs\n+\n+         and then Comes_From_Source (N)\n+\n+         --  Where the entity is the same on both sides\n+\n+         and then Is_Entity_Name (Lhs)\n+         and then Is_Entity_Name (Rhs)\n+         and then Entity (Lhs) = Entity (Rhs)\n+\n+         --  But exclude the case where the right side was an operation\n+         --  that got rewritten (e.g. JUNK + K, where K was known to be\n+         --  zero). We don't want to warn in such a case, since it is\n+         --  reasonable to write such expressions especially when K is\n+         --  defined symbolically in some other package.\n+\n+        and then Nkind (Original_Node (Rhs)) not in N_Op\n+      then\n+         Error_Msg_NE\n+           (\"?useless assignment of & to itself\", N, Entity (Lhs));\n+      end if;\n+   end Analyze_Assignment;\n+\n+   -----------------------------\n+   -- Analyze_Block_Statement --\n+   -----------------------------\n+\n+   procedure Analyze_Block_Statement (N : Node_Id) is\n+      Decls : constant List_Id := Declarations (N);\n+      Id    : constant Node_Id := Identifier (N);\n+      Ent   : Entity_Id;\n+\n+   begin\n+      --  If a label is present analyze it and mark it as referenced\n+\n+      if Present (Id) then\n+         Analyze (Id);\n+         Ent := Entity (Id);\n+         Set_Ekind (Ent, E_Block);\n+         Generate_Reference (Ent, N, ' ');\n+         Generate_Definition (Ent);\n+\n+         if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n+            Set_Label_Construct (Parent (Ent), N);\n+         end if;\n+\n+      --  Otherwise create a label entity\n+\n+      else\n+         Ent := New_Internal_Entity (E_Block, Current_Scope, Sloc (N), 'B');\n+         Set_Identifier (N, New_Occurrence_Of (Ent, Sloc (N)));\n+      end if;\n+\n+      Set_Etype (Ent, Standard_Void_Type);\n+      Set_Block_Node (Ent, N);\n+      New_Scope (Ent);\n+\n+      if Present (Decls) then\n+         Analyze_Declarations (Decls);\n+         Check_Completion;\n+      end if;\n+\n+      Analyze (Handled_Statement_Sequence (N));\n+      Process_End_Label (Handled_Statement_Sequence (N), 'e');\n+\n+      --  Analyze exception handlers if present. Note that the test for\n+      --  HSS being present is an error defence against previous errors.\n+\n+      if Present (Handled_Statement_Sequence (N))\n+        and then Present (Exception_Handlers (Handled_Statement_Sequence (N)))\n+      then\n+         declare\n+            S : Entity_Id := Scope (Ent);\n+\n+         begin\n+            --  Indicate that enclosing scopes contain a block with handlers.\n+            --  Only non-generic scopes need to be marked.\n+\n+            loop\n+               Set_Has_Nested_Block_With_Handler (S);\n+               exit when Is_Overloadable (S)\n+                 or else Ekind (S) = E_Package\n+                 or else Ekind (S) = E_Generic_Function\n+                 or else Ekind (S) = E_Generic_Package\n+                 or else Ekind (S) = E_Generic_Procedure;\n+               S := Scope (S);\n+            end loop;\n+         end;\n+      end if;\n+\n+      Check_References (Ent);\n+      End_Scope;\n+   end Analyze_Block_Statement;\n+\n+   ----------------------------\n+   -- Analyze_Case_Statement --\n+   ----------------------------\n+\n+   procedure Analyze_Case_Statement (N : Node_Id) is\n+\n+      Statements_Analyzed : Boolean := False;\n+      --  Set True if at least some statement sequences get analyzed.\n+      --  If False on exit, means we had a serious error that prevented\n+      --  full analysis of the case statement, and as a result it is not\n+      --  a good idea to output warning messages about unreachable code.\n+\n+      Save_Unblocked_Exit_Count : constant Nat := Unblocked_Exit_Count;\n+      --  Recursively save value of this global, will be restored on exit\n+\n+      procedure Non_Static_Choice_Error (Choice : Node_Id);\n+      --  Error routine invoked by the generic instantiation below when\n+      --  the case statment has a non static choice.\n+\n+      procedure Process_Statements (Alternative : Node_Id);\n+      --  Analyzes all the statements associated to a case alternative.\n+      --  Needed by the generic instantiation below.\n+\n+      package Case_Choices_Processing is new\n+        Generic_Choices_Processing\n+          (Get_Alternatives          => Alternatives,\n+           Get_Choices               => Discrete_Choices,\n+           Process_Empty_Choice      => No_OP,\n+           Process_Non_Static_Choice => Non_Static_Choice_Error,\n+           Process_Associated_Node   => Process_Statements);\n+      use Case_Choices_Processing;\n+      --  Instantiation of the generic choice processing package.\n+\n+      -----------------------------\n+      -- Non_Static_Choice_Error --\n+      -----------------------------\n+\n+      procedure Non_Static_Choice_Error (Choice : Node_Id) is\n+      begin\n+         Error_Msg_N (\"choice given in case statement is not static\", Choice);\n+      end Non_Static_Choice_Error;\n+\n+      ------------------------\n+      -- Process_Statements --\n+      ------------------------\n+\n+      procedure Process_Statements (Alternative : Node_Id) is\n+      begin\n+         Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n+         Statements_Analyzed := True;\n+         Analyze_Statements (Statements (Alternative));\n+      end Process_Statements;\n+\n+      --  Variables local to Analyze_Case_Statement.\n+\n+      Exp       : Node_Id;\n+      Exp_Type  : Entity_Id;\n+      Exp_Btype : Entity_Id;\n+\n+      Case_Table     : Choice_Table_Type (1 .. Number_Of_Choices (N));\n+      Last_Choice    : Nat;\n+      Dont_Care      : Boolean;\n+      Others_Present : Boolean;\n+\n+   --  Start of processing for Analyze_Case_Statement\n+\n+   begin\n+      Unblocked_Exit_Count := 0;\n+      Exp := Expression (N);\n+      Analyze_And_Resolve (Exp, Any_Discrete);\n+      Check_Unset_Reference (Exp);\n+      Exp_Type  := Etype (Exp);\n+      Exp_Btype := Base_Type (Exp_Type);\n+\n+      --  The expression must be of a discrete type which must be determinable\n+      --  independently of the context in which the expression occurs, but\n+      --  using the fact that the expression must be of a discrete type.\n+      --  Moreover, the type this expression must not be a character literal\n+      --  (which is always ambiguous) or, for Ada-83, a generic formal type.\n+\n+      --  If error already reported by Resolve, nothing more to do\n+\n+      if Exp_Btype = Any_Discrete\n+        or else Exp_Btype = Any_Type\n+      then\n+         return;\n+\n+      elsif Exp_Btype = Any_Character then\n+         Error_Msg_N\n+           (\"character literal as case expression is ambiguous\", Exp);\n+         return;\n+\n+      elsif Ada_83\n+        and then (Is_Generic_Type (Exp_Btype)\n+                    or else Is_Generic_Type (Root_Type (Exp_Btype)))\n+      then\n+         Error_Msg_N\n+           (\"(Ada 83) case expression cannot be of a generic type\", Exp);\n+         return;\n+      end if;\n+\n+      --  If the case expression is a formal object of mode in out,\n+      --  then treat it as having a nonstatic subtype by forcing\n+      --  use of the base type (which has to get passed to\n+      --  Check_Case_Choices below).  Also use base type when\n+      --  the case expression is parenthesized.\n+\n+      if Paren_Count (Exp) > 0\n+        or else (Is_Entity_Name (Exp)\n+                  and then Ekind (Entity (Exp)) = E_Generic_In_Out_Parameter)\n+      then\n+         Exp_Type := Exp_Btype;\n+      end if;\n+\n+      --  Call the instantiated Analyze_Choices which does the rest of the work\n+\n+      Analyze_Choices\n+        (N, Exp_Type, Case_Table, Last_Choice, Dont_Care, Others_Present);\n+\n+      if Exp_Type = Universal_Integer and then not Others_Present then\n+         Error_Msg_N (\"case on universal integer requires OTHERS choice\", Exp);\n+      end if;\n+\n+      --  If all our exits were blocked by unconditional transfers of control,\n+      --  then the entire CASE statement acts as an unconditional transfer of\n+      --  control, so treat it like one, and check unreachable code. Skip this\n+      --  test if we had serious errors preventing any statement analysis.\n+\n+      if Unblocked_Exit_Count = 0 and then Statements_Analyzed then\n+         Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+         Check_Unreachable_Code (N);\n+      else\n+         Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+      end if;\n+   end Analyze_Case_Statement;\n+\n+   ----------------------------\n+   -- Analyze_Exit_Statement --\n+   ----------------------------\n+\n+   --  If the exit includes a name, it must be the name of a currently open\n+   --  loop. Otherwise there must be an innermost open loop on the stack,\n+   --  to which the statement implicitly refers.\n+\n+   procedure Analyze_Exit_Statement (N : Node_Id) is\n+      Target   : constant Node_Id := Name (N);\n+      Cond     : constant Node_Id := Condition (N);\n+      Scope_Id : Entity_Id;\n+      U_Name   : Entity_Id;\n+      Kind     : Entity_Kind;\n+\n+   begin\n+      if No (Cond) then\n+         Check_Unreachable_Code (N);\n+      end if;\n+\n+      if Present (Target) then\n+         Analyze (Target);\n+         U_Name := Entity (Target);\n+\n+         if not In_Open_Scopes (U_Name) or else Ekind (U_Name) /= E_Loop then\n+            Error_Msg_N (\"invalid loop name in exit statement\", N);\n+            return;\n+         else\n+            Set_Has_Exit (U_Name);\n+         end if;\n+\n+      else\n+         U_Name := Empty;\n+      end if;\n+\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Scope_Id := Scope_Stack.Table (J).Entity;\n+         Kind := Ekind (Scope_Id);\n+\n+         if Kind = E_Loop\n+           and then (No (Target) or else Scope_Id = U_Name) then\n+            Set_Has_Exit (Scope_Id);\n+            exit;\n+\n+         elsif Kind = E_Block or else Kind = E_Loop then\n+            null;\n+\n+         else\n+            Error_Msg_N\n+              (\"cannot exit from program unit or accept statement\", N);\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Verify that if present the condition is a Boolean expression.\n+\n+      if Present (Cond) then\n+         Analyze_And_Resolve (Cond, Any_Boolean);\n+         Check_Unset_Reference (Cond);\n+      end if;\n+   end Analyze_Exit_Statement;\n+\n+   ----------------------------\n+   -- Analyze_Goto_Statement --\n+   ----------------------------\n+\n+   procedure Analyze_Goto_Statement (N : Node_Id) is\n+      Label       : constant Node_Id := Name (N);\n+      Scope_Id    : Entity_Id;\n+      Label_Scope : Entity_Id;\n+\n+   begin\n+      Check_Unreachable_Code (N);\n+\n+      Analyze (Label);\n+\n+      if Entity (Label) = Any_Id then\n+         return;\n+\n+      elsif Ekind (Entity (Label)) /= E_Label then\n+         Error_Msg_N (\"target of goto statement must be a label\", Label);\n+         return;\n+\n+      elsif not Reachable (Entity (Label)) then\n+         Error_Msg_N (\"target of goto statement is not reachable\", Label);\n+         return;\n+      end if;\n+\n+      Label_Scope := Enclosing_Scope (Entity (Label));\n+\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Scope_Id := Scope_Stack.Table (J).Entity;\n+\n+         if Label_Scope = Scope_Id\n+           or else (Ekind (Scope_Id) /= E_Block\n+                     and then Ekind (Scope_Id) /= E_Loop)\n+         then\n+            if Scope_Id /= Label_Scope then\n+               Error_Msg_N\n+                 (\"cannot exit from program unit or accept statement\", N);\n+            end if;\n+\n+            return;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+\n+   end Analyze_Goto_Statement;\n+\n+   --------------------------\n+   -- Analyze_If_Statement --\n+   --------------------------\n+\n+   --  A special complication arises in the analysis of if statements.\n+   --  The expander has circuitry to completely deleted code that it\n+   --  can tell will not be executed (as a result of compile time known\n+   --  conditions). In the analyzer, we ensure that code that will be\n+   --  deleted in this manner is analyzed but not expanded. This is\n+   --  obviously more efficient, but more significantly, difficulties\n+   --  arise if code is expanded and then eliminated (e.g. exception\n+   --  table entries disappear).\n+\n+   procedure Analyze_If_Statement (N : Node_Id) is\n+      E : Node_Id;\n+\n+      Save_Unblocked_Exit_Count : constant Nat := Unblocked_Exit_Count;\n+      --  Recursively save value of this global, will be restored on exit\n+\n+      Del : Boolean := False;\n+      --  This flag gets set True if a True condition has been found,\n+      --  which means that remaining ELSE/ELSIF parts are deleted.\n+\n+      procedure Analyze_Cond_Then (Cnode : Node_Id);\n+      --  This is applied to either the N_If_Statement node itself or\n+      --  to an N_Elsif_Part node. It deals with analyzing the condition\n+      --  and the THEN statements associated with it.\n+\n+      procedure Analyze_Cond_Then (Cnode : Node_Id) is\n+         Cond : constant Node_Id := Condition (Cnode);\n+         Tstm : constant List_Id := Then_Statements (Cnode);\n+\n+      begin\n+         Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n+         Analyze_And_Resolve (Cond, Any_Boolean);\n+         Check_Unset_Reference (Cond);\n+\n+         --  If already deleting, then just analyze then statements\n+\n+         if Del then\n+            Analyze_Statements (Tstm);\n+\n+         --  Compile time known value, not deleting yet\n+\n+         elsif Compile_Time_Known_Value (Cond) then\n+\n+            --  If condition is True, then analyze the THEN statements\n+            --  and set no expansion for ELSE and ELSIF parts.\n+\n+            if Is_True (Expr_Value (Cond)) then\n+               Analyze_Statements (Tstm);\n+               Del := True;\n+               Expander_Mode_Save_And_Set (False);\n+\n+            --  If condition is False, analyze THEN with expansion off\n+\n+            else -- Is_False (Expr_Value (Cond))\n+               Expander_Mode_Save_And_Set (False);\n+               Analyze_Statements (Tstm);\n+               Expander_Mode_Restore;\n+            end if;\n+\n+         --  Not known at compile time, not deleting, normal analysis\n+\n+         else\n+            Analyze_Statements (Tstm);\n+         end if;\n+      end Analyze_Cond_Then;\n+\n+   --  Start of Analyze_If_Statement\n+\n+   begin\n+      --  Initialize exit count for else statements. If there is no else\n+      --  part, this count will stay non-zero reflecting the fact that the\n+      --  uncovered else case is an unblocked exit.\n+\n+      Unblocked_Exit_Count := 1;\n+      Analyze_Cond_Then (N);\n+\n+      --  Now to analyze the elsif parts if any are present\n+\n+      if Present (Elsif_Parts (N)) then\n+         E := First (Elsif_Parts (N));\n+         while Present (E) loop\n+            Analyze_Cond_Then (E);\n+            Next (E);\n+         end loop;\n+      end if;\n+\n+      if Present (Else_Statements (N)) then\n+         Analyze_Statements (Else_Statements (N));\n+      end if;\n+\n+      --  If all our exits were blocked by unconditional transfers of control,\n+      --  then the entire IF statement acts as an unconditional transfer of\n+      --  control, so treat it like one, and check unreachable code.\n+\n+      if Unblocked_Exit_Count = 0 then\n+         Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+         Check_Unreachable_Code (N);\n+      else\n+         Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n+      end if;\n+\n+      if Del then\n+         Expander_Mode_Restore;\n+      end if;\n+\n+   end Analyze_If_Statement;\n+\n+   ----------------------------------------\n+   -- Analyze_Implicit_Label_Declaration --\n+   ----------------------------------------\n+\n+   --  An implicit label declaration is generated in the innermost\n+   --  enclosing declarative part. This is done for labels as well as\n+   --  block and loop names.\n+\n+   --  Note: any changes in this routine may need to be reflected in\n+   --  Analyze_Label_Entity.\n+\n+   procedure Analyze_Implicit_Label_Declaration (N : Node_Id) is\n+      Id : Node_Id := Defining_Identifier (N);\n+\n+   begin\n+      Enter_Name (Id);\n+      Set_Ekind           (Id, E_Label);\n+      Set_Etype           (Id, Standard_Void_Type);\n+      Set_Enclosing_Scope (Id, Current_Scope);\n+   end Analyze_Implicit_Label_Declaration;\n+\n+   ------------------------------\n+   -- Analyze_Iteration_Scheme --\n+   ------------------------------\n+\n+   procedure Analyze_Iteration_Scheme (N : Node_Id) is\n+   begin\n+      --  For an infinite loop, there is no iteration scheme\n+\n+      if No (N) then\n+         return;\n+\n+      else\n+         declare\n+            Cond : constant Node_Id := Condition (N);\n+\n+         begin\n+            --  For WHILE loop, verify that the condition is a Boolean\n+            --  expression and resolve and check it.\n+\n+            if Present (Cond) then\n+               Analyze_And_Resolve (Cond, Any_Boolean);\n+               Check_Unset_Reference (Cond);\n+\n+            --  Else we have a FOR loop\n+\n+            else\n+               declare\n+                  LP : constant Node_Id   := Loop_Parameter_Specification (N);\n+                  Id : constant Entity_Id := Defining_Identifier (LP);\n+                  DS : constant Node_Id   := Discrete_Subtype_Definition (LP);\n+                  F  : List_Id;\n+\n+               begin\n+                  Enter_Name (Id);\n+\n+                  --  We always consider the loop variable to be referenced,\n+                  --  since the loop may be used just for counting purposes.\n+\n+                  Generate_Reference (Id, N, ' ');\n+\n+                  --  Check for case of loop variable hiding a local\n+                  --  variable (used later on to give a nice warning\n+                  --  if the hidden variable is never assigned).\n+\n+                  declare\n+                     H : constant Entity_Id := Homonym (Id);\n+\n+                  begin\n+                     if Present (H)\n+                       and then Enclosing_Dynamic_Scope (H) =\n+                                Enclosing_Dynamic_Scope (Id)\n+                       and then Ekind (H) = E_Variable\n+                       and then Is_Discrete_Type (Etype (H))\n+                     then\n+                        Set_Hiding_Loop_Variable (H, Id);\n+                     end if;\n+                  end;\n+\n+                  --  Now analyze the subtype definition\n+\n+                  Analyze (DS);\n+\n+                  if DS = Error then\n+                     return;\n+                  end if;\n+\n+                  --  The subtype indication may denote the completion\n+                  --  of an incomplete type declaration.\n+\n+                  if Is_Entity_Name (DS)\n+                    and then Present (Entity (DS))\n+                    and then Is_Type (Entity (DS))\n+                    and then Ekind (Entity (DS)) = E_Incomplete_Type\n+                  then\n+                     Set_Entity (DS, Get_Full_View (Entity (DS)));\n+                     Set_Etype  (DS, Entity (DS));\n+                  end if;\n+\n+                  if not Is_Discrete_Type (Etype (DS)) then\n+                     Wrong_Type (DS, Any_Discrete);\n+                     Set_Etype (DS, Any_Type);\n+                  end if;\n+\n+                  Make_Index (DS, LP);\n+\n+                  Set_Ekind          (Id, E_Loop_Parameter);\n+                  Set_Etype          (Id, Etype (DS));\n+                  Set_Is_Known_Valid (Id, True);\n+\n+                  --  The loop is not a declarative part, so the only entity\n+                  --  declared \"within\" must be frozen explicitly. Since the\n+                  --  type of this entity has already been frozen, this cannot\n+                  --  generate any freezing actions.\n+\n+                  F := Freeze_Entity (Id, Sloc (LP));\n+                  pragma Assert (F = No_List);\n+\n+                  --  Check for null or possibly null range and issue warning\n+\n+                  if Nkind (DS) = N_Range\n+                    and then Comes_From_Source (N)\n+                    and then not Inside_A_Generic\n+                  then\n+                     declare\n+                        L : constant Node_Id := Low_Bound  (DS);\n+                        H : constant Node_Id := High_Bound (DS);\n+\n+                        Llo : Uint;\n+                        Lhi : Uint;\n+                        LOK : Boolean;\n+                        Hlo : Uint;\n+                        Hhi : Uint;\n+                        HOK : Boolean;\n+\n+                     begin\n+                        Determine_Range (L, LOK, Llo, Lhi);\n+                        Determine_Range (H, HOK, Hlo, Hhi);\n+\n+                        --  If range of loop is null, issue warning\n+\n+                        if (LOK and HOK) and then Llo > Hhi then\n+                           Warn_On_Instance := True;\n+                           Error_Msg_N\n+                             (\"?loop range is null, loop will not execute\",\n+                              DS);\n+                           Warn_On_Instance := False;\n+\n+                        --  The other case for a warning is a reverse loop\n+                        --  where the upper bound is the integer literal\n+                        --  zero or one, and the lower bound can be positive.\n+\n+                        elsif Reverse_Present (LP)\n+                          and then Nkind (H) = N_Integer_Literal\n+                          and then (Intval (H) = Uint_0\n+                                      or else\n+                                    Intval (H) = Uint_1)\n+                          and then Lhi > Hhi\n+                        then\n+                           Warn_On_Instance := True;\n+                           Error_Msg_N (\"?loop range may be null\", DS);\n+                           Warn_On_Instance := False;\n+                        end if;\n+                     end;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+      end if;\n+   end Analyze_Iteration_Scheme;\n+\n+   -------------------\n+   -- Analyze_Label --\n+   -------------------\n+\n+   --  Important note: normally this routine is called from Analyze_Statements\n+   --  which does a prescan, to make sure that the Reachable flags are set on\n+   --  all labels before encountering a possible goto to one of these labels.\n+   --  If expanded code analyzes labels via the normal Sem path, then it must\n+   --  ensure that Reachable is set early enough to avoid problems in the case\n+   --  of a forward goto.\n+\n+   procedure Analyze_Label (N : Node_Id) is\n+      Lab : Entity_Id;\n+\n+   begin\n+      Analyze (Identifier (N));\n+      Lab := Entity (Identifier (N));\n+\n+      --  If we found a label mark it as reachable.\n+\n+      if Ekind (Lab) = E_Label then\n+         Generate_Definition (Lab);\n+         Set_Reachable (Lab);\n+\n+         if Nkind (Parent (Lab)) = N_Implicit_Label_Declaration then\n+            Set_Label_Construct (Parent (Lab), N);\n+         end if;\n+\n+      --  If we failed to find a label, it means the implicit declaration\n+      --  of the label was hidden.  A for-loop parameter can do this to a\n+      --  label with the same name inside the loop, since the implicit label\n+      --  declaration is in the innermost enclosing body or block statement.\n+\n+      else\n+         Error_Msg_Sloc := Sloc (Lab);\n+         Error_Msg_N\n+           (\"implicit label declaration for & is hidden#\",\n+            Identifier (N));\n+      end if;\n+   end Analyze_Label;\n+\n+   --------------------------\n+   -- Analyze_Label_Entity --\n+   --------------------------\n+\n+   procedure Analyze_Label_Entity (E : Entity_Id) is\n+   begin\n+      Set_Ekind           (E, E_Label);\n+      Set_Etype           (E, Standard_Void_Type);\n+      Set_Enclosing_Scope (E, Current_Scope);\n+      Set_Reachable       (E, True);\n+   end Analyze_Label_Entity;\n+\n+   ----------------------------\n+   -- Analyze_Loop_Statement --\n+   ----------------------------\n+\n+   procedure Analyze_Loop_Statement (N : Node_Id) is\n+      Id  : constant Node_Id := Identifier (N);\n+      Ent : Entity_Id;\n+\n+   begin\n+      if Present (Id) then\n+\n+         --  Make name visible, e.g. for use in exit statements. Loop\n+         --  labels are always considered to be referenced.\n+\n+         Analyze (Id);\n+         Ent := Entity (Id);\n+         Generate_Reference  (Ent, N, ' ');\n+         Generate_Definition (Ent);\n+\n+         --  If we found a label, mark its type. If not, ignore it, since it\n+         --  means we have a conflicting declaration, which would already have\n+         --  been diagnosed at declaration time. Set Label_Construct of the\n+         --  implicit label declaration, which is not created by the parser\n+         --  for generic units.\n+\n+         if Ekind (Ent) = E_Label then\n+            Set_Ekind (Ent, E_Loop);\n+\n+            if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n+               Set_Label_Construct (Parent (Ent), N);\n+            end if;\n+         end if;\n+\n+      --  Case of no identifier present\n+\n+      else\n+         Ent := New_Internal_Entity (E_Loop, Current_Scope, Sloc (N), 'L');\n+         Set_Etype (Ent,  Standard_Void_Type);\n+         Set_Parent (Ent, N);\n+      end if;\n+\n+      New_Scope (Ent);\n+      Analyze_Iteration_Scheme (Iteration_Scheme (N));\n+      Analyze_Statements (Statements (N));\n+      Process_End_Label (N, 'e');\n+      End_Scope;\n+   end Analyze_Loop_Statement;\n+\n+   ----------------------------\n+   -- Analyze_Null_Statement --\n+   ----------------------------\n+\n+   --  Note: the semantics of the null statement is implemented by a single\n+   --  null statement, too bad everything isn't as simple as this!\n+\n+   procedure Analyze_Null_Statement (N : Node_Id) is\n+   begin\n+      null;\n+   end Analyze_Null_Statement;\n+\n+   ------------------------\n+   -- Analyze_Statements --\n+   ------------------------\n+\n+   procedure Analyze_Statements (L : List_Id) is\n+      S : Node_Id;\n+\n+   begin\n+      --  The labels declared in the statement list are reachable from\n+      --  statements in the list. We do this as a prepass so that any\n+      --  goto statement will be properly flagged if its target is not\n+      --  reachable. This is not required, but is nice behavior!\n+\n+      S := First (L);\n+\n+      while Present (S) loop\n+         if Nkind (S) = N_Label then\n+            Analyze_Label (S);\n+         end if;\n+\n+         Next (S);\n+      end loop;\n+\n+      --  Perform semantic analysis on all statements\n+\n+      S := First (L);\n+\n+      while Present (S) loop\n+\n+         if Nkind (S) /= N_Label then\n+            Analyze (S);\n+         end if;\n+\n+         Next (S);\n+      end loop;\n+\n+      --  Make labels unreachable. Visibility is not sufficient, because\n+      --  labels in one if-branch for example are not reachable from the\n+      --  other branch, even though their declarations are in the enclosing\n+      --  declarative part.\n+\n+      S := First (L);\n+\n+      while Present (S) loop\n+         if Nkind (S) = N_Label then\n+            Set_Reachable (Entity (Identifier (S)), False);\n+         end if;\n+\n+         Next (S);\n+      end loop;\n+   end Analyze_Statements;\n+\n+   ----------------------------\n+   -- Check_Unreachable_Code --\n+   ----------------------------\n+\n+   procedure Check_Unreachable_Code (N : Node_Id) is\n+      Error_Loc : Source_Ptr;\n+      P         : Node_Id;\n+\n+   begin\n+      if Is_List_Member (N)\n+        and then Comes_From_Source (N)\n+      then\n+         declare\n+            Nxt : Node_Id;\n+\n+         begin\n+            Nxt := Original_Node (Next (N));\n+\n+            if Present (Nxt)\n+              and then Comes_From_Source (Nxt)\n+              and then Is_Statement (Nxt)\n+            then\n+               --  Special very annoying exception. If we have a return that\n+               --  follows a raise, then we allow it without a warning, since\n+               --  the Ada RM annoyingly requires a useless return here!\n+\n+               if Nkind (Original_Node (N)) /= N_Raise_Statement\n+                 or else Nkind (Nxt) /= N_Return_Statement\n+               then\n+                  --  The rather strange shenanigans with the warning message\n+                  --  here reflects the fact that Kill_Dead_Code is very good\n+                  --  at removing warnings in deleted code, and this is one\n+                  --  warning we would prefer NOT to have removed :-)\n+\n+                  Error_Loc := Sloc (Nxt);\n+\n+                  --  If we have unreachable code, analyze and remove the\n+                  --  unreachable code, since it is useless and we don't\n+                  --  want to generate junk warnings.\n+\n+                  --  We skip this step if we are not in code generation mode.\n+                  --  This is the one case where we remove dead code in the\n+                  --  semantics as opposed to the expander, and we do not want\n+                  --  to remove code if we are not in code generation mode,\n+                  --  since this messes up the ASIS trees.\n+\n+                  --  Note that one might react by moving the whole circuit to\n+                  --  exp_ch5, but then we lose the warning in -gnatc mode.\n+\n+                  if Operating_Mode = Generate_Code then\n+                     loop\n+                        Nxt := Next (N);\n+                        exit when No (Nxt) or else not Is_Statement (Nxt);\n+                        Analyze (Nxt);\n+                        Remove (Nxt);\n+                        Kill_Dead_Code (Nxt);\n+                     end loop;\n+                  end if;\n+\n+                  --  Now issue the warning\n+\n+                  Error_Msg (\"?unreachable code\", Error_Loc);\n+               end if;\n+\n+            --  If the unconditional transfer of control instruction is\n+            --  the last statement of a sequence, then see if our parent\n+            --  is an IF statement, and if so adjust the unblocked exit\n+            --  count of the if statement to reflect the fact that this\n+            --  branch of the if is indeed blocked by a transfer of control.\n+\n+            else\n+               P := Parent (N);\n+\n+               if Nkind (P) = N_If_Statement then\n+                  null;\n+\n+               elsif Nkind (P) = N_Elsif_Part then\n+                  P := Parent (P);\n+                  pragma Assert (Nkind (P) = N_If_Statement);\n+\n+               elsif Nkind (P) = N_Case_Statement_Alternative then\n+                  P := Parent (P);\n+                  pragma Assert (Nkind (P) = N_Case_Statement);\n+\n+               else\n+                  return;\n+               end if;\n+\n+               Unblocked_Exit_Count := Unblocked_Exit_Count - 1;\n+            end if;\n+         end;\n+      end if;\n+   end Check_Unreachable_Code;\n+\n+end Sem_Ch5;"}, {"sha": "c7d94685fa1352f9c74790ca438dea38323155f8", "filename": "gcc/ada/sem_ch5.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 5                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Sem_Ch5 is\n+\n+   procedure Analyze_Assignment                 (N : Node_Id);\n+   procedure Analyze_Block_Statement            (N : Node_Id);\n+   procedure Analyze_Case_Statement             (N : Node_Id);\n+   procedure Analyze_Exit_Statement             (N : Node_Id);\n+   procedure Analyze_Goto_Statement             (N : Node_Id);\n+   procedure Analyze_If_Statement               (N : Node_Id);\n+   procedure Analyze_Implicit_Label_Declaration (N : Node_Id);\n+   procedure Analyze_Label                      (N : Node_Id);\n+   procedure Analyze_Loop_Statement             (N : Node_Id);\n+   procedure Analyze_Null_Statement             (N : Node_Id);\n+   procedure Analyze_Statements                 (L : List_Id);\n+\n+   procedure Analyze_Label_Entity (E : Entity_Id);\n+   --  This procedure performs direct analysis of the label entity E. It\n+   --  is used when a label is created by the expander without bothering\n+   --  to insert an N_Implicit_Label_Declaration in the tree. It also takes\n+   --  care of setting Reachable, since labels defined by the expander can\n+   --  be assumed to be reachable.\n+\n+   procedure Check_Unreachable_Code (N : Node_Id);\n+   --  This procedure is called with N being the node for a statement that\n+   --  is an unconditional transfer of control. It checks to see if the\n+   --  statement is followed by some other statement, and if so generates\n+   --  an appropriate warning for unreachable code.\n+\n+end Sem_Ch5;"}, {"sha": "f8e0b4fce4285cb34e89c92c01ee107c1251afb2", "filename": "gcc/ada/sem_ch6.adb", "status": "added", "additions": 4779, "deletions": 0, "changes": 4779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "beb47569a42565702eb55a92631a4842fa62dd35", "filename": "gcc/ada/sem_ch6.ads", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,170 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 6                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $                             --\n+--                                                                          --\n+--   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sem_Ch6 is\n+\n+   procedure Analyze_Abstract_Subprogram_Declaration    (N : Node_Id);\n+   procedure Analyze_Function_Call                      (N : Node_Id);\n+   procedure Analyze_Operator_Symbol                    (N : Node_Id);\n+   procedure Analyze_Parameter_Association              (N : Node_Id);\n+   procedure Analyze_Procedure_Call                     (N : Node_Id);\n+   procedure Analyze_Return_Statement                   (N : Node_Id);\n+   procedure Analyze_Subprogram_Declaration             (N : Node_Id);\n+   procedure Analyze_Subprogram_Body                    (N : Node_Id);\n+\n+   function Analyze_Spec (N : Node_Id) return Entity_Id;\n+   --  Analyze subprogram specification in both subprogram declarations\n+   --  and body declarations.\n+\n+   procedure Check_Delayed_Subprogram (Designator : Entity_Id);\n+   --  Designator can be a E_Subrpgram_Type, E_Procedure or E_Function. If a\n+   --  type in its profile depends on a private type without a full\n+   --  declaration, indicate that the subprogram is delayed.\n+\n+   procedure Check_Discriminant_Conformance\n+     (N        : Node_Id;\n+      Prev     : Entity_Id;\n+      Prev_Loc : Node_Id);\n+   --  Check that the discriminants of a full type N fully conform to\n+   --  the discriminants of the corresponding partial view Prev.\n+   --  Prev_Loc indicates the source location of the partial view,\n+   --  which may be different than Prev in the case of private types.\n+\n+   procedure Check_Fully_Conformant\n+     (New_Id  : Entity_Id;\n+      Old_Id  : Entity_Id;\n+      Err_Loc : Node_Id := Empty);\n+   --  Check that two callable entitites (subprograms, entries, literals)\n+   --  are fully conformant, post error message if not (RM 6.3.1(17)) with\n+   --  the flag being placed on the Err_Loc node if it is specified, and\n+   --  on the appropriate component of the New_Id construct if not. Note:\n+   --  when checking spec/body conformance, New_Id must be the body entity\n+   --  and Old_Id is the spec entity (the code in the implementation relies\n+   --  on this ordering, and in any case, this makes sense, since if flags\n+   --  are to be placed on the construct, they clearly belong on the body.\n+\n+   procedure Check_Mode_Conformant\n+     (New_Id   : Entity_Id;\n+      Old_Id   : Entity_Id;\n+      Err_Loc  : Node_Id := Empty;\n+      Get_Inst : Boolean := False);\n+   --  Check that two callable entitites (subprograms, entries, literals)\n+   --  are mode conformant, post error message if not (RM 6.3.1(15)) with\n+   --  the flag being placed on the Err_Loc node if it is specified, and\n+   --  on the appropriate component of the New_Id construct if not. The\n+   --  argument Get_Inst is set to True when this is a check against a\n+   --  formal access-to-subprogram type, indicating that mapping of types\n+   --  is needed.\n+\n+   procedure Check_Subtype_Conformant\n+     (New_Id  : Entity_Id;\n+      Old_Id  : Entity_Id;\n+      Err_Loc : Node_Id := Empty);\n+   --  Check that two callable entitites (subprograms, entries, literals)\n+   --  are subtype conformant, post error message if not (RM 6.3.1(16))\n+   --  the flag being placed on the Err_Loc node if it is specified, and\n+   --  on the appropriate component of the New_Id construct if not.\n+\n+   procedure Check_Type_Conformant\n+     (New_Id  : Entity_Id;\n+      Old_Id  : Entity_Id;\n+      Err_Loc : Node_Id := Empty);\n+   --  Check that two callable entitites (subprograms, entries, literals)\n+   --  are type conformant, post error message if not (RM 6.3.1(14)) with\n+   --  the flag being placed on the Err_Loc node if it is specified, and\n+   --  on the appropriate component of the New_Id construct if not.\n+\n+   procedure Create_Extra_Formals (E : Entity_Id);\n+   --  For each parameter of a subprogram or entry that requires an additional\n+   --  formal (such as for access parameters and indefinite discriminated\n+   --  parameters), creates the appropriate formal and attach it to its\n+   --  associated parameter. Each extra formal will also be appended to\n+   --  the end of Subp's parameter list (with each subsequent extra formal\n+   --  being attached to the preceding extra formal).\n+\n+   function Find_Corresponding_Spec (N : Node_Id) return Entity_Id;\n+   --  Use the subprogram specification in the body to retrieve the previous\n+   --  subprogram declaration, if any.\n+\n+   function Fully_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   --  Determine whether two callable entities (subprograms, entries,\n+   --  literals) are fully conformant (RM 6.3.1(17))\n+\n+   function Fully_Conformant_Expressions\n+     (Given_E1 : Node_Id;\n+      Given_E2 : Node_Id)\n+      return  Boolean;\n+   --  Determines if two (non-empty) expressions are fully conformant\n+   --  as defined by (RM 6.3.1(18-21))\n+\n+   function Mode_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   --  Determine whether two callable entities (subprograms, entries,\n+   --  literals) are mode conformant (RM 6.3.1(15))\n+\n+   procedure New_Overloaded_Entity\n+     (S            : Entity_Id;\n+      Derived_Type : Entity_Id := Empty);\n+   --  Process new overloaded entity. Overloaded entities are created\n+   --  by enumeration type declarations, subprogram specifications,\n+   --  entry declarations, and (implicitly) by type derivations.\n+   --  If Derived_Type is not Empty, then it indicates that this\n+   --  is subprogram derived for that type.\n+\n+   procedure Process_Formals (\n+     S           : Entity_Id;\n+     T           : List_Id;\n+     Related_Nod : Node_Id);\n+   --  Enter the formals in the scope of the subprogram or entry, and\n+   --  analyze default expressions if any. The implicit types created for\n+   --  access parameter are attached to the Related_Nod which comes from the\n+   --  context.\n+\n+   procedure Set_Actual_Subtypes (N : Node_Id; Subp : Entity_Id);\n+   --  If the formals of a subprogram are unconstrained, build a subtype\n+   --  declaration that uses the bounds or discriminants of the actual to\n+   --  construct an actual subtype for them. This is an optimization that\n+   --  is done only in some cases where the actual subtype cannot change\n+   --  during execution of the subprogram. By setting the actual subtype\n+   --  once, we avoid recomputing it unnecessarily.\n+\n+   procedure Set_Formal_Mode (Formal_Id : Entity_Id);\n+   --  Set proper Ekind to reflect formal mode (in, out, in out)\n+\n+   function Subtype_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   --  Determine whether two callable entities (subprograms, entries,\n+   --  literals) are subtype conformant (RM6.3.1(16))\n+\n+   function Type_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   --  Determine whether two callable entities (subprograms, entries,\n+   --  literals) are type conformant (RM6.3.1(14))\n+\n+   procedure Valid_Operator_Definition (Designator : Entity_Id);\n+   --  Verify that an operator definition has the proper number of formals\n+\n+end Sem_Ch6;"}, {"sha": "c1b0521b38a8fa60b466e8c8b7914731866fe0ad", "filename": "gcc/ada/sem_ch7.adb", "status": "added", "additions": 1703, "deletions": 0, "changes": 1703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1703 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M . C H 7                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.335 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines to process package specifications and\n+--  bodies. The most important semantic aspects of package processing are the\n+--  handling of private and full declarations, and the construction of\n+--  dispatch tables for tagged types.\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Exp_Disp; use Exp_Disp;\n+with Exp_Dbug; use Exp_Dbug;\n+with Lib;      use Lib;\n+with Lib.Xref; use Lib.Xref;\n+with Namet;    use Namet;\n+with Nmake;    use Nmake;\n+with Nlists;   use Nlists;\n+with Opt;      use Opt;\n+with Output;   use Output;\n+with Sem;      use Sem;\n+with Sem_Cat;  use Sem_Cat;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n+with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Style;\n+\n+package body Sem_Ch7 is\n+\n+   -----------------------------------\n+   -- Handling private declarations --\n+   -----------------------------------\n+\n+   --  The principle that each entity has a single defining occurrence clashes\n+   --  with the presence of two separate definitions for private types: the\n+   --  first is the private type declaration, and the second is the full type\n+   --  declaration. It is important that all references to the type point to\n+   --  the same defining occurence, namely the first one. To enforce the two\n+   --  separate views of the entity, the corresponding information is swapped\n+   --  between the two declarations. Outside of the package, the defining\n+   --  occurence only contains the private declaration information, while in\n+   --  the private part and the body of the package the defining occurrence\n+   --  contains the full declaration. To simplify the swap, the defining\n+   --  occurrence that currently holds the private declaration points to the\n+   --  full declaration. During semantic processing the defining occurence also\n+   --  points to a list of private dependents, that is to say access types or\n+   --  composite types whose designated types or component types are subtypes\n+   --  or derived types of the private type in question. After the full decla-\n+   --  ration has been seen, the private dependents are updated to indicate\n+   --  that they have full definitions.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Install_Composite_Operations (P : Entity_Id);\n+   --  Composite types declared in the current scope may depend on\n+   --  types that were private at the point of declaration, and whose\n+   --  full view is now in  scope. Indicate that the corresponding\n+   --  operations on the composite type are available.\n+\n+   function Is_Private_Base_Type (E : Entity_Id) return Boolean;\n+   --  True for a private type that is not a subtype.\n+\n+   function Is_Visible_Dependent (Dep : Entity_Id) return Boolean;\n+   --  If the private dependent is a private type whose full view is\n+   --  derived from the parent type, its full properties are revealed\n+   --  only if we are in the immediate scope of the private dependent.\n+   --  Should this predicate be tightened further???\n+\n+   procedure Preserve_Full_Attributes (Priv, Full : Entity_Id);\n+   --  Copy to the private declaration the attributes of the full view\n+   --  that need to be available for the partial view also.\n+\n+   procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id);\n+   --  Called upon entering the private part of a public child package\n+   --  and the body of a nested package, to potentially declare certain\n+   --  inherited subprograms that were inherited by types in the visible\n+   --  part, but whose declaration was deferred because the parent\n+   --  operation was private and not visible at that point. These\n+   --  subprograms are located by traversing the visible part declarations\n+   --  looking for nonprivate type extensions and then examining each of\n+   --  the primitive operations of such types to find those that were\n+   --  inherited but declared with a special internal name. Each such\n+   --  operation is now declared as an operation with a normal name (using\n+   --  the name of the parent operation) and replaces the previous implicit\n+   --  operation in the primitive operations list of the type. If the\n+   --  inherited private operation has been overridden, then it's\n+   --  replaced by the overriding operation.\n+\n+   --------------------------\n+   -- Analyze_Package_Body --\n+   --------------------------\n+\n+   procedure Analyze_Package_Body (N : Node_Id) is\n+      Loc              : constant Source_Ptr := Sloc (N);\n+      HSS              : Node_Id;\n+      Body_Id          : Entity_Id;\n+      Spec_Id          : Entity_Id;\n+      Last_Spec_Entity : Entity_Id;\n+      New_N            : Node_Id;\n+      Pack_Decl        : Node_Id;\n+\n+   begin\n+      --  Find corresponding package specification, and establish the\n+      --  current scope. The visible defining entity for the package is the\n+      --  defining occurrence in the spec. On exit from the package body, all\n+      --  body declarations are attached to the defining entity for the body,\n+      --  but the later is never used for name resolution. In this fashion\n+      --  there is only one visible entity that denotes the package.\n+\n+      if Debug_Flag_C then\n+         Write_Str (\"====  Compiling package body \");\n+         Write_Name (Chars (Defining_Entity (N)));\n+         Write_Str (\" from \");\n+         Write_Location (Loc);\n+         Write_Eol;\n+      end if;\n+\n+      --  Set Body_Id. Note that this wil be reset to point to the\n+      --  generic copy later on in the generic case.\n+\n+      Body_Id := Defining_Entity (N);\n+\n+      if Present (Corresponding_Spec (N)) then\n+\n+         --  Body is body of package instantiation. Corresponding spec\n+         --  has already been set.\n+\n+         Spec_Id := Corresponding_Spec (N);\n+         Pack_Decl := Unit_Declaration_Node (Spec_Id);\n+\n+      else\n+         Spec_Id := Current_Entity_In_Scope (Defining_Entity (N));\n+\n+         if Present (Spec_Id)\n+           and then Is_Package (Spec_Id)\n+         then\n+            Pack_Decl := Unit_Declaration_Node (Spec_Id);\n+\n+            if Nkind (Pack_Decl) = N_Package_Renaming_Declaration then\n+               Error_Msg_N (\"cannot supply body for package renaming\", N);\n+               return;\n+\n+            elsif Present (Corresponding_Body (Pack_Decl)) then\n+               Error_Msg_N (\"redefinition of package body\", N);\n+               return;\n+            end if;\n+\n+         else\n+            Error_Msg_N (\"missing specification for package body\", N);\n+            return;\n+         end if;\n+\n+         if Is_Package (Spec_Id)\n+           and then\n+             (Scope (Spec_Id) = Standard_Standard\n+               or else Is_Child_Unit (Spec_Id))\n+           and then not Unit_Requires_Body (Spec_Id)\n+         then\n+            if Ada_83 then\n+               Error_Msg_N\n+                 (\"optional package body (not allowed in Ada 95)?\", N);\n+            else\n+               Error_Msg_N\n+                 (\"spec of this package does not allow a body\", N);\n+            end if;\n+         end if;\n+      end if;\n+\n+      Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n+      Style.Check_Identifier (Body_Id, Spec_Id);\n+\n+      if Is_Child_Unit (Spec_Id) then\n+\n+         if Nkind (Parent (N)) /= N_Compilation_Unit then\n+            Error_Msg_NE\n+              (\"body of child unit& cannot be an inner package\", N, Spec_Id);\n+         end if;\n+\n+         Set_Is_Child_Unit (Body_Id);\n+      end if;\n+\n+      --  Generic package case\n+\n+      if Ekind (Spec_Id) = E_Generic_Package then\n+\n+         --  Disable expansion and perform semantic analysis on copy.\n+         --  The unannotated body will be used in all instantiations.\n+\n+         Body_Id := Defining_Entity (N);\n+         Set_Ekind (Body_Id, E_Package_Body);\n+         Set_Scope (Body_Id, Scope (Spec_Id));\n+         Set_Body_Entity (Spec_Id, Body_Id);\n+         Set_Spec_Entity (Body_Id, Spec_Id);\n+\n+         New_N := Copy_Generic_Node (N, Empty, Instantiating => False);\n+         Rewrite (N, New_N);\n+\n+         --  Update Body_Id to point to the copied node for the remainder\n+         --  of the processing.\n+\n+         Body_Id := Defining_Entity (N);\n+         Start_Generic;\n+      end if;\n+\n+      --  The Body_Id is that of the copied node in the generic case, the\n+      --  current node otherwise. Note that N was rewritten above, so we\n+      --  must be sure to get the latest Body_Id value.\n+\n+      Set_Ekind (Body_Id, E_Package_Body);\n+      Set_Body_Entity (Spec_Id, Body_Id);\n+      Set_Spec_Entity (Body_Id, Spec_Id);\n+\n+      --  Defining name for the package body is not a visible entity: Only\n+      --  the defining name for the declaration is visible.\n+\n+      Set_Etype (Body_Id, Standard_Void_Type);\n+      Set_Scope (Body_Id, Scope (Spec_Id));\n+      Set_Corresponding_Spec (N, Spec_Id);\n+      Set_Corresponding_Body (Pack_Decl, Body_Id);\n+\n+      --  The body entity is not used for semantics or code generation, but\n+      --  it is attached to the entity list of the enclosing scope to simplify\n+      --  the listing of back-annotations for the types it main contain.\n+\n+      if Scope (Spec_Id) /= Standard_Standard then\n+         Append_Entity (Body_Id, Scope (Spec_Id));\n+      end if;\n+\n+      --  Indicate that we are currently compiling the body of the package.\n+\n+      Set_In_Package_Body (Spec_Id);\n+      Set_Has_Completion (Spec_Id);\n+      Last_Spec_Entity := Last_Entity (Spec_Id);\n+\n+      New_Scope (Spec_Id);\n+\n+      Set_Categorization_From_Pragmas (N);\n+\n+      Install_Visible_Declarations (Spec_Id);\n+      Install_Private_Declarations (Spec_Id);\n+      Install_Composite_Operations (Spec_Id);\n+\n+      if Ekind (Spec_Id) = E_Generic_Package then\n+         Set_Use (Generic_Formal_Declarations (Pack_Decl));\n+      end if;\n+\n+      Set_Use (Visible_Declarations (Specification (Pack_Decl)));\n+      Set_Use (Private_Declarations (Specification (Pack_Decl)));\n+\n+      --  This is a nested package, so it may be necessary to declare\n+      --  certain inherited subprograms that are not yet visible because\n+      --  the parent type's subprograms are now visible.\n+\n+      if Ekind (Scope (Spec_Id)) = E_Package\n+        and then Scope (Spec_Id) /= Standard_Standard\n+      then\n+         Declare_Inherited_Private_Subprograms (Spec_Id);\n+      end if;\n+\n+      if Present (Declarations (N)) then\n+         Analyze_Declarations (Declarations (N));\n+      end if;\n+\n+      HSS := Handled_Statement_Sequence (N);\n+\n+      if Present (HSS) then\n+         Process_End_Label (HSS, 't');\n+         Analyze (HSS);\n+\n+         --  Check that elaboration code in a preelaborable package body is\n+         --  empty other than null statements and labels (RM 10.2.1(6)).\n+\n+         Validate_Null_Statement_Sequence (N);\n+      end if;\n+\n+      Validate_Categorization_Dependency (N, Spec_Id);\n+      Check_Completion (Body_Id);\n+\n+      --  Generate start of body reference. Note that we do this fairly late,\n+      --  because the call will use In_Extended_Main_Source_Unit as a check,\n+      --  and we want to make sure that Corresponding_Stub links are set\n+\n+      Generate_Reference (Spec_Id, Body_Id, 'b');\n+\n+      --  For a generic package, collect global references and mark\n+      --  them on the original body so that they are not resolved\n+      --  again at the point of instantiation.\n+\n+      if Ekind (Spec_Id) /= E_Package then\n+         Save_Global_References (Original_Node (N));\n+         End_Generic;\n+      end if;\n+\n+      --  The entities of the package body have so far been chained onto\n+      --  the declaration chain for the spec. That's been fine while we\n+      --  were in the body, since we wanted them to be visible, but now\n+      --  that we are leaving the package body, they are no longer visible,\n+      --  so we remove them from the entity chain of the package spec entity,\n+      --  and copy them to the entity chain of the package body entity, where\n+      --  they will never again be visible.\n+\n+      if Present (Last_Spec_Entity) then\n+         Set_First_Entity (Body_Id, Next_Entity (Last_Spec_Entity));\n+         Set_Next_Entity (Last_Spec_Entity, Empty);\n+         Set_Last_Entity (Body_Id, Last_Entity (Spec_Id));\n+         Set_Last_Entity (Spec_Id, Last_Spec_Entity);\n+\n+      else\n+         Set_First_Entity (Body_Id, First_Entity (Spec_Id));\n+         Set_Last_Entity  (Body_Id, Last_Entity  (Spec_Id));\n+         Set_First_Entity (Spec_Id, Empty);\n+         Set_Last_Entity  (Spec_Id, Empty);\n+      end if;\n+\n+      End_Package_Scope (Spec_Id);\n+\n+      --  All entities declared in body are not visible.\n+\n+      declare\n+         E : Entity_Id;\n+\n+      begin\n+         E := First_Entity (Body_Id);\n+\n+         while Present (E) loop\n+            Set_Is_Immediately_Visible (E, False);\n+            Set_Is_Potentially_Use_Visible (E, False);\n+            Set_Is_Hidden (E);\n+\n+            --  Child units may appear on the entity list (for example if\n+            --  they appear in the context of a subunit) but they are not\n+            --  body entities.\n+\n+            if not Is_Child_Unit (E) then\n+               Set_Is_Package_Body_Entity (E);\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+      end;\n+\n+      Check_References (Body_Id);\n+\n+      --  The processing so far has made all entities of the package body\n+      --  public (i.e. externally visible to the linker). This is in general\n+      --  necessary, since inlined or generic bodies, for which code is\n+      --  generated in other units, may need to see these entities. The\n+      --  following loop runs backwards from the end of the entities of the\n+      --  package body making these entities invisible until we reach a\n+      --  referencer, i.e. a declaration that could reference a previous\n+      --  declaration, a generic body or an inlined body, or a stub (which\n+      --  may contain either of these). This is of course an approximation,\n+      --  but it is conservative and definitely correct.\n+\n+      --  We only do this at the outer (library) level non-generic packages.\n+      --  The reason is simply to cut down on the number of external symbols\n+      --  generated, so this is simply an optimization of the efficiency\n+      --  of the compilation process. It has no other effect.\n+\n+      if (Scope (Spec_Id) = Standard_Standard or else Is_Child_Unit (Spec_Id))\n+        and then not Is_Generic_Unit (Spec_Id)\n+        and then Present (Declarations (N))\n+      then\n+         Make_Non_Public_Where_Possible : declare\n+            Discard : Boolean;\n+\n+            function Has_Referencer\n+              (L     : List_Id;\n+               Outer : Boolean)\n+               return  Boolean;\n+            --  Traverse the given list of declarations in reverse order.\n+            --  Return True as soon as a referencer is reached. Return\n+            --  False if none is found. The Outer parameter is True for\n+            --  the outer level call, and False for inner level calls for\n+            --  nested packages. If Outer is True, then any entities up\n+            --  to the point of hitting a referencer get their Is_Public\n+            --  flag cleared, so that the entities will be treated as\n+            --  static entities in the C sense, and need not have fully\n+            --  qualified names. For inner levels, we need all names to\n+            --  be fully qualified to deal with the same name appearing\n+            --  in parallel packages (right now this is tied to their\n+            --  being external).\n+\n+            --------------------\n+            -- Has_Referencer --\n+            --------------------\n+\n+            function Has_Referencer\n+              (L     : List_Id;\n+               Outer : Boolean)\n+               return  Boolean\n+            is\n+               D : Node_Id;\n+               E : Entity_Id;\n+               K : Node_Kind;\n+               S : Entity_Id;\n+\n+            begin\n+               if No (L) then\n+                  return False;\n+               end if;\n+\n+               D := Last (L);\n+\n+               while Present (D) loop\n+                  K := Nkind (D);\n+\n+                  if K in N_Body_Stub then\n+                     return True;\n+\n+                  elsif K = N_Subprogram_Body then\n+                     if Acts_As_Spec (D) then\n+                        E := Defining_Entity (D);\n+\n+                        --  An inlined body acts as a referencer. Note also\n+                        --  that we never reset Is_Public for an inlined\n+                        --  subprogram. Gigi requires Is_Public to be set.\n+\n+                        --  Note that we test Has_Pragma_Inline here rather\n+                        --  than Is_Inlined. We are compiling this for a\n+                        --  client, and it is the client who will decide\n+                        --  if actual inlining should occur, so we need to\n+                        --  assume that the procedure could be inlined for\n+                        --  the purpose of accessing global entities.\n+\n+                        if Has_Pragma_Inline (E) then\n+                           return True;\n+                        else\n+                           Set_Is_Public (E, False);\n+                        end if;\n+\n+                     else\n+                        E := Corresponding_Spec (D);\n+\n+                        if Present (E)\n+                          and then (Is_Generic_Unit (E)\n+                                     or else Has_Pragma_Inline (E)\n+                                     or else Is_Inlined (E))\n+                        then\n+                           return True;\n+                        end if;\n+                     end if;\n+\n+                  --  Processing for package bodies\n+\n+                  elsif K = N_Package_Body\n+                    and then Present (Corresponding_Spec (D))\n+                  then\n+                     E := Corresponding_Spec (D);\n+\n+                     --  Generic package body is a referencer. It would\n+                     --  seem that we only have to consider generics that\n+                     --  can be exported, i.e. where the corresponding spec\n+                     --  is the spec of the current package, but because of\n+                     --  nested instantiations, a fully private generic\n+                     --  body may export other private body entities.\n+\n+                     if Is_Generic_Unit (E) then\n+                        return True;\n+\n+                     --  For non-generic package body, recurse into body\n+                     --  unless this is an instance, we ignore instances\n+                     --  since they cannot have references that affect\n+                     --  outer entities.\n+\n+                     elsif not Is_Generic_Instance (E) then\n+                        if Has_Referencer\n+                             (Declarations (D), Outer => False)\n+                        then\n+                           return True;\n+                        end if;\n+                     end if;\n+\n+                  --  Processing for package specs, recurse into declarations.\n+                  --  Again we skip this for the case of generic instances.\n+\n+                  elsif K = N_Package_Declaration then\n+                     S := Specification (D);\n+\n+                     if not Is_Generic_Unit (Defining_Entity (S)) then\n+                        if Has_Referencer\n+                             (Private_Declarations (S), Outer => False)\n+                        then\n+                           return True;\n+                        elsif Has_Referencer\n+                               (Visible_Declarations (S), Outer => False)\n+                        then\n+                           return True;\n+                        end if;\n+                     end if;\n+\n+                  --  Objects and exceptions need not be public if we have\n+                  --  not encountered a referencer so far. We only reset\n+                  --  the flag for outer level entities that are not\n+                  --  imported/exported, and which have no interface name.\n+\n+                  elsif K = N_Object_Declaration\n+                    or else K = N_Exception_Declaration\n+                    or else K = N_Subprogram_Declaration\n+                  then\n+                     E := Defining_Entity (D);\n+\n+                     if Outer\n+                       and then not Is_Imported (E)\n+                       and then not Is_Exported (E)\n+                       and then No (Interface_Name (E))\n+                     then\n+                        Set_Is_Public (E, False);\n+                     end if;\n+                  end if;\n+\n+                  Prev (D);\n+               end loop;\n+\n+               return False;\n+            end Has_Referencer;\n+\n+         --  Start of processing for Make_Non_Public_Where_Possible\n+\n+         begin\n+            Discard := Has_Referencer (Declarations (N), Outer => True);\n+         end Make_Non_Public_Where_Possible;\n+      end if;\n+\n+      --  If expander is not active, then here is where we turn off the\n+      --  In_Package_Body flag, otherwise it is turned off at the end of\n+      --  the corresponding expansion routine. If this is an instance body,\n+      --  we need to qualify names of local entities, because the body may\n+      --  have been compiled as a preliminary to another instantiation.\n+\n+      if not Expander_Active then\n+         Set_In_Package_Body (Spec_Id, False);\n+\n+         if Is_Generic_Instance (Spec_Id)\n+           and then Operating_Mode = Generate_Code\n+         then\n+            Qualify_Entity_Names (N);\n+         end if;\n+      end if;\n+   end Analyze_Package_Body;\n+\n+   ---------------------------------\n+   -- Analyze_Package_Declaration --\n+   ---------------------------------\n+\n+   procedure Analyze_Package_Declaration (N : Node_Id) is\n+      Id : constant Node_Id := Defining_Entity (N);\n+      PF : Boolean;\n+\n+   begin\n+      Generate_Definition (Id);\n+      Enter_Name (Id);\n+      Set_Ekind (Id, E_Package);\n+      Set_Etype (Id, Standard_Void_Type);\n+      New_Scope (Id);\n+\n+      PF := Is_Pure (Enclosing_Lib_Unit_Entity);\n+      Set_Is_Pure (Id, PF);\n+\n+      Set_Categorization_From_Pragmas (N);\n+\n+      if Debug_Flag_C then\n+         Write_Str (\"====  Compiling package spec \");\n+         Write_Name (Chars (Id));\n+         Write_Str (\" from \");\n+         Write_Location (Sloc (N));\n+         Write_Eol;\n+      end if;\n+\n+      Analyze (Specification (N));\n+      Validate_Categorization_Dependency (N, Id);\n+      End_Package_Scope (Id);\n+\n+      --  For a compilation unit, indicate whether it needs a body, and\n+      --  whether elaboration warnings may be meaningful on it.\n+\n+      if Nkind (Parent (N)) = N_Compilation_Unit then\n+         Set_Body_Required (Parent (N), Unit_Requires_Body (Id));\n+\n+         if not Body_Required (Parent (N)) then\n+            Set_Suppress_Elaboration_Warnings (Id);\n+         end if;\n+\n+         Validate_RT_RAT_Component (N);\n+      end if;\n+\n+      --  Clear Not_Source_Assigned on all variables in the package spec,\n+      --  because at this stage some client, or the body, or a child package,\n+      --  may modify variables in the declaration. Note that we wait till now\n+      --  to reset these flags, because during analysis of the declaration,\n+      --  the flags correctly indicated the status up to that point. We\n+      --  similarly clear any Is_True_Constant indications.\n+\n+      declare\n+         E : Entity_Id;\n+\n+      begin\n+         E := First_Entity (Id);\n+         while Present (E) loop\n+            if Ekind (E) = E_Variable then\n+               Set_Not_Source_Assigned (E, False);\n+               Set_Is_True_Constant    (E, False);\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+      end;\n+   end Analyze_Package_Declaration;\n+\n+   -----------------------------------\n+   -- Analyze_Package_Specification --\n+   -----------------------------------\n+\n+   procedure Analyze_Package_Specification (N : Node_Id) is\n+      Id           : constant Entity_Id  := Defining_Entity (N);\n+      Orig_Decl    : constant Node_Id    := Original_Node (Parent (N));\n+      Vis_Decls    : constant List_Id    := Visible_Declarations (N);\n+      Priv_Decls   : constant List_Id    := Private_Declarations (N);\n+      E            : Entity_Id;\n+      L            : Entity_Id;\n+      Public_Child : Boolean             := False;\n+\n+      function Is_Public_Child (Child, Unit : Entity_Id) return Boolean;\n+      --  Child and Unit are entities of compilation units. True if Child\n+      --  is a public child of Parent as defined in 10.1.1\n+\n+      function Is_Public_Child (Child, Unit : Entity_Id) return Boolean is\n+      begin\n+         if not Is_Private_Descendant (Child) then\n+            return True;\n+         else\n+            if Child = Unit then\n+               return not Private_Present (\n+                 Parent (Unit_Declaration_Node (Child)));\n+            else\n+               return Is_Public_Child (Scope (Child), Unit);\n+            end if;\n+         end if;\n+      end Is_Public_Child;\n+\n+   --  Start of processing for Analyze_Package_Specification\n+\n+   begin\n+      if Present (Vis_Decls) then\n+         Analyze_Declarations (Vis_Decls);\n+      end if;\n+\n+      --  Verify that incomplete types have received full declarations.\n+\n+      E := First_Entity (Id);\n+\n+      while Present (E) loop\n+         if Ekind (E) = E_Incomplete_Type\n+           and then No (Full_View (E))\n+         then\n+            Error_Msg_N (\"no declaration in visible part for incomplete}\", E);\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      if Is_Remote_Call_Interface (Id)\n+         and then Nkind (Parent (Parent (N))) = N_Compilation_Unit\n+      then\n+         Validate_RCI_Declarations (Id);\n+      end if;\n+\n+      --  Save global references in the visible declarations, before\n+      --  installing private declarations of parent unit if there is one,\n+      --  because the privacy status of types defined in the parent will\n+      --  change. This is only relevant for generic child units, but is\n+      --  done in all cases for uniformity.\n+\n+      if Ekind (Id) = E_Generic_Package\n+        and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n+      then\n+         declare\n+            Orig_Spec : constant Node_Id    := Specification (Orig_Decl);\n+            Save_Priv : constant List_Id := Private_Declarations (Orig_Spec);\n+\n+         begin\n+            Set_Private_Declarations (Orig_Spec, Empty_List);\n+            Save_Global_References   (Orig_Decl);\n+            Set_Private_Declarations (Orig_Spec, Save_Priv);\n+         end;\n+      end if;\n+\n+      --  If package is a public child unit, then make the private\n+      --  declarations of the parent visible.\n+\n+      if Present (Parent_Spec (Parent (N))) then\n+         declare\n+            Par       : Entity_Id := Id;\n+            Pack_Decl : Node_Id;\n+\n+         begin\n+            while Scope (Par) /= Standard_Standard\n+              and then Is_Public_Child (Id, Par)\n+            loop\n+               Public_Child := True;\n+               Par := Scope (Par);\n+               Install_Private_Declarations (Par);\n+               Pack_Decl := Unit_Declaration_Node (Par);\n+               Set_Use (Private_Declarations (Specification (Pack_Decl)));\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Analyze private part if present. The flag In_Private_Part is\n+      --  reset in End_Package_Scope.\n+\n+      L := Last_Entity (Id);\n+\n+      if Present (Priv_Decls) then\n+         L := Last_Entity (Id);\n+         Set_In_Private_Part (Id);\n+\n+         --  Upon entering a public child's private part, it may be\n+         --  necessary to declare subprograms that were derived in\n+         --  the package visible part but not yet made visible.\n+\n+         if Public_Child then\n+            Declare_Inherited_Private_Subprograms (Id);\n+         end if;\n+\n+         Analyze_Declarations (Priv_Decls);\n+\n+         --  The first private entity is the immediate follower of the last\n+         --  visible entity, if there was one.\n+\n+         if Present (L) then\n+            Set_First_Private_Entity (Id, Next_Entity (L));\n+         else\n+            Set_First_Private_Entity (Id, First_Entity (Id));\n+         end if;\n+\n+      --  There may be inherited private subprograms that need to be\n+      --  declared, even in the absence of an explicit private part.\n+      --  If there are any public declarations in the package and\n+      --  the package is a public child unit, then an implicit private\n+      --  part is assumed.\n+\n+      elsif Present (L) and then Public_Child then\n+         Set_In_Private_Part (Id);\n+         Declare_Inherited_Private_Subprograms (Id);\n+         Set_First_Private_Entity (Id, Next_Entity (L));\n+      end if;\n+\n+      --  Check rule of 3.6(11), which in general requires\n+      --  waiting till all full types have been seen.\n+\n+      E := First_Entity (Id);\n+      while Present (E) loop\n+         if Ekind (E) = E_Record_Type or else Ekind (E) = E_Array_Type then\n+            Check_Aliased_Component_Types (E);\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      if Ekind (Id) = E_Generic_Package\n+        and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n+        and then Present (Priv_Decls)\n+      then\n+         --  Save global references in private declarations, ignoring the\n+         --  visible declarations that were processed earlier.\n+\n+         declare\n+            Orig_Spec : constant Node_Id := Specification (Orig_Decl);\n+            Save_Vis  : constant List_Id := Visible_Declarations (Orig_Spec);\n+            Save_Form : constant List_Id :=\n+                          Generic_Formal_Declarations (Orig_Decl);\n+\n+         begin\n+            Set_Visible_Declarations        (Orig_Spec, Empty_List);\n+            Set_Generic_Formal_Declarations (Orig_Decl, Empty_List);\n+            Save_Global_References          (Orig_Decl);\n+            Set_Generic_Formal_Declarations (Orig_Decl, Save_Form);\n+            Set_Visible_Declarations        (Orig_Spec, Save_Vis);\n+         end;\n+      end if;\n+\n+      Process_End_Label (N, 'e');\n+   end Analyze_Package_Specification;\n+\n+   --------------------------------------\n+   -- Analyze_Private_Type_Declaration --\n+   --------------------------------------\n+\n+   procedure Analyze_Private_Type_Declaration (N : Node_Id) is\n+      PF : constant Boolean := Is_Pure (Enclosing_Lib_Unit_Entity);\n+      Id : Entity_Id := Defining_Identifier (N);\n+\n+   begin\n+      Generate_Definition (Id);\n+      Set_Is_Pure         (Id, PF);\n+      Init_Size_Align     (Id);\n+\n+      if (Ekind (Current_Scope) /= E_Package\n+          and then Ekind (Current_Scope) /= E_Generic_Package)\n+        or else In_Private_Part (Current_Scope)\n+      then\n+         Error_Msg_N (\"invalid context for private declaration\", N);\n+      end if;\n+\n+      New_Private_Type (N, Id, N);\n+      Set_Depends_On_Private (Id);\n+      Set_Has_Delayed_Freeze (Id);\n+\n+   end Analyze_Private_Type_Declaration;\n+\n+   -------------------------------------------\n+   -- Declare_Inherited_Private_Subprograms --\n+   -------------------------------------------\n+\n+   procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id) is\n+      E : Entity_Id;\n+\n+   begin\n+      E := First_Entity (Id);\n+\n+      while Present (E) loop\n+\n+         --  If the entity is a nonprivate type extension whose parent\n+         --  type is declared in an open scope, then the type may have\n+         --  inherited operations that now need to be made visible.\n+         --  Ditto if the entity is a formal derived type in a child unit.\n+\n+         if Is_Tagged_Type (E)\n+           and then\n+             ((Is_Derived_Type (E) and then not Is_Private_Type (E))\n+               or else\n+             (Nkind (Parent (E)) = N_Private_Extension_Declaration\n+               and then Is_Generic_Type (E)))\n+           and then In_Open_Scopes (Scope (Etype (E)))\n+           and then E = Base_Type (E)\n+         then\n+            declare\n+               Op_List        : constant Elist_Id := Primitive_Operations (E);\n+               Op_Elmt        : Elmt_Id := First_Elmt (Op_List);\n+               Op_Elmt_2      : Elmt_Id;\n+               Prim_Op        : Entity_Id;\n+               New_Op         : Entity_Id := Empty;\n+               Parent_Subp    : Entity_Id;\n+               Found_Explicit : Boolean;\n+               Decl_Privates  : Boolean := False;\n+\n+            begin\n+               while Present (Op_Elmt) loop\n+                  Prim_Op := Node (Op_Elmt);\n+\n+                  --  If the primitive operation is an implicit operation\n+                  --  with an internal name whose parent operation has\n+                  --  a normal name, then we now need to either declare the\n+                  --  operation (i.e., make it visible), or replace it\n+                  --  by an overriding operation if one exists.\n+\n+                  if Present (Alias (Prim_Op))\n+                    and then not Comes_From_Source (Prim_Op)\n+                    and then Is_Internal_Name (Chars (Prim_Op))\n+                    and then not Is_Internal_Name (Chars (Alias (Prim_Op)))\n+                  then\n+                     Parent_Subp := Alias (Prim_Op);\n+\n+                     Found_Explicit := False;\n+                     Op_Elmt_2 := Next_Elmt (Op_Elmt);\n+                     while Present (Op_Elmt_2) loop\n+                        if Chars (Node (Op_Elmt_2)) = Chars (Parent_Subp)\n+                          and then Type_Conformant (Prim_Op, Node (Op_Elmt_2))\n+                        then\n+                           --  The private inherited operation has been\n+                           --  overridden by an explicit subprogram, so\n+                           --  change the private op's list element to\n+                           --  designate the explicit so the explicit\n+                           --  one will get the right dispatching slot.\n+\n+                           New_Op := Node (Op_Elmt_2);\n+                           Replace_Elmt (Op_Elmt, New_Op);\n+                           Remove_Elmt (Op_List, Op_Elmt_2);\n+                           Found_Explicit := True;\n+                           Decl_Privates  := True;\n+                           exit;\n+                        end if;\n+\n+                        Next_Elmt (Op_Elmt_2);\n+                     end loop;\n+\n+                     if not Found_Explicit then\n+                        Derive_Subprogram\n+                          (New_Op, Alias (Prim_Op), E, Etype (E));\n+\n+                        pragma Assert\n+                          (Is_Dispatching_Operation (New_Op)\n+                            and then Node (Last_Elmt (Op_List)) = New_Op);\n+\n+                        --  Substitute the new operation for the old one\n+                        --  in the type's primitive operations list. Since\n+                        --  the new operation was also just added to the end\n+                        --  of list, the last element must be removed.\n+\n+                        --  (Question: is there a simpler way of declaring\n+                        --  the operation, say by just replacing the name\n+                        --  of the earlier operation, reentering it in the\n+                        --  in the symbol table (how?), and marking it as\n+                        --  private???)\n+\n+                        Replace_Elmt (Op_Elmt, New_Op);\n+                        Remove_Last_Elmt (Op_List);\n+                        Decl_Privates := True;\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (Op_Elmt);\n+               end loop;\n+\n+               --  The type's DT attributes need to be recalculated\n+               --  in the case where private dispatching operations\n+               --  have been added or overridden. Normally this action\n+               --  occurs during type freezing, but we force it here\n+               --  since the type may already have been frozen (e.g.,\n+               --  if the type's package has an empty private part).\n+               --  This can only be done if expansion is active, otherwise\n+               --  Tag may not be present.\n+\n+               if Decl_Privates\n+                 and then Expander_Active\n+               then\n+                  Set_All_DT_Position (E);\n+               end if;\n+            end;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+   end Declare_Inherited_Private_Subprograms;\n+\n+   -----------------------\n+   -- End_Package_Scope --\n+   -----------------------\n+\n+   procedure End_Package_Scope (P : Entity_Id) is\n+   begin\n+      Uninstall_Declarations (P);\n+      Pop_Scope;\n+   end End_Package_Scope;\n+\n+   ---------------------------\n+   -- Exchange_Declarations --\n+   ---------------------------\n+\n+   procedure Exchange_Declarations (Id : Entity_Id) is\n+      Full_Id : constant Entity_Id := Full_View (Id);\n+      H1      : constant Entity_Id := Homonym (Id);\n+      Next1   : constant Entity_Id := Next_Entity (Id);\n+      H2      : Entity_Id;\n+      Next2   : Entity_Id;\n+\n+   begin\n+      --  If missing full declaration for type, nothing to exchange\n+\n+      if No (Full_Id) then\n+         return;\n+      end if;\n+\n+      --  Otherwise complete the exchange, and preserve semantic links\n+\n+      Next2 := Next_Entity (Full_Id);\n+      H2    := Homonym (Full_Id);\n+\n+      --  Reset full declaration pointer to reflect the switched entities\n+      --  and readjust the next entity chains.\n+\n+      Exchange_Entities (Id, Full_Id);\n+\n+      Set_Next_Entity (Id, Next1);\n+      Set_Homonym     (Id, H1);\n+\n+      Set_Full_View   (Full_Id, Id);\n+      Set_Next_Entity (Full_Id, Next2);\n+      Set_Homonym     (Full_Id, H2);\n+   end Exchange_Declarations;\n+\n+   ----------------------------------\n+   -- Install_Composite_Operations --\n+   ----------------------------------\n+\n+   procedure Install_Composite_Operations (P : Entity_Id) is\n+      Id : Entity_Id;\n+\n+   begin\n+      Id := First_Entity (P);\n+\n+      while Present (Id) loop\n+\n+         if Is_Type (Id)\n+           and then (Is_Limited_Composite (Id)\n+                      or else Is_Private_Composite (Id))\n+           and then No (Private_Component (Id))\n+         then\n+            Set_Is_Limited_Composite (Id, False);\n+            Set_Is_Private_Composite (Id, False);\n+         end if;\n+\n+         Next_Entity (Id);\n+      end loop;\n+   end Install_Composite_Operations;\n+\n+   ----------------------------\n+   -- Install_Package_Entity --\n+   ----------------------------\n+\n+   procedure Install_Package_Entity (Id : Entity_Id) is\n+   begin\n+      if not Is_Internal (Id) then\n+         if Debug_Flag_E then\n+            Write_Str (\"Install: \");\n+            Write_Name (Chars (Id));\n+            Write_Eol;\n+         end if;\n+\n+         if not Is_Child_Unit (Id) then\n+            Set_Is_Immediately_Visible (Id);\n+         end if;\n+\n+      end if;\n+   end Install_Package_Entity;\n+\n+   ----------------------------------\n+   -- Install_Private_Declarations --\n+   ----------------------------------\n+\n+   procedure Install_Private_Declarations (P : Entity_Id) is\n+      Id        : Entity_Id;\n+      Priv_Elmt : Elmt_Id;\n+      Priv      : Entity_Id;\n+      Full      : Entity_Id;\n+\n+   begin\n+      --  First exchange declarations for private types, so that the\n+      --  full declaration is visible. For each private type, we check\n+      --  its Private_Dependents list and also exchange any subtypes of\n+      --  or derived types from it. Finally, if this is a Taft amendment\n+      --  type, the incomplete declaration is irrelevant, and we want to\n+      --  link the eventual full declaration with the original private\n+      --  one so we also skip the exchange.\n+\n+      Id := First_Entity (P);\n+\n+      while Present (Id) and then Id /= First_Private_Entity (P) loop\n+\n+         if Is_Private_Base_Type (Id)\n+           and then Comes_From_Source (Full_View (Id))\n+           and then Present (Full_View (Id))\n+           and then Scope (Full_View (Id)) = Scope (Id)\n+           and then Ekind (Full_View (Id)) /= E_Incomplete_Type\n+         then\n+            Priv_Elmt := First_Elmt (Private_Dependents (Id));\n+\n+            --  If there is a use-type clause on the private type, set the\n+            --  full view accordingly.\n+\n+            Set_In_Use (Full_View (Id), In_Use (Id));\n+            Full := Full_View (Id);\n+\n+            if Is_Private_Base_Type (Full)\n+              and then Has_Private_Declaration (Full)\n+              and then Nkind (Parent (Full)) = N_Full_Type_Declaration\n+              and then In_Open_Scopes (Scope (Etype (Full)))\n+              and then In_Package_Body (Current_Scope)\n+              and then not Is_Private_Type (Etype (Full))\n+            then\n+               --  This is the completion of a private type by a derivation\n+               --  from another private type which is not private anymore. This\n+               --  can only happen in a package nested within a child package,\n+               --  when the parent type is defined in the parent unit. At this\n+               --  point the current type is not private either, and we have to\n+               --  install the underlying full view, which is now visible.\n+\n+               if No (Full_View (Full))\n+                 and then Present (Underlying_Full_View (Full))\n+               then\n+                  Set_Full_View (Id, Underlying_Full_View (Full));\n+                  Set_Underlying_Full_View (Full, Empty);\n+                  Set_Is_Frozen (Full_View (Id));\n+               end if;\n+            end if;\n+\n+            Exchange_Declarations (Id);\n+            Set_Is_Immediately_Visible (Id);\n+\n+            while Present (Priv_Elmt) loop\n+               Priv := Node (Priv_Elmt);\n+\n+               --  Before the exchange, verify that the presence of the\n+               --  Full_View field. It will be empty if the entity\n+               --  has already been installed due to a previous call.\n+\n+               if Present (Full_View (Priv))\n+                 and then Is_Visible_Dependent (Priv)\n+               then\n+\n+                  --  For each subtype that is swapped, we also swap the\n+                  --  reference to it in Private_Dependents, to allow access\n+                  --  to it when we swap them out in End_Package_Scope.\n+\n+                  Replace_Elmt (Priv_Elmt, Full_View (Priv));\n+                  Exchange_Declarations (Priv);\n+                  Set_Is_Immediately_Visible\n+                    (Priv, In_Open_Scopes (Scope (Priv)));\n+                  Set_Is_Potentially_Use_Visible\n+                    (Priv, Is_Potentially_Use_Visible (Node (Priv_Elmt)));\n+               end if;\n+\n+               Next_Elmt (Priv_Elmt);\n+            end loop;\n+\n+            null;\n+         end if;\n+\n+         Next_Entity (Id);\n+      end loop;\n+\n+      --  Next make other declarations in the private part visible as well.\n+\n+      Id := First_Private_Entity (P);\n+\n+      while Present (Id) loop\n+         Install_Package_Entity (Id);\n+         Next_Entity (Id);\n+      end loop;\n+\n+      --  Indicate that the private part is currently visible, so it can be\n+      --  properly reset on exit.\n+\n+      Set_In_Private_Part (P);\n+   end Install_Private_Declarations;\n+\n+   ----------------------------------\n+   -- Install_Visible_Declarations --\n+   ----------------------------------\n+\n+   procedure Install_Visible_Declarations (P : Entity_Id) is\n+      Id : Entity_Id;\n+\n+   begin\n+      Id := First_Entity (P);\n+\n+      while Present (Id) and then Id /= First_Private_Entity (P) loop\n+         Install_Package_Entity (Id);\n+         Next_Entity (Id);\n+      end loop;\n+   end Install_Visible_Declarations;\n+\n+   ----------------------\n+   -- Is_Fully_Visible --\n+   ----------------------\n+\n+   --  The full declaration of a private type is visible in the private\n+   --  part of the package declaration, and in the package body, at which\n+   --  point the full declaration must have been given.\n+\n+   function Is_Fully_Visible (Type_Id : Entity_Id) return Boolean is\n+      S : constant Entity_Id := Scope (Type_Id);\n+\n+   begin\n+      if Is_Generic_Type (Type_Id) then\n+         return False;\n+\n+      elsif In_Private_Part (S) then\n+         return Present (Full_View (Type_Id));\n+\n+      else\n+         return In_Package_Body (S);\n+      end if;\n+   end Is_Fully_Visible;\n+\n+   --------------------------\n+   -- Is_Private_Base_Type --\n+   --------------------------\n+\n+   function Is_Private_Base_Type (E : Entity_Id) return Boolean is\n+   begin\n+      return Ekind (E) = E_Private_Type\n+        or else Ekind (E) = E_Limited_Private_Type\n+        or else Ekind (E) = E_Record_Type_With_Private;\n+   end Is_Private_Base_Type;\n+\n+   --------------------------\n+   -- Is_Visible_Dependent --\n+   --------------------------\n+\n+   function Is_Visible_Dependent (Dep : Entity_Id) return Boolean\n+   is\n+      S : constant Entity_Id := Scope (Dep);\n+\n+   begin\n+      --  Renamings created for actual types have the visibility of the\n+      --  actual.\n+\n+      if Ekind (S) = E_Package\n+        and then Is_Generic_Instance (S)\n+        and then (Is_Generic_Actual_Type (Dep)\n+                   or else Is_Generic_Actual_Type (Full_View (Dep)))\n+      then\n+         return True;\n+\n+      elsif not (Is_Derived_Type (Dep))\n+        and then Is_Derived_Type (Full_View (Dep))\n+      then\n+         return In_Open_Scopes (S);\n+      else\n+         return True;\n+      end if;\n+   end Is_Visible_Dependent;\n+\n+   ----------------------------\n+   -- May_Need_Implicit_Body --\n+   ----------------------------\n+\n+   procedure May_Need_Implicit_Body (E : Entity_Id) is\n+      P     : constant Node_Id := Unit_Declaration_Node (E);\n+      S     : constant Node_Id := Parent (P);\n+      B     : Node_Id;\n+      Decls : List_Id;\n+\n+   begin\n+      if not Has_Completion (E)\n+        and then Nkind (P) = N_Package_Declaration\n+        and then Present (Activation_Chain_Entity (P))\n+      then\n+         B :=\n+           Make_Package_Body (Sloc (E),\n+             Defining_Unit_Name => Make_Defining_Identifier (Sloc (E),\n+               Chars => Chars (E)),\n+             Declarations  => New_List);\n+\n+         if Nkind (S) = N_Package_Specification then\n+            if Present (Private_Declarations (S)) then\n+               Decls := Private_Declarations (S);\n+            else\n+               Decls := Visible_Declarations (S);\n+            end if;\n+         else\n+            Decls := Declarations (S);\n+         end if;\n+\n+         Append (B, Decls);\n+         Analyze (B);\n+      end if;\n+   end May_Need_Implicit_Body;\n+\n+   ----------------------\n+   -- New_Private_Type --\n+   ----------------------\n+\n+   procedure New_Private_Type (N : Node_Id; Id : Entity_Id; Def : Node_Id) is\n+   begin\n+      Enter_Name (Id);\n+\n+      if Limited_Present (Def) then\n+         Set_Ekind (Id, E_Limited_Private_Type);\n+      else\n+         Set_Ekind (Id, E_Private_Type);\n+      end if;\n+\n+      Set_Etype              (Id, Id);\n+      Set_Has_Delayed_Freeze (Id);\n+      Set_Is_First_Subtype   (Id);\n+      Init_Size_Align        (Id);\n+\n+      Set_Is_Constrained (Id,\n+        No (Discriminant_Specifications (N))\n+          and then not Unknown_Discriminants_Present (N));\n+\n+      Set_Discriminant_Constraint (Id, No_Elist);\n+      Set_Girder_Constraint (Id, No_Elist);\n+\n+      if Present (Discriminant_Specifications (N)) then\n+         New_Scope (Id);\n+         Process_Discriminants (N);\n+         End_Scope;\n+\n+      elsif Unknown_Discriminants_Present (N) then\n+         Set_Has_Unknown_Discriminants (Id);\n+      end if;\n+\n+      Set_Private_Dependents (Id, New_Elmt_List);\n+\n+      if Tagged_Present (Def) then\n+         Set_Is_Tagged_Type       (Id, True);\n+         Set_Ekind                (Id, E_Record_Type_With_Private);\n+         Make_Class_Wide_Type     (Id);\n+         Set_Primitive_Operations (Id, New_Elmt_List);\n+         Set_Is_Abstract          (Id, Abstract_Present (Def));\n+         Set_Is_Limited_Record    (Id, Limited_Present (Def));\n+         Set_Has_Delayed_Freeze   (Id, True);\n+\n+      elsif Abstract_Present (Def) then\n+         Error_Msg_N (\"only a tagged type can be abstract\", N);\n+      end if;\n+   end New_Private_Type;\n+\n+   ------------------------------\n+   -- Preserve_Full_Attributes --\n+   ------------------------------\n+\n+   procedure Preserve_Full_Attributes (Priv, Full : Entity_Id) is\n+      Priv_Is_Base_Type : constant Boolean := Priv = Base_Type (Priv);\n+\n+   begin\n+      Set_Size_Info                   (Priv,                          (Full));\n+      Set_RM_Size                     (Priv, RM_Size                  (Full));\n+      Set_Size_Known_At_Compile_Time  (Priv, Size_Known_At_Compile_Time\n+                                                                      (Full));\n+\n+      if Priv_Is_Base_Type then\n+         Set_Is_Controlled            (Priv, Is_Controlled (Base_Type (Full)));\n+         Set_Has_Task                 (Priv, Has_Task      (Base_Type (Full)));\n+         Set_Finalize_Storage_Only    (Priv, Finalize_Storage_Only\n+                                                           (Base_Type (Full)));\n+         Set_Has_Controlled_Component (Priv, Has_Controlled_Component\n+                                                           (Base_Type (Full)));\n+      end if;\n+\n+      Set_Freeze_Node                 (Priv, Freeze_Node              (Full));\n+\n+      if Is_Tagged_Type (Priv)\n+        and then Is_Tagged_Type (Full)\n+        and then not Error_Posted (Full)\n+      then\n+         if Priv_Is_Base_Type then\n+            Set_Access_Disp_Table     (Priv, Access_Disp_Table\n+                                                           (Base_Type (Full)));\n+         end if;\n+\n+         Set_First_Entity             (Priv, First_Entity             (Full));\n+         Set_Last_Entity              (Priv, Last_Entity              (Full));\n+      end if;\n+   end Preserve_Full_Attributes;\n+\n+   ----------------------------\n+   -- Uninstall_Declarations --\n+   ----------------------------\n+\n+   procedure Uninstall_Declarations (P : Entity_Id) is\n+      Id   : Entity_Id;\n+      Decl : Node_Id := Unit_Declaration_Node (P);\n+      Full : Entity_Id;\n+      Priv_Elmt : Elmt_Id;\n+      Priv_Sub  : Entity_Id;\n+\n+      function Type_In_Use (T : Entity_Id) return Boolean;\n+      --  Check whether type or base type appear in an active use_type clause.\n+\n+      function Type_In_Use (T : Entity_Id) return Boolean is\n+      begin\n+         return Scope (Base_Type (T)) = P\n+           and then  (In_Use (T) or else In_Use (Base_Type (T)));\n+      end Type_In_Use;\n+\n+   --  Start of processing for Uninstall_Declarations\n+\n+   begin\n+      Id := First_Entity (P);\n+\n+      while Present (Id) and then Id /= First_Private_Entity (P) loop\n+         if Debug_Flag_E then\n+            Write_Str (\"unlinking visible entity \");\n+            Write_Int (Int (Id));\n+            Write_Eol;\n+         end if;\n+\n+         --  On  exit from the package scope, we must preserve the visibility\n+         --  established by use clauses in the current scope. Two cases:\n+\n+         --  a) If the entity is an operator, it may be a primitive operator of\n+         --  a type for which there is a visible use-type clause.\n+\n+         --  b) for other entities, their use-visibility is determined by a\n+         --  visible use clause for the package itself. For a generic instance,\n+         --  the instantiation of the formals appears in the visible part,\n+         --  but the formals are private and remain so.\n+\n+         if Ekind (Id) = E_Function\n+           and then  Is_Operator_Symbol_Name (Chars (Id))\n+           and then not Is_Hidden (Id)\n+         then\n+            Set_Is_Potentially_Use_Visible (Id,\n+              In_Use (P)\n+              or else Type_In_Use (Etype (Id))\n+              or else Type_In_Use (Etype (First_Formal (Id)))\n+              or else (Present (Next_Formal (First_Formal (Id)))\n+                         and then\n+                           Type_In_Use\n+                             (Etype (Next_Formal (First_Formal (Id))))));\n+         else\n+            Set_Is_Potentially_Use_Visible (Id,\n+              In_Use (P) and not Is_Hidden (Id));\n+         end if;\n+\n+         --  Local entities are not immediately visible outside of the package.\n+\n+         Set_Is_Immediately_Visible (Id, False);\n+\n+         if Is_Tagged_Type (Id) and then Ekind (Id) = E_Record_Type then\n+            Check_Abstract_Overriding (Id);\n+         end if;\n+\n+         if (Ekind (Id) = E_Private_Type\n+               or else Ekind (Id) = E_Limited_Private_Type)\n+           and then No (Full_View (Id))\n+           and then not Is_Generic_Type (Id)\n+           and then not Is_Derived_Type (Id)\n+         then\n+            Error_Msg_N (\"missing full declaration for private type&\", Id);\n+\n+         elsif Ekind (Id) = E_Record_Type_With_Private\n+           and then not Is_Generic_Type (Id)\n+           and then No (Full_View (Id))\n+         then\n+            if Nkind (Parent (Id)) = N_Private_Type_Declaration then\n+               Error_Msg_N (\"missing full declaration for private type&\", Id);\n+            else\n+               Error_Msg_N\n+                 (\"missing full declaration for private extension\", Id);\n+            end if;\n+\n+         elsif Ekind (Id) = E_Constant\n+           and then No (Constant_Value (Id))\n+           and then No (Full_View (Id))\n+           and then not Is_Imported (Id)\n+           and then (Nkind (Parent (Id)) /= N_Object_Declaration\n+                      or else not No_Initialization (Parent (Id)))\n+         then\n+            Error_Msg_N (\"missing full declaration for deferred constant\", Id);\n+         end if;\n+\n+         Next_Entity (Id);\n+      end loop;\n+\n+      --  If the specification was installed as the parent of a public child\n+      --  unit, the private declarations were not installed, and there is\n+      --  nothing to do.\n+\n+      if not In_Private_Part (P) then\n+         return;\n+      else\n+         Set_In_Private_Part (P, False);\n+      end if;\n+\n+      --  Make private entities invisible and exchange full and private\n+      --  declarations for private types.\n+\n+      while Present (Id) loop\n+         if Debug_Flag_E then\n+            Write_Str (\"unlinking private entity \");\n+            Write_Int (Int (Id));\n+            Write_Eol;\n+         end if;\n+\n+         if Is_Tagged_Type (Id) and then Ekind (Id) = E_Record_Type then\n+            Check_Abstract_Overriding (Id);\n+         end if;\n+\n+         Set_Is_Immediately_Visible (Id, False);\n+\n+         if Is_Private_Base_Type (Id)\n+           and then Present (Full_View (Id))\n+         then\n+            Full := Full_View (Id);\n+\n+            --  If the partial view is not declared in the visible part\n+            --  of the package (as is the case when it is a type derived\n+            --  from some other private type in the private part if the\n+            --  current package), no exchange takes place.\n+\n+            if No (Parent (Id))\n+              or else List_Containing (Parent (Id))\n+                /= Visible_Declarations (Specification (Decl))\n+            then\n+               goto Next_Id;\n+            end if;\n+\n+            --  The entry in the private part points to the full declaration,\n+            --  which is currently visible. Exchange them so only the private\n+            --  type declaration remains accessible, and link private and\n+            --  full declaration in the opposite direction. Before the actual\n+            --  exchange, we copy back attributes of the full view that\n+            --  must be available to the partial view too.\n+\n+            Preserve_Full_Attributes (Id, Full);\n+\n+            Set_Is_Potentially_Use_Visible (Id, In_Use (P));\n+\n+            if  Is_Indefinite_Subtype (Full)\n+              and then not Is_Indefinite_Subtype (Id)\n+            then\n+               Error_Msg_N\n+                 (\"full view of type must be definite subtype\", Full);\n+            end if;\n+\n+            Priv_Elmt := First_Elmt (Private_Dependents (Id));\n+            Exchange_Declarations (Id);\n+\n+            --  Swap out the subtypes and derived types of Id that were\n+            --  compiled in this scope, or installed previously by\n+            --  Install_Private_Declarations.\n+            --  Before we do the swap, we verify the presence of the\n+            --  Full_View field which may be empty due to a swap by\n+            --  a previous call to End_Package_Scope (e.g. from the\n+            --  freezing mechanism).\n+\n+            while Present (Priv_Elmt) loop\n+               Priv_Sub := Node (Priv_Elmt);\n+\n+               if Present (Full_View (Priv_Sub)) then\n+\n+                  if Scope (Priv_Sub) = P\n+                     or else not In_Open_Scopes (Scope (Priv_Sub))\n+                  then\n+                     Set_Is_Immediately_Visible (Priv_Sub, False);\n+                  end if;\n+\n+                  if Is_Visible_Dependent (Priv_Sub) then\n+                     Preserve_Full_Attributes\n+                       (Priv_Sub, Full_View (Priv_Sub));\n+                     Replace_Elmt (Priv_Elmt, Full_View (Priv_Sub));\n+                     Exchange_Declarations (Priv_Sub);\n+                  end if;\n+               end if;\n+\n+               Next_Elmt (Priv_Elmt);\n+            end loop;\n+\n+         elsif Ekind (Id) = E_Incomplete_Type\n+           and then No (Full_View (Id))\n+         then\n+            --  Mark Taft amendment types\n+\n+            Set_Has_Completion_In_Body (Id);\n+\n+         elsif not Is_Child_Unit (Id)\n+           and then (not Is_Private_Type (Id)\n+                      or else No (Full_View (Id)))\n+         then\n+            Set_Is_Hidden (Id);\n+            Set_Is_Potentially_Use_Visible (Id, False);\n+         end if;\n+\n+         <<Next_Id>>\n+            Next_Entity (Id);\n+      end loop;\n+\n+   end Uninstall_Declarations;\n+\n+   ------------------------\n+   -- Unit_Requires_Body --\n+   ------------------------\n+\n+   function Unit_Requires_Body (P : Entity_Id) return Boolean is\n+      E : Entity_Id;\n+\n+   begin\n+      --  Imported entity never requires body. Right now, only\n+      --  subprograms can be imported, but perhaps in the future\n+      --  we will allow import of packages.\n+\n+      if Is_Imported (P) then\n+         return False;\n+\n+      --  Body required if library package with pragma Elaborate_Body\n+\n+      elsif Has_Pragma_Elaborate_Body (P) then\n+         return True;\n+\n+      --  Body required if subprogram\n+\n+      elsif (Is_Subprogram (P)\n+               or else\n+             Ekind (P) = E_Generic_Function\n+               or else\n+             Ekind (P) = E_Generic_Procedure)\n+      then\n+         return True;\n+\n+      --  Treat a block as requiring a body\n+\n+      elsif Ekind (P) = E_Block then\n+         return True;\n+\n+      elsif Ekind (P) = E_Package\n+        and then Nkind (Parent (P)) = N_Package_Specification\n+        and then Present (Generic_Parent (Parent (P)))\n+      then\n+         declare\n+            G_P : Entity_Id := Generic_Parent (Parent (P));\n+\n+         begin\n+            if Has_Pragma_Elaborate_Body (G_P) then\n+               return True;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Otherwise search entity chain for entity requiring completion.\n+\n+      E := First_Entity (P);\n+      while Present (E) loop\n+\n+         --  Always ignore child units. Child units get added to the entity\n+         --  list of a parent unit, but are not original entities of the\n+         --  parent, and so do not affect whether the parent needs a body.\n+\n+         if Is_Child_Unit (E) then\n+            null;\n+\n+         --  Otherwise test to see if entity requires a completion\n+\n+         elsif (Is_Overloadable (E)\n+               and then Ekind (E) /= E_Enumeration_Literal\n+               and then Ekind (E) /= E_Operator\n+               and then not Is_Abstract (E)\n+               and then not Has_Completion (E))\n+\n+           or else\n+             (Ekind (E) = E_Package\n+               and then E /= P\n+               and then not Has_Completion (E)\n+               and then Unit_Requires_Body (E))\n+\n+           or else\n+             (Ekind (E) = E_Incomplete_Type and then No (Full_View (E)))\n+\n+           or else\n+            ((Ekind (E) = E_Task_Type or else\n+              Ekind (E) = E_Protected_Type)\n+               and then not Has_Completion (E))\n+\n+           or else\n+             (Ekind (E) = E_Generic_Package and then E /= P\n+               and then not Has_Completion (E)\n+               and then Unit_Requires_Body (E))\n+\n+           or else\n+             (Ekind (E) = E_Generic_Function\n+               and then not Has_Completion (E))\n+\n+           or else\n+             (Ekind (E) = E_Generic_Procedure\n+               and then not Has_Completion (E))\n+\n+         then\n+            return True;\n+\n+         --  Entity that does not require completion\n+\n+         else\n+            null;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      return False;\n+   end Unit_Requires_Body;\n+\n+end Sem_Ch7;"}, {"sha": "057c73ca655c92f3e55d813eeb4642f2283f5db6", "filename": "gcc/ada/sem_ch7.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,87 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 7                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $                             --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sem_Ch7  is\n+\n+   procedure Analyze_Package_Body                       (N : Node_Id);\n+   procedure Analyze_Package_Declaration                (N : Node_Id);\n+   procedure Analyze_Package_Specification              (N : Node_Id);\n+   procedure Analyze_Private_Type_Declaration           (N : Node_Id);\n+\n+   procedure End_Package_Scope (P : Entity_Id);\n+   --  Calls Uninstall_Declarations, and then pops the scope stack.\n+\n+   procedure Exchange_Declarations (Id : Entity_Id);\n+   --  Exchange private and full declaration on entry/exit from a package\n+   --  declaration or body. The semantic links of the respective nodes\n+   --  are preserved in the exchange.\n+\n+   procedure Install_Visible_Declarations (P : Entity_Id);\n+   procedure Install_Private_Declarations (P : Entity_Id);\n+\n+   --  On entrance to a package body, make declarations in package spec\n+   --  immediately visible.\n+\n+   --  When compiling the body of a package,  both routines are called in\n+   --  succession. When compiling the body of a child package, the call\n+   --  to Install_Private_Declaration is immediate for private children,\n+   --  but is deffered until the compilation of the  private part of the\n+   --  child for public child packages.\n+\n+   procedure Install_Package_Entity (Id : Entity_Id);\n+   --  Basic procedure for the previous two. Places one entity on its\n+   --  visibility chain, and recurses on the visible part if the entity\n+   --  is an inner package.\n+\n+   function Unit_Requires_Body (P : Entity_Id) return Boolean;\n+   --  Check if a unit requires a body. A specification requires a body\n+   --  if it contains declarations that require completion in a body.\n+\n+   procedure May_Need_Implicit_Body (E : Entity_Id);\n+   --  If a package declaration contains tasks and does not require a\n+   --  body, create an implicit body at the end of the current declarative\n+   --  part to activate those tasks.\n+\n+   function Is_Fully_Visible (Type_Id : Entity_Id) return Boolean;\n+   --  Indicates whether the Full Declaration of a private type is visible.\n+\n+   procedure New_Private_Type (N : Node_Id; Id : Entity_Id; Def : Node_Id);\n+   --  Common processing for private type declarations and for formal\n+   --  private type declarations. For private types, N and Def are the type\n+   --  declaration node; for formal private types, Def is the formal type\n+   --  definition.\n+\n+   procedure Uninstall_Declarations (P : Entity_Id);\n+   --  At the end of a package declaration or body, declarations in the\n+   --  visible part are no longer immediately visible, and declarations in\n+   --  the private part are not visible at all. For inner packages, place\n+   --  visible entities at the end of their homonym chains. For compilation\n+   --  units, make all entities invisible. In both cases, exchange private\n+   --  and visible declarations to restore order of elaboration.\n+end Sem_Ch7;"}, {"sha": "ab90a102d70a1dbcb048b013e3733e99a379e7ef", "filename": "gcc/ada/sem_ch8.adb", "status": "added", "additions": 5224, "deletions": 0, "changes": 5224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "c2713657a4a695a70b232f52e880629a824db82a", "filename": "gcc/ada/sem_ch8.ads", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,190 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 8                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.33 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Sem_Ch8 is\n+\n+   -----------------------------------\n+   -- Handling extensions of System --\n+   -----------------------------------\n+\n+   --  For targets that define a much larger System package than given in\n+   --  the RM, we use a child package containing additional declarations,\n+   --  which is loaded when needed, and whose entities are conceptually\n+   --  within System itself. The presence of this auxiliary package is\n+   --  controlled with the pragma Extend_System. The following variable\n+   --  holds the entity of the auxiliary package, to simplify the special\n+   --  visibility rules that apply to it.\n+\n+   System_Aux_Id : Entity_Id := Empty;\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Analyze_Exception_Renaming                 (N : Node_Id);\n+   procedure Analyze_Expanded_Name                      (N : Node_Id);\n+   procedure Analyze_Generic_Function_Renaming          (N : Node_Id);\n+   procedure Analyze_Generic_Package_Renaming           (N : Node_Id);\n+   procedure Analyze_Generic_Procedure_Renaming         (N : Node_Id);\n+   procedure Analyze_Object_Renaming                    (N : Node_Id);\n+   procedure Analyze_Package_Renaming                   (N : Node_Id);\n+   procedure Analyze_Subprogram_Renaming                (N : Node_Id);\n+   procedure Analyze_Use_Package                        (N : Node_Id);\n+   procedure Analyze_Use_Type                           (N : Node_Id);\n+\n+   function Applicable_Use (Pack_Name : Node_Id) return Boolean;\n+   --  Common code to Use_One_Package and Set_Use, to determine whether\n+   --  use clause must be processed. Pack_Name is an entity name that\n+   --  references the package in question.\n+\n+   procedure End_Scope;\n+   --  Called at end of scope. On exit from blocks and bodies (subprogram,\n+   --  package, task, and protected bodies), the name of the current scope\n+   --  must be removed from the scope stack, and the local entities must be\n+   --  removed from their homonym chains. On exit from record declarations,\n+   --  from package specifications, and from tasks and protected type\n+   --  specifications, more specialized procedures are invoked.\n+\n+   procedure End_Use_Clauses (Clause : Node_Id);\n+   --  Invoked on scope exit, to undo the effect of local use clauses. U is\n+   --  the first Use clause of a scope being exited. This can be the current\n+   --  scope, or some enclosing scopes when building a clean environment to\n+   --  compile an instance body for inlining.\n+\n+   procedure End_Use_Package (N : Node_Id);\n+   procedure End_Use_Type    (N : Node_Id);\n+   --  Subsidiaries of End_Use_Clauses.  Also called directly for use clauses\n+   --  appearing in context clauses.\n+\n+   procedure Find_Direct_Name (N : Node_Id);\n+   --  Given a direct name (Identifier or Operator_Symbol), this routine\n+   --  scans the homonym chain for the name searching for corresponding\n+   --  visible entities to find the referenced entity (or in the case of\n+   --  overloading), entities. On return, the Entity, and Etype fields\n+   --  are set. In the non-overloaded case, these are the correct final\n+   --  entries. In the overloaded case, Is_Overloaded is set, Etype and\n+   --  Entity refer to an arbitrary element of the overloads set, and\n+   --  an appropriate list of entries has been made in the overload\n+   --  interpretation table (to be disambiguated in the resolve phase).\n+\n+   procedure Find_Expanded_Name (N : Node_Id);\n+   --  Selected component is known to be expanded name. Verify legality\n+   --  of selector given the scope denoted by prefix.\n+\n+   procedure Find_Selected_Component (N : Node_Id);\n+   --  Resolve various cases of selected components, recognize expanded names\n+\n+   procedure Find_Type (N : Node_Id);\n+   --  Perform name resolution, and verify that the name found is that of a\n+   --  type. On return the Entity and Etype fields of the node N are set\n+   --  appropriately. If it is an incomplete type whose full declaration has\n+   --  been seen, return the entity in the full declaration. Similarly, if\n+   --  the type is private, it has receivd a full declaration, and we are\n+   --  in the private part or body of the package, return the full\n+   --  declaration as well. Special processing for Class types as well.\n+\n+   function Get_Full_View (T_Name : Entity_Id) return Entity_Id;\n+   --  If T_Name is an incomplete type and the full declaration has been\n+   --  seen, or is the name of a class_wide type whose root is incomplete.\n+   --  return the corresponding full declaration.\n+\n+   function Has_Implicit_Operator (N : Node_Id) return Boolean;\n+   --  N is an expanded name whose selector is an operator name (eg P.\"+\").\n+   --  A declarative part contains an implicit declaration of an operator\n+   --  if it has a declaration of a type to which one of the predefined\n+   --  operators apply. The existence of this routine is an artifact of\n+   --  our implementation: a more straightforward but more space-consuming\n+   --  choice would be to make all inherited operators explicit in the\n+   --  symbol table.\n+\n+   procedure Initialize;\n+   --  Initializes data structures used for visibility analysis. Must be\n+   --  called before analyzing each new main source program.\n+\n+   procedure Install_Use_Clauses (Clause : Node_Id);\n+   --  applies the use clauses appearing in a given declarative part,\n+   --  when the corresponding scope has been placed back on the scope\n+   --  stack after unstacking to compile a different context (subunit or\n+   --  parent of generic body).\n+\n+   function In_Open_Scopes (S : Entity_Id) return Boolean;\n+   --  S is the entity of a scope. This function determines if this scope\n+   --  is currently open (i.e. it appears somewhere in the scope stack).\n+\n+   function Is_Appropriate_For_Record (T : Entity_Id) return Boolean;\n+   --  Prefix is appropriate for record if it is of a record type, or\n+   --  an access to such.\n+\n+   function Is_Appropriate_For_Entry_Prefix (T : Entity_Id) return Boolean;\n+   --  True if it is of a task type, a protected type, or else an access\n+   --  to one of these types.\n+\n+   procedure New_Scope (S : Entity_Id);\n+   --  Make new scope stack entry, pushing S, the entity for a scope\n+   --  onto the top of the scope table. The current setting of the scope\n+   --  suppress flags is saved for restoration on exit.\n+\n+   procedure Pop_Scope;\n+   --  Remove top entry from scope stack, restoring the saved setting\n+   --  of the scope suppress flags.\n+\n+   function Present_System_Aux (N : Node_Id := Empty) return Boolean;\n+   --  Return True if the auxiliary system file has been sucessfully loaded.\n+   --  Otherwise attempt to load it, using the name supplied by a previous\n+   --  Extend_System pragma, and report on the success of the load.\n+   --  If N is present, it is a selected component whose prefix is System,\n+   --  or else a with-clause on system. N is absent when the function is\n+   --  called to find the visibility of implicit operators.\n+\n+   procedure Restore_Scope_Stack;\n+   procedure Save_Scope_Stack;\n+   --  These two procedures are called from Semantics, when a unit U1 is\n+   --  to be compiled in the course of the compilation of another unit U2.\n+   --  This happens whenever Rtsfind is called. U1, the unit retrieved by\n+   --  Rtsfind, must be compiled in its own context, and the current scope\n+   --  stack containing U2 and local scopes must be made unreachable. On\n+   --  return, the contents of the scope stack must be made accessible again.\n+\n+   procedure Use_One_Package (P : Entity_Id; N : Node_Id);\n+   --  Make visible entities declarated in package P potentially use-visible\n+   --  in the current context. Also used in the analysis of subunits, when\n+   --  re-installing use clauses of parent units. N is the use_clause that\n+   --  names P (and possibly other packages).\n+\n+   procedure Use_One_Type (Id : Node_Id; N : Node_Id);\n+   --  Id is the subtype mark from a use type clause. This procedure makes\n+   --  the primitive operators of the type potentially use-visible.\n+   --  N is the Use_Type_Clause that names Id.\n+\n+   procedure Set_Use (L : List_Id);\n+   --  Find use clauses that are declarative items in a package declaration\n+   --  and  set the potentially use-visible flags of imported entities before\n+   --  analyzing the corresponding package body.\n+\n+end Sem_Ch8;"}, {"sha": "2075e5e534280b05a653bccaecb9c683e9a5459b", "filename": "gcc/ada/sem_ch9.adb", "status": "added", "additions": 1705, "deletions": 0, "changes": 1705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,1705 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 9                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.235 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Checks;   use Checks;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Exp_Ch9;\n+with Elists;   use Elists;\n+with Itypes;   use Itypes;\n+with Lib.Xref; use Lib.Xref;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch5;  use Sem_Ch5;\n+with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n+with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Sinfo;    use Sinfo;\n+with Style;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+\n+package body Sem_Ch9 is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Check_Max_Entries (Def : Node_Id; R : Restriction_Parameter_Id);\n+   --  Given either a protected definition or a task definition in Def, check\n+   --  the corresponding restriction parameter identifier R, and if it is set,\n+   --  count the entries (checking the static requirement), and compare with\n+   --  the given maximum.\n+\n+   function Find_Concurrent_Spec (Body_Id : Entity_Id) return Entity_Id;\n+   --  Find entity in corresponding task or protected declaration. Use full\n+   --  view if first declaration was for an incomplete type.\n+\n+   procedure Install_Declarations (Spec : Entity_Id);\n+   --  Utility to make visible in corresponding body the entities defined\n+   --  in task, protected type declaration, or entry declaration.\n+\n+   -----------------------------\n+   -- Analyze_Abort_Statement --\n+   -----------------------------\n+\n+   procedure Analyze_Abort_Statement (N : Node_Id) is\n+      T_Name : Node_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+      T_Name := First (Names (N));\n+      while Present (T_Name) loop\n+         Analyze (T_Name);\n+\n+         if not Is_Task_Type (Etype (T_Name)) then\n+            Error_Msg_N (\"expect task name for ABORT\", T_Name);\n+            return;\n+         else\n+            Resolve (T_Name,  Etype (T_Name));\n+         end if;\n+\n+         Next (T_Name);\n+      end loop;\n+\n+      Check_Restriction (No_Abort_Statements, N);\n+      Check_Potentially_Blocking_Operation (N);\n+   end Analyze_Abort_Statement;\n+\n+   --------------------------------\n+   -- Analyze_Accept_Alternative --\n+   --------------------------------\n+\n+   procedure Analyze_Accept_Alternative (N : Node_Id) is\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Pragmas_Before (N)) then\n+         Analyze_List (Pragmas_Before (N));\n+      end if;\n+\n+      Analyze (Accept_Statement (N));\n+\n+      if Present (Condition (N)) then\n+         Analyze_And_Resolve (Condition (N), Any_Boolean);\n+      end if;\n+\n+      if Is_Non_Empty_List (Statements (N)) then\n+         Analyze_Statements (Statements (N));\n+      end if;\n+   end Analyze_Accept_Alternative;\n+\n+   ------------------------------\n+   -- Analyze_Accept_Statement --\n+   ------------------------------\n+\n+   procedure Analyze_Accept_Statement (N : Node_Id) is\n+      Nam       : constant Entity_Id := Entry_Direct_Name (N);\n+      Formals   : constant List_Id   := Parameter_Specifications (N);\n+      Index     : constant Node_Id   := Entry_Index (N);\n+      Stats     : constant Node_Id   := Handled_Statement_Sequence (N);\n+      Ityp      : Entity_Id;\n+      Entry_Nam : Entity_Id;\n+      E         : Entity_Id;\n+      Kind      : Entity_Kind;\n+      Task_Nam  : Entity_Id;\n+\n+      -----------------------\n+      -- Actual_Index_Type --\n+      -----------------------\n+\n+      function Actual_Index_Type (E : Entity_Id) return Entity_Id;\n+      --  If the bounds of an entry family depend on task discriminants,\n+      --  create a new index type where a discriminant is replaced by the\n+      --  local variable that renames it in the task body.\n+\n+      function Actual_Index_Type (E : Entity_Id) return Entity_Id is\n+         Typ   : Entity_Id := Entry_Index_Type (E);\n+         Lo    : Node_Id := Type_Low_Bound  (Typ);\n+         Hi    : Node_Id := Type_High_Bound (Typ);\n+         New_T : Entity_Id;\n+\n+         function Actual_Discriminant_Ref (Bound : Node_Id) return Node_Id;\n+         --  If bound is discriminant reference, replace with corresponding\n+         --  local variable of the same name.\n+\n+         function Actual_Discriminant_Ref (Bound : Node_Id) return Node_Id is\n+            Typ : Entity_Id := Etype (Bound);\n+            Ref : Node_Id;\n+\n+         begin\n+            if not Is_Entity_Name (Bound)\n+              or else Ekind (Entity (Bound)) /= E_Discriminant\n+            then\n+               return Bound;\n+\n+            else\n+               Ref := Make_Identifier (Sloc (N), Chars (Entity (Bound)));\n+               Analyze (Ref);\n+               Resolve (Ref, Typ);\n+               return Ref;\n+            end if;\n+         end Actual_Discriminant_Ref;\n+\n+      --  Start of processing for Actual_Index_Type\n+\n+      begin\n+         if not Has_Discriminants (Task_Nam)\n+           or else (not Is_Entity_Name (Lo)\n+                     and then not Is_Entity_Name (Hi))\n+         then\n+            return Entry_Index_Type (E);\n+         else\n+            New_T := Create_Itype (Ekind (Typ), N);\n+            Set_Etype        (New_T, Base_Type (Typ));\n+            Set_Size_Info    (New_T, Typ);\n+            Set_RM_Size      (New_T, RM_Size (Typ));\n+            Set_Scalar_Range (New_T,\n+              Make_Range (Sloc (N),\n+                Low_Bound  => Actual_Discriminant_Ref (Lo),\n+                High_Bound => Actual_Discriminant_Ref (Hi)));\n+\n+            return New_T;\n+         end if;\n+      end Actual_Index_Type;\n+\n+   --  Start of processing for Analyze_Accept_Statement\n+\n+   begin\n+      Tasking_Used := True;\n+\n+      --  Entry name is initialized to Any_Id. It should get reset to the\n+      --  matching entry entity. An error is signalled if it is not reset.\n+\n+      Entry_Nam := Any_Id;\n+\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Task_Nam := Scope_Stack.Table (J).Entity;\n+         exit when Ekind (Etype (Task_Nam)) = E_Task_Type;\n+         Kind :=  Ekind (Task_Nam);\n+\n+         if Kind /= E_Block and then Kind /= E_Loop\n+           and then not Is_Entry (Task_Nam)\n+         then\n+            Error_Msg_N (\"enclosing body of accept must be a task\", N);\n+            return;\n+         end if;\n+      end loop;\n+\n+      if Ekind (Etype (Task_Nam)) /= E_Task_Type then\n+         Error_Msg_N (\"invalid context for accept statement\",  N);\n+         return;\n+      end if;\n+\n+      --  In order to process the parameters, we create a defining\n+      --  identifier that can be used as the name of the scope. The\n+      --  name of the accept statement itself is not a defining identifier.\n+\n+      if Present (Index) then\n+         Ityp := New_Internal_Entity\n+           (E_Entry_Family, Current_Scope, Sloc (N), 'E');\n+      else\n+         Ityp := New_Internal_Entity\n+           (E_Entry, Current_Scope, Sloc (N), 'E');\n+      end if;\n+\n+      Set_Etype          (Ityp, Standard_Void_Type);\n+      Set_Accept_Address (Ityp, New_Elmt_List);\n+\n+      if Present (Formals) then\n+         New_Scope (Ityp);\n+         Process_Formals (Ityp, Formals, N);\n+         Create_Extra_Formals (Ityp);\n+         End_Scope;\n+      end if;\n+\n+      --  We set the default expressions processed flag because we don't\n+      --  need default expression functions. This is really more like a\n+      --  body entity than a spec entity anyway.\n+\n+      Set_Default_Expressions_Processed (Ityp);\n+\n+      E := First_Entity (Etype (Task_Nam));\n+\n+      while Present (E) loop\n+         if Chars (E) = Chars (Nam)\n+           and then (Ekind (E) = Ekind (Ityp))\n+           and then Type_Conformant (Ityp, E)\n+         then\n+            Entry_Nam := E;\n+            exit;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      if Entry_Nam = Any_Id then\n+         Error_Msg_N (\"no entry declaration matches accept statement\",  N);\n+         return;\n+      else\n+         Set_Entity (Nam, Entry_Nam);\n+         Generate_Reference (Entry_Nam, Nam, 'b');\n+         Style.Check_Identifier (Nam, Entry_Nam);\n+      end if;\n+\n+      --  Verify that the entry is not hidden by a procedure declared in\n+      --  the current block (pathological but possible).\n+\n+      if Current_Scope /= Task_Nam then\n+         declare\n+            E1 : Entity_Id;\n+\n+         begin\n+            E1 := First_Entity (Current_Scope);\n+\n+            while Present (E1) loop\n+\n+               if Ekind (E1) = E_Procedure\n+                 and then Type_Conformant (E1, Entry_Nam)\n+               then\n+                  Error_Msg_N (\"entry name is not visible\", N);\n+               end if;\n+\n+               Next_Entity (E1);\n+            end loop;\n+         end;\n+      end if;\n+\n+      Set_Convention (Ityp, Convention (Entry_Nam));\n+      Check_Fully_Conformant (Ityp, Entry_Nam, N);\n+\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         exit when Task_Nam = Scope_Stack.Table (J).Entity;\n+\n+         if Entry_Nam = Scope_Stack.Table (J).Entity then\n+            Error_Msg_N (\"duplicate accept statement for same entry\", N);\n+         end if;\n+\n+      end loop;\n+\n+      declare\n+         P : Node_Id := N;\n+      begin\n+         loop\n+            P := Parent (P);\n+            case Nkind (P) is\n+               when N_Task_Body | N_Compilation_Unit =>\n+                  exit;\n+               when N_Asynchronous_Select =>\n+                  Error_Msg_N (\"accept statements are not allowed within\" &\n+                               \" an asynchronous select inner\" &\n+                               \" to the enclosing task body\", N);\n+                  exit;\n+               when others =>\n+                  null;\n+            end case;\n+         end loop;\n+      end;\n+\n+      if Ekind (E) = E_Entry_Family then\n+         if No (Index) then\n+            Error_Msg_N (\"missing entry index in accept for entry family\", N);\n+         else\n+            Analyze_And_Resolve (Index, Entry_Index_Type (E));\n+            Apply_Range_Check (Index, Actual_Index_Type (E));\n+         end if;\n+\n+      elsif Present (Index) then\n+         Error_Msg_N (\"invalid entry index in accept for simple entry\", N);\n+      end if;\n+\n+      --  If statements are present, they must be analyzed in the context\n+      --  of the entry, so that references to formals are correctly resolved.\n+      --  We also have to add the declarations that are required by the\n+      --  expansion of the accept statement in this case if expansion active.\n+\n+      --  In the case of a select alternative of a selective accept,\n+      --  the expander references the address declaration even if there\n+      --  is no statement list.\n+\n+      Exp_Ch9.Expand_Accept_Declarations (N, Entry_Nam);\n+\n+      --  If label declarations present, analyze them. They are declared\n+      --  in the enclosing task, but their enclosing scope is the entry itself,\n+      --  so that goto's to the label are recognized as local to the accept.\n+\n+      if Present (Declarations (N)) then\n+\n+         declare\n+            Decl : Node_Id;\n+            Id   : Entity_Id;\n+\n+         begin\n+            Decl := First (Declarations (N));\n+\n+            while Present (Decl) loop\n+               Analyze (Decl);\n+\n+               pragma Assert\n+                 (Nkind (Decl) = N_Implicit_Label_Declaration);\n+\n+               Id := Defining_Identifier (Decl);\n+               Set_Enclosing_Scope (Id, Entry_Nam);\n+               Next (Decl);\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Set Not_Source_Assigned flag on all entry formals\n+\n+      E := First_Entity (Entry_Nam);\n+\n+      while Present (E) loop\n+         Set_Not_Source_Assigned (E, True);\n+         Next_Entity (E);\n+      end loop;\n+\n+      --  Analyze statements if present\n+\n+      if Present (Stats) then\n+         New_Scope (Entry_Nam);\n+         Install_Declarations (Entry_Nam);\n+\n+         Set_Actual_Subtypes (N, Current_Scope);\n+         Analyze (Stats);\n+         Process_End_Label (Handled_Statement_Sequence (N), 't');\n+         End_Scope;\n+      end if;\n+\n+      --  Some warning checks\n+\n+      Check_Potentially_Blocking_Operation (N);\n+      Check_References (Entry_Nam, N);\n+      Set_Entry_Accepted (Entry_Nam);\n+\n+   end Analyze_Accept_Statement;\n+\n+   ---------------------------------\n+   -- Analyze_Asynchronous_Select --\n+   ---------------------------------\n+\n+   procedure Analyze_Asynchronous_Select (N : Node_Id) is\n+   begin\n+      Tasking_Used := True;\n+      Check_Restriction (Max_Asynchronous_Select_Nesting, N);\n+      Check_Restriction (No_Select_Statements, N);\n+\n+      Analyze (Triggering_Alternative (N));\n+\n+      Analyze_Statements (Statements (Abortable_Part (N)));\n+   end Analyze_Asynchronous_Select;\n+\n+   ------------------------------------\n+   -- Analyze_Conditional_Entry_Call --\n+   ------------------------------------\n+\n+   procedure Analyze_Conditional_Entry_Call (N : Node_Id) is\n+   begin\n+      Check_Restriction (No_Select_Statements, N);\n+      Tasking_Used := True;\n+      Analyze (Entry_Call_Alternative (N));\n+      Analyze_Statements (Else_Statements (N));\n+   end Analyze_Conditional_Entry_Call;\n+\n+   --------------------------------\n+   -- Analyze_Delay_Alternative  --\n+   --------------------------------\n+\n+   procedure Analyze_Delay_Alternative (N : Node_Id) is\n+      Expr : Node_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+      Check_Restriction (No_Delay, N);\n+\n+      if Present (Pragmas_Before (N)) then\n+         Analyze_List (Pragmas_Before (N));\n+      end if;\n+\n+      if Nkind (Parent (N)) = N_Selective_Accept\n+        or else Nkind (Parent (N)) = N_Timed_Entry_Call\n+      then\n+         Expr := Expression (Delay_Statement (N));\n+\n+         --  defer full analysis until the statement is expanded, to insure\n+         --  that generated code does not move past the guard. The delay\n+         --  expression is only evaluated if the guard is open.\n+\n+         if Nkind (Delay_Statement (N)) = N_Delay_Relative_Statement then\n+            Pre_Analyze_And_Resolve (Expr, Standard_Duration);\n+\n+         else\n+            Pre_Analyze_And_Resolve (Expr);\n+         end if;\n+\n+         Check_Restriction (No_Fixed_Point, Expr);\n+      else\n+         Analyze (Delay_Statement (N));\n+      end if;\n+\n+      if Present (Condition (N)) then\n+         Analyze_And_Resolve (Condition (N), Any_Boolean);\n+      end if;\n+\n+      if Is_Non_Empty_List (Statements (N)) then\n+         Analyze_Statements (Statements (N));\n+      end if;\n+   end Analyze_Delay_Alternative;\n+\n+   ----------------------------\n+   -- Analyze_Delay_Relative --\n+   ----------------------------\n+\n+   procedure Analyze_Delay_Relative (N : Node_Id) is\n+      E : constant Node_Id := Expression (N);\n+\n+   begin\n+      Check_Restriction (No_Relative_Delay, N);\n+      Tasking_Used := True;\n+      Check_Restriction (No_Delay, N);\n+      Check_Potentially_Blocking_Operation (N);\n+      Analyze_And_Resolve (E, Standard_Duration);\n+      Check_Restriction (No_Fixed_Point, E);\n+   end Analyze_Delay_Relative;\n+\n+   -------------------------\n+   -- Analyze_Delay_Until --\n+   -------------------------\n+\n+   procedure Analyze_Delay_Until (N : Node_Id) is\n+      E : constant Node_Id := Expression (N);\n+\n+   begin\n+      Tasking_Used := True;\n+      Check_Restriction (No_Delay, N);\n+      Check_Potentially_Blocking_Operation (N);\n+      Analyze (E);\n+\n+      if not Is_RTE (Base_Type (Etype (E)), RO_CA_Time) and then\n+         not Is_RTE (Base_Type (Etype (E)), RO_RT_Time)\n+      then\n+         Error_Msg_N (\"expect Time types for `DELAY UNTIL`\", E);\n+      end if;\n+   end Analyze_Delay_Until;\n+\n+   ------------------------\n+   -- Analyze_Entry_Body --\n+   ------------------------\n+\n+   procedure Analyze_Entry_Body (N : Node_Id) is\n+      Id         : constant Entity_Id := Defining_Identifier (N);\n+      Decls      : constant List_Id   := Declarations (N);\n+      Stats      : constant Node_Id   := Handled_Statement_Sequence (N);\n+      Formals    : constant Node_Id   := Entry_Body_Formal_Part (N);\n+      P_Type     : constant Entity_Id := Current_Scope;\n+      Entry_Name : Entity_Id;\n+      E          : Entity_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+\n+      --  Entry_Name is initialized to Any_Id. It should get reset to the\n+      --  matching entry entity. An error is signalled if it is not reset\n+\n+      Entry_Name := Any_Id;\n+\n+      Analyze (Formals);\n+\n+      if Present (Entry_Index_Specification (Formals)) then\n+         Set_Ekind (Id, E_Entry_Family);\n+      else\n+         Set_Ekind (Id, E_Entry);\n+      end if;\n+\n+      Set_Scope          (Id, Current_Scope);\n+      Set_Etype          (Id, Standard_Void_Type);\n+      Set_Accept_Address (Id, New_Elmt_List);\n+\n+      E := First_Entity (P_Type);\n+      while Present (E) loop\n+         if Chars (E) = Chars (Id)\n+           and then (Ekind (E) = Ekind (Id))\n+           and then Type_Conformant (Id, E)\n+         then\n+            Entry_Name := E;\n+            Set_Convention (Id, Convention (E));\n+            Check_Fully_Conformant (Id, E, N);\n+            exit;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      if Entry_Name = Any_Id then\n+         Error_Msg_N (\"no entry declaration matches entry body\",  N);\n+         return;\n+\n+      elsif Has_Completion (Entry_Name) then\n+         Error_Msg_N (\"duplicate entry body\", N);\n+         return;\n+\n+      else\n+         Set_Has_Completion (Entry_Name);\n+         Generate_Reference (Entry_Name, Id, 'b');\n+         Style.Check_Identifier (Id, Entry_Name);\n+      end if;\n+\n+      Exp_Ch9.Expand_Entry_Barrier (N, Entry_Name);\n+      New_Scope (Entry_Name);\n+\n+      Exp_Ch9.Expand_Entry_Body_Declarations (N);\n+      Install_Declarations (Entry_Name);\n+      Set_Actual_Subtypes (N, Current_Scope);\n+\n+      --  The entity for the protected subprogram corresponding to the entry\n+      --  has been created. We retain the name of this entity in the entry\n+      --  body, for use when the corresponding subprogram body is created.\n+      --  Note that entry bodies have to corresponding_spec, and there is no\n+      --  easy link back in the tree between the entry body and the entity for\n+      --  the entry itself.\n+\n+      Set_Protected_Body_Subprogram (Id,\n+        Protected_Body_Subprogram (Entry_Name));\n+\n+      if Present (Decls) then\n+         Analyze_Declarations (Decls);\n+      end if;\n+\n+      if Present (Stats) then\n+         Analyze (Stats);\n+      end if;\n+\n+      Check_References (Entry_Name);\n+      Process_End_Label (Handled_Statement_Sequence (N), 't');\n+      End_Scope;\n+\n+      --  If this is an entry family, remove the loop created to provide\n+      --  a scope for the entry index.\n+\n+      if Ekind (Id) = E_Entry_Family\n+        and then Present (Entry_Index_Specification (Formals))\n+      then\n+         End_Scope;\n+      end if;\n+\n+   end Analyze_Entry_Body;\n+\n+   ------------------------------------\n+   -- Analyze_Entry_Body_Formal_Part --\n+   ------------------------------------\n+\n+   procedure Analyze_Entry_Body_Formal_Part (N : Node_Id) is\n+      Id      : constant Entity_Id := Defining_Identifier (Parent (N));\n+      Index   : constant Node_Id   := Entry_Index_Specification (N);\n+      Formals : constant List_Id   := Parameter_Specifications (N);\n+\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Index) then\n+         Analyze (Index);\n+      end if;\n+\n+      if Present (Formals) then\n+         Set_Scope (Id, Current_Scope);\n+         New_Scope (Id);\n+         Process_Formals (Id, Formals, Parent (N));\n+         End_Scope;\n+      end if;\n+\n+   end Analyze_Entry_Body_Formal_Part;\n+\n+   ------------------------------------\n+   -- Analyze_Entry_Call_Alternative --\n+   ------------------------------------\n+\n+   procedure Analyze_Entry_Call_Alternative (N : Node_Id) is\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Pragmas_Before (N)) then\n+         Analyze_List (Pragmas_Before (N));\n+      end if;\n+\n+      Analyze (Entry_Call_Statement (N));\n+\n+      if Is_Non_Empty_List (Statements (N)) then\n+         Analyze_Statements (Statements (N));\n+      end if;\n+   end Analyze_Entry_Call_Alternative;\n+\n+   -------------------------------\n+   -- Analyze_Entry_Declaration --\n+   -------------------------------\n+\n+   procedure Analyze_Entry_Declaration (N : Node_Id) is\n+      Id      : Entity_Id := Defining_Identifier (N);\n+      D_Sdef  : Node_Id   := Discrete_Subtype_Definition (N);\n+      Formals : List_Id   := Parameter_Specifications (N);\n+\n+   begin\n+      Generate_Definition (Id);\n+      Tasking_Used := True;\n+\n+      if No (D_Sdef) then\n+         Set_Ekind (Id, E_Entry);\n+      else\n+         Enter_Name (Id);\n+         Set_Ekind (Id, E_Entry_Family);\n+         Analyze (D_Sdef);\n+         Make_Index (D_Sdef, N, Id);\n+      end if;\n+\n+      Set_Etype          (Id, Standard_Void_Type);\n+      Set_Convention     (Id, Convention_Entry);\n+      Set_Accept_Address (Id, New_Elmt_List);\n+\n+      if Present (Formals) then\n+         Set_Scope (Id, Current_Scope);\n+         New_Scope (Id);\n+         Process_Formals (Id, Formals, N);\n+         Create_Extra_Formals (Id);\n+         End_Scope;\n+      end if;\n+\n+      if Ekind (Id) = E_Entry then\n+         New_Overloaded_Entity (Id);\n+      end if;\n+\n+   end Analyze_Entry_Declaration;\n+\n+   ---------------------------------------\n+   -- Analyze_Entry_Index_Specification --\n+   ---------------------------------------\n+\n+   --  The defining_Identifier of the entry index specification is local\n+   --  to the entry body, but must be available in the entry barrier,\n+   --  which is evaluated outside of the entry body. The index is eventually\n+   --  renamed as a run-time object, so is visibility is strictly a front-end\n+   --  concern. In order to make it available to the barrier, we create\n+   --  an additional scope, as for a loop, whose only declaration is the\n+   --  index name. This loop is not attached to the tree and does not appear\n+   --  as an entity local to the protected type, so its existence need only\n+   --  be knwown to routines that process entry families.\n+\n+   procedure Analyze_Entry_Index_Specification (N : Node_Id) is\n+      Iden    : constant Node_Id := Defining_Identifier (N);\n+      Def     : constant Node_Id := Discrete_Subtype_Definition (N);\n+      Loop_Id : Entity_Id :=\n+                  Make_Defining_Identifier (Sloc (N),\n+                    Chars => New_Internal_Name ('L'));\n+\n+   begin\n+      Tasking_Used := True;\n+      Analyze (Def);\n+      Make_Index (Def, N);\n+      Set_Ekind (Loop_Id, E_Loop);\n+      Set_Scope (Loop_Id, Current_Scope);\n+      New_Scope (Loop_Id);\n+      Enter_Name (Iden);\n+      Set_Ekind (Iden, E_Entry_Index_Parameter);\n+      Set_Etype (Iden, Etype (Def));\n+   end Analyze_Entry_Index_Specification;\n+\n+   ----------------------------\n+   -- Analyze_Protected_Body --\n+   ----------------------------\n+\n+   procedure Analyze_Protected_Body (N : Node_Id) is\n+      Body_Id   : constant Entity_Id := Defining_Identifier (N);\n+      Spec_Id   : Entity_Id;\n+      Last_E    : Entity_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+      Set_Ekind (Body_Id, E_Protected_Body);\n+      Spec_Id := Find_Concurrent_Spec (Body_Id);\n+\n+      if Present (Spec_Id)\n+        and then Ekind (Spec_Id) = E_Protected_Type\n+      then\n+         null;\n+\n+      elsif Present (Spec_Id)\n+        and then Ekind (Etype (Spec_Id)) = E_Protected_Type\n+        and then not Comes_From_Source (Etype (Spec_Id))\n+      then\n+         null;\n+\n+      else\n+         Error_Msg_N (\"missing specification for protected body\", Body_Id);\n+         return;\n+      end if;\n+\n+      Generate_Reference (Spec_Id, Body_Id, 'b');\n+      Style.Check_Identifier (Body_Id, Spec_Id);\n+\n+      --  The declarations are always attached to the type\n+\n+      if Ekind (Spec_Id) /= E_Protected_Type then\n+         Spec_Id := Etype (Spec_Id);\n+      end if;\n+\n+      New_Scope (Spec_Id);\n+      Set_Corresponding_Spec (N, Spec_Id);\n+      Set_Corresponding_Body (Parent (Spec_Id), Body_Id);\n+      Set_Has_Completion (Spec_Id);\n+      Install_Declarations (Spec_Id);\n+\n+      Exp_Ch9.Expand_Protected_Body_Declarations (N, Spec_Id);\n+\n+      Last_E := Last_Entity (Spec_Id);\n+\n+      Analyze_Declarations (Declarations (N));\n+\n+      --  For visibility purposes, all entities in the body are private.\n+      --  Set First_Private_Entity accordingly, if there was no private\n+      --  part in the protected declaration.\n+\n+      if No (First_Private_Entity (Spec_Id)) then\n+         if Present (Last_E) then\n+            Set_First_Private_Entity (Spec_Id, Next_Entity (Last_E));\n+         else\n+            Set_First_Private_Entity (Spec_Id, First_Entity (Spec_Id));\n+         end if;\n+      end if;\n+\n+      Check_Completion (Body_Id);\n+      Check_References (Spec_Id);\n+      Process_End_Label (N, 't');\n+      End_Scope;\n+   end Analyze_Protected_Body;\n+\n+   ----------------------------------\n+   -- Analyze_Protected_Definition --\n+   ----------------------------------\n+\n+   procedure Analyze_Protected_Definition (N : Node_Id) is\n+      E : Entity_Id;\n+      L : Entity_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+      Analyze_Declarations (Visible_Declarations (N));\n+\n+      if Present (Private_Declarations (N))\n+        and then not Is_Empty_List (Private_Declarations (N))\n+      then\n+         L := Last_Entity (Current_Scope);\n+         Analyze_Declarations (Private_Declarations (N));\n+\n+         if Present (L) then\n+            Set_First_Private_Entity (Current_Scope, Next_Entity (L));\n+\n+         else\n+            Set_First_Private_Entity (Current_Scope,\n+              First_Entity (Current_Scope));\n+         end if;\n+      end if;\n+\n+      E := First_Entity (Current_Scope);\n+\n+      while Present (E) loop\n+\n+         if Ekind (E) = E_Function\n+           or else Ekind (E) = E_Procedure\n+         then\n+            Set_Convention (E, Convention_Protected);\n+\n+         elsif Is_Task_Type (Etype (E)) then\n+            Set_Has_Task (Current_Scope);\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      Check_Max_Entries (N, Max_Protected_Entries);\n+      Process_End_Label (N, 'e');\n+   end Analyze_Protected_Definition;\n+\n+   ----------------------------\n+   -- Analyze_Protected_Type --\n+   ----------------------------\n+\n+   procedure Analyze_Protected_Type (N : Node_Id) is\n+      E      : Entity_Id;\n+      T      : Entity_Id;\n+      Def_Id : constant Entity_Id := Defining_Identifier (N);\n+\n+   begin\n+      Tasking_Used := True;\n+      Check_Restriction (No_Protected_Types, N);\n+\n+      T := Find_Type_Name (N);\n+\n+      if Ekind (T) = E_Incomplete_Type then\n+         T := Full_View (T);\n+      end if;\n+\n+      Set_Ekind              (T, E_Protected_Type);\n+      Init_Size_Align        (T);\n+      Set_Etype              (T, T);\n+      Set_Is_First_Subtype   (T, True);\n+      Set_Has_Delayed_Freeze (T, True);\n+      Set_Girder_Constraint  (T, No_Elist);\n+      New_Scope (T);\n+\n+      if Present (Discriminant_Specifications (N)) then\n+         if Has_Discriminants (T) then\n+\n+            --  Install discriminants. Also, verify conformance of\n+            --  discriminants of previous and current view.  ???\n+\n+            Install_Declarations (T);\n+         else\n+            Process_Discriminants (N);\n+         end if;\n+      end if;\n+\n+      Analyze (Protected_Definition (N));\n+\n+      --  Protected types with entries are controlled (because of the\n+      --  Protection component if nothing else), same for any protected type\n+      --  with interrupt handlers. Note that we need to analyze the protected\n+      --  definition to set Has_Entries and such.\n+\n+      if (Abort_Allowed or else Restrictions (No_Entry_Queue) = False\n+           or else Number_Entries (T) > 1)\n+        and then\n+          (Has_Entries (T)\n+            or else Has_Interrupt_Handler (T)\n+            or else Has_Attach_Handler (T))\n+      then\n+         Set_Has_Controlled_Component (T, True);\n+      end if;\n+\n+      --  The Ekind of components is E_Void during analysis to detect\n+      --  illegal uses. Now it can be set correctly.\n+\n+      E := First_Entity (Current_Scope);\n+\n+      while Present (E) loop\n+         if Ekind (E) = E_Void then\n+            Set_Ekind (E, E_Component);\n+            Init_Component_Location (E);\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      End_Scope;\n+\n+      if T /= Def_Id\n+        and then Is_Private_Type (Def_Id)\n+        and then Has_Discriminants (Def_Id)\n+        and then Expander_Active\n+      then\n+         Exp_Ch9.Expand_N_Protected_Type_Declaration (N);\n+         Process_Full_View (N, T, Def_Id);\n+      end if;\n+\n+   end Analyze_Protected_Type;\n+\n+   ---------------------\n+   -- Analyze_Requeue --\n+   ---------------------\n+\n+   procedure Analyze_Requeue (N : Node_Id) is\n+      Entry_Name : Node_Id := Name (N);\n+      Entry_Id   : Entity_Id;\n+      Found      : Boolean;\n+      I          : Interp_Index;\n+      It         : Interp;\n+      Enclosing  : Entity_Id;\n+      Target_Obj : Node_Id := Empty;\n+      Req_Scope  : Entity_Id;\n+      Outer_Ent  : Entity_Id;\n+\n+   begin\n+      Check_Restriction (No_Requeue, N);\n+      Check_Unreachable_Code (N);\n+      Tasking_Used := True;\n+\n+      Enclosing := Empty;\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Enclosing := Scope_Stack.Table (J).Entity;\n+         exit when Is_Entry (Enclosing);\n+\n+         if Ekind (Enclosing) /= E_Block\n+           and then Ekind (Enclosing) /= E_Loop\n+         then\n+            Error_Msg_N (\"requeue must appear within accept or entry body\", N);\n+            return;\n+         end if;\n+      end loop;\n+\n+      Analyze (Entry_Name);\n+\n+      if Etype (Entry_Name) = Any_Type then\n+         return;\n+      end if;\n+\n+      if Nkind (Entry_Name) = N_Selected_Component then\n+         Target_Obj := Prefix (Entry_Name);\n+         Entry_Name := Selector_Name (Entry_Name);\n+      end if;\n+\n+      --  If an explicit target object is given then we have to check\n+      --  the restrictions of 9.5.4(6).\n+\n+      if Present (Target_Obj) then\n+         --  Locate containing concurrent unit and determine\n+         --  enclosing entry body or outermost enclosing accept\n+         --  statement within the unit.\n+\n+         Outer_Ent := Empty;\n+         for S in reverse 0 .. Scope_Stack.Last loop\n+            Req_Scope := Scope_Stack.Table (S).Entity;\n+\n+            exit when Ekind (Req_Scope) in Task_Kind\n+              or else Ekind (Req_Scope) in Protected_Kind;\n+\n+            if Is_Entry (Req_Scope) then\n+               Outer_Ent := Req_Scope;\n+            end if;\n+         end loop;\n+\n+         pragma Assert (Present (Outer_Ent));\n+\n+         --  Check that the accessibility level of the target object\n+         --  is not greater or equal to the outermost enclosing accept\n+         --  statement (or entry body) unless it is a parameter of the\n+         --  innermost enclosing accept statement (or entry body).\n+\n+         if Object_Access_Level (Target_Obj) >= Scope_Depth (Outer_Ent)\n+           and then\n+             (not Is_Entity_Name (Target_Obj)\n+               or else Ekind (Entity (Target_Obj)) not in Formal_Kind\n+               or else Enclosing /= Scope (Entity (Target_Obj)))\n+         then\n+            Error_Msg_N\n+              (\"target object has invalid level for requeue\", Target_Obj);\n+         end if;\n+      end if;\n+\n+      --  Overloaded case, find right interpretation\n+\n+      if Is_Overloaded (Entry_Name) then\n+         Get_First_Interp (Entry_Name, I, It);\n+         Found := False;\n+         Entry_Id := Empty;\n+\n+         while Present (It.Nam) loop\n+\n+            if No (First_Formal (It.Nam))\n+              or else Subtype_Conformant (Enclosing, It.Nam)\n+            then\n+               if not Found then\n+                  Found := True;\n+                  Entry_Id := It.Nam;\n+               else\n+                  Error_Msg_N (\"ambiguous entry name in requeue\", N);\n+                  return;\n+               end if;\n+            end if;\n+\n+            Get_Next_Interp (I, It);\n+         end loop;\n+\n+         if not Found then\n+            Error_Msg_N (\"no entry matches context\",  N);\n+            return;\n+         else\n+            Set_Entity (Entry_Name, Entry_Id);\n+         end if;\n+\n+      --  Non-overloaded cases\n+\n+      --  For the case of a reference to an element of an entry family,\n+      --  the Entry_Name is an indexed component.\n+\n+      elsif Nkind (Entry_Name) = N_Indexed_Component then\n+\n+         --  Requeue to an entry out of the body\n+\n+         if Nkind (Prefix (Entry_Name)) = N_Selected_Component then\n+            Entry_Id := Entity (Selector_Name (Prefix (Entry_Name)));\n+\n+         --  Requeue from within the body itself\n+\n+         elsif Nkind (Prefix (Entry_Name)) = N_Identifier then\n+            Entry_Id := Entity (Prefix (Entry_Name));\n+\n+         else\n+            Error_Msg_N (\"invalid entry_name specified\",  N);\n+            return;\n+         end if;\n+\n+      --  If we had a requeue of the form REQUEUE A (B), then the parser\n+      --  accepted it (because it could have been a requeue on an entry\n+      --  index. If A turns out not to be an entry family, then the analysis\n+      --  of A (B) turned it into a function call.\n+\n+      elsif Nkind (Entry_Name) = N_Function_Call then\n+         Error_Msg_N\n+           (\"arguments not allowed in requeue statement\",\n+            First (Parameter_Associations (Entry_Name)));\n+         return;\n+\n+      --  Normal case of no entry family, no argument\n+\n+      else\n+         Entry_Id := Entity (Entry_Name);\n+      end if;\n+\n+      --  Resolve entry, and check that it is subtype conformant with the\n+      --  enclosing construct if this construct has formals (RM 9.5.4(5)).\n+\n+      if not Is_Entry (Entry_Id) then\n+         Error_Msg_N (\"expect entry name in requeue statement\", Name (N));\n+      elsif Ekind (Entry_Id) = E_Entry_Family\n+\n+        and then Nkind (Entry_Name) /= N_Indexed_Component\n+      then\n+         Error_Msg_N (\"missing index for entry family component\", Name (N));\n+\n+      else\n+         Resolve_Entry (Name (N));\n+\n+         if Present (First_Formal (Entry_Id)) then\n+            Check_Subtype_Conformant (Enclosing, Entry_Id, Name (N));\n+\n+            --  Mark any output parameters as assigned\n+\n+            declare\n+               Ent : Entity_Id := First_Formal (Enclosing);\n+\n+            begin\n+               while Present (Ent) loop\n+                  if Ekind (Ent) = E_Out_Parameter then\n+                     Set_Not_Source_Assigned (Ent, False);\n+                  end if;\n+\n+                  Next_Formal (Ent);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+\n+   end Analyze_Requeue;\n+\n+   ------------------------------\n+   -- Analyze_Selective_Accept --\n+   ------------------------------\n+\n+   procedure Analyze_Selective_Accept (N : Node_Id) is\n+      Alts : constant List_Id := Select_Alternatives (N);\n+      Alt  : Node_Id;\n+\n+      Accept_Present    : Boolean := False;\n+      Terminate_Present : Boolean := False;\n+      Delay_Present     : Boolean := False;\n+      Relative_Present  : Boolean := False;\n+      Alt_Count         : Uint    := Uint_0;\n+\n+   begin\n+      Check_Restriction (No_Select_Statements, N);\n+      Tasking_Used := True;\n+\n+      Alt := First (Alts);\n+      while Present (Alt) loop\n+         Alt_Count := Alt_Count + 1;\n+         Analyze (Alt);\n+\n+         if Nkind (Alt) = N_Delay_Alternative then\n+            if Delay_Present then\n+\n+               if (Relative_Present /=\n+                 (Nkind (Delay_Statement (Alt)) = N_Delay_Relative_Statement))\n+               then\n+                  Error_Msg_N\n+                    (\"delay_until and delay_relative alternatives \", Alt);\n+                  Error_Msg_N\n+                    (\"\\cannot appear in the same selective_wait\", Alt);\n+               end if;\n+\n+            else\n+               Delay_Present := True;\n+               Relative_Present :=\n+                 Nkind (Delay_Statement (Alt)) = N_Delay_Relative_Statement;\n+            end if;\n+\n+         elsif Nkind (Alt) = N_Terminate_Alternative then\n+            if Terminate_Present then\n+               Error_Msg_N (\"Only one terminate alternative allowed\", N);\n+            else\n+               Terminate_Present := True;\n+               Check_Restriction (No_Terminate_Alternatives, N);\n+            end if;\n+\n+         elsif Nkind (Alt) = N_Accept_Alternative then\n+            Accept_Present := True;\n+\n+            --  Check for duplicate accept\n+\n+            declare\n+               Alt1 : Node_Id;\n+               Stm  : constant Node_Id := Accept_Statement (Alt);\n+               EDN  : constant Node_Id := Entry_Direct_Name (Stm);\n+               Ent  : Entity_Id;\n+\n+            begin\n+               if Nkind (EDN) = N_Identifier\n+                 and then No (Condition (Alt))\n+                 and then Present (Entity (EDN)) -- defend against junk\n+                 and then Ekind (Entity (EDN)) = E_Entry\n+               then\n+                  Ent := Entity (EDN);\n+\n+                  Alt1 := First (Alts);\n+                  while Alt1 /= Alt loop\n+                     if Nkind (Alt1) = N_Accept_Alternative\n+                       and then No (Condition (Alt1))\n+                     then\n+                        declare\n+                           Stm1 : constant Node_Id := Accept_Statement (Alt1);\n+                           EDN1 : constant Node_Id := Entry_Direct_Name (Stm1);\n+\n+                        begin\n+                           if Nkind (EDN1) = N_Identifier then\n+                              if Entity (EDN1) = Ent then\n+                                 Error_Msg_Sloc := Sloc (Stm1);\n+                                 Error_Msg_N\n+                                   (\"?accept duplicates one on line#\", Stm);\n+                                 exit;\n+                              end if;\n+                           end if;\n+                        end;\n+                     end if;\n+\n+                     Next (Alt1);\n+                  end loop;\n+               end if;\n+            end;\n+         end if;\n+\n+         Next (Alt);\n+      end loop;\n+\n+      Check_Restriction (Max_Select_Alternatives, Alt_Count, N);\n+      Check_Potentially_Blocking_Operation (N);\n+\n+      if Terminate_Present and Delay_Present then\n+         Error_Msg_N (\"at most one of terminate or delay alternative\", N);\n+\n+      elsif not Accept_Present then\n+         Error_Msg_N\n+           (\"select must contain at least one accept alternative\", N);\n+      end if;\n+\n+      if Present (Else_Statements (N)) then\n+         if Terminate_Present or Delay_Present then\n+            Error_Msg_N (\"else part not allowed with other alternatives\", N);\n+         end if;\n+\n+         Analyze_Statements (Else_Statements (N));\n+      end if;\n+   end Analyze_Selective_Accept;\n+\n+   ------------------------------\n+   -- Analyze_Single_Protected --\n+   ------------------------------\n+\n+   procedure Analyze_Single_Protected (N : Node_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Id     : constant Node_Id    := Defining_Identifier (N);\n+      T      : Entity_Id;\n+      T_Decl : Node_Id;\n+      O_Decl : Node_Id;\n+      O_Name : constant Entity_Id := New_Copy (Id);\n+\n+   begin\n+      Generate_Definition (Id);\n+      Tasking_Used := True;\n+\n+      --  The node is rewritten as a protected type declaration,\n+      --  in exact analogy with what is done with single tasks.\n+\n+      T :=\n+        Make_Defining_Identifier (Sloc (Id),\n+          New_External_Name (Chars (Id), 'T'));\n+\n+      T_Decl :=\n+        Make_Protected_Type_Declaration (Loc,\n+         Defining_Identifier => T,\n+         Protected_Definition => Relocate_Node (Protected_Definition (N)));\n+\n+      O_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => O_Name,\n+          Object_Definition   => Make_Identifier (Loc,  Chars (T)));\n+\n+      Rewrite (N, T_Decl);\n+      Insert_After (N, O_Decl);\n+      Mark_Rewrite_Insertion (O_Decl);\n+\n+      --  Enter names of type and object before analysis, because the name\n+      --  of the object may be used in its own body.\n+\n+      Enter_Name (T);\n+      Set_Ekind (T, E_Protected_Type);\n+      Set_Etype (T, T);\n+\n+      Enter_Name (O_Name);\n+      Set_Ekind (O_Name, E_Variable);\n+      Set_Etype (O_Name, T);\n+\n+      --  Instead of calling Analyze on the new node,  call directly\n+      --  the proper analysis procedure. Otherwise the node would be\n+      --  expanded twice, with disastrous result.\n+\n+      Analyze_Protected_Type (N);\n+\n+   end Analyze_Single_Protected;\n+\n+   -------------------------\n+   -- Analyze_Single_Task --\n+   -------------------------\n+\n+   procedure Analyze_Single_Task (N : Node_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Id     : constant Node_Id    := Defining_Identifier (N);\n+      T      : Entity_Id;\n+      T_Decl : Node_Id;\n+      O_Decl : Node_Id;\n+      O_Name : constant Entity_Id := New_Copy (Id);\n+\n+   begin\n+      Generate_Definition (Id);\n+      Tasking_Used := True;\n+\n+      --  The node is rewritten as a task type declaration,  followed\n+      --  by an object declaration of that anonymous task type.\n+\n+      T :=\n+        Make_Defining_Identifier (Sloc (Id),\n+          New_External_Name (Chars (Id), Suffix => \"TK\"));\n+\n+      T_Decl :=\n+        Make_Task_Type_Declaration (Loc,\n+          Defining_Identifier => T,\n+          Task_Definition     => Relocate_Node (Task_Definition (N)));\n+\n+      O_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => O_Name,\n+          Object_Definition   => Make_Identifier (Loc, Chars (T)));\n+\n+      Rewrite (N, T_Decl);\n+      Insert_After (N, O_Decl);\n+      Mark_Rewrite_Insertion (O_Decl);\n+\n+      --  Enter names of type and object before analysis, because the name\n+      --  of the object may be used in its own body.\n+\n+      Enter_Name (T);\n+      Set_Ekind (T, E_Task_Type);\n+      Set_Etype (T, T);\n+\n+      Enter_Name (O_Name);\n+      Set_Ekind (O_Name, E_Variable);\n+      Set_Etype (O_Name, T);\n+\n+      --  Instead of calling Analyze on the new node,  call directly\n+      --  the proper analysis procedure. Otherwise the node would be\n+      --  expanded twice, with disastrous result.\n+\n+      Analyze_Task_Type (N);\n+\n+   end Analyze_Single_Task;\n+\n+   -----------------------\n+   -- Analyze_Task_Body --\n+   -----------------------\n+\n+   procedure Analyze_Task_Body (N : Node_Id) is\n+      Body_Id : constant Entity_Id := Defining_Identifier (N);\n+      Spec_Id : Entity_Id;\n+      Last_E  : Entity_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+      Set_Ekind (Body_Id, E_Task_Body);\n+      Set_Scope (Body_Id, Current_Scope);\n+      Spec_Id := Find_Concurrent_Spec (Body_Id);\n+\n+      --  The spec is either a task type declaration, or a single task\n+      --  declaration for which we have created an anonymous type.\n+\n+      if Present (Spec_Id)\n+        and then Ekind (Spec_Id) = E_Task_Type\n+      then\n+         null;\n+\n+      elsif Present (Spec_Id)\n+        and then Ekind (Etype (Spec_Id)) = E_Task_Type\n+        and then not Comes_From_Source (Etype (Spec_Id))\n+      then\n+         null;\n+\n+      else\n+         Error_Msg_N (\"missing specification for task body\", Body_Id);\n+         return;\n+      end if;\n+\n+      Generate_Reference (Spec_Id, Body_Id, 'b');\n+      Style.Check_Identifier (Body_Id, Spec_Id);\n+\n+      --  Deal with case of body of single task (anonymous type was created)\n+\n+      if Ekind (Spec_Id) = E_Variable then\n+         Spec_Id := Etype (Spec_Id);\n+      end if;\n+\n+      New_Scope (Spec_Id);\n+      Set_Corresponding_Spec (N, Spec_Id);\n+      Set_Corresponding_Body (Parent (Spec_Id), Body_Id);\n+      Set_Has_Completion (Spec_Id);\n+      Install_Declarations (Spec_Id);\n+      Last_E := Last_Entity (Spec_Id);\n+\n+      Analyze_Declarations (Declarations (N));\n+\n+      --  For visibility purposes, all entities in the body are private.\n+      --  Set First_Private_Entity accordingly, if there was no private\n+      --  part in the protected declaration.\n+\n+      if No (First_Private_Entity (Spec_Id)) then\n+         if Present (Last_E) then\n+            Set_First_Private_Entity (Spec_Id, Next_Entity (Last_E));\n+         else\n+            Set_First_Private_Entity (Spec_Id, First_Entity (Spec_Id));\n+         end if;\n+      end if;\n+\n+      Analyze (Handled_Statement_Sequence (N));\n+      Check_Completion (Body_Id);\n+      Check_References (Body_Id);\n+\n+      --  Check for entries with no corresponding accept\n+\n+      declare\n+         Ent : Entity_Id;\n+\n+      begin\n+         Ent := First_Entity (Spec_Id);\n+\n+         while Present (Ent) loop\n+            if Is_Entry (Ent)\n+              and then not Entry_Accepted (Ent)\n+              and then Comes_From_Source (Ent)\n+            then\n+               Error_Msg_NE (\"no accept for entry &?\", N, Ent);\n+            end if;\n+\n+            Next_Entity (Ent);\n+         end loop;\n+      end;\n+\n+      Process_End_Label (Handled_Statement_Sequence (N), 't');\n+      End_Scope;\n+   end Analyze_Task_Body;\n+\n+   -----------------------------\n+   -- Analyze_Task_Definition --\n+   -----------------------------\n+\n+   procedure Analyze_Task_Definition (N : Node_Id) is\n+      L : Entity_Id;\n+\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Visible_Declarations (N)) then\n+         Analyze_Declarations (Visible_Declarations (N));\n+      end if;\n+\n+      if Present (Private_Declarations (N)) then\n+         L := Last_Entity (Current_Scope);\n+         Analyze_Declarations (Private_Declarations (N));\n+\n+         if Present (L) then\n+            Set_First_Private_Entity\n+              (Current_Scope, Next_Entity (L));\n+         else\n+            Set_First_Private_Entity\n+              (Current_Scope, First_Entity (Current_Scope));\n+         end if;\n+      end if;\n+\n+      Check_Max_Entries (N, Max_Task_Entries);\n+      Process_End_Label (N, 'e');\n+   end Analyze_Task_Definition;\n+\n+   -----------------------\n+   -- Analyze_Task_Type --\n+   -----------------------\n+\n+   procedure Analyze_Task_Type (N : Node_Id) is\n+      T      : Entity_Id;\n+      Def_Id : constant Entity_Id := Defining_Identifier (N);\n+\n+   begin\n+      Tasking_Used := True;\n+      Check_Restriction (Max_Tasks, N);\n+      T := Find_Type_Name (N);\n+      Generate_Definition (T);\n+\n+      if Ekind (T) = E_Incomplete_Type then\n+         T := Full_View (T);\n+      end if;\n+\n+      Set_Ekind              (T, E_Task_Type);\n+      Set_Is_First_Subtype   (T, True);\n+      Set_Has_Task           (T, True);\n+      Init_Size_Align        (T);\n+      Set_Etype              (T, T);\n+      Set_Has_Delayed_Freeze (T, True);\n+      Set_Girder_Constraint (T, No_Elist);\n+      New_Scope (T);\n+\n+      if Present (Discriminant_Specifications (N)) then\n+         if Ada_83 and then Comes_From_Source (N) then\n+            Error_Msg_N (\"(Ada 83) task discriminant not allowed!\", N);\n+         end if;\n+\n+         if Has_Discriminants (T) then\n+\n+            --  Install discriminants. Also, verify conformance of\n+            --  discriminants of previous and current view.  ???\n+\n+            Install_Declarations (T);\n+         else\n+            Process_Discriminants (N);\n+         end if;\n+      end if;\n+\n+      if Present (Task_Definition (N)) then\n+         Analyze_Task_Definition (Task_Definition (N));\n+      end if;\n+\n+      if not Is_Library_Level_Entity (T) then\n+         Check_Restriction (No_Task_Hierarchy, N);\n+      end if;\n+\n+      End_Scope;\n+\n+      if T /= Def_Id\n+        and then Is_Private_Type (Def_Id)\n+        and then Has_Discriminants (Def_Id)\n+        and then Expander_Active\n+      then\n+         Exp_Ch9.Expand_N_Task_Type_Declaration (N);\n+         Process_Full_View (N, T, Def_Id);\n+      end if;\n+   end Analyze_Task_Type;\n+\n+   -----------------------------------\n+   -- Analyze_Terminate_Alternative --\n+   -----------------------------------\n+\n+   procedure Analyze_Terminate_Alternative (N : Node_Id) is\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Pragmas_Before (N)) then\n+         Analyze_List (Pragmas_Before (N));\n+      end if;\n+\n+      if Present (Condition (N)) then\n+         Analyze_And_Resolve (Condition (N), Any_Boolean);\n+      end if;\n+   end Analyze_Terminate_Alternative;\n+\n+   ------------------------------\n+   -- Analyze_Timed_Entry_Call --\n+   ------------------------------\n+\n+   procedure Analyze_Timed_Entry_Call (N : Node_Id) is\n+   begin\n+      Check_Restriction (No_Select_Statements, N);\n+      Tasking_Used := True;\n+      Analyze (Entry_Call_Alternative (N));\n+      Analyze (Delay_Alternative (N));\n+   end Analyze_Timed_Entry_Call;\n+\n+   ------------------------------------\n+   -- Analyze_Triggering_Alternative --\n+   ------------------------------------\n+\n+   procedure Analyze_Triggering_Alternative (N : Node_Id) is\n+      Trigger : Node_Id := Triggering_Statement (N);\n+   begin\n+      Tasking_Used := True;\n+\n+      if Present (Pragmas_Before (N)) then\n+         Analyze_List (Pragmas_Before (N));\n+      end if;\n+\n+      Analyze (Trigger);\n+      if Comes_From_Source (Trigger)\n+        and then Nkind (Trigger) /= N_Delay_Until_Statement\n+        and then Nkind (Trigger) /= N_Delay_Relative_Statement\n+        and then Nkind (Trigger) /= N_Entry_Call_Statement\n+      then\n+         Error_Msg_N\n+          (\"triggering statement must be delay or entry call\", Trigger);\n+      end if;\n+\n+      if Is_Non_Empty_List (Statements (N)) then\n+         Analyze_Statements (Statements (N));\n+      end if;\n+   end Analyze_Triggering_Alternative;\n+\n+   -----------------------\n+   -- Check_Max_Entries --\n+   -----------------------\n+\n+   procedure Check_Max_Entries (Def : Node_Id; R : Restriction_Parameter_Id) is\n+      Ecount : Uint;\n+\n+      procedure Count (L : List_Id);\n+      --  Count entries in given declaration list\n+\n+      procedure Count (L : List_Id) is\n+         D : Node_Id;\n+\n+      begin\n+         if No (L) then\n+            return;\n+         end if;\n+\n+         D := First (L);\n+         while Present (D) loop\n+            if Nkind (D) = N_Entry_Declaration then\n+               declare\n+                  DSD : constant Node_Id :=\n+                          Discrete_Subtype_Definition (D);\n+\n+               begin\n+                  if No (DSD) then\n+                     Ecount := Ecount + 1;\n+\n+                  elsif Is_OK_Static_Subtype (Etype (DSD)) then\n+                     declare\n+                        Lo : constant Uint :=\n+                               Expr_Value\n+                                 (Type_Low_Bound (Etype (DSD)));\n+                        Hi : constant Uint :=\n+                               Expr_Value\n+                                 (Type_High_Bound (Etype (DSD)));\n+\n+                     begin\n+                        if Hi >= Lo then\n+                           Ecount := Ecount + Hi - Lo + 1;\n+                        end if;\n+                     end;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"static subtype required by Restriction pragma\", DSD);\n+                  end if;\n+               end;\n+            end if;\n+\n+            Next (D);\n+         end loop;\n+      end Count;\n+\n+   --  Start of processing for Check_Max_Entries\n+\n+   begin\n+      if Restriction_Parameters (R) >= 0 then\n+         Ecount := Uint_0;\n+         Count (Visible_Declarations (Def));\n+         Count (Private_Declarations (Def));\n+         Check_Restriction (R, Ecount, Def);\n+      end if;\n+   end Check_Max_Entries;\n+\n+   --------------------------\n+   -- Find_Concurrent_Spec --\n+   --------------------------\n+\n+   function Find_Concurrent_Spec (Body_Id : Entity_Id) return Entity_Id is\n+      Spec_Id : Entity_Id := Current_Entity_In_Scope (Body_Id);\n+\n+   begin\n+      --  The type may have been given by an incomplete type declaration.\n+      --  Find full view now.\n+\n+      if Present (Spec_Id) and then Ekind (Spec_Id) = E_Incomplete_Type then\n+         Spec_Id := Full_View (Spec_Id);\n+      end if;\n+\n+      return Spec_Id;\n+   end Find_Concurrent_Spec;\n+\n+   --------------------------\n+   -- Install_Declarations --\n+   --------------------------\n+\n+   procedure Install_Declarations (Spec : Entity_Id) is\n+      E    : Entity_Id;\n+      Prev : Entity_Id;\n+\n+   begin\n+      E := First_Entity (Spec);\n+\n+      while Present (E) loop\n+         Prev := Current_Entity (E);\n+         Set_Current_Entity (E);\n+         Set_Is_Immediately_Visible (E);\n+         Set_Homonym (E, Prev);\n+         Next_Entity (E);\n+      end loop;\n+   end Install_Declarations;\n+\n+end Sem_Ch9;"}, {"sha": "d4922b3a9469f5c0974810600304ccd465dee564", "filename": "gcc/ada/sem_ch9.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ C H 9                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Sem_Ch9  is\n+   procedure Analyze_Abort_Statement                    (N : Node_Id);\n+   procedure Analyze_Accept_Alternative                 (N : Node_Id);\n+   procedure Analyze_Accept_Statement                   (N : Node_Id);\n+   procedure Analyze_Asynchronous_Select                (N : Node_Id);\n+   procedure Analyze_Conditional_Entry_Call             (N : Node_Id);\n+   procedure Analyze_Delay_Alternative                  (N : Node_Id);\n+   procedure Analyze_Delay_Relative                     (N : Node_Id);\n+   procedure Analyze_Delay_Until                        (N : Node_Id);\n+   procedure Analyze_Entry_Body                         (N : Node_Id);\n+   procedure Analyze_Entry_Body_Formal_Part             (N : Node_Id);\n+   procedure Analyze_Entry_Call_Alternative             (N : Node_Id);\n+   procedure Analyze_Entry_Declaration                  (N : Node_Id);\n+   procedure Analyze_Entry_Index_Specification          (N : Node_Id);\n+   procedure Analyze_Protected_Body                     (N : Node_Id);\n+   procedure Analyze_Protected_Definition               (N : Node_Id);\n+   procedure Analyze_Protected_Type                     (N : Node_Id);\n+   procedure Analyze_Requeue                            (N : Node_Id);\n+   procedure Analyze_Selective_Accept                   (N : Node_Id);\n+   procedure Analyze_Single_Protected                   (N : Node_Id);\n+   procedure Analyze_Single_Task                        (N : Node_Id);\n+   procedure Analyze_Task_Body                          (N : Node_Id);\n+   procedure Analyze_Task_Definition                    (N : Node_Id);\n+   procedure Analyze_Task_Type                          (N : Node_Id);\n+   procedure Analyze_Terminate_Alternative              (N : Node_Id);\n+   procedure Analyze_Timed_Entry_Call                   (N : Node_Id);\n+   procedure Analyze_Triggering_Alternative             (N : Node_Id);\n+end Sem_Ch9;"}, {"sha": "31dae9026e9c1e237de2838f2c91f8db30b2d962", "filename": "gcc/ada/sem_disp.adb", "status": "added", "additions": 992, "deletions": 0, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,992 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ D I S P                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.114 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Elists;   use Elists;\n+with Einfo;    use Einfo;\n+with Exp_Disp; use Exp_Disp;\n+with Errout;   use Errout;\n+with Hostparm; use Hostparm;\n+with Nlists;   use Nlists;\n+with Output;   use Output;\n+with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Uintp;    use Uintp;\n+\n+package body Sem_Disp is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Override_Dispatching_Operation\n+     (Tagged_Type : Entity_Id;\n+      Prev_Op     : Entity_Id;\n+      New_Op      : Entity_Id);\n+   --  Replace an implicit dispatching operation with an  explicit one.\n+   --  Prev_Op is an inherited primitive operation which is overridden\n+   --  by the explicit declaration of New_Op.\n+\n+   procedure Add_Dispatching_Operation\n+     (Tagged_Type : Entity_Id;\n+      New_Op      : Entity_Id);\n+   --  Add New_Op in the list of primitive operations of Tagged_Type\n+\n+   function Check_Controlling_Type\n+     (T    : Entity_Id;\n+      Subp : Entity_Id)\n+      return Entity_Id;\n+      --  T is the type of a formal parameter of subp. Returns the tagged\n+      --  if the parameter can be a controlling argument, empty otherwise\n+\n+   --------------------------------\n+   --  Add_Dispatching_Operation --\n+   --------------------------------\n+\n+   procedure Add_Dispatching_Operation\n+     (Tagged_Type : Entity_Id;\n+      New_Op      : Entity_Id)\n+   is\n+      List : constant Elist_Id := Primitive_Operations (Tagged_Type);\n+\n+   begin\n+      Append_Elmt (New_Op, List);\n+   end Add_Dispatching_Operation;\n+\n+   -------------------------------\n+   -- Check_Controlling_Formals --\n+   -------------------------------\n+\n+   procedure Check_Controlling_Formals\n+     (Typ  : Entity_Id;\n+      Subp : Entity_Id)\n+   is\n+      Formal    : Entity_Id;\n+      Ctrl_Type : Entity_Id;\n+      Remote    : constant Boolean :=\n+                    Is_Remote_Types (Current_Scope)\n+                      and then Comes_From_Source (Subp)\n+                      and then Scope (Typ) = Current_Scope;\n+\n+   begin\n+      Formal := First_Formal (Subp);\n+\n+      while Present (Formal) loop\n+         Ctrl_Type := Check_Controlling_Type (Etype (Formal), Subp);\n+\n+         if Present (Ctrl_Type) then\n+            if Ctrl_Type = Typ then\n+               Set_Is_Controlling_Formal (Formal);\n+\n+               --  Check that the parameter's nominal subtype statically\n+               --  matches the first subtype.\n+\n+               if Ekind (Etype (Formal)) = E_Anonymous_Access_Type then\n+                  if not Subtypes_Statically_Match\n+                           (Typ, Designated_Type (Etype (Formal)))\n+                  then\n+                     Error_Msg_N\n+                       (\"parameter subtype does not match controlling type\",\n+                        Formal);\n+                  end if;\n+\n+               elsif not Subtypes_Statically_Match (Typ, Etype (Formal)) then\n+                  Error_Msg_N\n+                    (\"parameter subtype does not match controlling type\",\n+                     Formal);\n+               end if;\n+\n+               if Present (Default_Value (Formal)) then\n+                  if Ekind (Etype (Formal)) = E_Anonymous_Access_Type then\n+                     Error_Msg_N\n+                       (\"default not allowed for controlling access parameter\",\n+                        Default_Value (Formal));\n+\n+                  elsif not Is_Tag_Indeterminate (Default_Value (Formal)) then\n+                     Error_Msg_N\n+                       (\"default expression must be a tag indeterminate\" &\n+                        \" function call\", Default_Value (Formal));\n+                  end if;\n+               end if;\n+\n+            elsif Comes_From_Source (Subp) then\n+               Error_Msg_N\n+                 (\"operation can be dispatching in only one type\", Subp);\n+            end if;\n+\n+         --  Verify that the restriction in E.2.2 (1) is obeyed.\n+\n+         elsif Remote\n+           and then Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+         then\n+            Error_Msg_N\n+              (\"Access parameter of a remote subprogram must be controlling\",\n+                Formal);\n+         end if;\n+\n+         Next_Formal (Formal);\n+      end loop;\n+\n+      if Present (Etype (Subp)) then\n+         Ctrl_Type := Check_Controlling_Type (Etype (Subp), Subp);\n+\n+         if Present (Ctrl_Type) then\n+            if Ctrl_Type = Typ then\n+               Set_Has_Controlling_Result (Subp);\n+\n+               --  Check that the result subtype statically matches\n+               --  the first subtype.\n+\n+               if not Subtypes_Statically_Match (Typ, Etype (Subp)) then\n+                  Error_Msg_N\n+                    (\"result subtype does not match controlling type\", Subp);\n+               end if;\n+\n+            elsif Comes_From_Source (Subp) then\n+               Error_Msg_N\n+                 (\"operation can be dispatching in only one type\", Subp);\n+            end if;\n+\n+         --  The following check is clearly required, although the RM says\n+         --  nothing about return types. If the return type is a limited\n+         --  class-wide type declared in the current scope, there is no way\n+         --  to declare stream procedures for it, so the return cannot be\n+         --  marshalled.\n+\n+         elsif Remote\n+           and then Is_Limited_Type (Typ)\n+           and then Etype (Subp) = Class_Wide_Type (Typ)\n+         then\n+            Error_Msg_N (\"return type has no stream attributes\", Subp);\n+         end if;\n+      end if;\n+   end Check_Controlling_Formals;\n+\n+   ----------------------------\n+   -- Check_Controlling_Type --\n+   ----------------------------\n+\n+   function Check_Controlling_Type\n+     (T    : Entity_Id;\n+      Subp : Entity_Id)\n+      return Entity_Id\n+   is\n+      Tagged_Type : Entity_Id := Empty;\n+\n+   begin\n+      if Is_Tagged_Type (T) then\n+         if Is_First_Subtype (T) then\n+            Tagged_Type := T;\n+         else\n+            Tagged_Type := Base_Type (T);\n+         end if;\n+\n+      elsif Ekind (T) = E_Anonymous_Access_Type\n+        and then Is_Tagged_Type (Designated_Type (T))\n+        and then Ekind (Designated_Type (T)) /= E_Incomplete_Type\n+      then\n+         if Is_First_Subtype (Designated_Type (T)) then\n+            Tagged_Type := Designated_Type (T);\n+         else\n+            Tagged_Type := Base_Type (Designated_Type (T));\n+         end if;\n+      end if;\n+\n+      if No (Tagged_Type)\n+        or else Is_Class_Wide_Type (Tagged_Type)\n+      then\n+         return Empty;\n+\n+      --  The dispatching type and the primitive operation must be defined\n+      --  in the same scope except for internal operations.\n+\n+      elsif (Scope (Subp) = Scope (Tagged_Type)\n+              or else Is_Internal (Subp))\n+        and then\n+            (not Is_Generic_Type (Tagged_Type)\n+              or else not Comes_From_Source (Subp))\n+      then\n+         return Tagged_Type;\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Check_Controlling_Type;\n+\n+   ----------------------------\n+   -- Check_Dispatching_Call --\n+   ----------------------------\n+\n+   procedure Check_Dispatching_Call (N : Node_Id) is\n+      Actual  : Node_Id;\n+      Control : Node_Id := Empty;\n+      Func    : Entity_Id;\n+\n+      procedure Check_Dispatching_Context;\n+      --  If the call is tag-indeterminate and the entity being called is\n+      --  abstract, verify that the context is a call that will eventually\n+      --  provide a tag for dispatching, or has provided one already.\n+\n+      -------------------------------\n+      -- Check_Dispatching_Context --\n+      -------------------------------\n+\n+      procedure Check_Dispatching_Context is\n+         Func : constant Entity_Id := Entity (Name (N));\n+         Par  : Node_Id;\n+\n+      begin\n+         if Is_Abstract (Func)\n+           and then No (Controlling_Argument (N))\n+         then\n+            Par := Parent (N);\n+\n+            while Present (Par) loop\n+\n+               if Nkind (Par) = N_Function_Call            or else\n+                  Nkind (Par) = N_Procedure_Call_Statement or else\n+                  Nkind (Par) = N_Assignment_Statement     or else\n+                  Nkind (Par) = N_Op_Eq                    or else\n+                  Nkind (Par) = N_Op_Ne\n+               then\n+                  return;\n+\n+               elsif Nkind (Par) = N_Qualified_Expression\n+                 or else Nkind (Par) = N_Unchecked_Type_Conversion\n+               then\n+                  Par := Parent (Par);\n+\n+               else\n+                  Error_Msg_N\n+                    (\"call to abstract function must be dispatching\", N);\n+                  return;\n+               end if;\n+            end loop;\n+         end if;\n+      end Check_Dispatching_Context;\n+\n+   --  Start of processing for Check_Dispatching_Call\n+\n+   begin\n+      --  Find a controlling argument, if any\n+\n+      if Present (Parameter_Associations (N)) then\n+         Actual := First_Actual (N);\n+\n+         while Present (Actual) loop\n+            Control := Find_Controlling_Arg (Actual);\n+            exit when Present (Control);\n+            Next_Actual (Actual);\n+         end loop;\n+\n+         if Present (Control) then\n+\n+            --  Verify that no controlling arguments are statically tagged\n+\n+            if Debug_Flag_E then\n+               Write_Str (\"Found Dispatching call\");\n+               Write_Int (Int (N));\n+               Write_Eol;\n+            end if;\n+\n+            Actual := First_Actual (N);\n+\n+            while Present (Actual) loop\n+               if Actual /= Control then\n+\n+                  if not Is_Controlling_Actual (Actual) then\n+                     null; -- can be anything\n+\n+                  elsif (Is_Dynamically_Tagged (Actual)) then\n+                     null; --  valid parameter\n+\n+                  elsif Is_Tag_Indeterminate (Actual) then\n+\n+                     --  The tag is inherited from the enclosing call (the\n+                     --  node we are currently analyzing). Explicitly expand\n+                     --  the actual, since the previous call to Expand\n+                     --  (from Resolve_Call) had no way of knowing about\n+                     --  the required dispatching.\n+\n+                     Propagate_Tag (Control, Actual);\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"controlling argument is not dynamically tagged\",\n+                        Actual);\n+                     return;\n+                  end if;\n+               end if;\n+\n+               Next_Actual (Actual);\n+            end loop;\n+\n+            --  Mark call as a dispatching call\n+\n+            Set_Controlling_Argument (N, Control);\n+\n+         else\n+            --  The call is not dispatching, check that there isn't any\n+            --  tag indeterminate abstract call left\n+\n+            Actual := First_Actual (N);\n+\n+            while Present (Actual) loop\n+               if Is_Tag_Indeterminate (Actual) then\n+\n+                  --  Function call case\n+\n+                  if Nkind (Original_Node (Actual)) = N_Function_Call then\n+                     Func := Entity (Name (Original_Node (Actual)));\n+\n+                  --  Only other possibility is a qualified expression whose\n+                  --  consituent expression is itself a call.\n+\n+                  else\n+                     Func :=\n+                       Entity (Name\n+                         (Original_Node\n+                           (Expression (Original_Node (Actual)))));\n+                  end if;\n+\n+                  if Is_Abstract (Func) then\n+                     Error_Msg_N (\n+                       \"call to abstract function must be dispatching\", N);\n+                  end if;\n+               end if;\n+\n+               Next_Actual (Actual);\n+            end loop;\n+\n+            Check_Dispatching_Context;\n+         end if;\n+\n+      else\n+         --  If dispatching on result, the enclosing call, if any, will\n+         --  determine the controlling argument. Otherwise this is the\n+         --  primitive operation of the root type.\n+\n+         Check_Dispatching_Context;\n+      end if;\n+   end Check_Dispatching_Call;\n+\n+   ---------------------------------\n+   -- Check_Dispatching_Operation --\n+   ---------------------------------\n+\n+   procedure Check_Dispatching_Operation (Subp, Old_Subp : Entity_Id) is\n+      Tagged_Seen            : Entity_Id;\n+      Has_Dispatching_Parent : Boolean := False;\n+      Body_Is_Last_Primitive : Boolean := False;\n+\n+   begin\n+      if Ekind (Subp) /= E_Procedure and then Ekind (Subp) /= E_Function then\n+         return;\n+      end if;\n+\n+      Set_Is_Dispatching_Operation (Subp, False);\n+      Tagged_Seen := Find_Dispatching_Type (Subp);\n+\n+      --  If Subp is derived from a dispatching operation then it should\n+      --  always be treated as dispatching. In this case various checks\n+      --  below will be bypassed. Makes sure that late declarations for\n+      --  inherited private subprograms are treated as dispatching, even\n+      --  if the associated tagged type is already frozen.\n+\n+      Has_Dispatching_Parent := Present (Alias (Subp))\n+        and then Is_Dispatching_Operation (Alias (Subp));\n+\n+      if No (Tagged_Seen) then\n+         return;\n+\n+      --  The subprograms build internally after the freezing point (such as\n+      --  the Init procedure) are not primitives\n+\n+      elsif Is_Frozen (Tagged_Seen)\n+        and then not Comes_From_Source (Subp)\n+        and then not Has_Dispatching_Parent\n+      then\n+         return;\n+\n+      --  The operation may be a child unit, whose scope is the defining\n+      --  package, but which is not a primitive operation of the type.\n+\n+      elsif Is_Child_Unit (Subp) then\n+         return;\n+\n+      --  If the subprogram is not defined in a package spec, the only case\n+      --  where it can be a dispatching op is when it overrides an operation\n+      --  before the freezing point of the type.\n+\n+      elsif ((not Is_Package (Scope (Subp)))\n+              or else In_Package_Body (Scope (Subp)))\n+        and then not Has_Dispatching_Parent\n+      then\n+         if not Comes_From_Source (Subp)\n+           or else (Present (Old_Subp) and then not Is_Frozen (Tagged_Seen))\n+         then\n+            null;\n+\n+         --  If the type is already frozen, the overriding is not allowed\n+         --  except when Old_Subp is not a dispatching operation (which\n+         --  can occur when Old_Subp was inherited by an untagged type).\n+         --  However, a body with no previous spec freezes the type \"after\"\n+         --  its declaration, and therefore is a legal overriding (unless\n+         --  the type has already been frozen). Only the first such body\n+         --  is legal.\n+\n+         elsif Present (Old_Subp)\n+           and then Is_Dispatching_Operation (Old_Subp)\n+         then\n+            if Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Body\n+              and then Comes_From_Source (Subp)\n+            then\n+               declare\n+                  Subp_Body : constant Node_Id := Unit_Declaration_Node (Subp);\n+                  Decl_Item : Node_Id := Next (Parent (Tagged_Seen));\n+\n+               begin\n+                  --  ??? The checks here for whether the type has been\n+                  --  frozen prior to the new body are not complete. It's\n+                  --  not simple to check frozenness at this point since\n+                  --  the body has already caused the type to be prematurely\n+                  --  frozen in Analyze_Declarations, but we're forced to\n+                  --  recheck this here because of the odd rule interpretation\n+                  --  that allows the overriding if the type wasn't frozen\n+                  --  prior to the body. The freezing action should probably\n+                  --  be delayed until after the spec is seen, but that's\n+                  --  a tricky change to the delicate freezing code.\n+\n+                  --  Look at each declaration following the type up\n+                  --  until the new subprogram body. If any of the\n+                  --  declarations is a body then the type has been\n+                  --  frozen already so the overriding primitive is\n+                  --  illegal.\n+\n+                  while Present (Decl_Item)\n+                    and then (Decl_Item /= Subp_Body)\n+                  loop\n+                     if Comes_From_Source (Decl_Item)\n+                       and then (Nkind (Decl_Item) in N_Proper_Body\n+                                  or else Nkind (Decl_Item) in N_Body_Stub)\n+                     then\n+                        Error_Msg_N (\"overriding of& is too late!\", Subp);\n+                        Error_Msg_N\n+                          (\"\\spec should appear immediately after the type!\",\n+                           Subp);\n+                        exit;\n+                     end if;\n+\n+                     Next (Decl_Item);\n+                  end loop;\n+\n+                  --  If the subprogram doesn't follow in the list of\n+                  --  declarations including the type then the type\n+                  --  has definitely been frozen already and the body\n+                  --  is illegal.\n+\n+                  if not Present (Decl_Item) then\n+                     Error_Msg_N (\"overriding of& is too late!\", Subp);\n+                     Error_Msg_N\n+                       (\"\\spec should appear immediately after the type!\",\n+                        Subp);\n+\n+                  elsif Is_Frozen (Subp) then\n+\n+                     --  the subprogram body declares a primitive operation.\n+                     --  if the subprogram is already frozen, we must update\n+                     --  its dispatching information explicitly here. The\n+                     --  information is taken from the overridden subprogram.\n+\n+                     Body_Is_Last_Primitive := True;\n+\n+                     if Present (DTC_Entity (Old_Subp)) then\n+                        Set_DTC_Entity (Subp, DTC_Entity (Old_Subp));\n+                        Set_DT_Position (Subp, DT_Position (Old_Subp));\n+                        Insert_After (\n+                          Subp_Body, Fill_DT_Entry (Sloc (Subp_Body), Subp));\n+                     end if;\n+                  end if;\n+               end;\n+\n+            else\n+               Error_Msg_N (\"overriding of& is too late!\", Subp);\n+               Error_Msg_N\n+                 (\"\\subprogram spec should appear immediately after the type!\",\n+                  Subp);\n+            end if;\n+\n+         --  If the type is not frozen yet and we are not in the overridding\n+         --  case it looks suspiciously like an attempt to define a primitive\n+         --  operation.\n+\n+         elsif not Is_Frozen (Tagged_Seen) then\n+            Error_Msg_N\n+              (\"?not dispatching (must be defined in a package spec)\", Subp);\n+            return;\n+\n+         --  When the type is frozen, it is legitimate to define a new\n+         --  non-primitive operation.\n+\n+         else\n+            return;\n+         end if;\n+\n+      --  Now, we are sure that the scope is a package spec. If the subprogram\n+      --  is declared after the freezing point ot the type that's an error\n+\n+      elsif Is_Frozen (Tagged_Seen) and then not Has_Dispatching_Parent then\n+         Error_Msg_N (\"this primitive operation is declared too late\", Subp);\n+         Error_Msg_NE\n+           (\"?no primitive operations for& after this line\",\n+            Freeze_Node (Tagged_Seen),\n+            Tagged_Seen);\n+         return;\n+      end if;\n+\n+      Check_Controlling_Formals (Tagged_Seen, Subp);\n+\n+      --  Now it should be a correct primitive operation, put it in the list\n+\n+      if Present (Old_Subp) then\n+         Check_Subtype_Conformant (Subp, Old_Subp);\n+         Override_Dispatching_Operation (Tagged_Seen, Old_Subp, Subp);\n+\n+      else\n+         Add_Dispatching_Operation (Tagged_Seen, Subp);\n+      end if;\n+\n+      Set_Is_Dispatching_Operation (Subp, True);\n+\n+      if not Body_Is_Last_Primitive then\n+         Set_DT_Position (Subp, No_Uint);\n+      end if;\n+\n+   end Check_Dispatching_Operation;\n+\n+   ------------------------------------------\n+   -- Check_Operation_From_Incomplete_Type --\n+   ------------------------------------------\n+\n+   procedure Check_Operation_From_Incomplete_Type\n+     (Subp : Entity_Id;\n+      Typ  : Entity_Id)\n+   is\n+      Full       : constant Entity_Id := Full_View (Typ);\n+      Parent_Typ : constant Entity_Id := Etype (Full);\n+      Old_Prim   : constant Elist_Id  := Primitive_Operations (Parent_Typ);\n+      New_Prim   : constant Elist_Id  := Primitive_Operations (Full);\n+      Op1, Op2   : Elmt_Id;\n+      Prev       : Elmt_Id := No_Elmt;\n+\n+      function Derives_From (Proc : Entity_Id) return Boolean;\n+      --  Check that Subp has the signature of an operation derived from Proc.\n+      --  Subp has an access parameter that designates Typ.\n+\n+      ------------------\n+      -- Derives_From --\n+      ------------------\n+\n+      function Derives_From (Proc : Entity_Id) return Boolean is\n+         F1, F2 : Entity_Id;\n+\n+      begin\n+         if Chars (Proc) /= Chars (Subp) then\n+            return False;\n+         end if;\n+\n+         F1 := First_Formal (Proc);\n+         F2 := First_Formal (Subp);\n+\n+         while Present (F1) and then Present (F2) loop\n+\n+            if Ekind (Etype (F1)) = E_Anonymous_Access_Type then\n+\n+               if Ekind (Etype (F2)) /= E_Anonymous_Access_Type then\n+                  return False;\n+\n+               elsif Designated_Type (Etype (F1)) = Parent_Typ\n+                 and then Designated_Type (Etype (F2)) /= Full\n+               then\n+                  return False;\n+               end if;\n+\n+            elsif Ekind (Etype (F2)) = E_Anonymous_Access_Type then\n+               return False;\n+\n+            elsif Etype (F1) /= Etype (F2) then\n+               return False;\n+            end if;\n+\n+            Next_Formal (F1);\n+            Next_Formal (F2);\n+         end loop;\n+\n+         return No (F1) and then No (F2);\n+      end Derives_From;\n+\n+   --  Start of processing for Check_Operation_From_Incomplete_Type\n+\n+   begin\n+      --  The operation may override an inherited one, or may be a new one\n+      --  altogether. The inherited operation will have been hidden by the\n+      --  current one at the point of the type derivation, so it does not\n+      --  appear in the list of primitive operations of the type. We have to\n+      --  find the proper place of insertion in the list of primitive opera-\n+      --  tions by iterating over the list for the parent type.\n+\n+      Op1 := First_Elmt (Old_Prim);\n+      Op2 := First_Elmt (New_Prim);\n+\n+      while Present (Op1) and then Present (Op2) loop\n+\n+         if Derives_From (Node (Op1)) then\n+\n+            if No (Prev) then\n+               Prepend_Elmt (Subp, New_Prim);\n+            else\n+               Insert_Elmt_After (Subp, Prev);\n+            end if;\n+\n+            return;\n+         end if;\n+\n+         Prev := Op2;\n+         Next_Elmt (Op1);\n+         Next_Elmt (Op2);\n+      end loop;\n+\n+      --  Operation is a new primitive.\n+\n+      Append_Elmt (Subp, New_Prim);\n+\n+   end Check_Operation_From_Incomplete_Type;\n+\n+   ---------------------------------------\n+   -- Check_Operation_From_Private_View --\n+   ---------------------------------------\n+\n+   procedure Check_Operation_From_Private_View (Subp, Old_Subp : Entity_Id) is\n+      Tagged_Type : Entity_Id;\n+\n+   begin\n+      if Is_Dispatching_Operation (Alias (Subp)) then\n+         Set_Scope (Subp, Current_Scope);\n+         Tagged_Type := Find_Dispatching_Type (Subp);\n+\n+         if Present (Tagged_Type) and then Is_Tagged_Type (Tagged_Type) then\n+            Append_Elmt (Old_Subp, Primitive_Operations (Tagged_Type));\n+\n+            --  If Old_Subp isn't already marked as dispatching then\n+            --  this is the case of an operation of an untagged private\n+            --  type fulfilled by a tagged type that overrides an\n+            --  inherited dispatching operation, so we set the necessary\n+            --  dispatching attributes here.\n+\n+            if not Is_Dispatching_Operation (Old_Subp) then\n+               Check_Controlling_Formals (Tagged_Type, Old_Subp);\n+               Set_Is_Dispatching_Operation (Old_Subp, True);\n+               Set_DT_Position (Old_Subp, No_Uint);\n+            end if;\n+\n+            --  If the old subprogram is an explicit renaming of some other\n+            --  entity, it is not overridden by the inherited subprogram.\n+            --  Otherwise, update its alias and other attributes.\n+\n+            if Present (Alias (Old_Subp))\n+              and then Nkind (Unit_Declaration_Node (Old_Subp))\n+                /= N_Subprogram_Renaming_Declaration\n+            then\n+               Set_Alias (Old_Subp, Alias (Subp));\n+\n+               --  The derived subprogram should inherit the abstractness\n+               --  of the parent subprogram (except in the case of a function\n+               --  returning the type). This sets the abstractness properly\n+               --  for cases where a private extension may have inherited\n+               --  an abstract operation, but the full type is derived from\n+               --  a descendant type and inherits a nonabstract version.\n+\n+               if Etype (Subp) /= Tagged_Type then\n+                  Set_Is_Abstract (Old_Subp, Is_Abstract (Alias (Subp)));\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Operation_From_Private_View;\n+\n+   --------------------------\n+   -- Find_Controlling_Arg --\n+   --------------------------\n+\n+   function Find_Controlling_Arg (N : Node_Id) return Node_Id is\n+      Orig_Node : constant Node_Id := Original_Node (N);\n+      Typ       : Entity_Id;\n+\n+   begin\n+      if Nkind (Orig_Node) = N_Qualified_Expression then\n+         return Find_Controlling_Arg (Expression (Orig_Node));\n+      end if;\n+\n+      --  Dispatching on result case\n+\n+      if Nkind (Orig_Node) = N_Function_Call\n+        and then Present (Controlling_Argument (Orig_Node))\n+        and then Has_Controlling_Result (Entity (Name (Orig_Node)))\n+      then\n+         return Controlling_Argument (Orig_Node);\n+\n+      --  Normal case\n+\n+      elsif Is_Controlling_Actual (N) then\n+         Typ := Etype (N);\n+\n+         if Is_Access_Type (Typ) then\n+            --  In the case of an Access attribute, use the type of\n+            --  the prefix, since in the case of an actual for an\n+            --  access parameter, the attribute's type may be of a\n+            --  specific designated type, even though the prefix\n+            --  type is class-wide.\n+\n+            if Nkind (N) = N_Attribute_Reference then\n+               Typ := Etype (Prefix (N));\n+            else\n+               Typ := Designated_Type (Typ);\n+            end if;\n+         end if;\n+\n+         if Is_Class_Wide_Type (Typ) then\n+            return N;\n+         end if;\n+      end if;\n+\n+      return Empty;\n+   end Find_Controlling_Arg;\n+\n+   ---------------------------\n+   -- Find_Dispatching_Type --\n+   ---------------------------\n+\n+   function Find_Dispatching_Type (Subp : Entity_Id) return Entity_Id is\n+      Formal    : Entity_Id;\n+      Ctrl_Type : Entity_Id;\n+\n+   begin\n+      if Present (DTC_Entity (Subp)) then\n+         return Scope (DTC_Entity (Subp));\n+\n+      else\n+         Formal := First_Formal (Subp);\n+         while Present (Formal) loop\n+            Ctrl_Type := Check_Controlling_Type (Etype (Formal), Subp);\n+\n+            if Present (Ctrl_Type) then\n+               return Ctrl_Type;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+      --  The subprogram may also be dispatching on result\n+\n+         if Present (Etype (Subp)) then\n+            Ctrl_Type := Check_Controlling_Type (Etype (Subp), Subp);\n+\n+            if Present (Ctrl_Type) then\n+               return Ctrl_Type;\n+            end if;\n+         end if;\n+      end if;\n+\n+      return Empty;\n+   end Find_Dispatching_Type;\n+\n+   ---------------------------\n+   -- Is_Dynamically_Tagged --\n+   ---------------------------\n+\n+   function Is_Dynamically_Tagged (N : Node_Id) return Boolean is\n+   begin\n+      return Find_Controlling_Arg (N) /= Empty;\n+   end Is_Dynamically_Tagged;\n+\n+   --------------------------\n+   -- Is_Tag_Indeterminate --\n+   --------------------------\n+\n+   function Is_Tag_Indeterminate (N : Node_Id) return Boolean is\n+      Nam       : Entity_Id;\n+      Actual    : Node_Id;\n+      Orig_Node : constant Node_Id := Original_Node (N);\n+\n+   begin\n+      if Nkind (Orig_Node) = N_Function_Call\n+        and then Is_Entity_Name (Name (Orig_Node))\n+      then\n+         Nam := Entity (Name (Orig_Node));\n+\n+         if not Has_Controlling_Result (Nam) then\n+            return False;\n+\n+         --  If there are no actuals, the call is tag-indeterminate\n+\n+         elsif No (Parameter_Associations (Orig_Node)) then\n+            return True;\n+\n+         else\n+            Actual := First_Actual (Orig_Node);\n+\n+            while Present (Actual) loop\n+               if Is_Controlling_Actual (Actual)\n+                 and then not Is_Tag_Indeterminate (Actual)\n+               then\n+                  return False; -- one operand is dispatching\n+               end if;\n+\n+               Next_Actual (Actual);\n+            end loop;\n+\n+            return True;\n+\n+         end if;\n+\n+      elsif Nkind (Orig_Node) = N_Qualified_Expression then\n+         return Is_Tag_Indeterminate (Expression (Orig_Node));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Tag_Indeterminate;\n+\n+   ------------------------------------\n+   -- Override_Dispatching_Operation --\n+   ------------------------------------\n+\n+   procedure Override_Dispatching_Operation\n+     (Tagged_Type : Entity_Id;\n+      Prev_Op     : Entity_Id;\n+      New_Op      : Entity_Id)\n+   is\n+      Op_Elmt   : Elmt_Id := First_Elmt (Primitive_Operations (Tagged_Type));\n+\n+   begin\n+      --  Patch the primitive operation list\n+\n+      while Present (Op_Elmt)\n+        and then Node (Op_Elmt) /= Prev_Op\n+      loop\n+         Next_Elmt (Op_Elmt);\n+      end loop;\n+\n+      --  If there is no previous operation to override, the type declaration\n+      --  was malformed, and an error must have been emitted already.\n+\n+      if No (Op_Elmt) then\n+         return;\n+      end if;\n+\n+      Replace_Elmt (Op_Elmt, New_Op);\n+\n+      if (not Is_Package (Current_Scope))\n+        or else not In_Private_Part (Current_Scope)\n+      then\n+         --  Not a private primitive\n+\n+         null;\n+\n+      else pragma Assert (Is_Inherited_Operation (Prev_Op));\n+\n+         --  Make the overriding operation into an alias of the implicit one.\n+         --  In this fashion a call from outside ends up calling the new\n+         --  body even if non-dispatching, and a call from inside calls the\n+         --  overriding operation because it hides the implicit one.\n+         --  To indicate that the body of Prev_Op is never called, set its\n+         --  dispatch table entity to Empty.\n+\n+         Set_Alias (Prev_Op, New_Op);\n+         Set_DTC_Entity (Prev_Op, Empty);\n+         return;\n+      end if;\n+   end Override_Dispatching_Operation;\n+\n+   -------------------\n+   -- Propagate_Tag --\n+   -------------------\n+\n+   procedure Propagate_Tag (Control : Node_Id; Actual : Node_Id) is\n+      Call_Node : Node_Id;\n+      Arg       : Node_Id;\n+\n+   begin\n+      if Nkind (Actual) = N_Function_Call then\n+         Call_Node := Actual;\n+\n+      elsif Nkind (Actual) = N_Identifier\n+        and then Nkind (Original_Node (Actual)) = N_Function_Call\n+      then\n+         --  Call rewritten as object declaration when stack-checking\n+         --  is enabled. Propagate tag to expression in declaration, which\n+         --  is original call.\n+\n+         Call_Node := Expression (Parent (Entity (Actual)));\n+\n+      --  Only other possibility is parenthesized or qualified expression\n+\n+      else\n+         Call_Node := Expression (Actual);\n+      end if;\n+\n+      --  Do not set the Controlling_Argument if already set. This happens\n+      --  in the special case of _Input (see Exp_Attr, case Input).\n+\n+      if No (Controlling_Argument (Call_Node)) then\n+         Set_Controlling_Argument (Call_Node, Control);\n+      end if;\n+\n+      Arg := First_Actual (Call_Node);\n+\n+      while Present (Arg) loop\n+         if Is_Tag_Indeterminate (Arg) then\n+            Propagate_Tag (Control,  Arg);\n+         end if;\n+\n+         Next_Actual (Arg);\n+      end loop;\n+\n+      --  Expansion of dispatching calls is suppressed when Java_VM, because\n+      --  the JVM back end directly handles the generation of dispatching\n+      --  calls and would have to undo any expansion to an indirect call.\n+\n+      if not Java_VM then\n+         Expand_Dispatch_Call (Call_Node);\n+      end if;\n+   end Propagate_Tag;\n+\n+end Sem_Disp;"}, {"sha": "75f415800dea92eba6e17a76b7caa69f66dc48f3", "filename": "gcc/ada/sem_disp.ads", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,91 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ D I S P                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines involved in tagged types and dynamic\n+--  dispatching.\n+\n+with Types; use Types;\n+package Sem_Disp is\n+\n+   procedure Check_Controlling_Formals (Typ : Entity_Id; Subp : Entity_Id);\n+   --  Check that all controlling parameters of Subp are of type Typ,\n+   --  that defaults for controlling parameters are tag-indeterminate,\n+   --  and that the nominal subtype of the parameters and result\n+   --  statically match the first subtype of the controlling type.\n+\n+   procedure Check_Dispatching_Call (N : Node_Id);\n+   --  Check if a call is a dispatching call. The subprogram is known to\n+   --  be a dispatching operation. The call is dispatching if all the\n+   --  controlling actuals are dynamically tagged. This procedure is called\n+   --  after overload resolution, so the call is known to be unambiguous.\n+\n+   procedure Check_Dispatching_Operation (Subp, Old_Subp : Entity_Id);\n+   --  Add \"Subp\" to the list of primitive operations of the corresponding type\n+   --  if it has a parameter of this type and is defined at a proper place for\n+   --  primitive operations. (new primitives are only defined in package spec,\n+   --  overridden operation can be defined in any scope). If Old_Subp is not\n+   --  Empty we are in the overriding case.\n+\n+   procedure Check_Operation_From_Incomplete_Type\n+     (Subp : Entity_Id;\n+      Typ  : Entity_Id);\n+   --  If a primitive operation was defined for the incomplete view of the\n+   --  type, and the full type declaration is a derived type definition,\n+   --  the operation may override an inherited one.\n+\n+   procedure Check_Operation_From_Private_View (Subp, Old_Subp : Entity_Id);\n+   --  Add \"Old_Subp\" to the list of primitive operations of the corresponding\n+   --  tagged type if it is the full view of a private tagged type. The Alias\n+   --  of \"OldSubp\" is adjusted to point to the inherited procedure of the\n+   --  full view because it is always this one which has to be called.\n+\n+   function Find_Controlling_Arg (N : Node_Id) return Node_Id;\n+   --  Returns the actual controlling argument if N is dynamically tagged,\n+   --  and Empty if it is not dynamically tagged.\n+\n+   function Find_Dispatching_Type (Subp : Entity_Id) return Entity_Id;\n+   --  Check whether a subprogram is dispatching, and find the tagged\n+   --  type of the controlling argument or arguments.\n+\n+   function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n+   --  Used to determine whether a call is dispatching, i.e. if is an\n+   --  an expression of a class_Wide type, or a call to a function with\n+   --  controlling result where at least one operand is dynamically tagged.\n+\n+   function Is_Tag_Indeterminate (N : Node_Id) return Boolean;\n+   --  An expression is tag-indeterminate if it is a call that dispatches\n+   --  on result, and all controlling operands are also indeterminate.\n+   --  Such a function call may inherit a tag from an enclosing call.\n+\n+   procedure Propagate_Tag (Control : Node_Id; Actual : Node_Id);\n+   --  If a function call is tag-indeterminate,  its controlling argument is\n+   --  found in the context;  either an enclosing call, or the left-hand side\n+   --  of the enclosing assignment statement. The tag must be propagated\n+   --  recursively to the tag-indeterminate actuals of the call.\n+\n+end Sem_Disp;"}, {"sha": "f2b5c6c6bfade16069ed153d5c329d05c8e9bf16", "filename": "gcc/ada/sem_dist.adb", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,686 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ D I S T                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.182 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Casing;   use Casing;\n+with Einfo;    use Einfo;\n+with Errout;   use Errout;\n+with Exp_Dist; use Exp_Dist;\n+with Exp_Tss;  use Exp_Tss;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Tbuild;   use Tbuild;\n+with Uname;    use Uname;\n+\n+package body Sem_Dist is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure RAS_E_Dereference (Pref : Node_Id);\n+   --  Handles explicit dereference of Remote Access to Subprograms.\n+\n+   function Full_Qualified_Name (E : Entity_Id) return String_Id;\n+   --  returns the full qualified name of the entity in lower case.\n+\n+   -------------------------\n+   -- Add_Stub_Constructs --\n+   -------------------------\n+\n+   procedure Add_Stub_Constructs (N : Node_Id) is\n+      U    : constant Node_Id := Unit (N);\n+      Spec : Entity_Id        := Empty;\n+      Exp  : Node_Id          := U;         --  Unit that will be expanded\n+\n+   begin\n+      pragma Assert (Distribution_Stub_Mode /= No_Stubs);\n+\n+      if Nkind (U) = N_Package_Declaration then\n+         Spec := Defining_Entity (Specification (U));\n+\n+      elsif Nkind (U) = N_Package_Body then\n+         Spec := Corresponding_Spec (U);\n+\n+      else pragma Assert (Nkind (U) = N_Package_Instantiation);\n+         Exp  := Instance_Spec (U);\n+         Spec := Defining_Entity (Specification (Exp));\n+      end if;\n+\n+      pragma Assert (Is_Shared_Passive (Spec)\n+        or else Is_Remote_Call_Interface (Spec));\n+\n+      if Distribution_Stub_Mode = Generate_Caller_Stub_Body then\n+\n+         if Is_Shared_Passive (Spec) then\n+            null;\n+         elsif Nkind (U) = N_Package_Body then\n+            Error_Msg_N\n+              (\"Specification file expected from command line\", U);\n+         else\n+            Expand_Calling_Stubs_Bodies (Exp);\n+         end if;\n+\n+      else\n+\n+         if Is_Shared_Passive (Spec) then\n+            Build_Passive_Partition_Stub (Exp);\n+         else\n+            Expand_Receiving_Stubs_Bodies (Exp);\n+         end if;\n+\n+      end if;\n+   end Add_Stub_Constructs;\n+\n+   -------------------------\n+   -- Full_Qualified_Name --\n+   -------------------------\n+\n+   function Full_Qualified_Name (E : Entity_Id) return String_Id is\n+      Ent         : Entity_Id := E;\n+      Parent_Name : String_Id := No_String;\n+\n+   begin\n+      --  Deals properly with child units\n+\n+      if Nkind (Ent) = N_Defining_Program_Unit_Name then\n+         Ent := Defining_Identifier (Ent);\n+      end if;\n+\n+      --  Compute recursively the qualification. Only \"Standard\" has no scope.\n+\n+      if Present (Scope (Scope (Ent))) then\n+         Parent_Name := Full_Qualified_Name (Scope (Ent));\n+      end if;\n+\n+      --  Every entity should have a name except some expanded blocks\n+      --  don't bother about those.\n+\n+      if Chars (Ent) = No_Name then\n+         return Parent_Name;\n+      end if;\n+\n+      --  Add a period between Name and qualification\n+\n+      if Parent_Name /= No_String then\n+         Start_String (Parent_Name);\n+         Store_String_Char (Get_Char_Code ('.'));\n+\n+      else\n+         Start_String;\n+      end if;\n+\n+      --  Generates the entity name in upper case\n+\n+      Get_Name_String (Chars (Ent));\n+      Set_Casing (All_Lower_Case);\n+      Store_String_Chars (Name_Buffer (1 .. Name_Len));\n+      return End_String;\n+   end Full_Qualified_Name;\n+\n+   -----------------------\n+   -- Get_Subprogram_Id --\n+   -----------------------\n+\n+   function Get_Subprogram_Id (E : Entity_Id) return Int is\n+      Current_Declaration : Node_Id;\n+      Result              : Int := 0;\n+\n+   begin\n+      pragma Assert\n+        (Is_Remote_Call_Interface (Scope (E))\n+           and then\n+             (Nkind (Parent (E)) = N_Procedure_Specification\n+                or else\n+              Nkind (Parent (E)) = N_Function_Specification));\n+\n+      Current_Declaration :=\n+        First (Visible_Declarations\n+          (Package_Specification_Of_Scope (Scope (E))));\n+\n+      while Current_Declaration /= Empty loop\n+         if Nkind (Current_Declaration) = N_Subprogram_Declaration\n+           and then Comes_From_Source (Current_Declaration)\n+         then\n+            if Defining_Unit_Name\n+                 (Specification (Current_Declaration)) = E\n+            then\n+               return Result;\n+            end if;\n+\n+            Result := Result + 1;\n+         end if;\n+\n+         Next (Current_Declaration);\n+      end loop;\n+\n+      --  Error if we do not find it\n+\n+      raise Program_Error;\n+   end Get_Subprogram_Id;\n+\n+   ------------------------\n+   -- Is_All_Remote_Call --\n+   ------------------------\n+\n+   function Is_All_Remote_Call (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+\n+   begin\n+      if (Nkind (N) = N_Function_Call\n+              or else Nkind (N) = N_Procedure_Call_Statement)\n+        and then Nkind (Name (N)) in N_Has_Entity\n+        and then Is_Remote_Call_Interface (Entity (Name (N)))\n+        and then Has_All_Calls_Remote (Scope (Entity (Name (N))))\n+        and then Comes_From_Source (N)\n+      then\n+         Par := Parent (Entity (Name (N)));\n+\n+         while Present (Par)\n+           and then (Nkind (Par) /= N_Package_Specification\n+                       or else Is_Wrapper_Package (Defining_Entity (Par)))\n+         loop\n+            Par := Parent (Par);\n+         end loop;\n+\n+         if Present (Par) then\n+            return\n+              not Scope_Within_Or_Same (Current_Scope, Defining_Entity (Par));\n+         else\n+            return False;\n+         end if;\n+      else\n+         return False;\n+      end if;\n+   end Is_All_Remote_Call;\n+\n+   ------------------------------------\n+   -- Package_Specification_Of_Scope --\n+   ------------------------------------\n+\n+   function Package_Specification_Of_Scope (E : Entity_Id) return Node_Id is\n+      N : Node_Id := Parent (E);\n+   begin\n+      while Nkind (N) /= N_Package_Specification loop\n+         N := Parent (N);\n+      end loop;\n+\n+      return N;\n+   end Package_Specification_Of_Scope;\n+\n+   --------------------------\n+   -- Process_Partition_ID --\n+   --------------------------\n+\n+   procedure Process_Partition_Id (N : Node_Id) is\n+      Loc            : constant Source_Ptr := Sloc (N);\n+      Ety            : Entity_Id;\n+      Nd             : Node_Id;\n+      Get_Pt_Id      : Node_Id;\n+      Get_Pt_Id_Call : Node_Id;\n+      Prefix_String  : String_Id;\n+      Typ            : constant Entity_Id := Etype (N);\n+\n+   begin\n+      Ety := Entity (Prefix (N));\n+\n+      --  In case prefix is not a library unit entity, get the entity\n+      --  of library unit.\n+\n+      while (Present (Scope (Ety))\n+        and then Scope (Ety) /= Standard_Standard)\n+        and not Is_Child_Unit (Ety)\n+      loop\n+         Ety := Scope (Ety);\n+      end loop;\n+\n+      Nd := Enclosing_Lib_Unit_Node (N);\n+\n+      --  Retrieve the proper function to call.\n+\n+      if Is_Remote_Call_Interface (Ety) then\n+         Get_Pt_Id := New_Occurrence_Of\n+           (RTE (RE_Get_Active_Partition_Id), Loc);\n+\n+      elsif Is_Shared_Passive (Ety) then\n+         Get_Pt_Id := New_Occurrence_Of\n+           (RTE (RE_Get_Passive_Partition_Id), Loc);\n+\n+      else\n+         Get_Pt_Id := New_Occurrence_Of\n+           (RTE (RE_Get_Local_Partition_Id), Loc);\n+      end if;\n+\n+      --  Get and store the String_Id corresponding to the name of the\n+      --  library unit whose Partition_Id is needed\n+\n+      Get_Unit_Name_String (Get_Unit_Name (Unit_Declaration_Node (Ety)));\n+\n+      --  Remove seven last character (\"(spec)\" or \" (body)\").\n+      --  (this is a bit nasty, should have interface for this ???)\n+\n+      Name_Len := Name_Len - 7;\n+\n+      Start_String;\n+      Store_String_Chars (Name_Buffer (1 .. Name_Len));\n+      Prefix_String := End_String;\n+\n+      --  Build the function call which will replace the attribute\n+\n+      if Is_Remote_Call_Interface (Ety)\n+        or else Is_Shared_Passive (Ety)\n+      then\n+         Get_Pt_Id_Call :=\n+           Make_Function_Call (Loc,\n+             Name => Get_Pt_Id,\n+             Parameter_Associations =>\n+               New_List (Make_String_Literal (Loc, Prefix_String)));\n+\n+      else\n+         Get_Pt_Id_Call := Make_Function_Call (Loc, Get_Pt_Id);\n+\n+      end if;\n+\n+      --  Replace the attribute node by a conversion of the function call\n+      --  to the target type.\n+\n+      Rewrite (N, Convert_To (Typ, Get_Pt_Id_Call));\n+      Analyze_And_Resolve (N, Typ);\n+\n+   end Process_Partition_Id;\n+\n+   ----------------------------------\n+   -- Process_Remote_AST_Attribute --\n+   ----------------------------------\n+\n+   procedure Process_Remote_AST_Attribute\n+     (N        : Node_Id;\n+      New_Type : Entity_Id)\n+   is\n+      Loc                   : constant Source_Ptr := Sloc (N);\n+      Remote_Subp           : Entity_Id;\n+      Tick_Access_Conv_Call : Node_Id;\n+      Remote_Subp_Decl      : Node_Id;\n+      RAS_Decl              : Node_Id;\n+      RS_Pkg_Specif         : Node_Id;\n+      RS_Pkg_E              : Entity_Id;\n+      RAS_Pkg_E             : Entity_Id;\n+      RAS_Type              : Entity_Id;\n+      RAS_Name              : Name_Id;\n+      Async_E               : Entity_Id;\n+      Subp_Id               : Int;\n+      Attribute_Subp        : Entity_Id;\n+      Parameter             : Node_Id;\n+\n+   begin\n+      --  Check if we have to expand the access attribute\n+\n+      Remote_Subp := Entity (Prefix (N));\n+\n+      if not Expander_Active then\n+         return;\n+\n+      elsif Ekind (New_Type) = E_Record_Type then\n+         RAS_Type := New_Type;\n+\n+      else\n+         --  If the remote type has not been constructed yet, create\n+         --  it and its attributes now.\n+\n+         Attribute_Subp := TSS (New_Type, Name_uRAS_Access);\n+\n+         if No (Attribute_Subp) then\n+            Add_RAST_Features (Parent (New_Type));\n+         end if;\n+\n+         RAS_Type := Equivalent_Type (New_Type);\n+      end if;\n+\n+      RAS_Name  := Chars (RAS_Type);\n+      RAS_Decl := Parent (RAS_Type);\n+      Attribute_Subp := TSS (RAS_Type, Name_uRAS_Access);\n+\n+      RAS_Pkg_E  := Defining_Entity (Parent (RAS_Decl));\n+      Remote_Subp_Decl := Unit_Declaration_Node (Remote_Subp);\n+\n+      if Nkind (Remote_Subp_Decl) = N_Subprogram_Body then\n+         Remote_Subp := Corresponding_Spec (Remote_Subp_Decl);\n+         Remote_Subp_Decl := Unit_Declaration_Node (Remote_Subp);\n+      end if;\n+\n+      RS_Pkg_Specif := Parent (Remote_Subp_Decl);\n+      RS_Pkg_E := Defining_Entity (RS_Pkg_Specif);\n+\n+      Subp_Id := Get_Subprogram_Id (Remote_Subp);\n+\n+      if Ekind (Remote_Subp) = E_Procedure\n+        and then Is_Asynchronous (Remote_Subp)\n+      then\n+         Async_E := Standard_True;\n+      else\n+         Async_E := Standard_False;\n+      end if;\n+\n+      --  Right now, we do not call the Name_uAddress_Resolver subprogram,\n+      --  which means that we end up with a Null_Address value in the ras\n+      --  field: each dereference of an RAS will go through the PCS, which\n+      --  is authorized but potentially not very efficient ???\n+\n+      Parameter := New_Occurrence_Of (RTE (RE_Null_Address), Loc);\n+\n+      Tick_Access_Conv_Call :=\n+        Make_Function_Call (Loc,\n+          Name => New_Occurrence_Of (Attribute_Subp, Loc),\n+          Parameter_Associations =>\n+            New_List (\n+              Parameter,\n+              Make_String_Literal (Loc, Full_Qualified_Name (RS_Pkg_E)),\n+              Make_Integer_Literal (Loc, Subp_Id),\n+              New_Occurrence_Of (Async_E, Loc)));\n+\n+      Rewrite (N, Tick_Access_Conv_Call);\n+      Analyze_And_Resolve (N, RAS_Type);\n+\n+   end Process_Remote_AST_Attribute;\n+\n+   ------------------------------------\n+   -- Process_Remote_AST_Declaration --\n+   ------------------------------------\n+\n+   procedure Process_Remote_AST_Declaration (N : Node_Id) is\n+      Loc           : constant Source_Ptr := Sloc (N);\n+      User_Type     : constant Node_Id := Defining_Identifier (N);\n+      Fat_Type      : constant Entity_Id :=\n+                        Make_Defining_Identifier\n+                          (Loc, Chars (User_Type));\n+      New_Type_Decl : Node_Id;\n+\n+   begin\n+      --  We add a record type declaration for the equivalent fat pointer type\n+\n+      New_Type_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Fat_Type,\n+          Type_Definition =>\n+            Make_Record_Definition (Loc,\n+              Component_List =>\n+                Make_Component_List (Loc,\n+                  Component_Items => New_List (\n+\n+                    Make_Component_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_Ras),\n+                      Subtype_Indication =>\n+                        New_Occurrence_Of\n+                          (RTE (RE_Unsigned_64), Loc)),\n+\n+                    Make_Component_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_Origin),\n+                      Subtype_Indication =>\n+                        New_Reference_To\n+                          (Standard_Integer,\n+                           Loc)),\n+\n+                    Make_Component_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_Receiver),\n+                      Subtype_Indication =>\n+                        New_Reference_To\n+                          (RTE (RE_Unsigned_64), Loc)),\n+\n+                    Make_Component_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_Subp_Id),\n+                      Subtype_Indication =>\n+                        New_Reference_To\n+                          (Standard_Natural,\n+                           Loc)),\n+\n+                    Make_Component_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_Async),\n+                      Subtype_Indication =>\n+                        New_Reference_To\n+                          (Standard_Boolean,\n+                           Loc))))));\n+\n+      Insert_After (N, New_Type_Decl);\n+      Set_Equivalent_Type (User_Type, Fat_Type);\n+      Set_Corresponding_Remote_Type (Fat_Type, User_Type);\n+\n+      --  The reason we suppress the initialization procedure is that we know\n+      --  that no initialization is required (even if Initialize_Scalars mode\n+      --  is active), and there are order of elaboration problems if we do try\n+      --  to generate an Init_Proc for this created record type.\n+\n+      Set_Suppress_Init_Proc (Fat_Type);\n+\n+      if Expander_Active then\n+         Add_RAST_Features (Parent (User_Type));\n+      end if;\n+\n+   end Process_Remote_AST_Declaration;\n+\n+   -----------------------\n+   -- RAS_E_Dereference --\n+   -----------------------\n+\n+   procedure RAS_E_Dereference (Pref : Node_Id) is\n+      Loc             : constant Source_Ptr := Sloc (Pref);\n+      Call_Node       : Node_Id;\n+      New_Type        : constant Entity_Id := Etype (Pref);\n+      RAS             : constant Entity_Id :=\n+                          Corresponding_Remote_Type (New_Type);\n+      RAS_Decl        : constant Node_Id   := Parent (RAS);\n+      Explicit_Deref  : constant Node_Id   := Parent (Pref);\n+      Deref_Subp_Call : constant Node_Id   := Parent (Explicit_Deref);\n+      Deref_Proc      : Entity_Id;\n+      Params          : List_Id;\n+\n+   begin\n+      if Nkind (Deref_Subp_Call) = N_Procedure_Call_Statement then\n+         Params := Parameter_Associations (Deref_Subp_Call);\n+\n+         if Present (Params) then\n+            Prepend (Pref, Params);\n+         else\n+            Params := New_List (Pref);\n+         end if;\n+\n+      elsif Nkind (Deref_Subp_Call) = N_Indexed_Component then\n+\n+         Params := Expressions (Deref_Subp_Call);\n+\n+         if Present (Params) then\n+            Prepend (Pref, Params);\n+         else\n+            Params := New_List (Pref);\n+         end if;\n+\n+      else\n+         --  Context is not a call.\n+\n+         return;\n+      end if;\n+\n+      Deref_Proc := TSS (New_Type, Name_uRAS_Dereference);\n+\n+      if not Expander_Active then\n+         return;\n+\n+      elsif No (Deref_Proc) then\n+         Add_RAST_Features (RAS_Decl);\n+         Deref_Proc := TSS (New_Type, Name_uRAS_Dereference);\n+      end if;\n+\n+      if Ekind (Deref_Proc) = E_Function then\n+         Call_Node :=\n+           Make_Function_Call (Loc,\n+              Name => New_Occurrence_Of (Deref_Proc, Loc),\n+              Parameter_Associations => Params);\n+\n+      else\n+         Call_Node :=\n+           Make_Procedure_Call_Statement (Loc,\n+              Name => New_Occurrence_Of (Deref_Proc, Loc),\n+              Parameter_Associations => Params);\n+      end if;\n+\n+      Rewrite (Deref_Subp_Call, Call_Node);\n+      Analyze (Deref_Subp_Call);\n+   end RAS_E_Dereference;\n+\n+   ------------------------------\n+   -- Remote_AST_E_Dereference --\n+   ------------------------------\n+\n+   function Remote_AST_E_Dereference (P : Node_Id) return Boolean\n+   is\n+      ET : constant Entity_Id  := Etype (P);\n+\n+   begin\n+      --  Perform the changes only on original dereferences, and only if\n+      --  we are generating code.\n+\n+      if Comes_From_Source (P)\n+        and then Is_Record_Type (ET)\n+        and then (Is_Remote_Call_Interface (ET)\n+                   or else Is_Remote_Types (ET))\n+        and then Present (Corresponding_Remote_Type (ET))\n+        and then (Nkind (Parent (Parent (P))) = N_Procedure_Call_Statement\n+                   or else Nkind (Parent (Parent (P))) = N_Indexed_Component)\n+        and then Expander_Active\n+      then\n+         RAS_E_Dereference (P);\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Remote_AST_E_Dereference;\n+\n+   ------------------------------\n+   -- Remote_AST_I_Dereference --\n+   ------------------------------\n+\n+   function Remote_AST_I_Dereference (P : Node_Id) return Boolean\n+   is\n+      ET     : constant Entity_Id  := Etype (P);\n+      Deref  : Node_Id;\n+   begin\n+\n+      if Comes_From_Source (P)\n+        and then (Is_Remote_Call_Interface (ET)\n+                   or else Is_Remote_Types (ET))\n+        and then Present (Corresponding_Remote_Type (ET))\n+        and then Ekind (Entity (P)) /= E_Function\n+      then\n+         Deref :=\n+           Make_Explicit_Dereference (Sloc (P),\n+             Prefix => Relocate_Node (P));\n+         Rewrite (P, Deref);\n+         Set_Etype (P, ET);\n+         RAS_E_Dereference (Prefix (P));\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Remote_AST_I_Dereference;\n+\n+   ---------------------------\n+   -- Remote_AST_Null_Value --\n+   ---------------------------\n+\n+   function Remote_AST_Null_Value\n+     (N    : Node_Id;\n+      Typ  : Entity_Id)\n+      return Boolean\n+   is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Target_Type : Entity_Id;\n+\n+   begin\n+      if not Expander_Active then\n+         return False;\n+\n+      elsif Ekind (Typ) = E_Access_Subprogram_Type\n+        and then (Is_Remote_Call_Interface (Typ)\n+                    or else Is_Remote_Types (Typ))\n+        and then Comes_From_Source (N)\n+        and then Expander_Active\n+      then\n+         --  Any null that comes from source and is of the RAS type must\n+         --  be expanded, except if expansion is not active (nothing\n+         --  gets expanded into the equivalent record type).\n+\n+         Target_Type := Equivalent_Type (Typ);\n+\n+      elsif Ekind (Typ) = E_Record_Type\n+        and then Present (Corresponding_Remote_Type (Typ))\n+      then\n+\n+         --  This is a record type representing a RAS type, this must be\n+         --  expanded.\n+\n+         Target_Type := Typ;\n+\n+      else\n+         --  We do not have to handle this case\n+\n+         return False;\n+\n+      end if;\n+\n+      Rewrite (N,\n+        Make_Aggregate (Loc,\n+          Expressions => New_List (\n+            Make_Integer_Literal (Loc, 0),                  -- Ras\n+            Make_Integer_Literal (Loc, 0),                  -- Origin\n+            Make_Integer_Literal (Loc, 0),                  -- Receiver\n+            Make_Integer_Literal (Loc, 0),                  -- Subp_Id\n+            New_Occurrence_Of (Standard_False, Loc))));     -- Asyn\n+      Analyze_And_Resolve (N, Target_Type);\n+      return True;\n+   end Remote_AST_Null_Value;\n+\n+end Sem_Dist;"}, {"sha": "b5c823ddc795fb47cd716947fd6e8a3e8492ca3c", "filename": "gcc/ada/sem_dist.ads", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,95 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ D I S T                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.56 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Semantic processing for distribution annex facilities\n+\n+with Types; use Types;\n+\n+package Sem_Dist is\n+\n+   procedure Add_Stub_Constructs (N : Node_Id);\n+   --  Create the stubs constructs for a remote call interface package\n+   --  specification or body or for a shared passive specification. For\n+   --  caller stubs, expansion takes place directly in the specification and\n+   --  no additional compilation unit is created.\n+\n+   function Is_All_Remote_Call (N : Node_Id) return Boolean;\n+   --  Check whether a function or procedure call should be expanded into\n+   --  a remote call, because the entity is declared in a package decl that\n+   --  is not currently in scope, and the proper pragmas apply.\n+\n+   procedure Process_Partition_Id (N : Node_Id);\n+   --  Replace attribute reference with call to runtime function. The result\n+   --  is converted to the context type, because the attribute yields a\n+   --  universal integer value.\n+\n+   procedure Process_Remote_AST_Attribute (N : Node_Id; New_Type : Entity_Id);\n+   --  Given N, an access attribute reference node whose prefix is a\n+   --  remote subprogram, rewrite N with a call to a conversion function\n+   --  whose return type is New_Type.\n+\n+   procedure Process_Remote_AST_Declaration (N : Node_Id);\n+   --  Given N, an access to subprogram type declaration node in RCI or\n+   --  remote types unit, build a new record (fat pointer) type declaration\n+   --  using the old Defining_Identifier of N and a link to the old\n+   --  declaration node N whose Defining_Identifier is changed.\n+   --  We also construct declarations of two subprograms in the unit\n+   --  specification which handle remote access to subprogram type\n+   --  (fat pointer) dereference and the unit receiver that handles\n+   --  remote calls (from remote access to subprogram type values.)\n+\n+   function Remote_AST_E_Dereference (P : Node_Id) return Boolean;\n+   --  If the prefix of an explicit dereference is a record type that\n+   --  represent the fat pointer for an Remote access to subprogram, in\n+   --  the context of a call, rewrite the enclosing call node into a\n+   --  remote call, the first actual of which is the fat pointer. Return\n+   --  true if the context is correct and the transformation took place.\n+\n+   function Remote_AST_I_Dereference (P : Node_Id) return Boolean;\n+   --  If P is a record type that represents the fat pointer for a remote\n+   --  access to subprogram, and P is the prefix of a call, insert an\n+   --  explicit dereference and perform the transformation described for\n+   --  the previous function.\n+\n+   function Remote_AST_Null_Value\n+     (N    : Node_Id;\n+      Typ  : Entity_Id)\n+      return Boolean;\n+   --  If N is a null value and Typ a remote access to subprogram type,\n+   --  this function will check if null needs to be replaced with an\n+   --  aggregate and will return True in this case. Otherwise, it will\n+   --  return False.\n+\n+   function Get_Subprogram_Id (E : Entity_Id) return Int;\n+   --  Given a subprogram defined in a RCI package, get its subprogram id\n+   --  which will be used for remote calls.\n+\n+   function Package_Specification_Of_Scope (E : Entity_Id) return Node_Id;\n+   --  Return the N_Package_Specification corresponding to a scope E\n+\n+end Sem_Dist;"}, {"sha": "555abb8ca884f040296b6d7db31158595f8b9546", "filename": "gcc/ada/sem_elab.adb", "status": "added", "additions": 2278, "deletions": 0, "changes": 2278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,2278 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ E L A B                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.84 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Checks;   use Checks;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Exp_Util; use Exp_Util;\n+with Expander; use Expander;\n+with Fname;    use Fname;\n+with Lib;      use Lib;\n+with Lib.Load; use Lib.Load;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Output;   use Output;\n+with Restrict; use Restrict;\n+with Sem;      use Sem;\n+with Sem_Cat;  use Sem_Cat;\n+with Sem_Ch7;  use Sem_Ch7;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Table;\n+with Tbuild;   use Tbuild;\n+with Uname;    use Uname;\n+\n+package body Sem_Elab is\n+\n+   --  The following table records the recursive call chain for output\n+   --  in the Output routine. Each entry records the call node and the\n+   --  entity of the called routine. The number of entries in the table\n+   --  (i.e. the value of Elab_Call.Last) indicates the current depth\n+   --  of recursion and is used to identify the outer level.\n+\n+   type Elab_Call_Entry is record\n+      Cloc : Source_Ptr;\n+      Ent  : Entity_Id;\n+   end record;\n+\n+   package Elab_Call is new Table.Table (\n+     Table_Component_Type => Elab_Call_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 50,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Elab_Call\");\n+\n+   --  This table is initialized at the start of each outer level call.\n+   --  It holds the entities for all subprograms that have been examined\n+   --  for this particular outer level call, and is used to prevent both\n+   --  infinite recursion, and useless reanalysis of bodies already seen\n+\n+   package Elab_Visited is new Table.Table (\n+     Table_Component_Type => Entity_Id,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 200,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Elab_Visited\");\n+\n+   --  This table stores calls to Check_Internal_Call that are delayed\n+   --  until all generics are instantiated, and in particular that all\n+   --  generic bodies have been inserted. We need to delay, because we\n+   --  need to be able to look through the inserted bodies.\n+\n+   type Delay_Element is record\n+      N : Node_Id;\n+      --  The parameter N from the call to Check_Internal_Call. Note that\n+      --  this node may get rewritten over the delay period by expansion\n+      --  in the call case (but not in the instantiation case).\n+\n+      E : Entity_Id;\n+      --  The parameter E from the call to Check_Internal_Call\n+\n+      Orig_Ent : Entity_Id;\n+      --  The parameter Orig_Ent from the call to Check_Internal_Call\n+\n+      Curscop : Entity_Id;\n+      --  The current scope of the call. This is restored when we complete\n+      --  the delayed call, so that we do this in the right scope.\n+\n+      From_Elab_Code : Boolean;\n+      --  Save indication of whether this call is from elaboration code\n+\n+      Outer_Scope : Entity_Id;\n+      --  Save scope of outer level call\n+\n+   end record;\n+\n+   package Delay_Check is new Table.Table (\n+     Table_Component_Type => Delay_Element,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 1000,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Delay_Check\");\n+\n+   C_Scope : Entity_Id;\n+   --  Top level scope of current scope. We need to compute this only\n+   --  once at the outer level, i.e. for a call to Check_Elab_Call from\n+   --  outside this unit.\n+\n+   Outer_Level_Sloc : Source_Ptr;\n+   --  Save Sloc value for outer level call node for comparisons of source\n+   --  locations. A body is too late if it appears after the *outer* level\n+   --  call, not the particular call that is being analyzed.\n+\n+   From_Elab_Code : Boolean;\n+   --  This flag shows whether the outer level call currently being examined\n+   --  is or is not in elaboration code. We are only interested in calls to\n+   --  routines in other units if this flag is True.\n+\n+   In_Task_Activation : Boolean := False;\n+   --  This flag indicates whether we are performing elaboration checks on\n+   --  task procedures, at the point of activation. If true, we do not trace\n+   --  internal calls in these procedures, because all local bodies are known\n+   --  to be elaborated.\n+\n+   Delaying_Elab_Checks : Boolean := True;\n+   --  This is set True till the compilation is complete, including the\n+   --  insertion of all instance bodies. Then when Check_Elab_Calls is\n+   --  called, the delay table is used to make the delayed calls and\n+   --  this flag is reset to False, so that the calls are processed\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   --  Note: Outer_Scope in all these calls represents the scope of\n+   --  interest of the outer level call. If it is set to Standard_Standard,\n+   --  then it means the outer level call was at elaboration level, and that\n+   --  thus all calls are of interest. If it was set to some other scope,\n+   --  then the original call was an inner call, and we are not interested\n+   --  in calls that go outside this scope.\n+\n+   procedure Check_A_Call\n+     (N                 : Node_Id;\n+      E                 : Entity_Id;\n+      Outer_Scope       : Entity_Id;\n+      Inter_Unit_Only   : Boolean;\n+      Generate_Warnings : Boolean := True);\n+   --  This is the internal recursive routine that is called to check for\n+   --  a possible elaboration error. The argument N is a subprogram call\n+   --  or generic instantiation to be checked, and E is the entity of\n+   --  the called subprogram, or instantiated generic unit. The flag\n+   --  Outer_Scope is the outer level scope for the original call.\n+   --  Inter_Unit_Only is set if the call is only to be checked in the\n+   --  case where it is to another unit (and skipped if within a unit).\n+   --  Generate_Warnings is set to True to suppress warning messages\n+   --  about missing pragma Elaborate_All's. These messages are not\n+   --  wanted for inner calls in the dynamic model.\n+\n+   procedure Check_Bad_Instantiation (N : Node_Id);\n+   --  N is a node for an instantiation (if called with any other node kind,\n+   --  Check_Bad_Instantiation ignores the call). This subprogram checks for\n+   --  the special case of a generic instantiation of a generic spec in the\n+   --  same declarative part as the instantiation where a body is present and\n+   --  has not yet been seen. This is an obvious error, but needs to be checked\n+   --  specially at the time of the instantiation, since it is a case where we\n+   --  cannot insert the body anywhere. If this case is detected, warnings are\n+   --  generated, and a raise of Program_Error is inserted. In addition any\n+   --  subprograms in the generic spec are stubbed, and the Bad_Instantiation\n+   --  flag is set on the instantiation node. The caller in Sem_Ch12 uses this\n+   --  flag as an indication that no attempt should be made to insert an\n+   --  instance body.\n+\n+   procedure Check_Internal_Call\n+     (N           : Node_Id;\n+      E           : Entity_Id;\n+      Outer_Scope : Entity_Id;\n+      Orig_Ent    : Entity_Id);\n+   --  N is a function call or procedure statement call node and E is\n+   --  the entity of the called function, which is within the current\n+   --  compilation unit (where subunits count as part of the parent).\n+   --  This call checks if this call, or any call within any accessed\n+   --  body could cause an ABE, and if so, outputs a warning. Orig_Ent\n+   --  differs from E only in the case of renamings, and points to the\n+   --  original name of the entity. This is used for error messages.\n+   --  Outer_Scope is the outer level scope for the original call.\n+\n+   procedure Check_Internal_Call_Continue\n+     (N           : Node_Id;\n+      E           : Entity_Id;\n+      Outer_Scope : Entity_Id;\n+      Orig_Ent    : Entity_Id);\n+   --  The processing for Check_Internal_Call is divided up into two phases,\n+   --  and this represents the second phase. The second phase is delayed if\n+   --  Delaying_Elab_Calls is set to True. In this delayed case, the first\n+   --  phase makes an entry in the Delay_Check table, which is processed\n+   --  when Check_Elab_Calls is called. N, E and Orig_Ent are as for the call\n+   --  to Check_Internal_Call. Outer_Scope is the outer level scope for\n+   --  the original call.\n+\n+   function Has_Generic_Body (N : Node_Id) return Boolean;\n+   --  N is a generic package instantiation node, and this routine determines\n+   --  if this package spec does in fact have a generic body. If so, then\n+   --  True is returned, otherwise False. Note that this is not at all the\n+   --  same as checking if the unit requires a body, since it deals with\n+   --  the case of optional bodies accurately (i.e. if a body is optional,\n+   --  then it looks to see if a body is actually present). Note: this\n+   --  function can only do a fully correct job if in generating code mode\n+   --  where all bodies have to be present. If we are operating in semantics\n+   --  check only mode, then in some cases of optional bodies, a result of\n+   --  False may incorrectly be given. In practice this simply means that\n+   --  some cases of warnings for incorrect order of elaboration will only\n+   --  be given when generating code, which is not a big problem (and is\n+   --  inevitable, given the optional body semantics of Ada).\n+\n+   procedure Insert_Elab_Check (N : Node_Id; C : Node_Id := Empty);\n+   --  Given code for an elaboration check (or unconditional raise if\n+   --  the check is not needed), inserts the code in the appropriate\n+   --  place. N is the call or instantiation node for which the check\n+   --  code is required. C is the test whose failure triggers the raise.\n+\n+   procedure Output_Calls (N : Node_Id);\n+   --  Outputs chain of calls stored in the Elab_Call table. The caller\n+   --  has already generated the main warning message, so the warnings\n+   --  generated are all continuation messages. The argument is the\n+   --  call node at which the messages are to be placed.\n+\n+   function Same_Elaboration_Scope (Scop1, Scop2 : Entity_Id) return Boolean;\n+   --  Given two scopes, determine whether they are the same scope from an\n+   --  elaboration point of view, i.e. packages and blocks are ignored.\n+\n+   procedure Set_C_Scope;\n+   --  On entry C_Scope is set to some scope. On return, C_Scope is reset\n+   --  to be the enclosing compilation unit of this scope.\n+\n+   function Spec_Entity (E : Entity_Id) return Entity_Id;\n+   --  Given a compilation unit entity, if it is a spec entity, it is\n+   --  returned unchanged. If it is a body entity, then the spec for\n+   --  the corresponding spec is returned\n+\n+   procedure Supply_Bodies (N : Node_Id);\n+   --  Given a node, N, that is either a subprogram declaration or a package\n+   --  declaration, this procedure supplies dummy bodies for the subprogram\n+   --  or for all subprograms in the package. If the given node is not one\n+   --  of these two possibilities, then Supply_Bodies does nothing. The\n+   --  dummy body is supplied by setting the subprogram to be Imported with\n+   --  convention Stubbed.\n+\n+   procedure Supply_Bodies (L : List_Id);\n+   --  Calls Supply_Bodies for all elements of the given list L.\n+\n+   function Within (E1, E2 : Entity_Id) return Boolean;\n+   --  Given two scopes E1 and E2, returns True if E1 is equal to E2, or\n+   --  is one of its contained scopes, False otherwise.\n+\n+   ------------------\n+   -- Check_A_Call --\n+   ------------------\n+\n+   procedure Check_A_Call\n+     (N                 : Node_Id;\n+      E                 : Entity_Id;\n+      Outer_Scope       : Entity_Id;\n+      Inter_Unit_Only   : Boolean;\n+      Generate_Warnings : Boolean := True)\n+   is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Ent  : Entity_Id;\n+      Decl : Node_Id;\n+\n+      E_Scope : Entity_Id;\n+      --  Top level scope of entity for called subprogram\n+\n+      Body_Acts_As_Spec : Boolean;\n+      --  Set to true if call is to body acting as spec (no separate spec)\n+\n+      Inst_Case : constant Boolean := Nkind (N) in N_Generic_Instantiation;\n+      --  Indicates if we have instantiation case\n+\n+      Caller_Unit_Internal : Boolean;\n+      Callee_Unit_Internal : Boolean;\n+\n+      Inst_Caller : Source_Ptr;\n+      Inst_Callee : Source_Ptr;\n+\n+      Unit_Caller : Unit_Number_Type;\n+      Unit_Callee : Unit_Number_Type;\n+\n+      Cunit_SW : Boolean := False;\n+      --  Set to suppress warnings for case of external reference where\n+      --  one of the enclosing scopes has the Suppress_Elaboration_Warnings\n+      --  flag set. For the internal case, we ignore this flag.\n+\n+      Cunit_SC : Boolean := False;\n+      --  Set to suppress dynamic elaboration checks where one of the\n+      --  enclosing scopes has Suppress_Elaboration_Checks set. For\n+      --  the internal case, we ignore this flag.\n+\n+   begin\n+      --  Go to parent for derived subprogram, or to original subprogram\n+      --  in the case of a renaming (Alias covers both these cases)\n+\n+      Ent := E;\n+      loop\n+         if Suppress_Elaboration_Warnings (Ent) then\n+            return;\n+         end if;\n+\n+         --  Nothing to do for imported entities,\n+\n+         if Is_Imported (Ent) then\n+            return;\n+         end if;\n+\n+         exit when Inst_Case or else No (Alias (Ent));\n+         Ent := Alias (Ent);\n+      end loop;\n+\n+      Decl := Unit_Declaration_Node (Ent);\n+\n+      if Nkind (Decl) = N_Subprogram_Body then\n+         Body_Acts_As_Spec := True;\n+\n+      elsif Nkind (Decl) = N_Subprogram_Declaration\n+        or else Nkind (Decl) = N_Subprogram_Body_Stub\n+        or else Inst_Case\n+      then\n+         Body_Acts_As_Spec := False;\n+\n+      --  If we have none of an instantiation, subprogram body or\n+      --  subprogram declaration, then it is not a case that we want\n+      --  to check. (One case is a call to a generic formal subprogram,\n+      --  where we do not want the check in the template).\n+\n+      else\n+         return;\n+      end if;\n+\n+      E_Scope := Ent;\n+      loop\n+         if Suppress_Elaboration_Warnings (E_Scope) then\n+            Cunit_SW := True;\n+         end if;\n+\n+         if Suppress_Elaboration_Checks (E_Scope) then\n+            Cunit_SC := True;\n+         end if;\n+\n+         --  Exit when we get to compilation unit, not counting subunits\n+\n+         exit when Is_Compilation_Unit (E_Scope)\n+           and then (Is_Child_Unit (E_Scope)\n+                       or else Scope (E_Scope) = Standard_Standard);\n+\n+         --  If we did not find a compilation unit, other than standard,\n+         --  then nothing to check (happens in some instantiation cases)\n+\n+         if E_Scope = Standard_Standard then\n+            return;\n+\n+         --  Otherwise move up a scope looking for compilation unit\n+\n+         else\n+            E_Scope := Scope (E_Scope);\n+         end if;\n+      end loop;\n+\n+      --  No checks needed for pure or preelaborated compilation units\n+\n+      if Is_Pure (E_Scope)\n+        or else Is_Preelaborated (E_Scope)\n+      then\n+         return;\n+      end if;\n+\n+      --  If the generic entity is within a deeper instance than we are, then\n+      --  either the instantiation to which we refer itself caused an ABE, in\n+      --  which case that will be handled separately. Otherwise, we know that\n+      --  the body we need appears as needed at the point of the instantiation.\n+      --  However, this assumption is only valid if we are in static mode.\n+\n+      if not Dynamic_Elaboration_Checks\n+        and then Instantiation_Depth (Sloc (Ent)) >\n+                 Instantiation_Depth (Sloc (N))\n+      then\n+         return;\n+      end if;\n+\n+      --  Do not give a warning for a package with no body\n+\n+      if Ekind (Ent) = E_Generic_Package\n+        and then not Has_Generic_Body (N)\n+      then\n+         return;\n+      end if;\n+\n+      --  Case of entity is not in current unit (i.e. with'ed unit case)\n+\n+      if E_Scope /= C_Scope then\n+\n+         --  We are only interested in such calls if the outer call was from\n+         --  elaboration code, or if we are in Dynamic_Elaboration_Checks mode.\n+\n+         if not From_Elab_Code and then not Dynamic_Elaboration_Checks then\n+            return;\n+         end if;\n+\n+         --  Nothing to do if some scope said to ignore warnings\n+\n+         if Cunit_SW then\n+            return;\n+         end if;\n+\n+         --  Nothing to do for a generic instance, because in this case\n+         --  the checking was at the point of instantiation of the generic\n+         --  However, this shortcut is only applicable in static mode.\n+\n+         if Is_Generic_Instance (Ent) and not Dynamic_Elaboration_Checks then\n+            return;\n+         end if;\n+\n+         --  Nothing to do if subprogram with no separate spec\n+\n+         if Body_Acts_As_Spec then\n+            return;\n+         end if;\n+\n+         --  Check cases of internal units\n+\n+         Callee_Unit_Internal :=\n+           Is_Internal_File_Name\n+             (Unit_File_Name (Get_Source_Unit (E_Scope)));\n+\n+         --  Do not give a warning if the with'ed unit is internal\n+         --  and this is the generic instantiation case (this saves a\n+         --  lot of hassle dealing with the Text_IO special child units)\n+\n+         if Callee_Unit_Internal and Inst_Case then\n+            return;\n+         end if;\n+\n+         if C_Scope = Standard_Standard then\n+            Caller_Unit_Internal := False;\n+         else\n+            Caller_Unit_Internal :=\n+              Is_Internal_File_Name\n+                (Unit_File_Name (Get_Source_Unit (C_Scope)));\n+         end if;\n+\n+         --  Do not give a warning if the with'ed unit is internal\n+         --  and the caller is not internal (since the binder always\n+         --  elaborates internal units first).\n+\n+         if Callee_Unit_Internal and (not Caller_Unit_Internal) then\n+            return;\n+         end if;\n+\n+         --  For now, if debug flag -gnatdE is not set, do no checking for\n+         --  one internal unit withing another. This fixes the problem with\n+         --  the sgi build and storage errors. To be resolved later ???\n+\n+         if (Callee_Unit_Internal and Caller_Unit_Internal)\n+            and then not Debug_Flag_EE\n+         then\n+            return;\n+         end if;\n+\n+         Ent := E;\n+\n+         --  If the call is in an instance, and the called entity is not\n+         --  defined in the same instance, then the elaboration issue\n+         --  focuses around the unit containing the template, it is\n+         --  this unit which requires an Elaborate_All.\n+\n+         --  However, if we are doing dynamic elaboration, we need to\n+         --  chase the call in the usual manner.\n+\n+         --  We do not handle the case of calling a generic formal correctly\n+         --  in the static case. See test 4703-004 to explore this gap ???\n+\n+         Inst_Caller := Instantiation (Get_Source_File_Index (Sloc (N)));\n+         Inst_Callee := Instantiation (Get_Source_File_Index (Sloc (Ent)));\n+\n+         if Inst_Caller = No_Location then\n+            Unit_Caller := No_Unit;\n+         else\n+            Unit_Caller := Get_Source_Unit (N);\n+         end if;\n+\n+         if Inst_Callee = No_Location then\n+            Unit_Callee := No_Unit;\n+         else\n+            Unit_Callee := Get_Source_Unit (Ent);\n+         end if;\n+\n+         if Unit_Caller /= No_Unit\n+           and then Unit_Callee /= Unit_Caller\n+           and then not Dynamic_Elaboration_Checks\n+         then\n+            E_Scope := Spec_Entity (Cunit_Entity (Unit_Caller));\n+\n+            --  If we don't get a spec entity, just ignore call. Not\n+            --  quite clear why this check is necessary.\n+\n+            if No (E_Scope) then\n+               return;\n+            end if;\n+\n+            --  Otherwise step to enclosing compilation unit\n+\n+            while not Is_Compilation_Unit (E_Scope) loop\n+               E_Scope := Scope (E_Scope);\n+            end loop;\n+\n+         --  For the case of not in an instance, or call within instance\n+         --  We recompute E_Scope for the error message, since we\n+         --  do NOT want to go to the unit which has the ultimate\n+         --  declaration in the case of renaming and derivation and\n+         --  we also want to go to the generic unit in the case of\n+         --  an instance, and no further.\n+\n+         else\n+            --  Loop to carefully follow renamings and derivations\n+            --  one step outside the current unit, but not further.\n+\n+            loop\n+               E_Scope := Ent;\n+               while not Is_Compilation_Unit (E_Scope) loop\n+                  E_Scope := Scope (E_Scope);\n+               end loop;\n+\n+               --  If E_Scope is the same as C_Scope, it means that there\n+               --  definitely was a renaming or derivation, and we are\n+               --  not yet out of the current unit.\n+\n+               exit when E_Scope /= C_Scope;\n+               Ent := Alias (Ent);\n+            end loop;\n+         end if;\n+\n+         if not Suppress_Elaboration_Warnings (Ent)\n+           and then not Suppress_Elaboration_Warnings (E_Scope)\n+           and then Elab_Warnings\n+           and then Generate_Warnings\n+         then\n+            Warn_On_Instance := True;\n+\n+            if Inst_Case then\n+               Error_Msg_NE\n+                 (\"instantiation of& may raise Program_Error?\", N, Ent);\n+            else\n+               Error_Msg_NE\n+                 (\"call to & may raise Program_Error?\", N, Ent);\n+            end if;\n+\n+            Error_Msg_Qual_Level := Nat'Last;\n+            Error_Msg_NE\n+              (\"\\missing pragma Elaborate_All for&?\", N, E_Scope);\n+            Error_Msg_Qual_Level := 0;\n+            Output_Calls (N);\n+            Warn_On_Instance := False;\n+\n+            --  Set flag to prevent further warnings for same unit\n+            --  unless in All_Errors_Mode.\n+\n+            if not All_Errors_Mode and not Dynamic_Elaboration_Checks then\n+               Set_Suppress_Elaboration_Warnings (E_Scope);\n+            end if;\n+         end if;\n+\n+         --  Check for runtime elaboration check required\n+\n+         if Dynamic_Elaboration_Checks then\n+            if not Elaboration_Checks_Suppressed (Ent)\n+              and then not Suppress_Elaboration_Checks (E_Scope)\n+              and then not Cunit_SC\n+            then\n+               --  Runtime elaboration check required. generate check of the\n+               --  elaboration Boolean for the unit containing the entity.\n+\n+               Insert_Elab_Check (N,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Elaborated,\n+                   Prefix =>\n+                     New_Occurrence_Of\n+                       (Spec_Entity (E_Scope), Loc)));\n+            end if;\n+\n+         --  If no dynamic check required, then ask binder to guarantee\n+         --  that the necessary elaborations will be done properly!\n+\n+         else\n+            if not Suppress_Elaboration_Warnings (E)\n+              and then not Suppress_Elaboration_Warnings (E_Scope)\n+              and then Elab_Warnings\n+              and then Generate_Warnings\n+              and then not Inst_Case\n+            then\n+               Error_Msg_Node_2 := E_Scope;\n+               Error_Msg_NE (\"call to& in elaboration code \" &\n+                  \"requires pragma Elaborate_All on&?\", N, E);\n+            end if;\n+\n+            Set_Elaborate_All_Desirable (E_Scope);\n+            Set_Suppress_Elaboration_Warnings (E_Scope);\n+         end if;\n+\n+      --  Case of entity is in same unit as call or instantiation\n+\n+      elsif not Inter_Unit_Only then\n+         Check_Internal_Call (N, Ent, Outer_Scope, E);\n+      end if;\n+\n+   end Check_A_Call;\n+\n+   -----------------------------\n+   -- Check_Bad_Instantiation --\n+   -----------------------------\n+\n+   procedure Check_Bad_Instantiation (N : Node_Id) is\n+      Nam : Node_Id;\n+      Ent : Entity_Id;\n+\n+   begin\n+      --  Nothing to do if we do not have an instantiation (happens in some\n+      --  error cases, and also in the formal package declaration case)\n+\n+      if Nkind (N) not in N_Generic_Instantiation then\n+         return;\n+\n+      --  Nothing to do if errors already detected (avoid cascaded errors)\n+\n+      elsif Errors_Detected /= 0 then\n+         return;\n+\n+      --  Nothing to do if not in full analysis mode\n+\n+      elsif not Full_Analysis then\n+         return;\n+\n+      --  Nothing to do if inside a generic template\n+\n+      elsif Inside_A_Generic then\n+         return;\n+\n+      --  Nothing to do if a library level instantiation\n+\n+      elsif Nkind (Parent (N)) = N_Compilation_Unit then\n+         return;\n+\n+      --  Nothing to do if we are compiling a proper body for semantic\n+      --  purposes only. The generic body may be in another proper body.\n+\n+      elsif\n+        Nkind (Parent (Unit_Declaration_Node (Main_Unit_Entity))) = N_Subunit\n+      then\n+         return;\n+      end if;\n+\n+      Nam := Name (N);\n+      Ent := Entity (Nam);\n+\n+      --  The case we are interested in is when the generic spec is in the\n+      --  current declarative part\n+\n+      if not Same_Elaboration_Scope (Current_Scope, Scope (Ent))\n+        or else not In_Same_Extended_Unit (Sloc (N), Sloc (Ent))\n+      then\n+         return;\n+      end if;\n+\n+      --  If the generic entity is within a deeper instance than we are, then\n+      --  either the instantiation to which we refer itself caused an ABE, in\n+      --  which case that will be handled separately. Otherwise, we know that\n+      --  the body we need appears as needed at the point of the instantiation.\n+      --  If they are both at the same level but not within the same instance\n+      --  then the body of the generic will be in the earlier instance.\n+\n+      declare\n+         D1 : constant Int := Instantiation_Depth (Sloc (Ent));\n+         D2 : constant Int := Instantiation_Depth (Sloc (N));\n+\n+      begin\n+         if D1 > D2 then\n+            return;\n+\n+         elsif D1 = D2\n+           and then Is_Generic_Instance (Scope (Ent))\n+           and then not In_Open_Scopes (Scope (Ent))\n+         then\n+            return;\n+         end if;\n+      end;\n+\n+      --  Now we can proceed, if the entity being called has a completion,\n+      --  then we are definitely OK, since we have already seen the body.\n+\n+      if Has_Completion (Ent) then\n+         return;\n+      end if;\n+\n+      --  If there is no body, then nothing to do\n+\n+      if not Has_Generic_Body (N) then\n+         return;\n+      end if;\n+\n+      --  Here we definitely have a bad instantiation\n+\n+      Error_Msg_NE\n+        (\"?cannot instantiate& before body seen\", N, Ent);\n+\n+      if Present (Instance_Spec (N)) then\n+         Supply_Bodies (Instance_Spec (N));\n+      end if;\n+\n+      Error_Msg_N\n+        (\"\\?Program_Error will be raised at run time\", N);\n+      Insert_Elab_Check (N);\n+      Set_ABE_Is_Certain (N);\n+\n+   end Check_Bad_Instantiation;\n+\n+   ---------------------\n+   -- Check_Elab_Call --\n+   ---------------------\n+\n+   procedure Check_Elab_Call\n+     (N           : Node_Id;\n+      Outer_Scope : Entity_Id := Empty)\n+   is\n+      Nam : Node_Id;\n+      Ent : Entity_Id;\n+      P   : Node_Id;\n+\n+   begin\n+      --  For an entry call, check relevant restriction\n+\n+      if Nkind (N) = N_Entry_Call_Statement\n+         and then not In_Subprogram_Or_Concurrent_Unit\n+      then\n+         Check_Restriction (No_Entry_Calls_In_Elaboration_Code, N);\n+\n+      --  Nothing to do if this is not a call (happens in some error\n+      --  conditions, and in some cases where rewriting occurs).\n+\n+      elsif Nkind (N) /= N_Function_Call\n+        and then Nkind (N) /= N_Procedure_Call_Statement\n+      then\n+         return;\n+\n+      --  Nothing to do if this is a call already rewritten for elab checking.\n+\n+      elsif Nkind (Parent (N)) = N_Conditional_Expression then\n+         return;\n+\n+      --  Nothing to do if inside a generic template\n+\n+      elsif Inside_A_Generic\n+        and then not Present (Enclosing_Generic_Body (N))\n+      then\n+         return;\n+      end if;\n+\n+      --  Here we have a call at elaboration time which must be checked\n+\n+      if Debug_Flag_LL then\n+         Write_Str (\"  Check_Elab_Call: \");\n+\n+         if No (Name (N))\n+           or else not Is_Entity_Name (Name (N))\n+         then\n+            Write_Str (\"<<not entity name>> \");\n+         else\n+            Write_Name (Chars (Entity (Name (N))));\n+         end if;\n+\n+         Write_Str (\"  call at \");\n+         Write_Location (Sloc (N));\n+         Write_Eol;\n+      end if;\n+\n+      --  Climb up the tree to make sure we are not inside a\n+      --  default expression of a parameter specification or\n+      --  a record component, since in both these cases, we\n+      --  will be doing the actual call later, not now, and it\n+      --  is at the time of the actual call (statically speaking)\n+      --  that we must do our static check, not at the time of\n+      --  its initial analysis).\n+\n+      P := Parent (N);\n+      while Present (P) loop\n+         if Nkind (P) = N_Parameter_Specification\n+              or else\n+            Nkind (P) = N_Component_Declaration\n+         then\n+            return;\n+         else\n+            P := Parent (P);\n+         end if;\n+      end loop;\n+\n+      --  Stuff that happens only at the outer level\n+\n+      if No (Outer_Scope) then\n+         Elab_Visited.Set_Last (0);\n+\n+         --  Nothing to do if current scope is Standard (this is a bit\n+         --  odd, but it happens in the case of generic instantiations).\n+\n+         C_Scope := Current_Scope;\n+\n+         if C_Scope = Standard_Standard then\n+            return;\n+         end if;\n+\n+         --  First case, we are in elaboration code\n+\n+         From_Elab_Code := not In_Subprogram_Or_Concurrent_Unit;\n+\n+         if From_Elab_Code then\n+\n+            --  Complain if call that comes from source in preelaborated\n+            --  unit and we are not inside a subprogram (i.e. we are in\n+            --  elab code)\n+\n+            if Comes_From_Source (N)\n+              and then In_Preelaborated_Unit\n+            then\n+               Error_Msg_N\n+                 (\"non-static call not allowed in preelaborated unit\", N);\n+               return;\n+            end if;\n+\n+         --  Second case, we are inside a subprogram or concurrent unit\n+         --  i.e, we are not in elaboration code.\n+\n+         else\n+            --  In this case, the issue is whether we are inside the\n+            --  declarative part of the unit in which we live, or inside\n+            --  its statements. In the latter case, there is no issue of\n+            --  ABE calls at this level (a call from outside to the unit\n+            --  in which we live might cause an ABE, but that will be\n+            --  detected when we analyze that outer level call, as it\n+            --  recurses into the called unit).\n+\n+            --  Climb up the tree, doing this test, and also testing\n+            --  for being inside a default expression, which, as\n+            --  discussed above, is not checked at this stage.\n+\n+            declare\n+               P : Node_Id;\n+               L : List_Id;\n+\n+            begin\n+               P := N;\n+               loop\n+                  --  If we find a parentless subtree, it seems safe to\n+                  --  assume that we are not in a declarative part and\n+                  --  that no checking is required.\n+\n+                  if No (P) then\n+                     return;\n+                  end if;\n+\n+                  if Is_List_Member (P) then\n+                     L := List_Containing (P);\n+                     P := Parent (L);\n+                  else\n+                     L := No_List;\n+                     P := Parent (P);\n+                  end if;\n+\n+                  exit when Nkind (P) = N_Subunit;\n+\n+                  --  Filter out case of default expressions, where\n+                  --  we do not do the check at this stage.\n+\n+                  if Nkind (P) = N_Parameter_Specification\n+                       or else\n+                     Nkind (P) = N_Component_Declaration\n+                  then\n+                     return;\n+                  end if;\n+\n+                  if Nkind (P) = N_Subprogram_Body\n+                       or else\n+                     Nkind (P) = N_Protected_Body\n+                       or else\n+                     Nkind (P) = N_Task_Body\n+                       or else\n+                     Nkind (P) = N_Block_Statement\n+                  then\n+                     if L = Declarations (P) then\n+                        exit;\n+\n+                     --  We are not in elaboration code, but we are doing\n+                     --  dynamic elaboration checks, in this case, we still\n+                     --  need to do the call, since the subprogram we are in\n+                     --  could be called from another unit, also in dynamic\n+                     --  elaboration check mode, at elaboration time.\n+\n+                     elsif Dynamic_Elaboration_Checks then\n+\n+                        --  This is a rather new check, going into version\n+                        --  3.14a1 for the first time (V1.80 of this unit),\n+                        --  so we provide a debug flag to enable it. That\n+                        --  way we have an easy work around for regressions\n+                        --  that are caused by this new check. This debug\n+                        --  flag can be removed later.\n+\n+                        if Debug_Flag_DD then\n+                           return;\n+                        end if;\n+\n+                        --  Do the check in this case\n+\n+                        exit;\n+\n+                     --  Static model, call is not in elaboration code, we\n+                     --  never need to worry, because in the static model\n+                     --  the top level caller always takes care of things.\n+\n+                     else\n+                        return;\n+                     end if;\n+                  end if;\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+\n+      --  Retrieve called entity. If this is a call to a protected subprogram,\n+      --  the entity is a selected component.\n+      --  The callable entity may be absent, in which case there is nothing\n+      --  to do. This happens with non-analyzed calls in nested generics.\n+\n+      Nam := Name (N);\n+\n+      if No (Nam) then\n+         return;\n+\n+      elsif Nkind (Nam) = N_Selected_Component then\n+         Ent := Entity (Selector_Name (Nam));\n+\n+      elsif not Is_Entity_Name (Nam) then\n+         return;\n+\n+      else\n+         Ent := Entity (Nam);\n+      end if;\n+\n+      if No (Ent) then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if this is a recursive call (i.e. a call to\n+      --  an entity that is already in the Elab_Call stack)\n+\n+      for J in 1 .. Elab_Visited.Last loop\n+         if Ent = Elab_Visited.Table (J) then\n+            return;\n+         end if;\n+      end loop;\n+\n+      --  See if we need to analyze this call. We analyze it if either of\n+      --  the following conditions is met:\n+\n+      --    It is an inner level call (since in this case it was triggered\n+      --    by an outer level call from elaboration code), but only if the\n+      --    call is within the scope of the original outer level call.\n+\n+      --    It is an outer level call from elaboration code, or the called\n+      --    entity is in the same elaboration scope.\n+\n+      --  And in these cases, we will check both inter-unit calls and\n+      --  intra-unit (within a single unit) calls.\n+\n+      C_Scope := Current_Scope;\n+\n+      --  If not outer level call, then we follow it if it is within\n+      --  the original scope of the outer call.\n+\n+      if Present (Outer_Scope)\n+        and then Within (Scope (Ent), Outer_Scope)\n+      then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Outer_Scope, Inter_Unit_Only => False);\n+\n+      elsif Elaboration_Checks_Suppressed (Current_Scope) then\n+         null;\n+\n+      elsif From_Elab_Code then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Standard_Standard, Inter_Unit_Only => False);\n+\n+      elsif Same_Elaboration_Scope (C_Scope, Scope (Ent)) then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Scope (Ent), Inter_Unit_Only => False);\n+\n+      --  If none of those cases holds, but Dynamic_Elaboration_Checks mode\n+      --  is set, then we will do the check, but only in the inter-unit case\n+      --  (this is to accomodate unguarded elaboration calls from other units\n+      --  in which this same mode is set). We don't want warnings in this case,\n+      --  it would generate warnings having nothing to do with elaboration.\n+\n+      elsif Dynamic_Elaboration_Checks then\n+         Set_C_Scope;\n+         Check_A_Call\n+           (N,\n+            Ent,\n+            Standard_Standard,\n+            Inter_Unit_Only => True,\n+            Generate_Warnings => False);\n+\n+      else\n+         return;\n+      end if;\n+   end Check_Elab_Call;\n+\n+   ----------------------\n+   -- Check_Elab_Calls --\n+   ----------------------\n+\n+   procedure Check_Elab_Calls is\n+   begin\n+      --  If expansion is disabled, do not generate any checks. Also\n+      --  skip checks if any subunits are missing because in either\n+      --  case we lack the full information that we need, and no object\n+      --  file will be created in any case.\n+\n+      if not Expander_Active or else Subunits_Missing then\n+         return;\n+      end if;\n+\n+      --  Skip delayed calls if we had any errors\n+\n+      if Errors_Detected = 0 then\n+         Delaying_Elab_Checks := False;\n+         Expander_Mode_Save_And_Set (True);\n+\n+         for J in Delay_Check.First .. Delay_Check.Last loop\n+            New_Scope (Delay_Check.Table (J).Curscop);\n+            From_Elab_Code := Delay_Check.Table (J).From_Elab_Code;\n+\n+            Check_Internal_Call_Continue (\n+              N           => Delay_Check.Table (J).N,\n+              E           => Delay_Check.Table (J).E,\n+              Outer_Scope => Delay_Check.Table (J).Outer_Scope,\n+              Orig_Ent    => Delay_Check.Table (J).Orig_Ent);\n+\n+            Pop_Scope;\n+         end loop;\n+\n+         --  Set Delaying_Elab_Checks back on for next main compilation\n+\n+         Expander_Mode_Restore;\n+         Delaying_Elab_Checks := True;\n+      end if;\n+   end Check_Elab_Calls;\n+\n+   ------------------------------\n+   -- Check_Elab_Instantiation --\n+   ------------------------------\n+\n+   procedure Check_Elab_Instantiation\n+     (N           : Node_Id;\n+      Outer_Scope : Entity_Id := Empty)\n+   is\n+      Nam     : Node_Id;\n+      Ent     : Entity_Id;\n+\n+   begin\n+      --  Check for and deal with bad instantiation case. There is some\n+      --  duplicated code here, but we will worry about this later ???\n+\n+      Check_Bad_Instantiation (N);\n+\n+      if ABE_Is_Certain (N) then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if we do not have an instantiation (happens in some\n+      --  error cases, and also in the formal package declaration case)\n+\n+      if Nkind (N) not in N_Generic_Instantiation then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if inside a generic template\n+\n+      if Inside_A_Generic then\n+         return;\n+      end if;\n+\n+      Nam := Name (N);\n+      Ent := Entity (Nam);\n+      From_Elab_Code := not In_Subprogram_Or_Concurrent_Unit;\n+\n+      --  See if we need to analyze this instantiation. We analyze it if\n+      --  either of the following conditions is met:\n+\n+      --    It is an inner level instantiation (since in this case it was\n+      --    triggered by an outer level call from elaboration code), but\n+      --    only if the instantiation is within the scope of the original\n+      --    outer level call.\n+\n+      --    It is an outer level instantiation from elaboration code, or the\n+      --    instantiated entity is in the same elaboratoin scope.\n+\n+      --  And in these cases, we will check both the inter-unit case and\n+      --  the intra-unit (within a single unit) case.\n+\n+      C_Scope := Current_Scope;\n+\n+      if Present (Outer_Scope)\n+        and then Within (Scope (Ent), Outer_Scope)\n+      then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Outer_Scope, Inter_Unit_Only => False);\n+\n+      elsif From_Elab_Code then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Standard_Standard, Inter_Unit_Only => False);\n+\n+      elsif Same_Elaboration_Scope (C_Scope, Scope (Ent)) then\n+         Set_C_Scope;\n+         Check_A_Call (N, Ent, Scope (Ent), Inter_Unit_Only => False);\n+\n+      --  If none of those cases holds, but Dynamic_Elaboration_Checks mode\n+      --  is set, then we will do the check, but only in the inter-unit case\n+      --  (this is to accomodate unguarded elaboration calls from other units\n+      --  in which this same mode is set). We inhibit warnings in this case,\n+      --  since this instantiation is not occurring in elaboration code.\n+\n+      elsif Dynamic_Elaboration_Checks then\n+         Set_C_Scope;\n+         Check_A_Call\n+           (N,\n+            Ent,\n+            Standard_Standard,\n+            Inter_Unit_Only => True,\n+            Generate_Warnings => False);\n+\n+      else\n+         return;\n+      end if;\n+   end Check_Elab_Instantiation;\n+\n+   -------------------------\n+   -- Check_Internal_Call --\n+   -------------------------\n+\n+   procedure Check_Internal_Call\n+     (N           : Node_Id;\n+      E           : Entity_Id;\n+      Outer_Scope : Entity_Id;\n+      Orig_Ent    : Entity_Id)\n+   is\n+      Inst_Case : constant Boolean := Nkind (N) in N_Generic_Instantiation;\n+\n+   begin\n+      --  If not function or procedure call or instantiation, then ignore\n+      --  call (this happens in some error case and rewriting cases)\n+\n+      if Nkind (N) /= N_Function_Call\n+           and then\n+         Nkind (N) /= N_Procedure_Call_Statement\n+           and then\n+         not Inst_Case\n+      then\n+         return;\n+\n+      --  Nothing to do if this is a call or instantiation that has\n+      --  already been found to be a sure ABE\n+\n+      elsif ABE_Is_Certain (N) then\n+         return;\n+\n+      --  Nothing to do if errors already detected (avoid cascaded errors)\n+\n+      elsif Errors_Detected /= 0 then\n+         return;\n+\n+      --  Nothing to do if not in full analysis mode\n+\n+      elsif not Full_Analysis then\n+         return;\n+\n+      --  Nothing to do if within a default expression, since the call\n+      --  is not actualy being made at this time.\n+\n+      elsif In_Default_Expression then\n+         return;\n+\n+      --  Nothing to do for call to intrinsic subprogram\n+\n+      elsif Is_Intrinsic_Subprogram (E) then\n+         return;\n+\n+      --  No need to trace local calls if checking task activation, because\n+      --  other local bodies are elaborated already.\n+\n+      elsif In_Task_Activation then\n+         return;\n+      end if;\n+\n+      --  Delay this call if we are still delaying calls\n+\n+      if Delaying_Elab_Checks then\n+         Delay_Check.Increment_Last;\n+         Delay_Check.Table (Delay_Check.Last) :=\n+           (N              => N,\n+            E              => E,\n+            Orig_Ent       => Orig_Ent,\n+            Curscop        => Current_Scope,\n+            Outer_Scope    => Outer_Scope,\n+            From_Elab_Code => From_Elab_Code);\n+         return;\n+\n+      --  Otherwise, call phase 2 continuation right now\n+\n+      else\n+         Check_Internal_Call_Continue (N, E, Outer_Scope, Orig_Ent);\n+      end if;\n+\n+   end Check_Internal_Call;\n+\n+   ----------------------------------\n+   -- Check_Internal_Call_Continue --\n+   ----------------------------------\n+\n+   procedure Check_Internal_Call_Continue\n+     (N           : Node_Id;\n+      E           : Entity_Id;\n+      Outer_Scope : Entity_Id;\n+      Orig_Ent    : Entity_Id)\n+   is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Inst_Case : constant Boolean := Is_Generic_Unit (E);\n+\n+      Sbody : Node_Id;\n+      Ebody : Entity_Id;\n+\n+      function Process (N : Node_Id) return Traverse_Result;\n+      --  Function applied to each node as we traverse the body.\n+      --  Checks for call that needs checking, and if so checks\n+      --  it. Always returns OK, so entire tree is traversed.\n+\n+      function Process (N : Node_Id) return Traverse_Result is\n+      begin\n+         --  If user has specified that there are no entry calls in elaboration\n+         --  code, do not trace past an accept statement, because the rendez-\n+         --  vous will happen after elaboration.\n+\n+         if (Nkind (Original_Node (N)) = N_Accept_Statement\n+              or else Nkind (Original_Node (N)) = N_Selective_Accept)\n+           and then Restrictions (No_Entry_Calls_In_Elaboration_Code)\n+         then\n+            return Abandon;\n+\n+         --  If we have a subprogram call, check it\n+\n+         elsif Nkind (N) = N_Function_Call\n+           or else Nkind (N) = N_Procedure_Call_Statement\n+         then\n+            Check_Elab_Call (N, Outer_Scope);\n+            return OK;\n+\n+         --  If we have a generic instantiation, check it\n+\n+         elsif Nkind (N) in N_Generic_Instantiation then\n+            Check_Elab_Instantiation (N, Outer_Scope);\n+            return OK;\n+\n+         --  Skip subprogram bodies that come from source (wait for\n+         --  call to analyze these). The reason for the come from\n+         --  source test is to avoid catching task bodies.\n+\n+         --  For task bodies, we should really avoid these too, waiting\n+         --  for the task activation, but that's too much trouble to\n+         --  catch for now, so we go in unconditionally. This is not\n+         --  so terrible, it means the error backtrace is not quite\n+         --  complete, and we are too eager to scan bodies of tasks\n+         --  that are unused, but this is hardly very significant!\n+\n+         elsif Nkind (N) = N_Subprogram_Body\n+           and then Comes_From_Source (N)\n+         then\n+            return Skip;\n+\n+         else\n+            return OK;\n+         end if;\n+      end Process;\n+\n+      procedure Traverse is new Atree.Traverse_Proc;\n+      --  Traverse procedure using above Process function\n+\n+   --  Start of processing for Check_Internal_Call_Continue\n+\n+   begin\n+      --  Save outer level call if at outer level\n+\n+      if Elab_Call.Last = 0 then\n+         Outer_Level_Sloc := Loc;\n+      end if;\n+\n+      Elab_Visited.Increment_Last;\n+      Elab_Visited.Table (Elab_Visited.Last) := E;\n+\n+      --  If the call is to a function that renames a literal, no check\n+      --  is needed.\n+\n+      if Ekind (E) = E_Enumeration_Literal then\n+         return;\n+      end if;\n+\n+      Sbody := Unit_Declaration_Node (E);\n+\n+      if Nkind (Sbody) /= N_Subprogram_Body\n+           and then\n+         Nkind (Sbody) /= N_Package_Body\n+      then\n+         Ebody := Corresponding_Body (Sbody);\n+\n+         if No (Ebody) then\n+            return;\n+         else\n+            Sbody := Unit_Declaration_Node (Ebody);\n+         end if;\n+      end if;\n+\n+      --  If the body appears after the outer level call or\n+      --  instantiation then we have an error case handled below.\n+\n+      if Earlier_In_Extended_Unit (Outer_Level_Sloc, Sloc (Sbody))\n+        and then not In_Task_Activation\n+      then\n+         null;\n+\n+      --  If we have the instantiation case we are done, since we now\n+      --  know that the body of the generic appeared earlier.\n+\n+      elsif Inst_Case then\n+         return;\n+\n+      --  Otherwise we have a call, so we trace through the called\n+      --  body to see if it has any problems ..\n+\n+      else\n+         pragma Assert (Nkind (Sbody) = N_Subprogram_Body);\n+\n+         Elab_Call.Increment_Last;\n+         Elab_Call.Table (Elab_Call.Last).Cloc := Loc;\n+         Elab_Call.Table (Elab_Call.Last).Ent  := E;\n+\n+         if Debug_Flag_LL then\n+            Write_Str (\"Elab_Call.Last = \");\n+            Write_Int (Int (Elab_Call.Last));\n+            Write_Str (\"   Ent = \");\n+            Write_Name (Chars (E));\n+            Write_Str (\"   at \");\n+            Write_Location (Sloc (N));\n+            Write_Eol;\n+         end if;\n+\n+         --  Now traverse declarations and statements of subprogram body.\n+         --  Note that we cannot simply Traverse (Sbody), since traverse\n+         --  does not normally visit subprogram bodies.\n+\n+         declare\n+            Decl : Node_Id := First (Declarations (Sbody));\n+\n+         begin\n+            while Present (Decl) loop\n+               Traverse (Decl);\n+               Next (Decl);\n+            end loop;\n+         end;\n+\n+         Traverse (Handled_Statement_Sequence (Sbody));\n+\n+         Elab_Call.Decrement_Last;\n+         return;\n+      end if;\n+\n+      --  Here is the case of calling a subprogram where the body has\n+      --  not yet been encountered, a warning message is needed.\n+\n+      Warn_On_Instance := True;\n+\n+      --  If we have nothing in the call stack, then this is at the\n+      --  outer level, and the ABE is bound to occur.\n+\n+      if Elab_Call.Last = 0 then\n+\n+         if Inst_Case then\n+            Error_Msg_NE\n+              (\"?cannot instantiate& before body seen\", N, Orig_Ent);\n+         else\n+            Error_Msg_NE\n+              (\"?cannot call& before body seen\", N, Orig_Ent);\n+         end if;\n+\n+         Error_Msg_N\n+           (\"\\?Program_Error will be raised at run time\", N);\n+         Insert_Elab_Check (N);\n+\n+      --  Call is not at outer level\n+\n+      else\n+         --  Deal with dynamic elaboration check\n+\n+         if not Elaboration_Checks_Suppressed (E) then\n+            Set_Elaboration_Entity_Required (E);\n+\n+            --  Case of no elaboration entity allocated yet\n+\n+            if No (Elaboration_Entity (E)) then\n+\n+               --  Create object declaration for elaboration entity, and put it\n+               --  just in front of the spec of the subprogram or generic unit,\n+               --  in the same scope as this unit.\n+\n+               declare\n+                  Loce : constant Source_Ptr := Sloc (E);\n+                  Ent  : constant Entity_Id  :=\n+                           Make_Defining_Identifier (Loc,\n+                             Chars => New_External_Name (Chars (E), 'E'));\n+\n+               begin\n+                  Set_Elaboration_Entity (E, Ent);\n+                  New_Scope (Scope (E));\n+\n+                  Insert_Action (Declaration_Node (E),\n+                    Make_Object_Declaration (Loce,\n+                      Defining_Identifier => Ent,\n+                      Object_Definition =>\n+                        New_Occurrence_Of (Standard_Boolean, Loce),\n+                      Expression => New_Occurrence_Of (Standard_False, Loce)));\n+\n+                  --  Set elaboration flag at the point of the body\n+\n+                  Set_Elaboration_Flag (Sbody, E);\n+\n+                  Pop_Scope;\n+               end;\n+            end if;\n+\n+            --  Generate check of the elaboration Boolean\n+\n+            Insert_Elab_Check (N,\n+              New_Occurrence_Of (Elaboration_Entity (E), Loc));\n+         end if;\n+\n+         --  Generate the warning\n+\n+         if not Suppress_Elaboration_Warnings (E) then\n+            if Inst_Case then\n+               Error_Msg_NE\n+                 (\"instantiation of& may occur before body is seen?\",\n+                  N, Orig_Ent);\n+            else\n+               Error_Msg_NE\n+                 (\"call to& may occur before body is seen?\", N, Orig_Ent);\n+            end if;\n+\n+            Error_Msg_N\n+              (\"\\Program_Error may be raised at run time?\", N);\n+\n+            Output_Calls (N);\n+         end if;\n+      end if;\n+\n+      Warn_On_Instance := False;\n+\n+      --  Set flag to suppress further warnings on same subprogram\n+      --  unless in all errors mode\n+\n+      if not All_Errors_Mode then\n+         Set_Suppress_Elaboration_Warnings (E);\n+      end if;\n+   end Check_Internal_Call_Continue;\n+\n+   ----------------------------\n+   --  Check_Task_Activation --\n+   ----------------------------\n+\n+   procedure Check_Task_Activation (N : Node_Id) is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Ent         : Entity_Id;\n+      P           : Entity_Id;\n+      Task_Scope  : Entity_Id;\n+      Cunit_SC    : Boolean := False;\n+      Decl        : Node_Id;\n+      Elmt        : Elmt_Id;\n+      Inter_Procs : Elist_Id := New_Elmt_List;\n+      Intra_Procs : Elist_Id := New_Elmt_List;\n+      Enclosing   : Entity_Id;\n+\n+      procedure Add_Task_Proc (Typ : Entity_Id);\n+      --  Add to Task_Procs the task body procedure(s) of task types in Typ.\n+      --  For record types, this procedure recurses over component types.\n+\n+      procedure Collect_Tasks (Decls : List_Id);\n+      --  Collect the types of the tasks that are to be activated in the given\n+      --  list of declarations, in order to perform elaboration checks on the\n+      --  corresponding task procedures which are called implicitly here.\n+\n+      function Outer_Unit (E : Entity_Id) return Entity_Id;\n+      --  find enclosing compilation unit of Entity, ignoring subunits, or\n+      --  else enclosing subprogram. If E is not a package, there is no need\n+      --  for inter-unit elaboration checks.\n+\n+      -------------------\n+      -- Add_Task_Proc --\n+      -------------------\n+\n+      procedure Add_Task_Proc (Typ : Entity_Id) is\n+         Comp : Entity_Id;\n+         Proc : Entity_Id := Empty;\n+\n+      begin\n+         if Is_Task_Type (Typ) then\n+            Proc := Get_Task_Body_Procedure (Typ);\n+\n+         elsif Is_Array_Type (Typ)\n+           and then Has_Task (Base_Type (Typ))\n+         then\n+            Add_Task_Proc (Component_Type (Typ));\n+\n+         elsif Is_Record_Type (Typ)\n+           and then Has_Task (Base_Type (Typ))\n+         then\n+            Comp := First_Component (Typ);\n+\n+            while Present (Comp) loop\n+               Add_Task_Proc (Etype (Comp));\n+               Comp := Next_Component (Comp);\n+            end loop;\n+         end if;\n+\n+         --  If the task type is another unit, we will perform the usual\n+         --  elaboration check on its enclosing unit. If the type is in the\n+         --  same unit, we can trace the task body as for an internal call,\n+         --  but we only need to examine other external calls, because at\n+         --  the point the task is activated, internal subprogram bodies\n+         --  will have been elaborated already. We keep separate lists for\n+         --  each kind of task.\n+\n+         if Present (Proc) then\n+            if Outer_Unit (Scope (Proc)) = Enclosing then\n+\n+               if No (Corresponding_Body (Unit_Declaration_Node (Proc)))\n+                 and then\n+                   (not Is_Generic_Instance (Scope (Proc))\n+                      or else\n+                    Scope (Proc) = Scope (Defining_Identifier (Decl)))\n+               then\n+                  Error_Msg_N\n+                    (\"task will be activated before elaboration of its body?\",\n+                      Decl);\n+                  Error_Msg_N\n+                    (\"Program_Error will be raised at run-time?\", Decl);\n+\n+               elsif\n+                 Present (Corresponding_Body (Unit_Declaration_Node (Proc)))\n+               then\n+                  Append_Elmt (Proc, Intra_Procs);\n+               end if;\n+\n+            else\n+               Elmt := First_Elmt (Inter_Procs);\n+\n+               --  No need for multiple entries of the same type.\n+\n+               while Present (Elmt) loop\n+                  if Node (Elmt) = Proc then\n+                     return;\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+\n+               Append_Elmt (Proc, Inter_Procs);\n+            end if;\n+         end if;\n+      end Add_Task_Proc;\n+\n+      -------------------\n+      -- Collect_Tasks --\n+      -------------------\n+\n+      procedure Collect_Tasks (Decls : List_Id) is\n+      begin\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+\n+            while Present (Decl) loop\n+\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Has_Task (Etype (Defining_Identifier (Decl)))\n+               then\n+                  Add_Task_Proc (Etype (Defining_Identifier (Decl)));\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end if;\n+      end Collect_Tasks;\n+\n+      ----------------\n+      -- Outer_Unit --\n+      ----------------\n+\n+      function Outer_Unit (E : Entity_Id) return Entity_Id is\n+         Outer : Entity_Id := E;\n+\n+      begin\n+         while Present (Outer) loop\n+            if Suppress_Elaboration_Checks (Outer) then\n+               Cunit_SC := True;\n+            end if;\n+\n+            exit when Is_Child_Unit (Outer)\n+              or else Scope (Outer) = Standard_Standard\n+              or else Ekind (Outer) /= E_Package;\n+            Outer := Scope (Outer);\n+         end loop;\n+\n+         return Outer;\n+      end Outer_Unit;\n+\n+   --  Start of processing for Check_Task_Activation\n+\n+   begin\n+      Enclosing := Outer_Unit (Current_Scope);\n+\n+      --  Find all tasks declared in the current unit.\n+\n+      if Nkind (N) = N_Package_Body then\n+         P := Unit_Declaration_Node (Corresponding_Spec (N));\n+\n+         Collect_Tasks (Declarations (N));\n+         Collect_Tasks (Visible_Declarations (Specification (P)));\n+         Collect_Tasks (Private_Declarations (Specification (P)));\n+\n+      elsif Nkind (N) = N_Package_Declaration then\n+         Collect_Tasks (Visible_Declarations (Specification (N)));\n+         Collect_Tasks (Private_Declarations (Specification (N)));\n+\n+      else\n+         Collect_Tasks (Declarations (N));\n+      end if;\n+\n+      --  We only perform detailed checks in all tasks are library level\n+      --  entities. If the master is a subprogram or task, activation will\n+      --  depend on the activation of the master itself.\n+      --  Should dynamic checks be added in the more general case???\n+\n+      if Ekind (Enclosing) /= E_Package then\n+         return;\n+      end if;\n+\n+      --  For task types defined in other units, we want the unit containing\n+      --  the task body to be elaborated before the current one.\n+\n+      Elmt := First_Elmt (Inter_Procs);\n+\n+      while Present (Elmt) loop\n+         Ent := Node (Elmt);\n+         Task_Scope := Outer_Unit (Scope (Ent));\n+\n+         if not Is_Compilation_Unit (Task_Scope) then\n+            null;\n+\n+         elsif Suppress_Elaboration_Warnings (Task_Scope) then\n+            null;\n+\n+         elsif Dynamic_Elaboration_Checks then\n+            if not Elaboration_Checks_Suppressed (Ent)\n+              and then not Cunit_SC\n+              and then not Restrictions (No_Entry_Calls_In_Elaboration_Code)\n+            then\n+               --  Runtime elaboration check required. generate check of the\n+               --  elaboration Boolean for the unit containing the entity.\n+\n+               Insert_Elab_Check (N,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Elaborated,\n+                   Prefix =>\n+                     New_Occurrence_Of\n+                       (Spec_Entity (Task_Scope), Loc)));\n+            end if;\n+\n+         else\n+            --  Force the binder to elaborate other unit first.\n+\n+            if not Suppress_Elaboration_Warnings (Ent)\n+              and then Elab_Warnings\n+              and then not Suppress_Elaboration_Warnings (Task_Scope)\n+            then\n+               Error_Msg_Node_2 := Task_Scope;\n+               Error_Msg_NE (\"activation of an instance of task type&\" &\n+                  \" requires pragma Elaborate_All on &?\", N, Ent);\n+            end if;\n+\n+            Set_Elaborate_All_Desirable (Task_Scope);\n+            Set_Suppress_Elaboration_Warnings (Task_Scope);\n+         end if;\n+\n+         Next_Elmt (Elmt);\n+      end loop;\n+\n+      --  For tasks declared in the current unit, trace other calls within\n+      --  the task procedure bodies, which are available.\n+\n+      In_Task_Activation := True;\n+      Elmt := First_Elmt (Intra_Procs);\n+\n+      while Present (Elmt) loop\n+         Ent := Node (Elmt);\n+         Check_Internal_Call_Continue (N, Ent, Enclosing, Ent);\n+         Next_Elmt (Elmt);\n+      end loop;\n+\n+      In_Task_Activation := False;\n+   end Check_Task_Activation;\n+\n+   ----------------------\n+   -- Has_Generic_Body --\n+   ----------------------\n+\n+   function Has_Generic_Body (N : Node_Id) return Boolean is\n+      Ent  : constant Entity_Id := Entity (Name (N));\n+      Decl : constant Node_Id   := Unit_Declaration_Node (Ent);\n+      Scop : Entity_Id;\n+\n+      function Find_Body_In (E : Entity_Id; N : Node_Id) return Node_Id;\n+      --  Determine if the list of nodes headed by N and linked by Next\n+      --  contains a package body for the package spec entity E, and if\n+      --  so return the package body. If not, then returns Empty.\n+\n+      function Load_Package_Body (Nam : Unit_Name_Type) return Node_Id;\n+      --  This procedure is called load the unit whose name is given by Nam.\n+      --  This unit is being loaded to see whether it contains an optional\n+      --  generic body. The returned value is the loaded unit, which is\n+      --  always a package body (only package bodies can contain other\n+      --  entities in the sense in which Has_Generic_Body is interested).\n+      --  We only attempt to load bodies if we are generating code. If we\n+      --  are in semantics check only mode, then it would be wrong to load\n+      --  bodies that are not required from a semantic point of view, so\n+      --  in this case we return Empty. The result is that the caller may\n+      --  incorrectly decide that a generic spec does not have a body when\n+      --  in fact it does, but the only harm in this is that some warnings\n+      --  on elaboration problems may be lost in semantic checks only mode,\n+      --  which is not big loss. We also return Empty if we go for a body\n+      --  and it is not there.\n+\n+      function Locate_Corresponding_Body (PE : Entity_Id) return Node_Id;\n+      --  PE is the entity for a package spec. This function locates the\n+      --  corresponding package body, returning Empty if none is found.\n+      --  The package body returned is fully parsed but may not yet be\n+      --  analyzed, so only syntactic fields should be referenced.\n+\n+      ------------------\n+      -- Find_Body_In --\n+      ------------------\n+\n+      function Find_Body_In (E : Entity_Id; N : Node_Id) return Node_Id is\n+         Nod : Node_Id;\n+\n+      begin\n+         Nod := N;\n+         while Present (Nod) loop\n+\n+            --  If we found the package body we are looking for, return it\n+\n+            if Nkind (Nod) = N_Package_Body\n+              and then Chars (Defining_Unit_Name (Nod)) = Chars (E)\n+            then\n+               return Nod;\n+\n+            --  If we found the stub for the body, go after the subunit,\n+            --  loading it if necessary.\n+\n+            elsif Nkind (Nod) = N_Package_Body_Stub\n+              and then Chars (Defining_Identifier (Nod)) = Chars (E)\n+            then\n+               if Present (Library_Unit (Nod)) then\n+                  return Unit (Library_Unit (Nod));\n+\n+               else\n+                  return Load_Package_Body (Get_Unit_Name (Nod));\n+               end if;\n+\n+            --  If neither package body nor stub, keep looking on chain\n+\n+            else\n+               Next (Nod);\n+            end if;\n+         end loop;\n+\n+         return Empty;\n+      end Find_Body_In;\n+\n+      -----------------------\n+      -- Load_Package_Body --\n+      -----------------------\n+\n+      function Load_Package_Body (Nam : Unit_Name_Type) return Node_Id is\n+         U : Unit_Number_Type;\n+\n+      begin\n+         if Operating_Mode /= Generate_Code then\n+            return Empty;\n+         else\n+            U :=\n+              Load_Unit\n+                (Load_Name  => Nam,\n+                 Required   => False,\n+                 Subunit    => False,\n+                 Error_Node => N);\n+\n+            if U = No_Unit then\n+               return Empty;\n+            else\n+               return Unit (Cunit (U));\n+            end if;\n+         end if;\n+      end Load_Package_Body;\n+\n+      -------------------------------\n+      -- Locate_Corresponding_Body --\n+      -------------------------------\n+\n+      function Locate_Corresponding_Body (PE : Entity_Id) return Node_Id is\n+         Spec  : constant Node_Id   := Declaration_Node (PE);\n+         Decl  : constant Node_Id   := Parent (Spec);\n+         Scop  : constant Entity_Id := Scope (PE);\n+         PBody : Node_Id;\n+\n+      begin\n+         if Is_Library_Level_Entity (PE) then\n+\n+            --  If package is a library unit that requires a body, we have\n+            --  no choice but to go after that body because it might contain\n+            --  an optional body for the original generic package.\n+\n+            if Unit_Requires_Body (PE) then\n+\n+               --  Load the body. Note that we are a little careful here to\n+               --  use Spec to get the unit number, rather than PE or Decl,\n+               --  since in the case where the package is itself a library\n+               --  level instantiation, Spec will properly reference the\n+               --  generic template, which is what we really want.\n+\n+               return\n+                 Load_Package_Body\n+                   (Get_Body_Name (Unit_Name (Get_Source_Unit (Spec))));\n+\n+            --  But if the package is a library unit that does NOT require\n+            --  a body, then no body is permitted, so we are sure that there\n+            --  is no body for the original generic package.\n+\n+            else\n+               return Empty;\n+            end if;\n+\n+         --  Otherwise look and see if we are embedded in a further package\n+\n+         elsif Is_Package (Scop) then\n+\n+            --  If so, get the body of the enclosing package, and look in\n+            --  its package body for the package body we are looking for.\n+\n+            PBody := Locate_Corresponding_Body (Scop);\n+\n+            if No (PBody) then\n+               return Empty;\n+            else\n+               return Find_Body_In (PE, First (Declarations (PBody)));\n+            end if;\n+\n+         --  If we are not embedded in a further package, then the body\n+         --  must be in the same declarative part as we are.\n+\n+         else\n+            return Find_Body_In (PE, Next (Decl));\n+         end if;\n+      end Locate_Corresponding_Body;\n+\n+   --  Start of processing for Has_Generic_Body\n+\n+   begin\n+      if Present (Corresponding_Body (Decl)) then\n+         return True;\n+\n+      elsif Unit_Requires_Body (Ent) then\n+         return True;\n+\n+      --  Compilation units cannot have optional bodies\n+\n+      elsif Is_Compilation_Unit (Ent) then\n+         return False;\n+\n+      --  Otherwise look at what scope we are in\n+\n+      else\n+         Scop := Scope (Ent);\n+\n+         --  Case of entity is in other than a package spec, in this case\n+         --  the body, if present, must be in the same declarative part.\n+\n+         if not Is_Package (Scop) then\n+            declare\n+               P : Node_Id;\n+\n+            begin\n+               P := Declaration_Node (Ent);\n+\n+               --  Declaration node may get us a spec, so if so, go to\n+               --  the parent declaration.\n+\n+               while not Is_List_Member (P) loop\n+                  P := Parent (P);\n+               end loop;\n+\n+               return Present (Find_Body_In (Ent, Next (P)));\n+            end;\n+\n+         --  If the entity is in a package spec, then we have to locate\n+         --  the corresponding package body, and look there.\n+\n+         else\n+            declare\n+               PBody : constant Node_Id := Locate_Corresponding_Body (Scop);\n+\n+            begin\n+               if No (PBody) then\n+                  return False;\n+               else\n+                  return\n+                    Present\n+                      (Find_Body_In (Ent, (First (Declarations (PBody)))));\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+   end Has_Generic_Body;\n+\n+   -----------------------\n+   -- Insert_Elab_Check --\n+   -----------------------\n+\n+   procedure Insert_Elab_Check (N : Node_Id; C : Node_Id := Empty) is\n+      Nod : Node_Id;\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      --  If expansion is disabled, do not generate any checks. Also\n+      --  skip checks if any subunits are missing because in either\n+      --  case we lack the full information that we need, and no object\n+      --  file will be created in any case.\n+\n+      if not Expander_Active or else Subunits_Missing then\n+         return;\n+      end if;\n+\n+      --  If we have a generic instantiation, where Instance_Spec is set,\n+      --  then this field points to a generic instance spec that has\n+      --  been inserted before the instantiation node itself, so that\n+      --  is where we want to insert a check.\n+\n+      if Nkind (N) in N_Generic_Instantiation\n+        and then Present (Instance_Spec (N))\n+      then\n+         Nod := Instance_Spec (N);\n+      else\n+         Nod := N;\n+      end if;\n+\n+      --  If we are inserting at the top level, insert in Aux_Decls\n+\n+      if Nkind (Parent (Nod)) = N_Compilation_Unit then\n+         declare\n+            ADN : constant Node_Id := Aux_Decls_Node (Parent (Nod));\n+            R   : Node_Id;\n+\n+         begin\n+            if No (C) then\n+               R :=  Make_Raise_Program_Error (Loc);\n+            else\n+               R := Make_Raise_Program_Error (Loc, Make_Op_Not (Loc, C));\n+            end if;\n+\n+            if No (Declarations (ADN)) then\n+               Set_Declarations (ADN, New_List (R));\n+            else\n+               Append_To (Declarations (ADN), R);\n+            end if;\n+\n+            Analyze (R);\n+         end;\n+\n+      --  Otherwise just insert before the node in question. However, if\n+      --  the context of the call has already been analyzed, an insertion\n+      --  will not work if it depends on subsequent expansion (e.g. a call in\n+      --  a branch of a short-circuit). In that case we replace the call with\n+      --  a conditional expression, or with a Raise if it is unconditional.\n+      --  Unfortunately this does not work if the call has a dynamic size,\n+      --  because gigi regards it as a dynamic-sized temporary. If such a call\n+      --  appears in a short-circuit expression, the elaboration check will be\n+      --  missed (rare enough ???).\n+\n+      else\n+         if Nkind (N) = N_Function_Call\n+           and then Analyzed (Parent (N))\n+           and then Size_Known_At_Compile_Time (Etype (N))\n+         then\n+            declare\n+               Typ : constant Entity_Id := Etype (N);\n+               R   : constant Node_Id   := Make_Raise_Program_Error (Loc);\n+               Chk : constant Boolean   := Do_Range_Check (N);\n+\n+            begin\n+               Set_Etype (R, Typ);\n+\n+               if No (C) then\n+                  Rewrite (N, R);\n+\n+               else\n+                  Rewrite (N,\n+                    Make_Conditional_Expression (Loc,\n+                      Expressions => New_List (C, Relocate_Node (N), R)));\n+               end if;\n+\n+               Analyze_And_Resolve (N, Typ);\n+\n+               --  If the original call requires a range check, so does the\n+               --  conditional expression.\n+\n+               if Chk then\n+                  Enable_Range_Check (N);\n+               else\n+                  Set_Do_Range_Check (N, False);\n+               end if;\n+            end;\n+\n+         else\n+            if No (C) then\n+               Insert_Action (Nod,\n+                  Make_Raise_Program_Error (Loc));\n+            else\n+               Insert_Action (Nod,\n+                  Make_Raise_Program_Error (Loc,\n+                    Condition =>\n+                      Make_Op_Not (Loc,\n+                        Right_Opnd => C)));\n+            end if;\n+         end if;\n+      end if;\n+   end Insert_Elab_Check;\n+\n+   ------------------\n+   -- Output_Calls --\n+   ------------------\n+\n+   procedure Output_Calls (N : Node_Id) is\n+      Ent : Entity_Id;\n+\n+      function Is_Printable_Error_Name (Nm : Name_Id) return Boolean;\n+      --  An internal function, used to determine if a name, Nm, is either\n+      --  a non-internal name, or is an internal name that is printable\n+      --  by the error message circuits (i.e. it has a single upper\n+      --  case letter at the end).\n+\n+      function Is_Printable_Error_Name (Nm : Name_Id) return Boolean is\n+      begin\n+         if not Is_Internal_Name (Nm) then\n+            return True;\n+\n+         elsif Name_Len = 1 then\n+            return False;\n+\n+         else\n+            Name_Len := Name_Len - 1;\n+            return not Is_Internal_Name;\n+         end if;\n+      end Is_Printable_Error_Name;\n+\n+   --  Start of processing for Output_Calls\n+\n+   begin\n+      for J in reverse 1 .. Elab_Call.Last loop\n+         Error_Msg_Sloc := Elab_Call.Table (J).Cloc;\n+\n+         Ent := Elab_Call.Table (J).Ent;\n+\n+         if Is_Generic_Unit (Ent) then\n+            Error_Msg_NE (\"\\?& instantiated #\", N, Ent);\n+\n+         elsif Chars (Ent) = Name_uInit_Proc then\n+            Error_Msg_N (\"\\?initialization procedure called #\", N);\n+\n+         elsif Is_Printable_Error_Name (Chars (Ent)) then\n+            Error_Msg_NE (\"\\?& called #\", N, Ent);\n+\n+         else\n+            Error_Msg_N (\"\\? called #\", N);\n+         end if;\n+      end loop;\n+   end Output_Calls;\n+\n+   ----------------------------\n+   -- Same_Elaboration_Scope --\n+   ----------------------------\n+\n+   function Same_Elaboration_Scope (Scop1, Scop2 : Entity_Id) return Boolean is\n+      S1 : Entity_Id := Scop1;\n+      S2 : Entity_Id := Scop2;\n+\n+   begin\n+      while S1 /= Standard_Standard\n+        and then (Ekind (S1) = E_Package\n+                    or else\n+                  Ekind (S1) = E_Block)\n+      loop\n+         S1 := Scope (S1);\n+      end loop;\n+\n+      while S2 /= Standard_Standard\n+        and then (Ekind (S2) = E_Package\n+                    or else\n+                  Ekind (S2) = E_Protected_Type\n+                    or else\n+                  Ekind (S2) = E_Block)\n+      loop\n+         S2 := Scope (S2);\n+      end loop;\n+\n+      return S1 = S2;\n+   end Same_Elaboration_Scope;\n+\n+   -----------------\n+   -- Set_C_Scope --\n+   -----------------\n+\n+   procedure Set_C_Scope is\n+   begin\n+      while not Is_Compilation_Unit (C_Scope) loop\n+         C_Scope := Scope (C_Scope);\n+      end loop;\n+   end Set_C_Scope;\n+\n+   -----------------\n+   -- Spec_Entity --\n+   -----------------\n+\n+   function Spec_Entity (E : Entity_Id) return Entity_Id is\n+      Decl : Node_Id;\n+\n+   begin\n+      --  Check for case of body entity\n+      --  Why is the check for E_Void needed???\n+\n+      if Ekind (E) = E_Void\n+        or else Ekind (E) = E_Subprogram_Body\n+        or else Ekind (E) = E_Package_Body\n+      then\n+         Decl := E;\n+\n+         loop\n+            Decl := Parent (Decl);\n+            exit when Nkind (Decl) in N_Proper_Body;\n+         end loop;\n+\n+         return Corresponding_Spec (Decl);\n+\n+      else\n+         return E;\n+      end if;\n+   end Spec_Entity;\n+\n+   -------------------\n+   -- Supply_Bodies --\n+   -------------------\n+\n+   procedure Supply_Bodies (N : Node_Id) is\n+   begin\n+      if Nkind (N) = N_Subprogram_Declaration then\n+         declare\n+            Ent : constant Entity_Id := Defining_Unit_Name (Specification (N));\n+\n+         begin\n+            Set_Is_Imported (Ent);\n+            Set_Convention  (Ent, Convention_Stubbed);\n+         end;\n+\n+      elsif Nkind (N) = N_Package_Declaration then\n+         declare\n+            Spec : constant Node_Id := Specification (N);\n+\n+         begin\n+            New_Scope (Defining_Unit_Name (Spec));\n+            Supply_Bodies (Visible_Declarations (Spec));\n+            Supply_Bodies (Private_Declarations (Spec));\n+            Pop_Scope;\n+         end;\n+      end if;\n+   end Supply_Bodies;\n+\n+   procedure Supply_Bodies (L : List_Id) is\n+      Elmt : Node_Id;\n+\n+   begin\n+      if Present (L) then\n+         Elmt := First (L);\n+         while Present (Elmt) loop\n+            Supply_Bodies (Elmt);\n+            Next (Elmt);\n+         end loop;\n+      end if;\n+   end Supply_Bodies;\n+\n+   ------------\n+   -- Within --\n+   ------------\n+\n+   function Within (E1, E2 : Entity_Id) return Boolean is\n+      Scop : Entity_Id;\n+\n+   begin\n+      Scop := E1;\n+\n+      loop\n+         if Scop = E2 then\n+            return True;\n+\n+         elsif Scop = Standard_Standard then\n+            return False;\n+\n+         else\n+            Scop := Scope (Scop);\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Within;\n+\n+end Sem_Elab;"}, {"sha": "87071c2005fd409418a0ab766225daa72d6540af", "filename": "gcc/ada/sem_elab.ads", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,156 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ E L A B                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines used to deal with issuing warnings\n+--  for cases of calls that may require warnings about possible access\n+--  before elaboration.\n+\n+with Types; use Types;\n+\n+package Sem_Elab is\n+\n+   -----------------------------\n+   -- Description of Approach --\n+   -----------------------------\n+\n+   --  Every non-static call that is encountered by Sem_Res results in\n+   --  a call to Check_Elab_Call, with N being the call node, and Outer\n+   --  set to its default value of True.\n+\n+   --  The goal of Check_Elab_Call is to determine whether or not the\n+   --  call in question can generate an access before elaboration\n+   --  error (raising Program_Error) either by directly calling a\n+   --  subprogram whose body has not yet been elaborated, or indirectly,\n+   --  by calling a subprogram whose body has been elaborated, but which\n+   --  contains a call to such a subprogram.\n+\n+   --  The only calls that we need to look at at the outer level are\n+   --  calls that occur in elaboration code. There are two cases. The\n+   --  call can be at the outer level of elaboration code, or it can\n+   --  be within another unit, e.g. the elaboration code of a subprogram.\n+\n+   --  In the case of an elaboration call at the outer level, we must\n+   --  trace all calls to outer level routines either within the current\n+   --  unit or to other units that are with'ed. For calls within the\n+   --  current unit, we can determine if the body has been elaborated\n+   --  or not, and if it has not, then a warning is generated.\n+\n+   --  Note that there are two subcases. If the original call directly\n+   --  calls a subprogram whose body has not been elaborated, then we\n+   --  know that an ABE will take place, and we replace the call by\n+   --  a raise of Program_Error. If the call is indirect, then we don't\n+   --  know that the PE will be raised, since the call might be guarded\n+   --  by a conditional. In this case we set Do_Elab_Check on the call\n+   --  so that a dynamic check is generated, and output a warning.\n+\n+   --  For calls to a subprogram in a with'ed unit, we require that\n+   --  a pragma Elaborate_All or pragma Elaborate be present, or that\n+   --  the referenced unit have a pragma Preelaborate, pragma Pure, or\n+   --  pragma Elaborate_Body. If none of these conditions is met, then\n+   --  a warning is generated that a pragma Elaborate_All may be needed.\n+\n+   --  For the case of an elaboration call at some inner level, we are\n+   --  interested in tracing only calls to subprograms at the same level,\n+   --  i.e. those that can be called during elaboration. Any calls to\n+   --  outer level routines cannot cause ABE's as a result of the original\n+   --  call (there might be an outer level call to the subprogram from\n+   --  outside that causes the ABE, but that gets analyzed separately).\n+\n+   --  Note that we never trace calls to inner level subprograms, since\n+   --  these cannot result in ABE's unless there is an elaboration problem\n+   --  at a lower level, which will be separately detected.\n+\n+   --  Note on pragma Elaborate. The checking here assumes that a pragma\n+   --  Elaborate on a with'ed unit guarantees that subprograms within the\n+   --  unit can be called without causing an ABE. This is not in fact the\n+   --  case since pragma Elaborate does not guarantee the transititive\n+   --  coverage guaranteed by Elaborate_All. However, we leave this issue\n+   --  up to the binder, which has generates warnings if there are possible\n+   --  problems in the use of pragma Elaborate.\n+\n+   --------------------------------------\n+   -- Instantiation Elaboration Errors --\n+   --------------------------------------\n+\n+   --  A special case arises when an instantiation appears in a context\n+   --  that is known to be before the body is elaborated, e.g.\n+\n+   --       generic package x is ...\n+   --       ...\n+   --       package xx is new x;\n+   --       ...\n+   --       package body x is ...\n+\n+   --  In this situation it is certain that an elaboration error will\n+   --  occur, and an unconditional raise Program_Error statement is\n+   --  inserted before the instantiation, and a warning generated.\n+\n+   --  The problem is that in this case we have no place to put the\n+   --  body of the instantiation. We can't put it in the normal place,\n+   --  because it is too early, and will cause errors to occur as a\n+   --  result of referencing entities before they are declared.\n+\n+   --  Our approach in this case is simply to avoid creating the body\n+   --  of the instantiation in such a case. The instantiation spec is\n+   --  modified to include dummy bodies for all subprograms, so that\n+   --  the resulting code does not contain subprogram specs with no\n+   --  corresponding bodies.\n+\n+   procedure Check_Elab_Call (N : Node_Id; Outer_Scope : Entity_Id := Empty);\n+   --  Check a call for possible elaboration problems. N is either an\n+   --  N_Function_Call or N_Procedure_Call_Statement node, and Outer\n+   --  indicates whether this is an outer level call from Sem_Res\n+   --  (Outer_Scope set to Empty), or an internal recursive call\n+   --  (Outer_Scope set to entity of outermost call, see body).\n+\n+   procedure Check_Elab_Calls;\n+   --  Not all the processing for Check_Elab_Call can be done at the time\n+   --  of calls to Check_Elab_Call. This is because for internal calls, we\n+   --  need to wait to complete the check until all generic bodies have been\n+   --  instantiated. The Check_Elab_Calls procedure cleans up these waiting\n+   --  checks. It is called once after the completion of instantiation.\n+\n+   procedure Check_Elab_Instantiation\n+     (N           : Node_Id;\n+      Outer_Scope : Entity_Id := Empty);\n+   --  Check an instantiation for possible elaboration problems. N is an\n+   --  instantiation node (N_Package_Instantiation, N_Function_Instantiation,\n+   --  or N_Procedure_Instantiation), and Outer_Scope indicates if this is\n+   --  an outer level call from Sem_Ch12 (Outer_Scope set to Empty), or an\n+   --  internal recursive call (Outer_Scope set to scope of outermost call,\n+   --  see body for further details). The returned value is relevant only\n+   --  for an outer level call, and is set to False if an elaboration error\n+   --  is bound to occur on the instantiation, and True otherwise. This is\n+   --  used by the caller to signal that the body of the instance should\n+   --  not be generated (see detailed description in body).\n+\n+   procedure Check_Task_Activation (N : Node_Id);\n+   --  at the point at which tasks are activated in a package body, check\n+   --  that the bodies of the tasks are elaborated.\n+\n+end Sem_Elab;"}, {"sha": "e418657ec09593b3df30cced534ae7fc5fa032ae", "filename": "gcc/ada/sem_elim.adb", "status": "added", "additions": 557, "deletions": 0, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,557 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ E L I M                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;   use Atree;\n+with Einfo;   use Einfo;\n+with Errout;  use Errout;\n+with Namet;   use Namet;\n+with Nlists;  use Nlists;\n+with Sinfo;   use Sinfo;\n+with Snames;  use Snames;\n+with Stand;   use Stand;\n+with Stringt; use Stringt;\n+\n+with GNAT.HTable; use GNAT.HTable;\n+package body Sem_Elim is\n+\n+   No_Elimination : Boolean;\n+   --  Set True if no Eliminate pragmas active\n+\n+   ---------------------\n+   -- Data Structures --\n+   ---------------------\n+\n+   --  A single pragma Eliminate is represented by the following record\n+\n+   type Elim_Data;\n+   type Access_Elim_Data is access Elim_Data;\n+\n+   type Names is array (Nat range <>) of Name_Id;\n+   --  Type used to represent set of names. Used for names in Unit_Name\n+   --  and also the set of names in Argument_Types.\n+\n+   type Access_Names is access Names;\n+\n+   type Elim_Data is record\n+\n+      Unit_Name : Access_Names;\n+      --  Unit name, broken down into a set of names (e.g. A.B.C is\n+      --  represented as Name_Id values for A, B, C in sequence).\n+\n+      Entity_Name : Name_Id;\n+      --  Entity name if Entity parameter if present. If no Entity parameter\n+      --  was supplied, then Entity_Node is set to Empty, and the Entity_Name\n+      --  field contains the last identifier name in the Unit_Name.\n+\n+      Entity_Scope : Access_Names;\n+      --  Static scope of the entity within the compilation unit represented by\n+      --  Unit_Name.\n+\n+      Entity_Node : Node_Id;\n+      --  Save node of entity argument, for posting error messages. Set\n+      --  to Empty if there is no entity argument.\n+\n+      Parameter_Types : Access_Names;\n+      --  Set to set of names given for parameter types. If no parameter\n+      --  types argument is present, this argument is set to null.\n+\n+      Result_Type : Name_Id;\n+      --  Result type name if Result_Types parameter present, No_Name if not\n+\n+      Hash_Link : Access_Elim_Data;\n+      --  Link for hash table use\n+\n+      Homonym : Access_Elim_Data;\n+      --  Pointer to next entry with same key\n+\n+   end record;\n+\n+   ----------------\n+   -- Hash_Table --\n+   ----------------\n+\n+   --  Setup hash table using the Entity_Name field as the hash key\n+\n+   subtype Element is Elim_Data;\n+   subtype Elmt_Ptr is Access_Elim_Data;\n+\n+   subtype Key is Name_Id;\n+\n+   type Header_Num is range 0 .. 1023;\n+\n+   Null_Ptr : constant Elmt_Ptr := null;\n+\n+   ----------------------\n+   -- Hash_Subprograms --\n+   ----------------------\n+\n+   package Hash_Subprograms is\n+\n+      function Equal (F1, F2 : Key) return Boolean;\n+      pragma Inline (Equal);\n+\n+      function Get_Key (E : Elmt_Ptr) return Key;\n+      pragma Inline (Get_Key);\n+\n+      function Hash (F : Key) return Header_Num;\n+      pragma Inline (Hash);\n+\n+      function Next (E : Elmt_Ptr) return Elmt_Ptr;\n+      pragma Inline (Next);\n+\n+      procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr);\n+      pragma Inline (Set_Next);\n+\n+   end Hash_Subprograms;\n+\n+   package body Hash_Subprograms is\n+\n+      -----------\n+      -- Equal --\n+      -----------\n+\n+      function Equal (F1, F2 : Key) return Boolean is\n+      begin\n+         return F1 = F2;\n+      end Equal;\n+\n+      -------------\n+      -- Get_Key --\n+      -------------\n+\n+      function Get_Key (E : Elmt_Ptr) return Key is\n+      begin\n+         return E.Entity_Name;\n+      end Get_Key;\n+\n+      ----------\n+      -- Hash --\n+      ----------\n+\n+      function Hash (F : Key) return Header_Num is\n+      begin\n+         return Header_Num (Int (F) mod 1024);\n+      end Hash;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      function Next (E : Elmt_Ptr) return Elmt_Ptr is\n+      begin\n+         return E.Hash_Link;\n+      end Next;\n+\n+      --------------\n+      -- Set_Next --\n+      --------------\n+\n+      procedure Set_Next (E : Elmt_Ptr; Next : Elmt_Ptr) is\n+      begin\n+         E.Hash_Link := Next;\n+      end Set_Next;\n+   end Hash_Subprograms;\n+\n+   package Elim_Hash_Table is new Static_HTable (\n+      Header_Num => Header_Num,\n+      Element    => Element,\n+      Elmt_Ptr   => Elmt_Ptr,\n+      Null_Ptr   => Null_Ptr,\n+      Set_Next   => Hash_Subprograms.Set_Next,\n+      Next       => Hash_Subprograms.Next,\n+      Key        => Key,\n+      Get_Key    => Hash_Subprograms.Get_Key,\n+      Hash       => Hash_Subprograms.Hash,\n+      Equal      => Hash_Subprograms.Equal);\n+\n+   ----------------------\n+   -- Check_Eliminated --\n+   ----------------------\n+\n+   procedure Check_Eliminated (E : Entity_Id) is\n+      Elmt : Access_Elim_Data;\n+      Scop : Entity_Id;\n+      Form : Entity_Id;\n+\n+   begin\n+      if No_Elimination then\n+         return;\n+\n+      --  Elimination of objects and types is not implemented yet.\n+\n+      elsif Ekind (E) not in Subprogram_Kind then\n+         return;\n+      end if;\n+\n+      Elmt := Elim_Hash_Table.Get (Chars (E));\n+\n+      --  Loop through homonyms for this key\n+\n+      while Elmt /= null loop\n+\n+         --  First we check that the name of the entity matches\n+\n+         if Elmt.Entity_Name /= Chars (E) then\n+            goto Continue;\n+         end if;\n+\n+         --  Then we need to see if the static scope matches within the\n+         --  compilation unit.\n+\n+         Scop := Scope (E);\n+         if Elmt.Entity_Scope /= null then\n+            for J in reverse Elmt.Entity_Scope'Range loop\n+               if Elmt.Entity_Scope (J) /= Chars (Scop) then\n+                  goto Continue;\n+               end if;\n+\n+               Scop := Scope (Scop);\n+\n+               if not Is_Compilation_Unit (Scop) and then J = 1 then\n+                  goto Continue;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Now see if compilation unit matches\n+\n+         for J in reverse Elmt.Unit_Name'Range loop\n+            if Elmt.Unit_Name (J) /= Chars (Scop) then\n+               goto Continue;\n+            end if;\n+\n+            Scop := Scope (Scop);\n+\n+            if Scop /= Standard_Standard and then J = 1 then\n+               goto Continue;\n+            end if;\n+         end loop;\n+\n+         if Scop /= Standard_Standard then\n+            goto Continue;\n+         end if;\n+\n+         --  Check for case of given entity is a library level subprogram\n+         --  and we have the single parameter Eliminate case, a match!\n+\n+         if Is_Compilation_Unit (E)\n+           and then Is_Subprogram (E)\n+           and then No (Elmt.Entity_Node)\n+         then\n+            Set_Is_Eliminated (E);\n+            return;\n+\n+         --  Check for case of type or object with two parameter case\n+\n+         elsif (Is_Type (E) or else Is_Object (E))\n+           and then Elmt.Result_Type = No_Name\n+           and then Elmt.Parameter_Types = null\n+         then\n+            Set_Is_Eliminated (E);\n+            return;\n+\n+         --  Check for case of subprogram\n+\n+         elsif Ekind (E) = E_Function\n+           or else Ekind (E) = E_Procedure\n+         then\n+            --  Two parameter case always matches\n+\n+            if Elmt.Result_Type = No_Name\n+              and then Elmt.Parameter_Types = null\n+            then\n+               Set_Is_Eliminated (E);\n+               return;\n+\n+            --  Here we have a profile, so see if it matches\n+\n+            else\n+               if Ekind (E) = E_Function then\n+                  if Chars (Etype (E)) /= Elmt.Result_Type then\n+                     goto Continue;\n+                  end if;\n+               end if;\n+\n+               Form := First_Formal (E);\n+\n+               if No (Form) and then Elmt.Parameter_Types = null then\n+                  Set_Is_Eliminated (E);\n+                  return;\n+\n+               elsif Elmt.Parameter_Types = null then\n+                  goto Continue;\n+\n+               else\n+                  for J in Elmt.Parameter_Types'Range loop\n+                     if No (Form)\n+                       or else Chars (Etype (Form)) /= Elmt.Parameter_Types (J)\n+                     then\n+                        goto Continue;\n+                     else\n+                        Next_Formal (Form);\n+                     end if;\n+                  end loop;\n+\n+                  if Present (Form) then\n+                     goto Continue;\n+                  else\n+                     Set_Is_Eliminated (E);\n+                     return;\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+\n+         <<Continue>> Elmt := Elmt.Homonym;\n+      end loop;\n+\n+      return;\n+   end Check_Eliminated;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Elim_Hash_Table.Reset;\n+      No_Elimination := True;\n+   end Initialize;\n+\n+   ------------------------------\n+   -- Process_Eliminate_Pragma --\n+   ------------------------------\n+\n+   procedure Process_Eliminate_Pragma\n+     (Arg_Unit_Name       : Node_Id;\n+      Arg_Entity          : Node_Id;\n+      Arg_Parameter_Types : Node_Id;\n+      Arg_Result_Type     : Node_Id)\n+   is\n+      Argx_Unit_Name       : Node_Id;\n+      Argx_Entity          : Node_Id;\n+      Argx_Parameter_Types : Node_Id;\n+      Argx_Result_Type     : Node_Id;\n+\n+      Data : constant Access_Elim_Data := new Elim_Data;\n+      --  Build result data here\n+\n+      Elmt : Access_Elim_Data;\n+\n+      Num_Names : Nat := 0;\n+      --  Number of names in unit name\n+\n+      Lit : Node_Id;\n+\n+      function OK_Selected_Component (N : Node_Id) return Boolean;\n+      --  Test if N is a selected component with all identifiers, or a\n+      --  selected component whose selector is an operator symbol. As a\n+      --  side effect if result is True, sets Num_Names to the number\n+      --  of names present (identifiers and operator if any).\n+\n+      ---------------------------\n+      -- OK_Selected_Component --\n+      ---------------------------\n+\n+      function OK_Selected_Component (N : Node_Id) return Boolean is\n+      begin\n+         if Nkind (N) = N_Identifier\n+           or else Nkind (N) = N_Operator_Symbol\n+         then\n+            Num_Names := Num_Names + 1;\n+            return True;\n+\n+         elsif Nkind (N) = N_Selected_Component then\n+            return OK_Selected_Component (Prefix (N))\n+              and then OK_Selected_Component (Selector_Name (N));\n+\n+         else\n+            return False;\n+         end if;\n+      end OK_Selected_Component;\n+\n+   --  Start of processing for Process_Eliminate_Pragma\n+\n+   begin\n+      Error_Msg_Name_1 := Name_Eliminate;\n+\n+      --  Process Unit_Name argument\n+\n+      Argx_Unit_Name := Expression (Arg_Unit_Name);\n+\n+      if Nkind (Argx_Unit_Name) = N_Identifier then\n+         Data.Unit_Name := new Names'(1 => Chars (Argx_Unit_Name));\n+         Num_Names := 1;\n+\n+      elsif OK_Selected_Component (Argx_Unit_Name) then\n+         Data.Unit_Name := new Names (1 .. Num_Names);\n+\n+         for J in reverse 2 .. Num_Names loop\n+            Data.Unit_Name (J) := Chars (Selector_Name (Argx_Unit_Name));\n+            Argx_Unit_Name := Prefix (Argx_Unit_Name);\n+         end loop;\n+\n+         Data.Unit_Name (1) := Chars (Argx_Unit_Name);\n+\n+      else\n+         Error_Msg_N\n+           (\"wrong form for Unit_Name parameter of pragma%\",\n+            Argx_Unit_Name);\n+         return;\n+      end if;\n+\n+      --  Process Entity argument\n+\n+      if Present (Arg_Entity) then\n+         Argx_Entity := Expression (Arg_Entity);\n+         Num_Names := 0;\n+\n+         if Nkind (Argx_Entity) = N_Identifier\n+           or else Nkind (Argx_Entity) = N_Operator_Symbol\n+         then\n+            Data.Entity_Name  := Chars (Argx_Entity);\n+            Data.Entity_Node  := Argx_Entity;\n+            Data.Entity_Scope := null;\n+\n+         elsif OK_Selected_Component (Argx_Entity) then\n+            Data.Entity_Scope := new Names (1 .. Num_Names - 1);\n+            Data.Entity_Name  := Chars (Selector_Name (Argx_Entity));\n+            Data.Entity_Node  := Argx_Entity;\n+\n+            Argx_Entity := Prefix (Argx_Entity);\n+            for J in reverse 2 .. Num_Names - 1 loop\n+               Data.Entity_Scope (J) := Chars (Selector_Name (Argx_Entity));\n+               Argx_Entity := Prefix (Argx_Entity);\n+            end loop;\n+\n+            Data.Entity_Scope (1) := Chars (Argx_Entity);\n+\n+         elsif Nkind (Argx_Entity) = N_String_Literal then\n+            String_To_Name_Buffer (Strval (Argx_Entity));\n+            Data.Entity_Name := Name_Find;\n+            Data.Entity_Node := Argx_Entity;\n+\n+         else\n+            Error_Msg_N\n+              (\"wrong form for Entity_Argument parameter of pragma%\",\n+              Argx_Unit_Name);\n+            return;\n+         end if;\n+      else\n+         Data.Entity_Node := Empty;\n+         Data.Entity_Name := Data.Unit_Name (Num_Names);\n+      end if;\n+\n+      --  Process Parameter_Types argument\n+\n+      if Present (Arg_Parameter_Types) then\n+         Argx_Parameter_Types := Expression (Arg_Parameter_Types);\n+\n+         --  Case of one name, which looks like a parenthesized literal\n+         --  rather than an aggregate.\n+\n+         if Nkind (Argx_Parameter_Types) = N_String_Literal\n+           and then Paren_Count (Argx_Parameter_Types) = 1\n+         then\n+            String_To_Name_Buffer (Strval (Argx_Parameter_Types));\n+            Data.Parameter_Types := new Names'(1 => Name_Find);\n+\n+         --  Otherwise must be an aggregate\n+\n+         elsif Nkind (Argx_Parameter_Types) /= N_Aggregate\n+           or else Present (Component_Associations (Argx_Parameter_Types))\n+           or else No (Expressions (Argx_Parameter_Types))\n+         then\n+            Error_Msg_N\n+              (\"Parameter_Types for pragma% must be list of string literals\",\n+               Argx_Parameter_Types);\n+            return;\n+\n+         --  Here for aggregate case\n+\n+         else\n+            Data.Parameter_Types :=\n+              new Names\n+                (1 .. List_Length (Expressions (Argx_Parameter_Types)));\n+\n+            Lit := First (Expressions (Argx_Parameter_Types));\n+            for J in Data.Parameter_Types'Range loop\n+               if Nkind (Lit) /= N_String_Literal then\n+                  Error_Msg_N\n+                    (\"parameter types for pragma% must be string literals\",\n+                     Lit);\n+                  return;\n+               end if;\n+\n+               String_To_Name_Buffer (Strval (Lit));\n+               Data.Parameter_Types (J) := Name_Find;\n+               Next (Lit);\n+            end loop;\n+         end if;\n+      end if;\n+\n+      --  Process Result_Types argument\n+\n+      if Present (Arg_Result_Type) then\n+         Argx_Result_Type := Expression (Arg_Result_Type);\n+\n+         if Nkind (Argx_Result_Type) /= N_String_Literal then\n+            Error_Msg_N\n+              (\"Result_Type argument for pragma% must be string literal\",\n+               Argx_Result_Type);\n+            return;\n+         end if;\n+\n+         String_To_Name_Buffer (Strval (Argx_Result_Type));\n+         Data.Result_Type := Name_Find;\n+\n+      else\n+         Data.Result_Type := No_Name;\n+      end if;\n+\n+      --  Now link this new entry into the hash table\n+\n+      Elmt := Elim_Hash_Table.Get (Hash_Subprograms.Get_Key (Data));\n+\n+      --  If we already have an entry with this same key, then link\n+      --  it into the chain of entries for this key.\n+\n+      if Elmt /= null then\n+         Data.Homonym := Elmt.Homonym;\n+         Elmt.Homonym := Data;\n+\n+      --  Otherwise create a new entry\n+\n+      else\n+         Elim_Hash_Table.Set (Data);\n+      end if;\n+\n+      No_Elimination := False;\n+   end Process_Eliminate_Pragma;\n+\n+end Sem_Elim;"}, {"sha": "861ffc996869e553eef3cbf7df5e9e28905ba398", "filename": "gcc/ada/sem_elim.ads", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_elim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "patch": "@@ -0,0 +1,54 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E M _ E L I M                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $                              --\n+--                                                                          --\n+--             Copyright (C) 1997 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines used to process the Eliminate pragma\n+\n+with Types; use Types;\n+\n+package Sem_Elim is\n+\n+   procedure Initialize;\n+   --  Initialize for new main souce program\n+\n+   procedure Process_Eliminate_Pragma\n+     (Arg_Unit_Name       : Node_Id;\n+      Arg_Entity          : Node_Id;\n+      Arg_Parameter_Types : Node_Id;\n+      Arg_Result_Type     : Node_Id);\n+   --  Process eliminate pragma. The number of arguments has been checked,\n+   --  as well as possible optional identifiers, but no other checks have\n+   --  been made. This subprogram completes the checking, and then if the\n+   --  pragma is well formed, makes appropriate entries in the internal\n+   --  tables used to keep track of Eliminate pragmas. The four arguments\n+   --  are the possible pragma arguments (set to Empty if not present).\n+\n+   procedure Check_Eliminated (E : Entity_Id);\n+   --  Checks if entity E is eliminated, and if so sets the Is_Eliminated\n+   --  flag on the given entity.\n+\n+end Sem_Elim;"}, {"sha": "dde46a4b48762911d72950f0f41d42ef30edd202", "filename": "gcc/ada/sem_eval.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "b693ffdb5c38dd95671e779415aa076892fb2ffd", "filename": "gcc/ada/sem_eval.ads", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "20b1918d60aa7615029c3ef026eddebfc0ed5205", "filename": "gcc/ada/sem_intr.adb", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "3576ffb2c66e2509ee1bba0e52fef4a8484dc913", "filename": "gcc/ada/sem_intr.ads", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_intr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_intr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "a876156c6ac15ea88eb485f95ef62350b09b6858", "filename": "gcc/ada/sem_maps.adb", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_maps.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_maps.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_maps.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "3033f890ff755dd4855281d62783c4e7bc84ad7a", "filename": "gcc/ada/sem_maps.ads", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_maps.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_maps.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_maps.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "800a5e82dc43f2d5e03cf9eaa4019f4fef27c5a0", "filename": "gcc/ada/sem_mech.adb", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "4b0993db3ba311ceb5b485c97682b733a93089a2", "filename": "gcc/ada/sem_mech.ads", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_mech.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_mech.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "4910c7842ac07092e00d62e21e164c5916237f31", "filename": "gcc/ada/sem_prag.adb", "status": "added", "additions": 8796, "deletions": 0, "changes": 8796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "fca13a6f3ded623f5220d551d5fb2eef7ab187c6", "filename": "gcc/ada/sem_prag.ads", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "641b120eb7ba93fab8face101529fd966bed8208", "filename": "gcc/ada/sem_res.adb", "status": "added", "additions": 6403, "deletions": 0, "changes": 6403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "5c926540c3b5d0757ef9172181508fc316f2a2e9", "filename": "gcc/ada/sem_res.ads", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "5b0c29c73f6bde56f949d2fb7475f543f32cc3b9", "filename": "gcc/ada/sem_smem.adb", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_smem.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "a164659310edd6e460f190f3484643fbc4543065", "filename": "gcc/ada/sem_smem.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_smem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_smem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_smem.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "9c335e6c4c6460bedc0a6d899a7ac2fe382fccca", "filename": "gcc/ada/sem_type.adb", "status": "added", "additions": 2028, "deletions": 0, "changes": 2028, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "5498e3827b845a925e86850fede6ac7bae0fd2e9", "filename": "gcc/ada/sem_type.ads", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "c2474720fb38ab3a01970d9229b17628c570c19d", "filename": "gcc/ada/sem_util.adb", "status": "added", "additions": 5205, "deletions": 0, "changes": 5205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "2d493944d41c9572200e3a15b45298609d380b0b", "filename": "gcc/ada/sem_util.ads", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "d4b76d4eeeff91036501efde89e3cc51557a65c6", "filename": "gcc/ada/sem_vfpt.adb", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_vfpt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_vfpt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_vfpt.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "ed27175b0b3141de299e6ba1d0453a3fbdb94955", "filename": "gcc/ada/sem_vfpt.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_vfpt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_vfpt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_vfpt.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "f3133d2006db00c780c5a016544d1d4e3f16965d", "filename": "gcc/ada/sem_warn.adb", "status": "added", "additions": 1062, "deletions": 0, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "0c5d75956a0a5087bbc1202aee39b26183161324", "filename": "gcc/ada/sem_warn.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "e191a5a1d4096b231318c68e0e227a4b3369dbf5", "filename": "gcc/ada/sequenio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsequenio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsequenio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsequenio.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "57bc534f58220751963a1d9e497af1c9afa3b514", "filename": "gcc/ada/sfn_scan.adb", "status": "added", "additions": 659, "deletions": 0, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsfn_scan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsfn_scan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "ed84fc6686d8281e84f8ed639dafc9856c237edc", "filename": "gcc/ada/sfn_scan.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsfn_scan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsfn_scan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "33e6da641b1f20765b54d7798c6cd2d3d406546b", "filename": "gcc/ada/sinfo-cn.adb", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo-cn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo-cn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-cn.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "03dcae3d630e89d80ea3be51afabb3d68fa4fbfd", "filename": "gcc/ada/sinfo-cn.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo-cn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo-cn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-cn.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "fb96678b814caf5e46ea94fd09c0c8c53454e29e", "filename": "gcc/ada/sinfo.adb", "status": "added", "additions": 4798, "deletions": 0, "changes": 4798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "335f9fa379c35e2f591fa60b1018a0ac882ef061", "filename": "gcc/ada/sinfo.ads", "status": "added", "additions": 8684, "deletions": 0, "changes": 8684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "f00cbbd26dc4d0eea79315529021bff2b7463c6b", "filename": "gcc/ada/sinput-l.adb", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "bba983fd00b3027a12c3289a650baf89631c3b1a", "filename": "gcc/ada/sinput-l.ads", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-l.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-l.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "10a20f4db9ae7831702d6d7728f37311977a55d4", "filename": "gcc/ada/sinput-p.adb", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-p.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-p.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "9292eaba543629597bfa984ca2e1bcfe155ceff6", "filename": "gcc/ada/sinput-p.ads", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-p.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput-p.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "b86128825504f5f1213eebee80dcc38d156a9573", "filename": "gcc/ada/sinput.adb", "status": "added", "additions": 1132, "deletions": 0, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "585a8b95ea0f9b42a54ac37ef2709d914840490a", "filename": "gcc/ada/sinput.ads", "status": "added", "additions": 650, "deletions": 0, "changes": 650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "acda714b8ed7ea52e1e374da38067f881203b391", "filename": "gcc/ada/snames.adb", "status": "added", "additions": 883, "deletions": 0, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "4c365b8f63ca37132b64335f6739826704ce412d", "filename": "gcc/ada/snames.ads", "status": "added", "additions": 1373, "deletions": 0, "changes": 1373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "e0c9b506b260dd0096047304290002166a8a3c76", "filename": "gcc/ada/snames.h", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "8c58ca815400123c20ec94bf8775fb10d890dd1d", "filename": "gcc/ada/sprint.adb", "status": "added", "additions": 3071, "deletions": 0, "changes": 3071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "d307eb742503ee57d8011fa39cfc29e02ee7787c", "filename": "gcc/ada/sprint.ads", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "b0001b178640d18a61a9e89dada5544bab374a4e", "filename": "gcc/ada/stand.adb", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "65cfa4f5670aa124d81117f2a7968cc388f08ae2", "filename": "gcc/ada/stand.ads", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "b2631ad2c0392bc85a1f2c98bdb94cae44d4437b", "filename": "gcc/ada/stringt.adb", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "0d4350ec090237addabfd91e8b51fdbdc658868c", "filename": "gcc/ada/stringt.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "3a1e1f684a31c468598fd2327b49de36e367e474", "filename": "gcc/ada/stringt.h", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstringt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.h?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "638333c0ee0ab8f242f59ebe43aaf3289727f36f", "filename": "gcc/ada/style.adb", "status": "added", "additions": 833, "deletions": 0, "changes": 833, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstyle.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstyle.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "a75807c1757ca6c0b16a3f7af5391ef8f83a51e9", "filename": "gcc/ada/style.ads", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstyle.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstyle.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "aae4d0475e95619da0ca1f86e3744a16bcadca4d", "filename": "gcc/ada/stylesw.adb", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstylesw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstylesw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "3352b4cf0beacd13efd6ff2e53c43f0cc141b580", "filename": "gcc/ada/stylesw.ads", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "ee97c6ff746834904e7d86ccca2df3f77c895282", "filename": "gcc/ada/switch.adb", "status": "added", "additions": 1364, "deletions": 0, "changes": 1364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fswitch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fswitch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch.adb?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "7153cdaa7658bb38bd483dc6fc17dd5afebbc00c", "filename": "gcc/ada/switch.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fswitch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fswitch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch.ads?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}, {"sha": "5473ebee42ec5fa97494390f1140263628029981", "filename": "gcc/ada/sysdep.c", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}]}