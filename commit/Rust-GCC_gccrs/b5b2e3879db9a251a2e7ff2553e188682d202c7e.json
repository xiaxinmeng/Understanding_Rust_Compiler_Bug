{"sha": "b5b2e3879db9a251a2e7ff2553e188682d202c7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjViMmUzODc5ZGI5YTI1MWEyZTdmZjI1NTNlMTg4NjgyZDIwMmM3ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-12-09T17:35:24Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-09T17:35:24Z"}, "message": "libstdc++: Implement ranges::safe_range for C++20 (P1870R1)\n\nThis change replaces the __forwarding_range implementation detail with\nthe ranges::safe_range concept and adds the ranges::enable_safe_range\nvariable template for opt-in in to the concept.\n\nIt also adjusts the begin/end/rbegin/rend customization point objects to\nmatch the new rules for accessing rvalue ranges only when safe to do so.\n\n\t* include/bits/range_access.h (ranges::enable_safe_range): Define.\n\t(ranges::begin, ranges::end, ranges::rbegin, ranges::rend): Constrain\n\tto only accept types satisfying safe_range and treat argument as an\n\tlvalue when calling a member of performing ADL.\n\t(ranges::__detail::__range_impl, ranges::__detail::__forwarding_range):\n\tRemove.\n\t(ranges::range): Adjust definition.\n\t(ranges::safe_range): Define.\n\t(ranges::iterator_t, ranges::range_difference_t): Reorder definitions\n\tto match the synopsis in the working draft.\n\t(ranges::disable_sized_range): Remove duplicate definition.\n\t* include/experimental/string_view (ranges::enable_safe_range): Add\n\tpartial specialization for std::experimental::basic_string_view.\n\t* include/std/ranges (ranges::viewable_range, ranges::subrange)\n\t(ranges::empty_view, ranges::iota_view): Use safe_range. Specialize\n\tenable_safe_range.\n\t(ranges::safe_iterator_t, ranges::safe_subrange_t): Define.\n\t* include/std/span (ranges::enable_safe_range): Add partial\n\tspecialization for std::span.\n\t* include/std/string_view (ranges::enable_safe_range): Likewise for\n\tstd::basic_string_view.\n\t* testsuite/std/ranges/access/begin.cc: Adjust expected results.\n\t* testsuite/std/ranges/access/cbegin.cc: Likewise.\n\t* testsuite/std/ranges/access/cdata.cc: Likewise.\n\t* testsuite/std/ranges/access/cend.cc: Likewise.\n\t* testsuite/std/ranges/access/crbegin.cc: Likewise.\n\t* testsuite/std/ranges/access/crend.cc: Likewise.\n\t* testsuite/std/ranges/access/data.cc: Likewise.\n\t* testsuite/std/ranges/access/end.cc: Likewise.\n\t* testsuite/std/ranges/access/rbegin.cc: Likewise.\n\t* testsuite/std/ranges/access/rend.cc: Likewise.\n\t* testsuite/std/ranges/empty_view.cc: Test ranges::begin and\n\tranges::end instead of unqualified calls to begin and end.\n\t* testsuite/std/ranges/safe_range.cc: New test.\n\t* testsuite/std/ranges/safe_range_types.cc: New test.\n\t* testsuite/util/testsuite_iterators.h: Add comment about safe_range.\n\nFrom-SVN: r279135", "tree": {"sha": "50bc117800c5e6bc739168e9953df1fcb21505db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50bc117800c5e6bc739168e9953df1fcb21505db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5b2e3879db9a251a2e7ff2553e188682d202c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b2e3879db9a251a2e7ff2553e188682d202c7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b2e3879db9a251a2e7ff2553e188682d202c7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b2e3879db9a251a2e7ff2553e188682d202c7e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c2de7a5720e0d6fbc5df8fc6fb03f2dbf164ff"}], "stats": {"total": 665, "additions": 482, "deletions": 183}, "files": [{"sha": "6ba082f1676c20105d9a16aea95f19065ef6db43", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -1,5 +1,42 @@\n 2019-12-09  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/range_access.h (ranges::enable_safe_range): Define.\n+\t(ranges::begin, ranges::end, ranges::rbegin, ranges::rend): Constrain\n+\tto only accept types satisfying safe_range and treat argument as an\n+\tlvalue when calling a member of performing ADL.\n+\t(ranges::__detail::__range_impl, ranges::__detail::__forwarding_range):\n+\tRemove.\n+\t(ranges::range): Adjust definition.\n+\t(ranges::safe_range): Define.\n+\t(ranges::iterator_t, ranges::range_difference_t): Reorder definitions\n+\tto match the synopsis in the working draft.\n+\t(ranges::disable_sized_range): Remove duplicate definition.\n+\t* include/experimental/string_view (ranges::enable_safe_range): Add\n+\tpartial specialization for std::experimental::basic_string_view.\n+\t* include/std/ranges (ranges::viewable_range, ranges::subrange)\n+\t(ranges::empty_view, ranges::iota_view): Use safe_range. Specialize\n+\tenable_safe_range.\n+\t(ranges::safe_iterator_t, ranges::safe_subrange_t): Define.\n+\t* include/std/span (ranges::enable_safe_range): Add partial\n+\tspecialization for std::span.\n+\t* include/std/string_view (ranges::enable_safe_range): Likewise for\n+\tstd::basic_string_view.\n+\t* testsuite/std/ranges/access/begin.cc: Adjust expected results.\n+\t* testsuite/std/ranges/access/cbegin.cc: Likewise.\n+\t* testsuite/std/ranges/access/cdata.cc: Likewise.\n+\t* testsuite/std/ranges/access/cend.cc: Likewise.\n+\t* testsuite/std/ranges/access/crbegin.cc: Likewise.\n+\t* testsuite/std/ranges/access/crend.cc: Likewise.\n+\t* testsuite/std/ranges/access/data.cc: Likewise.\n+\t* testsuite/std/ranges/access/end.cc: Likewise.\n+\t* testsuite/std/ranges/access/rbegin.cc: Likewise.\n+\t* testsuite/std/ranges/access/rend.cc: Likewise.\n+\t* testsuite/std/ranges/empty_view.cc: Test ranges::begin and\n+\tranges::end instead of unqualified calls to begin and end.\n+\t* testsuite/std/ranges/safe_range.cc: New test.\n+\t* testsuite/std/ranges/safe_range_types.cc: New test.\n+\t* testsuite/util/testsuite_iterators.h: Add comment about safe_range.\n+\n \t* testsuite/27_io/filesystem/path/concat/strings.cc: Test more cases.\n \n \tPR libstdc++/92853"}, {"sha": "6ebd667f03198aec6352d170de94bec6fc3225e8", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 92, "deletions": 91, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -342,6 +342,9 @@ namespace ranges\n   template<typename>\n     inline constexpr bool disable_sized_range = false;\n \n+  template<typename _Tp>\n+    inline constexpr bool enable_safe_range = false;\n+\n   namespace __detail\n   {\n     using __max_diff_type = long long;\n@@ -359,31 +362,39 @@ namespace ranges\n       constexpr make_unsigned_t<_Tp>\n       __to_unsigned_like(_Tp __t) noexcept\n       { return __t; }\n+\n+    // Part of the constraints of ranges::safe_range\n+    template<typename _Tp>\n+      concept __maybe_safe_range\n+\t= is_lvalue_reference_v<_Tp> || enable_safe_range<remove_cvref_t<_Tp>>;\n+\n   } // namespace __detail\n \n   namespace __cust_access\n   {\n+    using std::ranges::__detail::__maybe_safe_range;\n+    using std::__detail::__class_or_enum;\n+\n     template<typename _Tp>\n       constexpr decay_t<_Tp>\n       __decay_copy(_Tp&& __t)\n       noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)\n       { return std::forward<_Tp>(__t); }\n \n     template<typename _Tp>\n-      concept __member_begin = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t)\n-\t{ { __decay_copy(__t.begin()) } -> input_or_output_iterator; };\n+      concept __member_begin = requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(__t.begin()) } -> input_or_output_iterator;\n+\t};\n \n     template<typename _Tp> void begin(_Tp&&) = delete;\n     template<typename _Tp> void begin(initializer_list<_Tp>&&) = delete;\n \n     template<typename _Tp>\n-      concept __adl_begin\n-\t= std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(begin(std::forward<_Tp>(__t))) }\n-\t    -> input_or_output_iterator;\n+\t  { __decay_copy(begin(__t)) } -> input_or_output_iterator;\n \t};\n \n     struct _Begin\n@@ -396,47 +407,45 @@ namespace ranges\n \t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n \t    return true;\n \t  else if constexpr (__member_begin<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().begin()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().begin()));\n \t  else\n-\t    return noexcept(__decay_copy(begin(std::declval<_Tp>())));\n+\t    return noexcept(__decay_copy(begin(std::declval<_Tp&>())));\n \t}\n \n     public:\n-      template<typename _Tp>\n+      template<__maybe_safe_range _Tp>\n \trequires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>\n \t  || __adl_begin<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n \t{\n \t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n \t    {\n \t      static_assert(is_lvalue_reference_v<_Tp>);\n-\t      return __e;\n+\t      return __t;\n \t    }\n \t  else if constexpr (__member_begin<_Tp>)\n-\t    return __e.begin();\n+\t    return __t.begin();\n \t  else\n-\t    return begin(std::forward<_Tp>(__e));\n+\t    return begin(__t);\n \t}\n     };\n \n     template<typename _Tp>\n-      concept __member_end = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t)\n+      concept __member_end = requires(_Tp& __t)\n \t{\n \t  { __decay_copy(__t.end()) }\n-\t    -> sentinel_for<decltype(_Begin{}(__t))>;\n+\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n \t};\n \n     template<typename _Tp> void end(_Tp&&) = delete;\n     template<typename _Tp> void end(initializer_list<_Tp>&&) = delete;\n \n     template<typename _Tp>\n-      concept __adl_end\n-\t= std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(end(std::forward<_Tp>(__t))) }\n+\t  { __decay_copy(end(__t)) }\n \t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n \t};\n \n@@ -450,28 +459,28 @@ namespace ranges\n \t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n \t    return true;\n \t  else if constexpr (__member_end<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().end()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().end()));\n \t  else\n-\t    return noexcept(__decay_copy(end(std::declval<_Tp>())));\n+\t    return noexcept(__decay_copy(end(std::declval<_Tp&>())));\n \t}\n \n     public:\n-      template<typename _Tp>\n+      template<__maybe_safe_range _Tp>\n \trequires is_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>\n \t|| __adl_end<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n \t{\n \t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n \t    {\n \t      static_assert(is_lvalue_reference_v<_Tp>);\n \t      static_assert(is_bounded_array_v<remove_reference_t<_Tp>>);\n-\t      return __e + extent_v<remove_reference_t<_Tp>>;\n+\t      return __t + extent_v<remove_reference_t<_Tp>>;\n \t    }\n \t  else if constexpr (__member_end<_Tp>)\n-\t    return __e.end();\n+\t    return __t.end();\n \t  else\n-\t    return end(std::forward<_Tp>(__e));\n+\t    return end(__t);\n \t}\n     };\n \n@@ -510,27 +519,25 @@ namespace ranges\n     };\n \n     template<typename _Tp>\n-      concept __member_rbegin = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t)\n-\t{ { __decay_copy(__t.rbegin()) } -> input_or_output_iterator; };\n+      concept __member_rbegin = requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;\n+\t};\n \n     template<typename _Tp> void rbegin(_Tp&&) = delete;\n \n     template<typename _Tp>\n-      concept __adl_rbegin\n-\t= std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(rbegin(std::forward<_Tp>(__t))) }\n-\t    -> input_or_output_iterator;\n+\t  { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;\n \t};\n \n     template<typename _Tp>\n-      concept __reversable = requires(_Tp&& __t)\n+      concept __reversable = requires(_Tp& __t)\n \t{\n-\t  { _Begin{}(std::forward<_Tp>(__t)) } -> bidirectional_iterator;\n-\t  { _End{}(std::forward<_Tp>(__t)) }\n-\t    -> same_as<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t  { _Begin{}(__t) } -> bidirectional_iterator;\n+\t  { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;\n \t};\n \n     struct _RBegin\n@@ -541,14 +548,14 @@ namespace ranges\n \t_S_noexcept()\n \t{\n \t  if constexpr (__member_rbegin<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().rbegin()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));\n \t  else if constexpr (__adl_rbegin<_Tp>)\n-\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp>())));\n+\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));\n \t  else\n \t    {\n-\t      if constexpr (noexcept(_End{}(std::declval<_Tp>())))\n+\t      if constexpr (noexcept(_End{}(std::declval<_Tp&>())))\n \t\t{\n-\t\t  using _It = decltype(_End{}(std::declval<_Tp>()));\n+\t\t  using _It = decltype(_End{}(std::declval<_Tp&>()));\n \t\t  // std::reverse_iterator copy-initializes its member.\n \t\t  return is_nothrow_copy_constructible_v<_It>;\n \t\t}\n@@ -558,24 +565,23 @@ namespace ranges\n \t}\n \n     public:\n-      template<typename _Tp>\n+      template<__maybe_safe_range _Tp>\n \trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const\n+\toperator()(_Tp&& __t) const\n \tnoexcept(_S_noexcept<_Tp>())\n \t{\n \t  if constexpr (__member_rbegin<_Tp>)\n-\t    return __e.rbegin();\n+\t    return __t.rbegin();\n \t  else if constexpr (__adl_rbegin<_Tp>)\n-\t    return rbegin(std::forward<_Tp>(__e));\n+\t    return rbegin(__t);\n \t  else\n-\t    return std::make_reverse_iterator(_End{}(std::forward<_Tp>(__e)));\n+\t    return std::make_reverse_iterator(_End{}(__t));\n \t}\n     };\n \n     template<typename _Tp>\n-      concept __member_rend = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t)\n+      concept __member_rend = requires(_Tp& __t)\n \t{\n \t  { __decay_copy(__t.rend()) }\n \t    -> sentinel_for<decltype(_RBegin{}(__t))>;\n@@ -584,11 +590,10 @@ namespace ranges\n     template<typename _Tp> void rend(_Tp&&) = delete;\n \n     template<typename _Tp>\n-      concept __adl_rend\n-\t= std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(rend(std::forward<_Tp>(__t))) }\n+\t  { __decay_copy(rend(__t)) }\n \t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n \t};\n \n@@ -600,14 +605,14 @@ namespace ranges\n \t_S_noexcept()\n \t{\n \t  if constexpr (__member_rend<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().rend()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().rend()));\n \t  else if constexpr (__adl_rend<_Tp>)\n-\t    return noexcept(__decay_copy(rend(std::declval<_Tp>())));\n+\t    return noexcept(__decay_copy(rend(std::declval<_Tp&>())));\n \t  else\n \t    {\n-\t      if constexpr (noexcept(_Begin{}(std::declval<_Tp>())))\n+\t      if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))\n \t\t{\n-\t\t  using _It = decltype(_Begin{}(std::declval<_Tp>()));\n+\t\t  using _It = decltype(_Begin{}(std::declval<_Tp&>()));\n \t\t  // std::reverse_iterator copy-initializes its member.\n \t\t  return is_nothrow_copy_constructible_v<_It>;\n \t\t}\n@@ -617,18 +622,18 @@ namespace ranges\n \t}\n \n     public:\n-      template<typename _Tp>\n+      template<__maybe_safe_range _Tp>\n \trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const\n+\toperator()(_Tp&& __t) const\n \tnoexcept(_S_noexcept<_Tp>())\n \t{\n \t  if constexpr (__member_rend<_Tp>)\n-\t    return __e.rend();\n+\t    return __t.rend();\n \t  else if constexpr (__adl_rend<_Tp>)\n-\t    return rend(std::forward<_Tp>(__e));\n+\t    return rend(__t);\n \t  else\n-\t    return std::make_reverse_iterator(_Begin{}(std::forward<_Tp>(__e)));\n+\t    return std::make_reverse_iterator(_Begin{}(__t));\n \t}\n     };\n \n@@ -667,8 +672,7 @@ namespace ranges\n     template<typename _Tp> void size(_Tp&&) = delete;\n \n     template<typename _Tp>\n-      concept __adl_size\n-\t= std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n+      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>\n \t&& !disable_sized_range<remove_cvref_t<_Tp>>\n \t&& requires(_Tp&& __t)\n \t{\n@@ -842,25 +846,26 @@ namespace ranges\n     inline constexpr __cust_access::_CData cdata{};\n   }\n \n-  namespace __detail\n-  {\n-    template<typename _Tp>\n-      concept __range_impl = requires(_Tp&& __t) {\n-\tranges::begin(std::forward<_Tp>(__t));\n-\tranges::end(std::forward<_Tp>(__t));\n+  /// [range.range] The range concept.\n+  template<typename _Tp>\n+    concept range = requires(_Tp& __t)\n+      {\n+\tranges::begin(__t);\n+\tranges::end(__t);\n       };\n \n-  } // namespace __detail\n-\n-  /// [range.range] The range concept.\n+  /// [range.range] The safe_range concept.\n   template<typename _Tp>\n-    concept range = __detail::__range_impl<_Tp&>;\n+    concept safe_range = range<_Tp> && __detail::__maybe_safe_range<_Tp>;\n+\n+  template<range _Range>\n+    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));\n \n   template<range _Range>\n     using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n \n   template<range _Range>\n-    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));\n+    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n \n   template<range _Range>\n     using range_value_t = iter_value_t<iterator_t<_Range>>;\n@@ -872,43 +877,38 @@ namespace ranges\n     using range_rvalue_reference_t\n       = iter_rvalue_reference_t<iterator_t<_Range>>;\n \n-  template<range _Range>\n-    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n-\n-  namespace __detail\n-  {\n-    template<typename _Tp>\n-      concept __forwarding_range = range<_Tp> && __range_impl<_Tp>;\n-  } // namespace __detail\n-\n   /// [range.sized] The sized_range concept.\n   template<typename _Tp>\n     concept sized_range = range<_Tp>\n       && requires(_Tp& __t) { ranges::size(__t); };\n \n-  template<typename>\n-    inline constexpr bool disable_sized_range = false;\n-\n   // [range.refinements]\n+\n+  /// A range for which ranges::begin returns an output iterator.\n   template<typename _Range, typename _Tp>\n     concept output_range\n       = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n \n+  /// A range for which ranges::begin returns an input iterator.\n   template<typename _Tp>\n     concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n \n+  /// A range for which ranges::begin returns a forward iterator.\n   template<typename _Tp>\n     concept forward_range\n       = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n \n+  /// A range for which ranges::begin returns a bidirectional iterator.\n   template<typename _Tp>\n     concept bidirectional_range\n       = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n \n+  /// A range for which ranges::begin returns a random access iterator.\n   template<typename _Tp>\n     concept random_access_range\n       = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n \n+  /// A range for which ranges::begin returns a contiguous iterator.\n   template<typename _Tp>\n     concept contiguous_range\n       = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n@@ -917,11 +917,12 @@ namespace ranges\n \t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n       };\n \n+  /// A range for which ranges::begin and ranges::end return the same type.\n   template<typename _Tp>\n     concept common_range\n       = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n \n-    // [range.iter.ops] range iterator operations\n+  // [range.iter.ops] range iterator operations\n \n   template<input_or_output_iterator _It>\n     constexpr void"}, {"sha": "cc9cb93ad5e643a2a8225abdd9b3ca2604e856ca", "filename": "libstdc++-v3/include/experimental/string_view", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -691,6 +691,18 @@ namespace experimental\n   } // namespace literals\n } // namespace experimental\n \n+#if __cpp_lib_concepts\n+  namespace ranges\n+  {\n+    template<typename> extern inline const bool enable_safe_range;\n+    // Opt-in to safe_range concept\n+    template<typename _CharT, typename _Traits>\n+      inline constexpr bool\n+\tenable_safe_range<experimental::basic_string_view<_CharT, _Traits>>\n+\t  = true;\n+  }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "c2567818cb50f2b43b4a960a2677d8130006c1a2", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -89,9 +89,10 @@ namespace ranges\n       = range<_Tp> && movable<_Tp> && default_initializable<_Tp>\n \t&& enable_view<_Tp>;\n \n+  /// A range which can be safely converted to a view.\n   template<typename _Tp>\n     concept viewable_range = range<_Tp>\n-      && (__detail::__forwarding_range<_Tp> || view<decay_t<_Tp>>);\n+      && (safe_range<_Tp> || view<decay_t<_Tp>>);\n \n   namespace __detail\n   {\n@@ -295,7 +296,7 @@ namespace ranges\n       }\n \n       template<__detail::__not_same_as<subrange> _Rng>\n-\trequires __detail::__forwarding_range<_Rng>\n+\trequires safe_range<_Rng>\n \t  && convertible_to<iterator_t<_Rng>, _It>\n \t  && convertible_to<sentinel_t<_Rng>, _Sent>\n \tconstexpr\n@@ -306,7 +307,7 @@ namespace ranges\n \t    _M_size._M_size = ranges::size(__r);\n \t}\n \n-      template<__detail::__forwarding_range _Rng>\n+      template<safe_range _Rng>\n \trequires convertible_to<iterator_t<_Rng>, _It>\n \t  && convertible_to<sentinel_t<_Rng>, _Sent>\n \tconstexpr\n@@ -401,12 +402,6 @@ namespace ranges\n \t  ranges::advance(_M_begin, __n, _M_end);\n \treturn *this;\n       }\n-\n-      friend constexpr _It\n-      begin(subrange&& __r) { return __r.begin(); }\n-\n-      friend constexpr _Sent\n-      end(subrange&& __r) { return __r.end(); }\n     };\n \n   template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n@@ -424,14 +419,14 @@ namespace ranges\n       -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,\n \t\t  subrange_kind::sized>;\n \n-  template<__detail::__forwarding_range _Rng>\n+  template<safe_range _Rng>\n     subrange(_Rng&&)\n       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,\n \t\t (sized_range<_Rng>\n \t\t  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)\n \t\t ? subrange_kind::sized : subrange_kind::unsized>;\n \n-  template<__detail::__forwarding_range _Rng>\n+  template<safe_range _Rng>\n     subrange(_Rng&&,\n \t     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)\n       -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;\n@@ -457,6 +452,12 @@ namespace ranges\n       else\n \treturn __r.end();\n     }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent,\n+\t   subrange_kind _Kind>\n+    inline constexpr bool\n+      enable_safe_range<subrange<_It, _Sent, _Kind>> = true;\n+\n } // namespace ranges\n \n   using ranges::get;\n@@ -471,20 +472,31 @@ namespace ranges\n       constexpr dangling(_Args&&...) noexcept { }\n   };\n \n+  template<range _Range>\n+    using safe_iterator_t = conditional_t<safe_range<_Range>,\n+\t\t\t\t\t  iterator_t<_Range>,\n+\t\t\t\t\t  dangling>;\n+\n+  template<range _Range>\n+    using safe_subrange_t = conditional_t<safe_range<_Range>,\n+\t\t\t\t\t  subrange<iterator_t<_Range>>,\n+\t\t\t\t\t  dangling>;\n+\n   template<typename _Tp> requires is_object_v<_Tp>\n-    class empty_view : public view_interface<empty_view<_Tp>>\n+    class empty_view\n+    : public view_interface<empty_view<_Tp>>\n     {\n     public:\n       static constexpr _Tp* begin() noexcept { return nullptr; }\n       static constexpr _Tp* end() noexcept { return nullptr; }\n       static constexpr _Tp* data() noexcept { return nullptr; }\n       static constexpr size_t size() noexcept { return 0; }\n       static constexpr bool empty() noexcept { return true; }\n-\n-      friend constexpr _Tp* begin(empty_view) noexcept { return nullptr; }\n-      friend constexpr _Tp* end(empty_view) noexcept { return nullptr; }\n     };\n \n+  template<typename _Tp>\n+    inline constexpr bool enable_safe_range<empty_view<_Tp>> = true;\n+\n   namespace __detail\n   {\n     template<copy_constructible _Tp> requires is_object_v<_Tp>\n@@ -899,6 +911,9 @@ namespace ranges\n \t    == __detail::__is_signed_integer_like<_Bound>))\n     iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;\n \n+  template<weakly_incrementable _Winc, semiregular _Bound>\n+    inline constexpr bool enable_safe_range<iota_view<_Winc, _Bound>> = true;\n+\n namespace views\n {\n   template<typename _Tp>"}, {"sha": "f215decb453c60970a579a96fae6ad428f6d327c", "filename": "libstdc++-v3/include/std/span", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -399,16 +399,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn {this->data() + __offset, __count};\n       }\n \n-      // observers: range helpers\n-\n-      friend constexpr iterator\n-      begin(span __sp) noexcept\n-      { return __sp.begin(); }\n-\n-      friend constexpr iterator\n-      end(span __sp) noexcept\n-      { return __sp.end(); }\n-\n     private:\n       [[no_unique_address]] __detail::__extent_storage<extent> _M_extent;\n       pointer _M_ptr;\n@@ -478,6 +468,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using type = _Type;\n     };\n \n+  namespace ranges\n+  {\n+    template<typename> extern inline const bool enable_safe_range;\n+    // Opt-in to safe_range concept\n+    template<typename _ElementType, size_t _Extent>\n+      inline constexpr bool\n+\tenable_safe_range<span<_ElementType, _Extent>> = true;\n+  }\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n #endif // concepts"}, {"sha": "add432bbb092cdc8715ace0f90e2d56f9ae326da", "filename": "libstdc++-v3/include/std/string_view", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -724,6 +724,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   } // namespace string_literals\n   } // namespace literals\n \n+#if __cpp_lib_concepts\n+  namespace ranges\n+  {\n+    template<typename> extern inline const bool enable_safe_range;\n+    // Opt-in to safe_range concept\n+    template<typename _CharT, typename _Traits>\n+      inline constexpr bool\n+\tenable_safe_range<basic_string_view<_CharT, _Traits>> = true;\n+  }\n+#endif\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "8439a2175e705b785c31d66b35e448487d4d1976", "filename": "libstdc++-v3/testsuite/std/ranges/access/begin.cc", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -71,11 +71,22 @@ struct R\n   int a[4] = { 0, 1, 2, 3 };\n \n   friend int* begin(R& r) { return r.a + 0; }\n-  friend int* begin(R&& r) { return r.a + 1; }\n+  friend int* begin(R&& r); // this overload is not defined\n   friend const int* begin(const R& r) noexcept { return r.a + 2; }\n-  friend const int* begin(const R&& r) noexcept { return r.a + 3; }\n+  friend const int* begin(const R&& r) noexcept; // not defined\n };\n \n+struct RV // view on an R\n+{\n+  R& r;\n+\n+  friend int* begin(RV& rv) { return begin(rv.r); }\n+  friend const int* begin(const RV& rv) noexcept { return begin(rv.r); }\n+};\n+\n+// Allow ranges::begin to work with RV&&\n+template<> constexpr bool std::ranges::enable_safe_range<RV> = true;\n+\n void\n test03()\n {\n@@ -86,20 +97,23 @@ test03()\n   static_assert(!noexcept(std::ranges::begin(r)));\n   VERIFY( std::ranges::begin(r) == begin(r) );\n \n-  static_assert(same_as<decltype(std::ranges::begin(std::move(r))),\n-\t\tdecltype(begin(std::move(r)))>);\n-  static_assert(!noexcept(std::ranges::begin(std::move(r))));\n-  VERIFY( std::ranges::begin(std::move(r)) == begin(std::move(r)) );\n-\n-\n   static_assert(same_as<decltype(std::ranges::begin(c)), decltype(begin(c))>);\n   static_assert(noexcept(std::ranges::begin(c)));\n   VERIFY( std::ranges::begin(c) == begin(c) );\n \n-  static_assert(same_as<decltype(std::ranges::begin(std::move(c))),\n-\t\tdecltype(begin(std::move(c)))>);\n-  static_assert(noexcept(std::ranges::begin(std::move(c))));\n-  VERIFY( std::ranges::begin(std::move(c)) == begin(std::move(c)) );\n+  RV v{r};\n+  // enable_safe_range<RV> allows ranges::begin to work for rvalues,\n+  // but it will call v.begin() or begin(v) on an lvalue:\n+  static_assert(same_as<decltype(std::ranges::begin(std::move(v))),\n+\t\tdecltype(begin(v))>);\n+  static_assert(!noexcept(std::ranges::begin(std::move(v))));\n+  VERIFY( std::ranges::begin(std::move(v)) == begin(v) );\n+\n+  const RV cv{r};\n+  static_assert(same_as<decltype(std::ranges::begin(std::move(cv))),\n+\t\tdecltype(begin(cv))>);\n+  static_assert(noexcept(std::ranges::begin(std::move(cv))));\n+  VERIFY( std::ranges::begin(std::move(cv)) == begin(cv) );\n }\n \n struct RR\n@@ -111,12 +125,15 @@ struct RR\n   short* begin() noexcept { return &s; }\n   const long* begin() const { return &l; }\n \n-  friend int* begin(RR& r) { return r.a + 0; }\n-  friend int* begin(RR&& r) { return r.a + 1; }\n+  friend int* begin(RR& r) noexcept { return r.a + 0; }\n+  friend int* begin(RR&& r); // not defined\n   friend const int* begin(const RR& r) { return r.a + 2; }\n-  friend const int* begin(const RR&& r) noexcept { return r.a + 3; }\n+  friend const int* begin(const RR&& r) noexcept; // not defined\n };\n \n+// N.B. this is a lie, begin on an RR rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<RR> = true;\n+\n void\n test04()\n {\n@@ -125,14 +142,16 @@ test04()\n   VERIFY( std::ranges::begin(r) == &r.s );\n   static_assert(noexcept(std::ranges::begin(r)));\n \n-  VERIFY( std::ranges::begin(std::move(r)) == r.a + 1 );\n-  static_assert(!noexcept(std::ranges::begin(std::move(r))));\n+  // calls r.begin() on an lvalue, not rvalue\n+  VERIFY( std::ranges::begin(std::move(r)) == std::ranges::begin(r) );\n+  static_assert(noexcept(std::ranges::begin(std::move(r))));\n \n   VERIFY( std::ranges::begin(c) == &r.l );\n   static_assert(!noexcept(std::ranges::begin(c)));\n \n-  VERIFY( std::ranges::begin(std::move(c)) == r.a + 3 );\n-  static_assert(noexcept(std::ranges::begin(std::move(c))));\n+  // calls r.begin() on a const lvalue, not rvalue\n+  VERIFY( std::ranges::begin(std::move(c)) == std::ranges::begin(c) );\n+  static_assert(!noexcept(std::ranges::begin(std::move(c))));\n }\n \n int"}, {"sha": "709df0d1588f3646f328fc080ee52c747992a120", "filename": "libstdc++-v3/testsuite/std/ranges/access/cbegin.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -40,20 +40,34 @@ struct R\n   int a[4] = { 0, 1, 2, 3 };\n \n   friend int* begin(R& r) { return r.a + 0; }\n-  friend int* begin(R&& r) { return r.a + 1; }\n+  friend int* begin(R&&); // this function is not defined\n   friend const int* begin(const R& r) noexcept { return r.a + 2; }\n-  friend const int* begin(const R&& r) noexcept { return r.a + 3; }\n+  friend const int* begin(const R&&); // this function is not defined\n };\n \n+struct RV // view on an R\n+{\n+  R& r;\n+\n+  friend int* begin(RV&); // this function is not defined\n+  friend const int* begin(const RV& rv) noexcept { return begin(std::as_const(rv.r)); }\n+};\n+\n+// Allow ranges::begin to work with RV&&\n+template<> constexpr bool std::ranges::enable_safe_range<RV> = true;\n+\n void\n test03()\n {\n   R r;\n   const R& c = r;\n   VERIFY(std::ranges::cbegin(r) == std::ranges::begin(c));\n-  VERIFY(std::ranges::cbegin(std::move(r)) == std::ranges::begin(std::move(c)));\n   VERIFY(std::ranges::cbegin(c) == std::ranges::begin(c));\n-  VERIFY(std::ranges::cbegin(std::move(c)) == std::ranges::begin(std::move(c)));\n+\n+  RV v{r};\n+  VERIFY(std::ranges::cbegin(std::move(v)) == std::ranges::begin(c));\n+  const RV cv{r};\n+  VERIFY(std::ranges::cbegin(std::move(cv)) == std::ranges::begin(c));\n }\n \n struct RR\n@@ -71,15 +85,18 @@ struct RR\n   friend const int* begin(const RR&& r) noexcept { return r.a + 3; }\n };\n \n+// N.B. this is a lie, cbegin on an RR rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<RR> = true;\n+\n void\n test04()\n {\n   RR r;\n   const RR& c = r;\n   VERIFY(std::ranges::cbegin(r) == std::ranges::begin(c));\n-  VERIFY(std::ranges::cbegin(std::move(r)) == std::ranges::begin(std::move(c)));\n+  VERIFY(std::ranges::cbegin(std::move(r)) == std::ranges::begin(c));\n   VERIFY(std::ranges::cbegin(c) == std::ranges::begin(c));\n-  VERIFY(std::ranges::cbegin(std::move(c)) == std::ranges::begin(std::move(c)));\n+  VERIFY(std::ranges::cbegin(std::move(c)) == std::ranges::begin(c));\n }\n \n int"}, {"sha": "f928bb795c2dfd752d96efa769bae3fd1c4ec6db", "filename": "libstdc++-v3/testsuite/std/ranges/access/cdata.cc", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -51,17 +51,22 @@ struct R\n   long l = 0;\n \n   int* data() const { return nullptr; }\n-  friend long* begin(R&& r) { return &r.l; }\n-  friend const long* begin(const R&& r) { return &r.l + 1; }\n+  friend long* begin(R&& r); // this function is not defined\n+  friend const long* begin(const R& r) { return &r.l; }\n+  friend const short* begin(const R&&); // not defined\n };\n \n+// This is a lie, ranges::begin(R&&) returns a dangling iterator.\n+template<> constexpr bool std::ranges::enable_safe_range<R> = true;\n+\n void\n test03()\n {\n   R r;\n   const R& c = r;\n-  VERIFY( std::ranges::cdata(std::move(r)) == std::ranges::data(std::move(c)) );\n-  VERIFY( std::ranges::cdata(std::move(c)) == std::ranges::data(std::move(c)) );\n+  VERIFY( std::ranges::cdata(r) == std::ranges::data(c) );\n+  VERIFY( std::ranges::cdata(std::move(r)) == std::ranges::begin(c) );\n+  VERIFY( std::ranges::cdata(std::move(c)) == std::ranges::begin(c) );\n }\n \n int"}, {"sha": "59053f75d67546c893a4e48546bc0cb4c2e2f3d2", "filename": "libstdc++-v3/testsuite/std/ranges/access/cend.cc", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -49,15 +49,31 @@ struct R\n   friend const int* end(const R&& r) noexcept { return r.a + 3; }\n };\n \n+struct RV // view on an R\n+{\n+  R& r;\n+\n+  friend const int* begin(RV& rv) { return rv.r.begin(); }\n+  friend int* end(RV& rv) { return end(rv.r); }\n+  friend const int* begin(const RV& rv) noexcept { return rv.r.begin(); }\n+  friend const int* end(const RV& rv) noexcept { return end(std::as_const(rv.r)); }\n+};\n+\n+// Allow ranges::end to work with RV&&\n+template<> constexpr bool std::ranges::enable_safe_range<RV> = true;\n+\n void\n test03()\n {\n   R r;\n   const R& c = r;\n   VERIFY( std::ranges::cend(r) == std::ranges::end(c) );\n-  VERIFY( std::ranges::cend(std::move(r)) == std::ranges::end(std::move(c)) );\n   VERIFY( std::ranges::cend(c) == std::ranges::end(c) );\n-  VERIFY( std::ranges::cend(std::move(c)) == std::ranges::end(std::move(c)) );\n+\n+  RV v{r};\n+  const RV cv{r};\n+  VERIFY( std::ranges::cend(std::move(v)) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(cv)) == std::ranges::end(c) );\n }\n \n struct RR\n@@ -81,15 +97,19 @@ struct RR\n   friend const int* end(const RR&& r) noexcept { return r.a + 3; }\n };\n \n+// N.B. this is a lie, begin/end on an RR rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<RR> = true;\n+\n void\n test04()\n {\n   RR r;\n   const RR& c = r;\n   VERIFY( std::ranges::cend(r) == std::ranges::end(c) );\n-  VERIFY( std::ranges::cend(std::move(r)) == std::ranges::end(std::move(c)) );\n   VERIFY( std::ranges::cend(c) == std::ranges::end(c) );\n-  VERIFY( std::ranges::cend(std::move(c)) == std::ranges::end(std::move(c)) );\n+\n+  VERIFY( std::ranges::cend(std::move(r)) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(c)) == std::ranges::end(c) );\n }\n \n int"}, {"sha": "17ea7983470d1970ca3012d336c64df37f7927ef", "filename": "libstdc++-v3/testsuite/std/ranges/access/crbegin.cc", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -31,15 +31,29 @@ struct R1\n   friend const int* rbegin(const R1&& r) { return &r.j; }\n };\n \n+struct R1V // view on an R1\n+{\n+  R1& r;\n+\n+  friend const long* rbegin(R1V&); // this is not defined\n+  friend const int* rbegin(const R1V& rv) noexcept { return rv.r.rbegin(); }\n+};\n+\n+// Allow ranges::end to work with R1V&&\n+template<> constexpr bool std::ranges::enable_safe_range<R1V> = true;\n+\n void\n test01()\n {\n   R1 r;\n   const R1& c = r;\n   VERIFY( std::ranges::crbegin(r) == std::ranges::rbegin(c) );\n-  VERIFY( std::ranges::crbegin(std::move(r)) == std::ranges::rbegin(std::move(c)) );\n   VERIFY( std::ranges::crbegin(c) == std::ranges::rbegin(c) );\n-  VERIFY( std::ranges::crbegin(std::move(c)) == std::ranges::rbegin(std::move(c)) );\n+\n+  R1V v{r};\n+  const R1V cv{r};\n+  VERIFY( std::ranges::crbegin(std::move(v)) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(cv)) == std::ranges::rbegin(c) );\n }\n \n struct R2\n@@ -50,19 +64,23 @@ struct R2\n   const int* begin() const { return a; }\n   const int* end() const { return a + 2; }\n \n-  friend const long* begin(const R2&& r) { return r.l; }\n-  friend const long* end(const R2&& r) { return r.l + 2; }\n+  friend const long* begin(const R2&&); // not defined\n+  friend const long* end(const R2&&); // not defined\n };\n \n+// N.B. this is a lie, rbegin on an R2 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R2> = true;\n+\n void\n test02()\n {\n   R2 r;\n   const R2& c = r;\n   VERIFY( std::ranges::crbegin(r) == std::ranges::rbegin(c) );\n-  VERIFY( std::ranges::crbegin(std::move(r)) == std::ranges::rbegin(std::move(c)) );\n   VERIFY( std::ranges::crbegin(c) == std::ranges::rbegin(c) );\n-  VERIFY( std::ranges::crbegin(std::move(c)) == std::ranges::rbegin(std::move(c)) );\n+\n+  VERIFY( std::ranges::crbegin(std::move(r)) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(c)) == std::ranges::rbegin(c) );\n }\n \n int"}, {"sha": "bc4d0d2949cbf8be99dc1e3df8b738f738c3bec1", "filename": "libstdc++-v3/testsuite/std/ranges/access/crend.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -33,15 +33,18 @@ struct R1\n   friend constexpr const int* rend(const R1&& r) { return &r.j + 1; }\n };\n \n+// N.B. this is a lie, rend on an R1 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R1> = true;\n+\n void\n test01()\n {\n   R1 r;\n   const R1& c = r;\n   VERIFY( std::ranges::crend(r) == std::ranges::rend(c) );\n-  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(std::move(c)) );\n   VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n-  VERIFY( std::ranges::crend(std::move(c)) == std::ranges::rend(std::move(c)) );\n+  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(c)) == std::ranges::rend(c) );\n }\n \n struct R2\n@@ -56,14 +59,17 @@ struct R2\n   friend const long* end(const R2&& r) { return r.l + 2; }\n };\n \n+// N.B. this is a lie, rend on an R2 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R2> = true;\n+\n void\n test02()\n {\n   R2 r;\n   const R2& c = r;\n   VERIFY( std::ranges::crend(r) == std::ranges::rend(c) );\n-  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(std::move(c)) );\n   VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(std::move(c)) );\n   VERIFY( std::ranges::crend(std::move(c)) == std::ranges::rend(std::move(c)) );\n }\n \n@@ -78,6 +84,9 @@ struct R3\n   friend const int* rend(const R3& r) { return &r.i; }\n };\n \n+// N.B. this is a lie, rend on an R3 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R3> = true;\n+\n void\n test03()\n {"}, {"sha": "1bd4e06dd0ebc101affa524cf9ecc5da28455a91", "filename": "libstdc++-v3/testsuite/std/ranges/access/data.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -56,15 +56,20 @@ struct R3\n   long l = 0;\n \n   int* data() const { return nullptr; }\n-  friend long* begin(R3&& r) { return &r.l; }\n-  friend const long* begin(const R3&& r) { return &r.l + 1; }\n+  friend long* begin(R3& r) { return &r.l; }\n+  friend const long* begin(const R3& r) { return &r.l + 1; }\n };\n \n+// N.B. this is a lie, begin on an R3 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R3> = true;\n+\n void\n test03()\n {\n   R3 r;\n   const R3& c = r;\n+  // r.data() can only be used on an lvalue, but ranges::begin(R3&&) is OK\n+  // because R3 satisfies ranges::safe_range.\n   VERIFY( std::ranges::data(std::move(r)) == std::to_address(std::ranges::begin(std::move(r))) );\n   VERIFY( std::ranges::data(std::move(c)) == std::to_address(std::ranges::begin(std::move(c))) );\n }"}, {"sha": "eaa13d031b3c71e713baff7a3061aaf8b3b45217", "filename": "libstdc++-v3/testsuite/std/ranges/access/end.cc", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -74,6 +74,19 @@ struct R\n   friend const int* end(const R&& r) noexcept { return r.a + 3; }\n };\n \n+struct RV // view on an R\n+{\n+  R& r;\n+\n+  const int* begin() const;\n+\n+  friend int* end(RV& v) noexcept { return end(v.r); }\n+  friend const int* end(const RV& v) { return end(std::as_const(v.r)); }\n+};\n+\n+// Allow ranges::begin to work with RV&&\n+template<> constexpr bool std::ranges::enable_safe_range<RV> = true;\n+\n void\n test03()\n {\n@@ -84,20 +97,21 @@ test03()\n   static_assert(!noexcept(std::ranges::end(r)));\n   VERIFY( std::ranges::end(r) == end(r) );\n \n-  static_assert(same_as<decltype(std::ranges::end(std::move(r))),\n-\t\tdecltype(end(std::move(r)))>);\n-  static_assert(!noexcept(std::ranges::end(std::move(r))));\n-  VERIFY( std::ranges::end(std::move(r)) == end(std::move(r)) );\n-\n-\n   static_assert(same_as<decltype(std::ranges::end(c)), decltype(end(c))>);\n   static_assert(noexcept(std::ranges::end(c)));\n   VERIFY( std::ranges::end(c) == end(c) );\n \n-  static_assert(same_as<decltype(std::ranges::end(std::move(c))),\n-\t\tdecltype(end(std::move(c)))>);\n-  static_assert(noexcept(std::ranges::end(std::move(c))));\n-  VERIFY( std::ranges::end(std::move(c)) == end(std::move(c)) );\n+  RV v{r};\n+  static_assert(same_as<decltype(std::ranges::end(std::move(v))),\n+\t\tdecltype(end(r))>);\n+  static_assert(noexcept(std::ranges::end(std::move(v))));\n+  VERIFY( std::ranges::end(std::move(v)) == end(r) );\n+\n+  const RV cv{r};\n+  static_assert(same_as<decltype(std::ranges::end(std::move(cv))),\n+\t\tdecltype(end(c))>);\n+  static_assert(!noexcept(std::ranges::end(std::move(cv))));\n+  VERIFY( std::ranges::end(std::move(cv)) == end(c) );\n }\n \n struct RR\n@@ -123,6 +137,9 @@ struct RR\n   friend const int* end(const RR&& r) noexcept { return r.a + 3; }\n };\n \n+// N.B. this is a lie, end on an RR rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<RR> = true;\n+\n void\n test04()\n {\n@@ -131,14 +148,14 @@ test04()\n   VERIFY( std::ranges::end(r) == &r.s );\n   static_assert(noexcept(std::ranges::end(r)));\n \n-  VERIFY( std::ranges::end(std::move(r)) == r.a + 1 );\n-  static_assert(!noexcept(std::ranges::end(std::move(r))));\n+  VERIFY( std::ranges::end(std::move(r)) == &r.s );\n+  static_assert(noexcept(std::ranges::end(std::move(r))));\n \n   VERIFY( std::ranges::end(c) == &r.l );\n   static_assert(!noexcept(std::ranges::end(c)));\n \n-  VERIFY( std::ranges::end(std::move(c)) == r.a + 3 );\n-  static_assert(noexcept(std::ranges::end(std::move(c))));\n+  VERIFY( std::ranges::end(std::move(c)) == &r.l );\n+  static_assert(!noexcept(std::ranges::end(std::move(c))));\n }\n \n int"}, {"sha": "aecbc2bb8af26fe8221589fc6add6a79e910150f", "filename": "libstdc++-v3/testsuite/std/ranges/access/rbegin.cc", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -31,26 +31,31 @@ struct R1\n   friend constexpr const int* rbegin(const R1&& r) { return &r.j; }\n };\n \n+// N.B. this is a lie, rbegin on an R1 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R1> = true;\n+\n void\n test01()\n {\n   constexpr R1 r;\n   static_assert( std::ranges::rbegin(r) == &r.i );\n-  static_assert( std::ranges::rbegin(std::move(r)) == &r.j );\n+  static_assert( std::ranges::rbegin(std::move(r)) == &r.i );\n }\n \n struct R2\n {\n   int a[2] = { };\n-  long l[2] = { };\n \n   constexpr const int* begin() const { return a; }\n   constexpr const int* end() const { return a + 2; }\n \n-  friend constexpr const long* begin(const R2&& r) { return r.l; }\n-  friend constexpr const long* end(const R2&& r) { return r.l + 2; }\n+  friend constexpr const long* begin(const R2&&); // not defined\n+  friend constexpr const long* end(const R2&&); // not defined\n };\n \n+// N.B. this is a lie, begin/end on an R2 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R2> = true;\n+\n void\n test02()\n {"}, {"sha": "b447e97b27c5f1ecfcc905ab9117dc61e1ed025f", "filename": "libstdc++-v3/testsuite/std/ranges/access/rend.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -29,16 +29,19 @@ struct R1\n \n   constexpr const int* rbegin() const { return &i; }\n   constexpr const int* rend() const { return &i + 1; }\n-  friend constexpr const int* rbegin(const R1&& r) { return &r.j; }\n-  friend constexpr const int* rend(const R1&& r) { return &r.j + 1; }\n+  friend constexpr const int* rbegin(const R1&&); // not defined\n+  friend constexpr const int* rend(const R1&&); // not defined\n };\n \n+// N.B. this is a lie, rend on an R1 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R1> = true;\n+\n void\n test01()\n {\n   constexpr R1 r;\n   static_assert( std::ranges::rend(r) == &r.i + 1 );\n-  static_assert( std::ranges::rend(std::move(r)) == &r.j + 1 );\n+  static_assert( std::ranges::rend(std::move(r)) == &r.i + 1 );\n }\n \n struct R2\n@@ -53,6 +56,9 @@ struct R2\n   friend constexpr const long* end(const R2&& r) { return r.l + 2; }\n };\n \n+// N.B. this is a lie, begin/end on an R2 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R2> = true;\n+\n void\n test02()\n {"}, {"sha": "b23e51fde559a6961c360e4158e5e12de8f6c47c", "filename": "libstdc++-v3/testsuite/std/ranges/empty_view.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fempty_view.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -31,5 +31,5 @@ static_assert(e.end() == nullptr);\n static_assert(e.data() == nullptr);\n static_assert(e.empty());\n \n-static_assert(begin(e) == nullptr);\n-static_assert(end(e) == nullptr);\n+static_assert(std::ranges::begin(e) == nullptr);\n+static_assert(std::ranges::end(e) == nullptr);"}, {"sha": "0cf30856d1508143e08a7d788b73df929809ce77", "filename": "libstdc++-v3/testsuite/std/ranges/safe_range.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <ranges>\n+#include <testsuite_iterators.h>\n+\n+static_assert( std::ranges::safe_range<int(&)[1]> );\n+static_assert( std::ranges::safe_range<const int(&)[1]> );\n+static_assert( !std::ranges::safe_range<int[1]> );\n+static_assert( !std::ranges::safe_range<int*> );\n+\n+using __gnu_test::test_contiguous_range;\n+\n+static_assert( !std::ranges::safe_range<test_contiguous_range<int>> );\n+static_assert( std::ranges::safe_range<test_contiguous_range<int>&> );\n+static_assert( !std::ranges::safe_range<test_contiguous_range<int>&&> );\n+\n+template<>\n+constexpr bool\n+  std::ranges::enable_safe_range<test_contiguous_range<long>> = true;\n+\n+static_assert( std::ranges::safe_range<test_contiguous_range<long>> );\n+static_assert( std::ranges::safe_range<test_contiguous_range<long>&> );\n+static_assert( std::ranges::safe_range<test_contiguous_range<long>&&> );"}, {"sha": "e730ec0a530772ccf9cabb2cc2472bb9f4010dad", "filename": "libstdc++-v3/testsuite/std/ranges/safe_range_types.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range_types.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range_types.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fsafe_range_types.cc?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <ranges>\n+#include <span>\n+#include <string>\n+#include <experimental/string_view>\n+\n+template<typename T>\n+constexpr bool\n+rvalue_is_safe_range()\n+{\n+  using std::ranges::safe_range;\n+\n+  // An lvalue range always models safe_range\n+  static_assert( safe_range<T&> );\n+  static_assert( safe_range<const T&> );\n+\n+  // Result should not depend on addition of const or rvalue-reference.\n+  static_assert( safe_range<T&&> == safe_range<T> );\n+  static_assert( safe_range<const T> == safe_range<T> );\n+  static_assert( safe_range<const T&&> == safe_range<T> );\n+\n+  return std::ranges::safe_range<T>;\n+}\n+\n+static_assert( rvalue_is_safe_range<std::ranges::subrange<int*, int*>>() );\n+static_assert( rvalue_is_safe_range<std::ranges::empty_view<int>>() );\n+static_assert( rvalue_is_safe_range<std::ranges::iota_view<int>>() );\n+static_assert( rvalue_is_safe_range<std::ranges::iota_view<int, int>>() );\n+\n+static_assert( rvalue_is_safe_range<std::span<int>>() );\n+static_assert( rvalue_is_safe_range<std::span<int, 99>>() );\n+\n+static_assert( ! rvalue_is_safe_range<std::string>() );\n+static_assert( ! rvalue_is_safe_range<std::wstring>() );\n+\n+static_assert( rvalue_is_safe_range<std::string_view>() );\n+static_assert( rvalue_is_safe_range<std::wstring_view>() );\n+\n+static_assert( rvalue_is_safe_range<std::experimental::string_view>() );\n+static_assert( rvalue_is_safe_range<std::experimental::wstring_view>() );"}, {"sha": "3dac911129a0b97e69d4b77d0b296da75c7a8e53", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b2e3879db9a251a2e7ff2553e188682d202c7e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=b5b2e3879db9a251a2e7ff2553e188682d202c7e", "patch": "@@ -758,6 +758,11 @@ namespace __gnu_test\n   template<typename T>\n     using test_output_sized_range\n       = test_sized_range<T, output_iterator_wrapper>;\n+\n+// test_container, test_range and test_sized_range do not own their elements,\n+// so they all model std::ranges::safe_range. This file does not define\n+// specializations of std::ranges::enable_safe_range, so that individual\n+// test can decide whether or not to do so.\n #endif // C++20\n } // namespace __gnu_test\n #endif // _TESTSUITE_ITERATORS"}]}