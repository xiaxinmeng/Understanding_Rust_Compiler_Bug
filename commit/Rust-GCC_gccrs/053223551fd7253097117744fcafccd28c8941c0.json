{"sha": "053223551fd7253097117744fcafccd28c8941c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUzMjIzNTUxZmQ3MjUzMDk3MTE3NzQ0ZmNhZmNjZDI4Yzg5NDFjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-23T10:00:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-23T10:00:19Z"}, "message": "re PR tree-optimization/54937 (Invalid loop bound estimate)\n\n\n\tPR middle-end/54937\n\t* tree-ssa-loop-niter.c (record_estimate): Do not try to lower\n\tthe bound of non-is_exit statements.\n\t(maybe_lower_iteration_bound): Do it here.\n\t(estimate_numbers_of_iterations_loop): Call it.\n\t* gcc.c-torture/execute/pr54937.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-2.c: Update.\n\nFrom-SVN: r192710", "tree": {"sha": "01d502a4a89d9cd1c28d2e29499fd563893cfe5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01d502a4a89d9cd1c28d2e29499fd563893cfe5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/053223551fd7253097117744fcafccd28c8941c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053223551fd7253097117744fcafccd28c8941c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/053223551fd7253097117744fcafccd28c8941c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053223551fd7253097117744fcafccd28c8941c0/comments", "author": null, "committer": null, "parents": [{"sha": "1a7de2015dfb81f40015a95be98abe50ad7382f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7de2015dfb81f40015a95be98abe50ad7382f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7de2015dfb81f40015a95be98abe50ad7382f0"}], "stats": {"total": 157, "additions": 147, "deletions": 10}, "files": [{"sha": "815c5824ac49723584386db8c5791e76ac54f909", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053223551fd7253097117744fcafccd28c8941c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053223551fd7253097117744fcafccd28c8941c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=053223551fd7253097117744fcafccd28c8941c0", "patch": "@@ -1,3 +1,11 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/54937\n+\t* tree-ssa-loop-niter.c (record_estimate): Do not try to lower\n+\tthe bound of non-is_exit statements.\n+\t(maybe_lower_iteration_bound): Do it here.\n+\t(estimate_numbers_of_iterations_loop): Call it.\n+\n 2012-10-23  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/54967"}, {"sha": "7a6d25847b638cb35bbfde5bc9a90eae61af6259", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=053223551fd7253097117744fcafccd28c8941c0", "patch": "@@ -1,3 +1,9 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/54937\n+\t* gcc.c-torture/execute/pr54937.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-2.c: Update.\n+\n 2012-10-23  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/54967"}, {"sha": "13dae6063f975986aa52634d8a2f5726b742ffb2", "filename": "gcc/testsuite/gcc.c-torture/execute/pr54937.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54937.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54937.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54937.c?ref=053223551fd7253097117744fcafccd28c8941c0", "patch": "@@ -0,0 +1,22 @@\n+\n+void exit (int);\n+void abort (void);\n+int a[1];\n+void (*terminate_me)(int);\n+\n+__attribute__((noinline,noclone))\n+t(int c)\n+{ int i;\n+  for (i=0;i<c;i++)\n+    {\n+      if (i)\n+       terminate_me(0);\n+      a[i]=0;\n+    }\n+}\n+main()\n+{\n+  terminate_me = exit;\n+  t(100);\n+  abort();\n+}"}, {"sha": "8a54a801c6edb3dc7ab5255d533a2f70ea03afd4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c?ref=053223551fd7253097117744fcafccd28c8941c0", "patch": "@@ -12,5 +12,5 @@ test(int c)\n     }\n }\n /* We are not able to get rid of the final conditional because the loop has two exits.  */\n-/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 2 times..\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 1 times..\" \"cunroll\"} } */\n /* { dg-final { cleanup-tree-dump \"cunroll\" } } */"}, {"sha": "054aff30954606bf06048458e664273915e76ccd", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 110, "deletions": 9, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053223551fd7253097117744fcafccd28c8941c0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=053223551fd7253097117744fcafccd28c8941c0", "patch": "@@ -2535,7 +2535,6 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n \t\t gimple at_stmt, bool is_exit, bool realistic, bool upper)\n {\n   double_int delta;\n-  edge exit;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2570,14 +2569,10 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n     }\n \n   /* Update the number of iteration estimates according to the bound.\n-     If at_stmt is an exit or dominates the single exit from the loop,\n-     then the loop latch is executed at most BOUND times, otherwise\n-     it can be executed BOUND + 1 times.  */\n-  exit = single_exit (loop);\n-  if (is_exit\n-      || (exit != NULL\n-\t  && dominated_by_p (CDI_DOMINATORS,\n-\t\t\t     exit->src, gimple_bb (at_stmt))))\n+     If at_stmt is an exit then the loop latch is executed at most BOUND times,\n+     otherwise it can be executed BOUND + 1 times.  We will lower the estimate\n+     later if such statement must be executed on last iteration  */\n+  if (is_exit)\n     delta = double_int_zero;\n   else\n     delta = double_int_one;\n@@ -2953,6 +2948,110 @@ gcov_type_to_double_int (gcov_type val)\n   return ret;\n }\n \n+/* See if every path cross the loop goes through a statement that is known\n+   to not execute at the last iteration. In that case we can decrese iteration\n+   count by 1.  */\n+\n+static void\n+maybe_lower_iteration_bound (struct loop *loop)\n+{\n+  pointer_set_t *not_executed_last_iteration = pointer_set_create ();\n+  struct nb_iter_bound *elt;\n+  bool found_exit = false;\n+  VEC (basic_block, heap) *queue = NULL;\n+  bitmap visited;\n+\n+  /* Collect all statements with interesting (i.e. lower than\n+     nb_iterations_upper_bound) bound on them. \n+\n+     TODO: Due to the way record_estimate choose estimates to store, the bounds\n+     will be always nb_iterations_upper_bound-1.  We can change this to record\n+     also statements not dominating the loop latch and update the walk bellow\n+     to the shortest path algorthm.  */\n+  for (elt = loop->bounds; elt; elt = elt->next)\n+    {\n+      if (!elt->is_exit\n+\t  && elt->bound.ult (loop->nb_iterations_upper_bound))\n+\t{\n+\t  if (!not_executed_last_iteration)\n+\t    not_executed_last_iteration = pointer_set_create ();\n+\t  pointer_set_insert (not_executed_last_iteration, elt->stmt);\n+\t}\n+    }\n+  if (!not_executed_last_iteration)\n+    return;\n+\n+  /* Start DFS walk in the loop header and see if we can reach the\n+     loop latch or any of the exits (including statements with side\n+     effects that may terminate the loop otherwise) without visiting\n+     any of the statements known to have undefined effect on the last\n+     iteration.  */\n+  VEC_safe_push (basic_block, heap, queue, loop->header);\n+  visited = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (visited, loop->header->index);\n+  found_exit = false;\n+\n+  do\n+    {\n+      basic_block bb = VEC_pop (basic_block, queue);\n+      gimple_stmt_iterator gsi;\n+      bool stmt_found = false;\n+\n+      /* Loop for possible exits and statements bounding the execution.  */\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  if (pointer_set_contains (not_executed_last_iteration, stmt))\n+\t    {\n+\t      stmt_found = true;\n+\t      break;\n+\t    }\n+\t  if (gimple_has_side_effects (stmt))\n+\t    {\n+\t      found_exit = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (found_exit)\n+\tbreak;\n+\n+      /* If no bounding statement is found, continue the walk.  */\n+      if (!stmt_found)\n+\t{\n+          edge e;\n+          edge_iterator ei;\n+\n+          FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (loop_exit_edge_p (loop, e)\n+\t\t  || e == loop_latch_edge (loop))\n+\t\t{\n+\t\t  found_exit = true;\n+\t\t  break;\n+\t\t}\n+\t      if (bitmap_set_bit (visited, e->dest->index))\n+\t\tVEC_safe_push (basic_block, heap, queue, e->dest);\n+\t    }\n+\t}\n+    }\n+  while (VEC_length (basic_block, queue) && !found_exit);\n+\n+  /* If every path through the loop reach bounding statement before exit,\n+     then we know the last iteration of the loop will have undefined effect\n+     and we can decrease number of iterations.  */\n+    \n+  if (!found_exit)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Reducing loop iteration estimate by 1; \"\n+\t\t \"undefined statement must be executed at the last iteration.\\n\");\n+      record_niter_bound (loop, loop->nb_iterations_upper_bound - double_int_one,\n+\t\t\t  false, true);\n+    }\n+  BITMAP_FREE (visited);\n+  VEC_free (basic_block, heap, queue);\n+}\n+\n /* Records estimates on numbers of iterations of LOOP.  If USE_UNDEFINED_P\n    is true also use estimates derived from undefined behavior.  */\n \n@@ -2996,6 +3095,8 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \n   infer_loop_bounds_from_undefined (loop);\n \n+  maybe_lower_iteration_bound (loop);\n+\n   /* If we have a measured profile, use it to estimate the number of\n      iterations.  */\n   if (loop->header->count != 0)"}]}