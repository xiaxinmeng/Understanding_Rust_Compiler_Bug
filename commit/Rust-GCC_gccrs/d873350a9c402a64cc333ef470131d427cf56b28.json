{"sha": "d873350a9c402a64cc333ef470131d427cf56b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg3MzM1MGE5YzQwMmE2NGNjMzMzZWY0NzAxMzFkNDI3Y2Y1NmIyOA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-15T15:39:12Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T21:33:58Z"}, "message": "d: Use new isXxxxExp helpers where possible\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc (build_attributes): Use isXxxxExp helpers instead of\n\texplicit casts.\n\t* d-codegen.cc (d_build_call): Likewise.\n\t* d-compiler.cc (Compiler::paintAsType): Likewise.\n\t* decl.cc (ExprVisitor::visit): Likewise.\n\t(layout_class_initializer): Likewise.\n\t* expr.cc (ExprVisitor::lvalue_p): Likewise\n\t(ExprVisitor::visit): Likewise.\n\t* types.cc (layout_aggregate_members): Likewise.", "tree": {"sha": "ec6eec46d4a04dfdb16d314e9e36fa69d2e93081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec6eec46d4a04dfdb16d314e9e36fa69d2e93081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d873350a9c402a64cc333ef470131d427cf56b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d873350a9c402a64cc333ef470131d427cf56b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d873350a9c402a64cc333ef470131d427cf56b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d873350a9c402a64cc333ef470131d427cf56b28/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c4db916e28bf97a729ec06ff71da03963f0f7e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4db916e28bf97a729ec06ff71da03963f0f7e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c4db916e28bf97a729ec06ff71da03963f0f7e4"}], "stats": {"total": 87, "additions": 46, "deletions": 41}, "files": [{"sha": "7e55b42fd03c80ae72fc1c1535a0c5f5b27c332e", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -268,7 +268,7 @@ build_attributes (Expressions *eattrs)\n       /* Should now have a struct `Attribute(\"attrib\", \"value\", ...)'\n \t initializer list.  */\n       gcc_assert (attr->op == TOKstructliteral);\n-      Expressions *elems = ((StructLiteralExp*) attr)->elements;\n+      Expressions *elems = attr->isStructLiteralExp ()->elements;\n       Expression *e0 = (*elems)[0];\n \n       if (e0->op != TOKstring)\n@@ -300,10 +300,10 @@ build_attributes (Expressions *eattrs)\n       for (size_t j = 1; j < elems->length; j++)\n \t{\n \t  Expression *e = (*elems)[j];\n+\t  StringExp *s = e->isStringExp ();\n \t  tree t;\n-\t  if (e->op == TOKstring && ((StringExp *) e)->sz == 1)\n+\t  if (s != NULL && s->sz == 1)\n \t    {\n-\t      StringExp *s = (StringExp *) e;\n \t      const char *string = (const char *)(s->len ? s->string : \"\");\n \t      t = build_string (s->len, string);\n \t    }"}, {"sha": "d31638e2c1d2e09e7598aca728475e99f74e1d82", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -1874,7 +1874,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \n \t  if (arg->op == TOKcomma)\n \t    {\n-\t      CommaExp *ce = (CommaExp *) arg;\n+\t      CommaExp *ce = arg->isCommaExp ();\n \t      tree tce = build_expr (ce->e1);\n \t      saved_args = compound_expr (saved_args, tce);\n \t      (*arguments)[i] = ce->e2;"}, {"sha": "41b3b53207aafc11fb9053bb2f2907896c37173d", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -88,7 +88,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n   else if (expr->op == TOKarrayliteral)\n     {\n       /* Build array as VECTOR_CST, assumes EXPR is constant.  */\n-      Expressions *elements = ((ArrayLiteralExp *) expr)->elements;\n+      Expressions *elements = expr->isArrayLiteralExp ()->elements;\n       vec<constructor_elt, va_gc> *elms = NULL;\n \n       vec_safe_reserve (elms, elements->length);\n@@ -136,7 +136,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n       Expression *e = d_eval_constant_expression (cst);\n       gcc_assert (e != NULL && e->op == TOKvector);\n \n-      return ((VectorExp *) e)->e1;\n+      return e->isVectorExp ()->e1;\n     }\n   else\n     {"}, {"sha": "28d1d6d5f31dfafb9c931ae3c7294fd3dd59de11", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -218,12 +218,11 @@ class DeclVisitor : public Visitor\n     for (size_t i = 0; i < d->objects->length; i++)\n       {\n \tRootObject *o = (*d->objects)[i];\n-\tif ((o->dyncast () == DYNCAST_EXPRESSION)\n-\t    && ((Expression *) o)->op == TOKdsymbol)\n+\tif (o->dyncast () == DYNCAST_EXPRESSION)\n \t  {\n-\t    Declaration *d = ((DsymbolExp *) o)->s->isDeclaration ();\n-\t    if (d)\n-\t      this->build_dsymbol (d);\n+\t    DsymbolExp *de = ((Expression *) o)->isDsymbolExp ();\n+\t    if (de != NULL && de->s->isDeclaration ())\n+\t      this->build_dsymbol (de->s);\n \t  }\n       }\n   }\n@@ -2239,7 +2238,7 @@ layout_class_initializer (ClassDeclaration *cd)\n   Expression *e = ne->ctfeInterpret ();\n   gcc_assert (e->op == TOKclassreference);\n \n-  return build_class_instance ((ClassReferenceExp *) e);\n+  return build_class_instance (e->isClassReferenceExp ());\n }\n \n tree"}, {"sha": "06cd83a737d1d74eb673a2dbb43537d62eb375ba", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -90,9 +90,15 @@ class ExprVisitor : public Visitor\n \n   bool lvalue_p (Expression *e)\n   {\n-    return ((e->op != TOKslice && e->isLvalue ())\n-\t    || (e->op == TOKslice && ((UnaExp *) e)->e1->isLvalue ())\n-\t    || (e->op == TOKcast && ((UnaExp *) e)->e1->isLvalue ()));\n+    SliceExp *se = e->isSliceExp ();\n+    if (se != NULL && se->e1->isLvalue ())\n+      return true;\n+\n+    CastExp *ce = e->isCastExp ();\n+    if (ce != NULL && ce->e1->isLvalue ())\n+      return true;\n+\n+    return (e->op != TOKslice && e->isLvalue ());\n   }\n \n   /* Build an expression of code CODE, data type TYPE, and operands ARG0 and\n@@ -174,7 +180,7 @@ class ExprVisitor : public Visitor\n     Expression *e1b = e1;\n     while (e1b->op == TOKcast)\n       {\n-\tCastExp *ce = (CastExp *) e1b;\n+\tCastExp *ce = e1b->isCastExp ();\n \tgcc_assert (same_type_p (ce->type, ce->to));\n \te1b = ce->e1;\n       }\n@@ -679,7 +685,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    if (ex->op == TOKcat)\n \t      {\n-\t\tex = ((CatExp *) ex)->e1;\n+\t\tex = ex->isCatExp ()->e1;\n \t\tndims++;\n \t      }\n \t  }\n@@ -696,7 +702,7 @@ class ExprVisitor : public Visitor\n \tfor (Expression *oe = ce->e2; oe != NULL;\n \t     (ce->e1->op != TOKcat\n \t      ? (oe = ce->e1)\n-\t      : (ce = (CatExp *)ce->e1, oe = ce->e2)))\n+\t      : (ce = ce->e1->isCatExp (), oe = ce->e2)))\n \t  {\n \t    tree arg = d_array_convert (etype, oe);\n \t    tree index = size_int (dim);\n@@ -790,7 +796,7 @@ class ExprVisitor : public Visitor\n \t   Strip off casts just incase anyway.  */\n \twhile (e1b->op == TOKcast)\n \t  {\n-\t    CastExp *ce = (CastExp *) e1b;\n+\t    CastExp *ce = e1b->isCastExp ();\n \t    gcc_assert (same_type_p (ce->type, ce->to));\n \t    e1b = ce->e1;\n \t  }\n@@ -883,7 +889,7 @@ class ExprVisitor : public Visitor\n     if (e->e1->op == TOKarraylength)\n       {\n \t/* Assignment to an array's length property; resize the array.  */\n-\tArrayLengthExp *ale = (ArrayLengthExp *) e->e1;\n+\tArrayLengthExp *ale = e->e1->isArrayLengthExp ();\n \ttree newlength = convert_expr (build_expr (e->e2), e->e2->type,\n \t\t\t\t       Type::tsize_t);\n \ttree ptr = build_address (build_expr (ale->e1));\n@@ -904,7 +910,7 @@ class ExprVisitor : public Visitor\n     /* Look for array[] = n;  */\n     if (e->e1->op == TOKslice)\n       {\n-\tSliceExp *se = (SliceExp *) e->e1;\n+\tSliceExp *se = e->e1->isSliceExp ();\n \tType *stype = se->e1->type->toBasetype ();\n \tType *etype = stype->nextOf ()->toBasetype ();\n \n@@ -998,7 +1004,7 @@ class ExprVisitor : public Visitor\n \tgcc_assert (e->op == TOKconstruct || e->op == TOKblit);\n \tgcc_assert (e->e1->op == TOKvar);\n \n-\tDeclaration *decl = ((VarExp *) e->e1)->var;\n+\tDeclaration *decl = e->e1->isVarExp ()->var;\n \tif (decl->storage_class & (STCout | STCref))\n \t  {\n \t    tree t2 = convert_for_assignment (build_expr (e->e2),\n@@ -1443,7 +1449,7 @@ class ExprVisitor : public Visitor\n \n \tif (e->e1->op == TOKvar)\n \t  {\n-\t    VarDeclaration *v = ((VarExp *) e->e1)->var->isVarDeclaration ();\n+\t    VarDeclaration *v = e->e1->isVarExp ()->var->isVarDeclaration ();\n \t    if (v && v->onstack)\n \t      {\n \t\tlibcall = tb1->isClassHandle ()->isInterfaceDeclaration ()\n@@ -1588,19 +1594,19 @@ class ExprVisitor : public Visitor\n \n     if (e->e1->op == TOKadd)\n       {\n-\tBinExp *be = (BinExp *) e->e1;\n-\tif (be->e1->op == TOKaddress\n-\t    && be->e2->isConst () && be->e2->type->isintegral ())\n+\tAddExp *ae = e->e1->isAddExp ();\n+\tif (ae->e1->op == TOKaddress\n+\t    && ae->e2->isConst () && ae->e2->type->isintegral ())\n \t  {\n-\t    Expression *ae = ((AddrExp *) be->e1)->e1;\n-\t    tnext = ae->type->toBasetype ();\n-\t    result = build_expr (ae);\n-\t    offset = be->e2->toUInteger ();\n+\t    Expression *ex = ae->e1->isAddrExp ()->e1;\n+\t    tnext = ex->type->toBasetype ();\n+\t    result = build_expr (ex);\n+\t    offset = ae->e2->toUInteger ();\n \t  }\n       }\n     else if (e->e1->op == TOKsymoff)\n       {\n-\tSymOffExp *se = (SymOffExp *) e->e1;\n+\tSymOffExp *se = e->e1->isSymOffExp ();\n \tif (!declaration_reference_p (se->var))\n \t  {\n \t    tnext = se->var->type->toBasetype ();\n@@ -1652,7 +1658,7 @@ class ExprVisitor : public Visitor\n        Taking the address of a struct literal is otherwise illegal.  */\n     if (e->e1->op == TOKstructliteral)\n       {\n-\tStructLiteralExp *sle = ((StructLiteralExp *) e->e1)->origin;\n+\tStructLiteralExp *sle = e->e1->isStructLiteralExp ()->origin;\n \tgcc_assert (sle != NULL);\n \n \t/* Build the reference symbol, the decl is built first as the\n@@ -1690,21 +1696,21 @@ class ExprVisitor : public Visitor\n     /* Calls to delegates can sometimes look like this.  */\n     if (e1b->op == TOKcomma)\n       {\n-\te1b = ((CommaExp *) e1b)->e2;\n+\te1b = e1b->isCommaExp ()->e2;\n \tgcc_assert (e1b->op == TOKvar);\n \n-\tDeclaration *var = ((VarExp *) e1b)->var;\n+\tDeclaration *var = e1b->isVarExp ()->var;\n \tgcc_assert (var->isFuncDeclaration () && !var->needThis ());\n       }\n \n     if (e1b->op == TOKdotvar && tb->ty != Tdelegate)\n       {\n-\tDotVarExp *dve = (DotVarExp *) e1b;\n+\tDotVarExp *dve = e1b->isDotVarExp ();\n \n \t/* Don't modify the static initializer for struct literals.  */\n \tif (dve->e1->op == TOKstructliteral)\n \t  {\n-\t    StructLiteralExp *sle = (StructLiteralExp *) dve->e1;\n+\t    StructLiteralExp *sle = dve->e1->isStructLiteralExp ();\n \t    sle->useStaticInit = false;\n \t  }\n \n@@ -1767,7 +1773,7 @@ class ExprVisitor : public Visitor\n \t    /* This gets the true function type, getting the function type\n \t       from e1->type can sometimes be incorrect, such as when calling\n \t       a 'ref' return function.  */\n-\t    tf = get_function_type (((DotVarExp *) e1b)->var->type);\n+\t    tf = get_function_type (e1b->isDotVarExp ()->var->type);\n \t  }\n \telse\n \t  tf = get_function_type (tb);\n@@ -1784,7 +1790,7 @@ class ExprVisitor : public Visitor\n       }\n     else if (e1b->op == TOKvar)\n       {\n-\tFuncDeclaration *fd = ((VarExp *) e1b)->var->isFuncDeclaration ();\n+\tFuncDeclaration *fd = e1b->isVarExp ()->var->isFuncDeclaration ();\n \tgcc_assert (fd != NULL);\n \ttf = get_function_type (fd->type);\n \n@@ -2145,7 +2151,7 @@ class ExprVisitor : public Visitor\n   void visit (SymOffExp *e)\n   {\n     /* Build the address and offset of the symbol.  */\n-    size_t soffset = ((SymOffExp *) e)->offset;\n+    size_t soffset = e->isSymOffExp ()->offset;\n     tree result = get_decl_tree (e->var);\n     TREE_USED (result) = 1;\n \n@@ -2956,7 +2962,7 @@ class ExprVisitor : public Visitor\n     /* First handle array literal expressions.  */\n     if (e->e1->op == TOKarrayliteral)\n       {\n-\tArrayLiteralExp *ale = ((ArrayLiteralExp *) e->e1);\n+\tArrayLiteralExp *ale = e->e1->isArrayLiteralExp ();\n \tvec<constructor_elt, va_gc> *elms = NULL;\n \tbool constant_p = true;\n "}, {"sha": "ba7e29a12e1e73339632294c15587c279fd5fad5", "filename": "gcc/d/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d873350a9c402a64cc333ef470131d427cf56b28/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=d873350a9c402a64cc333ef470131d427cf56b28", "patch": "@@ -292,7 +292,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t\t  gcc_assert (ro->dyncast () == DYNCAST_EXPRESSION);\n \t\t  Expression *e = (Expression *) ro;\n \t\t  gcc_assert (e->op == TOKdsymbol);\n-\t\t  DsymbolExp *se = (DsymbolExp *) e;\n+\t\t  DsymbolExp *se = e->isDsymbolExp ();\n \n \t\t  tmembers.push (se->s);\n \t\t}"}]}