{"sha": "b9b2c339633c658046d481aa0db0d3c1008a4595", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjliMmMzMzk2MzNjNjU4MDQ2ZDQ4MWFhMGRiMGQzYzEwMDhhNDU5NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-28T08:44:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-28T08:44:16Z"}, "message": "i386.md (cmp?i): Simplify; refuse immediate operand in alternative 0\n\n\n\t* i386.md (cmp?i): Simplify; refuse immediate operand\n\tin alternative 0\n\t* i386.c (cmpsi_operand): Refuse constants.\n\n\t* i386.md (movsi_insv_1, movsi_insv_1_rex64): Allow immediate operand.\n\n\t* flow.c (block_label, redirect_edge_and_branch): Split out from ....\n\t(split_edge) .... here;\n\nFrom-SVN: r43635", "tree": {"sha": "af20ee6990ac9b4117e28a11c414e4b18829ccd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af20ee6990ac9b4117e28a11c414e4b18829ccd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9b2c339633c658046d481aa0db0d3c1008a4595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b2c339633c658046d481aa0db0d3c1008a4595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b2c339633c658046d481aa0db0d3c1008a4595", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b2c339633c658046d481aa0db0d3c1008a4595/comments", "author": null, "committer": null, "parents": [{"sha": "72beea565337f58c8de18df182ace2e8e30746d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72beea565337f58c8de18df182ace2e8e30746d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72beea565337f58c8de18df182ace2e8e30746d2"}], "stats": {"total": 205, "additions": 116, "deletions": 89}, "files": [{"sha": "2784e01aa6ae27e0388e107b2e05a5f9e79becea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9b2c339633c658046d481aa0db0d3c1008a4595", "patch": "@@ -1,3 +1,14 @@\n+Thu Jun 28 10:31:06 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (cmp?i): Simplify; refuse immediate operand\n+\tin alternative 0\n+\t* i386.c (cmpsi_operand): Refuse constants.\n+\n+\t* i386.md (movsi_insv_1, movsi_insv_1_rex64): Allow immediate operand.\n+\n+\t* flow.c (block_label, redirect_edge_and_branch): Split out from ....\n+\t(split_edge) .... here;\n+\n 2001-06-28  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* i386/i386.c (ix86_valid_type_attribute_p): Give external"}, {"sha": "3d702ea3f3c54c500add47712795d7559da0802c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b9b2c339633c658046d481aa0db0d3c1008a4595", "patch": "@@ -1794,7 +1794,7 @@ cmpsi_operand (op, mode)\n       rtx op;\n       enum machine_mode mode;\n {\n-  if (general_operand (op, mode))\n+  if (nonimmediate_operand (op, mode))\n     return 1;\n \n   if (GET_CODE (op) == AND"}, {"sha": "713981a3c68936998b73b2be7fc89605b0b90264", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b9b2c339633c658046d481aa0db0d3c1008a4595", "patch": "@@ -1003,13 +1003,12 @@\n \n (define_expand \"cmpdi\"\n   [(set (reg:CC 17)\n-\t(compare:CC (match_operand:DI 0 \"x86_64_general_operand\" \"\")\n+\t(compare:CC (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t\t    (match_operand:DI 1 \"x86_64_general_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if ((GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-      || (CONSTANT_P (operands[0]) && CONSTANT_P (operands[1])))\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[0] = force_reg (DImode, operands[0]);\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -1023,8 +1022,7 @@\n   \"\"\n   \"\n {\n-  if ((GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-      || (CONSTANT_P (operands[0]) && CONSTANT_P (operands[1])))\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[0] = force_reg (SImode, operands[0]);\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -1033,13 +1031,12 @@\n \n (define_expand \"cmphi\"\n   [(set (reg:CC 17)\n-\t(compare:CC (match_operand:HI 0 \"general_operand\" \"\")\n+\t(compare:CC (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t\t    (match_operand:HI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if ((GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-      || (CONSTANT_P (operands[0]) && CONSTANT_P (operands[1])))\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[0] = force_reg (HImode, operands[0]);\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -1048,13 +1045,12 @@\n \n (define_expand \"cmpqi\"\n   [(set (reg:CC 17)\n-\t(compare:CC (match_operand:QI 0 \"general_operand\" \"\")\n+\t(compare:CC (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t\t    (match_operand:QI 1 \"general_operand\" \"\")))]\n   \"TARGET_QIMODE_MATH\"\n   \"\n {\n-  if ((GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-      || (CONSTANT_P (operands[0]) && CONSTANT_P (operands[1])))\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[0] = force_reg (QImode, operands[0]);\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -1953,7 +1949,7 @@\n (define_expand \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"\"))\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"! TARGET_PARTIAL_REG_STALL\"\n+  \"! TARGET_PARTIAL_REG_STALL || optimize_size\"\n   \"\n {\n   /* Don't generate memory->memory moves, go through a register */\n@@ -1964,7 +1960,7 @@\n (define_insn \"*movstricthi_1\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+rm,r\"))\n \t(match_operand:HI 1 \"general_operand\" \"rn,m\"))]\n-  \"! TARGET_PARTIAL_REG_STALL\n+  \"(! TARGET_PARTIAL_REG_STALL || optimize_size)\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"mov{w}\\\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"imov\")\n@@ -1974,7 +1970,8 @@\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n \t(match_operand:HI 1 \"const0_operand\" \"i\"))\n    (clobber (reg:CC 17))]\n-  \"reload_completed && (!TARGET_USE_MOV0 || optimize_size)\"\n+  \"reload_completed\n+   && ((!TARGET_USE_MOV0 && !TARGET_PARTIAL_REG_STALL) || optimize_size)\"\n   \"xor{w}\\\\t{%0, %0|%0, %0}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"HI\")"}, {"sha": "010a63529c0aaeff32453b755317fc9934cc200c", "filename": "gcc/flow.c", "status": "modified", "additions": 93, "deletions": 74, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b2c339633c658046d481aa0db0d3c1008a4595/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b9b2c339633c658046d481aa0db0d3c1008a4595", "patch": "@@ -471,6 +471,8 @@ static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void allocate_bb_life_data\tPARAMS ((void));\n static void find_sub_basic_blocks\tPARAMS ((basic_block));\n+static int redirect_edge_and_branch \tPARAMS ((edge, basic_block));\n+static rtx block_label\t\t\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -1574,6 +1576,92 @@ split_block (bb, insn)\n   return new_edge;\n }\n \n+/* Return label in the head of basic block.  Create one if it doesn't exist.  */\n+static rtx\n+block_label (block)\n+     basic_block block;\n+{\n+  if (GET_CODE (block->head) != CODE_LABEL)\n+    block->head = emit_label_before (gen_label_rtx (), block->head);\n+  return block->head;\n+}\n+\n+/* Attempt to change code to redirect edge E to TARGET.\n+   Don't do that on expense of adding new instructions or reordering\n+   basic blocks.  */\n+static int\n+redirect_edge_and_branch (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  rtx insn = e->src->end;\n+  rtx tmp;\n+  rtx old_label = e->dest->head;\n+  if (e->flags & EDGE_FALLTHRU)\n+    return 0;\n+\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    abort ();\n+\n+  /* Recognize a tablejump and adjust all matching cases.  */\n+  if ((tmp = JUMP_LABEL (insn)) != NULL_RTX\n+      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n+      && GET_CODE (tmp) == JUMP_INSN\n+      && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n+    {\n+      rtvec vec;\n+      int j;\n+      rtx new_label = block_label (target);\n+\n+      if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n+\tvec = XVEC (PATTERN (tmp), 0);\n+      else\n+\tvec = XVEC (PATTERN (tmp), 1);\n+\n+      for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n+\tif (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n+\t  {\n+\t    RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (VOIDmode, new_label);\n+\t    --LABEL_NUSES (old_label);\n+\t    ++LABEL_NUSES (new_label);\n+\t  }\n+\n+      /* Handle casesi dispatch insns */\n+      if ((tmp = single_set (insn)) != NULL\n+\t  && SET_DEST (tmp) == pc_rtx\n+\t  && GET_CODE (SET_SRC (tmp)) == IF_THEN_ELSE\n+\t  && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF\n+\t  && XEXP (XEXP (SET_SRC (tmp), 2), 0) == old_label)\n+\t{\n+\t  XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t       new_label);\n+\t  --LABEL_NUSES (old_label);\n+\t  ++LABEL_NUSES (new_label);\n+\t}\n+    }\n+  else\n+    {\n+      /* ?? We may play the games with moving the named labels from\n+\t one basic block to the other in case only one computed_jump is\n+\t available.  */\n+      if (computed_jump_p (insn))\n+\treturn 0;\n+\n+      /* A return instruction can't be redirected.  */\n+      if (returnjump_p (insn))\n+\treturn 0;\n+\n+      /* If the insn doesn't go where we think, we're confused.  */\n+      if (JUMP_LABEL (insn) != old_label)\n+\tabort ();\n+      redirect_jump (insn, block_label (target), 0);\n+    }\n+\n+  redirect_edge_succ (e, target);\n+  return 1;\n+}\n+\n \n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n@@ -1598,15 +1686,6 @@ split_edge (edge_in)\n   old_pred = edge_in->src;\n   old_succ = edge_in->dest;\n \n-  /* Remove the existing edge from the destination's pred list.  */\n-  {\n-    edge *pp;\n-    for (pp = &old_succ->pred; *pp != edge_in; pp = &(*pp)->pred_next)\n-      continue;\n-    *pp = edge_in->pred_next;\n-    edge_in->pred_next = NULL;\n-  }\n-\n   /* Create the new structures.  */\n   bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n   edge_out = (edge) xcalloc (1, sizeof (*edge_out));\n@@ -1624,13 +1703,11 @@ split_edge (edge_in)\n     }\n \n   /* Wire them up.  */\n-  bb->pred = edge_in;\n   bb->succ = edge_out;\n   bb->count = edge_in->count;\n   bb->frequency = (edge_in->probability * edge_in->src->frequency\n \t\t   / REG_BR_PROB_BASE);\n \n-  edge_in->dest = bb;\n   edge_in->flags &= ~EDGE_CRITICAL;\n \n   edge_out->pred_next = old_succ->pred;\n@@ -1743,73 +1820,15 @@ split_edge (edge_in)\n   NOTE_BASIC_BLOCK (bb_note) = bb;\n   bb->head = bb->end = bb_note;\n \n-  /* Not quite simple -- for non-fallthru edges, we must adjust the\n-     predecessor's jump instruction to target our new block.  */\n+  /* For non-fallthry edges, we must adjust the predecessor's\n+     jump instruction to target our new block.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n-      rtx tmp, insn = old_pred->end;\n-      rtx old_label = old_succ->head;\n-      rtx new_label = gen_label_rtx ();\n-\n-      if (GET_CODE (insn) != JUMP_INSN)\n+      if (!redirect_edge_and_branch (edge_in, bb))\n \tabort ();\n-\n-      /* ??? Recognize a tablejump and adjust all matching cases.  */\n-      if ((tmp = JUMP_LABEL (insn)) != NULL_RTX\n-\t  && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n-\t  && GET_CODE (tmp) == JUMP_INSN\n-\t  && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n-\t{\n-\t  rtvec vec;\n-\t  int j;\n-\n-\t  if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n-\t    vec = XVEC (PATTERN (tmp), 0);\n-\t  else\n-\t    vec = XVEC (PATTERN (tmp), 1);\n-\n-\t  for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n-\t    if (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n-\t      {\n-\t\tRTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (VOIDmode, new_label);\n-\t\t--LABEL_NUSES (old_label);\n-\t\t++LABEL_NUSES (new_label);\n-\t      }\n-\n-\t  /* Handle casesi dispatch insns */\n-\t  if ((tmp = single_set (insn)) != NULL\n-\t      && SET_DEST (tmp) == pc_rtx\n-\t      && GET_CODE (SET_SRC (tmp)) == IF_THEN_ELSE\n-\t      && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF\n-\t      && XEXP (XEXP (SET_SRC (tmp), 2), 0) == old_label)\n-\t    {\n-\t      XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t   new_label);\n-\t      --LABEL_NUSES (old_label);\n-\t      ++LABEL_NUSES (new_label);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* This would have indicated an abnormal edge.  */\n-\t  if (computed_jump_p (insn))\n-\t    abort ();\n-\n-\t  /* A return instruction can't be redirected.  */\n-\t  if (returnjump_p (insn))\n-\t    abort ();\n-\n-\t  /* If the insn doesn't go where we think, we're confused.  */\n-\t  if (JUMP_LABEL (insn) != old_label)\n-\t    abort ();\n-\n-\t  redirect_jump (insn, new_label, 0);\n-\t}\n-\n-      emit_label_before (new_label, bb_note);\n-      bb->head = new_label;\n     }\n+  else\n+    redirect_edge_succ (edge_in, bb);\n \n   return bb;\n }"}]}