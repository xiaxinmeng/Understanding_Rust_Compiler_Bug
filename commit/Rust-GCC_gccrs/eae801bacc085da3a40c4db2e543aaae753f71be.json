{"sha": "eae801bacc085da3a40c4db2e543aaae753f71be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlODAxYmFjYzA4NWRhM2E0MGM0ZGIyZTU0M2FhYWU3NTNmNzFiZQ==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-01-16T19:50:43Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-01-16T19:50:43Z"}, "message": "libstdc++: Optimize synchronization in std::future if futexes are available.\n\n\t* src/c++11/futex.cc: New file.\n\t* include/bits/atomic_futex.h: New file.\n\t* include/std/future (__future_base::_State_baseV2): Use\n\tatomic_futex_unsigned instead of mutex+condvar.\n\t* src/c++11/futex.cc: Likewise.\n\t* include/Makefile.am: Add atomic_futex.h.\n\t* include/Makefile.in: Likewise.\n\t* src/c++11/Makefile.am: Add futex.cc.\n\t* src/c++11/Makefile.in: Likewise.\n\nFrom-SVN: r219770", "tree": {"sha": "7e0f7a52bc8fea8db2cc39c259441e1c7ab73feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0f7a52bc8fea8db2cc39c259441e1c7ab73feb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eae801bacc085da3a40c4db2e543aaae753f71be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae801bacc085da3a40c4db2e543aaae753f71be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae801bacc085da3a40c4db2e543aaae753f71be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae801bacc085da3a40c4db2e543aaae753f71be/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1175297f6ed139cf3019a13e8333c00cd5f91644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1175297f6ed139cf3019a13e8333c00cd5f91644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1175297f6ed139cf3019a13e8333c00cd5f91644"}], "stats": {"total": 512, "additions": 459, "deletions": 53}, "files": [{"sha": "4cd62b0c725c8e7a74f2cda53ba11279de0507c4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -1,3 +1,15 @@\n+2015-01-16  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* src/c++11/futex.cc: New file.\n+\t* include/bits/atomic_futex.h: New file.\n+\t* include/std/future (__future_base::_State_baseV2): Use\n+\tatomic_futex_unsigned instead of mutex+condvar.\n+\t* src/c++11/futex.cc: Likewise.\n+\t* include/Makefile.am: Add atomic_futex.h.\n+\t* include/Makefile.in: Likewise.\n+\t* src/c++11/Makefile.am: Add futex.cc.\n+\t* src/c++11/Makefile.in: Likewise.\n+\n 2015-01-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* acinclude.m4: Fix typo in comment."}, {"sha": "dc83ad4f70c4075e71d9863a1cdf4ebabc845152", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -1764,6 +1764,11 @@ GLIBCXX_3.4.21 {\n     _ZNSt7codecvtID[is]c11__mbstate_t*;\n     _ZT[ISV]St7codecvtID[is]c11__mbstate_tE;\n \n+    extern \"C++\"\n+    {\n+      std::__atomic_futex_unsigned_base*;\n+    };\n+\n } GLIBCXX_3.4.20;\n \n "}, {"sha": "4772950124a97d0828f267b68834b9984b814b8a", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -83,6 +83,7 @@ bits_headers = \\\n \t${bits_srcdir}/allocated_ptr.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n+\t${bits_srcdir}/atomic_futex.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "ebcaa9663fe24f45cff8d8a851ac32959aba3349", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -351,6 +351,7 @@ bits_headers = \\\n \t${bits_srcdir}/allocated_ptr.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n+\t${bits_srcdir}/atomic_futex.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "9a418d8a00bcdf426619e2bf2db8075436ba3989", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -0,0 +1,288 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/atomic_futex.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_ATOMIC_FUTEX_H\n+#define _GLIBCXX_ATOMIC_FUTEX_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <atomic>\n+#include <chrono>\n+#if !defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+#include <mutex>\n+#include <condition_variable>\n+#endif\n+\n+#ifndef _GLIBCXX_ALWAYS_INLINE\n+#define _GLIBCXX_ALWAYS_INLINE inline __attribute__((always_inline))\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#if defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+  struct __atomic_futex_unsigned_base\n+  {\n+    // Returns false iff a timeout occurred.\n+    bool\n+    _M_futex_wait_until(unsigned *__addr, unsigned __val, bool __has_timeout,\n+\tchrono::seconds __s, chrono::nanoseconds __ns);\n+\n+    // This can be executed after the object has been destroyed.\n+    static void _M_futex_notify_all(unsigned* __addr);\n+  };\n+\n+  template <unsigned _Waiter_bit = 0x80000000>\n+  struct __atomic_futex_unsigned : __atomic_futex_unsigned_base\n+  {\n+    typedef chrono::system_clock __clock_t;\n+\n+    // XXX We expect this to be lock-free, and having the payload at offset 0.\n+#if ATOMIC_INT_LOCK_FREE < 2\n+# error We require lock-free atomic operations on int\n+#endif\n+    atomic<unsigned> _M_data;\n+\n+    __atomic_futex_unsigned(unsigned __data) : _M_data(__data)\n+    { }\n+\n+    _GLIBCXX_ALWAYS_INLINE unsigned\n+    _M_load(memory_order __mo)\n+    {\n+      return _M_data.load(__mo) & ~_Waiter_bit;\n+    }\n+\n+  private:\n+\n+    // If a timeout occurs, returns a current value after the timeout;\n+    // otherwise, returns the operand's value if equal is true or a different\n+    // value if equal is false.\n+    // The assumed value is the caller's assumption about the current value\n+    // when making the call.\n+    unsigned\n+    _M_load_and_test_until(unsigned __assumed, unsigned __operand,\n+\tbool __equal, memory_order __mo, bool __has_timeout,\n+\tchrono::seconds __s, chrono::nanoseconds __ns)\n+    {\n+      for (;;)\n+\t{\n+\t  // Don't bother checking the value again because we expect the caller to\n+\t  // have done it recently.\n+\t  // memory_order_relaxed is sufficient because we can rely on just the\n+\t  // modification order (store_notify uses an atomic RMW operation too),\n+\t  // and the futex syscalls synchronize between themselves.\n+\t  _M_data.fetch_or(_Waiter_bit, memory_order_relaxed);\n+\t  bool __ret;\n+\t  __ret = _M_futex_wait_until((unsigned*)(void*)&_M_data,\n+\t      __assumed | _Waiter_bit, __has_timeout, __s, __ns);\n+\t  // Fetch the current value after waiting (clears _Waiter_bit).\n+\t  __assumed = _M_load(__mo);\n+\t  if (!__ret || ((__operand == __assumed) == __equal))\n+\t    return __assumed;\n+\t  // TODO adapt wait time\n+\t}\n+    }\n+\n+    // Returns the operand's value if equal is true or a different value if\n+    // equal is false.\n+    // The assumed value is the caller's assumption about the current value\n+    // when making the call.\n+    unsigned\n+    _M_load_and_test(unsigned __assumed, unsigned __operand,\n+\tbool __equal, memory_order __mo)\n+    {\n+      return _M_load_and_test_until(__assumed, __operand, __equal, __mo,\n+\t  false, chrono::seconds(0), chrono::nanoseconds(0));\n+    }\n+\n+    // If a timeout occurs, returns a current value after the timeout;\n+    // otherwise, returns the operand's value if equal is true or a different\n+    // value if equal is false.\n+    // The assumed value is the caller's assumption about the current value\n+    // when making the call.\n+    template<typename _Dur>\n+    unsigned\n+    _M_load_and_test_until_impl(unsigned __assumed, unsigned __operand,\n+\tbool __equal, memory_order __mo,\n+\tconst chrono::time_point<__clock_t, _Dur>& __atime)\n+    {\n+      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+      // XXX correct?\n+      return _M_load_and_test_until(__assumed, __operand, __equal, __mo,\n+\t  true, __s.time_since_epoch(), __ns);\n+    }\n+\n+  public:\n+\n+    _GLIBCXX_ALWAYS_INLINE unsigned\n+    _M_load_when_not_equal(unsigned __val, memory_order __mo)\n+    {\n+      unsigned __i = _M_load(__mo);\n+      if ((__i & ~_Waiter_bit) != __val) return;\n+      // TODO Spin-wait first.\n+      return _M_load_and_test(__i, __val, false, __mo);\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_load_when_equal(unsigned __val, memory_order __mo)\n+    {\n+      unsigned __i = _M_load(__mo);\n+      if ((__i & ~_Waiter_bit) == __val)\n+\treturn;\n+      // TODO Spin-wait first.\n+      _M_load_and_test(__i, __val, true, __mo);\n+    }\n+\n+    // Returns false iff a timeout occurred.\n+    template<typename _Rep, typename _Period>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_for(unsigned __val, memory_order __mo,\n+\tconst chrono::duration<_Rep, _Period>& __rtime)\n+    {\n+      return _M_load_when_equal_until(__val, __mo, __clock_t::now() + __rtime);\n+    }\n+\n+    // Returns false iff a timeout occurred.\n+    template<typename _Clock, typename _Duration>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\tconst chrono::time_point<_Clock, _Duration>& __atime)\n+    {\n+      // DR 887 - Sync unknown clock to known clock.\n+      const typename _Clock::time_point __c_entry = _Clock::now();\n+      const __clock_t::time_point __s_entry = __clock_t::now();\n+      const auto __delta = __atime - __c_entry;\n+      const auto __s_atime = __s_entry + __delta;\n+      return _M_load_when_equal_until(__val, __mo, __s_atime);\n+    }\n+\n+    // Returns false iff a timeout occurred.\n+    template<typename _Duration>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\tconst chrono::time_point<__clock_t, _Duration>& __atime)\n+    {\n+      unsigned __i = _M_load(__mo);\n+      if ((__i & ~_Waiter_bit) == __val)\n+\treturn true;\n+      // TODO Spin-wait first.  Ignore effect on timeout.\n+      __i = _M_load_and_test_until_impl(__i, __val, true, __mo, __atime);\n+      return (__i & ~_Waiter_bit) == __val;\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_store_notify_all(unsigned __val, memory_order __mo)\n+    {\n+      unsigned* __futex = (unsigned *)(void *)&_M_data;\n+      if (_M_data.exchange(__val, __mo) & _Waiter_bit)\n+\t_M_futex_notify_all(__futex);\n+    }\n+\n+  };\n+\n+#else\n+\n+  // If futexes are not available, use a mutex and a condvar to wait.\n+  // Because we access the data only within critical sections, all accesses\n+  // are sequentially consistent; thus, we satisfy any provided memory_order.\n+  template <unsigned _Waiter_bit = 0x80000000>\n+  struct __atomic_futex_unsigned\n+  {\n+    typedef chrono::system_clock __clock_t;\n+\n+    unsigned _M_data;\n+    mutex _M_mutex;\n+    condition_variable _M_condvar;\n+\n+    __atomic_futex_unsigned(unsigned __data) : _M_data(__data)\n+    { }\n+\n+    _GLIBCXX_ALWAYS_INLINE unsigned\n+    _M_load(memory_order __mo)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      return _M_data;\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE unsigned\n+    _M_load_when_not_equal(unsigned __val, memory_order __mo)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      while (_M_data == __val)\n+\t_M_condvar.wait(__lock);\n+      return _M_data;\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_load_when_equal(unsigned __val, memory_order __mo)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      while (_M_data != __val)\n+\t_M_condvar.wait(__lock);\n+    }\n+\n+    template<typename _Rep, typename _Period>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_for(unsigned __val, memory_order __mo,\n+\tconst chrono::duration<_Rep, _Period>& __rtime)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      return _M_condvar.wait_for(__lock, __rtime,\n+\t\t\t\t [&] { return _M_data == __val;});\n+    }\n+\n+    template<typename _Clock, typename _Duration>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\tconst chrono::time_point<_Clock, _Duration>& __atime)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      return _M_condvar.wait_until(__lock, __atime,\n+\t\t\t\t   [&] { return _M_data == __val;});\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_store_notify_all(unsigned __val, memory_order __mo)\n+    {\n+      unique_lock<mutex> __lock(_M_mutex);\n+      _M_data = __val;\n+      _M_condvar.notify_all();\n+    }\n+\n+  };\n+\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif"}, {"sha": "cb0226dec4c0a05d9533b1b1fcd5475935e40b00", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -41,6 +41,7 @@\n #include <condition_variable>\n #include <system_error>\n #include <atomic>\n+#include <bits/atomic_futex.h>\n #include <bits/functexcept.h>\n #include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n@@ -294,15 +295,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef _Ptr<_Result_base> _Ptr_type;\n \n+      enum _Status : unsigned {\n+\t__not_ready,\n+\t__ready\n+      };\n+\n       _Ptr_type\t\t\t_M_result;\n-      mutex               \t_M_mutex;\n-      condition_variable  \t_M_cond;\n-      atomic_flag\t\t_M_retrieved = ATOMIC_FLAG_INIT;\n-      bool\t\t\t_M_ready = false;\n+      __atomic_futex_unsigned<>\t_M_status;\n+      atomic_flag         \t_M_retrieved = ATOMIC_FLAG_INIT;\n       once_flag\t\t\t_M_once;\n \n     public:\n-      _State_baseV2() noexcept = default;\n+      _State_baseV2() noexcept : _M_result(), _M_status(_Status::__not_ready)\n+\t{ }\n       _State_baseV2(const _State_baseV2&) = delete;\n       _State_baseV2& operator=(const _State_baseV2&) = delete;\n       virtual ~_State_baseV2() = default;\n@@ -312,22 +317,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t// Run any deferred function or join any asynchronous thread:\n \t_M_complete_async();\n-\n-\tunique_lock<mutex> __lock(_M_mutex);\n-\t_M_cond.wait(__lock, [&] { return _M_ready; });\n+\t// Acquire MO makes sure this synchronizes with the thread that made\n+\t// the future ready.\n+\t_M_status._M_load_when_equal(_Status::__ready, memory_order_acquire);\n \treturn *_M_result;\n       }\n \n       template<typename _Rep, typename _Period>\n         future_status\n         wait_for(const chrono::duration<_Rep, _Period>& __rel)\n         {\n-\t  unique_lock<mutex> __lock(_M_mutex);\n-\t  if (_M_ready)\n+\t  // First, check if the future has been made ready.  Use acquire MO\n+\t  // to synchronize with the thread that made it ready.\n+\t  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)\n \t    return future_status::ready;\n-\t  if (_M_has_deferred())\n+\t  if (_M_is_deferred_future())\n \t    return future_status::deferred;\n-\t  if (_M_cond.wait_for(__lock, __rel, [&] { return _M_ready; }))\n+\t  if (_M_status._M_load_when_equal_for(_Status::__ready,\n+\t      memory_order_acquire, __rel))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join\n@@ -349,12 +356,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         future_status\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n         {\n-\t  unique_lock<mutex> __lock(_M_mutex);\n-\t  if (_M_ready)\n+\t  // First, check if the future has been made ready.  Use acquire MO\n+\t  // to synchronize with the thread that made it ready.\n+\t  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)\n \t    return future_status::ready;\n-\t  if (_M_has_deferred())\n+\t  if (_M_is_deferred_future())\n \t    return future_status::deferred;\n-\t  if (_M_cond.wait_until(__lock, __abs, [&] { return _M_ready; }))\n+\t  if (_M_status._M_load_when_equal_until(_Status::__ready,\n+\t      memory_order_acquire, __abs))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join\n@@ -367,45 +376,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       // Provide a result to the shared state and make it ready.\n-      // Atomically performs:\n-      //   if (!_M_ready) {\n-      //     _M_result = __res();\n-      //     _M_ready = true;\n-      //   }\n+      // Calls at most once: _M_result = __res();\n       void\n       _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)\n       {\n-\tunique_lock<mutex> __lock(_M_mutex, defer_lock);\n+\tbool __did_set = false;\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n \tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n-\t\t  std::__addressof(__res), std::__addressof(__lock));\n-\tif (__lock.owns_lock())\n-\t  {\n-\t    _M_ready = true;\n-\t    _M_cond.notify_all();\n-\t  }\n+\t\t  std::__addressof(__res), std::__addressof(__did_set));\n+\tif (__did_set)\n+\t  // Use release MO to synchronize with observers of the ready state.\n+\t  _M_status._M_store_notify_all(_Status::__ready,\n+\t\t\t\t\tmemory_order_release);\n \telse if (!__ignore_failure)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n       }\n \n       // Provide a result to the shared state but delay making it ready\n       // until the calling thread exits.\n-      // Atomically performs:\n-      //   if (!_M_ready) {\n-      //     _M_result = __res();\n-      //   }\n+      // Calls at most once: _M_result = __res();\n       void\n       _M_set_delayed_result(function<_Ptr_type()> __res,\n \t\t\t    weak_ptr<_State_baseV2> __self)\n       {\n+\tbool __did_set = false;\n \tunique_ptr<_Make_ready> __mr{new _Make_ready};\n-\tunique_lock<mutex> __lock(_M_mutex, defer_lock);\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n \tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n-\t\t  std::__addressof(__res), std::__addressof(__lock));\n-\tif (!__lock.owns_lock())\n+\t\t  std::__addressof(__res), std::__addressof(__did_set));\n+\tif (!__did_set)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n \t__mr->_M_shared_state = std::move(__self);\n \t__mr->_M_set();\n@@ -424,12 +425,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // provider is abandoning this shared state, so noone can be\n \t    // trying to make the shared state ready at the same time, and\n \t    // we can access _M_result directly instead of through call_once.\n-\t    {\n-\t      lock_guard<mutex> __lock(_M_mutex);\n-\t      _M_result.swap(__res);\n-\t      _M_ready = true;\n-\t    }\n-\t    _M_cond.notify_all();\n+\t    _M_result.swap(__res);\n+\t    // Use release MO to synchronize with observers of the ready state.\n+\t    _M_status._M_store_notify_all(_Status::__ready,\n+\t\t\t\t\t  memory_order_release);\n \t  }\n       }\n \n@@ -523,18 +522,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       // The function invoked with std::call_once(_M_once, ...).\n       void\n-      _M_do_set(function<_Ptr_type()>* __f, unique_lock<mutex>* __lock)\n+      _M_do_set(function<_Ptr_type()>* __f, bool* __did_set)\n       {\n-        _Ptr_type __res = (*__f)(); // do not hold lock while running setter\n-\t__lock->lock();\n-        _M_result.swap(__res);\n+        _Ptr_type __res = (*__f)();\n+        // Notify the caller that we did try to set; if we do not throw an\n+        // exception, the caller will be aware that it did set (e.g., see\n+        // _M_set_result).\n+\t*__did_set = true;\n+        _M_result.swap(__res); // nothrow\n       }\n \n       // Wait for completion of async function.\n       virtual void _M_complete_async() { }\n \n       // Return true if state corresponds to a deferred function.\n-      virtual bool _M_has_deferred() const { return false; }\n+      virtual bool _M_is_deferred_future() const { return false; }\n \n       struct _Make_ready final : __at_thread_exit_elt\n       {\n@@ -1606,7 +1608,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Caller should check whether the state is ready first, because this\n       // function will return true even after the deferred function has run.\n-      virtual bool _M_has_deferred() const { return true; }\n+      virtual bool _M_is_deferred_future() const { return true; }\n     };\n \n   // Common functionality hoisted out of the _Async_state_impl template."}, {"sha": "90697d044ddcfa74aaec02d45b768dcfa7cb303e", "filename": "libstdc++-v3/src/c++11/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -60,6 +60,7 @@ sources = \\\n \tdebug.cc \\\n \tfunctexcept.cc \\\n \tfunctional.cc \\\n+\tfutex.cc \\\n \tfuture.cc \\\n \thash_c++0x.cc \\\n \thashtable_c++0x.cc \\"}, {"sha": "70d5bd770ddea4196d9b4a0b3b607dc63f29e96c", "filename": "libstdc++-v3/src/c++11/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -74,7 +74,7 @@ libc__11convenience_la_LIBADD =\n am__objects_2 = ctype_configure_char.lo ctype_members.lo\n am__objects_3 = chrono.lo codecvt.lo condition_variable.lo \\\n \tcow-stdexcept.lo ctype.lo debug.lo functexcept.lo \\\n-\tfunctional.lo future.lo hash_c++0x.lo hashtable_c++0x.lo \\\n+\tfunctional.lo futex.lo future.lo hash_c++0x.lo hashtable_c++0x.lo \\\n \tios.lo limits.lo mutex.lo placeholders.lo random.lo regex.lo \\\n \tshared_ptr.lo snprintf_lite.lo system_error.lo thread.lo \\\n \t$(am__objects_1) $(am__objects_2)\n@@ -351,6 +351,7 @@ sources = \\\n \tdebug.cc \\\n \tfunctexcept.cc \\\n \tfunctional.cc \\\n+\tfutex.cc \\\n \tfuture.cc \\\n \thash_c++0x.cc \\\n \thashtable_c++0x.cc \\"}, {"sha": "ad766c83229907a60eefd2ea1877c2bfee9fe257", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -0,0 +1,97 @@\n+// futex -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#if defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+#include <bits/atomic_futex.h>\n+#include <chrono>\n+#include <climits>\n+#include <syscall.h>\n+#include <unistd.h>\n+#include <sys/time.h>\n+#include <errno.h>\n+#include <debug/debug.h>\n+\n+// Constants for the wait/wake futex syscall operations\n+const unsigned futex_wait_op = 0;\n+const unsigned futex_wake_op = 1;\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  bool\n+  __atomic_futex_unsigned_base::_M_futex_wait_until(unsigned *__addr,\n+      unsigned __val,\n+      bool __has_timeout, chrono::seconds __s, chrono::nanoseconds __ns)\n+  {\n+    if (!__has_timeout)\n+      {\n+\t// Ignore whether we actually succeeded to block because at worst,\n+\t// we will fall back to spin-waiting.  The only thing we could do\n+\t// here on errors is abort.\n+\tint ret __attribute__((unused));\n+\tret = syscall (SYS_futex, __addr, futex_wait_op, __val);\n+\t_GLIBCXX_DEBUG_ASSERT(ret == 0 || errno == EINTR || errno == EAGAIN);\n+\treturn true;\n+      }\n+    else\n+      {\n+\tstruct timeval tv;\n+\tgettimeofday (&tv, NULL);\n+\t// Convert the absolute timeout value to a relative timeout\n+\tstruct timespec rt;\n+\trt.tv_sec = __s.count() - tv.tv_sec;\n+\trt.tv_nsec = __ns.count() - tv.tv_usec * 1000;\n+\tif (rt.tv_nsec < 0)\n+\t  {\n+\t    rt.tv_nsec += 1000000000;\n+\t    --rt.tv_sec;\n+\t  }\n+\t// Did we already time out?\n+\tif (rt.tv_sec < 0)\n+\t  return false;\n+\n+\tif (syscall (SYS_futex, __addr, futex_wait_op, __val, &rt) == -1)\n+\t  {\n+\t    _GLIBCXX_DEBUG_ASSERT(errno == EINTR || errno == EAGAIN\n+\t\t\t\t  || errno == ETIMEDOUT);\n+\t    if (errno == ETIMEDOUT)\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+  }\n+\n+  void\n+  __atomic_futex_unsigned_base::_M_futex_notify_all(unsigned* __addr)\n+  {\n+    // This syscall can fail for various reasons, including in situations\n+    // in which there is no real error.  Thus, we don't bother checking\n+    // the error codes.  See the futex documentation and glibc for background.\n+    syscall (SYS_futex, __addr, futex_wake_op, INT_MAX);\n+  }\n+\n+}\n+#endif"}, {"sha": "c711a5fe8236093166712368979353c36bff0dac", "filename": "libstdc++-v3/src/c++11/future.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae801bacc085da3a40c4db2e543aaae753f71be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc?ref=eae801bacc085da3a40c4db2e543aaae753f71be", "patch": "@@ -89,11 +89,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     unique_ptr<_Make_ready> mr{static_cast<_Make_ready*>(p)};\n     if (auto state = mr->_M_shared_state.lock())\n       {\n-\t{\n-\t  lock_guard<mutex> __lock{state->_M_mutex};\n-\t  state->_M_ready = true;\n-\t}\n-\tstate->_M_cond.notify_all();\n+\t// Use release MO to synchronize with observers of the ready state.\n+\tstate->_M_status._M_store_notify_all(_Status::__ready,\n+\t    memory_order_release);\n       }\n   }\n "}]}