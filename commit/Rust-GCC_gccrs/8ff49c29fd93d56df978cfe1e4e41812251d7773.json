{"sha": "8ff49c29fd93d56df978cfe1e4e41812251d7773", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmNDljMjlmZDkzZDU2ZGY5NzhjZmUxZTRlNDE4MTIyNTFkNzc3Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-06-04T12:44:01Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-06-04T12:44:01Z"}, "message": "re PR rtl-optimization/39871 (Code size increase on ARM due to poor register allocation)\n\n\tPR rtl-optimization/39871\n\tPR rtl-optimization/40615\n\tPR rtl-optimization/42500\n\tPR rtl-optimization/42502\n\t* ira.c (init_reg_equiv_memory_loc: New function.\n\t(ira): Call it twice.\n\t* reload.h (calculate_elim_costs_all_insns): Declare.\n\t* ira-costs.c: Include \"reload.h\".\n\t(regno_equiv_gains): New static variable.\n\t(init_costs): Allocate it.\n\t(finish_costs): Free it.\n\t(ira_costs): Call calculate_elim_costs_all_insns.\n\t(find_costs_and_classes): Take estimated elimination costs\n\tinto account.\n\t(ira_adjust_equiv_reg_cost): New function.\n\t* ira.h (ira_adjust_equiv_reg_cost): Declare it.\n\t* reload1.c (init_eliminable_invariants, free_reg_equiv,\n\telimination_costs_in_insn, note_reg_elim_costly): New static\n\tfunctions.\n\t(elim_bb): New static variable.\n\t(reload): Move code out of here into init_eliminable_invariants and\n\tfree_reg_equiv.  Call them.\n\t(calculate_elim_costs_all_insns): New function.\n\t(eliminate_regs_1): Declare.  Add extra arg FOR_COSTS;\n\tall callers changed.  If FOR_COSTS is true, don't call alter_reg,\n\tbut call note_reg_elim_costly if we turned a valid memory address\n\tinto an invalid one.\n\t* Makefile.in (ira-costs.o): Depend on reload.h.\n\ntestsuite/\n\tPR rtl-optimization/39871\n\tPR rtl-optimization/40615\n\tPR rtl-optimization/42500\n\tPR rtl-optimization/42502\n\t* gcc.target/arm/eliminate.c: New test.\n\nFrom-SVN: r160260", "tree": {"sha": "2c2e8b8f4d4f62d949c6bbb9dc5113108d6f3f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c2e8b8f4d4f62d949c6bbb9dc5113108d6f3f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ff49c29fd93d56df978cfe1e4e41812251d7773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff49c29fd93d56df978cfe1e4e41812251d7773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff49c29fd93d56df978cfe1e4e41812251d7773", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff49c29fd93d56df978cfe1e4e41812251d7773/comments", "author": null, "committer": null, "parents": [{"sha": "95c5655ce9ccbf00ad109f2def9e9858005e4faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c5655ce9ccbf00ad109f2def9e9858005e4faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c5655ce9ccbf00ad109f2def9e9858005e4faf"}], "stats": {"total": 790, "additions": 613, "deletions": 177}, "files": [{"sha": "fa0304ffbd5e8cd685335e47b40adda8f9ea99fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -1,3 +1,34 @@\n+2010-06-04  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/39871\n+\tPR rtl-optimization/40615\n+\tPR rtl-optimization/42500\n+\tPR rtl-optimization/42502\n+\t* ira.c (init_reg_equiv_memory_loc: New function.\n+\t(ira): Call it twice.\n+\t* reload.h (calculate_elim_costs_all_insns): Declare.\n+\t* ira-costs.c: Include \"reload.h\".\n+\t(regno_equiv_gains): New static variable.\n+\t(init_costs): Allocate it.\n+\t(finish_costs): Free it.\n+\t(ira_costs): Call calculate_elim_costs_all_insns.\n+\t(find_costs_and_classes): Take estimated elimination costs\n+\tinto account.\n+\t(ira_adjust_equiv_reg_cost): New function.\n+\t* ira.h (ira_adjust_equiv_reg_cost): Declare it.\n+\t* reload1.c (init_eliminable_invariants, free_reg_equiv,\n+\telimination_costs_in_insn, note_reg_elim_costly): New static\n+\tfunctions.\n+\t(elim_bb): New static variable.\n+\t(reload): Move code out of here into init_eliminable_invariants and\n+\tfree_reg_equiv.  Call them.\n+\t(calculate_elim_costs_all_insns): New function.\n+\t(eliminate_regs_1): Declare.  Add extra arg FOR_COSTS;\n+\tall callers changed.  If FOR_COSTS is true, don't call alter_reg,\n+\tbut call note_reg_elim_costly if we turned a valid memory address\n+\tinto an invalid one.\n+\t* Makefile.in (ira-costs.o): Depend on reload.h.\n+\n 2010-06-04  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/thumb2.md (*thumb2_movdf_soft_insn): Fix alternatives"}, {"sha": "b46985087f544e84e0eed8a56fa44f3307d83e27", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -3276,7 +3276,7 @@ ira-build.o: ira-build.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n ira-costs.o: ira-costs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    hard-reg-set.h $(RTL_H) $(EXPR_H) $(TM_P_H) $(FLAGS_H) $(BASIC_BLOCK_H) \\\n    $(REGS_H) addresses.h insn-config.h $(RECOG_H) $(TOPLEV_H) $(TARGET_H) \\\n-   $(PARAMS_H) $(IRA_INT_H)\n+   $(PARAMS_H) $(IRA_INT_H) reload.h\n ira-conflicts.o: ira-conflicts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(PARAMS_H) \\"}, {"sha": "39955b6469355168bf6624b1f3679bdc35065e37", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"addresses.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"reload.h\"\n #include \"toplev.h\"\n #include \"target.h\"\n #include \"params.h\"\n@@ -123,6 +124,10 @@ static enum reg_class *pref_buffer;\n /* Record cover register class of each allocno with the same regno.  */\n static enum reg_class *regno_cover_class;\n \n+/* Record cost gains for not allocating a register with an invariant\n+   equivalence.  */\n+static int *regno_equiv_gains;\n+\n /* Execution frequency of the current insn.  */\n static int frequency;\n \n@@ -1263,6 +1268,7 @@ find_costs_and_classes (FILE *dump_file)\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t  int inc_dec_p = false;\n #endif\n+\t  int equiv_savings = regno_equiv_gains[i];\n \n \t  if (! allocno_p)\n \t    {\n@@ -1311,6 +1317,15 @@ find_costs_and_classes (FILE *dump_file)\n #endif\n \t\t}\n \t    }\n+\t  if (equiv_savings < 0)\n+\t    temp_costs->mem_cost = -equiv_savings;\n+\t  else if (equiv_savings > 0)\n+\t    {\n+\t      temp_costs->mem_cost = 0;\n+\t      for (k = 0; k < cost_classes_num; k++)\n+\t\ttemp_costs->cost[k] += equiv_savings;\n+\t    }\n+\n \t  best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n \t  best = ALL_REGS;\n \t  alt_class = NO_REGS;\n@@ -1680,13 +1695,16 @@ init_costs (void)\n   regno_cover_class\n     = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n \t\t\t\t       * max_reg_num ());\n+  regno_equiv_gains = (int *) ira_allocate (sizeof (int) * max_reg_num ());\n+  memset (regno_equiv_gains, 0, sizeof (int) * max_reg_num ());\n }\n \n /* Common finalization function for ira_costs and\n    ira_set_pseudo_classes.  */\n static void\n finish_costs (void)\n {\n+  ira_free (regno_equiv_gains);\n   ira_free (regno_cover_class);\n   ira_free (pref_buffer);\n   ira_free (costs);\n@@ -1702,6 +1720,7 @@ ira_costs (void)\n   init_costs ();\n   total_allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size\n \t\t\t\t\t\t       * ira_allocnos_num);\n+  calculate_elim_costs_all_insns ();\n   find_costs_and_classes (ira_dump_file);\n   setup_allocno_cover_class_and_costs ();\n   finish_costs ();\n@@ -1802,3 +1821,16 @@ ira_tune_allocno_costs_and_cover_classes (void)\n       }\n     }\n }\n+\n+/* Add COST to the estimated gain for eliminating REGNO with its\n+   equivalence.  If COST is zero, record that no such elimination is\n+   possible.  */\n+\n+void\n+ira_adjust_equiv_reg_cost (unsigned regno, int cost)\n+{\n+  if (cost == 0)\n+    regno_equiv_gains[regno] = 0;\n+  else\n+    regno_equiv_gains[regno] += cost;\n+}"}, {"sha": "4fac13ce994ff2358503df89ff4626446c489005", "filename": "gcc/ira.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -3149,8 +3149,19 @@ build_insn_chain (void)\n   if (dump_file)\n     print_insn_chains (dump_file);\n }\n-\n \f\n+/* Allocate memory for reg_equiv_memory_loc.  */\n+static void\n+init_reg_equiv_memory_loc (void)\n+{\n+  max_regno = max_reg_num ();\n+\n+  /* And the reg_equiv_memory_loc array.  */\n+  VEC_safe_grow (rtx, gc, reg_equiv_memory_loc_vec, max_regno);\n+  memset (VEC_address (rtx, reg_equiv_memory_loc_vec), 0,\n+\t  sizeof (rtx) * max_regno);\n+  reg_equiv_memory_loc = VEC_address (rtx, reg_equiv_memory_loc_vec);\n+}\n \n /* All natural loops.  */\n struct loops ira_loops;\n@@ -3255,6 +3266,8 @@ ira (FILE *f)\n   record_loop_exits ();\n   current_loops = &ira_loops;\n \n+  init_reg_equiv_memory_loc ();\n+\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Building IRA IR\\n\");\n   loops_p = ira_build (optimize\n@@ -3315,13 +3328,8 @@ ira (FILE *f)\n #endif\n \n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  max_regno = max_reg_num ();\n \n-  /* And the reg_equiv_memory_loc array.  */\n-  VEC_safe_grow (rtx, gc, reg_equiv_memory_loc_vec, max_regno);\n-  memset (VEC_address (rtx, reg_equiv_memory_loc_vec), 0,\n-\t  sizeof (rtx) * max_regno);\n-  reg_equiv_memory_loc = VEC_address (rtx, reg_equiv_memory_loc_vec);\n+  init_reg_equiv_memory_loc ();\n \n   if (max_regno != max_regno_before_ira)\n     {"}, {"sha": "97bfa87501282af713fbf9700c2c3e760265fc89", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -88,3 +88,4 @@ extern void ira_mark_new_stack_slot (rtx, int, unsigned int);\n extern bool ira_better_spill_reload_regno_p (int *, int *, rtx, rtx, rtx);\n extern bool ira_bad_reload_regno (int, rtx, rtx);\n \n+extern void ira_adjust_equiv_reg_cost (unsigned, int);"}, {"sha": "8168b51f020527317597fc458bd821aa93198855", "filename": "gcc/reload.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -349,6 +349,10 @@ extern void mark_home_live (int);\n extern rtx eliminate_regs (rtx, enum machine_mode, rtx);\n extern bool elimination_target_reg_p (rtx);\n \n+/* Called from the register allocator to estimate costs of eliminating\n+   invariant registers.  */\n+extern void calculate_elim_costs_all_insns (void);\n+\n /* Deallocate the reload register used by reload number R.  */\n extern void deallocate_reload_reg (int r);\n "}, {"sha": "030d0078203ebdc51ec3e5f0e4e62f57db3acffa", "filename": "gcc/reload1.c", "status": "modified", "additions": 502, "deletions": 169, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -412,15 +412,19 @@ static void alter_reg (int, int, bool);\n static void set_label_offsets (rtx, rtx, int);\n static void check_eliminable_occurrences (rtx);\n static void elimination_effects (rtx, enum machine_mode);\n+static rtx eliminate_regs_1 (rtx, enum machine_mode, rtx, bool, bool);\n static int eliminate_regs_in_insn (rtx, int);\n static void update_eliminable_offsets (void);\n static void mark_not_eliminable (rtx, const_rtx, void *);\n static void set_initial_elim_offsets (void);\n static bool verify_initial_elim_offsets (void);\n static void set_initial_label_offsets (void);\n static void set_offsets_for_label (rtx);\n+static void init_eliminable_invariants (rtx, bool);\n static void init_elim_table (void);\n+static void free_reg_equiv (void);\n static void update_eliminables (HARD_REG_SET *);\n+static void elimination_costs_in_insn (rtx);\n static void spill_hard_reg (unsigned int, int);\n static int finish_spills (int);\n static void scan_paradoxical_subregs (rtx);\n@@ -697,6 +701,9 @@ has_nonexceptional_receiver (void)\n \f\n /* Global variables used by reload and its subroutines.  */\n \n+/* The current basic block while in calculate_elim_costs_all_insns.  */\n+static basic_block elim_bb;\n+\n /* Set during calculate_needs if an insn needs register elimination.  */\n static int something_needs_elimination;\n /* Set during calculate_needs if an insn needs an operand changed.  */\n@@ -777,138 +784,16 @@ reload (rtx first, int global)\n       if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))\n \tdf_set_regs_ever_live (i, true);\n \n-  /* Find all the pseudo registers that didn't get hard regs\n-     but do have known equivalent constants or memory slots.\n-     These include parameters (known equivalent to parameter slots)\n-     and cse'd or loop-moved constant memory addresses.\n-\n-     Record constant equivalents in reg_equiv_constant\n-     so they will be substituted by find_reloads.\n-     Record memory equivalents in reg_mem_equiv so they can\n-     be substituted eventually by altering the REG-rtx's.  */\n-\n-  reg_equiv_constant = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_invariant = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_mem = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_alt_mem_list = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_address = XCNEWVEC (rtx, max_regno);\n-  reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n   reg_old_renumber = XCNEWVEC (short, max_regno);\n   memcpy (reg_old_renumber, reg_renumber, max_regno * sizeof (short));\n   pseudo_forbidden_regs = XNEWVEC (HARD_REG_SET, max_regno);\n   pseudo_previous_regs = XCNEWVEC (HARD_REG_SET, max_regno);\n \n   CLEAR_HARD_REG_SET (bad_spill_regs_global);\n \n-  /* Look for REG_EQUIV notes; record what each pseudo is equivalent\n-     to.  Also find all paradoxical subregs and find largest such for\n-     each pseudo.  */\n-\n-  num_eliminable_invariants = 0;\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx set = single_set (insn);\n-\n-      /* We may introduce USEs that we want to remove at the end, so\n-\t we'll mark them with QImode.  Make sure there are no\n-\t previously-marked insns left by say regmove.  */\n-      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE\n-\t  && GET_MODE (insn) != VOIDmode)\n-\tPUT_MODE (insn, VOIDmode);\n-\n-      if (NONDEBUG_INSN_P (insn))\n-\tscan_paradoxical_subregs (PATTERN (insn));\n-\n-      if (set != 0 && REG_P (SET_DEST (set)))\n-\t{\n-\t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\t  rtx x;\n-\n-\t  if (! note)\n-\t    continue;\n-\n-\t  i = REGNO (SET_DEST (set));\n-\t  x = XEXP (note, 0);\n-\n-\t  if (i <= LAST_VIRTUAL_REGISTER)\n-\t    continue;\n-\n-\t  if (! function_invariant_p (x)\n-\t      || ! flag_pic\n-\t      /* A function invariant is often CONSTANT_P but may\n-\t\t include a register.  We promise to only pass\n-\t\t CONSTANT_P objects to LEGITIMATE_PIC_OPERAND_P.  */\n-\t      || (CONSTANT_P (x)\n-\t\t  && LEGITIMATE_PIC_OPERAND_P (x)))\n-\t    {\n-\t      /* It can happen that a REG_EQUIV note contains a MEM\n-\t\t that is not a legitimate memory operand.  As later\n-\t\t stages of reload assume that all addresses found\n-\t\t in the reg_equiv_* arrays were originally legitimate,\n-\t\t we ignore such REG_EQUIV notes.  */\n-\t      if (memory_operand (x, VOIDmode))\n-\t\t{\n-\t\t  /* Always unshare the equivalence, so we can\n-\t\t     substitute into this insn without touching the\n-\t\t       equivalence.  */\n-\t\t  reg_equiv_memory_loc[i] = copy_rtx (x);\n-\t\t}\n-\t      else if (function_invariant_p (x))\n-\t\t{\n-\t\t  if (GET_CODE (x) == PLUS)\n-\t\t    {\n-\t\t      /* This is PLUS of frame pointer and a constant,\n-\t\t\t and might be shared.  Unshare it.  */\n-\t\t      reg_equiv_invariant[i] = copy_rtx (x);\n-\t\t      num_eliminable_invariants++;\n-\t\t    }\n-\t\t  else if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n-\t\t    {\n-\t\t      reg_equiv_invariant[i] = x;\n-\t\t      num_eliminable_invariants++;\n-\t\t    }\n-\t\t  else if (LEGITIMATE_CONSTANT_P (x))\n-\t\t    reg_equiv_constant[i] = x;\n-\t\t  else\n-\t\t    {\n-\t\t      reg_equiv_memory_loc[i]\n-\t\t\t= force_const_mem (GET_MODE (SET_DEST (set)), x);\n-\t\t      if (! reg_equiv_memory_loc[i])\n-\t\t\treg_equiv_init[i] = NULL_RTX;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  reg_equiv_init[i] = NULL_RTX;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else\n-\t    reg_equiv_init[i] = NULL_RTX;\n-\t}\n-    }\n-\n-  if (dump_file)\n-    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-      if (reg_equiv_init[i])\n-\t{\n-\t  fprintf (dump_file, \"init_insns for %u: \", i);\n-\t  print_inline_rtx (dump_file, reg_equiv_init[i], 20);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n+  init_eliminable_invariants (first, true);\n   init_elim_table ();\n \n-  first_label_num = get_first_label_num ();\n-  num_labels = max_label_num () - first_label_num;\n-\n-  /* Allocate the tables used to store offset information at labels.  */\n-  /* We used to use alloca here, but the size of what it would try to\n-     allocate would occasionally cause it to exceed the stack limit and\n-     cause a core dump.  */\n-  offsets_known_at = XNEWVEC (char, num_labels);\n-  offsets_at = (HOST_WIDE_INT (*)[NUM_ELIMINABLE_REGS]) xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n-\n   /* Alter each pseudo-reg rtx to contain its hard reg number.  Assign\n      stack slots to the pseudos that lack hard regs or equivalents.\n      Do not touch virtual registers.  */\n@@ -1413,31 +1298,11 @@ reload (rtx first, int global)\n \t}\n     }\n \n-  /* Indicate that we no longer have known memory locations or constants.  */\n-  if (reg_equiv_constant)\n-    free (reg_equiv_constant);\n-  if (reg_equiv_invariant)\n-    free (reg_equiv_invariant);\n-  reg_equiv_constant = 0;\n-  reg_equiv_invariant = 0;\n-  VEC_free (rtx, gc, reg_equiv_memory_loc_vec);\n-  reg_equiv_memory_loc = 0;\n-\n   free (temp_pseudo_reg_arr);\n \n-  if (offsets_known_at)\n-    free (offsets_known_at);\n-  if (offsets_at)\n-    free (offsets_at);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (reg_equiv_alt_mem_list[i])\n-      free_EXPR_LIST_list (&reg_equiv_alt_mem_list[i]);\n-  free (reg_equiv_alt_mem_list);\n-\n-  free (reg_equiv_mem);\n+  /* Indicate that we no longer have known memory locations or constants.  */\n+  free_reg_equiv ();\n   reg_equiv_init = 0;\n-  free (reg_equiv_address);\n   free (reg_max_ref_width);\n   free (reg_old_renumber);\n   free (pseudo_previous_regs);\n@@ -1730,6 +1595,100 @@ calculate_needs_all_insns (int global)\n   *pprev_reload = 0;\n }\n \f\n+/* This function is called from the register allocator to set up estimates\n+   for the cost of eliminating pseudos which have REG_EQUIV equivalences to\n+   an invariant.  The structure is similar to calculate_needs_all_insns.  */\n+\n+void\n+calculate_elim_costs_all_insns (void)\n+{\n+  int *reg_equiv_init_cost;\n+  basic_block bb;\n+  int i;\n+\n+  reg_equiv_init_cost = XCNEWVEC (int, max_regno);\n+  init_elim_table ();\n+  init_eliminable_invariants (get_insns (), false);\n+\n+  set_initial_elim_offsets ();\n+  set_initial_label_offsets ();\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+      elim_bb = bb;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  /* If this is a label, a JUMP_INSN, or has REG_NOTES (which might\n+\t     include REG_LABEL_OPERAND and REG_LABEL_TARGET), we need to see\n+\t     what effects this has on the known offsets at labels.  */\n+\n+\t  if (LABEL_P (insn) || JUMP_P (insn)\n+\t      || (INSN_P (insn) && REG_NOTES (insn) != 0))\n+\t    set_label_offsets (insn, insn, 0);\n+\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      rtx set = single_set (insn);\n+\n+\t      /* Skip insns that only set an equivalence.  */\n+\t      if (set && REG_P (SET_DEST (set))\n+\t\t  && reg_renumber[REGNO (SET_DEST (set))] < 0\n+\t\t  && (reg_equiv_constant[REGNO (SET_DEST (set))]\n+\t\t      || (reg_equiv_invariant[REGNO (SET_DEST (set))])))\n+\t\t{\n+\t\t  unsigned regno = REGNO (SET_DEST (set));\n+\t\t  rtx init = reg_equiv_init[regno];\n+\t\t  if (init)\n+\t\t    {\n+\t\t      rtx t = eliminate_regs_1 (SET_SRC (set), VOIDmode, insn,\n+\t\t\t\t\t\tfalse, true);\n+\t\t      int cost = rtx_cost (t, SET,\n+\t\t\t\t\t   optimize_bb_for_speed_p (bb));\n+\t\t      int freq = REG_FREQ_FROM_BB (bb);\n+\n+\t\t      reg_equiv_init_cost[regno] = cost * freq;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      /* If needed, eliminate any eliminable registers.  */\n+\t      if (num_eliminable || num_eliminable_invariants)\n+\t\telimination_costs_in_insn (insn);\n+\n+\t      if (num_eliminable)\n+\t\tupdate_eliminable_offsets ();\n+\t    }\n+\t}\n+    }\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    {\n+      if (reg_equiv_invariant[i])\n+\t{\n+\t  if (reg_equiv_init[i])\n+\t    {\n+\t      int cost = reg_equiv_init_cost[i];\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Reg %d has equivalence, initial gains %d\\n\", i, cost);\n+\t      if (cost != 0)\n+\t\tira_adjust_equiv_reg_cost (i, cost);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Reg %d had equivalence, but can't be eliminated\\n\",\n+\t\t\t i);\n+\t      ira_adjust_equiv_reg_cost (i, 0);\n+\t    }\n+\t}\n+    }\n+\n+  free_reg_equiv ();\n+  free (reg_equiv_init_cost);\n+}\n+\f\n /* Comparison function for qsort to decide which of two reloads\n    should be handled first.  *P1 and *P2 are the reload numbers.  */\n \n@@ -2518,6 +2477,36 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n     }\n }\n \f\n+/* Called through for_each_rtx, this function examines every reg that occurs\n+   in PX and adjusts the costs for its elimination which are gathered by IRA.\n+   DATA is the insn in which PX occurs.  We do not recurse into MEM\n+   expressions.  */\n+\n+static int\n+note_reg_elim_costly (rtx *px, void *data)\n+{\n+  rtx insn = (rtx)data;\n+  rtx x = *px;\n+\n+  if (MEM_P (x))\n+    return -1;\n+\n+  if (REG_P (x)\n+      && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && reg_equiv_init[REGNO (x)]\n+      && reg_equiv_invariant[REGNO (x)])\n+    {\n+      rtx t = reg_equiv_invariant[REGNO (x)];\n+      rtx new_rtx = eliminate_regs_1 (t, Pmode, insn, true, true);\n+      int cost = rtx_cost (new_rtx, SET, optimize_bb_for_speed_p (elim_bb));\n+      int freq = REG_FREQ_FROM_BB (elim_bb);\n+\n+      if (cost != 0)\n+\tira_adjust_equiv_reg_cost (REGNO (x), -cost * freq);\n+    }\n+  return 0;\n+}\n+\n /* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.\n \n@@ -2537,6 +2526,9 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n    This means, do not set ref_outside_mem even if the reference\n    is outside of MEMs.\n \n+   If FOR_COSTS is true, we are being called before reload in order to\n+   estimate the costs of keeping registers with an equivalence unallocated.\n+\n    REG_EQUIV_MEM and REG_EQUIV_ADDRESS contain address that have had\n    replacements done assuming all offsets are at their initial values.  If\n    they are not, or if REG_EQUIV_ADDRESS is nonzero for a pseudo we\n@@ -2545,7 +2537,7 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n \n static rtx\n eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n-\t\t  bool may_use_invariant)\n+\t\t  bool may_use_invariant, bool for_costs)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2593,11 +2585,12 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t{\n \t  if (may_use_invariant || (insn && DEBUG_INSN_P (insn)))\n \t    return eliminate_regs_1 (copy_rtx (reg_equiv_invariant[regno]),\n-\t\t\t             mem_mode, insn, true);\n+\t\t\t             mem_mode, insn, true, for_costs);\n \t  /* There exists at least one use of REGNO that cannot be\n \t     eliminated.  Prevent the defining insn from being deleted.  */\n \t  reg_equiv_init[regno] = NULL_RTX;\n-\t  alter_reg (regno, -1, true);\n+\t  if (!for_costs)\n+\t    alter_reg (regno, -1, true);\n \t}\n       return x;\n \n@@ -2658,8 +2651,10 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t operand of a load-address insn.  */\n \n       {\n-\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n-\trtx new1 = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n+\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true,\n+\t\t\t\t     for_costs);\n+\trtx new1 = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true,\n+\t\t\t\t     for_costs);\n \n \tif (reg_renumber && (new0 != XEXP (x, 0) || new1 != XEXP (x, 1)))\n \t  {\n@@ -2733,9 +2728,11 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n+\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false,\n+\t\t\t\t     for_costs);\n \trtx new1 = XEXP (x, 1)\n-\t\t   ? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, false) : 0;\n+\t  ? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, false,\n+\t\t\t      for_costs) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx_fmt_ee (code, GET_MODE (x), new0, new1);\n@@ -2746,15 +2743,17 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true,\n+\t\t\t\t      for_costs);\n \t  if (new_rtx != XEXP (x, 0))\n \t    {\n \t      /* If this is a REG_DEAD note, it is not valid anymore.\n \t\t Using the eliminated version could result in creating a\n \t\t REG_DEAD note for the stack or frame pointer.  */\n \t      if (REG_NOTE_KIND (x) == REG_DEAD)\n \t\treturn (XEXP (x, 1)\n-\t\t\t? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true)\n+\t\t\t? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true,\n+\t\t\t\t\t    for_costs)\n \t\t\t: NULL_RTX);\n \n \t      x = alloc_reg_note (REG_NOTE_KIND (x), new_rtx, XEXP (x, 1));\n@@ -2769,7 +2768,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new_rtx = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true,\n+\t\t\t\t      for_costs);\n \t  if (new_rtx != XEXP (x, 1))\n \t    return\n \t      gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new_rtx);\n@@ -2795,7 +2795,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n \t{\n \t  rtx new_rtx = eliminate_regs_1 (XEXP (XEXP (x, 1), 1), mem_mode,\n-\t\t\t\t      insn, true);\n+\t\t\t\t\t  insn, true, for_costs);\n \n \t  if (new_rtx != XEXP (XEXP (x, 1), 1))\n \t    return gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (x, 0),\n@@ -2818,7 +2818,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     case POPCOUNT:\n     case PARITY:\n     case BSWAP:\n-      new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false,\n+\t\t\t\t  for_costs);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_fmt_e (code, GET_MODE (x), new_rtx);\n       return x;\n@@ -2839,7 +2840,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  new_rtx = SUBREG_REG (x);\n \t}\n       else\n-\tnew_rtx = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false);\n+\tnew_rtx = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false,\n+\t\t\t\t    for_costs);\n \n       if (new_rtx != SUBREG_REG (x))\n \t{\n@@ -2873,14 +2875,20 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      return\n-\treplace_equiv_address_nv (x,\n-\t\t\t\t  eliminate_regs_1 (XEXP (x, 0), GET_MODE (x),\n-\t\t\t\t\t\t    insn, true));\n+\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), GET_MODE (x), insn, true,\n+\t\t\t\t  for_costs);\n+      if (for_costs\n+\t  && memory_address_p (GET_MODE (x), XEXP (x, 0))\n+\t  && !memory_address_p (GET_MODE (x), new_rtx))\n+\tfor_each_rtx (&XEXP (x, 0), note_reg_elim_costly, insn);\n+\n+      return replace_equiv_address_nv (x, new_rtx);\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n-      new_rtx = eliminate_regs_1 (XEXP (x, 0), VOIDmode, insn, false);\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), VOIDmode, insn, false,\n+\t\t\t\t  for_costs);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_USE (GET_MODE (x), new_rtx);\n       return x;\n@@ -2904,7 +2912,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new_rtx = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false);\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false,\n+\t\t\t\t      for_costs);\n \t  if (new_rtx != XEXP (x, i) && ! copied)\n \t    {\n \t      x = shallow_copy_rtx (x);\n@@ -2917,7 +2926,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new_rtx = eliminate_regs_1 (XVECEXP (x, i, j), mem_mode, insn, false);\n+\t      new_rtx = eliminate_regs_1 (XVECEXP (x, i, j), mem_mode, insn, false,\n+\t\t\t\t\t  for_costs);\n \t      if (new_rtx != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_v (XVECLEN (x, i),\n@@ -2941,7 +2951,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n rtx\n eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n {\n-  return eliminate_regs_1 (x, mem_mode, insn, false);\n+  return eliminate_regs_1 (x, mem_mode, insn, false, false);\n }\n \n /* Scan rtx X for modifications of elimination target registers.  Update\n@@ -3459,7 +3469,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t  /* Companion to the above plus substitution, we can allow\n \t     invariants as the source of a plain move.  */\n \t  is_set_src = false;\n-\t  if (old_set && recog_data.operand_loc[i] == &SET_SRC (old_set))\n+\t  if (old_set\n+\t      && recog_data.operand_loc[i] == &SET_SRC (old_set))\n \t    is_set_src = true;\n \t  in_plus = false;\n \t  if (plus_src\n@@ -3470,7 +3481,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t  substed_operand[i]\n \t    = eliminate_regs_1 (recog_data.operand[i], VOIDmode,\n \t\t\t        replace ? insn : NULL_RTX,\n-\t\t\t\tis_set_src || in_plus);\n+\t\t\t\tis_set_src || in_plus, false);\n \t  if (substed_operand[i] != orig_operand[i])\n \t    val = 1;\n \t  /* Terminate the search in check_eliminable_occurrences at\n@@ -3601,11 +3612,167 @@ eliminate_regs_in_insn (rtx insn, int replace)\n      the pre-passes.  */\n   if (val && REG_NOTES (insn) != 0)\n     REG_NOTES (insn)\n-      = eliminate_regs_1 (REG_NOTES (insn), VOIDmode, REG_NOTES (insn), true);\n+      = eliminate_regs_1 (REG_NOTES (insn), VOIDmode, REG_NOTES (insn), true,\n+\t\t\t  false);\n \n   return val;\n }\n \n+/* Like eliminate_regs_in_insn, but only estimate costs for the use of the\n+   register allocator.  INSN is the instruction we need to examine, we perform\n+   eliminations in its operands and record cases where eliminating a reg with\n+   an invariant equivalence would add extra cost.  */\n+\n+static void\n+elimination_costs_in_insn (rtx insn)\n+{\n+  int icode = recog_memoized (insn);\n+  rtx old_body = PATTERN (insn);\n+  int insn_is_asm = asm_noperands (old_body) >= 0;\n+  rtx old_set = single_set (insn);\n+  int i;\n+  rtx orig_operand[MAX_RECOG_OPERANDS];\n+  rtx orig_dup[MAX_RECOG_OPERANDS];\n+  struct elim_table *ep;\n+  rtx plus_src, plus_cst_src;\n+  bool sets_reg_p;\n+\n+  if (! insn_is_asm && icode < 0)\n+    {\n+      gcc_assert (GET_CODE (PATTERN (insn)) == USE\n+\t\t  || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t  || DEBUG_INSN_P (insn));\n+      return;\n+    }\n+\n+  if (old_set != 0 && REG_P (SET_DEST (old_set))\n+      && REGNO (SET_DEST (old_set)) < FIRST_PSEUDO_REGISTER)\n+    {\n+      /* Check for setting an eliminable register.  */\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == SET_DEST (old_set) && ep->can_eliminate)\n+\t  return;\n+    }\n+\n+  /* We allow one special case which happens to work on all machines we\n+     currently support: a single set with the source or a REG_EQUAL\n+     note being a PLUS of an eliminable register and a constant.  */\n+  plus_src = plus_cst_src = 0;\n+  sets_reg_p = false;\n+  if (old_set && REG_P (SET_DEST (old_set)))\n+    {\n+      sets_reg_p = true;\n+      if (GET_CODE (SET_SRC (old_set)) == PLUS)\n+\tplus_src = SET_SRC (old_set);\n+      /* First see if the source is of the form (plus (...) CST).  */\n+      if (plus_src\n+\t  && CONST_INT_P (XEXP (plus_src, 1)))\n+\tplus_cst_src = plus_src;\n+      else if (REG_P (SET_SRC (old_set))\n+\t       || plus_src)\n+\t{\n+\t  /* Otherwise, see if we have a REG_EQUAL note of the form\n+\t     (plus (...) CST).  */\n+\t  rtx links;\n+\t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t    {\n+\t      if ((REG_NOTE_KIND (links) == REG_EQUAL\n+\t\t   || REG_NOTE_KIND (links) == REG_EQUIV)\n+\t\t  && GET_CODE (XEXP (links, 0)) == PLUS\n+\t\t  && CONST_INT_P (XEXP (XEXP (links, 0), 1)))\n+\t\t{\n+\t\t  plus_cst_src = XEXP (links, 0);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Determine the effects of this insn on elimination offsets.  */\n+  elimination_effects (old_body, VOIDmode);\n+\n+  /* Eliminate all eliminable registers occurring in operands that\n+     can be handled by reload.  */\n+  extract_insn (insn);\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    orig_dup[i] = *recog_data.dup_loc[i];\n+\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      orig_operand[i] = recog_data.operand[i];\n+\n+      /* For an asm statement, every operand is eliminable.  */\n+      if (insn_is_asm || insn_data[icode].operand[i].eliminable)\n+\t{\n+\t  bool is_set_src, in_plus;\n+\n+\t  /* Check for setting a register that we know about.  */\n+\t  if (recog_data.operand_type[i] != OP_IN\n+\t      && REG_P (orig_operand[i]))\n+\t    {\n+\t      /* If we are assigning to a register that can be eliminated, it\n+\t\t must be as part of a PARALLEL, since the code above handles\n+\t\t single SETs.  We must indicate that we can no longer\n+\t\t eliminate this reg.  */\n+\t      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+\t\t   ep++)\n+\t\tif (ep->from_rtx == orig_operand[i])\n+\t\t  ep->can_eliminate = 0;\n+\t    }\n+\n+\t  /* Companion to the above plus substitution, we can allow\n+\t     invariants as the source of a plain move.  */\n+\t  is_set_src = false;\n+\t  if (old_set && recog_data.operand_loc[i] == &SET_SRC (old_set))\n+\t    is_set_src = true;\n+\t  if (is_set_src && !sets_reg_p)\n+\t    note_reg_elim_costly (&SET_SRC (old_set), insn);\n+\t  in_plus = false;\n+\t  if (plus_src && sets_reg_p\n+\t      && (recog_data.operand_loc[i] == &XEXP (plus_src, 0)\n+\t\t  || recog_data.operand_loc[i] == &XEXP (plus_src, 1)))\n+\t    in_plus = true;\n+\n+\t  eliminate_regs_1 (recog_data.operand[i], VOIDmode,\n+\t\t\t    NULL_RTX,\n+\t\t\t    is_set_src || in_plus, true);\n+\t  /* Terminate the search in check_eliminable_occurrences at\n+\t     this point.  */\n+\t  *recog_data.operand_loc[i] = 0;\n+\t}\n+    }\n+\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    *recog_data.dup_loc[i]\n+      = *recog_data.operand_loc[(int) recog_data.dup_num[i]];\n+\n+  /* If any eliminable remain, they aren't eliminable anymore.  */\n+  check_eliminable_occurrences (old_body);\n+\n+  /* Restore the old body.  */\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    *recog_data.operand_loc[i] = orig_operand[i];\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    *recog_data.dup_loc[i] = orig_dup[i];\n+\n+  /* Update all elimination pairs to reflect the status after the current\n+     insn.  The changes we make were determined by the earlier call to\n+     elimination_effects.  */\n+\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      if (ep->previous_offset != ep->offset && ep->ref_outside_mem)\n+\tep->can_eliminate = 0;\n+\n+      ep->ref_outside_mem = 0;\n+    }\n+\n+  return;\n+}\n+\n /* Loop through all elimination pairs.\n    Recalculate the number not at initial offset.\n \n@@ -3915,6 +4082,172 @@ init_elim_table (void)\n       ep->to_rtx = gen_rtx_REG (Pmode, ep->to);\n     }\n }\n+\n+/* Find all the pseudo registers that didn't get hard regs\n+   but do have known equivalent constants or memory slots.\n+   These include parameters (known equivalent to parameter slots)\n+   and cse'd or loop-moved constant memory addresses.\n+\n+   Record constant equivalents in reg_equiv_constant\n+   so they will be substituted by find_reloads.\n+   Record memory equivalents in reg_mem_equiv so they can\n+   be substituted eventually by altering the REG-rtx's.  */\n+\n+static void\n+init_eliminable_invariants (rtx first, bool do_subregs)\n+{\n+  int i;\n+  rtx insn;\n+\n+  reg_equiv_constant = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_invariant = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_mem = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_alt_mem_list = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_address = XCNEWVEC (rtx, max_regno);\n+  if (do_subregs)\n+    reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n+  else\n+    reg_max_ref_width = NULL;\n+\n+  num_eliminable_invariants = 0;\n+\n+  first_label_num = get_first_label_num ();\n+  num_labels = max_label_num () - first_label_num;\n+\n+  /* Allocate the tables used to store offset information at labels.  */\n+  offsets_known_at = XNEWVEC (char, num_labels);\n+  offsets_at = (HOST_WIDE_INT (*)[NUM_ELIMINABLE_REGS]) xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n+\n+/* Look for REG_EQUIV notes; record what each pseudo is equivalent\n+   to.  If DO_SUBREGS is true, also find all paradoxical subregs and\n+   find largest such for each pseudo.  FIRST is the head of the insn\n+   list.  */\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx set = single_set (insn);\n+\n+      /* We may introduce USEs that we want to remove at the end, so\n+\t we'll mark them with QImode.  Make sure there are no\n+\t previously-marked insns left by say regmove.  */\n+      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE\n+\t  && GET_MODE (insn) != VOIDmode)\n+\tPUT_MODE (insn, VOIDmode);\n+\n+      if (do_subregs && NONDEBUG_INSN_P (insn))\n+\tscan_paradoxical_subregs (PATTERN (insn));\n+\n+      if (set != 0 && REG_P (SET_DEST (set)))\n+\t{\n+\t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\t  rtx x;\n+\n+\t  if (! note)\n+\t    continue;\n+\n+\t  i = REGNO (SET_DEST (set));\n+\t  x = XEXP (note, 0);\n+\n+\t  if (i <= LAST_VIRTUAL_REGISTER)\n+\t    continue;\n+\n+\t  if (! function_invariant_p (x)\n+\t      || ! flag_pic\n+\t      /* A function invariant is often CONSTANT_P but may\n+\t\t include a register.  We promise to only pass\n+\t\t CONSTANT_P objects to LEGITIMATE_PIC_OPERAND_P.  */\n+\t      || (CONSTANT_P (x)\n+\t\t  && LEGITIMATE_PIC_OPERAND_P (x)))\n+\t    {\n+\t      /* It can happen that a REG_EQUIV note contains a MEM\n+\t\t that is not a legitimate memory operand.  As later\n+\t\t stages of reload assume that all addresses found\n+\t\t in the reg_equiv_* arrays were originally legitimate,\n+\t\t we ignore such REG_EQUIV notes.  */\n+\t      if (memory_operand (x, VOIDmode))\n+\t\t{\n+\t\t  /* Always unshare the equivalence, so we can\n+\t\t     substitute into this insn without touching the\n+\t\t       equivalence.  */\n+\t\t  reg_equiv_memory_loc[i] = copy_rtx (x);\n+\t\t}\n+\t      else if (function_invariant_p (x))\n+\t\t{\n+\t\t  if (GET_CODE (x) == PLUS)\n+\t\t    {\n+\t\t      /* This is PLUS of frame pointer and a constant,\n+\t\t\t and might be shared.  Unshare it.  */\n+\t\t      reg_equiv_invariant[i] = copy_rtx (x);\n+\t\t      num_eliminable_invariants++;\n+\t\t    }\n+\t\t  else if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n+\t\t    {\n+\t\t      reg_equiv_invariant[i] = x;\n+\t\t      num_eliminable_invariants++;\n+\t\t    }\n+\t\t  else if (LEGITIMATE_CONSTANT_P (x))\n+\t\t    reg_equiv_constant[i] = x;\n+\t\t  else\n+\t\t    {\n+\t\t      reg_equiv_memory_loc[i]\n+\t\t\t= force_const_mem (GET_MODE (SET_DEST (set)), x);\n+\t\t      if (! reg_equiv_memory_loc[i])\n+\t\t\treg_equiv_init[i] = NULL_RTX;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  reg_equiv_init[i] = NULL_RTX;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else\n+\t    reg_equiv_init[i] = NULL_RTX;\n+\t}\n+    }\n+\n+  if (dump_file)\n+    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+      if (reg_equiv_init[i])\n+\t{\n+\t  fprintf (dump_file, \"init_insns for %u: \", i);\n+\t  print_inline_rtx (dump_file, reg_equiv_init[i], 20);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+}\n+\n+/* Indicate that we no longer have known memory locations or constants.\n+   Free all data involved in tracking these.  */\n+\n+static void\n+free_reg_equiv (void)\n+{\n+  int i;\n+\n+  if (reg_equiv_constant)\n+    free (reg_equiv_constant);\n+  if (reg_equiv_invariant)\n+    free (reg_equiv_invariant);\n+  reg_equiv_constant = 0;\n+  reg_equiv_invariant = 0;\n+  VEC_free (rtx, gc, reg_equiv_memory_loc_vec);\n+  reg_equiv_memory_loc = 0;\n+\n+  if (offsets_known_at)\n+    free (offsets_known_at);\n+  if (offsets_at)\n+    free (offsets_at);\n+  offsets_at = 0;\n+  offsets_known_at = 0;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (reg_equiv_alt_mem_list[i])\n+      free_EXPR_LIST_list (&reg_equiv_alt_mem_list[i]);\n+  free (reg_equiv_alt_mem_list);\n+\n+  free (reg_equiv_mem);\n+  free (reg_equiv_address);\n+}\n \f\n /* Kick all pseudos out of hard register REGNO.\n "}, {"sha": "1f3ae6849f4c54a34323fd384f8081cd80fb1692", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -1,3 +1,11 @@\n+2010-06-04  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/39871\n+\tPR rtl-optimization/40615\n+\tPR rtl-optimization/42500\n+\tPR rtl-optimization/42502\n+\t* gcc.target/arm/eliminate.c: New test.\n+\n 2010-06-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/44410"}, {"sha": "f254dd811d2a1ebeb287c2d23c7e47aeecaa654e", "filename": "gcc/testsuite/gcc.target/arm/eliminate.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feliminate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ff49c29fd93d56df978cfe1e4e41812251d7773/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feliminate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feliminate.c?ref=8ff49c29fd93d56df978cfe1e4e41812251d7773", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" }  */\n+\n+struct X\n+{\n+  int c;\n+};\n+\n+extern void bar(struct X *);\n+\n+void foo ()\n+{\n+  struct X x;\n+  bar (&x);\n+  bar (&x);\n+  bar (&x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"r0,\\[\\\\t \\]*sp\" 3 } } */"}]}