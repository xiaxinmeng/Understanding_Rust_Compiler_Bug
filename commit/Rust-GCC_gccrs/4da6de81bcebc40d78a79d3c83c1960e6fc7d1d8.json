{"sha": "4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhNmRlODFiY2ViYzQwZDc4YTc5ZDNjODNjMTk2MGU2ZmM3ZDFkOA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2011-10-06T11:50:26Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2011-10-06T11:50:26Z"}, "message": "re PR target/50305 (Inline asm reload failure when building Linux kernel)\n\n\tgcc/\n\tPR target/50305\n\t* config/arm/arm.c (arm_legitimize_reload_address): Recognize\n\toutput of a previous pass through legitimize_reload_address.\n\tDo not attempt to optimize addresses if the base register is\n\tequivalent to a constant.\n\n\tgcc/testsuite/\n\tPR target/50305\n\t* gcc.target/arm/pr50305.c: New test.\n\nFrom-SVN: r179603", "tree": {"sha": "89db83a084de31419946262731bbccba47d527cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89db83a084de31419946262731bbccba47d527cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/comments", "author": null, "committer": null, "parents": [{"sha": "fa7fd586c317945a2023d4fc8c59907a993dddf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7fd586c317945a2023d4fc8c59907a993dddf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa7fd586c317945a2023d4fc8c59907a993dddf9"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "8c54eaf5b5013c313ad349b78509ef48645eaddf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "patch": "@@ -1,3 +1,11 @@\n+2011-10-06  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\tPR target/50305\n+\t* config/arm/arm.c (arm_legitimize_reload_address): Recognize\n+\toutput of a previous pass through legitimize_reload_address.\n+\tDo not attempt to optimize addresses if the base register is\n+\tequivalent to a constant.\n+\n 2011-10-06  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* function.c (thread_prologue_and_epilogue_insns): Mark"}, {"sha": "2feac6f45e1db945348f28e75eda6445abc4c643", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "patch": "@@ -6550,9 +6550,26 @@ arm_legitimize_reload_address (rtx *p,\n \t\t\t       int opnum, int type,\n \t\t\t       int ind_levels ATTRIBUTE_UNUSED)\n {\n+  /* We must recognize output that we have already generated ourselves.  */\n+  if (GET_CODE (*p) == PLUS\n+      && GET_CODE (XEXP (*p, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (*p, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (*p, 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (*p, 1)) == CONST_INT)\n+    {\n+      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n+\t\t   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),\n+\t\t   VOIDmode, 0, 0, opnum, (enum reload_type) type);\n+      return true;\n+    }\n+\n   if (GET_CODE (*p) == PLUS\n       && GET_CODE (XEXP (*p, 0)) == REG\n       && ARM_REGNO_OK_FOR_BASE_P (REGNO (XEXP (*p, 0)))\n+      /* If the base register is equivalent to a constant, let the generic\n+\t code handle it.  Otherwise we will run into problems if a future\n+\t reload pass decides to rematerialize the constant.  */\n+      && !reg_equiv_constant (ORIGINAL_REGNO (XEXP (*p, 0)))\n       && GET_CODE (XEXP (*p, 1)) == CONST_INT)\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (*p, 1));"}, {"sha": "27f774624015941c2b9284a21134f2895b98ac61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "patch": "@@ -1,3 +1,8 @@\n+2011-10-06  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\tPR target/50305\n+\t* gcc.target/arm/pr50305.c: New test.\n+\n 2011-10-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/38884"}, {"sha": "2f6ad5cfeabf99ae0fce592e533c9f8c56a4df39", "filename": "gcc/testsuite/gcc.target/arm/pr50305.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr50305.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr50305.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr50305.c?ref=4da6de81bcebc40d78a79d3c83c1960e6fc7d1d8", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"incompatible options\" { arm*-*-* } { \"-march=*\" } { \"-march=armv7-a\" } } */\n+/* { dg-options \"-O2 -fno-omit-frame-pointer -marm -march=armv7-a -mfpu=vfp3\" } */\n+\n+struct event {\n+ unsigned long long id;\n+ unsigned int flag;\n+};\n+\n+void dummy(void)\n+{\n+  /* This is here to ensure that the offset of perf_event_id below\n+     relative to the LANCHOR symbol exceeds the allowed displacement.  */\n+  static int __warned[300];\n+ __warned[0] = 1;\n+}\n+\n+extern void *kmem_cache_alloc_trace (void *cachep);\n+extern void *cs_cachep;\n+extern int nr_cpu_ids;\n+\n+struct event *\n+event_alloc (int cpu)\n+{\n+ static unsigned long long __attribute__((aligned(8))) perf_event_id;\n+ struct event *event;\n+ unsigned long long result;\n+ unsigned long tmp;\n+\n+ if (cpu >= nr_cpu_ids)\n+  return 0;\n+\n+ event = kmem_cache_alloc_trace (cs_cachep);\n+\n+ __asm__ __volatile__ (\"dmb\" : : : \"memory\");\n+\n+ __asm__ __volatile__(\"@ atomic64_add_return\\n\"\n+\"1:\tldrexd\t%0, %H0, [%3]\\n\"\n+\"\tadds\t%0, %0, %4\\n\"\n+\"\tadc\t%H0, %H0, %H4\\n\"\n+\"\tstrexd\t%1, %0, %H0, [%3]\\n\"\n+\"\tteq\t%1, #0\\n\"\n+\"\tbne\t1b\"\n+ : \"=&r\" (result), \"=&r\" (tmp), \"+Qo\" (perf_event_id)\n+ : \"r\" (&perf_event_id), \"r\" (1LL)\n+ : \"cc\");\n+\n+ __asm__ __volatile__ (\"dmb\" : : : \"memory\");\n+\n+ event->id = result;\n+\n+ if (cpu)\n+  event->flag = 1;\n+\n+ for (cpu = 0; cpu < nr_cpu_ids; cpu++)\n+   kmem_cache_alloc_trace (cs_cachep);\n+\n+ return event;\n+}\n+"}]}