{"sha": "1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI5ZGVlYjQ2ZTNjMmFmNzVhNzA5NmUxODY5ZTUzMDdiOGJmMWU0NQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2004-08-17T12:51:01Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-08-17T12:51:01Z"}, "message": "lang.c (lang_printable_name): Obey verbose flag.\n\n2004-08-17  Andrew Haley  <aph@redhat.com>\n\n\t* lang.c (lang_printable_name): Obey verbose flag.\n\t* parse.y (constructor_circularity_msg): Set VERBOSE arg for\n\tlang_printable_name().\n\t(verify_constructor_circularity, get_printable_method_name,\n\tcheck_abstract_method_definitions, java_check_regular_methods,\n\tjava_check_abstract_methods, check_inner_class_access,\n\tfix_constructors, patch_method_invocation, patch_return):\n\tLikewise.\n\t* expr.c (pop_type_0): Likewise.\n\n\t* java-tree.h (lang_printable_name_wls): Delete.\n\nFrom-SVN: r86118", "tree": {"sha": "12aa8faa9056877f7059dff529dec6f009a13671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12aa8faa9056877f7059dff529dec6f009a13671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "108a579c02badf9b3eddc3d182516bd73c585a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108a579c02badf9b3eddc3d182516bd73c585a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108a579c02badf9b3eddc3d182516bd73c585a38"}], "stats": {"total": 76, "additions": 40, "deletions": 36}, "files": [{"sha": "7fdaf07251afc7d9f185bf82449acedcbe7e8774", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "patch": "@@ -1,3 +1,17 @@\n+2004-08-17  Andrew Haley  <aph@redhat.com>\n+\n+\t* lang.c (lang_printable_name): Obey verbose flag.\n+\t* parse.y (constructor_circularity_msg): Set VERBOSE arg for\n+\tlang_printable_name().\n+\t(verify_constructor_circularity, get_printable_method_name,\n+\tcheck_abstract_method_definitions, java_check_regular_methods,\n+\tjava_check_abstract_methods, check_inner_class_access,\n+\tfix_constructors, patch_method_invocation, patch_return):\n+\tLikewise.\n+\t* expr.c (pop_type_0): Likewise.\n+\n+\t* java-tree.h (lang_printable_name_wls): Delete.\n+\n 2004-08-16  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/8473:"}, {"sha": "b9429a1fade1e106ba0c267e819f09961a18cfa4", "filename": "gcc/java/lang.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "patch": "@@ -497,24 +497,14 @@ put_decl_node (tree node)\n    which is also called directly by java_print_error_function. */\n \n const char *\n-lang_printable_name (tree decl, int v  __attribute__ ((__unused__)))\n+lang_printable_name (tree decl, int v)\n {\n   decl_bufpos = 0;\n-  put_decl_node (decl);\n-  put_decl_string (\"\", 1);\n-  return decl_buf;\n-}\n-\n-/* Does the same thing that lang_printable_name, but add a leading\n-   space to the DECL name string -- With Leading Space.  */\n-\n-const char *\n-lang_printable_name_wls (tree decl, int v  __attribute__ ((__unused__)))\n-{\n-  decl_bufpos = 1;\n-  put_decl_node (decl);\n+  if (v == 0 && TREE_CODE (decl) == FUNCTION_DECL)\n+    put_decl_node (DECL_NAME (decl));\n+  else\n+    put_decl_node (decl);\n   put_decl_string (\"\", 1);\n-  decl_buf [0] = ' ';\n   return decl_buf;\n }\n "}, {"sha": "e1012a7c485c70180c1ec0f622c512a9b7aa52b3", "filename": "gcc/java/parse.y", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9deeb46e3c2af75a7096e1869e5307b8bf1e45/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=1b9deeb46e3c2af75a7096e1869e5307b8bf1e45", "patch": "@@ -4842,8 +4842,8 @@ static char *\n constructor_circularity_msg (tree from, tree to)\n {\n   static char string [4096];\n-  char *t = xstrdup (lang_printable_name (from, 0));\n-  sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 0));\n+  char *t = xstrdup (lang_printable_name (from, 2));\n+  sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 2));\n   free (t);\n   return string;\n }\n@@ -4875,7 +4875,7 @@ verify_constructor_circularity (tree meth, tree current)\n \t\t  java_error_count--;\n \t\t}\n \t    }\n-\t  t = xstrdup (lang_printable_name (meth, 0));\n+\t  t = xstrdup (lang_printable_name (meth, 2));\n \t  parse_error_context (TREE_PURPOSE (c),\n \t\t\t       \"%s: recursive invocation of constructor `%s'\",\n \t\t\t       constructor_circularity_msg (current, meth), t);\n@@ -6100,7 +6100,7 @@ get_printable_method_name (tree decl)\n       DECL_NAME (decl) = DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl)));\n     }\n \n-  to_return = lang_printable_name (decl, 0);\n+  to_return = lang_printable_name (decl, 2);\n   if (DECL_CONSTRUCTOR_P (decl))\n     DECL_NAME (decl) = name;\n \n@@ -6207,7 +6207,7 @@ check_abstract_method_definitions (int do_interface, tree class_decl,\n \t    (lookup_cl (class_decl),\n \t     \"Class `%s' doesn't define the abstract method `%s %s' from %s `%s'. This method must be defined or %s `%s' must be declared abstract\",\n \t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n-\t     t, lang_printable_name (method, 0),\n+\t     t, lang_printable_name (method, 2),\n \t     (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ?\n \t      \"interface\" : \"class\"),\n \t     IDENTIFIER_POINTER (ccn),\n@@ -6385,7 +6385,7 @@ java_check_regular_methods (tree class_decl)\n \t  char *t = xstrdup (lang_printable_name (class, 0));\n \t  parse_error_context\n \t    (method_wfl, \"Method `%s' can't be static in inner class `%s'. Only members of interfaces and top-level classes can be static\",\n-\t     lang_printable_name (method, 0), t);\n+\t     lang_printable_name (method, 2), t);\n \t  free (t);\n \t}\n \n@@ -6407,7 +6407,7 @@ java_check_regular_methods (tree class_decl)\n \t  tree found_decl = TYPE_NAME (DECL_CONTEXT (found));\n \t  parse_error_context (method_wfl, \"Class `%s' must override `%s' with a public method in order to implement interface `%s'\",\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n-\t\t\t       lang_printable_name (method, 0),\n+\t\t\t       lang_printable_name (method, 2),\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (found_decl)));\n \t}\n \n@@ -6416,11 +6416,11 @@ java_check_regular_methods (tree class_decl)\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n \t{\n \t  char *t = xstrdup\n-\t    (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n+\t    (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 2));\n \t  parse_error_context\n \t    (method_wfl,\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n-\t     lang_printable_name (found, 0), t,\n+\t     lang_printable_name (found, 2), t,\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n@@ -6438,7 +6438,7 @@ java_check_regular_methods (tree class_decl)\n \t    (method_wfl,\n \t     \"%s methods can't be overridden. Method `%s' is %s in class `%s'\",\n \t     (METHOD_FINAL (found) ? \"Final\" : \"Static\"),\n-\t     lang_printable_name (found, 0),\n+\t     lang_printable_name (found, 2),\n \t     (METHOD_FINAL (found) ? \"final\" : \"static\"),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -6451,7 +6451,7 @@ java_check_regular_methods (tree class_decl)\n \t  parse_error_context\n \t    (method_wfl,\n \t     \"Instance methods can't be overridden by a static method. Method `%s' is an instance method in class `%s'\",\n-\t     lang_printable_name (found, 0),\n+\t     lang_printable_name (found, 2),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  continue;\n@@ -6473,7 +6473,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"Methods can't be overridden to be more private. Method `%s' is not %s in class `%s'\", lang_printable_name (method, 0),\n+\t     \"Methods can't be overridden to be more private. Method `%s' is not %s in class `%s'\", lang_printable_name (method, 2),\n \t     (METHOD_PUBLIC (method) ? \"public\" :\n \t      (METHOD_PRIVATE (method) ? \"private\" : \"protected\")),\n \t     IDENTIFIER_POINTER (DECL_NAME\n@@ -6616,7 +6616,7 @@ check_throws_clauses (tree method, tree method_wfl, tree found)\n \t  parse_error_context\n \t    (method_wfl, \"Invalid checked exception class `%s' in `throws' clause.  The exception must be a subclass of an exception thrown by `%s' from class `%s'\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n-\t     lang_printable_name (found, 0),\n+\t     lang_printable_name (found, 2),\n \t     IDENTIFIER_POINTER\n \t     (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t}\n@@ -6643,11 +6643,11 @@ java_check_abstract_methods (tree interface_decl)\n       if (found)\n \t{\n \t  char *t;\n-\t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n+\t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 2));\n \t  parse_error_context\n \t    (DECL_FUNCTION_WFL (found),\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n-\t     lang_printable_name (found, 0), t,\n+\t     lang_printable_name (found, 2), t,\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n@@ -6673,7 +6673,7 @@ java_check_abstract_methods (tree interface_decl)\n \t\t(lookup_cl (sub_interface_method),\n \t\t \"Interface `%s' inherits method `%s' from interface `%s'. This method is redefined with a different return type in interface `%s'\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n-\t\t lang_printable_name (found, 0),\n+\t\t lang_printable_name (found, 2),\n \t\t IDENTIFIER_POINTER\n \t\t   (DECL_NAME (TYPE_NAME\n \t\t\t       (DECL_CONTEXT (sub_interface_method)))),\n@@ -7240,7 +7240,7 @@ check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n \n   parse_error_context (cl, \"Nested %s %s is %s; cannot be accessed from here\",\n \t\t       (CLASS_INTERFACE (decl) ? \"interface\" : \"class\"),\n-\t\t       lang_printable_name (decl, 0), access);\n+\t\t       lang_printable_name (decl, 2), access);\n }\n \n /* Accessibility check for top-level classes. If CLASS_NAME is in a\n@@ -8835,7 +8835,7 @@ fix_constructors (tree mdecl)\n \t  parse_error_context\n \t    (lookup_cl (TYPE_NAME (class_type)),\n \t     \"No constructor matching `%s' found in class `%s'\",\n-\t     lang_printable_name (mdecl, 0), n);\n+\t     lang_printable_name (mdecl, 2), n);\n \t  DECL_NAME (mdecl) = save;\n \t}\n \n@@ -10297,7 +10297,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t    }\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n-\t      char *fct_name = xstrdup (lang_printable_name (list, 0));\n+\t      char *fct_name = xstrdup (lang_printable_name (list, 2));\n \t      parse_error_context\n \t\t(identifier_wfl,\n \t\t \"Can't make static reference to method `%s %s' in class `%s'\",\n@@ -14669,13 +14669,13 @@ patch_return (tree node)\n \t  parse_error_context (wfl_operator,\n \t\t\t       \"`return' with%s value from `%s %s'\",\n \t\t\t       (error_found == 1 ? \"\" : \"out\"),\n-\t\t\t       t, lang_printable_name (meth, 0));\n+\t\t\t       t, lang_printable_name (meth, 2));\n \t  free (t);\n \t}\n       else\n \tparse_error_context (wfl_operator,\n \t\t\t     \"`return' with value from constructor `%s'\",\n-\t\t\t     lang_printable_name (meth, 0));\n+\t\t\t     lang_printable_name (meth, 2));\n       return error_mark_node;\n     }\n "}]}