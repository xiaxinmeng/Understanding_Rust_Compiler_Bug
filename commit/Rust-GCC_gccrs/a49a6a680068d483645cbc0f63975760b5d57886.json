{"sha": "a49a6a680068d483645cbc0f63975760b5d57886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ5YTZhNjgwMDY4ZDQ4MzY0NWNiYzBmNjM5NzU3NjBiNWQ1Nzg4Ng==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-02-18T06:32:01Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-02-18T06:32:01Z"}, "message": "loop.c (canonicalize_condition): New function, broken out of get_condition.\n\n\t* loop.c (canonicalize_condition): New function,\n\tbroken out of get_condition.\n\t(get_condition): Use it.\n\t* expr.h (canonicalize_condition): Prototype it.\n\n\t* tree.h (tree_int_cst_msb): Declare.\n\t* tree.c (tree_int_cst_msb): New function.\n\nFrom-SVN: r32045", "tree": {"sha": "3c30c190987a1ec418bb165199041649c8b305e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c30c190987a1ec418bb165199041649c8b305e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a49a6a680068d483645cbc0f63975760b5d57886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49a6a680068d483645cbc0f63975760b5d57886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a49a6a680068d483645cbc0f63975760b5d57886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49a6a680068d483645cbc0f63975760b5d57886/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "930b1f40d0f3b4ad09d916f2a6da33f9d20dfad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/930b1f40d0f3b4ad09d916f2a6da33f9d20dfad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/930b1f40d0f3b4ad09d916f2a6da33f9d20dfad9"}], "stats": {"total": 129, "additions": 97, "deletions": 32}, "files": [{"sha": "6a5b4006fc2794071b583a315c75cd11659cf02b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a49a6a680068d483645cbc0f63975760b5d57886", "patch": "@@ -1,3 +1,13 @@\n+Fri Feb 18 01:29:22 EST 2000  John Wehle  (john@feith.com)\n+\n+\t* loop.c (canonicalize_condition): New function,\n+\tbroken out of get_condition.\n+\t(get_condition): Use it.\n+\t* expr.h (canonicalize_condition): Prototype it.\n+\n+\t* tree.h (tree_int_cst_msb): Declare.\n+\t* tree.c (tree_int_cst_msb): New function.\n+\n 2000-02-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* stmt.c (set_file_and_line_for_stmt): Don't crash if cfun->stmt"}, {"sha": "22af908908fc744a30ba6554c8aba31697b89f19", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a49a6a680068d483645cbc0f63975760b5d57886", "patch": "@@ -888,7 +888,12 @@ extern rtx emit_store_flag_force PARAMS ((rtx, enum rtx_code, rtx, rtx,\n \n /* Functions from loop.c:  */\n \n-/* Given a JUMP_INSN, return a description of the test being made.  */\n+/* Given an insn and condition, return a canonical description of\n+   the test being made.  */\n+extern rtx canonicalize_condition PARAMS ((rtx, rtx, int, rtx *));\n+\n+/* Given a JUMP_INSN, return a canonical description of the test\n+   being made.  */\n extern rtx get_condition PARAMS ((rtx, rtx *));\n \n /* Generate a conditional trap instruction.  */"}, {"sha": "c89718fa24797409b3e9e6ad45913bd5c40fd82a", "filename": "gcc/loop.c", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a49a6a680068d483645cbc0f63975760b5d57886", "patch": "@@ -8995,57 +8995,54 @@ update_reg_last_use (x, insn)\n     }\n }\n \f\n-/* Given a jump insn JUMP, return the condition that will cause it to branch\n-   to its JUMP_LABEL.  If the condition cannot be understood, or is an\n-   inequality floating-point comparison which needs to be reversed, 0 will\n-   be returned.\n-\n-   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n-   insn used in locating the condition was found.  If a replacement test\n-   of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.\n-\n-   The condition will be returned in a canonical form to simplify testing by\n-   callers.  Specifically:\n+/* Given an insn INSN and condition COND, return the condition in a\n+   canonical form to simplify testing by callers.  Specifically:\n \n    (1) The code will always be a comparison operation (EQ, NE, GT, etc.).\n    (2) Both operands will be machine operands; (cc0) will have been replaced.\n    (3) If an operand is a constant, it will be the second operand.\n    (4) (LE x const) will be replaced with (LT x <const+1>) and similarly\n-       for GE, GEU, and LEU.  */\n+       for GE, GEU, and LEU.\n+\n+   If the condition cannot be understood, or is an inequality floating-point\n+   comparison which needs to be reversed, 0 will be returned.\n+\n+   If REVERSE is non-zero, then reverse the condition prior to canonizing it.\n+\n+   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   insn used in locating the condition was found.  If a replacement test\n+   of the condition is desired, it should be placed in front of that\n+   insn and we will be sure that the inputs are still valid.  */\n \n rtx\n-get_condition (jump, earliest)\n-     rtx jump;\n+canonicalize_condition (insn, cond, reverse, earliest)\n+     rtx insn;\n+     rtx cond;\n+     int reverse;\n      rtx *earliest;\n {\n   enum rtx_code code;\n-  rtx prev = jump;\n+  rtx prev = insn;\n   rtx set;\n   rtx tem;\n   rtx op0, op1;\n   int reverse_code = 0;\n   int did_reverse_condition = 0;\n   enum machine_mode mode;\n \n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  if (GET_CODE (jump) != JUMP_INSN\n-      || ! condjump_p (jump) || simplejump_p (jump))\n-    return 0;\n+  code = GET_CODE (cond);\n+  mode = GET_MODE (cond);\n+  op0 = XEXP (cond, 0);\n+  op1 = XEXP (cond, 1);\n \n-  code = GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 0));\n-  mode = GET_MODE (XEXP (SET_SRC (PATTERN (jump)), 0));\n-  op0 = XEXP (XEXP (SET_SRC (PATTERN (jump)), 0), 0);\n-  op1 = XEXP (XEXP (SET_SRC (PATTERN (jump)), 0), 1);\n+  if (reverse)\n+    {\n+      code = reverse_condition (code);\n+      did_reverse_condition ^= 1;\n+    }\n \n   if (earliest)\n-    *earliest = jump;\n-\n-  /* If this branches to JUMP_LABEL when the condition is false, reverse\n-     the condition.  */\n-  if (GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n-      && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump))\n-    code = reverse_condition (code), did_reverse_condition ^= 1;\n+    *earliest = insn;\n \n   /* If we are comparing a register with zero, see if the register is set\n      in the previous insn to a COMPARE or a comparison operation.  Perform\n@@ -9262,6 +9259,40 @@ get_condition (jump, earliest)\n   return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n }\n \n+/* Given a jump insn JUMP, return the condition that will cause it to branch\n+   to its JUMP_LABEL.  If the condition cannot be understood, or is an\n+   inequality floating-point comparison which needs to be reversed, 0 will\n+   be returned.\n+\n+   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   insn used in locating the condition was found.  If a replacement test\n+   of the condition is desired, it should be placed in front of that\n+   insn and we will be sure that the inputs are still valid.  */\n+\n+rtx\n+get_condition (jump, earliest)\n+     rtx jump;\n+     rtx *earliest;\n+{\n+  rtx cond;\n+  int reverse;\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  if (GET_CODE (jump) != JUMP_INSN\n+      || ! condjump_p (jump) || simplejump_p (jump))\n+    return 0;\n+\n+  cond = XEXP (SET_SRC (PATTERN (jump)), 0);\n+\n+  /* If this branches to JUMP_LABEL when the condition is false, reverse\n+     the condition.  */\n+  reverse\n+    = GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n+      && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump);\n+\n+  return canonicalize_condition (jump, cond, reverse, earliest);\n+}\n+\n /* Similar to above routine, except that we also put an invariant last\n    unless both operands are invariants.  */\n "}, {"sha": "c01d46e71d956a3f6eec39abbb86086cc4464e27", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a49a6a680068d483645cbc0f63975760b5d57886", "patch": "@@ -4062,6 +4062,24 @@ tree_int_cst_lt (t1, t2)\n   return INT_CST_LT_UNSIGNED (t1, t2);\n }\n \n+/* Return the most significant bit of the integer constant T.  */\n+\n+int\n+tree_int_cst_msb (t)\n+     tree t;\n+{\n+  register int prec;\n+  HOST_WIDE_INT h;\n+  HOST_WIDE_INT l;\n+\n+  /* Note that using TYPE_PRECISION here is wrong.  We care about the\n+     actual bits, not the (arbitrary) range of the type.  */\n+  prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (t))) - 1;\n+  rshift_double (TREE_INT_CST_LOW (t), TREE_INT_CST_HIGH (t), prec,\n+\t\t 2 * HOST_BITS_PER_WIDE_INT, &l, &h, 0);\n+  return (l & 1) == 1;\n+  }\n+\n /* Return an indication of the sign of the integer constant T.\n    The return value is -1 if T < 0, 0 if T == 0, and 1 if T > 0.\n    Note that -1 will never be returned it T's type is unsigned.  */"}, {"sha": "02fa95b82f15d2e6292c1f7fe8dbc8c55f06f7f8", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49a6a680068d483645cbc0f63975760b5d57886/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a49a6a680068d483645cbc0f63975760b5d57886", "patch": "@@ -1666,6 +1666,7 @@ extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n extern int attribute_list_contained\tPARAMS ((tree, tree));\n extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n+extern int tree_int_cst_msb\t\tPARAMS ((tree));\n extern int tree_int_cst_sgn\t\tPARAMS ((tree));\n extern int index_type_equal\t\tPARAMS ((tree, tree));\n extern tree get_inner_array_type\tPARAMS ((tree));"}]}