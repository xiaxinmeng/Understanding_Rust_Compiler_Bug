{"sha": "c44033714b2800977881fdb85cc7662c89eafbf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ0MDMzNzE0YjI4MDA5Nzc4ODFmZGI4NWNjNzY2MmM4OWVhZmJmMQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-04-10T04:17:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-10T04:17:51Z"}, "message": "rtl.h (rebuild_jump_labels): Declare.\n\n        * rtl.h (rebuild_jump_labels): Declare.\n        * jump.c (jump_optimize_1): Renamed from jump_optimize.  Make static.\n        Add new argument MARK_LABELS_ONLY.  Quit after mark_all_labels if\n        requested.\n        (jump_optimize, rebuild_jump_labels): New wrapper functions for\n        jump_optimize_1.\n        * toplev.c (rest_of_compilation): Use rebuild_jump_labels instead of\n        running the entire jump optimizer.\n\nFrom-SVN: r26327", "tree": {"sha": "4637eb0e6a1825b933e72073aa6abf834c06e231", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4637eb0e6a1825b933e72073aa6abf834c06e231"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c44033714b2800977881fdb85cc7662c89eafbf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c44033714b2800977881fdb85cc7662c89eafbf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c44033714b2800977881fdb85cc7662c89eafbf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c44033714b2800977881fdb85cc7662c89eafbf1/comments", "author": null, "committer": null, "parents": [{"sha": "5d90cd8ff35f5f714a88039f1c92058f14e5b532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d90cd8ff35f5f714a88039f1c92058f14e5b532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d90cd8ff35f5f714a88039f1c92058f14e5b532"}], "stats": {"total": 67, "additions": 53, "deletions": 14}, "files": [{"sha": "fd8f5d7a3e08977b4e167f57fa890202a6d47ef0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c44033714b2800977881fdb85cc7662c89eafbf1", "patch": "@@ -14,6 +14,15 @@\n \n Sat Apr 10 03:50:12 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* rtl.h (rebuild_jump_labels): Declare.\n+\t* jump.c (jump_optimize_1): Renamed from jump_optimize.  Make static.\n+\tAdd new argument MARK_LABELS_ONLY.  Quit after mark_all_labels if\n+\trequested.\n+\t(jump_optimize, rebuild_jump_labels): New wrapper functions for\n+\tjump_optimize_1.\n+\t* toplev.c (rest_of_compilation): Use rebuild_jump_labels instead of\n+\trunning the entire jump optimizer.\n+\n \t* rtl.h (local_alloc): Returns an integer now.\n \t* local-alloc.c (recorded_label_ref): New file scoped variable.\n \t(local_alloc): Initialize recorded_label_ref to zero.  Return its"}, {"sha": "9a031937dd23d69888dd10f63897d1b383343a07", "filename": "gcc/jump.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=c44033714b2800977881fdb85cc7662c89eafbf1", "patch": "@@ -126,9 +126,33 @@ static void delete_from_jump_chain\tPROTO((rtx));\n static int delete_labelref_insn\t\tPROTO((rtx, rtx, int));\n static void mark_modified_reg\t\tPROTO((rtx, rtx));\n static void redirect_tablejump\t\tPROTO((rtx, rtx));\n+static void jump_optimize_1\t\tPROTO ((rtx, int, int, int, int));\n #ifndef HAVE_cc0\n static rtx find_insert_position         PROTO((rtx, rtx));\n #endif\n+\n+/* Main external entry point into the jump optimizer.  See comments before\n+   jump_optimize_1 for descriptions of the arguments.  */\n+void\n+jump_optimize (f, cross_jump, noop_moves, after_regscan)\n+     rtx f;\n+     int cross_jump;\n+     int noop_moves;\n+     int after_regscan;\n+{\n+  jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, 0);\n+}\n+\n+/* Alternate entry into the jump optimizer.  This entry point only rebuilds\n+   the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping\n+   instructions.  */\n+void\n+rebuild_jump_labels (f)\n+     rtx f;\n+{\n+  jump_optimize_1 (f, 0, 0, 0, 1);\n+}\n+\n \f\n /* Delete no-op jumps and optimize jumps to jumps\n    and jumps around jumps.\n@@ -143,18 +167,22 @@ static rtx find_insert_position         PROTO((rtx, rtx));\n    If AFTER_REGSCAN is nonzero, then this jump pass is being run immediately\n    after regscan, and it is safe to use regno_first_uid and regno_last_uid.\n \n+   If MARK_LABELS_ONLY is nonzero, then we only rebuild the jump chain\n+   and JUMP_LABEL field for jumping insns.\n+\n    If `optimize' is zero, don't change any code,\n    just determine whether control drops off the end of the function.\n    This case occurs when we have -W and not -O.\n    It works because `delete_insn' checks the value of `optimize'\n    and refrains from actually deleting when that is 0.  */\n \n void\n-jump_optimize (f, cross_jump, noop_moves, after_regscan)\n+jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n      rtx f;\n      int cross_jump;\n      int noop_moves;\n      int after_regscan;\n+     int mark_labels_only;\n {\n   register rtx insn, next;\n   int changed;\n@@ -182,6 +210,11 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n   mark_all_labels (f, cross_jump);\n \n+  /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL\n+     notes.  */\n+  if (mark_labels_only)\n+    return;\n+\n   /* Keep track of labels used from static data;\n      they cannot ever be deleted.  */\n "}, {"sha": "9fb8c4ac30a9d1f9b53700eda6d0b993e2821bd7", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c44033714b2800977881fdb85cc7662c89eafbf1", "patch": "@@ -1354,6 +1354,7 @@ extern int rtx_renumbered_equal_p\tPROTO ((rtx, rtx));\n extern int true_regnum\t\t\tPROTO ((rtx));\n extern int redirect_jump\t\tPROTO ((rtx, rtx));\n extern void jump_optimize\t\tPROTO ((rtx, int, int, int));\n+extern void rebuild_jump_labels\t\tPROTO ((rtx));\n extern void thread_jumps\t\tPROTO ((rtx, int, int));\n extern int redirect_exp\t\t\tPROTO ((rtx *, rtx, rtx, rtx));\n extern int rtx_equal_for_thread_p\tPROTO ((rtx, rtx, rtx));"}, {"sha": "282928435087551d277e05b1ca122e4c169da48b", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44033714b2800977881fdb85cc7662c89eafbf1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c44033714b2800977881fdb85cc7662c89eafbf1", "patch": "@@ -3526,7 +3526,7 @@ rest_of_compilation (decl)\n   /* Likewise, for DECL_ARGUMENTS.  */\n   tree saved_arguments = 0;\n   int failure = 0;\n-  int run_jump_after_reload;\n+  int rebuild_label_notes_after_reload;\n \n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n@@ -4074,10 +4074,10 @@ rest_of_compilation (decl)\n \t     {\n \t       recompute_reg_usage (insns, ! optimize_size);\n \t       regclass (insns, max_reg_num ());\n-\t       run_jump_after_reload = local_alloc ();\n+\t       rebuild_label_notes_after_reload = local_alloc ();\n \t     });\n   else\n-    run_jump_after_reload = 0;\n+    rebuild_label_notes_after_reload = 0;\n \n   /* Dump rtl code after allocating regs within basic blocks.  */\n \n@@ -4112,20 +4112,16 @@ rest_of_compilation (decl)\n   if (failure)\n     goto exit_rest_of_compilation;\n \n-  /* Register allocation and reloading may have turned an indirect jump into\n-     a direct jump.  If so, we must rerun the jump optimizer to ensure that\n-     the JUMP_LABEL of any jump changed by that transformation is valid.\n-\n-     We do this before reload_cse_regs since it may allow reload_cse to do\n-     a better job.  */\n-  if (run_jump_after_reload)\n-    TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t       !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN));\n-\n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n     reload_cse_regs (insns);\n \n+  /* Register allocation and reloading may have turned an indirect jump into\n+     a direct jump.  If so, we must rebuild the JUMP_LABEL fields of\n+     jumping instructions.  */\n+  if (rebuild_label_notes_after_reload)\n+    TIMEVAR (jump_time, rebuild_jump_labels (insns));\n+\n   /* If optimizing and we are performing instruction scheduling after\n      reload, then go ahead and split insns now since we are about to\n      recompute flow information anyway."}]}