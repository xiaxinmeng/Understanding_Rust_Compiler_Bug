{"sha": "a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThiNThkODRiZjRmZDljOTI1YTgzNWJhMzljMWM1NTIzODNiYzYxYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-18T20:27:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-18T20:27:59Z"}, "message": "libgo: update to Go 1.12.1\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/167749\n\nFrom-SVN: r269780", "tree": {"sha": "97d68e0e70fb780b04f3171a0f53102a39c23f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97d68e0e70fb780b04f3171a0f53102a39c23f41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/comments", "author": null, "committer": null, "parents": [{"sha": "891cd9e3b9a89b0461fb838d38c51b6fab596337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891cd9e3b9a89b0461fb838d38c51b6fab596337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891cd9e3b9a89b0461fb838d38c51b6fab596337"}], "stats": {"total": 536, "additions": 398, "deletions": 138}, "files": [{"sha": "a09733f8c467407d5420e62dba01c5fe5bfbc6c0", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -1,4 +1,4 @@\n-cc70be24502faeffefb66fd0abeb7f20a6c7792a\n+87945b620b2100d33e27f33e6276a4e4e5890659\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d456361af0b159bac11ea8947d434308c0615ca7", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -1,4 +1,4 @@\n-05e77d41914d247a1e7caf37d7125ccaa5a53505\n+0380c9ad38843d523d9c9804fe300cb7edd7cd3c\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "f325447817bc7d75c1be02cc1546a70673304f0d", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -1 +1 @@\n-go1.12\n+go1.12.1"}, {"sha": "54d6bc2559dc9d901d7ac8ba6b59a6bb30426351", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -200,18 +200,6 @@ func (f *File) saveExprs(x interface{}, context astContext) {\n \t\t}\n \tcase *ast.CallExpr:\n \t\tf.saveCall(x, context)\n-\tcase *ast.GenDecl:\n-\t\tif x.Tok == token.CONST {\n-\t\t\tfor _, spec := range x.Specs {\n-\t\t\t\tvs := spec.(*ast.ValueSpec)\n-\t\t\t\tif vs.Type == nil {\n-\t\t\t\t\tfor _, name := range spec.(*ast.ValueSpec).Names {\n-\t\t\t\t\t\tconsts[name.Name] = true\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n \t}\n }\n "}, {"sha": "e56207acaa7f32daf9c719b9396b41b87950b239", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 11, "deletions": 53, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -915,21 +915,16 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \t\t\tneedsUnsafe = true\n \t\t}\n \n-\t\t// Explicitly convert untyped constants to the\n-\t\t// parameter type, to avoid a type mismatch.\n-\t\tif p.isConst(f, arg) {\n-\t\t\tptype := p.rewriteUnsafe(param.Go)\n+\t\t// Use \"var x T = ...\" syntax to explicitly convert untyped\n+\t\t// constants to the parameter type, to avoid a type mismatch.\n+\t\tptype := p.rewriteUnsafe(param.Go)\n+\n+\t\tif !p.needsPointerCheck(f, param.Go, args[i]) || param.BadPointer {\n \t\t\tif ptype != param.Go {\n \t\t\t\tneedsUnsafe = true\n \t\t\t}\n-\t\t\targ = &ast.CallExpr{\n-\t\t\t\tFun:  ptype,\n-\t\t\t\tArgs: []ast.Expr{arg},\n-\t\t\t}\n-\t\t}\n-\n-\t\tif !p.needsPointerCheck(f, param.Go, args[i]) {\n-\t\t\tfmt.Fprintf(&sb, \"_cgo%d := %s; \", i, gofmtPos(arg, origArg.Pos()))\n+\t\t\tfmt.Fprintf(&sb, \"var _cgo%d %s = %s; \", i,\n+\t\t\t\tgofmtLine(ptype), gofmtPos(arg, origArg.Pos()))\n \t\t\tcontinue\n \t\t}\n \n@@ -1272,47 +1267,6 @@ func (p *Package) isType(t ast.Expr) bool {\n \treturn false\n }\n \n-// isConst reports whether x is an untyped constant expression.\n-func (p *Package) isConst(f *File, x ast.Expr) bool {\n-\tswitch x := x.(type) {\n-\tcase *ast.BasicLit:\n-\t\treturn true\n-\tcase *ast.SelectorExpr:\n-\t\tid, ok := x.X.(*ast.Ident)\n-\t\tif !ok || id.Name != \"C\" {\n-\t\t\treturn false\n-\t\t}\n-\t\tname := f.Name[x.Sel.Name]\n-\t\tif name != nil {\n-\t\t\treturn name.IsConst()\n-\t\t}\n-\tcase *ast.Ident:\n-\t\treturn x.Name == \"nil\" ||\n-\t\t\tstrings.HasPrefix(x.Name, \"_Ciconst_\") ||\n-\t\t\tstrings.HasPrefix(x.Name, \"_Cfconst_\") ||\n-\t\t\tstrings.HasPrefix(x.Name, \"_Csconst_\") ||\n-\t\t\tconsts[x.Name]\n-\tcase *ast.UnaryExpr:\n-\t\treturn p.isConst(f, x.X)\n-\tcase *ast.BinaryExpr:\n-\t\treturn p.isConst(f, x.X) && p.isConst(f, x.Y)\n-\tcase *ast.ParenExpr:\n-\t\treturn p.isConst(f, x.X)\n-\tcase *ast.CallExpr:\n-\t\t// Calling the builtin function complex on two untyped\n-\t\t// constants returns an untyped constant.\n-\t\t// TODO: It's possible to construct a case that will\n-\t\t// erroneously succeed if there is a local function\n-\t\t// named \"complex\", shadowing the builtin, that returns\n-\t\t// a numeric type. I can't think of any cases that will\n-\t\t// erroneously fail.\n-\t\tif id, ok := x.Fun.(*ast.Ident); ok && id.Name == \"complex\" && len(x.Args) == 2 {\n-\t\t\treturn p.isConst(f, x.Args[0]) && p.isConst(f, x.Args[1])\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n // isVariable reports whether x is a variable, possibly with field references.\n func (p *Package) isVariable(x ast.Expr) bool {\n \tswitch x := x.(type) {\n@@ -2533,13 +2487,16 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t// Treat this typedef as a uintptr.\n \t\t\ts := *sub\n \t\t\ts.Go = c.uintptr\n+\t\t\ts.BadPointer = true\n \t\t\tsub = &s\n \t\t\t// Make sure we update any previously computed type.\n \t\t\tif oldType := typedef[name.Name]; oldType != nil {\n \t\t\t\toldType.Go = sub.Go\n+\t\t\t\toldType.BadPointer = true\n \t\t\t}\n \t\t}\n \t\tt.Go = name\n+\t\tt.BadPointer = sub.BadPointer\n \t\tif unionWithPointer[sub.Go] {\n \t\t\tunionWithPointer[t.Go] = true\n \t\t}\n@@ -2549,6 +2506,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tif oldType == nil {\n \t\t\ttt := *t\n \t\t\ttt.Go = sub.Go\n+\t\t\ttt.BadPointer = sub.BadPointer\n \t\t\ttypedef[name.Name] = &tt\n \t\t}\n "}, {"sha": "80f35681d75f0dfcd91cf1781ff1d4f74c5167fd", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -71,9 +71,6 @@ type File struct {\n \tEdit     *edit.Buffer\n }\n \n-// Untyped constants in the current package.\n-var consts = make(map[string]bool)\n-\n func (f *File) offset(p token.Pos) int {\n \treturn fset.Position(p).Offset\n }\n@@ -154,6 +151,7 @@ type Type struct {\n \tGo         ast.Expr\n \tEnumValues map[string]int64\n \tTypedef    string\n+\tBadPointer bool\n }\n \n // A FuncType collects information about a function type in both the C and Go worlds."}, {"sha": "7d389c3c1af9f13b16429480924f6d1709b9aa42", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -37,7 +37,7 @@ See golang.org to learn more about Go.\n // the first time Default is called.\n func initDefaultCache() {\n \tdir := DefaultDir()\n-\tif dir == \"off\" || dir == \"\" {\n+\tif dir == \"off\" {\n \t\tif defaultDirErr != nil {\n \t\t\tbase.Fatalf(\"build cache is required, but could not be located: %v\", defaultDirErr)\n \t\t}\n@@ -74,7 +74,12 @@ func DefaultDir() string {\n \n \tdefaultDirOnce.Do(func() {\n \t\tdefaultDir = os.Getenv(\"GOCACHE\")\n+\t\tif filepath.IsAbs(defaultDir) || defaultDir == \"off\" {\n+\t\t\treturn\n+\t\t}\n \t\tif defaultDir != \"\" {\n+\t\t\tdefaultDir = \"off\"\n+\t\t\tdefaultDirErr = fmt.Errorf(\"GOCACHE is not an absolute path\")\n \t\t\treturn\n \t\t}\n "}, {"sha": "c0e06676df1eb22403f2bf53fc71f48c8468a87a", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -129,6 +129,7 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\tptest.Internal.Imports = append(imports, p.Internal.Imports...)\n \t\tptest.Internal.RawImports = str.StringList(rawTestImports, p.Internal.RawImports)\n \t\tptest.Internal.ForceLibrary = true\n+\t\tptest.Internal.BuildInfo = \"\"\n \t\tptest.Internal.Build = new(build.Package)\n \t\t*ptest.Internal.Build = *p.Internal.Build\n \t\tm := map[string][]token.Position{}\n@@ -186,6 +187,7 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\t},\n \t\tInternal: PackageInternal{\n \t\t\tBuild:      &build.Package{Name: \"main\"},\n+\t\t\tBuildInfo:  p.Internal.BuildInfo,\n \t\t\tAsmflags:   p.Internal.Asmflags,\n \t\t\tGcflags:    p.Internal.Gcflags,\n \t\t\tLdflags:    p.Internal.Ldflags,\n@@ -352,6 +354,7 @@ func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t\t\tcopy(p1.Imports, p.Imports)\n \t\t\tp = p1\n \t\t\tp.Target = \"\"\n+\t\t\tp.Internal.BuildInfo = \"\"\n \t\t}\n \n \t\t// Update p.Internal.Imports to use test copies.\n@@ -361,6 +364,13 @@ func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t\t\t\tp.Internal.Imports[i] = p1\n \t\t\t}\n \t\t}\n+\n+\t\t// Don't compile build info from a main package. This can happen\n+\t\t// if -coverpkg patterns include main packages, since those packages\n+\t\t// are imported by pmain.\n+\t\tif p.Internal.BuildInfo != \"\" && p != pmain {\n+\t\t\tsplit()\n+\t\t}\n \t}\n }\n "}, {"sha": "da9f63fec9c0fb4d1efe81ea3035abc125032181", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -23,55 +23,99 @@ import (\n type codeRepo struct {\n \tmodPath string\n \n-\tcode     codehost.Repo\n+\t// code is the repository containing this module.\n+\tcode codehost.Repo\n+\t// codeRoot is the import path at the root of code.\n \tcodeRoot string\n-\tcodeDir  string\n+\t// codeDir is the directory (relative to root) at which we expect to find the module.\n+\t// If pathMajor is non-empty and codeRoot is not the full modPath,\n+\t// then we look in both codeDir and codeDir+modPath\n+\tcodeDir string\n \n-\tpath        string\n-\tpathPrefix  string\n-\tpathMajor   string\n+\t// pathMajor is the suffix of modPath that indicates its major version,\n+\t// or the empty string if modPath is at major version 0 or 1.\n+\t//\n+\t// pathMajor is typically of the form \"/vN\", but possibly \".vN\", or\n+\t// \".vN-unstable\" for modules resolved using gopkg.in.\n+\tpathMajor string\n+\t// pathPrefix is the prefix of modPath that excludes pathMajor.\n+\t// It is used only for logging.\n+\tpathPrefix string\n+\n+\t// pseudoMajor is the major version prefix to use when generating\n+\t// pseudo-versions for this module, derived from the module path.\n+\t//\n+\t// TODO(golang.org/issue/29262): We can't distinguish v0 from v1 using the\n+\t// path alone: we have to compute it by examining the tags at a particular\n+\t// revision.\n \tpseudoMajor string\n }\n \n-func newCodeRepo(code codehost.Repo, root, path string) (Repo, error) {\n-\tif !hasPathPrefix(path, root) {\n-\t\treturn nil, fmt.Errorf(\"mismatched repo: found %s for %s\", root, path)\n+// newCodeRepo returns a Repo that reads the source code for the module with the\n+// given path, from the repo stored in code, with the root of the repo\n+// containing the path given by codeRoot.\n+func newCodeRepo(code codehost.Repo, codeRoot, path string) (Repo, error) {\n+\tif !hasPathPrefix(path, codeRoot) {\n+\t\treturn nil, fmt.Errorf(\"mismatched repo: found %s for %s\", codeRoot, path)\n \t}\n \tpathPrefix, pathMajor, ok := module.SplitPathVersion(path)\n \tif !ok {\n \t\treturn nil, fmt.Errorf(\"invalid module path %q\", path)\n \t}\n+\tif codeRoot == path {\n+\t\tpathPrefix = path\n+\t}\n \tpseudoMajor := \"v0\"\n \tif pathMajor != \"\" {\n \t\tpseudoMajor = pathMajor[1:]\n \t}\n \n+\t// Compute codeDir = bar, the subdirectory within the repo\n+\t// corresponding to the module root.\n+\t//\n \t// At this point we might have:\n-\t//\tcodeRoot = github.com/rsc/foo\n \t//\tpath = github.com/rsc/foo/bar/v2\n+\t//\tcodeRoot = github.com/rsc/foo\n \t//\tpathPrefix = github.com/rsc/foo/bar\n \t//\tpathMajor = /v2\n \t//\tpseudoMajor = v2\n \t//\n-\t// Compute codeDir = bar, the subdirectory within the repo\n-\t// corresponding to the module root.\n-\tcodeDir := strings.Trim(strings.TrimPrefix(pathPrefix, root), \"/\")\n-\tif strings.HasPrefix(path, \"gopkg.in/\") {\n-\t\t// But gopkg.in is a special legacy case, in which pathPrefix does not start with codeRoot.\n-\t\t// For example we might have:\n-\t\t//\tcodeRoot = gopkg.in/yaml.v2\n-\t\t//\tpathPrefix = gopkg.in/yaml\n-\t\t//\tpathMajor = .v2\n-\t\t//\tpseudoMajor = v2\n-\t\t//\tcodeDir = pathPrefix (because codeRoot is not a prefix of pathPrefix)\n-\t\t// Clear codeDir - the module root is the repo root for gopkg.in repos.\n-\t\tcodeDir = \"\"\n+\t// which gives\n+\t//\tcodeDir = bar\n+\t//\n+\t// We know that pathPrefix is a prefix of path, and codeRoot is a prefix of\n+\t// path, but codeRoot may or may not be a prefix of pathPrefix, because\n+\t// codeRoot may be the entire path (in which case codeDir should be empty).\n+\t// That occurs in two situations.\n+\t//\n+\t// One is when a go-import meta tag resolves the complete module path,\n+\t// including the pathMajor suffix:\n+\t//\tpath = nanomsg.org/go/mangos/v2\n+\t//\tcodeRoot = nanomsg.org/go/mangos/v2\n+\t//\tpathPrefix = nanomsg.org/go/mangos\n+\t//\tpathMajor = /v2\n+\t//\tpseudoMajor = v2\n+\t//\n+\t// The other is similar: for gopkg.in only, the major version is encoded\n+\t// with a dot rather than a slash, and thus can't be in a subdirectory.\n+\t//\tpath = gopkg.in/yaml.v2\n+\t//\tcodeRoot = gopkg.in/yaml.v2\n+\t//\tpathPrefix = gopkg.in/yaml\n+\t//\tpathMajor = .v2\n+\t//\tpseudoMajor = v2\n+\t//\n+\tcodeDir := \"\"\n+\tif codeRoot != path {\n+\t\tif !hasPathPrefix(pathPrefix, codeRoot) {\n+\t\t\treturn nil, fmt.Errorf(\"repository rooted at %s cannot contain module %s\", codeRoot, path)\n+\t\t}\n+\t\tcodeDir = strings.Trim(pathPrefix[len(codeRoot):], \"/\")\n \t}\n \n \tr := &codeRepo{\n \t\tmodPath:     path,\n \t\tcode:        code,\n-\t\tcodeRoot:    root,\n+\t\tcodeRoot:    codeRoot,\n \t\tcodeDir:     codeDir,\n \t\tpathPrefix:  pathPrefix,\n \t\tpathMajor:   pathMajor,\n@@ -149,9 +193,6 @@ func (r *codeRepo) Stat(rev string) (*RevInfo, error) {\n \t\treturn r.Latest()\n \t}\n \tcodeRev := r.revToRev(rev)\n-\tif semver.IsValid(codeRev) && r.codeDir != \"\" {\n-\t\tcodeRev = r.codeDir + \"/\" + codeRev\n-\t}\n \tinfo, err := r.code.Stat(codeRev)\n \tif err != nil {\n \t\treturn nil, err\n@@ -290,14 +331,17 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \tfound1 := err1 == nil && isMajor(mpath1, r.pathMajor)\n \n \tvar file2 string\n-\tif r.pathMajor != \"\" && !strings.HasPrefix(r.pathMajor, \".\") {\n+\tif r.pathMajor != \"\" && r.codeRoot != r.modPath && !strings.HasPrefix(r.pathMajor, \".\") {\n \t\t// Suppose pathMajor is \"/v2\".\n \t\t// Either go.mod should claim v2 and v2/go.mod should not exist,\n \t\t// or v2/go.mod should exist and claim v2. Not both.\n \t\t// Note that we don't check the full path, just the major suffix,\n \t\t// because of replacement modules. This might be a fork of\n \t\t// the real module, found at a different path, usable only in\n \t\t// a replace directive.\n+\t\t//\n+\t\t// TODO(bcmills): This doesn't seem right. Investigate futher.\n+\t\t// (Notably: why can't we replace foo/v2 with fork-of-foo/v3?)\n \t\tdir2 := path.Join(r.codeDir, r.pathMajor[1:])\n \t\tfile2 = path.Join(dir2, \"go.mod\")\n \t\tgomod2, err2 := r.code.ReadFile(rev, file2, codehost.MaxGoMod)\n@@ -418,7 +462,7 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t}\n \tdefer dl.Close()\n \tif actualDir != \"\" && !hasPathPrefix(dir, actualDir) {\n-\t\treturn fmt.Errorf(\"internal error: downloading %v %v: dir=%q but actualDir=%q\", r.path, rev, dir, actualDir)\n+\t\treturn fmt.Errorf(\"internal error: downloading %v %v: dir=%q but actualDir=%q\", r.modPath, rev, dir, actualDir)\n \t}\n \tsubdir := strings.Trim(strings.TrimPrefix(dir, actualDir), \"/\")\n "}, {"sha": "7a419576ced03ce767259e03a374ce19931d615b", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -323,6 +323,15 @@ var codeRepoTests = []struct {\n \t\ttime:    time.Date(2017, 5, 31, 16, 3, 50, 0, time.UTC),\n \t\tgomod:   \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n \t},\n+\t{\n+\t\tpath:    \"nanomsg.org/go/mangos/v2\",\n+\t\trev:     \"v2.0.2\",\n+\t\tversion: \"v2.0.2\",\n+\t\tname:    \"63f66a65137b9a648ac9f7bf0160b4a4d17d7999\",\n+\t\tshort:   \"63f66a65137b\",\n+\t\ttime:    time.Date(2018, 12, 1, 15, 7, 40, 0, time.UTC),\n+\t\tgomod:   \"module nanomsg.org/go/mangos/v2\\n\\nrequire (\\n\\tgithub.com/Microsoft/go-winio v0.4.11\\n\\tgithub.com/droundy/goopt v0.0.0-20170604162106-0b8effe182da\\n\\tgithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e // indirect\\n\\tgithub.com/gorilla/websocket v1.4.0\\n\\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\\n\\tgithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect\\n\\tgithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c\\n\\tgolang.org/x/sys v0.0.0-20181128092732-4ed8d59d0b35 // indirect\\n)\\n\",\n+\t},\n }\n \n func TestCodeRepo(t *testing.T) {"}, {"sha": "70a305a3a10330674e285fe34c54d5a084c5d305", "filename": "libgo/go/internal/fmtsort/sort.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -167,7 +167,7 @@ func compare(aVal, bVal reflect.Value) int {\n \t\tif c, ok := nilCompare(aVal, bVal); ok {\n \t\t\treturn c\n \t\t}\n-\t\tc := compare(reflect.ValueOf(aType), reflect.ValueOf(bType))\n+\t\tc := compare(reflect.ValueOf(aVal.Elem().Type()), reflect.ValueOf(bVal.Elem().Type()))\n \t\tif c != 0 {\n \t\t\treturn c\n \t\t}"}, {"sha": "e060d4bf5157aa4b81d5c2b27dae01dfe5c1581b", "filename": "libgo/go/internal/fmtsort/sort_test.go", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffmtsort%2Fsort_test.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -126,10 +126,6 @@ var sortTests = []sortTest{\n \t\tmap[[2]int]string{{7, 2}: \"72\", {7, 1}: \"71\", {3, 4}: \"34\"},\n \t\t\"[3 4]:34 [7 1]:71 [7 2]:72\",\n \t},\n-\t{\n-\t\tmap[interface{}]string{7: \"7\", 4: \"4\", 3: \"3\", nil: \"nil\"},\n-\t\t\"<nil>:nil 3:3 4:4 7:7\",\n-\t},\n }\n \n func sprint(data interface{}) string {\n@@ -210,3 +206,41 @@ func TestOrder(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestInterface(t *testing.T) {\n+\t// A map containing multiple concrete types should be sorted by type,\n+\t// then value. However, the relative ordering of types is unspecified,\n+\t// so test this by checking the presence of sorted subgroups.\n+\tm := map[interface{}]string{\n+\t\t[2]int{1, 0}:             \"\",\n+\t\t[2]int{0, 1}:             \"\",\n+\t\ttrue:                     \"\",\n+\t\tfalse:                    \"\",\n+\t\t3.1:                      \"\",\n+\t\t2.1:                      \"\",\n+\t\t1.1:                      \"\",\n+\t\tmath.NaN():               \"\",\n+\t\t3:                        \"\",\n+\t\t2:                        \"\",\n+\t\t1:                        \"\",\n+\t\t\"c\":                      \"\",\n+\t\t\"b\":                      \"\",\n+\t\t\"a\":                      \"\",\n+\t\tstruct{ x, y int }{1, 0}: \"\",\n+\t\tstruct{ x, y int }{0, 1}: \"\",\n+\t}\n+\tgot := sprint(m)\n+\ttypeGroups := []string{\n+\t\t\"NaN: 1.1: 2.1: 3.1:\", // float64\n+\t\t\"false: true:\",        // bool\n+\t\t\"1: 2: 3:\",            // int\n+\t\t\"a: b: c:\",            // string\n+\t\t\"[0 1]: [1 0]:\",       // [2]int\n+\t\t\"{0 1}: {1 0}:\",       // struct{ x int; y int }\n+\t}\n+\tfor _, g := range typeGroups {\n+\t\tif !strings.Contains(got, g) {\n+\t\t\tt.Errorf(\"sorted map should contain %q\", g)\n+\t\t}\n+\t}\n+}"}, {"sha": "512a891017dc34225f3e39f05c5a8f8de75cb64e", "filename": "libgo/go/os/removeall_at.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fos%2Fremoveall_at.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fos%2Fremoveall_at.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fremoveall_at.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -92,7 +92,8 @@ func removeAllFrom(parent *File, path string) error {\n \t\t\tif IsNotExist(err) {\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\treturn err\n+\t\t\trecurseErr = err\n+\t\t\tbreak\n \t\t}\n \n \t\tnames, readErr := file.Readdirnames(request)"}, {"sha": "21371d8776a68ccf54f739d1fb654b7dd2a90034", "filename": "libgo/go/os/removeall_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fos%2Fremoveall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fos%2Fremoveall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fremoveall_test.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -372,3 +372,33 @@ func TestRemoveAllButReadOnly(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestRemoveUnreadableDir(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"nacl\", \"js\", \"windows\":\n+\t\tt.Skipf(\"skipping test on %s\", runtime.GOOS)\n+\t}\n+\n+\tif Getuid() == 0 {\n+\t\tt.Skip(\"skipping test when running as root\")\n+\t}\n+\n+\tt.Parallel()\n+\n+\ttempDir, err := ioutil.TempDir(\"\", \"TestRemoveAllButReadOnly-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer RemoveAll(tempDir)\n+\n+\ttarget := filepath.Join(tempDir, \"d0\", \"d1\", \"d2\")\n+\tif err := MkdirAll(target, 0755); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := Chmod(target, 0300); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := RemoveAll(filepath.Join(tempDir, \"d0\")); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "aba1717e7d5e0c7186a0e2a91adb011730d71f0e", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -96,19 +96,14 @@ func Clean(path string) string {\n \t\t}\n \t\treturn originalPath + \".\"\n \t}\n-\n-\tn := len(path)\n-\tif volLen > 2 && n == 1 && os.IsPathSeparator(path[0]) {\n-\t\t// UNC volume name with trailing slash.\n-\t\treturn FromSlash(originalPath[:volLen])\n-\t}\n \trooted := os.IsPathSeparator(path[0])\n \n \t// Invariants:\n \t//\treading from path; r is index of next byte to process.\n-\t//\twriting to out; w is index of next byte to write.\n-\t//\tdotdot is index in out where .. must stop, either because\n+\t//\twriting to buf; w is index of next byte to write.\n+\t//\tdotdot is index in buf where .. must stop, either because\n \t//\t\tit is the leading slash or it is a leading ../../.. prefix.\n+\tn := len(path)\n \tout := lazybuf{path: path, volAndPath: originalPath, volLen: volLen}\n \tr, dotdot := 0, 0\n \tif rooted {"}, {"sha": "22632a0b63a90db85eb250e0739c73d4f508ee5d", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 100, "deletions": 3, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -93,9 +93,6 @@ var wincleantests = []PathTest{\n \t{`//host/share/foo/../baz`, `\\\\host\\share\\baz`},\n \t{`\\\\a\\b\\..\\c`, `\\\\a\\b\\c`},\n \t{`\\\\a\\b`, `\\\\a\\b`},\n-\t{`\\\\a\\b\\`, `\\\\a\\b`},\n-\t{`\\\\folder\\share\\foo`, `\\\\folder\\share\\foo`},\n-\t{`\\\\folder\\share\\foo\\`, `\\\\folder\\share\\foo`},\n }\n \n func TestClean(t *testing.T) {\n@@ -1417,3 +1414,103 @@ func TestIssue29372(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Issue 30520 part 1.\n+func TestEvalSymlinksAboveRoot(t *testing.T) {\n+\ttestenv.MustHaveSymlink(t)\n+\n+\tt.Parallel()\n+\n+\ttmpDir, err := ioutil.TempDir(\"\", \"TestEvalSymlinksAboveRoot\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpDir)\n+\n+\tevalTmpDir, err := filepath.EvalSymlinks(tmpDir)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif err := os.Mkdir(filepath.Join(evalTmpDir, \"a\"), 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Symlink(filepath.Join(evalTmpDir, \"a\"), filepath.Join(evalTmpDir, \"b\")); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(evalTmpDir, \"a\", \"file\"), nil, 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Count the number of \"..\" elements to get to the root directory.\n+\tvol := filepath.VolumeName(evalTmpDir)\n+\tc := strings.Count(evalTmpDir[len(vol):], string(os.PathSeparator))\n+\tvar dd []string\n+\tfor i := 0; i < c+2; i++ {\n+\t\tdd = append(dd, \"..\")\n+\t}\n+\n+\twantSuffix := strings.Join([]string{\"a\", \"file\"}, string(os.PathSeparator))\n+\n+\t// Try different numbers of \"..\".\n+\tfor _, i := range []int{c, c + 1, c + 2} {\n+\t\tcheck := strings.Join([]string{evalTmpDir, strings.Join(dd[:i], string(os.PathSeparator)), evalTmpDir[len(vol)+1:], \"b\", \"file\"}, string(os.PathSeparator))\n+\t\tif resolved, err := filepath.EvalSymlinks(check); err != nil {\n+\t\t\tt.Errorf(\"EvalSymlinks(%q) failed: %v\", check, err)\n+\t\t} else if !strings.HasSuffix(resolved, wantSuffix) {\n+\t\t\tt.Errorf(\"EvalSymlinks(%q) = %q does not end with %q\", check, resolved, wantSuffix)\n+\t\t} else {\n+\t\t\tt.Logf(\"EvalSymlinks(%q) = %q\", check, resolved)\n+\t\t}\n+\t}\n+}\n+\n+// Issue 30520 part 2.\n+func TestEvalSymlinksAboveRootChdir(t *testing.T) {\n+\ttestenv.MustHaveSymlink(t)\n+\n+\ttmpDir, err := ioutil.TempDir(\"\", \"TestEvalSymlinksAboveRootChdir\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpDir)\n+\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Chdir(wd)\n+\n+\tif err := os.Chdir(tmpDir); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tsubdir := filepath.Join(\"a\", \"b\")\n+\tif err := os.MkdirAll(subdir, 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Symlink(subdir, \"c\"); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(subdir, \"file\"), nil, 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tsubdir = filepath.Join(\"d\", \"e\", \"f\")\n+\tif err := os.MkdirAll(subdir, 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Chdir(subdir); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcheck := filepath.Join(\"..\", \"..\", \"..\", \"c\", \"file\")\n+\twantSuffix := filepath.Join(\"a\", \"b\", \"file\")\n+\tif resolved, err := filepath.EvalSymlinks(check); err != nil {\n+\t\tt.Errorf(\"EvalSymlinks(%q) failed: %v\", check, err)\n+\t} else if !strings.HasSuffix(resolved, wantSuffix) {\n+\t\tt.Errorf(\"EvalSymlinks(%q) = %q does not end with %q\", check, resolved, wantSuffix)\n+\t} else {\n+\t\tt.Logf(\"EvalSymlinks(%q) = %q\", check, resolved)\n+\t}\n+}"}, {"sha": "de043c1677ba492a57659bfc1b94f3a4d3c8bdcd", "filename": "libgo/go/path/filepath/symlink.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -44,18 +44,26 @@ func walkSymlinks(path string) (string, error) {\n \t\t} else if path[start:end] == \"..\" {\n \t\t\t// Back up to previous component if possible.\n \t\t\t// Note that volLen includes any leading slash.\n+\n+\t\t\t// Set r to the index of the last slash in dest,\n+\t\t\t// after the volume.\n \t\t\tvar r int\n \t\t\tfor r = len(dest) - 1; r >= volLen; r-- {\n \t\t\t\tif os.IsPathSeparator(dest[r]) {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif r < volLen {\n+\t\t\tif r < volLen || dest[r+1:] == \"..\" {\n+\t\t\t\t// Either path has no slashes\n+\t\t\t\t// (it's empty or just \"C:\")\n+\t\t\t\t// or it ends in a \"..\" we had to keep.\n+\t\t\t\t// Either way, keep this \"..\".\n \t\t\t\tif len(dest) > volLen {\n \t\t\t\t\tdest += pathSeparator\n \t\t\t\t}\n \t\t\t\tdest += \"..\"\n \t\t\t} else {\n+\t\t\t\t// Discard everything since the last slash.\n \t\t\t\tdest = dest[:r]\n \t\t\t}\n \t\t\tcontinue"}, {"sha": "629cf2f04fbe6a36bca17c52c30478f93fc27f56", "filename": "libgo/go/runtime/testdata/testprog/gc.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fgc.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -18,6 +18,7 @@ func init() {\n \tregister(\"GCFairness2\", GCFairness2)\n \tregister(\"GCSys\", GCSys)\n \tregister(\"GCPhys\", GCPhys)\n+\tregister(\"DeferLiveness\", DeferLiveness)\n }\n \n func GCSys() {\n@@ -210,3 +211,25 @@ func GCPhys() {\n \tfmt.Println(\"OK\")\n \truntime.KeepAlive(saved)\n }\n+\n+// Test that defer closure is correctly scanned when the stack is scanned.\n+func DeferLiveness() {\n+\tvar x [10]int\n+\tescape(&x)\n+\tfn := func() {\n+\t\tif x[0] != 42 {\n+\t\t\tpanic(\"FAIL\")\n+\t\t}\n+\t}\n+\tdefer fn()\n+\n+\tx[0] = 42\n+\truntime.GC()\n+\truntime.GC()\n+\truntime.GC()\n+}\n+\n+//go:noinline\n+func escape(x interface{}) { sink2 = x; sink2 = nil }\n+\n+var sink2 interface{}"}, {"sha": "8d39e3478d7e839a07fbd2df97bad8096fe433b4", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -578,6 +578,13 @@ func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node,\n \t}\n \ttyp := receiver.Type()\n \treceiver, isNil := indirect(receiver)\n+\tif receiver.Kind() == reflect.Interface && isNil {\n+\t\t// Calling a method on a nil interface can't work. The\n+\t\t// MethodByName method call below would panic.\n+\t\ts.errorf(\"nil pointer evaluating %s.%s\", typ, fieldName)\n+\t\treturn zero\n+\t}\n+\n \t// Unless it's an interface, need to get to a value of type *T to guarantee\n \t// we see all methods of T and *T.\n \tptr := receiver"}, {"sha": "3cf9496db45c53a17ef9777052a193f08b9a9312", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -58,8 +58,10 @@ type T struct {\n \tEmpty3 interface{}\n \tEmpty4 interface{}\n \t// Non-empty interfaces.\n-\tNonEmptyInterface    I\n-\tNonEmptyInterfacePtS *I\n+\tNonEmptyInterface         I\n+\tNonEmptyInterfacePtS      *I\n+\tNonEmptyInterfaceNil      I\n+\tNonEmptyInterfaceTypedNil I\n \t// Stringer.\n \tStr fmt.Stringer\n \tErr error\n@@ -141,24 +143,25 @@ var tVal = &T{\n \t\t{\"one\": 1, \"two\": 2},\n \t\t{\"eleven\": 11, \"twelve\": 12},\n \t},\n-\tEmpty1:               3,\n-\tEmpty2:               \"empty2\",\n-\tEmpty3:               []int{7, 8},\n-\tEmpty4:               &U{\"UinEmpty\"},\n-\tNonEmptyInterface:    &T{X: \"x\"},\n-\tNonEmptyInterfacePtS: &siVal,\n-\tStr:                  bytes.NewBuffer([]byte(\"foozle\")),\n-\tErr:                  errors.New(\"erroozle\"),\n-\tPI:                   newInt(23),\n-\tPS:                   newString(\"a string\"),\n-\tPSI:                  newIntSlice(21, 22, 23),\n-\tBinaryFunc:           func(a, b string) string { return fmt.Sprintf(\"[%s=%s]\", a, b) },\n-\tVariadicFunc:         func(s ...string) string { return fmt.Sprint(\"<\", strings.Join(s, \"+\"), \">\") },\n-\tVariadicFuncInt:      func(a int, s ...string) string { return fmt.Sprint(a, \"=<\", strings.Join(s, \"+\"), \">\") },\n-\tNilOKFunc:            func(s *int) bool { return s == nil },\n-\tErrFunc:              func() (string, error) { return \"bla\", nil },\n-\tPanicFunc:            func() string { panic(\"test panic\") },\n-\tTmpl:                 Must(New(\"x\").Parse(\"test template\")), // \"x\" is the value of .X\n+\tEmpty1:                    3,\n+\tEmpty2:                    \"empty2\",\n+\tEmpty3:                    []int{7, 8},\n+\tEmpty4:                    &U{\"UinEmpty\"},\n+\tNonEmptyInterface:         &T{X: \"x\"},\n+\tNonEmptyInterfacePtS:      &siVal,\n+\tNonEmptyInterfaceTypedNil: (*T)(nil),\n+\tStr:                       bytes.NewBuffer([]byte(\"foozle\")),\n+\tErr:                       errors.New(\"erroozle\"),\n+\tPI:                        newInt(23),\n+\tPS:                        newString(\"a string\"),\n+\tPSI:                       newIntSlice(21, 22, 23),\n+\tBinaryFunc:                func(a, b string) string { return fmt.Sprintf(\"[%s=%s]\", a, b) },\n+\tVariadicFunc:              func(s ...string) string { return fmt.Sprint(\"<\", strings.Join(s, \"+\"), \">\") },\n+\tVariadicFuncInt:           func(a int, s ...string) string { return fmt.Sprint(a, \"=<\", strings.Join(s, \"+\"), \">\") },\n+\tNilOKFunc:                 func(s *int) bool { return s == nil },\n+\tErrFunc:                   func() (string, error) { return \"bla\", nil },\n+\tPanicFunc:                 func() string { panic(\"test panic\") },\n+\tTmpl:                      Must(New(\"x\").Parse(\"test template\")), // \"x\" is the value of .X\n }\n \n var tSliceOfNil = []*T{nil}\n@@ -365,6 +368,7 @@ var execTests = []execTest{\n \t{\".NilOKFunc not nil\", \"{{call .NilOKFunc .PI}}\", \"false\", tVal, true},\n \t{\".NilOKFunc nil\", \"{{call .NilOKFunc nil}}\", \"true\", tVal, true},\n \t{\"method on nil value from slice\", \"-{{range .}}{{.Method1 1234}}{{end}}-\", \"-1234-\", tSliceOfNil, true},\n+\t{\"method on typed nil interface value\", \"{{.NonEmptyInterfaceTypedNil.Method0}}\", \"M0\", tVal, true},\n \n \t// Function call builtin.\n \t{\".BinaryFunc\", \"{{call .BinaryFunc `1` `2`}}\", \"[1=2]\", tVal, true},\n@@ -1492,6 +1496,11 @@ func TestExecutePanicDuringCall(t *testing.T) {\n \t\t\t\"{{call .PanicFunc}}\", tVal,\n \t\t\t`template: t:1:2: executing \"t\" at <call .PanicFunc>: error calling call: test panic`,\n \t\t},\n+\t\t{\n+\t\t\t\"method call on nil interface\",\n+\t\t\t\"{{.NonEmptyInterfaceNil.Method0}}\", tVal,\n+\t\t\t`template: t:1:23: executing \"t\" at <.NonEmptyInterfaceNil.Method0>: nil pointer evaluating template.I.Method0`,\n+\t\t},\n \t}\n \tfor _, tc := range tests {\n \t\tb := new(bytes.Buffer)"}, {"sha": "4ea7d3177a5dd9984265538a438fce18c9c593bf", "filename": "libgo/misc/cgo/test/testdata/issue30527.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 30527: function call rewriting casts untyped\n+// constants to int because of \":=\" usage.\n+\n+package cgotest\n+\n+import \"cgotest/issue30527\"\n+\n+func issue30527G() {\n+\tissue30527.G(nil)\n+}"}, {"sha": "eb50147b39fcf84013ef31c910e503fa8a247e57", "filename": "libgo/misc/cgo/test/testdata/issue30527/a.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fa.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue30527\n+\n+import \"math\"\n+\n+/*\n+#include <inttypes.h>\n+\n+static void issue30527F(char **p, uint64_t mod, uint32_t unused) {}\n+*/\n+import \"C\"\n+\n+func G(p **C.char) {\n+\tC.issue30527F(p, math.MaxUint64, 1)\n+\tC.issue30527F(p, 1<<64-1, Z)\n+}"}, {"sha": "87e8255bd8d3a840cc06443a0044dd5f6884775d", "filename": "libgo/misc/cgo/test/testdata/issue30527/b.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b58d84bf4fd9c925a835ba39c1c552383bc61b/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue30527%2Fb.go?ref=a8b58d84bf4fd9c925a835ba39c1c552383bc61b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue30527\n+\n+const (\n+\tX = 1 << iota\n+\tY\n+\tZ\n+)"}]}