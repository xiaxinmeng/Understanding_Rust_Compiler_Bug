{"sha": "e11e816ec758b244fc01ce2e51a363a0967ade19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExZTgxNmVjNzU4YjI0NGZjMDFjZTJlNTFhMzYzYTA5NjdhZGUxOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-30T20:55:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-30T20:55:11Z"}, "message": "langhooks.c: Fix formatting.\n\n\t* langhooks.c: Fix formatting.\n\t* langhooks.h: Likewise.\n\t* lcm.c: Likewise.\n\t* libgcc2.c: Likewise.\n\t* lists.c: Likewise.\n\t* local-alloc.c: Likewise.\n\t* loop.c: Likewise.\n\t* loop.h: Likewise.\n\nFrom-SVN: r54070", "tree": {"sha": "5571e1edfbc286f33f9f02aa9fb4c0a973d14f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5571e1edfbc286f33f9f02aa9fb4c0a973d14f11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e11e816ec758b244fc01ce2e51a363a0967ade19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11e816ec758b244fc01ce2e51a363a0967ade19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11e816ec758b244fc01ce2e51a363a0967ade19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11e816ec758b244fc01ce2e51a363a0967ade19/comments", "author": null, "committer": null, "parents": [{"sha": "76ae32d753d65655f9adcc8b8b2198ad11758407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ae32d753d65655f9adcc8b8b2198ad11758407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ae32d753d65655f9adcc8b8b2198ad11758407"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "2da19626416c21249788ed51212e6cfe10a7f286", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -1,7 +1,19 @@\n-2002-05-30\tMarc Espie <espie@openbsd.org>\n-\t* config.gcc (sparc64-*-openbsd*):  New.\n-\t* config/sparc/openbsd1-64.h:  New.\n-\t* config/sparc/openbsd64.h:  New.\n+2002-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* langhooks.c: Fix formatting.\n+\t* langhooks.h: Likewise.\n+\t* lcm.c: Likewise.\n+\t* libgcc2.c: Likewise.\n+\t* lists.c: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* loop.h: Likewise.\n+\n+2002-05-30  Marc Espie <espie@openbsd.org>\n+\n+\t* config.gcc (sparc64-*-openbsd*): New.\n+\t* config/sparc/openbsd1-64.h: New.\n+\t* config/sparc/openbsd64.h: New.\n \n 2002-05-30  Jeff Law <law@redhat.com>\n "}, {"sha": "79eb7f4c2ec47276f9cfb962b88c61ca8933e108", "filename": "gcc/langhooks.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -158,9 +158,9 @@ lhd_set_decl_assembler_name (decl)\n      VAR_DECLs for variables with static storage duration need a real\n      DECL_ASSEMBLER_NAME.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (TREE_CODE (decl) == VAR_DECL \n-\t  && (TREE_STATIC (decl) \n-\t      || DECL_EXTERNAL (decl) \n+      || (TREE_CODE (decl) == VAR_DECL\n+\t  && (TREE_STATIC (decl)\n+\t      || DECL_EXTERNAL (decl)\n \t      || TREE_PUBLIC (decl))))\n     /* By default, assume the name to use in assembly code is the\n        same as that used in the source language.  (That's correct\n@@ -400,8 +400,8 @@ lhd_tree_inlining_convert_parm_for_inlining (parm, value, fndecl)\n   return value;\n }\n \n-/* lang_hooks.tree_dump.dump_tree:  Dump language-specific parts of tree \n-   nodes.  Returns non-zero if it does not want the usual dumping of the \n+/* lang_hooks.tree_dump.dump_tree:  Dump language-specific parts of tree\n+   nodes.  Returns non-zero if it does not want the usual dumping of the\n    second argument.  */\n \n int\n@@ -412,7 +412,7 @@ lhd_tree_dump_dump_tree (di, t)\n   return 0;\n }\n \n-/* lang_hooks.tree_dump.type_qual:  Determine type qualifiers in a \n+/* lang_hooks.tree_dump.type_qual:  Determine type qualifiers in a\n    language-specific way.  */\n \n int\n@@ -421,4 +421,3 @@ lhd_tree_dump_type_quals (t)\n {\n   return TYPE_QUALS (t);\n }\n-"}, {"sha": "ffa351794068caf0b1993bc35844492ca5e89d3a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -81,7 +81,7 @@ struct lang_hooks_for_functions\n \n struct lang_hooks_for_tree_dump\n {\n-  /* Dump language-specific parts of tree nodes.  Returns non-zero if it \n+  /* Dump language-specific parts of tree nodes.  Returns non-zero if it\n      does not want the usual dumping of the second argument.  */\n   int (*dump_tree) PARAMS ((void *, tree));\n \n@@ -96,7 +96,7 @@ struct lang_hooks_for_types\n   /* Return a new type (with the indicated CODE), doing whatever\n      language-specific processing is required.  */\n   tree (*make_type) PARAMS ((enum tree_code));\n-  \n+\n   /* Given MODE and UNSIGNEDP, return a suitable type-tree with that\n      mode.  */\n   tree (*type_for_mode) PARAMS ((enum machine_mode, int));\n@@ -344,7 +344,7 @@ struct lang_hooks\n   struct lang_hooks_for_functions function;\n \n   struct lang_hooks_for_tree_inlining tree_inlining;\n-  \n+\n   struct lang_hooks_for_tree_dump tree_dump;\n \n   struct lang_hooks_for_decls decls;"}, {"sha": "3d4ccc9bb58417a2db929c2b58930e26d6b28a7d", "filename": "gcc/lcm.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -147,7 +147,7 @@ compute_antinout_edge (antloc, transp, antin, antout)\n       qlen--;\n \n       if (qout >= qend)\n-        qout = worklist;\n+\tqout = worklist;\n \n       if (bb->aux == EXIT_BLOCK_PTR)\n \t/* Do not clear the aux field for blocks which are predecessors of\n@@ -174,7 +174,7 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \t      e->src->aux = e;\n \t      qlen++;\n \t      if (qin >= qend)\n-\t        qin = worklist;\n+\t\tqin = worklist;\n \t    }\n     }\n \n@@ -207,7 +207,7 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n       if (pred == ENTRY_BLOCK_PTR)\n \tsbitmap_copy (earliest[x], antin[succ->index]);\n       else\n-        {\n+\t{\n \t  if (succ == EXIT_BLOCK_PTR)\n \t    sbitmap_zero (earliest[x]);\n \t  else\n@@ -317,7 +317,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n       bb->aux = NULL;\n       qlen--;\n       if (qout >= qend)\n-        qout = worklist;\n+\tqout = worklist;\n \n       /* Compute the intersection of LATERIN for each incoming edge to B.  */\n       sbitmap_ones (laterin[bb->index]);\n@@ -529,7 +529,7 @@ compute_available (avloc, kill, avout, avin)\n       qlen--;\n \n       if (qout >= qend)\n-        qout = worklist;\n+\tqout = worklist;\n \n       /* If one of the predecessor blocks is the ENTRY block, then the\n \t intersection of avouts is the null set.  We can identify such blocks\n@@ -558,7 +558,7 @@ compute_available (avloc, kill, avout, avin)\n \t      qlen++;\n \n \t      if (qin >= qend)\n-\t        qin = worklist;\n+\t\tqin = worklist;\n \t    }\n     }\n \n@@ -930,7 +930,7 @@ add_seginfo (head, info)\n     {\n       ptr = head->seginfo;\n       while (ptr->next != NULL)\n-        ptr = ptr->next;\n+\tptr = ptr->next;\n       ptr->next = info;\n     }\n }\n@@ -1035,7 +1035,7 @@ optimize_mode_switching (file)\n \n \t/* Create the list of segments within each basic block.\n \t   If NORMAL_MODE is defined, allow for two extra\n-\t   blocks split from the entry and exit block. */\n+\t   blocks split from the entry and exit block.  */\n #ifdef NORMAL_MODE\n \tentry_exit_extra = 2;\n #endif"}, {"sha": "5895c9c9fb4503adf7c7e3670b7519d911be6905", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -151,9 +151,9 @@ __mulvsi3 (Wtype a, Wtype b)\n Wtype\n __negvsi2 (Wtype a)\n {\n-   Wtype w;\n+  Wtype w;\n \n-   w  = -a;\n+  w  = -a;\n \n   if (a >= 0 ? w > 0 : w < 0)\n     abort ();\n@@ -166,31 +166,31 @@ __negvsi2 (Wtype a)\n DWtype\n __negvdi2 (DWtype a)\n {\n-   DWtype w;\n+  DWtype w;\n \n-   w  = -a;\n+  w  = -a;\n \n   if (a >= 0 ? w > 0 : w < 0)\n     abort ();\n \n-   return w;\n+  return w;\n }\n #endif\n \f\n #ifdef L_absvsi2\n Wtype\n __absvsi2 (Wtype a)\n {\n-   Wtype w = a;\n+  Wtype w = a;\n \n-   if (a < 0)\n+  if (a < 0)\n #ifdef L_negvsi2\n-     w = __negvsi2 (a);\n+    w = __negvsi2 (a);\n #else\n-     w = -a;\n+    w = -a;\n \n-   if (w < 0)\n-     abort ();\n+  if (w < 0)\n+    abort ();\n #endif\n \n    return w;\n@@ -201,27 +201,27 @@ __absvsi2 (Wtype a)\n DWtype\n __absvdi2 (DWtype a)\n {\n-   DWtype w = a;\n+  DWtype w = a;\n \n-   if (a < 0)\n+  if (a < 0)\n #ifdef L_negvsi2\n-     w = __negvsi2 (a);\n+    w = __negvsi2 (a);\n #else\n-     w = -a;\n+    w = -a;\n \n-   if (w < 0)\n-     abort ();\n+  if (w < 0)\n+    abort ();\n #endif\n \n-   return w;\n+  return w;\n }\n #endif\n \f\n #ifdef L_mulvdi3\n DWtype\n __mulvdi3 (DWtype u, DWtype v)\n {\n-   DWtype w;\n+  DWtype w;\n \n   w = u * v;\n \n@@ -1383,21 +1383,21 @@ __bb_exit_func (void)\n \t  /* length of extra data in bytes.  */\n \t  __write_long ((4 + 8 + 8) + (4 + 8 + 8), da_file, 4);\n \n-\t  /* overall statistics. */\n+\t  /* overall statistics.  */\n \t  /* number of counters.  */\n-\t  __write_long (n_counters_p, da_file, 4);\t\n+\t  __write_long (n_counters_p, da_file, 4);\n \t  /* sum of counters.  */\n-\t  __write_gcov_type (sum_counters_p, da_file, 8);\t\n+\t  __write_gcov_type (sum_counters_p, da_file, 8);\n \t  /* maximal counter.  */\n-\t  __write_gcov_type (max_counter_p, da_file, 8);\t\n+\t  __write_gcov_type (max_counter_p, da_file, 8);\n \n-\t  /* per-object statistics. */\n+\t  /* per-object statistics.  */\n \t  /* number of counters.  */\n-\t  __write_long (ptr->ncounts, da_file, 4);\t\n+\t  __write_long (ptr->ncounts, da_file, 4);\n \t  /* sum of counters.  */\n-\t  __write_gcov_type (sum_counters_o, da_file, 8);\t\n+\t  __write_gcov_type (sum_counters_o, da_file, 8);\n \t  /* maximal counter.  */\n-\t  __write_gcov_type (max_counter_o, da_file, 8);\t\n+\t  __write_gcov_type (max_counter_o, da_file, 8);\n \n \t  /* write execution counts for each function.  */\n \n@@ -1460,7 +1460,7 @@ __bb_init_func (struct bb *blocks)\n \n   if (blocks->zero_word)\n     return;\n-  \n+\n   /* Initialize destructor and per-thread data.  */\n   if (!bb_head)\n     atexit (__bb_exit_func);\n@@ -1474,7 +1474,7 @@ __bb_init_func (struct bb *blocks)\n /* Called before fork or exec - write out profile information gathered so\n    far and reset it to zero.  This avoids duplication or loss of the\n    profile information gathered so far.  */\n-void \n+void\n __bb_fork_func (void)\n {\n   struct bb *ptr;"}, {"sha": "88abc545ba1951ea48539bef5f94a863392b34e1", "filename": "gcc/lists.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -62,7 +62,7 @@ free_list (listp, unused_listp)\n }\n \n /* This call is used in place of a gen_rtx_INSN_LIST. If there is a cached\n-   node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST \n+   node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST\n    is made.  */\n rtx\n alloc_INSN_LIST (val, next)\n@@ -85,7 +85,7 @@ alloc_INSN_LIST (val, next)\n }\n \n /* This call is used in place of a gen_rtx_EXPR_LIST. If there is a cached\n-   node available, we'll use it, otherwise a call to gen_rtx_EXPR_LIST \n+   node available, we'll use it, otherwise a call to gen_rtx_EXPR_LIST\n    is made.  */\n rtx\n alloc_EXPR_LIST (kind, val, next)\n@@ -118,14 +118,14 @@ zap_lists (dummy)\n   unused_insn_list = NULL;\n }\n \n-void \n+void\n init_EXPR_INSN_LIST_cache ()\n {\n   ggc_add_root (&unused_expr_list, 1, 1, zap_lists);\n }\n \n /* This function will free up an entire list of EXPR_LIST nodes.  */\n-void \n+void\n free_EXPR_LIST_list (listp)\n      rtx *listp;\n {\n@@ -135,7 +135,7 @@ free_EXPR_LIST_list (listp)\n }\n \n /* This function will free up an entire list of INSN_LIST nodes.  */\n-void \n+void\n free_INSN_LIST_list (listp)\n      rtx *listp;\n {\n@@ -145,7 +145,7 @@ free_INSN_LIST_list (listp)\n }\n \n /* This function will free up an individual EXPR_LIST node.  */\n-void \n+void\n free_EXPR_LIST_node (ptr)\n      rtx ptr;\n {\n@@ -154,7 +154,7 @@ free_EXPR_LIST_node (ptr)\n }\n \n /* This function will free up an individual INSN_LIST node.  */\n-void \n+void\n free_INSN_LIST_node (ptr)\n      rtx ptr;\n {"}, {"sha": "77607ba74be5b3e34f9e4ba1ff8cc56b00613693", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -1115,7 +1115,7 @@ update_equiv_regs ()\n \t\t      REG_N_REFS (regno) = 0;\n \t\t      REG_FREQ (regno) = 0;\n \t\t      delete_insn (equiv_insn);\n-\t\t      \n+\n \t\t      reg_equiv[regno].init_insns\n \t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n \t\t    }\n@@ -1159,16 +1159,16 @@ update_equiv_regs ()\n     {\n       int j;\n       if (clear_regnos > 8)\n-        {\n+\t{\n \t  FOR_EACH_BB (bb)\n \t    {\n \t      AND_COMPL_REG_SET (bb->global_live_at_start, &cleared_regs);\n \t      AND_COMPL_REG_SET (bb->global_live_at_end, &cleared_regs);\n \t    }\n \t}\n       else\n-        EXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j,\n-          {\n+\tEXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j,\n+\t  {\n \t    FOR_EACH_BB (bb)\n \t      {\n \t        CLEAR_REGNO_REG_SET (bb->global_live_at_start, j);"}, {"sha": "8581af2746ec564d5372cf1ebe6b171288116399", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -1073,7 +1073,7 @@ scan_loop (loop, flags)\n \t\t  unconditional jump, otherwise the code at the top of the\n \t\t  loop might never be executed.  Unconditional jumps are\n \t\t  followed by a barrier then the loop_end.  */\n-               && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop->top\n+\t       && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop->top\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop_end\n \t\t     && any_uncondjump_p (p)))\n \tmaybe_never = 1;\n@@ -3742,9 +3742,9 @@ remove_constant_addition (x)\n       /* In case our parameter was constant, remove extra zero from the\n \t expression.  */\n       if (XEXP (exp, 0) == const0_rtx)\n-        *x = XEXP (exp, 1);\n+\t*x = XEXP (exp, 1);\n       else if (XEXP (exp, 1) == const0_rtx)\n-        *x = XEXP (exp, 0);\n+\t*x = XEXP (exp, 0);\n     }\n \n   return addval;\n@@ -8647,9 +8647,9 @@ loop_insn_first_p (insn, reference)\n       /* Start with test for not first so that INSN == REFERENCE yields not\n          first.  */\n       if (q == insn || ! p)\n-        return 0;\n+\treturn 0;\n       if (p == reference || ! q)\n-        return 1;\n+\treturn 1;\n \n       /* Either of P or Q might be a NOTE.  Notes have the same LUID as the\n          previous insn, hence the <= comparison below does not work if\n@@ -9642,11 +9642,11 @@ loop_regs_scan (loop, extra_size)\n   if (LOOP_INFO (loop)->has_call)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)\n-          && rtx_varies_p (gen_rtx_REG (Pmode, i), /*for_alias=*/1))\n-        {\n-          regs->array[i].may_not_optimize = 1;\n-          regs->array[i].set_in_loop = 1;\n-        }\n+\t  && rtx_varies_p (gen_rtx_REG (Pmode, i), /*for_alias=*/1))\n+\t{\n+\t  regs->array[i].may_not_optimize = 1;\n+\t  regs->array[i].set_in_loop = 1;\n+\t}\n \n #ifdef AVOID_CCMODE_COPIES\n   /* Don't try to move insns which set CC registers if we should not\n@@ -10583,9 +10583,9 @@ loop_iv_class_dump (bl, file, verbose)\n       fprintf (file, \" Giv%d: insn %d, benefit %d, \",\n \t       i, INSN_UID (v->insn), v->benefit);\n       if (v->giv_type == DEST_ADDR)\n-\t  print_simple_rtl (file, v->mem);\n+\tprint_simple_rtl (file, v->mem);\n       else\n-\t  print_simple_rtl (file, single_set (v->insn));\n+\tprint_simple_rtl (file, single_set (v->insn));\n       fputc ('\\n', file);\n     }\n }\n@@ -10628,7 +10628,7 @@ loop_giv_dump (v, file, verbose)\n \n   if (v->giv_type == DEST_REG)\n     fprintf (file, \"Giv %d: insn %d\",\n-\t     REGNO (v->dest_reg),  INSN_UID (v->insn));\n+\t     REGNO (v->dest_reg), INSN_UID (v->insn));\n   else\n     fprintf (file, \"Dest address: insn %d\",\n \t     INSN_UID (v->insn));"}, {"sha": "4f4dc4160c16a002218b27a6c1a49670295bd793", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e816ec758b244fc01ce2e51a363a0967ade19/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=e11e816ec758b244fc01ce2e51a363a0967ade19", "patch": "@@ -205,7 +205,7 @@ enum iv_mode\n struct iv\n {\n   enum iv_mode type;\n-  union \n+  union\n   {\n     struct iv_class *class;\n     struct induction *info;\n@@ -394,7 +394,7 @@ int loop_invariant_p PARAMS ((const struct loop *, rtx));\n rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\n void loop_iv_add_mult_hoist PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n void loop_iv_add_mult_sink PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n-void loop_iv_add_mult_emit_before PARAMS ((const struct loop *, rtx, \n+void loop_iv_add_mult_emit_before PARAMS ((const struct loop *, rtx,\n \t\t\t\t\t   rtx, rtx, rtx,\n \t\t\t\t\t   basic_block, rtx));\n rtx express_from PARAMS ((struct induction *, struct induction *));\n@@ -414,7 +414,7 @@ int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n int loop_insn_first_p PARAMS ((rtx, rtx));\n typedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n-rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block, \n+rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block,\n \t\t\t\t  rtx, rtx));\n rtx loop_insn_sink PARAMS((const struct loop *, rtx));\n rtx loop_insn_hoist PARAMS((const struct loop *, rtx));"}]}