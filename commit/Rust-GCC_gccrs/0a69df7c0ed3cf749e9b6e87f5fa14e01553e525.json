{"sha": "0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE2OWRmN2MwZWQzY2Y3NDllOWI2ZTg3ZjVmYTE0ZTAxNTUzZTUyNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-08-07T09:29:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-08-07T09:29:01Z"}, "message": "[multiple changes]\n\n2009-08-07  Thomas Quinot  <quinot@adacore.com>\n\n\t* targparm.adb: Minor reformatting\n\t* sem.adb: Minor reformatting\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): Add comment.\n\n2009-08-07  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-conf.adb: Remove duplicate directory separator in the output when\n\tan object directory does not exist.\n\n2009-08-07  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Minor reformatting\n\n2009-08-07  Vincent Celier  <celier@adacore.com>\n\n\t* mlib-prj.adb (Build_Library): Fixed bug in name of ALI file (wrong\n\tlength used).\n\n2009-08-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): In Ravenscar mode,\n\tdetect non-static private components that will violate restriction\n\tNo_Implicit_Heap_Allocation.\n\n2009-08-07  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_ugn.texi: Edited Rule Exemption section of gnatcheck chapter.\n\nFrom-SVN: r150562", "tree": {"sha": "24deb0f98e9cee082de4b9e2490c31750e2ef641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24deb0f98e9cee082de4b9e2490c31750e2ef641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/comments", "author": null, "committer": null, "parents": [{"sha": "b84b6ee6d9d34ac0ecac939bb59567bf77a34d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84b6ee6d9d34ac0ecac939bb59567bf77a34d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b84b6ee6d9d34ac0ecac939bb59567bf77a34d3e"}], "stats": {"total": 245, "additions": 170, "deletions": 75}, "files": [{"sha": "eb2e98be9389e5bdd00cc4c6c7602981ae443ea6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -1,3 +1,33 @@\n+2009-08-07  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* targparm.adb: Minor reformatting\n+\t* sem.adb: Minor reformatting\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): Add comment.\n+\n+2009-08-07  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-conf.adb: Remove duplicate directory separator in the output when\n+\tan object directory does not exist.\n+\n+2009-08-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Minor reformatting\n+\n+2009-08-07  Vincent Celier  <celier@adacore.com>\n+\n+\t* mlib-prj.adb (Build_Library): Fixed bug in name of ALI file (wrong\n+\tlength used).\n+\n+2009-08-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): In Ravenscar mode,\n+\tdetect non-static private components that will violate restriction\n+\tNo_Implicit_Heap_Allocation.\n+\n+2009-08-07  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_ugn.texi: Edited Rule Exemption section of gnatcheck chapter.\n+\n 2009-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (end_subprog_body): Tweak comment."}, {"sha": "acf96b057d8e51439d711f260b8201ecce4728c2", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -4039,8 +4039,10 @@ package body Exp_Ch4 is\n       --  and replace the conditional expression by a reference to Cnn\n \n       --  ??? Note: this expansion is wrong for limited types, since it does\n-      --  a copy of a limited value. The proper fix would be to do the\n-      --  following expansion:\n+      --  a copy of a limited value. Similarly it's wrong for unconstrained or\n+      --  class-wide types since in neither case can we have an uninitialized\n+      --  object declaration The proper fix would be to do the following\n+      --  expansion:\n \n       --      Cnn : access typ;\n       --      if cond then"}, {"sha": "526a2dd552c9116921a35724c2a42a5b8490370f", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -53,6 +53,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch11; use Sem_Ch11;\n with Sem_Elab; use Sem_Elab;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -7522,7 +7523,7 @@ package body Exp_Ch9 is\n       Loc      : constant Source_Ptr := Sloc (N);\n       Prot_Typ : constant Entity_Id  := Defining_Identifier (N);\n \n-      Pdef     : constant Node_Id    := Protected_Definition (N);\n+      Pdef : constant Node_Id := Protected_Definition (N);\n       --  This contains two lists; one for visible and one for private decls\n \n       Rec_Decl     : Node_Id;\n@@ -7547,6 +7548,13 @@ package body Exp_Ch9 is\n       --  to the internal body, for possible inlining later on. The source\n       --  operation is invisible to the back-end and is never actually called.\n \n+      function Static_Component_Size (Comp : Entity_Id) return Boolean;\n+      --  When compiling under the Ravenscar profile, private components must\n+      --  have a static size, or else a protected object  will require heap\n+      --  allocation, violating the corresponding restriction. It is preferable\n+      --  to make this check here, because it provides a better error message\n+      --  than the back-end, which refers to the object as a whole.\n+\n       procedure Register_Handler;\n       --  For a protected operation that is an interrupt handler, add the\n       --  freeze action that will register it as such.\n@@ -7563,6 +7571,40 @@ package body Exp_Ch9 is\n          end if;\n       end Check_Inlining;\n \n+      ---------------------------------\n+      -- Check_Static_Component_Size --\n+      ---------------------------------\n+\n+      function Static_Component_Size (Comp : Entity_Id) return Boolean is\n+         Typ : constant Entity_Id := Etype (Comp);\n+         C   : Entity_Id;\n+\n+      begin\n+         if Is_Scalar_Type (Typ) then\n+            return True;\n+\n+         elsif Is_Array_Type (Typ) then\n+            return Compile_Time_Known_Bounds (Typ);\n+\n+         elsif Is_Record_Type (Typ) then\n+            C := First_Component (Typ);\n+            while Present (C) loop\n+               if not Static_Component_Size (C) then\n+                  return False;\n+               end if;\n+\n+               Next_Component (C);\n+            end loop;\n+\n+            return True;\n+\n+         --  Any other types will be checked by the back-end\n+\n+         else\n+            return True;\n+         end if;\n+      end Static_Component_Size;\n+\n       ----------------------\n       -- Register_Handler --\n       ----------------------\n@@ -7754,6 +7796,24 @@ package body Exp_Ch9 is\n          while Present (Priv) loop\n \n             if Nkind (Priv) = N_Component_Declaration then\n+               if not Static_Component_Size (Defining_Identifier (Priv)) then\n+\n+                  --  When compiling for a restricted profile, the private\n+                  --  components must have a static size. If not, this is an\n+                  --  error for a single protected declaration, and rates a\n+                  --  warning on a protected type declaration.\n+\n+                  if not Comes_From_Source (Prot_Typ) then\n+                     Check_Restriction (No_Implicit_Heap_Allocations, Priv);\n+\n+                  elsif Restriction_Active (No_Implicit_Heap_Allocations) then\n+                     Error_Msg_N (\"component has non-static size?\", Priv);\n+                     Error_Msg_NE\n+                       (\"\\creation of protected object of type& will violate\"\n+                        & \" restriction No_Implicit_Heap_Allocations?\",\n+                        Priv, Prot_Typ);\n+                  end if;\n+               end if;\n \n                --  The component definition consists of a subtype indication,\n                --  or (in Ada 2005) an access definition. Make a copy of the"}, {"sha": "fcf3878f61df27d4321c9a1720ec4db198c03c0f", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -1320,15 +1320,15 @@ package body Exp_Util is\n \n          Rewrite (Subtype_Indic, New_Reference_To (T, Loc));\n \n-      --  nothing needs to be done for private types with unknown discriminants\n+      --  Nothing needs to be done for private types with unknown discriminants\n       --  if the underlying type is not an unconstrained composite type or it\n       --  is an unchecked union.\n \n       elsif Is_Private_Type (Unc_Type)\n         and then Has_Unknown_Discriminants (Unc_Type)\n         and then (not Is_Composite_Type (Underlying_Type (Unc_Type))\n-                  or else Is_Constrained (Underlying_Type (Unc_Type))\n-                  or else Is_Unchecked_Union (Underlying_Type (Unc_Type)))\n+                   or else Is_Constrained (Underlying_Type (Unc_Type))\n+                   or else Is_Unchecked_Union (Underlying_Type (Unc_Type)))\n       then\n          null;\n "}, {"sha": "bffbf8be6891e43baa326f948252beb748ecc8f2", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -20953,19 +20953,24 @@ the @option{-U} option followed by the name of the main unit:\n @cindex Rule exemption (for @command{gnatcheck})\n \n @noindent\n-@command{gnatcheck} can be used to inforce a coding standard. It may be\n-appropriate, in some circumstances, to accept violations of the coding\n-standard. In such a case, it is a good idea to justify the violation within\n-the sources themselves. It makes it possible to maintain the justification\n-for such violations along with the sources containing them.\n-@command{gnatcheck} supports such justified violations with the notion of\n-``exemption'' covering a specific source code section. Usually,\n-@command{gnatcheck} issues rule violation messages both on @file{stderr}\n-and in a report file. Exempted violations are not reported at all on\n-@file{stderr} so that users using @command{gnatcheck} in interactive mode\n+One of the most useful applications of @command{gnatcheck} is to\n+automate the enforcement of project-specific coding standards,\n+for example in safety-critical systems where particular features\n+must be restricted in order to simplify the certification effort.\n+However, it may sometimes be appropriate to violate a coding standard rule,\n+and in such cases the rationale for the violation should be provided\n+in the source program itself so that the individuals\n+reviewing or maintaining the program can immediately understand the intent.\n+\n+The @command{gnatcheck} tool supports this practice with the notion of\n+a ``rule exemption'' covering a specific source code section. Normally\n+rule violation messages are issued both on @file{stderr}\n+and in a report file. In contrast, exempted violations are not listed on\n+@file{stderr}; thus users invoking @command{gnatcheck} interactively\n (e.g. in its GPS interface) do not need to pay attention to known and\n-justified violations. The @command{gnatcheck} report includes exempted\n-violations in a special section along with their justification.\n+justified violations. However, exempted violations along with their\n+justification are documented in a special section of the report file that\n+@command{gnatcheck} generates.\n \n @menu\n * Using pragma Annotate to Control Rule Exemption::\n@@ -20977,33 +20982,36 @@ violations in a special section along with their justification.\n @cindex Using pragma Annotate to control rule exemption\n \n @noindent\n-Rule exemption is controlled by pragma @code{Annotate} when its first parameter is\n-``gnatcheck''. Here is the syntax of @command{gnatcheck} annotations:\n+Rule exemption is controlled by pragma @code{Annotate} when its first\n+argument is ``gnatcheck''. The syntax of @command{gnatcheck}'s\n+exemption control annotations is as follows:\n \n @smallexample @c ada\n-pragma Annotate (gnatcheck, exemption_control, Rule_Name, [justification]);\n-\n-exemption_control ::= \"Exempt_On\" | \"Exempt_Off\"\n+@group\n+pragma Annotate (gnatcheck, @i{exemption_control}, @i{Rule_Name}, [@i{justification}]);\n \n-Rule_Name         ::= string_literal\n+@i{exemption_control} ::= \"Exempt_On\" | \"Exempt_Off\"\n \n-justification     ::= string_literal\n+@i{Rule_Name}         ::= string_literal\n \n+@i{justification}     ::= string_literal\n+@end group\n @end smallexample\n \n @noindent\n-When a @command{gnatcheck} annotatation has more then four parameters,\n-@command{gnatcheck} issues a warning and ignore additional parameters.\n-If the additional parameters do not follow the syntax above,\n+When a @command{gnatcheck} annotatation has more then four arguments,\n+@command{gnatcheck} issues a warning and ignores the additional arguments.\n+If the additional arguments do not follow the syntax above,\n @command{gnatcheck} emits a warning and ignores the annotation.\n \n-@code{Rule_Name} should be the name of some existing @command{gnatcheck} rule.\n-If this is not the case, the warning message is generated and the pragma is\n+The @i{@code{Rule_Name}} argument should be the name of some existing\n+@command{gnatcheck} rule.\n+Otherwise a warning message is generated and the pragma is\n ignored. If @code{Rule_Name} denotes a rule that is not activated by the given\n-@command{gnatcheck} call, the pragma is ignored silently.\n+@command{gnatcheck} call, the pragma is ignored and no warning is issued.\n \n-A source code section where an exemption is active for a given rule starts with\n-an extempt_on annotation and terminates with an exempt_off one:\n+A source code section where an exemption is active for a given rule is\n+delimited by an @code{exempt_on} and @code{exempt_off} annotation pair:\n \n @smallexample @c ada\n pragma Annotate (gnatcheck, \"Exempt_On\", Rule_Name, \"justification\");\n@@ -21019,34 +21027,32 @@ pragma Annotate (gnatcheck, \"Exempt_Off\", Rule_Name);\n @itemize @bullet\n \n @item\n-an ``Exempt_Off'' annotation can only appear after a corresponding\n-``Exempt_On'' annotation in order to create a properly formed exempted source\n-code section;\n+An ``Exempt_Off'' annotation can only appear after a corresponding\n+``Exempt_On'' annotation.\n \n @item\n-exempted source code sections are only based on the source location of the\n-annotations. Any source construct having a source location in between the two\n-annotations is part of the exempted source code section;\n+Exempted source code sections are only based on the source location of the\n+annotations. Any source construct between the two\n+annotations is part of the exempted source code section.\n \n @item\n-exempted source code sections for different rules are independent. They can\n-be nested or intersect with one another without limitation. It is not allowed\n-to create nested or intersecting source code sections for the same rule;\n+Exempted source code sections for different rules are independent. They can\n+be nested or intersect with one another without limitation.\n+Creating nested or intersecting source code sections for the same rule is\n+not allowed.\n \n @item\n-malformed exempted source code sections are reported by a warning and\n-the corresponding rule exemption is ignored;\n+Malformed exempted source code sections are reported by a warning, and\n+the corresponding rule exemptions are ignored.\n \n @item\n-when an exempted source code section does not contain at least one violation\n-of the exempted rule, a warning is emitted on @file{stderr}. This allow proper\n-maintenance of exempted source code sections;\n+When an exempted source code section does not contain at least one violation\n+of the exempted rule, a warning is emitted on @file{stderr}.\n \n @item\n-if an exempted source code section reaches the end of the compilation unit\n-source and there is no @code{Annotate} pragma closing this section, then the\n-exemption for the given rule is turned off and a warning is issued.\n-\n+If an ``Exempt_On'' annotation pragma does not have a matching\n+``Exempt_Off'' annotation pragma in the same compilation unit, then the\n+exemption for the given rule is ignored and a warning is issued.\n @end itemize\n \n "}, {"sha": "6f9b37128bad89673b296d5cb02df845e61b0fbd", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -1812,13 +1812,13 @@ package body MLib.Prj is\n                      Canonical_Case_File_Name (Name (1 .. Last));\n                      Delete := False;\n \n-                     if (The_Build_Mode = Static and then\n-                           Name (1 .. Last) =  Archive_Name)\n+                     if (The_Build_Mode = Static\n+                          and then Name (1 .. Last) =  Archive_Name)\n                        or else\n-                         ((The_Build_Mode = Dynamic or else\n-                             The_Build_Mode = Relocatable)\n-                          and then\n-                            Name (1 .. Last) = DLL_Name)\n+                         ((The_Build_Mode = Dynamic\n+                            or else\n+                           The_Build_Mode = Relocatable)\n+                          and then Name (1 .. Last) = DLL_Name)\n                      then\n                         Delete := True;\n \n@@ -1835,17 +1835,19 @@ package body MLib.Prj is\n                            while Unit /= No_Unit_Index loop\n                               if Unit.File_Names (Impl) /= null\n                                 and then Unit.File_Names (Impl).Project /=\n-                                No_Project\n+                                                                 No_Project\n                               then\n                                  if Ultimate_Extending_Project_Of\n-                                   (Unit.File_Names (Impl).Project) =\n-                                    For_Project\n+                                      (Unit.File_Names (Impl).Project) =\n+                                                                 For_Project\n                                  then\n                                     Get_Name_String\n                                       (Unit.File_Names (Impl).File);\n-                                    Name_Len := Name_Len -\n-                                      File_Extension\n-                                        (Name (1 .. Name_Len))'Length;\n+                                    Name_Len :=\n+                                      Name_Len -\n+                                        File_Extension\n+                                          (Name (1 .. Name_Len))'Length;\n+\n                                     if Name_Buffer (1 .. Name_Len) =\n                                       Name (1 .. Last - 4)\n                                     then\n@@ -1856,18 +1858,16 @@ package body MLib.Prj is\n \n                               elsif Unit.File_Names (Spec) /= null\n                                 and then Ultimate_Extending_Project_Of\n-                                  (Unit.File_Names (Spec).Project) =\n-                                   For_Project\n+                                           (Unit.File_Names (Spec).Project) =\n+                                                                   For_Project\n                               then\n-                                 Get_Name_String\n-                                   (Unit.File_Names (Spec).File);\n+                                 Get_Name_String (Unit.File_Names (Spec).File);\n                                  Name_Len :=\n                                    Name_Len -\n-                                   File_Extension\n-                                     (Name (1 .. Name_Len))'Length;\n+                                     File_Extension (Name (1 .. Last))'Length;\n \n                                  if Name_Buffer (1 .. Name_Len) =\n-                                   Name (1 .. Last - 4)\n+                                      Name (1 .. Last - 4)\n                                  then\n                                     Delete := True;\n                                     exit;"}, {"sha": "9258cd4c5de93fa785372c95f876321bc9b4ad8a", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -675,7 +675,6 @@ package body Prj.Conf is\n                Name_Len := 0;\n                Add_Str_To_Name_Buffer\n                  (Get_Name_String (Project.Directory.Name));\n-               Add_Char_To_Name_Buffer (Directory_Separator);\n                Add_Str_To_Name_Buffer (Get_Name_String (Obj_Dir.Value));\n             end if;\n          end if;"}, {"sha": "071d38fdb45f140fddcfaf091f9cbf7932ecc8b5", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -1978,9 +1978,7 @@ package body Sem is\n                   --  See if it belongs to current unit, and if so, include its\n                   --  with_clauses. Do not process main unit prematurely.\n \n-                  if Pnode = CU\n-                    and then CU /= Cunit (Main_Unit)\n-                  then\n+                  if Pnode = CU and then CU /= Cunit (Main_Unit) then\n                      Walk_Immediate (Cunit (S), Include_Limited);\n                   end if;\n                end;"}, {"sha": "b8cc154c88c1187df555e2a9d4c9cc27d05c859f", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a69df7c0ed3cf749e9b6e87f5fa14e01553e525/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=0a69df7c0ed3cf749e9b6e87f5fa14e01553e525", "patch": "@@ -510,7 +510,7 @@ package body Targparm is\n \n             goto Line_Loop_Continue;\n \n-         --  Next See if we have a configuration parameter\n+         --  Next see if we have a configuration parameter\n \n          else\n             Config_Param_Loop : for K in Targparm_Tags loop"}]}