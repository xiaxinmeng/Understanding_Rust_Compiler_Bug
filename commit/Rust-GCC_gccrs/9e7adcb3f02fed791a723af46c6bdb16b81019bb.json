{"sha": "9e7adcb3f02fed791a723af46c6bdb16b81019bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3YWRjYjNmMDJmZWQ3OTFhNzIzYWY0NmM2YmRiMTZiODEwMTliYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-13T08:57:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-13T08:57:29Z"}, "message": "i386.c (ix86_fp_comparison_arithmetics_cost, [...]): New functions.\n\n\n\t* i386.c (ix86_fp_comparison_arithmetics_cost,\n\tix86_fp_comparison_fcomi_cost, ix86_fp_comparison_sahf_cost,\n\tix86_fp_comparison_cost): New functions.\n\t(ix86_expand_fp_compare): Use the costs to choose best bethod; add\n\ttwo new parameters SECOND_TEST and BYPASS_TEST; allow generating\n\ttwo-branch sequences; make static.\n\t(ix86_use_fcomi_compare): Do decision according to the costs.\n\t(split_fp_branch): New.\n\t* i386.md (compare-and-branch patterns): Use split_fp_branch.\n\t* i386-protos.h (ix86_expand_fp_compare): Remove\n\t(ix86_split_fp_branch): Declare.\n\n\t* i386.h (PREDICATE_CODES): Update codes from fcmov_comparison_operand\n\tand ix86_comparison_operator.\n\n\t* i386.c (ix86_prepare_fp_compare_args): Try to rearange the comparison\n\tto make it cheaper.\n\n\t* i386.c (put_condition_code): Output properly the unordered/ordered\n\tcompares in fp case.\n\t(ix86_expand_fp_movcc): Use ix86_expand_compare infrastructure.\n\n\t* tm.texi (REVERSE_CONDITION): Document.\n\t* i386.c (ix86_fp_compare_mode): Simplify; return always CCFPmode\n\tin -ffast-math mode.\n\t* i386.h (REVERSE_CONDITION, REVERSIBLE_CC_MODE): New macro.\n\nFrom-SVN: r38979", "tree": {"sha": "c70ae326ad613b614bd7ef8b4da3a8ae9e7fabd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c70ae326ad613b614bd7ef8b4da3a8ae9e7fabd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e7adcb3f02fed791a723af46c6bdb16b81019bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7adcb3f02fed791a723af46c6bdb16b81019bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7adcb3f02fed791a723af46c6bdb16b81019bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7adcb3f02fed791a723af46c6bdb16b81019bb/comments", "author": null, "committer": null, "parents": [{"sha": "9323f9693a7eaa07669840009e0dc65cc625e9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9323f9693a7eaa07669840009e0dc65cc625e9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9323f9693a7eaa07669840009e0dc65cc625e9a2"}], "stats": {"total": 353, "additions": 274, "deletions": 79}, "files": [{"sha": "33025c281679e3724e484a2229613caa659064e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -1,3 +1,32 @@\n+Sat Jan 13 09:53:32 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_fp_comparison_arithmetics_cost,\n+\tix86_fp_comparison_fcomi_cost, ix86_fp_comparison_sahf_cost,\n+\tix86_fp_comparison_cost): New functions.\n+\t(ix86_expand_fp_compare): Use the costs to choose best bethod; add\n+\ttwo new parameters SECOND_TEST and BYPASS_TEST; allow generating\n+\ttwo-branch sequences; make static.\n+\t(ix86_use_fcomi_compare): Do decision according to the costs.\n+\t(split_fp_branch): New.\n+\t* i386.md (compare-and-branch patterns): Use split_fp_branch.\n+\t* i386-protos.h (ix86_expand_fp_compare): Remove\n+\t(ix86_split_fp_branch): Declare.\n+\n+\t* i386.h (PREDICATE_CODES): Update codes from fcmov_comparison_operand\n+\tand ix86_comparison_operator.\n+\n+\t* i386.c (ix86_prepare_fp_compare_args): Try to rearange the comparison\n+\tto make it cheaper.\n+\n+\t* i386.c (put_condition_code): Output properly the unordered/ordered\n+\tcompares in fp case.\n+\t(ix86_expand_fp_movcc): Use ix86_expand_compare infrastructure.\n+\n+\t* tm.texi (REVERSE_CONDITION): Document.\n+\t* i386.c (ix86_fp_compare_mode): Simplify; return always CCFPmode\n+\tin -ffast-math mode.\n+\t* i386.h (REVERSE_CONDITION, REVERSIBLE_CC_MODE): New macro.\n+\n 2001-01-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (sh_expand_epilogue): Use PR explicitly."}, {"sha": "3bf2ea85a4634cc01f28afa06a57034a458178d0", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -101,7 +101,6 @@ extern void ix86_expand_unary_operator PARAMS ((enum rtx_code, enum machine_mode\n extern int ix86_unary_operator_ok PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t rtx[]));\n extern int ix86_match_ccmode PARAMS ((rtx, enum machine_mode));\n-extern rtx ix86_expand_fp_compare PARAMS ((enum rtx_code, rtx, rtx, rtx));\n extern rtx ix86_expand_compare PARAMS ((enum rtx_code));\n extern int ix86_use_fcomi_compare PARAMS ((enum rtx_code));\n extern void ix86_expand_branch PARAMS ((enum rtx_code, rtx));\n@@ -129,6 +128,7 @@ extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n+extern void ix86_split_fp_branch PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));\n \n #ifdef TREE_CODE\n extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));"}, {"sha": "da26760d9be021803d89b20114a40af2d0642cb1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 205, "deletions": 68, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -439,6 +439,12 @@ static void ix86_fp_comparison_codes PARAMS ((enum rtx_code code,\n \t\t\t\t\t      enum rtx_code *,\n \t\t\t\t\t      enum rtx_code *,\n \t\t\t\t\t      enum rtx_code *));\n+static rtx ix86_expand_fp_compare PARAMS ((enum rtx_code, rtx, rtx, rtx,\n+\t\t\t\t\t  rtx *, rtx *));\n+static int ix86_fp_comparison_arithmetics_cost PARAMS ((enum rtx_code code));\n+static int ix86_fp_comparison_fcomi_cost PARAMS ((enum rtx_code code));\n+static int ix86_fp_comparison_sahf_cost PARAMS ((enum rtx_code code));\n+static int ix86_fp_comparison_cost PARAMS ((enum rtx_code code));\n \f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -3169,10 +3175,10 @@ put_condition_code (code, mode, reverse, fp, file)\n       suffix = \"be\";\n       break;\n     case UNORDERED:\n-      suffix = \"p\";\n+      suffix = fp ? \"u\" : \"p\";\n       break;\n     case ORDERED:\n-      suffix = \"np\";\n+      suffix = fp ? \"nu\" : \"np\";\n       break;\n     default:\n       abort ();\n@@ -4647,35 +4653,12 @@ enum machine_mode\n ix86_fp_compare_mode (code)\n      enum rtx_code code;\n {\n-  int unordered;\n-\n-  switch (code)\n-    {\n-    case NE: case EQ:\n-      /* When not doing IEEE compliant compares, fault on NaNs.  */\n-      unordered = (TARGET_IEEE_FP != 0);\n-      break;\n-\n-    case LT: case LE: case GT: case GE:\n-      unordered = 0;\n-      break;\n-\n-    case UNORDERED: case ORDERED:\n-    case UNEQ: case UNGE: case UNGT: case UNLE: case UNLT: case LTGT:\n-      unordered = 1;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  /* ??? If we knew whether invalid-operand exceptions were masked,\n-     we could rely on fcom to raise an exception and take care of\n-     NaNs.  But we don't.  We could know this from c99 math pragmas.  */\n-  if (TARGET_IEEE_FP)\n-    unordered = 1;\n-\n-  return unordered ? CCFPUmode : CCFPmode;\n+  /* ??? In order to make all comparisons reversible, we do all comparisons\n+     non-trapping when compiling for IEEE.  Once gcc is able to distinguish\n+     all forms trapping and nontrapping comparisons, we can make inequality\n+     comparisons trapping again, since it results in better code when using\n+     FCOM based compares.  */\n+  return TARGET_IEEE_FP ? CCFPUmode : CCFPmode;\n }\n \n enum machine_mode\n@@ -4725,13 +4708,12 @@ ix86_cc_mode (code, op0, op1)\n \n int\n ix86_use_fcomi_compare (code)\n-     enum rtx_code code;\n+     enum rtx_code code ATTRIBUTE_UNUSED;\n {\n-  return (TARGET_CMOVE\n-\t  && (code == ORDERED || code == UNORDERED\n-\t      /* All other unordered compares require checking\n-\t\t multiple sets of bits.  */\n-\t      || ix86_fp_compare_mode (code) == CCFPmode));\n+  enum rtx_code swapped_code = swap_condition (code);\n+  return ((ix86_fp_comparison_cost (code) == ix86_fp_comparison_fcomi_cost (code))\n+\t  || (ix86_fp_comparison_cost (swapped_code)\n+\t      == ix86_fp_comparison_fcomi_cost (swapped_code)));\n }\n \n /* Swap, force into registers, or otherwise massage the two operands\n@@ -4787,6 +4769,18 @@ ix86_prepare_fp_compare_args (code, pop0, pop1)\n \t}\n     }\n \n+  /* Try to rearrange the comparison to make it cheaper.  */\n+  if (ix86_fp_comparison_cost (code)\n+      > ix86_fp_comparison_cost (swap_condition (code))\n+      && (GET_CODE (op0) == REG || !reload_completed))\n+    {\n+      rtx tmp;\n+      tmp = op0, op0 = op1, op1 = tmp;\n+      code = swap_condition (code);\n+      if (GET_CODE (op0) != REG)\n+\top0 = force_reg (op_mode, op0);\n+    }\n+\n   *pop0 = op0;\n   *pop1 = op1;\n   return code;\n@@ -4892,29 +4886,123 @@ ix86_fp_comparison_codes (code, bypass_code, first_code, second_code)\n     }\n }\n \n+/* Return cost of comparison done fcom + arithmetics operations on AX.\n+   All following functions do use number of instructions as an cost metrics.\n+   In future this should be tweaked to compute bytes for optimize_size and\n+   take into account performance of various instructions on various CPUs.  */\n+static int\n+ix86_fp_comparison_arithmetics_cost (code)\n+     enum rtx_code code;\n+{\n+  if (!TARGET_IEEE_FP)\n+    return 4;\n+  /* The cost of code output by ix86_expand_fp_compare.  */\n+  switch (code)\n+    {\n+    case UNLE:\n+    case UNLT:\n+    case LTGT:\n+    case GT:\n+    case GE:\n+    case UNORDERED:\n+    case ORDERED:\n+    case UNEQ:\n+      return 4;\n+      break;\n+    case LT:\n+    case NE:\n+    case EQ:\n+    case UNGE:\n+      return 5;\n+      break;\n+    case LE:\n+    case UNGT:\n+      return 6;\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Return cost of comparison done using fcomi operation.\n+   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n+static int\n+ix86_fp_comparison_fcomi_cost (code)\n+     enum rtx_code code;\n+{\n+  enum rtx_code bypass_code, first_code, second_code;\n+  /* Return arbitarily high cost when instruction is not supported - this\n+     prevents gcc from using it.  */\n+  if (!TARGET_CMOVE)\n+    return 1024;\n+  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n+  return (bypass_code != NIL || second_code != NIL) + 2;\n+}\n+\n+/* Return cost of comparison done using sahf operation.\n+   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n+static int\n+ix86_fp_comparison_sahf_cost (code)\n+     enum rtx_code code;\n+{\n+  enum rtx_code bypass_code, first_code, second_code;\n+  /* Return arbitarily high cost when instruction is not preferred - this\n+     avoids gcc from using it.  */\n+  if (!TARGET_USE_SAHF && !optimize_size)\n+    return 1024;\n+  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n+  return (bypass_code != NIL || second_code != NIL) + 3;\n+}\n+\n+/* Compute cost of the comparison done using any method.\n+   See ix86_fp_comparison_arithmetics_cost for the metrics.  */\n+static int\n+ix86_fp_comparison_cost (code)\n+     enum rtx_code code;\n+{\n+  int fcomi_cost, sahf_cost, arithmetics_cost = 1024;\n+  int min;\n+\n+  fcomi_cost = ix86_fp_comparison_fcomi_cost (code);\n+  sahf_cost = ix86_fp_comparison_sahf_cost (code);\n+\n+  min = arithmetics_cost = ix86_fp_comparison_arithmetics_cost (code);\n+  if (min > sahf_cost)\n+    min = sahf_cost;\n+  if (min > fcomi_cost)\n+    min = fcomi_cost;\n+  return min;\n+}\n \n /* Generate insn patterns to do a floating point compare of OPERANDS.  */\n \n-rtx\n-ix86_expand_fp_compare (code, op0, op1, scratch)\n+static rtx\n+ix86_expand_fp_compare (code, op0, op1, scratch, second_test, bypass_test)\n      enum rtx_code code;\n      rtx op0, op1, scratch;\n+     rtx *second_test;\n+     rtx *bypass_test;\n {\n   enum machine_mode fpcmp_mode, intcmp_mode;\n   rtx tmp, tmp2;\n+  int cost = ix86_fp_comparison_cost (code);\n   enum rtx_code bypass_code, first_code, second_code;\n \n   fpcmp_mode = ix86_fp_compare_mode (code);\n   code = ix86_prepare_fp_compare_args (code, &op0, &op1);\n \n+  if (second_test)\n+    *second_test = NULL_RTX;\n+  if (bypass_test)\n+    *bypass_test = NULL_RTX;\n+\n   ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n \n-  /* %%% fcomi is probably always faster, even when dealing with memory,\n-     since compare-and-branch would be three insns instead of four.  */\n-  if (bypass_code == NIL && second_code == NIL \n-      && (TARGET_CMOVE || TARGET_USE_SAHF || optimize_size))\n+  /* Do fcomi/sahf based test when profitable.  */\n+  if ((bypass_code == NIL || bypass_test)\n+      && (second_code == NIL || second_test)\n+      && ix86_fp_comparison_arithmetics_cost (code) > cost)\n     {\n-      do_sahf:\n       if (TARGET_CMOVE)\n \t{\n \t  tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n@@ -4932,6 +5020,15 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n \n       /* The FP codes work out to act like unsigned.  */\n       intcmp_mode = fpcmp_mode;\n+      code = first_code;\n+      if (bypass_code != NIL)\n+\t*bypass_test = gen_rtx_fmt_ee (bypass_code, VOIDmode,\n+\t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n+\t\t\t\t       const0_rtx);\n+      if (second_code != NIL)\n+\t*second_test = gen_rtx_fmt_ee (second_code, VOIDmode,\n+\t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n+\t\t\t\t       const0_rtx);\n     }\n   else\n     {\n@@ -5072,7 +5169,8 @@ ix86_expand_compare (code)\n   op1 = ix86_compare_op1;\n \n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n-    ret = ix86_expand_fp_compare (code, op0, op1, gen_reg_rtx (HImode));\n+    ret = ix86_expand_fp_compare (code, op0, op1, gen_reg_rtx (HImode),\n+\t\t    \t\t  NULL, NULL);\n   else\n     ret = ix86_expand_int_compare (code, op0, op1);\n \n@@ -5249,6 +5347,59 @@ ix86_expand_branch (code, label)\n     }\n }\n \n+/* Split branch based on floating point condition.  */\n+void\n+ix86_split_fp_branch (condition, op1, op2, target1, target2, tmp)\n+     rtx condition, op1, op2, target1, target2, tmp;\n+{\n+  rtx second, bypass;\n+  rtx label = NULL_RTX;\n+  enum rtx_code code = GET_CODE (condition);\n+  enum rtx_code bypass_code, second_code, first;\n+\n+  if (target2 != pc_rtx)\n+    {\n+      rtx tmp = target2;\n+      code = reverse_condition_maybe_unordered (code);\n+      target2 = target1;\n+      target1 = tmp;\n+    }\n+\n+  condition = ix86_expand_fp_compare (code, op1, op2,\n+\t\t\t\t      tmp, &second, &bypass);\n+  if (bypass != NULL_RTX)\n+    {\n+      label = gen_label_rtx ();\n+      emit_jump_insn (gen_rtx_SET\n+\t\t      (VOIDmode, pc_rtx,\n+\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t     bypass,\n+\t\t\t\t\t     gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\tlabel),\n+\t\t\t\t\t     pc_rtx)));\n+    }\n+  /* AMD Athlon and probably other CPUs too have fast bypass path between the\n+     comparison and first branch.  The second branch takes longer to execute\n+     so place first branch the worse predicable one if possible.  */\n+  if (second != NULL_RTX\n+      && (GET_CODE (second) == UNORDERED || GET_CODE (second) == ORDERED))\n+    {\n+      rtx tmp = condition;\n+      condition = second;\n+      second = tmp;\n+    }\n+  emit_jump_insn (gen_rtx_SET\n+\t\t  (VOIDmode, pc_rtx,\n+\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t condition, target1, target2)));\n+  if (second != NULL_RTX)\n+    emit_jump_insn (gen_rtx_SET\n+\t\t    (VOIDmode, pc_rtx,\n+\t\t     gen_rtx_IF_THEN_ELSE (VOIDmode, second, target1, target2)));\n+  if (label != NULL_RTX)\n+    emit_label (label);\n+}\n+\n int\n ix86_expand_setcc (code, dest)\n      enum rtx_code code;\n@@ -5662,44 +5813,30 @@ ix86_expand_fp_movcc (operands)\n   enum rtx_code code;\n   enum machine_mode mode;\n   rtx tmp;\n+  rtx compare_op;\n \n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n \n   code = GET_CODE (operands[1]);\n-  switch (code)\n+  compare_op = ix86_expand_compare (code);\n+\n+  /* The floating point conditional move instructions don't directly\n+     support signed integer comparisons.  */\n+\n+  if (!fcmov_comparison_operator (compare_op, GET_MODE (XEXP (compare_op, 0))))\n     {\n-    case LT:\n-    case LE:\n-    case GE:\n-    case GT:\n-    case UNEQ:\n-    case UNGE:\n-    case UNGT:\n-    case UNLE:\n-    case UNLT:\n-    case LTGT:\n       tmp = gen_reg_rtx (QImode);\n       ix86_expand_setcc (code, tmp);\n       code = NE;\n       ix86_compare_op0 = tmp;\n       ix86_compare_op1 = const0_rtx;\n-      break;\n-\n-    default:\n-      break;\n+      compare_op = ix86_expand_compare (code);\n     }\n \n-  mode = SELECT_CC_MODE (code, ix86_compare_op0, ix86_compare_op1);\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, FLAGS_REG),\n-\t\t\t  gen_rtx_COMPARE (mode,\n-\t\t\t\t\t   ix86_compare_op0,\n-\t\t\t\t\t   ix86_compare_op1)));\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n-\t\t\t\tgen_rtx_fmt_ee (code, VOIDmode,\n-\t\t\t\t\t\tgen_rtx_REG (mode, FLAGS_REG),\n-\t\t\t\t\t\tconst0_rtx),\n+\t\t\t\tcompare_op,\n \t\t\t\toperands[2],\n \t\t\t\toperands[3])));\n "}, {"sha": "938de27a375bea859fcd96a00cacbc437c3000d8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -2532,6 +2532,18 @@ while (0)\n    possible, to allow for more combinations.  */\n \n #define SELECT_CC_MODE(OP,X,Y) ix86_cc_mode (OP, X, Y)\n+\n+/* Return non-zero if MODE implies a floating point inequality can be\n+   reversed.  */\n+\n+#define REVERSIBLE_CC_MODE(MODE) 1\n+\n+/* A C expression whose value is reversed condition code of the CODE for\n+   comparison done in CC_MODE mode.  */\n+#define REVERSE_CONDITION(CODE, MODE) \\\n+  ((MODE) != CCFPmode && (MODE) != CCFPUmode ? reverse_condition (CODE) \\\n+   : reverse_condition_maybe_unordered (CODE))\n+\n \f\n /* Control the assembler format that we output, to the extent\n    this does not vary between assemblers.  */\n@@ -2842,10 +2854,13 @@ do { long l;\t\t\t\t\t\t\\\n   {\"nonmemory_no_elim_operand\", {CONST_INT, REG, SUBREG}},\t\t\\\n   {\"q_regs_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"non_q_regs_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU}},\t\t\\\n+  {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU, UNORDERED, \\\n+\t\t\t\t ORDERED, LT, UNLT, GT, UNGT, LE, UNLE,\t\\\n+\t\t\t\t GE, UNGE, LTGT, UNEQ}},\t\t\\\n   {\"sse_comparison_operator\", {EQ, LT, LE, UNORDERED }},\t\t\\\n   {\"ix86_comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU,\t\\\n-\t\t\t       GTU, UNORDERED, ORDERED}},\t\t\\\n+\t\t\t       GTU, UNORDERED, ORDERED, UNLE, UNLT,\t\\\n+\t\t\t       UNGE, UNGT, LTGT, UNEQ }},\t\t\\\n   {\"cmp_fp_expander_operand\", {CONST_DOUBLE, SUBREG, REG, MEM}},\t\\\n   {\"ext_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"binary_fp_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\"}, {"sha": "12d7e39de2a04f78b6f9676216202d7fe6aedd9c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -9304,14 +9304,12 @@\n    (clobber (reg:CCFP 18))\n    (clobber (reg:CCFP 17))]\n   \"reload_completed\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 5)\n-\t  (match_dup 3)\n-\t  (match_dup 4)))]\n+  [(const_int 0)]\n   \"\n {\n-  operands[5] = ix86_expand_fp_compare (GET_CODE (operands[0]), operands[1],\n-\t\t\t\t\toperands[2], NULL_RTX);\n+  ix86_split_fp_branch (operands[0], operands[1], operands[2],\n+\t\t\toperands[3], operands[4], NULL_RTX);\n+  DONE;\n }\")\n \n (define_split\n@@ -9331,8 +9329,9 @@\n \t  (match_dup 4)))]\n   \"\n {\n-  operands[6] = ix86_expand_fp_compare (GET_CODE (operands[0]), operands[1],\n-\t\t\t\t\toperands[2], operands[5]);\n+  ix86_split_fp_branch (operands[0], operands[1], operands[2],\n+\t\t\toperands[3], operands[4], operands[5]);\n+  DONE;\n }\")\n \f\n ;; Unconditional and other jump instructions"}, {"sha": "0cba90968950db9fff0036abb8127b86f87b2e5d", "filename": "gcc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7adcb3f02fed791a723af46c6bdb16b81019bb/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=9e7adcb3f02fed791a723af46c6bdb16b81019bb", "patch": "@@ -4857,6 +4857,21 @@ inequality comparisons are always given @code{CCFPEmode}:\n #define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)\n @end smallexample\n \n+@findex REVERSE_CONDITION (@var{code}, @var{mode})\n+A C expression whose value is reversed condition code of the @var{code} for\n+comparison done in CC_MODE @var{mode}.  The macro is used only in case\n+@code{REVERSIBLE_CC_MODE (@var{mode})} is nonzero.  Define this macro in case\n+machine has some non-standard way how to reverse certain conditionals.  For\n+instance in case all floating point conditions are non-trapping, compiler may\n+freely convert unordered compares to ordered one.  Then definition may look\n+like:\n+\n+@smallexample\n+#define REVERSE_CONDITION(CODE, MODE) \\\n+   ((MODE) != CCFPmode ? reverse_condtion (CODE) \\\n+    : reverse_condition_maybe_unordered (CODE))\n+@end smallexample\n+\n @end table\n \n @node Costs"}]}